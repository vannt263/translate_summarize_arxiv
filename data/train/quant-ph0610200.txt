{
  "article_text": [
    "classical list decoding , which was rooted in the late 1950s by elias @xcite and wozencraft @xcite , has drawn significant attention since sudan s @xcite discovery of an efficient list decoding algorithm for reed - solomon codes beyond its `` traditional '' error - correction radius .",
    "list decoding has since then found useful applications to cryptography as well as complexity theory ( see , , a survey article @xcite ) .",
    "quantum list decoding dealing with classical block codes first arose in connection to quantum hardcore functions in a seminal paper by kawachi and yamakami @xcite ( following an early result of adcock and cleve @xcite on biased oracles ) in the so - called _ implicit - input explicit - output model _ , in which we wish to output a list of messages with oracle access to a quantum encoding procedure which produces a quantum superposition of corrupted codewords .",
    "this model differs from the conventional error - correction model between a sender and a receiver through a noisy channel .",
    "in contrast , we are given a ( possibly ) faulty quantum algorithm ( known as a _ quantum - computationally corrupted codeword _ or _",
    "quantumly corrupted codeword _ ) which encodes a classical message to a certain quantum state representing a quantum corruption of the correct codeword .",
    "it is in general hard to recover the original message from such a quantumly corrupted codeword ; however , we may be able to produce a reasonably small list that contains all messages whose codewords are close proximity to the given quantumly corrupted codeword .",
    "this closeness is scaled by the notion of _ presence _ , which expresses the average probability of obtaining each block of the target codeword from the quantumly corrupted codeword .",
    "( see @xcite for an intuition behind this notion . )",
    "this is the primary purpose of quantum list decoding .",
    "a natural question is : what types of classical block codes are efficiently quantum list decodable ?    there are known families of block codes that are efficiently quantum list decodable with arbitrary presence .",
    "the first known example is hadamard codes . in classical list decoding ,",
    "goldreich and levin @xcite showed the classical list decodability of the binary hadamard codes and subsequently goldreich , rubinfeld , and sudan @xcite gave a general list decoding algorithm for the @xmath0-ary hadamard codes .",
    "concerning quantum list decoding , adcock and cleve @xcite essentially proved that the binary hadamard codes are quantum list decodable in polynomial time .",
    "for the @xmath0-ary hadamard codes , a fast quantum list decoding algorithm was recently given by kawachi and yamakami @xcite .",
    "they also presented two additional quantum list decodable codes : _ shifted legendre symbol codes _ and _ pairwise equality codes_. all these codes , nonetheless , have _ exponentially - small rate _ , where the ( message ) rate of a code is a ratio of message length and codeword s block length .",
    "this paper is motivated by the question of whether there exists a family of efficiently quantum list decodable codes of polynomially - small rate and constant codeword alphabet size , because such a code family finds useful applications to quantum complexity theory ( an example will be seen in section [ sec : search - problem ] ) .",
    "natural candidates are well - studied reed - solomon codes .",
    "they have relatively large rate ; however , they usually have large alphabet size .",
    "a standard way to build a code of large rate but small alphabet size is to concatenate two codes of good properties .",
    "we claim that concatenating generalized reed - solomon codes with hadamard codes gives the desired codes , assuming that the generalized reed - solomon codes are efficiently quantum list decodable .",
    "this claim is proven by employing in section [ sec : codes ] a technique of constructing a `` quantum reduction '' between two quantumly corrupted codewords . note that this technique requires no _ soft information _ , which is a key ingredient in the classical case of @xcite .",
    "are the generalized reed - solomon codes _ efficiently _ quantum list decodable ?",
    "a direct and simple approach toward their quantum list decoding is an application of the polynomial reconstruction algorithm of guruswami and sudan @xcite .",
    "when codeword presence in a quantumly corrupted codeword is relatively high , we can show in section [ sec : reed - solomon ] how to construct a quantum list decoding algorithm for the generalized reed - solomon codes .",
    "as the presence becomes lower , however , it seems harder to solve efficiently the quantum list decoding problem for the generalized reed - solomon codes , because its efficient list decoding leads to the unexpected consequence that every @xmath1-problem can be efficiently solved on a quantum computer with high success probability .",
    "there is also a direct connection between quantum list decodability of the generalized reed - solomon codes and quantum solvability of two classical problems : the _ noisy polynomial interpolation problem _ ( npip ) @xcite and the _ bounded distance vector problem _ ( bdvp ) .    to a certain type of application , our quantum list decoding algorithm for the aforementioned concatenated code",
    "is still applicable .",
    "our example is the _ qcma search problem _ , in which we want to find a classical witness of polynomial size that forces a given polynomial - time quantum algorithm to accept with high probability .",
    "we show in section [ sec : search - problem ] that solving this search problem on average implies solving it in worst case .",
    "finally , we make a brief discussion on the notion of _ local quantum list decoding _ based on an implicit - input implicit - output model where an outcome of a list decoder is a list of _ descriptions _ of quantum circuit list - decoders .",
    "similar to the classical case of @xcite , we can apply our quantum list decoder for the generalized reed - solomon codes to do local quantum list decoding for reed - mller codes from quantumly corrupted codewords . as an immediate consequence",
    ", we can prove the so - called _ hardness amplification _ of quantum circuits , following the argument of @xcite .",
    "this section explains basic notions and notation concerning quantum list decoding . throughout this paper ,",
    "let @xmath2 denote the set of all nonnegative integers and set @xmath3 .",
    "for any positive integers @xmath4 with @xmath5 , let @xmath6_{{\\mathbb{z}}}$ ] denote the set @xmath7 and let @xmath8 $ ] be short for @xmath9_{{\\mathbb{z}}}$ ] if @xmath10 .",
    "we briefly explain classical block ( error - correcting ) codes , which are objects of our interest . roughly speaking , a _ code _ is a set of strings of the same length over a finite alphabet @xmath11 and each string of a code is indexed by a message and is called a _",
    "codeword_. in this paper , we are mostly focused on a _ family of codes _ , each of which corresponds to a different message length @xmath12 in @xmath2 .",
    "such a code family is in general specified by a series @xmath13 of _ message space _ @xmath14 , _ index set _",
    "@xmath15 , and _ code alphabet _",
    "@xmath16 for each _ message length _ @xmath12 ( which serves as a `` basis parameter '' in this paper ) .    as standard in complexity theory , a code @xmath17 is viewed as a function that , for each message length @xmath12 , maps @xmath18 to @xmath16 .",
    "let @xmath19 and @xmath20 .",
    "it is convenient to assume that @xmath21 so that @xmath12 actually represents the _ length _ of messages in @xmath14 over the message alphabet @xmath22 ; in this case , @xmath23 for each @xmath24 . by abbreviating @xmath25 as @xmath26 ,",
    "we treat @xmath27 as a function mapping @xmath15 to @xmath16 and is called a _ codeword _ , where the _ block length _",
    "@xmath28 of such a codeword is @xmath29 . for simplicity",
    ", we often assume that @xmath30 so that each element of @xmath15 can be expressed in @xmath31 bits .",
    "we freely identify @xmath32 with the vector @xmath33 in the _ ambient space _ @xmath34 of dimension @xmath28 .",
    "we mainly work on a finite field and we often regard @xmath16 as the finite field @xmath35 ( @xmath36 ) of order @xmath37 .    the _ ( message ) rate _ of @xmath17 is defined to be the ratio @xmath38 .",
    "the _ ( hamming ) distance _ @xmath39 between two codewords @xmath32 and @xmath40 is the number of non - zero components in the vector @xmath41 .",
    "the _ minimal distance _",
    "@xmath42 of a code @xmath17 is the smallest distance between any pair of distinct codewords in @xmath17 .",
    "in contrast , @xmath43 denotes the _ relative ( hamming ) distance _ @xmath44 .",
    "the above - described code is simply called a @xmath45-code is used instead . ] ( or @xmath46-code if the minimal distance @xmath47 of the code of message length @xmath12 is emphasized ) .",
    "we may drop a length parameter @xmath12 from both subscript and argument place whenever we discuss a set of codewords with a `` fixed '' @xmath12 .",
    "hadamard codes @xmath48 .",
    "let @xmath12 be any message length , used as a parameter , and let @xmath0 be any prime number .",
    "a @xmath0-ary hadamard code family @xmath49 consists of @xmath50-codes obtained as follows . for each message @xmath51 in @xmath52 ,",
    "let @xmath53 , where @xmath54 .",
    "( normalized ) generalized reed - solomon codes @xmath55 .",
    "let @xmath0 be any prime and let @xmath56 be any positive integers with @xmath57 .",
    "a ( normalized ) generalized reed - solomon code family @xmath58 consists of all @xmath59-codes obtained as follows .",
    "let @xmath60 be any message and let @xmath61 be a set of @xmath62 distinct elements ( called _ code locators _ ) in @xmath63 .",
    "let @xmath64 be the polynomial of degree at most @xmath65 for each @xmath66 .",
    "we are mostly concerned with a quantum corruption that occurs during a quantum procedure of encoding messages into codewords .",
    "the process of such a quantum corruption can be described as a certain type of unitary map .",
    "formally , a _",
    "quantum - computationally corrupted codeword _ ( or _ quantumly corrupted codeword _ ) is a unitary operator @xmath67 , with two fixed function parameters @xmath68 and @xmath69 mapping @xmath2 to @xmath2 , that satisfies the following condition : for any three strings @xmath70 , @xmath71 , and @xmath72 , there exists a unit vector @xmath73 of length @xmath69 such that @xmath74 where the notation @xmath75 is shorthand for @xmath76 and @xmath77 is the bitwise xor .",
    "the _ presence _ of codeword @xmath32 in @xmath67 , denoted @xmath78 , is the average probability of obtaining the correct values @xmath79 over all indices @xmath80 ; namely , @xmath81 .",
    "see @xcite for an intuition behind these notions .",
    "we further expand the notions of presence and distance .",
    "let @xmath12 be any message length .",
    "define @xmath82 to be the set of all vectors @xmath83^{q(n)m(n)}$ ] ( which is viewed as a `` measured '' quantumly corrupted codeword ) such that @xmath84_{{\\mathbb{z}}}}w_{r , z}=1 $ ] for each index @xmath85_{{\\mathbb{z}}}$ ] .",
    "notice that @xmath86 for any @xmath87 .",
    "next , consider the set @xmath88 of all codewords @xmath89_{{\\mathbb{z}}})^{m(n)}$ ] .",
    "we embed this codeword @xmath90 into @xmath82 in the following way .",
    "define @xmath91 , where @xmath92 if @xmath93 and @xmath94 otherwise .",
    "moreover , for any code ( , a subset of @xmath88 ) @xmath95 , let @xmath96 .",
    "finally , we obtain @xmath97 .",
    "first , we expand the notion of presence . for",
    "any @xmath98 and any vector @xmath87 , define @xmath99 , where @xmath100 denotes the standard inner product .",
    "second , we expand the notion of the ( hamming ) distance . for any pair @xmath101 ,",
    "define @xmath102 .",
    "this new definition clearly expands the standard notion of the distance @xmath103 because , for any @xmath104 , we have @xmath105 notice that , for any @xmath98 and any vector @xmath87 ,",
    "@xmath106      a relatively good upper bound on the value of presence is shown in @xcite by following a geometric method of guruswami and sudan @xcite , who gave a @xmath0-ary extension of johnson bound .",
    "let @xmath17 be any @xmath107-code family with message space @xmath14 and define @xmath108 as @xmath109 , where `` @xmath110 '' is taken over all quantumly corrupted word @xmath67 for @xmath17 .",
    "@xcite[johnson - bound ] let @xmath12 be any message length .",
    "let @xmath111 satisfy the inequality @xmath112 , where @xmath113 equals @xmath114 .",
    "assume that @xmath17 is an @xmath115-code family .",
    "the value @xmath108 is upper - bounded by @xmath116 , where @xmath117 . in case where @xmath118 , it holds that @xmath119 .    to derive an asymptotic bound from this lemma",
    ", we introduce @xmath120 , which indicates the minimal possible presence for a family of quantum list decodable codes of minimal relative distance @xmath121 having only a polynomial - size message list .",
    "let @xmath122 be any @xmath107-code family .",
    "for each pair @xmath87 and @xmath123 $ ] , set @xmath124 . for any @xmath24",
    ", let @xmath125 denote @xmath126\\}$ ] and define @xmath127 .",
    "moreover , for any function set @xmath128 , we define @xmath129 . for any function @xmath130 and any value @xmath121 , let @xmath131 , where @xmath132 . for each constant @xmath133 ,",
    "let @xmath134 , where @xmath135 .",
    "finally , @xmath120 is set to be @xmath136",
    ".    from lemma [ johnson - bound ] follows the next proposition .",
    "let @xmath137 $ ] be any minimal relative distance .",
    "it holds that @xmath138 and thus , @xmath139 .",
    "consider the case where the upper bound given in lemma [ johnson - bound ] is at most @xmath140 .",
    "for readability , we omit the parameter `` @xmath12 '' in the following calculation .",
    "we then obtain the inequality @xmath141 which is equivalent to @xmath142 the term @xmath143 is thus lower - bounded by @xmath144    assuming that @xmath145 , the proposition follows immediately from the relation @xmath146 .",
    "it is still open whether the equality @xmath147 holds .",
    "list decoding has been modeled in several different ways in the past literature .",
    "this paper chiefly uses the model that takes quantumly corrupted codewords implicitly as an oracle and outputs hidden messages explicitly . upon this _ implicit - input explicit - output model _ ,",
    "the _ quantum list decoding problem _ ( qldp ) for a code @xmath17 is described in the following fashion .",
    "first , let @xmath17 be any @xmath107-code family with message space @xmath14 and let @xmath148 be any set of quantumly corrupted codewords for @xmath17 . take a _",
    "bias parameter _ @xmath149 .",
    "@xmath150-quantum list decoding problem ( @xmath150-qldp ) for code @xmath17 w.r.t .",
    "@xmath148    * input : a message length @xmath12 and a value @xmath151 . *",
    "implicit input : an oracle @xmath152 representing a quantumly corrupted codeword for @xmath17 . *",
    "output : a list of messages including all messages @xmath153 that satisfy the inequality @xmath154 . for convenience",
    ", we refer to such a list as a _ valid list _ for the @xmath150-qldp .",
    "our goal is to solve this @xmath150-qldp using quantum computation with oracle access to a quantumly corrupted codeword in @xmath148 with success probability at least @xmath155 , which is given as a _ confidence parameter_. now , let us introduce the notion of quantum list decoding algorithm that works with bias @xmath150 and confidence @xmath156 .",
    "let @xmath17 be any code family , let @xmath149 be any bias parameter , and let @xmath155 be any confidence parameter .",
    "a _ quantum list decoding algorithm _ ( or a quantum list decoder ) for @xmath17 with bias @xmath150 and confidence @xmath156 is a quantum algorithm @xmath157 that solves the @xmath150-qldp for @xmath17 with success probability at least @xmath155 .",
    "if @xmath157 also runs in time polynomial in @xmath158 , it is called a _",
    "polynomial - time quantum list decoding algorithm _ for @xmath17 .",
    "the _ list size _ of a quantum list decoding algorithm refers to the maximal size of a valid list produced by the algorithm .",
    "remark : in certain applications , list size plays a crucial role . for instance , if a quantum list decoder produces a valid list @xmath159 with probability at least @xmath155 , it is possible to specify a hidden message @xmath160 _ uniquely _ with the same success probability with help of `` advice '' of @xmath161 size over message alphabet @xmath11 .    in the rest of this subsection , we discuss a simple connection between one - way functions and the qldps . to begin with ,",
    "we introduce the notion of a one - way function of the strong form , which we preferably call _ super one - way_.    [ super - oneway ] a function @xmath162 is called _ quantum super one - way _ if ( i ) there exists a polynomial - time quantum algorithm @xmath157 such that @xmath163 for a certain quantum state @xmath164 and ( ii ) for any positive polynomial @xmath165 and any polynomial - time quantum algorithm @xmath166 , the probability that @xmath167 outputs @xmath160 is at most @xmath168 .    remark : the `` standard '' one - wayness requires that @xmath169 outputs @xmath160 with negligible probability whereby the information @xmath170 is _ hidden _ from the adversary @xmath166 who tries to invert @xmath162 .",
    "our new notion indicates that @xmath166 hardly outputs @xmath160 even though @xmath170 is given besides @xmath171 as supplemental information .",
    "a typical example of a quantum super one - way function is a _ quantum one - way permutation _ because , for a permutation , we can replace @xmath170 in definition [ super - oneway ] with @xmath172 by uncomputing a deterministic procedure that computes @xmath171 from @xmath160 .",
    "no polynomial - time quantum list decodable code with polynomially - small confidence is quantum super one - way .",
    "let @xmath162 be a quantum super one - way function with its _ length function _",
    "@xmath173 ( , @xmath174 ) .",
    "consider an @xmath175-code @xmath17 and let @xmath79 denote the @xmath176th bit @xmath177 of @xmath171 .",
    "take a polynomial - time quantum algorithm @xmath157 computing @xmath17 and assume that @xmath178 for a certain quantum state @xmath164 .",
    "fix @xmath160 arbitrarily and define @xmath179 for each pair @xmath180 of strings . toward a contradiction ,",
    "assume that @xmath17 has a polynomial - time quantum list decoder @xmath166 with polynomially - small confidence .",
    "without loss of generality , we can assume that @xmath181\\geq 1/p(n)$ ] for a certain fixed positive polynomial @xmath165 .",
    "convert this @xmath166 to an algorithm that inverts @xmath162 as follows . on input @xmath182 , where @xmath183 , run @xmath166 .",
    "whenever @xmath166 makes an oracle call with a query @xmath184 , generate its answer @xmath185 from the input information .",
    "finally , output an outcome of @xmath166 .",
    "this implies that @xmath162 is not quantum super one - way , a contradiction .",
    "a family of polynomial - time classical list decodable codes of polynomially - small rate and binary codeword alphabet finds numerous applications in the fields of cryptography and complexity theory ( see , , @xcite ) .",
    "since all known efficiently quantum list decodable code families have exponentially - small rate , it is natural to ask whether there is any quantum list decodable code of polynomially - small rate and small alphabet size for any given bias parameter .",
    "a standard way of building a family of classical block codes of polynomially - small rate and small codeword alphabet size is to concatenate two codes of good properties : for instance , a generalized reed - solomon code and a hadamard code .",
    "we can build a similar code under the assumption that the generalized reed - solomon codes are efficiently quantum list decodable for a certain bias value .",
    "we first explain forney s @xcite notion of _ concatenated codes_. let us consider two codes @xmath186 and @xmath187 such that @xmath186 is an @xmath188-code and @xmath187 is an @xmath189-code .",
    "let @xmath190 be any message of length @xmath191 , where each @xmath192 is taken from @xmath193 over a @xmath0-letter alphabet @xmath11 .",
    "since @xmath192 can be expressed as a @xmath194-letter string , @xmath160 can be viewed as a string of total length @xmath195 over a @xmath0-letter alphabet .",
    "the code @xmath196 , given by the inner code @xmath187 concatenated with the outer code @xmath186 , is defined as @xmath197 .",
    "this concatenated code @xmath17 is an @xmath198-code , where @xmath199 satisfies @xmath200 , where @xmath201 is called the _ design distance_.    for our purpose , we choose the concatenated code @xmath202 $ ] explained in @xcite .",
    "concatenated code @xmath202 $ ] .",
    "this is the concatenated code obtained by a certain generalized reed - solomon code as an outer code with a hadamard code as an inner code .",
    "following @xcite , we choose three parameters @xmath203 with @xmath204 and @xmath205 $ ] such that @xmath10 , @xmath206 , @xmath207 , and @xmath208 for a certain number @xmath209 . here",
    ", we use the @xmath210 generalized reed - solomon code @xmath211 as an outer code and the @xmath212 hadamard code @xmath213 as an inner code .",
    "the desired code @xmath202=\\{c^{grs\\mbox{-}h}[n , q,\\theta]_x\\}_{x}$ ] is the collection of all concatenated codes defined by @xmath202_x(r , r ' ) =   \\mathrm{had}^{(q , m ) } \\odot   \\mathrm{grs}^{(q^m , q^m\\theta , q^m)}$ ] .",
    "this concatenated code is a @xmath214-code , where @xmath215 ( design distance ) .",
    "we have the bound @xmath216 , which further implies that @xmath217 .",
    "therefore , as far as @xmath218 and @xmath219 for a certain polynomial @xmath165 , @xmath220 is upper - bounded by @xmath221 .",
    "now , we claim that @xmath202 $ ] is quantumly list decodable for an appropriate choice of parameters @xmath222 , assuming that the generalized reed - solomon codes are quantumly list decodable for a specific bias parameter .",
    "[ concatenated_code ] let @xmath223 satisfy the following conditions : @xmath224 , @xmath225 $ ] , @xmath226 , @xmath208 , @xmath227 , and @xmath228 .",
    "if the @xmath210 generalized reed - solomon code has a quantum list decoder with bias @xmath229 and confidence @xmath156 running in time polynomial in @xmath230 , then @xmath202 $ ] has a quantum list decoding algorithm with bias @xmath150 and confidence @xmath156 running in time polynomial in @xmath230 .    in this lemma",
    ", the value @xmath156 of the confidence of the generalized reed - solomon code is transferred to the concatenated code @xmath202 $ ] .",
    "the proof of the lemma is given in the subsequent subsection .",
    "for the proof of lemma [ concatenated_code ] , we wish to construct a `` quantum reduction '' between two quantumly corrupted codewords .",
    "it is useful to describe such a reduction , say , from @xmath67 to @xmath231 , as a quantum algorithm that , on each input @xmath184 , computes the outcome @xmath232 by making oracle calls to @xmath67 .",
    "this can be seen as a strong form of well - known _ turing reduction _ between two languages .    as a key lemma",
    ", we show a general result concerning the @xmath0-ary hadamard code used as an inner code for an arbitrary outer code @xmath17 .",
    "now , let @xmath17 be any @xmath233-code , which is treated as a function @xmath234 mapping from @xmath235 to @xmath236 .",
    "the concatenated code @xmath237 therefore satisfies that @xmath238 for @xmath239 and @xmath240 .",
    "our goal is to construct a quantum reduction between quantumly corrupted codewords @xmath241 and @xmath242 associated with @xmath17 and @xmath243 , respectively . for any unitary transform @xmath244 , we conveniently say that a quantum algorithm @xmath157 _ realizes _",
    "@xmath244 if , for any basis state @xmath245 , @xmath157 on input @xmath245 produces the state @xmath246 exactly .",
    "we have the following key lemma on the code @xmath243 .",
    "[ from - d - to - c ] let @xmath17 and @xmath243 be the codes given as above and let @xmath242 be any quantumly corrupted codeword for @xmath243 .",
    "there exist a polynomial - time quantum algorithm @xmath166 and a quantumly corrupted codeword @xmath241 for @xmath17 such that    1 .",
    "@xmath247 @xmath248 ; and 2 .",
    "@xmath166 realizes @xmath241 with access to @xmath242 as an oracle .    from the above lemma ,",
    "lemma [ concatenated_code ] follows easily .",
    "we quickly sketch its proof .",
    "lemma [ concatenated_code ]",
    "let @xmath223 be the parameters given in the lemma .",
    "for simplicity , write @xmath249 .",
    "assume that the @xmath250 generalized reed - solomon code has a polynomial - time quantum list decoder @xmath157 with bias @xmath229 and confidence @xmath156 .",
    "let @xmath67 be any quantumly corrupted codeword for @xmath202 $ ] .",
    "we want to find all messages @xmath160 that satisfy the inequality @xmath251_x)\\geq 1/q+\\varepsilon$ ] . by lemma [ from - d - to - c ] , we can reduce @xmath67 to another quantumly corrupted codeword @xmath241 for the outer code @xmath252 with the following presence condition : @xmath253 where the last inequality follows from the bound @xmath254 . by running a quantum list decoder for the @xmath252 , we obtain a list that contains all messages @xmath160 satisfying @xmath255 with the desired probability .",
    "the proof of our key lemma ( lemma [ from - d - to - c ] ) is much more involved .",
    "we note that a simple approach using the following relation @xmath256 where @xmath257 , does not give the desired presence value for @xmath32 .",
    "lemma [ from - d - to - c ] let @xmath17 be any @xmath233-code and let @xmath243 be the concatenated code @xmath258 .",
    "assume that , for any @xmath259 , @xmath260 .",
    "the desired quantumly corrupted codeword @xmath241 can be realized by the following quantum algorithm using @xmath242 as an oracle .",
    "quantum algorithm @xmath166 :    \\(1 ) starting with @xmath261 ( a general case is similar ) , move the last register to the leftmost location and then generate the state @xmath262}{| k \\rangle}{| r \\rangle}{| 0 \\rangle}{| 0^d \\rangle}$ ] .",
    "\\(2 ) fix @xmath62 for the meantime and generate the state @xmath263 .",
    "\\(3 ) apply @xmath242 to the first three registers .",
    "this step transforms the previous state into @xmath264    \\(4 ) encode the content of the fourth register into the `` phase '' together with the information on @xmath62 , , @xmath265 this process is known as the _ phase encoding_.    \\(5 ) apply the inverse of @xmath242 .",
    "the resulted state @xmath266 can be expressed as @xmath267 with certain amplitudes @xmath268 and a certain vector @xmath269 whose last two registers contain no @xmath270 .",
    "the amplitude @xmath268 is calculated as @xmath271 note that @xmath272 because @xmath273 therefore , our state @xmath266 is written in the form @xmath274 what is the norm of @xmath269 ?",
    "since @xmath275 , the squared norm of @xmath269 satisfies @xmath276    \\(6 ) if the last two registers contain @xmath270 , multiply the content @xmath277 of the third register by @xmath62 to obtain @xmath278 ; otherwise , do nothing . note that @xmath278 is in @xmath279 since so is @xmath277 .",
    "\\(7 ) similarly , exactly when @xmath270 is in the last two registers , apply the inverse fourier transform @xmath280 over @xmath281 to the second register .",
    "this produces the state @xmath282 where @xmath283 is the complex number defined by @xmath284    \\(8 ) prepare two new registers @xmath285 for @xmath269 and then generate @xmath286 so that we have the state @xmath287 .",
    "\\(9 ) finally , output the state @xmath288}\\sum_{w\\in({\\mathbb{f}}_q)^m } \\gamma_{k , r , w }   { | r \\rangle}{| w \\rangle}{| k \\rangle}{| 0 \\rangle}{| 0^d \\rangle } \\\\ & & + \\frac{1}{\\sqrt{q^m(q-1)}}\\sum_{k\\in[q-1]}\\sum_{w\\in({\\mathbb{f}}_q)^m } { | r \\rangle}{| w \\rangle}{| k \\rangle}{| \\delta_{k , r } \\rangle}.\\end{aligned}\\ ] ] this ends the description of @xmath166 .    to complete the proof",
    ", we need to evaluate the value of the presence of @xmath32 in @xmath241 , , @xmath289 } \\left(|\\gamma_{k , r , c_x(r)}|^2 + q^{-m}\\|{| \\delta_{k , r } \\rangle}\\|^2\\right)$ ] .",
    "note that @xmath290 for each pair @xmath291 .",
    "recall that @xmath292 .",
    "it thus follows that , for each @xmath293 $ ] , @xmath294 where @xmath295 .",
    "an argument similar to @xcite shows that , for a certain @xmath293 $ ] , @xmath296 .",
    "hence , @xmath297 therefore , @xmath298 is lower - bounded by @xmath299 this completes the proof of lemma [ from - d - to - c ] .",
    "lemma [ from - d - to - c ] gives a fast quantum reduction from @xmath242 to @xmath241 .",
    "by contrast , there also exists a quantum reduction from @xmath241 to @xmath242 with the following conditions .",
    "[ from - c - to - d ] let @xmath241 be any quantumly corrupted codeword for @xmath17 .",
    "there exist a polynomial - time quantum algorithm @xmath157 and a quantumly corrupted codeword @xmath242 for @xmath243 such that    1 .",
    "@xmath300 ; and 2 .",
    "@xmath157 realizes @xmath242 with oracle access to @xmath241 .",
    "given @xmath241 , the following quantum algorithm @xmath157 realizes the desired @xmath242 .",
    "quantum algorithm @xmath157 :    \\(1 ) start with the state @xmath301 .",
    "\\(2 ) change the register order to obtain the state @xmath302 .",
    "\\(3 ) invoke @xmath241 .",
    "assume that we obtain the state @xmath303",
    "\\(4 ) compute deterministically @xmath304 from @xmath305 to obtain @xmath306 where @xmath307 is the garbage produced while simulating the deterministic computation in a reversible fashion .",
    "\\(5 ) change the register order so that we obtain @xmath308    it is not difficult to evaluate the value @xmath309 using @xmath298 .",
    "we turn our interest to the question of whether the generalized reed - solomon codes are efficiently quantum list decodable against a given bias parameter .",
    "we point out that a classical approach works well when the bias is relatively large ; however , for smaller bias , there seems little hope in search of an efficient quantum list decoder .",
    "we also show that the generalized reed - solomon codes have natural connections to the _ noisy polynomial interpolation problem _ ( npip ) of naor and pinkas @xcite and a lattice problem , which we call the _ bounded distance vector problem _ ( bdvp ) .",
    "a direct and simple approach toward the quantum list decoding of the @xmath310 generalized reed - solomon codes is the use of the guruswami - sudan polynomial reconstruction algorithm @xcite .",
    "this approach works well after performing measurement on all oracle answers when bias is relatively large .",
    "[ reed - solomon ] let @xmath204 and @xmath311 satisfy the conditions : @xmath312 , @xmath313 , and @xmath314 there exists a quantum list decoding algorithm for the @xmath310 generalized reed - solomon codes with bias @xmath150 and confidence @xmath156 running in time polynomial in @xmath315 .",
    "choose numbers @xmath204 and @xmath311 to satisfy the premise of the lemma .",
    "let @xmath67 be any quantumly corrupted codeword for the @xmath316 .",
    "now , we want to find all messages @xmath160 satisfying the inequality @xmath317 .",
    "fix such a message @xmath160 arbitrarily in the following argument .",
    "let @xmath318 .",
    "it easily follows that @xmath319 , where @xmath320 , because we have @xmath321    initially , set @xmath176 to be @xmath94 . using @xmath67 as an oracle , we iterate the following procedure by incrementing @xmath176 by one .",
    "first , we make a query on @xmath176 to the oracle @xmath322 times , where @xmath322 is the minimal integer satisfying @xmath323 notice that @xmath324 since @xmath325 . after receiving each answer from @xmath67 ,",
    "we perform a measurement on the computational basis over @xmath63 and store a pair @xmath326 if @xmath327 is a result of this measurement .",
    "since there are at most @xmath328 values @xmath327 with @xmath329 , the probability @xmath330 of obtaining all such @xmath327 s is bounded by @xmath331 where the last inequality follows from the choice of @xmath322 . after the @xmath0th iteration , we can store at most @xmath332 points .",
    "let @xmath333 be the set of all stored points .",
    "the probability that @xmath333 contains all the points @xmath326 that satisfy @xmath329 is at least @xmath334 .",
    "lastly , we should find all univariate polynomials @xmath165 of degree at most @xmath65 that lie on at least @xmath335 points in @xmath333 .",
    "for this purpose , we run the well - known guruswami - sudan polynomial reconstruction algorithm .",
    "guruswami and sudan @xcite gave a deterministic algorithm @xmath157 that solves in time polynomial in @xmath336 the following _ polynomial reconstruction problem _",
    ": on input of integers @xmath337 and @xmath338 points @xmath339}\\subseteq { \\mathbb{f}}_q\\times{\\mathbb{f}}_q$ ] , find all univariate polynomials @xmath165 of degree at most @xmath340 which lie on at least @xmath341 points , provided that @xmath342 .",
    "the choice of our parameters implies that @xmath343 therefore , the guruswami - sudan algorithm correctly produces a list that includes all the polynomials @xmath165 of degree at most @xmath65 that satisfy @xmath344 for at least @xmath345 indices @xmath176 .",
    "hence , the list also includes all messages @xmath160 for which @xmath317 .    combining the above lemma with lemma [ concatenated_code ]",
    ", we obtain the proposition below .",
    "[ high - rate ] let @xmath346 satisfy the conditions : @xmath347 , @xmath348 $ ] , @xmath206 , @xmath208 , @xmath227 , @xmath349 , and @xmath350 , where @xmath351 . the concatenated code @xmath202 $ ] has a quantum list decoder with bias @xmath150 and confidence @xmath156 running in time polynomial in @xmath352 .    to use the guruswami - sudan algorithm in the proof of lemma [ reed - solomon",
    "] , we make the bias @xmath150 relatively large .",
    "is there any other way to list decode the generalized reed - solomon codes from a quantumly corrupted codeword even for relatively small bias ?",
    "we can show in the next proposition that an _ efficient _ quantum list decoder for the generalized reed - solomon codes with arbitrary bias and high confidence can be used to solve all @xmath1-problems _ efficiently _ on a quantum computer with high success probability .",
    "let @xmath353 be any function from @xmath2 to @xmath2 with @xmath354 for all @xmath24 .",
    "if there exists a quantum list decoder for the generalized reed - solomon codes with arbitrary bias and confidence @xmath355 running in @xmath353 time , then every np - problem can be solved by a certain quantum algorithm with success probability at least @xmath355 in @xmath356 time .",
    "we want to give a reduction from a certain @xmath1-complete problem to the qldp with a specific quantumly corrupted codeword . to make our proof simple , we use the following restricted form of the interpolation problem discussed in @xcite .    constrained interpolation problem ( cip )    * input : three numbers @xmath357 , a prime @xmath0 , a set @xmath358 of @xmath338 points in @xmath359 , given in binary .",
    "* condition : @xmath360 and @xmath361 for any @xmath362_{{\\mathbb{z}}}$ ] , where @xmath363 . *",
    "question : is there any univariate polynomial @xmath165 of degree at most @xmath199 such that @xmath364 and @xmath365 for at least @xmath366 different @xmath367 s ?",
    "this problem is clearly in @xmath1 and is also proven to be np - hard @xcite .",
    "now , let @xmath357 , let @xmath0 be a prime , and let @xmath358 be any set of @xmath338 points in @xmath359 .",
    "define @xmath243 as the set @xmath368 of code locators and write @xmath369 .",
    "note that @xmath370 by the given condition .",
    "using @xmath371 , we define a quantumly corrupted codeword @xmath67 of the form @xmath372 for every @xmath373 .",
    "let @xmath374 be any point in @xmath359 .",
    "if @xmath375 , let @xmath376 ; otherwise , let @xmath377 . finally , let @xmath378 .",
    "note that @xmath379 since @xmath380 .",
    "now , we claim the following : a polynomial @xmath165 of degree @xmath199 passes on at least @xmath366 points in @xmath371 as well as the point @xmath381 if and only if the presence of @xmath165 in @xmath67 satisfies @xmath382 therefore , solving the cip can be reduced to solving the @xmath150-qldp with @xmath67 .",
    "note that it takes only quantum polynomial time to _ realize _ @xmath67 from the set @xmath371 ( which is given as an input ) . applying a @xmath353-time quantum list decoder for the @xmath150-qldp with confidence",
    "@xmath355 , we obtain a valid list of polynomials @xmath165 .",
    "the list size is at most @xmath353 .",
    "since the list may contain illegitimate polynomials , we need to check if each @xmath165 passes on at least @xmath383 different points in @xmath371 including @xmath381 .",
    "this quantum algorithm solves the cip with success probability at least @xmath355 .",
    "since the inclusion @xmath384 seems unlikely , there is little hope to find a `` polynomial - time '' quantum list decoder for the generalized reed - solomon code with relatively small bias .",
    "we point out that quantum list decoding of the generalized reed - solomon code is closely related to the _ noisy polynomial interpolation problem _ introduced by naor and pinkas @xcite .",
    "noisy polynomial interpolation problem ( npip )    * input : three numbers @xmath385 , a prime @xmath0 , @xmath12 distinct points @xmath386 in @xmath63 , and @xmath12 sets @xmath387 , each of which consists of exactly @xmath338 elements from @xmath63 .",
    "* promise : there exists a _ unique _ polynomial @xmath165 of degree at most @xmath62 such that , for each @xmath388 $ ] , there exists exactly one element @xmath389 satisfying @xmath390 . *",
    "output : the hidden polynomial @xmath165 .",
    "naor and pinkas used the npip as an intractable assumption for a cryptographic primitive , called _ oblivious polynomial evaluation_. now , we prove the following .",
    "if the generalized reed - solomon codes are quantum list decodable with arbitrary bias and confidence @xmath355 , then there exists a quantum algorithm that solves the npip with probability at least @xmath355 .",
    "take @xmath12 distinct elements @xmath391 and @xmath12 sets @xmath387 of @xmath338 elements each .",
    "assume that the promise of the npip holds with a unique polynomial , say , @xmath165 of degree at most @xmath62 .",
    "we set the bias @xmath150 to be @xmath392 and let @xmath393}s_i$ ] .",
    "note that @xmath394 .",
    "let us define a quantumly corrupted codeword @xmath67 as follows .",
    "for any element @xmath160 in @xmath395 , say @xmath396 for a certain @xmath397 $ ] , let @xmath398 where @xmath399 if @xmath389 and @xmath94 otherwise .",
    "for the other elements @xmath160 outside of @xmath395 , let @xmath400 we claim that the unique polynomial @xmath165 satisfies the condition @xmath401 .",
    "since @xmath402 and @xmath403 , it follows that @xmath404 hence , we conclude that @xmath405 .",
    "now , consider the @xmath150-qldp for the @xmath406 with @xmath67 . by our assumption",
    ", there exists a quantum list decoder @xmath157 that solves this @xmath150-qldp with high confidence . to apply this @xmath157 to find the hidden polynomial @xmath165",
    ", we need to _ realize _ @xmath67 from the given inputs @xmath407 .",
    "this is done by generating the state @xmath408 as follows : choose @xmath327 in @xmath409 randomly and then generate the amplitude @xmath410 .",
    "therefore , we can solve the npip with high success probability .      to construct a quantum list decoder for the generalized reed - solomon code against relatively small bias",
    ", it suffices to give a quantum algorithm to the following lattice problem",
    ".    bounded distance vector problem ( bdvp )    * input : @xmath338 basis vectors @xmath411 and a radius @xmath412 . *",
    "oracle : given a vector @xmath413 , returns the value @xmath414}\\lambda_j^2v_j^2 $ ] , where @xmath415 and @xmath416^n$ ] is a weight vector .",
    "* output : a list that contains all vectors @xmath417 in the lattice @xmath159 spanned by @xmath418 , satisfying @xmath419 .    if there exists a quantum algorithm that solves the bdvp with probability at least @xmath355 , then there exist quantum list decoders for the generalized reed - solomon codes with arbitrary bias and confidence @xmath355 .",
    "the following argument is owing to @xcite .",
    "we want to construct an efficient quantum reduction to the bdvp from the qldp for the @xmath420 generalized reed - solomon code .",
    "this proves the proposition .",
    "fix a set @xmath421 of @xmath422 distinct code locators in @xmath63 and consider the product set @xmath423,j\\in[q]\\}$ ] .",
    "let @xmath150 be any bias and assume that a quantumly corrupted codeword @xmath67 for the generalized reed - solomon code satisfies @xmath424}\\alpha_{i , j}{| x_i \\rangle}{| s\\oplus z_j \\rangle}{| t\\oplus \\phi_{i , j } \\rangle}. $ ] the _ ( special ) lagrange interpolation polynomials _ corresponding to @xmath425 are @xmath426-\\{i\\ } } \\frac{x - x_j}{x_i - x_j}$ ] in @xmath427 $ ] , which is of degree @xmath428 , for each @xmath429 $ ] .",
    "note that every @xmath430 satisfies the following property : @xmath431 and @xmath432 if @xmath433 .",
    "assume that @xmath434 for certain constants @xmath435 .",
    "let @xmath436 be any message and let @xmath437 be its codeword , , the polynomial over @xmath63 of degree at most @xmath65 .",
    "now , we assume that @xmath438 .",
    "note that @xmath439 satisfies the lagrange s interpolation formula : @xmath440 where @xmath441 if @xmath442 and @xmath94 otherwise .",
    "note that @xmath443 for each fixed @xmath367 and @xmath90 .",
    "let @xmath444 be our _ target vector_. we define the set @xmath159 as the collection of all vectors @xmath445 such that    1 .",
    "@xmath446\\left [ \\sum_{j=1}^{q}d_{ij } = \\sum_{j=1}^{q}d_{i'j } \\right]$ ] ; and 2 .",
    "@xmath447_{{\\mathbb{z } } } \\left[\\sum_{i=1}^{m}\\sum_{j=1}^{q } d_{ij}z_jc_{ik } = 0\\;\\mathrm{mod}\\;q\\right]$ ] .",
    "it is not difficult to show that @xmath159 forms a lattice .",
    "notice that the target vector @xmath448 belongs to @xmath159 .",
    "a set of basis vectors @xmath418 for @xmath159 can be found easily ( see , , @xcite ) .",
    "next , we define a weight vector @xmath449^{qm}$ ] as follows : for each point @xmath450 , let @xmath451 .",
    "the _ weighted norm _",
    "@xmath452 of a vector @xmath453 is thus calculated as @xmath454 therefore , the square of the weighted norm of @xmath448 equals @xmath455 by taking the radius @xmath456 , it follows that @xmath457 iff @xmath438 .    to solve the qldp , we first compute a basis vectors @xmath458 and a radius @xmath459",
    "we then solve the bdvp using the weight vector ( given by an oracle ) .",
    "let @xmath460 be the resulted list of vectors in @xmath159 .",
    "for each @xmath461 , find @xmath462 such that @xmath463 by solving a set of linear equations .",
    "we present an example of how to use proposition [ high - rate ] .",
    "our example here is a qcma search problem . set our alphabet @xmath11 to be @xmath464 in this section .",
    "a _ qcma search problem _ is a triplet @xmath465 , where @xmath159 is a language , @xmath422 is a polynomial - time quantum algorithm taking inputs from @xmath466 , and @xmath165 is a polynomial , with the following two requirements :    1 .   for every @xmath467 , there exists a witness @xmath468 such that @xmath469\\geq 2/3 $ ] ; and 2 .   for every @xmath470 , @xmath471\\geq 2/3 $ ]",
    "holds for any string @xmath468 .    a _ solution function _",
    "@xmath162 for the search problem @xmath465 satisfies that ( i ) for every @xmath467 , @xmath472\\geq 2/3 $ ] and @xmath473 and ( ii ) for every @xmath470 , @xmath474 ( a special symbol ) .",
    "moreover , @xmath475 denotes the class consisting of all languages @xmath159 over the alphabet @xmath11 such that there exist a polynomial - time quantum algorithm @xmath422 and a polynomial @xmath165 for which @xmath465 is a qcma search problem .",
    "[ qcma - search ] let @xmath277 be any positive polynomial .",
    "the following two statements are equivalent .    1 .   for every qcma search problem ,",
    "there exist its solution function @xmath476 and a polynomial - time quantum algorithm @xmath157 such that , for every @xmath160 , @xmath477\\geq 1/2 + 1/s(|x|)$ ] .",
    "2 .   for every qcma search problem",
    ", there exist its solution function @xmath162and a polynomial - time quantum algorithm @xmath166 such that , for every @xmath160 , @xmath478\\geq 2/3 $ ] .",
    "an immediate corollary is stated as follows .    assuming that @xmath479 , for every positive polynomial pair @xmath480 with @xmath481 for all @xmath24 , there exists a qcma search problem @xmath482 that satisfies the following : for any solution function @xmath162 for @xmath482 , no polynomial - time quantum algorithm finds strings @xmath327 , on each input @xmath160 of length @xmath12 , with probability at least @xmath483 such that the relative distance @xmath484 is at most @xmath485 .",
    "assume that @xmath479 .",
    "assume also that , for every qcma search problem , there exist its solution function @xmath162 and a polynomial - time quantum algorithm @xmath157 that finds a string @xmath327 , on each input @xmath160 , with probability at least @xmath483 with @xmath486 .",
    "consider the following algorithm @xmath166 : on input @xmath487 , run @xmath157 on input @xmath160 and then output the @xmath367th bit of its outcome .",
    "the success probability of @xmath166 is lower - bounded by @xmath488}{\\hspace * { 1 mm } } \\\\ & \\geq & \\left(1-\\frac{2p(n)}{p'(n)(p(n)+2)}\\right)\\left(1-\\max\\{\\delta(y , f(x))\\right)\\ } ) \\\\ & = & \\frac{1}{2}+ \\frac{1}{p(n ) } - \\frac{1}{p'(n)}.\\end{aligned}\\ ] ]    now , choose a polynomial @xmath277 satisfying that @xmath489 for all @xmath24 . by proposition",
    "[ qcma - search ] , we have a polynomial - time quantum algorithm that computes a certain solution function with probability at least @xmath490 .",
    "this means that qcma is included in bqp , a contradiction .",
    "finally , we give the proof of proposition [ qcma - search ] .",
    "proposition [ qcma - search ] let @xmath277 be any positive polynomial . take two positive polynomials @xmath491 and a @xmath492-code family @xmath17 that is polynomial - time classically list decodable and has a polynomial - time quantum list decoder @xmath243 with bias @xmath493 and confidence @xmath355 , producing a list of size at most @xmath37 , where @xmath12 is message length . without loss of generality , we can assume that @xmath354 for all @xmath24 .",
    "the implication ( 2 ) @xmath494 ( 1 ) is trivial .",
    "next , we assume ( 1 ) and want to show ( 2 ) . let @xmath495 be any qcma search problem .",
    "assume also that @xmath496 for all @xmath24 .",
    "note that a standard _ majority vote technique _ can reduce the bounded error probability of a quantum algorithm exponentially small ( without changing the witness size ) by polynomially - many repetitions . therefore , we can assume from ( 1 ) that    1 .",
    "for every @xmath467 , there exists a witness @xmath468 such that @xmath497 \\geq 1- 2^{-r(|x|)}$ ] ; and 2 .   for every @xmath470 and for every @xmath468",
    ", we have @xmath498 \\geq 1- 2^{-r(|x|)}$ ] ,    where @xmath499 and @xmath422 is a certain polynomial - time quantum algorithm that depends on @xmath500 .",
    "now , we define another qcma search problem @xmath501 as follows .",
    "let @xmath40 denote the codeword , to which @xmath327 is encoded , of block length @xmath502 . consider the quantum algorithm @xmath503 that behaves as follows .",
    "_ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ on input @xmath504 , first run the classical list decoding algorithm in polynomial time to produce with probability at least @xmath505 a list @xmath506 of candidates for @xmath17 using @xmath507 as a classically corrupted codeword ( or a received word ) . next , check if @xmath508 for a certain @xmath509 .",
    "if there is no such @xmath327 , reject immediately .",
    "assuming @xmath508 , run @xmath510 and outputs its outcome .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath511 .",
    "we then claim that @xmath501 is a qcma search problem .",
    "take any @xmath24 and any @xmath512 .",
    "consider the case where @xmath467 . since there exists a witness @xmath513 , the corresponding codeword @xmath508 forces @xmath503 to accept @xmath504 with probability at least @xmath514 .",
    "for the other case where @xmath470 , let @xmath507 be any string in @xmath515 . if @xmath516 for all @xmath509 , then @xmath503 accepts @xmath504 with probability @xmath517 . on the contrary , if @xmath508 for a certain @xmath509 , then @xmath503 accepts @xmath504 with probability @xmath518 .    again , by the majority vote technique , we can reduce the error probability of @xmath503 to @xmath519 . abusing the notation",
    ", we use @xmath503 to denote this new algorithm . by our assumption",
    "( 1 ) , there exist a solution function @xmath476 for @xmath501 and a polynomial - time quantum algorithm @xmath157 such that , for every @xmath512 , @xmath520 where @xmath521 for any choice @xmath522 , and @xmath523 \\geq 1/2 + 1/s(n)$ ] .",
    "we fix an arbitrary @xmath160 and , for the meantime , we omit subscript @xmath160 .",
    "let us define the oracle @xmath67 as follows : @xmath524 if there exists a string @xmath327 satisfying @xmath525 , then the presence of @xmath40 in @xmath67 is @xmath526    recall that @xmath243 produces a list of size at most @xmath353 for message length @xmath12 .",
    "we assume the standard order in @xmath527 .",
    "consider the following algorithm @xmath166 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ on input @xmath160 ( @xmath528 ) , run @xmath243 using @xmath67 as an oracle to produce a list @xmath529 of @xmath530 candidates ( since the message size is @xmath531 ) , which include the above @xmath327 ( if @xmath467 ) , with probability @xmath532",
    ". run @xmath533 sequentially for all @xmath534 in order .",
    "output the first @xmath534 such that @xmath533 outputs @xmath535 .",
    "if there is no such @xmath507 , output @xmath536 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath171 be the minimal string @xmath507 in @xmath529 such that ( i ) @xmath537\\geq 1 - 2^{-r(n)}$ ] and ( ii ) for all @xmath538 in @xmath529 , @xmath539\\geq 1 - 2^{-r(n)}$ ] .",
    "the probability that @xmath540 outputs @xmath171 is at least @xmath541 this guarantees that we obtain @xmath171 with probability at least @xmath490 .",
    "in the previous sections , we have used the model of implicit inputs and explicit outputs .",
    "when the running time of a quantum list decoder is limited to sublinear , it becomes impossible to explicitly output a list of messages .",
    "instead , we may allow a quantum list decoder to produces a list of `` oracle quantum circuits , '' each of which output each block element of a specific message with oracle access to a quantumly corrupted codeword .",
    "such a model is called an _ implicit - output model_. we briefly discuss a realm of quantum list decoding on this implicit - input implicit - output model .",
    "let us introduce the notion of local quantum list decoding , analogous to local list decoding .",
    "let @xmath17 be any @xmath107-code family with message alphabet @xmath11 .",
    "we say that @xmath17 is _ locally quantum list decodable _ with bias @xmath150 and confidence @xmath156 if there exists a quantum algorithm @xmath157 such that , for any message length @xmath24 ( given in binary , not in unary ) , any @xmath67 for @xmath17 , and any @xmath512 with @xmath542 , the following happens with probability at least @xmath490 :    1 .",
    "@xmath543 outputs a list of descriptions of oracle quantum circuits @xmath544 ; and 2 .",
    "there exists an index @xmath545 $ ] such that , for every @xmath388 $ ] , @xmath546 outputs @xmath192 with probability at least @xmath155    similar to @xmath547 , we can define the concatenated code @xmath548 using an appropriate reed - mller code and a proper hadamard code . following an argument of @xcite , we can easily prove that , using lemmas [ from - d - to - c ] and [ reed - solomon ] , the code @xmath548 is efficiently locally quantum list decodable with polynomially - small bias and confidence @xmath355 .",
    "hence , we can conclude :    [ local - decode ] there exists a code family of polynomially - small rate and constant codeword alphabet size that are efficiently locally quantum list decodable with confidence @xmath355 for polynomially - small bias .",
    "an immediate consequence of this lemma is the hardness amplification of quantum circuits , again following an argument of @xcite .",
    "there exists a constant @xmath549 for which the following is true .",
    "let @xmath550 and let @xmath162 be any boolean function from @xmath551 . if no quantum circuit of size @xmath277 computes @xmath162 with probability at least @xmath156 , then there exists a boolean function @xmath476 mapping @xmath552 with @xmath553 such that no quantum circuit @xmath17 of size @xmath554 satisfies @xmath555\\geq 1/2+\\varepsilon$ ] , where @xmath556 denotes the random variable indicating the observed outcome bit of @xmath17 on input @xmath160 .",
    "the theme of this paper is an exploration of quantum list decodable code families of polynomially - small rate and constant codeword alphabet size .",
    "we have shown that certain generalized reed - solomon codes concatenated with hadamard codes achieving such requirement are efficiently quantum list decodable when the bias of presence is relatively large .",
    "even with such large bias , this helps us show the local quantum list decodability of reed - mller codes .",
    "notice that a core part of the proofs of these results heavily relies on classical list decoding algorithms of @xcite . among codes of polynomially - small rate , is there any code whose quantum list decoding algorithm is in essence different from its classical one ?",
    "is there any quantum list decodable code that is not even classically list decodable ? does a generalized reed - solomon code have a subexponential - time quantum list decoder against arbitrary bias ?",
    "another important open problem is to find useful applications of quantum list decoding to a wide range of quantum information processing .",
    "a. kawachi and t. yamakami .",
    "quantum hardcore functions by complexity - theoretical quantum list decoding . in _ proc .",
    "33rd icalp 2006 _ , lncs vol.4052 , pp.216227 , 2006 .",
    "see also arxiv.org quant - ph/0602088 and eccc report tr06 - 020 ."
  ],
  "abstract_text": [
    "<S> our task of quantum list decoding for a classical block code is to recover from a given quantumly corrupted codeword a short list containing all messages whose codewords have high `` presence '' in this quantumly corrupted codeword . </S>",
    "<S> all known families of efficiently quantum list decodable codes , nonetheless , have exponentially - small message rate . we show that certain generalized reed - solomon codes concatenated with hadamard codes of polynomially - small rate and constant codeword alphabet size have efficient quantum list decoding algorithms , provided that target codewords should have relatively high presence in a given quantumly corrupted codeword .    </S>",
    "<S> _ keywords : _ error - correcting code , quantum list decoding , quantum computation , quantumly corrupted codeword </S>"
  ]
}