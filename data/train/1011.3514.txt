{
  "article_text": [
    "in the last decade , multiphysics astrophysical simulations have increased exponentially in both sophistication and size @xcite ; however , the software tools to mine those simulations have not kept pace .",
    "typically , methods for examining data suffer from a lack of agility , discouraging exploratory investigation .",
    "massively parallel visualization tools such as visit and paraview @xcite , are quite general , serving the needs of many disparate communities of researchers . while a multi - code , astrophysical analysis system could be built on top of one of these tools , we have chosen a lighter weight approach that we feel is complementary .",
    "the lack of domain - specific quantitative analysis tools designed for astrophysical data leads to the development of specialized tools by individual researchers or research groups , most of which are never shared outside the research group .",
    "this can substantially inhibit collaboration between different groups  even those using the same simulation code .",
    "furthermore , tools developed by a single research group are often tightly coupled to a specific simulation code or project .",
    "this results in a constant process of reinvention : individual research groups create analysis scripts specific to a single simulation tool that read data from disk , assemble it in memory , convert units , select subsections of that data , perform some type of quantitative analysis and then output a reduced data product .",
    "when collaborative analysis between research groups exists , it often includes creation of intermediate data formats , requiring substantial `` last mile '' efforts to ensure correct units , format , and other data - transport details .",
    "this fractionation of the astrophysical community demonstrates a clear need for a flexible and cross - code software package for quantitative data analysis and visualization . in this paper",
    "we present ` yt ` , a data analysis and visualization package that works with several astrophysical simulation codes . `",
    "yt ` is developed openly and is freely available at http://yt.enzotools.org/. it has been designed to be a common platform for simulation analysis , so that scripts can be shared across groups and analysis can be repeated by independent scientists .",
    "historically , ` yt ` was initially developed to examine slices and projected regions through deeply nested adaptive mesh refinement cosmological simulations conducted with enzo @xcite , but it was quickly repurposed to be a multi - code mechanism for data analysis and visualization .    by making this tool available , we hope not only to encourage cross - group collaboration and validation of results , but to remove or at least greatly lower the barrier to entry for exploratory simulation analysis . ` yt ` provides mechanisms for conducting complete analysis pipelines resulting in publication quality figures and data tables , as well as the necessary components for constructing new methods for examining data .",
    "the concepts for data handling and representation in ` yt ` are certainly not new , but their application to astrophysical data enables complex , detailed analysis pipelines to be shared between individuals studying disparate phenomena using disparate methods .",
    "this enables and even encourages reproducibility and independent verification of results .    `",
    "yt ` is primarily written in python with several core routines written in c for fast computation . ` yt ` heavily utilizes the numpy library ( * ? ? ?",
    "* http://numpy.scipy.org ) , and is itself a python module suitable for direct scripting or access as a library .",
    "a community of users and developers has grown around the project , and it has been used in numerous published papers and posters ( for example * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "in order to accomodate the diverse computing environments on which astrophysical simulations are run , ` yt ` was designed to use primarily off - screen rendering and scripting interfaces , although several smaller tools are provided for specific , interactive visualization tasks .",
    "the former method is well - suited to remote visualization and can be run via a job execution queue on a batch - compute cluster , such as those on which the underlying simulation are run . `",
    "yt ` is subdivided into several sub - packages for data handling , data analysis , and plotting .",
    "this modularity encourages the creation of reusable components for multi - step analysis operations , _ which can then be used without modification on data from any simulation code ` yt ` supports_.    as an example , in figure  [ fig : halo_proj ] we have included a script that combines many of these components into a modifiable pipeline for visualization .",
    "this script loads a dataset from disk ( via ` yt ` s generic ` load ` command ) , returning an instance of a python class ` staticoutput ` .",
    "this object is used as the source for a halo finding operation (   [ sec : halo_finding ] ) , which again returns an instance of a python class representing the collection of identified halos .",
    "each halo s baryonic content is inspected individually (   [ sec : data_containers ] ) and the angular momentum vector is calculated (   [ sec : object_quantities ] ) and used as input to a volume rendering operation (   [ sec : volume_rendering ] ) . through this entire operation",
    ", the underlying simulation data has largely been abstracted as a set of physical objects .        .... from yt.mods import * from yt.visualization.volume_rendering.api import \\",
    "projectiontransferfunction from yt.visualization.image_writer import \\",
    "write_image    pf = load(\"dd1701/dd1701 \" )    halos = halofinder(pf )    tf = projectiontransferfunction ( )    for halo in halos :      center = halo.center_of_mass ( )      radius = halo.maximum_radius ( )      sp = halo.get_sphere ( )      l_vec = sp.quantities[\"angularmomentumvector \" ] ( )      cam = pf.h.camera(center , l_vec , 10.0*radius ,                        resolution=(512 , 512 )",
    ",                        log_fields = false ,                        transfer_function = tf )      i m = cam.snapshot ( )      write_image(na.log10(im ) , \" halo_%04i.png \" % halo.id ) ....    in this paper , we will start by describing the mechanisms by which ` yt ` addresses and processes physical data (   [ sec : mechanisms ] ) .",
    "we then discuss the visualization mechanisms available in ` yt ` (   [ sec : visualization ] ) such as projections , slices and volume rendering .",
    "we proceed to enumerate the simulation codes ` yt ` works with and discuss the challenges they present (   [ sec : codes ] ) . in ",
    "[ sec : parallelism ] we describe the parallelism strategies used by ` yt ` .",
    "the mechanisms by which ` yt ` can be embedded in running simulations are presented and described in   [ sec : embedding ] . following this ,",
    "we conclude by describing both the pre - packaged analysis modules for ` yt ` (   [ sec : analysis_modules ] ) , future directions in (   [ sec : future_directions ] ) and discuss the community engagement and involvement around ` yt ` (   [ sec : conclusions ] ) .",
    "the vast majority of adaptive mesh refinement calculations in the astrophysical literature are computed on a rectilinear grid ; while this affords a number of computational efficiencies and conveniences , astrophysical phenomena as a whole are not rectangular prisms and thus are ill - suited to analysis as rectangular prisms .",
    "this presents a fundamental disconnect between the data structures utilized by simulations and the geoemetries found in nature .",
    "furthermore , the task of selecting geometric regions in space requires substantial overhead . ` yt ` provides a number of convenience functions and mechanisms for addressing data within astrophysical simulations that make the process of handling and manipulating data straightforward .",
    "the ` yt ` codebase has been organized along several conceptual lines , each corresponding to a set of tasks or classes in python .",
    "the primary mechanisms for handling data are contained in the python module ` yt.data_objects ` , while all code and data structures specific to a particular simulation code resides within a submodule of ` yt.frontends ` ( such as ` yt.frontends.enzo ` , ` yt.frontends.orion ` , etc ) . to open a dataset",
    ", the user creates an instance of a simulation code - specific subclass of ` staticoutput ` , a lightweight class that scans a parameter file and obtains the necessary information to orient the dataset : the current time in the simulation , the domain information , the mechanisms for converting units , and the necessary file locations on disk . a convenience function ( ` load ` ) for automatically creating such an instance",
    "is provided , such that it only requires a path on disk to the dataset of interest . however , geometric information about the manner in which data is laid out on disk or in the simulation domain is compartmentalized to a ` amrhierarchy ` object .",
    "these objects are comparatively expensive to construct , as they contain a hierarchy of ` gridpatch ` objects , all of which posses spatial and parentage information .",
    "these objects are not instantiated or constructed until requested .",
    "all data access is mediated by ` amrhierarchy ` objects , as noted below .",
    "as an example , a sample ` yt ` session where enzo data is loaded off disk and examined might look something like this :    .... > > > from yt.mods import * > > > dataset = load(\"40 - 3d-3 \" ) > > > print dataset.current_time 646.750 > >",
    "> print dataset.current_redshift 0.0 > > > dataset.hierarchy.print_stats ( ) level    # grids      # cells ---------------------------    0           4         32768    1          34        253496    2         304        525784 ----------------------------             342        812048 ....    in this session , a relatively small dataset is loaded from disk .",
    "the object ` dataset ` contains a number of pieces of information about the dataset : the current time , cosmological parameters ( if applicable ) , the domain size , and so on .",
    "it is not until the attribute ` .hierarchy ` ( or ` .h ` for brevity ) is accessed that ` yt ` parses the underlying grid patches that exist on disk , instantiates both the ` amrhierarchy ` object , and its component ` gridpatch ` objects , orients them in space and sets up a mapping between grids and their location on disk .",
    "all further accessing of data , such as through data containers , is mediated by the hierarchy object itself , rather than by the parameter file .    by relegating data handling to individual instances of classes ,",
    "we compartmentalize datasets ; because each dataset is merely a variable , the number that can be opened and simultaneously cross - compared is only limited by the available memory and processing power of the host computer .",
    "furthermore , datasets from different simulation codes can be opened and compared simultaneously in memory .      when handling astrophysical data , it is appropriate to speak of geometric regions that outline the rough boundaries of physical objects : dark matter halos as ellipsoids , protostars as spheres , spiral galaxies as cylinders , and so on .",
    "the central conceit behind ` yt ` is the presentation to the user of a series of physical objects with the underlying simulation largely abstracted . for amr data",
    ", this means hiding the language of grid patches , files on disk and their interrelationships , and instead describing only geometric or physical systems ; these intermediate steps are handled exclusively by ` yt ` , without requiring any intervention on the part of the user .",
    "for instance , to select a spherical region , the user specifies a center and a radius and the underlying ` yt ` machinery will identify grid patches that intersect that spherical region , identify which grid patches are the most highly - refined at all regions within the sphere , locate the appropriate data on disk , read it and return this data to the user .    the mechanisms in ` yt",
    "` for this abstraction are called _",
    "data containers_. these are python objects , subclasses of a generic ` amrdata ` interface , affiliated with a specific instance of an ` amrhierarchy ` object , that provide a consistent interface to a region of selected data .",
    "this region can be defined by geometric concerns or selected by criteria from physical quantities in the domain .",
    "data contained in these objects is accessed in a consistent manner and loaded on demand : the computational cost of creating a box that covers an entire region is negligible , and until data is actually accessed from that box the memory overhead remains likewise negligible . by abstracting the selection of and access to data in this manner , operations that can be decomposed spatially or that are  embarrassingly parallel \" can be transparently parallelized , without requiring the user s intervention .",
    "( see section  [ sec : object_quantities ] and section  [ sec : parallelism ] . )",
    "the data containers implemented in ` yt ` include spheres , rectangular prisms , cylinders ( disks ) , arbitrary regions based on logical operations , topologically - connected sets of cells , axis - orthogonal and arbitrary - angle rays , and both axis - orthogonal and arbitrary - angle slices .",
    "below , we show an example of a hypothetical user accessing dataset ` 40 - 3d-3 ` ( as shown above ) , creating a sphere of radius @xmath0 centered at the origin , and then accessing all `` density '' values that reside within that sphere .    .... dataset = load(\"40 - 3d-3 \" ) sphere = dataset.h.sphere ( [ 0.0 , 0.0 , 0.0 ] ,            100.0 / dataset[\"pc \" ] ) print sphere[\"density \" ] ....    when a data container is queried for a particular field ( as in the final line above ) , ` yt ` will select the appropriate grid patches , read them from disk and mask out regions where higher resolution data is available , and then return to the user a one - dimensional array of values that constitute the data within a region . `",
    "yt ` also transparently allows for the creation of _ derived fields _ , fields that are defined as functions of the base fields output by the simulation or even other derived fields .",
    "these can be defined by the user and supplied to ` yt ` , and ` yt ` provides a number of such fields .",
    "for instance , the user could define a derived field based on the density and temperature present in the cell to estimate molecular hydrogen formation timescales , the angular momentum with respect to a particular center , the total magnetic energy in a cell , the spatial coordinates of a point , and so on .",
    "data containers provide several methods for data access .",
    "the data can be accessed directly , as in the above code listing , or through abstractions such as _ object quantities _",
    ", described in section  [ sec : object_quantities ] .",
    "furthermore , data objects provide geometric information about the grid patches that contribute to a given object , and through the usage of fields the total mass , total volume and other physical quantities can be constructed .    despite the pervasive abstraction of data selection , ` yt ` also allows for queries based on simulation data structures and access to raw fields in memory .",
    "for instance , grid patch objects respect an identical protocol to data containers . accessing raw data in the terms",
    "the simulation code itself uses allows ` yt ` to be very useful during development and debugging ( of both ` yt ` and the simulation code ! )    the abstraction of data into data containers leads to the creation of systems of components : data containers become `` sources '' for both analysis procedures as well as visualization tasks .",
    "these analysis procedures then become reusable and the basis for chains of more complicated analysis tasks . using such chains",
    ", a user can volume render a set of halos based on their angular momentum vectors ( as in figure  [ fig : halo_proj ] ) , color particles by merger history , and even calculate disk inclination angles and mass fluxes .",
    "once a region of the simulation is selected for analysis , ` yt ` must process the raw data fields themselves . its model for handling this data and processing fundamental data fields into new fields describing _ derived quantities _ is built on top of an object model with which we can build automatically recursive field generators that depend on other fields .",
    "all fields , including derived fields , are allowed to be defined by either a component of a data file , or a function that transforms one or more other fields .",
    "this indirection allows multiple layers of definition to exist , encouraging the user to extend the existing field set as needed .    by defining simple functions that operate via numpy array operations , generating derived fields",
    "is straightforward and fast .",
    "for instance , a field such as the magnitude of the velocity in a cell @xmath1 can be defined independently of the source of the data :    .... def velocitymagnitude(field , data ) :      return ( data[\"x - velocity\"]**2.0 +              data[\"y - velocity\"]**2.0 +              data[\"z - velocity\"]**2.0)**0.5 ....    each operation acts on each element of the source data fields ; this preserves the abstraction of fields as undifferentiated sets of cells , when in fact those cells could be distributed spatially over the entire dataset with varying cell widths .",
    "once a function is defined , it is added to a global field container that contains not only the fields , but a set of metadata about each field  the units of the field , the units of the field when projected , and any implicit or explicit requirements for that field .",
    "field definitions can require that certain parameters be provided ( such as a height vector , a center point , a bulk velocity and so on ) or , most powerfully , that the data object has some given characteristic .",
    "this is typically applied to ensure that data is given in a spatial context ; for finite difference solutions , such as calculating the gradient or divergence of a set of fields , ` yt ` allows the derived field to mandate that the input data provided in a three - dimensional structure .",
    "furthermore , when specifying that some data object be provided in three dimensions , a number of buffer cells can be specified as well ; the returned data structure will then have those buffer cells taken from neighboring grids ( this utilizes _ covering grids _ , as described in ",
    "[ sec : fixed_resolution_grids ] ) .",
    "this enables higher - order methods to be used in the generation of fields , for instance when a given finite difference stencil extends beyond the computational domain of a single grid patch . `",
    "yt ` provides several fields that utilize buffer zones , such as the divergence of the velocity and the spatially - averaged local density .",
    "in addition to the flexibility of defining field quantities at every point in space , ` yt ` provides the ability to examine quantities constructed from whole regions in space .",
    "these _ derived quantities _ are available from any data container present in ` yt ` .",
    "they are defined by some relationship of the points contained within the container ; this can be the bulk angular momentum vector , the average velocity , the center of mass , the total mass , the moment of inertia and so on .",
    "these bulk quantities affiliated with objects are defined in two stages : the calculation stage , wherein intermediate values can be created and stored , and a reduction stage where the intermediate values are combined in some manner to produce a final result .",
    "this allows derived quantities to operate transparently in parallel in an un - ordered fashion : a script that calculates the total mass in a sphere occupying some volume in the simulation domain , when run in parallel , will transparently distribute work ( computation and disk io ) between processors and then re - join the work to produce a final result .",
    "this parallelization process is described in more detail in section  [ sec : parallelism ] .",
    "for instance , the following script that uses the ` sphere ` created in the above code listing , will return the mass - weighted angular momentum vector of the baryonic content of that sphere :    .... l_vec = sphere.quantities [      \" angularmomentumvector \" ] ( ) ....    the returned value ( ` l_vec ` ) is a numpy array and can be used in subsequent analysis .",
    "these object quantities can be newly defined , can take any number of parameters , and can take as input any derived field created by the user .",
    "this not only allows further flexibility on the part of the simulation , but allows advanced , bulk manipulations of extremely large datasets to proceed in a straightforward fashion .",
    "multi - resolution data presents challenges to the application of certain classes of algorithms , for example those using the fast fourier transforms . to address this need ,",
    "the creation of fixed - resolution ( and three - dimensional ) arrays of data filling arbitrary rectangular prisms must be easy and accessible .",
    "however , unless the entire region under consideration is contained within a single grid patch , it can be difficult to construct these arrays . `",
    "yt ` creates these arrays , or _ covering grids _",
    ", by an iterative process",
    ". first all grids intersecting or fully - contained within the requested rectangular prism are selected .",
    "these grids are then iterated over , starting on the coarsest level , and used to fill in each point in the new array .",
    "all grid cells that intersect with the covering grid and where no finer - resolution data is available are deposited into the appropriate cell in the _ covering grid_. by this method , the entire covering grid is filled in with the finest cells available to it .",
    "this can be utilized for generating ghost zones , as well as for new constructed grids that span the spatial extent of many other grids that are disjoint in the domain .",
    "however , coarse cells are duplicated across all cells in the ( possibly finer - resolution ) covering grid with which they intersect , which can lead to unwanted resolution artifacts . to combat this , a _ smoothed covering grid _",
    "object is also available .",
    "this object is filled in completely by iterating over , from coarsest to finest , all levels @xmath2 where @xmath3 is the level at which the covering grid is being extracted .",
    "once a given level has been filled in , the grid is trilinearly interpolated to the next level , and then all new data points from grids at that level replace existing data points .",
    "we note , however , that this does not explicitly perform the crack - fixing method described in @xcite . nevertheless , it is suitable for generating smoothed multi - resolution grids and constructing vertex - centered data , as used in section  [ sec : volume_rendering ] .",
    "distributions of data within the space of other variables are often necessary when examining and analyzing data .",
    "for instance , in a collapsing gas cloud or galaxy cluster , examining the average temperature with increasing radius from a central location provides a convenient means of examining the process of collapse , as well as the effective equation of state . to conduct this sort of analysis ,",
    "typically a multi - dimensional histogram is constructed , wherein the values in every bin are weighted averages of some additional quantity . in ` yt ` , the term _ profile _ is used to describe any weighted average or distribution of a variable with respect to an other independent variable or variables .",
    "such uses include a probability density function of density , a radial profile of molecular hydrogen fraction , and a radius , temperature , and velocity phase diagram . ` yt `",
    "provides functionality for these profiles to have one , two or three independent variables , and all native or user - defined fields known by ` yt ` can serve as variables in this process .",
    "each profile , defined uniquely by its bounds and independent variables , accepts a data container as a source and is then self - contained within an instance of the appropriate python class ( ` binnedprofile1d ` , ` binnedprofile2d ` or ` binnedprofile3d ` ) .",
    "one can imagine profiles serving two different purposes : to show the average value of a variable at a fixed location in the phase space of a set of independent variables ( such as the average molecular hydrogen fraction as a function of density and temperature ) , or for the sum of a variable inside a phase space of independent variables ( such as the total mass within bins of density and temperature . ) ` yt ` can calculate both of these types of profiles over any data container .",
    "this process is essentially that of a weighted histogram .",
    "we define up to three axes of comparison , which will be designated @xmath4 , @xmath5 , and @xmath6 , but should not be confused with the spatial axes of the simulation .",
    "these are discretized into @xmath7 where @xmath8 is the number of bins along the specified axis .",
    "indices @xmath9 for each value among the set of points being profiled are then generated along each axis such that @xmath10 these indices are then used to calculated the weighted average or sum in each bin : @xmath11 where @xmath12 is now the average value in bin @xmath9 in our weighted average , and the @xmath13 points are selected such that their index along the considered axis is @xmath9 .",
    "this method is trivially extended to multiple dimensions . to conduct a non - averaged distribution , the weights are all set to @xmath14 in the numerator , and the sum in the denominator is not calculated .",
    "this allows , for example , the examination of mass distribution in a plane defined by chemo - thermal quantities . in figure",
    "[ fig : phase_mass ] we show an example image , where the distribution of matter in a galaxy merger simulation has been shown as a function of density and the local @xmath15 .",
    "this is an `` unweighted '' profile , where the value in every cell corresponds to the total mass occupying that region in phase space .",
    "the construction of objects , particularly when guided by analysis pipelines or calculated values , can often be a computationally expensive task ; in particular , clumps found by the contouring algorithm ( see section  [ sec : level_sets ] ) and the gravitational binding checks that are used to describe them require a relatively time - consuming set of steps . to save time and enable repeatable analysis",
    ", the storage of objects between sessions is essential .",
    "python itself comes with an object serialization protocol called `` pickle '' that can handle most objects .",
    "however , by default the pickle protocol is greedy  it seeks to take all affiliated data . for a given ` yt ` object",
    ", this may include the entire hierarchy of amr grid data , the parameter file describing the amr run , all arrays associated with that object , and even user - space variables ( see   [ sec : codes ] for more details about the former two ) . under the assumption that the data used to generate the fields within a given object will be available the next time the object is accessed",
    ", we can reduce the size and scope of the pickling process by designing a means of storing and retrieving these objects across sessions .    `",
    "yt ` implements a custom version of the pickling protocol , storing instead a description in physical space of the object itself .",
    "this usually involves replicating the parameters used to create the ` amrdata ` object , such as the radius and center of a sphere .",
    "once the protocol has been executed , all the information necessary to reconstruct the object is stored either in a single , standalone file or in a local data store .",
    "the primary obstacle to retrieving an object from storage is ensuring that the affiliation of that object with a given dataset is retained .",
    "this is accomplished through a persistent per - user storage file , wherein unique ids for all `` known '' datasets are stored .",
    "these unique ids are updated when new datasets are opened .",
    "when an object is retrieved from storage , the unique i d affiliated with that object is looked up and the dataset is opened and returned to the user with the object .",
    "` yt ` provides methods for creating 2d and 3d visualizations of simulation data .",
    "the mechanisms for creating 2d visualizations have two primary components : the data - handling portion and the figure creation or `` pixelization '' step .",
    "the former is composed of a sophisticated set of objects which provide uniform access to 2d data objects , while the latter is a simple method for making plots quickly , which can be wrapped into other convenience functions ( both created by ` yt ` and external to ` yt ` . )",
    "the figure creation in ` yt ` is motivated by a desire for simplicity : rather than attempting to accommodate the myriad use cases and user preferences , ` yt ` seeks to provide a set of routines that can be extended easily .",
    "users requiring complex figures for specific publications can take the 2d image pixel buffers provided by ` yt ` and feed them to any plotting package , though ` yt ` integrates most naturally with the matplotlib python module @xcite . here , we first describe each of the 2d pixalization mechanisms , and then the 3d volume rendering algorithms .",
    "futher information on the simple , built - in figure generation can be found in the ` yt ` documentation .",
    "the simplest means of examining data is plotting grid - axis aligned slices through the dataset .",
    "this has several benefits - it is easy to calculate which grids and which cells are required to be read off disk ( and most data formats allow for easy striding of data off disk , which reduces this operation s io overhead ) and the process of stepping through a given dataset is relatively easy to automate .    to construct a set of data points representing a slice , we construct a set of data points defined as @xmath16 where @xmath17 indicates that this is in the image plane rather than in the global coordiantes of the simulation , and @xmath18 is the value of the field selected ; furthermore , every returned @xmath19 point does not overlap with any points where @xmath20 or @xmath21 .",
    "each point is at the finest resolution available .",
    "when handling astrophysical simulation data , one often wishes to examine either the sum of values along a given sight - line or a weighted - average along a given sight - line , in a _ projection_. ` yt ` provides an algorithm for generating line integrals in an adaptive fashion , such that every returned @xmath19 point does not contain data from any points where @xmath22 or @xmath21 ; the alternative to this is a simple 2d image array of fixed resolution perpendicular to the line of sight whose values are filled in by all of the cells of the source object with overlapping domains .",
    "but , by providing this list of _ all _ finest - resolution data points in a projected domain , images of any field of view can be constructed essentially instantaneously ; conversely , however , the initial projection process takes longer , for reasons described below .",
    "we term the outputs of this process _",
    "adaptive projections_. for the santa fe light cone dataset @xcite , to project the entire domain at the highest resolution would normally require an image with @xmath23 values .",
    "utilizing this adaptive projection method , we require less than @xmath24 of this amount of image storage .    to obtain the finest points available ,",
    "the grids are iterated over in order of the level of refinement  first the coarsest and then proceeding to the finest levels of refinement .",
    "the process of projecting a grid varies depending on the desired output from the projection . for weighted averages ,",
    "we first evaluate the sums @xmath25 where @xmath26 is the output value at every cell in the image plane , @xmath27 is the sum of the weights along the line of sight in the image plane , @xmath28 is every cell in the grid s data field , @xmath29 is the weight field at every cell in the grid s data field , and @xmath30 is the path length through a single cell . because this process is conducted on a grid - by - grid basis , and the @xmath30 does not change within a given grid , this term can be moved outside of the sum . for an unweighted integration , @xmath27",
    "is set to @xmath14 , rather than to the evaluation of the sum .",
    "a mask of cells where finer data exists is reduced with a logical `` and '' operation along the axis of projection ; any cell where this mask is `` false '' has data of a higher refinement level available to it .",
    "this grid is then compared against all grids on the same level of refinement with which it overlaps ; the flattened @xmath4 and @xmath5 position arrays are compared via integer indexing and any collisions are combined .",
    "this process is repeated with data from coarser grids that have been identified as having subsequent data available to it ; each coarse cell is then added to the @xmath31 cells on the current level of processing , where @xmath32 is the refinement factor . at this point ,",
    "all cells in the array of data for the current level where the reduced child mask is  true \" are removed from subsequent processing , as they are part of the final output of the projection .",
    "all cells where the child mask is  false \" are retained to be processed on the next level . in this manner , we create a cascading refinement process , where only two levels of refinement have to be compared at a given time .    when the entire data hierarchy has been processed , the final flattened arrays of @xmath33 and @xmath34 are divided to construct the output data value @xmath18 : @xmath35 which is kept as the weighted average value along the axis of projection . in the case of an un - weighted projection",
    ", the denominator reduces to @xmath36 , which is in fact unity . once this process is completed , the projection object respects the same data protocol as an ordinary slice and can be plotted in the same way .",
    "future versions of ` yt ` will migrate to a quad - tree projection mechanism , currently still in the testing phase . using",
    "this quad - tree approach will allow grids to be handled in any order , as well as providing an overall speed increase .",
    "because of the multi - scale nature of most adaptive mesh refinement calculations , ` yt ` operates in a manner to reduce the total disk access required to generate 2d visualizations .",
    "pragmatically , this means that slices and projections are constructed of the finest available data at all points and then a pixel buffer is created for display .",
    "this enables the user to conduct a single projection through a dataset and then , with minimal computation effort , create many images of different regions in that domain . for central - collapse simulations , a single slice can be made through the data and then images can be made of that slice at different widths without handling the 3d data again . in ` yt ` , 2d data sources are stored as a flattened array of data points , with the positions and widths of those data points . to construct an image buffer ,",
    "these data points are pixelized and placed into a fixed - resolution array , defined by @xmath37 .",
    "every pixel in the image plane is iterated over , and any cells that overlap with it are deposited into every pixel @xmath38 as    @xmath39    where @xmath40 is an attempt to anti - alias the output image plane , to account for misalignment in the image and world coordinate systems and @xmath41 and @xmath42 are the areas of the cell and pixel respectively .",
    "this process is generally quite fast , and even for very large simulations ( such as in @xcite ) the process of generating a pixel buffer from an adaptive projection takes much less than one second .",
    "the buffer created by this process can be used either in ` yt ` , utilizing the built - in methods for visualization , or it can be exported to external utilities such as ds9 @xcite .      at some length scales in star formation problems , gas is likely to collapse into a disk , which is often not aligned with the cardinal axes of the simulation . by slicing along the axes , patterns such as spiral density waves could be missed and remain unexamined . in order to better visualize off - axis phenomena , ` yt ` is able to create images misaligned with the axes .",
    "a _ cutting plane _ is an arbitrarily - aligned plane that transforms the intersected points into a new coordinate system such that they can be pixelized and made into a publication - quality plot .    to construct a _ cutting plane _",
    ", both a central point and a single normal vector are required .",
    "the normal vector is taken as orthogonal to the desired image plane .",
    "this leaves a degree of freedom for rotation of the image plane about the normal vector and through the central point .",
    "a minimization procedure is conducted to determine the appropriate ",
    "north \" vector in the image plane ; the axis with which the normal vector ( @xmath43 ) has the greatest cross product is selected and referred to as @xmath44 .",
    "in addition to this , we define @xmath45 where @xmath46 is the vector to the center point of the plane , and @xmath47 is the inclination vector . from this",
    "we construct two matrices , the rotation matrix : @xmath48 and its inverse , which are used to rotate coordiantes into and out of the image plane , respectively .",
    "grids are identified as being intersected by the cutting plane through fast array operations on their boundaries .",
    "we define a new array , @xmath49 , where @xmath50 where the index @xmath51 is over each grid and the index @xmath9 refers to which of the eight grid vertices ( @xmath52 ) of the grid is being examined .",
    "grids are accepted if all three components of every @xmath53 are of identical sign : @xmath54 upon identification of the grids that are intersected by the cutting plane , we select data points where @xmath55 this generates a small number of false positives ( from regarding a cell as a sphere rather than a rectangular prism ) , which are removed during the pixelization step when creating a plot . each data point is then rotated into the image plane via the rotation matrix : @xmath56 this technique requires a new pixelization routine in order to ensure that the correct cells are taken and placed on the plot , which requires an additional set of checks to determine if the cell intersects with the image plane .",
    "the process here is similar to the standard pixelization procedure , described in section  [ sec : image_creation ] , with the addition of the rotation step . defining @xmath57 , every data point where @xmath58 is within the bounds of the image is examined by the pixelization routine for overlap of the data point with a pixel in the output buffer .",
    "every potentially intersecting pixel is then iterated over and the coordinates @xmath59 of the image buffer are rotated via the inverse rotation matrix back to the world coordinates @xmath60 .",
    "these are then compared against the @xmath61 of this original datapoint . if all three conditions @xmath62 are satisfied , the data value from the cell is deposited in that image buffer pixel .",
    "an unfortunate side effect of the relatively complicated pixelization procedure , as well as the strict intersection - based inclusion , is that the process of antialising is non - trivial and computationally expensive , and therefore ` yt ` does not perform any antialiasing of cutting - plane images . by utilizing the same transformation and pixelization process , overlaying in - plane velocity vectors",
    "is trivially accomplished and a simple mechanism to do so is included in ` yt ` . in figure  [ fig : cutting ] we show an example image , where the inner @xmath63 of a primordial star forming region is shown , where the normal to the image plane is aligned with the angular momentum vector and where velocity vectors have been overlaid .",
    "direct ray casting through a volume enables the generation of new types of visualizations and images describing a simulation . ` yt",
    "` has the facility to generate volume renderings by a direct ray casting method .",
    "currently the implementation is implemented to run exclusively on the cpu , rather than faster hardware - based rendering mechanisms , but this also allows for clearer descriptions of the algorithms used for compositing , calculation of the transfer function , and future advances in parallelization .",
    "furthermore , it eases the task of informing volume renderings with other analysis results : for instance , halo location , angular momentum , spectral energy distributions and other derived or calculated information .",
    "the volume rendering in ` yt ` follows a relatively straightforward approach .    1 .",
    "create a set of transfer functions governing the emission and absorption in red , green , blue , @xmath40 space ( rgba ) as a function of one or more variables .",
    "( @xmath64 ) these can be functions of any field variable , weighted by independent fields , and even weighted by other evaluated transfer functions .",
    "partition all grids into non - overlapping , fully domain - tiling  bricks . \" each of these  bricks \" contains the finest available data at any location .",
    "this process itself is the most time consuming , and is referred to as a process of homogenization .",
    "3 .   generate vertex - centered data for all grids in the volume rendered domain .",
    "4 .   order the bricks from back - to - front . 5 .",
    "construct plane of rays parallel to the image plane , with initial values set to zero and located at the back of the region to be rendered .",
    "6 .   for every brick , identify which rays intersect . these are then each ` cast ' through the brick .",
    "every cell a ray intersects is sampled 5 times ( adjustable by parameter ) , and data values at each sampling point are trilinearly interpolated from the vertex - centered data .",
    "this is needed when the transfer function is composed of very thin contours which might not be picked up by a single sample of the cell .",
    "each transfer function is evaluated at each sample point .",
    "this gives us , for each channel , both emission ( @xmath9 ) and absorption ( @xmath40 ) values .",
    "3 .   the value for the pixel corresponding to the current ray is updated with new values calculated by rectangular integration over the path length : + @xmath65 + where @xmath8 and @xmath66 represent the pixel before and after passing through a sample , @xmath51 is the color ( red , green , blue ) and @xmath67 is the path length between samples .    at this point ,",
    "the final resultant plane of values is returned to the user . because this process is neutral to the colors used , and because it integrates a simplified form of the radiative transfer equation , it can be repurposed for generating simulated images from realistic input emissions and absorptions , in the absence of scattering terms .    .",
    "isocontours were placed at @xmath68 and @xmath69 @xcite.,scaledwidth=48.0% ]    in ` yt ` , volume rendering is exposed through both a simplified interface , wherein images are generated and returned .",
    "a more detailed `` camera '' interface that allows for camera paths , zooms , stereoscopic rendering and easier access to the underlying vector plane is also available .",
    "transfer functions that can automatically sample colormaps as well as one that provides off - axis line integrals are supplied , as well as a transfer function whose colors correspond to johnson filter - convolved planck emission with approximate scattering terms , as in @xcite .    by allowing for detailed control over the specification of the transfer function ,",
    "viewing angle and generation of images , volume renderings that contain a scientific narrative are easier to create .",
    "for instance , in figure  [ fig : vr_binary ] we have constructed a volume rendering of the population iii star formation simulation described in @xcite , where a collapsing metal - free halo has been found to fragment into two distinct clumps .",
    "this volume rendering has been aligned such that the normal vector to the image plane is aligned with the angular momentum vector of the two - clump system .",
    "furthermore , the isocontours visible in the image have been selected such that they coincide with transitions between chemical states in the cloud .",
    "additional volume renderings based on derived fields describing chemical and kinetic quantities could be constructed , as well .",
    "` yt ` was originally designed exclusively for analyzing data from the adaptive mesh refinement code enzo .",
    "the built - in fields were tuned to the needs of enzo analysis and the disk io mechanisms were tuned for enzo data formats .",
    "however , abstractions to the underlying representation of state variables have enabled it to be extended to work with a number of other simulation codes natively , including orion @xcite , flash @xcite , chombo @xcite and ramses .",
    "work is ongoing to add support for the art @xcite and gadget @xcite simulation codes .",
    "this cross - code support has already enabled collaboration between these communities , and it is our hope that it will act as a gateway to better development of common infrastructure for analysis of simulation outputs .      for a simulation code to be considered supported , the following requirements must be met :    * simulation - specific fluid quantities and domain information must be translated or mapped into the common yt format .",
    "this enables abstraction of the underlying quantities in a common ( typically cgs ) system . *",
    "data on disk must be mapped and localized in memory ; this enables ` yt ` to find and read data from the disk in order to present it to the user . for amr codes , this means identifying grid patches or blocks and localizing them to a region on disk . * routines for reading data must be constructed , to read either entire grid patches or subsets of those grid patches .",
    "adding support for a new code requires the implementation of a set of subclasses that govern the interface between the data on disk and the internal ` yt ` structures ; in the ` yt ` distribution this is documented and examples are provided .",
    "these data structures and io routines are compartmentalized in the ` yt ` source code .    by abstracting these three functions into code - specific routines , and ensuring a uniform set of units and fluid quantity meanings ,",
    "the interface to data ( and thus the analysis of the data ) becomes agnostic to the simulation code .",
    "the same routines for calculating the moment of inertia of a protostellar accretion disk in an orion simulation can be utilized to calculate the moment of inertia of a protostellar accretion disk in an enzo simulation .",
    "the routines for calculating the clumping factor in a ramses simulation can be used on a flash simulation .",
    "cross - code comparison of results is possible with minimal effort : not only do indepdendent research groups no longer have to reinvent identical routines for executing common analysis tasks , but they can be certain the specific details of implementations of these routines are identical .",
    "ramses is based on an octree data structure . in order to support the ramses code ( and other octree codes ) , the ` yt ` backend reads the hierarchy of cells and then conducts a process of patch coalescing . to identify patches ,",
    "we have implemented the mechanism used by enzo to create subgrid patches from cells flagged for refinement . in this algorithm , one - dimensional histograms of cell counts",
    "are first calculated along all three dimensions .",
    "these histograms are inspected for zeros and then for the strongest zero - crossings in their second derivative . at these locations , cutting planes are inserted .",
    "this process is conducted recursively until the ratio of finest cells in a region to the total number of cells in that region is greater than some efficiency factor , typically set to be 0.2 .",
    "these patches are then used as the final grid patches , allowing array operations on the enclosed cells to operate in bulk .      in order to enable analysis of the broadest possible number of simulation codes , ` yt ` supports the reading of a generic gridded data format , based on hdf5 , described in the ` yt ` documentation .",
    "this format explicitly notes conversion factors , field positions , particle positions and has mechanisms for explicitly adding new fields , where the field is named , units are described and it is explicitly included . `",
    "yt ` is able to write other formats to this highly - explicit format , enabling conversion between different simulation formats .",
    "furthermore , because this is a fully - explicit format , external codes for which native support in ` yt ` is not available can be converted to this intermediate format , where they can then be read in and analyzed in ` yt ` .",
    "even grid - based codes , wherein fluid quantities are repsented in an eulerian fashion with the fluid quantities defined in a mesh everywhere in the domain , are typically in fact hybrid codes combining both particles and mesh quantities in a single set of coupled governing equations .",
    "particles are used represent the collisionless ( dark matter , stellar ) components of the calculation , while the fluid quantities represent the gaseous component . to accommodate this ,",
    "` yt ` can read particle values as well as gridded fluid values off disk .",
    "when a particle field ( for example mass , position , velocity , age of star particles , luminosity ) is requested from a data container , ` yt ` identifies those particles that reside within the data container , loads the requested field from disk , and returns this to the user . `",
    "yt ` additionally provides particle interpolation and cloud - in - cell deposition routines , so that particles can be deposited onto grid patches and their attributes regarded as fluid , rather than discrete , quantities .    with data created by enzo and flash ,",
    "particles are associated on disk within the highest - resolution grid patch in which they reside ; this allows ` yt ` to conduct fast , on - demand loading of dark matter and star particles . for",
    "data created by orion , sink and star particles are stored in a separate , unique file , which can be read into memory and associated with data containers as necessary . for enzo data , several data container - aware routines are provided to enable very fast intra - grid selection of particles within data containers such as spheres and rectangular prisms . however , while load - balancing for fluid fields can be estimated in advance , load - balancing of particle analysis requires more care .",
    "these challenges are discussed in more detail in @xcite .",
    "particle fields can also be used as input into derived field creation .",
    "for instance , many star formation prescriptions in cosmological codes ( e.g. , * ? ? ?",
    "* ) rely on an initial mass at the time of creation of a star particle , which is then dwindled over time as the star particle feeds material back into its environment .",
    "the initial mass is therefore encoded in the combination of the age and the creation time of a star particle , and a derived field can be constructed specific to the star formation prescription to provide the initial mass of the star particles . by combining derived fields for spectral energy distributions with the particle deposition routines provided in ` yt ` ,",
    "star particles can also be used as an input to the volume rendering algorithm (   [ sec : volume_rendering ] ) .",
    "as the capabilities of supercomputers grow , the size of datasets grows as well .",
    "most standalone codes are not parallelized ; the process is time - consuming , complicated , and error - prone . therefore ,",
    "the disconnect between simulation time and data analysis time has grown ever larger . in order to meet these changing needs , ` yt ` has been modified to run in parallel on multiple independent processing units on a single dataset . specifically , utilizing the message passing interface ( * ? ? ? * hereafter mpi ) via the ` mpi4py ` python module ( * ? ? ?",
    "* ; * ? ? ?",
    "* http://mpi4py.googlecode.com/ ) , a lightweight , numpy - native wrapper that enables natural access to the c - based routines for interprocess communication , the code has been able to subdivide datasets into multiple decomposed regions that can then be analyzed independently and joined to provide a final result .",
    "a primary goal of this process has been to preserve at all times the api , such that the user can submit an unchanged serial script to a batch processing queue , and the toolkit will recognize it is being run in parallel and distribute tasks appropriately .    the tasks in ` yt ` that require parallel analysis can be divided into two broad categories : those tasks that act on data in an unordered , uncorrelated fashion ( such as weighted histograms , summations , and some bulk property calculation ) , and those tasks that act on a decomposed domain ( such as halo finding and projection ) . all objects and tasks that utilize parallel analysis exist as subclasses of ` parallelanalysisinterface ` , which provides a number of functions for load balancing , inter - process communication , domain decomposition and parallel debugging . furthermore , ` yt ` itself provides a very simple parallel debugger based on the python built - in ` pdb ` module .",
    "to parallelize unordered analysis tasks , a set of convenience functions have been implemented utilizing an initialize / finalize formalism ; this abstracts the entirety of the analysis task as a transaction . signaling the beginning and end of the analysis transaction initiates several procedures , defined by the analysis task itself , that handle the initialization of data objects and variables and that combine information across processors .",
    "these are abstracted by an underlying parallelism library , which implements several different methods useful for parallel analysis . by this means , the intrusion of parallel methods and algorithms into previously serial tasks is kept to a minimum ; invasive changes are typically not necessary to parallelize a task .",
    "this transaction follows several steps :    1 .",
    "obtain list of grids to process 2 .",
    "initialize parallelism on the object 3 .",
    "processes each grid 4 .",
    "finalize parallelism on the object    this is implemented through the python iterator protocol ; the initialization of the iterator encompasses the first two steps and the finalization of the iterator encompasses the final step .    inside the grid selection routine , ` yt ` decomposes the relevant set of grids into chunks based on the organization of the datasets on disk .",
    "implementation of the parallel analysis interface mandates that objects implement two gatekeeper functions for both initialization and finalization of the parallel process . at the end of the finalization step",
    ", the object is expected to be identical on all processors .",
    "this enables scripts to be run identically in parallel and in serial . for unordered analysis",
    ", this process results in close - to - ideal scaling with the number of processors .    in order to decompose a task across processors , a means of assigning grids to processors",
    "is required . for spatially oriented - tasks ( such as projections )",
    "this is simple and accomplished through the decomposition of some spatial domain . for unordered analysis tasks ,",
    "the clear means by which grids can be selected is through a minimization of file input overhead",
    ". the process of reading a single set of grid data from disk can be outlined as :    1 .",
    "open file 2 .",
    "seek to grid data position 3 .",
    "read data 4 .",
    "close file    for those data formats where multiple grids are written to a single file , this process can be consolidated substantially by performing multiple reads inside a single file once it has been opened .",
    "if we know the means by which the grids and fields are ordered on disk , we can simplify the seeking requirements and instead read in large sweeps across the disk . by futher pre - allocating all necessary memory ,",
    "this becomes a single operation that can be accomplished in one `` sweep '' across each file . by allocating as many grids from a single `` grid output '' file on a single processor",
    ", this procedure can be used to minimize file overhead on each processor .",
    "each of these techniques are implemented where possible .    in figure",
    "[ fig : scaling_profile ] we show the results of a strong - scaling study of conducting profiles of the final dataset from the santa fe light cone @xcite project .",
    "this dataset consists of @xmath70 computational elements .",
    "the dashed black corresponds to profiling in one dimension , and the solid line corresponds to profiling in two dimensions .",
    "overplotted in thin solid lines are the ideal scaling relationships , as calibrated to the time taken by 16 processors .",
    "we see nearly ideal strong scaling up to 128 processors , at which point overhead dominates ; we are essentially starving the processors of work at this scale .",
    "the overall time taken to conduct a profile is quite low , on one of the largest amr datasets in the published literature .",
    "we note also that the substantial speed difference between the two mechanisms of profiling , which is counter - intuitive , is a result of a difference in implementation of the histogramming method ; 1d profiles use a pure - python solution to histogramming , whereas 2d profiles use a hand - coded c routine for histogramming .",
    "future versions of ` yt ` will eliminate this bottleneck for 1d profiling and we expect to regain parity between the two methods .",
    "several tasks in ` yt ` are inherently spatial in nature , and thus must be decomposed in a spatially - aware fashion .",
    "mpi provides a means of decomposing an arbitrary region across a given number of processors . through this method",
    ", the ` parallelanalysisinterface ` provides mechanisms by which the domain can be divided into an arbitrary number of subdomains , which are then realized as individual data containers and independently processed .",
    "for instance , because of the inherently spatial nature of the adaptive projection algorithm implemented in ` yt ` , parallelization requires decomposition with respect to the image plane ( however , as noted in section [ sec : projections ] future revisions of the algorithm will allow for unordered grid projection . ) to project in parallel , the computational domain is divided such that the image plane is distributed equally among the processors ; each component of the image plane is decomposed into rectangular prisms ( ` amrregion ` instances ) along the entire line of sight .",
    "each processor is allocated a rectangular prism of dimensions @xmath71 where the axes have been rotated such that the line of sight of the projection is the third dimension , @xmath72 is constant across processors , and @xmath73 is the entire computational domain along the axis of projection . following the projection algorithm , each processor will then have a final image plane set of points , as per usual : @xmath74 but subject to the constraints that all points are contained within the rectangular prism as prescribed by the image plane decomposition . at the end of the projection step",
    "all processors join their image arrays , which are guaranteed to contain only unique points .",
    "enzo and orion utilize different file formats , but both are designed to output a single file per processor with all constituent grids computed on that processor localized to that file .",
    "both codes conduct  load balancing \" operations on the computational domain , so processors are not necessarily guaranteed to have spatially localized grids ; this results in the output format not being spatially decomposed , but rather unordered . as a result , this method of projection does not scale as well as desired , because each processor is likely to have to read grid datasets from many files . despite that , the communication overhead is essentially irrelevant , because the processors only need to communicate the end of the projection process , to share their non - overlapping final result with all other processors in the computational group .    in figure",
    "[ fig : scaling_projection ] we show the results of a strong - scaling study of adaptively projecting the same dataset as in section[sec : unordered_analysis ] .",
    "the dashed line represents a projection of the density field , whereas the solid line represents projection in the absence of disk io .",
    "clearly the algorithmic overhead dominates the cost of disk io , but we also see strong scaling between 4 and 64 processors ; at 128 processors we see deviation from this .",
    "the relatively early termination of strong scaling ( 64 processors for this dataset , but we expect this to be higher for larger datasets ) as a result of algorithmic overhead is one of the motivations behind future improvements to the projection algorithm , as discussed in section  [ sec : projections ] .",
    "however , from a pragmatic perspective , because ` yt ` creates adaptive projections , the time taken to project is a one - time investment and thus not a rate - determining step for post - processed analysis . for non - adaptive projections",
    ", the process of handling all of the data , conducting parallel reductions and outputting images must be undertaken for every chosen field of view .",
    "an outstanding problem in the analysis of large scale data is that of interfacing with disk storage ; while data can be written to disk , read back , and then analyzed in an arbitrary fashion , this process is not only slow but requires substantial intermediate disk space for a substantial quantity of data that will undergo severely reductionist analysis @xcite . to address this problem ,",
    "the typical solution is to insert analysis code , generation of derived quantities , images , and so forth , into the simulation code .",
    "however , the usual means of doing this is through either a substantial hand - written framework that attempts to account for every analysis task , or a limited framework that only handles very limited analysis tasks . `",
    "yt ` provides an explicit embedding api to enable in - line analysis .    by enabling in - line analysis ,",
    "the relative quantity of analysis output is substantially greater than that enabled by disk - mediated analysis ; the cadence of analysis tasks can be increased , leading to greater time - domain resolution . removing numerous large files dumped to disk as a prerequisite for conducting analysis and generating visualization allows for a much more favorable ratio of data to analyzed data .",
    "for example , in a typical population iii star formation simulation , such as in @xcite , the size of the data dumps can be as much as 10 gigabytes per timestep ; however , the relative amount of information that can be gleaned from these outputs is significantly smaller @xcite .",
    "using smaller data output mechanisms as well as more clever streaming methods can improve this ratio ; however , by enabling in - line analysis , images of the evolution of a collapsing population iii halo can be output at every single update of the hydrodynamical time , allowing for true `` movies '' of star formation to be produced . by allowing for the creation and exporting of radial profiles and other analytical methods ,",
    "this technique opens up vast avenues for analysis while simulations are being conducted , rather than afterward .",
    "the python / c api allows for passage of data in - memory to an instance of the python interpreter . `",
    "yt ` has been instrumented such that it can be accessed by an embedded python interpreter inside a simulation code , such that one interpreter instance exists for every mpi task . ` yt ` provides a clear api for passing the necessary geometric information from the simulation code to the analysis package . by utilizing thin wrappers around the memory",
    "in which field values and simulation data exist , the contents of the running simulation are exposed to ` yt ` and analysis can be conducted on them . while this currently works for many relatively simple tasks ,",
    "it is not currently able to decompose data spatially ; as we are constrained by the parallel nature of most domain decomposition algorithms , we attempt to avoid passing data between mpi tasks .",
    "this means if a grid resides within mpi task 1 , it will not be passed to mpi task 2 during the analysis stage .",
    "currently this mechanism for inline analysis has been exposed to enzo simulations , and we hope to extend this in the future to additional simulation codes .",
    "inline analysis will only become more important as simulations increase in size and scope , and future development in ` yt ` will make it easier , more robust , and more memory efficient . the primary mechanism by which ` yt ` will be embedded will change ; future iterations of the inline analysis interface will rely on communication between separate mpi jobs for simulation and analysis , rather than an analysis task that shares memory space with the running simulation code .",
    "this mechanism will allow asynchronous analysis tasks to be run , enabling the simulation to proceed while the user controls the data that is examined .",
    "additionally , the method for interfacing ` yt ` and simulation codes will be provided as a single c++ library that can be linked against , allowing it to be embedded by other developers .",
    "as a result of the ability to assemble complicated chains of analysis tasks from component parts , ` yt ` has accumulated a number of pre - defined analysis modules .",
    "these modules are included with the base distribution of ` yt ` and are designed to provide a number of entry points and in some cases even interact with each other . adding a new analysis module is a straightforward process ; the specifics of the application programming interface ( e.g. , the required paramters and returned values )",
    "must be documented and made available in a public - facing function , with appropriate documentation .",
    "the code for all analysis modules is required to export this api , which is then made available to users .",
    "below , we describe a selection of the most mature and broadly - useful of the analysis modules provided in the primary ` yt ` distribution . for a more complete listing",
    ", we direct interested readers to the online ` yt ` documentation .      in cosmological hydrodynamic simulations , dark matter particles and gas parcels are coupled through gravitational interaction .",
    "furthermore , dark matter dominates gravitational interaction on all but the smallest scales .",
    "dark matter particles act as a collisionless fluid , and are the first component of the simulation to collapse into identifiable structures ; as such , they can be used effectively to identify regions of structure formation .",
    "the hop algorithm @xcite is an effective and tested means of identifying collapsed dark matter halos in a simulation , and has been a part of the enzo code distribution for some time . typically to conduct halo finding",
    ", a simulation is allowed to execute to completion , an entire dataset is loaded into memory , and then the hop algorithm processes the entire domain . this process is memory - intensive , and requires that the entire dataset be loaded into a single computer .",
    "it is not inherently parallel and thus does no domain decomposition . including this code inside ` yt ` , as a means of abstracting away compilation and data access , was trivial ; however , to do so the input to hop was generalized to be an arbitrary three - dimensional data source . as a result",
    ", the hop algorithm can now be applied on subsets of the domain .",
    "each identified halo ( ` halo ` objects ) is a fully - qualified data source , which can be used throughout the rest of ` yt ` .",
    "for instance , halos can be identified by examining particle distributions , and then the constituent gas quantities can be examined or visualized .    ` yt ` provides standard hop and friends - of - friends algorithms , as well a ground - up parallel reimplementation of the hop algorithm designed to be run on very large datasets . for a deeper discussion of this implementation , see @xcite",
    ".      further analysis of halos can be performed in an automated way using ` yt ` s halo profiling tool .",
    "the halo profiler reads in a list of halos created by any halo finding procedure .",
    "the halo profiler may also be configured to run any of ` yt ` s halo finders if halo information does not yet exist .",
    "one dimensional radial profiles and projections of user - specified fields are then made for each halo in the list .",
    "because halos are typically quite small in relation to the total computational domain , the halo profiler runs in parallel by distributing the individual halos over the available processors .",
    "a single dataset may contain thousands or tens of thousand of halos , in which case insightful analysis often relies on the ability to extract scalar quantities from each halo , such as the virial mass and radius or parameter values for analytical models . to facilitate this",
    ", simple filtering function can be created whose only requirement is to accept a one dimensional profile object .",
    "these filter functions return true or false to indicate whether the halo meets certain criteria and may optionally also return a dictionary of scalar quantities .",
    "an unlimited number of filters can be applied during the profiling process .",
    "when profiling has completed , a list of halos that passed all of the filters is written out , including any quantities return by the filter functions .",
    "below is an example of the output from the profiling and filtering process . in this example , a filter is used to calculate virial quantities by interpolating profile data ( here radius , stellar mass , and total mass ) at the point where the halo overdensity ( also a profile field ) crosses a critical value .",
    "this filter is also configured to accept only halos with total virial mass greater than @xmath75 .",
    "note that some halos have been rejected by the filter .",
    ".... # i d   center[0 ]   center[1 ]   center[2 ]   radiusmpc   starmassmsun   totalmassmsn 0000   0.706602    0.485794    0.466725    2.838402    2.628117e+13   1.052590e+15 0002   0.939776    0.664665    0.831547    2.461491    1.962899e+13   6.714788e+14 0004   0.809778    0.101728    0.708202    2.224953    1.712548e+13   5.095553e+14 0006   0.510057    0.268133    0.057933    2.286010    1.412319e+13   5.400834e+14 0007   0.205331    0.064149    0.764243    2.169436    1.212237e+13   4.662484e+14 ....      the dark and baryonic mass of a halo is accumulated in two non - exclusive ways .",
    "matter may simply be accreted onto the halo from the surrounding medium , or multiple halos may merge together over time to form a larger single halo . because the mass accretion history drives the observable properties of the galaxy embedded in the dark matter halo ,",
    "it is important to be able to track when , and by what means , mass is added to a halo .",
    "the merger tree toolkit in ` yt ` enables the creation , analysis , and simple visualization of a merger tree for the halos in a cosmological simulation .",
    "the creation of the merger tree is fully - parallelized , and will automatically call any of the parallelized ` yt ` halo finders if the halos are not pre - identified .",
    "the output is a sqlite database , which provides a convenient and powerful way to store the halo relational data .",
    "sql databases are a common way to store data of this type .",
    "for example , it is the way that the millennium simulation @xcite merger tree data is distributed .    included in the toolkit",
    "are several convenience functions that assist the user in extracting data from the database .",
    "the merger tree can drive powerful analysis pipelines which use the many toolkits in ` yt ` to analyze the dark and baryonic matter content of the halos .",
    "there is also a function that will output a graphical representation of the merger tree in the graphviz directed graph visualization format .",
    "a two point function operates on the field values at a pair of points separated by some distance .",
    "examples include two point correlations of galaxies or structure functions , such as the rms gas velocity structure function used to study the cascade of turbulent energy @xcite .",
    "the two point function toolkit in ` yt ` is a framework that supports an unlimited number of user - defined functions , and is fully - parallelized .",
    "conceptually , the two point function toolkit is simply a mechanical base upon which a user may place any number of functions for evaluation . following a defined functional input and output stencil",
    ", the user needs only to write functions for their analyses .",
    "the toolkit handles the data input , output , and parallelism without direct involvement of the user .",
    "a two point function that runs on a small dataset on a personal computer will work on a massive dataset in parallel on a supercomputer without any modifications .",
    "both unigrid and amr datasets are supported , automatically and transparently to the user . the toolkit is highly adaptable and configurable .",
    "how many times and over what physical range the functions are evaluated is controlled by the user .",
    "the domain decomposition and level of parallelism is adjustable in an intuitive and simple way .",
    "the output are portable and efficient hdf5 files , one file per two point function evaluated , containing the raw probability distribution function ( pdf ) of the output values of each function .",
    "the pdfs can then be analyzed or integrated using several included analysis convenience functions .",
    "nearly all of the machinery of ` yt ` is designed to operate on a single simulation dataset , providing spatial analysis while ignoring the time domain .",
    "time domain analysis is often performed by embedding an analysis script within a ` for ` loop , which requires the user to work out by hand exactly which datasets from the simulation correspond to the targeted time or redshift interval .",
    "matters can be further complicated if a simulation is configured to output data based on more criteria than simply intervals of constant time .",
    "this is often the case in cosmological simulations where the user will also specify a list of redshifts at which data should be written . in the case of enzo ,",
    "redshift and time outputs follow independent naming schemes , making it difficult to construct a single , time - ordered list of dataset paths .",
    "however , in much the same way that the parameter file associated with a dataset provides all of the information necessary to contextualize the contained data , the parameter file used to initialize a simulation provides everything that is needed to understand the interrelationship of all the datasets created by that simulation .    just as a ` yt ` object ( called a ` staticoutput ` ) is generated for each distinct simulation output , a ` yt ` object called a ` timeseries ` is instantiated with the parameter file of the simulation . upon initialization",
    ", the time series object will extract from the simulation parameter file all the information required to know exactly what data has been produced , assuming the simulation has run to completion .",
    "the time series object contains an ordered list of datasets corresponding to the time interval to be analyzed .",
    "much like data containers such as spheres and regions are created with respect to a single dataset , they can also be created in relation to the time series object .",
    "these time series data containers can be operated on in the same way as has already been described , except that in this case any analysis is performed sequentially on each dataset encompassed by the time series object .",
    "this enables scripts to address time domain analysis in a much more straightforward fashion .",
    "conventional techniques for visualizing simulation data capture the state within the computational domain at one instance in time .",
    "however , true astronomical observations sample the universe at continually earlier epochs as they peer further away .",
    "an approximation to this is accomplished by stacking multiple datasets from different epochs of a single simulation in the line of sight such that the total comoving radial distance from end to end of the stack spans the desired redshift interval . the comoving radial distance ( @xmath76 ) , or lines of sight distance , ( see @xcite and @xcite for an explanation of this and other cosmological distance measures ) over the redshift range , @xmath77 to @xmath78 , is given by @xmath79 where @xmath80 , @xmath81 is the speed of light , @xmath82 is the hubble constant , and @xmath83 is the expansion factor , defined as @xmath84 @xmath85 , @xmath86 , and @xmath87 are the contributions to the total energy density of the universe by matter , curvature , and the cosmological constant . the user specifies the redshift of the observer and the redshift interval of the observation . the time series machinery discussed in  [ sec : time_series ] is used to make the preliminary selection of datasets appropriate for the requested redshift interval .",
    "the dataset stack is constructed moving from the upper limit of the redshift interval to the lower limit .",
    "the dataset at the redshift closest to the upper limit of the requested interval is the first added to the stack .",
    "next , the @xmath88 corresponding to the length of the simulation box is calculated .",
    "note that this @xmath88 is not constant with redshift .",
    "the next dataset added to the stack is chosen to be the one whose redshift is closest to , but no less than , ( @xmath89 ) of the last dataset in the stack .",
    "this process continues until the lower limit of the redshift range is reached .",
    "this method minimizes the number of datasets required to span a given redshift interval , but the user may specify that a smaller fraction of the total box length be used to calculate the maximum @xmath88 allowable between two datasets in the stack .",
    "two different styles of observations can be created from the above construction : `` light cone '' projections for imaging and `` light rays '' as synthetic quasar sight lines .",
    "a light cone projection exists as the combination of projections of each dataset in the stack . to make a light cone projection",
    ", the user must also specify the angular field of view and resolution of the image . as discussed previously",
    ", the comoving radial distance determines the fraction of the box in the line of sight that is used in the projection . in the plane of the image ,",
    "the width of the region sample for an image with field of view , @xmath90 , is @xmath91 $ ] , where @xmath92 is the angular size distance , expressed as @xmath93 to minimize the likelihood that the same structures are sampled more than once along the line of sight , the projection axis and the center of the projected region are chosen randomly for each dataset in the stack , taking advantage of the periodicity of the computational domain .",
    "the ` yt ` implementation of this method has been used in @xcite .",
    "although this method is not unique to ` yt ` , e.g. @xcite , certain elements of ` yt ` s projection machinery ( see  [ sec : projections ] and  [ sec : image_creation ] ) provide great advantages to this implementation .",
    "though only a fraction of the domain of each dataset in the stack is needed for projection , the full domain in the lateral directions ( but not in the line of sight ) is , in fact , projected .",
    "since a projection object has been created for the entire domain , additional light cone projections sampling unique regions of the domain can be made with no further projection required .",
    "this can greatly expedite the process of making a large number of light cone projections for statistical analysis . `",
    "yt ` has the ability to calculate the amount of common volume sample by two different light cone projections .",
    "a unique solution generator exists to find a set of random realizations that have a user - specified maximum common volume .",
    "the unique solution generator will first attempt to vary only the randomization in the lateral direction , allowing a single set of projection objects to be used more than once , before attempting a fully unique randomization .",
    "light rays rely on the same dataset stack as light cone projections , except the data object created for each dataset in the stack is an arbitrary - angle ray instead of a projection .",
    "just as with light cone projections , each ray segment has a random orientation for each dataset in the stack .",
    "a ray segment contains an array of all of the pixels intersected by the ray as well as the path length , @xmath30 , of the ray through each pixel .",
    "therefore , the column density , @xmath13 , corresponding to a physical density , @xmath94 , for an individual length element of the ray is simply @xmath95 . knowing the redshift of each dataset and the position of a point along the ray , each length element can be assigned a unique redshift assuming a smooth hubble flow , allowing for the creation of synthetic spectra with properly redshifted lines",
    ".      visual inspection of simulations provides a simple method of identifying distinct hydrodynamic regions ; however , a quantitative approach must be taken to describe those regions .",
    "specifically , distinct collapsing regions can be identified by locating topologically - connected sets of cells .",
    "the nature of adaptive mesh refinement , wherein a given set of cells may be connected across grid and refinement boundaries , requires traversing grid and resolution boundaries .",
    "unfortunately , while locating connected sets inside a single - resolution grid is a straightforward but non - trivial problem in recursive programming , extending this in an efficient way to hierarchical datasets can be problematic . to that end ,",
    "the algorithm implemented in ` yt ` checks on a grid - by - grid basis , utilizing a buffer zone of cells at the grid boundary to join sets that span grid boundaries .",
    "the algorithm for identifying these sets is a recursive and iterative process .    1 .",
    "identify grid patches to be considered , such as from a sphere or rectangular prism .",
    "2 .   give unique identification numbers to all finest - level cells within the desired level set @xmath96 1 .",
    "give unique identification number to all coarse - cells in considered grid within desired level set @xmath97 2 .",
    "obtain buffer zone of one cell - width , including level set ids 3 .",
    "recursively examine all cells identified as level set members : 1 .",
    "update level set i d to be the maximum of 26 neighboring cells 2 .",
    "if current level set i d is greater than original level set i d , repeat until it is not 3 .",
    "notify all neighboring cells with level set i d less than current level set i d to re - examine neighbors and update 3 .",
    "construct relationship across grid boundaries . any level set neighboring the grid boundary is added to a",
    "`` join tree , '' composed of an old level set i d and a new level set i d .",
    "4 .   flatten join tree by ensuring all nodes are unique and do not reference any other nodes in the join tree .",
    "coalesce level sets by assigning new level set ids to those cells that are referenced in the join tree .",
    "reorder level set ids such that the largest level sets have the lowest numbers 7 .",
    "return extracted level set objects    once level sets are identified , they are split into individual data containers ( instances of ` extractedregion ` ) that are returned to the user .",
    "this presents an integrated interface for generating and analyzing topologically - connected sets of related cells .",
    "this method was used in @xcite to study fragmentation of collapsing gas clouds , specifically to examine the gravitational boundedness of these clouds and the length and density scales at which fragmentation occurs .    to determine whether or not an object is bound",
    ", we evaluate the inequality    @xmath98    where @xmath8 is the number of cells in the identified level set .",
    "the left hand side of this equation is the total kinetic energy in the object ; if desired , the internal thermal energy ( @xmath99 ) can also be added to this term .",
    "this code has been written to run either in a hand - coded c module or on the graphics processor , using nvidia s cuda framework @xcite via the pycuda @xcite package .",
    "future versions of the level set - identification algorithm will implement the method described in @xcite , which has been designed to be fast and parallelizable .",
    "development on ` yt ` is driven by the pragmatic needs of working astrophysics researchers .",
    "several clear goals need to be met in the future , particularly as the size and scope of simulation data increases .",
    "we also hope to work with other research groups to add support for the visualization and analysis of output from other popular astrophysics simulation codes such as art , gadget , pluto @xcite , and zeus - mp @xcite .",
    "the most relevant improvement for very large simulation datasets is to improve load balancing for parallel operations .",
    "as noted above , for some operations this can be accomplished by avoiding image - plane decomposition .",
    "several efforts are underway to this end .",
    "both the volume rendering and projection algorithms load balance through decomposition of the image plane , which often leads to poor work distribution .",
    "these shortcomings are being addressed algorithmically : adaptive projections will utilize a quad tree , enabling better load balancing , and volume rendering will utilize a kd - tree approach combined with intermediate image composition .",
    "however , an underlying problem with the parallelization as it stands is the global state ; each instance of a python interpreter running ` yt ` currently runs in either `` parallel '' or `` serial '' mode .",
    "future versions of the ` yt ` parallel analysis interface will allow this to be toggled based on the task under consideration , as well as more convenience functions for distributing work tasks between processors  for instance , scatter / gather operations on halos .    improvements to the communication mechanisms for parallel analysis in ` yt ` will be necessary as _ in situ _ analysis grows more pervasive in large calculations . _ in situ",
    "_ analysis is challenging as it must necessarily proceed asynchronously with the simulation ; this will require careful data transport between ` yt ` and the simulation code .",
    "abstracting and isolating the engine that drives this communication will be necessary to enable ` yt ` to be embedded in simulation codes other than enzo .    with the widespread deployment of graphics processing units ( gpus ) and other accelerators to supercomputing centers",
    ", we will explore using them for fast numerical computation . the primary support for gpus in python",
    "is to enable dynamic cuda or opencl @xcite kernel compilation as well as transparent hosting of arrays in gpu memory ( e.g. , see * ? ? ?",
    "these hosted arrays implement many , if not all , numpy array operations and could be used as a drop - in replacement in ` yt ` .",
    "this could provide a working mechanism for many numeric calculations to be conducted in parallel on the gpu . in order to ensure that offloading computation from the cpu to the gpu is effective",
    ", the entire ` yt ` code base will have to be audited to avoid unnecessary copying of arrays and to ensure that as many array operations as possible are conducted in - place .",
    "these particular `` hot spots '' provide minimum overhead in standard cpu computing , but could be extremely detrimental or even cause difficult - to - debug failures in a mixed cpu / gpu environment .",
    "furthermore , ensuring that mixed - mode operation is robust and reliable will be a difficult goal to reach , particularly as ` yt ` must support both cpu and cpu+gpu computation modes .",
    "we are optimistic about exploring mixed - mode operation in the future , but ensuring its reliability and robustness will be challenging .",
    "an additional concern is that cuda is currently a proprietary standard , and the development of the open standard opencl is not as fast - paced .    at many supercomputing centers , toolkits for constructing graphical user interfaces",
    "are not available or are extremely difficult to build and install .",
    "this greatly reduces the utility of creating a traditional gui . to circumvent this limitation we will be providing a fully - integrated gui for ` yt ` written in html and javascript and served by a webserver running inside ` yt ` itself . rather than a large , bulky framework within which operations could be constructed and executed",
    ", this gui will present a simple interactive interpreter that can be accessed through a web browser .",
    "this hosted interpreter would be aware of the hosting web page , and it would dynamically create user interface widgets as well as enable the inline display of newly - created images . as this requires no server - side libraries or widgets , and as python itself provides all of the necessary tools on top of which this type of gui could be built , we anticipate that this will be far more maintainable and straightforward than a traditional gui .",
    "a user will create a new server on - demand on a supercomputing center login node and connect to it through an ssh tunnel from a local machine such as a laptop .",
    "remote analysis and visualization will be guided and driven through the locally - rendered web page , with results and images passed back asynchronously and displayed inline in the same web page .",
    "the ` yt ` project is fully free and open source software , with no dependencies on external code that is not also free and open source software .",
    "the development process occurs completely in the open at http://yt.enzotools.org/ , with publicly - accessible source control systems , bug tracking , mailing lists , and regression tests . building",
    "a community of users has been a priority of the ` yt ` development team , both to encourage collaboration and to solicit contributions from new developers ; both the user and developer communities are highly distributed around the world . ` yt ` provides both online and downloadable documentation , covering introductions to the code , narrative discussion of analysis mechanisms and modules , and generated documentation covering the data structures and functions provided by ` yt ` s scripting interface .",
    "a downloadable cookbook provides scripts for many common end - to - end analysis tasks , all of which provide example images .",
    "the ` yt ` source code comes with a developers guide , a list of project ideas , and suggestions for how to get started . `",
    "yt ` is developed using mercurial , a distributed version control system that enables local versioned development and encourages users to make and contribute changes upstream .",
    "a number of additional pieces of infrastructure assist with community engagement . ` yt ` provides a number of user - friendly interfaces to assist with debugging , such as a `` pastebin '' that can be accessed programmatically .",
    "this allows crash reports to be sent upstream if desired , as well as allowing users to pass around snippets of code from the command line , mediated by the ` yt ` project server . in the summer of 2010",
    "a ` yt ` users developers workshop was held in conjunction with the first enzo users workshop at the university of california , san diego .    in the early days of computational astrophysics , it was common for researchers to be intimately familiar with the simulation code they used to simulate and study astrophysical phenomena . as both computers and simulation codes have increased in scope and complexity , however , it is now much more common for groups of researchers to collaborate on the development of a simulation code , which is then made publicly available and utilized by a much larger community of less computationally - savvy astrophysicists .",
    "this transition requires the development of complementary , community - developed analysis and visualization packages , as well .",
    "we have presented one such analysis package , ` yt ` , which is designed to be applicable to multiple simulation codes and to operate based on physically - relevant quantities .",
    "this abstraction of the underlying platform enables not only sophisticated examination and visualization of simulation data , but also cross - code verification and validation of simulation results .",
    "the creation of a freely available , publicly inspectable platform for simulation analysis allows the community to disentangle the coding process from the scientific process .",
    "simultaneously , by making this platform public , inspectable and freely available , it can be openly improved and verified . the availability and relatively approachable nature of ` yt ` , in addition to the inclusion of many simple analysis tasks , reduces the barrier to entry for young scientists .",
    "rather than worrying about the differences between enzo and flash hierarchy formats , or row versus column ordering , or hdf4 versus hdf5 versus unformatted fortran data formats , researchers can focus on understanding and exploring their data . more generally , however , by orienting the development of an analysis framework as a community project , the fragmentation of methods and mechanisms for astrophysical data analysis is greatly inhibited .",
    "future generations of simulations and simulation codes will not only benefit from this collaboration , but they will require it .",
    "m.j.t .  acknowledges support by nasa atfp grant nnx08ah26 g , nsf ast-0807312 , nsf ast-0807075 , as well as the hospitality of the kavli institute for particle astrophysics and cosmology , the kavli institute for theoretical physics ( during the program `` star formation throughout cosmic time '' ) and the university of california high - performance astro - computing center ( during the 2010 international summer school on astrocomputing program ) .",
    "b.d.s  acknowledges support by nasa grants atfp nnx09-ad80 g and nnz07-ag77 g and nsf grants ast-0707474 and ast-0908199",
    ". j.s.o .  acknowledges support by nsf grant ast09 - 08553 .",
    "s.s .  acknowledges support by nsf grants ast-0708960 and ast-0808184 .",
    ".  has been supported by nsf grant ast-0807215 and a doe computational science graduate fellowship under grant number de - fg02 - 97er25308 .",
    "we thank greg bryan , david collison , ralf kaehler , christopher moody , brian oshea , joel primack and john wise for their continued support and assistance developing ` yt ` .",
    "we would like to thank stella offner , ji - hoon kim , john zuhone , and oliver hahn for providing data , helpful comments , and assistance with orion , enzo , flash , and ramses , respectively .",
    "we thank the ` yt ` community for their support and bug reports over the last four years .",
    "additional thanks to lisandro dalcn and the numpy and python communities for creating such excellent tools for scientific analysis .",
    "portions of ` yt ` were developed under the auspices of the national nuclear security administration of the us department of energy at los alamos national laboratory under contract no .",
    "de - ac52 - 06na25396 , supported by doe ldrd grants 20051325prd4 and 20050031dr . `",
    "yt ` has additionally benefited from the development supported by the nsf career award ast-0239709 from the national science foundation , the scaling study presented in this work was conducted on the triton resource ( http://tritonresource.sdsc.edu/ ) at the san diego supercomputer center .",
    "we also thank the anonymous referee for several helpful suggestions and comments .                                          , w.  a. & mandel , e. 2003 , in astronomical society of the pacific conference series , vol .",
    "295 , astronomical data analysis software and systems xii , ed .",
    "h.  e.  payne , r.  i.  jedrzejewski , & r.  n.  hook , 489+                                        offner , s. , klein , r. i. , mckee , c.  f. , & chakrabarti , s.  2008 , `` radiative transfer simulations : low - mass cores , disks , and protostars '' , new light on young stars : spitzer s view of circumstellar disks , pasadena , ca .                          ,",
    "v. , white , s.  d.  m. , jenkins , a. , frenk , c.  s. , yoshida , n. , gao , l. , navarro , j. , thacker , r. , croton , d. , helly , j. , peacock , j.  a. , cole , s. , thomas , p. , couchman , h. , evrard , a. , colberg , j. , & pearce , f. 2005 , , 435 , 629          weber , g.  h. , ahern , s. , bethel , e.  w. , borovikov , s. , childs , h.  r. , deines , e. , garth , c. , hagen , h. , hamann , b. , joy , k.  i. , martin , d. , meredith , j. , prabhat , pugmire , d. , rbel , o. , van  straalen , b. , & wu , k. 2010 , in numerical modeling of space plasma flows : astronum-2009 ( astronomical society of the pacific conference series ) , lbnl-3185e . to appear"
  ],
  "abstract_text": [
    "<S> the analysis of complex multiphysics astrophysical simulations presents a unique and rapidly growing set of challenges : reproducibility , parallelization , and vast increases in data size and complexity chief among them . in order to meet these challenges , and in order to open up new avenues for collaboration between users of multiple simulation platforms , we present ` yt ` , an open source , community - developed astrophysical analysis and visualization toolkit . analysis and visualization with ` yt ` are oriented around physically relevant quantities rather than quantities native to astrophysical simulation codes . while originally designed for handling enzo s structure adaptive mesh refinement ( amr ) data , ` yt ` has been extended to work with several different simulation methods and simulation codes including orion , ramses , and flash . </S>",
    "<S> we report on its methods for reading , handling , and visualizing data , including projections , multivariate volume rendering , multi - dimensional histograms , halo finding , light cone generation and topologically - connected isocontour identification . </S>",
    "<S> furthermore , we discuss the underlying algorithms ` yt ` uses for processing and visualizing data , and its mechanisms for parallelization of analysis tasks . </S>"
  ]
}