{
  "article_text": [
    "temporal data mining is concerned with finitely many useful patterns in sequential ( symbolic ) data streams @xcite .",
    "frequent episode discovery , first introduced in @xcite , is a popular framework for mining patterns from sequential data .",
    "the framework has been successfully used in many application domains , e.g. , analysis of alarm sequences in telecommunication networks @xcite , root cause diagnostics from faults log data in manufacturing @xcite , user - behavior prediction from web interaction logs @xcite , inferring functional connectivity from multi - neuronal spike train data @xcite , relating financial events and stock trends @xcite , protein sequence classification @xcite , intrusion detection @xcite , text mining @xcite , seismic data analysis @xcite etc .",
    "the data in this framework is a single long stream of events , where each event is described by a symbolic event - type from a finite alphabet and the time of occurrence of the event .",
    "the patterns of interest are termed episodes . informally ,",
    "an episode is a short ordered sequence of event types , and a _ frequent _ episode is one that occurs often enough in the given data sequence .",
    "discovering frequent episodes is a good way to unearth temporal correlations in the data .",
    "given a user - defined frequency threshold , the task is to efficiently obtain all frequent episodes in the data sequence .    an important design choice in frequent episode discovery is the definition of frequency of episodes .",
    "intuitively any frequency should capture the notion of the episode occurring many times in the data and , at the same time , should have an efficient algorithm for computing the same .",
    "there are many ways to define frequency and this has given rise to different algorithms for frequent episode discovery @xcite .",
    "in the original framework of @xcite , frequency was defined as the number of fixed - width sliding windows over the data that contain at least one occurrence of the episode .",
    "another notion for frequency is based on the number of _ minimal _ occurrences @xcite .",
    "two frequency definitions called _ head frequency _ and _ total frequency _ are proposed in @xcite in order to overcome some limitations of the windows - based frequency of @xcite . in @xcite ,",
    "two more frequency definitions for episodes were proposed , based on certain specialized sets of occurrences of episodes in the data .",
    "many of the algorithms , such as the winepi of @xcite and the occurrences - based frequency counting algorithms of @xcite , employ finite state automata as the basic building blocks for recognizing occurrences of episodes in the data sequence .",
    "an automata - based counting scheme for minimal occurrences has also been proposed in @xcite .    the multiplicity of frequency definitions and the associated algorithms for frequent episode discovery makes it difficult to compare the different methods . in this paper , we present a unified view of algorithms for frequent episode discovery under all the various frequency definitions .",
    "we present a generic automata - based algorithm for obtaining frequencies of a set of episodes and show that all the currently available algorithms can be obtained as special cases of this method .",
    "this viewpoint helps in obtaining useful insights regarding the kinds of occurrences tracked by the different algorithms .",
    "the framework also aids in deriving proofs of correctness for the various counting algorithms , many of which are not currently available in literature .",
    "our framework also helps in understanding the anti - monotonicity conditions satisfied by different frequencies which is needed for the candidate generation step .",
    "our general view can also help in generalizing current algorithms , which can discover only serial or parallel episodes , to the case of episodes with general partial orders and we briefly comment on this in our conclusions .",
    "the paper is organized as follows .",
    "[ sec : overview ] gives an overview of the episode framework and explains all the currently used frequencies in literature .",
    "[ sec : algorithms ] presents our generic algorithm and shows that all current counting techniques for these various frequencies can be derived as special cases .",
    "[ sec : proof - of - correctness ] gives proofs of correctness for the various counting algorithms utilizing this unified framework .",
    "[ sec : candgen ] discusses the candidate generation step for all these frequencies . in sec .",
    "[ sec : discussion ] we provide some discussion and concluding remarks .",
    "in this section we briefly review the framework of frequent episode discovery @xcite .",
    "the data , referred to as an _ event sequence _",
    ", is denoted by @xmath0 @xmath1 @xmath2 , where each pair @xmath3 represents an _ event _ , and the number of events in the event sequence is @xmath4 .",
    "each @xmath5 is a symbol ( or _ event - type _ ) from a finite alphabet , @xmath6 , and @xmath7 is a positive integer representing the time of occurrence of the @xmath8 event .",
    "the sequence is ordered so that , @xmath9 for all @xmath10 .",
    "the following is an example event sequence with 10 events : @xmath11 an @xmath12-node episode , @xmath13 , is defined as a triple , @xmath14 , where @xmath15 , is a collection of @xmath12 nodes , @xmath16 is a partial order on @xmath17 and @xmath18 is a map that associates each node in @xmath13 with an event type from @xmath6 .",
    "thus an episode is a ( typically small ) collection of event - types along with an associated partial order .",
    "when the order @xmath16 is total , @xmath13 is called a serial episode , and when the order is empty , @xmath13 is called a parallel episode . in this paper , we restrict our attention to serial episodes . without loss of generality",
    ", we can now assume that the total order on the nodes of @xmath13 is given by @xmath19 .",
    "for example , consider a 3-node episode @xmath20 , @xmath21 , @xmath22 , @xmath23 , with @xmath24 .",
    "we denote such an episode by @xmath25 .",
    "an occurrence of episode @xmath13 in an event sequence @xmath26 is a map @xmath27 such that @xmath28 for all @xmath29 , and for all @xmath30 with @xmath31 we have @xmath32 . in the example event sequence @xmath33",
    ", the events @xmath34 , @xmath35 and @xmath36 constitute an occurrence of @xmath37 while @xmath35 , @xmath38 and @xmath36 do not .",
    "we use @xmath39 $ ] to refer to the @xmath40 event - type in @xmath13 .",
    "this way , an @xmath12-node episode @xmath13 can be represented using @xmath41 { \\ensuremath{\\rightarrow}}\\alpha[2 ] { \\ensuremath{\\rightarrow}}\\ldots { \\ensuremath{\\rightarrow}}\\alpha[n])$ ] .",
    "an episode @xmath42 is said to be a _",
    "subepisode _ of @xmath13 ( denoted @xmath43 ) if all the event - types in @xmath42 also appear in @xmath13 , and if their order in @xmath42 is same as that in @xmath13 .",
    "for example , @xmath44 is a 2-node subepisode of the episode @xmath37 while @xmath45 is not .",
    "the _ frequency _ of an episode is some measure of how often it occurs in the event sequence .",
    "a frequent episode is one whose frequency exceeds a user - defined threshold .",
    "the task in frequent episode discovery is to find all frequent episodes .",
    "given an occurrence @xmath46 of an @xmath12-node episode @xmath13 , @xmath47 is called the _ span _ of the occurrence . in many applications , one may want to consider only those occurrences whose span is below some user - chosen limit .",
    "( this is because , occurrences constituted by events that are widely separated in time may not represent any underlying causative influences ) .",
    "we call any such constraint on span as an _ expiry - time constraint_. the constraint is specified by a threshold , @xmath48 , such that occurrences of episodes whose span is greater than @xmath48 are not considered while counting the frequency",
    ".    one popular approach to frequent episode discovery is to use an apriori - style level - wise procedure . at level @xmath49 of the procedure , a ` candidate generation '",
    "step combines frequent episodes of size @xmath50 to build candidates ( or potential frequent episodes ) of size @xmath49 using some kind of anti - monotonicity property ( e.g.  frequency of an episode can not exceed frequency of any of its subepisodes ) .",
    "the second step at level @xmath49 is called ` frequency counting ' in which , the algorithm counts or computes the frequencies of the candidates and determines which of them are frequent .",
    "there are many ways to define the frequency of an episode .",
    "intuitively , any definition must capture some notion of how often the episode occurs in the data .",
    "it must also admit an efficient algorithm to obtain the frequencies for a set of episodes .",
    "further , to be able to apply a level - wise procedure , we need the frequency definition to satisfy some anti - monotonicity criterion . additionally , we would also like the frequency definition to be conducive to statistical significance analysis .    in this section ,",
    "we discuss various frequency definitions that have been proposed in literature .",
    "( recall that the data is an event sequence , @xmath51 ) .",
    "[ def : windowsbased ] @xcite a window on an event sequence , @xmath26 , is a time interval @xmath52 $ ] , where @xmath53 and @xmath54 are positive integers such that @xmath55 and @xmath56 . the _ window width _ of @xmath52 $ ] is given by @xmath57 .",
    "given a user - defined window width @xmath48 , the * windows - based frequency * of @xmath13 is the number of windows of width @xmath48 which contain at least one occurrence of @xmath13 .",
    "for example , in the event sequence ( [ eq : example - sequence ] ) , there are @xmath58 windows with window width @xmath58 which contain an occurrence of @xmath37 .",
    "@xcite the time - window of an occurrence , @xmath46 , of @xmath13 is given by @xmath59 $ ] .",
    "a _ minimal window _ of @xmath13 is a time - window which contains an occurrence of @xmath13 , such that no proper sub - window of it contains an occurrence of @xmath13 .",
    "an occurrence in a minimal window is called a minimal occurrence .",
    "the * minimal occurrences - based frequency * of @xmath13 in @xmath26 ( denoted @xmath60 ) is defined as the number of minimal windows of @xmath13 in @xmath26 .",
    "[ def : minimal ]    in the example sequence ( [ eq : example - sequence ] ) there are 3 minimal windows of @xmath37 : @xmath61 $ ] , @xmath62 $ ] and @xmath63 $ ] .",
    "@xcite given a window - width @xmath49 , the * head frequency * of @xmath13 is the number of windows of width @xmath49 which contain an occurrence of @xmath13 starting at the left - end of the window and is denoted as @xmath64 .",
    "[ def : head ]    @xcite given a window width @xmath49 , the * total frequency * of @xmath13 , denoted as @xmath65 , is defined as follows .",
    "@xmath66 [ def : total ]    for a window - width of @xmath67 , the head frequency @xmath68 of @xmath69 in ( [ eq : example - sequence ] ) is @xmath70 .",
    "the total frequency of @xmath71 , @xmath72 , in ( [ eq : example - sequence ] ) is @xmath73 because the head frequency of @xmath74 in ( [ eq : example - sequence ] ) is @xmath73 .",
    "@xcite two occurrences @xmath75 and @xmath76 of @xmath13 are said to be _ non - overlapped _ if either @xmath77 or @xmath78 .",
    "a set of occurrences is said to be non - overlapped if every pair of occurrences in the set is non - overlapped .",
    "a set @xmath79 , of non - overlapped occurrences of @xmath13 in @xmath26 is _ maximal _ if @xmath80 , where @xmath81 is any other set of non - overlapped occurrences of @xmath13 in @xmath26 .",
    "the * non - overlapped frequency * of @xmath13 in @xmath26 ( denoted as @xmath82 ) is defined as the cardinality of a maximal non - overlapped set of occurrences of @xmath13 in @xmath26 .",
    "[ def : nonoverlapped ]    two occurrences are non - overlapped if no event of one occurrence appears in between events of the other .",
    "the notion of a maximal non - overlapped set is needed since there can be many sets of non - overlapped occurrences of an episode with different cardinality@xcite .",
    "the non - overlapped frequency of @xmath71 in ( [ eq : example - sequence ] ) is @xmath83 .",
    "a maximal set of non - overlapped occurrences is @xmath84 and @xmath85 .",
    "@xcite two occurrences @xmath75 and @xmath76 of @xmath13 are said to be _ non - interleaved _ if either @xmath86 or @xmath87 .",
    "a set of occurrences @xmath79 of @xmath13 in @xmath26 is _ non - interleaved _ if every pair of occurrences in the set is non - interleaved .",
    "a set @xmath79 of non - interleaved occurrences of @xmath13 in @xmath26 is * maximal * if @xmath80 , where @xmath81 is any other set of non - interleaved occurrences of @xmath13 in @xmath26 .",
    "the * non - interleaved frequency * of @xmath13 in @xmath26 ( denoted as @xmath88 ) is defined as the cardinality of a maximal non - interleaved set of occurrences of @xmath13 in @xmath26 .",
    "[ def : noninterleaved ]    the occurrences @xmath89 and @xmath90 are non - interleaved ( though overlapped ) occurrences of @xmath37 in @xmath26 .",
    "together with @xmath91 , these two occurrences form a set of maximal non - interleaved occurrences of @xmath37 in ( [ eq : example - sequence ] ) and thus @xmath92 .",
    "@xcite two occurrences @xmath75 and @xmath76 of @xmath13 are said to be _ distinct _ if they do not share any two events .",
    "a set of occurrences is distinct if every pair of occurrences in it is distinct .",
    "a set @xmath79 of distinct occurrences of @xmath13 in @xmath26 is * maximal * if @xmath80 , where @xmath81 is any other set of distinct occurrences of @xmath13 in @xmath26 .",
    "the * distinct occurrences - based frequency * of @xmath13 in @xmath26 ( denoted as @xmath93 ) is the cardinality of a maximal distinct set of occurrences of @xmath13 in @xmath26 .",
    "[ def : distinct ]    the three occurrences that constituted the maximal non - interleaved occurrences of @xmath37 in ( [ eq : example - sequence ] ) also form a set of maximal distinct occurrences in ( [ eq : example - sequence ] ) .",
    "+ the first frequency proposed in the literature was the windows based count @xcite and was originally applied for analyzing alarms in a telecommunication network .",
    "it uses an automata based algorithm called winepi for counting .",
    "candidate generation exploits the anti - monotonicity property that all subepisodes are at least as frequent as the parent episode .",
    "a statistical significance test for frequent episodes based on the windows - based count was proposed in @xcite .",
    "there is also an algorithm for discovering frequent episodes with a maximum - gap constraint under the windows - based count @xcite .",
    "the minimal windows based frequency and a level - wise procedure called minepi to track minimal windows were also proposed in @xcite .",
    "this algorithm has high space complexity since the exact locations of all the minimal windows of the various episodes are kept in memory .",
    "nevertheless , it is useful in rule generation .",
    "an efficient automata - based scheme for counting the number of minimal windows ( along with a proof of correctness ) was proposed in @xcite .",
    "the problem of statistical significance of minimal windows was recently addressed in @xcite .",
    "an algorithm for extracting rules under a maximal gap constraint and based on minimal occurrences has been proposed in @xcite .    in the windows - based frequency ,",
    "the window width is essentially an expiry - time constraint ( an upper - bound on the span of the episodes ) .",
    "however , if the span of an occurrence is much smaller than the window width , then its frequency is artificially inflated because the same occurrence will be found in several successive sliding windows .",
    "the head frequency measure , proposed in @xcite , is a variant of the windows - based count intended to overcome this problem .",
    "based on the notion of head frequency , @xcite presents two algorithms minepi+ and emma .",
    "they also point out how head frequency can be a better choice for rule generation compared to the windows - based or the minimal windows - based counts . under the head frequency count , however , there can be episodes whose frequency is higher than some of their subepisodes ( see @xcite for details ) . to circumvent this ,",
    "@xcite propose the idea of total frequency .",
    "currently , there is no statistical significance analysis based on head frequency or total frequency .",
    "an efficient automata - based counting algorithm under the non - overlapped frequency measure ( along with a proof of correctness ) can be found in @xcite . a statistical significance test for the same is proposed in @xcite .",
    "however , the algorithm in @xcite does not handle any expiry - time constraints .",
    "an efficient automata - based algorithm for counting non - overlapped occurrences under expiry - time constraint was proposed in @xcite though this has higher time and space complexity than the algorithm in @xcite .",
    "no proofs of correctness or statistical significance analysis are available for non - overlapped occurrences under an expiry - time constraint .",
    "algorithms for frequent episode discovery under the non - interleaved frequency can be found in @xcite .",
    "no proofs of correctness are available for these algorithms .",
    "another frequency measure we discuss in this paper is based on the idea of distinct occurrences .",
    "no algorithms are available for counting frequencies under this measure .",
    "the unified view of automata - based counting that we will present in this paper can be readily used to design algorithms for counting distinct occurrences of episodes .",
    "in this section , we present a generic algorithm for obtaining frequencies of episodes under the different frequency definitions listed in sec .  [",
    "sec : frequencies - of - episodes ] .",
    "the basic ingredient in all the algorithms is a simple finite state automaton ( fsa ) that is used to recognize ( or track ) an episode s occurrences in the event sequence . the fsa for recognizing occurrences of @xmath37 is illustrated in fig .  [ fig : automaton ] . in general",
    ", an fsa for an @xmath12-node serial episode @xmath94{\\ensuremath{\\rightarrow}}\\alpha[2]{\\ensuremath{\\rightarrow}}\\dots{\\ensuremath{\\rightarrow}}\\alpha[n]$ ] has @xmath95 states .",
    "the first @xmath12 states are represented by a pair @xmath96)$ ] , @xmath97 .",
    "the @xmath98 state is @xmath99 where @xmath100 is a null symbol .",
    "intuitively , if the fsa is in state @xmath101)$ ] , it means that the fsa has already seen the first @xmath102 event types of this episode and is now waiting for @xmath103 $ ] ; if we now encounter an event of type @xmath103 $ ] in the data it can accept it ( that is , it can transit to its next state ) .",
    "the start ( first ) state of the fsa is @xmath104)$ ] .",
    "the @xmath98 state is the accepting state because when an automaton reaches this state , a full occurrence of the episode is tracked .",
    "\\(0 ) @xmath105 ; ( 1 ) [ right = of 0 ] @xmath106 ; ( 2 ) [ right = of 1 ] @xmath107 ; ( 3 ) [ right = of 2 ] @xmath108 ; ( 0 ) edge node @xmath109 ( 1 ) edge [ loop above ] node @xmath6\\@xmath110 ( ) ( 1 ) edge node @xmath111 ( 2 ) edge [ loop above ] node @xmath6\\@xmath112 ( ) ( 2 ) edge node @xmath113 ( 3 ) edge [ loop above ] node @xmath6\\@xmath114 ( ) ( 3 ) edge [ loop above ] node @xmath6 ( ) ;    we first explain how these fsa can be used for obtaining all the different types of frequencies of episodes before presenting the generic algorithm .",
    "while discussing various algorithms , we represent any occurrence @xmath46 by @xmath115 $ ] , which is the vector of times of the events that constitute the occurrence . for the discussion of all algorithms in this section , we consider the example of tracking occurrences of @xmath116 in the data stream @xmath117 given by    @xmath118    there is a ` natural ' lexicographic order on the set of * all * occurrences @xmath119 , of any episode , @xmath13 , defined below .",
    "this is a total order on @xmath119 and it will be useful in our analysis .",
    "the lexicographic ordering , @xmath120 , on the set of all occurrences of @xmath13 is defined as follows : @xmath121 if the least @xmath122 for which @xmath123 is such that @xmath124 .",
    "the simplest of all automata - based frequency counting algorithms is the one for counting non - overlapped occurrences @xcite which uses only @xmath125-automata per episode .",
    "( we call it algorithm no here ) . at the start , one automaton for each of the candidate episodes is initialized in its start state .",
    "each of the automata make a state transition as soon as a relevant event - type appears in the data stream .",
    "whenever an automaton reaches its final state , frequency of the corresponding episode is incremented , the automaton is removed from the system and a fresh automaton for the episode is initialized in the start state .",
    "as is easy to see , this method will count non - overlapped occurrences of episodes . under the no algorithm",
    ", we denote the occurrence tracked by the @xmath40 automaton initialized for @xmath13 as @xmath126 .    in our example , algorithm no tracks the following two occurrences of the episode @xmath13 : ( i ) @xmath127 $ ] and ( ii ) @xmath128 $ ] , and the corresponding non - overlapped frequency is @xmath83 .    in this paper",
    "we introduce the concept of _ earliest transiting _ occurrence of an episode which is useful for analyzing different frequency counting algorithms .    _",
    "an occurrence @xmath46 of @xmath13 is called earliest transiting if @xmath129 is the first occurrence of @xmath39 $ ] after @xmath130 @xmath131 .",
    "[ def : earliest transiting ] _",
    "it is easy to see that all occurrences tracked by algorithm no are earliest transiting .",
    "let @xmath132 denote the set of all earliest transiting occurrences of a given episode .",
    "we denote the @xmath40 occurrence ( as per the lexicographic ordering of occurrences ) in @xmath132 as @xmath133 .",
    "there are 6 earliest transiting occurrences of @xmath13 in @xmath117 .",
    "they are @xmath134 $ ] , @xmath135 $ ] , @xmath136 $ ] , @xmath137 $ ] , @xmath138 $ ] and @xmath139 $ ] .",
    "the earliest transiting occurrences tracked by the no algorithm are @xmath140 and @xmath141 .    while the algorithm no is very simple and efficient , it can not handle any expiry - time constraint .",
    "recall that the expiry - time constraint specifies an upper - bound , @xmath48 , on the span of any occurrence that is counted .",
    "suppose we want to count with @xmath142 .",
    "both the occurrences tracked by no have spans greater than @xmath143 and hence the resulting frequency count would be zero . however , @xmath144 is an occurrence which satisfies the expiry time constraint .",
    "algorithm no can not track @xmath144 because it uses only one automaton per episode and the automaton has to make a state transition as soon as the relevant event - type appears in the data . to overcome this limitation ,",
    "the algorithm can be modified so that a new automaton is initialized in the start state , whenever an existing automaton moves out of its start state .",
    "all automata make state transitions as soon as they are possible .",
    "each such automaton would track an earliest transiting occurrence . in this process",
    ", two automata may reach the same state . in our example , after seeing @xmath145 , the second and third automata to be initialized for @xmath13 , would be waiting in the same state ( ready to accept the next @xmath111 in the data ) .",
    "clearly , both automata will make state transitions on the same events from now on and so we need to keep only one of them .",
    "we retain the newer or most recently initialized automaton ( in this case , the third automaton ) since the span of the occurrence tracked by it would be smaller . when an automaton reaches its final state , if the span of the occurrence tracked by it is less than @xmath48 , then the corresponding frequency is incremented and all automata of the episode except the one waiting in the start state are retired .",
    "( this ensures we are tracking only non - overlapped occurrences )",
    ". when the occurrence tracked by the automaton that reaches the final state fails the expiry constraint , we just retire the current automaton ; any other automata for the episode will continue to accept events . under this modified algorithm , in @xmath117 , the first automaton that reaches its final state tracks @xmath146 which violates the expiry time constraint of @xmath147 .",
    "so , we drop only this automaton .",
    "the next automaton that reaches its final state tracks @xmath144 .",
    "this occurrence has span less than @xmath147 .",
    "hence we increment the corresponding frequency count and retire all current automata for this episode .",
    "since there are no other occurrences non - overlapped with @xmath144 , the final frequency would be 1 .",
    "we denote this algorithm for counting the non - overlapped occurrences under an expiry - time constraint as no - x .",
    "the occurrences tracked by both no and no - x would be earliest transiting .    note that several earliest transiting occurrences may end simultaneously .",
    "for example , in @xmath117 , @xmath148 , @xmath149 and @xmath150 all end together at @xmath151 .",
    "both @xmath152 and @xmath153 form maximal sets of non - overlapped occurrences .",
    "sometimes ( e.g. when determining the distribution of spans of occurrences for an episode ) we would like to track the _ innermost _ one among the occurrences that are ending together . in this example , this means we want to track the set of occurrences @xmath153 .",
    "this can be done by simply omitting the expiry - time check in the no - x algorithm .",
    "( that is , whenever an automaton reaches final state , irrespective of the span of the occurrence tracked by it , we increment frequency and retire all other automata except for the one in start state ) .",
    "we denote this as the no - i algorithm and this is the algorithm proposed in @xcite .    in no - i , if we only retire automata that reached their final states ( rather than retire all automata except the one in the start state ) , we have an algorithm for counting minimal occurrences ( denoted mo ) . in our example , the automata tracking @xmath150 , @xmath154 and @xmath155 are the ones that reach their final states in this algorithm .",
    "the time - windows of these occurrences constitute the set of all minimal windows of @xmath13 in @xmath117 .",
    "expiry time constraints can be incorporated by incrementing frequency only when the occurrence tracked has span less than the expiry - time threshold .",
    "the corresponding expiry - time algorithm is referred to as mo - x .",
    "the windows - based counting algorithm ( which we refer to as wb ) is also based on tracking earliest transiting occurrences .",
    "wb also uses multiple automata per episode to track minimal occurrences of episodes like in mo .",
    "the only difference lies in the way frequency is incremented .",
    "the algorithm essentially remembers , for each candidate episode , the last minimal window in which the candidate was observed .",
    "then , at each time tick , effectively , if this last minimal window lies within the current sliding window of width @xmath48 , frequency is incremented by one .",
    "this is because , an occurrence of episode @xmath13 exists in a given window @xmath156 if and only @xmath156 contains a minimal window of @xmath13 .",
    "it is easy to see that head frequency with a window - width of @xmath48 is simply the number of earliest transiting occurrences whose span is less than @xmath48 .",
    "thus we can have a head frequency counting algorithm ( referred to here as hd ) that is similar to mo - x except that when two automata reach the same state simultaneously we do not remove the older automaton .",
    "this way , hd will track all earliest transiting occurrences which satisfy an expiry time - constraint of @xmath48 . for @xmath157 and for episode",
    "@xmath13 , hd tracks @xmath146 , @xmath144 , @xmath158 and @xmath159 and returns a frequency count of @xmath70 . the total frequency count for an episode @xmath13 is the minimum of the head frequencies of all its subepisodes ( including itself ) .",
    "this can be computed as the minimum of the head frequency of @xmath13 and the total frequency of its @xmath160-suffix subepisodes which would have been computed in the previous pass over the data .",
    "( see @xcite for details ) .",
    "the head frequency counting algorithm can have high space - complexity as all the time instants at which automata make their first state transition need to be remembered .",
    "the non - interleaved frequency counting algorithm ( which we refer to as ni ) differs from the minimal occurrence algorithm in that , an automaton makes a state transition only if there is no other automaton of the same episode in the destination state . unlike the other frequency counting algorithms discussed so far , such an fsa transition policy will track occurrences which are not necessarily earliest transiting . in our example , until the event @xmath161 in the data sequence , both the minimal and non - interleaved algorithms make identical state transitions .",
    "however , on @xmath145 , ni will not allow the automaton in state @xmath162 to make a state transition as there is already an active automaton for @xmath13 in state @xmath163 which had accepted @xmath161 earlier .",
    "eventually , ni tracks the occurrences @xmath164 $ ] , @xmath165 $ ] , @xmath166 $ ] and @xmath167 $ ] .",
    "while there are no algorithms reported for counting distinct occurrences , we can construct one using the same ideas . such an algorithm ( to be called as do )",
    "differs from the one for counting minimal occurrences , in allowing multiple automata for an episode to reach the same state .",
    "however , on seeing an event @xmath3 which multiple automata can accept , only one of the automata ( the oldest among those in the same state ) is allowed to make a state transition ; the others continue to wait for future events with the same event - type as @xmath5 to make their state transitions .",
    "the set of maximal distinct occurrences of @xmath13 in @xmath117 are @xmath168 , @xmath169 $ ] , @xmath170 $ ] , @xmath171 $ ] and @xmath172 $ ] which are the ones tracked by this algorithm .",
    "we can also consider counting _ all _ occurrences of an episode even though it may be inefficient .",
    "the algorithm for counting _ all _ occurrences ( referred to as the ao ) allows all automata to make transitions whenever the appropriate events appear in the data sequence .",
    "however , at each state transition , a copy of the automaton in the earlier state is added to the set of active automata for the episode . from the above discussion",
    ", it is clear that by manipulating the fsa ( that recognize occurrences ) in different ways we get counting schemes for different frequencies .",
    "the choices to be made in different algorithms essentially concern when to initiate a new automaton in the start state , when to retire an existing automaton , when to effect a possible state transition and when ( and by how much ) to increment the frequency .",
    "we now present a unified scheme incorporating all this in _",
    "algorithm  [ algo : unified ] _ for obtaining frequencies of a set of serial episodes .",
    "this algorithm has five boolean variables , namely , transit , copy - automaton , join - automaton , increment - freq and retire - automaton .",
    "the counting algorithms for all the different frequencies are obtained from this general algorithm by suitably setting the values of these boolean variables ( either by some constants or by values calculated using the current context in the algorithm ) .",
    "tables  [ tab : transit ]  [ tab : retire - automata ] specify the choices needed to obtain the algorithms for different frequencies .",
    "( a list of all algorithms is given in table  [ tab : various - counts ] ) .",
    "as can be seen from our general algorithm , when an event type for which an automaton is waiting is encountered in the data , the the automaton can accept it only if the variable transit is true .",
    "hence for all algorithms that track earliest transiting occurrences , transit will be set to true as can be seen from table  [ tab : transit ] . for algorithms ni and",
    "do where we allow the state transition only if some condition is satisfied . the condition copy - automaton ( table  [ tab : copy - automaton ] )",
    "is for deciding whether or not to leave another automaton in the current state when an automaton is transiting to the next state . except for no and ao",
    ", we create such a copy only when the currently transiting automaton is moving out of its start state . in no",
    "we never make such a copy ( because this algorithm uses only one automaton per episode ) while in ao we need to do it for every state transition . as we have seen earlier , in some of the algorithms , when two automata for an episode reach the same state , the older automaton is removed .",
    "this is controlled by join - automaton , as given by table  [ tab : join - automaton ] .",
    "increment - frequency ( table  [ tab : increment - freq ] ) is the condition under which the frequency of an episode is incremented when an automaton reaches its final state .",
    "this increment is always done for algorithms that have no expiry time constraint or window width . for the others we increment the frequency only if the occurrence tracked satisfies the constraint .",
    "retire - automata condition ( table  [ tab : retire - automata ] ) is concerned with removal of all automata of an episode when a complete occurrence has been tracked .",
    "this condition is true only for the non - overlapped occurrences - based counting algorithms .",
    "apart from the five boolean variables explained above , our general algorithm contains one more variable , namely , inc , which decides the amount by which frequency is incremented when an automaton reaches the final state .",
    "its values for different frequency counts are listed in  table  [ tab : inc ] .",
    "for all algorithms except wb , we set @xmath173 .",
    "we now explain how frequency is incremented in wb . to count the number of sliding windows that contain at least one occurrence of the episode , whenever a new minimal occurrence enters a sliding window",
    ", we can calculate the number of consecutive windows in which this new minimal occurrence will be found in .",
    "for example , in @xmath117 , with a window - width of @xmath174 , consider the first minimal occurrence of @xmath175 , namely , the occurrence constituted by events @xmath145 , @xmath176 , @xmath177 and @xmath151 .",
    "the first sliding window in which this occurrence can be found is @xmath178 $ ] .",
    "the occurrence stays in consecutive sliding windows , until the sliding window @xmath179 $ ] .",
    "when this first minimal occurrence enters the sliding window @xmath178 $ ] , we observe that there is no other ` older ' minimal occurrence in @xmath178 $ ] , and hence , as per the _ else _ condition in _ table [ tab : inc ] _ , the @xmath180 is incremented by @xmath181 .",
    "similarly , when the second minimal occurrence enters the sliding window @xmath182 $ ] , we increment @xmath180 by @xmath183 .",
    "the third minimal occurrence ( constituted by the events @xmath184 , @xmath185 , @xmath186 and @xmath187 ) first enters the sliding window @xmath188 $ ] , with the second minimal window still occurring within this window .",
    "this third minimal occurrence remains in consecutive sliding windows until @xmath189 $ ] . as per the _ if _ condition of _ table [ tab : inc ] _ , @xmath180 is incremented by @xmath190 .",
    "we note that such an implementation of the windows - based algorithm removes the need for the @xmath191 list of @xcite which was used to store all automata whose first state transition occurred at time - tick @xmath192 .",
    "set @xmath193 of @xmath12-node serial episodes , event stream @xmath194 , @xmath195 , @xmath196 ,    frequencies of episodes in @xmath193    add automaton of @xmath13 waiting in the start state .",
    "initialize frequency of @xmath13 to zero .",
    "@xmath13=candidate associated with @xmath197 ; @xmath102 = state which @xmath197 is ready to transit into ; add copy of @xmath197 to collection of automata .",
    "transit @xmath197 to state @xmath102 retain @xmath197 and retire earlier automaton retire @xmath197 .",
    "increment frequency of @xmath13 by inc .",
    "retire all automaton of @xmath13 and create a state 0 automaton .",
    ".values taken by inc [ cols=\"^,^\",options=\"header \" , ]     [ remark:3 - 1 ] even though we included ao ( for counting all occurrences of an episode ) for sake of completeness , this is not a good frequency measure .",
    "this is mainly because it does not seem to satisfy any anti - monotonicity condition .",
    "for example , consider the data sequence @xmath198 .",
    "there are @xmath199 occurrences of @xmath200 but only 4 occurrences of each of its @xmath83-node subepisodes .",
    "also , its space complexity can be high .",
    "[ remark:3.2 ] : the quantitative relationships between the different frequency counts for a given episode can be described as follows : @xmath201 where @xmath202 denotes the frequency of an episode under ao , while @xmath203 and @xmath204 denote the corresponding head and total frequencies defined with a window - width exceeding the total time - span of the event sequence . for a large sliding window width , the head frequency @xmath203 is same as the number of earliest transiting occurrences of an episode . in general ,",
    "the inequality @xmath205 holds only for injective episodes ( an episode @xmath13 is injective if it does not contain any repeated event - types ) .",
    "all other inequalities are true for any serial episode .",
    "the first inequality is obvious .",
    "the second inequality follows directly from _ equation [ eq : total - frequency ] _ in _ definition [ def : total]_. given a set of @xmath206 maximal distinct occurrences of an episode @xmath13 in a data stream @xmath26 , one can extract that many earliest transiting occurrences of not only @xmath13 but also of all its subepisodes in @xmath26 .",
    "hence the third inequality is also true . also , it is easy to verify that a set of non - interleaved occurrences of an injective episode are also distinct , which validates the fourth inequality",
    ". we will show the correctness of the remaining two inequalities in the next section .",
    "in this section , we present proofs of correctness of the different frequency counting algorithms presented in sec .  [",
    "sec : algorithms ] ( all of which are specific instances of _ algorithm [ algo : unified ] _ ) .    in our proofs",
    ", we consider the case of event sequences with distinct occurrence - times for events .",
    "when we are not considering expiry - time constraints , the actual values of times of occurrences of different events are not really important ; only the time ordering of the events is important in deciding on the occurrences of episodes .",
    "hence , in this section we will use @xmath207 interchangeably with @xmath208 , the time of the first event in the occurrence @xmath46 and so on .",
    "modifications needed in the case of data having multiple events with the same time of occurrence , are discussed at the end of the section .",
    "first , we analyze the minimal occurrences counting algorithm ( mo ) .",
    "our proof methodology is different from the one presented in @xcite , where , the algorithm is viewed as computing a table @xmath209 $ ] , where , @xmath210 $ ] is the largest value @xmath211 such that @xmath212 contains an occurrence of @xmath213{\\ensuremath{\\rightarrow}}\\ldots \\alpha[j]$ ] , using dynamic programming .",
    "the algorithm , after processing @xmath5 , stores the @xmath40 row of this matrix .",
    "the dynamic programming recursion helps compute the @xmath40 row of this matrix from its @xmath214 row .",
    "whenever @xmath215>s[i-1,n]$ ] , the count is incremented since a new minimal occurrence is recognized .",
    "viewed from an automata perspective , the @xmath40 row of the matrix essentially stores the first state transition times of the currently active automata .",
    "our analysis of the minimal occurrence algorithm also leads to an analysis and proof for counting non - overlapped occurrences ( no and no - x ) as well .",
    "another advantage of our proof strategy is that it may be generalized to the case of episodes with general partial orders .",
    "( we briefly discuss this in section  [ sec : discussion ] ) .",
    "[ lemma : power ] suppose @xmath46 is an earliest transiting occurrence of an @xmath12-node episode @xmath13 . if @xmath216 is any general occurrence such that @xmath217 , then @xmath218 @xmath219 .",
    "this lemma follows easily from the definition of the lexicographic ordering , @xmath120 , and the definition of earliest transiting occurrence .",
    "[ remark:4 - 1 ] recall that @xmath220 is the @xmath40 earliest transiting ( et ) occurrence of an episode .",
    "thus , by definition , @xmath221 and @xmath222 whenever @xmath223 .",
    "hence , from the above lemma , we have @xmath224 for all @xmath49 and @xmath223 .",
    "in particular , we have , @xmath225 and @xmath226 , for an @xmath12-node episode .",
    "the main idea of our proof is that to find all minimal windows of an episode , it is enough to capture a certain subset of earliest transiting occurrences .",
    "[ lemma : minimal_et ] an earliest transiting ( et ) occurrence @xmath220 , of an @xmath12-node episode , is not a minimal occurrence if and only if @xmath227 .    the ` if ' part follows easily from remark  [ remark:4 - 1 ] . for",
    "the ` only if ' part , let us denote by @xmath228=[h_i^e(v_1),h_i^e(v_n)]$ ] the window of @xmath220 .",
    "given that @xmath156 is not a minimal window , we need to show that @xmath227 .",
    "since @xmath156 is not a minimal window , one of its proper sub - windows contains an occurrence , say , @xmath46 , of this episode .",
    "that means if @xmath46 starts at @xmath229 then it must end before @xmath230 .",
    "but , since @xmath220 is earliest transiting , any occurrence starting at the same event as @xmath220 can not end before @xmath220 . thus we must have @xmath231 .",
    "this means , by lemma  [ lemma : power ] , since @xmath220 is earliest transiting , we can not have @xmath232 .",
    "since the window of @xmath46 has to be contained in the window of @xmath220 , we thus have @xmath233 . by definition",
    ", @xmath234 will start at the earliest possible position after @xmath220 . since there is an occurrence starting with @xmath207 we must have @xmath235 .",
    "now , since @xmath234 is earliest transiting , it can not end after @xmath46 .",
    "thus we must have @xmath236 .",
    "also , @xmath234 can not end earlier than @xmath220 because both are earliest transiting .",
    "thus , we must have @xmath237 .",
    "this completes proof of lemma .",
    "[ remark:4 - 2 ] this lemma shows that any et occurrence @xmath220 such that @xmath238 is a minimal occurrence .",
    "the converse is also true .",
    "consider a minimal window @xmath239 $ ] .",
    "since this is a minimal window , there is an occurrence ( and hence an et occurrence ) starting at @xmath229 .",
    "denote this et occurrence by @xmath220 .",
    "we know @xmath240 because @xmath156 is a minimal window .",
    "then the next et occurrence @xmath234 has to start after @xmath229 and has to end beyond @xmath230 because @xmath156 is minimal .",
    "thus we have @xmath241 .",
    "now we are ready to prove correctness of the mo algorithm .",
    "consider _ algorithm [ algo : unified ] _ operating in the mo(minimal occurrence ) mode for tracking occurrences of an @xmath12-node episode @xmath13 .",
    "since transit is always true in the mo mode , all automata would be tracking et occurrences .",
    "since copy - automaton is true in mo mode whenever an automaton transits out of start state , we will always have an automaton in the start state .",
    "_ this , along with the fact that transit is always true , implies that the @xmath40 initialized automaton would be tracking @xmath220 , the @xmath40 et occurrence .",
    "_ let us denote by @xmath242 the @xmath40 initialized automaton .",
    "however , since join - automaton is also always true , not all automata ( initialized for this episode ) would result in incrementing the frequency ; some of them would be removed when one automaton transits into a state already occupied by some other automaton . in view of lemma  [ lemma : minimal_et ] and",
    "remark  [ remark:4 - 2 ] , if we show that the automaton @xmath242 results in increment of frequency if and only if @xmath220 , the occurrence tracked by it , is such that @xmath243 , then , the proof of correctness of mo algorithm is complete .",
    "[ lemma : minimal_algorithm ] in the mo algorithm the @xmath40 automaton that was initialized for @xmath13 , referred to as @xmath244 , contributes to the frequency count iff @xmath245 .",
    "@xmath246 the last step follows because both @xmath220 and @xmath234 are et occurrences and hence @xmath247 implies @xmath248 .",
    "conversely , we have @xmath249 the first step follows because , if @xmath244 contributes to the frequency then no automaton initialized after it would ever come to the same state occupied by it and since all occurrences tracked are earliest transiting , this must mean @xmath250 , @xmath251 .",
    "this completes proof of the lemma .",
    "another interesting observation is that if @xmath133 is minimal , then it is non - interleaved with @xmath252 .",
    "suppose @xmath133 is minimal and @xmath133 is not non - interleaved with @xmath252 .",
    "since @xmath133 is minimal , we have @xmath253 .",
    "if @xmath220 is not non - interleaved with @xmath234 , there exists a @xmath254 such that @xmath255 .",
    "thus we must have @xmath256 .",
    "but this can not be because @xmath257 is the earliest @xmath103 $ ] after @xmath258 and if it is also after @xmath259 then the fact that both @xmath220 and @xmath234 are et occurrences should mean @xmath260 which contradicts that @xmath220 is minimal .",
    "hence @xmath220 and @xmath252 are non - interleaved .",
    "thus , given the sequence of minimal windows , the earliest transiting occurrences from each of these minimal windows gives a sequence of ( same number of ) non - interleaved occurrences .",
    "this leads to @xmath261 as stated earlier in ( [ eq : all - f - relationships ] ) .",
    "the no - x algorithm can be viewed as a slight modification to the mo algorithm . as in the mo algorithm",
    ", we always have an automaton in the start state and all automata make transitions as soon as possible and when an automaton transits into a state occupied by another , the older one is removed . however , in the no - x algorithm",
    ", the increment - freq variable is true only when we have an occurrence satisfying @xmath48 constraint .",
    "hence , to start with , we look for the first minimal occurrence which satisfies the expiry time constraint and increment frequency . at this point ,",
    "( unlike in the mo algorithm ) we terminate all automata except the one in the start state since we are trying to construct a non - overlapped set of occurrences .",
    "then we look for the next earliest minimal occurrence ( which will be non - overlapped with the first one ) satisfying expiry time constraint and so on .",
    "since minimal occurrences locally have the least time span , this strategy of searching for minimal occurrences satisfying expiry time constraint in a non - overlapped fashion is quite intuitive .",
    "let @xmath262 denote the sequence of occurrences tracked by the no - x algorithm ( for an @xmath12-node episode ) .",
    "then the following property of @xmath263 is obvious .",
    "[ property : algo3  ] @xmath264 is the earliest minimal occurrence satisfying expiry time constraints .",
    "@xmath265 is the first minimal occurrence ( satisfying expiry time constraint ) that starts after @xmath266 .",
    "there is no minimal occurrence satisfying expiry time constraint which starts after @xmath267 .",
    "[ theorem : maximality non - overlap constraints ] _ @xmath263 is a maximal non - overlapped sequence satisfying expiry time constraint @xmath48 . _    consider any other set of non - overlapped occurrences satisfying expiry constraints , @xmath81 = @xmath268 such that @xmath269 .",
    "let @xmath270 then we first show @xmath271 suppose @xmath272 .",
    "consider the earliest transiting occurrence @xmath273 starting from @xmath274 .",
    "this ends at or before @xmath275 by lemma [ lemma : power ] . among all et occurrences that end at the same event as @xmath273 ,",
    "the last one ( under the lexicographic ordering ) is a minimal occurrence by lemma [ lemma : minimal_et ] .",
    "its window is contained in that of @xmath276 which satisfies the expiry time constraint .",
    "hence we have found a minimal occurrence satisfying expiry constraint ending before @xmath264 which contradicts the first statement of property [ property : algo3  ] .",
    "hence @xmath277 .",
    "now applying the same argument to the data stream starting with the first event after @xmath278 , we get @xmath279 and so on and thus can conclude @xmath280 .",
    "this shows that no other set of non - overlapped occurrences can have more number of occurrences than those in @xmath263 .",
    "hence , @xmath263 is maximal .",
    "if we choose @xmath48 equal to the time span of the data stream , the no - x algorithm reduces to the no - i algorithm because every occurrence satisfies expiry constraint .",
    "hence proof of correctness of no - i algorithm is immediate .",
    "we now explain the relation between the sets of occurrences tracked by the no and no - i algorithms . as proved in @xcite the no algorithm ( which uses one automaton per episode ) , tracks a maximal non - overlapped sequence of occurrences , say , @xmath281 .",
    "since the no - i algorithm has no expiry time constraint , it also tracks a maximal set of non - overlapped occurrences . among all the et occurrences that end at @xmath282 ,",
    "let @xmath283 be the last one ( as per the lexicographic ordering ) .",
    "then the @xmath40 occurrence tracked by the no - i algorithm would be @xmath283 as we show now . since @xmath284 would be the first et occurrence , it is clear from our discussion in the previous subsection that the first occurrence tracked by the mo algorithm would be @xmath285 . as is easy to see",
    ", the mo and no - i algorithms would be identical till the first time an automaton reaches the accepting state .",
    "hence @xmath285 would be the first occurrence tracked by the no - i algorithm .",
    "now the no - i algorithm would remove all automata except for the one in the start state .",
    "hence , it is as if we start the algorithm with data starting with the first event after @xmath286 .",
    "now , by the property of no algorithm , @xmath287 would be the first et occurrence in this data stream and hence @xmath288 would be the first minimal window here . hence it is the second occurrence tracked by no - i and so on .",
    "the above also shows that each occurrence tracked by the no - i algorithm is also tracked by the mo algorithm and hence we have @xmath289 as stated in  ( [ eq : all - f - relationships ] ) .",
    "@xmath290 is also a maximal set of non - overlapping minimal windows as discussed in  @xcite .",
    "the algorithm ni which counts non - interleaved occurrences is different from all the ones discussed so far because it does not track et occurrences . here",
    "also we always have an automaton waiting in the start state .",
    "however , the transitions are conditional in the sense that the @xmath40 created automaton makes a transition from state @xmath291 to @xmath102 provided the @xmath214 created automaton is past state @xmath102 after processing the current event .",
    "this is because we want the @xmath40 automata to track an occurrence non - interleaved with the occurrence tracked by @xmath214 automaton .",
    "let @xmath292 be the sequence of occurrences tracked by ni . from the above discussion",
    "it is clear that it has the following property ( while counting occurrences of @xmath13 ) .",
    "[ property : algo1 ] _",
    "@xmath293 is the first or earliest occurrence ( of @xmath13 ) . for all @xmath294 and @xmath295",
    ", @xmath296 is the first occurrence of @xmath297 $ ] at or after @xmath298 ; and @xmath299 is the earliest occurrence of @xmath300 $ ] after @xmath301 .",
    "there is no occurrence of @xmath13 beyond @xmath302 which is non - interleaved with it . _",
    "the proof that @xmath303 is a maximal non - interleaved sequence is very similar in spirit to that of the no - x algorithm . as earlier",
    ", we can show that given an arbitrary sequence of non - interleaved occurrences @xmath81 = @xmath268 , we have @xmath304 and hence get the correctness proof of ni algorithm .",
    "it is easy to verify the correctness of the do algorithm also along similar lines .",
    "it appears difficult to extend both the ni and do algorithms to incorporate expiry time constraints . for this we should track a set of occurrences @xmath305 of @xmath13 , where @xmath75 is the first occurrence satisfying @xmath48 and @xmath76 is the next earliest occurrence satisfying @xmath48 that is non - interleaved with ( or distinct from , in case of do ) @xmath75 and so on .",
    "note that this @xmath76 need not have to be the earliest occurrence non - overlapped with @xmath75 . at present , there are no algorithms for counting non - interleaved or distinct occurrences satisfying an expiry time constraint .    before ending this section , we briefly outline what needs to be done when the data stream contains multiple events having the same time of occurrence .",
    "an important thing to note is that two events having the same time of occurrence can not be a part of a serial episode occurrence .",
    "hence , each automata can at most accept one event from a set of events having the same occurrence time . with this condition ,",
    "the do , ao and hd algorithms go through as before .",
    "one would need to process the set of events having the same occurrence time together and allow all the permissible automata to make a one step transition first as done using @xmath306 list in @xcite .",
    "after this , before processing the set of events with the next occurrence time , we would need to do the multiple automata check for the various candidate episodes and delete the appropriate older automata for algorithms mo , mo - x , no - i and no - x .",
    "for the non - interleaved algorithm , one needs to actually back track the transitions which resulted in two automata to coalesce .",
    "in this section , we discuss the anti - monotonicity properties of the various frequency counts , which in - turn are exploited by their respective candidate generation steps in the apriori - style level - wise procedure for frequent episode discovery .",
    "it is well known that the windows - based@xcite , non - overlapped@xcite and total@xcite frequency measures satisfy the anti - monotonicity property that _ all subepisodes of a frequent episode are frequent_. one can verify that the same holds for the distinct occurrences based frequency too .",
    "it has been pointed out in @xcite that the head frequency does not satisfy this anti - monotonicity property . for an episode @xmath13 , in general ,",
    "only the subepisodes involving @xmath213 $ ] are as frequent as @xmath13 under the head count . in a level - wise apriori - based episode discovery , the candidate generation for the head frequency count would exploit the condition that if an @xmath12-node episode is frequent , then all @xmath160-node subepisodes that include @xmath213 $ ] have to be frequent .",
    "the head frequency definition has some limitations in the sense that the frequency of the @xmath160-node suffix subepisode - node episode @xmath213 \\rightarrow \\alpha[2 ] \\rightarrow \\cdots \\rightarrow \\alpha[n]$ ] , its @xmath307-node _ prefix subepisode _ is @xmath213 \\rightarrow \\alpha[2 ] \\rightarrow \\cdots \\rightarrow \\alpha[k]$ ] and its @xmath308-node suffix subepisode is @xmath309 \\rightarrow \\alpha[k+2 ] \\rightarrow \\cdots \\rightarrow \\alpha[n]$ ] for @xmath310 .",
    "] can be arbitrarily low .",
    "consider the event stream with @xmath311 @xmath109s followed by a @xmath111 and @xmath113 .",
    "suppose all occurrences of @xmath312 satisfy the expiry constraint @xmath48 .",
    "even though there are @xmath311 occurrences of @xmath313 , there is only one occurrence of @xmath314 .",
    "this can be a problem when one desires that the frequent episodes capture repetitive causative influences .    like the head frequency",
    ", the minimal occurrences ( windows ) and the non - interleaved occurrences also do not satisfy the anti - monotonicity property that all subepisodes are at least as frequent as the corresponding episode .",
    "however , the @xmath160-node prefix and suffix subepisodes are at least as frequent as the episode as we show below . for an example , consider a data stream where successive events are given by @xmath315 . even though there are two minimal windows ( and two non - interleaved occurrences ) of @xmath316 ,",
    "there is only one minimal window ( and one non - interleaved occurrence ) of each of the non - prefix and non - suffix subepisodes @xmath317 and @xmath318 . however , the situation here is not as bad as that for head frequency because all such subepisodes will have at least as many distinct occurrences as the number of minimal or non - interleaved occurrences of the episode , at least in case of injective episodes .",
    "( note that this example is that of an injective episode ) .",
    "this is because , in case of injective episodes , the number of distinct occurrence is always greater than the non - interleaved count , which in - turn is greater than the minimal windows count .",
    "hence , given that there are @xmath206 non - interleaved or minimal occurrences of an injective episode @xmath13 , there are at least @xmath206 distinct occurrences of @xmath13 too .",
    "since the distinct occurrences based frequency satisfies the original anti - monotonicity property , all subepisodes of @xmath13 too will have at least @xmath206 distinct occurrences .",
    "we now formally prove the anti - monotonicity property for minimal and non - interleaved occurrences based frequencies .",
    "if a n - node serial episode @xmath13 has a frequency @xmath206 in the minimal or the non - interleaved sense , then its @xmath160-prefix subepisode @xmath319 and suffix subepisode @xmath320 have a frequency of at least @xmath206 .",
    "consider a minimal window of the episode @xmath13 , @xmath321 $ ] .",
    "consider the earliest occurrence @xmath322 of the prefix subepisode starting from @xmath323 and let @xmath324 be its window .",
    "any proper sub - window of @xmath324 starting at @xmath323 and containing an occurrence of @xmath325 contradicts lemma [ lemma : power ] . a proper sub - window of @xmath324 containing an occurrence of @xmath325 starting after @xmath323 would contradict the minimality of @xmath156 itself .",
    "hence @xmath324 is a minimal window of @xmath325 starting at @xmath323 .",
    "we hence conclude that @xmath325 has a frequency of at least @xmath206 . a similar proof works for the suffix subepisode by considering the window of the last occurrence @xmath326 of the suffix subepisode ending at @xmath327",
    ".    let @xmath328 be a maximal non - interleaved sequence . from each occurrence @xmath329 ,",
    "we choose the sub - occurrence @xmath330 $ ] , of @xmath325 .",
    "it is easy to see that this new sequence of occurrences @xmath331 forms a non - interleaved sequence .",
    "hence the frequency of @xmath325 is at least @xmath206 .",
    "a similar argument works for the suffix episode .",
    "hence , for every episode @xmath13 , we extract its @xmath160 suffix , go down the candidate list and search for a block of episodes whose @xmath332 prefix matches this suffix .",
    "we form candidates as many as the number of episodes in this matching block .",
    "this kind of candidate generation has already been reported in the literature in @xcite , @xcite and @xcite in the context of sequences under inter - event time constraints .",
    "the framework of frequent episodes in event streams is a very useful data mining technique for unearthing temporal dependencies from data streams in many applications .",
    "the framework is about a decade old and many different frequency measures and associated algorithms have been proposed over the last ten years . in this paper",
    "we have presented a generic automata - based algorithm for obtaining frequencies of a set of candidate episodes .",
    "this method unifies all the known algorithms in the sense that we can particularize our algorithm ( by setting values for a set of variables ) for counting frequent episodes under any of the frequency measures proposed in literature .",
    "as we showed here , this unified view gives useful insights into the kind of occurrences counted under different frequency definitions and thus also allows us to prove relations between frequencies of an episode under different frequency definitions .",
    "our view also allows us to get correctness proofs for all algorithms .",
    "we introduced the notion of earliest transiting occurrences and , using this concept , are able to get simple proofs of correctness for most algorithms .",
    "this has also allowed us to understand the kind of anti - monotonicity properties satisfied by different frequency measures .",
    "while the main contribution of this paper is this unified view of all frequency counting algorithms , some of the specific results presented here are also new . the relationships between different frequencies of an episode ( cf .",
    "eqn  [ eq : all - f - relationships ] ) , is proved here for the first time .",
    "the distinct - occurrences based frequency and an automata - based algorithm for it are novel .",
    "the specific proof of correctness presented here for minimal occurrences is also novel .",
    "also , the correctness proofs for non - overlapped occurrences based frequency counting under expiry time constraint has been provided here for the first time .    in this paper",
    "we have considered only the case of serial episodes .",
    "this is because , at present , there are no algorithms for discovering general partial orders under the various frequency definitions .",
    "however , all counting algorithms explained here for serial episodes can be extended to episodes with a general partial order structure .",
    "we can come up with a similar finite state automata(fsa ) which track the earliest transiting occurrences of an episode with a general partial order structure @xcite .",
    "for example , consider a partial order episode @xmath333 which represents @xmath109 and @xmath111 occurring in any order followed by a @xmath113 . in order to track an occurrence of such a pattern",
    ", the initial state has to wait for either of @xmath109 and @xmath111 . on seeing an @xmath109 it goes to state-1 where it waits only for a @xmath111 ; on the other hand , on seeing a @xmath111 first it moves to state-2 where it waits only for an @xmath109 . then on seeing a @xmath111 in state-1 or seeing a @xmath109 in state-2 it moves into state-3 where it waits for a @xmath113 and so on .",
    "thus , in each state in such a fsa , in general , we wait for any of a set of event types ( instead of a single event for serial episodes ) and a given state will now branch out into different states on different event types .",
    "with such a fsa technique it is possible to generalize the method presented here so that we have algorithms for counting frequencies of general partial order episodes under different frequencies .",
    "the proofs presented here for serial episodes can also be extended for general partial order episodes . while it seems possible , as explained above , to generalize the counting schemes to handle general partial order episodes , it is not obvious what would be an appropriate candidate generation scheme for general partial order episodes under different frequency definitions .",
    "this is an important direction for future work .    in this paper , we have considered only expiry time constraint which prescribes an upper bound on the span of the occurrence",
    ". it would be interesting to see under what other time constraints ( e.g. , gap constraints ) , design of counting algorithms under this generic framework is possible . also , some unexplored choice of the boolean conditions in the proposed generic algorithm may give rise to algorithms for new useful frequency measures .",
    "this is also a useful direction of research to explore .",
    "bouchra bouqata , christopher  d. caraothers , boleslaw  k. szymanski , and mohammed  j. zaki .",
    "vogue : a novel variable order - gap state machine for modeling sequences . in _ proc .",
    "european conf .",
    "principles and practice of knowledge discovery in databases ( pkdd06 ) _ , pages 4254 , sep 2006 .",
    "iwanuma k. , takano y. , and nabeshima h. on anti - monotone frequency measures for extracting sequential patterns from a single very - long sequence .",
    "in _ proc .",
    "ieee conf .",
    "cybernetics and intelligent systems _ , pages 213217 , dec 2004 .",
    "srivatsan laxman , p.  s. sastry , and k.  p. unnikrishnan .",
    "a fast algorithm for finding frequent episodes in event streams . in _ proc .",
    "acm sigkdd intl conf",
    ". knowledge discovery and data mining ( kdd07 ) _ , pages 410419 , aug 2007 .",
    "srivatsan laxman , vikram tankasali , and ryen  w. white .",
    "stream prediction using a generative model based on frequent episodes in event sequences . in _ proc .",
    "acm sigkdd intl conf",
    ". knowledge discovery and data mining ( kdd09 ) _ , pages 453461 , jul 2008 .",
    "nicolas meger and christophe rigotti .",
    "constraint - based mining of episode rules and optimal window sizes . in _ proc .",
    "european conf .",
    "principles and practice of knowledge discovery in databases ( pkdd04 ) _ , september 2004 .      anny nag and ada fu , wai - chee . mining freqeunt episodes for relating financial events and stock trends . in _ proc .",
    "pacific - asia conf .",
    "knowledge discovery and data mining , ( pakdd 2003 ) _ , pages 2739 , 2003 .",
    "min - feng wang , yen - ching wu , and meng - feng tsai . exploiting frequent episodes in weighted suffix tree to improve intrusion detection system . in _ proc .",
    "intl conf .",
    "advanced information networking and applications(aina08 ) _ , pages 12461252 , mar 2008 ."
  ],
  "abstract_text": [
    "<S> frequent episode discovery framework is a popular framework in temporal data mining with many applications . over the years </S>",
    "<S> many different notions of frequencies of episodes have been proposed along with different algorithms for episode discovery . in this paper </S>",
    "<S> we present a unified view of all such frequency counting algorithms . </S>",
    "<S> we present a generic algorithm such that all current algorithms are special cases of it . </S>",
    "<S> this unified view allows one to gain insights into different frequencies and we present quantitative relationships among different frequencies . </S>",
    "<S> our unified view also helps in obtaining correctness proofs for various algorithms as we show here . </S>",
    "<S> we also point out how this unified view helps us to consider generalization of the algorithm so that they can discover episodes with general partial orders . </S>"
  ]
}