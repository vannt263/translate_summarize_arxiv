{
  "article_text": [
    "the ambiguity of an nfa @xmath0 measures the degree of nondeterminism employed by @xmath0 as a function of the input size : let @xmath8 be the number of accepting computations of @xmath0 on input @xmath9 and define @xmath10 to be the ambiguity of @xmath0 .",
    "there are related complexity measures such as the advice and the leaf complexity of @xmath0 . to describe their definition let @xmath11 be the computation tree of @xmath0 on input @xmath9 .",
    "then advice@xmath12 is the maximum , over all paths in @xmath13 from the root to a leaf , of the number of nodes with at least two children and @xmath14 is the advice complexity of @xmath0 .",
    "the leaf complexity of @xmath0 determines the maximal number of computations for inputs of length @xmath1 .",
    "thus , if leaf@xmath15 is the number of leaves of @xmath11 , then @xmath16 for a minimal nfa @xmath0 these measures are related as follows @xcite @xmath17 and , since @xmath18 is at most linear , leaf complexity and ambiguity are polynomially related , provided both are at least linear .",
    "since leaf complexity is either bounded by a constant or at least linear but polynomially bounded , or otherwise exponential in the input length , we obtain that ambiguity is either bounded by a constant or bounded by a polynomial or at least exponential @xcite .",
    "advice and leaf complexity are rather coarse measures , since advice and leaf complexity of an unambiguous nfa may be linear .",
    "ambiguity on the other hand also influences the tractability of algorithmic questions .",
    "for instance , for any fixed @xmath19 it can be determined efficiently whether two nfa s of ambiguity at most @xmath20 are equivalent , resp . whether the ambiguity of a given nfa is at most @xmath20 @xcite .",
    "how large is the decrease in conciseness , i.e. , the increase in the number of states , if ambiguity is restricted ? to study this question , four classes of nfa s , namely una ( unambiguous nondeterministic automata ) , fna ( finitely ambiguous nfa ) , pna ( polynomially ambiguous nfa ) and ena ( exponentially ambiguous nfa ) are introduced in @xcite . the classification into fna s",
    ", pna s or ena s can be performed efficiently @xcite .",
    "remember that the ambiguity of an nfa @xmath0 is either at least exponential or at most polynomial and hence an nfa is either a pna or an ena .",
    "leung @xcite shows that there are ena s @xmath21 with @xmath1 states such that any equivalent pna has at least @xmath22 states .",
    "hence ena s can be far more succinct than pna s .",
    "subsequently a similar result , applicable to a larger class of languages , was shown in @xcite by using methods of communication complexity .",
    "in particular , the conciseness problem for pna s can be reduced to the following communication result for the iterated language of non - disjointness .",
    "let @xmath23 be the alphabet of all subsets of @xmath24 of size @xmath25 and set @xmath26 thus @xmath27 consists of all strings @xmath28 where all pairs @xmath29 correspond to overlapping subsets .",
    "we assume the standard communication model with two players , alice and bob , where alice receives @xmath30 and bob receives @xmath31 .",
    "( observe that @xmath32 has small nfa s with poly@xmath33 states . )",
    "[ fact ] ( @xcite , pages 51 - 53 ) .",
    "let @xmath34 be arbitrary .",
    "if a deterministic protocol @xmath35 accepts only strings from @xmath36 and if at most @xmath37 messages are exchanged , then @xmath35 accepts at most @xmath38 strings from @xmath36 .",
    "( @xmath39 is a sufficiently small constant ) .    of particular interest",
    "are fna s , for instance since their equivalence problem is efficiently solvable .",
    "however a separation of fna s and pna s has remained open for almost twenty years @xcite .",
    "we are able to show such a separation and even prove a hierarchy result for polynomial ambiguity . to describe our result",
    "we introduce the languages used in the separation . for a language @xmath40 of strings of identical",
    "length define @xmath41 thus the input is partitioned into blocks of identical length and an input is accepted iff at least @xmath20 blocks belong to the finite set @xmath40 .",
    "now assume that @xmath40 can be recognized by a small nfa @xmath0 .",
    "since @xmath40 is a finite set , we can recognize @xmath42 by an nfa with ambiguity @xmath6 , if we increase the size of @xmath0 by at most the factor @xmath20 .",
    "how should the languages @xmath40 look like ? in a first attempt set @xmath43 as the language of inequality between @xmath25-bit strings .",
    "then @xmath40 is recognizable by an nfa with @xmath44 states and ( bounded ) ambiguity @xmath25 .",
    "but @xmath45 is also recognizable with @xmath44 states and ambiguity @xmath25 : guess a position @xmath46 and accept @xmath47 if @xmath48 for some @xmath49 .    what went wrong ?",
    "few advice bits suffice and these advice bits can be remembered . in our second ( and successful ) attempt",
    "we therefore set @xmath50 , where we work with the iterated language of non - disjointness from fact [ fact ] .",
    "this construction has two advantages .",
    "firstly , @xmath40 has a small nfa .",
    "secondly , at least intuitively , the number of guesses required for @xmath40 increases exponentially with @xmath51 and hence a small nfa s for @xmath52 can not remember sequences of @xmath51 guesses . our main result verifies this intuition .    [ main ]",
    "let @xmath53 be arbitrary . set @xmath54 and @xmath55 .",
    "any nfa for @xmath42 with ambiguity @xmath7 has at least @xmath56 states .",
    "however , @xmath42 can be recognized by an nfa with ambiguity @xmath6 and size @xmath57 .",
    "observe that we have obtained the claimed separation of fna s and pna s for @xmath58 , but theorem [ main ] also establishes a hierarchy of polynomial ambiguity .",
    "we start by proving theorem [ main ] for @xmath58 .",
    "let @xmath50 and assume that the nfa @xmath0 recognizes @xmath59 with sublinear ambiguity .",
    "observe that all strings in @xmath40 have length @xmath60 and hence strings in @xmath45 have blocks of identical length @xmath60 .",
    "we set @xmath61 , where @xmath23 is the alphabet of @xmath62 .",
    "finally set @xmath63 thus , as in the definition of @xmath59 , the input is partitioned into blocks and an input is accepted iff _ no _ block belongs to the finite set @xmath40 .",
    "the computationally hardest task for the nfa @xmath0 is to separate @xmath64 from @xmath45 .",
    "the critical part of the argument is to exploit the limitation of sublinear ambiguity .",
    "let @xmath65 be the set of states of @xmath0 . in section [ autocom ]",
    "we construct states @xmath66 such that at least @xmath67 strings in @xmath40 have a computation starting in @xmath68 and ending in @xmath69 .",
    "moreover we show in lemma [ densit ] that for any string @xmath70 there is a string @xmath71 such that strings @xmath72 with period @xmath73 can be `` stored '' in a `` launching cycle '' before reaching @xmath68 and in a `` storage cycle '' after leaving @xmath69 .",
    "the launching cycle has the form @xmath74 and allows to reach @xmath68 via a computation @xmath75 ; analogously the storage cycle is built from computations @xmath76 and @xmath77 .",
    "so far the launching cycle is harmless , since it delivers strings in @xmath78 to state @xmath68 , but these strings can not use computations from @xmath68 to @xmath69 which may be reserved for strings in @xmath40 .",
    "however , if a single occurrence of @xmath79 within @xmath72 is replaced by an impostor string @xmath80 and if the launching cycle does not detect the replacement , then @xmath0 is forced into linear ambiguity , provided the impostor @xmath81 can also hide at a matching position within the storage cycle ( see lemma [ 1 ] ) .",
    "thus the nfa @xmath0 has to solve the `` detection problem '' , namely it has to detect whether an impostor @xmath80 has replaced an occurrence of @xmath70 in both cycles .",
    "the detection problem is set up in such a way that    * at least @xmath67 strings from @xmath40 are accepted , namely those strings @xmath80 with a computation @xmath82 , and * all strings @xmath81 which for some @xmath70 survive in matching positions within both cycles are rejected . in particular , all strings in @xmath83 are rejected , since a string @xmath84 is its own impostor .",
    "observe that no string @xmath81 is simultaneously accepted as well as rejected , since all impostors have to be detected .",
    "@xmath0 may try to solve the detection problem unconventionally for instance by allowing a potential impostor @xmath81 to survive undetected within the launching and storage cycle , but not allowing @xmath81 to survive in _ matching positions _ within both cycles .",
    "also @xmath0 does not have to solve the detection problem completely , since it can tolerate an impostor @xmath81 without a computation @xmath85 .",
    "we then simulate @xmath0 in section [ dcom ] by a nondeterministic communication protocol which rejects all strings in @xmath83 , accepts at least @xmath67 strings in @xmath40 and does not simultaneously accept and reject a string in @xmath83 ( see lemma [ com ] ) .",
    "thus we have reduced the problem of avoiding linear ambiguity for nfa s recognizing @xmath59 to a communication problem in which a rather small minority of strings in @xmath40 has to be separated from all of @xmath83 .",
    "we show in lemma [ det ] how to transform such a nondeterministic protocol into a deterministic protocol by increasing the number of messages only subexponentially .",
    "we are left with a deterministic protocol which rejects all strings in @xmath83 and accepts at least @xmath67 strings in @xmath40 .",
    "finally the argument concludes with an application of fact [ fact ] .",
    "thus , as in the case of exponential ambiguity , we again have reduced the conciseness problem to an investigation of deterministic protocols which recognize a `` small , but significant chunk '' of a given product language .",
    "the general case of ambiguity @xmath6 is tackled in section [ hierarchy ] . showing the existence of launching and storage cycles",
    "has now become a more complex problem .",
    "previously it was sufficient that the periodic string @xmath86 was `` living '' in the one launching and the one storage cycle .",
    "now we have to work with a vector @xmath87 of states and have to move @xmath86 to @xmath68 and all the way from @xmath88 to @xmath89 for all @xmath90 and finally from @xmath91 to an accepting state .",
    "we begin by utilizing the special structure of the languages @xmath59 .",
    "let @xmath0 be an nfa for @xmath45 with initial state @xmath92 .",
    "let @xmath93 be an arbitrary state of @xmath0 .",
    "* we say that a string @xmath94 * reaches * state @xmath93 iff there is a string @xmath95 and a computation for @xmath96 which starts in @xmath92 and ends in @xmath93 .",
    "moreover state @xmath93 * accepts * @xmath97 iff there is a string @xmath98 and an accepting computation for @xmath99 starting in @xmath93 . *",
    "a pair @xmath100 of states of @xmath0 is * critical * for the pair @xmath101 iff all strings in @xmath102 reach @xmath68 and all strings in @xmath103 are accepted by @xmath69 .",
    "our next goal is to construct a pair @xmath104 such that for all strings @xmath105 acceptance is `` decided '' by critical pairs .",
    "in particular we construct @xmath106 such that there are accepting computations of the form @xmath107 for a final state @xmath108 and a critical pair @xmath100 for @xmath109 .",
    "the crucial advantage of a critical pair is that all strings in @xmath110 reach @xmath68 and all strings in @xmath111 are accepted by @xmath69 ; in particular , there is no transition @xmath82 for a string @xmath112 and acceptance is indeed decided by @xmath100 .",
    "[ onetwo ] let @xmath0 be an nfa for @xmath45 .",
    "then there are strings @xmath113 such that @xmath114    we process the states of @xmath0 in two phases . in the first phase we construct a string @xmath115 such that each state",
    "@xmath93 is either _ alive _ for @xmath116 ( i.e. , all strings in @xmath102 reach @xmath93 ) or _",
    "dead _ for @xmath116 ( i.e. , no string in @xmath102 reaches @xmath93 ) .",
    "the construction process proceeds iteratively by processing all states @xmath93 of @xmath0 in an arbitrary order .",
    "we begin by setting @xmath117 . when processing state @xmath93 we differentiate two cases .",
    "* case 1 : * all strings in @xmath102 reach @xmath93 .",
    "we do not modify @xmath116 .",
    "observe that @xmath93 is alive for @xmath116 and stays alive for any string in @xmath64 with suffix @xmath116 .",
    "* case 2 : * there is a string @xmath118 such that @xmath119 does not reach @xmath93",
    ". the string @xmath119 does not reach @xmath93 and hence no string in @xmath120 has a computation beginning in the starting state @xmath92 and ending in @xmath93 .",
    "we replace @xmath116 by @xmath119 and @xmath93 is dead for @xmath116 , but also dead for any string in @xmath121 with suffix @xmath116 .",
    "also observe that any already processed state @xmath122 stays alive , resp .",
    "remains dead .",
    "in the second phase we proceed completely analogously , but now construct a string @xmath123 such that each state @xmath93 is either _ alive _ for @xmath124 ( i.e. , @xmath93 accepts all strings in @xmath125 ) or _ dead _ for @xmath124 ( i.e. , @xmath93 does not accept any string in @xmath126 ) .",
    "now consider any string @xmath127 in @xmath128 .",
    "observe that @xmath129 is a subset of @xmath45 .",
    "however @xmath116 can not reach a dead state for @xmath116 and @xmath124 can not be accepted by a dead state for @xmath124 .",
    "thus any accepting computation for @xmath130 has to utilize a transition @xmath85 between alive states @xmath68 for @xmath116 and @xmath69 for @xmath124 . but any pair @xmath100 of alive states is a critical pair and we are done .    from now on",
    "we fix a pair @xmath104 for which lemma [ onetwo ] holds .",
    "let @xmath100 be an arbitrary critical pair for @xmath106 .",
    "we now utilize that all strings in @xmath131 reach @xmath68 and all strings in @xmath103 are accepted by @xmath69 .",
    "[ densit ] for all strings @xmath84 there are states @xmath132 , integers @xmath133 ( with @xmath134 ) and a string @xmath95 as well as computations @xmath135    we consider all strings of the form @xmath136 the string @xmath137 has suffix @xmath116 and hence @xmath137 reaches @xmath68 . as a consequence there is @xmath118 and a computation @xmath138 for @xmath139 which begins in the initial state @xmath92 and reaches @xmath68 . after reading @xmath140 ,",
    "computation @xmath138 processes @xmath137 and produces a sequence of @xmath141 states , where we list all states before reading a copy of @xmath142 , resp . after reading the last copy",
    "a state @xmath25 of @xmath0 appears twice in this sequence and we obtain a transition of the form @xmath143 for @xmath144 .",
    "finally @xmath138 , starting in @xmath25 , reaches @xmath68 after reading the remaining @xmath145 copies .    to establish ( [ one ] )",
    ", we set @xmath146 and obtain transitions @xmath147 and @xmath148 . thus ( [ one ] ) follows .",
    "part ( [ two ] ) is established by a similar argument , but now applied to @xmath149 .",
    "this time we get transitions @xmath150 and @xmath151 .",
    "but then @xmath152 as well as @xmath153 are transitions for any multiples @xmath154 and the claim follows , if we replace both @xmath155 and @xmath156 by @xmath157 .",
    "let @xmath100 be a critical pair for @xmath109 .",
    "we now introduce the detection problem for @xmath100 in which strings in @xmath40 have to be `` weakly '' separates from strings in @xmath83 .",
    "it turns out that any nfa @xmath0 for @xmath45 solves the detection problems for all critical pairs , provided @xmath0 has ambiguity @xmath158 .",
    "since we show later that @xmath0 can be efficiently simulated by a communication protocol with communication resources related to the number of states and that the detection problem is hard for communication complexity , @xmath0 must have many states .",
    "the detection problem of @xmath100 has the following form :    * accept a string @xmath159 iff there is a computation @xmath85 of @xmath0 .",
    "remember that for no @xmath160 there is a computation @xmath161 with the initial state @xmath92 , a final state @xmath108 and strings @xmath162 .",
    "hence no string @xmath84 is accepted . *",
    "reject a string @xmath159 iff there are states @xmath163 , integers @xmath164 ( with @xmath165 ) and strings @xmath166 with computations @xmath167 ( the computations ( [ xx1 ] ) and ( [ xx2 ] ) will be used later to define a launching and storage cycle respectively .",
    "it turns out that @xmath81 is placed within matching positions of the @xmath73- and @xmath168-cycle and hence @xmath81 plays the role of an impostor of @xmath79 . )",
    "* @xmath159 is left undecided iff @xmath81 is neither accepted nor rejected .",
    "to explain the purpose of these transitions consider the string @xmath169 \\cdot [ zu \\cdot ( z'u)^{a-1}].\\end{aligned}\\ ] ] if we process the first half @xmath170 of @xmath171 starting in state @xmath172 , then there is a computation @xmath173 of the form @xmath174 as well as a computation @xmath175 from @xmath172 to @xmath68 according to ( [ xx1 ] ) .",
    "when reading the second half of @xmath171 , computation @xmath173 splits into a computation @xmath176 which goes full circle reaching state @xmath172 again and a computation @xmath177 which reaches @xmath68 after completely reading @xmath171 .",
    "now assume that there is a transition @xmath82 .",
    "computation @xmath175 has reached @xmath68 after reading the first half of @xmath171 and now reads the second half @xmath178 of @xmath171 .",
    "it travels from @xmath68 to @xmath69 and subsequently reaches state @xmath179 , if _ additionally _ the string @xmath81 is read .",
    "we have been successful    * in `` storing '' a mother computation via computation @xmath176 in state @xmath172 , * preparing for a new `` launch '' in state @xmath68 via computation @xmath177 and *  storing  offspring computations in state @xmath180 via computation @xmath175 .",
    "we utilize properties ( 1)-(3 ) by defining a sequence @xmath181 with many computations , namely we set @xmath182 = s_m \\cdot [ z \\cdot ( uz')^{a-1 } \\cdot u].\\end{aligned}\\ ] ] assume inductively that there are computations for @xmath183 which have reached the states @xmath172 and @xmath68 respectively and a computation for @xmath184 which has reached @xmath180 . after reading the suffix @xmath170 of @xmath185 , the computation starting in @xmath172",
    "has split into a computation reaching @xmath172 again and a computation reaching @xmath68 , whereas the freshly launched computation reaches @xmath180 from @xmath68 after reading @xmath186 .",
    "observe that all previously launched computations go full circle after reading @xmath187 and again have reached state @xmath180 . as a consequence ,",
    "there are @xmath188 distinct computations for @xmath189 all reaching state @xmath180 at the same time .",
    "we say that @xmath0 has no redundant states , if each state is part of some accepting computation of @xmath0 . which strings are rejected and which strings are accepted ?    [ 1 ] let @xmath0 be an nfa recognizing @xmath45 without redundant states .",
    "also assume that @xmath0 has ambiguity @xmath158 .",
    "* consider the detection problem of an arbitrary critical pair @xmath100 .",
    "then all strings in @xmath83 are rejected and no string in @xmath190 is simultaneously accepted and rejected . *",
    "each string in @xmath40 is accepted in the detection problem of some critical pair .",
    "\\(a ) we observe first that every string @xmath84 is rejected .",
    "we may choose @xmath191 and the transitions required in ( [ xx1 ] ) and ( [ xx2 ] ) exist as a consequence of lemma [ densit ] : the states @xmath192 and @xmath193 belong to the @xmath25-cycle and the @xmath130-cycle respectively .",
    "now assume that there is a string @xmath159 which is accepted and rejected .",
    "since @xmath81 is accepted , there is a computation @xmath82 . also , since @xmath81 is rejected , there are computations of the form ( [ xx1 ] ) and ( [ xx2 ] )",
    ". thus we may construct the strings @xmath194 for every @xmath188 and obtain @xmath188 distinct computations which , starting from state @xmath172 , reach state @xmath180 at the same time .",
    "but @xmath0 does not have redundant states and each state , and in particular state @xmath172 , is reachable from the initial state .",
    "also each state , and in particular state @xmath180 , can reach an accepting state .",
    "thus there are strings @xmath195 such that @xmath196 has @xmath188 accepting computations . but @xmath194 is a string with length linear in @xmath188 and hence @xmath0 has at least linear ambiguity .",
    "\\(b ) follows from part ( a ) , if we apply lemma [ onetwo ] .",
    "we show that the detection problem has an efficient communication protocol , provided a small nfa @xmath0 with ambiguity @xmath158 recognizes @xmath45 .",
    "remember that @xmath197 and @xmath61 .",
    "we work with the conventional two - party communication model consisting of two players alice and bob .",
    "if @xmath198 is the input of @xmath0 , then alice receives @xmath30 and bob receives @xmath31 as their respective inputs .",
    "alice and bob communicate nondeterministically with computations either being accepting , rejecting or undecided .",
    "we say that an input is accepted if at least one computation is accepting , rejecting if at least one computation is rejecting and undecided if all computations are undecided .",
    "( thus undecided computations play the role of rejecting computations for conventional nondeterminism . )",
    "observe that we allow to simultaneously accept and reject an input .",
    "now assume that the nfa @xmath0 recognizes @xmath45 .",
    "let @xmath199 be two states of @xmath0 and let @xmath159 be an input string .",
    "our first goal is to determine whether @xmath0 has a computation for @xmath81 starting in @xmath122 and ending in @xmath200 .",
    "set @xmath201 .",
    "beginning with @xmath202 , alice simulates @xmath0 for input @xmath203 by starting in state @xmath204 and sends state @xmath205 , if @xmath206 is reached .",
    "bob simulates @xmath0 for input @xmath207 by starting in state @xmath206 and sends state @xmath208 , if @xmath209 is reached . in the last round bob",
    "accepts if additionally @xmath210 holds and otherwise outputs `` undecided '' .",
    "obviously the simulating protocol exchanges at most @xmath211 messages .",
    "it has an accepting computation iff @xmath0 has a computation @xmath212 and otherwise leaves the input undecided .",
    "we say that a protocol solves the detection problem of @xmath100 if the protocol labels each input as accepted , rejected or undecided as prescribed by the detection problem .",
    "[ com ] assume that @xmath0 recognizes @xmath45 and that @xmath0 has ambiguity @xmath158 .",
    "let @xmath100 be a critical pair for @xmath109 .",
    "then there is a nondeterministic protocol @xmath213 which solves the detection problem of @xmath100 with @xmath214 messages .",
    "we begin by describing the protocol @xmath213 . in its first attempt",
    "@xmath213 tries to accept its input @xmath159 by simulating the automaton @xmath0 when reading @xmath81 starting in state @xmath68 . @xmath213",
    "accepts @xmath81 iff state @xmath69 is reached and otherwise leaves @xmath81 undecided .    in its second attempt",
    "@xmath213 tries to reject @xmath81 .",
    "alice guesses states @xmath163 as well as strings @xmath215 and integers @xmath216 ( with @xmath134 ) .",
    "then alice verifies the following transitions _ without _ communication , namely    * @xmath217 as well as @xmath218 and * @xmath219 as well as @xmath220 .    in order to check the remaining transition @xmath221 and @xmath222 , alice guesses additional states @xmath223 and verifies the transitions @xmath224 and @xmath225 by herself .",
    "subsequently alice communicates the states @xmath226 as well as @xmath227 and both alice and bob simulate the automaton @xmath0 on input @xmath81 for starting states @xmath172 and @xmath228 .",
    "bob rejects iff the transitions @xmath229 and @xmath230 have been verified and otherwise labels @xmath81 as undecided .",
    "observe that @xmath213 exchanges at most @xmath214 messages , since @xmath213 uses messages only when simulating @xmath0 on the string @xmath159 .",
    "in lemma [ com ] we have solved the detection problem of a critical pair by a nondeterministic protocol @xmath213 with only @xmath214 messages .",
    "however the detection problem separates @xmath40 from its complement @xmath83 only weakly , since the majority of strings from @xmath40 are either rejected or left undecided .",
    "we begin our analysis by transforming the nondeterministic protocol @xmath213 into a deterministic protocol @xmath35 .",
    "we avoid an exponential blowup in the number of messages by observing the structural limitations of @xmath213 .",
    "in particular , @xmath213 accepts a subset @xmath231 of @xmath232 and rejects a superset @xmath233 of @xmath83 , where @xmath234 and @xmath233 are disjoint .",
    "[ det ] there is a deterministic protocol @xmath35 which accepts at least @xmath67 strings from @xmath40 and rejects all strings from @xmath83 .",
    "no string is left undecided and no string is accepted as well as rejected . moreover , at most @xmath235 messages are exchanged .",
    "we begin by fixing a critical pair @xmath100 such that at least @xmath67 strings are accepted in the detection problem of @xmath100 .",
    "observe that such a critical pair exists as a consequence of lemma [ 1 ] ( b ) , since each string in @xmath40 is accepted in the detection problem of at least one critical pair and there are at most @xmath236 critical pairs .",
    "let @xmath231 be the subset of @xmath40 which is accepted in the detection problem of @xmath100 and let @xmath233 be the superset of @xmath83 of rejected strings . according to lemma [ com ] there is a nondeterministic protocol @xmath213 which solves the detection problem of @xmath100 with at most @xmath214 messages .",
    "thus there are conventional nondeterministic protocols @xmath237 for @xmath234 and @xmath238 for @xmath233 which exchange at most @xmath214 messages each .    to obtain a deterministic protocol @xmath35 from @xmath237 and @xmath238",
    "we utilize that deterministic protocols with @xmath239 messages can be built from nondeterministic protocols , provided the protocols recognize a language _ and _ its complement by exchanging at most @xmath129 messages @xcite .",
    "our situation however is more complicated , since @xmath234 is only a subset of the complement of @xmath240 .",
    "we employ the construction in @xcite with the following modifications .",
    "define the communication matrix @xmath138 of @xmath241 by setting @xmath242 = \\left\\ { \\begin{array } { ll } 1 & \\;\\ ; x_1y_1 \\cdots x_ty_t \\in l_{\\rm{yes } } , \\\\ 0 & \\;\\ ; x_1y_1 \\cdots x_ty_t \\in l_{\\rm{no } } \\\\ { \\rm{undecided } } & \\;\\;{\\rm{otherwise . } } \\end{array } \\right.\\ ] ] each message @xmath188 corresponds to a submatrix @xmath129 of @xmath138 defined by the collection of rows for which the message is sent and the collection of columns for which it is accepted .",
    "now let @xmath129 be a submatrix of the communication matrix @xmath138 .",
    "we define @xmath243 to be the maximal size of a submatrix @xmath244 of @xmath129 ,",
    "where @xmath244 , after a suitable permutation of rows and columns of @xmath129 , is a lower triangular matrix with ones on the diagonal and zeroes above the diagonal .",
    "( observe that @xmath244 may contain undecided entries , but these entries have to appear below the diagonal . )",
    "since @xmath234 is accepted by the nondeterministic protocol @xmath237 and since no two diagonal entries can be accepted by the same message , we obtain that @xmath245 is bounded by the number of messages of @xmath237 and hence @xmath246 follows .",
    "we first try to reject the given input by deterministically selecting a sequence @xmath247 of messages from the protocol @xmath238 . as for the conventional transformation to deterministic protocols",
    ", the triangular message complexity will be halved in each step and in particular @xmath248 follows .",
    "we proceed as in the conventional transformation and stop the communication prematurely , if the output `` no '' can be excluded and output `` yes '' . otherwise , after at most @xmath249 rounds",
    ", we obtain @xmath250 . as a consequence",
    ", the submatrix @xmath251 has no triangular submatrix of size two or larger .",
    "in particular , the submatrix @xmath129 of @xmath252 spanned by all rows and columns of @xmath253 with a one , contains all ones of @xmath252 , no zeroes and possibly undecided entries .",
    "if the joint input belongs to @xmath129 , then we stop and accept , resp .",
    "stop and reject otherwise . in each round only messages of @xmath238 and hence at most @xmath214 messages are exchanged .",
    "thus overall at most @xmath254^ { \\log_2 \\delta_{\\rm{yes}}(c ) } = |q|^{o(t^2 \\cdot \\log_2|q|)}$ ] messages are generated .",
    "remember that @xmath255 , where @xmath62 is the language of non - disjointness for @xmath25-element subsets of @xmath256 .",
    "let @xmath35 be a deterministic protocol which accepts only strings in @xmath40 .",
    "also let @xmath39 be a sufficiently small positive constant .",
    "we apply fact [ fact ] and obtain that @xmath35 accepts at most @xmath257 strings from @xmath40 , provided at most @xmath37 messages are exchanged .",
    "now , if an nfa @xmath0 with sublinear ambiguity recognizes @xmath258 , then we apply lemma [ det ] to obtain a deterministic protocol which exchanges at most @xmath259 messages , accepts at least @xmath260 strings and accepts only strings from @xmath40 .",
    "thus , if @xmath261 for a sufficiently small positive constant @xmath39 , then at most @xmath262 inputs from @xmath40 are accepted .",
    "but the nondeterministic protocol accepts at least @xmath67 strings from @xmath40 and hence @xmath263 follows .",
    "we set @xmath264 .",
    "let @xmath265 be a sufficiently small positive constant .",
    "now either @xmath266 and we are done , since then @xmath267 or @xmath268 holds .",
    "in the latter case @xmath269 and the upper bound on the number of messages in fact [ fact ] is met , provided @xmath265 is sufficiently small .",
    "but then @xmath270 follows from ( [ q ] ) and hence @xmath271 holds for some positive constant @xmath272 .",
    "we obtain @xmath273 and hence @xmath274 , since @xmath264 .",
    "we get a contradiction if @xmath265 is chosen sufficiently small and we have shown    [ final ] let @xmath0 be an nfa with sublinear ambiguity recognizing @xmath59",
    ". then @xmath0 has at least @xmath275 states .",
    "let @xmath276 be arbitrary and let @xmath0 be an nfa for @xmath277 .",
    "we again follow the strategy for @xmath58 , however the transition from nfa s to communication protocols is now more involved .",
    "for @xmath278 we have to work with vectors @xmath279 of states and besides reachabilty for @xmath68 and acceptance by @xmath280 we also have to guarantee that computation paths exist between @xmath281 and @xmath88 .",
    "this last requirement requires some further work .      *",
    "all strings in @xmath131 reach @xmath68 and all strings in @xmath103 are accepted by @xmath280 * and for all strings @xmath284 and for all @xmath285 ( @xmath286 ) there is a string @xmath287 such that a computation for @xmath288 starts in @xmath88 and ends in @xmath89 .",
    "we construct @xmath116 as in lemma [ onetwo ] and hence for any state @xmath93 of the nfa @xmath0 either all strings in @xmath131 reach @xmath93 or no such string reaches @xmath93 . to construct @xmath124",
    "we first run the procedure of lemma [ onetwo ] and property ( 1 ) is satisfied .",
    "then we process all pairs @xmath289 of states of @xmath0 in some arbitrary order .",
    "if for all strings @xmath71 there is a string @xmath290 such that @xmath291 has a computation beginning in @xmath93 and ending in @xmath122 , then we say that the pair @xmath289 is `` alive '' and @xmath124 is left unchanged .",
    "otherwise there is a string @xmath71 such that no computation for a string in @xmath292 has a computation beginning in @xmath93 and ending in @xmath122 .",
    "we replace @xmath124 by @xmath293 .",
    "the pair @xmath289 is now `` dead '' , since no string in @xmath294 has a computation beginning in @xmath93 and ending in @xmath122 .",
    "also observe that processed pairs do not change their status , i.e. , remain dead , resp . stay alive after updating @xmath124 .",
    "we have generalized lemma [ onetwo ] .        for @xmath58 lemma [ densit ]",
    "establishes that a string @xmath86 `` lives '' in a launching cycle for @xmath68 and a storage cycle for @xmath69 .",
    "its generalization requires more work .",
    "let @xmath297 be a critical vector and let @xmath84 be an arbitrary string .",
    "we construct a string @xmath284 for @xmath81 so that some string with period @xmath298 can be launched by @xmath68 , stored and launched in between @xmath299 and @xmath89 and finally stored by @xmath280 .",
    "in particular , we say that a string @xmath284 is appropriate for @xmath81 if the following properties are satisfied :    * @xmath300 reaches @xmath68 . * for every @xmath285 , @xmath286 , there is a string @xmath301 and computations @xmath302 .",
    "moreover , @xmath301 starts with a suffix of @xmath298 containing @xmath124 as prefix , followed by @xmath303 and completed by a prefix of @xmath304 . *",
    "state @xmath280 accepts any string @xmath305 which consists of a suffix of @xmath298 containing @xmath124 as prefix , followed by @xmath303 . *",
    "the string @xmath306 has periods @xmath307 and @xmath298 respectively .",
    "now assume that @xmath304 is appropriate for @xmath81 .",
    "we show that the string @xmath308 `` lives '' in appropriate cycles for each @xmath309 .",
    "first observe that @xmath86 has period @xmath307 and hence also period @xmath298 .",
    "the proof of lemma [ densit ] shows that a launching cycle @xmath310 is established , once @xmath300 reaches @xmath68 . also , intermediate cycles in between @xmath299 and @xmath89 exist , since @xmath301 has substring @xmath303 , and a final storage cycle following @xmath280 exists , since @xmath280 accepts a string with suffix @xmath303 .",
    "let @xmath311 be some arbitrary ordering of the states of @xmath0 .",
    "each pair @xmath312 influences the construction of @xmath304 .",
    "assume for the moment that strings @xmath313 are already defined .",
    "we set @xmath314 for all @xmath315 ( @xmath316 ) .",
    "observe that @xmath317 , if @xmath318 is alive , and that @xmath124 is a prefix of @xmath319 .",
    "choose the strings @xmath320 so that there is a computation for @xmath319 from @xmath321 to @xmath89 .",
    "such strings @xmath313 exist with property ( 2 ) of a critical vector , since @xmath124 is a prefix of @xmath319 and @xmath322 is alive .",
    "finally set @xmath323 we show that @xmath304 is appropriate for @xmath81 by first verifying property ( 1 ) .",
    "the string @xmath304 has suffix @xmath116 and hence , by property ( 1 ) of a critical vector , @xmath300 reaches @xmath68 , the first component of the critical vector @xmath324 .    observe that each @xmath319 has prefix @xmath124 and hence @xmath325 and @xmath304 have @xmath124 as prefix .",
    "we start the verification of properties ( 2 ) and ( 3 ) by defining @xmath326 and constructing a computation @xmath327 . since @xmath124 is a prefix of @xmath304 ,",
    "there is a computation for @xmath303 which leads from @xmath69 to a state @xmath321 such that the pair @xmath328 is alive .",
    "but then , by definition of @xmath329 , there is a computation for @xmath330 which starts in @xmath69 , reaches @xmath321 after reading @xmath303 and ends in @xmath331 after reading @xmath329 .",
    "we set @xmath332 . by construction",
    ", @xmath329 is a prefix of @xmath333 which itself is a prefix of @xmath304 .",
    "thus there is a string @xmath334 with @xmath335 and @xmath334 has prefix @xmath124 .",
    "we now construct a string @xmath336 and a computation @xmath337 as follows .",
    "since @xmath334 has prefix @xmath124 there is a computation for @xmath338 which reaches a state @xmath339 when starting in state @xmath340 . since the pair @xmath341 is alive",
    ", we obtain the computation @xmath342 and set @xmath343 .",
    "the construction of @xmath301 and verifying a computation @xmath302 for arbitrary @xmath344 proceeds in a completely analogous fashion . finally , again by property ( 1 ) of a critical vector , state @xmath280 accepts any string @xmath305 consisting of a suffix of @xmath298 followed by @xmath300 , since the suffix of @xmath298 has prefix @xmath124 .",
    "the remainder of the argument proceeds completely analogous to the case of @xmath58 .",
    "lemma [ 1 ] shows that an nfa with sublinear ambiguity solves the detection problem for @xmath58 .",
    "to introduce its generalization we firstly introduce the detection problem for @xmath345 : @xmath81 has to be rejected iff there is a string @xmath70 such that @xmath81 , acting as an impostor of @xmath79 , can be placed in matching positions within the @xmath346 individual @xmath168-cycles of @xmath0 .",
    "lemma [ 1 ] was a direct consequence of lemma [ densit ] in the case of @xmath58 .",
    "in the same manner we can now show that an nfa with ambiguity @xmath7 solves the detection problem for general @xmath20 as a direct consequence of lemma [ twok ] .",
    "let @xmath0 be an nfa with ambiguity @xmath7 for @xmath277 .",
    "as in lemma [ com ] we simulate @xmath0 to obtain a nondeterministic protocol @xmath213 solving the detection problem with @xmath347 messages ; the exponent grows by the factor @xmath20 , since @xmath346 instead of two computations of @xmath0 on input @xmath81 have to be simulated .",
    "we transform @xmath213 into a deterministic protocol @xmath35 with @xmath348 messages as in lemma [ det ] . to complete the proof of theorem [ main ] ,",
    "we replace @xmath25 by @xmath349 in the proof of lemma [ final ] ( to compensate for the increase in the number of messages of @xmath35 from @xmath350 to @xmath351 ) and obtain"
  ],
  "abstract_text": [
    "<S> the ambiguity of a nondeterministic finite automaton ( nfa ) @xmath0 for input size @xmath1 is the maximal number of accepting computations of @xmath0 for an input of size @xmath1 . for all @xmath2 </S>",
    "<S> we construct languages @xmath3 which can be recognized by nfa s with size @xmath4poly@xmath5 and ambiguity @xmath6 , but @xmath3 has only nfa s with exponential size , if ambiguity @xmath7 is required . in particular , a hierarchy for polynomial ambiguity is obtained , solving a long standing open problem ( ravikumar and ibarra , 1989 , leung , 1998 ) .    </S>",
    "<S> juraj hromkovi    georg schnitger </S>"
  ]
}