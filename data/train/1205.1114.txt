{
  "article_text": [
    "flash memory has seen growing usage in recent years across all areas of computing technology ; devices utilizing flash include tablets , cell phones , and usb drives .",
    "the lifespan of flash memories has been of serious concern since their inception ; flash memory degrades proportionally to the number of times it is erased . while significant advances have been made to combat this effect , flash usage continues to grow in areas where rewrite - intensive operations are necessary .",
    "we consider the problem of extending the operational lifetime of flash memory by avoiding erase operations , at the expense of some additional time and space overhead .",
    "_ multi - level flash memory _ is a form of nand random access memory _ ( ram ) _ capable of storing one of @xmath0 discrete states in each flash cell .",
    "these @xmath1 values may interpreted as nonnegative integers in the range @xmath2.$ ] cells are aggregated into _ blocks _ of fixed size .",
    "individual multi - level flash cells may be incremented , which is a fast and non - destructive operation .",
    "however , idiosyncratically , bucket states can only be decreased by resetting an entire block to state 0 _ en masse . _ these _ resets _ or _ erasures _ are costly both in terms of time of the operation and lifetime of the device .",
    "typical block erases take between 1.5 - 2 milliseconds in comparison to seek or write times which are in the tens or hundreds of microseconds .",
    "each nand flash device has a set number of expected erasure cycles it can perform before failing .",
    "wear distribution can be done in multiple ways ranging from a purely round robin approach to keeping the most actively used blocks in ram .",
    "however recent advances in multiple level flash memory data representation relaxes the requirement that a block must be erased before it can be rewritten . since erasures are a limiting factor to both the durability and write throughput of multi - level flash memory , we investigate approaches to avoid erasures , at the cost of modest constant - factor expenditures of space and cpu time .",
    "our fm tree is an amalgam of ideas from established search tree data structures . in this section",
    "we survey their properties .",
    "bayer mccreight b - tree , _ henceforth denoted _ b - tree _ , is a type of balanced search tree developed for managing large blocks of data , particularly in file - systems and databases .",
    "a b@xmath3 tree resembles a b - tree , with the addition of redundant node links that facilitate tree traversal in common database operations .",
    "b@xmath4 trees are a relaxed version of the common b@xmath3 tree where the notoriously complex post - deletion rebalancing operation is omitted .",
    "perhaps surprisingly , sen and tarjan showed that , despite postponing rebalance operations , b@xmath4 trees still boast asymptotically optimal update operations up to amortization , and may be implemented simply with attractive constant factors .      in creating a durable b - tree",
    "we have made a variety of changes to the implementation of both operations on and storage of the keys within the b - tree .",
    "these alterations reduce the maximum number of erasures per block and the average number of erasures across all blocks .    *",
    "block erasures are performed lazily , postponing them for as long as possible .",
    "* the requirement that key / value pairs be sorted within nodes is relaxed .",
    "this gives the insertion operation leeway to reuse key / value slots without erasing the block , but makes searching a single node take @xmath5 rather than @xmath6 time .",
    "* as in the b@xmath4 tree , the delete operation marks unused nodes _ barren _ rather than actually splicing the node out of the tree .",
    "barren nodes are ignored until the tree is eventually garbage collected and rebuilt .",
    "this allows a node to be excised by toggling flash cell(s ) representing a boolean barren flag , without performing block erasures .",
    "we prove that an fm tree supports the search , insert , and delete operations all in amortized @xmath7 time , matching the lower bound for amortized search tree data structures .",
    "we show that , for any sequence of operations , an fm tree performs strictly fewer erasures than a conventional b - tree .",
    "we present a variety of experiments performed on a python implementation of the fm tree .",
    "we emulate the flash memory , fm tree , and b - tree to run a variety of benchmarks .",
    "every experimental trial consists of randomly generated data sets that are inserted into both trees .",
    "each tree is inserted with a baseline of 1000 elements . following these initial insertions , 10000 randomly chosen insertions and deletions are performed .",
    "we repeat this process a total of 4 times independently and determine the average for each data point .",
    "we then calculate the fm tree performance by comparing the erasures , reads and writes between it and the b - tree .",
    "this process indicates that the fm tree performs 27 times to 72.2 times fewer erasures . while the total read count was higher , the total writes and erasures performed were far lower",
    ". as these are the most expensive operations in terms of time , realistically the fm tree would also be far faster than the b - tree .",
    "we find that the fm - tree is a more durable , faster variant of the b - tree with properties that make it intrinsically better for operating on flash memory .",
    "we also show that the erasure count for the fm tree is drastically smaller ( 27 to 72 times ) than that of a b - tree ."
  ],
  "abstract_text": [
    "<S> we consider the task of optimizing the _ b - tree _ data structure , used extensively in operating systems and databases , for sustainable usage on multi - level flash memory . </S>",
    "<S> empirical evidence shows that this new flash memory tree , or _ fm tree , _ extends the operational lifespan of each block of flash memory by a factor of roughly 27 to 70 times , while still supporting logarithmic - time search tree operations . </S>"
  ]
}