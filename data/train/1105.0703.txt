{
  "article_text": [
    "-density parity - check ( ldpc ) codes were first introduced by gallager in the 1960s @xcite , together with a class of iterative decoding algorithms .",
    "later , in the 1990s , the rediscovery of ldpc codes by mackay and neal @xcite , @xcite launched a period of intensive research on these codes and their decoding algorithms .",
    "significant attention was paid to iterative message - passing ( mp ) decoders , particularly belief propagation ( bp ) @xcite as embodied by the sum - product algorithm ( spa ) @xcite .    despite the unparalleled success of iterative decoding in practice",
    ", it is quite difficult to analyze the performance of such iterative mp decoders due to the heuristic nature of their message update rules and their local nature .",
    "an alternative approach , linear programming ( lp ) decoding , was introduced by feldman et al .",
    "@xcite as an approximation to maximum - likelihood ( ml ) decoding .",
    "many theoretical and empirical observations suggest similarities between the performance of lp and mp decoding methods .",
    "for example , graph - cover decoding can be used as a theoretical tool to show the connection between lp decoding and iterative mp decoding  @xcite .    however , there are some key differences that distinguish lp decoding from iterative mp decoding",
    ". one of these differences is that the lp decoder has the _ ml certificate property _",
    ", i.e. , it is detectable if the decoding algorithm fails to find an ml codeword .",
    "when it fails to find an ml codeword , the lp decoder finds a non - integer solution , commonly called a _",
    "pseudocodeword_. another difference is that while adding redundant parity checks satisfied by all the codewords can only improve lp decoding , adding redundant parity checks may have a negative effect on mp decoding , especially in the waterfall region , due to the creation of short cycles in the tanner graph .",
    "this property of lp decoding allows improvements by tightening the lp relaxation , i.e. , reducing the feasible space of the lp problem by adding more linear constraints from redundant parity checks .    in the original formulation of lp decoding proposed by feldman _",
    "_ , the number of constraints in the lp problem is linear in the block - length but exponential in the maximum check node degree , and the authors also argued that the number of useful constraints could be reduced to polynomial in code length .",
    "the computational complexity of the original lp formulation therefore can be prohibitively high , motivating the design of computationally simplified decoding algorithms that can achieve the same error - rate performance with a smaller number of constraints .",
    "for example , efficient polynomial - time algorithms can be used for solving the original lp formulation @xcite . an alternative lp formulation",
    "whose size is linear in the check node degree and code length can also be obtained by changing the graphical representation of the code @xcite ; namely , all check nodes of high degree are replaced by dendro - subgraphs ( trees ) with an appropriate number of auxiliary degree-3 check nodes and degree-2 variable nodes .",
    "several other low - complexity lp decoders were also introduced in @xcite , suggesting that lp solvers with complexity similar to the min - sum algorithm and the sum - product algorithm are feasible .",
    "another approach is to add linear constraints in an adaptive and selective way during the lp formulation  @xcite .",
    "such an adaptive linear programming ( alp ) decoding approach also allows the adaptive incorporation of linear constraints generated by redundant parity checks ( rpc ) into the lp problem , making it possible to reduce the feasible space and improve the system performance . a linear inequality derived from an rpc that eliminates a pseudocodeword solution",
    "is referred to as a `` cut . ''",
    "an algorithm proposed in @xcite uses a random walk on a subset of the code factor graph to find these rpc cuts .",
    "however , the random nature of this algorithm limits its efficiency .",
    "in fact , experiments show that the average number of random trials required to find an rpc cut grows exponentially with the length of the code",
    ".    recently , the authors of @xcite proposed a separation algorithm that derives gomory cuts from the ip formulation of the decoding problem and finds cuts from rpcs which are generated by applying gaussian elimination to the original parity - check matrix . in  @xcite",
    ", a cutting - plane method was proposed to improve the fractional distance of a given binary parity - check matrix  the minimum weight of nonzero vertices of the fundamental polytope  by adding redundant rows obtained by converting the parity - check matrix into row echelon form after a certain column permutation .",
    "however , we have observed that the rpcs obtained by the approach in  @xcite are not able to produce enough cuts to improve the error - rate performance relative to the separation algorithm when they are used in conjunction with either alp decoding or the separation algorithm .",
    "a detailed survey on mathematical programming approaches for decoding binary linear codes can be found in @xcite .    in this paper",
    ", we greatly improve the error - correcting performance of lp decoding by designing algorithms that can efficiently generate cut - inducing rpcs and find possible cuts from such rpcs .",
    "first , we derive a new necessary condition and a new sufficient condition for a parity - check to provide a cut at a given pseudocodeword .",
    "these conditions naturally suggest an efficient algorithm that can be used to find , for a given pseudocodeword solution to an lp problem , the unique cut ( if it exists ) among the parity inequalities associated with a parity check .",
    "this algorithm was previously introduced by taghavi _",
    "* algorithm  2 ) and , independently and in a slightly different form , by wadayama  ( * ? ? ?",
    "* fig .  6 ) .",
    "the conditions also serve as the motivation for a new , more efficient adaptive cut - inducing rpc generation algorithm that identifies useful rpcs by performing specific elementary row operations on the original parity - check matrix of the binary linear code . by adding the corresponding linear constraints into the lp problem",
    ", we can significantly improve the error - rate performance of the lp decoder , even approaching the ml decoder performance in the high - snr region for some codes . finally , we modify the alp decoder to make it more efficient when being combined with the new cut - generating algorithm .",
    "simulation results demonstrate that the proposed decoding algorithms significantly improve the error - rate performance of the original lp decoder .",
    "the remainder of the paper is organized as follows . in section  [ sec : lpd ] , we review the original formulation of lp decoding and several adaptive lp decoding algorithms .",
    "section  [ sec : ecsa ] presents the new necessary condition and new sufficient condition for a parity - check to induce a cut , as well as their connection to the efficient cut - search algorithm . in section  [ sec : acga ] , we describe our proposed algorithm for finding rpc - based cuts .",
    "section  [ sec : nr ] presents our simulation results , and section  [ sec : concl ] concludes the paper .",
    "consider a binary linear block code @xmath0 of length @xmath1 and a corresponding @xmath2 parity - check matrix @xmath3 .",
    "a codeword @xmath4 is transmitted across a memoryless binary - input output - symmetric channel , resulting in a received vector @xmath5 .",
    "assuming that the transmitted codewords are equiprobable , the ml decoder finds the solution to the following optimization problem ( see , e.g. , @xcite ) @xmath6 where @xmath7 , and @xmath8 is the vector of log - likelihood ratios ( llr ) defined as @xmath9 since the ml decoding problem is an integer programming problem , it is desirable to replace its integrality constraints with a set of linear constraints , transforming the ip problem into a more readily solved lp problem .",
    "the desired feasible space of the corresponding lp problem should be the _",
    "codeword polytope _ ,",
    "i.e. , the convex hull of all the codewords in @xmath0 . with this , unless the cost vector of the lp decoding problem is orthogonal to a face of the constraint polytope , the optimal solution is one integral vertex of its codeword polytope , in which case it is the same as the output of the ml decoder .",
    "when the lp solution is not unique , there is at least one integral vertex corresponding to an ml codeword .",
    "however , the number of linear constraints typically needed to represent the codeword polytope increases exponentially with the code length , which makes such a relaxation impractical .    as an approximation to ml decoding , feldman _ et al . _",
    "@xcite relaxed the codeword polytope to a polytope now known as _ fundamental polytope _",
    "@xcite , denoted as @xmath10 , which depends on the parity - check matrix @xmath11 .",
    "[ lp ] let us define @xmath12 where @xmath13 is the @xmath14th row of the parity - check matrix @xmath11 and @xmath15 .",
    "thus , @xmath16 is the set of all binary vectors satisfying the @xmath14th parity - check constraint .",
    "we denote by @xmath17 the convex hull of @xmath16 in @xmath18 , which consists of all possible real convex combinations of the points in @xmath16 , now regarded as points in @xmath18 .",
    "the fundamental polytope @xmath10 of the parity - check matrix @xmath11 is defined to be the set @xmath19    therefore , lp decoding can be written as the following optimization problem :    @xmath20    the solution of the above lp problem corresponds to a vertex of the fundamental polytope that minimizes the cost function .",
    "since the fundamental polytope has both integral and nonintegral vertices , with the integral vertices corresponding exactly to the codewords of @xmath21 @xcite , if the lp solver outputs an integral solution , it must be a valid codeword and is guaranteed to be an ml solution , which is called the _",
    "ml certificate property_. the nonintegral solutions are called pseudocodewords . since the fundamental polytope is a function of the parity - check matrix @xmath11 used to represent the code @xmath21 , different parity - check matrices for @xmath21 may have different fundamental polytopes . therefore , a given code has many possible lp - based relaxations , and some may be better than others when used for lp decoding",
    ".    the fundamental polytope can also be described by a set of linear inequalities , obtained as follows @xcite .",
    "first of all , for a point @xmath22 within the fundamental polytope , it should satisfy the box constraints such that @xmath23 , for @xmath24 .",
    "then , let @xmath25 be the set of neighboring variable nodes of the check node @xmath14 in the tanner graph , that is , @xmath26 where @xmath27 is the element in the @xmath14th row and @xmath28th column of the parity - check matrix , @xmath3 . for each row @xmath29 of the parity - check matrix , corresponding to a check node in the associated tanner graph ,",
    "the linear inequalities used to form the fundamental polytope @xmath10 are given by @xmath30 where for a set @xmath31 , @xmath32 denotes its cardinality .",
    "it is easy to see that is equivalent to @xmath33 note that , for each check node @xmath14 , the corresponding inequalities in or and the linear box constraints exactly describe the convex hull of the set @xmath16 .    the linear constraints in ( and",
    "therefore also ) are referred to as _ parity inequalities _ , which are also known as _ forbidden set inequalities _",
    "it can be easily verified that these linear constraints are equivalent to the original parity - check constraints when each @xmath34 takes on binary values only .",
    "[ prop1 ] the parity inequalities of the form derived from all rows of the parity - check matrix @xmath3 and the box constraints completely describe the fundamental polytope @xmath10 .    with this",
    ", lp decoding can also be formulated as follows    @xmath35    in the following parts of this paper , we refer to the above formulation of lp decoding problem based on the fundamental polytope of the original parity - check matrix as the _ original _ lp decoding .      in the original formulation of lp decoding presented in @xcite ,",
    "every check node @xmath14 generates @xmath36 parity inequalities that are used as linear constraints in the lp problem described in .",
    "the total number of constraints and the complexity of the original lp decoding problem grows exponentially with the maximum check node degree .",
    "so , even for binary linear codes with moderate check degrees , the number of constraints in the original lp decoding could be prohibitively large . in the literature , several approaches to reducing the complexity of the original lp formulation have been described @xcite .",
    "we will use adaptive linear programming ( alp ) decoding @xcite as the foundation of the improved lp decoding algorithms presented in later sections .",
    "the alp decoder exploits the structure of the lp decoding problem , reflected in the statement of the following lemma .",
    "[ lemma1 ] if at any given point @xmath37^n$ ] , one of the parity inequalities introduced by a check node @xmath14 is violated , the rest of the parity inequalities from this check node are satisfied with strict inequality .",
    "[ def1]definition    [ def_cut ] given a parity - check node @xmath14 , a set @xmath38 of odd cardinality , and a vector @xmath37^n$ ] such that the corresponding parity inequality of the form or does not hold , we say that the constraint is _ violated _ or , more succinctly , a _ cut _ at @xmath22 . ) does not hold for a pseudocodeword @xmath22 , then the vector @xmath39 , where @xmath40 for all @xmath41 @xmath42 for all @xmath43 @xmath44 otherwise , and @xmath45 , is a _",
    "valid cut _ , separating @xmath22 from the codeword polytope . ]    in @xcite , an efficient algorithm for finding cuts at a vector @xmath37^n$ ] was presented .",
    "it relies on the observation that violation of a parity inequality at @xmath22 implies that @xmath46 where @xmath47 is an odd - sized subset of @xmath48 .    given a parity check @xmath14 , the algorithm first puts its neighboring variables in @xmath22 into non - increasing order , i.e. , @xmath49 , for @xmath50 .",
    "it then successively considers subsets of odd cardinality having the form @xmath51 , increasing the size of @xmath47 by two each step , until a cut ( if one exists ) is found .",
    "this algorithm can find a cut among the constraints corresponding to a check node @xmath14 by examining at most @xmath52 inequalities , rather than exhaustively checking all @xmath36 inequalities in the original formulation of lp decoding .",
    "the alp decoding algorithm starts by solving the lp problem with the same objective function as , but with only the following constraints @xmath53 the solution of this initial lp problem can be obtained simply by making a hard decision on the components of a received vector .",
    "the alp decoding algorithm starts with this point , searches every check node for cuts , adds all the cuts found during the search as constraints into the lp problem , and solves it again .",
    "this procedure is repeated until an optimal integer solution is generated or no more cuts can be found ( see @xcite for more details ) .",
    "adaptive lp decoding has exactly the same error - correcting performance as the original lp decoding .",
    "in this section , we derive a necessary condition and a sufficient condition for a parity inequality to be a cut at @xmath54^n$ ] .",
    "we also show their connection to the efficient cut - search algorithm proposed by taghavi _",
    "et al . _",
    "* algorithm  2 ) and wadayama  ( * ? ? ?",
    "* fig .  6 ) .",
    "this algorithm is more efficient than the search technique from @xcite that was mentioned in section  [ sec : lpd ] .",
    "consider the original parity inequalities in given by feldman _",
    "et al . _ in @xcite .",
    "if a parity inequality derived from check node @xmath14 induces a cut at @xmath55 , the cut can be written as    @xmath56    from and lemma [ lemma1 ] , we can derive the following necessary condition for a parity - check constraint to induce a cut .",
    "[ thm1 ] given a nonintegral vector @xmath22 and a parity check @xmath14 , let @xmath57 be the set of nonintegral neighbors of @xmath14 in the tanner graph , and let @xmath58 .",
    "a necessary condition for parity check @xmath14 to induce a cut at @xmath22 is @xmath59 this is equivalent to @xmath60 where , for @xmath61 , @xmath62 denotes the absolute value .    for a given vector @xmath22 and a subset @xmath63 , define the function",
    "@xmath64 if parity - check @xmath14 incudes a cut at @xmath22 , there must be a set @xmath65 of odd cardinality such that ( [ cut ] ) holds .",
    "this means that @xmath66 .",
    "now , it is easy to see that the set @xmath67 minimizes the function @xmath68 , from which it follows that @xmath69",
    ". therefore , inequality must hold in order for parity check @xmath14 to induce a cut .    for @xmath70",
    ", we have @xmath71 and for @xmath72 , we have @xmath73 hence , can be rewritten as @xmath74 or equivalently , @xmath75 which implies inequality .",
    "[ thm1rm ] theorem  [ thm1 ] shows that to see whether a parity - check node could provide a cut at a pseudocodeword @xmath22 we only need to examine its fractional neighbors .",
    "reasoning similar to that used in the proof of theorem  [ thm1 ] yields a sufficient condition for a parity - check node to induce a cut at @xmath22 .",
    "[ thm1]theorem    [ thm2 ] given a nonintegral vector @xmath22 and a parity check @xmath14 , let @xmath57 and @xmath58 . if the inequality @xmath76 holds , there must be a violated parity inequality derived from parity check @xmath14 .",
    "this sufficient condition can be written as @xmath77    lemma [ lemma1 ] implies that , if parity check @xmath14 gives a cut at @xmath22 , then there is at most one odd - sized set @xmath78 that satisfies . from the proof of theorem [ thm1 ]",
    ", we have @xmath79 @xmath80 .",
    "if @xmath81 is even , we need to find one element @xmath82 such that inserting it into or removing it from @xmath67 would result in the minimum increment to the value of @xmath83 .",
    "obviously , @xmath84 , and the increment is @xmath85 . if more than one @xmath28 minimizes the expression @xmath86 , we choose one arbitrarily as @xmath87 .",
    "hence , setting @xmath88 we have @xmath89 .",
    "if inequality holds , then @xmath90 .",
    "since either @xmath91 or @xmath92 is odd , is a sufficient condition for parity - check constraint @xmath14 to induce a cut at @xmath22 .",
    "arguing as in the latter part of the proof of theorem  [ thm1 ] , it can be shown that is equivalent to .",
    "theorem [ thm1 ] and theorem [ thm2 ] provide a necessary condition and a sufficient condition , respectively , for a parity - check node to produce a cut at any given vector @xmath22 .",
    "it is worth pointing out that becomes a necessary and sufficient condition for a parity check to produce a cut when @xmath91 is odd , and becomes a necessary and sufficient condition when @xmath91 is even .",
    "together , they suggest a highly efficient technique for finding cuts , the cut - search algorithm ( csa ) described in algorithm  [ alg1 ] . if there is a violated parity inequality , the csa returns the set @xmath47 corresponding to the cut ; otherwise , it returns an empty set .",
    "as mentioned above , the csa was used by taghavi _",
    "et al . _",
    "* algorithm  2 ) in conjunction with alp decoding , and by wadayama  ( * ? ? ?",
    "6 ) as a feasibility check in the context of interior point decoding . in addition to providing another perspective on the csa , the necessary condition and sufficient condition proved in theorems 1 and 2 , respectively ,",
    "serve as the basis for a new adaptive approach to finding cut - inducing rpcs , as described in the next section .",
    "parity - check node @xmath14 and vector @xmath55 variable node set @xmath47 @xmath93 and @xmath94 @xmath95 @xmath96 arbitrary @xmath97 @xmath98 @xmath99 found the violated parity inequality on parity - check node @xmath14 there is no violated parity inequality on parity - check node @xmath14 @xmath100 @xmath47",
    "although the addition of a redundant row to a parity - check matrix does not affect the @xmath101-nullspace and , therefore , the linear code it defines , different parity - check matrix representations of a linear code may give different fundamental polytopes underlying the corresponding lp relaxation of the ml decoding problem .",
    "this fact inspires the use of cutting - plane techniques to improve the error - correcting performance of the original lp and alp decoders .",
    "specifically , when the lp decoder gives a nonintegral solution ( i.e. , a pseudocodeword ) , we try to find the rpcs that introduce cuts at that point , if such rpcs exist .",
    "the cuts obtained in this manner are called _",
    "rpc cuts_. the effectiveness of this method depends on how closely the new relaxation approximates the ml decoding problem , as well as on the efficiency of the technique used to search for the cut - inducing rpcs .",
    "an rpc can be obtained by modulo-2 addition of some of the rows of the original parity - check matrix , and this new check introduces a number of linear constraints that may give a cut . in @xcite , a random walk on a cycle within the subgraph defined by the nonintegral entries in a pseudocodeword served as the basis for a search for rpc cuts .",
    "however , there is no guarantee that this method will find a cut ( if one exists ) within a finite number of iterations .",
    "in fact , the average number of random trials needed to find an rpc cut grows exponentially with the code length .",
    "the ip - based separation algorithm in @xcite performs gaussian elimination on a submatrix comprising the columns of the original parity - check matrix that correspond to the nonintegral entries in a pseudocodeword in order to get redundant parity checks . in  @xcite ,",
    "the rpcs that potentially provide cutting planes are obtained by transforming a column - permuted version of the submatrix into row echelon form .",
    "the chosen permutation organizes the columns according to descending order of their associated nonintegral pseudocodeword entries , with the exception of the column corresponding to the largest nonintegral entry , which is placed in the rightmost position of the submatrix @xcite .",
    "this approach was motivated by the fact that a parity check @xmath14 provides a cut at a pseudocodeword if there exists a variable node in @xmath48 whose value is greater than the sum of the values of all of the other neighboring variable nodes ( * ? ? ?",
    "* lemma 2 ) .",
    "however , when combined with alp decoding , the resulting `` cutting - plane algorithm '' does not provide sufficiently many cuts to surpass the separation algorithm in error - rate performance .",
    "motivated by the new derivation of the csa based on the conditions in theorems [ thm1 ] and [ thm2 ] , we next propose a new algorithm for generating cut - inducing rpcs .",
    "when used with alp decoding , the cuts have been found empirically to achieve near - ml decoding performance in the high - snr region for several short - to - moderate length ldpc codes .",
    "however , application of these new techniques to codes with larger block lengths proved to be prohibitive computationally , indicating that further work is required to develop practical methods for enhanced lp decoding of longer codes .",
    "given a nonintegral solution of the lp problem , we can see from theorems [ thm1 ] and [ thm2 ] that an rpc with a small number of nonintegral neighboring variable nodes may be more likely to satisfy the necessary condition for providing a cut at the pseudocodeword .",
    "moreover , the nonintegral neighbors should have values either close to 0 or close to 1 ; in other words , they should be as far from @xmath102 as possible .",
    "let @xmath103^n$ ] be a pseudocodeword solution to lp decoding , with @xmath104 nonintegral positions , @xmath105 zeros , and @xmath106 ones .",
    "we first group entries of @xmath107 according to whether their values are nonintegral , zero , or one",
    ". then , we sort the nonintegral positions in ascending order according to the value of @xmath108 and define the permuted vector @xmath109 satisfying the following ordering @xmath110 @xmath111 and@xmath112 by applying the same permutation @xmath113 to the columns of the original parity - check matrix @xmath3 , we get @xmath114 where @xmath115 , @xmath116 , and @xmath117 consist of columns of @xmath11 corresponding to positions of @xmath118 with nonintegral values , zeros , and ones , respectively .    the following familiar definition from matrix theory will be useful @xcite .",
    "[ def1]definition    [ def_ref ] a matrix is in _ reduced row echelon form _",
    "if its nonzero rows ( i.e. , rows with at least one nonzero element ) are above any all - zero rows , and the leading entry ( i.e. , the first nonzero entry from the left ) of a nonzero row is the only nonzero entry in its column and is always strictly to the right of the leading entry of the row above it .    by applying a suitable sequence of elementary row operations @xmath119 ( over @xmath101 ) to @xmath120 , we get @xmath121 where @xmath122 is in reduced row echelon form . applying the inverse permutation @xmath123 to columns of @xmath124",
    ", we get an equivalent parity - check matrix @xmath125 whose rows are likely to be cut - inducing rpcs , for the reasons stated above .",
    "multiple nonintegral positions in the pseudocodeword @xmath107 could have values of the same distance from @xmath102 , i.e. , @xmath126 for some @xmath127 .",
    "in such a case , the ordering of the nonintegral positions in is not uniquely determined .",
    "hence , the set of rpcs generated by operations  may depend upon the particular ordering reflected in the permutation @xmath113 .",
    "nevertheless , if the decoder uses a fixed , deterministic sorting rule such as , for example , a stable sorting algorithm , then the decoding error probability will be independent of the transmitted codeword .",
    "the next theorem describes a situation in which a row of @xmath128 is guaranteed to provide a cut .",
    "[ thm1]theorem    [ thm3 ] if there exists a weight - one row in submatrix @xmath122 , the corresponding row of the equivalent parity - check matrix @xmath128 is a cut - inducing rpc .",
    "given a pseudocodeword @xmath107 , suppose the @xmath14th row of submatrix @xmath122 has weight one and the corresponding nonintegral position in @xmath107 is @xmath129 . since it is the only nonintegral position in @xmath48 , the left - hand side of is equal to @xmath130 .",
    "since @xmath131 , this is larger than @xmath132 , the right - hand side . hence , according to theorem [ thm2 ] , rpc @xmath14 satisfies the sufficient condition for providing a cut . in other words , there must be a violated parity inequality induced by rpc @xmath14 .",
    "[ thm1rm]remark    [ thm3rm ] theorem  [ thm3 ] is equivalent to ( * ? ? ?",
    "* theorem  3.3 ) .",
    "the proof of the result shown here , though , is considerably simpler , thanks to the application of theorem  [ thm2 ] .",
    "although theorem  [ thm3 ] only ensures a cut for rows with weight one in submatrix @xmath122 , rows in @xmath122 of weight",
    "larger than one may also provide rpc cuts .",
    "hence , the csa should be applied on every row of the redundant parity - check matrix @xmath128 to search for all possible rpc cuts .",
    "the approach of generating a redundant parity - check matrix @xmath128 based on a given pseudocodeword and applying the csa on each row of this matrix is called adaptive cut generation ( acg ) .",
    "combining acg with alp decoding , we obtain the acg - alp decoding algorithm described in algorithm  [ alg2 ] . beginning with the original parity - check matrix",
    ", the algorithm iteratively applies alp decoding .",
    "when a point is reached when no further cuts can be produced from the original parity - check matrix , the acg technique is invoked to see whether any rpc cuts can be generated .",
    "the acg - alp decoding iteration stops when no more cuts can be found either from the original parity - check matrix or in the form of redundant parity checks .",
    "cost vector @xmath8 , original parity - check matrix @xmath3 optimal solution of current lp problem initialize the lp problem with the constraints in .",
    "solve the current lp problem , and get optimal solution @xmath133 .",
    "apply * algorithm 1 ( csa ) * on each row of @xmath3 .",
    "construct @xmath128 associated with @xmath133 according to . apply * algorithm 1 ( csa ) * to each row of @xmath128 .",
    "add cuts that are found into the lp problem as constraints , and go to line 2 .      in the alp decoding",
    ", the number of constraints in the lp problem grows as the number of iterations grows , increasing the complexity of solving the lp problem . for acg - alp decoding , this problem becomes more severe since the algorithm generates additional rpc cuts and uses more iterations to successfully decode inputs on which the alp decoder has failed .    from lemma  [ lemma1 ] , we know that a binary parity - check constraint can provide at most one cut .",
    "hence , if a binary parity check gives a cut , all other linear inequalities introduced by this parity check in previous iterations can be removed from the lp problem .",
    "the implementation of this observation leads to a _ modified alp ( malp ) _ decoder referred to as the malp - a decoder  @xcite .",
    "this decoder improves the efficiency of alp decoding , where only cuts associated with the original parity - check matrix are used .",
    "however , with acg - alp decoding , different rpcs may be generated adaptively in every iteration and most of them give only one cut throughout the sequence of decoding iterations .",
    "as a result , when malp - a decoding is combined with the acg technique , only a small number of constraints are removed from the lp problem , and the decoding complexity is only slightly reduced .",
    "[ def1]definition    [ def_act ] a linear inequality constraint of the form @xmath134 is called _ active _ at point @xmath135 if it holds with equality , i.e. , @xmath136 , and is called _ inactive _ otherwise .    for an lp problem with a set of linear inequality constraints , the optimal solution @xmath137^n$ ]",
    "is a vertex of the polytope formed by the hyperplanes corresponding to all active constraints . in other words ,",
    "if we set up an lp problem with only those active constraints , the optimal solution remains the same .",
    "therefore , a simple and intuitive way to reduce the number of constraints is to remove all inactive constraints from the lp problem at the end of each iteration , regardless of whether or not the corresponding binary parity check generates a cut .",
    "this approach is called malp - b decoding  @xcite . by combining the acg technique and the malp - b algorithm",
    ", we obtain the acg - malp - b decoding algorithm .",
    "it is similar to the acg - alp algorithm described in algorithm  [ alg2 ] but includes one additional step that removes all inactive constraints from the lp problem , as indicated in line 3 of algorithm  [ alg3 ] .",
    "since adding further constraints into an lp problem reduces the feasible space , the minimum value of the cost function is non - decreasing as a function of the number of iterations . in our computer simulations ,",
    "the acg - malp - b decoding algorithm was terminated when no further cuts could be found .",
    "( see fig .",
    "[ fig_iter ] for statistics on the average number of iterations required to decode one codeword of the ( 155,64 ) tanner ldpc code . )    cost vector @xmath8 , original parity - check matrix @xmath3 optimal solution of current lp problem initialize lp problem with the constraints in .",
    "solve the current lp problem , get optimal solution @xmath133 .",
    "acg - malp - b only : remove all inactive constraints from the lp problem .",
    "acg - malp - c only : remove inactive constraints that have above - average slack values from the lp problem . apply * csa * only on rows of @xmath3 that have not introduced constraints .",
    "construct @xmath128 according to @xmath133 apply * csa * on each row of @xmath128 . terminate .",
    "add found cuts into lp problem as constraints , and go to line 2 .    in our implementation of both malp - b and acg - malp - b decoding",
    ", we have noticed that a considerable number of the constraints deleted in previous iterations are added back into the lp problem in later iterations , and , in fact , many of them are added and deleted several times .",
    "we have observed that malp - b - based decoding generally takes more iterations to decode a codeword than alp - based decoding , resulting in a tradeoff between the number of iterations and the size of the constituent lp problems .",
    "malp - b - based decoding has the largest number of iterations and the smallest lp problems to solve in each iteration , while alp - based decoding has a smaller number of iterations but larger lp problems .",
    "although it is difficult to know in advance which inactive constraints might become cuts in later iterations , there are several ways to find a better tradeoff between the malp - b and alp techniques to speed up lp decoding .",
    "this tradeoff , however , is highly dependent on the lp solver used in the implementation .",
    "for example , we used the simplex solver from the open - source gnu linear programming kit ( glpk )  @xcite , and found that the efficiency of iterative alp - based decoders is closely related to the total number of constraints used to decode one codeword , i.e. , the sum of the number of constraints used in all iterations .",
    "this suggests a new criterion for the removal of inactive constraints whose implementation we call the malp - c decoder .    in malp - c decoding , instead of removing all inactive constraints from the lp problem in each iteration",
    ", we remove only the linear inequality constraints with slack variables that have above - average values , as indicated in line 4 of algorithm  [ alg3 ] .",
    "the acg - malp - b and acg - malp - c decoding algorithms are both described in algorithm  [ alg3 ] , differing only in the use of line 3 or line 4 .",
    "although all three of the adaptive variations of lp decoding discussed in this paper  alp , malp - b , and malp - c  have the exact same error - rate performance as the original lp decoder , they may lead to different decoding results for a given received vector when combined with the acg technique , as shown in the next section .",
    "to demonstrate the improvement offered by our proposed decoding algorithms , we compared their error - correcting performance to that of alp decoding ( which , again , has the same performance as the original lp decoding ) , bp decoding ( two cases , using the sum - product algorithm with a maximum of 100 iterations and 1000 iterations , respectively ) , the separation algorithm ( sa ) @xcite , the random - walk - based rpc search algorithm @xcite , and ml decoding for various ldpc codes on the additive white gaussian noise ( awgn ) channel .",
    "we use the simplex algorithm from the open - source glpk @xcite as our lp solver .",
    "the ldpc codes we evaluated are mackay s rate-@xmath102 , ( 3,6)-regular ldpc codes with lengths 96 and 408 , respectively @xcite ; a rate-@xmath138 , ( 3,4)-regular ldpc code of length 100 ; the rate-@xmath139 , ( 3,5)-regular tanner code of length 155 @xcite ; and a rate-0.89 , ( 3,27)-regular high - rate ldpc code of length 999 @xcite .",
    "the proposed acg - alp , acg - malp - b , and acg - malp - c decoding algorithms are all based on the underlying cut - searching algorithm ( algorithm  [ alg1 ] ) and the adaptive cut - generation technique of section  [ subsec : rpc ] . therefore , their error - rate performance is very similar .",
    "however , their performance may not be identical , because cuts are found adaptively from the output pseudocodewords in each iteration and the different sets of constraints used in the three proposed algorithms may lead to different solutions of the corresponding lp problems .    in our simulation ,",
    "the lp solver uses double - precision floating - point arithmetic , and therefore , due to this limited numerical resolution , it may round some small nonzero vector coordinate values to 0 or output small nonzero values for vector coordinates which should be 0 .",
    "similar rounding errors may occur for coordinate values close to 1 .",
    "coordinates whose values get rounded to integers by the lp solver might lead to some `` false '' cuts  parity inequalities not actually violated by the exact lp solution .",
    "this is because such rounding by the lp solver would decrease the left - hand side of parity inequality . on the other hand ,",
    "when coordinates that should have integer values are given nonintegral values , the resulting errors would increase the left - hand side of parity inequality , causing some cuts to be missed .",
    "moreover , this would also increase the size of the submatrix @xmath115 in , leading to higher complexity for the acg - alp decoding algorithm .",
    "to avoid such numerical problems in our implementation of the csa , we used @xmath140 instead of 1 on the right - hand side of the inequality in line 14 of algorithm  [ alg1 ] . whenever the lp solver outputs a solution vector , coordinates with value less than @xmath141 were rounded to 0 and coordinates with value larger than @xmath140 were rounded to 1 .",
    "the rounded values were then used in the cut - search and rpc - generation steps in the decoding algorithms described in previous sections . if such a procedure were not applied , and if , as a result , false cuts were to be produced , the corresponding constraints , when added into the lp problem to be solved in the next step , would leave the solution vector unchanged , causing the decoder to become stuck in an endless loop .",
    "we saw no such behavior in our decoder simulations incorporating the prescribed thresholding operations .",
    "finally , we want to point out that there exist lp solvers , such as _ qsopt_ex rational lp solver _ @xcite , that produce exact rational solutions to lp instances with rational input .",
    "however , such solvers generally have higher computational overhead than their floating - point counterparts . for this reason",
    ", we did not use an exact rational lp solver in our empirical studies .     for random ( 3,4)-regular ldpc code of length 100 on the awgn channel .",
    "]    fig .",
    "[ fig_fer_100 ] shows the simulation results for the length-100 , regular-(3,4 ) ldpc code whose fer performance was also evalutated in @xcite and @xcite .",
    "we can see that the proposed algorithms have a gain of about 2  db over the original lp and alp decoder .",
    "they also perform significantly better than both the separation algorithm and the random - walk algorithm .",
    "the figure also shows the results obtained with the box - and - match soft - decision decoding algorithm ( bma ) @xcite , whose fer performance is guaranteed to be within a factor of 1.05 times that of ml decoding .",
    "we conclude that the performance gap between the proposed decoders and ml decoding is less than 0.2  db at an fer of @xmath142 .        [ cols=\"^,^,^,^,^ \" , ]         from fig .",
    "[ fig_iter ] and fig .",
    "[ subfig_cst ] , we can see that , as expected , the acg - alp decoder takes fewer iterations to decode a codeword on average than the acg - malp - b / c decoders , but the acg - malp - b / c decoders have fewer constraints in each iteration , including the final iteration .",
    "we have observed that the acg - malp - b / c decoders require a larger number of iterations to decode than the acg - alp decoder , and fewer cuts are added into the constituent lp problems in each iteration on average , as reflected in fig .",
    "[ subfig_cpi ] .",
    "this is because there are some iterations in which the added constraints had been previously removed . among all three",
    "proposed acg - based decoding algorithms , we can see that the acg - alp decoder has the largest number of constraints in the final iteration and needs the least overall number of iterations to decode , while acg - malp - b decoding has the smallest number of constraints but requires the largest number of iterations .",
    "the acg - malp - c decoder offers a tradeoff between those two : it has fewer constraints than the acg - alp decoder and requires fewer iterations than the acg - malp - b decoder .",
    "if we use the accumulated number of constraints in all iterations to decode one codeword as a criterion to judge the efficiency of these algorithms during simulation , then acg - malp - c decoding is more efficient than the other two algorithms in the low and moderate snr regions , as shown in table  [ tabcst ] .",
    "note that the acg - malp - b decoder is most efficient at high snr where the decoding of most codewords succeeds in a few iterations and the chance of a previously removed inactive constraint being added back in later iterations is quite small .",
    "hence , acg - malp - b decoding is preferred in the high - snr region .    fig .",
    "[ fig_simt ] presents an alternative way of comparing the complexity of the decoding algorithms .",
    "it shows the average decoding time when we implement the algorithms using c++ code on a desktop pc , with glpk as the lp solver .",
    "the bp decoder is implemented in software with messages represented as double - precision floating - point numbers , and the exact computation of sum - product algorithm is used , without any simplification or approximation .",
    "the bp decoder iterations stop as soon as a codeword is found , or when the maximum allowable number of iterations  here set to 100 and 1000  have been attempted without convergence . the simulation time is averaged over the number of transmitted codewords required for the decoder to fail on 200 codewords .",
    "we observe that the acg - malp - b and acg - malp - c decoders are both uniformly faster than acg - alp over the range of snr values considered , and , as expected from table  [ tabcst ] , acg - malp - c decoding is slightly more efficient than acg - malp - b decoding in terms of actual running time .",
    "of course , the decoding time depends both on the number of lp problems solved and the size of these lp problems , and the preferred trade - off depends heavily upon the implementation , particularly the lp solver that is used .",
    "obviously , the improvement in error - rate performance provided by all three acg - based decoding algorithms over the alp decoding comes at the cost of increased decoding complexity .",
    "as snr increases , however , the average decoding complexity per codeword of the proposed algorithms approaches that of the alp decoder .",
    "this is because , at higher snr , the decoders can often successfully decode the received frames without generating rpc cuts .",
    "[ fig_iter ] shows that the acg - alp decoder requires , on average , more iterations than the sa decoder .",
    "our observations suggest that this is a result of the fact that the acg - alp decoder can continue to generate new rpc cuts after the number of iterations at which the sa decoder can no longer do so and , hence , stops decoding .",
    "the simulation data showed that the additional iterations of the acg - alp decoder often resulted in a valid codeword , thus contributing to its superiority in perfomance relative to the sa decoder .    from fig .",
    "[ subfig_cpi ] , it can be seen that the acg - alp - based decoding algorithms generate , on average , fewer cuts per iteration than the sa decoder .",
    "moreover , as reflected in fig .",
    "[ subfig_hcut ] and [ subfig_rcut ] , the acg - alp decoders find more cuts from the original parity - check matrix and generate fewer rpc cuts per codeword .",
    "these observations suggest that the csa is very efficient in finding cuts from a given parity check , while the sa decoder tends to generate rpcs even when there are still some cuts other than the gomory cuts that can be found from the original parity - check matrix .",
    "this accounts for the fact , reflected in fig .",
    "[ fig_simt ] , that the sa becomes less efficient as snr increases , when the original parity - check matrix usually can provide enough cuts to decode a codeword .",
    "the effectiveness of our cut - search algorithm permits the acg - alp - based decoders to successfully decode most codewords in the high - snr region without generating rpcs , resulting in better overall decoder efficiency .",
    "due to limitations on our computing capability , we have not yet tested our proposed algorithms on ldpc codes of length greater than 1000 .",
    "we note that , in contrast to @xcite and @xcite , we can not give an upper bound on the maximum number of iterations required by the acg - alp - based decoding algorithms because rpcs and their corresponding parity inequalities are generated adaptively as a function of intermediate pseudocodewords arising during the decoding process . consequently , even though the decoding of short - to - moderate length ldpc codes was found empirically to converge after an acceptable number of interations , some sort of constraint on the maximum number of iterations allowed may have to be imposed when decoding longer codes .",
    "finally , we point out that the complexity of the algorithm for generating cut - inducing rpcs lies mainly in the gaussian elimination step , but as applied to binary matrices , this requires only logical operations which can be executed quite efficiently .",
    "in this paper , we derived a new necessary condition and a new sufficient condition for a parity - check constraint in a linear block code parity - check matrix to provide a violated parity inequality , or cut , at a pseudocodeword produced by lp decoding . using these results",
    ", we presented an efficient algorithm to search for such cuts and proposed an effective approach to generating cut - inducing redundant parity checks ( rpcs ) .",
    "the key innovation in the cut - generating approach is a particular transformation of the parity - check matrix used in the definition of the lp decoding problem . by properly re - ordering the columns of the original parity - check matrix and transforming the resulting matrix into a `` partial '' reduced row echelon form",
    ", we could efficiently identify rpc cuts that were found empirically to significantly improve the lp decoder performance .",
    "we combined the new cut - generation technique with three variations of adaptive lp decoding , providing a tradeoff between the number of iterations required and the number of constraints in the constituent lp problems .",
    "frame - error - rate ( fer ) simulation results for several ldpc codes of length up to 999 show that the proposed adaptive cut - generation , adaptive lp ( acg - alp ) decoding algorithms outperform other enhanced lp decoders , such as the separation algorithm ( sa ) decoder , and significantly narrow the gap to ml decoding performance for ldpc codes with short - to - moderate block lengths .",
    "10 r. g. gallager , `` low - density parity - check codes . ''",
    "_ ire trans .",
    "inform . theory _",
    ", vol . 8 , pp .",
    "2128 , jan . 1962 .",
    "d. j. c. mackay and r. m. neal , `` good codes based on very sparse matrices , '' in _ cryptography and coding : lecture notes in computer science _ , vol .",
    "1025 . c. boyd , ed",
    "heidelberg : springer berlin , 1995 , pp . 100111 .",
    "d. j. c. mackay and r. m. neal , `` near shannon - limit performance of low density parity check codes , '' _ electron .",
    "457458 , mar . 13 , 1997 .",
    "r. mceliece , d. mackay , and j. cheng , `` turbo decoding as an instance of pearl s `` belief propagation '' algorithm , '' _ ieee j. sel .",
    "areas commun .",
    "2 , pp . 140152 , feb . 1998 .",
    "f. r. kschischang , b. j. frey , and h .- a .",
    "loeliger , `` factor graphs and the sum - product algorithm , '' _ ieee trans .",
    "inform . theory _",
    "2 , pp . 498519 , feb . 2001 .",
    "j. feldman , m.  j. wainwright , and d.  r.  karger , `` using linear programming to decode binary linear codes , '' _ ieee trans .",
    "inform . theory _",
    "3 , pp . 954972 , mar .",
    "p. o. vontobel and r. koetter , `` graph - cover decoding and finite - length analysis of message - passing iterative decoding of ldpc codes , '' corr , arxiv.org/abs/cs.it/0512078 .",
    "j. feldman , `` decoding error - correcting codes via linear programming , '' ph.d .",
    "dissertation , dept .",
    "sci . , mass .",
    "technol . , cambridge , ma , 2003 .",
    "k. yang , x.  wang , and j. feldman , `` a new linear programming approach to decoding linear block codes , '' _ ieee trans .",
    "inform . theory _",
    "3 , pp . 10611072 , mar .",
    "m. chertkov and m. stepanov , `` pseudo - codeword landscape , '' in _ proc ieee int .",
    "theory ( isit ) _ , nice , france , jun .",
    "2007 , pp .",
    "p. o. vontobel and r. koetter , `` on low - complexity linear - programming decoding of ldpc codes , '' _ europ",
    "18 , pp . 509517 , apr . 2007 .",
    "m. h. taghavi and p. h. siegel , `` adaptive methods for linear programming decoding , '' _ ieee trans .",
    "inform . theory _",
    "53965410 , dec . 2008 .",
    "a. tanatmis , s. ruzika , h.  w.  hamacher , m.  punekar , f.  kienle , and n.  wehn , `` a separation algorithm for improved lp - decoding of linear block codes , '' _ ieee trans .",
    "inform . theory _",
    "56 , no . 7 , pp",
    ". 32773289 , jul .",
    "m. miwa , t.  wadayama , and i.  takumi , `` a cutting - plane method based on redundant rows for improving fractional distance , '' _ ieee j. sel .",
    "areas commun .",
    "_ , vol 27 , no . 6 , pp .",
    "11051012 , aug .",
    "m. helmling , s. ruzika , and a. tanatmis ,  mathematical programming decoding of binary linear codes : theory and algorithms , ",
    "arxiv:1107.3715 [ cs.it ] m. h. taghavi , a. shokrollahi , and p.  h.  siegel , `` efficient implementation of linear programming decoding , '' _ ieee trans .",
    "inform . theory _ , vol .",
    "9 , pp . 59605982 , sep . 2011",
    ". t. wadayama , `` interior point decoding for linear vector channels based on convex optimization , '' _ ieee trans .",
    "inform . theory _ ,",
    "10 , pp . 49054921 , oct .",
    "r. a. horn and c.  r.  johnson , _ matrix analysis_. cambridge , uk : cambridge university press , 1990 . gnu linear programming kit , [ online ] .",
    "available : http://www.gnu.org/software/glpk d. j. c. mackay , _ encyclopedia of sparse graph codes_. [ online ] .",
    "available : http://www.inference.phy.cam.ac.uk/mackay/codes/data.html r. m. tanner , d. sridhara , and t.  fuja , `` a class of group - structured ldpc codes , '' in _ proc .",
    "commun . theory and appl .",
    "( iscta ) _ , ambleside , u.k .",
    "2001 , pp .",
    "qsopt linear programming solver , [ online ] .",
    "available : http://www2.isye.gatech.edu/~wcook/qsopt/index.html a. valembois and m. fossorier , `` box and match techniques applied to soft decision decoding , '' _ ieee trans .",
    "inf . theory _",
    "5 , pp . 796810 , may 2004 ."
  ],
  "abstract_text": [
    "<S> linear programming ( lp ) decoding approximates maximum - likelihood ( ml ) decoding of a linear block code by relaxing the equivalent ml integer programming ( ip ) problem into a more easily solved lp problem . </S>",
    "<S> the lp problem is defined by a set of box constraints together with a set of linear inequalities called `` parity inequalities '' that are derived from the constraints represented by the rows of a parity - check matrix of the code and can be added iteratively and adaptively . in this paper </S>",
    "<S> , we first derive a new necessary condition and a new sufficient condition for a violated parity inequality constraint , or `` cut , '' at a point in the unit hypercube . </S>",
    "<S> then , we propose a new and effective algorithm to generate parity inequalities derived from certain additional redundant parity check ( rpc ) constraints that can eliminate pseudocodewords produced by the lp decoder , often significantly improving the decoder error - rate performance . </S>",
    "<S> the cut - generating algorithm is based upon a specific transformation of an initial parity - check matrix of the linear block code . </S>",
    "<S> we also design two variations of the proposed decoder to make it more efficient when it is combined with the new cut - generating algorithm . </S>",
    "<S> simulation results for several low - density parity - check ( ldpc ) codes demonstrate that the proposed decoding algorithms significantly narrow the performance gap between lp decoding and ml decoding </S>",
    "<S> .    low - density parity - check ( ldpc ) codes , linear codes , linear programming ( lp ) decoding , iterative decoding , maximum - likelihood ( ml ) decoding , pseudocodewords . </S>"
  ]
}