{
  "article_text": [
    "in the research of verification , very often two types of specification properties attract most interest from academia and industry .",
    "the first type specifies that _ `` bad things will never happen '' _ while the second type specifies that _",
    "`` good things will happen''_@xcite . in linear temporal logics ,",
    "the former is captured by modal operator @xmath3 while the latter by @xmath4@xcite .",
    "tremendous research effort has been devoted to the efficient analysis of these two types of properties in the framework of linear temporal logics@xcite . in the branching temporal logics of ( timed ) _",
    "ctl_@xcite , these two types can be mapped to modal operators @xmath5 and @xmath6 respectively .",
    "@xmath5 properties are called _ safety _ properties while @xmath6 s are usually called _ inevitability _ properties@xcite . in the domain of dense - time system verification ,",
    "people have focused on the efficient analysis of safety properties@xcite .",
    "inevitability properties in _ timed ctl ( tctl)_@xcite are comparatively more complex to analyze due to the following reason . in the framework of model - checking , to analyze an inevitability property , say @xmath0 , we actually compute the set of states that satisfy the negation of inevitability , in symbols @xmath7 $ ] , and then use the intersection emptiness between @xmath7 $ ] and the initial states for the answer to the inevitability anlaysis . however , property @xmath8 in tctl semantics is only satisfied with non - zeno computations@xcite .",
    "( zeno computations are those counter - intuitive infinite computations whose execution times converge to a finite value@xcite . ) for example , a specification like    `` along all computations , eventually a bus collision will happen in three time units ''    can be violated by a zeno computation whose execution time converges to a finite timepoint , e.g. 2.9 . such requirement on non - zeno computations",
    "may add complexity to the evaluation of inevitability properties .",
    "in this work , we present our symbolic tctl model - checking algorithm which can handle the non - zeno requirement in the evaluation of _ greatest fixpoints_. the evaluation of inevitability properties in tctl involves nested reachability analysis and demands much higher complexity than simple safety analysis .    to contain the complexity of tctl inevitability ,",
    "it is important to integrate new and old techniques for a performance solution . in this paper , we investigate three approaches . in the first approach ,",
    "we investigate how to adjust a parameter value in our greatest fixpoint evaluation algorithms for better performance .",
    "we have carried out experiments to get insight on this issue .    in the second approach",
    ", we present a technique called _ early decision on the greatest fixpoint ( edgf)_. the idea is that , in the evaluation of the greatest fixpoints , we start with a state - space and iteratively pare states from it until we reach a fixpoint . throughout iterations of the greatest fixpoint evaluations ,",
    "the state - space is non - increasing .",
    "thus , if in a middle greatest fixpoint evaluation iteration , we find that target states have already been pared from the greatest fixpoint , we can conclude that it is not possible to include these target states in the fixpoint . through this technique",
    ", we can reduce time - complexity irrelevant to the answer of the model - checking . as reported in section  [ sec.experiments ] , significant performance improvement has been observed in several benchmarks .",
    "our third approach is to use abstraction techniques@xcite .",
    "we shall focus on a special subclass , , of tctl in which every formula can be analyzed with safe abstraction if over - approximation is used in the evaluation of its negation .",
    "for example , we may write the following formula in the subclass .",
    "@xmath9    this formula says that if a request is responded by a service , then a request will follow the service .",
    "this subclass allows for nested modal formulas and we feel that it captures many tctl inevitability properties .    one challenge in designing safe abstraction techniques in model - checking is making them accurate enough to discern many true properties , while still allowing us to enhance verification performance . in previous research , people have designed many abstraction techniques for reachability analysis@xcite , as have we@xcite .",
    "however , for model - checking formulas in , abstraction accuracy can be a bigger issue since the inaccuracy in abstraction can be potentially magnified when we use inaccurate evaluation results of nested modal subformulas to evaluate nesting modal subformulas with abstraction techniques .",
    "thus it is important to discern accuracy of previous abstraction techniques in discerning true formulas .    in this paper",
    ", we also discuss another possibility for abstract evaluation of greatest fixpoints , which is to omit the requirement for non - zeno computations in tctl semantics . as reported in section  [ sec.experiments ] , many benchmarks are true even without exclusion of zeno computations .",
    "finally , we have implemented these ideas in our model - checker / simulator red 4.1@xcite .",
    "we report here our experiments to observe the effects of parameter values , edgf , various abstraction techniques , and non - zeno requirements on our inevitability analysis .",
    "we also compare our analysis with kronos 5.1@xcite , which is another model - checker for full tctl .",
    "our presentation is ordered as follows .",
    "section  [ sec.relwork ] discusses several related works .",
    "sections  [ sec.system ] and [ sec.tctl ] give brief presentations of our model , _ timed automata ( ta ) _ , and tctl . section  [ sec.algorithm ] presents our tctl model - checking algorithm with requirements for non - zeno computations .",
    "section  [ sec.edgf ] improves our model - checking algorithm using an edgf technique .",
    "section  [ sec.zeno ] gives another version of a greatest fixpoint evaluation algorithm by omitting the requirement of non - zeno computations .",
    "section  [ sec.tctle ] identifies the subclass of tctl which supersedes many inevitability properties , while allowing for safe abstract model - checking by using over - approximation techniques .",
    "section  [ sec.experiments ] illustrates our experiment results and helps clarify how various techniques can be used to improve analysis of inevitability properties .",
    "section  [ sec.conc ] is the conclusion .",
    "the ta model with dense - time clocks was first presented in @xcite .",
    "notably , the data - structure of dbm is proposed in @xcite for the representation of convex state - spaces of ta .",
    "the theory and algorithm of tctl model - checking were first given in @xcite .",
    "the algorithm is based on region graphs and helps manifest the pspace - complexity of the tctl model - checking problem .    in @xcite ,",
    "henzinger et al proposed an efficient symbolic model - checking algorithm for tctl .",
    "however , the algorithm does not distinguish between zeno and non - zeno computations .",
    "instead , the authors proposed to modify tas with zeno computations to ones without . in comparison ,",
    "our greatest fixpoint evaluation algorithm is innately able to quantify over non - zeno computations .",
    "several verification tools for ta have been devised and implemented so far@xcite .",
    "uppaal@xcite is one of the popular tool with dbm technology .",
    "it supports safety ( reachability ) analysis in forward reasoning techniques .",
    "various state - space abstraction techniques and compact representation techniques have been developed@xcite .",
    "recently , moller has used uppaal with abstraction techniques to analyze restricted inevitability properties with no modal - formula nesting@xcite .",
    "the idea is to make model augmentations to speed up the verification performance .",
    "moller also shows how to extend the idea to analyze tctl with only universal quantifications .",
    "however , no experiment has been reported on the verification of nested modal - formulas .",
    "kronos@xcite is a full tctl model - checker with dbm technology and both forward and backward reasoning capability .",
    "experiments to demonstrate how to use kronos to verify several tctl _ bounded inevitability _ properties is demonstrated in @xcite .",
    "( _ bouonded inevitabilities _ are those inevitabilities specified with a deadline . ) but no report has been made on how to enhance the performance of general inevitability analysis . in comparison , we have discussed techniques like edgf and abstractions which handle both bounded and unbounded inevitabilities .",
    "ddd is a reachability analyzer based on bdd - like data - structures for ta@xcite .",
    "sgm@xcite is a compositional safety ( reachability ) analyzer for ta , also based on dbm technology .",
    "a newer version also supports partial tctl model - checking .",
    "cmc is another compositional model - checker@xcite .",
    "its specification language is a restricted subclass of @xmath10 and is capable of specifying bounded inevitabilities .",
    "our tool red ( version 4.1@xcite ) is a full tctl model - checker / simulator with a bdd - like data - structure , called crd ( clock - restriction diagram)@xcite .",
    "previous research with red has focused on enhancing the performance of safety analysis .",
    "abstraction techniques for analysis have been studied in great depth since the pioneering work of cousot et al@xcite . for ta",
    ", convex - hull over - approximation@xcite has been a popular choice for dbm technology due to its intuitiveness and effective performance .",
    "it is difficult to implement this over - approximation in red@xcite since variable - accessing has to observe variable - orderings of bdd - like data - structures .",
    "nevertheless , many over - approximation techniques for ta have been reported in @xcite for bdd - like data - structures and in @xcite specifically for crd .",
    "relations between abstraction techniques and subclasses of ctl with only universal ( or existential respectively ) path quantifiers has been studied in @xcite .",
    "as mentioned above , the corresponding framework in tctl is noted in @xcite .",
    "we use the widely accepted model of _ timed automata_@xcite , which is a finite - state automata equipped with a finite set of clocks which can hold nonnegative real - values . at any moment , a timed automata can stay in only one _ mode _ ( or _ control location _ ) . in its operation ,",
    "one of the transitions can be triggered when the corresponding triggering condition is satisfied . upon being triggered ,",
    "the automata instantaneously transits from one mode to another and resets some clocks to zero . between transitions , all clocks increase readings at a uniform rate .    for convenience ,",
    "given a set @xmath11 of modes and a set @xmath12 of clocks , we use @xmath13 as the set of all boolean combinations of atoms of the forms @xmath14 and @xmath15 , where @xmath16 , @xmath17 , `` @xmath18 '' is one of @xmath19 , and @xmath20 is an integer constant .",
    "a ta @xmath21 is given as a tuple @xmath22 with the following restrictions .",
    "@xmath12 is the set of clocks .",
    "@xmath11 is the set of modes .",
    "@xmath23 is the initial condition .",
    "@xmath24 defines the invariance condition of each mode .",
    "@xmath25 is the set of transitions . @xmath26 and",
    "@xmath27 respectively define the triggering condition and the clock set to reset of each transition .",
    "a _ valuation _ of a set is a mapping from the set to another set .",
    "given an @xmath28 and a valuation @xmath29 of @xmath12 , we say @xmath29 _ satisfies _ @xmath30 , in symbols @xmath31 , iff it is the case that when the variables in @xmath30 are interpreted according to @xmath29 , @xmath30 will be evaluated as @xmath32 .",
    "a state @xmath29 of @xmath33 is a valuation of @xmath34 such that    there is a unique @xmath16 such that @xmath35 and for all @xmath36 ;    for each @xmath37 , @xmath38 ( the set of nonnegative reals ) and @xmath39 .",
    "given state @xmath29 and @xmath16 such that @xmath35 , we call @xmath14 the mode of @xmath29 , in symbols @xmath40 . for any @xmath41 , @xmath42 is a state identical to @xmath29 except that for every clock @xmath37 , @xmath43 . given @xmath44",
    ", @xmath45 is a new state identical to @xmath29 except that for every @xmath46 , @xmath47 .    given a ta @xmath33 , a _ run _",
    "is an ( infinite ) sequence of state - time pairs , @xmath48 , such that @xmath49 and @xmath50 is a monotonically increasing real - number ( time ) divergent sequence , and for all @xmath51 ,    _ invariance conditions are preserved in each interval : _ that is , + for all @xmath52 $ ] , @xmath53 ; and    either _ no transition happens at time @xmath54 _ , that is , @xmath55 and @xmath56 ; or _ a transition happens at @xmath54 _ , that is ,    _ there is such a transition _ , that is @xmath57 ; and    _ the corresponding triggering condition is satisfied _ , that is , @xmath58 ; and    _ the clocks are reset to zero accordingly _ , that is , @xmath59 .",
    "tctl@xcite is a branching temporal logic for the specification of dense - time systems .",
    "[ def.syntax.tctl]*(syntax of tctl formulas ) : * a tctl formula @xmath1 has the following syntax rules .",
    "@xmath60    here @xmath28 and @xmath61 , @xmath62 are tctl formulas .",
    "the modal operators are intuitively explained in the following .",
    "@xmath63 means that `` if there is a clock @xmath64 with reading zero now , then @xmath1 is satisfied . ''",
    "@xmath65 means `` there exists a run ''    @xmath66 means that along a computation , @xmath61 is true until @xmath62 becomes true .",
    "@xmath67 means that along a computation , @xmath61 is always true .    besides the standard shorthands of temporal logics@xcite",
    ", we adopt the following for tctl :    @xmath68    [ def.satisfy.tctl]*(satisfaction of tctl formulas ) : * we write in notations @xmath69 to mean that @xmath1 is satisfied at state @xmath29 in ta @xmath21 .",
    "the satisfaction relation is defined inductively as follows .",
    "when @xmath70 , @xmath71 according to the definition in the beginning of subsection  [ sec.system ] .    @xmath72 iff either @xmath71 or @xmath73    @xmath74 iff @xmath75    @xmath76 iff @xmath77 .    @xmath78 iff",
    "there exists a run @xmath79 such that @xmath80 in @xmath21 , and there exist an @xmath81 and a @xmath82 $ ] , s.t .",
    "@xmath83 ,    for all @xmath84 , if either @xmath85)$ ] or @xmath86 , then @xmath87 .    in words",
    ", @xmath29 satisfies @xmath88 iff there exists a run from @xmath29 such that along the run , @xmath61 is true until @xmath62 is true .",
    "@xmath89 iff there exists a run @xmath79 such that @xmath80 in @xmath21 , and for every @xmath81 and @xmath82 $ ] , @xmath90 .",
    "in other words , @xmath29 satisfies @xmath91 iff there exists a run from @xmath29 such that @xmath61 is always true .",
    "a ta @xmath21 satisfies a tctl formula @xmath1 , in symbols @xmath92 , iff for every state @xmath49 , @xmath93 .",
    "our model - checking algorithm is backward reasoning . we need two basic procedures , one for the computation of the weakest precondition of transitions , and the other for backward time - progression .",
    "these two procedures are important in the symbolic construction of backward reachable state - space representations .",
    "various presentations of the two procedures can be found in @xcite . given a state - space representation @xmath30 and a transition @xmath94 , the first procedure , @xmath95 , computes the weakest precondition",
    "in which , every state satisfies the invariance condition imposed by @xmath96 ; and    from which we can transit to states in @xmath30 through @xmath94 .",
    "the second procedure , @xmath97 , computes the space representation of states    from which we can go to states in @xmath30 simply by time - passage ; and    every state in the time - passage also satisfies the invariance condition imposed by @xmath96 .    with the two basic procedures",
    ", we can construct a symbolic backward reachability procedure as in @xcite .",
    "we call this procedure @xmath98 for convenience .",
    "intuitively , @xmath98 characterizes the backwardly reachable state - space from states in @xmath99 through runs along which all states satisfy @xmath100 .",
    "computationally , @xmath98 can be defined as the least fixpoint of the equation @xmath101 , i.e. ,    @xmath102 .",
    "our model - checking algorithm is modified from the classic model - checking algorithm for tctl@xcite .",
    "the design of the greatest fixpoint evaluation algorithm with consideration of non - zeno requirement is based on the following lemma .",
    "[ lemma.gfp ] given @xmath103 , @xmath104 iff there is a finite run from @xmath29 of duration @xmath105 such that along the run every state satisfies @xmath30 and the finite run ends at a state satisfying @xmath106 .   + details are omitted due to page - limit .",
    "but note that we can construct an infinite and divergent run by concatenating an infinite sequence of finite runs with durations @xmath103 .",
    "the existence of infinitely many such concatenable finite runs is assured by the recursive construction of @xmath106 .",
    "then @xmath106 can be defined with the following greatest fixpoint .",
    "@xmath107    here clock zc is used specifically to measure the non - zeno requirement .",
    "the following procedure can construct the greatest fixpoint satisfying @xmath106 with a non - zeno requirement .    ' '' ''",
    "@xmath108 / * d is a static parameter for measuring time - progress * / \\ {   + @xmath109 ; @xmath110 ;   + repeat until @xmath111 , \\{(1 )   + @xmath112 ; @xmath113 ; ( 2 )   + }   + return @xmath114 ; + }    ' '' ''    here @xmath115 removes a clock from a state - predicate without losing information on relations among other clocks .",
    "details can be found in appendix  [ app.clock.eliminate ] .",
    "note here that @xmath2 works as a parameter .",
    "we can choose the value of @xmath103 for better performance in the computation of the greatest fixpoint .",
    "procedure gfp ( ) can be used in the labeling algorithm in @xcite to replace the evaluation of @xmath116-formulas . for completeness of the presentation ,",
    "please check appendix  [ app.mck ] to see our complete model - checking algorithm with non - zeno requirement .",
    "the correctness follows from lemma  [ lemma.gfp ] .",
    "in the evaluation of the greatest fixpoint for formulas like @xmath91 , we start from the description , say @xmath114 , for a subspace of @xmath61 and iteratively eliminate those subspaces which can not go to a state in @xmath114 through finite runs of @xmath103 time units .",
    "thus , the state - space represented by @xmath114 shrinks iteratively until it settles at a fixpoint . in practice",
    ", this greatest fixpoint usually happens in conjunction with other formulas .",
    "for example , we may want to specify @xmath117 meaning that a bus at the collision state , will enter the idle state in 26 time - units .",
    "after negation for model - checking , we get @xmath118 . in evaluating this negated formula ,",
    "we want to see if the greatest fixpoint for the @xmath116-formula intersects with the state - space for @xmath119 .",
    "we do not actually have to compute the greatest fixpoint to know if the intersection is empty .",
    "since the value of @xmath114 iteratively shrinks , we can check if the intersection between @xmath114 and the state - space for @xmath119 becomes empty at each iteration of the greatest fixpoint construction ( i.e. , the repeat - loop at statement ( 1 ) in procedure gfp ) .",
    "if at an iteration , we find the intersection with @xmath114 is already empty , then there is no need to continue calculating the greatest fixpoint and we can immediately return the current value of @xmath114 ( or @xmath120 ) without affecting the result of the model - checking .",
    "based on this idea , we rewrite our model - checking algorithm with our _ early deision on the greatest fixpoint ( edgf)_. we introduce a new parameter @xmath121 to pass the information of the target states inherited from the scope .    ' '' ''    @xmath122 + / * @xmath123 is the set of clocks declared in the scope of @xmath124 * / + / * @xmath121 is constraints inhereted in the scope of @xmath124 for early decision of gfp * / \\ {   + switch ( @xmath124 ) \\ {   + * case * ( @xmath120 ) : return @xmath120 ;   + * case * ( @xmath125 ) : return @xmath126 ;   + * case * ( @xmath127 ) : return @xmath128 ;   + * case * ( @xmath129 ) : return @xmath130 ;   + * case * ( @xmath131 ) :   + if @xmath62 does not contain modal operator , \\ {   + @xmath132 ;   + return @xmath133;(3 )   + }   + else \\ {   + @xmath134 ;   + return @xmath135;(4 )   + }   + * case * ( @xmath136 ) : return @xmath137 ;   + * case * ( @xmath138 ) : return @xmath139 ;   + * case * ( @xmath140 ) :   + @xmath141 ; @xmath142 ;   + return @xmath98 ;   + * case * ( @xmath91 ) : return @xmath143 ;   + } + } + @xmath144 / * d is a static parameter for measuring time - progress * / \\ {   + @xmath109 ; @xmath110 ;   + repeat until @xmath111 or @xmath145 , \\{(5 )   + @xmath112 ; @xmath113 ; ( 6 )   + }   + return @xmath114 ; + }    ' '' ''    to model - check ta @xmath21 against tctl formula @xmath1 , we reply @xmath32 iff @xmath146 is false .",
    "as can be seen from statement ( 3 ) and ( 4 ) in the case of conjunction formulas , we strengthen the target - state information . in the evaluation of the greatest fixpoint ,",
    "we use condition - testing @xmath145 in statement ( 5 ) respectively to check for early decision .",
    "in practice , the greatest fixpoint computation procedures presented in the last two sections can be costly in computing resources since their characterizations have a least fixpoint nested in a greatest fixpoint .",
    "this is necessary to guarantee that only nonzeno computations are considered . in reality",
    ", it may happen that , due to well - designed behaviors , systems may still satisfy certain inevitability properties for both zeno and non - zeno computation . in this case , we can benefit from a less expensive procedure to compute the greatest fixpoint .",
    "for example , we have designed the following procedure which does not rule out zeno computations in the evaluation of @xmath116-formulas .    ' '' ''",
    "@xmath147 \\ {   + @xmath148 ;   + repeat until @xmath111 or @xmath145 , \\ { ( 7 )   + @xmath112 ; @xmath149 ;   + }   + return @xmath114 ; + }    ' '' ''    even if the procedure can be imprecise in over - estimation of the greatest fixpoint , it can be much less expensive in the verification of well - designed real - world projects .",
    "we have also experimented with abstraction techniques in the evaluation of greatest fixpoints .",
    "due to page - limit , we shall leave the explanation in appendix  [ app.tctla ] .",
    "the corresponding xperiment report is in subsection  [ subsec.exp.tctla ] .",
    "we have implemented the ideas in our model - checker / simulator , red version 4.1 , for ta .",
    "red uses the new bdd - like data - structure , _ crd _ ( clock - restriction diagram)@xcite , and supports both forward and backward analysis , full tctl model - checking with non - zeno computations , deadlock detection , and counter - example generation .",
    "users can also declare global and local ( to each process ) variables of type clock , integer , and pointer ( to identifier of processes ) .",
    "boolean conditions on variables can be tested and variable values can be assigned .",
    "the tctl formulas in red also allow quantification on process identifiers for succinct specification .",
    "interested readers can download red for free from    ....                               http://cc.ee.ntu.edu.tw/~val/ ....",
    "we design our experiment in two ways .",
    "first , we run red 4.1 with various options and benchmarks to test if our ideas can indeed improve the verification performance of inevitability properties in @xmath150 .",
    "second , we compare red 4.1 with kronos 5.2 to check if our implementation remains competitive in regard to other tools .",
    "however , we remind the readers that comparison report with other tools should be read carefully since red uses different data - structures from kronos . moreover , it is difficult to know what fine - tuning techniques each tool has used .",
    "thus it is difficult to conclude if the techniques presented in this work really contribute to the performance difference between red and kronos .",
    "nevertheless , we believe it is still an objective measure to roughly estimate how our ideas perform .    in the following section , we shall first discuss the design of our benchmarks , then report our experiments .",
    "data is collected on a pentium 4 1.7ghz with 256 mb memory running linux .",
    "execution times are collected for kronos while times and memory ( for data - structure ) are collected for red .",
    "`` s '' means seconds of cpu time , `` k '' means kilobytes for memory space for data - structures , `` o / m '' means `` out - of - memory . ''",
    "we do not claim that the benchmarks selected here represent the complete spectrum of model - checking tasks .",
    "the evaluation of tctl formulas may incur various complex computations depending on the structures of the timed automata and the specification formulas .",
    "but we do carefully choose our benchmarks according to the broad spectrum of combination of models and specifications so that we can gain some insights about performance enhancement of tctl inevitability analysis .",
    "benchmarks include three different timed automatas and specifications for unbounded inevitability , bounded inevitability@xcite , and modal operators with nesting depth zero , one , and two respectively .",
    "we identify one important benchmark which can only be verified with non - zeno computations .",
    "the other benchmarks can be ( safely ) verified without requirement of non - zeno computations .",
    "due to page - limit , we leave the description of the benchmarks in appendix  [ app.benchmarks ] .      in statement ( 2 ) of procedure gfp ( ) and statement ( 6 ) of procedure gfp_edgf ( ) , we use inequality @xmath151 to check time - progress in non - zeno computations , where @xmath2 is a parameter @xmath152 .",
    "we can choose various values for the parameter in our implementations .",
    "in our experiment reported in this subsection , we have found that the value of parameter @xmath2 can greatly affect the verification performance .    in this experiment",
    ", we shall use various values of parameter @xmath2 ranging from @xmath153 to beyond the biggest timing constants used in the models . for the leader - election benchmark ,",
    "the biggest timing constant used is @xmath154 . for the pathos benchmark ,",
    "the biggest timing constant used is equal to the number of processes . for the csma / cd benchmarks ( a ) , ( b ) , and ( c ) , the biggest timing constant used is equal to 808 .",
    "in fact , we can also use inequality @xmath155 , with @xmath103 , in statements ( 2 ) and ( 6 ) of procedures gfp ( ) and gfp_edgf ( ) respectively . due to page - limit",
    ", we shall leave the performance data table to appendix  [ app.d.table ] .",
    "we have drawn charts to show time - complexity for the benchmarks w.r.t .",
    "@xmath2-values in figure  [ fig.charts.time ] .",
    "cc & + ( a ) leader - election & ( b ) pathos + & + ( c ) csma / cd(a ) & ( d ) csma / cd(b ) +   +    the y - axis is with `` time in sec '' while the x - axis is with `` @xmath156 '' used in `` @xmath157 . ''",
    "more charts for the space - complexity can be found in appendix  [ app.d.mem ] .    as can be seen from the charts",
    ", our algorithms may respond with different complexity curves to various model structures and specifications . for benchmarks",
    "leader - election and pathos , it seems that the bigger the @xmath2-value , the better the performance .",
    "for the three csma / cd benchmarks , it seems that the best performance happens when @xmath2 is around 80 .",
    "but one thing common in these charts is that @xmath158 always gives the worst performance .",
    "we have to admit that we do not have a theory to analyze or predict the complexity curves w.r.t . various model structures and specifications .",
    "more experiments on more benchmarks may be needed in order to get more understanding of the curves . in general , we feel it can be difficult to analyze such complexity curves .",
    "after all , our models of ta are still `` programs '' in some sense .",
    "nevertheless , we have still tried hard to look into the execution of our algorithms for explanation of the complexity cuves . procedures gfp ( ) and gfp_edgf ( ) both are constructed with an inner loop ( for the least fixpoint evaluation of reachable - bck ( ) ) and an outer loop ( for the greatest fixpoint evaluation ) . with bigger @xmath2-values , it seems that the outer loop converges faster while the inner loop converges slower .",
    "that is to say , with bigger @xmath2-values , we may need less iterations of the outer - loop and , in the same time , more iterations of the inner loop to compute the greatest fixpoints . the complexity patterns in the charts are thus superpositions between the complexities of the outer loop and the inner loop .",
    "we have used the @xmath2-values with the best performance for the experiments reported in the next few subsections . for benchmarks pathos and leader - election , @xmath156 is set to @xmath159 .",
    "( @xmath160 is the biggest timing constant used in model @xmath21 and tctl specification @xmath1 . ) for the three csma / cd benchmarks , @xmath156 is set to @xmath161 .      in our first experiment",
    ", we observe the performance of our inevitability analysis algorithm w.r.t .",
    "the non - zeno requirement and the edgf policy .",
    "the performance data is in table  [ tab.z ] .",
    ".performance w.r.t .",
    "non - zeno requirements and edgf techniques [ cols= \" < , < , > , > , > , > \" , ]",
    "the charts for memory complexity with various @xmath2-parameter values is in figure  [ fig.charts.mem ] ."
  ],
  "abstract_text": [
    "<S> inevitability properties in branching temporal logics are of the syntax @xmath0 , where @xmath1 is an arbitrary ( timed ) ctl formula . in the sense </S>",
    "<S> that `` good things will happen '' , they are parallel to the `` liveness '' properties in linear temporal logics . </S>",
    "<S> such inevitability properties in dense - time logics can be analyzed with greatest fixpoint calculation . </S>",
    "<S> we present algorithms to model - check inevitability properties both with and without requirement of non - zeno computations . </S>",
    "<S> we discuss a technique for early decision on greatest fixpoints in the temporal logics . </S>",
    "<S> our algorithms come with a @xmath2-parameter for the measurement of time - progress . </S>",
    "<S> we have experimented with various issues , which may affect the performance of tctl inevitability analysis . </S>",
    "<S> specifically , we report the performance of our implementation w.r.t . various @xmath2-parameter values and with or without the non - zeno computation requirement in the evaluation of greatest fixpoints . </S>",
    "<S> we have also experimented with safe abstration techniques for model - checking tctl inevitability properties . </S>",
    "<S> analysis on the experiment data helps clarify how various techniques can be used to improve verification of inevitability properties .    </S>",
    "<S> * keywords : * branching temporal logics , tctl , real - time systems , inevitability , model - checking , greatest fixpoint , abstraction </S>"
  ]
}