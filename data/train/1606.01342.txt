{
  "article_text": [
    "let @xmath0 , @xmath1 , @xmath2 , be an undirected graph and let @xmath3 be the set of all spanning trees of  @xmath4 . in the _ minimum spanning tree problem _",
    ", a cost is specified for each edge , and we seek a spanning tree in @xmath4 of the minimum total cost . this problem is well known and can be solved efficiently by using several polynomial time algorithms ( see , e.g. ,  @xcite ) .    in this paper , we first study the _ recoverable spanning tree problem _ ( rec st for short ) .",
    "namely , for each edge @xmath5 , we are given a _",
    "first stage cost _",
    "@xmath6 and a _ second stage cost _",
    "@xmath7 ( recovery stage cost ) . given a spanning tree @xmath8 ,",
    "let @xmath9 be the set of all spanning trees @xmath10 such that @xmath11 ( the recovery set ) , where  @xmath12 is a fixed integer in @xmath13 $ ] , called the _ recovery parameter_. note that @xmath9 can be seen as a neighborhood of  @xmath14 containing all spanning trees which can be obtained from @xmath14 by exchanging up to  @xmath12 edges .",
    "the rec st problem can be stated formally as follows : @xmath15 we thus seek a first stage spanning tree @xmath8 and a second stage spanning tree @xmath16 , so that the total cost of @xmath14 and @xmath17 for @xmath6 and @xmath7 , respectively , is minimum .",
    "notice that rec st generalizes the following _ incremental spanning tree problem _ , investigated in  @xcite : @xmath18 where @xmath19 is a given spanning tree .",
    "so , we wish to find an improved spanning tree  @xmath17 with the minimum cost , within a neighborhood of  @xmath20 determined by @xmath21 .",
    "several interesting practical applications of the incremental network optimization were presented in  @xcite .",
    "it is worth pointing out that inc st can be seen as the rec st problem with a fixed first stage spanning tree  @xmath20 , whereas in rec st both the first and the second stage trees are unknown .",
    "it has been shown in  @xcite that inc st can be solved in strongly polynomial time by applying the lagrangian relaxation technique . on the other hand , no strongly polynomial time combinatorial algorithm for rec",
    "st has been known to date .",
    "thus proposing such an algorithm for this problem is one of the main results of this paper .    the rec st problem , beside being an interesting problem _ per se _ , has an important connection with a more general problem .",
    "namely , it is an inner problem in the _ recoverable robust model _ with uncertain recovery costs , discussed in  @xcite .",
    "indeed , the recoverable spanning tree problem can be generalized by considering its robust version .",
    "suppose that the second stage costs @xmath7 , @xmath5 , are uncertain and let @xmath22 contain all possible realizations of the second stage costs , called _",
    "scenarios_. we will denote by @xmath23 the second stage cost of edge @xmath5 under scenario @xmath24 , where @xmath25 is a cost vector . in the _ recoverable robust spanning tree",
    "_ problem ( rob rec st for short ) , we choose an initial spanning tree @xmath14 in the first stage , with the cost equal to @xmath26 .",
    "then , after scenario @xmath27 reveals , @xmath14 can be modified by exchanging at most  @xmath12 edges , obtaining a new spanning tree @xmath28",
    ". the second stage cost of @xmath17 under scenario @xmath24 is equal to @xmath29 . our goal is to find a pair of trees @xmath14 and @xmath17 such that @xmath30 , which minimizes the sum of the first and the second stage costs @xmath31 in the worst case .",
    "the rob rec st problem is defined formally as follows : @xmath32    if @xmath33 for each @xmath5 and @xmath34 , then rob rec st is equivalent to the following _ min - max spanning tree _",
    "problem , examined in  @xcite , in which we seek a spanning tree that minimizes the largest cost over all scenarios : @xmath35    if @xmath33 for each @xmath5 and @xmath36 , then rob rec st becomes the following _ adversarial problem _",
    "@xcite in which an _ adversary _ wants to find a scenario which leads to the greatest increase in the cost of the minimum spanning tree : @xmath37    we now briefly recall the known complexity results on rob rec st .",
    "it turns out that its computational complexity highly relies on the way of defining the scenario set  @xmath22 .",
    "there are two popular methods of representing  @xmath22 , namely the _ discrete and interval uncertainty representations_. for the _ discrete uncertainty representation _ ( see , e.g. ,  @xcite ) , scenario set , denoted by  @xmath38 , contains @xmath39 explicitly listed scenarios , i.e. @xmath40 . in this case",
    ", the rob rec st problem is known to be np - hard for @xmath41 and any constant @xmath12  @xcite .",
    "furthermore , it becomes strongly np - hard and not at all approximable when both @xmath39 and @xmath12 are a part of the input  @xcite .",
    "it is worthwhile to mention that min - max st is np hard even when @xmath41 and becomes strongly np - hard and not approximable within @xmath42 for any @xmath43 unless np @xmath44 dtime@xmath45 , when @xmath39 is a part of input  @xcite .",
    "it admits an fptas , when @xmath39 is a constant  @xcite and is approximable within @xmath46 , when @xmath39 is a part of the input  @xcite .",
    "the adv st problem , under scenario set @xmath38 , is polynomially solvable , since it boils down to solving @xmath39 traditional minimum spanning tree problems .    for the _ interval uncertainty representation _",
    ", which is considered in this paper , one assumes that the second stage cost of each edge @xmath5 is known to belong to the closed interval @xmath47 $ ] , where @xmath7 is a _ nominal cost _ of @xmath5 and @xmath48 is the maximum deviation of the cost of  @xmath49 from its nominal value .",
    "in the traditional case  @xmath22 , denoted by @xmath50 , is the cartesian product of all these intervals  @xcite , i.e. @xmath51 , e\\in e\\}. \\label{intset}\\ ] ]    in  @xcite a polynomial algorithm for the _ recoverable robust matroid basis _",
    "problem under scenario set  @xmath50 was constructed , provided that the recovery parameter  @xmath12 is constant . in consequence ,",
    "rob rec st under @xmath50 is also polynomially solvable for constant @xmath12 .",
    "unfortunately , the algorithm proposed in  @xcite is exponential in @xmath12 .",
    "interestingly , the corresponding recoverable robust version of the shortest path problem ( @xmath3 is replaced with the set of all @xmath52 paths in @xmath4 ) has been proven to be strongly np - hard and not at all approximable even if @xmath53  @xcite . it has been recently shown in  @xcite that rob rec st under @xmath50 is polynomially solvable when  @xmath12 is a part of the input . in order to prove this result , a technique called the _ iterative relaxation _ of a linear programming formulation ,",
    "whose framework was described in  @xcite , has been applied this technique , however , does not imply directly a strongly polynomial algorithm for rob rec st , since it requires the solution of a linear program .    in",
    "@xcite a popular and commonly used modification of the scenario set  @xmath50 has been proposed .",
    "the new scenario set , denoted as @xmath54 , is a subset of @xmath50 such that under each scenario in @xmath54 , the costs of at most @xmath55 edges are greater than their nominal values @xmath7 , where @xmath55 is assumed to be a fixed integer in @xmath56 $ ] .",
    "scenario set @xmath54 is formally defined as follows : @xmath57 , \\delta_e\\in \\{0,1\\ } , e\\in e , \\sum_{e\\in e } \\delta_e\\leq \\gamma\\}. \\label{intset1}\\ ] ] the parameter @xmath55 allows us to model the degree of uncertainty . when @xmath58 , then we get rec st ( rob rec st with one scenario  @xmath59 ) . on the other hand , when @xmath60 , then we get rob rec st under the traditional interval uncertainty  @xmath50 .",
    "it turns out that the adv st problem under @xmath54 is strongly np - hard ( it is equivalent to the problem of finding @xmath55 most vital edges )  @xcite .",
    "consequently , the more general rob rec st problem is also strongly np - hard .",
    "interestingly , the corresponding min - max st problem with  @xmath54 is polynomially solvable  @xcite .",
    "yet another interesting way of defining scenario set , which allows us to control the amount of uncertainty , is called the scenario set with a _ budget constraint _ ( see , e.g , .",
    "this scenario set , denoted as @xmath61 , is defined as follows : @xmath62 , e\\in e , \\sum_{e\\in e } \\delta_e\\leq \\gamma \\ } , \\label{intset2}\\ ] ] where @xmath63 is a a fixed parameter that can be seen as a budget of an adversary , and represents the maximum total increase of the edge costs from their nominal values .",
    "obviously , if @xmath55 is sufficiently large , then @xmath61 reduces to the traditional interval uncertainty representation   @xmath64 .",
    "the computational complexity of rob rec st for scenario set @xmath65 is still open .",
    "we only know that its special cases , namely min - max st and adv st , are polynomially solvable  @xcite .",
    "in this paper we will construct a combinatorial algorithm for rec st with strongly polynomial running time .",
    "we will apply this algorithm for solving rob rec st under scenario set  @xmath50 in strongly polynomial time .",
    "moreover , we will show how the algorithm for rec st can be used to obtain several approximation results for rob rec st , under scenario sets @xmath54 and @xmath61 .",
    "this paper is organized as follows .",
    "section  [ sec1 ] contains the main result of this paper  a combinatorial algorithm for rec st with strongly polynomial running time .",
    "section  [ sec2 ] discusses rob rec st under the interval uncertainty representations @xmath64 , @xmath54 , and @xmath61 .",
    "in this section we construct a combinatorial algorithm for rec st with strongly polynomial running time . since @xmath66 for each @xmath8 , rec st ( see ( [ recst ] ) ) is equivalent to the following mathematical programming problem : @xmath67 where @xmath68 . problem  ( [ mrecst ] ) can be expressed as the following mip model : @xmath69 where @xmath70 stands for the set of edges that have both endpoints in @xmath71 .",
    "we first apply the lagrangian relaxation ( see , e.g. , @xcite ) to ( [ mipst_o])-([mipst_8 ] ) by relaxing the cardinality constraint  ( [ mipst_7 ] ) with a nonnegative multiplier  @xmath72 .",
    "we also relax the integrality constraints  ( [ mipst_8 ] ) .",
    "we thus get the following linear program ( with the corresponding dual variables which will be used later ) : @xmath73 , \\nonumber\\\\                        & -\\sum_{e\\in e(u ) } x_e \\geq   -(|u|-1 ) ,   & \\forall u\\subset v , & & [ w_u ] , \\nonumber\\\\                         & \\sum_{e\\in e } y_e = n-1 , &   & & [ \\nu ] , \\nonumber\\\\                        & -\\sum_{e\\in e(u ) } y_e \\geq   -(|u|-1 ) , & \\forall u\\subset v , & & [ v_u ] ,   \\nonumber\\\\                        & x_e - z_e \\geq   0 ,                               & \\forall e\\in e ,   & & [ \\alpha_e],\\nonumber\\\\                         & y_e - z_e   \\geq   0 ,                               & \\forall e\\in e ,   & & [ \\beta_e],\\nonumber\\\\                        & x_e , y_e , z_e \\geq 0 , & \\forall e\\in e.   & & \\nonumber   \\end{aligned}\\ ] ]    for any @xmath74 , the lagrangian function  @xmath75 is a lower bound on  @xmath76 .",
    "it is well - known that @xmath75 is concave and piecewise linear . by the optimality test ( see , e.g. , @xcite ) , we obtain the following theorem :    let @xmath77 be an optimal solution to  ( [ llpst_o ] ) for some @xmath74 , feasible to  ( [ mipst_1])-([mipst_8 ] ) and satisfying the complementary slackness condition @xmath78 .",
    "then @xmath77 is optimal to  ( [ mipst_o])-([mipst_8 ] ) .",
    "[ tloc ]    let @xmath79 , @xmath80 , be a pair of spanning trees of @xmath4 ( a _ pair _ for short ) .",
    "this pair corresponds to a feasible @xmath81 solution to  ( [ llpst_o ] ) , defined as follows : @xmath82 for @xmath83 , @xmath84 for @xmath85 , and @xmath86 for @xmath87 ; the values of the remaining variables are set to  0 . from now on , by a pair @xmath79 we also mean a feasible solution to  ( [ llpst_o ] ) defined as above . given a pair @xmath79 with the corresponding solution @xmath77 , let us define the partition @xmath88 of the set of the edges @xmath89 in the following way : @xmath90 , @xmath91 , @xmath92 and @xmath93 .",
    "thus equalities : @xmath94 , @xmath95 and @xmath96 hold .",
    "our goal is to establish some sufficient optimality conditions for a given pair @xmath79 in the problem  ( [ llpst_o ] ) .",
    "the dual to  ( [ llpst_o ] ) has the following form : @xmath97    [ lemdu ] the dual problem  ( [ dllpst_o ] ) can be rewritten as follows : @xmath98    fix some @xmath99 and @xmath100 such that @xmath101 for each @xmath5 in  ( [ dllpst_o ] ) .",
    "for these constant values of @xmath99 and @xmath100 , @xmath5 , using the dual to  ( [ dllpst_o ] ) , we arrive to @xmath102 and the lemma follows .",
    "lemma  [ lemdu ] allows us to establish the following result :    [ tssoc ] a pair @xmath79 is optimal to  ( [ llpst_o ] ) for a fixed @xmath74 if there exist @xmath103 , @xmath104 such that @xmath105 for each @xmath5 and    * @xmath14 is a minimum spanning tree for the costs @xmath106 , @xmath17 is a minimum spanning tree for the costs @xmath107 * @xmath108 for each @xmath109 , @xmath110 for each @xmath111 .    by the primal - dual relation , the inequality @xmath112 holds . using  ( [ eqdual ] )",
    ", we obtain @xmath113 the weak duality theorem implies the optimality of @xmath79 in  ( [ llpst_o ] ) for a fixed @xmath74 .    a pair @xmath79 , which satisfies the sufficient pair optimality conditions for @xmath114 , can be computed in polynomial time .",
    "[ ltheta0 ]    let @xmath14 be a minimum spanning tree for the costs @xmath6 and @xmath17 be a minimum spanning tree for the costs @xmath7 , @xmath5 . since @xmath114 , we set @xmath108 , @xmath110 for each @xmath5 .",
    "it is clear that @xmath79 satisfies the sufficient pair optimality conditions .",
    "assume that @xmath79 satisfies the sufficient pair optimality conditions for some @xmath74 .",
    "if , for this pair , @xmath115 and @xmath116 , then we are done , because by theorem  [ tloc ] , the pair  @xmath79 is optimal to  ( [ mipst_o])-([mipst_8 ] ) .",
    "suppose that @xmath117 ( @xmath79 is not feasible to  ( [ mipst_o])-([mipst_8 ] ) ) .",
    "we will now show a polynomial time procedure for finding a new pair @xmath118 , which satisfies the sufficient pair optimality conditions and @xmath119 .",
    "this implies a polynomial time algorithm for the problem ( [ mipst_o])-([mipst_8 ] ) , since it is enough to start with a pair satisfying the sufficient pair optimality conditions for @xmath114 ( see lemma  [ ltheta0 ] ) and repeat the procedure at most @xmath120 times , i.e. until @xmath121 .",
    "given a spanning tree  @xmath122 in  @xmath0 and edge  @xmath123 , let us denote by @xmath124 the unique path in  @xmath122 connecting nodes  @xmath12 and  @xmath125 .",
    "it is well known that for any @xmath126 , @xmath127 is also a spanning tree in @xmath4 .",
    "we will say that @xmath128 is the result of a _ move _ on @xmath122 .    consider a pair @xmath79 that satisfies the sufficient pair optimality conditions for some fixed @xmath74 . set @xmath129 and @xmath130 for every @xmath5 , where @xmath99 and @xmath100 , @xmath5 , are the numbers which satisfy the conditions in theorem  [ tssoc ] .",
    "thus , by theorem  [ tssoc](i ) and the _ path optimality conditions _ ( see , e.g. , @xcite ) , we get the following conditions which must be satisfied by @xmath79 :    @xmath131    [ toptc ]    we now build a so - called _ admissible graph _ @xmath132 in two steps .",
    "we first associate with each edge  @xmath5 a node  @xmath133 and include it to @xmath134 , @xmath135 .",
    "we then add arc @xmath136 to @xmath137 if @xmath138 , @xmath139 and @xmath140 .",
    "this arc is called an _",
    "@xmath14-arc_. we also add arc @xmath141 to @xmath137 if @xmath142 , @xmath143 and @xmath144 .",
    "this arc is called an _ @xmath17-arc_.",
    "we say that @xmath145 is _ admissible _ if @xmath111 , or @xmath146 is reachable from a node @xmath147 , such that @xmath148 , by a directed path in @xmath149 . in the second step we remove from @xmath149 all the nodes which are not admissible , together with their incident arcs .",
    "an example of an admissible graph is shown in figure  [ fga ] .",
    "each node of this admissible graph is reachable from some node @xmath150 , @xmath148 .",
    "note that the arcs @xmath151 and @xmath152 are not present in @xmath149 , because @xmath153 is not reachable from any node @xmath150 , @xmath148 .",
    "these arcs have been removed from @xmath149 in the second step .",
    "observe that each @xmath14-arc @xmath154 represents a move on @xmath14 , namely @xmath155 is a spanning tree in @xmath4 .",
    "similarly , each @xmath17-arc @xmath156 represents a move on @xmath17 , namely @xmath157 is a spanning tree in @xmath4 .",
    "notice that the cost , with respect to @xmath158 , of @xmath159 is the same as @xmath14 and the cost , with respect to @xmath160 , of @xmath161 is the same as @xmath17 .",
    "so , the moves indicated by @xmath14-arcs and @xmath17-arcs preserve the optimality of @xmath14 and @xmath17 , respectively .",
    "observe that @xmath138 or @xmath85 , which implies @xmath162 .",
    "also @xmath163 or @xmath164 , which implies @xmath165 .",
    "hence , no arc in @xmath137 can start in a node corresponding to an edge in @xmath166 and no arc in @xmath137 can end in a node corresponding to an edge in @xmath167 .",
    "observe also that @xmath156 can be both @xmath14-arc and @xmath17-arc only if @xmath111 and @xmath168 .",
    "such a case is shown in figure  [ fga ] ( see the arc @xmath169 ) . since",
    "each arc @xmath156 represents a move on @xmath14 or @xmath17 , @xmath49 and @xmath170 can not both belong to @xmath171 or @xmath172",
    ".     such that @xmath173 and @xmath174 .",
    "( b )  the admissible graph @xmath149 for @xmath79.,width=502 ]    we will consider two cases : @xmath175 and @xmath176 .",
    "the first case means that there is a directed path from @xmath146 , @xmath111 , to a node @xmath177 , @xmath168 , in the admissible graph @xmath149 and in the second case no such a path exists .",
    "we will show that in the first case it is possible to find a new pair @xmath178 which satisfies the sufficient pair optimality conditions and @xmath179 .",
    "the idea will be to perform a sequence of moves on @xmath14 and @xmath17 , indicated by the arcs on some suitably chosen path from @xmath146 , @xmath111 , to @xmath177 , @xmath168 in the admissible graph @xmath149 .",
    "let us formally handle this case .",
    "[ txva ] if @xmath175 , then there exists a pair @xmath178 with @xmath119 , which satisfies the sufficient pair optimality conditions for @xmath72 .",
    "we begin by introducing the notion of a _ cycle graph _ @xmath180 , corresponding to a given spanning tree  @xmath122 of graph  @xmath181 .",
    "we build  @xmath182 as follows : we associate with each edge  @xmath5 a node  @xmath133 and include it to @xmath183 , @xmath184 ; then we add arc @xmath185 to @xmath186 if @xmath187 and @xmath188 .",
    "an example is shown in figure  [ fcyclegraph ] .     with a spanning tree @xmath122 ( the solid lines ) .",
    "( b ) the cycle graph @xmath182 . ]    [ ccycleg ] given a spanning tree @xmath122 of  @xmath4 , let @xmath189 be a subset of arcs of @xmath182 , where all @xmath190 and @xmath191 ( resp . @xmath192 and @xmath193 )",
    ", @xmath194 $ ] , are distinct . if @xmath195 is not a spanning tree , then @xmath182 contains a subgraph depicted in figure  [ fcycle ] , where @xmath196 $ ] .     from claim  [ ccycleg ] . ]",
    "let us illustrate claim  [ ccycleg ] by using the sample graph in figure  [ fcyclegraph ] .",
    "suppose that @xmath197 . then @xmath198 is not a spanning tree and @xmath182 contains the subgraph composed of the following arcs ( see figure  [ fcyclegraph ] ) : @xmath199    we form @xmath128 by performing a sequence of moves consisting in adding edges  @xmath192 and removing edges @xmath200 , @xmath201 $ ] .",
    "suppose that , at some step , a cycle appears , which is formed by some edges from @xmath202 and the remaining edges of  @xmath122 ( not removed from @xmath122 ) .",
    "such a cycle must appear , since otherwise @xmath128 would be a spanning tree .",
    "let us relabel the edges so that @xmath203 are on this cycle , i.e. the first @xmath204 moves consisting in adding @xmath192 and removing @xmath193 create the cycle , @xmath205 $ ] .",
    "an example of such a situation for @xmath206 is shown in figure  [ fclaimgraph ] .",
    "the cycle is formed by the edges @xmath207 and the paths @xmath208 , @xmath209 and @xmath210 in @xmath122 . consider the edge @xmath211 . because @xmath122 is a spanning tree , @xmath212 .",
    "observe that @xmath213 can not belong to any of @xmath208 , @xmath209 and @xmath210 .",
    "if it would be contained in one of these paths , then no cycle would be created .",
    "hence , @xmath214 must belong to @xmath215 .",
    "the above argument is general and , by using it , we can show that for each @xmath216 $ ] , @xmath217 for some @xmath218\\setminus \\{i\\}$ ] .    .",
    "( a ) the bold lines represent paths in @xmath122 ( not necessarily disjoint ) ; @xmath219 .",
    "( b ) the subgraph @xmath220 with the corresponding cycle . ]",
    "we are now ready to build a subgraph depicted in figure  [ fcycle ] .",
    "consider a subgraph @xmath220 of the cycle graph @xmath182 built as follows .",
    "the nodes of @xmath220 are @xmath221 .",
    "observe that @xmath220 has exactly @xmath222 nodes , since all the edges @xmath223 are distinct by the assumption of the claim .",
    "for each @xmath216 $ ] we add to @xmath220 two arcs , namely @xmath224 , @xmath225 and @xmath226 , @xmath217 for @xmath218\\setminus \\{i\\}$ ] ( see figure  [ fclaimgraph ] ) .",
    "the resulting graph @xmath220 is bipartite and has exactly @xmath222 arcs . in consequence @xmath220 ( and thus @xmath182 ) must contain a cycle which is of the form depicted in figure  [ fcycle ] .",
    "after this preliminary step , we can now return to the main proof .",
    "if @xmath175 , then , by the construction of the admissible graph , there exists a directed path in @xmath149 from a node  @xmath146 , @xmath111 , to a node  @xmath177 , @xmath168 .",
    "let @xmath227 be a shortest such a path from @xmath146 to @xmath177 , i.e. a path consisting of the fewest number of arcs , called an _ augmenting path_. we need to consider the following cases :    1 .",
    "[ auc1 ] the augmenting path  @xmath227 is of the form : @xmath228 if @xmath185 is @xmath14-arc , then @xmath155 is an updated spanning tree of  @xmath4 such that @xmath229 .",
    "furthermore @xmath159 is a minimum spanning tree for the costs @xmath158 and the new pair @xmath230 satisfies the sufficient pair optimality conditions ( @xmath231 , so condition ( ii ) in theorem  [ tssoc ] is not violated ) .",
    "if @xmath185 is @xmath17-arc , then @xmath232 is an updated spanning tree of  @xmath4 such that @xmath233 .",
    "also @xmath161 is a minimum spanning tree for the costs @xmath160 and the new pair @xmath234 satisfies the sufficient pair optimality conditions .",
    "an example can be seen in figure  [ fga ] .",
    "there is a path @xmath235 in the admissible graph .",
    "the arc @xmath169 is both @xmath14-arc and @xmath17-arc .",
    "we can thus choose one of the two possible moves @xmath236 or @xmath237 , which results in @xmath230 or @xmath238 .",
    "[ auc2 ] the augmenting path  @xmath227 is of the form : @xmath239 let @xmath240 .",
    "let @xmath241 for case @xmath242 , and @xmath243 for case @xmath244 .",
    "we now have to show that the resulting pair @xmath178 is a pair of spanning trees .",
    "suppose that @xmath159 is not a spanning tree .",
    "observe that the @xmath14-arcs @xmath245 belong to the cycle graph @xmath246 .",
    "thus , by claim  [ ccycleg ] , the cycle graph @xmath246 must contain a subgraph depicted in figure  [ fcycle ] , where @xmath196 $ ] .",
    "an easy verification shows that all edges @xmath247 , @xmath248 must have the same costs with respect to @xmath158 .",
    "indeed , if some costs are different , then there exists an edge exchange which decreases the cost of @xmath14 .",
    "this contradicts our assumption that  @xmath14 is a minimum spanning tree with respect to @xmath158 .",
    "finally , there must be an arc @xmath249 in the subgraph such that @xmath250 .",
    "since @xmath251 , the arc @xmath249 is present in the admissible graph  @xmath149 .",
    "this leads to a contradiction with our assumption that @xmath227 is an augmenting path .",
    "now suppose that @xmath161 is not a spanning tree .",
    "we consider only the case @xmath242 since the proof of case @xmath244 is just the same . for a convenience ,",
    "let us number the nodes @xmath190 on @xmath227 from @xmath252 to @xmath253 , so that @xmath254 .",
    "the arcs @xmath255 , which correspond to the @xmath17-arcs @xmath256 of @xmath227 , belong to the cycle graph @xmath257 .",
    "hence , by claim  [ ccycleg ] , @xmath257 must contain a subgraph depicted in figure  [ fcycle ] , where @xmath258 $ ] .",
    "the rest of the proof is similar to the proof for @xmath14 .",
    "namely , the edges @xmath192 and @xmath193 for @xmath259 must have the same costs with respect to @xmath160 .",
    "also , there must exist an arc @xmath260 in the subgraph such that @xmath261 . in consequence",
    ", the arc @xmath262 belongs to the admissible graph , which contradicts the assumption that @xmath227 is an augmenting path .",
    "+ an example of the case @xmath242 is shown in figure  [ figex2 ] . thus @xmath263 and @xmath264 .",
    "an example of the case ( b ) is shown in figure  [ figex3 ] . in this example",
    "@xmath159 is the same as in the previous case and @xmath265 .",
    "+ it is easy to verify that @xmath266 holds ( see also the examples in figures  [ figex2 ] and  [ figex3 ] ) .",
    "the spanning trees @xmath159 and @xmath161 are optimal for the costs @xmath158 and @xmath160 , respectively .",
    "furthermore , @xmath267 and @xmath268 , so @xmath118 satisfies the sufficient pair optimality conditions ( the condition ( ii ) in theorem  [ tssoc ] is not violated ) . +   and the corresponding admissible graph for the case  [ auc2]a . ]",
    "+   and the corresponding admissible graph for the case  [ auc2]b . ]",
    "[ auc3 ] the augmenting path @xmath227 is of the form @xmath269 let @xmath270 for the case @xmath242 and @xmath271 for the case @xmath244 .",
    "let @xmath272 .",
    "the proof that @xmath159 and @xmath161 are spanning trees follows by the same arguments as for the symmetric case described in point  [ auc2 ] .",
    "an example of the case @xmath242 is shown in figure  [ figex4 ] .",
    "thus @xmath273 and @xmath274 . an example for the case @xmath244 is shown in figure  [ figex5 ] .",
    "the spanning tree @xmath161 is the same as in the previous case and @xmath275 . the equality @xmath276 holds . also , the trees @xmath159 and @xmath161 are optimal for the costs @xmath158 and @xmath160 , respectively , @xmath267 , @xmath268 , so @xmath118 satisfies the sufficient pair optimality conditions . +   and the corresponding admissible graph for the case  [ auc3]a",
    "] +   and the corresponding admissible graph for the case  [ auc3]b . ]",
    "we now turn to the case @xmath176 .",
    "fix @xmath277 ( the precise value of @xmath278 will be specified later ) and set :    @xmath279    [ newc ]    [ lemdelta ] there exists a sufficiently small @xmath277 such that the costs @xmath280 and @xmath281 satisfy the path optimality conditions for @xmath14 and @xmath17 , respectively , i.e :    @xmath282    [ toptcs ]    if @xmath283 ( resp .",
    "@xmath284 ) , @xmath285 ( resp .",
    "@xmath286 ) , then there is @xmath277 , such that after setting the new costs  ( [ newc ] ) the inequality @xmath287 ( resp .",
    "@xmath288 ) holds .",
    "hence , one can choose a sufficiently small  @xmath277 such that after setting the new costs  ( [ newc ] ) , all the strong inequalities are not violated .",
    "therefore , for such a chosen  @xmath278 it remains to show that all originally tight inequalities in  ( [ toptc ] ) are preserved for the new costs .",
    "consider a tight inequality of the form : @xmath289 on the contrary , suppose that @xmath290 .",
    "this is only possible when @xmath291 and @xmath292 . hence and from the construction of the new costs",
    ", we have @xmath293 ( see ( [ newcb ] ) ) and @xmath145 ( see ( [ newca ] ) ) . by  ( [ ep1 ] )",
    ", we obtain @xmath156 .",
    "thus @xmath294 , a contradiction .",
    "consider a tight inequality of the form : @xmath295 on the contrary , suppose that @xmath296 .",
    "this is only possible when @xmath297 and @xmath298 .",
    "thus we deduce that @xmath299 and @xmath294 ( see ( [ newc ] ) ) . from  ( [ ep2 ] )",
    ", it follows that @xmath300 and so @xmath145 , a contradiction .",
    "we are now ready to give the precise value of @xmath278 .",
    "we do this by increasing the value of  @xmath278 until some inequalities , originally not tight in  ( [ toptc ] ) , become tight .",
    "namely , let @xmath301 be the smallest value of @xmath278 for which an inequality originally not tight becomes tight .",
    "obviously , it occurs when @xmath302 for @xmath138 , @xmath139 or @xmath303 for @xmath164 , @xmath304 . by  ( [ newc ] ) , @xmath145 and @xmath293",
    "accordingly , if @xmath305 , then at least one arc is added to @xmath149 .",
    "observe also that no arc can be removed from @xmath149 - the admissibility of the nodes remains unchanged .",
    "it follows from the fact that each tight inequality for @xmath145 and @xmath294 is still tight .",
    "this leads to the following lemma .",
    "[ linttheta ] if @xmath176 , then @xmath306 satisfies the sufficient pair optimality conditions for each @xmath307 $ ] .",
    "set @xmath308 , @xmath309 $ ] .",
    "lemma  [ lemdelta ] implies that @xmath14 is optimal for @xmath280 and @xmath17 is optimal for @xmath281 . from  ( [ newc ] ) and the definition of the costs @xmath158 and @xmath160",
    ", it follows that @xmath310 and @xmath311 , where @xmath312 and @xmath313 for each @xmath145 , @xmath314 and @xmath315 for each @xmath299 .",
    "notice that @xmath316 for each @xmath5 . by  ( [ newc ] ) , @xmath317 for each @xmath111 ( recall that @xmath111 implies @xmath145 ) , and thus @xmath110 for each @xmath111 . since @xmath176 , @xmath318 holds for each @xmath109 , and so @xmath108 for each @xmath109 .",
    "we thus have shown that there exist @xmath319 such that @xmath320 for each @xmath5 satisfying the conditions  ( i ) and  ( ii ) in theorem  [ tssoc ] , which completes the proof .",
    "we now describe a polynomial procedure that , for a given pair @xmath79 satisfying the sufficient pair optimality conditions for some @xmath74 , finds a new pair of spanning trees @xmath118 , which also satisfies the sufficient pair optimality conditions with @xmath321 .",
    "we start by building the admissible graph @xmath322 for @xmath79 .",
    "if this graph contains an augmenting path , then by lemma  [ txva ] , we are done . otherwise , we determine @xmath323 and modify the costs by using  ( [ newc ] ) .",
    "lemma  [ linttheta ] shows that @xmath79 satisfies the sufficient pair optimality conditions for @xmath324 . for @xmath323",
    "some new arcs are added to the admissible graph @xmath149 ( all the previous arcs must be still present in @xmath149 ) . thus @xmath149 is updated and we set @xmath325 , @xmath326 for each @xmath5 , and @xmath327 .",
    "we repeat this until there is an augmenting path in @xmath322 .",
    "note that such a path must appear after at most @xmath328 iterations , which follows from the fact that at some step a node @xmath146 such that @xmath109 must appear in @xmath149 .     and",
    "@xmath329.,width=377 ]    sample computations are shown in figure  [ figexiter ] .",
    "we start with the pair @xmath79 , where @xmath330 and @xmath329 , which satisfies the sufficient pair optimality conditions for @xmath114 ( see figure  [ figexiter]a ) . observe that in this case it is enough to check that @xmath14 is optimal for the costs @xmath331 and @xmath17 is optimal for the costs @xmath332 , @xmath5 . for @xmath114 , the admissible graph does not contain any augmenting path .",
    "we thus have to modify the costs @xmath158 and @xmath160 , according to  ( [ newc ] ) . for @xmath333 ,",
    "a new inequality becomes tight and one arc is added to the admissible graph ( see figure  [ figexiter]b ) .",
    "the admissible graph still does not have an augmenting path , so we have to again modify the costs . for @xmath333",
    "some new inequalities become tight and three arcs are added to the admissible graph ( see figure  [ figexiter]c ) .",
    "now the admissible graph has two augmenting paths ( cases  [ auc1 ] and  [ auc3]a , see the proof of lemma  [ txva ] ) .",
    "choosing one of them , and performing the modification described in the proof of lemma  [ txva ] we get a new pair @xmath178 with @xmath119 .",
    "let us now estimate the running time of the procedure .",
    "the admissible graph has at most @xmath334 nodes and at most @xmath335 arcs .",
    "it can be built in @xmath336 time .",
    "the augmenting path in the admissible graph can be found in @xmath336 time by applying the breath first search .",
    "also the number of inequalities which must be analyzed to find @xmath323 is @xmath336 .",
    "since we have to update the cost of each arc of the admissible graph at most @xmath334 times , until an augmenting path appears , the required time of the procedure is @xmath337 .",
    "we thus get the following result .",
    "the rec st problem is solvable in @xmath338 time , where @xmath339 . [ trecpol ]",
    "in this section we are concerned with the rob rec st problem under the interval uncertainty representation , i.e. for the scenario sets @xmath64 , @xmath54 , and @xmath61 . using the polynomial algorithm for rec st , constructed in section  [ sec1 ] , we will provide a polynomial algorithm for rob rec st under  @xmath64 and some approximation algorithms for a wide class of rob rec st under  @xmath54 and @xmath61 .",
    "the idea will be to solve rec st for a suitably chosen second stage costs .",
    "let @xmath340 where @xmath341 .",
    "it is worth pointing out that under scenario sets @xmath64 and @xmath61 , the value of @xmath342 , for a given spanning tree @xmath14 , can be computed in polynomial time  @xcite . on the other hand ,",
    "computing @xmath342 under @xmath54 turns out to be strongly np - hard  @xcite .",
    "given scenario @xmath343 , consider the following rec st problem : @xmath344 problem  ( [ incst1 ] ) is equivalent to the formulation  ( [ recst ] ) for @xmath59 and it is polynomially solvable , according to the result obtained in section  [ sec1 ] . as in the previous section , we denote by pair @xmath79 a solution to  ( [ incst1 ] ) , where @xmath8 and @xmath16 . given @xmath345 , we call @xmath79 an _ optimal pair under _",
    "@xmath345 if @xmath79 is an optimal solution to  ( [ incst1 ] ) .",
    "the rob rec st problem with scenario set  @xmath64 can be rewritten as follows : @xmath346 thus ( [ irs ] ) is ( [ incst1 ] ) for @xmath347 .",
    "hence and from theorem  [ trecpol ] we immediately get the following theorem :    for scenario set @xmath50 , the rob rec st problem is solvable in @xmath348 time .",
    "we now address rob rec st under  @xmath54 and @xmath61 .",
    "suppose that @xmath349 for each @xmath5 , where @xmath350 $ ] is a given constant .",
    "this inequality means that for each edge @xmath5 the nominal cost  @xmath7 is positive and @xmath351 is at most @xmath352 greater than @xmath7 .",
    "it is reasonable to assume that this condition will be true in many practical applications for not very large value of @xmath352 .",
    "[ lemappr1 ] suppose that @xmath349 for each @xmath5 , where @xmath350 $ ] , and let @xmath353 be an optimal pair under @xmath354 . then for the scenario sets @xmath54 and @xmath61 the inequality @xmath355 holds for any @xmath8 .",
    "we give the proof only for the scenario set @xmath54 .",
    "the proof for @xmath61 is the same .",
    "let @xmath8 .",
    "the following inequality is satisfied : @xmath356 clearly , @xmath357 is a feasible pair to  ( [ incst1 ] ) under @xmath358 . from the definition of @xmath359 we get",
    "@xmath360 where @xmath361 .",
    "hence @xmath362 and the lemma follows .    the condition @xmath349 , @xmath5 , in lemma  [ lemappr1 ] , can be weakened and , in consequence , the set of instances to which the approximation ratio of the algorithm applies can be extended .",
    "indeed , from inequality  ( [ pappro ] ) it follows that the bounds of the uncertainty intervals are only required to meet the condition @xmath363 .",
    "this condition can be verified efficiently , since @xmath364 can be computed in polynomial time .",
    "we now focus on rob rec st for  @xmath61 .",
    "define @xmath365 and suppose that @xmath366 ( if @xmath367 , then the problem is equivalent to rec st for the second stage costs @xmath7 , @xmath5 ) .",
    "consider scenario @xmath368 under which @xmath369 for each @xmath5 .",
    "obviously , @xmath370 , since @xmath371 .",
    "the following theorem provides another approximation result for rob rec st with scenario set  @xmath61 :    [ lemappr2 ] let @xmath353 be an optimal pair under  @xmath368",
    ". then the following implications are true for scenario set @xmath61 :    * if @xmath372 , @xmath373 $ ] , then @xmath374 for any @xmath8 . *",
    "if @xmath375 , @xmath376 then @xmath377 for any @xmath8 .",
    "let @xmath8 .",
    "since @xmath370 , we get @xmath378 we first prove implication  @xmath379 . by  ( [ ee0 ] ) and the definition of @xmath359 , we obtain @xmath380 where @xmath361 .",
    "the rest of the proof is the same as in the proof of lemma  [ lemappr1 ] .",
    "we now prove implication  @xmath381 . by  ( [ ee0 ] ) and the definition of @xmath359",
    ", we have @xmath382 if @xmath375 . then @xmath383 and @xmath384    note that the value of @xmath385 under @xmath61 can be computed in polynomial time  @xcite . in consequence",
    ", the constants @xmath386 and @xmath387 can be efficiently determined for every particular instance of the problem .",
    "clearly , we can assume that @xmath388 for each @xmath5 , which implies @xmath389 , where @xmath328 .",
    "hence , we can assume that @xmath390 for every instance of the problem .",
    "we thus get from lemma  [ lemappr2 ] ( implication ( i ) ) that @xmath391 for any @xmath8 and the problem is approximable within @xmath334 .",
    "if @xmath392 , @xmath386 and @xmath387 are the constants from lemmas  [ lemappr1 ] and  [ lemappr2 ] , then the following theorem summarizes the approximation results :    rob rec st is approximable within @xmath393 under scenario set @xmath54 and it is approximable within @xmath394 under scenario set @xmath61 .    observe that lemma  [ lemappr1 ] and lemma  [ lemappr2 ] hold of any sets @xmath3 and @xmath395 ( the particular structure of these sets is not exploited ) .",
    "hence the approximation algorithms can be applied to any problem for which the recoverable version  ( [ incst1 ] ) is polynomially solvable .",
    "in this paper we have studied the recoverable robust spanning tree problem ( rob rec st ) under various interval uncertainty representations .",
    "the main result is the polynomial time combinatorial algorithm for the recoverable spanning tree .",
    "we have applied this algorithm for solving rob rec st under the traditional uncertainty representation ( see , e.g. ,  @xcite ) in polynomial time . moreover , we have used the algorithm for providing several approximation results for rec st with the scenario set introduced by bertsimas and sim  @xcite and the scenario set with a budged constraint ( see , e.g , .",
    "there is a number of open questions concerning the considered problem .",
    "perhaps , the most interesting one is to resolve the complexity of the robust problem under the interval uncertainty representation with budget constraint .",
    "it is possible that this problem may be solved in polynomial time by some extension of the algorithm constructed in this paper .",
    "one can also try to extend the algorithm for the more general recoverable matroid base problem , which has also been shown to be polynomially solvable in  @xcite .                                      c.  liebchen , m.  e. lbbecke , r.  h. mhring , and s.  stiller . the concept of recoverable robustness , linear programming recovery , and railway applications . in _ robust and online large - scale optimization",
    ", volume 5868 of _ lecture notes in computer science _ , pages 127 .",
    "springer - verlag , 2009 ."
  ],
  "abstract_text": [
    "<S> this paper deals with the recoverable robust spanning tree problem under interval uncertainty representations . a strongly polynomial time </S>",
    "<S> , combinatorial algorithm for the recoverable spanning tree problem is first constructed . </S>",
    "<S> this problem generalizes the incremental spanning tree problem , previously discussed in literature . </S>",
    "<S> the algorithm built is then applied to solve the recoverable robust spanning tree problem , under the traditional interval uncertainty representation , in polynomial time . moreover </S>",
    "<S> , the algorithm allows to obtain several approximation results for the recoverable robust spanning tree problem under the bertsimas and sim interval uncertainty representation and the interval uncertainty representation with a budget constraint .    </S>",
    "<S> robust optimization ; interval data ; recovery ; spanning tree </S>"
  ]
}