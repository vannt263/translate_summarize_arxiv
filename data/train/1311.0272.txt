{
  "article_text": [
    "the computing requirements for high energy physics ( hep ) projects like the large hadron collider ( lhc )  @xcite at the european laboratory for particle physics ( cern ) in geneva , switzerland are larger than can be met with resources deployed in a single computing center .",
    "this has led to the construction of a global distributing computing system known as the worldwide lhc computing grid ( wlcg )  @xcite , which brings together resources from nearly 160 computer centers in 35 countries .",
    "computing at this scale has been used , for example , by the cms  @xcite and atlas  @xcite experiments for the discovery of the higgs boson  @xcite . to achieve this and other results the cms experiment , for example , typically used during 2012 a processing capacity between 80,000 and 100,000 x86 - 64 cores from the wlcg .",
    "further discoveries are possible in the next decade as the lhc moves to its design energy and increases the machine luminosity .",
    "however , increases in dataset sizes by 2 - 3 orders of magnitude ( and commensurate processing capacity ) will eventually be required to realize the full potential of this scientific instrument .",
    "building the software to run on and operate such a computing system is a major challenge .",
    "the distributed nature of the system implies that ownership and control of the resources is also distributed , and thus the resources are by necessity heterogeneous in nature .",
    "this heterogeneity appears both in terms of specific x86 hardware generations and in patch levels of the deployed linux operating systems .",
    "as these resources are at times shared with other projects custom modifications of systems for hep - specific or experiment - specific reasons are in general not possible .",
    "the very large number of cpu hours used also introduces significant reliability requirements on the software .",
    "the software itself is non - trivial : each experiment typically is dependent on many millions of lines of code , written for the most part in c++ with contributions from up to a thousand physicists . given the upgrade and evolution plans for the lhc , these software projects , begun in the late 1990 s , will likely need to evolve with computing technology through the 2020 s .",
    "such an environment however provides significant opportunities for innovation . in this paper",
    "we examine one interesting technology , _ process checkpoint - restart _ , which has great potential for use in hep workflows in such a system .",
    "we first describe the specific use cases of interest and the requirements to make the technology useful in the hep environment .",
    "we then provide some benchmarks for the use of checkpoint - restart with the cms software on today s x86 - 64 processors . and finally , we examine aspects of this technology which are of interest given the possible evolution of processor technologies and resource availability in the coming years .",
    "we look in particular at the use of checkpointing with architectures like intel s xeon phi , a member of intel s mic ( many integrated core ) architecture .",
    "in many circumstances it is desirable to `` checkpoint '' the state of a unix process , or a set of processes , to disk with the possibility of restarting it at a later time .",
    "there are a number of interesting use cases for this functionality :    * debugging : * the very large number of jobs and cpu hours required for hep computing makes high reliability of the software quite important .",
    "the distributed and heterogeneous nature of the computing system however makes debugging problems somewhat difficult , as the first step to resolving most code behavior problems is being able to reproduce the problem . while a traditional `` core '' file may provide information about the process state after a crash has happened , it does nt allow one to step through the program to see the behavior leading to the crash",
    ". in the case where the crash happens after a job has run for many hours , reproducing a problem by rerunning it from the beginning can also be quite expensive . if however a job were to checkpoint its state from time to time , it would be possible to use the last checkpointed state before a crash to reproduce and replay the problem quickly .",
    "* avoiding cpu - intensive initialization steps : * many applications are constructed such that they have cpu - intensive initialization steps .",
    "examples include in - memory geometry construction from a simplified geometry description , physics cross section table calculations , etc .",
    "typically this is done to allow generality of software implementation for multiple possible job configurations : it is easier to calculate quantities derived from job configurations on the fly at the beginning of each job than to store those quantities for a possibly infinite number of potential job configurations .",
    "hep workflows are however constructed such that a particular job configuration may be used for a very large number of jobs , where the geometry or physics process configuration are the same and only random number seeds or input files change from job to job .",
    "the result is that the same calculation is done in every single job instance in a particular workflow . in most cases where jobs run for a long time",
    "this job initialization time is negligible relative to the total running time .",
    "however two cases exist where job initialization time can be problematic .",
    "first , very short duration jobs can sometimes be required for other software reasons or for operational reasons related to resource availability or input dataset structure . in this case",
    "the overhead from long startup initialization times can be a significant fraction of the cpu utilization .",
    "second , as will be described later , there are strong reasons to consider the use of multi - threaded applications in the future . in the case where the startup initialization itself can not be easily parallelized and will be executed sequentially on a single core",
    ", the initialization itself may effectively idle a large number of other cores eventually needed for the event processing . in this case , a single instance of the job can be run and checkpointed just after the initialization phase .",
    "that checkpoint can then be used to restart a much larger number of instances of the application in batch , with only minor reconfiguration to set input files and/or random number seeds .",
    "the instances running in batch can thus avoid the startup cpu cost .",
    "* allowing preemption during opportunistic resource use : * from time to time , it is possible to `` opportunistically '' use computing resources which belong to some other organization when the other organization does not have enough work to keep the processors fully utilized for some period of time . in some of these cases the period of time for which the resources are made available may not be well defined in advance and the resources may need to be handed back to their owner in an unscheduled fashion . in this case",
    "it is useful to be able to `` preempt '' running opportunistic jobs , checkpoint their state to disk and restart them when opportunistic use is again possible .",
    "* interactive `` workspaces '' : * in interactive programs , such as event displays and analysis tools , the user provides inputs which lead to particular state of the program at a given time . being able to save that state out , for example before going home for the day , and restart later is often desirable .    *",
    "very long running jobs : * in situations where jobs must run for an extremely long time , sometimes days or weeks , they can be sensitive to hardware or infrastructure failures or interfere with required site maintenance .",
    "in these cases it can be quite useful to checkpoint periodically the program to avoid losing and needing to repeat the calculations from scratch after such failures .",
    "* managing `` tails '' for multi - threaded applications * : several hep experiments are moving in the direction of multi - threaded frameworks , which ( initially ) process events on different threads . as the cpu time per event can vary significantly ( with long `` tails '' to the distribution ) at the end of the job , one thread may still be processing an event which takes a long time while the other threads / cores are idled .",
    "one possibility for managing such situations would be to checkpoint the job with a single active thread and restart a number of such jobs at a later time together , to keep the full set of cpu cores active .",
    "a rudimentary `` checkpoint - restart '' can sometimes be achieved in an application - specific fashion .",
    "for example a typical hep event processing framework can be constructed to perform a simple `` checkpoint '' by flushing completed output events to its output file after every n input events have been processed .",
    "in addition it is necessary to write some sort of `` metadata '' to track any other relevant internal state needed to restart the job , e.g. how far the job had progressed through its input events , the state of random number generators , etc . in this example",
    "a `` restart '' would then be performed by restarting the framework and passing it information to allow it to reconfigure itself to match the state it was in at the time of the output checkpoint .",
    "this requires however the addition and maintenance of dedicated code , both in the framework itself and externally in the workflow management system . in some cases , where third party libraries are used which also maintain state , it can be quite complex to truly restore the same state .",
    "if the state is encapsulated within the code of the library , for software engineering reasons , it can also be impossible .",
    "a much better , and more general , solution is true process - level checkpointing .",
    "this is a technology which has existed for a long time , especially in high performance computing ( hpc ) and batch systems , however often the particular implementations are tied to specific environments .",
    "thus the technology has not seen general use in hep high throughput distributed computing . in this paper",
    "we examine the use of a transparent , user - level checkpointing package for distributed applications called distributed multithreaded checkpointing ( dmtcp )  @xcite .",
    "the features of dmtcp make it more appropriate for deployment in the hep distributed computing environment .",
    "dmtcp ( distributed multithreaded checkpointing ) is free , open source software ( http://dmtcp.sourceforge.net , lgpl license ) .",
    "the dmtcp project traces its roots to late  2004 .",
    "a key feature of dmtcp for use in the heterogeneous hep computing environment is that it works in user space , with no kernel - level modifications required . as such",
    "it is works with a wide range of linux kernel versions .",
    "it also works with multi - threaded applications and compression of output checkpoint files is possible",
    ".    its usage can be as simple as :    ....    dmtcp_launch ./myapp arg1 ...    dmtcp_command --checkpoint     [ from a second terminal window ]    dmtcp_restart ckpt_myapp_*.dmtcp ....    dmtcp is also `` contagious '' .",
    "if a process begins under dmtcp control , then any child processes will also be under dmtcp control , and any remote processes ( spawned through `` ssh '' ) will also be under dmtcp control . at the time of checkpoint , a script , dmtcp_restart_script.sh , is written , and the script can restart all processes across all nodes for the given computation .    the newly released dmtcp version  2.0 ( as of oct",
    ". 3 , 2013 ) , supports dmtcp plugins to flexibly adapt to external conditions .",
    "for example , the dmtcp plugin interface permits application - initiated checkpoints , as well as application - delayed checkpoints during critical operations .",
    "alternatively , the interval flag of dmtp_launch permits automatic periodic checkpointing .",
    "dmtcp plugins make it easier to use event hooks to detach such external resources as a database prior to checkpoint , and to reconnect during restart .",
    "while dmtcp will save and restore the file offset of open files , event hooks make available an alternative of cleanly closing valuable files during checkpoint , and re - opening them during restart . in another example , dmtcp virtualizes network addresses to enable transparent migration to a new cluster .",
    "finally , if a large region of memory is not actively used at the time of checkpoint , then the size of the checkpoint image can be considerably reduced .",
    "an event hook allows the application to write zeroes into the inactive memory at checkpoint time , and dmtcp will then replace the zeroes by zero - fill - on - demand pages ( empty pages to be recreated on demand ) .    among the contributed plugins for dmtcp",
    "is the rm ( resource manager ) plugin , which supports use of dmtcp within the torque and slurm batch queues .",
    "plugin support for additional batch queues is planned .",
    "similarly , future support for the intel scif network is planned , allowing one to checkpoint a computation over a network of intel mic cpus .",
    "the scif plugin will be based on the existing contributed plugin to support checkpointing over infiniband .",
    "other contributed plugins support checkpointing a network of virtual machines .",
    "virtual machines ease the job of deploying complex software .",
    "to investigate the characteristics of dmtcp with hep software , we chose to make tests using the cms simulation application .",
    "the machine used to do the test was a dual quad - core intel xeon l5520 operating at 2.27ghz , with 24 gb of memory .",
    "tests were done with checkpoint files written to a local disk as well as the normal job output files .",
    "the test job had no input event file .",
    "however it reads conditions via a web squid from a remote database .",
    "dmtcp version 1.2.7 and cmssw version @xmath0 , compiled with gcc version 4.7.2 , were used for the tests . for simplicity",
    "the test job used with checkpointing was the only cpu - intensive process running on the machine at the time the tests were performed .",
    "the tests were done using the external dmtcp coordinator trigger to produce a checkpoint , rather than the api .",
    "the cms application generated simple minimum bias events and simulated them with geant4  @xcite .",
    "the particular test job itself has a 2 minute initialization phase and then takes an average time per event of @xmath113 seconds .",
    "the memory footprint is @xmath11 gb vsize ( 750 mb rss ) .",
    "a typical uncompressed checkpoint takes @xmath11.5s and the resulting size on disk of the checkpoint file was @xmath1750 mb . when triggering checkpointing with the compression on , @xmath110s was required .",
    "the checkpoint image was however significantly smaller , at only @xmath1220 mb . in both cases",
    "no problems were seen in restarting the application from the checkpoint files .",
    "the construction of the wlcg was greatly facilitated by the convergence around the year 2000 on commodity x86 hardware and the standardized use of linux as the operating system for scientific computing clusters .",
    "even if multiple generations of x86 hardware ( and hardware from both intel and amd ) are provided in the various computer centers , this was a far simpler situation than the previous typical mix of proprietary unix operating systems and processors . until around 2005",
    ", a combination of increased instruction level parallelism and ( in particular ) processor clock frequency increases insured that performance gains expected from moore s law would be seen by single sequential applications running on a single processor . the combination of linux , commodity x86 processors and moore s law gains for sequential applications made for a simple software environment .",
    "however since around 2005 processors have hit scaling limits , largely driven by overall power consumption  @xcite .",
    "the first large change in commercial processor products as a result of these limits was the introduction of `` multicore '' cpus , with more than one functional processor on a chip .",
    "at the same time clock frequencies ceased to increase with each processor generation and indeed were often reduced relative to the peak .",
    "the result of this was one could no longer expect that single , sequential applications would run faster on newer processors .",
    "however in the first approximation , the individual cores in the multicore cpus appeared more or less like the single standalone processors used previously .",
    "most large scientific applications ( hpc / parallel or high throughput ) run in any case on clusters and the additional cores are often simply scheduled as if they were additional nodes in the cluster .",
    "this allows overall throughput to continue to scale even if that of a single application does not .",
    "it has several disadvantages , though , in that a number of things that would have been roughly constant over subsequent purchasing generations in a given cluster ( with a more or less fixed number of rack slots , say ) now grow with each generation of machines in the computer center .",
    "this includes the total memory required in each box , the number of open files and/or database connections , increasing number of independent ( and incoherent ) i / o streams , the number of jobs handled by batch schedulers , etc .",
    "the specifics vary from application to application , but potential difficulties in continually scaling these system parameters puts some pressure on applications to make code changes in response , for example by introducing thread - level parallelism where it did not previously exist .",
    "there is moreover a more general expectation that the limit of power consumption on future moore s law scaling will lead to more profound changes going forward . in particular ,",
    "the power hungry x86 - 64 `` large '' cores of today will likely be replaced by simpler and less power hungry `` small '' cores .",
    "one example of such a technology is the intel mic architecture , as implemented in the intel xeon phi coprocessor card .",
    "to test the use of checkpointing on the xeon phi , we used a beta version of geant4 version 10 which provides support for event - based multi - threaded applications .",
    "we did not use the full cms simulation for this , but instead a simpler benchmark application ( fullcms ) which uses the actual cms geometry imported from gdml file .",
    "the experimental setup was a standard intel xeon box with 32 logical cores , equipped with an intel xeon phi 5120p coprocessor card . in our test",
    "the application is started and checkpoints are triggered in different moments . then we have restarted the application from the checkpoint file and we have verified that the application resumes correctly from the saved state .",
    "this condition is verified checking that the final output of the simulation equals the original one .",
    "a comparison of random number engine status at the end of the job . since in a geant4 application",
    "there is a very large use of random numbers ( billions of calls to the engine in typical application ) , if the status of the application from the checkpoint file does not match exactly the original one the sequence of the random number calls will be different , producing a different final state of the random number engine .",
    "a typical geant4 application with multi - thread support consists of a sequential part in which the geometry of the experimental setup is built in memory and physics processes are initialized ( e.g. material - dependent cross sections are calculated ) .",
    "threads are then spawned , initialized and they start to simulate events independently ( see figure  [ fig : geant4-ckpt ] ) . to reduce the total memory footprint the most memory consuming objects are shared between threads .",
    "the need for synchronization between threads ( locks , barriers ) is minimized since only read - only objects are shared .",
    "we have performed tests to verify the correct behavior of dmtcp for two of the use cases described in section  [ sec : usecase ] .    in the first case",
    "we have instrumented the geant4 application code with a call to dmtcp to trigger a checkpoint file at the end of the initialization phase ( figure  [ fig : ckpt1 ] ) . on the intel xeon phi accelerator",
    "the initialization takes about 5 minutes .",
    "the checkpointing itself takes about 1 minute ( the application working directory , physically located on the host , was mounted by the coprocessor through nfs ) and the resulting checkpoint image file is 1.4 gb ( uncompressed ) . restarting from the checkpoint image file takes less than 10s .",
    "functionally this appears to work as expected .",
    "the resulting checkpoint image file can thus be distributed to other nodes and the simulation process `` cloned '' without the startup cost , simply by resetting the random number seeds .    for the second test",
    "we have emulated the use case of some threads being slower than other in producing results .",
    "this can happen if one or more threads is simulating more complex - than - average events .",
    "to control such behavior we have modified our application in a way that half of the threads were responsible of simulating simple and fast events ( low energy single particles ) while the second half of threads was responsible for longer ones ( ten times higher energy ) .",
    "in current geant4 multi - threaded mode the application will wait for all threads before terminating thus leaving half of the mic cores unused .",
    "we have instrumented the application code to verify when the number of active threads drops below a given value , in such a case a checkpoint is triggered ( figure  [ fig : ckpt2 ] ) .",
    "also in this case we have verified that the application was behaving as expected .",
    "it is important to note that we did not have to modify geant4 `` kernel '' code to enable checkpointing , all code modifications were done at the application level . for the first test ( checkpointing at first event ) we have provided feedback to geant4 developers that have introduced a new user - hook , not present in the initial design of the code , that allows for the execution of ( optional ) user code just before the first event is simulated but after all threads have been fully initialized ( this guarantees that the checkpointing is performed in a reproducible state of the application ) .",
    "both tests show that checkpointing can be used to increase the efficiency of resource usage also on accelerator technologies where the minimization of the time spent in sequential fractions of the code or with only few threads active is fundamental to efficiently use the hardware resources .",
    "we have made investigations into the use of the checkpoint - restart technology dmtcp with hep applications from cms and geant4 .",
    "we have reported on the performance seen , both on a traditional x86 - 64 architecture and on intel s xeon phi , for situations relevant for a number of interesting use cases for hep computing .",
    "we believe that the results obtained are very encouraging and demonstrate the viability of the use of this technology in the hep environment .",
    "this work was partially supported by the national science foundation under grant  oci-0960978 ( arya , cooperman ) and cooperative agreement phy-1120138 ( elmer ) as well as by the u.s .",
    "department of energy ( dotti ) .",
    "9 evans l and bryant p 2008 lhc machine _ jinst _ * 3 * s08001 bird i 2011 computing for the large hadron collider _ annual review of nuclear and particle science _ * 61 * 99 - 118 chatrchyan s et al ( cms collaboration ) 2008 the cms experiment at the cern lhc _ jinst _ * 3 * s08004 aad g et al ( atlas collaboration ) 2008 the atlas experiment at the cern large hadron collider _ jinst _ * 3 * s08003 chatrchyan s et al ( cms collaboration ) 2012 observation of a new boson at a mass of 125 gev with the cms experiment at the lhc _ phys.lett . _",
    "* b716 * 30 - 61 aad g et al ( atlas collaboration ) 2012 observation of a new particle in the search for the standard model higgs boson with the atlas detector at the lhc",
    "_ phys.lett .",
    "_ * b716 * 1 - 29    ansel j , arya k and cooperman g 2009 dmtcp : transparent checkpointing for cluster computations and the desktop _ proc .",
    "ieee intl .",
    "parallel and distributed processing symposium _",
    "( rome ) agostinelli s et al 2003 geant4 - a simulation toolkit _ nuclear instruments and methods in physics research _ * a 506 * 250 - 303 fuller s h and millet l i ( editors ) 2011 _ the future of computing performance : game over or next level ? _ the national academies press ."
  ],
  "abstract_text": [
    "<S> process checkpoint - restart is a technology with great potential for use in hep workflows . </S>",
    "<S> use cases include debugging , reducing the startup time of applications both in offline batch jobs and the high level trigger , permitting job preemption in environments where spare cpu cycles are being used opportunistically and efficient scheduling of a mix of multicore and single - threaded jobs . </S>",
    "<S> we report on tests of checkpoint - restart technology using cms software , geant4-mt ( multi - threaded geant4 ) , and the dmtcp ( distributed multithreaded checkpointing ) package . </S>",
    "<S> we analyze both single- and multi - threaded applications and test on both standard intel x86 architectures and on intel mic . </S>",
    "<S> the tests with multi - threaded applications on intel mic are used to consider scalability and performance . </S>",
    "<S> these are considered an indicator of what the future may hold for many - core computing . </S>"
  ]
}