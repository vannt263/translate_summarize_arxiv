{
  "article_text": [
    "instantly decodable network coding ( idnc ) is a class of linear network coding schemes @xcite which has been widely studied and applied in wireless unicast , multicast and broadcast systems .",
    "it has been shown that idnc schemes can quite significantly improve data throughput in such systems compared to their uncoded counterparts @xcite , while offering simple xor - based encoding and decoding .",
    "furthermore , idnc provides instant packet decodability at the receivers , which can result in faster delivery of the packets to the application layer compared to other linear network coding schemes @xcite .    in this paper , we are primarily concerned with investigating the performance limits of idnc schemes for data dissemination in single - hop wireless broadcast systems in terms of throughput and delay . in such systems",
    ", there is a single sender who wishes to broadcast a block of data packets to multiple receivers @xcite . due to packet erasures in wireless fading channels ,",
    "some transmitted packets are lost at the receivers .",
    "generally , information about received or lost packets are fed back from the receivers to the sender after transmission of one or multiple packets .",
    "the sender then determines which data packets from the block to combine and transmit next subject to idnc constraints .",
    "this process is repeated until the broadcast of the block is complete , i.e. until all receivers have decoded all data packets .    in such systems ,",
    "the time it takes to complete the block , or simply the idnc block completion time , is a fundamental measure of its throughput performance and will be studied in this paper .",
    "taking the block completion time of random linear network coding ( rlnc ) @xcite as a benchmark , many works in the literature have been concerned with proposing idnc schemes with good throughput performance @xcite .",
    "the majority of these schemes collect feedback about the lost packets and determine an _ online _ idnc solution accordingly , which comprises one or more coded packets , such that it can efficiently bring the system closer to block completion .",
    "although these works differ in their models and assumptions about the frequency and reliability of feedback @xcite , at their core they run dynamic idnc algorithms , responding to erasure patterns that have happened along the transmission .",
    "the main limitation of such studies is that it is impossible to say _ a priori _ how long it will actually take to complete a block starting with a certain system packet reception state at the receivers .",
    "furthermore , such idnc solution is in fact the result of a local optimization , and there is no guarantee that the solution is globally optimal .",
    "therefore , the following two fundamental questions still seem unanswered in the literature :    1 .",
    "what is the _",
    "best _ throughput performance of idnc ? 2 .",
    "which idnc solution can achieve this best throughput performance ?    by best throughput , we refer to the minimum block completion time that is possible by using idnc starting with a certain system packet reception state , _ in the absence of any future erasures_. it is clear that packet erasures in an actual system can defer block completion .",
    "therefore , our measure of throughput is the best possible performance of the idnc schemes in terms of throughput and serves as an upper bound on what idnc can achieve in the presence of erasures .",
    "such measure of throughput is significant because it disentangles the effects of channel - induced packet erasures and algorithm - induced idnc coded packet selection on the throughput of the system .",
    "based on this measure of throughput , we propose the concept of _ optimal _ idnc scheme which refers to an idnc scheme that provides globally optimal idnc solution and achieves the best throughput performance in the absence of any future erasures .    besides block completion time",
    ", another fundamental performance metric of idnc is its decoding delay .",
    "there are various definitions of decoding delay in the literature @xcite . in this work ,",
    "we consider _ packet decoding delay _ , defined as the number of time slots it takes till the data packets are decoded by the receivers .",
    "the reasons for our choice are twofold .",
    "first , short packet decoding delay is the main advantage of idnc , which is particularly desirable for applications in which data packets are useful regardless of their order .",
    "second , packet decoding delay is naturally related to the throughput of idnc and its respective idnc solution .",
    "that is , having investigated the best throughput performance of idnc and the optimal idnc solution , decoding delay limits of idnc schemes can be obtained with relative ease .    the contributions of this paper can be summarized as follows .",
    "first , the best achievable throughput performance of idnc , regardless of packets erasure probabilities and feedback frequency , and its corresponding optimal idnc solution are rigorously obtained .",
    "furthermore , the concept of _ idnc packet diversity _ in the optimal idnc solution is introduced .",
    "it is a measure of the robustness of idnc solution against packet erasures .",
    "while ensuring the optimal throughput performance , our proposed idnc solution enhances packet diversity wherever possible , hence enhancing its robustness against erasures .",
    "this feature distinguishes our optimal idnc solution from other idnc solutions in the literature , where packet diversity has never been considered , to the best of our knowledge .",
    "second , the impact of feedback frequency on the performance of the idnc scheme is investigated , the concept of semi - online feedback is introduced and optimal fully - online and optimal semi - online idnc schemes are devised .",
    "third , we derive lower and upper bounds on the throughput and decoding delay performance of idnc schemes",
    ". furthermore , we design the optimal idnc coding algorithm , as well as its simplified alternatives that offer efficient performances with much lower computational complexities .",
    "the performance of these algorithms is evaluated via extensive simulations under different settings of system parameters .",
    "the results illustrate the interactions among these parameters and can serve as simple implementation guidelines .",
    "plenty of hands - on examples are also designed to demonstrate the proposed concepts , theorems , methodologies , and algorithms . in summary",
    ", this work can be a useful reference in the idnc literature and can motivate further research .",
    "idnc can be divided into two categories , strict idnc ( s - idnc ) @xcite and general idnc ( g - idnc ) @xcite .",
    "although they have the same system model and use similar dynamic algorithms , they differ in the sense that g - idnc coded packets are allowed to include two or more new data packets for some receivers .",
    "however , this is not allowed in s - idnc . in this paper , we focus on s - idnc ( or idnc for short ) . the relationship and comparisons between s- and g - idnc",
    "will be discussed when necessary .",
    "s - idnc problem is , to some extent , related to the index coding problem @xcite , especially when memoryless decoding is considered in the index coding problem @xcite .",
    "nevertheless , their problem formulations are different .",
    "a basic assumption in index coding is that a receiver who has successfully received a subset of packets but is still missing multiple packets can be considered as multiple receivers each wanting only one of the missing packets .",
    "however , such splitting is prohibited in s - idnc , for it will violate the instantly decodable property of idnc coded packets .",
    "therefore , results of index coding and s - idnc can not be used interchangeably .",
    "we consider a packet - based wireless broadcast scenario from one sender to @xmath0 receivers .",
    "receiver @xmath1 is denoted by @xmath2 and the set of all receivers is @xmath3 .",
    "there are a total of @xmath4 binary packets with identical length to be delivered to all receivers .",
    "packet @xmath5 is denoted by @xmath6 and the set of all packets is @xmath7 .",
    "sometimes we will refer to @xmath6 as an original data packet to distinguish it from a coded packet .",
    "time is slotted and in each time slot , one ( coded or original data ) packet is broadcast .",
    "the wireless channel between the sender and each receiver is modeled as a memoryless erasure link with i.i.d .",
    "packet erasure probability of @xmath8 .",
    "the results proposed in the paper can be generalized , with proper modifications , to non - homogeneous erasure links .",
    "initially , the @xmath4 packets are transmitted uncoded once using @xmath4 time slots .",
    "this is the _",
    "systematic transmission phase_. after this phase , each receiver provides feedback to the sender about the packets it has received or lost .",
    "the number of packets that are not received by at least one receiver due to erasures is denoted by @xmath9 and their set is denoted by @xmath10 , where @xmath11 .",
    "the number of receivers that have not received all the @xmath4 packets is denoted by @xmath12 and the set of these receivers is denoted by @xmath13 , where @xmath14 .",
    "the complete state of receivers and packets can be captured by an @xmath15 state feedback matrix ( sfm ) @xmath16 ( also known as receiver - packet incidence matrix  @xcite ) , where the element at row @xmath1 and column @xmath5 is denoted by @xmath17 and @xmath18 based on the sfm , we define the notions of _ wants _ set @xcite for each receiver and _ targeted _ receivers for each packet :    the wants set of receiver @xmath2 , denoted by @xmath19 , is the subset of packets in @xmath20 which are lost at @xmath2 due to packet erasures .",
    "that is , @xmath21 .",
    "the target set of a packet @xmath6 , denoted by @xmath22 , is the subset of receivers in @xmath23 who want packet @xmath6 .",
    "that is , @xmath24 .",
    "the size of @xmath22 is denoted by @xmath25 .",
    "consider the sfm in fig.[fig : sfm_example ] .",
    "there are @xmath26 packets and @xmath27 receivers after the systematic transmission phase .",
    "the wants set of @xmath28 is @xmath29 .",
    "the target set of @xmath30 is @xmath31 and thus @xmath32 .      in this subsection",
    ", we present some basic definitions and performance metrics related to idnc . then in the next subsection",
    ", we will briefly discuss existing models in the literature to deal with the idnc problem .",
    "after the systematic transmission phase and collecting receivers feedback , the _ coded transmission phase _ starts . in this phase , idnc aims to satisfy the demands of all receivers by sending coded packets under two fundamental restrictions :    1 .",
    "the sender uses the binary field @xmath33 for linear coding ; 2 .",
    "receivers do not store received coded packets for future decoding , i.e. memory is not required at the receivers ;    more precisely , the first restriction means that the @xmath34-th transmitted coded packet is of the form @xmath35 where @xmath36 and the summation is bit - wise xor @xmath37 .",
    "we denote by @xmath38 the set of original data packets that have non - zero coefficients in @xmath39 , namely , @xmath40 .",
    "@xmath38 fully represents @xmath39 and is called a coding set .",
    "based on , @xmath39 can be one of the following for each receiver :    a coded packet @xmath39 is instantly decodable for receiver @xmath2 if @xmath38 contains only one original data packet from the wants set @xmath19 of @xmath2 .",
    "a coded packet @xmath39 is non - instantly decodable for receiver @xmath2 if @xmath38 contains two or more original data packets from the wants set @xmath19 of @xmath2 .",
    "due to restriction 2 above , a non - instantly decodable coded packet will be discarded by @xmath2 upon receiving .",
    "a coded packet @xmath39 is non - innovative for receiver @xmath2 if @xmath38 only contains original data packets not from the wants set @xmath19 of @xmath2 .",
    "otherwise , it is innovative .",
    "a non - innovative coded packet will be also discarded by @xmath2 upon receiving .",
    "consider the sfm in fig.[fig : sfm_example ] .",
    "@xmath41 is instantly decodable for @xmath28 because the corresponding coding set @xmath42 only contains one original data packet ( @xmath43 ) from the wants set of @xmath28 .",
    "thus , @xmath28 can instantly decode @xmath43 through the operation @xmath44 .",
    "@xmath45 is also instantly decodable for @xmath46 .",
    "however , @xmath45 is non - instantly decodable for @xmath47 because both @xmath48 and @xmath43 are from the wants set of @xmath47 .",
    "@xmath45 is non - innovative for @xmath49 because @xmath49 has both @xmath48 and @xmath43 already .",
    "the throughput and decoding delay performance of idnc can be measured by _ the minimum number of coded transmissions _ and _ the average packet decoding delay _",
    ", where :    given an sfm , the minimum number of coded transmissions , or equivalently the minimum block completion time , is the smallest possible number of idnc coded transmissions required in order to satisfy the demands of all the receivers in the absence of any future packet erasures .",
    "this number is denoted by @xmath50 .    in the next section",
    ", we will further show that @xmath50 can not be reduced regardless of feedback frequency .",
    "thus , we claim that @xmath50 is the _ absolute _ minimum number of coded transmissions .",
    "@xmath50 indicates the best throughput performance , which can be calculated as @xmath51 .",
    "such measure is important as it disentangles the effect of channel - induced packet erasures and algorithm - induced idnc coded packet selections on the throughput of the system .",
    "next , we define the average packet decoding delay , @xmath52",
    ".    denote by @xmath53 the time slot in the coded transmission phase when original data packet @xmath6 is decoded by receiver @xmath2 , and let @xmath54 if @xmath55 .",
    "then : @xmath56    consider the sfm in fig.[fig : sfm_example ] .",
    "assume that four idnc coded packets @xmath57 , @xmath58 , @xmath59 , and @xmath60 are transmitted .",
    "assuming erasure - free transmissions , all the receivers will be satisfied after four time slots .",
    "@xmath61 are summarized in table [ tab : delay_sfm ] .",
    "the block completion time is 4 and the average packet decoding delay is @xmath62 .",
    "however , we have not discussed or determined yet if they are the best throughput and decoding delay performance of idnc .",
    ".the decoding delay of original data packets at the receivers [ cols=\"^,^,^,^,^,^,^\",options=\"header \" , ]     optimizing the throughput and decoding delay performance in idnc has been recognized as a highly non - trivial and computationally complex problem @xcite .",
    "various approaches have been taken in the literature to solve this problem , which we now briefly discuss .",
    "one main model to capture idnc constraints and determine coded packets is strict idnc or s - idnc @xcite . imposing the s - idnc constraint means that :    [ def : s_idnc_constraint ] s - idnc constraint : for every receiver @xmath2 , the coding set @xmath38 contains at most one original data packet from the wants set of @xmath2 . in other words , for every receiver",
    ", the coded packet @xmath39 in is either instantly decodable or non - innovative , but it is never non - instantly decodable .    in @xcite",
    ", it is shown that the s - idnc constraint on the coded packets can be represented using an undirected graph with @xmath9 vertices corresponding to @xmath9 wanted original data packets .",
    "more details on the graphical representation of s - idnc will be provided in section[sec : optimal_idnc ] .",
    "in contrast , in the general idnc or g - idnc proposed in @xcite the s - idnc constraint is relaxed by allowing the sender to send coded packets that are non - instantly decodable for a selected subset of receivers .",
    "if a receiver receives such a coded packet , it will discard that packet .",
    "in other words , in g - idnc the sender is not restricted to send idnc coded packets for all the receivers , but the receivers adhere to the idnc decoding principle .",
    "recently , a new type of g - idnc is proposed in @xcite , which further relaxes this constraint by allowing receivers to store non - instantly decodable packets for future decoding so that they are not wasted .",
    "consider the sfm in fig.[fig : sfm_example ] .",
    "@xmath63 is a valid coded packet for both s - idnc and g - idnc .",
    "however , @xmath41 is a valid coded packet for g - idnc but not for s - idnc , since it is non - instantly decodable for @xmath47 . in g - idnc ,",
    "when @xmath47 receives @xmath41 , it will discard it .",
    "g - idnc problem can also be modeled using an undirected graph where for each lost packet @xmath64 of each receiver @xmath65 a vertex @xmath66 is added to the graph .",
    "the key operation of g - idnc algorithms is to search for the largest _ _ maximal clique(s ) _ _ @xcite .",
    "the size of g - idnc graph is @xmath67 , while the size of s - idnc graph is @xmath9 .    in the rest of this paper ,",
    "our aim is to better understand and characterize the s - idnc problem from both theoretical and implementation viewpoints .",
    "an important note is that the characteristics of s - idnc can not be directly extended to g - idnc due to the fact that they construct and update their graphs in different ways , as will be explained in section[sec : optimal_idnc ] .",
    "characterizing g - idnc could be the objective of future research and is out of the scope of this paper . in the rest of the paper ,",
    "when there is no ambiguity , we will simply refer to s - idnc as idnc .",
    "idnc constraints of an sfm @xmath16 can be represented by an undirected graph @xmath68 with @xmath9 vertices .",
    "each vertex @xmath69 represents a wanted original data packet @xmath64 .",
    "two vertices @xmath70 and @xmath71 are connected by an edge @xmath72 if @xmath64 and @xmath73 are not jointly wanted by any receiver @xcite .",
    "this graph model , however , has only been employed in the literature to heuristically find idnc coding solutions @xcite . in this section",
    ", we will first revisit this graph model by constructing its equivalent matrix and set models .",
    "then , we will use these models to rigorously prove some theorems about the minimum block completion time , @xmath50 .",
    "the key difference between s - idnc and g - idnc will become clear after the proofs . based on these theorems",
    ", we will discuss the effect of feedback frequency on idnc throughput and propose the optimal idnc schemes with fully- or semi - online feedback .",
    "although some similar concepts and results exist in the graph theory literature @xcite , their compilation , presentation and more importantly interpretation in the idnc context is new , to the best of our knowledge .",
    "we will highlight the similarities , differences , and new results as appropriate .      in this subsection",
    ", we construct the matrix and set models of idnc and demonstrate their relationship with its graph model .",
    "the construction is based on the concepts of conflicting and non - conflicting original data packets , defined as follows .",
    "[ def : conf_packet ] two original data packets @xmath64 and @xmath73 conflict with each other if both belong to the wants set , @xmath19 , of at least one receiver such as @xmath2 .",
    "mathematically , we can denote a conflict between @xmath64 and @xmath73 by @xmath74 , where @xmath75 .",
    "@xmath64 and @xmath73 do not conflict otherwise .",
    "it is clear that to avoid non - instantly decodable coded packets , two conflicting original data packets @xmath64 and @xmath73 can not be coded together .",
    "the equivalent of such conflict in the graph model is the absence of an edge between @xmath70 and @xmath71 @xcite .",
    "on the other hand , two non - conflicting data packets @xmath64 and @xmath73 have their respective vertices @xmath70 and @xmath71 connected .",
    "the conflict states of all the original data packets can be fully described by a triangular conflict matrix @xmath76 of size @xmath77 :    a fully - square conflict matrix of size @xmath78 is a binary - valued matrix with element at row @xmath79 and column @xmath80 denoted by @xmath81 corresponding to the conflict state of packets @xmath64 and @xmath73 . in particular , @xmath82 if @xmath74 and @xmath83 otherwise .",
    "due to the symmetry of conflict between packets and noting that @xmath84 , @xmath85 , we can reduce the fully - square matrix to a triangular matrix @xmath76 of size @xmath77 .",
    "from now on , by conflict matrix , we mean the reduced triangular matrix @xmath76 .    the conflict matrix and the graph model of the sfm in fig.[fig : sfm_example ]",
    "are presented in fig.[fig : conflict_example ] and fig.[fig : graph_example ] , respectively .",
    "note that in dealing with the conflict matrix , we are not concerned with the receivers who may need a certain packet .",
    "in fact , it is not difficult to show that two or more sfms can have the same conflict matrix .",
    "unless otherwise stated , it suffices to deal with conflict matrix @xmath76 for design and analysis of idnc , instead of sfm @xmath16 .",
    "we now define the key concept of _ maximal coding set _ that is allowed for idnc transmission .",
    "a maximal coding set , @xmath86 , is a set of original data packets which simultaneously hold the following two properties : 1 ) their xor coded packet @xmath45 satisfies idnc constraint in definition  [ def : s_idnc_constraint ] , i.e. @xmath45 is either instantly decodable or non - innovative for every receiver @xmath87 ; 2 ) addition of any other original data packet from @xmath88 to @xmath86 will make the resulted @xmath45 non - instantly decodable for at least one receiver in @xmath23 .    [ exmp : all_sets ] consider a coding set @xmath89 of the sfm in fig.[fig : sfm_example ] .",
    "its corresponding coded packet is @xmath63 .",
    "@xmath45 is instantly decodable for @xmath90 and is non - innovative for @xmath46 .",
    "one can verify that adding any other original data packet from @xmath91 to @xmath86 will make @xmath45 non - instantly decodable for at least one receiver . hence , @xmath86 is a maximal coding set . through exhaustive search , one can find all remaining maximal coding sets : @xmath92 , @xmath93 , @xmath94 .",
    "the equivalent of maximal coding sets in the idnc graph model is known as maximal cliques @xcite .",
    "therefore , we use @xmath86 to denote both a maximal coding set and a maximal clique .    for reasons that become clear at the end of this subsection ,",
    "we ensure that in each idnc coded transmission , the sender will code _ all and not a subset of _ the original data packets in a maximal coding set . to satisfy the demands of all the receivers ,",
    "the sender has to transmit coded packets from an appropriately chosen collection of maximal coding sets . to achieve this",
    ", each original data packet should appear at least once in this collection .",
    "this condition can be formally represented as the _ diversity constraint _",
    ", where diversity of a packet is defined as :    the diversity of an original data packet @xmath64 within a collection of maximal coding sets is denoted by @xmath95 and is the number of maximal coding sets in which it appears .",
    "a collection of maximal coding sets satisfies the diversity constraint iff every original data packet has a diversity of at least one within this collection .    given all the maximal coding sets of a conflict matrix @xmath76 , there exists at least one collection which satisfies the diversity constraint ( in the extreme case all the maximal coding sets include all the original data packets ) .",
    "the size of the collection is the number of maximal coding sets in it .",
    "we then define the _ minimum collection _ and its size as follows :    a collection of maximal coding sets is minimum if there does not exist any other collection which satisfies the diversity constraint with a smaller size .",
    "the size of the minimum collection is called the minimum collection size .",
    "this number , as we will prove in the next subsection , is exactly the minimum number of coded transmissions , @xmath50 .",
    "we thus denote a minimum collection by @xmath96 if the @xmath50 maximal coding sets in @xmath97 are sent using @xmath50 time slots , in the absence of packet erasures , the demands of all receivers will be satisfied . here by `` sending a maximal coding set '' , we mean that the corresponding coded packet is generated and sent .",
    "a problem in the graph theory which is somewhat _ similar _ to finding a minimum collection of maximal coding sets is the minimum clique cover problem  @xcite . in this problem",
    ", a graph @xmath98 is partitioned into disjoint cliques and the partitioning solution that results into the smallest number of disjoint cliques is referred to as minimum clique cover solution of the problem .",
    "furthermore , it is worth noting that the cardinality of the minimum clique cover solution is equal to the chromatic number of the complementary graph has opposite vertex connectivity to @xmath98 .",
    "] of @xmath98 , denoted by @xmath99 @xcite . however , there is a difference between the minimum clique cover problem and our minimum collection finding problem , as cliques do not overlap in the minimum clique cover problem .",
    "that is , the cliques are not necessarily maximal and each vertex appears in only one clique .",
    "this would be equivalent to choosing a minimum collection of coding sets in our idnc model where all original data packets have a diversity equal to one .",
    "this would not change @xmath50 .",
    "however , it can have a serious adverse impact on idnc s robustness to erasures , which in turn degrades the idnc overall throughput and decoding delay performance .",
    "consequently , it is desirable to choose a minimum collection of _ maximal _ coding sets that , while satisfying @xmath50 , provides as many _ packet diversities _ as possible .",
    "the minimum collection and the importance of packet diversity is illustrated with the following example .",
    "[ exmp : min_collection ] having all the maximal coding sets of sfm in fig.[fig : example ] obtained in example [ exmp : all_sets ] , one can easily verify that the only minimum collection is @xmath100 by sending these three coding sets in @xmath97 using @xmath101 transmissions , the demands of all the receivers will be satisfied in the absence of packet erasures .",
    "all the original data packets in @xmath97 have a diversity of one , except @xmath102 which has a diversity of 2 , i.e. @xmath103 .",
    "now , let us assume that there is a packet erasure probability of @xmath104 in the transmission links between the sender and the receivers . under this scenario , with these three coded transmissions ,",
    "the probability of @xmath102 being lost at its targeted receiver @xmath49 ( due to erasures ) will be @xmath105 .",
    "this probability is much lower then that of other original data packets , which will be equal to @xmath104 .",
    "the problem of finding all the maximal cliques and the problem of minimum clique cover for an undirected graph are both np - complete @xcite .",
    "this is also true for s - idnc because the s - idnc graph does not have any special structural properties .",
    "a similar statement can be found in @xcite for g - idnc . since a minimum collection of a s - idnc conflict matrix",
    "can be reduced to a minimum clique cover solution of a s - idnc graph by reducing the diversity of all data packets to one , the problem of finding minimum collections in s - idnc is at least np - complete .",
    "its exact and simplified algorithms will be presented in section[sec : implementations ] .      in this subsection",
    ", we prove that the three numbers : 1 ) the minimum number of coded transmissions ( @xmath50 ) , 2 ) the minimum collection size of the conflict matrix , and 3 ) the chromatic number of the complementary graph ( @xmath99 ) , are identical .",
    "based on this we propose two important remarks .",
    "for a given conflict matrix @xmath76 , the equivalence between its @xmath50 and minimum collection size can be proved by induction using the following theorem :    [ theo : uidnc ] upon successful reception of a maximal coding set @xmath86 of @xmath76 by all its targeted receivers , the minimum collection size of the updated @xmath106 , denoted by @xmath107 , is at least @xmath108 .",
    "this theorem holds if the following two theorems hold :    [ theo : chromatic ] the minimum collection size of a conflict matrix @xmath76 with a graph model @xmath98 equals the chromatic number of the complementary graph of @xmath98 , @xmath99 .",
    "[ theo : chromatic_minus ] suppose @xmath86 is a maximal clique in @xmath98 and the chromatic number of @xmath109 is @xmath50 . by removing @xmath86 from @xmath98",
    "we obtain an updated graph @xmath110 .",
    "the chromatic number of @xmath111 is at least @xmath108 .",
    "more precisely , if @xmath86 belongs to a minimum collection of @xmath76 , @xmath112 , while if @xmath86 does not belong to any minimum collection of @xmath76 , @xmath113 .",
    "since the @xmath110 in theorem [ theo : chromatic_minus ] is indeed the graph model of @xmath107 in theorem [ theo : uidnc ] , we conclude that theorem [ theo : uidnc ] holds if theorem [ theo : chromatic ] and [ theo : chromatic_minus ] hold .",
    "the proofs of theorem [ theo : chromatic ] and [ theo : chromatic_minus ] are provided in [ app:1 ] and [ app:2 ] , respectively .    the above theorems apply to s - idnc , but not g - idnc .",
    "the reason is that unlike s - idnc graph , g - idnc graph is not * static*. that is , by removing a clique from the g - idnc graph , new edges may be added to the remaining vertices , which breaks theorem [ theo : chromatic_minus ] . in contrast , removing any clique from the s - idnc graph will never change the connectivity of the remaining vertices . in other words , g - idnc problem does not have its dual * static * minimum clique cover problem .",
    "[ remark : suboptimal ] heuristic algorithms are suboptimal because they can not guarantee @xmath50 .",
    "they may choose a maximal coding set @xmath86 which is , though large , not included in any minimum collection of @xmath76 .",
    "then theorem [ theo : chromatic_minus ] indicates that , even if @xmath86 is successfully received by all its targeted receivers , the chromatic number of the updated @xmath114 is still @xmath50 and thus @xmath50 more transmissions are needed .",
    "below is an example .",
    "consider the maximal coding sets in example [ exmp : all_sets ] .",
    "a suboptimal idnc algorithm might choose @xmath92 , which does not belong to the only minimum collection @xmath115 . even if this set is successfully received by all its targeted receivers , still three more transmissions are needed to be able to deliver @xmath116 and @xmath117 to the receivers . in total , there will be at least four transmissions , which is greater than @xmath101 .",
    "this example motivates the concept of optimal idnc schemes , which will be presented next .        in a fully - online idnc scheme , the sender collects feedback from all receivers in every time slot to update the sfm and the corresponding conflict matrix .",
    "a coding set is then chosen and its coded packet is generated and broadcast . to minimize the number of coded transmissions and to reduce the decoding delay , this coding set must satisfy the following three conditions :    1 .",
    "it should be a maximal coding set ; 2 .",
    "it should be chosen from a minimum collection @xmath97 of the updated conflict matrix ; and 3 .",
    "it should target the largest number of receivers among all the maximal coding sets in @xmath97 .",
    "we define such a fully - online idnc scheme as the _ optimal fully - online idnc scheme _ in terms of throughput .      according to theorem [ theo",
    ": uidnc]-[theo : chromatic_minus ] , collecting fully - online feedback during @xmath50 transmissions can not reduce the total number of coded transmissions to below @xmath50 , even in the best case scenario of erasure - free packet reception . hence , as a variation of existing idnc schemes in the literature , we propose to reduce feedback frequency to _ semi - online _ , where the sfm @xmath16 is updated in rounds .",
    "for example , feedback is collected after @xmath50 coded packets from a selected minimum collection @xmath97 have been transmitted and so on .",
    "we define this scheme as the optimal idnc scheme in terms of throughput when feedback frequency is semi - online , or simply _ the optimal semi - online idnc scheme_. we refer to the minimum collection @xmath97 as the _ optimal semi - online idnc solution_. maximal coding sets in @xmath97 are properly ordered so that those targeting more receivers are assigned with smaller subscripts and sent first .",
    "fig.[fig : full_semi_flow ] illustrates the process of the proposed optimal idnc schemes .",
    "we then define the minimum average packet decoding delay of the proposed idnc schemes :    we denote by @xmath118 the minimum average packet decoding delay of the proposed fully- and semi - online idnc scheme .",
    "it is achieved if the maximal coding sets in the optimal semi - online idnc solution @xmath97 are broadcast in the absence of packet erasures , and is calculated as : @xmath119 where @xmath120 is the index of the first maximal coding set in @xmath97 which contains @xmath6 .    compared with , the decoding delays of an original data packet @xmath6 at its targeted receivers , i.e. , @xmath61 , are unified to @xmath120 here because all these receivers can decode @xmath6 in the same time slot if there is no packet erasure .",
    "it is noticed that by `` minimum '' we mean the smallest possible average packet decoding delay of the proposed ( throughput ) optimal idnc schemes in the absence of packet erasures .",
    "@xmath118 is not necessarily the optimal average packet decoding delay that idnc can offer , finding which is still an open problem . indeed , as we shall see in section[sec : simulations ] , a suboptimal idnc scheme in terms of throughput may achieve a better decoding delay .",
    "it is also noticed that , since the initial sfm @xmath16 is a @xmath121 all - one matrix , the systematic transmission phase is a special semi - online idnc round , which requires the @xmath4 original data packets to be sent uncoded using @xmath122 transmissions .",
    "in addition to making the throughput and delay analysis of idnc tractable , a lower feedback frequency can be advantageous in practical implementations of idnc where the use of reverse link is costly and involves transmission of some control overheads .",
    "another practical attraction is that it also avoids solving the idnc coding problem in every time slot .",
    "however , this comes at the potential cost of degradation in the overall system throughput in semi - online idnc , as we explain next .",
    "imagine an idnc scheme in the presence of erasures .",
    "in the fully - online feedback case , @xmath16 is updated before every coded transmission , so the coded packet is chosen from the minimum collection of the actual @xmath16 at the receivers . however , in the semi - online feedback case , the sender does not update @xmath16 until the round for @xmath123 is complete . here",
    "@xmath124 belong to the minimum collection of the @xmath16 last revealed to the sender , but not necessarily belong to the actual @xmath16 at the receivers .",
    "if this is the case , these coded packets can become throughput inefficient .",
    "intuitively , we expect the gap between semi- and fully - online schemes to be small when packet erasure probability is low ( in the extreme case where the packet erasure probability is zero , the two schemes perform the same ) . in any case",
    ", the throughput and delay analysis of semi - online idnc scheme serves as a worst - case scenario for an optimal fully - online idnc with packet erasures .",
    "the findings in the last section are important because they enable theoretical analysis on the achievable throughput and decoding delay of idnc . for throughput , @xmath50 is equal to the chromatic number of the complementary idnc graph . for decoding delay , @xmath118 is the average decoding delay of the proposed optimal semi - online idnc solution .",
    "we note , however , that there is no explicit formula to calculate the optimal @xmath50 .",
    "it can only be found via algorithmic implementations that can be computationally complex , as will be discussed in section [ sec : implementations ] .",
    "therefore , it is desirable to have some bounds on @xmath50 that can be more easily calculated or algorithmically found .",
    "this is the aim of this section .",
    "it is particularly useful and can find its application in , e.g. , adaptive network coding systems which choose among idnc and other network coding techniques to meet the throughput and decoding delay requirements . since the calculation of @xmath118 depends on @xmath50 as indicated by , we will first derive bounds on @xmath50 in this section and then on @xmath118 in the next section .",
    "we start with the review of existing results in graph theory and then propose useful bounds in idnc context .      given a set of system parameters @xmath125 }",
    ", the complementary idnc graph @xmath126 after the systematic transmission phase can be modeled as the classic erdos - renyi random graph @xcite . in this model , there are @xmath4 vertices and any two of them are connected by an undirected edge with i.i.d .",
    "probability of @xmath127 . in the context of idnc",
    ", @xmath127 is the probability that two original data packets conflict with each other and can be calculated as : @xmath128    the chromatic number of this random graph model has the following property @xcite :    almost every random graph with @xmath4 vertices and vertex connection probability of @xmath127 has chromatic number of : @xmath129 where @xmath130 approaches zero with increasing @xmath4 .    since @xmath131 , this lemma",
    "could be used to calculate the mean of @xmath50 under any set of @xmath132 .",
    "however , it is only asymptotically accurate for large @xmath4 . since in idnc systems",
    "@xmath4 may not be very large , does not provide sufficient accuracy .    in graph theory",
    ", @xmath99 is bounded as : @xmath133 where @xmath134 is called the clique number of @xmath126 and is the size of the maximum ( the largest maximal ) clique in @xmath126 , and @xmath135 is the largest vertex degree of @xmath126 , i.e. , the largest number of edges incident to any vertex in @xmath126 . as we will show later ,",
    "while @xmath134 is a tight lower bound , the upper bound @xmath136 is very loose and is not useful for idnc framework . in the next two subsections",
    ", we will derive useful loose / tight lower / upper bounds on @xmath50 , respectively .",
    "the loose bounds are easy to calculate and they reveal the limits of idnc , while the tight bounds are more computationally involved , but nevertheless are shown numerically to be accurate estimates of @xmath50 .      in this subsection , we find the smallest and largest possible @xmath50 of all the conflicts matrices which have a size of @xmath9 and @xmath137 zero entries , with their set denoted by @xmath138 .",
    "the results are our loose lower and upper bounds and are denoted by @xmath139 and @xmath140 , respectively .",
    "they reveal the throughput limits of idnc for any given @xmath9 and @xmath137 and are important references for practical / heuristic idnc coding algorithm design : any algorithm offering @xmath50 above the upper bound or below the lower bound is throughput inefficient or non - instantly decodable , respectively .",
    "[ eq : ct_min_demo ] @xmath141      the general intuition here is _ trying our best to waste the coding opportunities brought by the @xmath137 zeros_. we first note that for any given original data packet , there are @xmath142 entries in @xmath76 about the conflict of that packet with all other packets .",
    "when @xmath143 , there is no coding opportunities , so @xmath144 . when @xmath145 $ ] , we can assign all zeros to the entries about the same original data packet , say @xmath146 . but @xmath50 remains @xmath142 because @xmath147 have to be transmitted separately .",
    "after @xmath142 zeros have been exhausted , there are @xmath148 entries in @xmath76 about every packet other than @xmath146 .",
    "thus when @xmath149 $ ] , we can assign these extra @xmath148 zeros to the entries about the same original data packet , say @xmath102 , and @xmath50 remains @xmath148 because @xmath150 have to be transmitted separately .",
    "this iterative process indicates that @xmath140 decreases in a staircase way with @xmath137 .",
    "the relationship can be written as : @xmath151\\\\                  k-2 , & m_0\\in[k,2k-3]\\\\                  \\vdots&\\vdots\\\\                  1 ,    & m_0=k(k-1)/2 \\end{cases}\\ ] ] one can easily verify that the proposed loose upper bound is much tighter than @xmath136 because the largest possible @xmath136 is always @xmath9 when @xmath152 $ ] .",
    "the intuition here is _ making the best of the coding opportunities brought by the @xmath137 zeros_. in other words , we should _ use as few zeros as possible to reduce @xmath50 by one_. when @xmath143 , no original data packets can be coded together . thus @xmath153 and @xmath154 .",
    "we then reduce @xmath50 iteratively . in each iteration",
    ", @xmath50 can be reduced by 1 , i.e. , the size of @xmath97 can be reduced by 1 , if we can merge two maximal coding sets in @xmath97 together . since any two packets from different maximal coding sets conflict ,",
    "to merge two maximal coding sets of size , say @xmath155 and @xmath1 , together , we need @xmath156 zeros . in order to use as few zeros as possible , we always pick two smallest sets which minimize @xmath156 . hence , in each iteration , it is impossible to reduce @xmath50 by 1 until @xmath156 new zeros are added to @xmath76 .",
    "this iterative process provides the lower - bound @xmath139 .",
    "similar to the upper - bound , the lower bound also decreases in a staircase way with @xmath137 .",
    "below is an example with @xmath157 :    [ exmp : uidnc_min ]    when we have an all - one conflict matrix ( @xmath143 ) , no packets can be coded together , and thus @xmath158 , as in ( [ eq : ct_min_0 ] ) .",
    "then in the first iteration , the size of @xmath97 can be reduced by 1 by merging @xmath159 and @xmath160 together , which requires one zero , as in ( [ eq : ct_min_1 ] ) . in the second iteration",
    ", the size of @xmath97 can be reduced by one by merging @xmath161 and @xmath162 together , which requires 1 zero , as in ( [ eq : ct_min_2 ] ) . in the third iteration ,",
    "@xmath163 zeros are needed to merge the two smallest maximal coding sets @xmath164 and @xmath165 together because we have to resolve the conflicts between @xmath146 and @xmath43 and between @xmath102 and @xmath43 . in the last iteration",
    ", @xmath166 zeros are needed to merge @xmath167 and @xmath168 together .",
    "after that , all the 10 entries in @xmath76 become zeros and @xmath50 becomes 1 .",
    "@xmath139 in this example can thus be expressed as : @xmath169\\\\ 2,&m_0\\in[4,9]\\\\ 1,&m_0=10 \\end{cases}\\ ] ]    this relationship can be approximated by a single formula which is derived by geller in @xcite using a different approach : @xmath170 where @xmath171 denotes the smallest integer greater than @xmath155 .",
    "one can easily verify that the proposed @xmath139 is slightly tighter than the bound in .      because @xmath99 is well lower",
    "bounded by @xmath134 and @xmath131 , our tight lower bound on @xmath50 is defined as @xmath172 .",
    "it can be identified by finding the maximum clique in @xmath126 .",
    "we then find a tight upper bound , denoted by @xmath173 .",
    "our tight upper bound on @xmath50 is derived using an iterative operation on a graph @xmath98 , denoted by @xmath174 .",
    "it iteratively outputs the maximum clique in @xmath98 and then deletes it from @xmath98 until @xmath98 becomes empty .",
    "mathematically : @xmath175    the resulted cliques actually form a partition of @xmath98 . hence , if the initial @xmath98 is an instance of idnc graph , the resulted cliques form a semi - online idnc solution , denoted by @xmath176 with cardinality @xmath173 .",
    "the minimum block completion time ( @xmath50 ) of this idnc instance is thus upper bounded by @xmath173 .",
    "the derivations of both @xmath177 and @xmath173 rely on finding the maximum clique in an idnc graph , which is np - complete @xcite . in section[sec : implementations ] , we will propose a heuristic clique - finding algorithm , which will in turn enable finding some heuristic bounds on @xmath50 .",
    "these heuristic bounds are still provable , but they are suboptimal because the heuristically found maximal cliques are not necessarily maximum .          based on the bounds we have derived for any instance of conflict matrix , we can calculate the average bounds over all the conflict matrices in @xmath138 so that the average bounds can be explicitly expressed as a function of @xmath178 .",
    "since the loose bounds are already functions of @xmath178 , the focus is on the average tight bounds , i.e. , @xmath179 and @xmath180 . they can be obtained by listing all the conflict matrices in @xmath138 , calculating their bounds , and then making the average .",
    "however , this is usually unrealistic , since there are @xmath181 possible conflict matrices , which are prohibitively large even when @xmath9 and @xmath137 are not so large .",
    "hence , averaging over `` all '' conflict matrices is replaced by monte carlo averaging , where instances of conflict matrix are generated by assigning random permutations of @xmath137 zeros and @xmath182 ones to the conflict matrix .",
    "we present the average bounds under @xmath183 original data packets and @xmath184 $ ] in fig.[fig : u_bounds_15 ] .",
    "the optimal @xmath50 , obtained using the method in section[sec : optimal_algorithms ] , is also averaged and plotted as a reference .",
    "it is denoted by @xmath185 .",
    "it decreases gradually with the increasing @xmath137 , and so do the tight bounds @xmath179 and @xmath180 .",
    "the gap between the tight bounds and the optimal one is marginal , with a value of less than 0.5 transmission on average for all @xmath137 .",
    "they are much tighter than the loose ones , which decrease in a stair - case way with increasing @xmath137 .",
    "according to its definition in , the minimum average packet decoding delay @xmath118 of an sfm @xmath16 is decided by the optimal semi - online idnc solution @xmath97 of the corresponding conflict matrix @xmath76 and the number of targeted receivers of all the original data packets @xmath186 .",
    "deriving lower / upper bounds on @xmath118 of an sfm is thus equivalent to finding two instances of @xmath97 which offer the best / worst possible decoding delays , respectively .",
    "we first discuss what instances will yield such decoding delays .",
    "an instance of @xmath97 is denoted by @xmath187 where @xmath188 is its cardinality .",
    "its average packet decoding delay is denoted by @xmath189 and can be calculated using , where @xmath190 is now the index of the first maximal coding set in @xmath191 that contains @xmath6 . therefore , for the purpose of calculation , @xmath6 can be removed from all the subsequent coding sets . after applying such removal to all the original data packets ,",
    "the intersection between any two coding sets in @xmath191 becomes empty .",
    "these coding sets are not necessarily maximal and we denote them by @xmath192 to distinguish them from maximal ones . below is an example .",
    "consider an instance @xmath193 , @xmath194 .",
    "after packet removal , the instance becomes : @xmath195 .",
    "let us denote by @xmath196 the number of targeted receivers of coding set @xmath197 . without loss of generality",
    "we assume that : @xmath198 it holds that @xmath199 .",
    "then , as a variation of ( [ eq : didnc_def ] ) , the average packet decoding delay under @xmath191 can also be calculated as : @xmath200    the above two equations indicate the condition that the best / worst possible instances of @xmath97 should satisfy :    1 .   because @xmath201 for all @xmath34 , @xmath189 is minimized if @xmath191 has @xmath202 and @xmath203 for @xmath204 $ ] .",
    "since it is rare to have coding sets wanted by only one receiver , we relax this condition as @xmath205 and refer to such @xmath191 as the best ; 2 .   @xmath189 is maximized with a value of @xmath206 if @xmath191 has @xmath207 and thus is the worst .",
    "we now propose different instances of @xmath97 and obtain lower / upper bounds on @xmath118 with different tightness .",
    "for any given sfm , without loss of generality we assume that its conflict matrix @xmath76 belongs to @xmath138 . by employing the loose bounds on @xmath50 for @xmath138",
    ", we can derive loose bounds on @xmath118 .",
    "the smallest possible cardinality of the instance @xmath187 is equal to the loose lower bound on @xmath50 , that is , @xmath208 .",
    "thus , @xmath189 is minimized if @xmath191 has : @xmath209 \\end{cases}\\ ] ]    by substituting the above @xmath210 into ( [ eq : d_definition_new ] ) , a loose lower bound on @xmath118 is obtained .",
    "the largest possible cardinality of the instance @xmath187 is equal to the loose upper bound on @xmath50 , that is , @xmath211 .",
    "thus , @xmath189 is maximized with a value of @xmath212 if @xmath191 has uniform @xmath210 , as discussed in c2 after .        in the derivation of the tight lower bound on @xmath50",
    ", we find a size-@xmath177 clique in the complementary idnc graph @xmath126 .",
    "denote the original data packets included in this clique by @xmath213 , and without loss of generality assume that @xmath214 .",
    "these original data packets must be sent separately because they are not connected in @xmath98 , i.e. , they conflict . in this case",
    ", the smallest decoding delay takes place when all the remaining @xmath215 original data packets can be coded together with @xmath146 in the first coding set . the sequence @xmath210 is : @xmath216 \\end{cases}\\ ] ]    by substituting the above @xmath210 into ( [ eq : d_definition_new ] ) , a tight lower bound on the minimum packet decoding delay is obtained and is denoted by @xmath217 .",
    "we use the idnc solution @xmath176 found using the operation @xmath174 in as our instance and thus its average decoding delay is our tight upper bound @xmath218 .          in this subsection",
    ", we obtain the average bounds on @xmath118 using a similar method as for the average bounds on @xmath50 . for a given set of @xmath178 , conflict matrices",
    "are randomly generated and the number of targeted receivers of the original data packets are also randomly generated .",
    "their decoding delay bounds , as well as @xmath118 under the optimal semi - online solution are calculated and averaged .",
    "simulation results for @xmath183 and @xmath184 $ ] are plotted in fig.[fig : d_bounds_15 ] .",
    "the profiles of the average decoding delay bounds are similar to the average throughput bounds .",
    "the average loose bounds decrease with increasing @xmath137 in a staircase way , while the average tight bounds decrease gradually as @xmath219 .",
    "the main difference is that @xmath219 is much closer to @xmath218 than in the throughput case , and for @xmath220 , the gap becomes negligible .",
    "the reason is that the idnc solution @xmath221 can be viewed as a greedy idnc solution in terms of decoding delay .",
    "it transmits the largest maximal coding set first , which is likely to target the most receivers .",
    "this result , together with the small gap between @xmath180 and @xmath185 , indicate that @xmath174 could be modified into a good heuristic idnc coding algorithm , which will be discussed in the next section .",
    "in this section , we present the algorithmic implementations of idnc .",
    "we first propose the optimal semi - online and fully - online idnc coding algorithms and then their heuristic alternatives .",
    "we also employ a heuristic clique - finding algorithm to obtain heuristic tight bounds on the throughput and decoding delay performance of idnc .",
    "our optimal semi - online idnc coding algorithm finds the minimum collections of the conflict matrix in two steps :    1 .",
    "_ find all the maximal coding sets ( cliques ) : _ this problem is np - complete but has an efficient recursive algorithm called bron - kerbosch algorithm @xcite .",
    "the group of all the maximal coding sets is denoted by @xmath222 .",
    "2 .   _ find minimum collections from @xmath222 : _ we propose an iterative algorithm in algorithm [ algorithm : branch ] to achieve it .",
    "the intuition behind this algorithm is that , if an original data packet belongs to @xmath223 maximal coding sets in @xmath222 , one of these @xmath223 maximal coding sets has to be transmitted . in the extreme case of @xmath224",
    ", this maximal coding set must be sent .",
    "below is an example of algorithm [ algorithm : branch ] .",
    "consider the graph model in fig.[fig : min_collection ] .",
    "in step-1 , we find all the maximal cliques : @xmath225 , @xmath226 , @xmath168 , @xmath227 , @xmath228 . then in step-2",
    "since @xmath97 is empty , none of the original data packets are included . among them",
    ", @xmath146 has a diversity of only one under @xmath229 .",
    "thus in the first iteration , the updated solution is @xmath97@xmath230 ; 2 .",
    "the remaining original data packets are @xmath231 . among them",
    "@xmath102 has a diversity of one under @xmath229 .",
    "thus in the second iteration , the updated solution is @xmath232,@xmath233 ; 3 .",
    "the remaining original data packets are @xmath48 and @xmath117 .",
    "they both have a diversity of two under @xmath229 .",
    "we pick @xmath48 and then branch : @xmath234,@xmath226,@xmath235 and @xmath236,@xmath226,@xmath237 .",
    "since @xmath238 satisfies the diversity constraint , the algorithm ceases and returns @xmath238 as the minimum collection .",
    "if the above two - step coding algorithm outputs several minimum collections , different criterion can be used for selection , such as the smallest average packet decoding delay and the highest average packet diversity , etc . in our simulations",
    ", we select the one having larger diversities for data packets wanted by more receivers , i.e. , the collection @xmath97 that maximizes @xmath239 will be chosen , where @xmath240 is the diversity of @xmath6 within @xmath97 and @xmath25 is the number of targeted receivers of @xmath6 .",
    "if fully - online feedback is allowed and computational cost at the sender is not an issue , the optimal fully - online idnc scheme can be applied , where in every time slot , the sender calculates the optimal semi - online solution as above , but sends only the first maximal coding set and then collects feedback .    * input : * the group of all maximal coding sets , @xmath222 ; * initialization : * a set of collections @xmath241 which only contains an empty collection , an iteration counter @xmath242 ; denote this collection by @xmath243 .",
    "denote the original data packets included in @xmath97 by @xmath244 and all the remaining original data packets by @xmath245 .",
    "also denote the maximal coding sets excluded in @xmath97 by @xmath246 ; pick an original data packet , say @xmath247 , in @xmath248 which has the smallest diversity @xmath223 within @xmath229 .",
    "denote the @xmath223 coding sets which contain @xmath247 by @xmath249 ; branch @xmath97 into @xmath223 new collections , @xmath250 .",
    "then , add @xmath249 to these collections , respectively .",
    "the size of the new collections are @xmath34 ; @xmath251 ; output the collections in @xmath241 that satisfy the diversity constraint .",
    "algorithm [ algorithm : branch ] is optimal because it finds all the possible minimum collections .",
    "however , it is also memory demanding because the number of candidature solutions usually grows exponentially after the branching in every iteration .",
    "thus in this subsection , we propose a simple greedy alternative to it .",
    "we first choose the largest maximal coding set in @xmath222 .",
    "then for the remaining original data packets that have not been covered , we look for a maximal coding set which comprises most of them .",
    "this iterative algorithm only produces one collection , which may be suboptimal because its cardinality may be greater than @xmath50 .",
    "the optimal clique finding in step-1 , together with this heuristic algorithm in step-2 , is referred to as the hybrid semi - online idnc coding algorithm .",
    "if fully - online idnc is applied , after finding @xmath222 in step-1 , we can greedily choose the maximal coding set in @xmath222 that targets the maximum number of receivers .",
    "this algorithm is referred to as the hybrid fully - online idnc coding algorithm .    to reduce the computational load due to step-1",
    ", we resort to a fully - heuristic clique - finding algorithm next .      a simple algorithm that heuristically finds the maximum ( the largest maximal ) clique in a graph is provided in algorithm [ algorithm : clique ] .",
    "the intuition behind this algorithm is that , a vertex is very likely to be in the maximum clique if this vertex has the largest number of edges incident to it .",
    "this algorithm has been employed in @xcite for fully - online idnc .",
    "so we also refer to it as the heuristic fully - online idnc coding algorithm .",
    "however , it has not been applied to semi - online idnc and its computational complexity has not been identified yet .    *",
    "input * : graph @xmath68 ; * initialization * : an empty vertex set @xmath252 ; weight every vertex in @xmath98 with the number of edges incident to it ; find the vertex @xmath253 which has the largest weight ; add @xmath253 to @xmath252 ; update @xmath98 by deleting the vertices not connected to @xmath253 , as well as deleting the edges incident to these vertices ( _ since these vertices can not be part of the target clique , they can be ignored _ ) ; update @xmath98 by deleting @xmath253 and the edges incident to @xmath253 ( _ since @xmath253 is already in @xmath252 , there is no need to consider it anymore _ ) ; vertices in @xmath252 are all connected and thus form a clique .",
    "the computational complexity of this algorithm is polynomial in the number of original data packets @xmath9 .",
    "the highest computational complexity occurs when the input graph is complete , i.e. , all the vertices are connected to each other . under this scenario ,",
    "only one vertex could be removed in each iteration ( in step 8) and thus , the size of the graph in the @xmath79-th iteration , @xmath254 $ ] , will be @xmath255 . as a result of this ,",
    "the highest computational complexity is @xmath256 . in practice",
    ", the graph size will shrink much faster after each iteration , and the number of iterations is usually smaller than @xmath9 .",
    "hence , the computational complexity of this algorithm is loosely upper - bounded by @xmath257 .",
    "in other words , the computational complexity of this algorithm is @xmath258 .      here , we apply algorithm [ algorithm : clique ] to heuristically find the proposed tight bounds on the throughput , and then the corresponding tight bounds on the decoding delay .",
    "the results are shown in figs .",
    "[ fig : u_bounds_15 ] and [ fig : d_bounds_15 ] , respectively .",
    "it is observed that the performance degradation due to the heuristic algorithm is marginal for both throughput and decoding delay .",
    "therefore , the heuristic tight bounds could serve as reliable and efficient estimates of the throughput and decoding delay .",
    "the operation @xmath174 in can be implemented by using algorithm [ algorithm : clique ] .",
    "the outcome is a heuristic semi - online idnc solution @xmath221 , which offers good throughput and decoding delay performance in the erasure - free scenario .",
    "however , since its cliques are disjoint , all the original data packets have a diversity of only one and thus are vulnerable to packet erasures in real systems .    to overcome this drawback",
    ", we propose a heuristic semi - online idnc coding algorithm in algorithm [ algorithm : encoding ] , which is an extension of @xmath174 .",
    "the key idea here is that , in the @xmath79-th iteration , after finding clique @xmath259 , we try to enlarge this clique by adding previously covered vertices to it whenever possible , i.e. , the vertices in @xmath260 . by doing so",
    ", the diversity of the newly added vertices ( packets ) is increased by one .",
    "below is an example :    consider the graph @xmath98 in fig.[fig : graph_example ] . in the first two iterations ,",
    "the algorithm will choose @xmath261 and @xmath262 , respectively , without any adding .",
    "in the third iteration , we have @xmath263 and the algorithm can only choose @xmath264 .",
    "among all the original data packets in @xmath265 , @xmath102 can be added to @xmath266 .",
    "thus @xmath267 .",
    "the process is then completed .",
    "maximal coding sets in the solution + * * *    & optimal & run bron - kerbosch @xcite in step-1 .",
    "run algorithm 1 in step-2 .",
    "+ & hybrid & run bron - kerbosch [ 28 ] in step-1 .",
    "run greedy algorithm in step-2 according to section[sec : hybrid_algorithms ] .",
    "+ & heuristic & run algorithm 3 .",
    "+ & optimal , hybrid & the same as the corresponding semi - online one , but only choose the maximal coding set that targets the most receivers .",
    "+ & heuristic & run algorithm 2 .",
    "+    * input * : a graph @xmath68 ; * initialization * : generate an empty vertex set @xmath268 , a working graph @xmath269 , and a counter @xmath270 ; find the maximum clique in @xmath271 using algorithm [ algorithm : clique ] .",
    "denote it by @xmath259 ; find the vertices in @xmath268 which are connected to @xmath259 .",
    "denote their set by @xmath272 ( _ they are the candidate vertices that could be added to @xmath259_. ) ; generate a subgraph of @xmath98 whose vertex set is @xmath272 .",
    "denoted this subgraph by @xmath273 ; find the maximum clique in @xmath274 using algorithm 1 , denoted it by @xmath275 ( _ all vertices in @xmath275 are connected to each other and thus can all be added to @xmath259 . _ ) ; update @xmath268 by adding vertices in @xmath259 into it ; update @xmath271 by removing @xmath259 from it ; update @xmath259 as @xmath276 ( _ the new clique is at least as large as the old one and thus , provides higher packet diversity _ ) ; @xmath277 ;",
    "in this section , we numerically evaluate the throughput and decoding delay performance of the proposed six idnc schemes with different combinations of feedback frequencies and algorithms , as shown in table [ tab : schemes_algorithms ] . instead of @xmath50 and @xmath118 , which indicate the best possible performance of idnc in terms of the throughput and packet decoding delay",
    ", we measure the total number of coded transmissions and the average packet decoding delay with the presence of packet erasures .",
    "the total number of data packets is @xmath278 , the total number of receivers is @xmath279 $ ] .",
    "two simulations are carried out . in the first simulation a small packet erasure probability of @xmath280 is applied , while in the second simulation @xmath104 .",
    "the throughput and decoding delay performance of rlnc are also plotted as references .",
    "the simulation results are shown in figs .",
    "[ fig : performance_small_pe ] and [ fig : performance_medium_pe ] . from these figures ,",
    "we obtain some useful observations that could serve as simple guidelines for the implementation of idnc :    1 .",
    "the gaps between the semi - online and the corresponding fully - online schemes become larger when @xmath8 increases from 0.05 to 0.2 .",
    "this result matches our expectation described in section[sec : optimal_schemes ] ; 2 .",
    "the gaps between the hybrid and the corresponding optimal schemes are marginal regardless of @xmath8 and @xmath0 .",
    "the hybrid ones even exceed their ( throughput ) optimal counterparts in decoding delay performance when @xmath8 is small .",
    "see also remarks after .",
    "hence , hybrid schemes could be preferable in practice , since they provide a good tradeoff between performance and computational load .",
    "this result also motivates the problem of finding decoding delay optimal idnc solutions in future research .",
    "3 .   the gaps between the heuristic semi - online and heuristic fully - online schemes are relatively small for all @xmath8 and @xmath0 , especially in terms of decoding delay .",
    "thus when the sender can only afford low computational load and it is primarily concerned with the decoding delay , applying semi - online feedback frequency is sufficient ;    a cross comparison between the optimal fully - online idnc and rlnc shows that , in terms of throughput , the performance of idnc is close to rlnc for all values of @xmath0 when @xmath280 , but the gap increases with @xmath0 when @xmath104 . in terms of decoding delay , the performance of idnc is always much better than rlnc when @xmath280 .",
    "such superiority becomes marginal with the increase of @xmath0 and @xmath8 .",
    "we conclude that , first , the performance of idnc is more vulnerable to the increase in the number of receivers and bad channel quality than rlnc .",
    "second , there is no clear winner between them when we consider both throughput and delay .",
    "in this paper , we presented a systematic study of instantly decodable network coding ( idnc ) in the single - hop wireless broadcast scenario .",
    "we obtained the optimal solution of idnc in terms of the completion time ( as a measure of throughput ) in the fully - online system where receivers feedback about the status of their received and lost packets are available at the sender after every single idnc transmission .",
    "we also studied a semi - online idnc scheme where receivers feedback is available after a number of idnc transmissions , and correspondingly proposed the optimal semi - online idnc solution .",
    "however , since finding these optimal solutions are computationally complex , efficient heuristic algorithms were also proposed . moreover , our studies on the optimal idnc solution resulted in finding useful loose and tight upper- and lower - bounds on the best throughput and decoding delay performance of idnc . while the loose bounds reveal the performance limits of idnc , the tight bounds provide efficient estimates of the performance of idnc .",
    "extensive simulations were carried out to evaluate the throughput and decoding delay performance of the proposed schemes .",
    "the simulation results can guide simple implementations of idnc .",
    "there are also many interesting directions that this work could be extended to .",
    "for example , the optimal decoding delay performance of idnc is yet widely unaddressed in the literature mainly due to 1 ) the lack of a commonly accepted definition of decoding delay ; and 2 ) the complicated interplay of decoding delay and throughput .",
    "another interesting direction is to extend this work to the general idnc scheme , or allow receivers to store non - instantly decodable packets .",
    "we prove that if there is a collection @xmath281 satisfying the diversity constraint , there is also a @xmath188-coloring solution of  @xmath126 and _ vice versa_. an eligible @xmath188-coloring solution is denoted by @xmath282 and has the following three properties : 1 ) the vertices in the same set @xmath283 share the same color ; 2 ) any two of vertices in the same @xmath283 are not connected ; 3 ) the intersection between any two sets @xmath283 and @xmath284 is empty .",
    "if @xmath285 satisfies the diversity constraint , we can always construct a new group of vertex sets as follows , which also satisfy the diversity constraint : set @xmath286 , then sequentially @xmath287 , @xmath288 , @xmath289 . following this construction process ,",
    "it is clear that the intersection between any two sets @xmath283 and @xmath284 is empty , thus property 3 ) is satisfied . since @xmath290",
    ", every vertex in the same @xmath283 is connected to each other under @xmath98 and therefore , they are all disconnected under @xmath126 and property 2 ) is satisfied .",
    "hence , if we assign @xmath188 colors to @xmath291 , they form a @xmath188-coloring solution of @xmath126 . on the other hand ,",
    "a @xmath188-coloring solution of @xmath126 is also a valid idnc collection in which all the data packets have a diversity of one .",
    "hence , the minimum number of colors , @xmath99 , is also the minimum collection size of the corresponding conflict matrix .",
    "suppose @xmath86 is a maximal clique of @xmath98 and @xmath292 .",
    "assuming the chromatic number of @xmath293 is @xmath294 , there exists at least one @xmath295-coloring solution of @xmath111 , denoted by @xmath296 .",
    "if this is the case , @xmath297 is a eligible @xmath298-coloring of @xmath126 and @xmath299 , contradicting the assumption that @xmath292 .",
    "thus @xmath300 is at least @xmath301",
    ".    the chromatic number of @xmath111 will still be @xmath188 when the removed @xmath86 does not belong to any minimum collection of @xmath76 .",
    "if @xmath302 , there exists at least one @xmath303-coloring solution of @xmath111 , denoted by @xmath304 . then @xmath305 is a valid minimum collection , contradicting that @xmath86 does not belong to any minimum collection of @xmath76 .",
    "thus @xmath306 in this case .",
    "p.  sadeghi , r.  shams , and d.  traskov , `` an optimal adaptive network coding scheme for minimizing decoding delay in broadcast erasure channels , '' _",
    "eurasip j. on wireless commun . and netw .",
    "_ , pp . 114 , jan .",
    "2010 .              s.  sorour and s.  valaee , `` completion delay minimization for instantly decodable network coding with limited feedback , '' in _ communications ( icc ) , 2011 ieee international conference on _ , 2011 , pp . 15 .",
    " , `` completion delay reduction in lossy feedback scenarios for instantly decodable network coding , '' in _ personal indoor and mobile radio communications ( pimrc ) , 2011 ieee 22nd international symposium on _ , 2011 , pp",
    ". 20252029 .",
    "x.  li , c .- c .",
    "wang , and x.  lin , `` on the capacity of immediately - decodable coding schemes for wireless stored - video broadcast with hard deadline constraints , '' _ selected areas in communications , ieee journal on _ , vol .",
    "29 , no .  5 , pp . 10941105 , 2011 .",
    "m.  s. karim and p.  sadeghi , `` decoding delay reduction in broadcast erasure channels with memory for network coding , '' in _ personal indoor and mobile radio communications ( pimrc ) , 2012 ieee 23rd international symposium on _ , 2012 , pp .",
    "6065 .",
    "s.  el  rouayheb , a.  sprintson , and c.  georghiades , `` on the index coding problem and its relation to network coding and matroid theory , '' _ information theory , ieee transactions on _ , vol .",
    "56 , no .  7 , pp . 31873195 , 2010 .",
    "n.  aboutorab , s.  sorour , and p.  sadeghi , `` o2-gidnc : beyond instantly decodable network coding , '' in _ network coding ( netcod ) , 2013 international symposium on_.1em plus 0.5em minus 0.4emieee , 2013 , pp . 16 ."
  ],
  "abstract_text": [
    "<S> in this paper , a comprehensive study of packet - based instantly decodable network coding ( idnc ) for single - hop wireless broadcast is presented . the optimal idnc solution in terms of throughput </S>",
    "<S> is proposed and its packet decoding delay performance is investigated . </S>",
    "<S> lower and upper bounds on the achievable throughput and decoding delay performance of idnc are derived and assessed through extensive simulations . furthermore , the impact of receivers feedback frequency on the performance of idnc is studied and optimal idnc solutions are proposed for scenarios where receivers feedback is only available after an idnc round , composed of several coded transmissions . however , since finding these idnc optimal solutions is computationally complex , we further propose simple yet efficient heuristic idnc algorithms . the impact of system settings and parameters such as channel erasure probability , feedback frequency , and the number of receivers is also investigated and simple guidelines for practical implementations of idnc are proposed . </S>"
  ]
}