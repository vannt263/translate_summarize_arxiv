{
  "article_text": [
    "proof - carrying code ( pcc ) @xcite is a general technique for mobile code safety which proposes to associate safety information in the form of a _ certificate _ to programs .",
    "the certificate ( or proof ) is created at compile time by the _ certifier _ on the code supplier side , and it is packaged along with the code .",
    "the consumer who receives or downloads the ( untrusted ) code+certificate package can then run a _ checker _ which by an efficient inspection of the code and the certificate can verify the validity of the certificate and thus compliance with the safety policy .",
    "the key benefit of this `` certificate - based '' approach to mobile code safety is that the consumer s task is reduced from the level of proving to the level of checking , a task which should be much simpler , efficient , and automatic than generating the original certificate .",
    "abstraction - carrying code ( acc ) @xcite has been recently proposed as an enabling technology for pcc in which an _ abstraction _",
    "( i.e. , an abstract model of the program ) plays the role of certificate .",
    "an important feature of acc is that not only the checking , but also the generation of the abstraction ( or fixpoint ) is _ automatically _ carried out by a fixed - point analyzer .",
    "lightweight bytecode verification @xcite is another pcc method which relies on analysis techniques ( namely on type analysis in the style of those used for java bytecode verification @xcite ) to generate and check certificates in the context of the java card language . in this paper",
    ", we will consider analyzers which construct a program _ analysis graph _ which is interpreted as an abstraction of the ( possibly infinite ) set of states explored by the concrete execution .",
    "essentially , the certification / analysis carried out by the supplier is an iterative process which repeatedly traverses the analysis graph until a fixpoint is reached . a key idea in acc",
    "is that , since the certificate is a fixpoint , a single pass over the analysis graph is sufficient to validate the certificate in the consumer side .",
    "existing models for pcc ( acc among them ) are based on checkers which receive a `` certificate+program '' package and read and validate the entire program w.r.t .  its certificate at once , in a non incremental way . however , there are situations which are not well suited to this simple model and which instead require only rechecking certain parts of the analysis graph which has already been validated . in particular , we consider possible untrusted _ updates _ of a validated ( trusted ) code ,",
    "i.e. , a code producer can ( periodically ) send to its consumers new updates of a previously submitted package .",
    "we characterize the different kind of updates , or modifications over a program .",
    "in particular , we include :    1 .",
    "the _ addition _ of new data / predicates and the extension of already existing predicates with new functionalities , 2 .",
    "the _ deletion _ of predicates or parts of them and 3 .",
    "the _ replacement _ of certain ( parts of ) predicates by new versions for them .",
    "in such a context of frequent software updates , it appears inefficient to submit a full certificate ( superseding the original one ) and to perform the checking of the entire updated program from scratch , as needs to be done with current systems . in the context of acc",
    ", we discuss the influence of the different kinds of updates on an _ incremental _ extension to pcc in terms of correctness and efficiency .",
    "we also outline the main issues on the generation of incremental certificates and the design of incremental checkers .",
    "the paper is organized as follows .",
    "section [ sec : basics - abstr - carry ] introduces briefly some notation and preliminary notions on abstract interpretation and acc . in section [ sec : incremental - acc ] , we present a general view of incremental acc . in section [ cu ]",
    "we describe the different kinds of updates over a program and the way they affect the certification and checking phases .",
    "section [ icertificates ] reviews the notion of full certificate and proposes the use of incremental certificate . in section [ icheckers ] , we discuss the extensions needed on a non - incremental checking algorithm in order to support incrementality and we sketch the new tasks of an incremental checking algorithm . finally , section  [ sec : discussion ] concludes .",
    "our work relies on the abstract interpretation - based analysis algorithm of @xcite for ( constraint ) logic programming , ( c)lp .",
    "we assume some familiarity with abstract interpretation ( see @xcite ) , ( c)lp ( see , e.g. , @xcite ) and pcc @xcite .    very briefly , _",
    "terms _ are constructed from variables ( e.g. , @xmath0 ) , _ functors _ ( e.g. , @xmath1 ) and _ predicates _",
    "( e.g. , @xmath2 ) .",
    "we denote by @xmath3 the _ substitution _",
    "@xmath4 , where @xmath5 , if @xmath6 , and @xmath7 are terms . a _ renaming _ is a substitution @xmath8 for which there exists the inverse @xmath9 such that @xmath10 .",
    "a _ constraint _ is a conjunction of expressions built from predefined predicates ( such as inequalities over the reals ) whose arguments are constructed using predefined functions ( such as real addition ) .",
    "atom _ has the form @xmath11 where @xmath2 is a predicate symbol and @xmath7 are terms .",
    "literal _ is either an atom or a constraint .",
    "a _ rule _ is of the form @xmath12 where @xmath13 , the _ head _ , is an atom and @xmath14 , the _ body _ , is a possibly empty finite sequence of literals . a _",
    "constraint logic program _",
    "@xmath15 , or _",
    ", is a finite set of rules .",
    "program rules are assumed to be normalized : only distinct variables are allowed to occur as arguments to atoms .",
    "furthermore , we require that each rule defining a predicate @xmath2 has identical sequence of variables @xmath16 in the head atom , i.e. , @xmath17 .",
    "we call this the _ base form _ of @xmath2 .",
    "this is not restrictive since programs can always be normalized .",
    "an abstract interpretation - based certifier is a function certifier@xmath18 which for a given program @xmath19 , an abstract domain @xmath20 and an abstract safety policy @xmath21 generates an abstract certificate @xmath22 , by using an abstract interpreter for @xmath23 , such that the certificate entails that @xmath24 satisfies @xmath25 .",
    "an abstract safety policy @xmath25 is a specification of the safety requirements given in terms of the abstract domain @xmath23 . in the following , using the same subscript @xmath26",
    ", we denote that @xmath25 and @xmath27 are specifications given as abstract semantic values of @xmath23 .",
    "the basics for defining such certifiers ( and their corresponding checkers ) in acc are summarized in the following five points :    * _ approximation . _ * : :    we consider a _ description ( or abstract ) domain _",
    "@xmath28    and its corresponding _ concrete domain _",
    "@xmath29 , both with a complete    lattice structure . description ( or abstract ) values and sets of    concrete values are related by an _ abstraction _",
    "function    @xmath30 , and a _ concretization _",
    "function    @xmath31 .",
    "the pair    @xmath32 forms a galois    connection .",
    "the concrete and abstract domains must be related in such    a way that the following condition holds  @xcite    +    @xmath33    +    in general @xmath34 is induced by    @xmath35 and @xmath26 .",
    "similarly , the    operations of _ least upper bound _ ( @xmath36 ) and _ greatest    lower bound _ ( @xmath37 ) mimic those of @xmath38    in a precise sense . *",
    "_ analysis .",
    "_ * : :    we consider the class of _ fixed - point semantics _ in which a    ( monotonic ) semantic operator , @xmath39 , is associated to    each program @xmath24 .",
    "the meaning of the program ,    @xmath40 ,    is defined as the least fixed point of the @xmath39 operator ,    i.e. ,    @xmath41 .",
    "if @xmath39 is continuous , the least fixed point is the limit    of an iterative process involving at most @xmath42    applications of @xmath39 starting from the bottom element of    the lattice .",
    "using abstract interpretation , we can usually only    compute    @xmath43 ,    as    @xmath44 .",
    "the operator @xmath45 is the abstract counterpart of    @xmath39 .",
    "+    @xmath46    +    correctness of analysis ensures that    @xmath47    safely approximates    @xmath48 ,    i.e. ,    @xmath49 .",
    "thus , such _ abstraction _ can be used as a certificate . * _ certificate . _ * : :    let @xmath27 be a safe approximation of    @xmath47 .",
    "if an abstract safety specification @xmath25 can be    proved w.r.t .",
    "@xmath27 , then @xmath24    satisfies the safety policy and @xmath27 is a valid    certificate :    +    @xmath50    +    note that the certificate can be stricter than the safety    specification and it is only required that @xmath25 is    implied by @xmath27 .",
    "* _ certifier . _",
    "* : :    together , equations ( [ eq:1 ] ) and ( [ ecuacion2 ] ) define a certifier    which provides program fixpoints ,    @xmath51 ,    as certificates which entail a given safety policy , i.e. , by taking    @xmath52 . * _ checking . _ * : :    a checker is a function    checker@xmath53    which for a program @xmath19 , an abstract domain    @xmath54 and certificate    @xmath22 checks whether    @xmath27 is a fixpoint of    @xmath55 or not :    +    @xmath56 * _ verification condition regeneration . _ * : :    to retain the safety guarantees , the consumer must regenerate a    trustworthy verification condition equation ( [ ecuacion2]) and use    the incoming certificate to test for adherence of the safety policy .",
    "+    @xmath57    +    a fundamental idea in acc is that , while analysis equation ( [ eq:1])    is an iterative process , checking equation  ( [ eq:3]) is guaranteed to    be done in a _ single pass _ over the abstraction .",
    "figures  [ inc - acc1 ] and [ inc - acc2 ] present a general view of the incremental certification and incremental checking processes respectively . in figure",
    "[ inc - acc1 ] , the producer starts from an updated program , @xmath58 , w.r.t .  a previously certified program , @xmath24 .",
    "it first retrieves from disk @xmath24 and its certificate , cert , computed in the previous certification phase .",
    "next , the process `` @xmath59 '' compares both programs and returns the differences between them , @xmath60 , i.e , the program updates which applied to @xmath24 results in @xmath58 , written as @xmath61 .",
    "note that , from an implementation perspective , a program update should contain both the new updates to be applied to the program and instructions on where to place and remove such new code .",
    "this can be easily done by using the traditional unix _",
    "format for coding program updates .",
    "an incremental certifier generates from cert , @xmath24 and @xmath60 an incremental certificate , inc_cert , which can be used by the consumer to validate the new updates .",
    "the package `` @xmath60+inc_cert '' is submitted to the code consumer .",
    "finally , in order to have a compositional incremental approach , the producer has to update the original certificate and program with the new updates .",
    "thus , the resulting ext_cert  and @xmath58 are stored in disk replacing cert  and @xmath24 , respectively .    in figure",
    "[ inc - acc2 ] , the consumer receives the untrusted package . in order to validate the incoming update w.r.t .  the provided ( incremental ) certificate , it first retrieves @xmath24 and cert  from disk .",
    "next , it reconstructs the updated program by using an operator `` @xmath62 '' which applies the update to @xmath24 and generates @xmath63 .",
    "this can implemented by using a program in the spirit of the traditional unix _ patch _ command as @xmath62 operator .",
    "an incremental checker now efficiently validates the new modification by using the stored data and the incoming incremental certificate .",
    "if the validation succeeds ( returns ok ) , the checker will have reconstructed the full certificate .",
    "as before , the updated program and extended certificate are stored in disk ( superseding the previous versions ) for future ( incremental ) updates . in order to simplify our scheme , we assume that the safety policy and the generation of the verification condition @xcite are embedded within the certifier and checker . however ,",
    "in an incremental approach , producer and consumer could perfectly agree on a new safety policy to be implied by the modification .",
    "it should be noted that this does not affect our incremental approach and the verification condition would be generated exactly as in non incremental pcc .",
    "let us now characterize the types of updates we consider and how they can be dealt within the acc scheme in the context of logic programming . given a program @xmath24",
    ", we define an _ update _ of @xmath24 , written as @xmath60 , as a set of tuples of the form @xmath64 , where @xmath65 is an atom in base form and :    * @xmath66 is the set of rules which are to be added to @xmath24 for predicate @xmath2 .",
    "this includes both the case of addition of new predicates , when @xmath2 did not exist in @xmath24 , as well as the extension of additional rules ( or functionality ) for @xmath2 , if it existed .",
    "* @xmath67 is the set of rules which are to be removed from @xmath24 for predicate @xmath2 .",
    "note that , for the sake of simplicity , we do not include the instructions on where to place and remove such code in the formalization of our method .",
    "we distinguish three classes of updates : _ addition _ , _ deletion _ and _ arbitrary changes_.    * the addition of predicates occurs when @xmath68 @xmath69 . * the _ deletion _ of predicates occurs if @xmath68 @xmath70 . * the remaining cases are considered _",
    "arbitrary changes_.    * _ addition of procedures . _",
    "* : :    when a program @xmath24 is extended with new predicates or new    clauses for existing predicates , the original certificate    @xmath27 is not guaranteed to be a fixpoint any    longer , because the contribution of the new rules can lead to a more    general answer .",
    "consider @xmath71 the program after    applying some additions and @xmath72 the    certificate computed from scratch for @xmath71 .",
    "then ,    @xmath73 .",
    "this means    that @xmath27 is no longer valid .",
    "therefore , we    need to perform the least upper bound ( _ lub _ ) of the contribution of    the new rules and submit , together with the extension , the new    certificate @xmath72 ( or the difference of    both certificates ) . the consumer will thus test the safety policy    w.r.t.@xmath72 .",
    "consider the abstract    operation @xmath74 which performs the    abstract disjunction of two descriptions .",
    "then , we define    @xmath75    and submit the incremental certificate @xmath76    which is defined as the ( abstract ) difference    @xmath77 .",
    "the notion of    incremental certificate is the issue of section  [ icertificates ] .",
    "* _ deletion of procedures .",
    "_ * : :    the first thing to note is that in order to entail the safety policy ,    unlike extensions over the program , we need not change the certificate    at all when some predicates are deleted . consider    @xmath78 the program after applying some deletions and    @xmath79 the certificate computed from    scratch for @xmath78 .",
    "the original certificate    @xmath27 is trivially guaranteed to be a fixpoint    ( hence a correct certificate ) , because the contribution of the rules    was conjoined ( by computing the lub ) to give    @xmath27 and so it still correctly describes the    contribution of each remaining rule . by applying equation  [ ecuacion2 ] ,",
    "@xmath27 is still valid for @xmath78    w.r.t .",
    "@xmath25 since    @xmath80",
    ". therefore , more    accuracy is not needed to ensure compliance with the safety policy .",
    "this suggests that the incremental certificate can be empty and the    checking process does not have to check any predicate .",
    "however , it can    happen that a new , more precise , safety policy is agreed by the    consumer and producer .",
    "also , this accuracy could be required in a    later modification .",
    "although @xmath27 is a correct    certificate , it is possibly less _ accurate _ than    @xmath79 , i.e. ,    @xmath81 .",
    "it is    therefore interesting to define the corresponding incremental    algorithm for reconstructing @xmath79 and    checking the deletions and the propagation of their effects . *",
    "_ arbitrary changes . _ * : :    the case of arbitrary changes considers that rules can both be deleted    from and added to an already validated program . in this case , the new    certificate for the modified program can be either equal , more or less    precise than the original one , or even not comparable .",
    "imagine that an    arbitrary change replaces a rule @xmath82 , which contributes    to a fixpoint @xmath83 , with a new one    @xmath84 which contributes to a fixpoint    @xmath85 such that    @xmath86    and @xmath87 and    @xmath88 .",
    "the    point is that we can not just compute an approximation of the new rule    and compute the lub with to the previous fixpoint , i.e. , we can not use    @xmath89 as certificate and have to provide    the more accurate @xmath85 .",
    "the reason is that    it might be possible to attest the safety policy by independently    using @xmath83 and    @xmath85 while it can not be implied by using    their lub @xmath89 .",
    "this happens for certain    safety policies which contain disjunctions , i.e. ,    @xmath90 does not    correspond to their lub @xmath89 .",
    "therefore ,    arbitrary changes require a precise recomputation of the new fixpoint    and its proper checking .",
    "+    as a practical remark , an arbitrary update can be decomposed into an    addition and a deletion and then handled as the first cases .",
    "we have    pointed out the difference because correctness and accuracy    requirements are different in each particular case , as we have seen    above .",
    "[ programas ] the next example shows a piece of a module which contains the following ( normalized ) program for the naive reversal of a list and uses the standard implementation of app for appending lists :    @xmath91,~ y = [ \\ ] . } \\\\",
    "( { \\tt rev_2 } ) & { \\tt rev(x , y )    : - ~x = [ u|v],~ rev(v , w),~ t = [ u],~    app(w , t , y ) . } \\\\ ( { \\tt app_1})&{\\tt app(x , y , z ) : -~ x = [ \\ ] , ~ y = z. } \\\\ ( { \\tt app_4 } ) & { \\tt app(x , y , z ) : -~ x = [ u|v],~ z = [ u|w],~ app(v , y , w)}. \\end{array}\\right . \\end{array}\\ ] ]",
    "suppose now that the consumer modifies @xmath92 introducing two more base cases for @xmath93 ( e.g. , added automatically by a partial evaluator @xcite ) :    @xmath94,~ z = [ u|y ] . } \\\\",
    "( { \\tt app_3 } ) & { \\tt app(x , y , z ) : -~ x = [ u , v],~ z = [ u , v|y ] .",
    "} \\end{array}\\ ] ]    the producer must send to the consumer the set @xmath95 , composed of the unique tuple :    @xmath96    where @xmath97 and @xmath98 , i.e. , we are in the case of an _ addition _ of predicates only .",
    "let us name @xmath99 to the program resulting from adding rules @xmath100 and @xmath101 to @xmath92 .",
    "note that these rules do not add any further information to the program ( i.e. , the certificate for @xmath92 and @xmath99 would remain the same and , as we will see , the _ incremental certificate is empty _ ) .",
    "consider now the following new definition for predicate app which is a specialization of the previous app to concatenate lists of a s of the same length :    @xmath102,y = [ \\ ] , z = [ \\ ] .}\\\\ { \\tt ( napp_2 ) } & { \\tt app(x , y , z ) : -~ x = [ a|v],y=[a|u ] , z = [ a , a|w ] ,       app(v , u , w)}. \\end{array}\\ ] ]    the update consists in deleting all rules for predicate app in @xmath99 and replacing them by @xmath103 and @xmath104 .",
    "let @xmath105 be the resulting program .",
    "@xmath106 is composed again of a unique tuple with the following information :    @xmath107    in this case , we are in presence of an _ arbitrary change _ , and as we will show in example [ ultimo ] , the _ incremental certificate _ will not be empty in this case ( since by using the abstract domain @xmath108 in example [ ex : dom - call ] , the fixpoint for @xmath105 will change w.r.t .",
    "the one for @xmath99 ) . @xmath109",
    "although acc and incremental acc , as outlined above , are general proposals not tied to any particular programming paradigm , our developments for incremental acc ( as well as for the original acc framework @xcite ) are formalized in the context of ( c)lp . a main idea in acc @xcite is that a _ certificate _ , @xmath76 , is automatically generated by using the _ complete _ set of _ entries _ returned by an abstract fixpoint analysis algorithm . for concreteness , we rely on an abstract interpretation - based analysis algorithm in the style of the generic analyzer of @xcite .    the analysis algorithm of @xcite , which we refer to as analyze , given a program @xmath24 and an abstract domain @xmath23 , receives a set of _ call patterns _ @xmath110 ( or abstract atoms ) which are a description of the calling modes into the program , and constructs an _ analysis graph _",
    "@xcite for @xmath111 which is an _ abstraction _ of the ( possibly infinite ) set of ( possibly infinite ) trees explored by the concrete execution of initial calls described by @xmath111 in @xmath24 .",
    "formally , a _ call pattern _ @xmath112 is composed of an atom in base form , @xmath113 , and a description in the abstract domain , @xmath114 , for @xmath115 .",
    "the program analysis graph computed by analyze@xmath116 for @xmath24 in @xmath23 can be implicitly represented by means of two data structures , the _ answer table _ ( @xmath117 ) and the _ dependency arc table _ ( @xmath118 ) ,",
    "which are the output of the algorithm analyze . each element ( or _ entry _ ) in the answer table takes the form @xmath119 such that , for the atom @xmath115 , @xmath114 is its _ call _ description and @xmath120 its _ success _ ( or answer ) description in the abstract domain .",
    "informally , such entry should be interpreted as `` the answer pattern for calls to @xmath115 satisfying precondition @xmath114 accomplishes postcondition @xmath121 '' .",
    "the dependency arc table is not relevant now , although it is fundamental in the design of the incremental checking , as we will see later .",
    "all the details and the formalization of the algorithm can be found in @xcite .",
    "our proposal for the incremental checking is that , if the consumer keeps the original ( fixed - point ) abstraction @xmath76 , it is possible to provide only the program updates and the incremental certificate @xmath122 . concretely , given :    * an update @xmath60 of @xmath24 , * the certificate cert  for @xmath24 and @xmath111 , * the certificate ext_cert  for @xmath123 and @xmath111    we define inc_cert , the _ incremental certificate _ for @xmath60 w.r.t .",
    "@xmath76 , as the difference of certificates @xmath124 and @xmath76 , i.e. , the set of entries in @xmath124 not occurring in @xmath76 .",
    "the first obvious advantage is that the size of the transmitted certificate can be considerably reduced .",
    "let us see an example .",
    "[ ex : dom - call ] consider program @xmath92 in example [ programas ] .",
    "the description domain that we are going to use in our examples is the _ definite boolean functions _  @xcite , denoted @xmath108 .",
    "the key idea in this description is to use implication to capture groundness dependencies .",
    "the reading of the function @xmath125 is `` if the program variable @xmath0 is ( becomes ) ground , so is ( does ) program variable @xmath126 . ''",
    "for example , the best description of the constraint @xmath127 is @xmath128 .",
    "the most general description @xmath129 does not provide information about any variable .",
    "the least general substitution @xmath130 assigns the empty set of values to each variable . for the analysis of our running example",
    ", we consider the set of call patterns @xmath131 @xmath132 , i.e. , no entry information is provided on @xmath133 nor @xmath134 .",
    "analyze(\\{@xmath135 } )  returns in the answer table , @xmath117 , the following entries :    @xmath136    the certificate cert  for this example is then composed of the entries @xmath137 and @xmath138 .",
    "consider now the addition of rules @xmath139 and @xmath140 in @xmath92 , i.e. , program @xmath99 of example [ programas ] .",
    "the analysis algorithm of @xcite returns as @xmath124 the same answer table @xmath117 as for @xmath92 , since the added rules do not affect the fixpoint result , i.e. , they do not add any further information .",
    "thus , the incremental certificate inc_cert  associated to such an update is empty .",
    "intuitively , an abstract interpretation - based checking algorithm ( like the one in @xcite ) receives as input a program @xmath24 , a set of abstract atoms @xmath111 and a certificate cert and constructs a program analysis graph in a single iteration by assuming the fixpoint information in cert . while the graph is being constructed , the obtained answers are stored in an answer table @xmath141 ( initially empty ) and compared with the corresponding fixpoints stored in cert .",
    "if any of the computed answers is not consistent with the certificate ( i.e. , it is greater than the fixpoint ) , the certificate is considered invalid and the program is rejected .",
    "otherwise , cert  gets accepted and @xmath142 .      in order to define an incremental checking ,",
    "the checking algorithm in @xcite needs to be modified to compute ( and store ) also the dependencies between the atoms in the answer table . in @xcite , we have instrumented a checking algorithm for full certificates with a _ dependency arc table_. this structure , @xmath118 , is not required by non incremental checkers but it is fundamental to support an incremental design .",
    "the @xmath118 returned by analyze  is composed of arcs ( or _ dependencies _ ) of the form @xmath143 associated to a program rule @xmath144 with @xmath145 , where @xmath146 is an atom .",
    "the intended meaning of such a dependency is that the answer for @xmath147 depends on the answer for @xmath148 , say @xmath120 .",
    "thus , if @xmath120 changes with the update of some rule for @xmath149 then , the arc @xmath150 must be reprocessed in order to compute the new answer for @xmath147 .",
    "this is to say that the rule for @xmath151 has to be processed again starting from atom @xmath149 , i.e. , we do not need to process the part @xmath152 because it is not affected by the changes .    in the following , we assume that checker is a non incremental checker such that , if the call checker(@xmath153 ) does not fail , then it returns the reconstructed answer table @xmath154 and the set of dependencies",
    "@xmath155 which have been generated .",
    "in such a case , we say that @xmath76 has been _ checked _ or _",
    "accepted_. by the correctness of the checker @xcite , the reconstructed structures contain exactly the same data as the answer table and the dependency arc table computed by the analysis algorithm analyze(@xmath111 ) for the program @xmath24 .",
    "[ ex : dom - call1 ] consider the program @xmath92 in example [ programas ] .",
    "analyze  returns , together with @xmath156 , the following dependency arc table :    @xmath157    intuitively , @xmath158 denotes that the answer for @xmath159 may change if the answer for @xmath160 changes .",
    "in such a case , the second rule @xmath161 for @xmath162 must be processed again starting from atom @xmath163 in order to recompute the fixpoint for @xmath159 . @xmath164 and",
    "@xmath165 reflect the recursivity of @xmath159 and @xmath166 @xmath167 , respectively , since they depend on themselves ( rules @xmath161 and @xmath168 respectively ) .",
    "the detailed steps performed by the algorithm can be found in @xcite .",
    "note that , the checker executed for the call pattern at hand , computes ( and stores ) in @xmath169 the entries @xmath170 , @xmath171 in example [ ex : dom - call ] , and , after traversing rules @xmath161 and @xmath168 , it stores in @xmath155 the dependencies @xmath164 , @xmath158 and @xmath165 .",
    "@xmath109      in order to support incrementality , the final values of the data structures @xmath169 , @xmath155 and @xmath24 must be available after the end of the execution of the checker .",
    "thus , we denote by @xmath172 , @xmath173 and @xmath174 the copy in persistent memory ( i.e. , in disk ) of such structures .",
    "now , we outline in a very general way the additional tasks that an incremental checking algorithm ( inc_check in the following ) has to perform .",
    "the complete code of the algorithm can be found in @xcite .",
    "it receives as input parameters an update @xmath60 of the original program @xmath24 , a set of abstract atoms @xmath110 and the incremental certificate @xmath122 for @xmath60 w.r.t .",
    "the following tasks are carried out by an incremental checker :    * step 1 ) * : :    it retrieves from memory    @xmath175 ,    @xmath176    @xmath177 and @xmath178 ( stored in persistent memory in a previous checking    phase ) and generates    @xmath179 .",
    "* step 2 ) * : :    it rechecks all entries in @xmath180 which have    been directly affected by an update .",
    "concretely , for each    @xmath181 , such that @xmath115    has an entry in @xmath60 , a call to    checker@xmath182    is generated , marking the entry as _ checked _ ( or _ accepted _ )    @xmath183 .",
    "this guarantees that the incremental checking    process is done in one pass ( i.e. , rules used to check    @xmath184 are traversed at most once ) .",
    "* step 3 ) * : :    it propagates and rechecks the indirect effect of these changes by    inspecting the dependencies in @xmath155 .",
    "thus , for all    @xmath185 , if there    exists a dependency of the form    @xmath186 ( modulo renaming ) in @xmath155 such    that @xmath187 is not marked as checked , then a call to    checker@xmath188    is generated and @xmath189 is marked as checked .",
    "this    process is repeated until there are no dependencies satisfying the    above condition .",
    "note that the condition    @xmath185 ensures    that the answer for @xmath184 has changed w.r.t .",
    "otherwise nothing has to be done ( this    will allow us to reduce the checking time w.r.t a full checking    process for @xmath24 and    @xmath124 ) . *",
    "step 4 ) * : :    if it does not issue an error  then it removes from    @xmath190 those entries corresponding to    deleted rules . we can identity them by exploring    @xmath155 . concretely , for all    @xmath191 , @xmath192 ,",
    "if there not exists a dependency    @xmath193 in    @xmath155 then remove @xmath184    from @xmath194 .",
    "* step 5 ) * : :    it stores @xmath195 , @xmath173    @xmath196 and    @xmath197 .    our first example is intended to illustrate a situation in which the task performed by the incremental checker can be optimized such that it only checks a part of the analysis graph .    [ examplech1 ]",
    "consider the addition of rules @xmath139 and @xmath140 to program @xmath92 , which results in program @xmath99 ( example [ programas ] ) .",
    "as shown in example [ ex : dom - call ] , the incremental certificate inc_cert  associated to such an update is empty .",
    "the incremental checking algorithm inc_check proceeds as follows :    * step 1 ) * : :    @xmath190 and @xmath176    are initialized with @xmath170,@xmath171 ( example    [ ex : dom - call ] ) and @xmath164,@xmath158 and    @xmath165 ( example [ ex : dom - call1 ] ) respectively .",
    "@xmath198 . *",
    "step 2 ) * : :    since @xmath199 and    @xmath200 is not empty , then a    call to    checker(@xmath99,\\{@xmath201},@xmath122 )    is generated in order to ensure that the fixpoint is preserved .",
    "now ,    @xmath202 is marked as checked .",
    "* step 3 ) * : :    no checking has to be done since @xmath122    is empty .",
    "* step 4 ) * : :    nothing is done since @xmath201 occurs at the    right - hand side of dependency @xmath165 .",
    "* step 5 ) * : :    finally , once inc_cert  has been validated , the consumer stores the    answer table @xmath169 , the dependency arc    table @xmath155 and the program    @xmath203 in disk with the same values as in step 1 .    @xmath109    our second example is intended to show how to propagate the effect of a change to the part of the analysis graph indirectly affected by such update .    [ ultimo ] the update consists in deleting all rules for predicate app in program @xmath99 of example  [ programas ] ( which results in program @xmath105 ) , and replacing them by @xmath103 and @xmath104 . after running the analyze  for @xmath105 ,",
    "the following answer table and dependencies are computed :    @xmath204    note that the analysis information has changed because the new definition of app allows inferring that all its arguments are ground upon success @xmath205 and @xmath206 .",
    "is subsumed by @xmath207 and we could indeed only submit @xmath207 .",
    "the incremental checking algorithm should be modified to search entries which are equal or more general than the required one .",
    "] this change propagates to the answer of rev and allows inferring that , regardless of the call pattern , both arguments of rev will be ground on the exit @xmath208 .",
    "the incremental certificate inc_cert  contains @xmath209 as it corresponds to a new call pattern and contains also @xmath210 and @xmath207 since their answers have changed w.r.t .",
    "the ones stored in @xmath76 ( example  [ ex : dom - call ] ) .",
    "let us illustrate the incremental checking process carried out to validate this update .",
    "* step 1 ) * : :    we retrieve from disk the answer table , dependency arc table and the    program stored in step 5 of example [ examplech1 ] . now    @xmath211 .",
    "* step 2 ) * : :    similar to step 2 of example [ examplech1 ] , but considering the new    rules for @xmath93 . *",
    "step 3 ) * : :    since we have the dependency @xmath212    and @xmath213 , a    call to    checker(@xmath105,@xmath214,@xmath122 )    is generated to ensure that the new fixpoint for    @xmath215 is valid . in the checking process ,    when traversing the rule @xmath161 , the new call pattern    @xmath216 occurs and it is also validated by    calling to checker . when traversing rule @xmath217 , the dependency @xmath165 is replaced by the new one    @xmath218 in @xmath155 , and the    call pattern is marked as checked .",
    "similarly , the dependency    @xmath219 is replaced by the new one    @xmath220 and @xmath215 is marked    as checked .",
    "now , all call patterns have been checked and the process    finishes . *",
    "step 4 ) * : :    the entry @xmath221 is removed from @xmath222 since it does not occur at the right - hand side of    any dependency .",
    "* step 5 ) * : :    the consumer stores the answer table    @xmath223 , the dependency arc table    @xmath224 and the    program @xmath225 in disk .",
    "@xmath109    the definition of the algorithm inc_check can be found in @xcite , together with the proof of the correctness of the algorithm .",
    "informally , correctness amounts to saying that if inc_check does not issue an error , then it returns as computed answer table the extended certificate @xmath124 for the updated program .",
    "moreover , we ensure that it does not iterate during the reconstruction of any answer .",
    "our proposal to incremental acc aims at reducing the size of certificates and the checking time when a supplier provides an untrusted update of a ( previously ) validated package .",
    "essentially , when a program is subject to an update , the incremental certificate we propose contains only the _ difference _ between the original certificate for the initial program and the new certificate for the updated one .",
    "checking time is reduced by traversing only those parts of the abstraction which are affected by the changes rather than the whole abstraction . an important point to note",
    "is that our incremental approach requires the original certificate and the dependency arc table to be stored by the consumer side for upcoming updates .",
    "the appropriateness of using the incremental approach will therefore depend on the particular features of the consumer system and the frequency of software updates .",
    "in general , our approach seems to be more suitable when the consumer prefers to minimize as much as possible the waiting time for receiving and validating the certificate while storage requirements are not scarce .",
    "we believe that , in everyday practice , time - consuming safety tests would be avoided by many users , while they would probably accept to store the safety certificate and dependencies associated to the package",
    ". nevertheless , there can sometimes be situations where storage resources can be very limited , while runtime resources for performing upcoming checkings could still be sufficient .",
    "we are now in the process of extending the acc implementation already available in the ` ciaopp `  system to support incrementality .",
    "our preliminary results in certificate reduction are very promising .",
    "we expect optimizations in the checking time similar to those achieved in the case of incremental analysis ( see , e.g. , @xcite ) .",
    "this work was funded in part by the information society technologies program of the european commission , future and emerging technologies under the ist-15905 _ mobius _ project , by the spanish ministry of education under the tin-2005 - 09207 _ merit _ project , and the madrid regional government under the s-0505/tic/0407 _ promesas _ project .",
    "the authors would like to thank the anonymous referees of wlpe for their useful comments .",
    "e.  albert , p.  arenas , and g.  puebla . an incremental approach to abstraction - carrying code .",
    "technical report clip3/2006 , technical university of madrid ( upm ) , school of computer science , upm , march 2006 .",
    "t.  armstrong , k.  marriott , p.  schachte , and h.  sndergaard .",
    "boolean functions for dependency analysis : algebraic properties and efficient representation . in springer - verlag ,",
    "editor , _ static analysis symposium , sas94 _ , number 864 in lncs , pages 266280 , namur , belgium , september 1994 .",
    "p.  cousot and r.  cousot .",
    "bstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _",
    "fourth acm symposium on principles of programming languages _ , pages 238252 , 1977 ."
  ],
  "abstract_text": [
    "<S> _ abstraction - carrying code _ ( acc ) has recently been proposed as a framework for proof - carrying code ( pcc ) in which the code supplier provides a program together with an _ abstraction _ ( or abstract model of the program ) whose validity entails compliance with a predefined safety policy . </S>",
    "<S> the abstraction thus plays the role of safety certificate and its generation ( and validation ) is carried out automatically by a fixed - point analyzer . </S>",
    "<S> existing approaches for pcc are developed under the assumption that the consumer reads and validates the entire program w.r.t .  the _ full _ certificate at once , in a non incremental way . in this abstract , we overview the main issues on _ incremental _ acc . in particular , in the context of logic programming , </S>",
    "<S> we discuss both the generation of incremental certificates and the design of an incremental checking algorithm for untrusted _ _ update__s of a ( trusted ) program , i.e. , when a producer provides a modified version of a previously validated program . by update , we refer to any arbitrary change on a program , i.e. , the extension of the program with new predicates , the deletion of existing predicates and the replacement of existing predicates by new versions for them . </S>",
    "<S> we also discuss how each kind of update affects the incremental extension in terms of accuracy and correctness . </S>"
  ]
}