{
  "article_text": [
    "as quoted by weber ( 1893 ) , leopold kronecker is known to have said : _ god made natural numbers ; all else is the work of man_. the proposed packages adresses aspects of combinatorial aspects of integer encodings and can be paraphrased as a slight modification of kronecker s quote : _",
    "god created the integral unit _",
    "`` @xmath1 '' ; _ all else is the result of computation_. the topic of integer encoding schemes , is one which generates interest both from the amateur and professional mathematician alike , since :    * barriers to entry to the subject are virtually non existent , in light of the fact that the main ideas can easily be conveyed to elementary school students . *",
    "it s topics have ramifications and connections with other topics in mathematics such as algebra , cobinatorics and number theory . *",
    "most importantly , the topic offers a treasure trove of fascinating easy to state open questions .",
    "a number _ circuit _ encoding @xmath2 is a finite directed acyclic graph constructed as follows .",
    "nodes of in - degree zero are labeled by either of the constants @xmath1 or @xmath3 .",
    "all other nodes of the graph have in - degree two and are labeled either ( @xmath4 ) , ( @xmath5 ) or ( @xmath6 ) .",
    "the two edges going into a gate labeled by ( @xmath6 ) are labelled by _ left _ and _ right _ , in order to distinguish the base ( left input ) from the exponent ( right input ) .",
    "the nodes of out - degree zero correspond to output gates of the circuit .",
    "the _ size _ of @xmath2 is the number of nodes in @xmath2 .",
    "the _ depth _ of @xmath2 is the length of the longest path in @xmath2 .",
    "a number _ formula _ encoding is a special circuit with the additional restriction that every node has out - degree at most one .",
    "given an monotonically increasing function @xmath7 @xmath8 we seek to determine the number of formula encodings for some integer @xmath9 of size at most @xmath10 .",
    "in many cases the analysis is considerably simplified by considering _ monotone _",
    "formula encodings , namely formula encodings further restricted to have all in - degree zero nodes labeled with the constant @xmath1 .",
    "it is rather natural to consider formulas for which @xmath1 is never an input to a multiplication or an exponentiation gate .",
    "it was shown in @xcite there exists constants @xmath11 and @xmath12 such that some real number number @xmath12 such that the number of formula encodings of @xmath9 is asymptotically equal to @xmath13 in the more general setting where the label @xmath3 is allowed for in - zero nodes of the graphs the asymptotics for the number formula encodings for an integer @xmath9 of size not exceeding @xmath14 as @xmath9 tends to infinity is still unknown .",
    "the content of this paper is the following .",
    "in section 2 we provide a general overview of the computational model and our basic assumptions .",
    "the rest of the paper provides an annotated implementations of the various procedures for manipulating formulas encodings . a seperate sage file which isolates the procedures acompanies the paper and",
    "can be used for experimental set up with our proposed package .",
    "let @xmath15 denote the set of formula encodings constructed by combining finitely many fan - in two addition ( @xmath4 ) , multiplication ( @xmath5 ) and exponentiation ( @xmath6 ) gates with restricted to either constants @xmath1 or @xmath16 .",
    "for the sake of completeness we pin down our computational model by describing formula transformation rules which prescribe equivalences among distinct elements of @xmath15 .",
    "let @xmath17 , @xmath18 , and @xmath19 denote arbitrary elements of @xmath15 .",
    "the equivalence between distinct elements of @xmath15 is prescribed by the following transformation rules    1 .",
    "commutativity @xmath20 2 .",
    "associativity @xmath21 3 .",
    "unit element @xmath22 4 .",
    "distributivity @xmath23    finally an important rule is that a formula is considered invalid if admits as a subformula any formula equivalent to @xmath24 via the transformation rules prescribed above . throughout the discussion",
    ", the efficiency of formula encodings will be a recurring theme and thus we ( often implicitly ) exclude from @xmath15 formulas which admit sub - formulas of the form @xmath25 we remark as is well known that any formulas from the set @xmath15 can be uniquely encoded as strings from the the alphabet @xmath26 using either the prefix or the postfix / polish notation .",
    "let @xmath27 denotes the number of formulas encoding in @xmath15 which evaluated to @xmath9 and of size not exceeding @xmath14 constructed using gates from the set @xmath28 and rooted at any of the gates in the set @xmath29 where @xmath30 . as pointed in @xcite , the non linear recurrence relations which determines the counts for the number of formulas encodings of @xmath9 and incidentally the number of vertices of the equivalence class graph associated with the integer @xmath9",
    "is given by @xmath31 @xmath32 @xmath33 and @xmath34 in order to analyze arithmetic algorithms , we introduce the graph @xmath35 whose vertices are elements @xmath15 which belong to the equivalence class of formulas of size at most @xmath14 which evaluate to some given number @xmath9 .",
    "we shall refer to @xmath35 as the arithmeticahedron of @xmath9 .",
    "edges are placed in between any two vertices of @xmath35 if either of the following conditions are true    1 .",
    "each formula vertex can be obtained from the other by the use of a single associativity transformation rules .",
    "each formula vertex can be obtained from the other by the use of a single commutativity transformation rule .",
    "each formula can be obtained from the other by the use of one of the distributivity transformation rules .",
    "arithmetical algorithm can thus be depicted as walks on some arithmeticahedron and incidentally the performance of algorithm can be measured in terms of the total length of walks on some arithmeticahedron .",
    "we present here the implementation details of our integer encoding packages . the package will be crucial for setting up various experiments which would suggest interesting conjecture and possibly proofs to some of these conjectures .",
    "we shall think of our formulas as rooted binary trees with leafs labeled with the integral unit ( @xmath1 ) and all other vertices labeled with either the addition ( @xmath4 ) , multiplication ( @xmath5 ) , or exponentiation ( @xmath6 ) operation .",
    "it shall be convenient to use the bracket notation to specify such trees to sage and note that the prefix notation is easily obtain from the bracket notation .",
    "+    def t2pre(expr ) : `` '' \" converts formula written in the bracket tree encoding to the prefix string encoding notation    examples : the implementation here tacitly assumes that the input is a valid binary bracket formula - tree expression .",
    "the usage of the function is illustrated bellow .",
    ": : sage : t2pre([+,1,1 ] ) +11    authors : - edinah k. gnang and doron zeilberger    to do : -    `` '' `` s = str(expr ) return ( ( ( ( s.replace(''[``,''``)).replace('']``,''``)).replace('',``,''``)).replace(''``,''``)).replace ( '' `` , '' \" )     + as the code for the function t2pre suggest the binary - tree formula is very close to the prefix notation .",
    "the usage of the function is illustrated bellow @xmath36\\right)=\\mbox{'+11'}\\ ] ] a minor variation on the prefix notation called the postfix notation is implemented bellow +    def t2p(expr ) : `` '' \" the function converts binary formula - tree format to the more compacts postfix string notation .",
    "examples : the implementation here tacitly assumes that the input is a valid binary formula - tree expression .",
    "the usage of the function is illustrated bellow .",
    ": : sage : t2p([+,1,1 ] ) 11+    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : -    `` '' `` s = str(expr ) return ( ( ( ( s.replace(''[``,''``)).replace('']``,''``)).replace('',``,''``)).replace(''``,''``)).replace ( '' `` , ' ' \" ) [ : : -1 ]    the usage of the function is illustrated bellow @xmath37\\right)=\\mbox{'11+'}\\ ] ] when using the wilf methodology @xcite , we will require a random number generator which amounts to rolling a loaded die .",
    "we implement here the function allowing us to roll a loaded die .",
    "+    def rollld(l ) : `` '' \" the functions constructs a loaded die according to values specified by the input list of positive integers .",
    "the input list also specifies the desired bias for each one of the faces of the dice    examples : the tacitly assume that the input list is indeed made up of positive integers as no check is perform to validate that assumption : : sage : rollld([1 , 2 , 3 ] ) 2    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" # summing up all the n = sum(l ) r = randint(1,n ) for i in range(len(l ) ) : if sum(l[:i+1 ] ) > =",
    "r : return i+1     + given a list of positive integers the procedures operates in two steps .",
    "first it samples uniformly at random a positive integer less than the sum of all the positive integers in the input list . the last step consist in returning the largest index of the element in the input list such that the sum of the integers preceding that index is less or equal to the sampled integers .",
    "we provide here a straight forward implementation of procedures for listing formulas which only uses addition .",
    "+    @cached_function def fat(n ) : `` '' \" the procedure outputs the list of formula - binary trees constructed using fan - in two addition gates and having inputs restricted to the integral unit 1 and the resulting formulas each evaluate to the input integer n > 0 .",
    "examples : the procedure expects a positive integer otherwise it returns the empty list .",
    ": : sage : fat(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : -    `` '' \" if n==1 : return [ 1 ] elif n > 1 and type(n ) = = integer : gu = [ ] for i in range(1,n ) : gu = gu + [ [ + , g1 , g2 ] for g1 in fat(i ) for g2 in fat(n - i ) ] return gu else : return [ ]     + we illustrate bellow the output of the function call with the inputs 1 and 2 .",
    "@xmath38 @xmath39 the formulas returned by the fat procedure are in binary tree form . for convenience we may implement a function which output the expression in prefix notation , the function for formatting the encoding into prefix",
    "is provided bellow +    @cached_function def fapre(n ) : `` '' \" the procedure outputs the list of formula in prefix notation constructed using fan - in two addition gates having inputs restricted to the integral unit 1 and the resulting formula evaluates to the input integer n > 0 .",
    "examples : the input n must be greater than 0 : : sage : fapre(3 ) [ +1 + 11 , ++111 ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return [ t2pre(g ) for g in fat(n ) ]     + the postfix variant of the function implemented is immediate and provided bellow .",
    "+    @cached_function def fap(n ) : `` '' \" the set of formula only using addition gates which evaluates to the input integer n in prefix notation .",
    "examples : the input n must be greater than 0 : : sage : fap(3 ) [ 11 + 1+ , 111++ ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - nothing as this procedure is optimal    `` '' \" return [ t2p(g ) for g in fat(n ) ]     + having implemented procedures which produces formulas using only addition , we now turn to the problem of enumerating such formulas",
    ". clearly we could enumerate the sets by first producing the formulas and then enumerating them , but this would lead to a very inefficient use of space and time resources .",
    "instead we compute recurrence formulas which determines the number of formulas encoding using only additions and with input restricted to the integral unit @xmath1 .",
    "+    @cached_function def ca(n ) : `` '' \" the procedure outputs the number of formula - binary trees constructed using fan - in two addition gates and having inputs restricted to the integral unit 1 and the each of the resulting formulas each evaluate to the input integer n > 0 .",
    "examples : the input n must be greater than 0 : : sage : ca(3 ) 2    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return 1 else : return sum([ca(i)*ca(n - i ) for i in range(1,n ) ] )     + we illustrate the usage of the functions bellow @xmath40 @xmath41 @xmath42 @xmath43 @xmath44 furthermore we may note that @xmath45 which would suggest that for @xmath46 @xmath47 to avoid redundancy we may choose to only list formulas for which the second term of the tree is less or equal to the integer encoded in the left term of the tree .",
    "we provide bellow the implementation of the procedure .",
    "+    @cached_function def lopfat(n ) : `` '' \" outputs all the formula - binary trees only using addition such that the first term of the addition is > = the second term .    examples : the input n must be greater than 0 : : sage : lopfat(3 ) [ [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 0 : return [ ] elif n = = 1 : return [ 1 ] else : gu = [ ] for i in range(1,1+floor(n/2 ) ) : gu = gu + [ [ + , g1 , g2 ] for g1 in lopfat(n - i ) for g2 in lopfat(i ) ] return gu     + for outputting such formulas in prefix notation we use the function implemented bellow +    def lopfapre(n ) : `` '' \" outputs all the formula - binary tree which evaluate to the input integer n such that the first term of the addition is > = the second term in prefix notation .",
    "examples : the input n must be greater than 0 : : sage : lopfapre(2 ) `` + 11 ''    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return [ t2pre(f ) for f in lopfat(n ) ]     + for outputting such formulas in postfix notation we use the function implemented bellow +    def lopfap(n ) : `` '' \" outputs all the formula - binary tree which evaluate to the input integer n such that the first term of the addition is > = the second term in postfix notation .    examples : the input n must be greater than 0 : : sage : lopfap(2 ) `` 11 + ''    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return [ t2p(f ) for f in lopfat(n ) ]     + similarly we provide an implementation for a distinct procedure for enumerating formulas trees for which the second term of the tree is less or equal to the integer encoded in the left term of the tree .",
    "+    @cached_function def lopca(n ) : `` '' \" outputs the number of formula - binary trees only using addition gates such that the first term of the addition is > = the second term .",
    "examples : the input n must be greater than 0 : : sage : lopca(3 ) 1    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return 1 else : return sum([lopca(i)*lopca(n - i ) for i in range(1,1+floor(n/2 ) ) ] )     + in many situations , there will be way more formulas then it would be reasonable to output in a list , however for experimental purposes it is often sufficient to generate formulas of interest uniformly at random . incidentally following the wilf methodology",
    "we implement a function for sampling uniformly at random formula which use only addition gates and have input restricted to the integer 1 .",
    "+    def rafat(n ) : `` '' \" outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n > 0 .",
    "examples : the input n must be greater than 0 : : sage : rafat(3 ) [ + , [ + , 1 , 1 ] , 1 ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 0 : return [ ] if n = = 1 : return [ 1 ] else : # rolling the loaded die .",
    "j = rollld([ca(i)*ca(n - i ) for i in range(1,n+1 ) ] ) return [ + , rafat(j ) , rafat(n - j ) ]     + quite straightforwardly we provide bellow the implementation of the procedure for sampling a random formulas but returning them respectively in prefix notation +    def rafapre(n ) : `` '' `` outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n in prefix notation . examples : the input n must be greater than 0 : : sage : rafapre(3 ) ' ' + + 111 \"    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return(t2pre(rafat(n ) ) )     + for outputting uniformly sampled random formula in postfix notation we implement the function bellow +    def rafap(n ) : `` '' \" outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n in postfix notation .    examples : the input n must be greater than 0 : : sage : rafap(3 ) 111++    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return(t2p(rafat(n ) ) )    similarly we implement a procedure for sampling uniformly at random a formula where the left term is greater or equal to the right term .",
    "+    def ralopfat(n ) : `` '' \" outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n such that the first term of the addition is > = the second term . examples : the input n must be greater than 0 : : sage : ralopfat(3 ) [ + , [ + , 1 , 1 ] , 1 ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return [ 1 ] else : # rolling the loaded die .",
    "j = rollld([lopca(i)*lopca(n - i ) for i in range(1,1+floor(n/2 ) ) ] ) return [ + , ralopfat(n - j ) , ralopfat(j ) ]    for outputting a uniformly sampled formulas in prefix having it s first term greater or equal to the second term in prefix notation we have +    def ralopfapre(n ) : `` '' `` outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n such that the first term of the addition is > = the second term in prefix notation .",
    "examples : the input n must be greater than 0 : : sage : ralopfapre(3 ) ' ' + + 111 \"    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return t2pre(ralopfat(n ) )    alternatively for outputting a uniformly sampled formula with the right term greater or equal to the left term expressed in postfix notation we use the function implemented bellow .",
    "+    def ralopfap(n ) : `` '' `` outputs a uniformly randomly chosen formula - binary tree which evaluate to the input integer n such that the first term of the addition is > = the second term in postfix notation . examples : the input n must be greater than 0 : : sage : ralopfap(3 ) ' ' 111++ \"    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return t2p(ralopfat(n ) )      we discuss here in detail procedures for producing and enumerating formulas which result from a finite combination of fan - in two addition , multiplication gates and having inputs restricted to integer @xmath1 .",
    "the basic principles underlying most procedures consists in partitioning the set of formula into disjoint sets according to the root gate of the formulas considered . in this particular case we will consider the partition of formulas according to wether or not the root gate corresponds to an addition or a multiplication gate .",
    "+    @cached_function def famta(n ) : `` '' \" the set of formula - binary trees only using additions and multiplications gates with the root gate being an addition gate and most importantly evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : famta(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 0 : return [ ] elif n = = 1 : return [ 1 ] else : gu = [ ] for i in range(1,n ) : gu = gu + [ [ + , g1 , g2 ] for g1 in famt(i ) for g2 in famt(n - i ) ] return gu     + the procedures which determines the formulas with root gate corresponding to a multiplication gate is provided bellow : +    @cached_function def famtm(n ) : `` '' \" the set of formula - binary trees only using addition and multiplication gates with root gate corresponding to a multiplication gate which evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : famtm(4 ) [ [ * , [ + , 1 , 1 ] , [ + , 1 , 1 ] ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return [ ] else : gu = [ ] for i in range(2 , 1+floor(n/2 ) ) : if mod(n , i ) = = 0 : gu = gu + [ [ * , g1 , g2 ] for g1 in famt(i ) for g2 in famt(n / i ) ] return gu     + we implement bellow the function which compute the union of the two partition of formulas , those rooted at an addition gate and the ones rooted at a multiplication gate .",
    "+    @cached_function def famt(n ) : `` '' \" the set of formula - binary trees only using addition and multiplication gates .    examples : the input n must be greater than 0 : : sage : famt(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return ( famta(n ) + famtm(n ) )     + again following the wilf methodology we implement distinct procedures for enumerating formulas which result from a finite combination of fan - in two addition and multiplication gates .",
    "we start by implementing the function which enumerate formulas rooted at an addition gate +    @cached_function def cama(n ) : `` '' \" output the size of the set of formulas produced by the procedure famta(n ) .",
    "examples : the input n must be greater than 0 : : sage : cama(4 ) 5    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : return sum([cam(i)*cam(n - i ) for i in range(1,n ) ] )     + we then implement the function which enumerate formulas resulting from finite combination of addition , multiplication gates rooted at a multiplication gate .",
    "+    @cached_function def camm(n ) : `` '' \" output the size of the set of formulas produced by the procedure famtm(n ) .",
    "examples : the input n must be greater than 0 : : sage : camm(4 ) 1    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : return sum([cam(i)*cam(n / i ) for i in range(2,1+floor(n/2 ) ) if mod(n , i)==0 ] )     + finally we implement the function which enumerates all formulas which result from a finite combination of addition , multiplication gates which evaluate to the input integer +    @cached_function def cam(n ) : `` '' \" output the size of the set of formulas produced by the procedure famt(n ) .",
    "examples : the input n must be greater than 0 : : sage : cam(6 ) 52    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return cama(n)+camm(n )     + as we have mentioned for formulas of large sizes we implement a function which samples uniformly at random formulas which evaluate to the input integer and result from a finite combination of addition and multiplication gates and rooted at an addition gate +    def rafamta(n ) : `` '' \" outputs a formula - binary tree formula sampled uniformly at random amoung all formulas which evaluates to the input integer n the formula results from a finite combination of addition and multiplication gates and is rooted at an addition gate .",
    "examples : the input n must be greater than 0 : : sage : rafamt(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : j = rollld([cam(i)*cam(n - i ) for i in range(1,n+1 ) ] ) return [ + , rafamt(j ) , rafamt(n - j ) ]     + similarly we implement a function which samples a uniformly at random a formula which evaluate to the input integer , which results from a finite combination of addition , multiplication gates and is rooted at a multiplication gate +    def rafamtm(n ) : `` '' \" outputs a formula - binary tree sampled uniformly at random which evaluates to the input integer n using only addition and multiplication gates and rooted at a mulitplication .",
    "examples : the input n must be greater than 0 : : sage : rafamt(6 ) [ *,[+ , 1 , 1 ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : print 1 has no multiplicative split return i elif is_prime(n ) : print str(n)+ has no multiplicative split return i else : lu = [ ] l = [ ] for i in range(2,1+floor(n/2 ) ) : if mod(n , i)==0 : lu.append(i ) l.append(cam(i)*cam(n/i ) ) j = rollld(l ) return [ * , rafamt(lu[j-1 ] ) , rafamt(n / lu[j-1 ] ) ]     + finally we can combine the two functions implemented above to obtain a functions which samples uniformly at random a formula which evaluates to the input integer and results from a finite combination of addition and multiplication gate +    def rafamt(n ) : `` '' \" outputs a formula - binary tree sampled uniformly at random which evaluates to the input integer n using only addition and multiplication gates .",
    "examples : the input n must be greater than 0 : : sage : rafamt(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : i = rollld[cama(n),camm(n ) ] if i==1 : return rafamta(n ) else : return rafamtm(n )     + for obtaining the list all formulas which combine addition and multiplication express using the postfix notation and evaluate to the input integer we have +    @cached_function def famp(n ) : `` '' \" outputs the set of formula - binary tree written in postfix notation which evaluates to the input integer n using only addition and multiplication gates .    examples : the input n must be greater than 0 : : sage : famp(2 ) 11+    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return [ t2p(f ) for f in famt(n ) ]     + similarly for obtaining the list all formulas which combine addition and multiplication gates and evaluate to the input integer express in the prefix notation we have +    @cached_function def fampre(n ) : `` '' \" outputs the set of formula - binary tree written in prefix notation which evaluates to the input integer n using only addition and multiplication gates .",
    "examples : the input n must be greater than 0 : : sage : fampre(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return [ t2pre(f ) for f in famt(n ) ]     + for obtaining the randomly sample integer which evaluates to the input integer and is uniformly sampled among all formulas which combine addition and multiplication express using the postfix notation we have +    @cached_function def rafamp(n ) : `` '' \" outputs a uniformly randomly sample formula - binary tree written in postfix notation which evaluates to the input integer n using only addition and multiplication gates .",
    "examples : the input n must be greater than 0 : : sage : rafamp(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return t2p(rafamt(n ) )     + similarly obtaining the randomly sample integer which evaluates to the input integer and is uniformly sampled among all formulas which combine addition and multiplication express using the prefix notation we have +    @cached_function def rafampre(n ) : `` '' \" outputs a uniformly randomly sample formula - binary tree written in prefix notation which evaluates to the input integer n using only addition and multiplication gates .",
    "examples : the input n must be greater than 0 : : sage : rafampre(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return t2pre(rafamt(n ) )      we discuss here procedures for producing and enumerating formulas using a combination of fan - in two addition , multiplication and exponentiation gates .",
    "the principles used are very much analogous to those used in the previous section .",
    "we start by formulas rooted at addition gates +    @cached_function def fameta(n ) : `` '' \" the set of formula - binary trees only using addition , multiplication , and exponentiation gates .",
    "the root gate being an addition gate and and the formula evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : fameta(2 ) [ + , 1 , 1 ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return [ 1 ] else : gu = [ ] for i in range(1,n ) : gu = gu + [ [ + , g1 , g2 ] for g1 in famet(i ) for g2 in famet(n - i ) ] return gu     + next we implement procedure for listing formulas rooted at a multiplication gate +    @cached_function def fametm(n ) : `` '' \" the set of formula - binary trees only using addition .",
    "multiplication and exponentiation gates with the top gate being a multiplication gate which evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : fametm(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return [ ] else : gu = [ ] for i in range(2,1+floor(n/2 ) ) : if mod(n , i ) = = 0 : gu = gu + [ [ * , g1 , g2 ] for g1 in famet(i ) for g2 in famet(n / i ) ] return gu     + and finally we list formulas rooted at an exponentiation gates +    @cached_function def famete(n ) : `` '' \" the set of formula - binary trees only using addition .",
    "multiplication and exponentiation gates with the top gate being an exponetiation gate which evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : famete(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n = = 1 : return [ ] else : gu = [ ] for i in range(2,2+floor(log(n)/log(2 ) ) ) : if floor(n^(1/i ) ) = = ceil(n^(1/i ) ) : gu = gu + [ [ ^ , g1 , g2 ] for g1 in famet(i ) for g2 in famet(n^(1/i ) ) ] return gu     + finally combining the three function implemented above we obtain the function which lists all formulas which combine addition , multiplication , and exponentiation gates which evaluate to the input integer .",
    "+    @cached_function def famet(n ) : `` '' \" the set of formula - binary trees only using addition . multiplication and exponentiation gates which evaluates to the input integer n.    examples : the input n must be greater than 0 : : sage : famet(3 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return fameta(n ) + fametm(n ) + famete(n )     + for a more efficient enumeration of the formulas resulting from combination of addition , multiplication and exponentitation gates which evaluate to the input integer we consider here enumerating procedure for formulas rooted at the addition gate : +    @cached_function def camea(n ) : `` '' \" output the size of the set of formulas produced by the procedure famta(n ) .",
    "examples : the input n must be greater than 0 : : sage : camea(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : return sum([came(i)*came(n - i ) for i in range(1,n ) ] )     + then rooted at a multiplication gate +    @cached_function def camem(n ) : `` '' \" output the size of the set of formulas produced by the procedure famta(n ) .",
    "examples : the input n must be greater than 0 : : sage : camm(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : return sum([came(i)*came(n / i ) for i in range(2,1+floor(n/2 ) ) if mod(n , i)==0 ] )     + then rooted at an exponentiation gate +    @cached_function def camee(n ) : `` '' \" output the size of the set of formulas produced by the procedure famta(n ) .",
    "examples : the input n must be greater than 0 : : sage : camee(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return 1 else : return sum([came(i)*came(n^(1/i ) ) for i in range(2,2+floor(log(n)/log(2)))if floor(n^(1/i ) ) = = ceil(n^(1/i ) ) ] )    the enumeration scheme can be described using non - linear recurrence formula expressed earlier and repeated here for the convenience of the reader @xmath48",
    "@xmath49 @xmath50 and @xmath34 so that procedure which enumerate formulas evaluating to the input integer and resulting from finite combination of addition , multiplication and exponentitation gates is implemented bellow +    @cached_function def came(n ) : `` '' \" output the size of the set of formulas produced by the procedure famta(n ) .",
    "examples : the input n must be greater than 0 : : sage : came(6 ) [ [ + , 1 , [ + , 1 , 1 ] ] , [ + , [ + , 1 , 1 ] , 1 ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" return camea(n)+camem(n)+camee(n )     + the code for computing the base of the exponent in the asymptotic formula , when exponentiation gates are not allowed +    def constani(nb_terms , nb_itrs , prec ) : # expressing the truncated series f = sum([cam(n)*x^n for n in range(1,nb_terms ) ] ) g = sum([cam(d)*(f.subs(x=(x^d))-x^d ) for d in range(2,nb_terms ) ] ) g = 1/4-g xk = 1/4.077 for itr in range(nb_itrs ) : xkp1 = realfield(prec)(g.subs(x = xk ) ) xk = xkp1 return realfield(prec)(1/xk )     + the code for computing the base of the exponent in the asymptotic formula , when exponentiation gates are allowed +    def constanii(nb_terms , nb_itrs , prec ) : # expressing the truncated series f = sum([came(n)*x^n for n in range(1,nb_terms ) ] ) g = sum([came(d)*(f.subs(x=(x^d))-x^d ) for d in range(2,nb_terms ) ] ) g = 1/4-g xk = 1/4.131 for itr in range(nb_itrs ) : xkp1 = realfield(prec)(g.subs(x = xk ) ) xk = xkp1 return realfield(prec)(1/xk )     + code for computing the constant factor multiple in the asymptotic formula +    def constaniii(nb_terms , nb_itrs , prec ) : f = sum([cam(n)*x^n for n in range(1,100 ) ] ) g = sum([cam(d)*(f.subs(x=(x^d))-x^d ) for d in range(2,100 ) ] ) g1 = 1/4-g # iteration xk = 1/4.077 for itr in range(20 ) : xkp1 = realfield(100)(g1.subs(x = xk ) ) xk = xkp1 print realfield(100)(1/xk ) # setting the constant rho",
    "r = xk h = x + g g = expand((1 - 4*h)*sum([(x / r)^j for j in range(100 ) ] ) ) l = g.operands ( ) ls = [ ] for i in range(100 ) : ls.append(l[len(l)-i-1 ] ) g = sum(ls ) g1 = sqrt(g.subs(x = x*r ) ) c = -1/2/sqrt(pi ) print n(-g1.subs(x=1)*c/2 ) c = n(-g1.subs(x=1)*c/2 ) # computing the list of ratio for ploting .",
    "rt = [ cam(n)*sqrt(n^3)/(c*(1/r)^n ) for n in range(2,100 ) ] plt = line([(n , n(rt[n ] ) ) for n in range(len(rt ) ) ] ) return [ plt , rt ]",
    "finally we use dynamic programming to determine the shortest monotone formula which evaluates to input integers .",
    "+    @cached_function def shortesttame(n ) : `` '' \" outputs the length and an example of the smallest binary - tree formula using fan - in two addition , multiplication and exponentiation gates .    examples : the input n must be greater than 0 : : sage : shortesttame(6 ) [ 9 , [ * , [ + , 1 , 1 ] , [ + , 1 , [ + , 1 , 1 ] ] ] ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" if n==1 : return [ 1,1 ] else : aluf = [ ] si = 2*n for i in range(1,n ) : t1 = shortesttame(i ) t2 = shortesttame(n - i ) if ( t1[0]+t2[0]+1 ) < si : si = t1[0]+t2[0]+1 if eval(t1[1 ] ) < = eval(t2[1 ] ) : aluf = [ + , t1[1 ] , t2[1 ] ] else : aluf = [ + , t2[1 ] , t1[1 ] ]    for i in range(2,floor(n/2 ) ) : if mod(n , i)==0 : t1 = shortesttame(i ) t2 = shortesttame(n / i ) if ( t1[0]+t2[0]+1 ) < si : si = t1[0]+t2[0]+1 if eval(t1[1 ] ) < = eval(t2[1 ] ) : aluf = [ * , t1[1 ] , t2[1 ] ] else : aluf = [ * , t2[1 ] , t1[1 ] ]    for i in range(2,2+floor(log(n)/log(2 ) ) ) : if floor(n^(1/i ) ) = = ceil(n^(1/i ) ) : t1 = shortesttame(n^(1/i ) ) t2 = shortesttame(i ) if ( t1[0]+t2[0]+1 ) < si : si = t1[0]+t2[0]+1 aluf = [ ^ , t1[1 ] , t2[1 ] ] return [ si , aluf ]    the recurrence formula scheme for determining the minimal formula encoding is given by the following tropicalization of the enumeration recurrence formula @xmath51 and @xmath52",
    "throughout the discussion the special formula @xmath53 occurs often enough to deserve an abbreviation , we shall use here the symbol @xmath54 , incidentally it is immediate that the our formula encoding can be viewed as functions and this fact will of some significance in subsequent discussion . but first as we have introduced our canonical encodings let us describe two natural algorithms for recovering formula encoding for relatively large set of integers . for computing goodstein canonical forms for relatively large set of integers",
    "we consider the following set recurrence defined by @xmath55 @xmath56 note that for @xmath57 , we have @xmath58 the implementation of the recurrence is just as straight forward .",
    "+    def goodstein(number_of_iterations=1 ) : `` '' \" produces the set of symbolic expressions associated with the the first canonical form . in all the expressions the symbolic variable x stands for a short hand notation for the formula ( 1 + 1 ) .",
    ": : sage : goodstein(1 ) [ 1 , x^x , x , x^x + 1 , x + 1 , x^x + x , x^x + x + 1 ]    authors : - edinah k. gnang , maksym radziwill and doron zeilberger    to do : - try to implement faster version of this procedure    `` '' \" # initial condition of initial set n0 = [ 1 , x ]    # main loop performing the iteration for iteration in range(number_of_iterations ) : # implementation of the set recurrence n0 = [ 1 ] + [ x^n for n in n0 ] # initialization of a buffer list n1 # which will store updates to n0 n1 = [ ] for n in set(n0).subsets ( ) : if n.cardinality ( ) > 0 : n1.append(sum(n ) ) n0 = list(n1 ) return n0     + as illustration for the computation @xmath59 one of the major benefit of the goodstein encoding is the fact the additional transformation rule @xmath60 results in the classical algorithms for integer addition , multiplication and exponentiation . in other words the goodstein encoding unifies into a single algorithm the seemingly different decimal algorithms for addition , multiplication and exponentiation , the price we pay for such a convenience is a factor @xmath61 additional space for encoding the integers .",
    "let us illustrate the general principle by recovering the goodstein encoding for the number encoded by the formula @xmath62 the main steps of the sequence of transformations are thus sketch bellow : + @xmath63",
    "second canonical form ( scf ) encoding are derived from the zeta recursion .",
    "@xmath64 @xmath65^{k}2,\\:2^{\\left(^{\\left(k-1\\right)}2 + 1\\right)}\\right]\\cap\\prod_{p\\in\\mathbb{p}_{k}}\\left\\ { 1\\cup p^{\\check{\\mathbb{n}}_{k}\\cap\\left[1,\\log_{p}\\left\\ { 2^{\\left(^{\\left(k-1\\right)}2 + 1\\right)}\\right\\ } \\right]}\\right\\ } \\right)\\ ] ] and @xmath66 is deduced from @xmath67 via completion and hence @xmath68 more generally we have that @xmath692^{\\left(^{k-1}2+t\\right)},\\:2^{\\left(^{k-1}2+t+1\\right)}\\right]\\cap\\prod_{p\\in\\mathbb{p}_{k+1}^{(t)}}\\left\\ { \\left\\ { 1\\right\\ } \\cup p^{\\check{\\mathbb{n}}_{k}\\cap\\left[1,\\log_{p}\\left\\ { 2^{\\left(^{k-1}2+t+1\\right)}\\right\\ } \\right]}\\right\\ } \\right)\\ ] ] quite similarly @xmath70 is deduced from @xmath71 via completion and hence @xmath72 finally @xmath73 the associated rational subset construction @xmath74 is specified by @xmath75 the implementation of the zeta recurrence is therefore given by +    def scf(nbitr ) : # symbol associated with the prime 2 .",
    "x = var(x ) # pr corresponds to the initial list of primes pr = [ x ] # nu corresponds to the initial list of integer nuc = [ 1,x ] ; tnuc = [ 1,x ] # initializing the upper and lower bound upr_bnd = 2 ^ 2 ; lwr_bnd = 2 # computing the set recurrence for itr in range(nbitr ) : for jtr in range(log(upr_bnd,2)-log(lwr_bnd,2 ) ) : tpnu = [ 1 ] for p in pr : tpnu = tpnu+ # keeping the elements within the range of the upper and lower bound nu = [ f for f in tpnu if ( 2^(n(log(lwr_bnd,2))+jtr)<f.subs(x=2 ) and f.subs(x=2)<=2^(n(log(lwr_bnd,2))+jtr+1 ) ) ] print iteration will find +str(2^(n(log(lwr_bnd,2))+jtr+1)-2^(n(log(lwr_bnd,2))+jtr)-len(nu))+ new primes in [ +str(2^(n(log(lwr_bnd,2))+jtr))+ , +str(2^(n(log(lwr_bnd,2))+jtr+1))+] # obtaining the corresponding sorted integer list la = [ f.subs(x=2 ) for f in nu ] ; lb = copy(la ) ; lb.sort ( ) # obtaining the sorting permutation perm = [ ] for i1 in range(len(la ) ) : for i2 in range(len(lb ) ) : if lb[i1]==la[i2 ] : perm.append(i2 ) break # sorting the list using the obtained permutation nu = [ nu[perm[j ] ] for j in range(len(nu ) ) ] # computing the set completion tnuc = tnuc + nu l = len(tnuc ) i = 2^(log(lwr_bnd,2)+jtr)-1",
    "while i < l-1 : if(tnuc[i+1].subs(x=2)-tnuc[i].subs(x=2)==2 ) : pr.append(tnuc[i]+1 ) tnuc.insert(i+1,tnuc[i]+1 ) l = l+1 else : i = i+1 # updating the list of integers nuc = tnuc # updating the upper and lower bound lwr_bnd",
    "= upr_bnd ; upr_bnd = 2^upr_bnd return [ pr , nuc ]     + we deduce from the similarly the code for obtaining scf encodings for rational numbers is provided bellow .",
    "+    def rationalset(pr , nuc ) : # initialization of the rational set quc = [ 1 ] # computing the set for p in pr : quc = quc+[m*pn for m in quc for pn in [ p^n for n in nuc]+ ] return quc     + if our in main interest is however to sieve out only scf encodings of primes , we would consider the following slightly modified zeta recursion @xmath76 @xmath77 such that @xmath78 we consider the sets @xmath79 @xmath80 @xmath81 @xmath82 @xmath81 @xmath83 and hence @xmath84 furthermore we have @xmath85\\cap\\mathbb{n}_{k+1}=\\bigcup_{q\\in\\mathbb{p}_{k}}\\mathbb{n}_{q , k+1}\\ ] ] finally , the set completion of @xmath86 to @xmath87 is obtained by adjoining to the set @xmath86 formula integer encodings of the form @xmath88 , for all unordered pairs @xmath89 of distinct elements of @xmath86",
    "such that @xmath90 the implementation of the modified zeta recursion as discussed above is discussed bellow +    def n_1_k_plus_1(nk , pk , k ) : l = [ ] for q in pk : for n in range(floor(ln(2^(k+1))/ln(q.subs(x=2 ) ) ) , floor(ln(2^(k+2))/ln(q.subs(x=2 ) ) ) ) : l.append(q^nk[n ] ) return l    then we consider procedure bellow which generates a script for constructing composite tower with a given number of factors +    def generate_factor_script(c ) : # creating the string corresponding to the file name filename = n_+str(c)+_kplus1.sage # opening the file f = open(filename,w ) f.write(def n_+str(c)+_k_plus_1(nk , pk , k): ) f.write( l = [ ]  ) # variable storing the spaces sp =  for i in range(c ) : if i<1 : sp = sp+  f.write(sp+for p+str(i)+ in pk: ) sp = sp+  f.write(sp+for n+str(i)+ in range(floor(ln(2^(k+2))/ln(p+str(i)+.subs(x=2)))): ) elif i==c-1 : sp = sp+  f.write(sp+for p+str(i)+ in pk[pk.index(p+str(i-1)+)+1:]: ) sp = sp+  dv =  for d in range(i ) : # string keeping track of the divisors if d = = i-1 : dv = dv+(p+str(i-1)+^nk[n+str(i-1)+]).subs(x=2) else : dv = dv+(p+str(d)+^nk[n+str(d)+]).subs(x=2)* f.write(sp+if floor(ln(2^(k+1)/(+dv+))/ln(p+str(i)+.subs(x=2)))>=0: ) sp = sp+  f.write(sp+for n+str(i)+ in range(floor(ln(2^(k+1)/(+dv+))/ln(p+str(i)+.subs(x=2))),floor(ln(2^(k+2)/(+dv+))/ln(p+str(i)+.subs(x=2)))): ) sp = sp+  mt =  for d in range(c ) : # string keeping track of the symbolic scf expression if d = = c-1 : mt = mt+p+str(c-1)+^nk[n+str(c-1)+] else : mt = mt+p+str(d)+^nk[n+str(d)+]* f.write(sp+l.append(+mt+)return l ) else : sp = sp+  f.write(sp+for p+str(i)+ in pk[pk.index(p+str(i-1)+)+1:]: ) sp = sp+  dv =  for d in range(i ) : # string keeping track of the divisors if d==i-1 : dv = dv+(p+str(i-1)+^nk[n+str(i-1)+]).subs(x=2) else : dv = dv+(p+str(d)+^nk[n+str(d)+]).subs(x=2)* f.write(sp+for n+str(i)+ in range(floor(ln(2^(k+2)/(+dv+))/ln(p+str(i)+.subs(x=2)))): ) # closing the file f.close ( )    then the main procedure which uses the two procedure implemented above is implemented here +    def zetarecursionii(nbitr ) : # defining the symbolic variables x which corresponds # to shorthand notation for ( 1 + 1 ) .",
    "var(x ) # initial conditions for the zeta recursion .",
    "# initial list of primes in scf encoding pi = [ x ] # initial list of expression associated with the scf # integer encoding .",
    "ni = [ 1 ] + pi if nbitr = = 0 : return [ ni , pi , i ] # the first iteration properly starts here i = 0 rb = [ ] rb.append(ni[len(ni)-1 ] ) rb = rb + n_1_k_plus_1(ni , pi , i ) # sorting the obtainted list tmp = [ ] for f in range(2^(i+1),2^(i+2)+1 ) : tmp.append ( [ ] ) for f in rb : tmp[-2^(i+1)+f.subs(x=2)].append(f ) # filling up rb in order rb = [ ] for f in range(len(tmp ) ) : if len(tmp[f ] ) = = 1 : rb.append(tmp[f][0 ] ) else : rb.append(tmp[f-1][0]+1 ) pi.append(tmp[f-1][0]+1 ) ni = list(ni+rb[1 : ] ) if nbitr = = 1 : return [ ni , pi , i ] for i in range(1 , nbitr+1 ) : print iteration number +str(i ) rb = [ ] rb.append(ni[len(ni)-1 ] ) rb = rb + n_1_k_plus_1(ni , pi , i ) # code for going beyound a single prime factors prm = 6 c = 2 while prm < 2^(i+2 ) : generate_factor_script(c ) load(n_+str(c)+_kplus1.sage ) rb = rb + eval(\"n _ # since ironically c indexes the next prime we have prm = prm*integer((pi[c-1]).subs(x=2 ) ) c = c+1 # sorting the obtainted list tmp = [ ] for f in range(2^(i+1),2^(i+2)+1 ) : tmp.append ( [ ] ) for f in rb : tmp[-2^(i+1)+f.subs(x=2)].append(f ) # filling up rb in order rb = [ ] for f in range(len(tmp ) ) : if len(tmp[f ] ) = = 1 : rb.append(tmp[f][0 ] ) else : rb.append(tmp[f-1][0]+1 ) pi.append(tmp[f-1][0]+1 ) ni = list(ni+rb[1 : ] ) return [ ni , pi , i ]    then running the procedure yields the following set of primes +    lp3 = zetarecursionii(3)[1 ]    @xmath91},\\sage{lp3[1]},\\sage{lp3[2]},\\sage{lp3[3]},\\sage{lp3[4]},\\right.\\ ] ] @xmath92},\\sage{lp3[6]},\\sage{lp3[7]},\\sage{lp3[8]},\\sage{lp3[9]},\\ ] ] @xmath93},\\sage{lp3[9]}\\right]\\ ] ] incidentally the number of composites less than @xmath94 with the prime @xmath95 in their tower connected to the root is given by @xmath96 so that we have @xmath97",
    "the encoding that we discuss appears to be just as natural as the goodstein encoding and offers the benefit of yield considerably smaller monotone formula encodings of integers .",
    "the recursive horner encoding also has the advantage that that it can be efficiently deduced from the goodstein endcoding , this is of course not true of the scf .",
    "+    def recursivehorner(nbitr=1 ) : x = var(x ) nk = [ 1 , x , 1+x , x^x ] # initialization of the lists lek = [ x^x ] lok = [ 1+x ] lpk = [ x , x^x ] # main loop computing the encoding for i in range(nbitr ) : # updating the list lekp1 = [ m*n for m in lpk for n in lok ] + [ x^m for m in lek+lok ] lokp1 = [ n+1 for n in lek ] lpkp1 = lpk + [ x^m for m in lek+lok ] # the new replaces the old nk = nk + lekp1+lokp1 lek = lekp1 lok = lokp1 lpk = lpkp1 return nk",
    "this material is based upon work supported by the national science foundation under agreements princeton university prime award no .",
    "ccf-0832797 and sub - contract no . 00001583 .",
    "the author would like to thank the ias for providing excellent working conditions .",
    "the author is also grateful to maksym radziwill for providing the code for the computation of the constants in the asymptotic formula , to doron zeilberger who s s initial maple implementation inspired the current implementation and to carlo sanna for insightful comments and suggestions while preparing this package ."
  ],
  "abstract_text": [
    "<S> the following @xmath0 document accompanies the papers @xcite , available from gnang s websites . </S>",
    "<S> please report bugs to gnang at cs dot rutgers dot edu . </S>",
    "<S> the most current version of the @xmath0 document are available from http://www.cs.rutgers.edu/~gnang[gnangs website ] </S>"
  ]
}