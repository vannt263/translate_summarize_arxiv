{
  "article_text": [
    "_ games played on graphs _ are nowadays a well - studied and well - established model for the computer - aided design of computer systems , as they enable _ automatic synthesis _ of systems that are _ correct - by - construction_. of particular interest are _ quantitative games _ , that allow one to model precisely _ quantitative _ parameters of the system , such as energy consumption . in this setting ,",
    "the game is played by two players on a directed weighted graph , where the edge weights model , for instance , a cost or a reward associated to the moves of the players .",
    "each vertex of the graph belongs to one of the two players who compete by moving a token along the graph edges , thereby forming an infinite path called a _",
    "play_. with each play is associated a real - valued _ payoff _ computed from the sequence of edge weights along the play .",
    "the traditional payoffs that have been considered in the literature include total - payoff  @xcite , mean - payoff  @xcite and discounted - payoff  @xcite . in this quantitative setting",
    ", one player aims at maximising the payoff while the other tries to minimise it .",
    "so one wants to compute , for each player , the best payoff that hecan guarantee from each vertex , and the associated optimal strategies ( i.e. , that guarantee the optimal payoff no matter how the adversary is playing ) .",
    "such quantitative games have been extensively studied in the literature .",
    "their associated decision problems ( _ is the value of a given vertex above a given threshold ?",
    "_ ) are known to be in @xmath0 .",
    "mean - payoff games have arguably been best studied from the algorithmic point of view .",
    "a landmark is zwick and paterson s pseudo - polynomial time ( i.e. , polynomial in the weighted graph when weights are encoded in unary ) algorithm @xcite , using the _ value iteration _ paradigm that consists in computing a sequence of vectors of values that converges towards the optimal values of the vertices .",
    "after a fixed , pseudo - polynomial , number of steps , the computed values are precise enough to deduce the actual values of all vertices .",
    "better pseudo - polynomial time algorithms have later been proposed , e.g. , in @xcite , also achieving sub - exponential expected running time by means of randomisation .    in this paper , we focus on _ total - payoff games_. given an infinite play @xmath1 , we denote by @xmath2 $ ] the prefix of @xmath1 of length @xmath3 , and by @xmath4)$ ] the ( finite ) sum of all edge weights along this prefix .",
    "the _ total - payoff _ of @xmath1 , @xmath5 , is the inferior limit of all those sums , i.e. , @xmath6)$ ] .",
    "compared to mean - payoff ( and discounted - payoff ) games , the literature on total - payoff games is less extensive .",
    "gimbert and zielonka have shown  @xcite that optimal memoryless strategies always exist for both players and the best algorithm to compute the values runs in exponential time @xcite , and consists in iteratively improving strategies .",
    "other related works include _ energy games _ where one player tries to optimise its energy consumption ( computed again as a sum ) , keeping the energy level always above 0 ( which makes difficult to apply techniques solving those games in the case of total - payoff ) ; and a probabilistic variant of total - payoff games , where the weights are restricted to be non - negative @xcite .",
    "yet , we argue that the total - payoff objective is interesting as a _ refinement _ of the mean - payoff . indeed , recall first that the total - payoff is finite if and only if the mean - payoff is null .",
    "then , the computation of the total - payoff enables a finer , two - stage analysis of a game  @xmath7 :    compute the mean payoff @xmath8 ;    subtract @xmath8 from all edge weights , and scale the resulting weights if necessary to obtain integers . at that point ,",
    "one has obtained a new game @xmath9 with null mean - payoff ;    compute @xmath10 to _ quantify the amount of fluctuation around the mean - payoff _ of the original game .",
    "unfortunately , so far , no efficient ( i.e. , pseudo - polynomial time ) algorithms for total - payoff games have been proposed , and straightforward adaptations of zwick and paterson s value iteration algorithm for mean - payoff do not work , as we demonstrate at the end of section  [ sec : quant - games ] . in the present article",
    ", we fill in this gap by introducing the first pseudo - polynomial time algorithm for computing the values in total - payoff games .",
    "our solution is a non - trivial value iteration algorithm that proceeds through nested fixed points ( see algorithm  [ algo : value - iter - tpo ] ) .",
    "a play of a total - payoff game is infinite by essence .",
    "we transform the game so that one of the players ( the minimiser ) must ensure a _",
    "reachability objective _ : we assume that the game ends once this reachability objective has been met .",
    "the intuition behind this transformation , that stems from the use of an inferior limit in the definition of the total - payoff , is as follows : in any play @xmath1 whose total - payoff is _ finite _ , there is a position @xmath11 in the play after which all the partial sums @xmath12)$ ] ( with @xmath13 ) will be larger than or equal to the total - payoff @xmath5 of @xmath1 , and infinitely often both will be equal .",
    "for example , consider the game depicted in  [ fig : tp](a ) , where the maximiser player ( henceforth called @xmath14 ) plays with the round vertices and the minimiser ( @xmath15 ) with the square vertices . for both players ,",
    "the optimal value when playing from @xmath16 is @xmath17 , and the play @xmath18 reaches this value ( i.e. , @xmath19 ) .",
    "moreover , for all @xmath20 : @xmath4){\\geqslant}{\\textnormal{\\textbf{tp}}}(\\pi)$ ] , and infinitely many prefixes ( @xmath21 $ ] , @xmath22 $ ] , @xmath23 $ ] , @xmath24 ) have a total - payoff of @xmath17 , as shown in  [ fig : tp](b ) .",
    "based on this observation , we transform a total - payoff game @xmath7 , into a new game that has _ the same value as the original total - payoff game _ but incorporates a reachability objective for @xmath15 .",
    "intuitively , in this new game , we allow a new action for @xmath15 : after each play prefix @xmath2 $ ] , hecan ask to _ stop the game _ , in which case the payoff of the play is the payoff @xmath4)$ ] of the prefix .",
    "however , allowing @xmath15 to stop the game at any moment would not allow to obtain the same value as in the original total - payoff game : for instance , in the example of  [ fig : tp](a ) , @xmath15 could secure value @xmath25 by asking to stop after @xmath26 $ ] , which is strictly smaller that the actual total - payoff ( @xmath17 ) of the whole play @xmath1 .",
    "so , we allow @xmath14 to _ veto _ to stop the game , in which case both must go on playing . again , allowing @xmath14 to turn down all of @xmath15 s requests would be unfair , so we parametrise the game with a natural number @xmath27 , which is the maximal number of vetoes that @xmath14 can play ( and we denote by @xmath28 the resulting game ) . for the _ play _ depicted in  [ fig : tp](b ) ,",
    "letting @xmath29 is sufficient : trying to obtain a better payoff than the optimal , @xmath15 could request to stop after @xmath30 $ ] , @xmath26 $ ] and @xmath31 $ ] , and @xmath14 can veto these three requests . after that , @xmath14 can safely accept the next request of @xmath15 , since the total payoff of all prefixes @xmath2 $ ] with @xmath32 are larger than or equal to @xmath19 .",
    "our key technical contribution is to show that _ for all total - payoff games , there exists a finite , pseudo - polynomial , value of @xmath27 such that the values in @xmath28 and @xmath7 coincide _ ( assuming all values are finite in @xmath7 : we treat the @xmath33 and @xmath34 values separately ) . now , assume that , when @xmath14 accepts to stop the game ( possibly because hehas exhausted the maximal number @xmath27 of vetoes ) , the game moves to a _ target state _ , and stops . by doing so",
    ", we effectively reduce the computation of the values in the total - payoff game @xmath7 to the computation of the values in the total - payoff game @xmath28 _ with an additional reachability objective _ ( the target state ) for @xmath15 .",
    "( 0 , -0.1 ) ",
    "( 0,4 ) ; ( -0.1,0 )  ( 11,0 ) ; ( 1,0 ) ",
    "( 1,-0.1 ) ; ( 2,0 ) ",
    "( 2,-0.1 ) ; ( 3,0 ) ",
    "( 3,-0.1 ) ; ( 4,0 ) ",
    "( 4,-0.1 ) ; ( 5,0 ) ",
    "( 5,-0.1 ) ; ( 6,0 ) ",
    "( 6,-0.1 ) ; ( 7,0 ) ",
    "( 7,-0.1 ) ; ( 8,0 ) ",
    "( 8,-0.1 ) ; ( 9,0 ) ",
    "( 9,-0.1 ) ; ( 10,0 ) ",
    "( 10,-0.1 ) ;    ( 0,1 ) ",
    "( -0.1,1 ) ; ( 0,2 ) ",
    "( -0.1,2 ) ; ( 0,3 ) ",
    "( -0.1,3 ) ;    ( 0,0 ) ",
    "( 4,2 )  ( 5,3 ) ",
    "( 10,2 ) ; ( 10,2 ) ",
    "( 11,3 ) ; ( 0,2 ) ",
    "( 11,2 ) ; at ( 11,2 ) @xmath35 ;    at ( -0.1,0 ) @xmath36 ; at ( -0.1,1 ) @xmath25 ; ( n ) at ( -0.1,2 ) @xmath17 ; at ( -0.1,3 ) @xmath37 ; at ( 0,4.2 ) @xmath4)$ ] ; at ( 11.3,.7 ) @xmath3 ;    at ( 0,-0.1 ) @xmath36 ; at ( 1,-0.1 ) @xmath25 ; at ( 2,-0.1 ) @xmath17 ; at ( 3,-0.1 ) @xmath37 ; at ( 4,-0.1 ) @xmath38 ; at ( 5,-0.1 ) @xmath39 ; at ( 6,-0.1 ) @xmath40 ; at ( 7,-0.1 ) @xmath41 ; at ( 8,-0.1 ) @xmath42 ; at ( 9,-0.1 ) @xmath43 ; at ( 10,-0.1 ) @xmath44 ;    ;    in the following , such refined total - payoff games  where @xmath15 _ must _ reach a designated target vertex  will be called _",
    "min - cost reachability games_. failing to reach the target vertices is the worst situation for @xmath15 , so the payoff of all plays that do not reach the target is @xmath33 , irrespective of the weights along the play .",
    "otherwise , the payoff of a play is the sum of the weights up to the first occurrence of the target . as such",
    ", this problem nicely generalises the classical shortest path problem in a weighted graph . in the one - player",
    "setting ( considering the point of view of @xmath15 for instance ) , this problem can be solved in polynomial time by dijkstra s and floyd - warshall s algorithms when the weights are non - negative and arbitrary , respectively . in @xcite ,",
    "khachiyan _ et al .",
    "_ propose an extension of dijkstra s algorithm to handle the two - player , non - negative weights case .",
    "however , in our more general setting ( two players , arbitrary weights ) , this problem has , as far as we know , not been studied as such , except that the associated decision problem is known to be in @xmath0@xcite . a pseudo - polynomial time algorithm to solve a very close problem , called the _",
    "longest shortest path problem _ has been introduced by bjrklund and vorobyov @xcite to eventually solve mean - payoff games . however , because of this peculiar context of mean - payoff games , their definition of the length of a path differs from our definition of the payoff and their algorithm can not be easily adapted to solve our min - cost reachability problem .",
    "thus , as a second contribution , we show that a value iteration algorithm enables us to compute in pseudo - polynomial time the values of a min - cost reachability game .",
    "we believe that min - cost reachability games bear their own potential theoretical and practical applications .",
    "those games are discussed in section  [ sec : reachability - objectives ] .",
    "in addition to the pseudo - polynomial time algorithm to compute the values , we show how to compute optimal strategies for both players and characterise them : there is always a memoryless strategy for the maximiser player , but we exhibit an example ( see  [ fig : weighted - game]@xmath45 ) where the minimiser player needs ( finite ) memory .",
    "those results on min - cost reachability games are exploited in section  [ sec : solving - total - payoff ] where we introduce and prove correct our efficient algorithm for total - payoff games .",
    "finally , we briefly present our implementation in section  [ sec : experiments ] , using as a core the numerical model - checker prism .",
    "this allows us to describe some heuristics able to improve the practical performances of our algorithms for total - payoff games and min - cost reachability games on certain subclasses of graphs .",
    "more technical explanations and full proofs may be found in an extended version of this article @xcite .",
    "we denote by @xmath46 the set of integers , and @xmath47 .",
    "the set of vectors indexed by @xmath48 with values in @xmath49 is denoted by @xmath50 .",
    "we let @xmath51 be the pointwise order over @xmath52 , where @xmath53 if and only if @xmath54 for all @xmath55 .",
    "we consider two - player turn - based games on weighted graphs and denote the two _ players _ by @xmath14 and @xmath15 .",
    "a _ weighted graph _ is a tuple @xmath56 where @xmath57 is a finite set of vertices partitioned into the sets @xmath58 and @xmath59 of @xmath14 and @xmath15 respectively , @xmath60 is a set of _ directed edges _ , @xmath61 is the _ weight function _ , associating an integer weight with each edge . in our drawings ,",
    "@xmath14 vertices are depicted by circles ; @xmath15 vertices by boxes . for every vertex @xmath62",
    ", the set of successors of @xmath63 by @xmath64 is denoted by @xmath65 . without loss of generality ,",
    "we assume that every graph is deadlock - free , i.e. , for all vertices  @xmath63 , @xmath66 .",
    "finally , throughout this article , we let @xmath67 be the greatest edge weight ( in absolute value ) in the game graph .",
    "finite play _ is a finite sequence of vertices @xmath68 such that for all @xmath69 , @xmath70 .",
    "play _ is an infinite sequence of vertices @xmath71 such that every finite prefix @xmath72 , denoted by @xmath2 $ ] , is a finite play .",
    "the total - payoff of a finite play @xmath73 is obtained by summing up the weights along @xmath1 , i.e. , @xmath74 . in the following ,",
    "we sometimes rely on the mean - payoff to obtain information about total - payoff objectives .",
    "the _ mean - payoff _ computes the average weight of  @xmath1 , i.e. , if @xmath75 , @xmath76 , and @xmath77 when @xmath78 .",
    "these definitions are lifted to infinite plays as follows .",
    "the total - payoff of a play @xmath1 is given by @xmath79)$ ] .",
    "for the @xmath80 .",
    "the @xmath80 is more natural since we adopt the point of view of the maximiser @xmath14 , hence the @xmath80 is the _ worst _ partial sum seen infinitely often . ] similarly , the mean - payoff of a play @xmath1 is given by @xmath81)$ ] .",
    "a weighted graph equipped with these payoffs is called a _ total - payoff game _ or a _ mean - payoff game _ , respectively .",
    "a _ strategy _ for @xmath14 ( respectively , @xmath15 ) in a game @xmath82 ( with @xmath83 one of the previous payoffs ) , is a mapping @xmath84 ( respectively , @xmath85 ) such that for all sequences @xmath86 with @xmath87 ( respectively , @xmath88 ) , @xmath89 .",
    "a play or finite play @xmath71 conforms to a strategy @xmath90 of @xmath14 ( respectively , @xmath15 ) if for all @xmath3 such that @xmath87 ( respectively , @xmath91 ) , @xmath92)$ ] .",
    "a strategy @xmath90 is _ memoryless _ if for all finite plays @xmath93 , we have @xmath94 for all @xmath63 .",
    "a strategy @xmath90 is said to be _ finite - memory _ if it can be encoded in a deterministic moore machine , @xmath95 , where @xmath96 is a finite set representing the memory of the strategy , with an initial memory content @xmath97 , @xmath98 is a memory - update function , and @xmath99 a decision function such that for every finite play @xmath1 and vertex @xmath63 , @xmath100 where @xmath101 is defined by induction on the length of the finite play @xmath1 as follows : @xmath102 , and @xmath103 .",
    "we say that @xmath104 is the _ size _ of the strategy .    for all strategies @xmath105 and @xmath106 , for all vertices @xmath63 ,",
    "we let @xmath107 be the outcome of @xmath105 and @xmath106 , defined as the unique play conforming to @xmath105 and @xmath106 and starting in  @xmath63 .",
    "naturally , the objective of @xmath14 is to maximise its payoff . in this model of zero - sum game , @xmath15 then wants to minimise the payoff of @xmath14 .",
    "formally , we let @xmath108 and @xmath109 be the respective values of the strategies , defined as ( recall that @xmath83 is either @xmath110 or @xmath111 ) : @xmath112 and @xmath113 . finally , for all vertices @xmath63 , we let @xmath114 and @xmath115 be the _ lower _ and _ upper values _ of @xmath63 respectively . we may easily show that @xmath116 .",
    "we say that strategies @xmath117 of @xmath14 and @xmath118 of @xmath15 are optimal if , for all vertices @xmath63 : @xmath119 and @xmath120 respectively .",
    "we say that a game @xmath7 is _ determined _ if for all vertices  @xmath63 , its lower and upper values are equal . in that case , we write @xmath121 , and refer to it as the _ value _ of  @xmath63 .",
    "if the game is clear from the context , we may drop the index @xmath7 of all previous values .",
    "mean - payoff and total - payoff games are known to be determined , with the existence of optimal memoryless strategies @xcite .",
    "total - payoff games have been mainly considered as a refinement of mean - payoff games  @xcite . indeed , if the mean - payoff value of a game is positive ( respectively , negative ) , its total - payoff value is necessarily @xmath33 ( respectively , @xmath34 ) . when the mean - payoff value is @xmath36 however , the total - payoff is necessarily different from @xmath33 and @xmath34 , hence total - payoff games are particularly useful in this case . deciding whether the total - payoff value of a vertex is positive can be achieved in @xmath0 . in @xcite ,",
    "the complexity is refined to up  @xmath122  co - up , and values are shown to be effectively computable solving nested fixed point equations with a strategy iteration algorithm working in exponential time in the worst case .",
    "our aim is to give a pseudo - polynomial algorithm solving total - payoff games . in many cases , ( e.g. , mean - payoff games ) , a successful way to obtain such an efficient algorithm",
    "is the _ value iteration paradigm_. intuitively , value iteration algorithms compute successive approximations @xmath123 of the game value by restricting the number of turns that the players are allowed to play : @xmath124 is the vector of optimal values achievable when the players play at most @xmath125 turns .",
    "the sequence of values is computed by means of an operator @xmath126 , letting @xmath127 for all @xmath125 .",
    "good properties ( scott - continuity and monotonicity ) of @xmath126 ensure convergence towards its smallest or greatest fixed point ( depending on the value of @xmath128 ) , which , in some cases , happens to be the value of the game .",
    "let us briefly explain why such a simple approach fails with total - payoff games . in our case ,",
    "the operator @xmath126 is such that @xmath129 for all @xmath130 and @xmath131 for all @xmath132 .",
    "this definition matches the intuition that @xmath124 are optimal values after @xmath125 turns .",
    "then , consider the example of  [ fig : tp](a ) , limited to vertices @xmath133 for simplicity . observe that there are two simple cycles with weight  @xmath36 , hence the total - payoff value of this game is finite .",
    "@xmath14 has the choice between cycling into one of these two cycles .",
    "it is easy to check that @xmath14 s optimal choice is to enforce the cycle between @xmath134 and @xmath135 , securing a payoff of @xmath136 from @xmath134 ( because of the @xmath80 definition of @xmath110 ) .",
    "hence , the values of @xmath137 , @xmath138 and @xmath139 are respectively @xmath25 , @xmath136 and  @xmath36 . in this game",
    ", we have @xmath140 , and the vector @xmath141 is indeed a fixed point of  @xmath126 .",
    "however , it is neither the greatest nor the smallest fixed point of @xmath126 , since _ if _ @xmath142 is a fixed point of @xmath126 , _ then _",
    "@xmath143 is also a fixed point , for all constant @xmath144 .",
    "if we try to initialise the value iteration algorithm with value @xmath145 , which could seem a reasonable choice , the sequence of computed vectors is : @xmath145 , @xmath146 , @xmath147 , @xmath146 , @xmath147 , @xmath24 that is not stationary , and does not even contain @xmath141 .",
    "thus , it seems difficult to compute the actual game values with an iterative algorithm relying on the @xmath126 operator , as in the case of mean - payoff games . notice",
    "that , in the previous example , the zwick and paterson s algorithm @xcite to solve mean - payoff games would easily conclude from the sequence above , since the vectors of interest are then the one divided by the length of the current sequence , i.e. , @xmath145 , @xmath148 , @xmath149 , @xmath150 , @xmath151 , @xmath24 indeed converging towards @xmath145 , the mean - payoff values of this game .",
    "( v1 ) ; i//in 2/1/1,3/2/2,4/3/3,5/4/ ( vi ) ; ( v5 ) edge[loop right , dashed , looseness=20 , out=80 , in=0 ] node[right ] @xmath36 ( v5 ) ; ( v1.north )  ( v5.north ) node[midway , yshift=25pt ] total - payoff = @xmath152 ;    ( txt ) mean - payoff = 0 ; ( txt ) edge[gray , bend left ] ( v1 ) ;    instead , as explained in the introduction , we propose a different approach that consists in reducing total - payoff games to min - cost reachability games where @xmath15 must enforce a reachability objective on top of his optimisation objective .",
    "the aim of the next section is to study these games , and we reduce total - payoff games to them in section  [ sec : solving - total - payoff ] .",
    "in this section , we consider _ min - cost reachability games _ ( mcr games for short ) , a variant of total - payoff games where one player has a reachability objective that hemust fulfil first , before optimising his quantitative objective . without loss of generality , we assign the reachability objective to player @xmath15 , as this will make our reduction from total - payoff games easier to explain .",
    "hence , when the target is not reached along a path , its payoff shall be the worst possible for @xmath15 , i.e. , @xmath33 .",
    "formally , an mcr game is played on a weighted graph @xmath56 equipped with a target set of vertices @xmath153 .",
    "the payoff @xmath154(\\pi)$ ] of a play @xmath155 is given by @xmath154(\\pi)=+\\infty$ ] if the play avoids @xmath156 , i.e. , if for all @xmath157 , @xmath158 , and @xmath154(\\pi)={\\textnormal{\\textbf{tp}}}(\\pi[k])$ ] if @xmath3 is the least position in @xmath1 such that @xmath159 .",
    "lower and upper values are then defined as in section  [ sec : quant - games ] . by an indirect consequence of martin s theorem  @xcite , we can show that mcr games are also determined .",
    "optimal strategies may however not exist , as we will see later .    as an example , consider the mcr game played on the weighted graph of  [ fig : weighted - game]@xmath45 , where @xmath160 is a positive integer and @xmath161 is the target .",
    "( 1 ) ; ( 2)[right of=1 ] ; ( 3)[right of=2 ] ;    \\(1 )  ( 0 , -1 )  node[above]@xmath162 ( 4 , -1 )  ( 3 ) ;    \\(1 ) edge[bend left=10 ] node[above]@xmath136 ( 2 ) ( 2 ) edge[bend left=10 ] node[below]@xmath36 ( 1 ) edge node[above]@xmath36 ( 3 ) ( 3 ) edge[loop right ] node[right]@xmath36 ( 3 ) ;    ( ) [ left of=1,node distance=.7 cm ] @xmath45 ;    ( 1 ) ; ( 2)[right of=1 ] ; ( 3)[right of=2 ] ;    \\(1 ) edge node[above]@xmath162 ( 2 ) ( 2 ) edge[loop below ] node[below]@xmath25 ( 2 ) edge node[above]@xmath160 ( 3 ) ( 3 ) edge[loop right ] node[right]@xmath36 ( 3 ) ;    ( ) [ left of=1,node distance=.7 cm ] @xmath163 ;    we claim that the values of vertices @xmath16 and @xmath164 are both @xmath162 .",
    "indeed , consider the following strategy for @xmath15 : during each of the first @xmath160 visits to @xmath164 ( if any ) , go to @xmath16 ; else , go to @xmath161 .",
    "clearly , this strategy ensures that the target will eventually be reached , and that either    edge @xmath165 ( with weight @xmath162 ) will eventually be traversed ; or    edge @xmath166 ( with weight @xmath136 ) will be traversed at least @xmath160 times .",
    "hence , in all plays following this strategy , the payoff will be at most @xmath162 .",
    "this strategy allows @xmath15 to secure @xmath162 , but hecannot ensure a lower payoff , since @xmath14 always has the opportunity to take the edge @xmath165 ( with weight @xmath162 ) instead of cycling between @xmath16 and @xmath164 .",
    "hence , @xmath14 s optimal choice is to follow the edge @xmath165 as soon as @xmath16 is reached , securing a payoff of @xmath162 .",
    "the @xmath15 strategy we have just given is optimal , and there is _ no optimal memoryless strategy _ for @xmath15 .",
    "indeed , always playing @xmath167 does not ensure a payoff @xmath168 ; and , always playing @xmath169 does not guarantee to reach the target , and this strategy has thus value @xmath33 .",
    "let us note that bjrklund and vorobyov introduce in @xcite the _ longest shortest path problem _ ( lsp for short ) and propose a pseudo - polynomial time algorithm to solve it .",
    "however , their definition has several subtle but important differences to ours , such as definition of the payoff of a play ( equivalently , the length of a path ) . as an example , in the game of  [ fig : weighted - game](a ) , the play @xmath170 ( that never reaches the target ) has length @xmath34 in their setting , while , in our setting , @xmath171(\\pi)=+\\infty$ ] .",
    "moreover , even if a pre - treatment would hypothetically allow one to use the lsp algorithm to solve mcr games , our solution is simpler to implement with the same worst - case complexity and heuristics only applicable to our value iteration solution .",
    "we now present our contributions for mcr games :    [ thm : optimal - strategy ] let @xmath172 $ ] be an mcr game .    1 .   for @xmath173 , deciding whether @xmath174 can be done in polynomial time .",
    "2 .   for @xmath173 ,",
    "deciding whether @xmath175 is as hard as mean - payoff , in @xmath0and can be achieved in pseudo - polynomial time .",
    "3 .   if @xmath176 for all vertices @xmath173 , then both players have optimal strategies",
    ". moreover , @xmath14 always has a memoryless optimal strategy , while @xmath15 may require finite ( pseudo - polynomial ) memory in his optimal strategy .",
    "4 .   computing all values @xmath177 ( for @xmath173 ) , as well as optimal strategies ( if they exist ) for both players , can be done in ( pseudo - polynomial ) time @xmath178 .    to prove the first item it suffices to notice that vertices with value @xmath33 are exactly those from which @xmath15 can not reach the target .",
    "therefore the problem reduces to deciding the winner in a classical reachability game , that can be solved in polynomial time  @xcite , using the classical _ attractor _ construction : in vertices of value @xmath33 , @xmath15 may play indifferently , while @xmath14 has an optimal memoryless strategy consisting in avoiding the attractor .    to prove the second item , it suffices first to notice that vertices with value @xmath34 are exactly those with a value @xmath179 in the mean - payoff game played on the same graph . on the other hand",
    ", we can show that any mean - payoff game can be transformed ( in polynomial time ) into an mcr game such that a vertex has value @xmath179 in the mean - payoff game if and only if the value of its corresponding vertex in the mcr game is @xmath34 .",
    "the rest of this section focuses on the proof of the third and fourth items .",
    "we start by explaining how to compute the values in pseudo - polynomial , and we discuss optimal strategies afterward .",
    "@xmath180    [ [ computing - the - values . ] ] computing the values .    from now on ,",
    "we assume , without loss of generality , that there is exactly one target vertex denoted by @xmath181 , and the only outgoing edge from @xmath181 is a self loop with weight @xmath36 : this is reflected by denoting @xmath182 the payoff mapping @xmath183 $ ] . our value iteration algorithm for mcr games is given in  [ algo : value - iteration - rt ] . to establish its correctness , we rely mainly on the operator  @xmath126 , which denotes the function @xmath184 mapping every vector @xmath185 to @xmath186 defined by @xmath187 and @xmath188 more precisely , we are interested in the sequence of iterates @xmath189[fi ] of @xmath126 from the initial vector @xmath128 defined by @xmath190 for all @xmath191 , and @xmath192 .",
    "the intuition behind the sequence @xmath193 is that _",
    "@xmath124 is the value of the game if we impose that @xmath15 must reach the target within @xmath125 steps _ ( and get a payoff of @xmath33 if hefails to do so ) .",
    "formally , for a play @xmath194 , we let @xmath195 if @xmath196 for some @xmath197 , and @xmath198 otherwise",
    ". we further let @xmath199 ( where @xmath105 and @xmath106 are respectively strategies of @xmath14 and @xmath15 ) .",
    "we can show that the operator @xmath126 allows one to compute the sequence @xmath200 , i.e. , for all @xmath201 : @xmath202 .",
    "let us first show that the algorithm is _ correct _ when the values of all nodes are _",
    "finite_. thanks to this characterisation , and by definition of @xmath203 , it is easy to see that , for all @xmath201 : @xmath204 .",
    "moreover , @xmath126 is a monotonic operator over the complete lattice @xmath52 . by knaster - tarski s theorem ,",
    "the fixed points of @xmath126 form a complete lattice and @xmath126 admits a greatest fixed point . by kleene",
    "s fixed point theorem , using the scott - continuity of @xmath126 , this greatest fixed point can be obtained as the limit of the non - increasing sequence of iterates @xmath205 starting in the maximal vector @xmath206 defined by @xmath207 for all @xmath55 . as @xmath208 , the sequence @xmath209 is also non - increasing ( i.e. , @xmath210 , for all @xmath201 ) and converges towards the greatest fixed point of  @xmath126 .",
    "we can further show that the value of the game @xmath211 is actually the greatest fixed point of @xmath126 .",
    "moreover , we can bound the number of steps needed to reach that fixed point ( when all values are finite  this is the point where this hypothesis is crucial ) , by carefully observing the possible vectors that can be computed by the algorithm : the sequence @xmath209 is non - increasing , and stabilises after at most @xmath212 steps on @xmath211 .",
    "thus , computing the sequence @xmath209 up to stabilisation yields the values of all vertices in an mcr game _ if all values are finite_. were it not for line  [ line - infty - rt ] ,  [ algo : value - iteration - rt ] would compute exactly this sequence .",
    "we claim that  [ algo : value - iteration - rt ] is correct even when vertices have values in @xmath213 .",
    "line  [ line - infty - rt ] allows to cope with vertices whose value is @xmath34 : when the algorithm detects that @xmath15 can secure a value small enough from a vertex @xmath63 , it sets @xmath63 s value to @xmath34 .",
    "intuitively , this is correct because if @xmath15 can guarantee a payoff smaller than @xmath214 , hecan force a negative cycle from which hecan reach @xmath181 with an arbitrarily small value .",
    "hence , one can ensure that , after @xmath125 iterations of the loop , @xmath215 , and the sequence still converges to @xmath211 , the greatest fixed point of @xmath126 .",
    "finally , if some vertex @xmath63 has value @xmath33 , one can check that @xmath216 is an invariant of the loop . from that point",
    ", one can prove the correctness of the algorithm .",
    "thus , the algorithm executes @xmath217 iterations .",
    "since each iteration can be performed in @xmath218 , the algorithm has a complexity of @xmath178 , as announced in theorem  [ thm : optimal - strategy ] .",
    "as an example , consider the min - cost reachability game of  [ fig : weighted - game]@xmath45 .",
    "the successive values for vertices @xmath166 ( value of the target @xmath161 is always 0 ) computed by the value iteration algorithm are the following : @xmath219 , @xmath220 , @xmath221 , @xmath222 , @xmath223 , @xmath224 , @xmath225 .",
    "this requires @xmath226 steps to converge ( hence a pseudo - polynomial time ) .",
    "[ [ computing - optimal - strategies - for - both - players . ] ] computing optimal strategies for both players .",
    "we now turn to the proof of the third item of theorem  [ thm : optimal - strategy ] , supposing that every vertex @xmath63 of the game has a finite value @xmath227 ( the case where @xmath174 is delt with the attractor construction ) .",
    "observe first that , @xmath15 may _ need memory _ to play optimally , as already shown by the example in  [ fig : weighted - game]@xmath45 , where the target is @xmath161 .",
    "nevertheless , let us briefly explain why optimal strategies for @xmath15 always exist , with a memory of pseudo - polynomial size .",
    "we extract from the sequence @xmath209 defined above ( or equivalently , from the sequence of vectors @xmath228 of  [ algo : value - iteration - rt ] ) the optimal strategy @xmath118 as follows .",
    "let @xmath3 be the first index such that @xmath229 .",
    "then , for every play @xmath1 ending in vertex @xmath230 , we let @xmath231 , if @xmath232 , and @xmath233 otherwise ( those @xmath234 may not be unique , but we can indifferently pick any of them ) . since @xmath106 only requires to know the last vertex and the length of the prefix up to @xmath3 , and since @xmath235 as explained above , @xmath118 needs a memory of pseudo - polynomial size only .",
    "moreover , it can be computed with the sequence of vectors @xmath228 in  [ algo : value - iteration - rt ] .",
    "it is not difficult to verify by induction that this strategy is optimal for @xmath15 .",
    "while optimal , this strategy might not be practical , for instance , in the framework of controller synthesis . implementing it would require to store the full sequence @xmath209 up to convergence step @xmath3 ( possibly pseudo - polynomial ) in a table , and to query this large table each time the strategy is called",
    ", an alternative optimal strategy @xmath236 can be construct , that consists in playing successively two _",
    "memoryless strategies _ @xmath237 and @xmath238 ( @xmath238 being given by the attractor construction ) .",
    "to determine when to switch from @xmath237 to @xmath238 , @xmath236 maintains a counter that is stored in a _ polynomial _ number of bits , thus the memory footprints of @xmath236 and @xmath118 are comparable .",
    "however , @xmath236 is easier to implement , because @xmath237 and @xmath238 can be described by a pair of tables of linear size , and , apart from querying those tables , @xmath236 consists only in incrementing and testing the counter to determine when to switch .",
    "moreover , this succession of two memoryless strategies allows us to also get some interesting strategy in case of vertices with values @xmath34 : indeed , we can still compute this pair of strategies , and simply modify the switching policy to run for a sufficiently long time to guarantee a value less than a given threshold . in the following ,",
    "we call such a strategy a _ switching strategy_.    finally , we can show that , contrary to @xmath15 , @xmath14 always has a _ memoryless optimal strategy _ @xmath117 defined by @xmath239 for all finite plays @xmath1 ending in @xmath130 .",
    "for example , in the game of  [ fig : weighted - game]@xmath45 , @xmath240 for all @xmath1 , since @xmath241 and @xmath242 .",
    "moreover , the previously described optimal strategies can be computed along the execution of  [ algo : value - iteration - rt ] .",
    "finally , we can show that , for all vertices @xmath63 , the pair of optimal strategies we have just defined yields a play @xmath243 which is _ non - looping _ , i.e. , never visits the same vertex twice before reaching the target .",
    "for instance , still in the game of  [ fig : weighted - game]@xmath45 , @xmath244 .",
    "we now turn our attention back to total - payoff games ( without reachability objective ) , and discuss our main contribution .",
    "building on the results of the previous section , we introduce the _ first _ ( as far as we know ) _ pseudo - polynomial time algorithm _ for solving those games in the presence of arbitrary weights , thanks to a reduction from total - payoff games to min - cost reachability games . the mcr game produced by the reduction",
    "has size pseudo - polynomial in the size of the original total - payoff game .",
    "then , we show how to compute the values of the total - payoff game without building the entire mcr game , and explain how to deduce memoryless optimal strategies from the computation of our algorithm .",
    "[ [ reduction - to - min - cost - reachability - games . ] ] reduction to min - cost reachability games .",
    "we provide a transformation from a total - payoff game @xmath245 $ ] to a min - cost reachability game @xmath28 such that the values of @xmath7 can be extracted from the values in @xmath28 ( as formalised below ) .",
    "intuitively , @xmath28 simulates the game where players play in @xmath7 ; @xmath15 may propose to stop playing and reach a fresh vertex @xmath181 acting as the target ; @xmath14 can then accept , in which case we reach the target , or refuse at most @xmath27 times , in which case the game continues .",
    "structurally , @xmath28 consists of a sequence of copies of @xmath7 along with some new states that we now describe formally .",
    "we let @xmath181 be a fresh vertex , and , for all @xmath246 , we define the min - cost reachability game @xmath247 \\rangle}$ ] where @xmath248 ( respectively , @xmath249 ) consists of @xmath250 copies @xmath251 , with @xmath252 , of each vertex @xmath130 ( respectively , @xmath132 ) and some _ exterior vertices _",
    "@xmath253 for all @xmath55 and @xmath252 ( respectively , _ interior vertices _",
    "@xmath254 for all @xmath55 and @xmath252 ) .",
    "moreover , @xmath248 contains the fresh target vertex @xmath181 .",
    "edges are given by @xmath255 all edge weights are zero , except edges @xmath256 that have weight @xmath257 .    for example , considering the weighted graph of  [ fig : weighted - game]@xmath45 , the corresponding reachability total - payoff game @xmath258 is depicted in  [ figureextpmcr ] ( where weights @xmath36 have been removed ) .",
    "the next proposition formalises the relationship between the two games .",
    "[ truetp2mcr ] let @xmath259 . for all @xmath62 and @xmath260 ,    * @xmath261 if and only if @xmath262 ; * @xmath263 if and only if @xmath264 .",
    "the bound @xmath27 is found by using the fact ( informally described in the previous section ) that if not infinite , the value of a min - cost reachability game belongs in @xmath265 $ ] , and that after enough visits of the same vertex , an adequate loop ensures that @xmath266 verifies the above properties .",
    "[ [ value - iteration - algorithm - for - total - payoff - games . ] ] value iteration algorithm for total - payoff games .    by proposition",
    "[ truetp2mcr ] , an immediate way to obtain a value iteration algorithm for total - payoff games is to build game @xmath28 , run  [ algo : value - iteration - rt ] on it , and map the computed values back to @xmath7 . we take advantage of the structure of @xmath28 to provide a better algorithm that avoids building @xmath28 .",
    "we first compute the values of the vertices in the _ last copy of the game _ ( vertices of the form @xmath267 , @xmath268 and @xmath269 ) , then of those in the penultimate ( vertices of the form @xmath270 , @xmath271 and @xmath272 ) , and so on .",
    "\\(a ) at ( 0,0 ) ; ( inta ) at ( 1,1)@xmath273 ; ( b ) at ( 2,0 ) ; ( intb ) at ( 1,-1)@xmath274 ; ( tg ) at ( 4,-1 ) ; ( c ) at ( 1,-2 ) ; ( intc ) at ( 1,-3)@xmath275 ; ( a ) to node[above right]@xmath136 ( intb ) ; ( b ) to ( inta ) ; ( a ) to[bend right ] node[midway , left]@xmath162 ( intc.north west ) ; ( b ) to[bend left ] ( intc.north east ) ; ( c ) to[bend right ] ( intc ) ; ( inta ) to ( a ) ; ( intb ) to ( b ) ; ( intc ) to[bend right ] ( c ) ; ( intb ) ",
    "node[midway , below]@xmath276(tg ) ; ( inta ) ",
    "node[midway , below ] @xmath277 ( 4,1 ) ",
    "( tg ) ; ( intc ) ",
    "node[midway , above]@xmath278 ( 4,-3 )  ( tg ) ;    we formalise this idea as follows .",
    "let @xmath279 be a vector mapping each vertex @xmath63 of @xmath7 to the value @xmath280 of vertex @xmath251 in @xmath28 .",
    "then , let us define an operator @xmath281 such that @xmath282 . the intuition behind the definition of @xmath283 for some vector @xmath284 , is to extract from @xmath28 one copy of the game , and make @xmath284 appear in the weights of some edges as illustrated in  [ fig : gamex ] .",
    "this game , @xmath285 , [ gy ] simulates a play in @xmath7 in which @xmath15 can opt for ` leaving the game ' at each round ( by moving to the target ) , obtaining @xmath286 , if @xmath63 is the current vertex .",
    "then @xmath287 is defined as the value of @xmath63 in @xmath285 . by construction , it is easy to see that @xmath282 holds for all @xmath288 .",
    "furthermore , we define @xmath289 for all @xmath63 , and have @xmath290 .",
    "one can prove the following properties of @xmath281 :    @xmath281 is monotonic , but may not be scott - continuous ;    the sequence @xmath291 converges towards @xmath292 .",
    "we are now ready to introduce  [ algo : value - iter - tpo ] to solve total - payoff games .",
    "intuitively , the outer loop computes , in variable @xmath293 , a non - decreasing sequence of vectors whose limit is @xmath292 , and that is stationary ( this is not necessarily the case for the sequence @xmath291 ) . line  [ line : tpo - init ] initialises @xmath293 to @xmath294 . each iteration of the outer loop amounts to running  [ algo : value - iteration - rt ] to compute @xmath295 ( lines  [ line : begin ] to  [ line : end ] ) , then detecting if some vertices have value @xmath33 , updating @xmath293 accordingly ( line  [ line:3-line - infty ] , following the second item of proposition  [ truetp2mcr ] ) .",
    "one can show that , for all @xmath296 , if we let @xmath297 be the value of @xmath293 after the @xmath298-th iteration of the main loop , @xmath299 , which ensures the correctness of the algorithm .",
    "[ line : tpo - init ]    [ thm : vi - tp ] if a total - payoff game @xmath245 $ ] is given as input ,  [ algo : value - iter - tpo ] outputs the vector @xmath292 of optimal values , after at most @xmath300 iterations of the external loop . the complexity of the algorithm is @xmath301 .",
    "the number of iterations in each internal loop is controlled by theorem  [ thm : optimal - strategy ] .",
    "on the example of  [ fig : weighted - game]@xmath45 , only 2 external iterations are necessary , but the number of iterations of each internal loop would be @xmath226 . by contrast , for the total - payoff game depicted in  [ fig : weighted - game]@xmath163 , each internal loop requires 2 iterations to converge , but the external loop takes @xmath160 iterations to stabilise . a combination of both examples would experience a pseudo - polynomial number of iterations to converge in both the internal and external loops , matching the @xmath302 term of the above complexity .    [ [ optimal - strategies . ] ] optimal strategies .    in section  [ sec : reachability - objectives ]",
    ", we have shown , for any min - cost reachability game , the existence of a pair of memoryless strategies permitting to reconstruct a _ switching _ optimal strategy for @xmath15 ( if every vertex has value different from @xmath34 , or a strategy ensuring any possible threshold for vertices with value @xmath34 ) .",
    "if we apply this construction to the game @xmath303 , we obtain a pair @xmath304 of strategies ( remember that @xmath238 is a strategy obtained by the attractor construction , hence it will not be useful for us for total - payoff games ) . consider the strategy @xmath305 , obtained by projecting @xmath237 on @xmath48 as follows : for all finite plays @xmath1 and vertex @xmath230 , let @xmath306 if @xmath307 .",
    "we can show that @xmath305 is optimal for @xmath15 in @xmath7 .",
    "notice that @xmath237 , and hence @xmath305 , can be computed during the last iteration of the value iteration algorithm , as explained in the case of min - cost reachability .",
    "a similar construction can be done to compute an optimal strategy of @xmath14 .",
    "in this section , we report on a prototype implementation of our algorithms . for convenience reasons , we have implemented them as an add - on to prism - games @xcite , although we could have chosen to extend another model - checker as we do not rely on the probabilistic features of prism models ( i.e. , we use the prism syntax of _ stochastic multi - player games _ , allowing arbitrary rewards , and forbidding probability distributions different of dirac ones ) .",
    "we then use rpatl specifications of the form @xmath308 $ ] and @xmath309 $ ] to model respectively min - cost reachability games and total - payoff games , where @xmath310 represents a coalition of players that want to minimise / maximise the payoff , and @xmath311 is another rpatl formula describing the target set of vertices ( for total - payoff games , such a formula is not necessary ) .",
    "we have tested our implementation on toy examples . on the parametric one studied after theorem  [ thm : vi - tp ] , obtained by mixing the graphs of  [ fig : weighted - game ] and repeating them for @xmath250 layers , results obtained by applying our algorithm for total - payoff games are summarised in table  [ table : res ] , where for each pair @xmath312 , we give the time @xmath313 in seconds , the number @xmath314 of iterations in the external loop , and the total number @xmath315 of iterations in the internal loop .",
    "we close this section by sketching two techniques that can be used to speed up the computation of the fixed point in  [ algo : value - iteration - rt ] and [ algo : value - iter - tpo ] .",
    "we fix a weighted graph @xmath56 .",
    "both accelerations rely on a topological order of the strongly connected components ( scc for short ) of the graph , given as a function @xmath316 , mapping each vertex to its _ component _ , verifying that    @xmath317 for some @xmath318 ,    @xmath319 is a maximal scc for all @xmath320 ,    and @xmath321 for all @xmath322 .    in case of an mrc game with @xmath181 the unique target , @xmath323 .",
    "intuitively , @xmath324 induces a directed acyclic graph whose vertices are the sets @xmath319 for all @xmath325 , and with an edge @xmath326 if and only if there are @xmath327 such that @xmath328 .    the _ first acceleration heuristic _ is a divide - and - conquer technique that consists in applying  [ algo : value - iteration - rt ] ( or the inner loop of  [ algo : value - iter - tpo ] ) iteratively on each @xmath319 for @xmath329 , using at each step the information computed during steps @xmath330 ( since the value of a vertex @xmath63 depends only on the values of the vertices @xmath331 such that @xmath332 ) .",
    "the _ second acceleration heuristic _ consists in studying more precisely each component @xmath319 .",
    "having already computed the optimal values @xmath177 of vertices @xmath333 , we ask an oracle to precompute a finite set @xmath334 of possible optimal values for each vertex @xmath335 . for mcr games and the inner iteration of the algorithm for total - payoff games , one way to construct such a set @xmath336 is to consider that possible optimal values are the one of non - looping paths inside the component exiting it , since , in mcr games , there exist optimal strategies for both players whose outcome is a non - looping path ( see section  [ sec : reachability - objectives ] )",
    ".    we can identify classes of weighted graphs for which there exists an oracle that runs in polynomial time and returns , for all vertices  @xmath63 , a set @xmath336 of polynomial size . on such classes ,  [ algo : value - iteration - rt ] and",
    "[ algo : value - iter - tpo ] , enhanced with our two acceleration techniques , _ run in polynomial time_. for instance , for all fixed positive integers @xmath337 , the class of weighted graphs where every component @xmath319 uses at most @xmath337 distinct weights ( that can be arbitrarily large in absolute value ) satisfies this criterion .",
    "table  [ table : res ] contains the results obtained with the heuristics on the parametric example presented before .",
    "observe that the acceleration technique permits here to decrease drastically the execution time , the number of iterations in both loops depending not even anymore on @xmath160 .",
    "even though the number of iterations in the external loop increases with heuristics , due to the decomposition , less computation is required in each internal loop since we only apply the computation for the active component",
    ".    10    henrik bjrklund and sergei vorobyov .",
    "a combinatorial strongly subexponential strategy improvement algorithm for mean payoff games .",
    ", 155:210229 , 2007 .",
    "thomas brihaye , gilles geeraerts , axel haddad , and benjamin monmege . to reach or not to reach ?",
    "efficient algorithms for total - payoff games .",
    "research report 1407.5030 , arxiv , july 2014 .",
    "thomas brihaye , gilles geeraerts , shankara  narayanan krishna , lakshmi manasa , benjamin monmege , and ashutosh trivedi .",
    "adding negative prices to priced timed games . in _ proceedings of the 25th international conference on concurrency theory ( concur14 ) _ , volume 8704 of _ lecture notes in computer science _ ,",
    "pages 560575 .",
    "springer , 2014 .",
    "lubo brim , jakub chaloupka , laurent doyen , rafaella gentilini , and jean - franois raskin .",
    "faster algorithms for mean - payoff games . , 38(2):97118 , 2011 .",
    "taolue chen , vojtch forejt , marta kwiatkowska , david parker , and aistis simaitis .",
    "automatic verification of competitive stochastic systems .",
    ", 43(1):6192 , 2013 .",
    "carlo comin and romeo rizzi .",
    "an improved pseudo - polynomial upper bound for the value problem and optimal strategy synthesis in mean payoff games .",
    "technical report 1503.04426 , arxiv , 2015 .",
    "andrzej ehrenfeucht and jan mycielski .",
    "positional strategies for mean payoff games .",
    ", 8(2):109113 , 1979 .",
    "emmanuel filiot , rafaella gentilini , and jean - franois raskin .",
    "quantitative languages defined by functional automata . in _ proceedings of the 23rd international conference on concurrency theory ( concur12 ) _ , volume 7454 of _ lecture notes in computer science _ , pages 132146 .",
    "springer , 2012 .    thomas  martin gawlitza and helmut seidl",
    ". games through nested fixpoints . in _ proceedings of the 21st international conference on computer aided verification ( cav09 ) _ , volume 5643 of _ lecture notes in computer science _ , pages 291305 .",
    "springer , 2009 .",
    "hugo gimbert and wiesaw zielonka .",
    "when can you play positionally ? in _ proceedings of the 29th international conference on mathematical foundations of computer science ( mfcs04 ) _ , volume 3153 of _ lecture notes in computer science _ , pages 686698 .",
    "springer , 2004 .",
    "leonid khachiyan , endre boros , konrad borys , khaled elbassioni , vladimir gurvich , gabor rudolf , and jihui zhao . on short paths interdiction problems : total and node - wise limited interdiction .",
    ", 43:204233 , 2008 .",
    "donald  a. martin .",
    "borel determinacy . , 102(2):363371 , 1975 .",
    "martin  l. puterman . .",
    "john wiley & sons , inc .",
    ", new york , ny , 1994 .",
    "ralph  e. strauch .",
    "negative dynamic programming . , 37:871890 , 1966 .",
    "robert  e. tarjan .",
    "depth first search and linear graph algorithms .",
    ", 1(2):146160 , 1972 .    wolfgang thomas .",
    "on the synthesis of strategies in infinite games . in _",
    "symposium on theoretical aspects of computer science ( stacs95 ) _ , volume 900 of _ lecture notes in computer science _ , pages 113 .",
    "springer , 1995 .",
    "uri zwick and michael  s. paterson .",
    "the complexity of mean payoff games .",
    ", 158:343359 , 1996 .",
    "[ endofarticle ]",
    "consider a quantitative game @xmath82 and a vertex @xmath62 . we will prove the determinacy result by using the borel determinacy result of @xcite . indeed , for an integer @xmath96 ,",
    "consider @xmath338 to be the set of infinite plays with a payoff less than or equal to @xmath96 .",
    "payoff mapping @xmath154 $ ] is easily shown to be borel measurable since the set of plays with finite payoff is then a countable union of open sets of plays . for @xmath110 , it is shown by considering a pointwise limit of borel measurable functions . therefore , for payoff @xmath83 representing total - payoff and min - cost reachability , we know that @xmath338 is a borel set , so that the qualitative game defined over the graph @xmath56 with winning condition @xmath338 is determined .",
    "we now use this preliminary result to show our determinacy result .",
    "we first consider cases where lower or upper values are infinite .",
    "suppose first that @xmath339 .",
    "we have to show that @xmath340 too .",
    "let @xmath96 be an integer . from @xmath341",
    ", we know that for all strategy @xmath105 of @xmath14 , there exists a strategy @xmath106 for @xmath15 , such that @xmath342 . in particular , @xmath14 has no winning strategy in the qualitative game equipped with @xmath338 as a winning condition . by the previous determinacy result ,",
    "we know that @xmath15 has a winning strategy in that case , i.e. , a strategy @xmath106 such that every strategy @xmath105 of @xmath14 verifies @xmath342 .",
    "this exactly means that @xmath343 .",
    "since this holds for every value @xmath96 , we get that @xmath340 .",
    "the proof goes exactly in a symetrical way to show that @xmath344 implies @xmath345 .",
    "consider then the case where both @xmath346 and @xmath347 are finite values .",
    "suppose that @xmath348 and consider a real number @xmath349 strictly in - between those two values . from @xmath350 , we deduce that @xmath15 has no winning strategy from @xmath63 in the qualitative game with winning condition @xmath351 .",
    "identically , from @xmath352 , we deduce that @xmath14 has no winning strategy from @xmath63 in the same game .",
    "this contradicts the determinacy of this qualitative game .",
    "hence , @xmath353 .",
    "consider the example of fig .  [ fig : strategy - counter - example ] , composed of three vertices of @xmath14 .",
    "there are two simple cycles with weight  @xmath36 , so that we know that the total - payoff value of this game is finite .",
    "indeed , @xmath14 has the choice between cycling into one of these two cycles . from the middle vertex @xmath164 ,",
    "looping to the right leads to the value @xmath136 ( because of the @xmath80 definition of the payoff of a play ) , and looping to the left leads to the value @xmath354 .",
    "hence , looping to the right is preferable and the value of @xmath164 is @xmath136 .",
    "we deduce that the value of @xmath16 is @xmath25 and of @xmath161 is @xmath36 .",
    "in this specific case where only @xmath14 vertices exist , a value iteration algorithm would then consist of iterating the following operator from @xmath52 to @xmath52 , defined for all @xmath185 and @xmath55 by @xmath355 i.e. , here , @xmath356 .",
    "operator @xmath126 is monotonous , so that knaster - tarski theorem ensures that fixed points form a non - empty lattice . since @xmath357 ,",
    "the vector of values of the game is one of these fixed points .",
    "however , notice that if @xmath142 is a fixed point of @xmath126 , @xmath358 is also a fixed point , for all constant @xmath144 .",
    "hence , @xmath141 is neither the greatest nor the smallest fixed point , and it seems difficult to find it with an iterative algorithm . if we try to initialise the value iteration algorithm with value @xmath145 , which could seem a reasonable choice , we then obtain the following sequence : @xmath145 , @xmath146 , @xmath147 , @xmath146 , @xmath147  that is not even stationary , and does not meet the sought value .",
    "( 1)@xmath164 ; ( 2)[left of=1]@xmath16 ; ( 3)[right of=1]@xmath161 ;    \\(1 ) edge[bend right=10 ] node[above]@xmath354 ( 2 ) edge[bend left=10 ] node[above]@xmath136 ( 3 ) ( 2 ) edge[bend right=10 ] node[below]@xmath17 ( 1 ) ( 3 ) edge[bend left=10 ] node[below]@xmath25 ( 1 ) ;",
    "bjrklund and vorobyov have studied games related to our min - cost reachability games , as the longest shortest path problem ( lsp for short ) in @xcite . to clarify the following discussion ,",
    "let us recall the definition of lsp , adapted to our syntax .",
    "the lsp problem considers a weighted graph @xmath7 , whose vertices are partitioned into two players , and equipped with a single target vertex @xmath181 . the problem asks to find a _",
    "memoryless _ strategy @xmath105 of @xmath14 such that in the graph @xmath359 , obtained from @xmath7 by deleting all outgoing edges from vertices of @xmath58 except those selected in @xmath105 , the length of the shortest path from every vertex to the target @xmath181 is as large as possible ( over all memoryless strategies ) .",
    "the definition of paths from a vertex @xmath63 to the target is , however , very different from ours : such a path may indeed be a finite play , without cycle , from @xmath63 to the target @xmath181 ( in which case its length is the sum of the weights of edges ) .",
    "however , any cycle containing @xmath63 ( even if it can not reach the target ) is also considered as a path to the target . the _ length _ of such cycle is defined as follows :    1 .",
    "if the cycle has a negative weight , its length is @xmath34 ; 2 .",
    "else , if it has a positive weight , its length is @xmath33 ; 3 .   else ,",
    "if it has zero weight , its length is @xmath36 .",
    "consider , as an example , the weighted graph of fig .",
    "[ fig : lsp ] , where , once again , @xmath14 vertices are depicted with circles . clearly , vertices @xmath360 and @xmath361 form independant subgames .",
    "we first consider the status of @xmath16 , @xmath164 and @xmath161 . in this subgame",
    ", @xmath14 has two possible strategies : @xmath362 that selects the @xmath166 edge , or @xmath363 that selects the @xmath165 edge instead .    1 .",
    "if we select @xmath362 , we obtain the following values for @xmath16 , @xmath164 and @xmath161 respectively : @xmath36 , @xmath36 and @xmath25 .",
    "indeed , from vertex @xmath164 , we can loop in the zero cycle in - between @xmath16 and @xmath164 , which is better than the simple path to the target ( having weight 3 ) , so that the distance from @xmath16 and @xmath164 is @xmath36 . from vertex @xmath161",
    ", only a single path leads to the target with weight @xmath25 .",
    "if we select @xmath363 , we obtain the following values for @xmath16 , @xmath164 and @xmath161 respectively : @xmath25 , @xmath37 and @xmath25 .",
    "indeed , from vertex @xmath161 , the distance is the length of the simple path to the target , which is better than looping in - between @xmath16 and @xmath161 with a positive weight cycle .",
    "hence , from vertex @xmath16 , the distance is @xmath25 too , whereas from @xmath164 , the distance is @xmath37 .",
    "now , let us turn our attention to @xmath134 .",
    "again , we must consider two strategies : strategy @xmath364 selects the @xmath365 edge ( the self - loop on @xmath134 ) and strategy @xmath366 selects the @xmath367 edge .    1 .",
    "if we select @xmath364 , we obtain value @xmath34 for @xmath134 , because all plays starting in @xmath134 loop in this negatively priced cycle .",
    "recall that with our definition of min - cost reachability , such a cycle that never reaches the target would yield a total - payoff of @xmath33 , regardless of the weights .",
    "this is coherent with our intuition that the first goal of @xmath15 is to reach the target .",
    "if we select @xmath366 , the value of @xmath134 is now @xmath36 , which is thus better for @xmath14 .    finally , the optimal strategy for @xmath14 is to choose edges @xmath165 and @xmath367 , leading to the lsp distances @xmath368 for vertices @xmath369 . with our definition of min - cost reachability game ,",
    "the situation is _ completely different _ : the value vector is then @xmath370 , associated with the optimal strategy @xmath105 selecting edges @xmath166 and @xmath365",
    ".    indeed , two main differences separate our two definitions .",
    "the first one is the treatment of negative weight cycles .",
    "actually , in lsp , the fact that after selecting strategy @xmath105 a vertex can not reach the target anymore in @xmath359 does not prevent from mapping the distance @xmath34 to a vertex contained in a negative cycle .",
    "this is in contrast with our definition , that would benefit to @xmath14 since in such a situation , the target is not reachable leading to the value @xmath33 .",
    "presented in the first item of theorem  [ thm : optimal - strategy ] . ]",
    "the second difference consists in the treatment of zero weight cycle . in lsp , a distance zero is then computed , which is highly related with the fact that the authors want to apply the resolution of lsp to mean - payoff games .",
    "( 1 ) ; ( 2)[above right of=1,yshift=-.7 cm ] ; ( 3)[below right of=1,yshift=.7 cm ] ; ( 4)[right of=2 ] ; ( tg)[right of=3 ] ;    \\(1 ) edge[bend left=20 ] node[above left]@xmath136 ( 2 ) edge[bend right=20 ] node[below left]@xmath36 ( 3 ) ( 2 ) edge node[below right]@xmath25 ( 1 ) edge node[above right]@xmath37 ( tg ) ( 3 ) edge node[above right]@xmath25 ( 1 ) edge node[above]@xmath25 ( tg ) ( 4 ) edge[loop right ] node[right]@xmath136 ( 4 ) edge node[right]@xmath36 ( tg ) ( tg ) edge[loop right ] node[right]@xmath36 ( tg ) ;    nevertheless , in section 9 of @xcite , the authors _ briefly _ study another more natural definition , mapping zero weight cycle to the distance @xmath33 ( closer to our definition ) . in that case , the lsp distances of vertices @xmath16 , @xmath164 and @xmath161 then match our value vector in min - cost reachability games . unfortunately , it is not clear how the algorithm that is presented by bjrklund and vorobyov can be adapted to accomodate this new definition of the cost and compute the values of the nodes . indeed",
    ", proposition  9.1 of @xcite proves that the decision version of the lsp ( i.e. , deciding if the lsp of a vertex is positive or not in a given graph ) is in @xmath0 , and they claim ( without formal proof ) that their pseudo - polynomial time algorithm permits to decide this problem .",
    "this requires a first transformation of the problem , so that no zero weight cycles remain in the weighted graph .",
    "this transformation , explained above proposition  9.1 , is correct but _ does not preserve the lsp of the vertices _ , so that their algorithm do not compute the lsp distance of vertices , but only study their positivity .",
    "hence , the comparison between our definition of min - cost reachability and the definition of lsp can be summarised as follows :    1 .",
    "either one relies on the first definition of lsp given in the paper . in this case ,",
    "bjrklund and vorobyov propose a pseudo - polynomial time algorithm to compute the lsp , but these values _ do not match our definition of the min - cost reachability _",
    "payoff , as demonstrated by the above example .",
    "2 .   or one relies on the second definition . in this case , we believe that the lsp values may match our definition of min - cost reachability but the paper _ does not explain formally how to compute those new values_.    it is plausible that the pseudo - polynomial time algorithm of bjrklund and vorobyov could be adapted to compute the lsp value according to the second definition . yet ,",
    "even in this case , there are several points of comparison worth mentioning :    1 .",
    "the worst - case complexity of the algorithm proposed by bjrklund and vorobyov is @xmath371 , which matches ours ( see proposition  [ the : rtpo - ca - marche - youpi ] ) .",
    "nevertheless , our solution is much easier to describe and to implement : while they must make repeated calls to a modified version of the bellman - ford algorithm ( the modification is crucial to obtain their complexity ) , we have a simple fixed point algorithm .",
    "our algorithm exploits the value iteration paradigm ( that can be seen as a _",
    "backward induction _ ) , while theirs is a _ strategy iteration algorithm_. because of that , there are examples on which our algorithm is more efficient that theirs ( although the worst - case complexity is the same ) . as an example , the lsp instance presented in fig .",
    "2 of @xcite , with @xmath372 vertices but a biggest weight @xmath160 exponential in @xmath250 , requires an exponential number @xmath373 of iterations for the strategy iteration algorithm , but our value iteration algorithm ( based on backward induction ) would solve it in linear time with respect to @xmath250 .",
    "more precisely , with our tool , we are able to compute the values of this game in less than a millisecond for constant @xmath374 ( i.e. , a game with @xmath375 vertices and largest weight @xmath376 ) : the value of the initial state obtained is @xmath377 , and as aforementioned , the number of iterations that our value iteration requires is @xmath378 , linear in @xmath250 .",
    "our tool being an add - on of the prism model - checker , relying on the use of integer rewards , we have not been able to build the game for a value @xmath250 greater than @xmath379 .",
    "3 .   we propose several acceleration heuristics that perform well on several examples we have tried .",
    "these accelerations can not easily be incorporated in their algorithm ( because it is a strategy iteration algorithm ) .",
    "4 .   finally , from the theoretical point of view , bjrklund and vorobyov do not study the strategies of the opponent player @xmath15 .",
    "in contrast , our study allows us to produce optimal strategies for both players , and in particular , show that memoryless strategies may not be sufficient for @xmath15 , whereas they are enough for @xmath14 .",
    "let @xmath380 $ ] be a min - cost reachability game . notice that for all plays @xmath381 , @xmath154(\\pi)=+\\infty$ ] if and only if @xmath382 for all @xmath157 , i.e. , @xmath1 avoids the target .",
    "then , let us show that the classical attractor technique @xcite allows us to compute the set @xmath383 . recall that the attractor of a set @xmath156 of vertices is obtained thanks to the sequence @xmath384 where : @xmath385 ; and for all @xmath201 : @xmath386 it is well - known that this sequence converges after at most @xmath387 steps to the set @xmath388 of all vertices from which @xmath15 has a memoryless strategy to ensure reaching @xmath156 .",
    "hence , under our hypothesis , @xmath389 .",
    "this proves the first item of theorem  [ thm : optimal - strategy ] .",
    "we give here the proof of the following aiming at computing the set @xmath390 of vertices with a value @xmath34 in a min - cost reachability game @xmath172 $ ] , from which we suppose that there is no more vertices with value @xmath33 .",
    "[ prop : from - wg - to - mp - and - vice - versa ] for all mcr game @xmath391 $ ] , for all vertices @xmath63 of @xmath7 , @xmath392 if and only if @xmath393 , where @xmath9 is the mean - payoff game @xmath394 $ ] .",
    "conversely , given a mean - payoff game @xmath395 $ ] , we can build , in polynomial time , an mcr game @xmath9 such that for all vertices @xmath63 of @xmath7 : @xmath396 if and",
    "only if @xmath397 .    consider first a min - cost reachability game @xmath172 $ ] such that @xmath398 for all @xmath62 , and @xmath399 $ ] the same weighted graph equipped of a mean - payoff objective .    if @xmath393 , the outcome starting in @xmath63 and following a profile @xmath400 of optimal memoryless strategies necessarily starts with a finite prefix and then loops in a cycle with a total weight less than @xmath36 .",
    "for every @xmath401 , we construct a strategy @xmath106 that ensures in @xmath7 a cost less than or equal to @xmath402 : this will prove that @xmath392 .",
    "since in every vertex of @xmath9 , @xmath15 has a strategy in @xmath7 to reach the final vertices ( otherwise there would exist a vertex with value @xmath33 ) , there exists @xmath403 such that @xmath15 can reach from any vertex of @xmath9 the target with a cost at most @xmath403 .",
    "the strategy @xmath106 of @xmath15 is then to follow @xmath118 until the accumulated cost is less than @xmath404 ( which we can prove will happen ) , at which point it follows its strategy to reach the target .",
    "reciprocally , if @xmath392 , consider @xmath405 and a strategy @xmath406 of @xmath15 ensuring a cost less than @xmath402 , i.e. , such that @xmath407 .",
    "consider the finitely - branching tree built from @xmath7 by unfolding the game from vertex @xmath63 and resolving the choices of @xmath15 with strategy @xmath406 .",
    "each branch of this tree corresponds to a possible strategy of @xmath14 .",
    "since this strategy generates a finite cost , we are certain that every such branch leads to a vertex of @xmath156 .",
    "if we trim the tree at those vertices , we finally obtain a finite tree .",
    "now , for a contradiction , suppose the optimal memoryless strategy @xmath117 of @xmath14 ensures a non - negative mean - payoff , that is , @xmath408 .",
    "consider the branch of the previous tree where @xmath14 follows strategy @xmath117 . since this finite branch has cost less than @xmath409",
    ", we know for sure that there is two occurrences of the same vertex @xmath331 with an in - between weight less than @xmath36 : otherwise , by removing all nonnegative cycles , we obtain a play without repetition of vertices , henceforth of length bounded by @xmath387 , and therefore of cost at least @xmath402 .",
    "suppose that @xmath410 .",
    "then , @xmath15 has a strategy @xmath106 to ensure a negative mean - payoff @xmath411 : indeed , it simply modifies its strategy so that it always follows his choices made in the negative cycle starting in @xmath331 , ensuring that , against the optimal strategy @xmath117 of @xmath14 , he gets a mean - payoff being the cost of the cycle .",
    "this is a contradiction since @xmath14 is supposed to have a strategy ensuring a non - negative mean - payoff from @xmath63 . hence , @xmath412 .",
    "but the same contradiction appears in that case since @xmath15 can force that it always stays in the negative cycle by modifying his strategy .",
    "finally , we have proved that @xmath14 can not have a memoryless strategy ensuring a non - negative mean - payoff from @xmath63 . by memoryless determinacy of the mean - payoff games , this ensures that @xmath15 has a memoryless strategy ensuring a negative mean - payoff from  @xmath63 .",
    "hence , we have shown that @xmath392 if and only if @xmath393 , which concludes the first claim of proposition  [ prop : from - wg - to - mp - and - vice - versa ] .",
    "conversely , we reduce mean - payoff games to min - cost reachability games as follows .",
    "let @xmath413 $ ] be a mean - payoff game .",
    "without loss of generality , we may suppose that the graph of the game is bipartite , in the sense that @xmath414 .",
    "the problem we are interested in is to decide whether @xmath415 for a given vertex  @xmath63 .",
    "we now construct a min - cost reachability game @xmath416 \\rangle}$ ] from @xmath7 .",
    "the only difference is the presence of a fresh target vertex @xmath181 on top of vertices of @xmath48 : @xmath417 with @xmath418 .",
    "edges of @xmath419 are given by @xmath420 .",
    "weights of edges are given by : @xmath421 if @xmath322 , and @xmath422 .",
    "we show that @xmath396 if and only if @xmath397 .    in @xmath9 ,",
    "all values are different from @xmath33 , since @xmath15 plays at least every two steps , and has the capability to go to the target vertex with weight 0 .",
    "hence , letting @xmath423 the mean - payoff game on the weighted graph of @xmath9 , by the previous direction , we have that for every vertex @xmath424 , @xmath397 if and only if @xmath425 .    to conclude , we prove that for all vertices @xmath62 , @xmath425 if and only if @xmath396 .",
    "if @xmath396 , by mapping the memoryless optimal strategies of @xmath7 into @xmath426 , we directly obtain that @xmath427 .",
    "reciprocally , if @xmath425 , we can project a profile of memoryless optimal strategies over vertices of @xmath7 : the play obtained from @xmath63 in @xmath7 is then the projection of the play obtained from @xmath63 in @xmath426 , with the same cost . hence , @xmath428 .",
    "we now prove the correction of algorithm  [ algo : value - iteration - rt ] , as stated below .",
    "[ the : rtpo - ca - marche - youpi ] if an mcr game @xmath429 $ ] is given as input ( possibly with values @xmath33 or @xmath34 ) , algorithm  [ algo : value - iteration - rt ] outputs @xmath292 , after at most @xmath430 iterations .",
    "observe first that for all @xmath55 , for all @xmath201 , and for all strategies @xmath105 and @xmath106 : @xmath431indeed , if the target vertex @xmath181 is reached within @xmath125 steps , then both plays will have the same payoff .",
    "otherwise , @xmath432 .",
    "thus , for all @xmath433 and @xmath62 : @xmath434 which can be rewritten as @xmath435    let us now consider the sequence @xmath436 .",
    "we first give an alternative definition of this sequence permitting to show its convergence .",
    "[ lemma : min - max - charact - of - bupval ] for all @xmath433 , for all @xmath55 : @xmath437    the lemma can be established by showing that @xmath438 is the value in a game played on a finite tree of depth @xmath125 ( i.e. , by applying a backward induction ) . we adopt the following notation for labeled unordered trees .",
    "a leaf is denoted by @xmath439 , where @xmath55 is the label of the leaf .",
    "a tree with root labeled by @xmath63 and subtrees @xmath440 is denoted by @xmath441 .",
    "then , for each @xmath55 and @xmath201 , we define @xmath442 as follows : @xmath443 now , let us further label those trees by a value in @xmath444 thanks to the function @xmath445 . for all tree of the form @xmath446",
    ", we let @xmath447 for all tree of the form @xmath448 ( for some @xmath433 ) , we let @xmath449    clearly , for all @xmath55 , for all @xmath201 , the branches of @xmath442 correspond to all the possible finite plays @xmath450 $ ] , i.e. , there is a branch for each possible strategy profile @xmath451 , @xmath452 .",
    "thus , @xmath453 for all @xmath201 , which permits us to conclude from .",
    "we have just shown that for all @xmath433 , @xmath454 , so that @xmath455 for all @xmath201 ( with @xmath124 defined in page  ) .",
    "[ rem : kleene - sequence ] notice that , at this point , it would not be too difficult to show that @xmath456 is a fixed point of operator @xmath126 . however , it is more difficult to show that it is the greatest fixed point of @xmath126 , and to deduce directly properties over optimal strategies in the min - cost reachability game",
    ". instead , we use the sequence @xmath436 to obtain more interesting results on @xmath456 .",
    "we now study refined properties of the sequence @xmath436 , namely its stationarity and the speed of its convergence .",
    "we start by characterizing how @xmath457 evolves over the first @xmath458 steps .",
    "the next lemma states that , for each node @xmath63 , the sequence @xmath459 is of the form @xmath460 where @xmath3 is the step at which @xmath63 has been added to the attractor , and each value @xmath461 is finite and bounded :    [ lem : link - attractor - values ] let @xmath55 be a vertex and let @xmath462 be such that @xmath463 ( assuming @xmath464 ) .",
    "then , for all @xmath465 :    @xmath466 implies @xmath467 and    @xmath468 implies @xmath469 .",
    "we prove the property for all vertices @xmath63 , by induction on @xmath298 .    * base case * : @xmath470 .",
    "we consider two cases .",
    "either @xmath471 . in this case ,",
    "@xmath78 , and we must show that @xmath472 , which is true by definition of @xmath473 . or @xmath191 . in this case ,",
    "@xmath474 , and we must show that @xmath475 , which is true again by definition of @xmath473 .    *",
    "inductive case * : @xmath476 .",
    "let us assume that the lemma holds for all @xmath63 , for all values of @xmath298 up to @xmath477 , and let us show that it holds for all @xmath63 , and for @xmath478 .",
    "let us fix a vertex @xmath63 , and its associated value @xmath3 .",
    "we consider two cases .    1 .",
    "first , assume @xmath479 .",
    "in this case , we must show that @xmath480 .",
    "we consider again two cases : 1 .",
    "if @xmath132 , then none of its successors belong to @xmath481 , otherwise , @xmath63 would be in @xmath482 , by definition of the attractor , and we would have @xmath483 . hence , by induction hypothesis , @xmath484 for all @xmath331 such that @xmath485 .",
    "thus : @xmath486 2 .",
    "if @xmath130 , then at least one successor of @xmath63 does not belong to @xmath481 , otherwise , @xmath63 would be in @xmath482 , by definition of the attractor , and we would have @xmath483 .",
    "hence , by induction hypothesis , there exists @xmath331 such that @xmath487 and @xmath484 .",
    "thus : @xmath488 2 .   second , assume @xmath483 .",
    "in this case , we must show that @xmath489 .",
    "as in the previous item , we consider two cases : 1 .   in the case where @xmath132 , we let @xmath490 be a vertex such that @xmath491 and @xmath492 .",
    "such a vertex exists by definition of the attractor . by induction hypothesis , @xmath493 .",
    "then : @xmath494 2 .   in the case where @xmath130 , we know that all successors @xmath331 of @xmath63 belong to @xmath495 by definition of the attractor . by induction hypothesis",
    ", for all successors @xmath331 of @xmath63 : @xmath496.hence : @xmath497    in particular , this allows us to conclude that , after @xmath387 steps , all values are bounded by @xmath498 :    [ cor : after - n - steps - no - infty ] for all @xmath55 : @xmath499 .    the next step is to show that the sequence stabilises after a bounded number of steps :    [ lem : value - stab ] the sequence @xmath500 stabilises after at most @xmath501 steps .    we first show that if @xmath15 can secure , from some vertex @xmath63 , a payoff less than @xmath502 , i.e. , @xmath503 , then it can secure an arbitrarily small payoff from that vertex , i.e. , @xmath175 , which contradicts our hypothesis that the value is finite .",
    "hence , let us suppose that there exists a strategy @xmath106 for @xmath15 such that @xmath504 .",
    "let @xmath9 be the mean - payoff game studied in proposition  [ prop : from - wg - to - mp - and - vice - versa ] .",
    "we will show that @xmath393 , which permits to conclude that @xmath392 .",
    "let @xmath105 be a memoryless strategy of @xmath14 . by hypothesis , we know that @xmath505 .",
    "this ensures the existence of a cycle with negative cost in the play @xmath107 : otherwise , we could iteratively remove every possible nonnegative cycle of the finite play before reaching @xmath181 ( hence reducing the cost of the play ) and obtain a play without cycles before reaching @xmath181 with a cost less than @xmath502 , which is impossible ( since it should be of length at most @xmath506 to cross at most one occurrence of each vertex ) .",
    "consider the first negative cycle in the play .",
    "after the first occurrence of the cycle , we let @xmath15 choose its actions like in the cycle . by this way",
    ", we can construct another strategy @xmath236 for @xmath15 , verifying that for every memoryless strategy @xmath105 of @xmath14 , we have @xmath507 being the weight of the negative cycle in which the play finishes . since for mean - payoff games , memoryless strategies are sufficient for @xmath14 , we deduce that @xmath393 .",
    "this reasoning permits to prove that at every step @xmath125 , @xmath508 for all vertices  @xmath63 .",
    "recall from corollary  [ cor : after - n - steps - no - infty ] that , after @xmath387 steps in the sequence , all vertices are assigned a value smaller that @xmath498 .",
    "moreover , we know that the sequence is non - increasing . in summary , for all @xmath157 and for all vertices @xmath63 : @xmath509 hence , in the worst case a strictly decreasing sequence will need @xmath510 steps to reach the lowest possible value where all vertices are assigned @xmath511 from the highest possible value where all vertices are assigned @xmath498 .",
    "thus , taking into account the @xmath387 steps to reach a finite value on all vertices , the sequence stabilises in at most @xmath512 steps .",
    "let us thus denote by @xmath513 the value obtained when the sequence @xmath436 stabilizes .",
    "we know from a previous discussion that @xmath513 is the greatest fixed point of operator @xmath126 .",
    "we are now ready to prove that this value is the actual value of the game :    [ lem : convergence ] for all min - cost reachability game : @xmath514    we already know that @xmath515 .",
    "let us show that @xmath516 .",
    "let @xmath62 be a vertex .",
    "since @xmath177 is finite integer , there exists a strategy @xmath106 for @xmath15 that realises this value , i.e. , @xmath517 notice that this holds because the values are integers , enducing that the infimum in the definition of @xmath518 is indeed reached .",
    "let us build a tree @xmath519 unfolding all possible plays from @xmath63 against @xmath106 .",
    "@xmath519 has a root labeled by @xmath63 .",
    "if a tree node is labeled by a vertex @xmath63 of @xmath15 , this tree node has a unique child labeled by @xmath520 .",
    "if a tree node is labeled by a vertex @xmath63 of @xmath14 , this tree node has one child per successor @xmath331 of @xmath63 in the graph , labeled by @xmath331 .",
    "we proceed this way until we encounter a node labeled by a vertex from @xmath181 in which case this node is a leaf .",
    "@xmath519 is necessarily finite .",
    "otherwise , by knig s lemma , it has one infinite branch that never reaches @xmath181 . from that infinite branch",
    ", one can extract a strategy @xmath105 for @xmath14 such that @xmath521 , hence @xmath174 , which contradicts the hypothesis .",
    "assume the tree has depth @xmath522 .",
    "then , @xmath519 is a subtree of the tree @xmath523 obtained by unfolding all possible plays up to length @xmath522 ( as in the proof of lemma  [ lemma : min - max - charact - of - bupval ] ) . in this case",
    ", it is easy to check that the value labeling the root of @xmath519 after applying backward induction is larger than or equal to the value labeling the root of @xmath523 after applying backward induction .",
    "the latter is @xmath177 while the former is @xmath524 , by lemma  [ lemma : min - max - charact - of - bupval ] , so that @xmath525 .",
    "since the sequence is non - increasing , we finally obtain @xmath526 .    as a corollary of this lemma ,",
    "we obtain :    [ lem : min - max - charact - of - value ] @xmath456 is the greatest fixed point of @xmath126 .",
    "this permits to obtain a value iteration algorithm , described in algorithm  [ algo : value - iteration - rt ] , that computes optimal values .",
    "notice that we do not suppose that every vertex has a finite value , which is justified in the proof of proposition  [ the : rtpo - ca - marche - youpi ] below proving the correctness of the algorithm , as well as its complexity .",
    "a crucial argument is given in the following lemma , following from the fact that @xmath456 is the greatest fixed point of @xmath126 :    [ lem : acceleration ] if the kleene sequence @xmath527 is initiated with a vector of values @xmath128 that is greater or equal to the optimal value vector @xmath456 , then the sequence converges at least as fast as before towards the optimal value vector .",
    "let us first suppose that values of every vertices are finite .",
    "then , we can easily prove by induction that at the beginning of the @xmath298th step of the loop , @xmath228 is equal to the vector @xmath528 , and that the condition of line  [ line - infty ] has never been fulfilled .",
    "hence , by lemma  [ lem : value - stab ] , after at most @xmath529 iterations , all values are found correctly in that case .",
    "suppose now that there exist vertices with value @xmath33 .",
    "those vertices will remain at their initial value @xmath33 during the whole computation , and hence do not interfere with the rest of the computation .",
    "finally , consider that the game contains vertices with value @xmath34 .",
    "we know that optimal values of vertices of values different from @xmath34 are at least @xmath530 so that , if the value of a vertex reaches an integer below @xmath531 , we are sure that its value is indeed @xmath34 , which proves correct the line  [ line - infty ] of the algorithm .",
    "this update may cost at most one step per vertices , which in total adds at most @xmath387 iterations .",
    "moreover , by lemma  [ lem : acceleration ] , dropping the value to @xmath34 does not harm the correction for the other vertices ( it may only speed the convergence of their values ) .",
    "this section is devoted to the formal construction of optimal strategies in mcr games , as explained briefly at the end of section  [ sec : reachability - objectives ] .",
    "we have already seen an example in fig .",
    "[ fig : weighted - game ] of a game where @xmath15 may need memory in an optimal strategy , i.e. , where @xmath15 has an optimal strategy , but no memoryless optimal strategies",
    ". reciprocally , as a consequence of the previous work , we first show that , for vertices with finite value , @xmath15 has always a finite - memory optimal strategy .",
    "[ prop - rtp - finite - memory ] in all min - cost reachability game with only vertices of finite values , @xmath15 has a finite - memory optimal strategy .",
    "we explain how to reconstruct from the fixpoint computation an optimal strategy @xmath118 for @xmath15 .",
    "let @xmath3 be the integer such that @xmath532 .",
    "for every step @xmath533 of the fixpoint computation , we define a strategy @xmath534 . for every finite play @xmath1 ending in a vertex @xmath63 of @xmath15 ,",
    "if the length of @xmath1 is @xmath535 , we let @xmath536 and otherwise , we let @xmath537 notice that the @xmath234 operator may select any possible vertex as long as it selects one with minimum value .",
    "we also let @xmath538 for every @xmath539 , as well as @xmath540 .",
    "notice that @xmath118 is a finite - memory strategy , since it only requires to know the last vertex and the length of the prefix up to @xmath3 .",
    "we now prove that @xmath541 for all vertices  @xmath63 , which proves that @xmath118 is an optimal strategy since @xmath542 by lemma  [ lem : convergence ] .",
    "to do so , we first show by induction on @xmath11 that @xmath543 holds for every strategy @xmath105 of @xmath14 and @xmath62 .",
    "this permits to conclude since , from @xmath544 for every @xmath545 , we can deduce : @xmath546 and @xmath457 is a stationary sequence converging towards @xmath513 .",
    "the proof by induction goes as follows . in case @xmath547 , either @xmath471 and both terms of are equal to @xmath36 , or @xmath548 and both terms of are equal to @xmath33 .",
    "supposing now that the property holds for an index @xmath11 , let us prove it for @xmath549 .",
    "for that , we consider a strategy @xmath105 of @xmath14 . in case @xmath471 ,",
    "we have @xmath550 we now consider the case @xmath548 .",
    "let @xmath331 be the second vertex in @xmath551 . from the definition of @xmath552 ,",
    "@xmath553 $ ] is the concatenation of @xmath63 and @xmath554 $ ] .",
    "hence , @xmath555 by induction hypothesis , we obtain that @xmath556 now , consider the two following cases .    *",
    "if @xmath557 , we have @xmath558 , so that , in case @xmath559 : @xmath560 using and lemma  [ lemma : min - max - charact - of - bupval ] , we obtain @xmath561 in case @xmath562 , we indeed have @xmath563 , so that we conclude similarly . * if @xmath564 , we have @xmath565 and @xmath566 once again using and lemma  [ lemma : min - max - charact - of - bupval ] , we obtain @xmath561    this concludes the induction proof .",
    "notice that the proof of proposition  [ prop - rtp - finite - memory ] together with the statement of lemma  [ lem : value - stab ] imply that a memory of size pseudo - polynomial for the strategy of @xmath15 is sufficient . before stating the result for @xmath14",
    ", we informally refine this result in order to find a strategy of @xmath15 having more _ structural properties_. it will be composed of two memoryless strategies @xmath237 and @xmath238 : the game will start with @xmath15 following @xmath237 , and at some point , determined by the weight of the current finite play , @xmath15 will switch to strategy @xmath238 which is an attractor strategy , i.e. , a strategy that reaches the target in less than @xmath387 steps , regardless of the weights along this path .",
    "intuitively the strategy @xmath237 ensures either to reach the target with optimal value , or to go in cycles of negative weights . the only chance for @xmath15 of having a greater value than the optimal is to go infinitely through these cycles without reaching the target .",
    "but if it does so , the total - payoff will decrease and at some point the value will be so low , that the cost of calling the attractor strategy will leave the total - payoff smaller than the optimal value .",
    "let us formalise this construction .    for the sake of exposure , we present the construction when all values are finite , but such construction can be applied with few changes when some vertices have value @xmath34 or @xmath33 .",
    "we start by defining a memoryless strategy @xmath237 that has some good properties ( stated in proposition  [ prop : almostperfect ] ) .",
    "let @xmath567 denote the value of variable @xmath568 after @xmath125 iteration of the loop of algorithm  [ algo : value - iteration - rt ] , and let @xmath569 for all @xmath55 .",
    "we have seen that the sequence @xmath570 is stationary at some point , equal to @xmath456 . for all vertices @xmath571 , let @xmath572 be the first index such that @xmath573 . fix a vertex @xmath574 such that @xmath575 ( that exists by definition ) and define @xmath576 . the following lemma states that the vertex @xmath331 already reached its final value at step @xmath577 .",
    "for all vertices @xmath578 , @xmath579 .",
    ". by contradiction assume that @xmath581 , note that there exists @xmath582 such that @xmath583 . by definition ,",
    "@xmath584 which raises a contradiction .    we can state the properties of @xmath237 : intuitively one can see it as an _ almost perfect strategy _ , in the sense that it is memoryless , if it reaches the target , then the value obtained is optimal , and if it does not reach the target then the total - payoff of the finite play will decrease as the game goes on .",
    "the only problem is one can not ensure that we reach the target .    [",
    "prop : almostperfect ] for all vertices @xmath63 , and for all plays @xmath585 starting in @xmath63 and conforming to @xmath237 ,    1 .",
    "if there exists @xmath586 such that @xmath587 , then @xmath588 , 2 .   if @xmath1 reaches @xmath181 then @xmath589",
    "let us prove @xmath590 , take a cycle @xmath591 with @xmath592 .",
    "notice that at least one vertex of this cycle belongs to @xmath15 , since , otherwise , @xmath14 would have a strategy to obtain a value @xmath33 for vertex @xmath16 , which contradicts the hypothesis on the game .",
    "hence , for the sake of the explanation , we suppose that @xmath593 .",
    "let us also suppose that @xmath594 is maximal among @xmath595 .",
    "the following extends straightforwardly to the case where this maximal vertex of @xmath15 is not @xmath596 .",
    "we prove by induction over @xmath597 that @xmath598 the base case comes from the fact that since @xmath599 we have @xmath600 thus @xmath601 . for the inductive case ,",
    "let us consider @xmath602 such that @xmath603 and let us prove it for @xmath549 .",
    "if @xmath604 , by definition of @xmath605 , we have @xmath606 in case @xmath607 , by maximality of @xmath594 , we have @xmath608 using that the sequence @xmath609 is non - increasing .    hence , in all cases",
    ", we have @xmath610 using again that @xmath609 is non - decreasing , we obtain @xmath611 injecting this into the induction hypothesis , we have @xmath612 which concludes the proof by induction .",
    "in particular , for @xmath613 , as @xmath587 we obtain that @xmath614 and as , by definition of @xmath594 , we have @xmath615 , we necessarily have @xmath616 .    to prove @xmath617 we decompose @xmath1 as @xmath618 with for all @xmath125 , @xmath619 .",
    "we prove by decreasing induction on @xmath125 that @xmath620 . if @xmath621 , @xmath622 . if @xmath623 , by induction we have @xmath624 thus @xmath625 .",
    "if @xmath599 then @xmath626 and @xmath627 .",
    "if @xmath628 , then @xmath629 .    next ,",
    "let @xmath238 be the memoryless strategy induced by the computation of the attractor : notice that it is possible to construct it directly from the value iteration computation by mapping a vertex @xmath63 to one vertex from which @xmath63 is first discovered ( i.e. , its value is first set to a real value different from @xmath33 ) .",
    "this strategy ensures to reach the target after at most @xmath387 steps , thus for all @xmath63 , @xmath630 .    before defining the strategy @xmath631",
    ", we introduce the notion of _ switchable finite play _ as follows .",
    "a finite play @xmath632 is switchable if @xmath87 and @xmath633 .",
    "intuitively a strategy is switchable , if by switching to the attractor strategy , we ensures to get an optimal value .",
    "we define the strategy @xmath236 as follows : for all finite play @xmath632 with @xmath87 : @xmath634    one can easily show that for all play @xmath635 that conforms to @xmath236 either @xmath636 conforms to @xmath237 if no finite play is switchable , or there exists @xmath3 such that @xmath632 conforms to @xmath237 , @xmath632 is a switchable finite play , and @xmath637 conforms to @xmath238 .",
    "the following proposition states that the strategy @xmath236 is optimal .    for all @xmath63 , @xmath638 .",
    "let @xmath62 and @xmath639 , let us show that @xmath640 . assume first that there exists @xmath3 such that @xmath632 conforms to @xmath237 , @xmath632 is a switchable finite play , and @xmath637 conforms to @xmath238 .",
    "thus @xmath1 reaches the target as @xmath637 does , and @xmath641 .",
    "as @xmath642 is a switchable finite play , we have @xmath643 , thus @xmath644 .",
    "assume now that @xmath636 does not contains a switchable prefix and thus @xmath1 conforms to @xmath237 . if @xmath1 reaches @xmath181 then by proposition  [ prop : almostperfect ] , @xmath640 . to conclude ,",
    "let us prove that @xmath1 reaches @xmath181 , and by contradiction assume that this is not the case .",
    "first we prove by induction on @xmath3 , that @xmath645 for all play @xmath646 that conforms to @xmath237 and does not reach @xmath181 , @xmath647 .    if @xmath648 the results is straightforward .",
    "for the inductive case , let @xmath649 and @xmath646 that conforms to @xmath237 and does not reach @xmath181 .",
    "then as @xmath650 , there exists @xmath586 such that @xmath651 .",
    "thus as @xmath652 is a play of size @xmath653 that conforms to @xmath237 and does not reach @xmath181 , we know by induction hypothesis that @xmath654 . furthermore by proposition  [ prop : almostperfect ] , we have that @xmath655 .",
    "thus @xmath656 which concludes the proof of @xmath645 .",
    "now we can get back to raising a contradiction , and for that we show that there exists a switchable finite play in @xmath636",
    ". take @xmath3 be the least index greater that @xmath657 such that @xmath87 ( we know that there exists one , otherwise the vertices @xmath658 with @xmath659 would not be in the attractor of @xmath181 ) .",
    "we have @xmath660    thus @xmath632 is a switchable prefix , which raises a contradiction .",
    "notice that @xmath236 may be more easily implementable than a more general finite - memory strategy , in particular , we may encode the current total - payoff in binary , hence saving some space .",
    "we give in algorithm  [ algo : value - iteration - rt - strategy ] a way to compute strategies @xmath237 and @xmath238 .      while we have already shown that optimal strategies for @xmath15 might require memory , let us show that @xmath14 always has a _ memoryless optimal strategy_. this asymmetry stems directly from the asymmetric definition of the game  while @xmath15 has the double objective of reaching @xmath181 and minimising its cost , @xmath14 aims at avoiding @xmath181 , and if not possible , maximising the cost .",
    "[ prop : optimal - player2 ] in all min - cost reachability game , @xmath14 has a memoryless optimal strategy .    for vertices with value",
    "@xmath33 , we already know a memoryless optimal strategy for @xmath14 , namely any strategy that remains outside the attractor of the target vertices . for vertices with value",
    "@xmath34 , all strategies are equally bad for @xmath14 .",
    "we now explain how to define a memoryless optimal strategy @xmath117 for @xmath14 in case of a graph containing only finite values . for every finite play @xmath1 ending in a vertex @xmath661 of @xmath14 , we let @xmath662 this is clearly a memoryless strategy .",
    "let us prove that it is optimal for @xmath14 , that is , for every vertex @xmath55 , and every strategy @xmath106 of @xmath15 @xmath663 in case @xmath664 does not reach the target set of vertices , the inequality holds trivially .",
    "otherwise , we let @xmath665 with @xmath11 the least position such that @xmath666 . if @xmath547 , i.e. , @xmath667 , we have @xmath668 otherwise , let us prove by induction on @xmath669 that @xmath670 this will permit to conclude since @xmath671 the base case @xmath672 corresponds to the previous case where the starting vertex is @xmath181 .",
    "supposing that the property holds for index @xmath125 , let us prove it for @xmath673 .",
    "we have @xmath674 by induction hypothesis , we have @xmath675 we now consider two cases :    * if @xmath676 , then @xmath677 , so that by definition of  @xmath117 : @xmath678 using corollary  [ lem : min - max - charact - of - value ] and , we obtain @xmath679 * if @xmath680 , then @xmath681 once again using corollary  [ lem : min - max - charact - of - value ] and , we obtain @xmath679    this concludes the proof .    this strategy @xmath682 can directly be computed along the execution of the value iteration algorithm .",
    "this is done in algorithm  [ algo : value - iteration - rt - strategy ] .",
    "this section is devoted to the proof of proposition  [ truetp2mcr ] .    for that purpose",
    ", we must relate paths in games @xmath7 and @xmath683 : with each finite path in @xmath683 , we associate a finite path in @xmath7 , obtained by looking at the sequence of vertices of @xmath48 appearing inside the vertices of the finite play . formally , the _ projection _ of a finite path @xmath1 is the sequence @xmath684 of vertices of @xmath7 inductively defined by @xmath685 and for all finite path @xmath1 , @xmath62 and @xmath252:@xmath686 in particular , notice that in the case of a play with prefix @xmath687 , the rest of the play is entirely composed of target vertices @xmath181 , since @xmath181 is a sink state .",
    "for instance , the projection of the finite play @xmath688 of the game @xmath258 of fig .  [ figureextpmcr ] is given by @xmath689 .",
    "the following lemma relates plays of @xmath683 with their projection in @xmath7 , comparing their total - payoff .",
    "[ claimprojection ] the projection mapping satisfies the following properties .    1 .",
    "[ item : partialplays ] if @xmath1 is a finite play in @xmath683 then @xmath684 is a finite play in @xmath7 .",
    "[ item : plays ] if @xmath1 is a play in @xmath683 that does not reach the target , then @xmath684 is a play in @xmath7 .",
    "[ item : payoff ] for all finite play @xmath1 , @xmath690 .",
    "the proof of [ item : plays ] is a direct consequence of [ item : partialplays ] . to each vertex @xmath691 , we associate a vertex @xmath692 as follows : @xmath693 then notice that if @xmath694 with @xmath695 , then either @xmath696 or @xmath697 .",
    "we now prove [ item : partialplays ] and [ item : payoff ] inductively on the size of the finite play @xmath698 of @xmath683 , along with the fact that    @xmath699 if @xmath700 and @xmath701 then the first vertex of @xmath684 is @xmath702 .    if @xmath78 , then @xmath703 are finite plays with the same total - payoff .",
    "if @xmath704 , either @xmath705 or @xmath706 and @xmath707 : in both cases , the properties hold trivially . otherwise , @xmath708 and we distinguish several possible prefixes :    * if @xmath709 , then @xmath710 .",
    "hence , [ item : partialplays ] holds by induction hypothesis .",
    "if @xmath684 is non - empty , so is @xmath711 .",
    "moreover , the first vertex of @xmath712 is either @xmath251 or @xmath253 , so that we can show @xmath38 by induction hypothesis .",
    "finally , the previous remark shows that the first edge of @xmath1 has necessarily weight 0 , so that , @xmath713 , and [ item : payoff ] also holds by induction hypothesis . * if @xmath714 , then @xmath715 so that @xmath38 holds directly .",
    "moreover , @xmath712 is a non - empty finite play so that @xmath716 with @xmath322 , and @xmath717 . by induction , @xmath711 is a finite play in @xmath718 , and it starts with @xmath331 ( by @xmath38 ) . since @xmath322",
    ", this shows that @xmath684 is a finite play .",
    "moreover , @xmath719 . by induction hypothesis",
    ", we have @xmath720 .",
    "moreover , @xmath721 which concludes the proof of  [ item : payoff ] . * if @xmath722 then @xmath723 : this allows us to conclude directly by using the previous case . * otherwise , @xmath724 , and then @xmath707 is a finite play with total - payoff @xmath36 , like @xmath1 , and @xmath38 holds trivially .",
    "the next lemma states that when playing memoryless strategies , one can bound the total - payoff of all finite plays .",
    "[ lemmaboundedvalue ] let @xmath55 , and @xmath105 ( respectively , @xmath106 ) be a memoryless strategy for @xmath14 ( respectively , @xmath15 ) in the total - payoff game @xmath7 , such that @xmath725 ( respectively , @xmath726 ) .",
    "then for all finite play @xmath1 conforming to @xmath105 ( respectively , to @xmath106 ) , @xmath727 ( respectively , @xmath728 ) .",
    "we prove the part for @xmath15 , the other case is similar .",
    "the proof proceeds by induction on the size of a partial play @xmath729 with @xmath730 . if @xmath731 then @xmath732 . if @xmath733 then there exists @xmath586 such that @xmath587 .",
    "assume by contradiction that @xmath734 .",
    "then the play @xmath735 conforms to @xmath106 and @xmath736 which contradicts @xmath726 .",
    "therefore @xmath737 .",
    "we have @xmath738 , and since @xmath587 , @xmath739 is a finite play starting from @xmath63 that conforms to @xmath106 , and by induction hypothesis @xmath740",
    ". then @xmath741 .",
    "this permits to bound the finite values @xmath742 of vertices",
    "@xmath63 of the game :    [ cor : bornesvaleurstp ] for all @xmath55 , @xmath743 \\uplus\\{-\\infty,+\\infty\\}$ ] .    from @xcite ,",
    "we know that total - payoff games are positionally determined , i.e. , there exists two memoryless strategies @xmath744 such that for all @xmath63 , @xmath745 .",
    "assume that @xmath746 .",
    "then since @xmath747 , lemma  [ lemmaboundedvalue ] shows that all finite play @xmath1 that conforms to @xmath106 verifies @xmath748 , therefore @xmath749 .",
    "one can similarly prove that @xmath750 .",
    "we now compare values in both games . a first lemma shows , in particular , that @xmath751 , in case @xmath261 .",
    "[ lem : upperbound ] for all @xmath752 , @xmath62 , and @xmath246 , if @xmath753 then @xmath754 .    by hypothesis and using the memoryless determinacy of @xcite",
    ", there exists a memoryless strategy @xmath106 for @xmath15 in @xmath7 such that @xmath755 .",
    "let @xmath756 be the strategy in @xmath683 defined , for all finite play @xmath1 , vertex @xmath331 and @xmath252 , by @xmath757 intuitively @xmath756 simulates @xmath106 , and asks to leave the copy when the current total - payoff is less than or equal to @xmath522 .",
    "notice that , by construction of @xmath756 , @xmath684 conforms to @xmath106 , if @xmath1 conforms to @xmath756 .    as a first step ,",
    "if a play @xmath1 starting in @xmath758 and conforming to @xmath756 encounters the target then its value is at most @xmath522 .",
    "indeed , it is of the form @xmath759 , and since it conforms to @xmath756 we have @xmath760    then , assume , by contradiction , that there exists a play @xmath1 starting in @xmath758 and conforming to @xmath756 , that does not encounter the target .",
    "then , this means that @xmath15 does not ask @xmath761 times the ability to exit in @xmath1 ( since on the @xmath762th time that we jump in an exterior vertex , @xmath14 is forced to go to the target ) . in particular",
    ", there exists @xmath763 such that @xmath1 is of the form @xmath764 . since for all @xmath125 , @xmath765",
    ", we have that @xmath766 .",
    "therefore , since any prefix of @xmath684 is the projection of a prefix of @xmath1 , lemma  [ claimprojection ] shows that @xmath767 , which raises a contradiction since @xmath684 conforms to @xmath106 and @xmath768 .",
    "hence every play that conforms to @xmath756 encounters the target , and , hence , has value at most  @xmath522 .",
    "this implies that @xmath754 .",
    "we now turn to the other comparison between @xmath769 and @xmath770 .",
    "since @xmath770 can be infinite in case the target is not reachable , we have to be more careful .",
    "in particular , we show that @xmath771 holds for large values of @xmath250 . in the following ,",
    "we let @xmath772 .",
    "[ lem : lowerbound ] for all",
    "@xmath773 , @xmath260 , and vertex @xmath63 , if @xmath774 then @xmath775 .",
    "by hypothesis and using the memoryless determinacy of @xcite , there exists a memoryless strategy @xmath105 for @xmath14 in @xmath7 such that @xmath776 .",
    "let @xmath777 be the strategy in @xmath28 defined , for all finite play @xmath1 , vertex @xmath331 and @xmath252 , by : @xmath778    intuitively @xmath777 simulates @xmath105 , and accepts to go to the target when the current total - payoff is greater than or equal to @xmath522 .    by construction of @xmath777 ,",
    "if @xmath1 conforms to @xmath777 , then @xmath684 conforms to @xmath105 . from the structure of the weighted graph , we know that for every play @xmath1 of @xmath266 , there exists @xmath779 such that @xmath1 is of the form @xmath780 verifying that : there are no occurrences of exterior vertices in @xmath781 ; for all @xmath782 , all vertices in @xmath783 belong to the @xmath11-th copy of @xmath7 ; either @xmath784 or all vertices of @xmath712 belong to the @xmath785th copy of @xmath7 ( in which case , @xmath466 ) .",
    "we now show that , in @xmath266 , @xmath786 for all play @xmath1 starting in @xmath787 and conforming to @xmath777 .",
    "there are three cases to consider",
    ".    1 .   if @xmath1 does not reach the target , then @xmath788 .",
    "2 .   if @xmath789 and @xmath790 then , @xmath791 thus , using lemma  [ claimprojection ] , @xmath792 3 .   if @xmath793 , assume by contradiction that @xmath794 otherwise , we directly obtain @xmath795 . let @xmath796 be a vertex that occurs at least @xmath797 times in the sequence @xmath798 : such a vertex exists , since otherwise @xmath799 which contradicts the fact that @xmath800 .",
    "let @xmath801 be a sequence of indices such that @xmath802 for all @xmath125 .",
    "we give a new decomposition of @xmath1 : @xmath803 since @xmath1 conforms to @xmath777 and according to the assumption , we have that for all @xmath125 , @xmath804 we consider two cases . 1 .",
    "if there exists @xmath805 such that @xmath806 then , let @xmath807 with @xmath808 , since @xmath805 conforms to @xmath777 , @xmath809 conforms to @xmath105 .",
    "therefore the play @xmath810 conforms to @xmath105 .",
    "furthermore , using again lemma  [ claimprojection ] , @xmath811 and since @xmath812 , we have @xmath813 thus @xmath814 is a play starting from @xmath63 that conforms to @xmath105 but whose total - payoff is strictly less than @xmath522 , which raises a contradiction .",
    "2 .   if for all @xmath805 , @xmath815 ( notice that it is implied by @xmath816 ) . from lemma  [ lemmaboundedvalue ] , since @xmath817 , we know that @xmath818 . from lemma  [ claimprojection ] , @xmath819 .",
    "therefore @xmath820 which contradicts the assumption that @xmath821    we have shown that @xmath786 for all play @xmath1 starting in @xmath787 and conforming to @xmath777 , which implies @xmath822 .    from the two previous lemmas , we are ready to relate precisely values in @xmath7 and @xmath266 .",
    "let @xmath62 .",
    "* if @xmath823 , then for all @xmath522 , @xmath824 .",
    "thus , by lemma  [ lem : upperbound ] , @xmath825 . therefore @xmath826 . *",
    "if @xmath827 $ ] .",
    "then , @xmath828 .",
    "thus , by lemma  [ lem : upperbound ] and [ lem : lowerbound ] , @xmath829 . therefore @xmath830 . *",
    "if @xmath831 , then @xmath832 . thus , by lemma  [ lem : lowerbound ] , @xmath833 .",
    "this section is devoted to the study of algorithm  [ algo : value - iter - tpo ] , in particular in the proof of theorem  [ thm : vi - tp ] .",
    "we first define formally the game @xmath285 described informally on page . to the original total - payoff game @xmath245 $ ] and to every vector @xmath834 , we associate the min - cost reachability game @xmath835 \\rangle}$ ] as follows . the sets of vertices are given by @xmath836 as in game @xmath837 , vertices of the form @xmath838 are called _ interior vertices_. edges are defined by @xmath839 while weights of edges are defined , for all @xmath840 , by @xmath841    it is easy to see that lines  [ line : begin ] to  [ line : end ] are a rewriting of algorithm  [ algo : value - iteration - rt ] in the special case of game @xmath285 : in particular , neither the target vertex nor interior vertices are explicit , but their behavior is taken into account by the transformation performed in line  [ line : begin ] and the operators @xmath842 used in the inner computation of lines  [ line : minvertex ] and [ line : maxvertex ] .",
    "hence , if we define @xmath843 for all @xmath62 , we can say that if inside the main loop , at line  [ line : begin ] the variable @xmath844 has value @xmath284 , then after line  [ line : end ] , it has value @xmath283 .",
    "notice that the game @xmath285 resembles a copy of @xmath7 in the game @xmath837 of the previous section .",
    "more , precisely , from the values @xmath845 in the @xmath298th copy , we can deduce the values in the @xmath785th copy by an application of operator @xmath281 : @xmath846 although the @xmath36th copy is not defined , we abuse the notation and set @xmath847 , which still conforms to the above equality . furthermore , due to the structure of the game @xmath837 notice that for all @xmath848 , @xmath849 .    notice the absence of exterior vertices @xmath850 in game @xmath285 , replaced by the computation of the maximum between @xmath36 and @xmath851 on the edge towards the target . before proving the correctness of algorithm  [ algo : value - iter - tpo ] ,",
    "we prove several interesting properties of operator @xmath281 .",
    "@xmath281 is a monotonic operator .",
    "for every vector @xmath834 , let @xmath852 be the operator associated with the min - cost reachability game as defined in section  [ sec : reachability - objectives ] , i.e. , for all @xmath853 , and for all @xmath854 @xmath855 we know from corollary  [ lem : min - max - charact - of - value ] that @xmath856 is the greatest fixed point of @xmath852 .",
    "consider now two vectors @xmath857 such that @xmath858 .",
    "first , notice that for all @xmath859 : @xmath860 indeed , to get the result it suffices to notice that for all @xmath861 , @xmath862 .",
    "consider then the vector @xmath863 defined by @xmath864 for all @xmath854 . from  , we have that @xmath865 , then a simple induction shows that for all @xmath125 , @xmath866 .",
    "thus , since @xmath856 ( respectively , @xmath867 ) is the greatest fixed point of @xmath868 ( respectively , @xmath869 ) , we have @xmath870 . as a consequence @xmath871 .",
    "notice that @xmath281 may not be scott - continuous , as shown in the following example .",
    "\\(v ) at ( 0,0 ) ; ( v ) edge[loop below ] node [ midway , below ] @xmath136 ( v ) ;    at ( 0,-1.7 ) @xmath7 ;    ( vbis ) at ( 0,0 ) ; ( inv ) at ( 0,-1 ) @xmath872 ; ( tg ) at ( 2,-1 ) ;    ( vbis ) to[bend right ] node[midway , left ] @xmath136 ( inv ) ; ( inv ) to[bend right ] node[midway , right ] @xmath36 ( vbis ) ; ( inv ) to node[above ] @xmath284 ( tg ) ;    at ( 0,-1.7 ) @xmath285 ;    recall that , in our setting , a scott - continuous operator is a mapping @xmath873 such that for any sequence of vectors @xmath209 having a limit @xmath874 , the sequence @xmath875 has a limit equal to @xmath876 .",
    "we present a total - payoff game whose associated operator @xmath281 is not continuous .",
    "let @xmath7 be the total - payoff game containing one vertex @xmath63 of @xmath15 and a self loop of weight @xmath136 ( as depicted in fig .",
    "[ fig : notcontinuous ] ) . for all @xmath877 , in the min - cost reachability game @xmath285",
    ", @xmath63 has value @xmath34 , indeed one can take the loop an arbitrary number of times before reaching the target , ensuring a value arbitrary low .",
    "therefore , if we take an increasing sequence @xmath878 of integers , @xmath879 for all @xmath125 , thus the limit of the sequence @xmath880 is @xmath34 .",
    "however , the limit of the sequence @xmath878 is @xmath33 and @xmath881 , since the target is not reachable anymore ( in case the weight of an edge would be @xmath33 , it is removed in the definition of @xmath882 ) .",
    "thus , @xmath281 is not scott - continuous .",
    "in particular , we may not use the kleene sequence , as we have done for min - cost reachability games , to conclude to the correctness of our algorithm .",
    "anyhow , we will show that the sequence @xmath883 indeed converges towards the vector of values of the total - payoff game .",
    "we first show that this vector is a pre - fixed point of @xmath281 starting with a technical lemma that is useful in the subsequent proof .",
    "[ propcooldestp ] let @xmath106 be a strategy for @xmath15 in @xmath7 , and @xmath884 a finite play that conforms to @xmath106 .",
    "then : @xmath885    let @xmath105 be an optimal strategy for @xmath15 and @xmath886 be the play @xmath887 . since @xmath105 is optimal , @xmath888 . furthermore notice that @xmath889 conforms to the strategy @xmath106 , therefore @xmath890 .",
    "thus : @xmath891    [ lem : pre - fixed - point ] @xmath892 is a pre - fixed point of @xmath281 , i.e. , @xmath893 .    to ease the notations ,",
    "we denote @xmath892 by @xmath894 in this proof . to prove this lemma",
    ", we just have to show that for all @xmath895 , the value of @xmath16 in the min - cost reachability game @xmath896 is at most its value in the original total - payoff game @xmath7 , i.e. , @xmath897    let @xmath106 be a memoryless strategy in @xmath7 such that @xmath898 for some @xmath899 . and let @xmath756 be a strategy in @xmath900 defined for all finite play @xmath901 with @xmath902 by @xmath903 and for all finite play @xmath904 , @xmath905    notice that , by construction , all plays starting in @xmath16 , conforming to @xmath756 and that reach the target have value at most @xmath522 .",
    "assume by contradiction that there exists a play @xmath906 that never reaches @xmath181 .",
    "in particular , for all  @xmath125 , @xmath907 .    again by construction , @xmath636 is a play in @xmath7 that conforms to @xmath106 and for all  @xmath125 , @xmath908 .    * if there exists @xmath909 such that @xmath910 , then @xmath911 which raises a contradiction . * if for all @xmath909 , @xmath912 then for all @xmath909 , @xmath913 thus @xmath914 , which contradicts the fact that @xmath915 conforms to @xmath106 and @xmath898 .",
    "thus @xmath916 . as a consequence , @xmath917 .",
    "even if it is not necessary for the proof of theorem  [ thm : vi - tp ] , we can show that @xmath292 is the least pre - fixed point of @xmath281 .",
    "notice that , by monotonicity of @xmath281 , this directly implies that @xmath892 is the least fixed point of @xmath281 .",
    "the proof that @xmath292 is the least pre - fixed point of @xmath281 amounts to better understand the convergence of the sequence @xmath918 ( remember that we set @xmath847 for all @xmath63 ) .",
    "indeed , proposition  [ truetp2mcr ] already shows that for vertices @xmath63 such that @xmath919 , @xmath920 converges towards @xmath921 .",
    "it is also the case for vertices @xmath63 such that @xmath922 as we show in lemma  [ lem : limit ] below .",
    "then , consider a pre - fixed point @xmath284 of @xmath281 , i.e. , @xmath923 . since @xmath924 and @xmath281 is monotonous ,",
    "we prove by immediate induction that @xmath925 for all @xmath63 and @xmath926 : indeed , if @xmath925 for all @xmath63 , we have @xmath927 this implies that @xmath928 , showing that @xmath929 is indeed the least pre - fixed point of @xmath281 , and hence the least fixed point of @xmath281 , by the above reasoning .    before continuing the proof of theorem  [ thm : vi - tp ]",
    ", we show the result used in the previous remark .",
    "[ lem : limit ] let @xmath55 such that @xmath263 , and @xmath105 a memoryless strategy for @xmath14 in @xmath7 such that @xmath930",
    ". then the following holds :    1 .   for every finite play @xmath642 conforming to @xmath105 starting in @xmath730 , if there exists @xmath586 such that @xmath587 then @xmath931 .",
    "2 .   for every @xmath932 , @xmath933 and @xmath642 a finite play conforming to @xmath105 and starting in @xmath730 , @xmath934 .",
    "3 .   for all @xmath932 and @xmath935 , @xmath936 .",
    "4 .   @xmath937 .",
    "we prove @xmath938 by contradiction .",
    "therefore , assume that @xmath939 , then @xmath940 comforms to @xmath105 and @xmath941 , which contradicts the fact that @xmath930 .",
    "we prove @xmath942 by induction on @xmath522 .",
    "the base case is straightforward . for the inductive case ,",
    "let @xmath943 , @xmath933 and @xmath642 a finite play conforming to @xmath105 and starting in @xmath730 .",
    "since @xmath944 there exists @xmath945 such that @xmath587 .",
    "thus : @xmath946 by induction hypothesis , as @xmath947 conforms to @xmath105 and has length at least @xmath948 ( because @xmath945 , implying that @xmath949 ) , we have @xmath950 , thus @xmath934 .    to prove @xmath951 , let @xmath952 be a strategy of @xmath14 in @xmath266 defined by @xmath953 and @xmath954 for all @xmath55 and @xmath468 .",
    "let @xmath1 be a play starting in @xmath787 and conforming to @xmath952 .",
    "if @xmath1 does not reach @xmath181 , then @xmath955 .",
    "if @xmath1 reaches the target then @xmath684 is of the form @xmath956 , with @xmath957 .",
    "it is clear by construction of @xmath952 that @xmath958 is a finite play of @xmath7 that conforms to @xmath105 .",
    "furthermore , @xmath959 thus , from @xmath942 , we have that @xmath960 .",
    "this implies @xmath795 .",
    "hence , every play in @xmath266 conforming to @xmath952 and starting in @xmath787 has a value at least @xmath522 , which means that @xmath936 .",
    "item @xmath961 is then a direct consequence of @xmath951 .",
    "we are now ready to state and prove the inductive invariant allowing us to show the correctness of algorithm  [ algo : value - iter - tpo ] .",
    "[ lem : invariant ] before the @xmath298-th iteration of the external loop of algorithm  [ algo : value - iter - tpo ] , we have @xmath962 for all vertices @xmath62 .    for @xmath470 ,",
    "we have @xmath963 for all vertex @xmath55 .",
    "suppose then that the invariant holds for @xmath926 .",
    "we know that @xmath964 .",
    "moreover , after the assignment of line  [ line : end ] , by definition of @xmath281 , variable @xmath844 contains @xmath965 .",
    "the operation performed on line  [ line:3-line - infty ] only increases the values of vector @xmath844 , so that at the end of the @xmath298th iteration , we have @xmath966 .",
    "since @xmath281 is monotonous , and by the invariant at step @xmath298 , we obtain @xmath967 moreover , using again the monotony of @xmath281 and lemma  [ lem : pre - fixed - point ] , we have @xmath968 a closer look at line  [ line:3-line - infty ] shows that @xmath965 and @xmath969 coincide over vertices @xmath63 such that @xmath970 , and otherwise @xmath971 .",
    "hence , if @xmath970 , we directly obtain @xmath972 . otherwise , we know that @xmath973 . by corollary  [ cor : bornesvaleurstp ] , we know that @xmath922 , so that @xmath974 . in the overall",
    ", we have proved @xmath975    we are now able to prove the correction of the algorithm .    for @xmath976 ( remember that @xmath27 was defined in the previous section ) ,",
    "the invariant of lemma  [ lem : invariant ] becomes @xmath977 for all vertices @xmath62 .",
    "notice that the iteration may have stopped before iteration @xmath27 , in which case the sequence @xmath978 may be considered as stationary . in case @xmath398 , proposition  [ truetp2mcr ] proves that @xmath979 , so that we have @xmath980 . in case @xmath981",
    ", proposition  [ truetp2mcr ] shows that @xmath982 : by the operation performed at line  [ line:3-line - infty ] , we obtain that @xmath983 .",
    "hence , @xmath984 is an upper bound on the number of iterations before convergence of algorithm  [ algo : value - iter - tpo ] , and moreover , at the convergence , the algorithm outputs the vector of optimal values of the total - payoff game .",
    "we depict in fig .  [",
    "fig : monster - example ] a weighted graph parametrized with the number @xmath250 of _ layers _ , as well as the greatest weight @xmath985 . for both the min - cost reachability objective ( with @xmath181 the target ) and the total - payoff objectives , the values of the vertices are as follows : vertices @xmath986 and @xmath987 ( @xmath988 ) have value @xmath36 , whereas vertices @xmath989 ( @xmath990 ) have value @xmath160 . in our add - on prototype of prism , we model the min - cost objective with @xmath991 $ ] for @xmath14 and @xmath992 $ ] for @xmath15 , whereas total - payoff objectives are modelled by @xmath993 $ ] and @xmath994 $ ] .",
    "( 1 ) ; ( 2)[right of=1 ] ; ( 3)[right of=2 ] ; ( 4)[below of=2 ] ; ( 5)[right of=4 ] ; ( 6)[right of=5 ] ; ( 7)[below of=5 ] ;    ( ) [ right of=7 ]  ; ( 3n-3)[right of=7,xshift=2cm]@xmath995 ; ( 3n-2)[below of=7 , xshift=2cm]@xmath996 ; ( 3n-1)[right of=3n-2]@xmath997 ; ( 3n)[right of=3n-1]@xmath998 ; ( tg)[below of=3n-1 ] ;    \\(1 ) edge[bend left=40 ] node[above]@xmath162 ( 3 ) ( 1 ) edge[bend left=10 ] node[above]@xmath136 ( 2 ) ( 2 ) edge[bend left=10 ] node[below]@xmath36 ( 1 ) edge node[above]@xmath36 ( 3 ) ( 3 ) edge[loop right ] node[right]@xmath25 ( 3 ) ( 3 ) edge[bend right=10 ] node[above left]@xmath160 ( 4 ) ;    \\(4 ) edge[bend left=40 ] node[above]@xmath162 ( 6 ) ( 4 ) edge[bend left=10 ] node[above]@xmath136 ( 5 ) ( 5 ) edge[bend left=10 ] node[below]@xmath36 ( 4 ) edge node[above]@xmath36 ( 6 ) ( 6 ) edge[loop right ] node[right]@xmath25 ( 6 ) ( 6 ) edge[bend right=10 ] node[above left]@xmath160 ( 7 ) ;    ( 3n-3 ) edge[bend right=10 ] node[above left]@xmath160 ( 3n-2 ) ( 3n-2 ) edge[bend left=40 ] node[above]@xmath162 ( 3n ) ( 3n-2 ) edge[bend left=10 ] node[above]@xmath136 ( 3n-1 ) ( 3n-1 ) edge[bend left=10 ] node[below]@xmath36 ( 3n-2 ) edge node[above]@xmath36 ( 3n ) ( 3n ) edge[loop right ] node[right]@xmath25",
    "( 3n ) ( 3n ) edge[bend right=10 ] node[above left]@xmath160 ( tg ) ( tg ) edge[loop right ] node[right]@xmath36 ( tg ) ;    we present in the following table the time for resolution ( in seconds ) , the number of iterations in the external loop , and the total number of iterations in the internal loops for the total - payoff resolution , for various values of parameters @xmath160 and @xmath250 :    notice that due to the very little memory consumption of the algorithm , there is no risk of running out of memory .",
    "however , the execution time can become very large .",
    "for instance , in case @xmath999 and @xmath1000 , the execution time becomes @xmath1001 whereas the total number of iterations in the internal loop is greater than a million .    on this example , with @xmath761 components , the acceleration heuristics presented in details in appendix  [ sec",
    ": accel - heur - rtp ] gives excellent results .",
    "indeed , by combining both heuristics , we obtain the following results :    notice that the number of iterations in both internal and external loops do no longer depend on the choice of parameter @xmath160 , as well as the execution time .",
    "with respect to the execution time , the decrease from the case without acceleration is even larger , since the updates of vector @xmath228 inside the inner loop need only to be performed on the vertices of the current component . for large instances ,",
    "the execution time may again become very large , but in case @xmath999 ( as previously said , this value is independent of the result ) and @xmath1000 , it shrinks to @xmath1002 whereas the total number of iterations in the internal loop becomes @xmath1003 , i.e. , 5 orders of magnitude less than for the algorithm without acceleration heuristics .",
    "algorithm  [ algo : value - iteration - rt - acc ] and [ algo : value - iter - tpo - acc ] are enhanced versions of algorithm  [ algo : value - iteration - rt ] and [ algo : value - iter - tpo ] respectively , that apply the acceleration heuristics described at the end of section  [ sec : experiments ] ."
  ],
  "abstract_text": [
    "<S> quantitative games are two - player zero - sum games played on directed weighted graphs . </S>",
    "<S> total - payoff games  that can be seen as a refinement of the well - studied mean - payoff games  are the variant where the payoff of a play is computed as the sum of the weights . </S>",
    "<S> our aim is to describe the first pseudo - polynomial time algorithm for total - payoff games in the presence of arbitrary weights . </S>",
    "<S> it consists of a non - trivial application of the value iteration paradigm . </S>",
    "<S> indeed , it requires to study , as a milestone , a refinement of these games , called min - cost reachability games , where we add a reachability objective to one of the players . for these games </S>",
    "<S> , we give an efficient value iteration algorithm to compute the values and optimal strategies ( when they exist ) , that runs in pseudo - polynomial time . </S>",
    "<S> we also propose heuristics to speed up the computations . </S>"
  ]
}