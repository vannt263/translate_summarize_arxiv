{
  "article_text": [
    "local reasoning about programs focusses on the collection of resources directly acted upon by the program .",
    "it has recently been introduced and used to substantial effect in _ local _ hoare reasoning about memory update .",
    "researchers previously used hoare reasoning based on first - order logic to specify how programs interacted with the _ whole _ memory . ohearn",
    ", reynolds and yang instead introduced local hoare reasoning based on separation logic  @xcite .",
    "the idea is to reason only about the local parts of the memory ",
    "the _ footprints_that are accessed by a program .",
    "intuitively , the footprints form the pre - conditions of the _ small _ axioms , which provide the smallest complete specification of the program .",
    "all the true hoare triples are derivable from the small axioms and the general hoare rules .",
    "in particular , the _ frame rule _ extends the reasoning to properties about the rest of the heap which has not been changed by the command .",
    "ohearn , reynolds and yang originally introduced separation logic to solve the problem of how to reason about the mutation of data structures in memory .",
    "they have applied their reasoning to several memory models , including heaps based on pointer arithmetic  @xcite , heaps with permissions  @xcite , and the combination of heaps with variable stacks which views variables as resource  @xcite . in each case , the basic soundness and completeness results for local hoare reasoning are essentially the same .",
    "for this reason , calcagno , ohearn and yang  @xcite recently introduced abstract local functions over abstract resource models which they call separation algebras .",
    "they generalised their specific examples of local imperative commands and memory models in this abstract framework .",
    "they introduced abstract separation logic to provide local hoare reasoning about such functions , and give general soundness and completeness results .",
    "we believe that the general concept of a local function is a fundamental step towards establishing the theoretical foundations of local reasoning , and abstract separation logic is an important generalisation of the local hoare reasoning systems now widely studied in the literature . however , calcagno , ohearn and yang do not characterise the footprints and small axioms in this general theory , which is a significant omission .",
    "ohearn , reynolds and yang , in one of their first papers on the subject  @xcite , state the local reasoning viewpoint as :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` to understand how a program works , it should be possible for reasoning and specification to be confined to the cells that the program actually accesses .",
    "the value of any other cell will automatically remain unchanged . ' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a complete understanding of the foundations of local hoare reasoning therefore requires a formal characterisation of the footprint notion .",
    "ohearn tried to formalise footprints in his work on separation logic ( personal communication with ohearn ) .",
    "his intuition was that the footprints should be the smallest states on which the program is safe - the _ safety footprint _ , and that the _ small axioms _ arising from these footprints should give rise to a complete specification using the general rules for local hoare reasoning .",
    "however , yang discovered that this notion of footprint does not work , since it does not always yield a _",
    "complete _ specification for the program .",
    "consider the program @xmath0 this _ allocate - deallocate _ program allocates a new cell , stores its address value in the stack variable @xmath1 , and then deallocates the cell .",
    "it is local because all its atomic constituents are local .",
    "this tiny example captures the essence of a common type of program ; there are many programs which , for example , create a list , work on the list , and then destroy the list .",
    "the smallest heap on which the _ ad _ program is safe is the empty heap @xmath2 .",
    "the specification using this pre - condition is : @xmath3 we can extend our reasoning to larger heaps by applying the frame rule : for example , extending to a one - cell heap with arbitrary address @xmath4 and value @xmath5 gives @xmath6 however , axiom ( 1 ) does not give the complete specification of the _ ad _ program .",
    "in fact , it captures very little of the spirit of allocation followed by de - allocation .",
    "for example , the following triple is also true : @xmath7 this triple ( 3 ) is true because , if @xmath4 is already allocated , then the new address can not be @xmath4 and hence @xmath1 can not be @xmath4 .",
    "it can not be derived from ( 1 ) .",
    "however , the combination of axiom ( 1 ) and axiom ( 3 ) for arbitrary one - cell heaps does provide the smallest complete specification .",
    "this example illustrates that ohearn s intuitive view of the footprints as the minimal safe states just does not work for common imperative programs .    in this paper",
    ", we introduce the formal definition of the footprint of a local function that does yield a complete specification for the function . for our _ ad _ example",
    ", our definition identifies @xmath2 and the arbitrary one - cell heaps @xmath8 as footprints , as expected .",
    "we prove the general result that , for any local function , the footprints are the only elements which are _ essential _ to specify completely the behaviour of this function .",
    "we then investigate the question of _",
    "sufficiency_. for well - founded resource , we show that the footprints are also always sufficient : that is , a complete specification always exists that only uses the footprints .",
    "we also explore results for the non - well - founded case , which depend on the presence of _",
    "negativity_. a resource has negativity if it is possible to combine two non - unit elements to get the unit , which is like taking two non - empty pieces of resource and joining them to get nothing . for non - well - founded models without negativity , such as heaps with infinitely divisible fractional permissions , either the footprints are sufficient ( such as for the _ write _ command in the permissions model ) or there is no smallest complete specification ( such as for the _ read _ command in the permissions model ) . for models with negativity , such as the integers under addition , we show that there do exist smallest complete specifications based on elements that are not essential and hence not footprints .    in the final section",
    ", we apply our theory of footprints to the issue of regaining the safety footprints .",
    "we address a question that arose from discussions with ohearn and yang , which is whether there is an alternative model of ram in which the safety footprint does correspond to the actual footprint , yielding complete specifications .",
    "we present such a model based on an examination of the cause of the _ ad _ problem in the original model .",
    "we prove that in this new model the footprint of _ every _ program , including _",
    "ad _ , does correspond to the safety footprint .",
    "moreover , we identify a general condition on the primitive commands of a programming language which ensures that this property holds in arbitrary models .",
    "a preliminary version of this paper was presented at the fossacs 2008 conference .",
    "the final section reports on work that is new to this journal version .",
    "this paper also contains the proofs which were excluded from the conference paper .",
    "the discussion in this paper is based on the framework introduced in @xcite , where the approach of local reasoning about programs with separation logic was generalised to local reasoning about _",
    "local _ functions that act on an abstract model of resource .",
    "our objective in this work is to investigate the notion of footprint in this abstract setting , and this section gives a description of the underlying framework .",
    "we begin by describing separation algebras , which provide a model of resource which generalises over the specific heap models used in separation logic works .",
    "informally , a separation algebra models resource as a set of elements that can be ` glued ' together to create larger elements .",
    "the ` glueing ' operator satisfies properties in accordance with this resource intuition , such as commutativity and associativity , as well as the cancellation property which requires that , if we are given an element and a subelement , then ` ungluing ' that subelement gives us a unique element .",
    "a * separation algebra * is a cancellative , partial commutative monoid @xmath9 , where @xmath10 is a set and @xmath11 is a partial binary operator with unit @xmath12 .",
    "the operator satisfies the familiar axioms of associativity , commutativity and unit , using a partial equality on @xmath10 where either both sides are defined and equal , or both are undefined .",
    "it also satisfies the cancellative property stating that , for each @xmath13 , the partial function @xmath14 is injective .",
    "we shall sometimes overload notation , using @xmath10 to denote the separation algebra @xmath9 .",
    "examples of separation algebras include multisets with union and unit @xmath15 , the natural numbers with addition and unit @xmath16 , heaps as finite partial functions from locations to values (  @xcite and example [ locsepexamples ] ) , heaps with permissions  @xcite , and the combination of heaps and variable stacks enabling us to model programs with variables as local functions (  @xcite ,  @xcite and example [ locsepexamples ] ) .",
    "these examples all have an intuition of resource , with @xmath17 intuitively giving more resource than just @xmath18 and @xmath19 for @xmath20 .",
    "however , notice that the general notion of a separation algebra also permits examples which may not have this resource intuition , such as @xmath21 with @xmath22 . since our aim is to investigate general properties of local reasoning , our inclination is to impose minimal restrictions on what counts as resource and to work with a simple definition of a separation algebra .",
    "given a separation algebra @xmath9 , the * separateness * ( @xmath23 ) relation between two states @xmath24 is given by @xmath25 .",
    "the * substate * ( @xmath26 ) relation is given by @xmath27 .",
    "we write @xmath28 when @xmath29 and @xmath30 .",
    "[ subtraction ] for @xmath31 , if @xmath32 then there exists a unique element denoted @xmath33 , such that @xmath34 .",
    "existence follows by definition of @xmath26 . for uniqueness , assume there exist @xmath35 such that @xmath36 and @xmath37 .",
    "then we have @xmath38 , and thus by the cancellation property we have @xmath39 .",
    "we consider functions on separation algebras that generalise imperative programs operating on heaps .",
    "such programs can behave non - deterministically , and can also _ fault_. to model non - determinism , we consider functions from a separation algebra @xmath10 to its powerset @xmath40 . to model faulting , we add a special top element @xmath41 to the powerset .",
    "we therefore consider total functions of the form @xmath42 . on any element of @xmath10 ,",
    "the function can either map to a set of elements , which models _ safe _ execution with non - deterministic outcomes , or to @xmath41 , which models a faulting execution .",
    "mapping to the empty set represents divergence ( non - termination ) .",
    "the standard subset relation on the powerset is extended to @xmath43 by defining @xmath44 for all @xmath45 .",
    "the binary operator @xmath46 on @xmath43 is given by @xmath47 @xmath43 is a total commutative monoid under @xmath46 with unit @xmath48 .    for functions @xmath49 , @xmath50 iff @xmath51 for all @xmath13 .",
    "we shall only consider functions that are _ well - behaved _ in the sense that they act _ locally _ with respect to resource .",
    "for imperative commands on the heap model , the locality conditions were first characterised in @xcite , where a soundness proof for local reasoning with separation logic was demonstrated for the specific heap model .",
    "the conditions identified were    1 .",
    "_ safety monotonicity _ :",
    "if the command is safe on some heap , then it is safe on any larger heap .",
    "_ frame property _",
    ": if the command is safe on some heap , then in any outcome of applying the command on a larger heap , the additional heap portion will remain unchanged by the command .",
    "in @xcite , these two properties were amalgamated and formulated for abstract functions on arbitrary separation algebras .",
    "[ def : localaction ] a * local function on @xmath10 * is a total function @xmath42 which satisfies the * locality condition * : @xmath52 we let @xmath53 be the set of local functions on @xmath10 .    intuitively , we think of a command to be local if , whenever the command executes safely on any resource element , then the command will not ` touch ' any additional resource that may be added .",
    "safety monotonicity follows from the above definition because , if @xmath54 is safe on @xmath55 ( @xmath56 ) , then it is safe on any larger state , since @xmath57 .",
    "the frame property follows by the fact that the additional state @xmath58 is preserved in the output of @xmath59 .",
    "note , however , that the @xmath60 ordering allows for reduced non - determinism on larger states .",
    "this , for example , is the case for the @xmath61 command from the introduction which allocates a cell , assigns its address to stack variable @xmath1 , and then deallocates the cell . on the empty heap ,",
    "its result would allow all possible values for variable @xmath1 .",
    "however , on the larger heap where cell 1 is already allocated , its result would allow all values for @xmath1 except 1 , and we therefore have a more deterministic outcome on this larger state .",
    "locality is preserved under sequential composition , non - deterministic choice and kleene - star , which are defined as @xmath62    [ locsepexamples ]    1 .   *",
    "plain heap model*. a simple example is the separation algebra of heaps @xmath63 , where @xmath64 are finite partial functions from a set of locations @xmath65 to a set of values @xmath66 with @xmath67 , the partial operator @xmath11 is the union of partial functions with disjoint domains , and the unit @xmath68 is the function with the empty domain . for @xmath69 ,",
    "let @xmath70 be the domain of @xmath71 .",
    "we write @xmath8 for the partial function with domain @xmath72 that maps @xmath4 to @xmath5 . for @xmath73 , if @xmath74 then @xmath75 .",
    "an example of a local function is the @xmath76 $ ] command that deletes the cell at location @xmath4 : @xmath77(h )   = \\left\\ { \\begin{array}{ll }   \\begin{array}{l}\\{h - ( l { \\!\\mapsto\\!}v)\\ } \\end{array } & \\ ; h \\succeq ( l { \\!\\mapsto\\!}v ) \\\\ \\begin{array}{l } \\top \\end{array } & \\ ; \\mbox{otherwise }   \\end{array}\\right.\\ ] ] the function is local : if @xmath78 then @xmath76(h ) = \\top$ ] , and @xmath76(h ' \\bullet h ) \\sqsubseteq \\top$ ] .",
    "otherwise , @xmath76(h ' \\bullet h )   = \\{(h'\\bullet h ) - ( l { \\!\\mapsto\\!}v)\\ }   \\sqsubseteq   \\{h'\\ } * \\{h - ( l { \\!\\mapsto\\!}v)\\ }    = \\{h'\\ } * dispose[l](h)$ ] .",
    "heap and stack*. there are two approaches to modelling the stack in the literature .",
    "one is to treat the stack as a total function from variables to values , and only combine two heap and stack pairs if the stacks are the same . the other approach , which we use here , is to allow splitting of the variable stack and treat it as part of the resource .",
    "we can incorporate the variable stack into the heap model by using the set @xmath79 , where @xmath65 and @xmath66 are as before and @xmath80 is the set of stack variables @xmath81 .",
    "the @xmath11 operator combines heap and stack portions with disjoint domains , and is undefined otherwise .",
    "the unit @xmath68 is the function with the empty domain which represents the empty heap and empty stack .",
    "although this approach is limited to disjoint reference to stack variables , this constraint can be lifted by enriching the separation algebra with _ permissions _ @xcite .",
    "however , this added complexity using permissions can be avoided for the discussion in this paper . for a state @xmath69 , we let @xmath82 and @xmath83 denote the set of heap locations and stack variables in the domain of @xmath71 respectively . in this model",
    "we can define the allocation and deallocation commands as @xmath84(h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\mid w \\in val , l \\in l \\backslash loc(h')\\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet",
    "x { \\!\\mapsto\\!}v \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr",
    "dispose[x](h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v   \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr}\\ ] ] + commands for heap mutation and lookup can be defined as @xmath85(h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v \\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}w \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr lookup[x , y](h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v \\bullet y { \\!\\mapsto\\!}v \\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet y { \\!\\mapsto\\!}w \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr}\\ ] ] the _ ad _ command described in the introduction , which is the composition @xmath86;dispose[x]$ ] , corresponds to the following local function @xmath87 note that in all cases , any stack variables that the command refers to should be in the stack in order for the command to execute safely , otherwise the command will be acting non - locally .",
    "3 .   * integers*. the integers form a separation algebra under addition with identity 0 . in this case",
    "we have that any ` adding ' function @xmath88 that adds a constant @xmath89 is local , while a function that multiplies by a constant @xmath89 , @xmath90 , is non - local in general .",
    "however , the integers under multiplication also form a separation algebra with identity 1 , and in this case every multiplying function is local but not every adding function .",
    "this illustrates the point that the notion of locality of commands depends on the notion of separation of resource that is being used .",
    "we now present the local reasoning framework for local functions on separation algebras .",
    "this is an adaptation of abstract separation logic @xcite , with some minor changes in formulation for the purposes of this paper .",
    "predicates over separation algebras are treated simply as subsets of the separation algebra .",
    "[ definition : predicates ] a * predicate * @xmath91 over @xmath10 is an element of the powerset @xmath40 .    note that the top element @xmath41 is not a predicate and that the @xmath92 operator , although defined on @xmath93 , acts as a binary connective on predicates .",
    "we have the distributive law for union that , for any @xmath94 , @xmath95 the same is not true for intersection in general , but does hold for @xmath96 predicates . a predicate is precise if , for any state , there is at most a single substate that satisfies the predicate .    [ precise ] a predicate @xmath97 is * precise * iff , for every @xmath13 , there exists at most one @xmath98 such that @xmath99 .",
    "thus , with precise predicates , there is at most a unique way to break a state to get a substate that satisfies the predicate .",
    "any singleton predicate @xmath100 is precise .",
    "another example of a precise predicate is @xmath101 for some @xmath4 , while @xmath102 for some @xmath5 is not precise .",
    "[ precisecharacterization ] a predicate @xmath91 is precise iff , for all @xmath94 , @xmath103    we first show the left to right direction .",
    "assume @xmath91 is precise .",
    "we have to show that for all @xmath94 , @xmath103 .",
    "assume @xmath104 .",
    "then there exist @xmath105 such that @xmath106 and @xmath107 and @xmath108 .",
    "thus for all @xmath109 , @xmath110 , and hence @xmath111 .",
    "now assume @xmath111 .",
    "then @xmath110 for all @xmath109 .",
    "hence there exists @xmath112 such that @xmath113 . since @xmath91 is precise , @xmath18 is unique",
    ". let @xmath114 .",
    "thus we have @xmath115 for all @xmath109 , and so @xmath116 .",
    "hence we have @xmath104 .    for the other direction ,",
    "we assume that @xmath91 is not precise and show that there exists an @xmath117 such that @xmath118 .",
    "since @xmath91 is not precise , there exists @xmath13 such that , for two distinct @xmath119 , we have @xmath112 and @xmath120 .",
    "let @xmath121 and @xmath122 .",
    "now let @xmath123 .",
    "since @xmath124 and @xmath125 , we have @xmath111 .",
    "however , because of the cancellation property , we also have that @xmath126 , and so @xmath127 .",
    "hence , @xmath128 , and we therefore have @xmath118 .",
    "our hoare reasoning framework is formulated with tuples of pre- and post- conditions , rather than the usual hoare triples that include the function as in @xcite . in our case",
    "the standard triple shall be expressed as a function @xmath54 _ satisfying _ a tuple @xmath129 , written @xmath130 .",
    "the reason for this is that we shall be examining the properties that a pre- and post- condition tuple may have with respect to a given function , such as whether a given tuple is complete for a given function .",
    "this approach is very similar to the notion of the _ specification statement _ ( a hoare triple with a ` hole ' ) introduced in @xcite , which is used in refinement calculi , and was also used to prove completeness of a local reasoning system in @xcite .",
    "let @xmath10 be a separation algebra .",
    "a * statement * on @xmath10 is a tuple @xmath129 , where @xmath131 are predicates .",
    "a * specification * @xmath132 on @xmath10 is a set of statements .",
    "we let @xmath133 denote the set of all specifications on @xmath10 .",
    "we shall exclude the subscript when it is clear from the context .",
    "the * domain * of a specification is defined as @xmath134 .",
    "* domain equivalence * is defined as @xmath135 .",
    "thus the domain is the union of the preconditions of all the statements in the specification .",
    "it is one possible measure of _ size _ : how much of @xmath10 the specification is referring to .",
    "we also adapt the notion of precise predicates to specifications .",
    "[ precisesaturatedspecification ] a specification is precise iff its domain is precise .",
    "a local function @xmath54 satisfies a statement @xmath136 , written @xmath137 , iff , for all @xmath138 , @xmath139 .",
    "it satisfies a specification @xmath140 , written @xmath141 , iff @xmath130 for all @xmath142 .",
    "[ semanticconsequence ] let @xmath143 and @xmath144 .",
    "each judgement @xmath145 , @xmath146 , and @xmath147 holds iff all local functions that satisfy the left hand side also satisfy the right hand side .    [ ordercharacterization ] @xmath50 iff , for all @xmath148 , @xmath149 implies @xmath130 .    for every specification @xmath132",
    ", there is a ` best ' local function satisfying @xmath132 ( lemma [ blalemma ] ) , in the sense that all statements that the best local function satisfies are satisfied by any local function that satisfies @xmath132 .",
    "for example , in the heap and stack separation algebra of example [ locsepexamples].2 , consider the specification @xmath150 there are many local functions that satisfy this specification .",
    "trivially , the local function that always diverges satisfies it .",
    "another example is the local function that assigns the value @xmath151 of the newly allocated cell to be 0 , rather than any non - deterministically chosen value .",
    "however , the best local function for this specification is the @xmath86 $ ] function described in example [ locsepexamples].2 , as it can be checked that for any local function @xmath54 satisfying @xmath152 , we have @xmath153 $ ] .",
    "the notion of the best local function shall be used when addressing questions about completeness of specifications .",
    "it is adapted from @xcite , except that we generalise to the best local function of a specification rather than a single pre- and post - condition pair .    for a specification @xmath140 ,",
    "the best local function of @xmath132 , written @xmath154 $ ] , is the function of type @xmath155 defined by @xmath156(\\sigma ) = \\bigsqcap \\{\\{\\sigma'\\ } * q \\mid \\sigma = \\sigma'\\bullet\\sigma '' , \\sigma''\\in p , ( p , q ) \\in \\phi\\}\\ ] ]    as an example , it can be checked that the best local function @xmath157 $ ] of the specification @xmath152 given above is indeed the function @xmath86 $ ] described in example [ locsepexamples].2 .",
    "the following lemma presents the important properties which characterise the best local function .",
    "[ blalemma ] let @xmath140 .",
    "the following hold :    1 .",
    "@xmath154 $ ] is local 2 .",
    "@xmath154 \\models \\phi$ ] 3 .   if @xmath54 is local and @xmath141 then @xmath158 $ ]    to show that @xmath154 $ ] is local , consider @xmath159 such that @xmath160 .",
    "we then calculate @xmath161(\\sigma_1\\bullet \\sigma_2)\\enspace = & \\bigsqcap \\{\\{\\sigma'\\ } * q \\mid \\sigma_1\\bullet \\sigma_2 = \\sigma'\\bullet \\sigma '' , \\sigma''\\in p , ( p , q ) \\in \\phi\\ } \\\\",
    "\\sqsubseteq & \\bigsqcap \\{\\{\\sigma_1\\bullet \\sigma'''\\ } * q \\mid \\sigma_2=\\sigma'''\\bullet \\sigma '' , \\sigma''\\in p , ( p , q ) \\in \\phi\\ } \\\\ = &",
    "\\bigsqcap \\{\\{\\sigma_1\\ } * \\{\\sigma'''\\ } * q \\mid \\sigma_2=\\sigma'''\\bullet \\sigma '' , \\sigma''\\in p , ( p , q ) \\in \\phi\\ } \\\\",
    "= & \\{\\sigma_1\\ } *   \\bigsqcap \\{\\{\\sigma'''\\ } * q \\mid \\sigma_2=\\sigma'''\\bullet \\sigma '' , \\sigma''\\in p , ( p , q ) \\in \\phi\\ } \\\\",
    "= & \\{\\sigma_1\\ } * { \\mathit{bla}}[\\phi](\\sigma_2 )   \\end{array}\\ ] ] in the second - last step we used the property that @xmath162 is precise ( lemma [ precisecharacterization ] ) .",
    "+ to show that @xmath154 $ ] satisfies @xmath132 , consider @xmath163 and @xmath164",
    ". then @xmath154(\\sigma ) \\sqsubseteq \\{u\\ } * q = q$ ] .",
    "for the last point , suppose @xmath54 is local and @xmath141 .",
    "then , for any @xmath55 such that @xmath165 and @xmath166 and @xmath142 , @xmath167 thus @xmath168(\\sigma)$ ] .",
    "+ in the case that there do not exist @xmath159 such that @xmath165 and @xmath169 , then @xmath170(\\sigma ) & = & \\bigsqcap \\emptyset \\\\ & = & \\top \\\\ \\end{array}\\ ] ] so in this case also @xmath168(\\sigma)$ ] .",
    "[ blaconsequence ] for @xmath140 and @xmath131 , @xmath154 \\models ( p , q ) \\leftrightarrow \\phi \\models ( p , q)$ ] .",
    "@xmath171 \\models ( p , q ) \\\\ \\hbox to50 pt{\\hfill } \\leftrightarrow   & \\mbox{for all local functions } f,\\ ;     f \\models \\phi \\rightarrow f \\models ( p , q )   & \\mbox { ( by lemma \\ref{blalemma } ) } \\\\",
    "\\hbox to50 pt{\\hfill } \\leftrightarrow   & \\phi \\models ( p , q )   & \\mbox { ( by definition \\ref{semanticconsequence})}.    \\hbox to51 pt{\\hfill\\qed } \\end{array}\\ ] ]    ' '' ''    @xmath172 @xmath173 frame & consequence & union & intersection   \\end{array}\\ ] ]    ' '' ''    the inference rules of the proof system are given in figure [ figure : rules ] .",
    "consequence , union and intersection are adaptations of standard rules of hoare logic .",
    "the frame rule is what permits local reasoning , as it codifies the fact that , since all functions are local , any assertion about a separate part of resource will continue to hold for that part after the application of the function .",
    "we omit the standard rules for basic constructs such as sequential composition , non - deterministic choice , and kleene - star which can be found in @xcite .",
    "[ proofconsequence ] for predicates @xmath174 and specifications @xmath175 , each of the judgements @xmath176 , @xmath177 , and @xmath178 holds iff the right - hand side is derivable from the left - hand side by the rules in figure [ figure : rules ] .    the proof system of figure [ figure : rules ] is sound and complete with respect to the satisfaction relation .",
    "[ completeness ] @xmath179    soundness can be checked by checking each of the proof rules in figure [ figure : rules ] .",
    "the frame rule is sound by the locality condition , and the others are easy to check",
    ".    for completeness , assume we are given @xmath180 . by lemma [ blaconsequence ] , we have @xmath154 \\models ( p , q)$ ] .",
    "so for all @xmath138 , @xmath154(\\sigma ) \\sqsubseteq q$ ] , which implies @xmath181(\\sigma ) \\sqsubseteq q \\quad ( * ) \\ ] ] now we have the following derivation :    @xmath182(\\sigma ) )        }      {             \\infer          {              ( \\{\\sigma\\ } , { \\mathit{bla}}[\\phi](\\sigma ) ) \\quad \\mbox{\\tiny{for all $ \\sigma \\in p$ } }          }          {              \\infer              {                  \\big ( \\displaystyle\\bigsqcap_{\\substack{\\sigma ' \\preceq \\sigma \\\\ \\sigma ' \\in r \\\\",
    "( r , s ) \\in \\phi } }   \\{\\sigma - \\sigma'\\ } * \\{\\sigma'\\ } , \\displaystyle\\bigsqcap_{\\substack{\\sigma ' \\preceq \\sigma \\\\ \\sigma ' \\in r \\\\",
    "( r , s ) \\in \\phi } }   \\{\\sigma - \\sigma'\\ } * s \\big ) \\quad \\mbox{\\tiny{for all $ \\sigma \\in p$ } }              }                 {                  \\infer                  {                             ( \\{\\sigma - \\sigma'\\ } * \\{\\sigma'\\ } , \\{\\sigma - \\sigma'\\ } * s ) \\quad \\mbox{\\tiny{for all $ \\sigma ' \\in r , ( r , s ) \\in \\phi , \\sigma ' \\preceq \\sigma , \\sigma \\in p$ } }                  }                  {                      \\infer                      {                          ( \\{\\sigma'\\ } , s ) \\quad \\mbox{\\tiny{for all $ \\sigma ' \\in r , ( r , s ) \\in \\phi$ } }                      }                      {                          \\infer                          {                              ( r , s ) \\quad \\mbox{\\tiny{for all $ ( r , s ) \\in \\phi$ } }                          }                          {                              \\phi                          }                                             }                  }              }          }      } } \\ ] ] the last step in the proof is by @xmath183 and the rule of consequence .",
    "note that the intersection rule can be safely applied because the argument of the intersection is necessarily non - empty ( if it were empty then @xmath154(\\sigma ) = \\top$ ] , which contradicts @xmath154(\\sigma ) \\sqsubseteq q$ ] ) .",
    "we discuss certain properties of specifications as a prerequisite for our main discussion on footprints in section  4 .",
    "we introduce the notion of a _ complete _ specification for a local function , which is a specification from which follows every property that holds for the function .",
    "however , a function may have many complete specifications , so we introduce a canonical form for specifications . we show that of all the complete specifications of a local function , there exists a unique canonical complete specification for every domain . as discussed in the introduction ,",
    "an important notion of local reasoning is the _ small specification _ which completely describes the behaviour of a local function by mentioning only the footprint .",
    "thus , as a prerequisite to investigating their existence , we formalise small specifications as complete specifications with the smallest possible domain .",
    "similarly , we define _ big _ specifications as complete specifications with the biggest domain .",
    "a specification @xmath140 is a * complete specification * for @xmath54 , written @xmath184 , iff , for all @xmath131,@xmath185 .",
    "let * @xmath186 * be the set of all complete specifications of f.    @xmath132 is complete for @xmath54 whenever the tuples that hold for @xmath54 are _ exactly _ the tuples that follow from @xmath132 .",
    "this also means that any two complete specfications @xmath132 and @xmath187 for a local function are semantically equivalent , that is , @xmath188 .",
    "the following proposition illustrates how the notions of best local action and complete specification are closely related .",
    "[ blaiffcomplete ] for all @xmath140 and local functions @xmath54 , @xmath189 $ ] .",
    "assume @xmath54 = @xmath190 $ ] .",
    "then , by lemma [ blaconsequence ] , we have that @xmath132 is a complete specification for @xmath54 .    for the converse , assume @xmath184 .",
    "we shall show that for any @xmath13 , @xmath191(\\sigma)$ ] .",
    "* case 1 : @xmath192*. if @xmath154(\\sigma ) \\neq \\top$ ] , then @xmath154 \\models ( \\{\\sigma\\ } , { \\mathit{bla}}[\\phi](\\sigma))$ ] .",
    "this means that @xmath193(\\sigma))$ ] ( by lemma [ blaconsequence ] ) , and so @xmath194(\\sigma))$ ] , but this is a contradiction .",
    "therefore , @xmath154(\\sigma ) = \\top$ ]    * case 2 : @xmath154(\\sigma ) = \\top$]*. if @xmath195 , then @xmath196 .",
    "this means that @xmath197 , and so @xmath154 \\models ( \\{\\sigma\\ } , f(\\sigma))$ ] , but this is a contradiction .",
    "therefore , @xmath192    * case 3 : @xmath154(\\sigma ) \\neq \\top$ ] and @xmath195*. we have @xmath198 \\models ( \\{\\sigma\\ } , f(\\sigma ) ) \\\\ \\rightarrow & { \\mathit{bla}}[\\phi](\\sigma ) \\sqsubseteq f(\\sigma ) \\\\\\\\ & { \\mathit{bla}}[\\phi ] \\models ( \\{\\sigma\\ } , { \\mathit{bla}}[\\phi](\\sigma ) ) \\\\ \\rightarrow & f \\models ( \\{\\sigma\\ } , { \\mathit{bla}}[\\phi](\\sigma ) ) \\\\ \\rightarrow & f(\\sigma ) \\sqsubseteq { \\mathit{bla}}[\\phi](\\sigma ) \\end{array}\\ ] ]    therefore @xmath191(\\sigma)$ ]    any specification is therefore only complete for a unique local function , which is its best local action .",
    "however , a local function may have lots of complete specifications .",
    "for example , if @xmath132 is a complete specification for @xmath54 and @xmath142 , then @xmath199 is also complete for @xmath54 if @xmath200 . for this reason it will be useful to have a canonical form for specifications .",
    "the * canonicalisation * of a specification @xmath132 is defined as @xmath201(\\sigma ) ) \\mid \\sigma \\in d(\\phi ) \\ } $ ] .",
    "a specification is in * canonical * form if it is equal to its canonicalisation .",
    "let @xmath202 denote the set of all canonical complete specifications of @xmath54 .",
    "notice that a given local function does not necessarily have a _ unique _",
    "canonical complete specification .",
    "for example , both @xmath203 and @xmath204 , for some @xmath13 , are canonical complete specifications for the identity function .    [ canproposition ] for any specification @xmath132 , we have @xmath205 .",
    "we first show @xmath206 . for any @xmath207 ,",
    "@xmath129 is of the form @xmath208(\\sigma))$ ] for some @xmath209 .",
    "so we have @xmath154 \\models ( p , q)$ ] , and so @xmath180 by lemma [ blaconsequence ] .",
    "we now show @xmath210 . for any @xmath142",
    ", we have @xmath154 \\models ( p , q)$ ] .",
    "so for all @xmath138 , @xmath154(\\sigma ) \\sqsubseteq q$ ] , which implies @xmath181(\\sigma ) \\sqsubseteq q \\quad ( * ) \\ ] ] now we have the following derivation : @xmath182(\\sigma ) )        }      {             \\infer          {              ( \\{\\sigma\\ } , { \\mathit{bla}}[\\phi](\\sigma ) ) \\quad \\mbox{\\scriptsize{for all $ \\sigma \\in p$ } }          }          {              \\phi_{can }          }                             } } \\ ] ] the last step is by @xmath183 and consequence .",
    "so we have @xmath211 , and by soundness @xmath212 .",
    "thus , the canonicalisation of a specification is logically equivalent to the specification .",
    "the following corollary shows that all complete specifications that have the same domain have a unique canonical form , and specifications of different domains have different canonical forms .",
    "[ candomainisomorphism ] @xmath202 is isomorphic to the quotient set @xmath213 , under the isomorphism that maps @xmath214_{\\cong_{d}}$ ] to @xmath215 , for every @xmath216 . by proposition [ blaiffcomplete ] ,",
    "all complete specifications for @xmath54 have the same best local action , which is @xmath54 itself .",
    "so by the definition of canonicalisation , it can be seen that complete specifications with different domains have different canonicalisations , and complete specifications with the same domain have the same canonicalisation .",
    "this shows that the mapping is well - defined and injective .",
    "every canonical complete specification @xmath132 is also complete , and @xmath214_{\\cong_{d}}$ ] maps to @xmath217 , so the mapping is surjective .",
    "[ bigsmallspec ] @xmath132 is a * small specification * for @xmath54 iff @xmath216 and there is no @xmath218 such that @xmath219 .",
    "a * big specification * is defined similarly .    _ small _ and _ big _ specifications are thus the specifications with the smallest and biggest domains respectively .",
    "the question is if / when small and big specifications exist .",
    "the following result shows that a canonical big specification exists for every local function .",
    "[ bigspec ] for any local function @xmath54 , the canonical big specification for @xmath54 is given by @xmath220 .",
    "@xmath221 is trivial to check . to show @xmath222 , assume @xmath130 for some @xmath131 .",
    "note that , for any @xmath138 , @xmath139 and so @xmath223 . we then have the derivation @xmath224 by soundness we get @xmath225 .",
    "@xmath226 has the biggest domain because @xmath54 would fault on any element not included in @xmath226 .",
    "the notion of a small specification has until now been used in an informal sense in local reasoning papers @xcite as specifications that completely specify the behaviour of an update command by only describing the command s behaviour on the part of the resource that it affects .",
    "although these papers present examples of such specifications for specific commands , the notion has so far not received a formal treatment in the general case .",
    "the question of the existence of small specifications is strongly related to the concept of footprints , since finding a small specification is about finding a complete specification with the smallest possible domain , and therefore enquiring about which elements of @xmath10 are essential and sufficient for a complete specification .",
    "this requires a formal characterisation of the footprint notion , which we shall now present .",
    "in the introduction we discussed how the _ ad _ program demonstrates that the footprints of a local function do not correspond simply to the smallest safe states , as these states alone do not always yield complete specifications . in this section",
    "we introduce the definition of footprint that does yield complete specifications . in order to understand what the footprint of a local function should be , we begin by analysing the definition of locality . recall that the definition of locality ( definition [ def : localaction ] ) says that the action on a certain state @xmath18 imposes a _",
    "limit _ on the action on a bigger state @xmath227 .",
    "this limit is @xmath228 , as we have @xmath229 .",
    "another way of viewing this definition is that for any state @xmath55 , the action of the function on that state has to be within the limit imposed by _ every _ substate @xmath58 of @xmath55 , that is , @xmath230 . in the case where @xmath231 , this condition is trivially satisfied for any function ( local or non - local ) .",
    "the distinguishing characteristic of local functions is that this condition is also satisfied by every strict substate of @xmath55 , and thus we have @xmath232 we define this overall constraint imposed on @xmath55 by all of its strict substates as the _ local limit _ of @xmath54 on @xmath55 , and show that the locality definition is equivalent to satisfying the local limit constraint .    for a local function @xmath54 on @xmath10 and @xmath13 ,",
    "the * local limit * of @xmath54 on @xmath55 is defined as @xmath233    [ locallimitproposition]@xmath234    assume @xmath54 is local .",
    "so for any @xmath55 , for every @xmath235 , @xmath230 .",
    "@xmath236 is therefore smaller than the intersection of all these sets , which is @xmath237 .    for the converse , assume the rhs and that @xmath17 is defined . if @xmath238 then @xmath239 and we are done",
    "otherwise , @xmath240 and we have @xmath241 .    thus for any local function @xmath54 acting on a certain state @xmath55 , the local limit determines a _",
    "smallest upper bound _ on the possible outcomes on @xmath55 , based on the outcomes on all smaller states .",
    "if this smallest upper bound does correspond exactly to the set of all possible outcomes on @xmath55 , then @xmath55 is ` large enough ' that just the action of @xmath54 on smaller states and the locality of @xmath54 determines the complete behaviour of @xmath54 on @xmath55 . in this case",
    "we will not think of @xmath55 as a footprint of @xmath54 , as smaller states are sufficient to determine the action of @xmath54 on @xmath55 . with this observation",
    ", we define footprints as those states on which the outcomes can not be determined only by the smaller states , that is , the set of outcomes is a _ strict _ subset of the local limit .",
    "[ def : footprint ] for a local function @xmath54 and @xmath13 , @xmath55 is a footprint of @xmath54 , written @xmath242 , iff @xmath243 .",
    "we denote the set of footprints of @xmath54 by @xmath244 .",
    "note that an element @xmath55 is therefore not a footprint if and only if the action of @xmath54 on @xmath55 is at the local limit , that is @xmath245 .",
    "[ minstates ] for any local function @xmath54 , the smallest safe states of @xmath54 are footprints of @xmath54 .",
    "let @xmath55 be a smallest safe state for @xmath54 .",
    "then for any @xmath235 , @xmath246 .",
    "therefore @xmath247 and so @xmath243",
    ".    however , the smallest safe states are not always the _ only _ footprints .",
    "an example is the _ ad _ command discussed in the introduction .",
    "the empty heap is a footprint as it is the smallest safe heap , but the heap cell @xmath248 is also a footprint .",
    "[ dispose ] the footprints of the @xmath76 $ ] command in the plain heap model ( example [ locsepexamples].1 ) are the cells at location @xmath4 .",
    "we check this by considering the following cases    1 .",
    "the empty heap , @xmath68 , is not a footprint since @xmath249}(u_h ) = \\top = dispose[l](u_h)$ ] 2 .",
    "every cell @xmath248 for some @xmath5 is a footprint @xmath250}(l { \\!\\mapsto\\!}v ) =   \\{l { \\!\\mapsto\\!}v\\ } * dispose[l](u_h ) =   \\{l { \\!\\mapsto\\!}v\\ } * \\top =   \\top\\\\ dispose[l](l { \\!\\mapsto\\!}v ) = \\{u_h\\ } \\sqsubset l_{dispose[l]}(l { \\!\\mapsto\\!}v ) \\end{array}\\ ] ] 3 .",
    "every state @xmath55 such that @xmath251 for some @xmath5 is not a footprint @xmath252}(\\sigma ) \\sqsubseteq",
    "\\{\\sigma - ( l { \\!\\mapsto\\!}v)\\ } * dispose[l](l { \\!\\mapsto\\!}v ) =   \\{\\sigma - ( l { \\!\\mapsto\\!}v)\\ } =   dispose[l](\\sigma)\\ ] ] by proposition [ locallimitproposition ] , we have @xmath249}(\\sigma ) =   dispose[l](\\sigma)$ ] .",
    "the intuition is that @xmath55 does not characterise any ` new ' behaviour of the function : its action on @xmath55 is just a consequence of its action on the cells at location @xmath4 and the locality property of the function .",
    "every state @xmath55 such that @xmath253 for some @xmath5 is not a footprint @xmath252}(\\sigma ) \\sqsubseteq",
    "\\{\\sigma\\ } * dispose[l](u_h ) =   \\{\\sigma\\ } * \\top = \\top =   dispose[l](\\sigma)\\ ] ] again by proposition [ locallimitproposition ] , @xmath249}(\\sigma ) =   dispose[l](\\sigma)$ ] .",
    "[ ad ] the _ ad _ ( allocate - deallocate ) command was defined on the heap and stack model in example [ locsepexamples].2 .",
    "we have the following cases for @xmath55 .    1 .",
    "@xmath254 for some @xmath255 is not a footprint , since @xmath256 .",
    "2 .   @xmath257 for some @xmath255 is a footprint since @xmath258 ( by case ( 1 ) ) and @xmath259 .",
    "3 .   @xmath260 for some @xmath261 is a footprint .",
    "@xmath262 4 .",
    "@xmath263 for some @xmath255 , and where @xmath264 , is not a footprint .",
    "@xmath265 by proposition [ locallimitproposition ] , we get @xmath266 .",
    "our footprint definition therefore works properly for these specific examples .",
    "now we give the formal general result which captures the underlying intuition of local reasoning , that the footprints of a local function are the only essential elements for a complete specification of the function .",
    "[ essentialitytheorem ] the footprints of a local function are the essential domain elements for any complete specification of that function , that is , @xmath267    assume some fixed @xmath54 and @xmath55 .",
    "we establish the following equivalent statement : @xmath268 we first show the right to left implication .",
    "so assume @xmath132 is a complete specification of @xmath54 such that @xmath269 . since @xmath184 , by proposition [ blaiffcomplete ] , we have @xmath270 $ ] .",
    "so @xmath271 now for any set @xmath272 in the above intersection , we have that @xmath113 , and @xmath142 for some @xmath91 .",
    "since @xmath113 , we have @xmath273 , and therefore @xmath274 .",
    "also , @xmath275 , because otherwise we would have @xmath138 , which would contradict the assumption that @xmath276 .",
    "so @xmath277 and we have @xmath278 so the local limit is smaller than each set @xmath272 in the intersection , and therefore it is smaller than the intersection itself : @xmath279 .",
    "we know from proposition [ locallimitproposition ] that @xmath280 , so we get @xmath245 and therefore @xmath281 .",
    "we now show the left to right implication .",
    "assume that @xmath55 is not a footprint of @xmath54 .",
    "we shall use the big specification , @xmath226 , to construct a complete specification of @xmath54 which does not contain @xmath55 in its domain . if @xmath192 then the big specification itself is such a specification , and we are done .",
    "otherwise assume @xmath56 .",
    "let @xmath282 .",
    "it can be seen that @xmath276 .",
    "now we need to show that @xmath132 is complete for @xmath54 . for this",
    "it is sufficient to show @xmath283 because we know that @xmath226 is complete for @xmath54 .",
    "the right to left direction , @xmath284 , is trivial .    for @xmath285 , we just need to show @xmath286 .",
    "we have the following derivation : @xmath287 the intersection rule can be safely applied as there is at least one @xmath235 such that @xmath288 .",
    "this is because @xmath56 , so if there were no such @xmath58 then @xmath55 would be a footprint , which is a contradiction . note that the last step uses the fact that @xmath289 because adding the top element to an intersection does not change its value . since @xmath55 is not a footprint , @xmath245 , and so @xmath286 .",
    "we know that the footprints are the only elements that are _ essential _ for a complete specification of a local function in the sense that every complete specification must include them .",
    "now we ask when a set of elements is _ sufficient _ for a complete specification of a local function , in the sense that there exists a complete specification of the function that only includes these elements .",
    "in particular , we wish to know if the footprints alone are sufficient .",
    "to study this , we begin by identifying the notion of the _ basis _ of a local function .      in the last section we defined the local limit of a function @xmath54 on a state @xmath55 as the constraint imposed on @xmath54 by all the strict substates of @xmath55 .",
    "this was used to identify the footprints as those states on which the action of @xmath54 can not be determined by just its action on the smaller states .",
    "we are now addressing the question of when a set of states is _ sufficient _ to determine the behaviour of @xmath54 on any state .",
    "we shall do this by identifying a fixed set of states , which we call a _ basis _ for @xmath54 , such that the action of @xmath54 on any state @xmath55 can be determined by just the substates of @xmath55 taken from this set ( rather than all the strict substates of @xmath55 ) .",
    "thus we first generalise the local limit definition to consider the constraint imposed by only the substates taken from a given set .    for a subset @xmath290 of a separation algebra @xmath10 , the * local limit",
    "* imposed by @xmath290 on the action of @xmath54 on @xmath55 is defined by @xmath291    sometimes , the local limit imposed by @xmath290 is enough to completely determine @xmath54 . in this case",
    ", we call @xmath290 a _ basis _ for @xmath54 .    @xmath292 is a * basis * for @xmath54 , written @xmath293 , iff @xmath294 .",
    "this means that , when given the action of @xmath54 on elements in a alone , we can determine the action of @xmath54 on any element in @xmath10 by just using the locality property of @xmath54 .",
    "every local function has at least one basis , namely the trivial basis @xmath10 itself .",
    "we next show the correspondence between the bases and complete specifications of a local function .",
    "[ basisspeclemma ] let @xmath295 .",
    "then we have @xmath296 .",
    "we have @xmath297 $ ] by definition .",
    "the result follows by proposition [ blaiffcomplete ] and the definition of basis .    for every canonical complete specification @xmath298",
    ", we have @xmath299 . by the previous lemma it follows that @xmath300 forms a basis for @xmath54 .",
    "the lemma therefore shows that every basis determines a complete canonical specification , and vice versa .",
    "this correspondence also carries over to all complete specifications for @xmath54 by the fact that every domain - equivalent class of complete specifications for @xmath54 is represented by the canonical complete specification with that domain ( corollary [ candomainisomorphism ] ) . by the essentiality of footprints ( theorem [ essentialitytheorem ] ) , it follows that the footprints are present in every basis of a local function .",
    "[ footprintbasislemma ] the footprints of @xmath54 are included in every basis of f. every basis @xmath290 of @xmath54 determines a complete specification for @xmath54 the domain of which is a subset of @xmath290 . by the essentiality theorem ( [ essentialitytheorem ] ) , the domain includes the footprints .",
    "the question of sufficiency is about how small the basis can get . given a local function , we wish to know if it has a smallest basis .      we know that every basis must contain the footprints .",
    "thus if the footprints alone form a basis , then the function will have a _",
    "smallest _ complete specification whose domain are just the footprints .",
    "we find that , for well - founded resource models , this is indeed the case .",
    "[ sufficiencytheorem ] if a separation algebra @xmath10 is well - founded under the @xmath26 relation , then the footprints of any local function form a basis for it , that is , @xmath301 .",
    "assume that @xmath10 is well - founded under @xmath26 .",
    "we shall show by induction that @xmath302 for all @xmath303 .",
    "the induction hypothesis is that , for all @xmath304 , @xmath305    * case 1 : * assume @xmath55 is a footprint of @xmath54 .",
    "we have @xmath306 is in the intersection in the definition of @xmath307 , and so @xmath308 .",
    "we have by locality that @xmath309 , and so @xmath310 .    * case 2 : * assume @xmath55 is not a footprint of @xmath54 .",
    "we have @xmath311 in section [ completespecifications ] , the notions of big and small specifications were introduced ( definition [ bigsmallspec ] ) , and the existence of a big specification was shown ( proposition [ bigspec ] ) .",
    "we are now in a position to show the existence of the small specification for well - founded resource .",
    "if @xmath10 is well - founded , then every local function has a small specification whose domain is the footprints of the function .",
    "[ smallspeccorollary ] for well - founded separation algebras , every local function has a small specification given by @xmath312 .",
    "@xmath312 is complete by theorem [ sufficiencytheorem ] and lemma [ basisspeclemma ] .",
    "it has the smallest domain by the essentiality theorem .",
    "thus , for well - founded resource , the footprints are always essential and sufficient , and specifications need not consider any other elements . in practice , small specifications may not always be in canonical form even though they always have the same domain as the canonical form .",
    "for example , the heap dispose command can have the specification @xmath313 rather than the canonical one given by @xmath314 .    in practical examples",
    "it is usually the case that resource is well - founded .",
    "a notable exception is the fractional permissions model @xcite in which the resource includes ` permissions to access ' , which can be indefinitely divided .",
    "we next investigate the non - well - founded case .",
    "if a separation algebra is non - well - founded under the @xmath26 relation , then there is some infinite descending chain of elements @xmath315 . from a resource - oriented point of view",
    ", there are two distinct ways in which this could happen .",
    "one way is when it is possible to remove non - empty pieces of resource from a state indefinitely , as in the separation algebra of non - negative real numbers under addition . in this case",
    "any infinite descending chain does not have more than one occurrence of any element .",
    "another way is when an infinite chain may exist because of repeated occurrences of some elements .",
    "this happens when there is _ negativity _ present in the resource : some elements have inverses in the sense that adding two non - unit elements together may give the unit .",
    "an example is the separation algebra of integers under addition , where @xmath316 , so adding -1 to 1 is like adding negative resource .",
    "also , since @xmath317 , we have that @xmath318 forms an infinite chain .    a separation algebra",
    "@xmath10 has * negativity * iff there exists a non - unit element @xmath13 that has an inverse ; that is , @xmath319 and @xmath320 for some @xmath321 .",
    "we say that @xmath10 is * non - negative * if no such element exists .",
    "all separation algebras with negativity are non - well - founded because , for elements @xmath55 and @xmath58 such that @xmath322 , the set @xmath323 forms an infinite descending chain ( there is no least element ) . all well - founded models are therefore non - negative . for the general non - negative case , we find that either the footprints form a basis , or there is no smallest basis .",
    "[ nonnegativetheorem ] if @xmath10 is non - negative then , for any local @xmath54 , either the footprints form a smallest basis or there is no smallest basis for f.    let @xmath290 be a basis for @xmath54 ( we know there is at least one , which is the trivial basis @xmath10 itself ) . if @xmath290 is the set of footprints then we are done .",
    "so assume @xmath290 contains some non - footprint @xmath324 .",
    "we shall show that there exists a smaller basis for @xmath54 , which is @xmath325 .",
    "so it suffices to show @xmath326 for all @xmath13 .",
    "* case 1 : * @xmath327 .",
    "we have @xmath328 as desired    * case 2 : * @xmath329 .",
    "this implies @xmath330 it remains to show that the right hand side of this intersection contains the left hand side : @xmath331    [ nonnegativecorollary ] if @xmath10 is non - negative , then every local function either has a small specification given by @xmath312 or there is no smallest complete specification for that function .",
    "[ permissions ] the fractional permissions model @xcite is non - well - founded and non - negative .",
    "it can be represented by the separation algebra @xmath332 where @xmath65 and @xmath66 are as in example [ locsepexamples ] , and @xmath333 is the interval ( 0 , 1 ] of rational numbers .",
    "elements of @xmath333 represent ` permissions ' to access a heap cell .",
    "a permission of 1 for a cell means both read and write access , while any permission less than 1 is read - only access .",
    "the operator @xmath11 joins disjoint heaps and adds the permissions together for any cells that are present in both heaps only if the resulting permission for each heap cell does not exceed 1 ; the operation is undefined otherwise . in this case , the write function that updates the value at a location requires a permission of at least 1 and faults on any smaller permission .",
    "it therefore has a small specification with precondition being the cell with permission 1 .",
    "the read function , however , can execute safely on any positive permission , no matter how small .",
    "thus , this function can be completely specified with a specification that has a precondition given by the cell with permission @xmath334 , for all @xmath335 .",
    "however , this is not a _ smallest _ specification , as a smaller one can be given by further restricting @xmath336 .",
    "we can therefore always find a smaller specification by reducing the value of @xmath334 but keeping it positive .    for resource with negativity , we find that it is possible to have small specifications that include non - essential elements ( which by theorem [ essentialitytheorem ] are not footprints ) .",
    "these elements are non - essential in the sense that complete specifications exist that do not include them , but there is no complete specification that includes only essential elements .",
    "[ negativeresource ] an example of a model with negativity is the separation algebra of integers @xmath337 . in this case",
    "there can be local functions which can have small specifications that contain non - footprints .",
    "let @xmath338 be defined as @xmath339 for some constant @xmath89 , as in example [ locsepexamples ] .",
    "@xmath54 is local , but it has no footprints .",
    "this is because for any @xmath340 , @xmath341 , and so @xmath340 is not a footprint of @xmath54 .",
    "however , @xmath54 does have small specifications , for example , @xmath342 , @xmath343 , or indeed @xmath344 for any @xmath345 .",
    "so although every element is non - essential , some element is required to give a complete specification .",
    "in the introduction we discussed how the notion of footprints as the smallest safe states - the _ safety footprint_- is inadequate for giving complete specifications , as illustrated by the _ ad _ example .",
    "for this reason , so far in this paper we have investigated the general notion of footprint for arbitrary local functions on arbitrary separation algebras .",
    "equipped with this general theory , we now investigate how the regaining of safety footprints may be achieved with different resource modelling choices .",
    "we start by presenting an alternative model of ram , based on an investigation of why the @xmath61 phenomenon occurs in the standard model .",
    "we then demonstrate that the footprints of the @xmath61 command in this new model do correspond to the safety footprints . in the final section",
    "we identify , for arbitrary separation algebras , a condition on local functions which guarantees the equivalence of the safety footprint and the actual footprint .",
    "we then show that if this condition is met by all the primitive commands of a programming language then the safety footprints are regained for every program in the language , and finally show that this is indeed the case in our new ram model .",
    "in this section we explore an alternative heap model in which the safety footprints do correspond to the actual footprints .",
    "we begin by taking a closer look at why the _ ad _ anomaly occurs in the standard heap and stack model described in example [ locsepexamples].2 .",
    "consider an application of the allocation command in this model : @xmath346}(42 \\mapsto v \\bullet x \\mapsto w ) = \\{42 \\mapsto v \\bullet x \\mapsto",
    "l   \\bullet l \\mapsto r \\mid l \\in l\\backslash \\{42\\ } , r \\in val\\}\\ ] ]    the intuition of locality is that the initial state @xmath347 is only describing a local region of the heap and the stack , rather than the whole global state . in this case",
    "it says that the address 42 is initially allocated , and the definition of the allocation command is that the resulting state will have a new cell , the address of which can be anything other than 42 .",
    "however , we notice that the initial state is in fact not just describing only its local region of the heap .",
    "it does state that 42 is allocated , but it also implicitly states a very global property : that _ all other addresses are not allocated_. this is why the allocation command can choose to allocate any location that is not 42 .",
    "thus in this model , every local state implicitly contains some global allocation information which is used by the allocation command .",
    "in contrast , a command such as mutate does not require this global ` knowledge ' of the allocation status of any other cell that it is not affecting .",
    "now the global information of which cells are free _ changes _ as more resource is added to the initial state , so this can lead to program behaviour being sensitive to the addition of more resource to the initial state , and this sensitivity is apparant in the case of the _ ad _ program .",
    "based on this observation , we consider an alternative model .",
    "as before , a state @xmath8 will represent a local allocated region of the heap at address @xmath4 with value @xmath5 .",
    "however , unlike before , this state will say nothing about the allocation status any locations other than @xmath4 .",
    "this information about the allocation status of other locations will be represented explicitly in a _ free _ set , which will contain every location that is not allocated in the _",
    "global heap_. the model can be interpreted from an ownership point of view , where the free set is to be thought of as a unique , atomic piece of resource , ownership of which needs to be obtained by a command if it wants to do allocation or deallocation .",
    "an analogy is with the permissions model : a command that wants to read or write to a cell needs ownership of the appropriate permission on that cell .",
    "in the same way , in our new model , a command that wants to do allocation or deallocation needs to have ownership of the free set : the ` permission ' to see which cells are free in the global heap so that it can choose one of them to allocate , or update the free set with the address that it deallocates . on the other hand ,",
    "commands that only read or write to cells shall not require ownership of the free set .",
    "[ freesetmodel ] formally , we work with a separation algebra @xmath348 .",
    "let @xmath65 , @xmath80 and @xmath66 be locations , variables and values , as before .",
    "states @xmath69 are given by the grammar : @xmath349 where @xmath350 , @xmath351 , @xmath352 and @xmath353 .",
    "the operator @xmath11 is undefined for states with overlapping locations or variables .",
    "let @xmath82 and @xmath83 be the set of locations and variables in state @xmath71 respectively .",
    "the set @xmath354 carries the information of which locations are free .",
    "thus we allow at most one free set in a state , and the free set must be disjoint from all locations in the state .",
    "so @xmath355 is only defined when @xmath356 and @xmath357 for any @xmath358 and @xmath359 .",
    "we assume @xmath11 is associative and commutative with unit @xmath68 .    in this model ,",
    "the allocation command requires ownership of the free set for safe execution , since it chooses the location to allocate from this set .",
    "it removes the chosen address from the free set as it allocates the cell .",
    "it is defined as @xmath360(h ) = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\bullet f\\backslash \\{l\\}\\mid w \\in val , l \\in f\\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}v \\bullet f \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\ ] ] note that the output states @xmath361 are defined , since we have @xmath362 and the input state @xmath363 implies that @xmath364 is disjoint from @xmath365 .",
    "the deallocation command also requires the free set , as it updates the set with the address of the cell that it deletes : @xmath366(h ) = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet f \\cup \\{l\\}\\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v \\bullet f \\end{array } \\\\",
    "\\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\ ] ] again , the output states are defined , since the input state implies that @xmath367 is disjoint from @xmath354 , and so @xmath364 is disjoint from @xmath368 .",
    "notice that in this model , only the allocation and deallocation commands require ownership of the free set , since commands such as mutation and lookup are completely independent of the allocation status of other cells , and they are defined exactly as in example [ locsepexamples].2 : @xmath369(h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v \\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}w \\end{array } \\\\ \\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr lookup[x , y](h ) & = \\left\\ { \\begin{array}{ll } \\begin{array}{l}\\ { h ' \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}v \\bullet y { \\!\\mapsto\\!}v \\ } \\end{array } &   \\begin{array}{l}h = h'\\bullet x",
    "{ \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet y { \\!\\mapsto\\!}w \\end{array } \\\\",
    "\\begin{array}{l}\\top \\end{array } & \\begin{array}{l}\\mbox{otherwise } \\end{array } \\end{array}\\right.\\cr}\\ ] ]    [ newmodellocal]the functions @xmath86 $ ] , @xmath370 $ ] , @xmath371 $ ] and @xmath372 $ ] are all local in the separation algebra @xmath348 from example [ freesetmodel ] .",
    "let @xmath373 $ ] and assume @xmath374 .",
    "we want to show @xmath375 .",
    "assume @xmath376 for some @xmath377 , @xmath1 , @xmath4 , @xmath5 and @xmath354 , because otherwise @xmath378 and we are done .",
    "so we have @xmath379 the other functions can be checked in a similar way .",
    "we consider the footprint of the _ ad _ command in the new model . in this model the sequential composition @xmath86;dispose[x]$ ]",
    "gives the function @xmath380 the smallest safe states are given by the set @xmath381 .",
    "by lemma [ minstates ] , these smallest safe states are footprints . however , unlike before , in this model these are the _ only _ footprints of the @xmath61 command . to see this ,",
    "consider a larger state @xmath382 for non - empty @xmath71 .",
    "we have @xmath383 since the local limit @xmath384 by definition , we have by proposition [ locallimitproposition ] that @xmath385 , and so @xmath386 is not a footprint of @xmath61 .",
    "thus the footprints of @xmath61 in this model do not include any non - empty heaps . by corollary [ smallspeccorollary ] , in this model the @xmath61 command has a smallest complete specification in which the pre - condition only describes the empty heap .",
    "this specification is @xmath387    intuitively , it says that if initially the heap is empty , the variable @xmath1 is present in the stack , and we know which cells are free in the global heap , then after the execution , the heap will still be empty , exactly the same cells will still be free , and @xmath1 will point to one of those free cells .",
    "this completely describes the behaviour of the command for all larger states using the frame rule .",
    "for example , we get the complete specification on the larger state in which 42 is allocated : @xmath388    in the pre - condition , the presence of location 42 in the heap means that 42 is not in the free set @xmath354 ( by definition of @xmath92 ) .",
    "therefore , in the post - condition , @xmath1 can not point to 42 .",
    "notice that in order to check that we have ` regained ' safety footprints , we only needed to check that the footprint definition ( definition [ def : footprint ] ) corresponds to the smallest safe states .",
    "the desired properties such as essentiality , sufficiency , and small specifications then follow by the results established in previous sections .",
    "now that we have regained the safety footprints for _ ad _ in the new model , we want to know if this is generally the case for _ any program_. we consider the abstract imperative programming language given in @xcite : @xmath389 where @xmath89 ranges over an arbitrary collection of primitive commands , @xmath390 is nondeterministic choice , @xmath391 is sequential composition , and @xmath392 is kleene - star ( iterated @xmath391 ) . as discussed in @xcite , conditionals and while loops can be encoded using @xmath390 and @xmath392 and assume statements .",
    "the denotational semantics of commands is given in figure  [ fig : densemantics ] .    ' '' ''    @xmath393 { \\llbracket c_1;c_2 \\rrbracket } =   { \\llbracket c_1 \\rrbracket};{\\llbracket c_2 \\rrbracket } \\quad \\quad { \\llbracket c_1+c_2 \\rrbracket }   = { \\llbracket c_1 \\rrbracket }   \\sqcup { \\llbracket c_2 \\rrbracket } \\quad \\quad { \\llbracket c^{\\star } \\rrbracket }    = \\bigsqcup_n { \\llbracket c^{\\,n } \\rrbracket } \\end{array}\\ ] ]    ' '' ''    taking the primitive commands to be @xmath86 $ ] , @xmath370 $ ] , @xmath371 $ ] , and @xmath372 $ ] , our original aim was to show that , for every command @xmath394 , the footprints of @xmath395 in the new model are the smallest safe states .",
    "however , in attempting to do this , we identified a general condition on primitive commands under which the result holds for arbitrary separation algebras .",
    "let @xmath54 be a local function on a separation algebra @xmath10 . if , for @xmath396 , we define @xmath397 , then the locality condition ( definition [ def : localaction ] ) can be restated as @xmath398    the @xmath60 ordering in this definition allows local functions to be more deterministic on larger states .",
    "this sensitivity of determinism to larger states is apparant in the _ ad _ command in the standard model from example [ locsepexamples].2 . on the empty heap , the command produces an empty heap , and reassigns variable @xmath1 to _ any _ value , while on the singleton cell 1 , it disallows the possibility that @xmath399 afterwards . in the new model , the @xmath61 command does not have this sensitivity of determinism in the output states . in this case",
    ", the presence or absence of the cell 1 does not affect the outcomes of the @xmath61 command , since the command can only assign @xmath1 to a value chosen from the free set , which does not change no matter what additional cells may be framed in . with this observation ,",
    "we consider the general class of local functions in which this sensitivity of determinism is not present .",
    "[ def : detconst ] let @xmath54 be a local function and @xmath400 the set of states on which @xmath54 does not fault . @xmath54 has the determinism constancy property iff , for every @xmath401 , @xmath402    notice that the determinism constancy property by itself implies that the function is local , and it can therefore be thought of as a form of ` strong locality ' .",
    "firstly , we find that local functions that have determinism constancy always have footprints given by the smallest safe states .",
    "[ detconstfootprint ] if a local function @xmath54 has determinism constancy then its footprints are the smallest safe states .",
    "let @xmath403 be the smallest safe states of @xmath54 .",
    "these are footprints by lemma [ minstates ] . for any larger state @xmath404",
    "where @xmath405 , @xmath321 and @xmath55 is non - empty , we have @xmath406 since @xmath407 , by proposition [ locallimitproposition ] we have that @xmath408 , and so @xmath404 is not a footprint of @xmath54 .",
    "we now demonstrate that the determinism constancy property is preserved by all the constructs of our programming language .",
    "this implies that if all the primitive commands of the programming language have determinism constancy , then the footprints of every program are the smallest safe states .",
    "[ detconstprograms ] if all the primitive commands of the programming language have determinism constancy , then the footprint of every program is given by the smallest safe states .",
    "assuming all primitive commands have determinism constancy , we shall show by induction that every composite command has determinism constancy and the result follows by lemma [ detconstfootprint ] .",
    "so for commands @xmath409 and @xmath410 , let @xmath411 and @xmath412 and assume @xmath54 and @xmath413 have determinism constancy . for sequential composition",
    "we have , for @xmath414 and @xmath321 , @xmath415    for non - deterministic choice , we have for @xmath416 and @xmath321 , @xmath417    for kleene - star , we have for @xmath418 and @xmath321 , @xmath419    now that we have shown the general result , it remains to check that all the primitive commands in the new model of section [ altmodel ] do have determinism constancy .",
    "[ rammodelsprop ] let @xmath420 be the stack and heap model of example [ locsepexamples].2 and @xmath421 be the alternative model of section [ altmodel ] .",
    "the commands @xmath86 $ ] , @xmath371 $ ] and @xmath372 $ ] all have determinism constancy in both models .",
    "the @xmath370 $ ] command has determinism constancy in @xmath421 but not in @xmath420 .",
    "we give the proofs for the new and dispose commands in the two models , and the cases for mutate and lookup can be checked in a similar way . for @xmath370 $ ] in @xmath420 , the following counterexample shows that it does not have determinism constancy .",
    "@xmath422(\\{l{\\!\\mapsto\\!}v\\}*\\{x{\\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}w\\})\\\\ & = & dispose[x](\\emptyset)\\\\ & = & \\emptyset \\\\ & \\sqsubset &   \\{l{\\!\\mapsto\\!}v \\bullet x{\\!\\mapsto\\!}l\\}\\\\ & = & \\{l{\\!\\mapsto\\!}v\\ } * dispose[x](x{\\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}w ) \\end{array}\\ ] ] for @xmath86 $ ] in @xmath420 ,",
    "any safe state is of the form @xmath423 . for any @xmath424",
    ", we have @xmath425(h \\bullet x{\\!\\mapsto\\!}v ) =   \\{h'\\ } * \\ { h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\mid w \\in val , l \\in l \\backslash loc(h)\\ } \\quad ( \\dagger)\\ ] ]    if @xmath426 is undefined then @xmath358 shares locations with @xmath82 or variables with @xmath427 .",
    "this means that the rhs in @xmath428 is the empty set .",
    "we have @xmath86(\\{h'\\}*\\{h \\bullet x{\\!\\mapsto\\!}v\\ } ) = new[x](\\emptyset ) = \\emptyset = \\{h'\\ } * new[x](h \\bullet x{\\!\\mapsto\\!}v)$ ] . if @xmath426 is defined , then @xmath429(\\{h'\\ } * \\{h \\bullet x{\\!\\mapsto\\!}v\\})\\\\ & = & new[x](h ' \\bullet h \\bullet x{\\!\\mapsto\\!}v)\\\\ & = & \\ { h ' \\bullet h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\mid w \\in val , l \\in l \\backslash loc(h'\\bullet h)\\}\\\\ & = & \\ { h'\\ } * \\{h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\mid w \\in val , l \\in l \\backslash loc(h'\\bullet h)\\}\\\\ & = & \\ { h'\\ } * \\{h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\mid w \\in val , l \\in l \\backslash loc(h)\\}\\\\ & = & \\{h'\\ } * new[x](h \\bullet x{\\!\\mapsto\\!}v )    \\end{array}\\ ] ] for @xmath370 $ ] in @xmath421 , any safe state is of the form @xmath430 .",
    "let @xmath431 .",
    "we have @xmath432(h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f ) =   \\{h'\\ } * \\ { h \\bullet x { \\!\\mapsto\\!}l \\bullet f\\cup\\{l\\}\\ } \\quad ( \\dagger\\mbox{\\!}\\dagger)\\ ] ]    if @xmath433 is undefined then either @xmath358 contains a free set or it contains locations in @xmath434 or variables in @xmath427 .",
    "if @xmath358 contains a free set or it contains locations in @xmath82 or variables in @xmath427 , then the rhs in @xmath435 is the empty set . if @xmath358 contains the location @xmath4 then also the rhs in @xmath435 is the empty set since the free set @xmath368 also contains @xmath4 .",
    "thus in both cases the rhs in @xmath435 is the empty set , and we have @xmath370(\\{h'\\}*\\{h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f\\ } ) = \\emptyset = \\{h'\\ } * dispose[x](h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f)$ ] .    if @xmath433 is defined then we have @xmath422(\\{h'\\}*\\{h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f\\})\\\\ & = & dispose[x](h ' \\bullet h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f)\\\\ & = & \\{h ' \\bullet h \\bullet x { \\!\\mapsto\\!}l \\bullet f\\cup\\{l\\}\\}\\\\ & = & \\{h'\\ } * \\ { h \\bullet x { \\!\\mapsto\\!}l \\bullet f\\cup\\{l\\}\\}\\\\ & = &   \\{h'\\ } *",
    "dispose[x](h \\bullet x { \\!\\mapsto\\!}l\\bullet l { \\!\\mapsto\\!}v \\bullet f )   \\end{array}\\ ] ]    for @xmath86 $ ] in @xmath421 , any safe state is of the form @xmath382 .",
    "let @xmath431 .",
    "we have @xmath425(h \\bullet x { \\!\\mapsto\\!}v \\bullet f ) =   \\{h'\\ } * \\ { h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\bullet f\\backslash\\{l\\ } \\mid w \\in val , l \\in f\\ } \\quad ( \\dagger\\mbox{\\!}\\dagger\\mbox{\\!}\\dagger)\\ ] ]    if @xmath436 is undefined then either @xmath358 contains a free set or it contains locations in @xmath82 or variables in @xmath427 . in all these cases",
    "the rhs in @xmath437 is the empty set , and so we have @xmath86(\\{h'\\}*\\{h \\bullet x { \\!\\mapsto\\!}v \\bullet f\\ } ) = \\emptyset = \\{h'\\ } * new[x](h \\bullet x { \\!\\mapsto\\!}v \\bullet f)$ ] .",
    "if @xmath436 is defined then we have @xmath438(\\{h'\\}*\\{h \\bullet x { \\!\\mapsto\\!}v \\bullet f\\})\\\\ & = & new[x](h ' \\bullet h \\bullet x { \\!\\mapsto\\!}v \\bullet f)\\\\ & = & \\{h ' \\bullet h \\bullet x { \\!\\mapsto\\!}l \\bullet l { \\!\\mapsto\\!}w \\bullet f\\backslash\\{l\\ } \\mid w \\in val , l \\in f\\ } \\\\ & = & \\{h'\\ } * \\ { h \\bullet x { \\!\\mapsto\\!}l \\bullet l",
    "{ \\!\\mapsto\\!}w \\bullet f\\backslash\\{l\\ } \\mid w \\in val , l \\in",
    "f\\}\\\\ & = & \\{h'\\ } * new[x](h \\bullet x { \\!\\mapsto\\!}v \\bullet f ) \\end{array}\\ ] ]    thus theorem [ detconstprograms ] and proposition [ rammodelsprop ] tell us that using the alternative model of example [ freesetmodel ] , the footprint of every program is given by the smallest safe states , and hence we have regained safety footprints for all programs .",
    "in fact , the same is true for the original model of example [ locsepexamples].2 if we do not include the dispose command as a primitive command , since all the other primitive commands have determinism constancy .",
    "this , for example , would be the case when modelling a garbage collected language @xcite .",
    "we have developed a general theory of footprints in the abstract setting of local functions that act on separation algebras .",
    "although central and intuitive concepts in local reasoning , the notion of footprints and small specifications had evaded a formal general treatment until now .",
    "the main obstacle was presented by the _ ad _",
    "problem , which demonstrated the inadequacy of the safety footprint notion in yielding complete specifications . in addressing this issue , we first investigated the notion of footprint which does not suffer from this inadequacy .",
    "based on an analysis of the definition of locality , we introduced the definition of the footprint of a local function , and demonstrated that , according to this definition , the footprints are the only essential elements necessary to obtain a complete specification of the function . for well - founded resource models , we showed that the footprints are also sufficient , and we also presented results for non - well - founded models .    having established the footprint definition , we then explored the conditions under which the safety footprint does correspond to the actual footprint .",
    "we introduced an alternative heap model in which safety footprints are regained for _ every _ program , including _",
    "ad_. we also presented a general condition on local functions in arbitrary models under which safety footprints are regained , and showed that if this condition is met by all the primitive commands of the programming language , then safety footprints are regained for every program .",
    "the theory of footprints has proven very useful in exploring the situations in which safety footprints could be regained , as one only needs to check that the smallest safe states correspond to the footprint definition [ def : footprint ] .",
    "this automatically gives the required properties such as essentiality and sufficiency , which , without the footprint definition and theorems , would need to be explicitly checked in the different cases .",
    "finally , we comment on some related work .",
    "the discussion in this paper has been based on the static notion of footprints as _ states _ of the resource on which a program acts . a different notion of footprint",
    "has recently been described in @xcite , where footprints are viewed as _ traces _ of execution of a computation .",
    "ohearn has described how the _ ad _ problem is avoided in this more elaborate semantics , as the allocation of cells in an execution prevents the framing of those cells .",
    "interestingly , however , the heap model from example [ freesetmodel ] illustrates that it is not essential to move to this more elaborate setting and incorporate dynamic , execution - specific information into the footprint in order to resolve the _ ad _ problem . instead , with the explicit representation of free cells in states , one can remain in an extensional semantics and have a purely static , resource - based ( rather than execution - based ) view of footprints .",
    "10    j.  berdine , c.  calcagno , b.  cook , d.  distefano , p.  o hearn , t.  wies and h.  yang .",
    "shape analysis for composite data structures . in _ cav",
    "_ , springer , vol . 4590 , pp . 178 - 192 , 2007 .",
    "j.  berdine , c.  calcagno , and p. ohearn .",
    "smallfoot : automatic modular assertion checking with separation logic . in _ fmco _ , springer , vol . 4111 , pp .",
    "115 - 137 , 2006 .    l.  birkedal and h.  yang . relational parametricity and separation logic . in _ fossacs _ ,",
    "springer , vol .",
    "4423 , pp . 93 - 107 , 2007 .",
    "r.  bornat , c.  calcagno , p.",
    "ohearn , and m.  parkinson .",
    "permission accounting in separation logic . in _ popl _ , acm ,",
    "259 - 270 , 2005 .",
    "r.  bornat , c.  calcagno , and h.  yang .",
    "variables as resource in separation logic . in _ mfps _ , elsevier entcs , vol .",
    "247 - 276 , 2005 .",
    "s.  d. brookes . a semantics for concurrent separation logic .",
    "in _ theoretical computer science _ , elsevier , vol .",
    "375 , pp . 227 - 270 , 2007 .    c.  calcagno , p.  gardner , and u.  zarfaty .",
    "context logic and tree update . in _",
    "acm , vol .",
    "271 - 282 , 2005 .    c.  calcagno , p.  gardner , and u.  zarfaty .",
    "local reasoning about data update . in _",
    "gordon plotkin s festschrift _ , elsevier entcs , vol .",
    "133 - 175 , 2007 .    c.  calcagno , p.",
    "ohearn , and h.  yang . local action and abstract separation logic . in _ lics _ ,",
    "ieee computer society , pp .",
    "366 - 378 , 2007 .",
    "t. hoare and p. ohearn .",
    "separation logic semantics of communicating processes . in _ fics _ , elsevier entcs , vol .",
    "3 - 25 , 2008 .",
    "s.  isthiaq and p. ohearn . as an assertion language for mutable data structures . in _",
    "acm , vol .",
    "14 - 26 , 2001 .    c. c. morgan . the specification statement . in _ acm transactions on programming languages and systems _ ,",
    "acm , vol .",
    "403 - 419 , 1988 .",
    "resources , concurrency and local reasoning . in _ theoretical computer science _ , elsevier , vol .",
    "271 - 307 , 2007 .",
    "p.  ohearn , j.  reynolds , and h.  yang .",
    "local reasoning about programs that alter data structures . in _ csl _",
    ", springer - verlag , vol .",
    "2142 , pp . 1 - 19 , 2001 .",
    "w. ohearn and d.  j. pym .",
    "the logic of bunched implications . in _ bulletin of symbolic logic _ ,",
    "asl , vol . 5 , pp . 215 - 244,1999 .",
    "m.  parkinson .",
    "local reasoning for java .",
    "thesis ( university of cambridge ) , 2005 .",
    "m.  parkinson , r.  bornat , and c.  calcagno .",
    "variables as resource in hoare logics . in _ lics _",
    ", ieee computer society , pp .",
    "137 - 146 , 2006 .",
    "d.  pym , p.  ohearn , and h.  yang .",
    "possible worlds and resources : the semantics of bi . in _ theoretical computer science _ , elsevier , vol .",
    "257 - 305 , 2004 .",
    "kluwer academic publishers , applied logic series , vol .",
    "26 , 2002 .    j.  c. reynolds .",
    "separation logic : a logic for shared mutable data structures . in _ lics _ , ieee computer society , pp .",
    "55 - 74 , 2002 .",
    "h.  yang and p.  ohearn . a semantic basis for local reasoning . in _",
    "fossacs _ , springer - verlag , vol . 2303 , pp .",
    "402 - 416 , 2002 .",
    "the authors wish to thank cristiano calcagno , peter ohearn and hongseok yang for detailed discussions on footprints .",
    "raza acknowledges support of an ors award .",
    "gardner acknowledges support of a microsoft research cambridge / royal academy of engineering senior research fellowship ."
  ],
  "abstract_text": [
    "<S> local reasoning about programs exploits the natural local behaviour common in programs by focussing on the footprint - that part of the resource accessed by the program . </S>",
    "<S> we address the problem of formally characterising and analysing the notion of footprint for abstract local functions introduced by calcagno , ohearn and yang . with our definition , we prove that the footprints are the only essential elements required for a complete specification of a local function . </S>",
    "<S> we formalise the notion of small specifications in local reasoning and show that , for well - founded resource models , a smallest specification always exists that only includes the footprints . </S>",
    "<S> we also present results for the non - well - founded case . </S>",
    "<S> finally , we use this theory of footprints to investigate the conditions under which the footprints correspond to the smallest safe states . </S>",
    "<S> we present a new model of ram in which , unlike the standard model , the footprints of every program correspond to the smallest safe states . </S>",
    "<S> we also identify a general condition on the primitive commands of a programming language which guarantees this property for arbitrary models . </S>"
  ]
}