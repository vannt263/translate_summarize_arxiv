{
  "article_text": [
    "groundness analysis is an important theme of logic programming and abstract interpretation .",
    "groundness analyses identify those program variables bound to terms that contain no variables ( ground terms ) .",
    "groundness information is typically inferred by tracking dependencies among program variables .",
    "these dependencies are commonly expressed as boolean functions .",
    "for example , the function @xmath0 describes a state in which @xmath1 is definitely ground , and there exists a grounding dependency such that whenever @xmath2 becomes ground then so does @xmath3 .",
    "groundness analyses usually track dependencies using either @xmath4 , the class of positive boolean functions @xcite , or @xmath5 , the class of definite positive functions @xcite .",
    "@xmath4 is more expressive than @xmath5 , but studies have shown that @xmath5 analysers can be faster than comparable @xmath4 analysers @xcite and , in practice , the loss of precision for goal - dependent groundness analysis is usually small @xcite .",
    "this paper is a development of @xcite and is an exploration of the representation of boolean functions for groundness analysis and the use of prolog as a medium for implementing all the components of a groundness analyser .",
    "the rationale for this work was to develop an analyser with conceptually simple domain operations , with a small and simple ( thus easily maintained ) prolog implementation based on a meta - interpreter and with performance comparable to that of bdd - based analysers .",
    "moreover , since prolog is well suited to symbolic manipulation , it should provide an appropriate medium for implementing a symbolic analysis , such as groundness analysis .",
    "any analysis that can be quickly prototyped in prolog is particularly attractive .",
    "the main drawback of this approach has traditionally been performance .",
    "the efficiency of an analyser can be guaranteed by including a widening ( the controlled exchange of precision for scalability ) . however , a successful analyser should fire widening infrequently to maximise precision .",
    "the efficiency of groundness analysis depends critically on the way dependencies are represented .",
    "representation has two aspects : the theoretical representation ( bdds , blake canonical form , etc . ) of the boolean functions and the data - structures of the implementation language that are used to support this representation .",
    "the theoretical representation determines the complexity of the domain operations , but the implementation requires the specific data - structures used to be amenable to efficient implementation in the chosen language .",
    "that is , the implementation can push the complexity into a higher class , or introduce a prohibitive constant factor in the complexity function .",
    "this paper considers how a representation should be chosen for the intended application ( groundness analysis ) by balancing the size of the representation ( and its impact ) with the complexity of the abstract operations and the frequency with which these operations are applied .",
    "the paper also explains how prolog can be used to implement a particularly efficient -based groundness analysis .",
    "the orthogonal issue of the iteration strategy used to drive the analysis is also considered .",
    "specifically , this paper makes the following contributions :    * a representation of  formulae as non - canonical conjunctions of clauses is chosen by following a methodology that advocates : 1 ) ensuring that the most commonly called domain operations are the most lightweight ; 2 ) that the abstractions that arise in practice should be dense ; 3 ) that , where possible , expensive domain operations should be filtered by lightweight special cases . * a fast prolog implementation of -based groundness analysis",
    "is given founded on the methodology above , using a compact , factorised representation .",
    "* representing boolean functions as non - ground formulae allows succinct implementation of domain operations .",
    "in particular a constant - time meet is achieved using difference lists and a quadratic - time entailment check is built using delay declarations . *",
    "a new join algorithm is presented which does not require formulae to be preprocessed into a canonical form . *",
    "the use of entailment checking as a filter for join is described , as is the use of a filtered projection .",
    "* various iteration strategies are systematically compared and it is suggested ( at least for groundness analysis ) that good performance can be obtained by a surprisingly simple analysis framework . *",
    "an extensive experimental evaluation of groundness analysis using a variety of combinations of domains , representations and iteration strategies is given .",
    "* as a whole , the work presented in this paper strongly suggests that the implementor can produce a robust , fast , precise , scalable analyser for goal - dependent groundness analysis written in prolog .",
    "the analyser presented does not require widening to be applied for any programs in the benchmarks suite .",
    "the rest of the paper is structured as follows : section 2 details the necessary preliminaries .",
    "section 3 reviews the methods used for choosing the representation of .",
    "it goes on to describe various representations of  in relation to a frequency analysis of the operations ; a non - canonical representation as conjunctions of clauses is detailed .",
    "section 4 describes a new join algorithm , along with filtering techniques for join and for projection .",
    "section 5 discusses a variety of iteration strategies for driving an analysis .",
    "section 6 gives an experimental evaluation of the various combinations of domain representations and iteration strategy for  ( and also for the domains  and ) .",
    "section 7 surveys related work and section 8 concludes .",
    "a boolean function is a function @xmath6 where @xmath7 .",
    "let @xmath8 denote a denumerable universe of variables .",
    "a boolean function can be represented by a propositional formula over @xmath9 where @xmath10 .",
    "the set of propositional formulae over @xmath11 is denoted by @xmath12 . throughout this paper , boolean functions and propositional formulae",
    "are used interchangeably without worrying about the distinction .",
    "the convention of identifying a truth assignment with the set of variables @xmath13 that it maps to @xmath14 is also followed .",
    "specifically , a map @xmath15 is introduced defined by : @xmath16 . in addition , the formula @xmath17 is often abbreviated as @xmath18 .",
    "the ( bijective ) map @xmath19 is defined by : @xmath20 = @xmath21 .    if @xmath22 , then the function @xmath23 , @xmath24 , @xmath25 , @xmath26 can be represented by the formula @xmath27 .",
    "also , @xmath28 = @xmath29 and @xmath30 = @xmath31 , @xmath32 .",
    "the focus of this paper is on the use of sub - classes of @xmath12 in tracing groundness dependencies .",
    "these sub - classes are defined below :    a function @xmath33 is positive iff @xmath34 .",
    "@xmath35 is the set of positive boolean functions over @xmath11 .",
    "a function @xmath33 is definite iff @xmath36 for all @xmath37 .",
    "@xmath38 is the set of positive functions over @xmath11 that are definite .",
    "a function @xmath33 is ge iff @xmath33 is definite positive and , where @xmath39 , for all @xmath37 , @xmath40 .",
    "@xmath41 is the set of ge functions over @xmath11 .",
    "note that @xmath42 .",
    "one useful representational property of @xmath38 is that each @xmath43 can be described as a conjunction of definite ( propositional ) clauses , that is , @xmath44 @xcite .",
    "note that the @xmath45s are not necessarily distinct .",
    "finally , @xmath5 abbreviates @xmath46 .",
    "also notice that @xmath47 , where @xmath48 .",
    "suppose @xmath49 and consider the following table , which states , for some boolean functions , whether they are in @xmath41 , @xmath38 or @xmath35 and also gives @xmath50 .",
    "@xmath51 note , in particular , that @xmath52 is not in @xmath38 ( since its set of models is not closed under intersection ) and that @xmath53 is neither in @xmath41 , nor @xmath35 nor @xmath38 .",
    "defining @xmath54 = @xmath55 , the 4-tuple @xmath56 is a finite lattice @xcite , where @xmath14 is the top element and @xmath57 is the bottom element .",
    "existential quantification is defined by schrder s elimination principle , that is , @xmath58",
    "\\ldotor f[x \\mapsto false]$ ] .",
    "note that if @xmath43 then @xmath59 @xcite .",
    "[ dotvee - ex ] if @xmath60 then @xmath61 = @xmath62 = @xmath63 , as can be seen in the hasse diagram for dyadic @xmath38 ( fig .",
    "[ hasse ] ) .",
    "note also that @xmath64 = @xmath65 = @xmath66 .",
    "c@c@c    ( 19,20)(0,0 ) ( 9,-3)(6,1)@xmath67    ( 9,0)(6,2)@xmath27    ( 9,2.5)(-1,1)6 ( 12,2.5)(0,1)6 ( 15,2.5)(1,1)6    ( 0,9)(6,2)@xmath1 ( 9,9)(6,2)@xmath68 ( 18,9)(6,2)@xmath3    ( 3.5,11.5)(1,1)6 ( 12,11.5)(0,1)6 ( 20.5,11.5)(-1,1)6    ( 9,18)(6,2)@xmath14    &    ( 19,20)(0,0 ) ( 9,-3)(6,1)@xmath69    ( 9,0)(6,2)@xmath27    ( 9,2.5)(-5,4)5 ( 12,2.5)(0,1)4 ( 15,2.5)(5,4)5    ( 0,6)(6,2)@xmath1 ( 9,6)(6,2)@xmath68 ( 18,6)(6,2)@xmath3    ( 3,8)(0,1)4 ( 11,8)(-1,1)4 ( 13,8)(1,1)4 ( 21,8)(0,1)4    ( 0,12)(6,2)@xmath70 ( 18,12)(6,2)@xmath71    ( 4.5,14)(5,4)5 ( 19.5,14)(-5,4)5    ( 9,18)(6,2)@xmath14    &    ( 19,20)(0,0 ) ( 9,-3)(6,1)@xmath72    ( 9,0)(6,2)@xmath27    ( 9,2.5)(-5,4)5 ( 12,2.5)(0,1)4 ( 15,2.5)(5,4)5    ( 0,6)(6,2)@xmath1 ( 9,6)(6,2)@xmath68 ( 18,6)(6,2)@xmath3    ( 3,8)(0,1)4 ( 11,8)(-1,1)4 ( 13,8)(1,1)4 ( 21,8)(0,1)4    ( 0,12)(6,2)@xmath70 ( 9,12)(6,2)@xmath73 ( 18,12)(6,2)@xmath71    ( 12,14)(0,1)4 ( 4,8)(5,4)5 ( 20,8)(-5,4)5    ( 4.5,14)(5,4)5 ( 19.5,14)(-5,4)5    ( 9,18)(6,2)@xmath14    the set of ( free ) variables in a syntactic object @xmath74 is denoted by @xmath75 .",
    "also , @xmath76 ( project out ) abbreviates @xmath77 and @xmath78 ( project onto ) denotes @xmath79 .",
    "let @xmath80 be fixed renamings such that @xmath81 = @xmath82 = @xmath83 .",
    "renamings are bijective and therefore invertible .",
    "downward closure , @xmath84 , relates @xmath4 and @xmath5 and is useful when tracking sharing with boolean functions @xcite .",
    "it is defined by @xmath85 .",
    "note that @xmath86 has the useful computational property that @xmath87 if @xmath88 .",
    "that is , @xmath84 takes a  formula to its best  approximation . finally , for any @xmath89 , @xmath90 = @xmath91 @xcite .",
    "the following pieces of logic programming terminology will also be needed .",
    "let @xmath92 denote the set of terms constructed from @xmath8 and a set of function symbols @xmath93 .",
    "@xmath94 is a set of predicate symbols .",
    "an equation @xmath95 is a pair @xmath96 where @xmath97 .",
    "a substitution is a ( total ) map @xmath98 such that @xmath99 is finite .",
    "let @xmath100 denote the set of substitutions and let @xmath101 denote a finite set of equations .",
    "let @xmath102 denote the term obtained by simultaneously replacing each occurrence of @xmath103 in @xmath104 with @xmath105 , and let @xmath106 = @xmath107 .",
    "composition of substitutions induces the ( more general than ) relation @xmath108 defined by : @xmath109 if there exists @xmath110 such that @xmath111 .",
    "more general than lifts to terms by @xmath112 iff there exists @xmath113 such that @xmath114 .",
    "the set of unifiers of @xmath101 , @xmath115 , is defined by : @xmath115 = @xmath116 and the set of most general unifiers , @xmath117 , is defined by : @xmath118 .",
    "finally , the set of generalisations of two terms is defined by : @xmath119 and the set of most specific generalisations is defined by : @xmath120 .",
    "the efficiency of an analyser depends critically on the algorithmic complexities of its abstract domain operations .",
    "these in turn are determined by the representation of the abstract domain .",
    "the representation also determines the size of the inputs to the domain operations , as well as impacting on memory usage . because of this",
    ", the choice of representation is fundamental to the efficiency of an analyser and is therefore of great importance .",
    "the remainder of this subsection reviews three factors which should help the implementor arrive at a suitable representation and suggest where domain operations might be refined .",
    "there are typically many degrees of freedom in designing an analyser , even for a given domain .",
    "furthermore , work can often be shifted from one abstract operation into another .",
    "for example , boolean formulae can be represented in either conjunctive normal form ( cnf ) or disjunctive normal form ( dnf ) . in cnf , conjunction is constant - time and disjunction is quadratic - time , whereas in dnf , conjunction is quadratic - time and disjunction is constant - time .",
    "ideally , an analysis should be designed so that the most frequently used operations have low complexity and are therefore fast .",
    "this motivates the following approach :    1 .",
    "prototype an analyser for the given domain .",
    "2 .   instrument the analyser to count the number of times each domain operation is invoked .",
    "3 .   generate these counts for a number of programs ( the bigger the better ) .",
    "4 .   choose a representation which gives a good match between the frequency and the complexity of the domain operations .    because the frequency analysis is solely concerned with generated instruction counts , the efficiency of the prototype analyser is not a significant issue .",
    "the objective is to choose a representation for which the most frequently occurring operations are also the fastest .",
    "however , this criterion needs to be balanced with others , such as the density of the representation .",
    "the complexity of the domain operations is a function of the size of their inputs .",
    "large inputs nullify the value of good complexities , hence a balance between size of representation and complexity of domain operations is needed . the following factors impact on this relationship :    1 .",
    "the abstractions which typically arise should be represented compactly .",
    "2 .   a factorised representation with an expressive , high density",
    ", low maintenance component is attractive .",
    "3 .   maintaining the representation ( for example , as a canonical form ) should not come with a high overhead .",
    "4 .   the representation should fit with machinery available in the implementation language .",
    "a domain is said to be factorised if its information is represented as a product of subdomains .",
    "it may not always be possible to fulfill all these requirements .",
    "moreover , these factors needs to balanced with others , such as their impact on the complexities of frequently called domain operations .      in many analyses it is inevitable that some domain operations will have high complexity .",
    "however , it is sometimes possible to reduce the impact of this by filtering the operation , as follows :    1",
    ".   for a high complexity domain operation identify special cases where the operation can be calculated using a lower complexity algorithm .",
    "2 .   instrument the analyser to quantify how often the lower complexity algorithm can be applied .",
    "3 .   if it appears that the special case occurs frequently",
    ", then implement the special case and measure the impact on performance .",
    "the bottom line is that the cost of detecting the special case should not outweigh the benefit of applying the specialised domain algorithm .      in order to balance the frequency of abstract operations against their cost ,",
    "an existing  analyser was instrumented to count the number of calls to the various abstract operations .",
    "the analyser used for this is based on armstrong and schachte s bdd - based domain operations for and   @xcite . using the domain operations provided for these domains ,",
    "a  analyser can easily be derived .",
    "this analyser is coded in prolog as a simple meta - interpreter that uses induced magic - sets @xcite and eager evaluation @xcite to perform goal - dependent bottom - up evaluation and call the c implemented domain operations .",
    "induced magic is a refinement of the magic set transformation , avoiding much of the re - computation that arises because of the repetition of literals in the bodies of magicked clauses @xcite .",
    "eager evaluation @xcite is a fixpoint iteration strategy which proceeds as follows : whenever an atom is updated with a new ( weaker ) abstraction , a recursive procedure is invoked to ensure that every clause that has that atom in its body is re - evaluated .",
    "an advantage of induced magic is that it can be coded straightforwardly in prolog .",
    "table 1 gives a breakdown of the relative frequency ( in percentages ) of the calls to each abstract operation in the bdd - based @xmath5 analysis of eight large programs .",
    "meet , join , equiv , project and rename are the obvious boolean operations",
    ". join ( diff ) is those calls to a join @xmath54 where @xmath121 and @xmath122 ( this will be useful in section [ filt ] ) .",
    "total details the total number of calls to these domain operations .",
    "[ freq - bdd ]    .frequency analysis : bdd - based analyser ( figures in % ) [ cols= \" > , > , > , > , > , > , > , > , > \" , ]     the first three columns of table 11 all give very similar times , indicating that true factorisation and redundancy removal have little effect on analysis times , essentially paying for themselves .",
    "the next three columns give times for the situation with one of e , g , p switches off ( relative to the default case ) .",
    "it is clear that turning off any of these optimisation gives a slow down of , perhaps , 10% .",
    "the next three columns give results for switching off optimisations in pairs .",
    "again there is a clear slowdown from the previous three results ( although notice that the epr and gr results are very similar ) , a slowdown of 15 - 20% from the default case .",
    "finally , the last column shows that switching off all the optimisations results in a slowdown of approximately 25% in most programs .",
    "one conclusion to be drawn from table 11 is that the non - canonical  analysis is extremely robust . by turning off all the optimisations for both the size of representation and the efficiency of the abstract operations , the analysis is still fast .",
    "it is expected that the effect of turning off these optimisations would be bigger when using a less effective iteration strategy or a less suitable ( orthogonal ) representation .",
    "van hentenryck _ et al . _",
    "@xcite is an early work which laid a foundation for bdd - based @xmath4 analysis .",
    "@xcite describe how variants of @xmath4 can be implemented using toupie , a constraint language based on the @xmath123-calculus .",
    "if this analyser was extended with , say , magic sets , it might lead to a very respectable goal - dependent analysis .",
    "more recently , bagnara and schachte @xcite have developed the idea @xcite that a factorised implementation of robdds which keeps definite information separately from dependency information is more efficient than keeping the two together .",
    "this hybrid representation can significantly decrease the size of an robdd and thus is a useful implementation tactic .",
    "heaton _ et al .",
    "_ @xcite propose , a sub - domain of @xmath5 , that can only propagate dependencies of the form @xmath124 across procedure boundaries .",
    "this information is precisely that contained in one of the fields of the gep factorised domain .",
    "the main finding of @xcite is that this sub - domain performs reasonably well for goal - dependent analysis .",
    "armstrong _ et al .",
    "_ @xcite study a number of different representations of boolean functions for both @xmath5 and @xmath4 .",
    "an empirical evaluation on 15 programs suggests that specialising dual blake canonical form ( dbcf ) for @xmath5 leads to the fastest analysis overall .",
    "_ @xcite also perform interesting precision experiments . @xmath5 and @xmath4 are compared , however , in a bottom - up framework that is based on condensing and is therefore biased towards @xmath4 .",
    "the authors point out that a top - down analyser would improve the precision of @xmath5 relative to @xmath4 .",
    "garca de la banda _ et al . _",
    "@xcite describe a prolog implementation of @xmath5 that is also based on an orthogonal dbcf representation ( though this is not explicitly stated ) and show that it is viable for some medium sized benchmarks .",
    "fecht and seidl @xcite describe another groundness analyser for  that is not coded in c. they adopt sml as a coding medium in order to build an analyser that is declarative and easy to maintain .",
    "their analyser employs a widening .",
    "codish and demoen @xcite describe a non - ground model based implementation technique for @xmath125 that would encode @xmath126 as three tuples @xmath127 , @xmath128 , @xmath129 .",
    "_ show how , for , meet , join and projection can be implemented with quadratic operations based on a @xmath130 quotient @xcite .",
    "@xmath5 functions are essentially represented as a set of models and widening is thus required to keep the size of the representation manageable . ideally , however , it would be better to avoid widening by , say , using a more compact representation .",
    "most recently , genaim and codish @xcite propose a dual representation for .",
    "for function @xmath33 , the models of @xmath90 are named and @xmath33 is represented by a tuple recording for each variable of @xmath33 which of these models the variable is in . for example , the models of @xmath131 are @xmath132 . naming the three models @xmath133 , @xmath134 , @xmath135 respectively , @xmath33 is represented by @xmath136 .",
    "this representation cleverly allows the well known aci1 unification theory to be used for the domain operations .",
    "@xcite report promising experimental results , but still need a widening to analyse the aqua_c benchmark .",
    "by considering the way in which goal - dependent groundness analyses proceed , an intelligent choice can be made as to how to represent the abstract domain and how the cost of the domain operations should be balanced .",
    "analysing the relative frequencies of the domain operations leads to a representation which is compact , and where the most commonly called domain operations are the most lightweight .",
    "filters for the more expensive domain operations are described which allow these operations to be calculated by inexpensive special cases .",
    "ways in which a non - ground representation for boolean functions may exploit the language features of prolog to obtain an efficient implementation are described .",
    "the iteration strategy for driving an analysis is also extremely important .",
    "several strategies are discussed and compared . it is concluded that for groundness analysis the fastest implementation uses a simple strategy avoiding precomputation and sophisticated data - structures .",
    "an implementor might find some or all of the issues discussed and ideas raised in this paper useful in designing a program analysis and in implementing it in prolog .",
    "the end product of this work is a highly principled goal - dependent groundness analyser combining the techniques described .",
    "it is written in prolog and is small and easily maintained .",
    "the analyser is a robust , fast , precise and scalable and does not require widening for the largest program in the benchmark suite .",
    "experimental results show that the speed of the fixpoint calculation is very close to that of reading , parsing and normalising the input file .",
    "results also suggest that the performance of the analyser compares well with other groundness analysers , including bdd - based analysers written in c.      we thank roberto bagnara , franois bourdoncle , , , john gallagher , samir genaim and pat hill for useful discussions .",
    "we would also like to thank peter schachte for help with his bdd analyser .",
    "this work was funded partly by epsrc grant gr / mo8769 .",
    "corsini , m .-",
    ", musumbu , k. , rauzy , a. , & le charlier , b. ( 1993 ) .",
    "efficient bottom - up abstract interpretation of prolog by means of constraint solving over finite domains . .",
    "lecture notes in computer science , vol . 714 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> boolean functions can be used to express the groundness of , and trace grounding dependencies between , program variables in ( constraint ) logic programs . in this paper , a variety of issues pertaining to the efficient prolog implementation of groundness analysis are investigated , focusing on the domain of definite boolean functions , . </S>",
    "<S> the systematic design of the representation of an abstract domain is discussed in relation to its impact on the algorithmic complexity of the domain operations ; the most frequently called operations should be the most lightweight . </S>",
    "<S> this methodology is applied to , resulting in a new representation , together with new algorithms for its domain operations utilising previously unexploited properties of   for instance , quadratic - time entailment checking . the iteration strategy driving the analysis </S>",
    "<S> is also discussed and a simple , but very effective , optimisation of induced magic is described . </S>",
    "<S> the analysis can be implemented straightforwardly in prolog and the use of a non - ground representation results in an efficient , scalable tool which does not require widening to be invoked , even on the largest benchmarks . </S>",
    "<S> an extensive experimental evaluation is given . </S>",
    "<S> + * keywords : * abstract interpretation , groundness analysis , definite boolean functions , fixpoint algorithms . </S>"
  ]
}