{
  "article_text": [
    "shallow semantic processing applications , comparing argument structures to search patterns or filling in simple templates , can achieve respectable results using the standard ` pipeline ' approach to semantics , in which sentences are morphologically and syntactically resolved to a single tree before being interpreted . putting disambiguation ahead of semantic evaluation is reasonable in these applications because they are primarily run on content like newspaper text or dictated speech , where no machine - readable contextual information is readily available to provide semantic guidance for disambiguation .    this single - tree semantic architecture is a poor fit for applications such as natural language interfaces however , in which a large amount of contextual information is available in the form of the objects and events in the application s run - time environment .",
    "this is because the environment information can not be used to inform parsing and disambiguation decisions unless the input sentence is semantically analyzed , but this does not occur until after parsing in the single - tree architecture . assuming that no current statistical disambiguation technique is so accurate that it could not benefit from this kind of environment - based information ( if available ) ,",
    "then it is important that the semantic analysis in an interface architecture be efficiently performed _ during _ parsing .",
    "this paper describes the computational properties of one such architecture , embedded within a system for giving various kinds of conditional instructions and behavioral constraints to virtual human agents in a 3-d simulated environment @xcite . in one application of this system ,",
    "users direct simulated maintenance personnel to repair a jet engine , in order to ensure that the maintenance procedures do not risk the safety of the people performing them .",
    "since it is expected to process a broad range of maintenance instructions , the parser is run on a large subset of the xtag english grammar @xcite , which has been annotated with lexical semantic classes @xcite associated with the objects , states , and processes in the maintenance simulation . since the grammar has several thousand lexical entries , the parser is exposed to considerable lexical and structural ambiguity as a matter of course .",
    "the environment - based disambiguation architecture described in this paper has much in common with very early environment - based approaches , such as those described by winograd @xcite , in that it uses the actual entities in an environment database to resolve ambiguity in the input .",
    "this research explores two extensions to the basic approach however :    1 .",
    "it incorporates ideas from type theory to represent a broad range of linguistic phenomena in a manner for which their extensions or _ potential referents _ in the environment are well - defined in every case .",
    "this is elaborated in section  [ sect : nodes ] .",
    "2 .   it adapts the concept of structure sharing , taken from the study of parsing , not only to translate the many possible interpretations of ambiguous sentences into shared logical expressions , but also to evaluate these sets of potential referents , over all possible interpretations , in polynomial time .",
    "this is elaborated in section  [ sect : forest ] .",
    "taken together , these extensions allow interfaced systems to evaluate a broad range of natural language inputs  including those containing np / vp attachment ambiguity and verb sense ambiguity  in a principled way , simply based on the objects and events in the systems environments . for example , such a system would be able to correctly answer ` did someone stop the test at 3:00 ? ' and resolve the ambiguity in the attachment of ` at 3:00 ' just from the fact that there are nt any 3:00 tests in the environment , only an event where one stops at 3:00 .",
    "because it evaluates instructions before attempting to choose a single interpretation , the interpreter can avoid getting ` stranded ' by disambiguation errors in earlier phases of analysis .",
    "the main challenge of this approach is that it requires the efficient calculation of the set of objects , states , or processes in the environment that each possible sub - derivation of an input sentence could refer to .",
    "a semantic interpreter could always be run on an ( exponential ) enumerated set of possible parse trees as a post - process , to filter out those interpretations which have no environment referents , but recomputing the potential environment referents for every tree would require an enormous amount of time ( particularly for broad coverage grammars such as the one employed here ) .",
    "the primary result of this paper is therefore a method of containing the time complexity of these calculations to lie within the complexity of parsing ( i.e.  within @xmath0 for a context - free grammar , where @xmath1 is the number of words in the input sentence ) , without sacrificing logical correctness , in order to make environment - based interpretation tractable for interactive applications .",
    "existing environment - based methods ( such as those proposed by winograd ) only calculate the referents of noun phrases , so they only consult the _ objects _ in an environment database when interpreting input sentences .",
    "but the evaluation of ambiguous sentences will be incomplete if the referents for verb phrases and other predicates are not calculated . in order to evaluate the possible interpretations of a sentence , as described in the previous section",
    ", an interface needs to define referent sets for every possible constituent .",
    "the proposed solution draws on a theory of constituent types from formal linguistic semantics , in which constituents such as nouns and verb phrases are represented as composeable functions that take entitiess or situations as inputs and ultimately return a truth value for the sentence . following a straightforward adaptation of standard type theory , common nouns ( functions from entities to truth values ) define potential referent sets of simple environment entities : @xmath2 , and sentences ( functions from situations or world states to truth values ) define potential referent sets of situations in which those sentences hold true : @xmath3 . depending on the needs of the application , these situations can be represented as intervals along a time line @xcite , or as regions in a three - dimensional space @xcite , or as some combination of the two , so that they can be constrained by modifiers that specify the situations times and locations .",
    "referents for other types of phrases may be expressed as tuples of entities and situations : one for each argument of the corresponding logical function s input ( with the presence or absence of the tuple representing the boolean output ) .",
    "for example , adjectives , prepositional phrases , and relative clauses , which are typically represented as situationally - dependent properties ( functions from situations and entities to truth values ) define potential referent sets of tuples that consist of one entity and one situation : @xmath4 .",
    "this representation can be extended to treat common nouns as situationally - dependent properties as well , in order to handle sets like ` bachelors ' that change their membership over time .",
    "any method for using the environment to guide the interpretation of natural language sentences requires a tractable representation of the many possible interpretations of each input .",
    "the representation described here is based on the polynomial - sized chart produced by any dynamic programming recognition algorithm .",
    "a record of the derivation paths in any dynamic programming recognition algorithm ( such as cky @xcite or earley @xcite ) can be interpreted as a polynomial sized and - or graph with space complexity equal to the time complexity of recognition , whose disjunctive nodes represent possible constituents in the analysis , and whose conjunctive nodes represent binary applications of rules in the grammar . this is called a _ shared forest _ of parse trees , because it can represent an exponential number of possible parses using a polynomial number of nodes which are shared between alternative analyses @xcite , and can be constructed and traversed in time of the same complexity ( e.g.  @xmath0 for context free grammars ) . for example , the two parse trees for the noun phrase ` button on handle beside adapter ' shown in figure  [ fig : gatetrees ] can be merged into the single shared forest in figure  [ fig : gateforest ] without any loss of information .",
    "these shared syntactic structures can further be associated with compositional semantic functions that correspond to the syntactic elements in the forest , to create a shared forest of trees each representing a complete expression in some logical form .",
    "this extended sharing is similar to the ` packing ' approach employed in the core language engine @xcite , except that the cle relies on a quasi - logical form to underspecify semantic information such as quantifier scope ( the calculation of which is deferred until syntactic ambiguities have been at least partially resolved by other means ) ; whereas the approach described here extends structure sharing to incorporate a certain amount of quantifier scope ambiguity in order to allow a complete evaluation of all subderivations in a shared forest before making any disambiguation decisions in syntax .",
    "various synchronous formalisms have been introduced for associating syntactic representations with logical functions in isomorphic or locally non - isomorphic derivations , including categorial grammars ( cgs ) @xcite , synchronous tree adjoining grammars ( tags ) @xcite , and synchronous description tree grammars ( dtgs ) @xcite .",
    "most of these formalisms can be extended to define semantic associations over entire shared forests , rather than merely over individual parse trees , in a straightforward manner , preserving the ambiguity of the syntactic forest without exceeding its polynomial size , or the polynomial time complexity of creating or traversing it .",
    "since one of the goals of this architecture is to use the system s representation of its environment to resolve ambiguity in its instructions , a space - efficient shared forest of logical functions will not be enough .",
    "the system must also be able to efficiently calculate the sets of potential referents in the environment for every subexpression in this forest .",
    "fortunately , since the logical function forest shares structure between alternative analyses , many of the sets of potential referents can be shared between analyses during evaluation as well .",
    "this has the effect of building a third shared forest of potential referent sets ( another and - or graph , isomorphic to the logical function forest and with the same polynomial complexity ) , where every conjunctive node represents the results of applying a logical function to the elements in that node s child sets , and every disjunctive node represents the union of all the potential referents in that node s child sets .",
    "the presence or absence of these environment referents at various nodes in the shared forest can be used to choose a viable parse tree from the forest , or to evaluate the truth or falsity of the input sentence without disambiguating it ( by checking the presence or lack of referents at the root of the forest ) .",
    "for example , the noun phrase ` button on handle beside adapter ' has at least two possible interpretations , represented by the two trees in figure  [ fig : gatetrees ] : one in which a button is on a handle and the _ handle _ ( but not necessarily the button ) is beside an adapter , and the other in which a button is on a handle and the _ button _ ( but not necessarily the handle ) is beside an adapter .",
    "the semantic functions are annotated just below the syntactic categories , and the potential environment referents are annotated just below the semantic functions in the figure . because there are no handles next to adapters in the environment ( only buttons next to adapters ) , the first interpretation has no environment referents at its root , so this analysis is dispreferred if it occurs within the analysis of a larger sentence .",
    "the second interpretation does have potential environment referents all the way up to the root ( there is a button on a handle which is also beside an adapter ) , so this analysis is preferred if it occurs within the analysis of a larger sentence .",
    "the shared forest representation effectively merges the enumerated set of parse trees into a single data structure , and unions the referent sets of the nodes in these trees that have the same label and cover the same span in the string yield ( such as the root node , leaves , and the pp covering ` beside adapter ' in the examples above ) .",
    "the referent - annotated forest for this sentence therefore looks like the forest in figure  [ fig : gateforest ] , in which the sets of buttons , handles , and adapters , as well as the set of things beside adapters , are shared between the two alternative interpretations . if there is a button next to an adapter , but no handle next to an adapter , the tree representing ` handle beside adapter ' as a constituent may be dispreferred in disambiguation , but the np constituent at the root is still preferred because it has potential referents in the environment due to the other interpretation .    the logical function at each node is defined over the referent sets of that node s immediate children .",
    "nodes that represent the attachment of a modifier with referent set @xmath5 to a relation with referent set @xmath6 produce referent sets of the form :    @xmath7    nodes in a logical function forest that represent the attachment of an argument with referent set @xmath8 to a relation with referent set @xmath6 produce referent sets of the form :    @xmath9    effectively stripping off one of the objects in each tuple if the object is also found in the set of referents for the argument . and  [ fig : gateforest ] . instead",
    ", an additional bar is added to the function name to designate the effective last object in each tuple : the tuple @xmath10 referenced by @xmath11 has @xmath12 as the last element , but the tuple referenced by @xmath13 actually has @xmath14 as the last element since the complement @xmath12 has been already been attached . ]",
    "this is a direct application of standard type theory to the calculation of referent sets : modifiers take and return functions of the same type , and arguments must satisfy one of the input types of an applied function .",
    "since both of these ` referent set composition ' operations at the conjunctive nodes  as well as the union operation at the disjunctive nodes  are linear in space and time on the number of elements in each of the composed sets ( assuming the sets are sorted in advance and remain so ) , the calculation of referent sets only adds a factor of @xmath15 to the size complexity of the forest and the time complexity of processing it , where @xmath15 is the number of objects and events in the run - time environment .",
    "thus , the total space and time complexity of the above algorithm ( on a context - free forest ) is @xmath16 .",
    "if other operations are added , the complexity of referent set composition will be limited by the least efficient operation .",
    "since the referent sets for situations are also well defined under type theory , this environment - based approach can also resolve attachment ambiguities involving verbs and verb phrases in addition to those involving only nominal referents .",
    "for example , if the interpreter is given the sentence `` coolant drained after test at 3:00 , '' which could mean the draining was at 3:00 or the test was at 3:00 , the referents for the draining process and the testing process can be treated as time intervals in the environment history .",
    "first , a forest is constructed which shares the subtrees for `` the test '' and `` after 3:00 , '' and the corresponding sets of referents .",
    "each node in this forest ( shown in figure  [ fig : testforest ] ) is then annotated with the set of objects and intervals that it could refer to in the environment .",
    "since there were no testing intervals at 3:00 in the environment , the referent set for the np ` test after 3:00 ' is evaluated to the null set .",
    "but since there is an interval corresponding to a draining process ( @xmath17 ) at the root , the whole vp will still be preferred as constituent due to the other interpretation .",
    "the evaluation of referents for quantifiers also presents a tractability problem , because the functions they correspond to in the montague analysis map two sets of entities to a truth value .",
    "this means that a straightforward representation of the potential referents of a quantifier such as ` at least one ' would contain every pair of non - empty subsets of the set @xmath18 of all entities , with a cardinality on the order of @xmath19 .",
    "if the evaluation of referents is deferred until quantifiers are composed with the common nouns they quantify over , the input sets would still be as large as the power sets of the nouns potential referents .",
    "only if the evaluation of referents is deferred until complete nps are composed as arguments ( as subjects or objects of verbs , for example ) can the output sets be restricted to a tractable size .",
    "this provision only covers _ in situ _ quantifier scopings , however . in order to model",
    "raised scopings , arbitrarily long chains of raised quantifiers ( if there are more than one ) would have to be evaluated before they are attached to the verb , as they are in a ccg - style function composition analysis of raising @xcite .",
    "fortunately , universal quantifiers like ` each ' and ` every ' only choose the one maximal set of referents out of all the possible subsets in the power set , so any number of raised universal quantifier functions can be composed into a single function whose referent set would be no larger than the set of all possible entities .",
    "it may not be possible to evaluate the potential referents of non - universal raised quantifiers in polynomial time , because the number of potential subsets they take as input is on the order of the power set of the noun s potential referents .",
    "this apparent failure may hold some explanatory power , however , since raised quantifiers other than ` each ' and ` every ' seem to be exceedingly rare in the data .",
    "this scarcity may be a result of the significant computational complexity of evaluating them in isolation ( before they are composed with a verb ) .",
    "an implemented system incorporating this environment - based approach to disambiguation has been tested on a set of manufacturer - supplied aircraft maintenance instructions , using a computer - aided design ( cad ) model of a portion of the aircraft as the environment .",
    "it contains several hundred three dimensional objects ( buttons , handles , sliding couplings , etc ) , labeled with object type keywords and connected to other objects through joints with varying degrees of freedom ( indicating how each object can be rotated and translated with respect to other objects in the environment ) .",
    "the test sentences were the manufacturer s instructions for replacing a piece of equipment in this environment .",
    "the baseline grammar was not altered to fit the test sentences or the environment , but the labeled objects in the cad model were automatically added to the lexicon as common nouns .    in this preliminary accuracy test",
    ", forest nodes that correspond to noun phrase or modifier categories are dispreferred if they have no potential entity referents , and forest nodes corresponding to other categories are dispreferred if their arguments have no potential entity referents .",
    "many of the nodes in the forest correspond to noun - noun modifications , which can not be ruled out by the grammar because the composition operation that generates them seems to be productive ( virtually any ` n2 ' that is attached to or contained in an ` n1 ' can be an ` n1 n2 ' ) .",
    "potential referents for noun - noun modifications are calculated by a rudimentary spatial proximity threshold , such that any potential referent of the _ modified _ noun lying within the threshold distance of a potential referent of the _ modifier _ noun in the environment is added to the composed set .",
    "the results are shown below .",
    "the average number of parse trees per sentence in this set was @xmath20 before disambiguation .",
    "the average ratio of nodes in enumerated tree sets to nodes in shared forests for the instructions in this test set was @xmath21 , a nearly tenfold reduction due to sharing .",
    "gold standard ` correct ' trees were annotated by hand using the same grammar that the parser uses . the success rate of the parser in this domain ( the rate at which the correct tree could be found in the parse forest ) was @xmath22 .",
    "the retention rate of the environment - based filtering mechanism described above ( the rate at which the correct tree was retained in parse forest ) was @xmath23 of successfully parsed sentences .",
    "the average reduction in number of possible parse trees due to the environment - based filtering mechanism described above was @xmath24 for successfully parsed and filtered forests.schuler/ebd.html . ]",
    "[ cols=\"^,^,^,^,^ \" , ]      indicates correct tree not in parse forest    * indicates correct tree not in filtered forest",
    "this paper has described a method by which the potential environment referents for all possible interpretations of of an input sentence can be evaluated _ during _ parsing , in polynomial time .",
    "the architecture described in this paper has been implemented with a large coverage grammar as a run - time interface to a virtual human simulation .",
    "it demonstrates that a natural language interface architecture that uses the objects and events in an application s run - time environment to inform disambiguation decisions ( by performing semantic evaluation during parsing ) is feasible for interactive applications .",
    "s.  billot and b.  lang .",
    "the structure of shared forests in ambiguous parsing . in _ proceedings of the 27@xmath25 annual meeting of the association for computational linguistics ( acl 89 ) _ , pages 143151 .",
    "aravind  k. joshi .",
    "in l.  karttunen d.  dowty and a.  zwicky , editors , _ natural language parsing : psychological , computational and theoretical perspectives _ , pages 206250",
    ". cambridge university press , cambridge , u.k .",
    "karin kipper , hoa  trang dang , and martha palmer . 2000 .",
    "class - based construction of a verb lexicon . in _ proceedings of the seventh national conference on artificial intelligence ( aaai-2000 )",
    "_ , austin , tx , july - august .              m.  tomita .",
    "an efficient context - free parsing algorith for natural languages . in _ proceedings of the ninth international annual conference on artificial intelligence _ , pages 756764 , los angeles , ca ."
  ],
  "abstract_text": [
    "<S> the standard pipeline approach to semantic processing , in which sentences are morphologically and syntactically resolved to a single tree before they are interpreted , is a poor fit for applications such as natural language interfaces . </S>",
    "<S> this is because the environment information , in the form of the objects and events in the application s run - time environment , can not be used to inform parsing decisions unless the input sentence is semantically analyzed , but this does not occur until after parsing in the single - tree semantic architecture . </S>",
    "<S> this paper describes the computational properties of an alternative architecture , in which semantic analysis is performed on all possible interpretations _ during _ parsing , in polynomial time . </S>"
  ]
}