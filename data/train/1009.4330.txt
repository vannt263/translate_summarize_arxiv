{
  "article_text": [
    "during the last thirty years high performance computing ( hpc ) has become an increasingly - important tool in scientific research .",
    "hpc studies enhance understanding of experimental findings , allow researchers to test theories on model systems , and even make it possible to investigate phenomena which can not be investigated via classical experiments .",
    "one class of computer experiments is of special interest : molecular dynamics ( md ) simulations .",
    "md is used to simulate materials on an atomic ( or coarser - grained ) level using various interaction models . through advances in compute capabilities and algorithms , md simulations",
    "have gradually expanded their range of applicability from modeling tiny systems of a few hundred atoms for up to a few thousand time steps , to performing short multi - billion atom simulations or multi - billion time - step simulations of smaller systems .",
    "while this is already impressive in itself , a single cubic centimeter of matter contains on the order of @xmath0 atoms , and to model only one second of its time propagation , @xmath1 time steps ( typically a femtosecond each ) would be required . therefore , the interest in accelerating md simulations is unstinting and of great interest for many computational scientists",
    ".    easily programmable graphics cards ( gpus ) represent a disruptive technology development that allows radical departure from recent years gradual improvements in md simulation speed . by harnessing the compute capability of gpus",
    ", md practitioners will be able to simulate much larger systems for much longer simulated times .",
    "gpus represent a jump in the performance - to - cost ratio of at least a factor of five .",
    "gpus also achieve more flops - per - watt than corresponding cpu hardware , making next - generation gpu - based hpc supercomputers more feasible from an operating energy cost perspective .",
    "the cuda programming language is currently the most widely used programming model for gpus .",
    "since its introduction , many scientific programmers have used cuda to write extremely fast software , thereby enabling previously - impossible investigations . among those",
    "are also a number of md codes which have shown speed - ups of 5 - 100x over existing cpu - based codes .    in this paper , we present our own implementation of a gpu - md code called lammps@xmath2 , which is introduced as an extension to the widely used md code lammps@xcite . with its 26 different force fields , lammps@xmath2 can model atomic , polymeric , biological , metallic , granular , and coarse - grained systems up to 20 times faster than a modern quad core workstation by harnessing a modern gpu . at the same time it offers unprecedented multi - gpu support for an md code . by providing very effective scaling of simulations on up to hundreds of gpus",
    ", lammps@xmath2 enables scientists to harness the full power of the world s most advanced supercomputers , such as the world s fastest supercomputer , the tianhe-1a at the chinese national supercomputing center in tianji@xcite .",
    "we start with a description of the design objectives of our implementation and an overview of the features of lammps@xmath2 .",
    "then we discuss aspects of our gpu implementations of lammps s pair force calculations .",
    "performance results are then presented for various md simulations on single gpus .",
    "this is followed by a discussion of strategies that enable gpu - based md codes to scale well on systems with many gpus .",
    "we also report and analyze lammps@xmath2 performance results on ncsa s lincoln cluster , using up to 256 gpus .",
    "parameters of the benchmark simulations are listed in appendix [ sec : app_simulations ] and hardware configuration are given in appendix [ sec : app_hardware ] .",
    "numerous gpu - md codes have been under development during the past several years . some of those are new codes ( hoomd@xcite , acemd@xcite ) , others are extensions or modifications of existing codes ( e.g. namd@xcite , amber@xcite , lammps@xcite ) .",
    "most of these projects are of limited scope and can not compete with the rich feature sets of legacy cpu - based md codes .",
    "this is not surprising considering the amount of development time which has been spent on the existing codes ; many of them have been under development for more than a decade .",
    "furthermore , some of these gpu - md codes have been written to accelerate specific compute - intensive tasks , limiting the need to implement a broad feature set .",
    "our goal is to provide a gpu - md code that can be used for simulation of a wide array of materials classes ( e.g. glasses , semiconductors , metals , polymers , biomolecules , etc . ) across a range of scales ( atomistic , coarse - grained , mesoscopic , continuum ) .",
    "lammps can perform such simulations on cpu - based clusters .",
    "it is a classical md code that been under development since the mid 1990s , is freely - available , and includes a very rich feature set . since building such simulation software from scratch would be an enormous task , we instead leverage the tremendous effort that has gone into lammps , and enable it to harness the compute power of gpus .",
    "we have written a lammps `` package '' that can be built along with the existing lammps software , thereby preserving lammps rich feature set for users while yielding tremendous computational speedups .",
    "other important lammps features include an extensive scripting system for running simulations , and a simple - to - extend and modular code infrastructure that allows for easy integration of new features .",
    "most importantly it has an mpi - based parallelization infrastructure that exhibits good scaling behavior on up to thousands of nodes .",
    "finally , starting with an existing code like lammps and building gpu versions of functions and classes one by one allows for easy code verification .",
    "our objectives can be summarized as follows ( in order of decreasing priority ) :    a.   maintain the rich feature set and flexibility of lammps , b.   achieve the highest possible speed - ups , c.   allow good parallel scalability on large gpu - based clusters , d.   minimize code changes , e.   write the code so that it is easy to maintain , f.   include gpu support for the full list of lammps capabilities , g.   make the gpu capabilities easy for lammps users to invoke .",
    "all of these design objectives have implications for design decisions , yet in many cases they are competing objectives .",
    "for example objective ( i ) implies that the different operations of a simulation have to be done by different modules , and that the modules have to be able to be used in any combination requested by the user .",
    "this in turn means that data , such as the particle positions , are loaded multiple times during a single simulation step from the device memory , which results in a considerably negative effect on the performance of the simulation .",
    "another slight performance hit is caused by the use of templates for the implementation of pair forces and communication routines .",
    "while this greatly enhances maintainability , it adds some computational overhead . by keeping full compatibility with lammps",
    "we were able to minimize the gpu - related changes that users will need to make to existing input scripts . in order to use lammps@xmath2",
    "it is often enough to add the line `` accelerator cuda '' at the beginning of an existing input script .",
    "this triggers use of gpus for all gpu - enabled features in lammps@xmath2 , while falling back to the original cpu version for all others .",
    "another big influence on design decisions comes from the limiting factors of the targeted architecture . since",
    "those have been discussed in detail elsewhere@xcite , here we only list the most important factors :    a.   in order to use the full gpu , thousands or even tens of thousands of threads are needed , b.   data transfer between the host and the gpu is slow , c.   the ratio of device memory bandwidth to computational peak performance is much smaller than on a cpu , d.   latencies of the device memory are large , e.   random memory accesses on the gpu are serialized . f.   32 threads are executed in parallel    considering ( b ) , we decided to minimize data transfers between device and host by running as many parts of the simulation as possible on the gpu .",
    "this distinguishes our approach from other gpu extensions of existing md codes , where only the most computationally - expensive pair forces are calculated on the gpu . a work - flow chart of our implementation is shown in figure [ fig : workflow ] .",
    "work - flow , dashed boxes are done on the cpu , while solid boxes are done on the gpu.,scaledwidth=25.0% ]    currently lammps@xmath2 supports 26 pair force styles ; long range coulomb interactions via a particle - particle / particle - mesh ( pppm ) algorithm ; nve , nvt , and npt integrators ; and a number of lammps `` fixes '' .",
    "in addition , pair force calculations on the gpu can be overlapped with bonded interactions and long range coulomb interactions if those are evaluated on the cpu .",
    "all of the bond , angle , dihedral , and improper forces available in the main lammps program can be used .",
    "simulations can be performed in single ( 32 bit floats ) and double ( 64 bit floats ) precision , as well as in a mixed precision mode , where only the force calculation is done in single precision while the time integration is done in double precision .",
    "in addition to the requirements of lammps , only the cuda toolkit ( available for free from nvidia ) is needed .",
    "currently only nvidia gpus with a compute capability of 1.3 or higher are supported .",
    "this includes geforce 285 , tesla c1060 as well as gtx480 and fermi c2050 gpus .",
    "the package is available under the gnu public license and can be downloaded from http://code.google.com/p/gpulammps/ , where detailed installation instructions and feature lists can be found .",
    "lammps@xmath2 , which is encapsulated in the user - cuda package of lammps , should not be confused with lammps `` gpu '' package , which has some overlapping capabilities ( see figures [ fig : bench_system_size ] and [ fig : scaling ] ) and is also available from the same website .",
    "we analyzed two variants of short range force calculations : a cell list approach and a neighbor list approach .",
    "while most cpu - based md codes use a neighbor list approach for the force calculation , it has been suggested@xcite that the cell list approach is better suited for gpu implementations .",
    "the idea of the cell list approach is a spatial decomposition of the simulation box into a regular grid of small sub - cells , with a maximum number of atoms per cell .",
    "because lammps uses neighbor lists , additional effort is required to re - order the existing data structures for the gpu calculation and to convert the data back into the original lammps format for every usual computation not done on the gpu .    in order to implement this idea on the gpu ,",
    "we associate every _ cell _ with a cuda thread _ block _ and have each of the @xmath3 _ threads _ of it calculate the forces for one _ particle _ in the cell .",
    "furthermore it is necessary to choose the cell size @xmath4 ( see fig . [",
    "fig : cell_lists](a ) ) and the maximum number of atoms per cell @xmath3 . for a given force cut - off radius @xmath5",
    ", we choose @xmath6 in order to keep the average distance between particles in the cell @xmath7 and to limit the frequency of re - assigning atoms to their cells .",
    "also , @xmath4 should be large enough to contain at least 32 particles in order to not to leave gpu threads idle .",
    "accordingly , @xmath3 is automatically chosen as a multiple of 32 , depending on the particle density .",
    "[ fig : cell_lists ]    when performing the force calculations in the cell list approach , at least two more optimizations can be used .",
    "the first is to use newton s third law @xmath8 to save half of the force calculation time . in 2d , forces need to be explicitly computed for only 4 of 8 the neighboring cells , with the other 4 obtained via newton s third law during other cells updates .",
    "figure [ fig : cell_lists](b ) depicts an example of such an update pattern , with the explicitly - computed neighbors of cell e connected with cell e by a solid black line , and the other 4 neighbors of cell e connected with cell e by solid gray lines .",
    "every cell then follows this pattern , and the interactions between all neighboring cells are then considered exactly once , as verified for cell e. in 3d , only 13 of the 26 neighboring cells are explicitly considered .",
    "note , however , that not every selection of 13 neighboring cells fulfills the required periodicity .",
    "execution of gpu thread blocks can be in any order , whether in sequence or in parallel .",
    "therefore , write conflicts may occur .",
    "for example , in figure [ fig : cell_lists](b ) , cell a and cell d might try to update the forces in cell b at the same time . in order to avoid such a write conflict and a resulting error in the calculation ,",
    "the code has been written to execute only non - interfering groups of cells simultaneously .",
    "if only one neighbor shell needs to be considered , there are six such groups in 2d and 18 such groups in 3d .",
    "this does not significantly affect performance since @xmath9 groups are executed , each in approximately @xmath10 of the original time .",
    "the second optimization is the use of shared memory for the positions of the particles in the neighboring cells . if a cell contains more atoms than will fit in shared memory , the particles have to be loaded to shared memory in groups one after another . for a more detailed discussion on this topic ,",
    "see @xcite .      in designing a neighbor list approach that uses blocks of threads",
    ", it becomes clear that there are two main ways that the force calculation work can be divvied up among the threads .",
    "the first possibility is to use one thread per atom ( tpa ) , where the thread loops over all of the neighbors of the given atom .",
    "the second possibility is to use one block per atom ( bpa ) , where each of the threads in the block loop over its designated portion of the neighbors of the given atom . in the following , pseudo - code for both algorithms",
    "are given :    tpa algorithm :    .... 1   i = blockid*threadsperblock+threadid ; 2   load(i ) // coalesced access 3   for(jj = 0 ; jj < numneigh[i ] ;   4       jj++ ) { 5    j < - neighbors[i][jj ] 6    load(j ) //",
    "random access 7    ftmp+=calcpairforce(i , j ) 8   } 9   10 ftmp - > f[i ] // coalesced access ....",
    "bpa algorithm :    .... 1   i = blockid 2   load(i ) // coalesced access 3   for(jj = 0 ; jj < numneigh[i ] ;   4       jj+=threadsperblock ) { 5    j < - neighbors[i][jj ] 6    load(j ) //",
    "random access 7    ftmp+=calcpairforce(i , j ) 8   } 9   reduce(ftmp ) 10 ftmp - > f[i ] // coalesced access ....",
    "both algorithms ostensibly have the same number of instructions ; however , when considering looping it becomes clear that the bpa algorithm requires the execution of a larger total number of lines of code .",
    "the bpa algorithm also requires the relatively expensive reduction of @xmath11 that is not required by the tpa algorithm .",
    "bpa also requires use of a much larger total number of blocks . for further clarification , table [ tab : bpa - tpa - nexec ] lists the number of times each line of code is executed , taking into account the number of blocks used , and considering that 32 threads of each block are executed in parallel .",
    ".[tab : bf ] number of executions per line for the bpa and tpa algorithms [ cols=\"^,^,^ \" , ]     while this seems to indicate that tpa would always be faster , one has to take into account cache usage as well . in order to reduce random accesses in the device memory while loading the neighbor atoms ( limiting factor ( e ) )",
    ", one can cache the positions using the texture cache .",
    "( we also tested global cache on fermi gpus , but it turns out to be slower due to its cache line size of 128 bytes . )",
    "this strategy improves the speed of both algorithms considerably , but it helps bpa more than tpa .",
    "the underlying reason is that less atoms are needed simultaneously with bpa than with tpa . as a result",
    ", bpa allows for better memory locality , and therefore the re - usage of data in the cache is increased ( assuming atoms are spatially ordered ) .",
    "revisiting table [ tab : bpa - tpa - nexec ] makes it evident that this better cache usage becomes increasingly important with an increasing number of neighbors , corresponding to an increased pair cutoff distance .",
    "consequently , one can expect a crossover cutoff for each type of pair force interaction , where tpa is faster for smaller cutoffs and bpa for larger .",
    "unfortunately it is hard to predict where this cutoff lies .",
    "it not only depends on the complexity of the given pair force interaction , but also on the hardware architecture itself .",
    "therefore , a short test is the best way to determine the crossover cutoff .",
    "the timing ratios shown in figure [ fig : bench_bpavstpa ] indicate that the force calculation time can depend significantly on the use of bpa or tpa .",
    "generally the differences are larger when running in single precision than when running in double precision . for the lj system ,",
    "an increase of the cutoff from @xmath12 to @xmath13 can turn the 30% tpa advantage into a 30% bpa advantage .",
    "therefore we decided to implement both algorithms , and allow dynamic selection of the faster algorithm using a built - in mini benchmark during the setup of the simulation .",
    "this ensures that the best possible performance is achieved over a wide range of cutoffs .",
    "while our particular findings are true only for nvidia gpus , one can expect that similar results would be found on other highly parallel architectures with comparable ratios of cache to computational power .    ) ; hardware : cl ( see appendix [ sec : app_hardware]),scaledwidth=45.0% ]    we tested the cell list approach and the neighbor list approach for a small lj system as a function of cutoff radius ( see fig .",
    "[ fig : cell_neigh ] ) .",
    "for the neighbor list approach , three distinct regions can be seen , as labeled in the figure . for regions ia and ib the tpa method is faster than the bpa method . above @xmath14",
    "the bpa algorithm is faster than the tpa method , so the code automatically switches to bpa , resulting in a different slope for region ii .",
    "the two different slopes in ia and ib are most likely a result of the limited texture cache size . for small cutoffs ,",
    "most neighbors fit into the texture cache , facilitating efficient re - usage of data .",
    "but at some point the collective number of neighbors becomes large enough that the texture cache can no longer be used efficiently .",
    "this changes the scaling behavior as a function of the cutoff radius .",
    "figure [ fig : cell_neigh ] clearly demonstrates that the cell - list - based force evaluation is considerably slower than the neighbor - list - based approach for all cut - offs . in this section",
    ", we will make a simple argument why this is not only true for the above example , but has to be expected in general .",
    "figure [ fig : cell_neigh ] is based on an earlier program version that still featured both cell and neighbor lists . due to the weak performance of the cell list approach ,",
    "we have completely dropped it and have focused our efforts on the optimization of the neighbor - list - based force calculation . while further improvements might have been possible for the cell list approach as well , the superiority of the neighbor list approach appears to be inevitable , as explained below .     particles . in region",
    "i ( @xmath15 ) the tpa algorithm is used , while in region ii the bpa algorithm is used .",
    "( the faster algorithm is automatically selected for each region . ) in sub - region ia texture cache is used effectively by the tpa algorithm , but in region ib the cache must be flushed frequently .",
    "the jumps in the cell list curve are caused by the gpu requirement of @xmath3 being a multiple of 32 and the resulting unsteady proportion of started threads versus those that are actually needed .",
    "system : lj ( see appendix [ sec : app_simulations ] ) ; hardware : ws@xmath16 ( see appendix [ sec : app_hardware]),scaledwidth=45.0% ]    obviously , the time @xmath17 for processing a single interaction force consists of two parts : memory access ( i.e. reading the other atom s position ) and the evaluation of the force formula .",
    "navely one might assume that the total time @xmath18 needed for all force calculations equals @xmath17 times the number of interactions .",
    "however , both the cell and the neighbor list algorithms first load all potential interaction partners to check if they are within the cut - off radius @xmath5 .",
    "whenever one thread finds an atom close enough ( @xmath19 ) and evaluates the force formula , the other threads processing interactions with @xmath20 have to wait until every thread in the warp has completed its calculations .",
    "therefore , the time for both memory access and for the evaluation of the force formula scale with the number of possible interaction partners @xmath9 , i.e. it is reasonable to say @xmath21 .",
    "still both factors depend on which algorithm is chosen ( cell or neighbor list ) . to determine which is faster , we examine the ratio of their computational times : @xmath22    for geometric reasons , @xmath23 .",
    "figure [ fig : cell_benchmark_explanation](a ) illustrates the 3d situation in a 2d sketch .",
    "the cell list approach requires loading all atom positions from @xmath24 surrounding ( cubic ) cells , each of edge length @xmath25 , while the neighbor list includes only atoms within a sphere of radius @xmath4 .",
    "the cell list approach is wasteful in the sense that many non - interacting atoms are loaded into memory .",
    "since the cell list approach requires the loading of roughly 3.3 times more data into memory than the neighbor list approach , and since the time for the evaluation of the force formula is the same in both cases , the cell list approach can only be faster if its memory access time is smaller",
    ". this could be possible due to coalesced memory accesses that can be done in the cell list approach . in order to find out whether this is realistic , we model the situation with two parameters :    * @xmath26 : the factor by which the coalesced memory accesses are faster than random accesses ( @xmath27 ) .",
    "* @xmath28 : the fraction of @xmath17 which is assumed to be spent on memory accesses ( @xmath29 ) .",
    "clearly , the cell lists need both high @xmath26 and high @xmath28 in order to gain the advantage with their faster memory accesses . with a little algebra ( see appendix [ sec : calc_comp ] ) , we can quantify some limits for @xmath26 and @xmath28 . in order to make the cell list method viable ,",
    "its memory accesses have to be at least 3.3 times faster than the memory accesses used in the neighbor list method , and at least 70% of the total neighbor list force calculation time has to be spent on memory accesses . in figure",
    "[ fig : alphagamma ] @xmath30 is shown for @xmath31 .",
    "while @xmath32% is not unrealistic for computation of inexpensive pair forces , the use of texture reads in the pair force kernels limits the advantage of coalesced memory accesses considerably ( i.e. decreasing @xmath26 ) , thus making the cell list approach always slower than the neighbor list approach . in practice ,",
    "the product of @xmath26 and @xmath28 is always below the solid line in figure [ fig : alphagamma ] , making the neighbor list approach the preferred alternative .",
    "approaches its maximum performance only for system sizes larger than 200,000 particles .",
    "the same system was also run using hoomd version 0.9.1 and the `` gpu '' package of lammps .",
    "the cpu curve has also been plotted with a scaling factor of 40 to make it easier to see .",
    "system : lj ( see appendix [ sec : app_simulations ] ) ; hardware : ws@xmath33 ( see appendix [ sec : app_hardware]),scaledwidth=45.0% ]    to assess the possible performance gains of harnessing gpus , we have performed benchmark simulations of several important classes of materials . both the regular cpu version of lammps and lammps@xmath2",
    "were run on our workstation b ( ws@xmath33 ) with an intel i7 950 quad core processor and a gtx 470 gpu from nvidia .",
    "simulations on the gpu were carried out in single , double , and mixed precision .",
    "we compare the loop times for 10,000 simulation steps .",
    "the results shown in figure [ fig : bench_single_gpu ] are proof of an impressive performance gain .",
    "even in the worst - case scenario , a granular simulation ( which has extremely few interactions per particle ) , the gpu is 5.3 times as fast as the quad core cpu when using single precision and 2.0 times as fast in double precision . in the best - case scenario",
    "the speed - up reaches a factor of 13.5 for the single precision simulation of a silicate glass involving long range coulomb interactions .",
    "single precision calculations are typically twice as fast as double precision calculations , while mixed precision is somewhere in between .",
    "it is worthy to note that this factor of two between single and double precision is reached on consumer grade geforce gpus , despite the fact that their double precision peak performance is only 1/8th of their single precision peak performance .",
    "this is a strong sign that lammps@xmath2 is memory bound .    generally ,",
    "the speed - up increases with the complexity of the interaction potential and the number of interactions per particle .",
    "additionally the speed - up also depends on the system size .",
    "as stated in section [ sec : design ] the gpu needs many threads in order to be fully utilized .",
    "this means that the gpu can not reach its maximum performance when there are relatively few particle - particle interactions .",
    "this point is illustrated in figure [ fig : bench_system_size ] , where the number of atom - steps per second is plotted as a function of the system size . as can be seen ,",
    "at least 200,000 particles are needed to fully utilize the gpu for this lennard - jones system .",
    "in contrast the cpu core is already nearly saturated with only 1,000 particles .",
    "all systems used to produce figure [ fig : bench_single_gpu ] were large enough to saturate the gpu .",
    "we have also plotted the performance curves for the gpu - md program hoomd ( version 0.9.1 ) and the `` gpu '' package of lammps in figure [ fig : bench_system_size ] for comparison purposes .",
    "the characteristics of hoomd are very similar to lammps@xmath2 .",
    "it reaches its top performance at about 200,000 particles .",
    "interestingly hoomd is somewhat slower than lammps@xmath2 at very high particle counts , while it is significantly faster at system sizes of 16,000 particles and below .",
    "this can probably be explained by the fact that hoomd is a single gpu code , whereas lammps@xmath2 has some overhead due to its multi - gpu capabilities .",
    "the `` gpu '' package of lammps reaches its maximum performance at about 8,000 particles . while it is faster than lammps@xmath2 for smaller systems ( and even faster than hoomd for fewer than 2,000 particles )",
    ", it is significantly slower than lammps@xmath2 and hoomd for this lj system at large system sizes .",
    "the reason is most likely that the `` gpu '' package of lammps only off - loads the pair force calculations and the neighbor list creation to the gpu , while the rest of the calculation ( e.g. communication , time integration , thermostats ) is performed on the cpu .",
    "this requires a lot of data transfers over the pci bus , which reduces overall performance and sets an upper limit on the speed - up . on the other hand , at very low particle counts",
    "the cpu is very efficient at doing these tasks that are less computationally demanding and memory bandwidth limited .",
    "while a gpu has a much higher bandwidth to the device memory than does the cpu to the ram , the whole data set can fit into the cache of the cpu for small system sizes .",
    "so for the smallest system sizes , the cpu can handle these tasks more efficiently than the gpu , leading to the higher performance of the `` gpu '' package for small system sizes .",
    "p0.08p0.45p0.45 &    * lj *    &    * silicate ( cutoff ) *     +    90    &   &   +    90    &   &   +    [ fig : scaling ]    in order to simulate large systems within a reasonable wall clock time , modern md codes allow parallelization over multiple cpus . lammps s spatial decomposition strategy was specifically chosen to enable this parallelization , allowing lammps to run efficiently on modern hpc hardware .",
    "depending on the simulated system , it has been shown to have parallel efficiencies times the number of atoms @xmath34 divided by the wall clock time @xmath17 : @xmath35 .",
    "let @xmath36 denote the atom - steps per second for a single cpu run , and let @xmath37 denote the atom - steps per second for an @xmath38 cpus run .",
    "parallel efficiency , @xmath39 , is then the ratio of @xmath36 to @xmath37 multiplied by @xmath38 : @xmath40 . ] of 70% to 95% for up to several ten thousand cpu cores . to split the work between the available cpus , lammps s spatial decomposition algorithm evenly divides the simulation box into as many sub - boxes as there are processors .",
    "mpi is used for communication between processors . during the run",
    ", each processor packs particle data into buffers for those particles that are within the interaction range of neighboring sub - boxes .",
    "each buffer is sent to the processor associated with each neighboring sub - box , while the corresponding data buffers from other processors are received and unpacked .    while the execution time of most parts of the simulation should in principle scale very well with the number of processors , communication time is a major exception . with an increasing number of processors , the fraction of the total simulation time which is used for inter - processor communication increases .",
    "this is already bad enough for cpu - based codes , where switching from 8 to 128 processors typically doubles or triples the relative portion of communication . but for gpu - based codes , the situation is even worse since the compute - intensive parts of the simulation are executed much faster ( typically by a factor of 20 to 50 times ) .",
    "it is therefore understandable why it is essential to perform as much of the simulation as possible on the gpu .",
    "consider the following example : in a given cpu simulation , 90% of the simulation time is spent on computing particle interaction forces . running only that part of the calculation on the gpu , and assuming a 20-fold speed - up in computing the forces , the overall",
    "speed - up is only a factor of 6.9 .",
    "if we then assume that with an increasing number of processors the fraction of the force calculation time drops to 85% in the cpu version , then the overall speed - up would be only a factor of 5.2 .",
    "on top of the usual parallel efficiency loss of the cpu code , additional parallel efficiency is lost for the gpu - based code if only calculating the pair forces on the gpu .",
    "if one processes the rest of the simulation on the gpu as well , the picture gets somewhat better .",
    "most of the other parts of the simulation are bandwidth bound , i.e. typical speed - ups are around 5 . taking the same numbers as before yields an overall speed - up of 15.4 and 13.8 , respectively .",
    "so if parts of the code that are less optimal for the gpu are also ported , not only will single node performance be better , but the code should also scale much better . while the above numbers are somewhat arbitrary , they illustrate the general trend .    in order to minimize the processing time on the host , as well as minimize the amount of data sent over the pci bus , lammps@xmath2 builds the communication buffers on the gpu .",
    "the buffers are then transferred back to the host and sent to the other processors via mpi . similarly , received data packages",
    "are transferred to the gpu and only opened there .",
    "actual measurements have been performed on ncsa s lincoln cluster , where up to 256 gpus on 128 nodes were used ( see figure [ fig : scaling ] ) .",
    "we compare weak and strong scaling behavior of lammps@xmath2 versus the cpu version of lammps for two systems : lj and silicate ( cutoff ) . in the weak scaling benchmark ,",
    "the number of atoms per node is kept fixed , such that the system size grows with increasing number of nodes . in this way",
    ", the approximate communication - to - calculation ratio should remain fairly constant , and the gpus avoid underutilization issues . in the strong scaling benchmark ,",
    "the total number of atoms is kept fixed regardless of the number of nodes used .",
    "this is done in order to see how much a given fixed - size problem can be accelerated .",
    "note that in figure [ fig : scaling ] , we plot the number of quad - core cpus rather than the number of individual cores .",
    "please also note that in general the lincoln - cluster would not be considered a gpu-``based '' cluster since the number of gpus per node is relatively small and two gpus share a single pcie2.0 8x connection .",
    "this latter issue represents a potential communication bottleneck since there are synchronization points in the code prior to data exchanges .",
    "consequently , both gpus on a node attempt to transfer their buffers at the same time through the same pcie connection . on systems where each of the ( up to four ) gpus of a node has its own dedicated pcie2.0 16x slot",
    ", the required transfer time would be as little as one fourth of the time on lincoln , thus allowing for even better scaling .",
    "since lincoln is not intended for large - scale simulations , it features only a single data rate ( sdr ) infiniband connection with a network bandwidth that can become saturated when running very large simulations .",
    "nevertheless , figure [ fig : scaling ] shows that very good scaling is achieved on lincoln .",
    "there , the number of atom - steps per second ( calculated by multiplying the number of atoms in the system by the number of executed time - steps , and dividing by the total execution time ) is plotted against the number of gpus and quad - core cpus that were used .",
    "we tested two different systems : a standard lennard - jones system ( density 0.84  @xmath41 , cutoff 3.0  @xmath42 ) , and a silicate system that uses the buckingham potential and cutoff coulombic interactions ( density 0.09  @xmath43 , cutoff 15   ) .",
    "while keeping the number of atoms per node constant , the scaling efficiency of lammps@xmath2 is comparable to that of regular cpu - based lammps . even at 256 gpus ( 128 nodes )",
    ", a 65  % scaling efficiency is achieved for the lennard - jones system that includes 500,000 atoms per node . and",
    "a surprising 103  % scaling efficiency is achieved for the silicate system run on 128 gpus ( 64 nodes ) and 34,992 atoms per node .",
    "this means that for the silicate system , 128 gpus achieved more than 65 times as many atom - steps per second than 2 gpus . in this case , a measured parallel efficiency slightly greater than unity is probably due to non - uniformities in the timing statistics caused by other jobs running on lincoln at the same time .",
    "we were also able to run this lennard - jones system with lammps s `` gpu '' package .",
    "as already seen in the single gpu performance , the gpu package is about a factor of three slower than lammps@xmath2 for this system .",
    "the poorer single gpu performance leads to slightly better scaling for lammps s gpu package .    comparing the absolute performance of lammps@xmath2 with lammps at 64 nodes gives a speed - up of 6 for the lennard - jones system and a speed - up of 14.75 for the silicate system . translating that to a comparison of gpus versus single cpu cores means speed - ups of 24 and 59 , respectively .",
    "such larger speed - ups are observed up to approximately 8 nodes ( 16 gpus ) in the strong scaling scenario , where we ran fixed - size problems of 2,048,000 lennard - jones atoms and 139,968 silicate atoms on an increasing number of nodes . with 32 gpus ( 16 nodes )",
    "the number of atoms per gpu gets so small ( 64,000 and 4,374 atoms , respectively ) that the gpus begin to be underutilized , leading to much lower parallel efficiencies ( see figure [ fig : bench_system_size ] ) . at the same time",
    ", the amount of mpi communication grows significantly .",
    "in fact , for the silicate system with its large 15   cutoff , each gpu starts to request not only the positions of atoms in neighboring sub - boxes , but also positions of atoms in next - nearest neighbor sub - boxes .",
    "this explains the sharp drop in parallel efficency seen at 32 gpus . in consequence ,",
    "256 gpus can not simulate the fixed - size silicate system significantly faster than 16 gpus . on the other hand ,",
    "those 16 gpus on 8 nodes are faster than all 1024 cores of 128 nodes when using the regular cpu version of lammps .",
    "we also tested the `` gpu '' package of lammps for strong scaling on the lennard - jones system . for this test ,",
    "its parallel efficency is lower than that of lammps@xmath2 up to 32 gpus . for more than 32 gpus",
    ", the `` gpu '' package shows stronger scaling than lammps@xmath2 .",
    "this can be ascribed to lammps@xmath2 s faster single node computations and subsequently higher communication - to - computation ratio .",
    "( note that each of the versions of lammps discussed here have the same mpi communication costs . ) in lammps@xmath2 , the time for the mpi data transfers actually reaches 50  % of the total runtime when using 256 gpus .",
    "a simple consideration explains why the mpi transfers are a main obstacle for better scaling .",
    "since the actual transfer of data can not be accelerated using gpus , it constitutes the same absolute overhead as with the cpu version lammps . considering that the rest of the code runs 15 to 60 times faster on a process - by - process basis",
    ", it is obvious that if 1  % to 5  % of the total time is spent on mpi transfers in the cpu lammps code , communication can become the dominating time factor when using the same number of gpus with lammps@xmath2 .    ) ; hardware : lincoln ( see appendix [ sec : app_hardware]),scaledwidth=45.0% ]    that the mpi transfer time is indeed the main cause of the poor weak scaling performance can be shown by profiling the code .",
    "figure [ fig : bench_mpi ] shows the total simulation time of the lennard - jones system versus the number of gpus used .",
    "it is broken down into the time needed for the pair force calculation , a lower estimate of the mpi transfer times and the rest .",
    "the lower estimate of the mpi transfer time does not include any gpu@xmath44host communication .",
    "it only consists of the time needed to perform the mpi send and receive operations while updating the positions of atoms residing in neighboring sub - boxes . all other mpi communication",
    "is included in the `` other '' time .",
    "clearly , almost all of the increase in the total time needed per simulation step can be attributed to the increase in the mpi communication time .",
    "furthermore at 64 gpus a sharp increase in the mpi communication time is observed .",
    "we presume that this can be attributed to the limited total network bandwidth of the single data rate infiniband installed in lincoln . considering the relatively modest communication requirements of an md simulation ( at least for this simple lennard - jones system ) ,",
    "this finding illustrates how important high throughput network connections are for gpu clusters . in order to somewhat mitigate this problem ,",
    "we have started to implement lammps@xmath2 modifications that will allow a partial overlap of force calculations and communication .",
    "preliminary results suggest that up to three quarters of the mpi communication time can be effectively hidden by that approach .    ) ; hardware : lincoln ( see appendix [ sec : app_hardware]),scaledwidth=45.0% ]    as a further example of what is possible with lammps@xmath2 , we performed another large - scale simulation . using 288 gpus on lincoln",
    ", we ran a one billion particle lennard - jones system ( density : 0.844 , cutoff : 2.5  @xmath45 ) .",
    "this simulation requires about 1  tb of aggregate device memory . to the best of our knowledge ,",
    "this is the largest md simulation run on gpus to date . in figure",
    "[ fig : bench_billion ] loop times for 100 time - steps are shown for lincoln , red storm ( a cray xt3 machine with 10368 processors sited at sandia national laboratories ) , and bluegene / l ( a machine with 65536 processor sited at lawrence livermore national laboratory ) .",
    "the data for the latter two machines was taken from the lammps homepage ( http://lammps.sandia.gov/bench.html ) . using 288 gpus , lincoln required 28.7  s to run this benchmark , landing between red storm using 10,000 processors ( 25.1  s ) and the bluegene / l machine using 32k processors ( 30.2  s ) .",
    "in this paper we have presented our own implementation of a general purpose gpu - md code that we call lammps@xmath2 .",
    "this code already supports 26 different force field types .",
    "we discussed multiple approaches for performing pair force calculations and concluded that an adaptive neighbor - list - based approach yields the best results .",
    "specifically , we have shown that the cell list approach is generally slower .",
    "if running on a quad - core workstation with a single gpu , users can expect a 5x to 14x reduction in time - to - solution by harnessing the gpu , depending on the simulated system class ( i.e. biomolecular , polymeric , granular , metallic , semiconductor ) . with a strong focus on scalability , lammps@xmath2 can efficiently use the upcoming generation of gpu - based hybrid clusters , such as tianhe-1a , nebulae and tsubame 2.0 ( the first , third , and fourth fastest supercomputers on the november 2010 top500 list ) . by performing scaling benchmarks on up to 256 gpus",
    ", lammps@xmath2 was shown to achieve general speed - ups of 20x to 60x using the latest generation of c1060s versus modern cpu cores , again depending on the simulated system class .",
    "these numbers imply that using lammps@xmath2 on a 32 node system with 4 gpus per node can achieve the same overall speed as the original cpu version of lammps on a conventional cpu - based cluster with 1024 nodes .",
    "this work was partially supported by the national center for supercomputing applications by providing access to the lincoln gpu cluster .",
    "sandia national laboratories is a multi - program laboratory managed and operated by sandia corporation , a wholly owned subsidiary of lockheed martin corporation , for the u.s .",
    "department of energys national nuclear security administration under contract de - ac04 - 94al85000 .",
    "* * lj*. potential : lennard - jones ( lj / cut ) , cutoff : 2.5  @xmath42 , density : 0.84  @xmath46 , temperature : 1.6 . * * silicate ( cutoff)*. potential : buckingham + coulomb ( buck / coul / cut ) , cutoff : 15.0   , density : 0.09  @xmath43 , temperature : 600  k. * * silicate*. potential : buckingham + coulomb ( buck / coul / long ) , atoms : 11,664 , cutoff : 10.0  , density : 0.09  @xmath43 , long range coulomb solver : pppm ( precision : 2.4e-6 ) , temperature : 600  k. * * eam*. potential : embedded atom method ( eam)@xcite , atoms : 256,000 , cutoff : 4.95   , density : 0.0847  @xmath43 , temperature : 800  k. * * coarse grained*. potential : coarse grained systems ( cg - cmm)@xcite , atoms : 160,560 , cutoff : 15.0   , temperature : 300  k. * * rhodopsin*. potential : charmm force field + coulomb ( lj / charmm / coul / long)@xcite , atoms : 32,000 , cutoff : 10.0   , long range coulomb solver : pppm ( precision : 1e-7 ) , temperature : 300  k. * * granular*. potential : granular force field ( gran / hooke)@xcite , atoms : 1,152,000 , density : 1.07  @xmath46 , temperature : 19 .",
    "* workstation server a ( ws@xmath16 ) intel q9550 @ 2.8ghz 8 gb ddr2 ram @ 800 mhz mainboard : evga 780i 3xpcie2.0 16x 2 x nvidia gtx 280 centos 5.4 * workstation server b ( ws@xmath33 ) intel i7 950 @ 3.0ghz 24 gb ddr3 ram @ 1066 mhz mainboard : asus p6x58d - e 3xpcie2.0 16x 2 x nvidia gtx 470 centos 5.5 * gpu cluster ( cl ) 2 x intel x5550 @ 2.66ghz 48 gb ddr3 ram @ 1066 mhz mainboard : supermicro x8dtg - qf r 1.0a 4xpcie2.0 16x 4 x nvidia tesla c1060 scientific linux 5.4 * ncsa lincoln ( lincoln ) 192 nodes 2 x intel x5300 @ 2.33ghz 16 gb ddr2 ram 2 x nvidia tesla c1060 on one pcie2.0 8x ( two nodes share one s1070 ) sdr infiniband red hat enterprise 4.8",
    "in this section , we make use of the defintions from [ sec : comp_neigh_cell ] , e.g. @xmath17 is the time for processing a single interaction and the fraction @xmath47 $ ] of the time is assumed to be spent on memory accesses , i.e. : @xmath48 while the actual force calculation for one interaction is the same for both approaches , the time for memory access varies : it is assumed to be a factor @xmath26 faster for the cell list approach , due to the",
    "_ coalesced accesses_.    the cell list will read @xmath49 neighbor cells and thus @xmath50 , while the neighbor list method will read @xmath51 atoms .",
    "we assume a homogeneous density and thus the same proportionality factor @xmath52 for both @xmath9 , i.e. ( @xmath21 ) : @xmath53      a.   if _ all _ of the pair force time is used for memory accesses ( @xmath55 ) , then @xmath26 has to be at least 3.3 .",
    "b.   if the memory accesses of the cell list approach take no time at all ( @xmath56 ) , then @xmath28 must still be @xmath57%",
    ".    22 s. plimpton , j comp .",
    "phys . * 117 * , 1 - 19 ( 1995 ) .",
    "top500 supercomputing sites , http://www.top500.org/lists/2010/11 j.a .",
    "anderson , c.d .",
    "lorenz , and a.  travesset , j. comp . phys .",
    "* 227 * , 5342 - 5359 ( 2008 ) .",
    "m. harvey , g. giupponi , and g. de fabritiis , j. chem .",
    "theory and comput . * 5 * , 1632 ( 2009 ) .",
    "phillips , r.  braun , w.  wang , j.  gumbart , e.  tajkhorshid , e.  villa , c.  chipot , r.d .",
    "skeel , l.  kale , and k.  schulten .",
    "j. comp . chem . * 26 * , 1781 - 1802 ( 2005 ) .",
    "http://www.ks.uiuc.edu/research/namd/ d.a .",
    "case , t.e .",
    "cheatham , iii , t.  darden , h.  gohlke , r. luo , k.m .",
    "merz , jr .",
    ", a.  onufriev , c.  simmerling , b.  wang and r.  woods . j. computat . chem . * 26 * , 1668 - 1688 ( 2005 ) . w.m .",
    "brown , p.  wang , s.j .",
    "plimpton , and a.n .",
    "tharrington , comp .",
    "comm . * 182 * , 898 - 911 ( 2011 ) .",
    "programming guide for cuda toolkit 3.1.1 http://developer.download.nvidia.com/ compute / cuda/3_1/toolkit / docs/ nvidia_cuda_c_programmingguide_3.1.pdf j.a .",
    "van meel , a.  arnold , d.  frenkel , portegies , r.g .",
    "belleman . molecular simulation ,",
    "3 . ( 2008 ) , pp . 259 - 266 .",
    "lars  winterfeld , accelerating the molecular dynamics program lammps using graphics cards processors and the nvidia cuda technology http://db-thueringen.de/ servlets / documentservlet?id=16406 daw , baskes , phys .",
    "lett . , * 50 * , 1285 ( 1983 ) .",
    "daw , baskes , phys .",
    "b , * 29 * , 6443 ( 1984 ) . shinoda , devane , klein , mol .",
    ", * 33 * , 27 ( 2007 ) .",
    "shinoda , devane , klein , soft matter , * 4 * , 2453 - 2462 ( 2008 ) .",
    "mackerell , bashford , bellott , dunbrack , evanseck , field , fischer , gao , guo , ha , _",
    "_ , j. phys .",
    "chem.,*102 * , 3586 ( 1998 ) .",
    "brilliantov , spahn , hertzsch , poschel , phys .",
    "e , * 53 * , 5382 - 5392 ( 1996 ) .",
    "silbert , ertas , grest , halsey , levine , plimpton , phys .",
    "e , * 64 * , 051302 ( 2001 ) .",
    "zhang and makse , phys .",
    "e , * 72 * , 011301 ( 2005 ) ."
  ],
  "abstract_text": [
    "<S> we present a gpu implementation of lammps , a widely - used parallel molecular dynamics ( md ) software package , and show 5x to 13x single node speedups versus the cpu - only version of lammps . </S>",
    "<S> this new cuda package for lammps also enables multi - gpu simulation on hybrid heterogeneous clusters , using mpi for inter - node communication , cuda kernels on the gpu for all methods working with particle data , and standard lammps c++ code for cpu execution . cell and neighbor list approaches </S>",
    "<S> are compared for best performance on gpus , with thread - per - atom and block - per - atom neighbor list variants showing best performance at low and high neighbor counts , respectively . </S>",
    "<S> computational performance results of gpu - enabled lammps are presented for a variety of materials classes ( e.g. biomolecules , polymers , metals , semiconductors ) , along with a speed comparison versus other available gpu - enabled md software . </S>",
    "<S> finally , we show strong and weak scaling performance on a cpu / gpu cluster using up to 128 dual gpu nodes . </S>"
  ]
}