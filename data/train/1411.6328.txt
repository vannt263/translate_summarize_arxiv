{
  "article_text": [
    "mds ( maximum distance separable ) codes are optimal error - correcting codes in the sense that they have the largest minimum distance for a given number of parity symbols . if each symbol is a vector or a column , we call such a code an mds array code ( e.g. @xcite ) . in ( distributed ) storage systems ,",
    "each column is usually stored in a different disk , and mds array codes are widely used to protect data against erasures due to their error correction ability and low computational complexity . in this paper , we call each symbol a column or a node , and the column length , or the vector size of a symbol , is denoted by @xmath2 .",
    "if an mds code has @xmath0 parities , then it can correct up to @xmath0 erasures of entire columns . in this paper ,",
    "we not only would like to recover the erasures , but also care about the efficiency in recovery : what is the fraction of the remaining data transmitted in order to correct the erasures ?",
    "we call this fraction the _ repair bandwidth ( fraction)_. for example , if @xmath0 erasures happen , it is obvious that we have to transmit all of the remaining information , therefore , the fraction is @xmath4 . for a single erasure",
    "it was shown in @xcite ( which also formulated the repair problem ) that this fraction is actually lower bounded by @xmath1 . in the general case ,",
    "it was shown in @xcite that when @xmath5 nodes are erased , then the repair bandwidth is lower bounded by @xmath6 .",
    "since the repair of information is much more crucial than redundancy , and we study mainly high - rate codes , we will focus on the optimal repair of information or systematic nodes .",
    "moreover , since single erasure is the most common scenario in practice , we assume @xmath7 . thus , in this paper a code is said to have an optimal repair if this bound of @xmath1 is achieved for the repair of _ any _ of its systematic nodes .",
    "for example , in figure [ fig1 ] , we show an mds code with @xmath8 systematic nodes , @xmath9 parity nodes , and column length @xmath10 .",
    "one can check that this code can correct any two erasures , therefore it is an mds code . in order to repair any systematic node , only @xmath11 fraction of the remaining information",
    "is transmitted .",
    "thus this code has optimal repair .    [",
    "cols=\"^,^,^,^,^,^\",options=\"header \" , ]        & @xmath12 & @xmath13 & @xmath14 & @xmath15 & @xmath14 & @xmath15 & @xmath14 & @xmath15 + & @xmath16 & @xmath17 & @xmath12 & @xmath13 & @xmath16 & @xmath17 & @xmath16 & @xmath17 + & @xmath18 & @xmath19 & @xmath18 & @xmath19 & @xmath12 & @xmath13 & @xmath18 & @xmath19 + repairing subspace & @xmath14 & @xmath15 & @xmath16 & @xmath17 & @xmath18 & @xmath19 & @xmath12 & @xmath13 +    the following theorem shows that the code indeed has optimal repair bandwidth @xmath1 .",
    "[ thm2 ] construction [ cnstr2 ] has optimal repair bandwidth @xmath1 when repairing one systematic node .    for distinct integers",
    "@xmath20 $ ] for @xmath21 $ ] and @xmath22 $ ] we will show that is satisfied , namely @xmath23    * case @xmath24 : it is easy to verify that the @xmath0 eigenspaces @xmath25 of @xmath26 satisfy @xmath27 notice that is usually _ not _ correct for arbitrary subspaces @xmath25 that satisfy @xmath28 . by definition @xmath29 , then @xmath30 * case @xmath31 , and @xmath32 : by the construction , the eigenspaces of @xmath33 are @xmath34 . since @xmath32 then @xmath35 , and @xmath36 * case @xmath31 , and @xmath37 : in this case we will only prove the case where @xmath38 .",
    "the rest of the cases are proved similarly .",
    "denote by @xmath39 , then by we need to show that @xmath40 denote the distinct eigenvalues of @xmath41 by @xmath42 . for a vector @xmath43 or equivalently",
    "an integer @xmath44 $ ] , denote by @xmath45 the vector that is the same as @xmath46 except the @xmath47-th entry , which is @xmath48 .",
    "notice that @xmath49\\}$ ] and @xmath50 writing the equations for all @xmath51 $ ] in a matrix , we get @xmath52 with @xmath53 after a sequence of elementary column operations , @xmath54 becomes the following vandermonde matrix @xmath55 since @xmath56 s are distinct , we know @xmath57 and hence @xmath54 is non - singular .",
    "therefore , @xmath58 @xmath59 . since @xmath60 contains @xmath61 for all @xmath0-ary vector @xmath46 , we know @xmath62 .",
    "we discuss the update and access complexity of our code in this subsection .",
    "first we make some observations .    1 .",
    "the code restricted to the systematic nodes @xmath63 , u = r$ ] is equivalent to that of @xcite . since the encoding matrices @xmath64",
    ", are all diagonal , every information entry appears exactly once in each of the two parities , and therefore it appears @xmath65 times in the code ( once in each of the parities and once in its systematic node ) .",
    "clearly this is the minimum possible , since the code is an mds .",
    "as mentioned in the introduction , this is an _ optimal - update _ code . in @xcite",
    "it was proven that an optimal - update code with diagonal encoding matrices has no more than @xmath66 systematic nodes .",
    "but we will show an optimal - update construction in the next section with @xmath67 systematic nodes but non - diagonal encoding matrices .",
    "2 .   shortening the code to contain only the @xmath68 systematic nodes @xmath63,u \\in [ 0,r-1]$ ] will result a code @xmath69 that is actually equivalent to the code in @xcite .",
    "we assume here that @xmath70\\}$ ] are standard basis .",
    "namely , each repairing subspace @xmath71 can be represented by an @xmath72 matrix , such that each row has exactly one nonzero entry .",
    "therefore when repairing a node , only @xmath73 symbols from each surviving node are being read and transmitted to the repair center , with no need of any computations within the surviving node ( e.g. figure [ fig2 ] ) .",
    "such a code is termed to have _",
    "optimal access_. it was shown in @xcite that a code with optimal access has at most @xmath67 nodes , therefore this construction is optimal . namely it is a code with optimal access and maximum possible number of systematic nodes .",
    "we conclude that the code construction is a combination of the longest optimal - access code and the longest optimal - update code ( with diagonal encoding matrices ) , which provides an interesting tradeoff among access , update , and the code length .",
    "in other words , we can achieve a larger number of nodes if we are willing to sacrifice the optimal - access and/or optimal - update properties .",
    "the shortening technique was also used in @xcite@xcite in order to get optimal - repair code with different code rates .",
    "clearly , the optimal - access property is highly desirable in a code .",
    "therefore one might ask what is the longest code ( in terms of @xmath74 ) , that has the maximum number of nodes that can be repaired with optimal access .",
    "in particular let us consider codes with 2 parities . if we try to extend the optimal - access code @xmath69 with @xmath67 systematic nodes to an optimal repair code @xmath75 with @xmath74 systematic nodes , then @xmath76 , as the following theorem suggests .",
    "therefore , our construction is longest in the sense of extending @xmath69 . before proving the theorem we will need the following lemma .",
    "* lemma 8) the repairing subspaces @xmath60 of an optimal repair @xmath77 code satisfy that for any subset of indices @xmath78 $ ] @xmath79 [ good lemma ]    [ thm3 ] any extension of an optimal access code with @xmath67 systematic nodes to an optimal repair code , will have no more than @xmath80 systematic nodes , for @xmath9 parities .",
    "let @xmath69 be an optimal - access code of length @xmath67 with 2 parities .",
    "let @xmath75 be an extended code of @xmath69 . by equivalently transforming the encoding matrices ( see @xcite )",
    ", we can always assume the encoding matrices of the parities in @xmath75 are @xmath81    here the first @xmath67 column blocks correspond to the encoding matrices of @xmath69 .",
    "first consider the code @xmath69 , that is the first @xmath67 nodes .",
    "if @xmath69 has optimal access , then each repairing subspace is spanned by @xmath73 standard basis vectors .",
    "since @xmath69 contains @xmath67 systematic nodes , on average each standard basis vector appears in @xmath82 repairing subspaces . for each @xmath83",
    "let @xmath84 $ ] be the subset of indices of the repairing subspaces that contain the vector @xmath85 .",
    "we claim that each standard basis vector appears exactly @xmath66 times , namely for each @xmath47 the size of @xmath86 is @xmath66 .",
    "assume to the contrary that @xmath87 for some @xmath47 .",
    "by lemma [ good lemma ] @xmath88 and we get a contradiction . moreover , if there exists @xmath86 of size less than @xmath66 , then by a simple counting argument we get that there exists an @xmath89 of size greater than @xmath66 , which can not happen . hence , we conclude that for each @xmath47 the size of @xmath86 is exactly @xmath66 and , @xmath90 now consider a systematic node @xmath91 $ ] that was added to the code @xmath69 . since @xmath75 is an optimal repair code , each repairing subspace of the nodes in @xmath69 is an invariant subspace of @xmath92 . since the intersection of invariant subspaces is again an invariant subspace we get that for any @xmath83 @xmath93 is an invariant subspace of @xmath92 .",
    "namely , each standard basis vector is an eigenvector of @xmath92 , and therefore @xmath92 is a diagonal matrix .",
    "we conclude that restricting the code @xmath75 to its last @xmath94 systematic nodes will yield to an optimal update code .",
    "by @xcite[theorem @xmath95 , there are only @xmath66 nodes that are all optimal update , hence @xmath96 .",
    "next we will show that the code can be made to be mds over a large finite field .",
    "[ thm5 ] the code can be made an mds over a field large enough .",
    "assign arbitrarily @xmath0 distinct nonzero eigenvalues to each matrix @xmath97 . recall that the encoding matrices are defined as @xmath98 , therefore each one of them is invertible .",
    "we multiply each encoding matrix @xmath99 by a specific variable @xmath100 , to get a new code defined by the matrix @xmath101.\\ ] ] clearly the new code is mds iff any @xmath102 block submatrix in is invertible , for any @xmath103 $ ] . define the multivariate polynomial @xmath104 in the variables @xmath105 , which is the product of the determinants of all the @xmath102 block submatrices , for any @xmath106 . hence",
    ", the code can be made to be mds if there is an assignment to the variables that does not evaluate @xmath104 to zero .",
    "let @xmath107 be the vector of the variables .",
    "for a vector of integers @xmath108 we define @xmath109 .",
    "furthermore , define the usual ordering on the terms @xmath110 according to the lexicographic order , i.e. , @xmath111 iff @xmath112 according to the lexicographic order .",
    "the leading coefficient of a multivariate polynomial , is the coefficient of the maximal nonzero term .",
    "for example , the leading coefficient of the polynomial @xmath113 is @xmath114 .",
    "let @xmath115 and @xmath116 be two sets of indices of size @xmath117 in @xmath118 $ ] and @xmath119 $ ] respectively .",
    "define @xmath120 to be the determinant of the submatrix restricted to row blocks @xmath46 and column blocks @xmath121 .",
    "it is easy to see that its leading coefficient is @xmath122 which is non zero , since by construction , each of matrices is invertible .",
    "moreover if @xmath123 are the determinant of different submatrices , then the leading coefficient of their product @xmath124 , is the product of their leading coefficients .",
    "since both of them are non zero , so is the product .",
    "@xmath104 is a product of such polynomials @xmath125 , therefore also its leading coefficient is non zero .",
    "moreover , each @xmath125 is an homogeneous polynomial , hence so is @xmath104 .",
    "we conclude that @xmath104 has a nonzero term @xmath110 ( its leading coefficient ) of degree equal to @xmath126 . by the combinatorial nullstellensatz",
    "@xcite we get that a field of size greater than @xmath127 will suffice .    for the case of 2 parities , we can explicitly specify the finite field size .",
    "the following construction defines uniquely the encoding matrices , by defining their eigenvalues .",
    "this assignment of the eigenvalues guarantees the mds property of the optimal repair code .",
    "[ construction 2 ] let @xmath128,j=0,1}$ ] be an arbitrary @xmath67 distinct non zero elements of the field @xmath129 , @xmath130 .",
    "assign arbitrarily to each eigenspace of the matrix @xmath131 , the eigenvalue @xmath132 or @xmath133 , as long as each @xmath134 correspond to distinct eigenvalues in the two matrices it appears as an eigenspace , @xmath135 .",
    "for example , we can assign eigenvalues in the following way : @xmath136 take the case of @xmath137 in figure [ fig2 ] , we can use finite field @xmath138 and assign the eigenvalues to be @xmath139 @xmath140    remark : if we have an extra systematic column with @xmath141 ( see column @xmath142 in figure [ fig1 ] ) , we can use a field of size @xmath143 and simply modify the above construction such that all @xmath144 , for @xmath145 , j=0,1 $ ] . for example , when @xmath146 , the coefficients in figure [ fig1 ] are assigned using the above algorithm , where the field size is @xmath8 .",
    "there is an optimal repair @xmath147 mds code if the finite field size is at least @xmath148 .",
    "we will show that construction [ construction 2 ] satisfies the mds property , namely , any two erasures can be repaired .",
    "this is equivalent to that ( i ) all the encoding matrices @xmath149 s are invertible , and ( ii ) any @xmath150 block sub matrix @xmath151\\ ] ] is invertible , for any distinct @xmath152 $ ] .",
    "since the eigenvalues are nonzero the first condition is satisfied .",
    "the second condition is equivalent to that @xmath153 is invertible .",
    "let @xmath154 , with @xmath155 , u , v \\in \\{0,1,2\\}$ ] .",
    "* case @xmath156 : let the eigenspaces of @xmath157 be @xmath158 and @xmath159 respectively , which correspond to eigenvalues @xmath160 , and @xmath161 .",
    "clearly @xmath162 it is easy to check that @xmath163 assume to the contrary that there exists a non zero vector @xmath46 such that @xmath164 where @xmath165 then , @xmath166 since @xmath46 is non zero , at least one of the @xmath167 s is non zero .",
    "hence , @xmath168 and we get a contradiction since the eigenvalues of @xmath131 , and @xmath169 are distinct . * case @xmath170 and @xmath171 : since @xmath170 the matrices @xmath131 and @xmath172 share a common eigenspace from the set of subspaces @xmath173 .",
    "denote by @xmath174 and @xmath175 the eigenspaces of @xmath131 , @xmath172 .",
    "denote by @xmath176 the eigenvalues that correspond to the eigenspace of @xmath177 in the matrices @xmath178 respectively . by construction , @xmath179 , and",
    "therefore by construction @xmath180 is an eigenspace of @xmath131 with an eigenvalue @xmath181 , and @xmath182 is an eigenspace of @xmath172 with an eigenvalue @xmath183 .",
    "assume that @xmath184 for some non zero vector @xmath185 where @xmath186 , @xmath187 , and @xmath188 then @xmath189 using we conclude that @xmath190 which is a contradiction",
    ".    one can observe that the proposed code construction has parameters @xmath147 , and a field size that scales linearly with the number of systematic nodes . on the other hand ,",
    "the @xmath191 code in @xcite requires only a field of size @xmath192 .",
    "thus , the proposed code can protect more systematic nodes , but has longer ( actual ) column length .",
    "the actual size of each column is longer since it has to store @xmath193 symbols of a _",
    "larger _ field .",
    "nonetheless , it may be possible to alter the structure of the encoding matrices a bit ( for example , relaxing the requirement that each of the encoding matrix is diagonalizable ) , and obtain a constant field size .",
    "this remains as a future research direction .",
    "in storage systems that use coding to combat failures , each parity symbol is a function of a subset of information symbols .",
    "therefore , when an information symbol updates its value , also the parity symbols that are function of it , need to be updated .",
    "since update is one of the most frequent operation in the system , one would like to minimize the amount of symbols update incurred by one information symbol update . in an mds code",
    "each parity node is a function of the _ entire _ information symbols , hence at least one parity symbol needs to be updated in any information symbol update .",
    "an optimal update mds code attains this lower bound , namely each parity node updates exactly one of its symbols for each information symbol update .",
    "it is easy to see that in an optimal update _ linear _ code , each encoding matrix is a generalized permutation matrix , i.e. there is exactly one nonzero entry in each row and each column .    in @xcite diagonal encoding matrices , which are a special case of generalized permutation matrices ,",
    "were considered .",
    "they showed that an optimal bandwidth mds code with @xmath114 parities , and diagonal encoding matrices , has at most @xmath194 systematic nodes . in this section",
    "we will show that one can improve that by not restricting to diagonal encoding matrices .",
    "more precisely , we will construct on optimal update code with @xmath195 systematic nodes .",
    "let @xmath196 for some integer @xmath66 , and define for any @xmath197 the following four subspaces of @xmath198 of dimension @xmath73 : @xmath199 where @xmath200 and @xmath201 are non zero elements of the field that satisfy @xmath202 in the following we will also use letters @xmath203 as superscripts for the encoding matrices .",
    "[ cnstr3 ] construct the @xmath204 code over @xmath205 by the following @xmath67 encoding matrices @xmath206 and @xmath207 .",
    "* define the matrix @xmath208 to have eigenspaces @xmath209 that correspond to eigenvalues @xmath210 respectively . *",
    "define the matrix @xmath64 to have eigenspaces @xmath211 that correspond to distinct non zero eigenvalues @xmath212 respectively .",
    "moreover , let the repairing subspace that correspond to the matrix @xmath213 be @xmath214 .",
    "e.g. , when @xmath146 , we get a @xmath215 with @xmath114 encoding matrices represented with respect to the standard basis @xmath216 ,    a_1^p \\left[\\begin{array}{cc }   & x^2\\\\ y^2 &   \\end{array } \\right].\\ ] ] and repairing subspaces @xmath217 when @xmath137 , the encoding matrices are @xmath218 , a_2^q=\\left[\\begin{array}{cccc } \\lambda & & & \\\\    & \\mu & & \\\\    & & \\lambda & \\\\    & & & \\mu \\end{array } \\right ] , a_1^p=\\left[\\begin{array}{cccc }   & & x^2 & \\\\    &   & & x^2\\\\ y^2   & &   & \\\\    & y^2 & &   \\end{array } \\right ] , a_2^p=\\left[\\begin{array}{cccc }   & x^2 & & \\\\",
    "y^2 &   & & \\\\    & &   & x^2\\\\    & & y^2 &   \\end{array } \\right].\\ ] ] the repairing subspaces are @xmath219 , \\left[\\begin{array}{cccc } y & x &   & \\\\    &   & y & x \\end{array } \\right ] , \\left[\\begin{array}{cccc } 1 & &   0&0 \\\\    & 1 & 0&0   \\end{array } \\right ] , \\left[\\begin{array}{cccc } 1 & 0 &   & \\\\    &   & 1 & 0 \\end{array } \\right].\\ ] ] in both cases it is not difficult to check that the subspace property is satisfied , hence the code has optimal bandwidth . and",
    "since the encoding matrices are permutation matrices , the code has optimal update .",
    "construction [ cnstr3 ] has optimal bandwidth and optimal update .",
    "it is easy to see that the encoding matrices are all permutation matrices , so the code has optimal update .",
    "we need to show the subspace property , namely for @xmath220 $ ] and @xmath221 @xmath222    * case @xmath223 : one can check that for @xmath224 , @xmath225 therefore the proof is the same as in theorem [ thm2 ] .",
    "* case @xmath226 : in this case @xmath227 is an eigenspace of @xmath213 , and the result follows . * case @xmath228 : assume that @xmath229 , and we will show that the transformation @xmath208 maps the subspace @xmath230 to the subspace @xmath231 , and since @xmath232 the result will follow .",
    "let @xmath233 and @xmath121 be the integer that is identical to @xmath46 except on the @xmath47-th digit . then @xmath234a_i^p \\\\        & = & \\frac{xy}{2y } ( ye_a + xe_b)- \\frac{-xy}{2y}(-ye_a+xe_b ) \\\\        & = & x^2 e_b\\in r_i .",
    "\\end{aligned}\\ ] ] when @xmath235 the result follows by the same reasoning .",
    "similar to theorem [ thm5 ] it is clear that the code can be mds over a large enough finite field . to summarize the result of this section",
    ", we gave a construction that doubled the number of systematic nodes compared to the bound in @xcite .",
    "the reason for the violation of this bound is by not restricting to diagonal encoding matrices .",
    "repairing a failed node is a computationally heavy task , that requires large amount of the system s resources .",
    "therefore , optimizing the repair algorithm is of high importance .",
    "one way to optimize is by reducing the amount of symbols needed to be accessed and read during the repair process .",
    "this parameter is quantified by the _ access ratio _ of the system . in this section",
    "we will use explicit linear transformations performed on the code in construction [ cnstr2 ] that yields to an equivalent code with a lower access ratio during a repair process .",
    "furthermore , these transformations maintain the other properties of the code , namely the mds and the optimal repair properties .",
    "formally , given an @xmath236 code @xmath237 , let @xmath238 denote the number of symbols ( or entries ) accessed in the surviving nodes during the repair of systematic node @xmath47 .",
    "the _ access ratio _ is defined as @xmath239 note that @xmath240 is the amount of surviving symbols in the system in the event of one node erasure , hence @xmath241 is the average fraction of the number of symbols in the system being accessed during a repair process .",
    "the @xmath242 code in construction [ cnstr2 ] has @xmath243 systematic nodes , where @xmath68 of them are repaired with optimal access , i.e. , only @xmath244 symbols are accessed from each node during the repair process .",
    "thus , repairing these nodes costs accessing @xmath245 symbols .",
    "however , repairing any of the rest @xmath66 systematic nodes , one has to access _ all _ the surviving symbols in the system .",
    "notice that , although the repair is optimal , in order to generate the transmitted data one has to access the entire information in the node . repairing these nodes costs accessing @xmath246 symbols , and",
    "the access ratio of the code is @xmath247 this value of the access ratio @xmath248 is our benchmark .",
    "we will show that with an appropriate selection of linear transformation , the value of access ratio @xmath241 can be reduced .",
    "but first we define how to apply linear transformation on the code to receive an equivalent code .",
    "moreover we will show that these linear transformations preserve the `` nice '' properties of our code .",
    "let @xmath249,j\\in [ k]}$ ] be the encoding matrix of an @xmath250 optimal repair mds code , with repairing subspaces @xmath251 we will apply a linear transformation on the code by multiplying on the right the encoding matrix @xmath41 by a block diagonal matrix @xmath252 , to get the encoding matrix @xmath253 as follows , @xmath254= ab = \\left [ \\begin{array}{ccc } a_{2,1 }   & \\cdots & a_{2,k } \\\\ \\vdots & \\ddots &   \\vdots\\\\ a_{r,1 } & \\cdots & a_{r , k } \\end{array } \\right ] \\left [ \\begin{array}{ccc } b_1 & & \\\\ & \\ddots & \\\\ & & b_k \\end{array } \\right].\\end{aligned}\\ ] ] namely , for @xmath255 , j \\in [ k]$ ] @xmath256 where @xmath257 is an invertible matrix of size @xmath258 .",
    "after applying the linear transforation @xmath252 on the encoding matrix , the repairing subspaces should be changed accordingly . recall that @xmath259 is the repairing subspace for surviving node @xmath260 during the repair of node @xmath47 .",
    "define the new repairing subspaces as follows : @xmath261,\\\\    s_i , & j \\in [ k+1,k+r ] .",
    "\\end{cases}\\ ] ] notice that compared to the original code , the repairing subspaces are changed only for the systematic nodes .",
    "consider the linear transformation defined by applied on an optimal - bandwidth mds code , then the resulting code is an optimal - bandwidth mds code , with repairing subspaces @xmath259 .    since the code defined by the encoding matrix @xmath41 is optimal bandwidth , then by the subspace property for any distinct @xmath262 $ ] , and @xmath263 $ ]",
    ", @xmath264 therefore , @xmath265 and is satisfied .",
    "moreover , the sum of subspaces satisfies @xmath266 therefore @xmath267 therefore is satisfied , and the equivalent code @xmath253 has optimal bandwidth .",
    "it is easy to check that if @xmath41 is an mds code , then also @xmath253 , and the result follows .",
    "now let us find a code such that the number of accesses will be decreased .",
    "we say node @xmath260 has optimal access during the repair of node @xmath47 , if only @xmath244 symbols are to be accessed in node @xmath260 during the repair on node @xmath47 .",
    "this is equivalent to the following * optimal - access condition : * @xmath268 can be written as a matrix with only @xmath244 non - zero columns .",
    "so we need to look for proper @xmath257 s such that this condition is satisfied by as many pairs @xmath269 as possible .",
    "let @xmath270 be the matrix of the left eigenspaces of the encoding matrix @xmath92 in construction [ cnstr2 ] , and we call it _",
    "eigenspace matrix_. when @xmath271 , for @xmath272 , y \\in [ m]$ ] , we have @xmath273 where @xmath274 are defined as in . here",
    "we view each @xmath274 as @xmath244 of vectors instead of a subspace .",
    "for example , for the code in figure [ fig2 ] if @xmath275 and consider standard basis @xmath276 then @xmath277 define the matrix of transformation as @xmath278 which is the inverse of the eigenspace matrix .    the access ratio of the @xmath279 code using is @xmath280    suppose node @xmath281 is erased . from node @xmath271 , @xmath282 ,",
    "by we need to send the following subspace : @xmath283 here @xmath284 is defined as @xmath285 as in construction [ cnstr2 ] , and @xmath286 is defined in .",
    "we are going to show that in a lot of cases @xmath60 can be rewritten as the product of a matrix @xmath54 and the eigenspace matrix @xmath270 : @xmath287 where @xmath54 is of size @xmath288 and contains only @xmath244 non - zero columns .",
    "this will lead to @xmath289 and therefore the code will have optimal access for the pair @xmath290 .    * case @xmath291 , @xmath292 .",
    "apparently , @xmath293 is one of the eigenspaces in @xmath270 and is satisfied . * case @xmath294 , @xmath295 . we have observed in that the subspaces satisfy @xmath296 , where @xmath297 are all the eigenspaces of @xmath92 .",
    "moreover , each @xmath298 only contains linear combinations of @xmath299 vectors in @xmath300 . hence holds . * case @xmath294 , @xmath301 .",
    "we need to access all remaining elements .",
    "recall the code length is @xmath302 .",
    "hence for each systematic node @xmath47 as a survived node , it has optimal access for @xmath303 erased nodes ( the first two cases ) , and accesses all elements for @xmath304 erased nodes ( the last case ) .",
    "for each parity node as a survived node , it has optimal access for @xmath68 erased nodes ( @xmath305 $ ] ) , and accesses all elements for @xmath66 erased nodes ( @xmath306 $ ] ) , because the repairing subspaces are still @xmath60 for parity nodes .",
    "therefore , the access ratio is @xmath307 hence the proof is completed .",
    "we note here that this transformation lowers the access ratio compared to the original code , but in the mean time increases the average updates for each systematic element .",
    "according to different system requirements , one can choose one code over another .",
    "the transformation in this section provides a general method to trade updates for access .",
    "given any optimal - bandwidth code , one can define such transformations and manipulate the encoding matrices to lower the access ratio .",
    ". for high code rate or @xmath308 , the column length is shown in the solid line . for low code rate or @xmath309 , the column length is shown in the dashed line.,title=\"fig : \" ] +    in this paper , we presented a family of codes with parameters @xmath279 and they are the longest known high - rate mds code with optimal repair .",
    "the codes were constructed using eigenspaces of the encoding matrices , such that they satisfy the subspace property .",
    "this property gives more insights on the structure of the codes , and simplifies the proof of optimal repair .",
    "if we require that the code rate approaches @xmath4 , i.e. , @xmath0 being a constant and @xmath66 goes to infinity , then the column length @xmath2 is _ exponential _ in the code length @xmath74 .",
    "however , if we require the code rate to be roughly a constant fraction , i.e. , @xmath66 being a constant and @xmath0 goes to infinity , then @xmath2 is _ polynomial _ in @xmath74 .",
    "therefore , depending on the application and therefore the different codes rate , one can obtain different asymptotic characteristics of the code length .    for @xmath310 or @xmath311 ( low code rate ) , constructions in @xcite",
    "give the column length @xmath312 .",
    "with some modifications , this column length is feasible for all @xmath313 . in our construction ( high code rate ) , the column length is @xmath314 .",
    "fix the value of @xmath74 , we can draw the graph of the column length with respect to the number of parities .",
    "even though we need integer values for @xmath315 , this graph still shows the trend of the code parameters .",
    "for example , this relationship is shown in figure [ fig5 ] for @xmath316 .",
    "these two regimes coincide when @xmath317 .",
    "actually , we can see that these two constructions are identical for @xmath318 .",
    "note that our construction only considers the repair of systematic nodes , so is only practical when @xmath319 .",
    "it is interesting to investigate the actual shape of this curve , and to understand for fixed code length @xmath74 how the column length @xmath2 changes with the number of parities @xmath0 .    besides , one possible application of the codes is hot / cold data .",
    "since some of the nodes have lower access ratio than others if erased and hot data is more commonly requested , we can put the hot data in the low - access nodes , and cold data in the others .    at",
    "last , it is still an open problem what is the longest optimal - repair code one can build given the column length @xmath2 . also , the bound of the finite field size used for the codes may not be tight enough . unlike the constructions in this paper",
    ", the field size may be reduced when we assume that the encoding matrices do not have eigenvalues or eigenvectors ( are not diagonalizable ) .",
    "m.  blaum , j.  brady , j.  bruck , and j.  menon , `` evenodd : an efficient scheme for tolerating double disk failures in raid architectures , '' _ ieee trans . on computers _ ,",
    "44 , no .  2 ,",
    "192202 , feb .",
    "1995 .    v. r.  cadambe , c.  huang , and j.  li,``permutation code :",
    "optimal exact - repair of a single failed node in mds code based distributed storage systems , '' in _ isit _ , 2011 . v.",
    "r. cadambe , c. huang , j. li , and s. mehrotra ,  polynomial length mds codes with optimal repair in distributed storage systems \" , in _ proceedings of 45th asilomar conference on signals systems and computing _ , nov 2011 .",
    "v. r.  cadambe , s. a.  jafar , h.  maleki , k.  ramchandran , and c.  suh .",
    "`` asymptotic interference alignment for optimal repair of mds codes in distributed storage , '' _ ieee trans . on information",
    "theory _ , vol .",
    "59 , no .  5 , pp . 29742987 , 2013 .",
    "p.  corbett , b.  english , a.  goel , t.  grcanac , s.  kleiman , j.  leong , and s.  sankar , `` row - diagonal parity for double disk failure correction , '' in _ proc . of the 3rd usenix symposium on file and storage technologies ( fast 04 ) _ , 2004 .",
    "j. li , x. tang , and p. udaya .",
    "`` a framework of constructions of minimum storage regenerating codes with the optimal update / access property for distributed storage systems based on invariant subspace technique , '' tech . rep .",
    "arxiv:1311.4947 , 2013 .",
    "k. v.  rashmi , n.b .",
    "shah , and p.v .",
    "kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ trans . on information theory _ ,",
    "57 , no .  8 , pp . 52275239 , 2011 .",
    "n.  b. shah , k. v.  rashmi , p.",
    "v. kumar , and k.  ramchandran , `` interference alignment in regenerating codes for distributed storage : necessity and code constructions , '' _ ieee trans .",
    "on information theory _ , vol  56 , no .  4 ,",
    "pp . 21342158 , 2012 .",
    "c.  suh and k.  ramchandran , `` exact - repair mds code construction using interference alignment , '' _ ieee trans . on information theory _",
    ", vol  57 , no .  3 , pp .",
    "14251442 , 2011 . for distributed storage ,  tech .",
    "arxiv:1004.4663 , 2010 .",
    "i. tamo , z. wang , and j. bruck , `` zigzag codes : mds array codes with optimal rebuilding , '' _ ieee trans . on information theory _ , vol  59 , no .  3 , pp . 15971616 , 2013 .",
    "i. tamo , z. wang , and j. bruck , `` access versus bandwidth in codes for storage , '' _ ieee trans . on information theory _",
    ", vol  60 , no .  4 , pp . 20282037 , 2014 .",
    "y.  wu and a.  dimakis , `` reducing repair traffic for erasure coding - based storage via interference alignment , '' in _ isit _ , 2009 .",
    "y.  wu , r.  dimakis , and k.  ramchandran , `` deterministic regenerating codes for distributed storage , '' in _",
    "allerton conference on control , computing , and communication , urbana - champaign , il _ , 2007 .",
    "l.  xu , v.  bohossian , j.  bruck , and d.  wagner , `` low - density mds codes and factors of complete graphs , '' _ ieee trans .",
    "on information theory _",
    "45 , no .  6 , pp . 18171826 , sep .",
    "l.  xu and j.  bruck , `` x - code : mds array codes with optimal encoding , '' _ ieee trans . on information theory _",
    "45 , no .  1 ,",
    "pp . 272276 , 1999 ."
  ],
  "abstract_text": [
    "<S> mds codes are erasure - correcting codes that can correct the maximum number of erasures for a given number of redundancy or parity symbols . if an mds code has @xmath0 parities and no more than @xmath0 erasures occur , then by transmitting all the remaining data in the code , the original information can be recovered . </S>",
    "<S> however , it was shown that in order to recover a single symbol erasure , only a fraction of @xmath1 of the information needs to be transmitted . </S>",
    "<S> this fraction is called the _ repair bandwidth ( fraction)_. explicit code constructions were given in previous works . </S>",
    "<S> if we view each symbol in the code as a vector or a column over some field , then the code forms a 2d array and such codes are especially widely used in storage systems . in this paper </S>",
    "<S> , we address the following question : given the length of the column @xmath2 , number of parities @xmath0 , can we construct high - rate mds array codes with optimal repair bandwidth of @xmath1 , whose code length is as long as possible ? in this paper , we give code constructions such that the code length is @xmath3 . </S>"
  ]
}