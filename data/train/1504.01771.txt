{
  "article_text": [
    "middleboxes ( e.g. proxies , firewalls , ids , wan optimizers , etc . )",
    "are special network devices that perform functional processing of network traffic in order to achieve a certain level of security and performance .",
    "each network flow may require certain set of functions . in some cases",
    "these functions can be applied only in a particular order , which makes routing in networks with middleboxes under limited resources constraints even a more difficult task .",
    "mechanism of controlling routing through the specified functional sequence is called service function chaining ( sfc ) . logically centralized traffic control offered by sdn",
    "enables traffic routing optimization ( in terms of device costs , total throughput , load balancing , link utilizations , etc . ) , while satisfying a correct traversal of network middleboxes for each flow . several recent works",
    "( e.g. @xcite , @xcite , @xcite ) provide relevant solutions .",
    "functionality provided by middleboxes can be incorporated in the network in several ways .",
    "traditional middlebox is a standalone physical device that can typically perform one network function , and may be located at an ingress switch . with the development of the network function virtualization ( nfv ) , middleboxes may be implemented using virtual machines ( vms ) that can be flexibly installed at the physical machines ( pms ) . in addition",
    ", virtualization enables implementation of the consolidated middleboxes @xcite , where a flow receives all of its required service functions at a single machine .",
    "the consolidated middlebox model simplifies traffic routing and helps reduce the number of routing rules in the switches .    in this paper",
    ", we follow the model in @xcite , and assume that each middlebox function is an application that can be installed at certain vms within the pms .",
    "it is also assumed that every flow obtains all its required functional treatment at a single pm , and thus the consolidated middlebox model is implied in the paper . network function consolidation and flexible implementation of middleboxes",
    "were previously discussed , for example in @xcite , @xcite , @xcite and @xcite .",
    "depending on the network traffic environment , two types of routing schemes can be developed : offline , where all required traffic demands are given or can be estimated ( for example , using a service level agreement between the customer and the provider ) , and online , where demands are unknown and a routing solution for each coming flow is made based on the flow class and the current state of the network . a solution obtained by a routing scheme",
    "can be converted into a set of routing rules that are installed in the switches .",
    "different criteria can be used to characterize the achievable performance of a routing scheme : total throughput , average delay , maximum pm utilization , etc . besides achieving a desired network performance ,",
    "a routing scheme must also satisfy resource and routing constraints .",
    "additionally , three new constraints are of a special interest in the sdn - enabled networks with middleboxes .    * * switch memory capacities : * number of rules installed in a single switch is limited by its memory capacity .",
    "ternary content - addressable memory ( tcam ) used in sdn switches is a scarce resource which is expensive both in terms of cost and power consumption . *",
    "* middlebox processing capacities : * load on each middlebox should not exceed its processing capacity .",
    "overload of middleboxes has to be avoided since it may cause loss of traffic , delay , incorrect traversal sequence or other problems . *",
    "* traversal constraints : * required network functions have to be applied to any given flow in a correct order .",
    "the switch memory constraint is important : flow table overflow is a serious problem that can significantly degrade network performance and , therefore should be avoided .",
    "because this constraint is of integer type , it makes the problem of finding an optimal routing solution hard .",
    "if , in addition , middleboxes are added to the network , finding such routing becomes even harder .",
    "in this paper we present an approach based on multi - point - to - point trees that efficiently finds a routing with a guarantee on the maximum number of rules in a single switch , while satisfying all other network constraints .",
    "moreover , our routing solution scales well with the network size : the explicit bound @xmath0 on the number of rules is additive and depends linearly on the number of destination nodes ( @xmath1 ) , links ( @xmath2 ) and flow classes ( @xmath3 ) in the network .",
    "this paper is organized as follows : in section 2 we introduce our network model and necessary notations . in section 3",
    "we describe our routing solution , in section 4 we evaluate its performance by simulations and demonstrate its advantages over several other routing schemes .",
    "finally , we compare our solution with related works in section 5 , and conclude in section 6 .",
    ".main notations .",
    "[ cols=\"^,^\",options=\"header \" , ]",
    "we assume that the network topology is defined by a directed graph @xmath4 , where @xmath5 is the set of its nodes and @xmath6 is the set of edges .",
    "each node corresponds either to a switch or to a pm , and each edge is a link connecting either two switches , a switch with a pm , or a pm with a switch .",
    "we denote by @xmath7 and @xmath8 the node sets corresponding to switches and pms , respectively , so that @xmath9 , and @xmath10 .",
    "it will be assumed for simplicity that each pm is connected with a single switch by bi - directional links as shown in fig .",
    "let @xmath11 be the subset of nodes in @xmath7 that are directly connected to the pm nodes ( @xmath12 in fig .",
    "[ g ] ) .",
    "each switch has a certain memory capacity that can be expressed as a number of rules that it can accommodate .",
    "we will denote this number by @xmath13 for a switch located at node @xmath14 ( @xmath15 , where @xmath16 is the cardinality of a set @xmath17 .",
    "additionally , let @xmath18 be the number of rules in this switch in a routing solution .",
    "although a pm may have several types of resources ( e.g. memory , cpu ) , it will be assumed for simplicity that each pm is characterized by a single resource capacity that will be denoted by @xmath19 for a pm located at node @xmath14 ( @xmath20 ) .",
    "similarly , each link @xmath21 @xmath22 has an associated link capacity that will be denoted by @xmath23 .",
    "there exist several types of network functions ( firewall , ips , ids , wan optimization , etc . ) , and each function has its own cost per unit of traffic in terms of pm resources .",
    "although in this work we assume that this processing cost is the same for all pms , it is easy to generalize it to the case when the costs are distinct for different pms .    additionally , there is a set of @xmath24 traffic demands or `` commodities '' that have to be routed in the network .",
    "we will use the terms traffic demand and commodity interchangeably .",
    "commodity @xmath25 is defined by a four - tuple @xmath26 @xmath27 , where @xmath28 . here",
    "@xmath29 and @xmath30 are , respectively , source and destination nodes , @xmath31 is an amount of flow that has to be routed for commodity @xmath25 , which we will call commodity s demand , and @xmath32 is an ordered set of network functions required by this commodity .",
    "any such ordered set of network functions defines the class of a commodity .",
    "we will denote by @xmath3 the total number of different classes of traffic demands . due to various functional requirements ,",
    "different commodities may have different per unit of traffic costs in terms of pm s processing power .",
    "let @xmath33 be such cost per unit of traffic for traffic demand @xmath25 .",
    "each pm hosts at most @xmath3 vms , where a single vm corresponds to a single commodity class .",
    "it is assumed that when a packet from a commodity of class @xmath34 arrives to a pm , it is transfered to the virtual machine associated with class @xmath34 , and all network functions of class @xmath34 are applied to this packet in a correct order .",
    "distribution of each pm s processing capacity among @xmath3 vms has to be determined .",
    "it is assumed , however , that positions of pms ( nodes @xmath8 ) are given as an input and are not subject to change .",
    "by @xmath35 we will denote the set of distinct destinations , then @xmath36 , @xmath37 .",
    "main notations are summarized in table [ table ] .      in this work",
    "we employ the idea of consolidated middleboxes , and each packet belonging to @xmath25 gets all functional treatment specified by @xmath38 at a single pm .",
    "it is allowed , however , that a single commodity s traffic is split into several paths from @xmath39 to @xmath40 , and distinct paths may traverse distinct pms .",
    "we point out that splitting occurs at the ip flow level and not at the packet level .",
    "this is similar to equal cost multipath @xcite in data centers , where hashing is used to split traffic at the ip flow level for routing on multiple paths .",
    "if the traffic demands are known in advance , an optimization problem can be posed whose feasible solution defines a routing that satisfies all network constraints .",
    "the variables of this optimization problem @xmath41 are the amount of traffic of commodity @xmath25 on edge @xmath42 , @xmath28 .",
    "here superscript @xmath43 with zero value corresponds to the traffic that has not visited a consolidated middlebox , and unit value is used to denote the traffic that has been processed by the required network functions .",
    "there are thus @xmath44 variables in this optimization problem .",
    "let @xmath45 be the demand from a node @xmath46 for the commodity @xmath25 .",
    "note that @xmath47 if @xmath48 , and is zero , otherwise .",
    "the problem is formulated as follows .",
    "@xmath49    @xmath50    @xmath51    @xmath52    @xmath53    @xmath54    @xmath55    @xmath56    @xmath57    @xmath58    @xmath59    0.2   and graphs @xmath60 and @xmath61 constructed at the first and the second steps of our algorithm , respectively.,title=\"fig : \" ]       0.2   and graphs @xmath60 and @xmath61 constructed at the first and the second steps of our algorithm , respectively.,title=\"fig : \" ]       0.18   and graphs @xmath60 and @xmath61 constructed at the first and the second steps of our algorithm , respectively.,title=\"fig : \" ]    constraints and are flow conservation constraints for switches , constraint forbids the traffic that has already been processed by a middlebox ( pm ) , to visit a middlebox again .",
    "next constraint says that all unprocessed traffic becomes processed at the pm associated with node @xmath62 .",
    "further , constraint is a pm processing capacity constraint .",
    "the following constraint is a link capacity constraint , and condition corresponds to the switch memory constraint .",
    "finally , requires that all flow values are nonnegative .",
    "the objective function of this optimization problem is the total flow over all edges .",
    "this choice of the objective function guarantees that no cycles will exist in an optimal solution .",
    "notice that there is no constraint @xmath63 similar to constraint , because it will be automatically satisfied due to the optimization s objective function .",
    "solution to this optimization problem expressed in terms of variables @xmath41 can be translated to a path - flow formulation @xcite , and the routing rules in switches can be obtained that implement this path - flow solution . each routing rule in a switch corresponds to a single path in the path - flow solution .",
    "notice that in the solution to the optimization problem , more than one source - destination path can be used to transfer traffic for a single commodity .",
    "the optimization problem formulated above contains integer switch memory constraints and thus belongs to the class of integer linear programs ( ilp ) .",
    "this problem , therefore , is np - hard , and it is extremely difficult to obtain its solution . in this work ,",
    "we adapt the idea of multipoint - to - point trees to construct a feasible routing scheme for sdn - enabled networks with middleboxes and known traffic demands .",
    "although the integer switch memory constraints are not explicitly incorporated into our solution , we can obtain the worst case bound on the number of rules in each switch .",
    "moreover , we show that this bound scales well with the network size and is low enough for our routing scheme to be implemented in the networks with existing switches .",
    "in this work we take advantage of the capabilities provided by sdn to design efficient routing . in particular , sdn facilitates global design optimization based on inputs and measurements collected from various points of the network , and the ability to translate design solutions into rules which can be downloaded to the switches .",
    "one of the major components of our routing solution is multipoint - to - point trees that were previously used , for example , by the label based forwarding mechanism of mpls @xcite .",
    "each multipoint - to - point tree is rooted at some node , and all its edges are oriented towards this root node .",
    "such trees can be used to route traffic from several sources to a single destination , and each tree is assigned with its own tag which is used to label all traffic belonging to this tree .",
    "utilization of mptpts helps to reduce the number of routing rules in the whole network @xcite .",
    "our solution contains two main steps .",
    "these steps are purely computational ( not actual routing steps ) , and allow to determine how the traffic for each commodity is labeled and routed . at the first step we route all traffic from the sources @xmath39 , ( @xmath64 @xmath24 ) to pms . at the second step ,",
    "we route all traffic that has been processed by the required network functions during the first step from the pms to the corresponding destinations @xmath40 , ( @xmath28 ) .",
    "both steps involve construction of mptp trees : there are @xmath3 roots for multipoint - to - point trees built at the first step , where each root corresponds to a particular flow class , and there are @xmath1 roots for the trees at the second step .",
    "there can be in general more than one mptp tree rooted at a single node . in fig .",
    "[ diagram ] we show the schematic of our mptpt - based routing algorithm .      at the first step we consider a graph @xmath65 which is obtained from the initial graph @xmath66 as follows :",
    "we add @xmath3 additional nodes @xmath67 such that node @xmath68 corresponds to the traffic class @xmath34 .",
    "this set of @xmath3 new nodes is denoted by @xmath69 , and @xmath70 .",
    "we further remove `` pm '' nodes belonging to the set @xmath8 , together with the edges going to and from these nodes .",
    "then , we connect each node from @xmath11 by edges to every node from @xmath69 .",
    "these new edges are not assigned with capacities explicitly , but the maximum amount of flow on them will be determined by the capacities of pms and the capacities of removed links from graph @xmath66 that were connecting nodes in @xmath11 with nodes @xmath8 .",
    "the vertex set of graph @xmath60 is a union of node sets @xmath7 and @xmath69 : @xmath71 .",
    "number of links in the graph @xmath60 is @xmath72 . in fig .",
    "[ ba ] we show an example of a network topology defined by a graph @xmath66 ( fig . [ g ] ) and corresponding constructed graph @xmath60 ( fig .",
    "[ g1 ] ) . in this example",
    "it is assumed that there are two classes of flows and the nodes @xmath73 and @xmath74 are associated with flow classes one and two , respectively . in fig .",
    "[ g1 ] the new added links are shown by dashed arrows .",
    "we additionally modify destinations of the given commodities .",
    "in particular , destination of all traffic demands of class @xmath34 is node @xmath68 , @xmath75 .",
    "therefore , for each commodity @xmath25 , its destination is one of the nodes in @xmath69 .",
    "we can now formulate an lp optimization problem that we solve at the first step of our method .",
    "in contrast to the commodity - based ilp problem considered in the previous subsection , the optimization here is in a tree - based formulation , and we do not distinguish traffic from different sources if they are for the same destination , i.e. if they belong to the same network class .",
    "let @xmath76 denote a pm connected to node @xmath77 in graph @xmath66 ( for example , @xmath78 for @xmath79 in the example from fig .",
    "[ ba ] ) , and @xmath80 , where @xmath81 , denotes the cost of pm resources per unit of traffic of class corresponding to the node @xmath82 .",
    "@xmath83    @xmath84    @xmath85    @xmath86    @xmath87    @xmath88    @xmath89    in this optimization problem variable @xmath90 is an amo - unt of flow to destination @xmath81 on link @xmath91 .",
    "constraint is a flow conservation at node @xmath92 , condition is a link capacity constraint that should be satisfied for any link that belongs to the both edge sets @xmath6 and @xmath93 of graphs @xmath66 and @xmath60 , respectively .",
    "further , constraint is a link capacity constraint for the links that connect switches with pms in graph @xmath66 .",
    "this constraint is necessary for feasibility of the solution to optimization problem ( 2 ) in the original graph @xmath66 .",
    "notice that in the right hand side of there is a minimum between capacities of the links going from a switch to a pm and from a pm to a switch .",
    "it will guarantee that all traffic processed at a pm can be send back to a switch connected to this pm .",
    "next constraint is a pm capacity constraint , and by we require that flow on each link is nonnegative . as in the ilp optimization problem",
    "( 1 ) , we minimize the total network flow to avoid cycles .",
    "solution to the optimization problem ( 2 ) determines how the traffic is routed from the sources to the pms .",
    "using algorithm flow2trees@xmath94 from @xcite that is listed as algorithm [ a1 ] below for completeness , from a basic feasible solution @xcite @xmath90 to the lp ( 2 ) we construct multipoint - to - point trees rooted at the destination nodes from @xmath69 , so that all network traffic in the solution is distributed among these trees .",
    "each tree contains traffic of the same class , leafs of a tree are the sources for this traffic class , and amount of traffic from each source in any tree can be determined .",
    "it is possible that several @xmath11 nodes belong to the same tree , i.e. one tree can route traffic to several pms .",
    "algorithm [ a1 ] is iteratively applied to construct trees to each destination @xmath81 .",
    "we will provide an upper bound on a total number of trees in the subsection @xmath95 .",
    "we refer the reader to @xcite for the details and analysis of algorithm [ a1 ] .      at the second step of our algorithm we use mptp trees to route traffic from the pms to destinations in graph @xmath61 obtained from @xmath60 as follows .",
    "first , nodes @xmath69 and links to them are removed from the network .",
    "therefore , the node set of the resulting graph @xmath96 only contains nodes from @xmath7 : @xmath97 .",
    "number of links in graph @xmath61 is @xmath98 .",
    "second , the link capacities are updated : for each link @xmath99 , the amount of traffic on it in the solution to ( 2 ) is subtracted from this link s initial capacity @xmath100 .",
    "we will denote by @xmath101 the updated capacity of link @xmath99 .",
    "graph @xmath61 corresponding to graph @xmath66 from fig .",
    "[ g ] is shown in fig . [ g2 ] .    0.3        0.3",
    "we then create a set of commodities for the second step .",
    "it is assumed that all traffic processed at a pm @xmath76 returns to switch @xmath77 connected to it .",
    "therefore , all traffic at step 2 is routed from the nodes @xmath11 to the destinations @xmath40 , where @xmath102 .",
    "solution to optimization ( 2 ) determines amount of traffic of every class and from every source arriving to each pm .",
    "however , amount of traffic to each destination @xmath40 arriving to a pm , in some cases can not be determined unambiguously .",
    "this can happen when there exist more than one commodities with the same source and of the same class but with different destinations .",
    "we illustrate this possibility with an example from fig .",
    "[ ambig ] . in fig .",
    "[ ambig1 ] the network topology is shown : there is only one source node @xmath103 , two pms and two destination nodes @xmath104 and @xmath105 .",
    "it is also assumed that there is only one traffic class 1 , @xmath106 units of traffic from @xmath103 should be sent to @xmath104 , and @xmath107 units to @xmath105 .",
    "graph @xmath60 constructed at the first step of our algorithm is shown in fig .",
    "[ ambig2 ] .",
    "suppose that two trees to node @xmath73 were obtained at the first step : tree @xmath108 ( @xmath109 , and tree @xmath110 ( @xmath111 . the links belonging to the trees @xmath108 and @xmath110 are shown by solid green ( tree @xmath108 ) and dashed blue ( tree @xmath110 ) lines in fig .",
    "[ ambig2 ] .",
    "assume for example , that @xmath112 units of traffic of class 1 belong to the tree @xmath108 , and @xmath113 units belong to the tree @xmath110 .",
    "therefore , after step 1 of our algorithm it is known how much traffic of this class from source @xmath103 arrives to node @xmath114 ( to be processed at pm1 ) , and how much traffic arrives to node @xmath115 ( to obtain functional treatment at pm2 ) , but distribution of traffic by destination at nodes @xmath114 and @xmath115 is unknown .",
    "this information , however , is necessary to define commodities at the second step of our approach , and thus a distribution decision is required .",
    "we will use the following heuristic to determine the traffic distribution by destination at each node @xmath77 .",
    "let @xmath116 be a set of trees obtained at step 1 of our algorithm that carry traffic of the same class @xmath117 from a source node @xmath103 to the root node @xmath118 corresponding to this traffic class .",
    "in addition , let @xmath119 be the set of destinations of commodities with source @xmath103 and of class @xmath117 , and @xmath120 are corresponding demands . by the definition of a tree , in each tree",
    "@xmath121 from set @xmath116 , there is a unique path from @xmath103 to @xmath118 , and therefore , all traffic from @xmath103 in the same tree obtains functional treatment at a single pm . according to our heuristic , in each tree @xmath121 , amount of traffic to destination @xmath122 is proportional to the fraction of traffic to this destination in the total amount of traffic to all destinations , i.e. proportional to @xmath123 .",
    "in example from fig .",
    "[ ambig ] , @xmath124 , @xmath125 , @xmath126 , @xmath127 and @xmath128 .",
    "then , according to the heuristic , in tree @xmath129 : @xmath130 units of traffic are to destination @xmath131 , @xmath132 units of traffic are to destination @xmath133 .",
    "similarly , in tree @xmath134 the distribution is @xmath135 and @xmath136 units to @xmath131 and @xmath133 , respectively .    using this distribution heuristic",
    ", we form a set of commodities for the second step of our algorithm . at the step 2 we do not distinguish traffic from different sources and from different network classes if they have the same destination .",
    "we construct mptp trees with the roots at the destinations @xmath40 , @xmath102 .",
    "similarly to step 1 , we first solve the following lp :    @xmath137    @xmath138    @xmath139    @xmath140    @xmath141    here and are flow conservation and link capacity constraints , respectively , and is a requirement for flows to be non negative on each link . using a basic feasible solution to this problem",
    ", we apply again algorithm [ a1 ] and obtain another set of multipoint - to - point trees .",
    "complete version of our mptpt - based routing approach is summarized in algorithm [ a2 ] .",
    "+ construct graph @xmath65 from @xmath4 ; + obtain commodities for step 1 ; + find a basic feasible solution to lp ( 2 ) ; + find mptp trees for the solution to lp ( 2 ) using algorithm [ a1 ] ; +   + construct graph @xmath96 from @xmath65 ; + obtain commodities for step 2 ; + find a basic feasible solution to lp ( 3 ) ; + find mptp trees for the solution to lp ( 3 ) using algorithm [ a1 ] .",
    "+    after both steps of our algorithm are performed , we can determine for any initial commodity @xmath142 what trees carry its traffic to the destination @xmath40 .",
    "each commodity s packet is assigned with two tags at the source switch : one for a tree label from step 1 , and another one for a tree label from step 2 .",
    "the first label can be removed from a packet during functional processing at a pm , and therefore the maximum number of routing rules in a single switch does not exceed the total number of multipoint - to - point trees of both steps . as suggested in previous works ( e.g. @xcite ) , vlan and tos fields of a packet header can be used for labels .      in this subsection",
    "we provide and prove an upper bound on the total number of mptp trees generated by algorithm [ a2 ] .",
    "each tree has its own label and any switch may contain at most one routing rule corresponding to this tree .",
    "the bound , therefore , also limits the number of routing rules in any switch .",
    "number of mptp trees produced by algorithm [ a2 ] does not exceed @xmath0 .",
    "it was shown in @xcite that when algorithm [ a1 ] is iteratively applied to a basic feasible solution of the multicommodity flow problem ( 3 ) , the maximum possible number of created trees is @xmath143 , i.e. bounded above by the sum of number of destinations and number of links in a network .",
    "the second term in this sum ( @xmath144 ) corresponds to the number of bundle constraints in lp .",
    "a constraint is called bundle if it involves variables for different destinations . in optimization problem",
    "( 3 ) link capacity constraints are bundle , and there are @xmath144 such constraints . although optimization problem ( 2 ) is slightly different from ( 3 ) , a similar bound for it can also be established .",
    "number of bundle constraints in ( 2 ) is @xmath145 , and number of destinations is equal to the number of traffic classes @xmath3 .",
    "therefore , the total number of trees produced by algorithm [ a2 ] is @xmath146 .",
    "notice that while our bound depends on the number of classes @xmath3 , it does not depend on the number of commodities , because @xmath1 is bounded by @xmath147 .",
    "the bound is additive and thus scales well with the network size .",
    "moreover , as shown by simulations , the real number of routing rules obtained by our algorithm is generally much smaller than this worst case bound .",
    "it is crucial that a basic feasible solution is used as an input to the algorithm [ a1 ] at both steps of algorithm [ a2 ] .",
    "we refer the reader to @xcite and @xcite for a more detailed discussion of basic feasible solutions and bundle constraints .",
    "0.25        0.25        0.255     therefore , algorithm 2 efficiently solves a routing problem ( it contains two linear optimizations and algorithm 1 with polynomial time complexity ) with a guarantee that the number of routing rules in each switch is limited by an additive bound .",
    "in this section we evaluate the performance of algorithm [ a2 ] and compare it with three other routing schemes . the first routing scheme is defined by optimization problem ( 1 ) with relaxed integer switch memory constraint , and a basic feasible solution for it is found using simplex method .",
    "the second scheme uses the same relaxed lp , but an interior point method ( ipm ) is applied to find a solution .",
    "finally , the third scheme is based on a greedy shortest path approach . in this approach",
    "the commodities are initially sorted in descending order by their total pm capacity requirement .",
    "then , iteratively for each commodity a shortest path is found from its source to a pm , and then a shortest path from the pm to commodity s destination .",
    "if link and pm capacity constraints on the shortest path do not allow to send commodity s total demand , a maximum possible fraction of it is sent along this path , and the remaining traffic is sent along the next shortest paths until all commodity s demand is routed . if at some point there is no path available to send commodity s residual demand , the algorithm stops .",
    "our evaluation analysis consists of two experiments . in the first experiment we find routing solution using each of four algorithms and",
    "calculate an average number of routing rules in switches for each solution .",
    "second experiment allows to estimate for each routing algorithm the maximum total throughput that it can route .",
    "both experiments are carried out for three network topologies : example from fig .",
    "[ ba ] , geant topology , and fat tree topology .",
    "geant network contains 41 switch nodes and 9 additional pm nodes that are connected to 9 switch nodes having the highest nodal degree ( so that each pm is connected to exactly one switch ) .",
    "fat tree topology consists of 22 switch nodes ( 2 core , 4 aggregation and 16 edge switches ) , and 6 pm nodes such that each pm node is connected to a single core or aggregate switch node .",
    "link and pm capacities were fixed in each simulation , and took values , respectively , 100 and 500 for the network on fig .",
    "[ ba ] , and 500 , 500 for geant topology .",
    "for the fat tree topology links between core and aggregation switches had capacities 200 , links between aggregation and edge switches had capacities 10 , and links between switches and pms were fixed at 100 .",
    "in addition , each pm had capacity 500 .",
    "* experiment 1 : average number of routing rules . * in the first experiment we varied number of classes and number of commodities , and each commodity s source , destination and class were generated randomly .",
    "the demands of the commodities , however , were all equal and fixed at 0.2 .",
    "results of experiment 1 for 3 and 7 traffic classes are shown in fig .",
    "it can be observed from the results that algorithm [ a2 ] allows to reduce average number of routing rules in switches by a factor of up to 10 .",
    "we did not add plots corresponding to the interior point method solution for geant and fat tree topologies because in the ipm solution average number of rules is much higher compared to the other algorithms .",
    "we also performed simulations for one and five traffic classes , and the results look similar to fig .",
    "the values of bounds on the maximum number of rules in switches are 43 , 295 and 137 for the topologies in the same order they are presented in fig .",
    "[ exp1 ] and for 7 traffic classes .",
    "these values were obtained under assumption that @xmath148 and therefore , limit the number of routing rules in each switch for any arbitrary large number of commodities .    0.26        0.26        0.26     * experiment 2 : maximum total throughput .",
    "* in the second experiment we measured the maximum total throughput that can be routed in a network by the algorithm [ a2 ] .",
    "notice , that ilp ( 1 ) with relaxed switch memory constraint always finds a routing solution when it exists .",
    "therefore , we used the relaxed lp ( 1 ) to determine the maximum possible network throughput . for a given set of commodities , we increased iteratively demands of all commodities by the same value until the relaxed lp ( 1 ) became unfeasible .",
    "we stored this maximum demand value , and repeated the procedure for the algorithm [ a2 ] and also for the greedy shortest path algorithm .",
    "results provided in fig .",
    "[ exp2 ] demonstrate that a loss in maximum throughput of the algorithm [ a2 ] is relatively small .",
    "most of the previous works on routing in networks with middleboxes aim to achieve a fair load balance among middleboxes @xcite , @xcite .",
    "however , it is generally assumed that for each given commodity a set of proper paths is provided ( or a single path ) @xcite , @xcite , @xcite .",
    "although this assumption simplifies finding a routing , it has an important disadvantage : it is generally not easy to find a set of suitable paths for all commodities such that all traffic demands can be routed and network constraints are satisfied . in @xcite",
    "the problem setup is similar to ours : middleboxes run as virtual machines at the pms , traffic demands are known , and a routing linear optimization program is proposed . the integer switch memory constraint ,",
    "however , is not incorporated into the routing problem , what makes it easier to find a feasible solution .",
    "the authors also explore the problem of an optimal placement of middleboxes .    an optimization model for network intrusion detection systems ( nids )",
    "load balancing is presented in @xcite .",
    "a linear optimization problem contains estimates of the commodities demands and thus is designed for a carrier - grade traffic environment .",
    "it is solved periodically to remain an optimal feasible routing for changing traffic demands .",
    "this optimization problem does not include switch capacity constraints , and its goal is to balance the load among different nids .",
    "it is also assumed that for each commodity a precomputed path is given as an input .",
    "therefore , the problem solved in @xcite is not exactly a traffic engineering problem , but a load engineering .    switch memory constraint was taken into account in @xcite , and it was also assumed that there exists a set of suitable paths for each commodity . due to the difficulty of the original optimization problem , it was decomposed in @xcite into two stages . at the first ( offline ) stage , only the switch memory constraint is taken into account , and for each commodity a subset of paths is chosen from its original path set . since the switch memory constraint is integer , the whole offline optimization problem solved at the first stage is an integer linear program ( ilp ) . at the second ( online ) stage , a simpler linear program ( lp ) is formulated to solve a load balancing problem .",
    "in this work we proposed a multipoint - to - point tree based algorithm for sdn - enabled networks with middleboxes and given required traffic demands .",
    "we showed both theoretically and experimentally that in the routing solution obtained by our algorithm , the maximum number of routing rules in a single switch is bounded , and this explicit bound scales well with the network size .",
    "moreover , the low complexity of the algorithm allows its application the algorithm in dynamic network environment .",
    "anderson , j. w. , braud , r. , kapoor , r. , porter , g. , and vahdat , a. ( 2012 , october ) .",
    "xomb : extensible open middleboxes with commodity servers . in acm",
    "/ ieee symposium on architectures for networking and communications systems ( pp .",
    "49 - 60 ) .",
    "acm .",
    "fayazbakhsh , s. k. , sekar , v. , yu , m. , and mogul , j. c. ( 2013 , august ) .",
    "flowtags : enforcing network - wide policies in the presence of dynamic middlebox actions . in acm sigcomm workshop on hot topics in software defined networking ( pp .",
    "19 - 24 ) .",
    "greenhalgh , a. , huici , f. , hoerdt , m. , papadimitriou , p. , handley , m. , and mathy , l. ( 2009 ) .",
    "flow processing and the rise of commodity network hardware .",
    "acm sigcomm computer communication review , 39(2 ) , 20 - 26 .",
    "heorhiadi , v. , reiter , m. k. , and sekar , v. ( 2012 , december ) .",
    "new opportunities for load balancing in network - wide intrusion detection systems . in international conference on emerging networking experiments and technologies ( pp .",
    "361 - 372 ) .",
    "qazi , z. a. , tu , c. c. , chiang , l. , miao , r. , sekar , v. , and yu , m. ( 2013 , august ) .",
    "simple - fying middlebox policy enforcement using sdn . in acm sigcomm computer communication review ( vol .",
    "27 - 38 ) .",
    "sekar , v. , egi , n. , ratnasamy , s. , reiter , m. k. , and shi , g. ( 2012 , april ) .",
    "design and implementation of a consolidated middlebox architecture . in usenix conference on networked systems design and implementation ( pp .",
    "24 - 24 ) .",
    "usenix association ."
  ],
  "abstract_text": [
    "<S> middleboxes are special network devices that perform various functions such as enabling security and efficiency . </S>",
    "<S> sdn - based routing approaches in networks with middleboxes need to address resource constraints , such as memory in the switches and processing power of middleboxes , and traversal constraint where a flow must visit the required middleboxes in a specific order . in this work </S>",
    "<S> we propose a solution based on multipoint - to - point trees ( mptpt ) for routing traffic in sdn - enabled networks with consolidated middleboxes . </S>",
    "<S> we show both theoretically and via simulations that our solution significantly reduces the number of routing rules in the switches , while guaranteeing optimum throughput and meeting processing requirements . additionally , the underlying algorithm has low complexity making it suitable in dynamic network environment .    </S>",
    "<S> software - defined networking , middlebox , multipoint - to - point tree , traffic engineering </S>"
  ]
}