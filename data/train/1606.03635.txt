{
  "article_text": [
    "the _ complexity _ of a natural number @xmath1 is the least number of @xmath15 s needed to write it using any combination of addition and multiplication , with the order of the operations specified using parentheses grouped in any legal nesting .",
    "for instance , @xmath16 has a complexity of @xmath17 , since it can be written using @xmath17 ones as @xmath18 but not with any fewer than @xmath17 .",
    "this notion was implicitly introduced in 1953 by kurt mahler and jan popken @xcite ; they actually considered an inverse function , the size of the largest number representable using @xmath14 copies of the number @xmath15 .",
    "( more generally , they considered the same question for representations using @xmath14 copies of a positive real number @xmath19 . )",
    "integer complexity was explicitly studied by john selfridge , and was later popularized by richard guy @xcite . following j. arias",
    "de reyna @xcite we will denote the complexity of @xmath1 by @xmath0 .",
    "integer complexity is approximately logarithmic ; it satisfies the bounds @xmath20 the lower bound can be deduced from the result of mahler and popken , and was explicitly proved by john selfridge @xcite .",
    "it is attained with equality for @xmath21 for all @xmath22 .",
    "the upper bound can be obtained by writing @xmath1 in binary and finding a representation using horner s algorithm .",
    "it is not sharp , and the constant @xmath23 can be improved for large @xmath1 @xcite .",
    "one can compute @xmath0 via dynamic programming , since @xmath24 , and for @xmath25 , one has @xmath26 this yields an algorithm for computing @xmath0 that runs in time @xmath27 ; in the multiplication case , one needs to check @xmath28 , and , navely , in the addition case , one needs to check @xmath29 .",
    "however , srinivas and shankar @xcite showed that the upper bound on the addition case case be improved , lowering the time required to @xmath30 , by taking advantage of the inequality @xmath31 to rule out cases when @xmath32 is too large .",
    "arias de reyna and van de lune @xcite took this further and showed that it could be computed in time @xmath33 , where @xmath34{3}+14571397\\sqrt[3]{9 } ) ) } { \\log(2^{10}3 ^ 7 ) } < 1.231;\\ ] ] this remains the best known algorithm for computing @xmath0 for general @xmath1 .    the notion of integer complexity is similar in spirit but different in detail from the better known measure of _ addition chain length _ , which has application to computation of powers , and which is discussed in detail in knuth ( * ? ? ?",
    "see also @xcite for some interesting analogies between them ; we will discuss this further in section  [ fksec ] .",
    "one of the easiest cases of complexity to determine is powers of @xmath35 ; for any @xmath36 , one has @xmath37 .",
    "it s clear that @xmath38 for any @xmath36 , and the reverse inequality follows from equation  .",
    "the fact that @xmath37 holds for all @xmath39 might prompt one to ask whether in general it is true that @xmath40 .",
    "this is false for @xmath41 , but it does not seem an unreasonable guess for @xmath25 . nonetheless , this does not hold ; the next smallest counterexample is @xmath42 , where @xmath43 but @xmath44 . indeed ,",
    "not only do there exist @xmath1 for which @xmath45 , there are @xmath1 for which @xmath46 ; one example is @xmath47 .",
    "still , this guess can be rescued .",
    "let us first make a definition :    a number @xmath48 is called _ stable _ if @xmath49 holds for every @xmath50 .",
    "otherwise it is called _",
    "unstable_.    in @xcite , this author and zelinsky showed :    [ basicstab ] for any natural number @xmath1 , there exists @xmath51 such that @xmath5 is stable .",
    "that is to say , there exists a minimal @xmath52 such that for any @xmath53 , @xmath54    this can be seen as a `` rescue '' of the incorrect guess that @xmath40 always . with this theorem",
    ", it makes sense to define :    given @xmath55 , define @xmath6 , the _ stabilization length _ of @xmath1 , to be the smallest @xmath14 such that @xmath56 is stable .",
    "we can also define the notion of the _ stable complexity _ of @xmath1 ( see @xcite ) , which is , intuitively , what the complexity of @xmath1 would be `` if @xmath1 were stable '' :    for a positive integer @xmath1 , we define the _ stable complexity _ of @xmath1 , denoted @xmath57 , to be @xmath58 for any @xmath14 such that @xmath56 is stable .",
    "this is well - defined ; if @xmath56 and @xmath59 are both stable , say with @xmath60 , then @xmath61    the paper @xcite , while proving the existence of @xmath6 , gave no upper bound on @xmath6 or indeed any way of computing it .",
    "certainly one can not compute whether or not @xmath1 is stable simply by computing for all @xmath14 the complexity of @xmath56 ; one can guarantee that @xmath1 is unstable by such computations , but never that it is stable . and",
    "it s not clear that @xmath57 , though it has been a useful object of study in @xcite , can actually be computed .",
    "we state the main result .",
    "[ frontpagethm ] we have :    1 .",
    "the function @xmath6 , the stabilization length of @xmath1 , is a computable function of @xmath1 .",
    "the function @xmath57 , the stable complexity of @xmath1 , is a computable function of @xmath1 .",
    "3 .   the set of stable numbers is a computable set .",
    "it s worth observing here that , strictly speaking , all three parts of this theorem are equivalent .",
    "if one has an algorithm for computing @xmath6 , then one may check whether @xmath1 is stable by checking whether @xmath62 , and one may compute @xmath57 by computing @xmath63 by the usual methods and observing that @xmath64 similarly , if one has an algorithm for computing @xmath57 , one may compute whether @xmath1 is stable by checking if @xmath65 . finally , if one has an algorithm for telling if @xmath1 is stable , one may determine @xmath6 by simply applying this algorithm to @xmath1 , @xmath66 , @xmath67 , ",
    ", until it returns a positive result , which must eventually occur . such methods for converting between @xmath6 and @xmath57 may be quite slow , however .",
    "fortunately , the algorithm described here ( algorithm  [ stabalg ] ) will yield both @xmath6 and @xmath57 at once , averting such issues ; and if one has @xmath6 , checking whether @xmath1 is stable is a one - step process .",
    "an obvious question about @xmath0 is that of the complexity of powers , generalizing what was said about powers of @xmath35 above . certainly for @xmath39",
    "it is true that @xmath68 and as noted earlier in the case @xmath69 we have equality .",
    "however other values of @xmath1 have a more complicated behavior .",
    "for instance , powers of @xmath70 do not work nicely , as @xmath71 .",
    "the behavior of powers of @xmath8 remains unknown ; it has previously been verified @xcite that @xmath72 one may combine the known fact that @xmath37 for @xmath39 , and the hope that @xmath73 for @xmath39 , into the following conjecture :    for @xmath74 and not both equal to @xmath75 , @xmath76    such a conjecture , if true , is quite far from being proven ; after all , it would require that @xmath77 for all @xmath39 , which would in turn imply that @xmath78 at present , it is not even known that this limit is any greater than @xmath79 , i.e. , that @xmath80 .",
    "indeed , some have suggested that @xmath0 may indeed just be asymptotic to @xmath81 ; see @xcite .",
    "nonetheless , in this paper we provide some more evidence for this conjecture , by proving :    [ frontpage2comput ] for @xmath82 and arbitrary @xmath11 , so long as @xmath14 and @xmath11 are not both zero , @xmath83    this extends the results of @xcite regarding numbers of the form @xmath84 , as well as the results of @xcite , which showed this for @xmath85 and arbitrary @xmath11 .",
    "we prove this not by careful hand analysis , as was done in @xcite , but by demonstrating , based on the methods of @xcite , a new algorithm ( algorithm  [ pow2alg ] ) for computing @xmath86 .",
    "not only does it runs much faster than existing algorithms , but it also works , as discussed above , by determining @xmath87 and @xmath88 , thus telling us whether or not , for the given @xmath14 , @xmath9 holds for all @xmath89 .",
    "the algorithms here can be used for more purposes as well ; see theorem  [ smallunstab ] for a further application of them .",
    "let us now turn our attention to the inner workings of these algorithms , which are based on the methods in @xcite .",
    "proving the statement @xmath90 has two parts ; showing that @xmath91 , and showing that @xmath92 .",
    "the former is , comparatively , the easy part , as it consists of just finding an expression for @xmath1 that uses at most @xmath14 ones ; the latter requires ruling out shorter expressions . the simplest method for this",
    "is simply exhaustive search , which , as has been mentioned , takes time @xmath27 , or time @xmath93 once some possibilities have been eliminated from the addition case .    in this paper",
    ", we take a different approach to lower bounding the quantity @xmath0 , one used earlier in the paper @xcite ; however , we make a number of improvements to the method of @xcite that both turn this method into an actual algorithm , and frequently allow it to run in a reasonable time .",
    "the method is based on considering the _ defect _ of @xmath1 :    the _ defect _ of @xmath1 , denoted @xmath94 is defined by @xmath95    let us further define :    for a real number @xmath96 , the set @xmath97 is the set of all natural numbers with defect less than @xmath98 .",
    "the papers @xcite provided a method of , for any choice of @xmath99 , recursively building up descriptions of the sets @xmath100 ; then ,",
    "if for some @xmath1 and @xmath14 we can use this to demonstrate that @xmath101 , then we have determined a lower bound on @xmath0 . more precisely , they showed that for any @xmath96 , there is a finite set @xmath102 of multilinear polynomials , of a particular form called _ low - defect polynomials _ , such that @xmath103 if and only if @xmath1 can be written as @xmath104 for some @xmath105 and some @xmath106 . in this paper , we take this method and show how the polynomials can be produced by an actual algorithm , and how further useful information can be computed once one has these polynomials .    in brief",
    ", the algorithm works as follows : first , we choose a step size @xmath99 .",
    "we start with a set of low - defect polynomials representing @xmath107 , and apply the method of @xcite to build up sets representing @xmath108 ; at each step , we use `` truncation '' method of @xcite to ensure we are representing the set @xmath109 exactly and not including extraneous elements . then we check whether or not @xmath110 ; if it is not , we continue on to @xmath111 .",
    "if it is , then we have a representation @xmath112 , and this gives us an upper bound on @xmath0 ; indeed , we can find a shortest representation for @xmath1 in this way , and so it gives us @xmath0 exactly .",
    "this is , strictly speaking , a little different than what was described above , in that it does not involve directly getting a lower bound on @xmath0 from the fact that @xmath113 .",
    "however , this can be used too , so long as we know in advance an upper bound on @xmath0 .",
    "for instance , this is quite useful when @xmath114 ( for @xmath39 ) , as then we know that @xmath115 , and hence that @xmath116 .",
    "so we can use the method of the above paragraph , but stop early , once we have covered defects up to @xmath117 .",
    "if we get a hit within that time , then we have found a shortest representation for @xmath114 .",
    "conversely , if @xmath1 is not detected , then we know that we must have @xmath118 and hence that @xmath119 i.e. , @xmath77 , thus verifying that the obvious representation is the best possible . again , though we have illustrated it here with powers of @xmath8 , this method can be used whenever we know in advance an upper bound on @xmath0 ; see appendix  [ impnotes ] .    now , so far we ve discussed using these methods to compute @xmath0 , but we can go further and use them to prove theorem  [ frontpagethm ] , i.e. , use them to compute @xmath6 and @xmath57 . in this case , at each step , instead of checking whether there is some @xmath120 such that @xmath112 , we check whether is some @xmath121 and some @xmath11 such that @xmath122 it is not immediately obvious that this is possible , since navely we would need to check infinitely many @xmath11 , but lemma  [ maxv3 ] allows us to do this while checking only finitely many @xmath11 .",
    "once we have such a detection , we can use the value of @xmath11 to determine @xmath6 , and the representation of @xmath59 obtained this way to determine @xmath63 and hence @xmath57 .",
    "in addition , if we know in advance an upper bound on @xmath0 , we can use the same trick as above to sometimes cut the computation short and conclude not only that @xmath90 but also that @xmath1 is stable .",
    "it is worth discussing some work analogous to this paper in the study of addition chains .",
    "an _ addition chain _ for @xmath1 is defined to be a sequence @xmath123 such that @xmath124 , @xmath125 , and , for any @xmath126 , there exist @xmath127 such that @xmath128 ; the number @xmath129 is called the length of the addition chain .",
    "the shortest length among addition chains for @xmath1 , called the _ addition chain length _ of @xmath1 , is denoted @xmath130 .",
    "addition chains were introduced in 1894 by h.  dellac @xcite and reintroduced in 1937 by a.  scholz @xcite ; extensive surveys on the topic can be found in knuth ( * ? ? ?",
    "* section 4.6.3 ) and subbarao @xcite .",
    "the notion of addition chain length has obvious similarities to that of integer complexity ; each is a measure of the resources required to build up the number @xmath1 starting from @xmath15 .",
    "both allow the use of addition , but integer complexity supplements this by allowing the use of multiplication , while addition chain length supplements this by allowing the reuse of any number at no additional cost once it has been constructed .",
    "furthermore , both measures are approximately logarithmic ; the function @xmath130 satisfies @xmath131    a difference worth noting is that @xmath130 is actually known to be asymptotic to @xmath132 , as was proved by brauer@xcite , but the function @xmath0 is not known to be asymptotic to @xmath81 ; the value of the quantity @xmath133 remains unknown . as mentioned above , guy @xcite has asked whether @xmath77 for @xmath39 ; if true , it would make this quantity at least @xmath134 .",
    "the experimental mathematics group at the university of latvia @xcite has checked that this is true for @xmath135 .",
    "another difference worth noting is that unlike integer complexity , there is no known way to compute addition chain length via dynamic programming . specifically , to compute integer complexity this way",
    ", one may use the fact that for any @xmath25 ,    @xmath26    by contrast , addition chain length seems to be harder to compute .",
    "suppose we have a shortest addition chain @xmath136 for @xmath1 ; one might hope that @xmath137 is a shortest addition chain for @xmath138 , but this need not be the case .",
    "an example is provided by the addition chain @xmath139 ; this is a shortest addition chain for @xmath140 , but @xmath141 is not a shortest addition chain for @xmath142 , as @xmath143 is shorter .",
    "moreover , there is no way to assign to each natural number @xmath1 a shortest addition chain @xmath144 for @xmath1 such that @xmath137 is the addition chain assigned to @xmath138 @xcite .",
    "this can be an obstacle both to computing addition chain length and proving statements about addition chains .",
    "nevertheless , the algorithms described here seem to have a partial analogue for addition chains in the work of a.  flammenkamp @xcite .",
    "we might define the _ addition chain defect _ of @xmath1 by @xmath145 a closely related quantity , the number of _ small steps _ of @xmath1 , was introduced by knuth @xcite .",
    "the number of small steps of @xmath1 is defined by @xmath146 clearly , this is related to @xmath147 by @xmath148 .    in 1991 , a.  flammenkamp determined a method for producing descriptions of all numbers @xmath1 with @xmath149 for a given integer @xmath14 , and produced such descriptions for @xmath150 @xcite .",
    "note that for @xmath14 an integer , @xmath149 if and only if @xmath151 , so this is the same as determining all @xmath1 with @xmath151 , restricted to the case where @xmath14 is an integer .",
    "part of what flammenkamp proved may be summarized as the following :    for any integer @xmath2 , there exists a finite set @xmath152 of polynomials ( in any number of variables , with nonnegative integer coefficients ) such that for any @xmath1 , one has @xmath149 if and only if one can write @xmath153 for some @xmath154 and some integers @xmath155 .",
    "moreover , @xmath152 can be effectively computed .",
    "unfortunately , the polynomials used in flammenkamp s method are more complicated than those produced by the algorithms here ; for instance , they can not always be taken to be multilinear .",
    "nonetheless , there is a distinct similarity .",
    "flammenkamp did not consider questions of stability ( which in this case would result from repeated multiplication by @xmath8 rather than by @xmath35 ; see @xcite for more on this ) , but it may be possible to use his methods to compute stability information about addition chains , just as the algorithms here may be used to compute stability information about integer complexity .",
    "the problem of extending flammenkamp s methods to allow for non - integer cutoffs seems more difficult .",
    "many of the algorithms described here are parametric , in that they require a choice of a `` step size '' @xmath99 . in the attached implementation , @xmath156 is always taken to be @xmath157 , and some precomputations have been made based on this choice .",
    "see appendix  [ impnotes ] for more on this .",
    "below , when we discuss the computational complexity of the algorithms given here , we are assuming a fixed choice of @xmath156 .",
    "it is possible that the value of @xmath156 affects the time complexity of these algorithms .",
    "one could also consider what happens when @xmath156 is considered as an input to the algorithm , so that one can not do pre - computations based on the choice of @xmath156 .",
    "( in this case we should really restrict the form of @xmath156 so that the question makes sense , for instance to @xmath158 , with @xmath1 a natural number and @xmath159 . )",
    "we will avoid these issues for now , and assume for the rest of this section that @xmath160 unless otherwise specified .",
    "two of the algorithms here optionally allow a second input , a known upper bound @xmath161 on @xmath0 .",
    "if no bound is input , we may think of this as @xmath162 .",
    "we will assume here the simplest case , where no bound @xmath161 is input , or equivalently where we always pick @xmath162 .",
    "we will not actually conduct here a formal analysis of the time complexity of algorithm  [ stabalg ] or algorithm  [ pow2alg ] .",
    "our assertion that algorithm  [ pow2alg ] is much faster than existing methods for computing @xmath86 is an empirical one .",
    "the speedup is a dramatic one , though ; for instance , the experimental mathematics group s computation of @xmath0 for @xmath163 required about 3 weeks on a supercomputer , although they used the @xmath27-time algorithm rather than any of the improvements @xcite ; whereas computing @xmath164 via algorithm  [ pow2alg ] required only around 20 hours on the author s laptop computer .",
    "empirically , increasing @xmath14 by one seems to approximately double the run time of algorithm  [ pow2alg ] .",
    "this suggests that perhaps algorithm  [ pow2alg ] runs in time @xmath165 , which would be better than the @xmath166 bound coming from applying existing methods @xcite to compute the complexity of @xmath86 .    for algorithm  [ stabalg ]",
    ", the run time seems to be determined more by the size of @xmath167 ( or by the size of @xmath94 , in the case of algorithm  [ genalg ] ) , rather than by the size of @xmath1 , since it seems that most of the work consists of building the sets of low - defect polynomials , rather than checking if @xmath1 is represented . for this reason , computing @xmath0 via algorithm  [ genalg ] is frequently much slower than using existing methods , even though it is much faster for powers of @xmath8 . note that strictly speaking , @xmath94 can be bounded in terms of @xmath1 , since @xmath168 but as mentioned earlier , this may be a substantial overestimate .",
    "so it is worth asking the question :    what is the time complexity of algorithm  [ pow2alg ] , for computing @xmath88 and @xmath87 ?",
    "what is the time complexity of of algorithm  [ stabalg ] ( with @xmath169 , for computing @xmath6 and @xmath57 ? what is the time complexity of algorithm  [ genalg ] ( with @xmath162 ) , for computing the values of @xmath170 for a given @xmath1 and all @xmath171 ?",
    "what if @xmath161 may be finite ? how do these depend on the parameter @xmath156 ?",
    "what if @xmath156 is an input ?",
    "although we have now given a means to compute @xmath6 , we have not provided any explicit upper bound on it .",
    "the same is true for the quantity @xmath172 which is another way of measuring `` how unstable '' the number @xmath1 is , and which is also now computable due to theorem  [ frontpagethm ] .",
    "we also do not have any reliable method of generating unstable numbers with which to demonstrate lower bounds .",
    "empirically , large instabilities  measured either by @xmath6 or by @xmath173  seem to be rare .",
    "this statement is not based on running algorithm  [ stabalg ] on many numbers to determine their stability , as that is quite slow in general , but rather on simply computing @xmath0 for @xmath174 and then checking @xmath0 , @xmath175 , @xmath176 ,  , and guessing that @xmath1 is stable if no instability is detected before the data runs out , a method that can only ever put lower bounds on @xmath6 and @xmath173 , never upper bounds .",
    "still , numbers that are detectably unstable at all seem to be somewhat rare , although they still seem to make up a positive fraction of all natural numbers ; namely , around @xmath177 . numbers that are more than merely unstable ",
    "having @xmath178 or @xmath179  are rarer .",
    "the largest lower bounds on @xmath6 or @xmath173 for a given @xmath1 encountered based on these computations are @xmath47 , which , as mentioned earlier , has @xmath46 and thus @xmath180 ; and @xmath181 numbers , the smallest of which is @xmath182 , which have @xmath183 and thus @xmath184 .",
    "finding @xmath1 where both @xmath6 and @xmath173 are decently large is hard ; for instance , these computations did not turn up any @xmath1 for which it could be seen that both @xmath185 and @xmath186 .",
    "( see table  [ droptable ] for more . )",
    "it s not even clear whether @xmath6 or @xmath173 can get arbitrarily large , or are bounded by some finite constant , although there s no clear reason why the latter would be so .",
    "still , this is worth pointing out as a question :    what is the natural density of the set of unstable numbers ? what is an explicit upper bound on @xmath6 , or on @xmath173 ? can @xmath6 and @xmath173 get arbitrarily large , or are they bounded ?",
    "further questions along these lines suggest themselves , but these questions seem difficult enough , so we will stop this line of inquiry there for now .",
    ".numbers that seem to have unusual drop patterns . here , the `` drop pattern '' of @xmath1 is the list of values @xmath187 , or equivalently @xmath188 , up until the point where this is always zero .",
    "this table is empirical , based on a computation of @xmath0 for @xmath174 ; it s possible these numbers have later drops further on",
    ". numbers which are divisible by @xmath35 are not listed . [ cols=\"<,<\",options=\"header \" , ]     strictly speaking , it is possible to prove theorem  [ frontpagethm ] using algorithms based purely on the methods of @xcite , without actually using the `` truncation '' method of the paper @xcite . of course",
    ", one can not simply remove the truncation step from the algorithms here and get correct answers ; other checks are necessary to compensate .",
    "see appendix  [ impnotes ] for a brief discussion of this .",
    "however , while this is sufficient to prove theorem  [ frontpagethm ] , the algorithms obtained this way are simply too slow to be of any use . and without the method of truncation , one can not write algorithm  [ mainalg ] , without which proving theorem  [ smallunstab ] would be quite difficult",
    ". we will demonstrate further applications of the theorem  [ smallunstab ] and the method of truncation in future papers @xcite .",
    "we can also ask about the computational complexity of computing these functions in general , rather than just the specific algorithms here .",
    "as noted above , the best known algorithm for computing @xmath0 takes time @xmath93 .",
    "it is also known@xcite that the problem `` given @xmath1 and @xmath14 in binary , is @xmath91 ? '' is in the class @xmath189 , because the size of a witness is @xmath190 .",
    "( this problem is not known to be @xmath189-complete . )",
    "however , it s not clear whether the problem `` given @xmath1 and @xmath14 in binary , is @xmath191 ? ''",
    "is in the class @xmath189 , because there s no obvious bound on the size of a witness .",
    "it is quite possible that it could be proven to be in @xmath189 , however , if an explicit upper bound could be obtained on @xmath6 .",
    "we can also consider the problem of computing the defect ordering , i.e. , `` given @xmath192 and @xmath193 in binary , is @xmath194 ? ''",
    "; the significance of this problem is that the set of all defects is in fact a well - ordered set @xcite with order type @xmath195 .",
    "this problem lies in @xmath196 in the polynomial hierarchy@xcite .",
    "the paper @xcite also defined the _ stable defect _ of @xmath1 :    [ dftstearlydef ] the _ stable defect _ of @xmath1 , denoted @xmath197 , is @xmath198    ( we will review the stable defect and its properties in section  [ subsecdft ] . )",
    "thus we get the problem of , `` given @xmath192 and @xmath193 in binary , is @xmath199 ? ''",
    "the image of @xmath200 is also well - ordered with order type @xmath195 , but until now it was not known that this problem is computable . but",
    "theorem  [ frontpagethm ] shows that it is , and so we can ask about its complexity . again , due to a lack of bounds on @xmath6 , it s not clear that this lies in @xmath196 .",
    "we can also ask about the complexity of computing @xmath6 , or @xmath173 ( which , conceivably , could be easier than @xmath0 or @xmath57 , though this seems unlikely ) , or , perhaps most importantly , of computing a set @xmath102 for a given @xmath96 . note that in this last case , it need not be the set @xmath102 found by algorithm  [ mainalg ] here ; we just want any set satisfying the required properties  a _ good covering _ of @xmath201 , as we call it here ( see definition  [ goodcover ] ) . of course",
    ", we must make a restriction on the input for this last question , as one can not actually take arbitrary real numbers as input ; perhaps it would be appropriate to restrict to @xmath98 of the form @xmath202 we summarize :    what is the complexity of computing @xmath0 ? what is the complexity of computing @xmath57 ?",
    "what is the complexity of computing the difference @xmath173 ? what is the complexity of computing the defect ordering @xmath194 ?",
    "what is the complexity of computing the stable defect ordering @xmath203 ? what is the complexity of computing the stabilization length @xmath6 ?    given @xmath204 , with @xmath205 and @xmath206 , what is the complexity of computing a good covering @xmath102 of @xmath201 ?",
    "in this section we will review the results of @xcite and @xcite regarding the defect @xmath94 , the stable complexity @xmath57 , and low - defect polynomials .",
    "first , some basic facts about the defect :    [ oldprops ] we have :    1 .   for all @xmath1 , @xmath207 .",
    "2 .   for @xmath2 , @xmath208 , with equality",
    "if and only if @xmath209 . the difference @xmath210 is a nonnegative integer .",
    "a number @xmath1 is stable if and only if for any @xmath2 , @xmath211 .",
    "if the difference @xmath212 is rational , then @xmath213 for some integer @xmath14 ( and so @xmath214 ) . 5 .",
    "given any @xmath1 , there exists @xmath14 such that @xmath56 is stable .",
    "6 .   for a given defect @xmath156 , the set @xmath215 has either the form @xmath216 for some @xmath1 and @xmath161 , or the form @xmath217 for some @xmath1 .",
    "this latter occurs if and only if @xmath156 is the smallest defect among @xmath218 for @xmath219 . 7",
    "@xmath220 , and for @xmath39 , @xmath221 .",
    "no other integers occur as @xmath94 for any @xmath1 .",
    "8 .   if @xmath222 and @xmath1 is stable , then so is @xmath48",
    ".    parts ( 1 ) through ( 7 ) , excepting part ( 3 ) , are just theorem  2.1 from @xcite .",
    "part ( 3 ) is proposition  12 from @xcite , and part ( 8) is proposition  3.1 from @xcite .",
    "the paper @xcite also defined the notion of a _ stable defect _ :    we define a _ stable defect _ to be the defect of a stable number .",
    "because of part ( 9 ) of theorem  [ oldprops ] , this definition makes sense ; a stable defect @xmath156 is not just one that is the defect of some stable number , but one for which any @xmath1 with @xmath223 is stable .",
    "stable defects can also be characterized by the following proposition from @xcite :    [ modz1 ] a defect @xmath156 is stable if and only if it is the smallest defect @xmath224 such that @xmath225 .",
    "we can also define the _ stable defect _ of a given number , which we denote @xmath197 .",
    "( we actually already defined this in definition  [ dftstearlydef ] , but let us disregard that for now and give a different definition ; we will see momentarily that they are equivalent . )    for a positive integer @xmath1 , define the _ stable defect",
    "_ of @xmath1 , denoted @xmath197 , to be @xmath218 for any @xmath14 such that @xmath56 is stable .",
    "( this is well - defined as if @xmath56 and @xmath59 are stable , then @xmath226 implies @xmath227 , and so does @xmath228 . )",
    "note that the statement `` @xmath156 is a stable defect '' , which earlier we were thinking of as `` @xmath229 for some stable @xmath1 '' , can also be read as the equivalent statement `` @xmath230 for some @xmath1 '' .",
    "we then have the following facts relating the notions of @xmath0 , @xmath94 , @xmath57 , and @xmath197 :    [ stoldprops ] we have :    1 .",
    "@xmath231 2 .",
    "@xmath197 is the smallest defect @xmath156 such that @xmath232 .",
    "3 .   @xmath233 4 .",
    "@xmath234 5 .",
    "@xmath235 , with equality if and only if @xmath1 is stable",
    "@xmath236 , with equality if and only if @xmath1 is stable .",
    "these are just propositions  3.5 , 3.7 , and 3.8 from @xcite .",
    "as has been mentioned in section  [ introdetail ] , we are going to represent the set @xmath237 by substituting in powers of @xmath35 into certain multilinear polynomials we call _ low - defect polynomials_. low - defect polynomials come from particular sorts of expressions we will call _ low - defect expressions_. we will associate with each polynomial or expression a `` base complexity '' to from a _ low - defect pair_. in this section we will review the properties of these polynomials and expressions .",
    "first , their definition :    a _ low defect expression _ is defined to be a an expression in positive integer constants , @xmath238 , @xmath239 , and some number of variables , constructed according to the following rules :    1 .",
    "any positive integer constant by itself forms a low - defect expression .",
    "2 .   given two low - defect expressions using disjoint sets of variables , their product is a low - defect expression .",
    "if @xmath240 and @xmath241 are low - defect expressions , we will use @xmath242 to denote the low - defect expression obtained by first relabeling their variables to disjoint and then multiplying them .",
    "3 .   given a low - defect expression @xmath243 , a positive integer constant @xmath244 , and a variable @xmath19 not used in @xmath243 , the expression @xmath245 is a low - defect expression .",
    "( we can write @xmath246 if we do not know in advance that @xmath19 is not used in @xmath243 . )",
    "we also define an _ augmented low - defect expression _ to be an expression of the form @xmath247 , where @xmath243 is a low - defect expression and @xmath19 is a variable not appearing in @xmath243",
    ". if @xmath243 is a low - defect expression , we also use @xmath248 to denote the low - defect @xmath249 .    note",
    "that we do not really care about what variables a low - defect expression is in  if we permute the variables of a low - defect polynomial or replace them with others , we will regard the result as an equivalent low - defect expression .",
    "we also define the complexity of a low - defect expression :    the _ complexity _ of a low - defect expression @xmath243 , denoted @xmath250 , is the sum of the complexities of all the constants used in @xmath243 .",
    "low - defect [ expression ] pair _ is an ordered pair @xmath251 where @xmath243 is a low - defect expression , and @xmath14 is a whole number with @xmath252 .",
    "the reason for introducing the notion of a `` low - defect pair '' is that we may not always know the complexity of a given low - defect expression ; frequently , we will only know an upper bound on it . for more theoretical applications , one does not always need to keep track of this , but since here we are concerned with computation , we need to keep track",
    ". one can , of course , always compute the complexity of any low - defect expression one is given ; but to do so may be computationally expensive , and it is easier to simply keep track of an upper bound .",
    "( indeed , for certain applications , one may actually want to keep track of more detailed information , such as an upper bound on each constant individually ; see appendix  [ impnotes ] for more on this . )",
    "one can then evaluate these expressions to get polynomials :    a _ low - defect polynomial _ is a polynomial @xmath253 obtained by evaluating a low - defect expression @xmath243 . if @xmath251 is a low - defect [ expression ] pair",
    ", we day @xmath254 is a low - defect [ polynomial ] pair .",
    "we use @xmath255 to refer to the polynomial obtained by evaluating @xmath248 , and call it an _ augmented low - defect polynomial_. for convenience , if @xmath254 is a low - defect pair , we may say `` the degree of @xmath254 '' to refer to the degree of @xmath253 .",
    "typically , for practical use , what we want is not either low - defect expressions or low - defect polynomials .",
    "low - defect polynomials do not retain enough information about how they were made .",
    "for instance , in the algorithms below , we will frequently want to substitute in values for the `` innermost '' variables in the polynomial ; it is shown in @xcite that this is well - defined even if multiple expressions can give rise to the same polynomial . however , if all one has is the polynomial rather than the expression which generated it , determining which variables are innermost may require substantial computation .",
    "on the other hand , low - defect expressions contain unneeded information ; there is little practical reason to distinguish between , e.g. , @xmath256 and @xmath257 , or between @xmath258 and @xmath259 , or @xmath260 and @xmath261 .",
    "a useful practical representation is what @xcite called a _ low - defect tree _ :    given a low - defect expression @xmath243 , we define a corresponding _ low - defect tree _",
    "@xmath262 , which is a rooted tree where both edges and vertices are labeled with positive integers .",
    "we build this tree as follows :    1 .",
    "if @xmath243 is a constant @xmath1 , @xmath262 consists of a single vertex labeled with @xmath1 .",
    "2 .   if @xmath263 , with @xmath264 the tree for @xmath243 , @xmath262 consists of @xmath264 with a new root attached to the root of @xmath264 .",
    "the new root is labeled with a @xmath15 , and the new edge is labeled with @xmath244 .",
    "3 .   if @xmath265 , with @xmath266 and @xmath267 the trees for @xmath240 and @xmath241 respectively , we construct @xmath243 by `` merging '' the roots of @xmath240 and @xmath241  that is to say , we remove the roots of @xmath240 and @xmath241 and add a new root , with edges to all the vertices adjacent to either of the old roots ; the new edge labels are equal to the old edge labels .",
    "the label of the new root is equal to the product of the labels of the old roots .",
    "see figure  [ treeexamp ] for an example illustrating this construction .",
    "child node[circle , draw ] @xmath15 child node[circle , draw ] @xmath268 child node[circle , draw ] @xmath35 edge from parent node[left ] @xmath15 edge from parent node[left ] @xmath269 child node[circle , draw ] @xmath8 edge from parent node[right]@xmath15 edge from parent node[right]@xmath15 ;    this will still contain information that is unnecessary for our purposes  for instance , this representation still distinguishes between @xmath270 and @xmath271  but it is on the whole a good medium between including too much and including too little . while the rest of the paper will discuss low - defect expressions and low - defect polynomials , we assume these are being represented as trees , for convenience .",
    "having now discussed the definition and representation of low - defect expressions and polynomials , let us now discuss their properties .",
    "note first that the degree of a low - defect polynomial is also equal to the number of variables it uses ; see proposition  [ polystruct ]",
    ". we will often refer to the `` degree '' of a low - defect pair @xmath272 ; this refers to the degree of @xmath253 .",
    "also note that augmented low - defect polynomials are never low - defect polynomials ; as we will see in a moment ( proposition  [ polystruct ] ) , low - defect polynomials always have nonzero constant term , whereas augmented low - defect polynomials always have zero constant term .",
    "low - defect polynomials are multilinear polynomials ; indeed , they are read - once polynomials ( in the sense of for instance @xcite ) , as low - defect expressions are easily seen to be read - once expressions .    in @xcite",
    "were proved the following propositions about low - defect pairs :    [ polystruct ] suppose @xmath253 is a low - defect polynomial of degree @xmath129 .",
    "then @xmath253 is a polynomial in the variables @xmath273 , and it is a multilinear polynomial , i.e. , it has degree @xmath15 in each of its variables .",
    "the coefficients are non - negative integers .",
    "the constant term is nonzero , and so is the coefficient of @xmath274 , which we will call the _ leading coefficient _ of @xmath253 .",
    "[ basicub ] if @xmath272 is a low - defect pair of degree @xmath129 , then @xmath275 and @xmath276    this is a combination of proposition  4.5 and corollary  4.12 from @xcite .    because of this",
    ", it makes sense to define :    given a low - defect pair @xmath272 ( say of degree @xmath129 ) and a number @xmath277 , we will say that @xmath272 _ efficiently @xmath35-represents _",
    "@xmath277 if there exist nonnegative integers @xmath278 such that @xmath279 we will say @xmath280 efficiently @xmath35-represents @xmath277 if there exist @xmath281 such that @xmath282 more generally , we will also say @xmath253 @xmath35-represents @xmath277 if there exist nonnegative integers @xmath278 such that @xmath283 . and similarly with @xmath255 .",
    "we will also use the same terminology regarding low - defect expressions .    note that if @xmath243 is a low - defect expression and @xmath284 ( or @xmath285 ) efficiently @xmath35-represents some @xmath277 , then @xmath286 ( respectively , @xmath287 efficiently @xmath35-represents @xmath277 , which means that in order for @xmath284 ( or @xmath285 to @xmath35-represent anything efficiently at all , we must have @xmath288 . and",
    "if @xmath253 is a low - defect polynomial and @xmath272 ( or @xmath289 efficiently @xmath35-represents some @xmath277 , then @xmath290 must be equal to the smallest @xmath250 among any low - defect expression @xmath243 that evaluates to @xmath253 ( which in @xcite and @xcite was denoted @xmath291 ) .",
    "but , again , it is still worth using low - defect pairs rather than just low - defect polynomials and expressions since we do not want to spend time computing the value @xmath250 .    for this reason it makes sense to use `` @xmath243 efficiently @xmath35-represents @xmath277 '' to mean `` some @xmath284 efficiently @xmath35-represents @xmath277 '' or equivalently `` @xmath286",
    "efficiently @xmath35-reperesents @xmath277 '' .",
    "similarly with @xmath248 .    in keeping with the name , numbers @xmath35-represented by low - defect polynomials , or their augmented versions , have bounded defect .",
    "let us make some definitions first :    given a low - defect pair @xmath272 , we define @xmath292 , the defect of @xmath272 , to be @xmath293 , where @xmath32 is the leading coefficient of @xmath253 .    given a low - defect pair @xmath272 of degree @xmath129 , we define @xmath294    then we have :    [ dftbd ] let @xmath272 be a low - defect pair of degree @xmath129 , and let @xmath281 be nonnegative integers .    1 .",
    "we have @xmath295 and the difference is an integer .",
    "we have @xmath296 and if @xmath297 , this inequality is strict .",
    "the function @xmath298 is strictly increasing in each variable , and @xmath299    this is a combination of proposition  4.9 and corollary  4.14 from @xcite along with proposition  2.14 from @xcite .",
    "indeed , one can make even stronger statements than ( 3 ) above . in @xcite , a partial order",
    "is placed on the variables of a low - defect polynomial @xmath253 , where , for variables @xmath19 and @xmath300 in @xmath253 , we say @xmath301 if @xmath19 appears `` deeper '' in a low - defect expression @xmath253 for than @xmath300 .",
    "formally ,    [ defnest ] let @xmath243 be a low - defect expression .",
    "let @xmath19 and @xmath300 be variables appearing in @xmath243 .",
    "we say that @xmath301 under the nesting ordering for @xmath243 if @xmath19 appears in the smallest low - defect subexpression of @xmath243 that contains @xmath300 .",
    "( if @xmath253 is a low - defect polynomial , it can be shown that the nesting order is independent of the low - defect expression used to generate it ; see proposition  3.18 from @xcite . )    for instance , if @xmath302 , one has @xmath303 and @xmath304 but no other relations .",
    "it s then shown @xcite[proposition  4.6 ] that ( 3 ) above is true even if only the minimal ( i.e. , innermost ) variables are allowed to approach infinity .",
    "that is to say :    [ minlimit ] let @xmath272 be a low - defect pair of degree @xmath129 .",
    "say @xmath305 , for @xmath306 , are the minimal variables of @xmath253 .",
    "then @xmath307 ( where the other @xmath308 remain fixed ) .",
    "note that if we store the actual low - defect expression rather than just the resulting polynomial , finding the minimal variables is easy .    with this",
    ", we have the basic properties of low - defect polynomials .",
    "finally , before we begin listing algorithms , let us state precisely what precisely the algorithms are for . we will first need the notion of a _ leader _ :",
    "a natural number @xmath1 is called a _ leader _ if it is the smallest number with a given defect . by part ( 6 ) of theorem  [ oldprops ] , this is equivalent to saying that either @xmath309 , or , if @xmath310 , then @xmath311 , i.e. , @xmath312 .",
    "let us also define :    for any real @xmath313 , define the set of _ @xmath129-defect numbers _",
    "@xmath237 to be @xmath314 define the set of _",
    "@xmath129-defect leaders _",
    "@xmath315 to be @xmath316    these sets are related by the following proposition from @xcite :    [ arbr ] for every @xmath317 , there exists a unique @xmath318 and @xmath2 such that @xmath319 and @xmath222 ; then @xmath320 .",
    "because of this , if we want to describe the set @xmath237 , it suffices to describe the set @xmath315 .    as mentioned earlier , what we want to do is to be able to write every number in @xmath237 as @xmath104 for some low - defect polynomial @xmath253 drawn from a finite set depending on @xmath129 .",
    "in fact , we want to be able to write every number in @xmath315 as @xmath321 , with the same restrictions .",
    "so we define :    [ coverdef ] for @xmath313 , a finite set @xmath322 of low - defect pairs will be called a _ covering set _ for @xmath315 if every @xmath323 can be efficiently @xmath35-represented by some pair in @xmath322 .",
    "( and hence every @xmath317 can be efficiently represented by some @xmath280 with @xmath324 . )",
    "of course , this is not always enough ; we do nt just want that every number in @xmath237 can be represented in this way , but also that every number generated this way is in @xmath237 .",
    "so we define :    [ goodcover ] for @xmath313 , a finite set @xmath322 of low - defect pairs will be called a _ good covering _ for @xmath315 if every @xmath323 can be efficiently @xmath35-represented by some pair in @xmath322 ( and hence every @xmath317 can be efficiently represented by some @xmath280 with @xmath324 ) ; for every @xmath325 , @xmath326 , with this being strict if @xmath327 .    with this , it makes sense to state the following theorem from @xcite :    [ mainthm ] for any real number @xmath328 , there exists a good covering of @xmath315 .",
    "this is theorem  4.9 from @xcite rewritten in terms of definition  [ goodcover ] .",
    "computing good coverings , then , will be one of the primary subjects for the rest of the paper .    before we continue with that , however , it is also worth noting here the following proposition from @xcite :    [ polycpxbd ] let @xmath272 be a low - defect pair of degree @xmath14 , and suppose that @xmath32 is the leading coefficient of @xmath253",
    ". then @xmath329 . in particular ,",
    "@xmath330 .",
    "this is a combination of proposition  3.24 and corollary  3.25 from @xcite .",
    "this implies that in any good covering of @xmath315 , all polynomials have degree at most @xmath331 .",
    "now let us discuss the `` building - up '' method from @xcite and @xcite that forms one - half the core of the algorithm .",
    "the second `` filtering - down '' half , truncation , will be described in section  [ secalgos ] .",
    "this section will describe how to compute covering sets for @xmath315 ( see definition  [ coverdef ] ) ; the next section will describe how to turn them into good coverings .",
    "note however that the results of the above sections and previous papers deal with real numbers , but real numbers can not be represented exactly in a computer .",
    "hence , we will for the rest of this section fix a subset @xmath332 of the real numbers on which we can do exact computation . for concreteness",
    ", we will define    the set @xmath332 is the set of all real numbers of the form @xmath333 , where @xmath334 and @xmath129 are rational and @xmath1 is a natural number .",
    "this will suffice for our purposes ; however it is worth noting that all these algorithms will work just as well with a larger set of allowed numbers , so long as it supports all the required operations .",
    "note that since the algorithms in both this section and later sections consist , in some cases , of simply using the methods described proofs of theorems in @xcite and @xcite , we will , in these cases , not give detailed proofs of correctness ; we will simply direct the reader to the proof of the corresponding theorem .",
    "we will include proofs of correctness only where we are not directly following the proof of an earlier theorem .",
    "the theorems of @xcite that build up covering sets for @xmath315 do so inductively ; they require first picking a step size @xmath99 and then determining covering sets @xmath337 for natural numbers @xmath14 .",
    "so first , we need a base case  an algorithm to compute @xmath338 .",
    "fortunately , this is given by the following theorem from @xcite :    [ finite ] for every @xmath156 with @xmath339 , the set of leaders @xmath338 is a finite set .",
    "more specifically , the list of @xmath1 with @xmath340 is as follows :",
    "@xmath341 for @xmath342 , of complexity @xmath343 and defect @xmath75 2 .",
    "@xmath344 for @xmath345 , of complexity @xmath346 and defect @xmath347 3 .",
    "@xmath348 for @xmath150 , of complexity @xmath349 and defect @xmath350 4 .",
    "@xmath351 for @xmath352 , of complexity @xmath353 and defect @xmath354 5 .",
    "@xmath355 of complexity @xmath356 and defect @xmath357 6 .",
    "@xmath358 of complexity @xmath359 and defect @xmath360 7 .",
    "@xmath361 for @xmath362 , of complexity @xmath363 and defect @xmath364    strictly speaking , we do not necessarily need this theorem to the same extent as @xcite needed it ; we only need it if we want to be able to choose step sizes @xmath156 with @xmath156 arbitrarily close to @xmath15 . in @xcite ,",
    "this was necessary to keep small the degrees of the polynomials ; larger steps translates into fewer steps , which translates into lower degree .",
    "however , in section  [ secalgos ] , we will introduce algorithms for performing truncation , as described in @xcite ; and with truncation , we can limit the degree without needing large steps ( see corollary  [ polycpxbd ] ) , allowing us to keep @xmath156 small if we so choose .",
    "for instance , in the attached implementation , we always use @xmath160 .",
    "nonetheless , one may wish to use larger @xmath156 , so this proposition is worth noting .",
    "the above theorem can be rephrased as our algorithm  [ startalg ] :    @xmath365 @xmath366 @xmath367 determine largest integer @xmath14 such that @xmath368 and @xmath369 @xmath370 determine largest integer @xmath14 such that @xmath371 and @xmath150 @xmath372 determine largest integer @xmath14 such that @xmath373 and @xmath352 @xmath374 @xmath375 @xmath376 determine largest integer @xmath14 for which @xmath377 @xmath378 @xmath262    the correctness of this algorithm is immediate from theorem  [ finite ] .",
    "now we record algorithm  [ buildalg ] , for computing a covering set for @xmath379 if we have ones already for @xmath380 .",
    "this algorithm is essentially the proof of theorem  4.10 from @xcite , though we have made a slight modification to avoid redundancy .",
    "@xmath381 , @xmath382 , @xmath383 a covering set for @xmath384 for @xmath385 @xmath386 a covering set for @xmath379 @xmath387 @xmath388 compute the set @xmath389 , and the complexities of its elements ; let @xmath390 be the set @xmath391 compute the set @xmath392 @xmath393 @xmath394 @xmath395 @xmath396 @xmath397 @xmath398",
    "@xmath399 @xmath386    if we examine the proof of theorem  4.10 from @xcite , it actually proves the following statement : suppose that @xmath339 and that @xmath36 .",
    "further suppose that @xmath400 are covering sets for @xmath338 , @xmath401 , respectively .",
    "then we can build a covering set @xmath402 for @xmath379 as follows :    1 .   if @xmath403 , then for @xmath404 and @xmath405 with @xmath406 and @xmath407 we include @xmath408 in @xmath402 ; + while if @xmath409 , then for @xmath410 , we include @xmath411 and @xmath412 in @xmath413 .",
    "2 .   for @xmath414 and",
    "any solid number @xmath415 with @xmath416 , we include @xmath417 in @xmath402 .",
    "3 .   for @xmath414 , any solid number @xmath415 with @xmath416 , and any @xmath418",
    ", we include @xmath419 in @xmath402 .",
    "4 .   for all @xmath420",
    ", we include @xmath421 in @xmath402 .",
    "5 .   for all @xmath420 and @xmath418",
    ", we include @xmath422 in @xmath402 .",
    "algorithm  [ buildalg ] is , for the most part , exactly this statement .",
    "the only difference is the removal of the pairs @xmath423 and @xmath424 from the possibilities of things to multiply by ; this step needs additional justification . for @xmath424 ,",
    "this is because no number @xmath1 can be most - efficiently represented as @xmath425 ; if @xmath272 is a low - defect pair , then the low - defect pair @xmath426 can not efficiently @xmath35-represent anything , as anything it @xmath35-represents is also @xmath35-represented by the pair @xmath272 . for @xmath423",
    ", there are two possibilities . if @xmath66 is a number which is @xmath35-represented by by @xmath427 , then either the representation as @xmath428 is most - efficient or it is not .",
    "if it is , then @xmath66 is not a leader , and so not in any @xmath384 , and thus we do not need it to be @xmath35-represented .",
    "if it is not , then it is not efficiently @xmath35-represented by @xmath427 .",
    "so these particular pairs do not need to be multiplied by , and the algorithm still works .",
    "we can now put the two of these together to form algorithm  [ algcover ] , for computing a covering set for @xmath315 .",
    "if we look ahead to algorithm  [ manytruncalg ] , we can turn it into a good covering .",
    "@xmath430 @xmath431 is a covering set for @xmath315 choose a step size @xmath382 let @xmath266 be the output of algorithm  [ startalg ] for @xmath156 use algorithm  [ buildalg ] to compute a covering set @xmath432 for @xmath379 from our covering sets @xmath433 for @xmath384 optional step : do other things to @xmath432 that continue to keep it a covering set for @xmath379 while making it more practical to work with . for instance , one may use algorithm  [ manytruncalg ] to turn it into a good covering of @xmath379 , or one may remove elements of @xmath432 that are redundant ( i.e. , if one has @xmath272 and @xmath434 in @xmath432 such that any @xmath1 which is efficiently @xmath35-represented by @xmath272 is also efficiently represented by @xmath434 , one may remove @xmath272 ) @xmath435 @xmath431    assuming the correctness of algorithm  [ startalg ] and algorithm  [ buildalg ] , the correctness of algorithm  [ algcover ] follows immediately .",
    "again , this is just making use of the proof of theorem  4.10 from @xcite .",
    "we have now completed the `` building - up '' half of the method ; in this section we will describe the `` filtering - down '' half .",
    "the algorithms here will be based on the proofs of the theorems in @xcite , so we will once again refer the reader to said proofs in our proofs of correctness .      the first step in being able to filter down is algorithm  [ algtrunc ] , for truncating a given polynomial to a given defect :    @xmath272 is a low - defect pair , @xmath436 @xmath262 is the truncation of @xmath272 to the defect @xmath98 @xmath437 @xmath438 @xmath437 find the smallest @xmath439 for which @xmath440 , where @xmath441 if @xmath442 is minimal in the nesting ordering and @xmath443 otherwise @xmath438 let @xmath444 be @xmath253 with @xmath445 substituted in for @xmath442 and let @xmath446 recursively apply algorithm  [ algtrunc ] to @xmath434 and @xmath98 to obtain a set @xmath264 @xmath447 @xmath431    this is an algorithmic version of the method described in the proof of theorem  4.8 from @xcite ; see that for details .",
    "( note that @xmath439 is guaranteed to exist by proposition  [ minlimit ] ; one can find it by brute force or slight variants . )",
    "there is a slight difference between the two methods in that the method described there , rather than forgetting @xmath272 when it recursively applies the method to @xmath434 and directly generating the set @xmath262 , instead generates a set of values for variables that may be substituted into @xmath253 to yield the set @xmath262 , only performing the substitution at the end .",
    "this is the same method , but without keeping track of extra information so that it can be written in a more straightforwardly recursive manner .",
    "if we can truncate one polynomial , we can truncate many of them ( algorithm  [ manytruncalg ] ) :    @xmath448 , @xmath313 , @xmath449 a covering set for @xmath315 @xmath322 is a good covering of @xmath315 @xmath450 use algorithm  [ algtrunc ] to truncate @xmath272 to @xmath129 ; call the result @xmath451 @xmath452 @xmath322    this is an algorithmic version of the method described in the proof of theorem  4.9 from @xcite  that if one has a covering set for @xmath315 and truncates each of its elements to the defect @xmath129 , one obtains a good covering of @xmath315 .",
    "it can also be seen as an application of the correctness of algorithms  [ buildalg ] and [ algtrunc ] .",
    "we can then put this together into algorithm  [ mainalg ] , for computing a good covering of @xmath315 :    @xmath448 , @xmath313 @xmath322 is a good covering of @xmath315 use algorithm  [ algcover ] to compute a covering set @xmath449 for @xmath315 use algorithm  [ manytruncalg ] to compute a good covering @xmath322 for @xmath315 from @xmath449 @xmath449    this follows immediately from the correctness of algorithms  [ algcover ] and [ manytruncalg ] .",
    "we ve now described how to compute good coverings of @xmath315 .",
    "but it still remains to show how to use this to compute other quantities of interest , such as @xmath6 and @xmath57 .",
    "we address this in the next section .",
    "in order to compute @xmath6 and @xmath57 , we re going to need to have to be able to tell , algorithmically , whether , given a low - defect polynomial @xmath253 and a a number @xmath1 , there exists @xmath2 such that @xmath253 @xmath35-represents @xmath56 .",
    "if we simply want to know whether @xmath253 @xmath35-represents @xmath1 , this is easy ; because @xmath453 we have an upper bound on how large the @xmath308 can be and we can solve this with brute force . however , if we want to check whether it represents @xmath56 for any @xmath14 , clearly this will not suffice , as there are infinitely many possibilities for @xmath14 .",
    "we will need a lemma to narrow them down :    [ maxv3 ] let @xmath253 be a polynomial in @xmath129 variables with nonnegative integer coefficients and nonzero constant term ; write @xmath454 with @xmath455 positive integers and @xmath456 .",
    "let @xmath457 be a natural number and let @xmath458 denote the number of times @xmath1 is divisible by @xmath415 .",
    "then for any @xmath459 , we have @xmath460 in particular , this applies when @xmath253 is a low - defect polynomial and @xmath461 .",
    "the number @xmath462 is the sum of the constant term @xmath463 ( call it simply @xmath464 ) and numbers of the form @xmath465 where the @xmath466 are simply the remaining @xmath455 enumerated in some order ( say @xmath467 ) . since we can choose the order , assume that @xmath468 .",
    "so consider forming the number @xmath462 by starting with @xmath464 and adding in the numbers @xmath465 one at a time .",
    "let @xmath469 denote the sum @xmath470 , so @xmath471 and @xmath472 .",
    "we check that for any @xmath473 , we have @xmath474    before proceeding further , we observe that if for some @xmath473 we have @xmath475 , then by assumption , for all @xmath476 , @xmath477 . now in general , if @xmath478 , then @xmath479 .",
    "so we can see by induction that for all @xmath480 , @xmath481 : this is true for @xmath482 , and if it is true for @xmath483 , then @xmath484 and so @xmath485 .",
    "so let @xmath486 be the smallest @xmath473 such that @xmath487 .",
    "( if no such @xmath473 exists , take @xmath488 . )",
    "then we first prove that equation   holds for @xmath489 .    in the case that @xmath489 , we will in fact prove the stronger statement that @xmath490 this is stronger as in general it is true that @xmath491 . for @xmath492",
    "this is immediate .",
    "so suppose that this is true for @xmath473 and we want to check it for @xmath493 , with @xmath494 . since @xmath494 , we have that @xmath495 . from this we can conclude the inequality @xmath496    now , we also know that @xmath497 and we can observe using above that @xmath498 we also know that @xmath499 as @xmath500 .",
    "so we can conclude using equation   that @xmath501 as desired .",
    "having proved equation   for @xmath489 , it then immediately follows for all @xmath473 , as by the above , for @xmath502 , @xmath503 this proves the claim .      with this in hand , we can now write down algorithm  [ anykalg ] for determining if @xmath253 @xmath35-represents any @xmath56 :    @xmath272 a low - defect pair , @xmath1 a natural number @xmath431 is the set of @xmath505 such that there exist whole numbers @xmath506 with @xmath507 and @xmath508 @xmath509 determine @xmath510 such that for any @xmath511 , one has @xmath512",
    "@xmath513 @xmath431    once we have picked a @xmath510 ( which can be found using lemma  [ maxv3 ] ) , it suffices to check if @xmath253 represents @xmath56 with @xmath514 . by proposition  [ polystruct ] , for any @xmath515 , we have @xmath516 and so it suffices to check it for tuples @xmath506 with @xmath517 .",
    "there are only finitely many of these and so this can be done by brute force , and this is exactly what the algorithm does .      now , at last , we can write down algorithm  [ stabalg ] , for computing @xmath6 and @xmath57 .",
    "we assume that in addition to @xmath1 , we are given @xmath161 , an upper bound on @xmath0 , which may be @xmath518 .",
    "running algorithm  [ stabalg ] with @xmath162 is always a valid choice ; alternatively , one may compute @xmath0 or an upper bound on it before applying algorithm  [ stabalg ] .",
    "@xmath1 a natural number , @xmath519 , @xmath520 @xmath521 choose a step size @xmath382 let @xmath129 be the smallest nonnegative integer , or @xmath518 , such that @xmath522 @xmath523 @xmath524 let @xmath525 be the output of algorithm 1 for @xmath156 use algorithm  [ buildalg ] to compute a covering @xmath383 of @xmath384 from coverings @xmath526 of @xmath527 for @xmath528 use algorithm  [ manytruncalg ] to turn @xmath383 into a good covering optional step : remove redundancies from @xmath383 as in algorithm  [ buildalg ] let @xmath529 be the output of algorithm  [ anykalg ] on @xmath272 and @xmath1 @xmath530 @xmath531 @xmath532 let @xmath533 consist of the elements @xmath505 of @xmath390 that minimize @xmath534 choose @xmath535 that minimizes @xmath14 @xmath536 @xmath537    this algorithm progressively builds up good covers @xmath383 of @xmath384 until it finds some @xmath473 such that there is some @xmath538 such that @xmath255 @xmath35-represents @xmath56 for some @xmath2 . to see that this is indeed what it is doing , observe that if @xmath539 then if @xmath540 , we may write @xmath541 and so @xmath253 itself @xmath35-represents some @xmath56 , while if @xmath542 , we may write @xmath543 and so @xmath255 @xmath35-represents @xmath1 itself . and",
    "this is exactly what the inner loop does ; it checks if @xmath253 @xmath35-represents any @xmath56 using algorithm  [ anykalg ] , and it checks if @xmath255 @xmath35-represents @xmath1 using brute force .",
    "now , if for a given @xmath473 we obtain @xmath544 , then that means that no @xmath56 is @xmath35-represented by any @xmath538 , and so for any @xmath14 , @xmath545 , that is , @xmath546 .",
    "conversely , if for a given @xmath473 we obtain @xmath390 nonempty , then that means that some @xmath56 is @xmath35-represented by some @xmath538 . since for any @xmath272",
    "we have @xmath547 ( and this is strict if @xmath327 ) , this means that @xmath548 , and so @xmath549 .",
    "so we see that if the algorithm exits the main loop with @xmath390 nonempty , it does so once has found some @xmath473 such that there exists @xmath14 with @xmath550 ; equivalently , once it has found some @xmath473 such that @xmath549 . or , equivalently , once it has found some @xmath473 such that @xmath551 .",
    "furthermore , note that @xmath552 must be a leader if @xmath553 , as otherwise @xmath554 would also be stable .",
    "so if @xmath553 , then @xmath552 must be efficiently @xmath35-represented by some @xmath538 .",
    "whereas if @xmath62 , then we only know that it is efficiently @xmath35-represented by some @xmath280 for some @xmath538 , but we also know @xmath555 .",
    "that is to say , the ordered pair @xmath556 must be in the set @xmath390 .",
    "in this case , where @xmath390 is nonempty , it remains to examine the set @xmath390 and pick out the correct candidate .",
    "each pair @xmath557 consists of some @xmath14 and some @xmath11 such that @xmath558 .",
    "this implies that @xmath559 and so the pair @xmath556 must be a pair @xmath505 for which the quantity @xmath560 , and hence the quantity @xmath534 , is minimized ; call this latter minimum @xmath561 .",
    "so @xmath562 ( note that this means that @xmath563 . )",
    "then the elements of @xmath533 are pairs @xmath564 with @xmath565 but we know also that @xmath566 so we conclude that for such a pair , @xmath567 . but",
    "this means that @xmath56 is stable , and so @xmath568 .",
    "but we know that @xmath6 is among the set of @xmath14 with @xmath569 , and so it is their minimum .",
    "thus , we can select the element @xmath535 that minimizes @xmath14 ; then @xmath570 , and we can take @xmath571 to find @xmath572 .",
    "this leaves the case where @xmath390 is empty . in this case",
    ", we must have that for all @xmath573 , and hence in particular for @xmath574 , no @xmath272 in @xmath383 @xmath35-represents any @xmath575 ; i.e. , no @xmath575 lies in @xmath576 , and hence , by proposition  [ arbr ] , no @xmath575 lies in @xmath577 .",
    "that is to say , for any @xmath14 , @xmath578 , and so @xmath579 since @xmath580 , and @xmath581 , we must have @xmath582 . since this is true for all @xmath2",
    ", we can conclude that @xmath1 is a stable number .",
    "so , @xmath1 is stable and @xmath583 , that is to say , @xmath62 and @xmath584 .",
    "we have now proven theorem  [ frontpagethm ] :    algorithm  [ stabalg ] , run with @xmath162 , gives us a way of computing @xmath6 and @xmath57 .",
    "then , to check if @xmath1 is stable , it suffices to check whether or not @xmath62 .",
    "this proves the theorem .",
    "but we re not done ; we can go further . as mentioned in section  [ introdetail ]",
    ", we can get more information if we go until we detect @xmath1 , rather than stopping as soon as we detect some @xmath56 .",
    "we now record algorithm  [ genalg ] , for not only determining @xmath6 and @xmath63 , but for determining all @xmath14 such that either @xmath585 or @xmath56 is a leader , and the complexities @xmath170 . by proposition",
    "[ arbr ] , this is enough to determine @xmath170 for all @xmath2 .",
    "one could also do this by using algorithm  [ stabalg ] to determine @xmath6 and then directly computing @xmath170 for all @xmath586 , but algorithm  [ genalg ] will often be faster .    @xmath1 a natural number , @xmath519 , @xmath520 @xmath533 the set of @xmath505 where either @xmath585 or @xmath362 and @xmath56 is a leader , and @xmath587 choose a step size @xmath382 let @xmath129 be the smallest nonnegative integer , or @xmath518 , such that @xmath522 @xmath523 @xmath524 let @xmath525 be the output of algorithm 1 for @xmath156 use algorithm  [ buildalg ] to compute a covering @xmath383 of @xmath384 from coverings @xmath526 of @xmath527 for @xmath528 use algorithm  [ manytruncalg ] to turn @xmath383 into a good covering optional step : remove redundancies from @xmath383 as in algorithm  [ buildalg ] determine @xmath510 such that for any @xmath511 , one has @xmath512 let @xmath529 be the output of algorithm  [ anykalg ] on @xmath272 and @xmath1 @xmath530 @xmath531 @xmath588 let @xmath589 let @xmath590 consist of the minimal elements of @xmath533 in the usual partial order let @xmath591 @xmath592    as in algorithm  [ stabalg ] , we are successively building up good coverings @xmath383 of @xmath384 , and for each one checking whether there is an @xmath538 and a @xmath2 such that @xmath280 @xmath35-represents @xmath56 .",
    "however , the exit condition on the loop is different ; ignoring for a moment the possibility of exiting due to @xmath593 , the difference is that instead of stopping once some @xmath56 is @xmath35-represented , we do not stop until @xmath1 itself is @xmath35-represented , or equivalently , @xmath594 .",
    "we ll use @xmath473 here to denote the value of @xmath473 when the loop exits .",
    "we want the set @xmath390 to have two properties : firstly , it should contain all the pairs @xmath505 we want to find .",
    "secondly , for any @xmath557 , we should have @xmath595 . for the first property ,",
    "observe that if @xmath56 is a leader and @xmath596 , then @xmath597 and so @xmath598 ; thus , @xmath56 ( being a leader ) is efficiently @xmath35-represented by some @xmath599 , and so if the loop exits due to @xmath593 , then @xmath600 . whereas if the loop exits due to @xmath601 , then note @xmath602 , and so @xmath56 ( again being a leader ) is efficiently @xmath35-represented by some @xmath603 , and so again @xmath604 .",
    "this leaves the case where @xmath585 .",
    "if the loop exits due to @xmath601 , then by choice of @xmath473 , @xmath1 is efficiently @xmath35-represented by some @xmath280 for some @xmath538 , so @xmath605 .",
    "whereas if the loop exits due to @xmath593 , then this means that @xmath606 , and so @xmath607 since we know @xmath608 , this implies @xmath583 , and so including @xmath609 in @xmath390 means @xmath605 .    for the second property , again , there are two ways a pair @xmath505 may end up in @xmath390 .",
    "one is that some low - defect pair @xmath272 @xmath35-represents the number @xmath610 , which , as in the proof of correctness for algorithm  [ stabalg ] , means @xmath595 .",
    "the other is that @xmath611 ; but in this case , @xmath608 by assumption .",
    "it then remains to isolate the pairs we want from the rest of @xmath390 .",
    "we will show that they are in fact precisely the minimal elements of @xmath390 under the partial order    @xmath612    say first that @xmath505 is one of the pairs we are looking for , i.e , either @xmath585 or @xmath56 is a leader , and @xmath587 .",
    "now suppose that that @xmath613 such that @xmath614 and @xmath615 .",
    "since @xmath613 , that means that @xmath616 . since @xmath614 ,",
    "we conclude that @xmath617 and hence that @xmath618 , so @xmath619 .",
    "now , if @xmath585 , then certainly @xmath620 ( and so @xmath621 ) ; otherwise , @xmath56 is a leader .",
    "suppose we had @xmath622 ; then since @xmath56 is a leader , that would mean @xmath623 and hence @xmath624 contrary to .",
    "so we conclude @xmath625 , and so @xmath505 is indeed minimal .",
    "conversely , suppose that @xmath505 is a minimal element of @xmath390 in this partial order .",
    "we must show that @xmath587 , and , if @xmath362 , that @xmath56 is a leader .",
    "choose @xmath614 as large as possible with either @xmath626 or @xmath627 a leader , so that @xmath628 . also , let @xmath629 ; by above , @xmath613 . since @xmath557 and @xmath630 , we know that @xmath631 and hence @xmath632 .",
    "since by assumption we also have @xmath614 , by the assumption of minimality we must have @xmath633 .",
    "but this means exactly that either @xmath585 or @xmath56 is a leader , and that @xmath634 as needed .      finally , before moving on to the results of applying these algorithms , we make note of one particular specialization of algorithm  [ stabalg ] , namely , the case where @xmath114 and @xmath635 .",
    "as was noted in section  [ discussion1 ] , this turns out to be surprisingly fast as a method of computing @xmath86 .",
    "we formalize it here :    @xmath36 an integer @xmath636 let @xmath637 be the result of applying algorithm  [ stabalg ] with @xmath114 and @xmath638 .",
    "@xmath637    this follows from the correctness of algorithm  [ stabalg ] and the fact that @xmath639 for @xmath39 .",
    "before we continue on to the results of applying these algorithms , let s make a few more notes on the stabilization length @xmath6 and the stable complexity @xmath57 , now that we have demonstrated how to compute them .",
    "we begin with the following inequality :    [ stabcpxineq ] for natural numbers @xmath192 and",
    "@xmath193 , @xmath640",
    ".    choose @xmath641 , @xmath642 , and @xmath439 such that @xmath643 , both @xmath644 are stable , and @xmath645 is also stable .",
    "then @xmath646    unfortunately , the analogous inequality for addition does not hold ; for instance , @xmath647 more examples can easily be found .    as was mentioned in section  [ discussion2 ]",
    ", we can measure the instability of the number @xmath1 by the quantity @xmath173 , defined as @xmath648    we can also measure of how far from optimal a factorization is  and , due to proposition  [ stabcpxineq ] , a stabilized version :    let @xmath649 be positive integers , and let @xmath277 be their product .",
    "we define @xmath650 to be the difference @xmath651 .",
    "similarly we define @xmath652 to be the difference @xmath653 .",
    "if @xmath654 , we will say that the factorization @xmath655 is a _",
    "good factorization_. if @xmath656 , we will say that the factorization @xmath655 is a _",
    "stably good factorization_.    these definitions lead to the following easily - proved but useful equation :    [ dropbadness ] let @xmath657 be natural numbers with product @xmath277 . then @xmath658    both sides are equal to the difference @xmath659 .",
    "the usefulness of this equation comes from the fact that all the summands are nonnegative integers .",
    "for instance , we can obtain the following implications from it :    let @xmath657 be natural numbers with product @xmath277 ; consider the factorization @xmath660 . then :    1 .",
    "if @xmath277 is stable and the factorization is good , then the @xmath661 are stable .",
    "if the @xmath661 are stable and the factorization is stably good , then @xmath277 is stable .",
    "if the factorization is stably good , then @xmath662 .",
    "( part ( 1 ) of this proposition also appeared as proposition  24 in @xcite . )    for part ( 1 ) , by proposition  [ dropbadness ] , if @xmath663 , then we must have that @xmath664 for all @xmath473 , i.e. , the @xmath661 are all stable . for part",
    "( 2 ) , again by proposition  [ dropbadness ] , if @xmath656 and @xmath664 for all @xmath473 , then we must have @xmath665 , i.e. , @xmath277 is stable .",
    "finally , for part ( 3 ) let @xmath666 , and let @xmath667 .",
    "then @xmath668 .",
    "now by hypothesis , @xmath669 and furthermore each @xmath670 is stable . hence by part ( 2 ) , we must also have that @xmath671 is stable , that is , that @xmath672 .",
    "having noted this , let us now continue on towards the results of actually performing computations with these algorithms .",
    "armed with our suite of algorithms , we now proceed to the results of our computations",
    ". we can use algorithm  [ pow2alg ] to prove theorem  [ frontpage2comput ] :    algorithm  [ pow2alg ] was applied with @xmath673 , and it was determined that @xmath674 and @xmath675 , that is to say , that @xmath676 is stable and @xmath677 , that is to say , that @xmath678 for all @xmath89 .",
    "this implies that @xmath13 for all @xmath679 and @xmath89 with @xmath14 and @xmath11 not both zero , as if one instead had @xmath680 , then writing @xmath681 , one would obtain @xmath682 .",
    "but we can do more with these algorithms than just straightforward computation of values of complexities and stable complexities . for instance",
    ", we can answer the question : what is the smallest unstable defect other than @xmath15 ?",
    "in @xcite it was determined that    [ 12d2stab ] for any @xmath25 , if @xmath683 , then @xmath1 is stable .",
    "that is to say , with the exception of @xmath15 , all defects less than @xmath684 are stable .",
    "this naturally leads to the question , what is the smallest unstable defect ( other than @xmath15 ) ?",
    "we might also ask , what is the smallest unstable number ( other than @xmath15 ) ?",
    "interestingly , among unstable numbers greater than @xmath15 , the number @xmath685 turns out to be smallest both by magnitude and by defect .",
    "however , if we measure unstable numbers ( other than @xmath15 ) by their unstable defect , the smallest will instead turn out to be @xmath686 .",
    "we record this in the following theorem :    [ smallunstab ] we have :    1 .",
    "the number @xmath685 is the smallest unstable number other than @xmath15 .",
    "2 .   other than @xmath15 ,",
    "the number @xmath685 is the unstable number with the smallest defect , and @xmath687 is the smallest unstable defect other than @xmath15 .",
    "3 .   among nonzero values of @xmath197 for unstable @xmath1 ,",
    "@xmath688 , or @xmath689 , is the smallest .",
    "for part ( 1 ) , it suffices to use algorithm  [ stabalg ] to check the stability of all numbers from @xmath8 to @xmath690 .    for parts ( 2 ) and ( 3 ) , in order to find unstable numbers of small defect , we will search for leaders of small defect which are divisible by @xmath35 .",
    "( since if @xmath1 is unstable , then @xmath552 is a leader divisible by @xmath35 , and @xmath691 ) .",
    "we use algorithm  [ mainalg ] to compute a good covering @xmath431 of @xmath692 . doing a careful examination of the low - defect polynomials that appear",
    ", we can determine all the multiples of @xmath35 that each one can @xmath35-represent ; we omit this computation , but its results are that the following multiples of @xmath35 can be @xmath35-represented : @xmath35 , @xmath269 , @xmath693 , @xmath694 , @xmath695 , @xmath696 , @xmath697 , @xmath698 , @xmath699 , @xmath700 , @xmath701 , @xmath702 , @xmath703 , @xmath704 , @xmath705 , @xmath706 , @xmath707 , @xmath708 , @xmath709 , @xmath710 , @xmath711 , @xmath712 , @xmath713 , @xmath714 , @xmath715 , @xmath716 , @xmath717 , @xmath718 , @xmath719 , @xmath720 , @xmath721 , @xmath722 , @xmath723 , @xmath724 , @xmath725 , @xmath726 , @xmath727 , @xmath728 , @xmath729 , @xmath730 , @xmath731 , @xmath732 , @xmath733 , @xmath734 , @xmath735 , @xmath736 , @xmath737 , @xmath738 , @xmath739 , @xmath740 , @xmath741 , @xmath742 , @xmath743 , @xmath744 , @xmath745 , @xmath746 , @xmath747 , @xmath748 , @xmath749 , @xmath750 , @xmath751 , @xmath752 , @xmath753 , @xmath754 , @xmath755 , @xmath756 , @xmath757 , @xmath758 , @xmath759 , and , for @xmath2 , numbers of the forms @xmath760 , @xmath761 , @xmath762 , @xmath763 , and @xmath764 .",
    "for the individual leaders , we can easily check by computation that the only ones which are leaders are @xmath35 , @xmath738 , and @xmath754 .",
    "this leaves the infinite families . for these , observe that if we divide them by @xmath35 , we get , respectively , @xmath765 , @xmath766 , @xmath767 , @xmath768 , and @xmath769 , and it is easy to check that any number of any of those forms has defect less than @xmath684 and hence is stable by theorem  [ 12d2stab ] ; thus , multiplying them by @xmath35 can not yield a leader .",
    "so we conclude that the only leaders @xmath48 with @xmath770 are @xmath35 , @xmath738 , and @xmath754 .",
    "therefore , the only unstable numbers @xmath1 with @xmath771 are @xmath15 , @xmath685 , and @xmath686 . note also that by the above computation , no power of @xmath35 times any of @xmath35 , @xmath738 , or @xmath754 is a leader ( as it would have to have smaller defect and would thus appear in the list ) , and thus the numbers @xmath35 , @xmath738 , and @xmath754 are not just leaders but in fact stable leaders .",
    "so to prove part ( 3 ) , it suffices to note that , since @xmath772 , among @xmath773 ( i.e.  @xmath774 ) and @xmath688 ( i.e.  @xmath775 ) , the latter is smaller .",
    "this leaves part ( 2 ) .",
    "observe that @xmath776 .",
    "and if @xmath1 is unstable , then @xmath777 .",
    "so if @xmath25 is unstable and @xmath778 , then @xmath779 , which by the above forces @xmath780 .",
    "but in fact , although @xmath781 , we nonetheless have @xmath782 ( because while @xmath776 , @xmath783 ) .",
    "thus @xmath784 is the smallest unstable defect other than @xmath15 , i.e. , @xmath685 is ( other than @xmath15 ) the smallest unstable number by defect .",
    "these computational results provide a good demonstration of the power of the methods here .",
    "the author is grateful to j.  arias de reyna for helpful discussion .",
    "he thanks his advisor j.  c.  lagarias for help with editing and further discussion .",
    "work of the author was supported by nsf grants dms-0943832 and dms-1101373 .",
    "in this appendix we make some notes about the attached implementation of the above algorithms and on other ways they could be implemented .",
    "we have actually not implemented algorithm  [ stabalg ] and algorithm  [ genalg ] in full generality , where @xmath161 may be arbitrary ; we have only implemented the case where @xmath162 , the case where @xmath785 ( computed beforehand ) , and the case of algorithm  [ pow2alg ] .    as was mentioned in section  [ discussion1 ] ,",
    "the step size in the attached implementation has been fixed at @xmath160 , with the sets @xmath338 and @xmath389 precomputed .",
    "other integral multiples of @xmath786 were tried , up to @xmath787 ( since @xmath788 and thus is not a valid step size ) , but these all seemed to be slower , contrary to the author s expectation .",
    "another variation with a similar flavor is that one could write a version of these algorithms with nonstrict inequalities , computing numbers @xmath1 with @xmath789 for a given @xmath129 , rather than @xmath790 ; see appendix  a of @xcite .",
    "we may define :      a finite set @xmath322 of low - defect pairs will be called a _ covering set _ for @xmath793 if , for every @xmath794 , there is some low - defect pair in @xmath322 that efficiently @xmath35-represents it .",
    "we will say @xmath322 is a _ good covering _ of @xmath793 if , in addition , every @xmath325 satisfies @xmath326 .",
    "it is also worth noting that the check for whether a given polynomial @xmath253 @xmath35-represents a given number @xmath1 can also be sped up . if @xmath253 is a low - defect polynomial with leading coefficent @xmath32 , maximum coefficient @xmath795 , and @xmath277 terms , then @xmath796 so we only need to search @xmath506 with @xmath797 a stricter condition than was described in the algorithms above .",
    "this improvement is , in fact , used in the attached implementation .",
    "it is also possible that there is a better way than brute force .    as was mentioned in section  [ secmorealgos ] , when running algorithm  [ stabalg ] or algorithm  [ genalg ] with @xmath161 finite , one can omit the @xmath35-representation check at intermediate steps .",
    "we have only implemented this variant for algorithm  [ pow2alg ] .",
    "it was mentioned in section  [ bdsec ] that considering `` low - defect expression pairs '' @xmath284 or `` low - defect tree pairs '' @xmath798 ( where @xmath243 is a low - defect expression , @xmath262 is a low - defect tree , and @xmath799 or @xmath800 , as appropriate ) may be useful .",
    "in fact , the attached implementation works with a tree representation essentially the same as low - defect trees and low - defect tree pairs . among other things ,",
    "this makes it easy to find the minimal variables to be substituted into .",
    "if one were actually representing low - defect polynomials as polynomials , this would take some work .",
    "there is a slight difference in that , rather than simply storing a base complexity @xmath801 , it stores for each vertex or edge  say with label @xmath0  a number @xmath14 such that @xmath802 , unless we are talking about a non - leaf vertex and @xmath41 , in which case @xmath585 .",
    "we can then determine a @xmath290 by adding up the values of @xmath14 that is to say , the complexity , rather than being attributed to the whole tree , is distributed among the parts of the tree responsible for it ; this makes it easier to check for and remove redundant low - defect pairs .",
    "it was also mentioned in section  [ bdsec ] that one could use a representation similar to low - defect expressions , but with all the integer constants replaced with @xmath803-expressions for same .",
    "e.g. , instead of @xmath804 , one might have @xmath805 .",
    "we have not implemented this , but doing this woud have one concrete benefit : it would allow the algorithms above to not only determine the complexity of a given number @xmath1 , but also to give a shortest representation .",
    "( and analogously with stable complexity . )",
    "the current implementation can not consistently do this in a useful manner . for instance , suppose that we ran algorithm  [ pow2alg ] and found some @xmath14 with @xmath806 .",
    "we might then look at the actual low - defect pair @xmath272 that @xmath35-represented it , to learn what this representation with only @xmath807 ones is .",
    "but it might turn out , on inspection , that @xmath253 was simply the constant @xmath808 ; this would not be very enlightening .",
    "using @xmath803-expressions would remedy this , as would having low - defect pairs keep track of their `` history '' somehow .",
    "it s also possible to write numerical versions of proposition  [ minlimit ] , that say exactly how far out one has to go in order to get within a specified @xmath809 of the limit @xmath292 ; one could use this in algorithm  [ algtrunc ] instead of simply searching larger and larger @xmath439 until one works .",
    "this was tried but found to be slower .    finally , it is worth expanding here on the remark in section  [ discussion2 ] that it is possible to write algorithm  [ stabalg ] and algorithm  [ stabalg ] without using truncation .",
    "surprisingly little modification is required ; the only extra step needed is that , in order to check if @xmath1 ( or any @xmath56 ) has defect less than @xmath810 , instead of just checking if a low - defect pair @xmath272 ( or its augmented version ) @xmath35-represents @xmath1 ( or any @xmath56 ) , if one finds that indeed @xmath811 ( or the appropriate equivalent ) , one must additionally check whether @xmath812 , since this is no longer guaranteed in advance .",
    "we will not state a proof of correctness here ; it is similar to the proofs above .",
    "such no - truncation versions of the algorithms were tried , but found to be too slow to be practical , because of the time needed to check whether the resulting polynomials @xmath35-represented a given number .",
    "another possibility , in the case where one is using a cutoff , is to truncate only at the final step , and not at the intermediate steps ; this has not been tried .",
    "if this is used , it should probably be combined with not checking whether @xmath1 ( or any @xmath56 ) is @xmath35-represented until the final step , for the reason just stated .",
    "99 h.  altman , internal structure of addition chains : well - ordering , arxiv:1409.1627 h.  altman , integer complexity and well - ordering , _ michigan mathematical journal _ * 64 * ( 2015 ) , no .  3 , 509538 . h.  altman , integer complexity : representing numbers of bounded defect , arxiv:1603.06122 , 2016 h.  altman , integer complexity : the integer defect , in preparation . h.  altman , refined estimates for counting numbers of low defect , in preparation . h.  altman and j.  arias de reyna , integer complexity , stability , and self - similarity , in preparation h.  altman and j.  zelinsky , numbers with integer complexity close to the lower bound , _",
    "integers _ * 12 * ( 2012 ) , no .  6 , 10931125 . j.  arias de reyna , complejidad de los nmeros naturales , _ gac .",
    "r.  soc .  mat .",
    "* 3 * ( 2000 ) , 230250 .",
    "j.  arias de reyna and j.  van de lune , algorithms for determining integer complexity , arxiv:1404.2183 , 2014 a.  brauer , on addition chains , _ bull .",
    "_ , * 45 * ( 1939 ) , 736739 . p.  w.  carruth , arithmetic of ordinals with applications to the theory of ordered abelian groups , _ bull",
    ".  amer .",
    "* 48 * ( 1942 ) , 262271 .",
    "j.  h.  conway , _ on numbers and games _ , second edition , a k peters , ltd . ,",
    "natick , massachusetts , 2001 , pp .",
    "d.  h.  j.  de jongh and r.  parikh , well - partial orderings and hierarchies , _ indag .",
    "_ * 39 * ( 1977 ) , 195206 .",
    "h.  dellac , _ intermd .",
    "_ * 1 * ( 1894 ) , 162164 .",
    "a.  flammenkamp , drei beitrge zur diskreten mathematik : additionsketten , no - three - in - line - problem , sociable numbers , diplomarbeit in mathematics ( bielefield university , 1991 ) , pp .",
    "r.  k.  guy , some suspiciously simple sequences , _ amer .  math .  monthly _ , * 93 * ( 1986 ) , 186190 ; and see * 94 * ( 1987 ) , 965 & * 96 * ( 1989 ) , 905",
    ". r.  k.  guy , _ unsolved problems in number theory _ , third edition , springer - verlag , new york , 2004 , pp .",
    "j.  iraids , personal communication .",
    "j.  iraids , k.  balodis , j.  ernenoks , m.  opmanis , r.  opmanis , k.  podnieks .",
    "integer complexity : experimental and analytical results , arxiv:1203.6462 , 2012 d.  e.  knuth , _ the art of computer programming _ , vol .  2 , third edition , addison - wesley , reading , massachusetts , pp .",
    "461485 k.  mahler and j.  popken , on a maximum problem in arithmetic ( dutch ) , _ nieuw arch .",
    "wiskunde _ , ( 3 ) * 1 * ( 1953 ) , 115 ; _ mr _ * 14 * , 852e",
    ". a.  scholz , aufgabe 253 , jahresbericht der deutschen mathematikervereinigung , vol .",
    "47 , teil ii , b.  g.  teubner , leipzig and berlin , 1937 , pp .",
    ". v.  v.  srinivas & b.  r.  shankar , integer complexity : breaking the @xmath27 barrier , _ world academy of science _ , * 41 * ( 2008 ) , 690691 m.  v.  subbarao , addition chains  some results and problems , _ number theory and applications _ , editor r.  a.  mollin , nato advanced science series : series c , v. 265 , kluwer academic publisher group , 1989 , pp .  555574 .",
    "i.  volkovich , characterizing arithmetic read - once formulae , arxiv:1408.1995 , 2014 j.  zelinsky , an upper bound on integer complexity , in preparation"
  ],
  "abstract_text": [
    "<S> define @xmath0 to be the _ complexity _ of @xmath1 , the smallest number of ones needed to write @xmath1 using an arbitrary combination of addition and multiplication . define @xmath1 to be _ stable _ if for all @xmath2 , we have @xmath3 . in @xcite , </S>",
    "<S> this author and zelinsky showed that for any @xmath1 , there exists some @xmath4 such that @xmath5 is stable ; however , the proof there provided no upper bound on @xmath6 or any way of computing it . in this paper </S>",
    "<S> , we describe an algorithm for computing @xmath6 , and thereby also show that the set of stable numbers is a computable set . </S>",
    "<S> the algorithm is based on considering the _ defect _ of a number , defined by @xmath7 , building on the methods presented in @xcite . as a side benefit </S>",
    "<S> , this algorithm also happens to allow fast evaluation of the complexities of powers of @xmath8 ; we use it to verify that @xmath9 for @xmath10 and arbitrary @xmath11 ( excluding the case @xmath12 ) , providing more evidence for the conjecture that @xmath13 whenever @xmath14 and @xmath11 are not both zero . </S>",
    "<S> an implementation of these algorithms in haskell is available . </S>"
  ]
}