{
  "article_text": [
    "containers , as introduced by abbott , altenkirch and ghani @xcite are a neat representation for a wide class of parameterized datatypes ( set functors ) in terms of a set of shapes and a set of positions in each shape .",
    "they cover lists , colists , streams , various kinds of trees , etc .",
    "containers can be used as a `` syntax '' for programming with these datatypes and reasoning about them , as can the strictly positive datatypes and polynomial functors of dybjer  @xcite , moerdijk and palmgren  @xcite , gambino and hyland  @xcite , and kock  @xcite .",
    "the theory of this class of datatypes is elegant , as they are well - behaved in many respects .",
    "this paper proceeds from the observation that datatypes often carry additional structure that containers alone do not account for .",
    "we introduce directed containers to capture the common situation in programming where every position in a data - structure determines another data - structure , informally , the sub - data - structure rooted by that position .",
    "some natural examples of such data - structures are non - empty lists and node - labelled trees , and data - structures with a designated position or focus ( zippers ) . in the former case ,",
    "the sub - data - structure is a sublist or a subtree . in the latter case ,",
    "it is the whole data - structure but with the focus moved to the given position .",
    "we show that directed containers are no less neat than containers .",
    "while containers denote set functors via a fully - faithful functor , directed containers interpret fully - faithfully into comonads .",
    "they admit some of the constructions that containers do , but not others : for instance , two directed containers can not be composed in general .",
    "our main result is that every comonad whose underlying functor is the interpretation of a container is the interpretation of a directed container .",
    "so the answer to the question in the title of this paper is : a container is a comonad exactly when it is a directed container . in more precise terms ,",
    "the category of directed containers is the pullback of the forgetful functor from the category of comonads to that of set functors along the interpretation functor of containers .",
    "this also means that a directed container is the same as a comonoid in the category of containers .    in the core of the paper ,",
    "we study directed containers on @xmath0 . toward the end of the paper we point it out that the development could also be carried out more generally in locally cartesian closed categories ( lcccs ) and yet more generally in categories with pullbacks .    in our mathematics , we use syntax similar to the dependently typed functional programming language agda @xcite .",
    "if some function argument will be derivable in most contexts , we mark it as implicit by enclosing it / its type in braces in the function s type declaration and either give this argument in braces or omit it in the definition and applications of the function .",
    "we have formalized the central parts of the theory presented in agda .",
    "the development is available at http://cs.ioc.ee/~danel/dcont.html .      in section  [ sec : containers ] , we review the basic theory of containers , showing also some examples . we introduce containers and their interpretation into set functors .",
    "we show some constructions of containers such as the coproduct of containers . in section  [ sec : dcontainers ] , we revisit our examples and introduce directed containers as a specialization of containers and describe their interpretation into comonads . our main result , that a container is a comonad exactly when it is directed , is the subject of section  [ sec : pullback ] . in section  [ sec : constructions ] , we look at some constructions , in particular the cofree directed container and the focussed container ( zipper ) construction .",
    "in addition , we also introduce strict directed containers and construct the product of two strict directed containers in the category of directed containers .",
    "intuitively , a strict directed container is a directed container where no position in a non - root subshape of a shape translates to its root . in section  [ sec : monads ]",
    ", we ask whether a similar characterization is possible for containers that are monads and hint that this is the case . in section  [ sec : cointerp ] , we show that interpreting the opposite of the category of directed containers into set functors gives monads . in section  [ sec : polycom ] , we hint how the directed container theory ( presented in the paper for @xmath0 ) could be developed in the more general setting of categories with pullbacks .",
    "we briefly summarize related work in section  [ sec : related ] and conclude with outlining some directions for future work in section  [ sec : concl ] .",
    "the proofs of the main results of sections  [ sec : dcontainers ] and [ sec : constructions ] appear in appendices a and b.    we spend a section on the background theory of containers as they are central for our paper but relatively little known , but assume that the reader knows about comonads , monoidal categories and comonoids .",
    "this article is a revised and expanded version of the fossacs 2012 conference paper @xcite .",
    "we have added many of the proofs that were omitted from the conference version .",
    "we have rearranged the different constructions on directed containers into a separate section , namely section  [ sec : constructions ] . in section  [ sec : cofree ] , we give a detailed discussion of cofree directed containers . in section  [ sec : products ] , which is entirely new , we define strict directed containers and coideal comonads and give an explicit formula for the product of two strict directed containers",
    ".    likewise entirely new are the sections on cointerpreting directed containers in section [ sec : cointerp ] and directed containers in categories with pullbacks in section [ sec : polycom ] .",
    "we begin with a recap of containers .",
    "we introduce the category of containers and the fully - faithful functor into the category of set functors defining the interpretation of containers and show that these are monoidal .",
    "we also recall some basic constructions of containers . for proofs of the propositions in this section and further information , we refer the reader to abbott et al .",
    "@xcite .",
    "containers are a form of `` syntax '' for datatypes .",
    "a _ container _",
    "@xmath1 is given by a set @xmath2 of _ shapes _ and a shape - indexed family @xmath3 of _ positions_. intuitively , shapes are `` templates '' for data - structures and positions identify `` blanks '' in these templates that can be filled with data .",
    "the datatype of lists is represented by @xmath1 where the shapes @xmath4 are the possible lengths of lists and the positions @xmath5 provide @xmath6 places for data in lists of length @xmath6 .",
    "non - empty lists are obtained by letting @xmath7 and @xmath8 ( so that shape @xmath6 has @xmath9 rather than @xmath6 positions ) .",
    "streams are characterized by a single shape with natural number positions : @xmath10 and @xmath11 .",
    "the singleton datatype has one shape and one position : @xmath12 , @xmath13",
    ".    a _ morphism _ between containers @xmath1 and @xmath14 is a pair @xmath15 of maps @xmath16 and @xmath17 ( the shape map and position map ) .",
    "note how the positions are mapped backwards .",
    "the intuition is that , if a function between two datatypes does not look at the data , then the shape of a data - structure given to it must determine the shape of the data - structure returned and the data in any position in the shape returned must come from a definite position in the given shape .    *",
    "the head function , sending a non - empty list to a single data item , is determined by the maps @xmath18 and @xmath19 defined by @xmath20 and @xmath21 . * the tail function , sending a non - empty list to a list , is represented by @xmath22 and @xmath23 defined by @xmath24 and @xmath25 .",
    "* for the function dropping every second element of a non - empty list , the shape and position maps @xmath22 and @xmath26 are @xmath27 and @xmath28 . * for self - append of a non - empty list , they are @xmath29 and @xmath30 defined by @xmath31 and @xmath32 . * for reversal of non - empty lists , they are @xmath22 and @xmath33 defined by @xmath34 and @xmath35 .",
    "( see prince et al .",
    "@xcite for more similar examples . )",
    "the _ identity _ morphism @xmath36 on a container @xmath37 is defined by @xmath38 .",
    "the _ composition _ @xmath39 of container morphisms @xmath40 and @xmath41 is defined by @xmath42 .",
    "composition of container morphisms is associative , identity is the unit .",
    "containers form a category @xmath43 .      to map containers into datatypes made of data - structures that have the positions in some shape filled with data , we must equip containers with a `` semantics '' .    for a container @xmath44",
    ", we define its _ interpretation _",
    "@xmath45 on sets by @xmath46 , so that @xmath47 consists of pairs of a shape and an assignment of an element of @xmath48 to each of the positions in this shape , reflecting the intuitive reading that shapes are  templates \" for datatypes and positions identify  blanks \" in these templates that can be filled in with data .",
    "the interpretation @xmath49 of @xmath50 on functions is defined by @xmath51 .",
    "it is straightforward that @xmath52 preserves identity and composition of functions , so it is a set functor ( as any datatype should be ) .",
    "our example containers denote the datatypes intended . if we let @xmath50 be the container of lists , we have @xmath53 .",
    "the container of streams interprets into @xmath54 .",
    "a morphism @xmath40 between containers @xmath44 and @xmath55 is interpreted as a natural transformation between @xmath52 and @xmath56 , i.e. , as a polymorphic function @xmath57 that is natural .",
    "it is defined by @xmath58 .",
    "@xmath59 preserves the identities and composition of container morphisms .",
    "the interpretation of the container morphism @xmath60 for the list head function is @xmath61 defined by @xmath62 .",
    "@xmath59 is a functor from @xmath43 to @xmath63}$ ] .",
    "every natural transformation between container interpretations is the interpretation of some container morphism . for containers @xmath37 and @xmath64 , a natural transformation @xmath65 between @xmath52 and @xmath56 , i.e.",
    ", a polymorphic function @xmath66 that is natural , can be `` quoted '' to a container morphism @xmath67 between @xmath50 and @xmath68 where @xmath69 and @xmath70 are defined by @xmath71 .    for any container morphism @xmath60 , @xmath72 , and , for any natural transformation @xmath65 and @xmath73 between container interpretations",
    ", @xmath74 implies @xmath75 .",
    "[ prop : csemfullyfaithful ] @xmath59 is fully faithful .",
    "we have already seen the _ identity _ container @xmath76 .",
    "the _ composition _ @xmath77 of containers @xmath78 and @xmath79 is the container @xmath1 defined by @xmath80 and @xmath81 .",
    "it has as shapes pairs of an outer shape @xmath6 and an assignment of an inner shape to every position in @xmath6 .",
    "the positions in the composite container are pairs of a position @xmath82 in the outer shape and a position in the inner shape assigned to @xmath82 .",
    "the ( horizontal ) composition @xmath83 of container morphisms @xmath84 and @xmath85 is the container morphism @xmath15 defined by @xmath86 and @xmath87 .",
    "the horizontal composition preserves the identity container morphisms and the ( vertical ) composition of container morphisms , which means that @xmath88 is a bifunctor .",
    "@xmath43 has isomorphisms @xmath89 , @xmath90 and @xmath91 , given by @xmath92 , @xmath93 and @xmath94 .",
    "they satisfy mac lane s coherence conditions .    [",
    "prop : monoidalcategory ] the category @xmath43 is a monoidal category .",
    "there are also natural isomorphisms @xmath95 and @xmath96 @xmath97 @xmath98 defined by @xmath99 and @xmath100 satisfying the appropriate coherence conditions .",
    "the functor @xmath59 is a monoidal functor .",
    "containers are closed under various constructions such as products , coproducts and constant exponentiation , preserved by interpretation .",
    "[ [ products ] ] products + + + + + + + +    for two containers @xmath78 and @xmath101 , their _ product _ @xmath102 is the container @xmath103 defined by @xmath104 and @xmath105 .",
    "it holds that @xmath106 .",
    "[ [ coproducts ] ] coproducts + + + + + + + + + +    the _ coproduct _ @xmath107 of containers @xmath108 and @xmath79 is the container @xmath1 defined by @xmath109 , @xmath110 and @xmath111 .",
    "it is the case that @xmath112 .",
    "[ [ exponentials ] ] exponentials + + + + + + + + + + + +    for a set @xmath113 and a container @xmath78 , the _ exponential _",
    "@xmath114 is the container @xmath1 where @xmath115 and @xmath116 .",
    "we have that @xmath117 .",
    "we now proceed to our contribution , directed containers .",
    "we define the category of directed containers and a fully - faithful functor interpreting directed containers as comonads , and discuss some examples and constructions .      parametrized datatypes often carry some additional structure that is worth making explicit .",
    "for example , each node in a list or non - empty list defines a sublist ( a suffix ) . in container terms",
    ", this corresponds to every position in a shape determining another shape , the subshape corresponding to this position .",
    "the theory of containers alone does not account for such additional structure .",
    "directed containers , studied in the rest of this paper , axiomatize subshapes and translation of positions in a subshape into the global shape .",
    "a _ directed container _ is a container @xmath1 together with three operations    @xmath118 ( the subshape corresponding to a position ) ,    @xmath119 ( the root ) ,    @xmath120 ( translation of subshape positions into positions in the global shape ) .    satisfying the following two shape equations and three position equations :    @xmath121 ,    @xmath122 ,    @xmath123 ,    @xmath124 ,    @xmath125 .",
    "( using @xmath126 as an infix operation , we write the first , implicit , argument next to the operation symbol when we want to give it explicitly . ) modulo the fact that the positions involved come from different sets , laws 35 are the laws of a monoid .",
    "in the special case @xmath12 , we have exactly one set of positions , namely @xmath127 , and that is a monoid .",
    "if @xmath128 is general , but @xmath129 does not depend on @xmath82 ( in this case @xmath130 thanks to law 1 ) , then each @xmath131 is a monoid .",
    "( one might also notice that laws 12 bear similarity to the laws of a monoid action .",
    "if none of @xmath132 , @xmath133 , @xmath134 depends on @xmath6 , then we have one single monoid and @xmath135 is then a right action of that monoid on @xmath128 . )    to help explain the operations and laws , we sketch in fig .  [ fig : dcontainer ] a data - structure with nested sub - data - structures .    @xmath136^(0.25){{\\mathsf{o}}{\\{s\\ } } } \\ar@{-}[ddddddddllllllll ] \\ar@{-}[ddddddddrrrrrrrr]_>>>>>>{s = s { \\mathrel{\\downarrow}}{\\mathsf{o}}{\\{s\\ } } } \\ar@{->}[dd]^(0.6){p = p { \\mathrel{\\oplus}}{\\mathsf{o}}{\\{s'\\ } } = { \\mathsf{o}}{\\{s\\ } } { \\mathrel{\\oplus}}p : p s } \\ar@{->}@/_5pc/[dddd]_{p { \\mathrel{\\oplus}}p ' }   \\ar@{->}@/_8.5pc/[ddddddd]_{(p { \\mathrel{\\oplus}}p ' ) { \\mathrel{\\oplus}}p '' = p { \\mathrel{\\oplus}}(p ' { \\mathrel{\\oplus}}p '' ) } \\\\ & & & & & & & & & \\\\ & & & & & & & &   \\bullet \\ar@(l , u)@{.>}[]^(0.25){{\\mathsf{o}}{\\{s'\\ } } }   \\ar@{.>}[dd]^(0.6){p ' : p s ' } \\ar@{.}[ddddddllllll ] \\ar@{.}[ddddddrrrrrr]_>>>>>>{s ' = s { \\mathrel{\\downarrow}}p } \\ar@{.>}@/^4.5pc/[ddddd]^(0.4){p ' { \\mathrel{\\oplus}}p '' } & &   \\\\ & & & & & & & & & & & \\\\ & & & & & & & & \\bullet \\ar@{-->}[ddd]^(0.65){p '' : p s '' } \\ar@{--}[ddddllll]^>>>>>>{s '' = s { \\mathrel{\\downarrow}}(p { \\mathrel{\\oplus}}p ' ) = s ' { \\mathrel{\\downarrow}}p ' } \\ar@{--}[ddddrrrr ] & & & &   \\\\ & & & & & & & & & & & & & \\\\ & & & & & & & & & & & & & \\\\ & & & & & & & & \\bullet & & & & & &",
    "\\\\ \\ar@{-}[rrrrrrrrrrrrrrrr ] & & & &   & & & & & & & & & & & & } \\ ] ]    the global shape @xmath6 is marked with a solid boundary and has a root position @xmath133 .",
    "then , any position @xmath82 in @xmath6 determines a shape @xmath137 , marked with a dotted boundary , to be thought of as the subshape of @xmath6 given by this position .",
    "the root position in @xmath138 is @xmath139 .",
    "law 3 says that its translation @xmath140 into a position in shape @xmath6 is @xmath82 , reflecting the idea that the subshape given by a position should have that position as the root .    by law 1 ,",
    "the subshape @xmath141 corresponding to the root position @xmath142 in the global shape @xmath6 is @xmath6 itself .",
    "law 4 , which is only well - typed thanks to law 1 , stipulates that the translation of position @xmath82 in @xmath141 into a position in @xmath6 is just @xmath82 ( which is possible , as @xmath143 ) .",
    "a further position @xmath144 in @xmath138 determines a shape @xmath145 . but",
    "@xmath144 also translates into a position @xmath146 in @xmath6 and that determines a shape @xmath147 .",
    "law 2 says that @xmath148 and @xmath147 are the same shape , which is marked by a dashed boundary in the figure .",
    "finally , law 5 ( well - typed only because of law 2 ) says that the two alternative ways to translate a position @xmath149 in shape @xmath148 into a position in shape @xmath6 agree with each other .",
    "lists can not form a directed container , as the shape @xmath150 ( for the empty list ) , having no positions , has no possible root position .",
    "but the container of _ non - empty lists _",
    "( with @xmath7 and @xmath151 ) is a directed container with respect to _ non - empty suffixes _ as sublists .",
    "the subshape given by a position @xmath82 in a shape @xmath6 ( for lists of length @xmath9 ) is the shape of the corresponding suffix , given by @xmath152 .",
    "the root @xmath133 is the position @xmath150 of the head node .",
    "a position in the global shape is recovered from a position @xmath144 in the subshape of the position @xmath82 by @xmath153 .",
    "[ fig : dcontainernelist ] shows an example of the shape and positions of a non - empty list with length 6 , i.e. , with shape @xmath154 .",
    "this figure also shows that the subshape determined by a position @xmath155 in the global shape @xmath6 is @xmath156 and a position @xmath157 in @xmath138 is rendered as the position @xmath158 in the initial shape .",
    "@xmath159_(0.8){p = 2 } \\ar@{->}@/^0.8pc/[rrr]^{p { \\mathrel{\\oplus}}p ' = 2 + 1 = 3 } \\ar@{-}[uurr]_>{s = 5 } \\ar@{-}[ddrr ]   & \\bullet & \\bullet \\ar@{.>}@/_0.8pc/[r]_>{p ' = 1 } \\ar@{.}[uurr]_>{s ' = s { \\mathrel{\\downarrow}}p = 5 - 2 = 3 } \\ar@{.}[ddrr ] & \\bullet & \\bullet & \\bullet \\\\ & & & & & \\\\ & & & & &   } \\ ] ]    clearly one could also choose prefixes as subshapes and the last node of a non - empty list as the root , but this gives an isomorphic directed container .",
    "non - empty lists also give rise to an entirely different directed container structure that has _",
    "cyclic shifts _ as `` sublists '' ( this example was suggested to us by jeremy gibbons ) .",
    "the subshape at each position is the global shape ( @xmath130 ) .",
    "the root is still @xmath160 .",
    "the interesting part is that translation into the global shape of a subshape position is defined by @xmath161 , satisfying all the required laws .",
    "@xmath162_(0.8){p=2 } \\ar@{->}@/^1pc/[rrrr]^{p { \\mathrel{\\oplus}}p ' = 2 + \\ , 2 = 4 } \\ar@{-}[uurr]_>{s = { { \\ast } } } \\ar@{-}[ddrr ] & \\bullet   & \\bullet \\ar@{.>}@/_1pc/[rr]_(0.8){p ' = 2 } \\ar@{.}[uurr]_>{s ' = s { \\mathrel{\\downarrow}}p = { { \\ast } } } \\ar@{.}[ddrr ] & \\bullet & \\bullet & \\bullet & ... \\\\ & & & & & \\\\ & & & & & } \\ ] ]    the container of _ streams _ ( @xmath12 , @xmath11 ) carries a very trivial directed container structure given by @xmath163 , @xmath164 and @xmath165 . fig .  [ fig : dcontainerstream ] shows how a position @xmath155 in the only possible global shape @xmath166 and a position @xmath167 in the equal subshape @xmath168 give back a position @xmath169 in the global shape .",
    "this directed container is nothing else than the monoid @xmath170 seen as a directed container .",
    "similarly to the theory of containers , one can also define morphisms between directed containers .",
    "a _ morphism _ between two directed containers @xmath171 and @xmath172 is a morphism @xmath15 between the containers @xmath1 and @xmath14 that satisfies three laws :    1 .",
    "@xmath173 , 2 .",
    "@xmath174 , 3 .",
    "@xmath175 .    in the special case @xmath176 , laws 2 and 3 are the laws of a monoid morphism .",
    "recall the intuition that @xmath177 determines the shape of the data - structure that some given data - structure is sent to and @xmath178 identifies for every position in the data - structure returned a position in the given data - structure .",
    "these laws say that the positions in the sub - data - structure for any position in the resulting data - structure must map back to positions in the corresponding sub - data - structure of the given data - structure .",
    "this means that they can receive data only from those positions , other flows are forbidden .",
    "morphisms between directed containers representing node - labelled tree datatypes are exactly upwards accumulations  this was one of the motivations for choosing the name ` directed containers ' .",
    "the container representations of the head and drop - even functions for non - empty lists are directed container morphisms for the directed container of non - empty lists and suffixes ( and the identity directed container ) . but those of self - append and reversal are not .",
    "for the directed container of non - empty lists and cyclic shifts , not only the representations of the head and drop - even functions but also the self - append function are directed container morphisms .",
    "the identities and composition of @xmath43 can give the identities and composition for directed containers , since for every directed container @xmath179 , the identity container morphism @xmath180 is a directed container morphism and the composition @xmath39 of two directed container morphisms is also a directed container morphism .",
    "directed containers form a category @xmath181 .      as directed containers are containers with some operations obeying some laws , a directed container should denote not just a set functor , but a set functor with operations obeying some laws .",
    "the correct domain of denotation for directed containers is provided by comonads on sets .    given a directed container @xmath182 , we define its _ interpretation _ @xmath183 to be the set functor @xmath184 ( i.e. , the interpretation of the underlying container ) together with two natural transformations @xmath185 the directed container laws ensure that the natural transformations @xmath186 , @xmath187 make the counit and comultiplication of a comonad structure on @xmath188",
    ".    intuitively , the counit extracts the data at the root position of a data - structure ( e.g. , the head of a non - empty list ) , the comultiplication , which produces a data - structure of data - structures , replaces the data at every position with the sub - data - structure corresponding to this position ( e.g. , the corresponding suffix or cyclic shift ) .",
    "the interpretation @xmath189 of a morphism @xmath60 between directed containers @xmath190 , @xmath191 is defined by @xmath192 ( using that @xmath60 is a container morphism between @xmath50 and @xmath68 ) .",
    "the directed container morphism laws ensure that this natural transformation between @xmath52 and @xmath56 is also a comonad morphism between @xmath183 and @xmath193 .",
    "since the category @xmath194 inherits its identities and composition from @xmath195 $ ] , the functor @xmath196 also preserves the identities and composition .",
    "@xmath196 is a functor from @xmath181 to @xmath194 .",
    "[ prop : dcsemfunctor ]    similarly to the case of natural transformations between container interpretations , one can also `` quote '' comonad morphisms between directed container interpretations into directed container morphisms .  for any directed containers @xmath190 , @xmath197 and any morphism @xmath65 between the comonads @xmath183 and @xmath193 ( which is a natural transformation between @xmath52 and @xmath56 ) ,",
    "the container morphism @xmath198 between the underlying containers @xmath50 and @xmath68 is also a directed container morphism between @xmath199 and @xmath200 .",
    "the directed container morphism laws follow from the comonad morphism laws .    from what we already know about interpretation and quoting of container morphisms , it is immediate that @xmath201 for any directed container morphism @xmath60 and that @xmath202 implies @xmath75 for any comonad morphisms @xmath65 and @xmath73 between directed container interpretations .",
    "[ prop : dcsemfullyfaithful ] @xmath196 is fully faithful .    the _ identity container _",
    "@xmath76 extends trivially to an identity directed container whose denotation is isomorphic to the identity comonad .",
    "but , similarly to the situation with functors and comonads , composition of containers fails to yield a composition monoidal structure on @xmath181 .",
    "we have elsewhere @xcite shown that , similarly to the functors and comonads case @xcite , the composition of the underlying containers of two directed containers carries a _",
    "compatible _ directed container structure if and only if there is a _ distributive law _ between these directed containers .",
    "compatible compositions of directed containers turn out to generalize zappa - szp products of monoids  @xcite , with distributive laws playing the role of matching pairs of mutual actions .",
    "since not every functor can be represented by a container , there is no point in asking whether every comonad can be represented as a directed container .",
    "an example of a natural comonad that is not a directed container is the cofree comonad on the finite powerset functor @xmath203 ( node - labelled nonwellfounded strongly - extensional trees ) where the carrier of this comonad is not a container ( @xmath203 is also not a container ) .",
    "but , what about those comonads whose underlying functor is an interpretation of a container ?",
    "it turns out that any such comonad does indeed define a directed container that is obtained as follows .",
    "given a comonad @xmath204 and a container @xmath44 such that @xmath205 , the counit @xmath186 and comultiplication @xmath187 induce container morphisms @xmath206 using that @xmath59 is fully faithful . from @xmath204 satisfying the laws of a comonad we can prove that @xmath207 satisfies the laws of a comonoid in @xmath43 ( i.e. , an object in @xmath208 ) .",
    "further , we can define @xmath209 and the comonoid laws further enforce the laws of the directed container for @xmath210 .",
    "it may seem that the maps @xmath211 and @xmath212 are not used in the directed container structure , but @xmath213 contains no information ( @xmath214 ) and the comonad / comonoid right counital law forces that @xmath215 , which gets used in the proofs of each of the five directed container laws .",
    "the latter fact is quite significant .",
    "it tells us that the comultiplication @xmath187 of any comonad whose underlying functor is the interpretation of a container preserves the shape of a given data - structure as the outer shape of the data - structure returned .",
    "the situation is summarized as follows .",
    "[ prop : comonad2dcontainer ] any comonad @xmath204 and container @xmath50 such that @xmath216 determine a directed container @xmath217 .",
    "[ prop : pullbacklaw2 ] @xmath218 .",
    "[ prop : pullbacklaw1 ] @xmath219 .",
    "these observations combine into the following theorem .",
    "[ prop : pullback ] the following is a pullback in @xmath220 : @xmath221^{u } \\ar[d]_{{\\llbracket - \\rrbracket^\\mathrm{dc}}}^{\\mathrm{f.f . } }    & { \\mathbf{cont}}\\ar[d]_{{\\llbracket - \\rrbracket^\\mathrm{c}}}^{\\mathrm{f.f . } } \\\\ { \\mathbf{comonads({{\\mathbf{set } } } ) } } \\ar[r]^{u }    & { [ { \\mathbf{set}},{\\mathbf{set}}]}}\\ ] ]    a structured way to prove this theorem is to first note that a pullback is provided by @xmath208 and then verify that @xmath208 is isomorphic to @xmath181 .",
    "sam staton pointed it out to us that the proof of the first part only hinges on @xmath43 and @xmath222 $ ] being monoidal categories and @xmath223 $ ] being a fully faithful monoidal functor .",
    "thus we actually establish a more general fact , viz .",
    ", that for any two monoidal categories @xmath224 and @xmath225 and a fully - faithful monoidal functor @xmath226 , the pullback of @xmath227 along the forgetful functor @xmath228 is @xmath229 .    in summary , we have seen that the interpretation of a container carries the structure of a comonad exactly when it extends to a directed container .",
    "we now show some constructions of directed containers . while some standard constructions of containers extend to directed containers ,",
    "others do not .      given two directed containers @xmath230 , @xmath231 , their coproduct is @xmath182 where the underlying container @xmath232 is the coproduct of containers @xmath78 and @xmath233 .",
    "all of the directed container operations are defined either using @xmath234 or @xmath235 depending on the given shape .",
    "this means that the subshape operation is given by @xmath236 and @xmath237 , the root position is given by @xmath238 and @xmath239 and the subshape position translation operation is given by @xmath240 and @xmath241 .",
    "the interpretation of @xmath199 is isomorphic to the coproduct of comonads @xmath242 and @xmath243 .",
    "@xmath199 defined above is a coproduct of the given directed containers @xmath244 and @xmath245 .",
    "it interprets to a coproduct of the comonads @xmath242 and @xmath243 , whose underlying functor is isomorphic to @xmath246 .",
    "there is no general way to endow the product of the underlying containers of two directed containers @xmath247 and @xmath231 with the structure of a directed container .",
    "one can define @xmath104 and @xmath248 , but there are two choices @xmath249 and @xmath250 for @xmath251 .",
    "moreover , there is no general way to define @xmath146 . but this should not be surprising , as the product of the underlying functors of two comonads is not generally a comonad .",
    "also , the product of two comonads would not be a comonad structure on the product of the underlying functors .",
    "however , for monads it is known that , although the coproduct of two arbitrary monads may not always exist and is generally relatively difficult to construct explicitly @xcite , there is a feasible explicit formula for the coproduct of two ideal monads @xcite .",
    "the duality with comonads gives a formula for the product of two coideal comonads .",
    "a _ coideal comonad _ on @xmath0 is given by a functor @xmath252 and a natural transformation @xmath253 such that the diagrams below commute @xmath254 \\ar[r]^{{\\delta^+ } } & d^+ { \\cdot}d \\ar[d]^{d^+ { \\cdot}{\\varepsilon } } & d^+    \\ar[d]_{{\\delta^+ } } \\ar[r]^{{\\delta^+ } } & d^+ { \\cdot}d \\ar[d]^{d^+ { \\cdot}{\\delta } } \\\\ & d^+ & d^+ { \\cdot}d   \\ar[r]_{{\\delta^+}{\\cdot}d } & d^+ { \\cdot}d { \\cdot}d } \\ ] ] for a functor @xmath255 and natural transformations @xmath256 and @xmath257 defined by    * @xmath258 * @xmath259 + @xmath260 * @xmath261 + @xmath262    the design of this definition ensures that the data @xmath204 make a comonad as soon as the data @xmath263 satisfy the coideal comonad laws .",
    "being a right comodule of the comonad @xmath204 .",
    "for the same concept , also the term ` ideal comonad ' has been used . ]",
    "given two coideal comonads @xmath264 and @xmath265 , the functor @xmath188 given by    * @xmath266    where    * @xmath267    ( assuming the existence of the final coalgebra ) carries a coideal comonad structure that is a product , in the category of all comonads , of the given ones .",
    "next we define the corresponding specialization of directed containers and give an explicit product construction for this case .",
    "a strict directed container is , intuitively , a directed container where no position in a non - root subshape of a shape translates to its root , i.e. , @xmath146 should not be @xmath251 when @xmath268 .",
    "a _ strict directed container _ is specifiable by the data    * @xmath2 * @xmath269 * @xmath270 * @xmath271    satisfying the laws    1 .",
    "@xmath272 2 .",
    "@xmath273    it induces a directed container @xmath274 via    * @xmath275 * @xmath276 + @xmath277 * @xmath278 * @xmath279 + @xmath280 + @xmath281    similarly to coideal comonads , the design of this definition also ensures that the data @xmath282 make a directed container as soon as the data @xmath283 satisfy the strict directed container laws .",
    "the type @xmath284 while the @xmath285 has type @xmath286 , not @xmath287 .",
    "the reason is that the first option for the type of @xmath285 is more general and really the `` correct '' one for comonads . for comonads",
    "whose underlying functors are containers , however , the corresponding type @xmath288 buys no additional generality . ]",
    "strict directed containers are the pullback of the interpretation of directed containers and the inclusion of coideal comonads into comonads .",
    "notice that the special case @xmath12 describes monoids without right - invertible non - unit elements ( such monoids are trivially also without left - invertible non - unit elements ; they arise from adding a unit to a semigroup freely ) .",
    "for example , the datatype of lists and suffixes is a strict directed container ; on the other hand , the datatype of lists and cyclic shifts is not .",
    "we take inspiration from the construction of the product of two coideal comonads and construct the product of two strict directed containers .    given two strict directed containers @xmath289 and @xmath290",
    ", we define the data @xmath291 by    * @xmath292 + where + @xmath293 + * @xmath294 + where + @xmath295 + * @xmath296 + @xmath297 + @xmath298 + where + @xmath299 + @xmath300 + ( by mutuual recursion ) + @xmath301 + @xmath302 + @xmath303 + @xmath304 + * @xmath305 + @xmath306 + @xmath307 + where + @xmath308 + @xmath309 + ( by mutual recursion ) + @xmath310 + @xmath311 + @xmath312 + @xmath313 + @xmath314 + @xmath315    [ prop : prod ] @xmath199 is a product , in the category of all directed containers , of the strict directed containers @xmath244 and @xmath245 .",
    "it interprets to a product , in the category of all comonads , of their interpreting coideal comonads .    the definitions above a considerable amount of detail , but the intuition behind them is not difficult .",
    "the product of two strict directed containers generalizes the coproduct of two monoids without non - unit right - invertible elements .",
    "the elements of this monoid are finite alternating sequences of non - unit elements of the two given monoids .",
    "the definitions above arrange for alternations of a similar nature .      given a container @xmath78 ,",
    "let us define @xmath316 by    * @xmath317 * @xmath318 * ( by recursion ) + @xmath319 + @xmath320 * @xmath321 * ( by recursion ) + @xmath322 + @xmath323    [ prop : cofree ] @xmath199 is a cofree directed container on @xmath324 .",
    "it interprets into a cofree comonad on the functor @xmath325 , which has its underlying functor isomorphic to @xmath326 .    in the special case @xmath327",
    ", we get that @xmath328 and this example degenerates to the free monoid on a given set @xmath329 , i.e. , the monoid of lists over @xmath329 ( with the empty list as the unit and concatenation as the multiplication operation ) .",
    "this directed container interprets into the comonad of nonwellfounded node - labelled @xmath329-branching trees .",
    "a recursive comonad is a coideal comonad @xmath330 such that , for any map @xmath331 , there exists a unique map @xmath332 such that @xmath333^{f^\\dagger } \\ar[d]_{{\\delta}^+ }    & y \\\\",
    "d^+\\ , ( d\\ , x ) \\ar[r]_{d^+\\ , ( x \\times f^\\dagger ) }    & d^+\\ , ( x \\times y ) \\ar[u]_{f } } \\ ] ]    recursive directed containers are the pullback of the interpretation of strict directed containers and the inclusion of recursive comonads into coideal comonads .",
    "now the cofree recursive directed container on a given container @xmath50 is obtained by replacing the @xmath334 in the definition of the shape set @xmath128 of the cofree directed container with @xmath335 .",
    "the interpretation has its underlying functor isomorphic to @xmath336 , which is the cofree recursive comonad on @xmath52 .",
    "while cofree directed containers represent datatypes of node - labelled nonwellfounded trees , cofree recursive directed containers correspond to node - labelled wellfounded trees .",
    "the simplest interesting example is the datatype of non - empty lists ( with its suffixes structure ) , which is represented by the cofree recursive directed container on the `` maybe '' container @xmath337 , i.e. , two shapes , one with no positions , the other with one position .",
    "below we discuss directed containers equipped a notion of focus .",
    "we present a construction for turning any container into a directed container with a designated focus .",
    "we also show that the zipper types of huet  @xcite have a direct representation as directed containers .",
    "any container @xmath78 defines a directed container @xmath338 as follows .",
    "we take @xmath339 , so that a shape is a pair of a shape @xmath6 , the `` shape proper '' , and an arbitrary position @xmath82 in that shape , the `` focus '' .",
    "we take @xmath340 , so that a position in the shape @xmath341 is a position in the shape proper @xmath6 , irrespective of the focus .",
    "the subshape determined by position @xmath144 in shape @xmath342 is given by keeping the shape proper but changing the focus : @xmath343 .",
    "the root in the shape @xmath342 is the focus @xmath82 , so @xmath344 .",
    "finally , we take the translation of positions from the subshape @xmath345 given by position @xmath144 to shape @xmath342 to be the identity , by defining @xmath346 .",
    "all directed container laws are satisfied .",
    "the directed container @xmath199 so obtained interprets into the canonical comonad structure on the functor @xmath347 , where @xmath348 denotes the derivative of the functor @xmath227 .",
    "( for derivatives of set functors and containers , see abbott et al .",
    "@xcite . )",
    "differently from , e.g. , the cofree directed container construction , this construction is not a functor from @xmath43 to @xmath181 . instead , it is a functor from the category of containers and cartesian container morphisms ( where position maps are bijections ) .",
    "inductive ( tree - like ) datatypes with a designated focus position are isomorphic to the zipper types of huet  @xcite .",
    "a zipper data - structure encodes a tree with a focus as a pair of a context and a tree .",
    "the tree is the subtree of the global tree rooted by the focus and the context encodes the rest of the global tree . on zippers , changing the focus",
    "is supported via local navigation operations for moving one step down into the tree or up or aside into the context .",
    "zipper datatypes are directly representable as directed containers .",
    "we illustrate this on the example of zippers for lists ( which are , in fact , the same as zippers for non - empty lists , as one can not focus on a position in the empty list ) .",
    "a list zipper is a pair of a list ( the context ) and a non - empty list ( the suffix determined by the focus position ) .",
    "accordingly , by defining @xmath349 , the shape of a zipper is a pair @xmath350 where @xmath351 is the shape of the context and @xmath352 is the shape of the suffix . for positions , it is convenient to choose @xmath353 by allocating the negative numbers in the interval for positions in the context and non - negative numbers for positions in the suffix .",
    "the root position is @xmath354 , i.e. , the focus .",
    "the subshape for each position is given by @xmath355 and translation of subshape positions by @xmath356 .",
    "[ fig : dcontainernelistfocus ] gives an example of a non - empty list with focus with its shape fixed to @xmath357 .",
    "it should be clear from the figure how the @xmath126 operation works on positions @xmath358 and @xmath359 to get back the position @xmath360 in the initial shape .",
    "the subshape operation @xmath135 works as follows : @xmath129 gives back a subshape @xmath361 and @xmath147 gives @xmath362 .",
    "@xmath363_{p = 4 } \\ar@{->}@/^1pc/[llll]^>>>>>>>{p { \\mathrel{\\oplus}}p =   + p ' = -3 } \\ar@{-}[uurr]_>{s = ( 5,6 ) }   \\ar@{-}[ddrr ] \\ar@{-}[uull ] \\ar@{-}[ddll ] & & \\bullet   & \\bullet   & \\bullet   & \\bullet   \\ar@{.>}@/_1pc/[lllllllll]_>>>>>>>>{p ' = -7 }   \\ar@{.}[uurr]_>{s ' = ( 9,2 ) } \\ar@{.}[ddrr ] \\ar@{.}[uull ] \\ar@{.}[ddll ] & \\bullet & \\bullet\\\\ & & & & &   &   & &   &   &   &   &   & \\\\ & & & & &   &   & &   &   &   &   & & } \\ ] ]    the isomorphism of the directed container representation of the list zipper datatype and the directed container of focussed lists is @xmath364 , @xmath365 , @xmath366 , @xmath367 .",
    "we refrain here from delving deeper into the topic of derivatives and zippers , leaving this discussion for another occasion .",
    "given that comonads whose underlying functor is the interpretation of a container are the same as directed containers , it is natural to ask whether a similar characterization is possible for monads whose underlying functor can be represented as a container .",
    "the answer is `` yes '' , but the additional structure is more involved than that of directed containers .    given a container @xmath44 , the structure @xmath368 of a monad on the functor @xmath369 is interdefinable with the following structure on @xmath50    @xmath370 ( for the shape map for @xmath371 ) ,    @xmath372 ( for the shape map for @xmath335 ) ,    @xmath373 and    @xmath374 ( both for the position map for @xmath335 )    subject to three shape equations and five position equations . perhaps not unexpectedly",
    ", this amounts to having a monoid structure on @xmath50 .",
    "we refrain from a more detailed discussion of this variation of the concept of containers .",
    "to get some intuition , consider the monad structure on the datatype of lists .",
    "the unit is given by singleton lists and multiplication is flattening a list of lists by concatenation .",
    "for the list container @xmath4 , @xmath375 , we get that @xmath376 , @xmath377 , @xmath378}$ ] and @xmath379 .",
    "the reason is that the shape of singleton lists is @xmath380 while flattening a list of lists with outer shape @xmath6 and inner shape @xmath381 for every position @xmath82 in @xmath6 results in a list of shape @xmath382 . for a position @xmath82 in the shape of the flattened list , the corresponding positions in the outer and inner shapes of the given list of lists are @xmath383 and @xmath384",
    "what we have just described is not the only way to relate containers to monads . in a recent work @xcite",
    ", we defined _ cointerpretation _ of containers as the functor @xmath385 $ ] given by @xmath386 differently from @xmath59 , the functor @xmath387 is neither full nor faithful .",
    "it also fails to be monoidal for the monoidal structure on @xmath388 ( taken from @xmath43 ) .",
    "but it is lax monoidal .",
    "it is straightforward that @xmath389 .",
    "lax monoidal functors send monoids to monoids .",
    "hence @xmath387 lifts to a functor @xmath390 that equips each set functor @xmath391 with a monad structure @xmath392 due to the resemblance to compatible compositions of reader and writer monads , we call monads in the image of this functor `` dependently typed update monads ''",
    ". it is instructive to think of shapes in @xmath128 as states , positions in @xmath393 as updates applicable to a state @xmath6 ( or programs safe to evaluate from state @xmath6 ) , @xmath129 as the result of applying an update @xmath82 to the state @xmath6 ( or the result of evaluating @xmath82 from @xmath6 ) , @xmath133 as the nil update in state @xmath6 and @xmath146 as accumulation of two consecutive updates ( skip and sequential composition ) .    the directed container for the nonempty list comonad , @xmath7 , @xmath394 $ ]",
    ", @xmath152 , @xmath164 , @xmath153 , gives us a monad on the set functor @xmath395 given by @xmath396 \\times x$ ] .",
    "the states are natural numbers ; the updates applicable to a state @xmath6 are numbers not greater than @xmath6 ; applying an update means decrementing the state .",
    "we can see that directed containers are not more `` comonadic '' inherently than they are `` monadic '' .",
    "we see them first of all as an algebraic - like structure in their own right , a generalization of monoids .",
    "container theory can be carried out in locally cartesian closed categories ( lcccs)the lccc generalization of containers being well known under the name of polynomials @xcite  and even more generally in categories with pullbacks @xcite .",
    "it is natural to expect the same of directed container theory .",
    "this is the case indeed .",
    "the proofs in this paper can be seen as having been carried out in the internal language of an lccc ( with the assumptions of existence of initial algebras and final coalgebras corresponding to assumptions about availability of w- and m - types ) .    in the weaker",
    "setting of a category with pullbacks , one has to be a lot more careful .",
    "it is possible to define the concepts required from the first principles .",
    "we show the definitions of the counterparts of directed containers and directed container morphisms ; we call them `` directed polynomials '' and `` directed polynomial morphisms '' in the local scope of this section .    in all diagrams below , bullet - labelled nodes with a pair of unlabelled outgoing arcs denote pullbacks defined by a pair of maps that are given directly or constructed . dashed arrows denote unique maps into a pullback .",
    "the polygon actually required to commute is marked with a small circular arrow .",
    "given a category with pullbacks @xmath224 , a directed polynomial is given by    * two objects @xmath128 and @xmath397 ( `` sets '' of shapes and positions ) and an exponentiable map @xmath398 ( assigning every position a shape ) @xmath399^{{\\mathsf{s } } } \\\\ s } \\ ] ] * a morphism @xmath135 picking out a shape for each position ( the corresponding subshape ) @xmath400_{{\\mathrel{\\downarrow } } } & s } \\ ] ] * a map @xmath251 picking out , for every shape , a position in that shape ( the root position ) @xmath399_{\\mathsf{s } } & \\\\ s \\ar@{=}[r ] \\ar@{}[ur]|<<<<{\\circlearrowright } & s \\ar[ul]_{{\\mathsf{o } } } } \\ ] ] * a map @xmath126 sending a position in a given , global shape and a position in the corresponding to subshape to a position in the global shape ( translation of the subshape position to the global shape ) @xmath401_{{\\mathsf{s } } } \\\\   & \\bullet \\ar[ul]_{{\\mathrel{\\oplus } } } \\ar[d ] \\ar[r ]         \\ar@{}[dl]|(0.4){\\circlearrowleft }         & p \\ar[d]^{{\\mathsf{s } } } \\\\   & p \\ar[r]_{{\\mathrel{\\downarrow } } } \\ar[d]^{{\\mathsf{s } } } & s \\\\ & s } \\ ] ]    satisfying the following five laws :    1 .",
    "@xmath400^{{\\mathrel{\\downarrow } } } & s \\ar@{=}[d ] \\ar@{}[dl]|<<<<<{\\circlearrowleft }   \\\\         & s \\ar[ul]^{{\\mathsf{o } } } } \\ ] ] 2 .",
    "@xmath402^{{\\mathrel{\\downarrow } } }    &       & \\\\   & \\bullet \\ar@{}[ur]|(0.4){\\circlearrowright } \\ar[ul]^{{\\mathrel{\\oplus } } } \\ar[d ] \\ar[r ]      & p \\ar[d]^{{\\mathsf{s } } } \\ar[r]_{{\\mathrel{\\downarrow } } }       & s \\\\    & p \\ar[r]_{{\\mathrel{\\downarrow } } }      & s } \\ ] ] 3 .",
    "@xmath403 & \\bullet \\ar@/_1.5pc/[dd ] \\ar[r ]   \\ar[l]_{{\\mathrel{\\oplus } } } \\ar@{}[dl]|(0.3){\\circlearrowright }   & p \\ar@/_1.5pc/[dd]_{{\\mathsf{s } } }   \\\\ & p \\ar@{.>}[u ] & s \\ar[u]_{{\\mathsf{o } } } \\\\ & p \\ar[r]_{{\\mathrel{\\downarrow } } } \\ar@{=}[u ] & s \\ar@{=}[u ] } \\ ] ] 4 .",
    "@xmath403 & \\\\ \\bullet \\ar[d ] \\ar@/^1.5pc/[rr ] \\ar[u]^{{\\mathrel{\\oplus } } } \\ar@{}[ur]|(0.3){\\circlearrowleft } & p \\ar@{.>}[l ] & p \\ar[d]^{{\\mathsf{s } } } \\ar@{=}[l ] \\\\",
    "p \\ar@/^1.5pc/[rr]^{{\\mathrel{\\downarrow } } } & s \\ar[l]^{{\\mathsf{o } } } \\ar@{=}[r ] & s } \\ ] ] 5 .",
    "@xmath404|-{\\circlearrowright }    & \\bullet \\ar[l]_{{\\mathrel{\\oplus } } }   \\ar@/_1.5pc/[ddd ] \\ar[r ]     & p \\ar@/_1.5pc/[ddd]_(0.47){{\\mathsf{s } } } \\\\",
    "\\bullet \\ar[d ] \\ar@/^1.5pc/[rrr ] \\ar[u]^{{\\mathrel{\\oplus } } }   & \\bullet \\ar[d ]   \\ar[r ] \\ar@{.>}[u ] \\ar@{.>}[l ]     & \\bullet \\ar[d ] \\ar[r ] \\ar[u]_{{\\mathrel{\\oplus } } }       & p \\ar[d]^{{\\mathsf{s } } }   \\\\ p \\ar@/^1.5pc/[rrr]^(0.47){{\\mathrel{\\downarrow } } }   & \\bullet \\ar[l]^{{\\mathrel{\\oplus } } } \\ar[d ] \\ar[r ]     & p \\ar[r]_{{\\mathrel{\\downarrow } } } \\ar[d]^{{\\mathsf{s } } } & s \\\\ & p \\ar[r]_{{\\mathrel{\\downarrow } } }     & s } \\ ] ]    the data @xmath128 , @xmath135 , @xmath251 , @xmath126 here correspond to the homonymous data of a directed container while @xmath397 and @xmath398 together correspond to @xmath397 .",
    "the five laws governing them correspond exactly to the five laws of a directed container .    a _ morphism _ between two directed polynomials @xmath405 and",
    "@xmath406 is given by two maps @xmath177 and @xmath178 ( of shapes and positions ) @xmath407_{{\\mathsf{s } } }    &       & \\\\ \\ar@{}[r]|-{\\circlearrowright }    & \\bullet \\ar[ul]_{q } \\ar[dl ] \\ar[dr ]      & \\\\ s \\ar[ddrr]_{t }    &       & p ' \\ar[dd]^{{\\mathsf{s } } ' } \\\\    &       & \\\\    &       & s ' } \\ ] ] satisfying the following three laws :    1 .",
    "@xmath408^{{\\mathrel{\\downarrow } } }    &       & s \\ar[ddrr]^{t }        &          & \\\\    & \\bullet \\ar[ul]^{q } \\ar[dl ] \\ar[dr ] \\ar@{}[rr]|-{\\circlearrowright }      &         &           & \\\\ s \\ar[ddrr]_{t }    &       & p ' \\ar[dd]^{{\\mathsf{s } } ' } \\ar[rr]^{{\\mathrel{\\downarrow ' } } }         &          & s ' \\\\    &       &         &           & \\\\    &       & s '         &          & } \\ ] ] 2 .",
    "@xmath409|-{\\circlearrowright }    & \\bullet \\ar[ul]_{q } \\ar[ddl ] \\ar[dr ]   \\\\ s \\ar[uu]^{{\\mathsf{o } } } \\ar@{=}[d ] \\ar@{.>}[ur ]    & & p ' \\ar@/_2pc/[ddd]_(0.4){{\\mathsf{s}}'}\\\\ s \\ar[ddrr]_{t } \\\\    & & s ' \\ar[uu]_{{\\mathsf{o ' } } } \\ar@{=}[d]\\\\    & & s '   } \\ ] ] 3 .",
    "@xmath410|(0.4){\\circlearrowright }      & & & \\\\ & & \\bullet \\ar[uuu]^{{\\mathrel{\\oplus } } } \\ar[rr ] \\ar[dd ]      & & p \\ar[dd]^{{\\mathsf{s } } }          & \\bullet \\ar[uuulll]_(0.35){q } \\ar@/^2.3pc/[ddddlll ] \\ar[dddrrr]\\\\ \\\\ & & p \\ar[rr]_{{\\mathrel{\\downarrow } } } \\ar[dd]_{{\\mathsf{s } } }      & & s \\ar@/^1pc/[ddddddrrrrrr]^(0.4){t}\\\\ & & & & & \\bullet \\ar[dlll ] \\ar[dddrrr ] \\ar@{.>}[rr ] \\ar@{.>}[dd ]                     \\ar@/^1pc/@{.>}[uuulll ] \\ar@{.>}[uuu ]            & & \\bullet \\ar[uuulll]_(0.35){q } \\ar[ulll ] \\ar[dddrrr ]                & p ' \\ar@/_2pc/[ddddddd]_(0.45){{\\mathsf{s } } ' } \\\\ & & s \\ar[ddddddrrrrrr]_{t }      & & & & & \\\\ & & & & & \\bullet \\ar[uuulll]^(0.35){q } \\ar[ulll ] \\ar[dddrrr ]             \\\\ & & & & & & & & \\bullet \\ar[uuu]_(0.4){{\\mathrel{\\oplus ' } } } \\ar[rr ] \\ar[dd ]                  & & p ' \\ar[dd]^{{\\mathsf{s}}'}\\\\ \\\\ & & & & & & & & p ' \\ar[rr]_{{\\mathrel{\\downarrow ' } } } \\ar[dd]^{{\\mathsf{s } } ' }                  & & s ' \\\\ \\\\ & & & & & & & & s ' } \\ ] ]    the data @xmath177 , @xmath178 correspond to the homonymous data of a directed container morphism and the three laws to the three laws of a directed container morphism .    in the special case @xmath411 ,",
    "the definitions of a directed polynomial and directed polynomial morphism are equivalent to those of a directed container and directed container morphism .    remarkably , the definition of a directed polynomial is completely symmetric in @xmath398 and @xmath135swapping them over we also get a directed polynomial .",
    "the definition of a directed polynomial morphism is symmetric , if @xmath178 is an isomorphism .",
    "the definitions of the interpretation of a directed polynomial resp . directed polynomial morphism into a comonad resp .",
    "comonad morphism require using distributivity pullbacks in @xmath224 ( or pullbacks in its slice categories ) .",
    "the core of this paper builds on the theory of containers as developed by abbott , altenkirch and ghani @xcite to analyze strictly positive datatypes .",
    "some generalizations of the concept of containers are the indexed containers of altenkirch and morris @xcite and the quotient containers of abbott et al .",
    "@xcite . in our work",
    "we look at a specialization of containers rather than a generalization .",
    "recently @xcite , we have also studied compatible compositions of directed containers and how they generalize zappa - szp products @xcite of two monoids .",
    "simple / indexed containers are intimately related to strongly positive datatypes / families and simple / dependent polynomial functors as appearing in the works of dybjer @xcite , moerdijk and palmgren @xcite , gambino and hyland @xcite , kock @xcite .",
    "girard s normal functors @xcite and joyal s analytic functors @xcite functors are similar to containers resp.quotient containers , but only allow for finitely many positions in a shape .",
    "gambino and kock @xcite also treat polynomial monads .",
    "abbott , altenkirch , ghani and mcbride @xcite have investigated derivatives of datatypes .",
    "derivatives provide a systematic way to explain huet s zipper type @xcite .",
    "brookes and geva @xcite and later uustalu with coauthors @xcite have used comonads to analyze notions of context - dependent computation such as dataflow computation , attribute grammars , tree transduction and cellular automata .",
    "uustalu and vene s @xcite observation of a connection between bottom - up tree relabellings and containers with extra structure started our investigation into directed containers .",
    "we introduced directed containers as a specialization of containers for describing a certain class of datatypes ( data - structures where every position determines a sub - data - structure ) that occur very naturally in programming .",
    "it was a pleasant discovery for us that directed containers are an entirely natural concept also from the mathematical point of view : they are the same as containers whose interpretation carries the structure of a comonad .",
    "they also generalize monoids in an interesting way .",
    "in a recent piece of work @xcite , we have witnessed that coalgebras of comonads interpreting directed containers are relevant for bidirectional transformations as a flavor of lenses ( `` dependently typed update lenses '' ) .    as future work , we intend to take a closer look at focussing and related concepts , such as derivatives .",
    "a curious special case of directed containers supports translation of the root of a shape into every subshape .",
    "such bidirectional containers include , e.g. , focussed containers and generalize groups in the same way as directed containers generalize monoids .",
    "we would like to find out if this specialization of directed containers is an interesting and useful concept .",
    "we wonder whether our explicit formula for the product of two directed containers can be scaled to the general , non - strict , case .",
    "last , we would like to analyze containers that are monads more closely .",
    "we are indebted to thorsten altenkirch , jeremy gibbons , peter morris , and sam staton for comments and suggestions .",
    "we thank our anonymous referees for the useful feedback that helped us improve the article .",
    "10    m. abbott .",
    "_ categories of containers_. phd thesis , university of leicester , 2003 .",
    "m. abbott , t. altenkirch , n. ghani .",
    "containers : constructing strictly positive types .",
    ".  comput .",
    "_ , 342(1):327 , 2005 .",
    "m. abbott , t. altenkirch , n. ghani , c. mcbride .",
    "constructing polymorphic programs with quotient types . in d. kozen ,",
    ", _ proc .  of 7th int .",
    "conf .  on mathematics of program construction , mpc 2004 _ , vol .",
    "3125 of _ lect .",
    "notes in comput .",
    "_ , pp . 215 .",
    "springer , 2004 .",
    "m. abbott , t. altenkirch , n. ghani , c. mcbride .",
    "@xmath412 is for data : differentiating data structures .",
    "inform . _ , 65(12):128 , 2005 .",
    "d. ahman , j. chapman , t. uustalu .",
    "when is a container a comonad ? in l.  birkedal , ed .",
    ", _ proc .  of 15th int .",
    "conf . on foundations of software science and computation structures , fossacs 2012 _ ,",
    "7213 of _ lect .",
    "notes in comput .",
    "_ , pp .  7488 .",
    "springer , 2012 .",
    "d. ahman , t. uustalu .",
    "coalgebraic update lenses . in b. jacobs , a. silva , s. staton , eds .",
    ", _ proc . of 30th conf . on mathematical foundations of programming semantics , mfps xxx _ , _ electron .",
    "notes in theor . comput .",
    "_ , elsevier , to appear .",
    "d. ahman , t. uustalu .",
    "distributive laws of directed containers . _",
    "progress in informatics _",
    ", 10:318 , 2013 .",
    "d. ahman , t. uustalu .",
    "update monads : cointerpreting directed containers . in r. matthes , a. schubert , eds .",
    ", _ proc . of 19th conf . on types for proofs and programs , types 2013 _ , vol .",
    "26 of _ leibniz int",
    ".  proc .  in inform .",
    "_ , pp . 123 . dagstuhl publishing , 2014 .",
    "t. altenkirch , p. morris .",
    "indexed containers . in _ proc .  of 24th ann .",
    "ieee symp .  on logic in computer science , lics 2009 _ , pp . 277285 .",
    "ieee cs press , 2009 .",
    "j.  beck .",
    "distributive laws . in b.",
    "eckmann , ed . , _",
    "seminar on triples and categorical homology , eth 1966/67 _ , vol .",
    "80 of _ lect .",
    "notes in math .",
    "_ , pp .  119140 .",
    "springer , 1969 .",
    "m.  g. brin . on the zappa - szp product .",
    "_ commun .  in algebra _",
    ", 33(2):393424 , 2005 .",
    "s. brookes , s. geva . computational comonads and intensional semantics . in m.",
    "p. fourman , p. t. johnstone , a. m. pitts , eds .",
    ", _ applications of categories in computer science _ ,",
    "77 of _ london math .",
    "society lect .",
    "note series _ , pp .",
    "cambridge univ .  press , 1992 .",
    "s. capobianco , t. uustalu . a categorical outlook on cellular automata . in j. kari , ed .",
    ", _ proc . of 2nd symp . on cellular automata , jac 2010 _ , vol .  13 of _ tucs lecture note series _",
    ", pp . 8889 .",
    "turku centre for comput .",
    "sci . , 2011 .",
    "p. dybjer . representing inductively defined sets by wellorderings in martin - lf s type theory .",
    "_ theor .",
    "_ , 176(12):329335 , 1997 .",
    "n. gambino , m. hyland . wellfounded trees and dependent polynomial functors . in s. berardi , m. coppo , f. damiani , eds . , _ revised selected papers from int .",
    "wksh .  on types for proofs and programs , types 2003 _ , vol .",
    "2075 of _ lect .",
    "notes in comput .",
    "_ , pp . 210225 .",
    "springer , 2004 .",
    "n. gambino , j. kock .",
    "polynomial functors and polynomial monads .",
    "proc . of cambridge phil .",
    "_ , 154(1):153192 , 2013 . n. ghani , t. uustalu .",
    "coproducts of ideal monads .",
    "inform . and appl .",
    "_ , 38(4 ) : 321342 , 2004 .    j .- y .",
    "normal functors , power series and lambda - calculus . _ ann .  of pure and appl .  logic _",
    ", 37(2):129177 , 1988 .",
    "i. hasuo , b. jacobs , t. uustalu .",
    "categorical views on computations on trees . in l. arge , c. cachin , t. jurdzinski , a. tarlecki , eds .",
    ", _ proc .  of 34th int .",
    "on automata , languages and programming , icalp 2007 _ , vol .",
    "4596 of _ lect .",
    "notes in comput .",
    "_ , pp . 619630 .",
    "springer , 2007 .",
    "g. huet . the zipper . _ j. of funct .",
    "_ , 7(5):549554 , 1997 .    a. joyal .",
    "foncteurs analytiques et espces de structures . in g. labelle , p. leroux , eds .",
    ", _ combinatoire numerative _ , vol .",
    "1234 of _ lect .",
    "notes in math .",
    "_ , pp . 126159 .",
    "springer , 1987 .",
    "g.  m. kelly . a unified treatment of transfinite constructions for free algebras , free monoids , colimits , associated sheaves and so on .",
    "_ bull . of austral .",
    "_ , 22(1):183 , 1980 .",
    "polynomial functors and trees .",
    "research notices _ , 2011(3):609673 , 2011 .",
    "i. moerdijk , e. palmgren .",
    "wellfounded trees in categories .",
    "pure and appl .",
    "104(13):189218 , 2000 .",
    "p. morris .",
    "constructing universes for generic programming .",
    "phd thesis , university of nottingham , 2007 .",
    "u. norell .",
    "towards a practical programming language based on dependent type theory .",
    "phd thesis , chalmers university of technology , 2007 .",
    "u. norell .",
    "dependently typed programming in agda . in p.",
    "koopman , r.  plasmeijer , and d.  swierstra , eds . , _ revised lectures from 6th int .",
    "school on advanced functional programming , afp 2008 _ , vol .",
    "5832 of _ lect .",
    "notes in comput .",
    "_ , pp . 230266 .",
    "springer , 2009 .",
    "r. prince , n. ghani , c. mcbride .",
    "proving properties about lists using containers . in j. garrigue , m. hermenegildo , eds .",
    ", _ proc .",
    "of 9th int .  symp . on functional and logic programming , flops 2008 _ , vol .",
    "4989 of _ lect .",
    "notes in comput .",
    "_ , pp . 97112 .",
    "springer , 2008 .",
    "t. uustalu , v. vene .",
    "the essence of dataflow programming . in k.",
    ", _ proc .  of 2nd asian symp . on programming languages and systems , aplas 2004 _ ,",
    "3780 of _ lect .",
    "notes in comput .",
    "_ , pp . 218 .",
    "springer , 2004 .",
    "t. uustalu , v. vene .",
    "comonadic functional attribute evaluation . in m.",
    "van eekelen , ed . ,",
    "_ trends in functional programming 6 _ , pp .",
    "intellect , 2007 .",
    "t. uustalu , v. vene .",
    "comonadic notions of computation . in j. admek",
    ", c. kupke , eds . , _ proc . of 9th int .",
    "wksh .  on coalgebraic methods in computer science , cmcs 2008 _ , vol .",
    "203(5 ) of _ electron .  notes in theor .",
    "_ , pp . 263284 .",
    "elsevier , 2008 .",
    "polynomials in categories with pullbacks .",
    "arxiv preprint , arxiv:1106.1983 .",
    "sulla costruzione dei gruppi prodotto di due dati sottogruppi permutabili tra loro . in _",
    "atti secondo congresso dellunione matemtica italiana _ , pp .",
    "edizioni cremonense , rome , 1942 .",
    "we must check that the interpretation @xmath413 of the given directed container @xmath179 is a comonad .",
    "proof of the right counital law : @xmath414 proof of the left counital law : @xmath415 proof of the coassociativity law : @xmath416    we must also verify that the interpretation @xmath417 of a morphism @xmath40 between two directed containers @xmath418 and @xmath419 is a comonad morphism between @xmath420 and @xmath421 .",
    "proof of the counit preservation law : @xmath422 proof of the comultiplication preservation law : @xmath423      from proposition  [ prop : csemfullyfaithful ] , we know that the interpretation of containers is fully faithful . it remains to show that , for directed containers @xmath424 , @xmath425 and a morphism @xmath65 between the comonads @xmath183 and @xmath193 , the container morphism @xmath426 between @xmath50 and @xmath68 is also a directed container morphism between @xmath199 and @xmath200 .    the counit and comultiplication @xmath186 and @xmath187 of the comonad @xmath183 induce container morphisms @xmath427 and @xmath428 by @xmath429 , @xmath430 .",
    "similarly @xmath431 and @xmath432 give us container morphisms @xmath433 and @xmath434 by @xmath435 , @xmath436 .",
    "let us express @xmath437 and @xmath438 directly in terms of @xmath135 , @xmath251 , @xmath126 .    first",
    ", from the definitions of @xmath186 , @xmath439 we get @xmath440 the definition of @xmath441 further gives us @xmath442    second , the definitions of @xmath187 , @xmath443 dictate that @xmath444 the definition of @xmath441 allows us to infer that @xmath445 analogous direct expressions in terms of @xmath446 , @xmath447 , @xmath448 hold for @xmath449 , @xmath450 .",
    "now , using @xmath451 above , we can repackage the two comonad morphism laws for @xmath452 in terms of container interpretations as depicted in the following two diagrams . @xmath453^{{\\mathsf{e } } } \\ar@{}[l]|(0.6){\\textrm{def .",
    "$ h^{{\\varepsilon}'}$ } } \\ar@{}[r]|(0.6){\\textrm{def .",
    "$ h^{\\varepsilon}$ } } & \\\\ { \\llbracket c \\rrbracket^\\mathrm{c } } \\ar[rr]^{{\\llbracket h \\rrbracket^\\mathrm{c } } } \\ar[ur]^{{\\varepsilon } } \\ar@/^2pc/[uur]^{{\\llbracket { h^{\\varepsilon}}\\rrbracket^\\mathrm{c } } }   \\ar@{}[ur]_(0.4){\\textrm{counit pres . } }   & & { \\llbracket c ' \\rrbracket^\\mathrm{c } } \\ar[ul]_{{\\varepsilon } ' } \\ar@/_2pc/[uul]_{{\\llbracket { h^{\\varepsilon'}}\\rrbracket^\\mathrm{c } } }   } \\hspace*{2 cm } \\xymatrix@c=2.5em@r=3em { & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c}}\\ar[r]^{{\\llbracket h { \\mathrel{\\cdot^\\mathrm{c}}}h \\rrbracket^\\mathrm{c } } }     & { \\llbracket c ' { \\mathrel{\\cdot^\\mathrm{c}}}c ' \\rrbracket^\\mathrm{c } }   \\\\ & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar[r]^{{\\llbracket h \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket h \\rrbracket^\\mathrm{c}}}\\ar[u]^{{\\mathsf{m}}\\ , { \\{c , c\\ } } } \\ar@{}[ur]|{\\textrm{nat .",
    "$ { \\mathsf{m}}$ } } \\ar@{}[dr]|{\\textrm{comult . pres . } } \\ar@{}[dl]_(0.35){\\textrm{def .",
    "$ { h^{\\delta}}$ } }    & { { \\llbracket c ' \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c ' \\rrbracket^\\mathrm{c}}}\\ar[u]_{{\\mathsf{m}}\\ , { \\{c',c'\\ } } } \\ar@{}[dr]^(0.35){\\textrm{def .",
    "$ { h^{\\delta'}}$}}\\\\ & { \\llbracket c \\rrbracket^\\mathrm{c}}\\ar[r]^{{\\llbracket h \\rrbracket^\\mathrm{c}}}\\ar[u]^{\\delta}\\ar@/^4pc/[uu]^{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } }   & { \\llbracket c ' \\rrbracket^\\mathrm{c}}\\ar[u]_{{\\delta } ' } \\ar@/_4pc/[uu]_{{\\llbracket { h^{\\delta'}}\\rrbracket^\\mathrm{c } } }        & } \\ ] ]    going a step further , we can quote these two diagrams to get their reformulations in terms of containers , resulting in the two diagrams below .",
    "@xmath454^{h } \\ar[ur]^{{h^{\\varepsilon } } } & & c ' \\ar[ul]_{{h^{\\varepsilon ' } } }   } \\hspace*{2 cm } \\xymatrix@c=2.5em@r=3em { { c { \\mathrel{\\cdot^\\mathrm{c}}}c } \\ar[r]^{h { \\mathrel{\\cdot^\\mathrm{c}}}h } & { c ' { \\mathrel{\\cdot^\\mathrm{c}}}c'}\\\\ c \\ar[r]^{h } \\ar[u]^{{h^{\\delta } } }   & c ' \\ar[u]_{{h^{\\delta ' } } } } \\ ] ]    we are now in a position to prove that @xmath455 satisfies directed container morphism laws .    from the counit preservation law by going clockwise",
    "we get that @xmath456 & { t^{\\varepsilon}}s\\\\ c \\ar[r]^{h^{{\\varepsilon } } } & { \\mathsf{id}^\\mathrm{c}}\\\\ { q^{\\varepsilon}}\\ , { \\{s\\}}\\ , { { \\ast } } & \\ar@{|->}[l ] { { \\ast}}}\\ ] ] and by going counter - clockwise @xmath456 & t s \\ar@{|->}[r ] & { t^{\\varepsilon'}}(t\\ , s)\\\\ c \\ar[r]^{h } & c ' \\ar[r]^{h^{{\\varepsilon } ' } } & { \\mathsf{id}^\\mathrm{c}}\\\\ q\\ , { \\{s\\}}\\ , ( { q^{\\varepsilon'}}\\ , { \\{t\\ , s\\}}\\ , { { \\ast } } ) & { q^{\\varepsilon'}}\\ , { \\{t\\ , s\\}}\\ , { { \\ast}}\\ar@{|->}[l ] & \\ar@{|->}[l ] { { \\ast}}}\\ ] ] which gives us the second directed container morphism law : @xmath457    clockwise traversal of the comultiplication preservation law gives us that @xmath458   & { t^{\\delta}}\\ , s \\ar@{|->}[r ]     & * \\txt{$(t\\ , ( { \\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s ) ) , $ \\\\$\\lambda p.\\ , t\\ , ( { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s ) $ \\\\$(q\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , p)))$}\\\\ c \\ar[r]^{h^{\\delta } } & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{h { \\mathrel{\\cdot^\\mathrm{c}}}h }     & c ' { \\mathrel{\\cdot^\\mathrm{c}}}c'\\\\ * \\txt{${q^{\\delta}}{\\{s\\ } } $ \\\\$(q\\,{\\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , p , $ \\\\$q\\ , { \\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , ( q\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , p)\\}}\\ , p')$ }   & * \\txt{$(q\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , p , $ \\\\$q { \\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , ( q\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , p)\\}}\\ , p')$ } \\ar@{|->}[l ]     & ( p , p ' ) \\ar@{|->}[l ] } \\ ] ] and counter - clockwise traversal that @xmath458   & t\\ , s \\ar@{|->}[r ]     & * \\txt{${t^{\\delta'}}\\ , ( t\\ , s)$}\\\\   c \\ar[r]^{h }   & c ' \\ar[r]^{h^{{\\delta } ' } }     & c ' { \\mathrel{\\cdot^\\mathrm{c}}}c'\\\\ q\\ , { \\{s\\}}\\ , ( { q^{\\delta'}}\\ , { \\{t\\ , s\\}}\\ , ( p , p ' ) )   & { q^{\\delta'}}\\ , { \\{t\\ , s\\}}\\ , ( p , p ' ) \\ar@{|->}[l ]     & ( p , p ' ) \\ar@{|->}[l ] } \\ ] ] from where we can derive both the first and the third directed container morphism laws : @xmath459@xmath460 @xmath461@xmath462@xmath463      we need to verify that @xmath464 satisfies the directed container laws and can assume that @xmath204 satisfies the comonad laws .",
    "the comonad laws can be rewritten in terms of container interpretations as outlined in the following commuting diagrams : @xmath465^{{\\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\varepsilon}}\\rrbracket^\\mathrm{c } } }   & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}{\\mathsf{id}^\\mathrm{c}}\\rrbracket^\\mathrm{c } } \\ar@/^2.5pc/[ddr]^{{\\llbracket \\rho \\rrbracket^\\mathrm{c}}}\\\\ \\ar@{}[ur]|{\\textrm{nat.\\ , $ { \\mathsf{m}}$ } }     & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket { \\mathsf{id}^\\mathrm{c}}\\rrbracket^\\mathrm{c}}\\ar[u]_{{\\mathsf{m}}\\ , { \\{c,{\\mathsf{id}}\\ } } }   \\ar@{}[r]_(0.65){\\textrm{mon.\\ f.\\ r.\\ unit } }      & \\\\ { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar[r]^{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\varepsilon } } \\ar[uu]^{{\\mathsf{m}}\\ , { \\{c , c\\ } } } \\ar@/^1pc/[ur]^{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket { h^{\\varepsilon}}\\rrbracket^\\mathrm{c } } }   \\ar@{}[ur]|{\\textrm{def .",
    "$ { h^{\\varepsilon}}$ } } \\ar@{}[uu]^(0.2){\\textrm{def .",
    "$ { h^{\\delta}}$ } }   & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\mathsf{id}}\\ar@{=}[r ] \\ar[u]_{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\mathsf{e } } }      & { \\llbracket c \\rrbracket^\\mathrm{c}}\\\\ { \\llbracket c \\rrbracket^\\mathrm{c } } \\ar[u]^{{\\delta } } \\ar@/^3pc/[uuu]^{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } } \\ar@{=}[urr ] \\ar@{}[ur]^{\\textrm{com .",
    "r.\\ counit } }   } \\xymatrix@c=3em@r=3em { & { \\llbracket { \\mathsf{id}^\\mathrm{c}}{\\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar@/_2.5pc/[ddl]_{{\\llbracket \\lambda \\rrbracket^\\mathrm{c } } } & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar[l]_{{\\llbracket { h^{\\varepsilon}}{\\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } } \\\\ & \\ar@{}[l]^(0.65){\\textrm{mon.\\ f.\\ l.\\ unit } } \\ar@{}[ur]|{\\textrm{nat .",
    "$ { \\mathsf{m}}$ } } { \\llbracket { \\mathsf{id}^\\mathrm{c}}\\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar[u]^{{\\mathsf{m}}\\ , { \\{{\\mathsf{id } } , c\\}}}\\\\ { \\llbracket c \\rrbracket^\\mathrm{c } }   & { \\mathsf{id}}{\\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar@2{-}[l ] \\ar[u]^{{\\mathsf{e}}{\\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } }      & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar[l]_{{\\varepsilon}{\\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } } \\ar[uu]_{{\\mathsf{m}}\\ , { \\{c , c\\ } } } \\ar@/_1pc/[ul]_{{\\llbracket { h^{\\varepsilon}}\\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } } \\ar@{}[ul]|{\\textrm{def .",
    "$ { h^{\\varepsilon}}$ } } \\ar@{}[uu]_(0.2){\\textrm{def .",
    "$ { h^{\\delta}}$ } } \\\\ & & { \\llbracket c \\rrbracket^\\mathrm{c } } \\ar[u]_{{\\delta } } \\ar@2{-}[ull ] \\ar@{}[ul]_{\\textrm{com",
    ". l. counit } } \\ar@/_3pc/[uuu]_{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } } } \\ ] ]    @xmath466_{\\textrm{com .",
    "coass . } } \\ar[rr]_{{\\delta } } \\ar[d]^{{\\delta } } \\ar@/^2pc/[rrr]^{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c}}}_{\\textrm{def .",
    "$ { h^{\\delta}}$ } } \\ar@/_3pc/[dd]_{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } }     & & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } }   \\ar[r]^{{\\mathsf{m}}\\ , { \\{c , c\\ } } } \\ar[d]_{{\\delta}{\\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } } \\ar@/^0.5pc/[dr]^{{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } }   \\ar@{}[dr]_{\\textrm{def .",
    "$ { h^{\\delta}}$ } }        & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar@/^3pc/[dd]^{{\\llbracket { h^{\\delta}}{\\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } } \\\\ { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar@{}[u]^{\\textrm{def .",
    "$ { h^{\\delta}}$ } } \\ar@{}[dr]^{\\textrm{def . $ { h^{\\delta}}$ } } \\ar[d]^{{\\mathsf{m}}\\ , { \\{c , c\\ } } } \\ar[r]^-{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\delta } } \\ar@/_0.5pc/[dr]_{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket { h^{\\delta}}\\rrbracket^\\mathrm{c } } }     & { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}({\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } ) \\ar[d]^{{\\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\mathsf{m}}\\ , { \\{c , c\\ } } }           \\ar@{}[drr]|{\\textrm{mon . f. ass . } }      & ( { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } ) { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar@{=}[l ] \\ar[r]_{{\\mathsf{m}}\\ , { \\{c , c\\ } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } }             & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c \\rrbracket^\\mathrm{c } } \\ar[d]_{{\\mathsf{m}}\\ , { \\{c { \\mathrel{\\cdot^\\mathrm{c}}}c , c\\ } } } \\ar@{}[u]|{\\textrm{nat . $ { \\mathsf{m}}$}}\\\\ { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar@/_2pc/[rr]_{{\\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\delta}}\\rrbracket^\\mathrm{c } } }     &   { \\llbracket c \\rrbracket^\\mathrm{c } } { \\cdot}{\\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar[r]^{{\\mathsf{m}}\\ , { \\{c , c { \\mathrel{\\cdot^\\mathrm{c}}}c\\ } } } \\ar@{}[d]|(0.3){\\textrm{nat .",
    "$ { \\mathsf{m}}$ } }      & { \\llbracket c { \\mathrel{\\cdot^\\mathrm{c}}}(c { \\mathrel{\\cdot^\\mathrm{c}}}c ) \\rrbracket^\\mathrm{c } }        &   { \\llbracket ( c { \\mathrel{\\cdot^\\mathrm{c}}}c ) { \\mathrel{\\cdot^\\mathrm{c}}}c \\rrbracket^\\mathrm{c } } \\ar[l]_{{\\llbracket \\alpha \\rrbracket^\\mathrm{c } } } \\\\   & &   } \\ ] ]    next we quote these three diagrams to get the comonad laws in terms of containers in the next three commuting diagrams .",
    "@xmath467 ^ -{c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\varepsilon } } } & c { \\mathrel{\\cdot^\\mathrm{c}}}{\\mathsf{id}^\\mathrm{c}}\\ar[r]^{\\rho }   & c\\\\ c \\ar[u]^{{h^{\\delta } } } \\ar@{=}[urr ] } \\quad \\xymatrix@c=3.5em@r=3em { c & { \\mathsf{id}^\\mathrm{c}}{\\mathrel{\\cdot^\\mathrm{c}}}c \\ar[l]_{\\lambda } & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[l]_-{{h^{\\varepsilon}}{\\mathrel{\\cdot^\\mathrm{c}}}c } \\\\ & & c \\ar[u]_{{h^{\\delta } } } \\ar@{=}[ull ] } \\ ] ] @xmath468^{{h^{\\delta } } } \\ar[d]_{{h^{\\delta } } }     &       & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[d]^{{h^{\\delta}}{\\mathrel{\\cdot^\\mathrm{c}}}c } \\\\ c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^-{c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\delta } } }     &   c { \\mathrel{\\cdot^\\mathrm{c}}}(c { \\mathrel{\\cdot^\\mathrm{c}}}c )      & ( c { \\mathrel{\\cdot^\\mathrm{c}}}c ) { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[l]_-{\\alpha } } \\ ] ]    from the comonad right counital law we get by going clockwise @xmath458 & { t^{\\delta}}s \\ar@{|->}[r ]   & * \\txt{$({\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s),$\\\\$\\lambda\\ \\_.\\ , { { \\ast}})$ } \\ar@{|->}[r ]     & { \\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\\\ c \\ar[r]^{{h^{\\delta } } }   & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\varepsilon } } }     & c { \\mathrel{\\cdot^\\mathrm{c}}}{\\mathsf{id}^\\mathrm{c}}\\ar[r]^{\\rho } & c\\\\ * \\txt{${q^{\\delta}}{\\{s\\}}\\ , ( p , $ \\\\${q^{\\varepsilon}}\\ , { \\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , p\\}}\\ , { { \\ast}})$ }   & * \\txt{$(p , $ \\\\${q^{\\varepsilon}}\\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , p\\}\\ , { { \\ast}})$ } \\ar@{|->}[l ]     & ( p,{{\\ast } } ) \\ar@{|->}[l ] & p \\ar@{|->}[l ] } \\ ] ] from where it follows that @xmath187 preserves the shape of the given data - structure as the outer shape of the composite data - structure returned and that the third directed container law holds : @xmath469 @xmath470    similarly , from the comonad left counital law we get by going counter - clockwise @xmath471   & { t^{\\delta}}s \\ar@{|->}[r ]     & * \\txt{$({{\\ast } } , \\lambda { { \\ast}}.\\ , { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s ) $ \\\\$({q^{\\varepsilon}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}))$ } \\ar@{|->}[r ]       & * \\txt{${\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s ) $ \\\\$({q^{\\varepsilon}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , { { \\ast}})$}\\\\ c \\ar[r]^{{h^{\\delta } } }   &",
    "c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{{h^{\\varepsilon}}{\\mathrel{\\cdot^\\mathrm{c}}}c }     & { \\mathsf{id}^\\mathrm{c}}{\\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{\\lambda }       & c\\\\ * \\txt{${q^{\\delta}}\\ , { \\{s\\ } } $ \\\\$({q^{\\varepsilon}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , { { \\ast } } , p)$ }   & * \\txt{$({q^{\\varepsilon}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , { { \\ast } } , $ \\\\$p)$ } \\ar@{|->}[l ]     & ( { { \\ast}},p ) \\ar@{|->}[l ]       & p \\ar@{|->}[l ] } \\ ] ] from where the first and fourth directed container laws follow : @xmath472 @xmath473    the last two directed container laws are derivable from the comonad coassociativity law . by going clockwise",
    "we get @xmath474   & { t^{\\delta}}s \\ar@{|->}[r ]     & * \\txt{$({t^{\\delta}}\\ , ( { \\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s ) ) , $ \\\\${\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s ) { \\circ}$\\\\$({q^{\\delta}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}))$ } \\ar@{|->}[r ]       & * \\txt{$({\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , ( { \\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s ) ) ) , $ \\\\$(\\lambda p.\\ , { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , ( { \\mathsf{fst}}\\ , ( { t^{\\delta}}s)))\\ , p,$\\\\$\\lambda p'.\\ , { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s ) $ \\\\$({q^{\\delta}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\}}\\ , ( p , p'))))$}\\\\ c \\ar[r]^{{h^{\\delta } } }   & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{{h^{\\delta}}{\\mathrel{\\cdot^\\mathrm{c}}}c }     & ( c { \\mathrel{\\cdot^\\mathrm{c}}}c ) { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{\\alpha }       & c { \\mathrel{\\cdot^\\mathrm{c}}}(c { \\mathrel{\\cdot^\\mathrm{c}}}c)\\\\ * \\txt{$({q^{\\delta}}{\\{s\\ } } $ \\\\$({q^{\\delta}}\\ , { \\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\ } } $ \\\\$(p , p'),p'')$ }   & * \\txt{$({q^{\\delta}}{\\{{\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s)\\ } } $ \\\\$(p , p ' ) , p'')$ } \\ar@{|->}[l ]     & ( ( p , p'),p '' ) \\ar@{|->}[l ]       & ( p , ( p ' , p '' ) ) \\ar@{|->}[l ] } \\ ] ] and by going counter - clockwise we get @xmath475 & { t^{\\delta}}s \\ar@{|->}[r ]   & * \\txt{$({\\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , s ) , $ \\\\$(\\lambda p.\\ , { \\mathsf{fst}}\\ , ( { t^{\\delta}}\\ , ( { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , p ) ) , $ \\\\$\\lambda p'.\\ , { \\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , ( { \\mathsf{snd}}\\ , ( { t^{\\delta}}s)\\ , p))\\ , p'))$}\\\\ c \\ar[r]^{{h^{\\delta } } }   & c { \\mathrel{\\cdot^\\mathrm{c}}}c \\ar[r]^{c { \\mathrel{\\cdot^\\mathrm{c}}}{h^{\\delta } } } & c { \\mathrel{\\cdot^\\mathrm{c}}}(c { \\mathrel{\\cdot^\\mathrm{c}}}c)\\\\ * \\txt{$({q^{\\delta}}\\ , { \\{s\\}}\\ , ( p , $ \\\\${q^{\\delta}}\\ , { \\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , p\\}}\\ , ( p',p'')))$ } & * \\txt{$(p , $ \\\\${q^{\\delta}}\\ , { \\{{\\mathsf{snd}}\\ , ( { t^{\\delta}}\\ , s)\\ , p\\}}\\ , ( p',p''))$ } \\ar@{|->}[l ] & ( p,(p',p '' ) ) \\ar@{|->}[l ] } \\ ] ] from where the second and fifth directed container laws follow @xmath476@xmath477 @xmath478@xmath479      by interpreting the given directed container @xmath480 we get a comonad @xmath481 whereby @xmath482 , @xmath483 and @xmath484 .    from the comonad , we get a directed container @xmath485 by taking @xmath486 , @xmath487 , @xmath488",
    ".    this directed container must be equal to the original directed container @xmath480 , i.e. , we need to prove that @xmath489 and @xmath490 and @xmath491 .    by the definitions of @xmath439 , @xmath443 , @xmath441 , for the container morphisms",
    "@xmath492 and @xmath493 we have that @xmath494 @xmath495 @xmath496 @xmath497    using the definitions of @xmath498 , @xmath499 , @xmath500 , @xmath186 , @xmath187 , we calculate : @xmath501 @xmath502 @xmath503      the comonad @xmath204 induces a directed container @xmath504 whereby @xmath505 @xmath506 @xmath507    by interpreting this directed container , we get a comonad @xmath508 by taking @xmath509 and @xmath510 .",
    "this comonad must equal @xmath481 , i.e. , we need to prove that @xmath511 and @xmath512 and @xmath513 = @xmath514 .",
    "first of all , from the definition of directed container interpretation , we know that the underlying functors are equal : @xmath515 .    using the definitions of @xmath431 , @xmath432 , @xmath135 , @xmath251 , @xmath126 we can calculate @xmath516 @xmath517 @xmath518    now , because of naturality of @xmath186 and @xmath187 expressed in the diagrams @xmath519 \\ar@{|->}@/_5pc/[dddd ] & { \\varepsilon}\\ , { \\{p\\ , s\\}}\\ , ( s,{\\mathsf{id } } ) \\ar@{|->}@/^5pc/[dddd ] \\\\",
    "\\sigma s : s .",
    "p\\ , s \\to p\\ , s \\ar[r]^-{{\\varepsilon}\\ , { \\{p\\ , s\\ } } } \\ar[dd]_{\\lambda ( s , v').\\ , ( s , v { \\circ}v ' ) } & p\\ , s \\ar[dd]^{v}\\\\ & \\\\ \\sigma",
    "p\\ , s \\to x \\ar[r]_-{{\\varepsilon}\\ , { \\{x\\ } } } & x\\\\ ( s , v ) \\ar@{|->}[r ] & { \\varepsilon}\\ , { \\{x\\}}\\ , ( s , v ) = v\\ , ( { \\varepsilon}\\ , { \\{p\\ , s\\}}\\ , ( s,{\\mathsf{id } } ) ) } \\ ] ]    @xmath519 \\ar@{|->}@/_6pc/[dddd ] & { \\delta}\\ , \\{p s\\}\\ , ( s,{\\mathsf{id } } ) \\ar@{|->}@/^12.5pc/[dddd ] \\\\",
    "\\sigma s : s .",
    "p\\ , s \\to p\\ , s \\ar[r]^-{{\\delta}\\ , \\{p\\ , s\\ } } \\ar[dd]_{\\lambda ( s , v').\\ , ( s , v { \\circ}v ' ) } & \\sigma s : s .",
    "p\\ , s \\to \\sigma",
    "p\\ , s ' \\to p\\ , s \\ar[dd]^{\\lambda ( s , v').\\ , ( s , \\lambda p.\\ , ( { \\mathsf{fst}}\\ , ( v'\\ , p ) , v { \\circ}{\\mathsf{snd}}\\ , ( v'\\ , p)))}\\\\ & \\\\ \\sigma s : s .",
    "p\\ , s \\to x \\ar[r]_-{{\\delta}\\ , { \\{x\\ } } } & \\sigma s : s .",
    "\\sigma s ' : s .",
    "p\\ , s ' \\to x \\\\ ( s , v ) \\ar@{|->}[r ] & * \\txt{${\\delta}\\ , { \\{x\\}}\\ , ( s , v ) = $ \\\\$({\\mathsf{fst}}\\ , ( { \\delta}\\ , { \\{p\\ , s\\}}\\ , ( s,{\\mathsf{id } } ) ) , $ \\\\$\\lambda p.\\ , ( { \\mathsf{fst}}\\ , ( { \\mathsf{snd}}\\ , { \\delta}\\ , { \\{p\\ , s\\}}\\ , ( s , { \\mathsf{id}})\\ , p ) , $ \\\\$\\lambda p'.\\ , v\\ , ( { \\mathsf{snd}}\\ , ( { \\mathsf{snd}}\\ , { \\delta}\\ , { \\{p\\ , s\\}}\\ ,   ( s,{\\mathsf{id}})\\ , p)\\ , p')))$ } } \\ ] ] it is evident that the counit and comultiplication of @xmath481 and @xmath520 are equal : @xmath521 @xmath522",
    "auxiliary statements @xmath543 and @xmath544 for law 2 , by mutual induction on the two @xmath82s .",
    "we show only the cases of the first statement . case @xmath531 , @xmath545 , @xmath546 : @xmath547 case @xmath531 , @xmath545 , @xmath548 : @xmath549 case @xmath531 , @xmath550 : @xmath551 case @xmath534 , @xmath552 : @xmath553 case @xmath554 : @xmath555      to check that @xmath199 is a product of @xmath244 and @xmath245 we can either verify it directly that it satisfies the required universal property or prove that it interprets to a product of the interpreting comonads . here",
    "we have chosen to pursue the first route .        moreover ,",
    "any directed container @xmath570 with two directed container morphisms @xmath571 and @xmath572 must jointly determine a unique directed container morphism @xmath573 such that the following two triangles commute .",
    "@xmath574_{t^{f_0 } \\lhd q^{f_0 } } \\ar[dr]^{t^{f_1 } \\lhd q^{f_1 } } \\ar[d]_{t^f \\lhd q^f } & \\\\ ( s_0 \\lhd p_0 , { \\mathrel{\\downarrow_0 } } , { \\mathsf{o}_0 } , { \\mathrel{\\oplus_0 } } ) & \\ar[l]^{t^{\\pi_0 } \\lhd q^{\\pi_0 } } ( s \\lhd p , { \\mathrel{\\downarrow } } , { \\mathsf{o } } , { \\mathrel{\\oplus } } )",
    "\\ar[r]_{t^{\\pi_1 } \\lhd q^{\\pi_1 } } & ( s_1 \\lhd p_1 , { \\mathrel{\\downarrow_1 } } , { \\mathsf{o}_1 } , { \\mathrel{\\oplus_1 } } ) } \\end{gathered}\\ ] ] we claim that @xmath575 is given by    * @xmath576 + @xmath577 + where + @xmath578 + @xmath579 + ( by mutual corecursion ) + @xmath580 + @xmath581 + * @xmath582 + @xmath583 + @xmath584 + @xmath585 + where + @xmath586 + @xmath587 + ( by mutual recursion ) + @xmath588 + @xmath589 + @xmath590 + @xmath591              auxiliary statements @xmath605 and @xmath606 for law 1 , by mutual induction on the @xmath82s , showing the cases of the first statement ; those of the second one are symmetric .",
    "case @xmath534 .",
    "@xmath607 case @xmath608 : @xmath609        auxiliary statements @xmath615 and @xmath616 for law 3 , by mutual induction on the @xmath82s , showing the cases of the first statement . case @xmath617",
    ", @xmath529 : @xmath618 case @xmath534 , @xmath619 : @xmath620 case @xmath534 , @xmath535 : @xmath621 case @xmath622 : @xmath623                                        that the directed container @xmath182 is cofree on the container @xmath78 can be shown either directly or by proving that it interprets into a cofree comonad on @xmath325 . in the following ,",
    "we illustrate the first route .",
    "this involves a fair amount of straightforward , but tedious inductive and coinductive reasoning in the lemmas below .        the universal property of cofreeness states that , for any other directed container @xmath671 and container morphism @xmath672 , there must exist a unique directed container morphism @xmath673 such that the following triangle commutes : @xmath674_{f } \\ar[rd]^{f_0 } & \\\\ s \\lhd",
    "p\\ar[r]^{{\\pi}}&s_0 \\lhd p_0 } \\end{gathered}\\ ] ] we claim that this directed container morphism @xmath575 is given by"
  ],
  "abstract_text": [
    "<S> abbott , altenkirch , ghani and others have taught us that many parameterized datatypes ( set functors ) can be usefully analyzed via container representations in terms of a set of shapes and a set of positions in each shape . </S>",
    "<S> this paper builds on the observation that datatypes often carry additional structure that containers alone do not account for . </S>",
    "<S> we introduce directed containers to capture the common situation where every position in a data - structure determines another data - structure , informally , the sub - data - structure rooted by that position . </S>",
    "<S> some natural examples are non - empty lists and node - labelled trees , and data - structures with a designated position ( zippers ) . </S>",
    "<S> while containers denote set functors via a fully - faithful functor , directed containers interpret fully - faithfully into comonads . </S>",
    "<S> but more is true : every comonad whose underlying functor is a container is represented by a directed container . </S>",
    "<S> in fact , directed containers are the same as containers that are comonads . </S>",
    "<S> we also describe some constructions of directed containers . </S>",
    "<S> we have formalized our development in the dependently typed programming language agda . </S>"
  ]
}