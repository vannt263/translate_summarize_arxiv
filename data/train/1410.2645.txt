{
  "article_text": [
    "in the standard theoretical framework for the _ set reconciliation _ problem , two parties @xmath0 and @xmath1 each hold a set of keys from a ( large ) universe @xmath6 with @xmath7 , with the sets named @xmath2 and @xmath3 respectively .",
    "the goal is for both parties to obtain @xmath8 .",
    "typically , set reconciliation is interesting algorithmically when the sets are large but the set difference @xmath9 is small ; the goal is then to perform the reconciliation efficiently with respect to the transmission size .",
    "ideally , the communication should depend on the size of the set difference , and not on the size of the sets .",
    "recent work has examined the problem of extending set reconciliation to multi - party settings @xcite .",
    "this work examined the problem where three or more parties @xmath10 hold sets of keys @xmath11 respectively at various locations in a network , and the goal is for all parties to obtain @xmath12 .",
    "this could of course be done by pairwise reconciliations , but more effective methods are possible . the multi - party set reconciliation problem is a natural distributed computing problem .",
    "for example , set reconciliation models distributed loosely replicated databases , which for simplicity we think of as simply holding a set of keys . such databases may be periodically synchronized . as we expect the number of differences among the databases to be small compared to the database size , we would like reconciliation schemes that scale with these differences .",
    "we also would like to make use of the network efficiently , ideally more efficiently than pairwise reconciliations .",
    "recent work has tackled this problem by extending invertible bloom lookup tables ( iblts ) , a hash - based data structure that , among other uses , provide a natural solution to the two - party set reconciliation problem @xcite .",
    "( see also @xcite . )",
    "the extension shows that by performing operations on iblts in an appropriate field , one can design protocols for multi - party set reconciliation @xcite . further , because iblts are linear sketches , using iblts allows the use of network coding techniques to improve the use of the network @xcite .    in this work",
    ", we return to the classic solution for the 2-party setting , which is based on characteristic polynomials and uses techniques similar to those used for reed - solomon codes @xcite .",
    "the goal is to see whether and how much of the results for iblts in the multi - party setting can be translated to similar results using these alternative techniques .",
    "we expect there to be a trade - off . in the 2-party",
    "setting , where @xmath13 bits of communication ( as long as @xmath14 , or an upper bound on @xmath14 that is @xmath15 , is known ) , but using characteristic polynomials generally requires a constant factor less communication than using iblts , and is almost optimal in terms of communication .",
    "in return , using characteristic polynomials is much more computationally intensive .",
    "while iblts require only a linear number of operations to recover all elements and @xmath16 operations for each party to compute the information to be transmitted ( assuming suitable field operations are @xmath17 and hashing can be treated as a constant - time operation ) , using characteristic polynomials requires almost @xmath18 time to recover all elements using standard gaussian elimination and @xmath19 operations to compute the information to be passed .",
    "( as discussed in @xcite , and as we discuss further below , theoretically faster algorithms are possible , but they are still super - linear , and it appears that due to high constant factors they may be unlikely to be useful in practice . ) finally , iblts are randomized and succeed with high probability , while using characteristic polynomials is deterministic .",
    "the main contribution of this work is to show that characteristic polynomials can , in a suitable fashion , be extended to the multi - party case .",
    "we follow the framework of the multi - party problem definition that is considered in @xcite , where the authors quantify the amount by which the sets differ by the number of elements which belong to at least one set but not all of them .",
    "we call this quantity the _ total set difference _ @xmath14 ; here @xmath20 , which generalizes the set difference for two parties .",
    "we first show that there is a protocol in the _ relay setting _",
    ", where each party is connected to an intermediate relay that can compute and broadcast messages , in which each party and the relay send a message of @xmath21 bits using an approach based on characteristic polynomials .",
    "the communication is asymptotically optimal information theoretically .",
    "building on this approach , we consider set reconciliation in an asynchronous network setting using characteristic polynomials .",
    "each party is located at a distinct node in a graph @xmath22 of size @xmath23 , and in one round , only parties which are on adjacent nodes can communicate with each other . using recent results from the network gossip literature",
    "@xcite , we show that with each party sending ( and receiving ) at most @xmath21 message bits in each round , it takes @xmath24 rounds for every node to obtain the union @xmath25 with high probability . here",
    "@xmath26 is the _ conductance _ of the graph @xmath22 ; see , e.g. , @xcite for more information on conductance .",
    "additionally , we show that with slight modifications , in both the central relay and the network setting , our protocols can also support recovery of owners of elements .",
    "that is , an agent @xmath27 , after obtaining the union of the sets @xmath12 , should also be able to recover an owner of the items she does not own herself . specifically , at the end of the protocol each party @xmath27 can not only obtain all the items in the set @xmath28 , but @xmath27 can also obtain an original owner of each of these items .",
    "although these results appear generally promising , we note they come with significant limitations",
    ". the intermediary nodes must do significant work , essentially decoding sketches and recoding information based on the decoding .",
    "less effort appears to be required by intermediary nodes when using iblts , as the corresponding data sketches are linear and can be combined using simple operations .",
    "hence , while our work shows that characteristic polynomials can be used as a basis for multi - party reconciliation , we believe that further simplification would be desirable .",
    "we work with the characteristic function of a set . for a set @xmath29 $ ] , and a prime @xmath30 greater than @xmath31 ,",
    "the characteristic function @xmath32 is a polynomial defined as : @xmath33 where @xmath34 is the prime finite field with @xmath30 elements .",
    "a sketch @xmath35 of a polynomial @xmath36 is defined as a @xmath37-tuple of the evaluation of @xmath38 at @xmath39 fixed points of @xmath34 .",
    "it is not important for us which @xmath39 points we choose , but for concreteness let us fix those points to be @xmath40 .",
    "we note that by lagrange interpolation , it is possible to recover the coefficients of a degree @xmath14 polynomial @xmath38 from its sketch @xmath35 .",
    "this is the key idea from reed - solomon codes that we exploit in our protocol . by a sketch @xmath41 of a set",
    "@xmath29 $ ] , we mean a sketch of its characteristic function .",
    "where there is no risk of confusion , we drop the subscript @xmath14 and refer to the sketch of @xmath42 as @xmath43 .",
    "the standard approach for 2-party reconciliation using sketches of this form is presented in @xcite . treating keys as numbers in a suitable field",
    ", @xmath0 considers the characteristic polynomial @xmath44 over a field @xmath45 for @xmath30 larger than @xmath31 ; and similarly @xmath1 considers @xmath46 .",
    "observe that in the rational function @xmath47 the common terms cancel out , leaving a rational function in @xmath48 where the sums of the degrees of the numerator and denominator is the set difference , where the set difference is defined as the quantity @xmath49 .",
    "assuming the set difference is at most @xmath14 , the rational function can be determined through interpolation by evaluating the function at @xmath50 points , and then factored .",
    "hence , if @xmath0 and @xmath1 send each other their respective sketches @xmath51 and @xmath52 , each party can compute @xmath47 at @xmath50 points and thereby determine and reconcile the values in @xmath53 .",
    "the total number of bits sent in each direction would be @xmath54 .",
    "note that this takes @xmath18 operations using standard gaussian elimination techniques .",
    "these ideas can be extended to use other codes , such as bch codes , with various computational trade - offs @xcite .",
    "because of the use of division to combine sketches , the sketches are not `` linear '' and do not naturally combine when used for three or more parties . however , as we show , with a bit more work this limitation can be circumvented .    in the case of multiple parties ,",
    "we define the total set difference of the collection of sets @xmath55 to be the quantity @xmath56 . for convenience ,",
    "we assume in what follows that all parties know in advance that the total set difference of the collection @xmath57 does not exceed @xmath14 . generally , in reconciliation settings , there are multiple phases .",
    "for example , in a first phase a bound on @xmath14 is obtained , which is then used for reconciliation .",
    "alternatively , one takes an upper bound on @xmath14 that is suitable most of the time , and then checks for successful reconciliation after the algorithm completes using hashing methods .",
    "see @xcite for further discussion on this point .",
    "we first describe a protocol where each of the @xmath23 parties @xmath58 , possessing sets @xmath59 respectively , communicate with a central relay in order to collectively obtain the union of all the sets .",
    "we use the shorthands @xmath25 and @xmath60 to denote @xmath61 } s_i$ ] and @xmath62 } s_i$ ] . as mentioned",
    "we assume that @xmath63 , where @xmath14 is small compared to the number of elements in the sets @xmath64 .",
    "the protocol is carried out as follows .",
    "initially , each party @xmath27 computes their own sketch @xmath65 and sends the @xmath21 bits describing this sketch to the relay . from these sketches ,",
    "the relay computes the sketch of the union @xmath25 .",
    "the relay broadcasts the sketch of @xmath25 and from this sketch each party @xmath27 can retrieve the elements of @xmath66 .    *",
    "combining sketches * we show how to combine the sketches of two sets to obtain the sketch of their union . in the following ,",
    "we use the @xmath67 operator to denote coordinate - wise multiplication ( in @xmath34 ) of two sketches .",
    "we also use @xmath68 to denote coordinate - wise division of two sketches . for two sets",
    "@xmath69 $ ] with a set difference of at most @xmath14 , given @xmath41 , and @xmath70 , we compute @xmath71 using the following identity . @xmath72 the central relay can find @xmath73 from factoring the rational function @xmath74 and extracting the numerator , since , in its reduced form the rational function @xmath74 can be written as @xmath75 similarly the relay can find @xmath76 . observe that the relay can recover the individual elements of @xmath77 and @xmath78 even though it does not have access to either of the sets @xmath42 and @xmath79 in its entirety .    by combining two sketches at a time ,",
    "the central relay can obtain the sketch of @xmath80 } s_i$ ] after @xmath81 combinations .",
    "the relay then broadcasts the sketch @xmath82 to each of the @xmath23 parties .",
    "* note on relay output * the careful reader might notice that the relay can in fact just broadcast each of the elements of @xmath83 to all the parties .",
    "however , to maintain generality we work with sketches throughout .",
    "this approach allows us to generalize our method to broader settings .",
    "* distributed computation at the relay * if the relay has access to multiple processors , she can perform the @xmath81 combinations in a parallel manner .",
    "it is easy to see that by combining two sketches at a time , using @xmath84 processors the relay needs to perform @xmath85 rounds of combinations .    * retrieving missing elements * each @xmath27 , having the sketch @xmath82 and having computed already the sketch for her own set @xmath64 , can retrieve the individual elements she is missing from @xmath25 .",
    "the first step is to compute the sketch of @xmath66 using component - wise division : @xmath86 from the sketch of @xmath66 , agent @xmath27 can interpolate the characteristic function of @xmath66 , which is a polynomial of degree at most @xmath14 .",
    "the actual elements of @xmath66 are then determined by factoring its characteristic function .",
    "* tightness of communication * the amount of communication in our protocol is information - theoretically as succinct as possible in this setting , as the number of elements in the universe grows , assuming that the parties have no prior knowledge of the constituents of each others sets other than the fact that the total set difference is at most @xmath14 .",
    "this is because , after fixing a particular agent @xmath27 s set as @xmath64 , with @xmath87 , there are at least @xmath88 different subsets of elements that @xmath27 might be missing from the union .",
    "but if @xmath31 is much larger compared to @xmath89 and @xmath14 , then @xmath90 .",
    "thus , to specify the missing elements we need at least @xmath91 bits .    * time complexity * we would like the computations performed by the parties and the relay to be efficient .",
    "we aim for the time required to encode to be linear in the number of set items , and the time to decode to be polynomial in the total set difference @xmath14 .",
    "we assume that the basic arithmetic operations in @xmath34 take constant time .",
    "( this may or may not be a reasonable assumption depending on the setting and the size of @xmath30 ; however , one can factor in a corresponding poly - logarithmic factor in @xmath31 as needed to handle the cost of operations in @xmath34 . )    initially , each party @xmath27 must evaluate the polynomial corresponding to their set s characteristic function at a pre - specified set of @xmath39 points .",
    "this can most straightforwardly be done by the standard computation with @xmath92 operations , though for large total set differences it may be more efficient ( at least theoretically ) to compute the coefficients of the characteristic function and then evaluate the polynomial simultaneously at the pre - specified set of @xmath39 points .",
    "( see , e.g. , @xcite for possible algorithms . )",
    "the computations performed by the relay include interpolation of a rational function where the numerator and denominator have total degree @xmath14 , evaluation of a @xmath14-degree polynomial at @xmath14 points , and point - wise multiplication of two sketches .",
    "each of these computations can be done in @xmath93 operations @xcite .",
    "( here @xmath94 hides polylog factors in @xmath14 . )",
    "the remaining computation performed by the relay is factorization of a @xmath14-degree polynomial over @xmath34 ; the best theoretical algorithm of which we are aware is given by kedlaya and umans @xcite , and requires approximately @xmath95 operations ; other algorithms may be more suitable in practice .",
    "( see also @xcite . )",
    "we can state our results in the form of the following theorem :    given an upper bound @xmath14 on the size of the total set difference , @xmath23 parties using a relay can reconcile their sets , from an universe of @xmath31 elements , using sketches of @xmath50 values in @xmath34 ( with @xmath96 ) and with each party sending one sketch and the relay broadcasting a sketch .",
    "each sketch can be encoded in a message of @xmath21 bits .",
    "the time for computation required by the @xmath97th party with set @xmath64 is the time to evaluate their characteristic polynomial at @xmath50 pre - chosen points , and the computation time required by the relay is dominated by the time to factor a degree @xmath14 polynomial over @xmath34 at most @xmath98 times .    *",
    "recovering an owner of a missing element * we describe modifications to our protocol that would further enable each party to also retrieve an owner of each element she is missing from the union . in some settings , this additional information be useful ; for example , there may be additional information associated with a set element that may require contact between the parties to obtain or resolve .",
    "the relay can maintain running sketches of the current union and intersection of the sets following the framework that we have described .",
    "when a new sketch for set @xmath64 arrives , new running values @xmath99 and @xmath100 can be computed from previous values @xmath101 and @xmath102 as follows : @xmath103 @xmath104 note that , as part of this process , by using @xmath105 to determine the characteristic polynomial of @xmath106 , the relay can determine which new elements are being brought into the union by each set as each sketch arrives .",
    "( for the combination of the first two sketches @xmath64 and @xmath107 , both @xmath108 and @xmath109 will need to be computed , as described above . ) as before , while the relay could broadcast this information , we prefer to keep everything in the setting of sketches .    to produce a final sketch , the relay can then re - encode each element @xmath110 in the final @xmath111 by encoding the element as @xmath112 , where @xmath113 is the @xmath114-based index of the smallest indexed owner of the element @xmath110 . as we are working over prime finite fields , the item value and owner i d",
    "are the remainder and the quotient respectively from division of the encoded field element by @xmath31 .",
    "we now work over a larger field @xmath115 with @xmath116 and we denote the sketch of any set @xmath79 as @xmath117 after re - encoding each element with an owner index .    the sketch @xmath118 is created by taking the point - wise multiplications of the corresponding sketches of @xmath102 and @xmath119 . @xmath120",
    "the final @xmath25 just equals the final computed @xmath101 ; note this corresponds to owner labels being set to @xmath114 .",
    "if the relay now sends @xmath118 to a party , with elements marked by an owner , the party can not use the previous cancellation procedure as she does not know which owner her own elements were assigned to .",
    "therefore , the relay also sends a sketch of the intersection , @xmath121 .",
    "each party thus receives the sketches of both @xmath25 and @xmath60 and can hence obtain the sketch of @xmath83 .",
    "we can decipher all the elements @xmath83 along with one of their owners .",
    "alternatively , with the re - encoded values from the relay , the set difference between the final @xmath25 and @xmath64 consists of at most @xmath122 elements , as @xmath14 elements in @xmath64 might have been re - encoded to different values ( that is , the same element but encoded to a different owner ) .",
    "hence the relay could send a sketch for up to @xmath122 differences , or @xmath123 .",
    "if each party computes @xmath124 , then after the relay broadcasts each party can compute @xmath125 by interpolation and thereby recover any missing elements or elements that have been re - encoded .    * asynchronous message arrivals * we note that our protocols are robust enough to be able to handle situations where the initial messages from the agents to the relay arrive asynchronously . in this case",
    ", the relay can keep performing computations without having to wait for all the @xmath23 messages to arrive .",
    "the encoding that maps from agent indices to owner ids remains fixed , but the relay has leeway in determining which owner i d is attached to a particular item , when the item has multiple owners .",
    "in fact , the relay can define an arbitrary ordering on the set of agents @xmath126 and use this ordering to choose the smallest owners of items .",
    "in particular , the relay can choose the order in which the messages from the agents arrive .",
    "this will enable the relay to simplify computation by enabling her to perform the sketch combinations without having to wait for subsequent messages to arrive .",
    "we state our modifications to the protocol to enable recovery of the owners in the corollary below .    given an upper bound @xmath14 on the size of the total set difference , each of @xmath23 parties using a relay can reconcile their sets and also obtain one owner of each missing element , using sketches of @xmath50 values in @xmath34 ( with @xmath127 ) , with each party sending one sketch and the relay broadcasting a sketch - each a message of size @xmath128 .",
    "the time for computation required by the @xmath97th party with set @xmath64 is the time to evaluate their characteristic polynomial at @xmath50 pre - chosen points , and the computation time required by the relay is dominated by the time to factor a degree @xmath14 polynomial over @xmath34 at most @xmath98 times .",
    "in this section , we describe a protocol for multi - party set reconciliation over a network . using previous results on gossip spreading techniques (",
    "also referred to generally as rumor spreading ) , we can show that our protocol terminates in @xmath129 rounds of communication , where @xmath26 is the conductance of the network . here",
    "again we are following the framework of @xcite , but replacing their use of iblts with sketches based on characteristic polynomials .    in this setting",
    ", we assume that each of the @xmath23 nodes start with the knowledge of only their own set , and aim to follow a gossip protocol so that each of them obtains the union of all the @xmath23 sets within a small number of rounds .",
    "the @xmath23 parties are situated at @xmath23 different nodes of a graph @xmath22 and only adjacent nodes can communicate with each other directly . to be clear the graph @xmath22 may have more than @xmath23 nodes , as there will generally be nodes that pass messages that are not parties with information .    in the case where one party has a piece of information to distribute to all other parties",
    ", it is known that the standard push - pull protocol for `` rumor spreading '' will distribute that information to all the nodes of the graph within @xmath129 rounds high probability @xcite .",
    "( the push - pull protocol works as follows : in each round , every informed node that knows the rumor to be spread chooses a random neighbor and sends it to the neighbor ; every uninformed node that does not know the rumor contacts a neighbor in an attempt to get the rumor . ) for more on rumor spreading , see also for example @xcite ) .    here",
    ", we explain how the approach used by the relay described previously allows us to use the standard push - pull protocol for reconciliation .",
    "( the general approach will also apply to allow us to use other rumor spreading protocols for reconciliation . )",
    "we show that the previous protocol described for relays without the owner information carries over to the network setting using the push - pull protocol . in a particular round ,",
    "a node @xmath130 would possess the sketch of the union of the sets belonging to a sub - collection of the agents , say @xmath131 $ ] .",
    "let us denote this set as @xmath132 ( @xmath133 ) where @xmath134 can be an arbitrary sub - collection of @xmath135 $ ] .",
    "we divide each round into two sub - rounds . in the first sub - round ,",
    "each vertex pushes whatever information it has to a random neighbor . in the second sub - round ,",
    "each vertex pulls whatever information it can obtain from a random neighbor .",
    "( here , the sets are the rumors , and each passed sketch encodes the information about the union of the sets obtained from all previous rounds . at the end , we use a union bound over all possible rumors . )",
    "if the node @xmath130 receives a sketch of @xmath136 from an adjacent neighbor , for some @xmath137 $ ] , then she can update her known sub - collection to be @xmath138 and obtain the sketch of @xmath139 .",
    "this procedure of combining the two sketches is the same as the one performed by the relay in the central relay setting .",
    "note that , thus far , the protocol we are considering does not carry information which would enable @xmath130 to know _ which _ sub - collection @xmath134 corresponds to the set that she is holding .    using the known bound on the push - pull protocol have the following theorem .",
    "given an upper bound @xmath14 on the size of the total set difference , @xmath23 parties each possessing sets from a universe of size @xmath31 communicating over a graph @xmath22 can reconcile their sets using sketches of @xmath50 values in @xmath34 ( such that @xmath96 ) , with each party sending one sketch per sub - round ( an @xmath140 bit message ) using the push - pull randomized gossip protocol , in @xmath129 rounds with high probability .",
    "we choose a suitable number of rounds @xmath141 based on the desired high probability bound that allows @xmath23 parallel versions of the single - message gossip protocol to successfully complete with high probability , as guaranteed by theorem 1.1 of @xcite .",
    "note that , for any single set , the sketch corresponding to that set behaves just as though it was acting as part of the single - message protocol ; the fact that other sketches may have been combined into a shared sketch does not make any difference from the point of view of the single set under consideration .",
    "hence , we can treat this as multiple single - message problems running in parallel , and apply a union bound on the failure probability .",
    "( see @xcite for a more extensive discussion . )    hence , after @xmath142 rounds , with high probability all @xmath23 parties obtain sketches for all of the @xmath23 sets , and hence all parties have the necessary information for reconciliation .",
    "* gossip protocol with owner information * we now turn to extending the above protocol to allow owner information to be be determined as well .",
    "the primary difficulty in adapting our protocol with owner information from the relay setting is that we might have the same item identified with different owners , and they might be mistaken for different items .",
    "however , if we carry along the sketch of the intersection as well , during the combination of two sets each party can extract and re - encode the items belonging to at least someone but not everyone in the sub - collection .    instead of @xmath114-indexed identifiers of the nodes ,",
    "we use labels @xmath143 for the agents for the purpose of owner identification .",
    "we work over of a prime field @xmath34 with @xmath30 a prime which is at least @xmath144 . for a given sub - collection @xmath131 $ ] ,",
    "we maintain the sketch of the union and the intersection of the original sets corresponding to the sub - collection @xmath134 .",
    "we denote these sets by the shorthands @xmath145 and @xmath146 respectively .",
    "we call the minimum indexed member of @xmath134 the _ leader _ of @xmath134 , and denote her index by @xmath147 .",
    "when we consider the set @xmath145 , for each element of @xmath148 , we also attach the index of the minimum - indexed owner from among agents in @xmath134 , following the approach used to associate an agent with an item in the relay case . for elements in @xmath146 ,",
    "we store the elements with a dummy owner value of @xmath114 .",
    "( otherwise , the elements of @xmath146 would have had @xmath147 as the minimum - indexed owner . ) to distinguish this encoding from the previous protocols , we denote the this sketch of a set @xmath42 as @xmath149 . in our protocol",
    ", at each node @xmath130 we maintain the running tuple @xmath150 , where @xmath134 is the collection of agents whom the node @xmath130 has made contact with , either directly or indirectly .",
    "( that is , it is the collection of agents whose original sketches have reached @xmath130 , albeit perhaps combined with other sketches along the way . ) again , note that in both the sketches @xmath151 and @xmath152 , the elements which also appear in @xmath146 are encoded with the owner - id of @xmath114 instead of @xmath147 .    *",
    "combining sub - collection sketches * when a node @xmath130 receives information about another sub - collection @xmath137 $ ] from a random neighbor , it combines this with its own tuple for @xmath131 $ ] to obtain the tuple @xmath153 , where @xmath154 .",
    "note that it is not necessary that @xmath134 and @xmath155 be disjoint sub - collections .",
    "we now describe how to combine @xmath156 and @xmath157 to compute @xmath158 .",
    "we are given the sketches of @xmath159 and @xmath160 , as well as the minimum indices @xmath147 and @xmath161 .",
    "we assume without loss of generality that @xmath162 , so @xmath163 .",
    "to compute the sketches @xmath164 and @xmath165 , the key idea is to extract the sketch of @xmath166 and then explicitly recover and re - encode all the elements in both @xmath132 and @xmath136 which do not belong to agent @xmath167 .",
    "we describe the procedure in three parts : ( a ) computing the sketch of @xmath166 .",
    "( b ) extracting the elements in @xmath168 and re - encoding their owner information .",
    "( c ) computing the sketch of @xmath169 .",
    "\\(a ) first , we show how to compute the sketch of @xmath166 .",
    "note that the items of @xmath146 have @xmath147 as their minimum - indexed owner , hence they will be encoded with an owner - id of @xmath114 in both the sketches @xmath152 and @xmath151 .",
    "an analogous statement holds for the sub - collection @xmath155 . as both @xmath152 and @xmath170 have all their owner - ids equal to @xmath114",
    ", we can treat these as sets of items without owner information .",
    "using the identity @xmath75 we can compute @xmath171 .",
    "now , we can perform point - wise division of the sketches to compute @xmath172 using , @xmath173 this gives us the sketch of @xmath174 .",
    "\\(b ) next , we extract the individual items of @xmath175 along with their owners .",
    "observe that all items in @xmath166 also belong to the leader of @xmath134 , namely @xmath176 . in both @xmath151 and @xmath165",
    "these items have the same owner i d of @xmath114 .",
    "hence , we can take advantage of the identity @xmath177 where @xmath113 is the smallest - indexed owner of item @xmath110 among agents in the sub - collection @xmath134 .",
    "thus , we have explicitly obtained the items in @xmath175 along with their minimum indexed owner .",
    "note that these are the items which belong to some agent in the collection @xmath134 , but not to all agents in the collection @xmath178 .",
    "using a similar procedure on sub - collection @xmath155 instead of @xmath134 , we obtain analogously the items in @xmath179 ; encoded with their minimum - indexed owners among agents in @xmath155 . at this point ,",
    "if @xmath180 , we modify the items in @xmath179 with owner i d @xmath114 to instead have owner i d @xmath161 . for items which appear both in @xmath175 and @xmath179 , we can now compute their minimum - indexed owner i d from among agents in @xmath181 by choosing the minimum of the two owners that was obtained from the two sketches of @xmath182 and @xmath179 .",
    "\\(c ) in our final sketch @xmath164 , the items which also appear in @xmath165 would have agent @xmath167 as their minimum - indexed owner ; hence by definition of @xmath183 these items appear in both the sketches with an owner i d of @xmath114 .",
    "this suggests that we can build the sketch @xmath164 by using the already - computed sketch @xmath165 as a starting point .",
    "in fact , @xmath184 , where @xmath185 denotes disjoint union . recall that we have the items @xmath110 of @xmath186 explicitly , along with their minimum - indexed owner i d ( say @xmath187 ) from among agents in @xmath181 .",
    "thus we have @xmath188    we can therefore compute @xmath164 by constructing the sketch of the characteristic function of @xmath189 and point - wise multiplying it with the sketch of @xmath166 .",
    "we summarize our result in the following corollary .",
    "given an upper bound @xmath14 on the size of the total set difference , @xmath23 parties each possessing sets from a universe of size @xmath31 communicating over a graph @xmath22 can reconcile their sets while recovering an owner for each missing element , using sketches of @xmath50 values in @xmath34 ( such that @xmath190 ) , with each party sending at most two sketches per sub - round ( @xmath191 bit messages ) using the push - pull randomized gossip protocol , in @xmath129 rounds with high probability .",
    "we had found that while the characteristic polynomial approach to set reconciliation has been known for some time , the issue of considering generalizations to multi - party settings had never apparently been suggested .",
    "linear sketches based on invertible bloom lookup tables allow fairly straightforward multi - party reconciliation protocols . in this work , we show that using characteristic polynomials can as well , albeit perhaps somewhat less naturally and with more computation requirements .",
    "a possible future direction is to improve the computation time requirements .",
    "currently , the primitives that we use for finite field arithmetic are not especially attuned to our needs .",
    "is it possible to take advantage of properties of finite fields to to enable more efficient manipulation of sketches ?",
    "it would also be interesting to investigate if this approach could be simplified further , as characteristic polynomials provide one of the simplest and most natural frameworks for reconciliation problems .",
    "f. chierichetti , s. lattanzi , and a. panconesi .",
    "almost tight bounds for rumour spreading with conductance . in _ proceedings of the forty - second acm symposium on theory of computing _ , pages 399408 , 2010 .",
    "d. eppstein and m. goodrich .",
    "straggler identification in round - trip data streams via newton s identities and invertible bloom filters .",
    "_ ieee transactions on knowledge and data engineering _ , 23(2):297306 , 2011 .",
    "m. mitzenmacher and g. varghese .",
    "the complexity of object reconciliation , and open problems related to set difference and coding . in _ proceedings of the 50th annual allerton conference _ , p. 1126 - 1132 , 2012 ."
  ],
  "abstract_text": [
    "<S> in the standard set reconciliation problem , there are two parties @xmath0 and @xmath1 , each respectively holding a set of elements @xmath2 and @xmath3 . the goal is for both parties to obtain the union @xmath4 . in many distributed computing settings the sets may be large but the set difference @xmath5 is small . in these cases </S>",
    "<S> one aims to achieve reconciliation efficiently in terms of communication ; ideally , the communication should depend on the size of the set difference , and not on the size of the sets .    </S>",
    "<S> recent work has considered generalizations of the reconciliation problem to multi - party settings , using a framework based on a specific type of linear sketch called an invertible bloom lookup table . here , we consider multi - party set reconciliation using the alternative framework of characteristic polynomials , which have previously been used for efficient pairwise set reconciliation protocols , and compare their performance with invertible bloom lookup tables for these problems . </S>"
  ]
}