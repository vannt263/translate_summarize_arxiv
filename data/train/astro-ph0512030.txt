{
  "article_text": [
    "the growth of cosmological structure in the universe is determined primarily by ( newtonian ) gravitational forces . unlike the electrostatic force , which can be both attractive and repulsive and for which shielding is important , the ubiquitous attraction of the gravitational force leads to extremely dense structures , relative to the average density in the universe .",
    "galaxies , for example , are typically @xmath2 times more dense than their surrounding environment , and substructure within them can be orders of magnitude more dense .",
    "modelling such large density contrasts is difficult with fixed grid methods and , consequently , particle - based solvers are an indispensable tool for conducting simulations of the growth of cosmological structure .",
    "the lagrangian nature of particle codes makes them inherently adaptive without requiring the complexity associated with adaptive eulerian methods .",
    "the lagrangian smoothed particle hydrodynamics ( sph,@xcite ) method also integrates well with gravitational solvers using particles , and because of its simplicity , robustness and ability to easily model complex geometries , has become widely used in cosmology .",
    "further , the necessity to model systems in which orbit crossing , or phase wrapping , occurs ( either in collisionless fluids or in collisional systems ) demands a fully lagrangian method that tracks mass . while full six - dimensional ( boltzmann ) phase - space models have been attempted , the resolution is still severely limited on current computers for most applications .",
    "particle solvers of interest in cosmology can broadly be divided into hybrid direct plus grid - based solvers such as particle - particle , particle - mesh methods ( 3m,@xcite ) and `` tree '' methods which use truncated low order multipole expansions to evaluate the force from distant particles @xcite .",
    "full multipole methods @xcite , are slowly gaining popularity but have yet to gain widespread acceptance in the cosmological simulation community .",
    "there are also a number of hybrid tree plus particle - mesh methods in which an efficient grid - based solver is used for long - range gravitational interactions with sub - grid forces being computed using a tree .",
    "special purpose hardware @xcite has rendered the direct pp method competitive in small simulations ( fewer than 16 million particles ) , but it remains unlikely that it will ever be competitive for larger simulations .",
    "the 3 m algorithm has been utilized extensively in cosmology .",
    "the first high resolution simulations of structure formation were conducted by efstathiou & eastwood @xcite using a modified 3 m plasma code . in 1998",
    "the virgo consortium used a 3 m code to conduct the first billion particle simulation of cosmological structure formation @xcite .",
    "the well - known problem of slow - down under heavy particle clustering , due to a rapid rise in the number of short - range interactions , can be largely solved by the use of adaptive , hierarchical , sub - grids @xcite .",
    "only when a regime is approached where multiple time steps are beneficial does the adaptive 3 m ( 3 m ) algorithm become less competitive than modern tree - based solvers .",
    "further , we note that a straightforward multiple time - step scheme has been implemented in 3 m with a factor of 3 speed - up reported @xcite .",
    "3 m has also been vectorized by a number of groups including summers @xcite . shortly after , both ferrell & bertschinger @xcite and theuns @xcite adapted 3 m to the massively parallel architecture of the connection machine .",
    "this early work highlighted the need for careful examination of the parallelization strategy because of the load imbalance that can result in gravitational simulations as particle clustering develops .",
    "parallel versions of 3 m that use a 1-dimensional domain decomposition , such as the p4 m code of brieu & evrard @xcite develop large load imbalances under clustering rendering them useful only for very homogeneous simulations .",
    "development of vectorized treecodes @xcite predates the early work on 3 m codes and a discussion of a combined tree+sph ( treesph ) code for massively parallel architectures is presented by dav @xcite .",
    "there are now a number of combined parallel tree+sph solvers @xcite and tree gravity solvers @xcite .",
    "pearce & couchman @xcite have discussed the parallelization of 3m+sph on the cray t3d using cray adaptive fortran ( craft ) , which is a directive - based parallel programming methodology .",
    "this code was developed from the serial hydra algorithm @xcite and much of our discussion in this paper draws from this first parallelization of 3m+sph .",
    "a highly efficient distributed memory parallel implementation of 3 m using the cray shmem library has been developed by macfarland @xcite , and further developments of this code include a translation to mpi-2 , the addition of 3 m subroutines and the inclusion of an sph solver @xcite .",
    "treecodes have also been combined with grid methods to form the tree - particle - mesh solver @xcite .",
    "the algorithm is somewhat less efficient than 3 m in a fixed time - step regime , but its simplicity offers advantages when multiple time - steps are considered @xcite . another interesting , and highly efficient n - body algorithm is the adaptive refinement tree ( art ) method @xcite which uses a short - range force correction that is calculated via a multi - grid solver on refined meshes .",
    "there are a number of factors in cosmology that drive researchers towards parallel computing .",
    "these factors can be divided into the desire to simulate with the highest possible resolution , and hence particle number , and also the need to complete simulations in the shortest possible time frame to enable rapid progress .",
    "the desire for high resolution comes from two areas .",
    "firstly , simultaneously simulating the growth of structure on the largest and smallest cosmological scales requires enormous mass resolution ( the ratio of mass scales between a supercluster and the substructure in a galaxy is @xmath3 ) .",
    "this problem is fundamentally related to the fact that in the currently favoured cold dark matter @xcite cosmology structure grows in a hierarchical manner .",
    "a secondary desire for high resolution comes from simulations that are performed to make statistical predictions . to ensure the lowest possible sample variance the largest possible simulation volume",
    "is desired .    for complex codes ,",
    "typically containing tens of thousands of lines , the effort in developing a code for distributed - memory machines , using an api such as mpi @xcite , can be enormous .",
    "the complexity within such codes arises from the subtle communication patterns that are disguised in serial implementations . indeed , as has been observed by the authors , development of an efficient communication strategy for a distributed memory version of the 3 m code",
    "has required substantially more code than the 3 m algorithm itself ( see @xcite ) .",
    "this is primarily because hybrid , or multi - part solvers , of which 3 m is a classic example , have data structures that require significantly different data topologies for optimal load balance at different stages of the solution cycle .",
    "clearly a globally addressable work space renders parallelization a far simpler task in such situations .",
    "it is also worth noting that due to time - step constraints and the scaling of the algorithm with the number of particles , doubling the linear resolution along an axis of a simulation increases the computational work load by a factor larger than 20 ; further doubling would lead to a workload in excess of 400 times greater .",
    "the above considerations lead to the following observation : modern smp servers with their shared memory design and superb performance characteristics are an excellent tool for conducting simulations requiring significantly more computational power than that available from a workstation .",
    "although such servers can never compete with massively parallel machines for the largest simulations , their ease of use and programming renders them highly productive computing environments .",
    "the openmp ( http://www.openmp.org ) api for shared - memory programming is simple to use and enables loop level parallelism by the insertion of pragmas within the source code .",
    "other than their limited expansion capacity , the strongest argument against purchasing an smp server remains hardware cost .",
    "however , there is a trade - off between science accomplishment and development time that must be considered above hardware costs alone .",
    "typically , programming a beowulf - style cluster for challenging codes takes far longer and requires a significantly greater monetary and personnel investment on a project - by - project basis .",
    "conversely , for problems that can be efficiently and quickly parallelized on a distributed memory architecture , smp servers are not cost effective .",
    "the bottom line remains that individual research groups must decide which platform is most appropriate .",
    "the code that we discuss in this paper neatly fills the niche between workstation computations and massively parallel simulations .",
    "there is also a class of simulation problems in cosmology that have particularly poor parallel scaling , regardless of the simulation algorithm used ( the fiducial example is the modelling of single galaxies , see @xcite ) .",
    "this class of problems corresponds to particularly inhomogeneous particle distributions that develop a large disparity in particle - update timescales ( some particles may be in extremely dense regions , while others may be in very low density regions ) .",
    "only a very small number of particlesinsufficient to be distributed effectively across multiple nodeswill require a large number of updates due to their small time - steps . for this type of simulation the practical limit of scalability appears to be order 10 pes .",
    "the layout of the paper is as follows : in section 2 we review the physical system being studied .",
    "this is followed by an extensive exposition of the 3 m algorithm and the improvements that yield the 3 m algorithm .",
    "the primary purpose of this section is to discuss some subtleties that directly impact our parallelization strategy . at the same time",
    "we also discuss the sph method and highlight the similarities between the two algorithms .",
    "section 2 concludes with a discussion of the serial hydra code .",
    "section 3 begins with a short discussion of the memory hierarchy in risc ( reduced instruction set computer ) systems , and how eliminating cache - misses and ensuring good cache reuse ensures optimal performance on these machines .",
    "this is followed by a discussion of a number of code optimizations for risc cpus that also lead to performance improvements on shared memory parallel machines ( primarily due to increased data locality ) . in particular",
    "we discuss improvements in particle bookkeeping , such as particle index reordering .",
    "while particle reordering might be considered an expensive operation , since it involves a global sort , it actually dramatically improves run time because of bottlenecks in the memory hierarchy of risc systems .",
    "in section 4 we discuss in detail the parallelization strategies adopted in hydra_omp . to help provide further understanding we compare the serial and parallel call trees . in section 5",
    "we consolidate material from sections 3 & 4 by discussing considerations for numa machines and in particular the issue of data placement .",
    "performance figures are given in section 6 , and we present our conclusions in section 7 .",
    "the simulation of cosmic structure formation is posed as an initial value problem .",
    "given a set of initial conditions , which are usually constrained by experimental data , such as the wmap data @xcite , we must solve the following gravito - hydrodynamic equations ;    1 .",
    "the continuity equations , @xmath4 where @xmath5 denotes gas and @xmath6 dark matter .",
    "2 .   the euler and acceleration equations , @xmath7 3 .",
    "the poisson equation , @xmath8 4 .   the entropy conservation equation , @xmath9    where the conservation of entropy is a result of ignoring dissipation , viscosity and thermal conductivity ( an ideal fluid ) . the dynamical system is closed by the equation of state @xmath10 .",
    "we assume an ideal gas equation of state , with @xmath11 in our code , although many others are possible .",
    "alternatively , the entropy equation can be substituted with the conservation of energy equation , @xmath12 and the equation of state is then @xmath13 .",
    "we note that the use of a particle - based method ensures that the continuity equations are immediately satisfied .",
    "let us first discuss the basic features of the 3 m algorithm , a thorough review can be found in @xcite .",
    "the fundamental basis of the 3 m algorithm is that the gravitational force can be separated into short and long range components , , @xmath14 where @xmath15 will be provided by a fourier - based solver and @xmath16 will be calculated by summing over particles within a given short range radius .",
    "the @xmath15 force is typical known as the pm force , for particle - mesh , while the @xmath16 range force is typical known as the pp force , for particle - particle .",
    "the accuracy of the @xmath17 force can be improved by further smoothing the mesh force , @xmath15 , and hence increasing the range over the which the short - scale calculation is done , at the cost of an increased number of particle  particle interactions .    the first step in evaluating that pm force is to interpolate the mass density of the particle distribution on to a grid which can be viewed as a map from a lagrangian representation to an eulerian one .",
    "the interpolation function we use is the the ` triangular shaped cloud ' ( tsc ) ` assignment function ' ( see @xcite for a detailed discussion of possible assignment functions ) .",
    "two benefits of using tsc are good suppression of aliasing from power above the nyquist frequency of the grid and a comparatively low directional force error around the grid spacing .",
    "the mass assignment operation count is @xmath18 , where @xmath19 is the number of particles .",
    "once the mass density grid has been constructed it is fourier transformed using an fft routine , which is an @xmath20 operation , where @xmath21 is the extent of the fourier grid in one direction . the resulting k - space field",
    "is then multiplied with a green s function that is calculated to minimize errors associated with the mass assignment procedure ( see hockney & eastwood for a review of the ` q - minimization ' procedure ) . following this convolution ,",
    "the resulting potential grid is differenced to recover the force grid .",
    "we use a 10-point differencing operator which incorporates off - axis components and reduces directional force errors , but many others are possible .",
    "finally , the pm accelerations are found from the force grid using the mass assignment function to interpolate the acceleration field .",
    "the pm algorithm has an operation cost that is approximately @xmath22 where @xmath23 and @xmath24 are constants ( the @xmath25 cost of the differencing is adequately approximated by the logarithmic term describing the fft ) .",
    "resolution above the nyquist frequency of the pm code , or equivalently sub pm grid resolution , is provided by the pair - wise ( shaped ) short - range force summation .",
    "supplementing the pm force with the short - range pp force gives the full p@xmath1 m algorithm , and the execution time scales approximately in proportion to @xmath23n+@xmath24l@xmath1 log l + @xmath26n@xmath27 , where @xmath28 is a constant and n@xmath27 corresponds to the number of particles in the short range force calculation within a specified region .",
    "the summation is performed over all the pp regions , which are identified using a chaining mesh of size _ ls_@xmath1 ; see  [ chaining ] for an illustration of the chaining mesh overlaid on the potential mesh .",
    "p@xmath1 m suffers the drawback that under heavy gravitational clustering the short range sum used to supplement the pm force slows the calculation down dramatically - the n@xmath27 term dominates as an increasingly large number of particles contribute to the short range sum .",
    "although acutely dependent upon the particle number and relative clustering in a simulation , the algorithm may slow down by a factor between 10 - 100 or possibly more . while finer meshes partially alleviate this problem they quickly become inefficient due to wasting computation on areas that do not need higher resolution .",
    "adaptive p@xmath1 m remedies the slow - down under clustering of 3 m by isolating regions where the n@xmath29 term dominates and solving for the short range force in these regions using fft methods on a sub - grid , which is then supplemented by short range calculations involving fewer neighbours .",
    "this process is a repeat of the 3 m algorithm on the selected regions , with an isolated fft and shaped force . at the expense of a little additional bookkeeping",
    ", this method circumvents the sometimes dramatic slow - down of 3 m .",
    "the operation count is now approximately , @xmath30,\\ ] ] where @xmath31 is the number of refinements .",
    "the @xmath32 and @xmath33 are all expected to be very similar to the @xmath23 , and @xmath28 of the main solver , while the @xmath34 are approximately four times larger than @xmath24 due to the isolated fourier transform .",
    "ideally during the course of the simulation the time per iteration approaches a constant , roughly 2 - 4 times that of a uniform distribution ( although when the sph algorithm is included this slow - down can be larger ) .",
    "when implemented in an adaptive form @xcite , with smoothing performed over a fixed number of neighbour particles , sph is an order @xmath19 scheme and fits well within the p@xmath1 m method since the short - range force - supplement for the mesh force can be used to find the particles which are required for the sph calculation .",
    "there are a number of excellent reviews of the sph methodology @xcite and we present , here , only those details necessary to understand our specific algorithm implementation .",
    "full details of our implementation can be found in @xcite .",
    "we use an explicit ` gather ' smoothing kernel and the symmetrization of the equation of motion is achieved by making the replacement , @xmath35 in the ` standard ' sph equation of motion ( see @xcite , for example ) .",
    "note that the sole purpose of ` kernel averaging ' in this implementation , denoted by the bar on the smoothing kernel @xmath36 , is to ensure that the above replacement is correct to @xmath37 .",
    "hence the equation of motion is , @xmath38 @xmath39 the artificial viscosity , @xmath40 , is used to prevent interpenetration of particle flows and is given by , @xmath41 where , @xmath42 @xmath43 and @xmath44 with bars being used to indicate averages over the @xmath45 indices .",
    "shear - correction @xcite , is achieved by including the @xmath46 term which reduces theunwanted artificial viscosity in shearing flows .",
    "note that the lack of @xmath47 symmetry in @xmath40 is not a concern since the equation of motion enforces force symmetry .",
    "the energy equation is given by , @xmath48    the solution of these equations is comparatively straightforward . as in the 3 m solver it is necessary to establish the neighbour particle lists .",
    "the density of each particle must be evaluated and then , in a second loop , the solution to the force and energy equations can be found . since the equation of motion does not explicitly depend on the density of particle @xmath49 ( the artificial viscosity has also been constructed to avoid this ) we emphasize that there is no need to calculate all the density values first and then calculate the force and energy equations . if one does calculate all densities first , then clearly the list of neighbours is calculated twice , or alternatively , a large amount of memory must be used to store the neighbour lists of all particles . using our method",
    "the density can be calculated , one list of neighbours stored , and then the force and energy calculations can be quickly solved using the stored list of neighbours ( see @xcite ) .",
    "as emphasized , the list data - structure used in the short - range force calculation provides a common feature between the 3 m and sph solvers .",
    "hence , once a list of particle neighbours has been found , it is simple to sort through this and establish which particles are to be considered for the gravitational calculation and the sph calculation .",
    "thus the incorporation of sph into ap@xmath1 m necessitates only the coordination of scalings and minor bookkeeping .",
    "the combined adaptive p@xmath1m - sph code , ` hydra ' , in serial fortran 77 form is available on the world wide web from http://coho.physics.mcmaster.ca/hydra .",
    "the solution cycle of one time - step may be summarized as follows ,    1 .",
    "assign mass to the fourier mesh .",
    "convolve with the green s function using the fft method to get potential .",
    "difference this to recover mesh forces in each dimension .",
    "3 .   apply mesh force and accelerate particles .",
    "4 .   decide where it is more computationally efficient to solve via the further use of fourier methods as opposed to short - range forces and , if so , place a new sub - mesh ( refinement ) there . 5 .",
    "accumulate the gas forces ( and state changes ) as well as the short range gravity for all positions not in sub - meshes .",
    "repeat 1 - 5 on all sub - meshes until forces on all particles in simulation have been accumulated .",
    "update time - step and repeat    note that the procedure of placing meshes is hierarchical in that a further sub - mesh may be placed inside a sub - mesh .",
    "this procedure can continue to an arbitrary depth but , typically , even for the most clustered simulations , speed - up only occurs to a depth of six levels of refinement .    a pseudo call - tree for the serial algorithm can be seen in  [ ctree ] .",
    "the purpose of each subroutine is as follows ,    *",
    "startup reads in data and parameter files * inunit calculates units of simulation from parameters in start - up files * updaterv time - stepping control * output check - pointing and scheduled data output routines * accel selection of time - step criteria and corrections , if necessary , for comoving versus physical coordinates * force main control routine of the force evaluation subroutines * rfinit & load set up parameters for pm and pp calculation , in load data is also loaded into particle buffers for the refinement .",
    "* clist & uload preparation of particle data for any refinements that may have been placed , uload also unloads particle data from refinement buffers * refforce call pm routines , controls particle bookkeeping , call pp routines . *",
    "green & igreen calculation of green s functions for periodic ( green ) and isolated ( igreen ) convolutions .",
    "* mesh & imesh mass assignment , convolution call , and calculation of pm acceleration in the periodic ( mesh ) and isolated ( imesh ) solvers",
    ". * cnvlt & icnvlt green s function convolution routines . *",
    "four3 m 3 dimensional fft routine for periodic boundary conditions . * list evaluation of chaining cell particle lists * refine check whether refinements need to be placed . * shforce calculate force look - up tables for pp * shgravsph evaluate pp and sph forces",
    "the architecture of risc cpus incorporates a memory hierarchy with widely differing levels of performance .",
    "consequently , the efficiency of a code running on a risc processor is dictated almost entirely by the ratio of the time spent in memory accesses to the time spent performing computation .",
    "this fact can lead to enormous differences in code performance .",
    "the relative access times for the hierarchy are almost logarithmic .",
    "access to the first level of cache memory takes 1 - 2 processor cycles , while access to the second level of cache memory takes approximately 5 times as long .",
    "access to main memory takes approximately 10 times longer .",
    "it is interesting to note that smp - numa servers provide further levels to this hierarchy , as will be discussed later .    to improve memory performance , when retrieving a word from main memory three other words",
    "are typically retrieved : the ` cache line ' .",
    "if the additional words are used within the computation on a short time scale , the algorithm exhibits good cache reuse .",
    "it is also important to not access memory in disordered fashion , optimally one should need memory references that are stored within caches .",
    "thus to exhibit good performance on a risc processor , a code must exhibit both good cache reuse and a low number of cache misses . in practice",
    ", keeping cache misses to a minimum is the first objective since cache reuse is comparatively easy to achieve given a sensible ordering of the calculation ( such as a fortran do loop ) .",
    "a number of optimizations for particle codes that run on risc processors are discussed in decyk @xcite .",
    "almost all of these optimizations are included within our serial code , with the exception of the mass assignment optimizations .",
    "indeed a large number of their optimizations , especially those relating to combining x , y , z coordinate arrays into one 3-d array , can be viewed as good programming style .",
    "while decyk demonstrate that the complexity of the periodic mass assignment function prevents compilers from software pipelining the mesh writes , we do not include their suggested optimization of removing the modulo statements and using a larger grid .",
    "however , the optimization is naturally incorporated in our isolated solver .",
    "the first optimization we attempted was the removal of a ` vectorizeable ' numerical recipes fft used within the code ( fourn , see @xcite ) .",
    "although the code uses an optimized 3-d fft that can call the fourn routine repeatedly using either 1-d or 2-d fft strategy ( to reduce the number of cache misses exhibited by the fourn routine when run in 3-d ) , the overall performance remains quite poor .",
    "therefore we replaced this routine with the fftpack ( see @xcite ) routines available from netlib , and explicitly made the 3-d fft a combination of 1-d ffts .",
    "although there is no question that fftw @xcite provides the fastest ffts on almost all architectures we have found little difference between fftpack and fftw within our parallel 3-d fft routine .",
    "the greatest performance improvement is seen in the isolated solver where the 3-d fft is compacted to account for the fact that multiple octants are initially zero .",
    "linked lists ( hereafter the list array is denoted ll ) are a common data structure used extensively in particle - in - cell type codes ( see @xcite , for an extensive review of their use ) . for a list of particles which is cataloged according to cells in which they reside , it is necessary to store an additional array which holds the label of the first particle in the list for a particular cell .",
    "this array is denoted ihc for integer head of chain .",
    "list traversal for a given cell is frequently programmed in fortran using an if ... then ...",
    "goto structure ( although it can be programmed with a do while loop ) , with the loop exiting on the if statement finding a value of zero in the linked list . since the loop ` index ' ( the particle index i ) is found recursively the compiler can not make decisions about a number of optimization processes , particularly software pipelining , for which loops are usually better . additionally ,",
    "if the particles indices are not ordered in the list traversal direction then there will usually be a cache miss in finding the element ll(i ) within the linked list array . within the particle data arrays ,",
    "the result of the particle indices not being contiguous is another series of cache misses . since",
    "a number of arrays must be accessed to recover the particle data , the problem is further compounded , and removal of the cache miss associated with the particle indices should improve performance significantly .",
    "the first step that may be taken to improve the situation is to remove the cache misses associated with the searching through the linked list . to do this the list must be formed so that it is ordered . in other words the first particle in cell j ,",
    "is given by ihc(j ) , the second particle is given by ll(ihc(j ) ) , the third by ll(ihc(j)+1 ) _ et cetera_. this ordered list also allows the short range force calculation to be programmed more elegantly since the if .. then .. goto structure of the linked list can be replaced by a loop .",
    "however , since there remains no guarantee that the particle indices will be ordered , the compiler is still heavily constrained in terms of the optimizations it may attempt , but the situation is distinctly better than for the standard linked list .",
    "tests performed on this ordered list algorithm show that a 30% improvement in speed is gained over the linked list code ( see  [ timings ] ) .",
    "cache misses in the data arrays are of course still present in this algorithm .",
    "as has been discussed , minimizing cache misses in the particle data arrays requires accessing them with a contiguous index .",
    "this means that within a given chaining cell the particle indices must be contiguous .",
    "this can be achieved by reordering the indices of particles within chaining cells at each step of the iteration ( although if particles need to be tracked a permutation array must be carried ) .",
    "this _ particle reordering _ idea was realized comparatively early and has been discussed in the literature @xcite .",
    "a similar concept has been applied by springel @xcite who uses peano - hilbert ordering of particle indices to ensure data locality . however , in 3 m codes , prior to the implementation presented here only macfarland @xcite and anderson and shumaker @xcite , actually revised the code to remove linked lists , other codes simply reordered the particles every few steps to reduce the probability of cache misses and achieved a performance improvement of up to 45% @xcite . since the adaptive refinements in use the same particle indexing method , the particle ordering must be done within the data loaded into a refinement , hierarchical rearrangement of indices results from the use of refinements .",
    "the step - to - step permutation is straightforward to calculate : first the particle indices are sorted according to their z - coordinate and then particle array indices are simply changed accordingly .",
    "it is important to note that this method of particle bookkeeping removes the need for an index list of the particles ( although in practice this storage is taken by the permutation array ) .",
    "all that need be stored is the particle index corresponding to the first particle in the cell and the number of particles in the cell . on a risc system particle reordering",
    "is so efficient that the speed of the simulation algorithm _ more than doubled_. for example , at the end of the santa barbara galaxy cluster simulation , the execution time was reduced from 380 seconds to 160 seconds on a 266 mhz pentium iii processor . on a more modern 2 ghz amd opteron , which has four times the l2 cache of a pentium iii , considerably better prefetch , as well as an on - die memory controller to reduce latency",
    ", we found the performance improvement for the final iterations to be a reduction in time from 29 seconds to 17 .",
    "this corresponds to a speed improvement of a factor of 1.7 , which , while slightly less impressive than the factor of 2.4 seen on the older pentium iii , is still a significant improvement .",
    "a comparison plot of the performance of a linked list , ordered list and ordered particle code is shown in  [ timings ] .",
    "particle - grid codes , of the kind used in cosmology , are difficult to parallelize efficiently .",
    "the fundamental limitation to the code is the degree to which the problem may be subdivided while still averting race conditions and unnecessary buffering or synchronization .",
    "for example , the fundamental limit on the size of a computational atom in the pp code is effectively a chaining cell , while for the fft routine it is a plane in the data cube . in practice ,",
    "load balance constraints come into play earlier than theoretical limits as the work within the minimal atoms will rarely be equal ( and can be orders of magnitude different ) .",
    "clearly these considerations set an upper bound on the degree to which the problem can be subdivided , which in turn limits the number of processors that may be used effectively for a given problem size .",
    "the code is a good example of gustafson s conjecture : a greater degree of parallelism may not allow arbitrarily increased execution speed for problems of fixed size , but should permit larger problems to be addressed in a similar time .    at an abstract level",
    ", the code divides into essentially two pieces : the top level mesh and the refinements .",
    "parallelization of the top level mesh involves parallelizing the work in each associated subroutine .",
    "since an individual refinement may have very little work a parallel scheme that seeks to divide work at all points during execution will be highly inefficient .",
    "therefore the following division of parallelism was made : conduct all refinements of size greater than @xmath50 particles across the whole machine , for refinements with less than @xmath50 particles use a list of all refinements and distribute one refinement to each processor ( or thread ) in a task farm arrangement . on the t3d",
    "the limiting @xmath50 was found to be approximately 32,768 particles , while on more modern machines we have found that 262,144 is a better limit .    in the following discussion",
    "the term processor element ( pe ) is used to denote a parallel execution thread . since only one thread of execution",
    "is allotted per processor ( we do not attempt load balancing via parallel slackness ) , this number is equivalent to the number of cpus , and the two terms are used interchangeably .",
    "the call tree of the parallel algorithm is given in figure  [ ptree ] .",
    "the openmp api supports a number of parallel constructs , such as executing multiple serial regions of code in parallel ( a single program multiple data model ) , as well as the more typical loop - based parallelism model ( sometimes denoted ",
    "par do s ) , where the entire set of loop iterations is distributed across all the pes .",
    "the pragma for executing a loop in parallel , c$omp parallel do is placed before the do loop within the code body .",
    "specification statements are necessary to inform the compiler about which variables are loop ` private ' ( each processor carries its own value ) and ` shared ' variables . a full specification of the details for each loop takes only a few lines of code , preventing the ` code bloat ' often associated with distributed memory parallel codes .",
    "we use loop level parallelism throughout our code . to optimize load balance in a given routine",
    "it is necessary to select the most optimal iteration scheduling algorithm .",
    "the openmp directives allow for the following types of iteration scheduling :    * static scheduling - the iterations are divided into chunks ( the size of which may be specified if desired ) and the chunks are distributed across the processor space in a contiguous fashion . a cyclic distribution , or a cyclic distribution of small chunks is also available . * dynamic scheduling -",
    "the iterations are again divided up into chunks , however as each processor finishes its allotted chunk , it dynamically obtains the next set of iterations , via a master - worker mechanism .",
    "* guided scheduling - is similar to static scheduling except that the chunk size decreases exponentially as each set of iterations is finished .",
    "the minimum number of iterations to be allotted to each chunk may be specified .",
    "* runtime scheduling - this option allows the decision on which scheduling to use to be delayed until the program is run . the desired scheduling is then chosen by setting an environment variable in the operating system .",
    "the code uses both static and dynamic scheduling .",
    "while the step - to - step permutation is in principle simple to calculate , the creation of the list permutation array must be done carefully to avoid race conditions .",
    "an effective strategy is to calculate the chaining cell residence for each particle and then sort into bins of like chaining cells .",
    "once particles have been binned in this fashion the rearrangement according to z - coordinates is a local permutation among particles in the chaining cell .",
    "our parallel algorithm works as follows :    1 .",
    "first calculate the chaining cell that each particle resides in , and store this in an array 2 .   perform an increasing - order global sort over the array of box indices 3 .   using a loop over particle indices , find the first particle in each section of contiguous like - indices ( the ihc array ) 4 .",
    "use this array to establish the number of particles in each contiguous section ( the nhc array ) 5 .",
    "write the z - coordinates of each particle within the chaining cell into another auxiliary array 6 .",
    "sort all the non - overlapping sublists of z - coordinates for all cells in parallel while at the same time permuting an index array to store the precise rearrangement of particle indices required 7 .",
    "pass the newly calculated permutation array to a routine that will rearrange all the particle data into the new order    the global sort is performed using parallel sorting by regular sampling , @xcite with a code developed in part by j. crawford and c. mobarry .",
    "this code has been demonstrated to scale extremely well on shared - memory architectures provided the number of elements per cpu exceeds 50,000 .",
    "this is significantly less than our ideal particle load per processor ( see section 6 ) . for the sorts within cells ,",
    "the slow step - to - step evolution of particle positions ensures data rearrangement is sufficiently local for this to be an efficient routine .",
    "hence we expect good scaling for the sort routines at the level of granularity we typically use .",
    "a race condition may occur in mass assignment because it is possible for pes to have particles which write to the same elements of the mass array .",
    "the approaches to solving this problem are numerous but consist mainly of two ideas ; ( a ) selectively assign particles to pes so that mass assignment occurs at grid cells that do not overlap , thus race condition is avoided or ( b ) use ghost cells and contiguous slabs of particles which are constrained in their extent in the simulation space .",
    "the final mass array must be accumulated by adding up all cells , including ghosts .",
    "ghost cells offer the advantage that they allow the calculation to be load - balanced ( the size of a slab may be adjusted ) but require more memory . controlling which particles are assigned does not require more memory but may cause a load imbalance .",
    "because the types of simulation performed have particle distributions that can vary greatly , both of these algorithms have been implemented .",
    "the particles in the simulation are ordered in the z - direction within the chaining cells . because the chaining cells are themselves ordered along the z - axis ( modulo their cubic arrangement ) a naive solution would be to simply divide up the list of particles . however",
    ", this approach does not prevent a race condition occurring , it merely makes it less likely . in the craft code the race condition was avoided by using the ` _ atomic update _ ' facility which is a lock__fetch__update__store__unlock hardware primitive that allows fast updating of arrays where race conditions are present .",
    "modern cache coherency protocols are unable to provide this kind of functionality .",
    "using the linked / ordered list to control the particle assignment provides an elegant solution to the race condition problem . since the linked list encodes the position of a particle to within a chaining cell , it is possible to selectively assign particles to the mass array that do not have overlapping writes",
    ". to assure a good load balance it is better to use columns ( @xmath51 , where @xmath52 is the size of the chaining mesh and @xmath53 is a number of chaining cells ) of cells rather than slabs ( @xmath54 ) .",
    "since there are more columns than slabs a finer grained distribution of the computation can be achieved and thus a better load balance .",
    "this idea can also be extended to a 3-d decomposition , however in simple experiments we have found this approach to be inefficient for all but the most clustered particle distributions ( in particular cache reuse is lowered by using a 3-d decomposition ) .    chaining mesh cells have a minimum width of 2.2 potential mesh cells in and  [ chaining ] displays a plot of the chaining mesh overlaid on the potential mesh .",
    "when performing mass assignment for a particle , writes will occur over all 27 grid cells found by the tsc assignment scheme . thus providing a buffer zone of one cell",
    "is not sufficient to avoid the race condition since particles in chaining cells one and three may still write to the same potential mesh cell .",
    "a spacing of two chaining mesh cells is sufficient to ensure no possibility of concurrent writes to the same mesh cell .",
    "the `` buffer zones '' thus divide up the simulation volume into a number of regions that can calculated concurrently and those that can not .",
    "moreover , there will be need to be a series of barrier synchronizations as regions that can be written concurrently are finished before beginning the next set of regions .",
    "the size of the buffer zone means that there are two distinct ways of performing the mass assignment using columns :    * @xmath55 columns in @xmath56 groups .",
    "assign mass for particles in each of the columns simultaneously and then perform a barrier synchronization at the end of each column .",
    "since the columns are in @xmath57 groups there are nine barriers .",
    "* @xmath58 columns which are grouped into @xmath59 groups . in this case",
    "the number of barriers is reduced to four , and if desired , the size of the column can be increased beyond two while still maintaining four barriers .",
    "however , load - imbalance under clustering argues against this idea .",
    "see  [ 2by2 ] for a graphical representation of the algorithm .    to improve load balance ,",
    "a list of the relative work in each column ( that can be evaluated before the barrier synchronization ) is calculated by summing over the number of particles in the column .",
    "once the workload of each column has been evaluated , the list of relative workloads is then sorted in descending order .",
    "the calculation then proceeds by dynamically assigning the list of columns to the pes as they become free .",
    "the only load imbalance then possible is a wait for the last pe to finish which should be a column with a low workload .",
    "static , and even cyclic , distributions offer the possibility of more severe load imbalance .    for portability reasons , we have parallelized the fft by hand rather than relying on a threaded library such as provided by fftw .",
    "the 3-d fft is parallelized over ` lines ' by calling a series of 1-d ffts .",
    "we perform the transpose operation by explicitly copying contiguous pieces of the main data array into buffers which have a long stride .",
    "this improves data locality of the code considerably as the stride has been introduced into the buffer which is a local array .",
    "the ffts are then performed on the buffer , and values are finally copied back into the data arrays . the convolution which follows the fft relies upon another set of nested loops in the axis directions . to enable maximum granularity we have combined the z- and y - directions into one larger loop which is then statically decomposed among the processors .",
    "parallel efficiency is high for this method since if the number of processors divides the size of the fft grid we have performed a simple slab decomposition of the serial calculation .",
    "the short range forces are accumulated by using 3 nested loops to sort through the chaining mesh . as in mass assignment ,",
    "a race condition is present due to the possibility of concurrent writes to the data arrays . again",
    ", in the craft code , this race condition was avoided by using the atomic update primitive .    because a particle in a given chaining mesh cell may write to its 26 nearest - neighbour cells it is necessary to provide a two cell buffer zone .",
    "we can therefore borrow the exact same column decomposition that was used in mass assignment .",
    "tests showed that of the two possible column sorting algorithms discussed in section  [ cpa ] , @xmath58 columns are more efficient than the @xmath60 columns .",
    "the difference in execution time in unclustered states was negligible , but for highly clustered distributions ( as measured in the santa barbara cluster simulation @xcite ) , the @xmath61 method was approximately 20% faster .",
    "this performance improvement is attributable to the difference in the number of barrier synchronizations required by each algorithm ( four versus nine ) and also the better cache reuse of the @xmath58 columns .",
    "as discussed earlier , the smaller sub - meshes ( @xmath62 ) are distributed as a task farm amongst the pes .",
    "as soon as one processor becomes free it is immediately given work from a pool via the dynamic scheduling option in openmp .",
    "load imbalance may still occur in the task farm if one refinement takes significantly longer than the rest and there are not enough refinements to balance the workload over the remaining pes .",
    "note also the task farm is divided into levels , the refinements placed within the top level , termed ` level one refinements ' must be completed before calculating the ` level two refinements ' , that have been generated by the level one refinements . however , we minimize the impact of the barrier wait by sorting refinements by the number of particles contained within them and then begin calculating the largest refinements first .",
    "this issue emphasizes one of the drawbacks of a shared memory codeit is limited by the parallelism available and one has to choose between distributing the workload over the whole machine or single cpus .",
    "it is not possible in the openmp programming environment to partition the machine into processor groups .",
    "this is the major drawback that has been addressed by the development of an mpi version of the code @xcite .",
    "because of the comparatively low ratio of work to memory read / write operations the code is potentially sensitive to memory latency issues . to test this sensitivity in a broad sense ,",
    "we have examined the performance of the code for a range of problem sizes , from @xmath63 particles to @xmath64 , the smallest of which is close to fitting in l2 cache .",
    "a strong latency dependence will translate into much higher performance for problem sizes resident in cache as opposed to those requiring large amounts of main memory .",
    "we also consider the performance for both clustered and unclustered particle distributions since the performance envelope is considerably different for these two cases .",
    "the best metric for performance is particle updates per second , since for the unclustered distribution p@xmath1 m has an operation dependence dominated by @xmath65 factors , while in the clustered state the algorithm dominated by the cost of the sph solution which also scales as @xmath65 .",
    "the results are plotted in figure [ latency ] , as a function of memory consumption .",
    "we find that the @xmath63 simulations show equal performance for both the linked list and ordered particle code under both clustering states .",
    "however , for larger problem sizes the unclustered state shows a considerable drop - off in performance for the linked list code , while the ordered particle code begins to level off at the @xmath66 problem size .",
    "the clustered distributions show little sensitivity to problem size , which is clearly indicative of good cache reuse and a lack of latency sensitivity .",
    "we conclude that the algorithm is comparatively insensitive to latency because the solution time is dominated largely by the pp part of the code which exhibits good cache reuse .",
    "the increased performance improvement seen for the ordered particle code is caused by the increased data locality .",
    "on numa architectures this has a direct benefit as although the penalty for distant memory fetches is large ( several hundreds of nanoseconds ) the cache reuse ensures this penalty is only felt rarely .",
    "we have found that the locality is sufficiently high to render direct data placement largely irrelevant on the sgi origin .",
    "the only explicit data placement we perform is a block distribution of the particle data over pes .",
    "the constant reordering of particles ensures that this is an effective distribution . for the remainder of the arrays we use the `` first touch '' placement paradigm , namely that the first pe to request a specific memory page",
    "is assigned it . despite the simplicity",
    ", this scheme works very effectively .",
    "since the granularity of the chaining cells is smaller than the smallest memory page size , prefetching is better strategy than memory page rearrangement .",
    "this works particularly effectively in the pp part of the algorithm where a comparatively large amount of work is done per particle . in this section of code",
    "we specify that two cache lines should always be retrieved for each cache miss , and we also allow the compiler to make further ( aggressive ) prefetching predictions .",
    "the net effect of this is to almost completely hide the latency on the origin .",
    "this can be seen in the performance scaling , where excellent results are achieved up to 64 nodes ( see section  [ perf ] )",
    ".    however , there is one particularly noticeable drawback to numa architectures .",
    "a number of the arrays used within the pm solver are equivalenced to a scratch work space within a common block .",
    "first touch placement means that the pages of the scratch array are distributed according to the layout of the first array equivalenced to the common block .",
    "if the layout of this array is not commensurate with the layout of subsequent arrays that are equivalenced to the scratch area then severe performance penalties result .",
    "our solution has simply been to remove the scratch work space and suffer the penalty of increased memory requirements .",
    "our initial tests of correctness of large simulations ( @xmath67 ) , comparing serial to parallel runs , showed variation in global values , such as the total mass within the box at the 0.01 percent level .",
    "however , this turned out to be a precision issue , as increasing the summation variables to double precision removed any variation in values . with these changes made ,",
    "we have confirmed that the parallel code gives identical results to the serial code to machine - level rounding errors .",
    "an extensive suite of tests of the code are detailed in @xcite and @xcite .",
    "our standard test case for benchmarking is the ` santa barbara cluster ' used in the paper by frenk @xcite",
    ". this simulation models the formation of a galaxy cluster of mass @xmath68 in a einstein - de sitter scdm cosmology with parameters @xmath69 , @xmath70=0.1 , @xmath71=0.6 , @xmath72 , and box size 64 mpc .",
    "our base simulation cube has @xmath66 particles , which yields 15300 particles in the galaxy cluster , and we use an s2 softening length of 37 kpc .",
    "particle masses are @xmath73 for dark matter and @xmath74 for gas . to prepare a larger data set we simply tile the cube as many times as necessary .",
    "an output from z=7.9 is used as an ` unclustered ' data set , and one from z=0.001 as a ` clustered ' data set .",
    "we were given access to two large smp machines to test our code on , a 64 processor sgi origin 3000 ( o3k , hereafter ) at the university of alberta and a 64 processor hewlett packard gs1280 alphaserver .",
    "both of these machines have numa architectures , the o3k topology being a hypercube , while the gs1280 uses a two dimensional torus .",
    "the processors in the o3k are 400 mhz mips r12000 ( baseline specfp2000 319 ) while the gs1280 processors are 21364 ev7 alpha cpus running at 1150 mhz ( baseline specfp2000 1124 ) .",
    "there is an expected raw performance difference of over a factor of three between the two cpus , although in practice we find the raw performance difference to be slightly over two .",
    "we conducted various runs with differing particle and data sizes to test scaling in both the strong ( fixed problem size ) and weak ( scaled problem size ) regimes .",
    "the parallel speed - up and raw execution times are summarized in tables [ tab1 ] & [ tab2 ] and speed - up is shown graphically in figure [ scaling ] .",
    "overheads associated with i / o and start - up are not included .",
    "further , we also do not include the overhead associated with placing refinements on the top level of the simulation , as this is only performed every 20 steps .    with the exception of the clustered @xmath66 run , parallel scaling is good ( better than 73% ) to 32 processors on both machines for all runs .",
    "the clustered @xmath66 simulation does not scale effectively because the domain decomposition is not sufficiently fine to deal with the load imbalance produced by this particle configuration .",
    "only the largest simulation has sufficient work to scale effectively beyond 32 processors . to estimate the scaling of the @xmath67",
    "run we estimated the speed - up on 8 nodes of the gs1280 as 7.9 ( based upon the slightly lower efficiencies observed on the @xmath64 compared to the o3k ) , while on the o3k we estimated the speed up as 8.0 .",
    "we then estimated the scaling from that point .",
    "speed - up relative to the 8 processor value is also given in table 1 , and thus values may be scaled as desired .",
    ".parallel scaling efficiencies and wall clock timings for a full gravity - hydrodynamic calculation on the sgi origin 3000 .",
    "results in parenthesis indicate that the values are estimated .",
    "the 64 processor results for the two smallest runs have been omitted because they resulted in a slowdown relative to the 32 processor run . [",
    "cols=\"^,<,^,^,^,^,^\",options=\"header \" , ]     [ tab2 ]    to quantify our results further we summarize the performance of the code using a popular performance metric for cosmological codes , namely the number of particle updates per second . as a function of the number of nodes within the calculation",
    "this also gives a clear picture of the scaling achieved . because the simulation results we obtained were run using the combined gravity - hydrodynamic solver it is necessary for us to interpolate the gravitational speed .",
    "to do this we calculated the ratio of the code speed with and without hydrodynamics , and also without the pp correction , on 1 cpu of our local gs160 alphaserver , and on 1 cpu of the o3k . to ensure this approximation is as reasonable as possible we calculated the ratios for both the z=7.9 and z=0.001 datasets .",
    "relative to the speed obtained for the combined solver , the gravity - only solver was found to be 1.63(1.29 ) times faster for the z=7.9 dataset and 1.84(1.49 ) times faster for the z=0.001 dataset , for the gs1280 ( and o3k ) .",
    "the pm speed was found to 2.4(2.5 ) times faster for the z=7.9 dataset and 9.21(10.3 ) times faster for the z=0.001 dataset .    in figure [ pups ]",
    "we show the estimated number of gravitational updates per second achieved on in both the clustered and unclustered state of the @xmath64 simulation ( other simulation sizes show almost identical speeds ) on the gs1280 .",
    "the clustered state is approximately three times slower than the unclustered state for all simulation sizes . to provide comparison to other published work",
    "we have also included results presented by dubinski for a @xmath75 simulation conducted on a @xmath76 grid using a distributed memory tree - pm code ( `` gotpm '' ) .",
    "although a direct comparison of speed is not as instructive as might be hoped , since both the machine specifications and particle distributions differ , it is intriguing that the raw pm speed of both codes are very similar , with our code showing a moderate speed advantage ( between 2.4 and 1.8 times faster depending on clustering ) .",
    "comparing the speed of the full solutions ( for the @xmath67 simulation ) in the clustered state shows hydra to be 2.3 times faster , although the initial configuration is 3.9 times faster , while reportedly tree - pm codes have a roughly constant cycle time with clustering @xcite .",
    "this highlights the fact that while tree - pm codes have a roughly constant cycle time with clustering , there is still significant room for improving the execution on unclustered data sets .",
    "it is also worth noting that , as yet , our implementation of 3 m lacks any multiple time - step capability , and implementing a mechanism that steps refinements within different time bins has potentially very significant performance gains .",
    "such an integrator would bear similarities to the mixed - variable symplectic integrators used in planetary integrations @xcite .",
    "although overall performance is the most useful measure of utility for the code , analysis of the time spent in certain code sections may elucidate performance bottlenecks .",
    "hence , for timing purposes , we break the code into three main sections ; the top level pm , the top level pp and the refinement farm .",
    "the speed of list making and particle book - keeping is incorporated within these sections .    the execution time is initially dominated by the solution time for the top level grid , but the growth of clustering makes the solution time strongly dependent upon the efficiency of the refinement farm . while the top level solution ( necessarily ) involves a large number of global barriers , the refinement farm only uses a small number and performs a large number of independent operations .",
    "the only exception is a critical section where the global list of refinements is updated , however we ensure the critical section is only entered if a refinement has indeed derived new refinements . thus , potentially , the refinement farm can scale better than the top level solution .",
    "in figure [ farmvstop ] we plot the relative scaling of the top level solution compared to the refinement farm for a several different particle numbers .",
    "provided sufficient work is available for distribution , the refinement farm is seen to scale extremely well , with parallel efficiencies of 99% and 83% observed for the @xmath67 data set on 64 processors for the o3k and gs1280 respectively .",
    "conducting high resolution simulations of cosmological structure formation necessitates the use of parallel computing .",
    "although distributed architectures provide an abundance of cheap computing power , the programming model for distributed systems is fundamentally complex . shared memory simplifies parallel programming greatly since the shared address space means that only the calculation itself need be distributed across nodes . in this paper",
    "we have discussed a code for parallel shared memory computers that exhibits only marginally higher complexity than a serial version of the code and which also exhibits excellent performance .",
    "additional constructs for parallel execution introduce only a small ( 10% ) penalty for running on 1 node compared to the serial code .",
    "although the code does have some problems with regards load balancing , in particular a deficit in performance occurs when a refinement is too large to be calculated as part of the task farm but is not large enough to be efficient across the whole machine , these situations are comparatively rare .",
    "the poor scaling of sph under heavy clustering is the most significant cause of load imbalance .",
    "in particular , if the heavy calculational load is confined to one refinement that is part of the task farm all threads will block until this refinement is completed .",
    "the most satisfactory solution to this problem is to substitute an alternative algorithm for the sph in high density regions .",
    "we will present details of an algorithm that improves the sph cycle time for high density regions elsewhere ( thacker in prep ) .",
    "most of the performance limitations can be traced to applying a grid code in a realm where it is not suitable .",
    "as has been emphasized before , treecodes are particularly versatile , and can be applied to almost any particle distribution . however , for periodic simulations they become inefficient since ewald s method must used to calculate periodic forces .",
    "fft - based grid methods calculate the periodic force implicitly , and exhibit particularly high performance for homogeneous particle distributions under light to medium clustering .",
    "highly clustered ( or highly inhomogeneous ) particle distributions are naturally tailored to the multi - timestepping capability of treecodes . although we see scope for introducing a multi - time stepping version of 3 m where sub - grids are advanced in different time step bins it is unclear in details what efficiencies could be gained .",
    "there are clearly parts of the algorithm , such as mass assignment , that are unavoidably subject to load imbalances .",
    "we expect that since the global grid update would be required infrequently the global integrator can still be made efficient .",
    "an efficient implementation of multiple time - steps is the last area where an order of magnitude improvement in simulation time can be expected for this class of algorithm .    in terms of raw performance ,",
    "the code speed is high relative to the values given by dubinski et al . on the gs1280 the full solution time for the unclustered distribution",
    "even exceeds that of the pm solution quoted for gotpm on 64 processors .",
    "3 m has been criticized previously for exhibiting a cycle time that fluctuates depending upon the underlying level of clustering .",
    "the data we have presented here shows the range in speeds is comparatively small ( a factor of 4 ) .",
    "we would also argue that since the cost of the short range correction is so small at early times , this criticism is misplaced .",
    "while recent implementations of tree - pm have an approximately constant cycle time irrespective of clustering , the large search radius used in the tree correction leads to the tree part of the algorithm dominating execution time for all stages of the simulation .",
    "conversely , only at the end of the simulation is this true for hydra .",
    "arguments have also been presented that suggest the pm cycle introduces spurious force errors that can only been corrected by using a long range pp correction ( out to 5 pm cells ) .",
    "it is certainly true that pm codes implemented with the so called ` poor man s poisson solver ' @xcite , and cloud - in - cell interpolation do suffer from large ( @xmath7750% ) directional errors in the force around 2 - 3 grid spacings .",
    "however , as has been shown , first by eastwood ( see @xcite for references ) and more recently by couchman , a combination of higher order assignment functions , q - minimized green s functions , and directionally optimized differencing functions can reduce errors in the inter - particle forces to sub 0.3% levels ( rms ) .",
    "surprisingly , although cic gives a smooth force law ( as compared to ngp ) , it does not reduce the angular isotropy of the mesh force .",
    "indeed , in two dimensions , moving from cic to tsc interpolation reduces directional errors from 50% to 6% and q - minimization of the green s function reduces the anisotropy to sub 0.5% levels @xcite .",
    "furthermore , the technique of interlacing can be used to improve the accuracy of the pm force still further , but the additional ffts required for this method rapidly lead to diminished returns .",
    "to date we have used this code to simulate problems ranging from galaxy formation to large - scale clustering . as emphasized in the introduction ,",
    "the simple programming model provided by openmp has enabled us to rapidly prototype new physics algorithms which in turn has lead to the code being applied across a diverse range of astrophysics . developing new physics models with this code takes a matter of hours , rather than the days typical of mpi coding .",
    "we plan to make a new version of the code , incorporating more streamlined data structures and minor algorithmic improvements , publically available in the near future .",
    "we thank an anonymous referee for comments which improved the paper .",
    "runs on the gs1280 machine were performed on our behalf by andrew feld of hewlett packard .",
    "we thank john kreatsoulas for arranging time for us on this machine .",
    "figures 1 , 2 , 4 and 5 were prepared by dr l. campbell .",
    "rjt is funded in part by a cita national fellowship .",
    "hmpc acknowledges the support of nserc and the canadian institute for advanced research .",
    "sharcnet and westgrid computing facilities were used during this research .                                                                                                        c. s. frenk ,",
    "s. d. m. white , p. bode , j. r. bond , g. l. bryan , r. cen , h. m. p. couchman , a. e. evrard , n. gnedin , a. jenkins , a. m. khokhlov , a. klypin , j. f. navarro , m. l. norman , j. p. ostriker , j. m. owen , f. r. pearce , u .- l . pen , m. steinmetz , p. a. thomas , j. v. villumsen , j. w. wadsley , m. s. warren , g. xu , and g. yepes , _ astrophys . j. _ , * 525 * , ( 1999 ) , 554 ."
  ],
  "abstract_text": [
    "<S> we discuss the design and implementation of hydra_omp a parallel implementation of the smoothed particle hydrodynamics  adaptive 3 m ( sph - a3 m ) code hydra . </S>",
    "<S> the code is designed primarily for conducting cosmological hydrodynamic simulations and is written in fortran77+openmp . </S>",
    "<S> a number of optimizations for risc processors and smp - numa architectures have been implemented , the most important optimization being hierarchical reordering of particles within chaining cells , which greatly improves data locality thereby removing the cache misses typically associated with linked lists . </S>",
    "<S> parallel scaling is good , with a minimum parallel scaling of 73% achieved on 32 nodes for a variety of modern smp architectures . </S>",
    "<S> we give performance data in terms of the number of particle updates per second , which is a more useful performance metric than raw mflops . </S>",
    "<S> a basic version of the code will be made available to the community in the near future . </S>",
    "<S> +    3 g @xmath0 50 50m1    3mp@xmath1 </S>",
    "<S> m 3map@xmath1 m    # 1 currsize normalsize currsize    simulation , cosmology , hydrodynamics , gravitation , structure formation + </S>"
  ]
}