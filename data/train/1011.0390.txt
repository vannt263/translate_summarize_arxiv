{
  "article_text": [
    "the adjacency of vertex @xmath1 and vertex @xmath2 is defined by the edge @xmath3 .",
    "a structure of this form is called a graph and is usually defined as @xmath4 , where @xmath5 are vertices and @xmath6 is the edge adjoining those vertices . , where @xmath7 is the main definition used throughout the article . ]",
    "when the only distinguishing characteristic between two edges is the vertices they join , the graph is called single - relational .",
    "the reason for this is that there is only a single type of relation in the graph ",
    "namely , the binary relation @xmath8 .",
    "single - relational graphs have been used widely to model various systems of homogenous elements related by a single type of relation and as such , have numerous algorithms associated with their analysis @xcite .",
    "when the domain of discourse is variegated by a heterogeneous set of relations , then the multi - relational graph becomes the more applicable construct .",
    "a multi - relational graph can be defined as @xmath9 , where @xmath10 is a family of edge sets and @xmath11 .",
    "when @xmath12 , then there are multiple relations between the vertices of @xmath13 .",
    "multi - relational graphs not only specify which vertices are adjacent to one another , they also specify the way in which they are adjacent . with respect to the formalisms of this article and without loss of generality , a multi - relational graph can also be represented as @xmath14 , where @xmath15 is ternary relation , @xmath16 , and @xmath17 is a set of edge labels ( i.e.  relation types ) .",
    "thus , in reference to the structure @xmath9 , @xmath18 and @xmath19 .",
    "the ternary relation model is the multi - relational graph structure used throughput this article .",
    "the reason for the use of this particular @xmath7 definition will be explained in  [ sec : operations ] .    given the growing use of multi - relational graphs in computing @xcite and the lack of graph techniques for such structures ( relative to single - relational graphs ) , an algebraic model for traversing multi - relational graphs is presented .",
    "this article can be interpreted as a convergence of the @xmath0-ary relational algebra of @xcite , the concatenative single - relational path algebra in @xcite , and the multi - relational tensor algebra presented in @xcite . however , unlike @xcite , the presented algebra is tied specifically to path construction by means of graph traversals as in @xcite and @xcite .",
    "next , unlike the algebra in @xcite , which is oriented primarily towards single - relational graphs , the presented algebra conveniently supports multiple relations as in @xcite and @xcite . finally , unlike @xcite ,",
    "the presented algebra is a concatenative , order - preserving variation of the relational algebra in @xcite and , as such , more aligned with @xcite .",
    "the operations presented are summarized in the itemization below and are provided here as a consolidated summary for ease of reference .",
    "* @xmath20 : the path length of path @xmath21 . * @xmath22 : the concatenation of two paths .",
    "forms the free monoid @xmath23 , where @xmath24 and @xmath25 is the empty / identity element . ]",
    "* @xmath26 : the projection of the @xmath27 edge of a path . * @xmath28 : the projection of the tail ( first element ) of a path .",
    "* @xmath29 : the projection of the head ( last element ) of a path .",
    "* @xmath30 : the projection of the label of an edge . *",
    "@xmath31 : the union of two path sets .",
    "* @xmath32 : the concatenative join of two path sets .",
    "* @xmath33 : the concatenative product of two path sets .",
    "definitions of these operations are provided in  [ sec : operations ] .",
    "the use of these operations to represent basic traversal idioms is presented in  [ sec : basic ] . in ",
    "[ sec : derivative ] , regular paths can be recognized and generated as demonstrated in  [ sec : recognizer ] and  [ sec : generator ] , respectively . making use of the algebra to evaluate single - relational graph algorithms",
    "is presented in  [",
    "sec : rich ] .",
    "the algebra provides a set of core operations for constructing a multi - relational graph traversal engine that is founded on monoid , automata , and formal language theory .",
    "traversing a graph is the process of moving over the edges specified in @xmath15 . during a traversal ,",
    "paths are derived and properties of those paths can be extracted .",
    "a path @xmath21 in a multi - relational graph is a sequence , or string , where @xmath34 and @xmath16 .",
    "a path allows for repeated edges .",
    "the path length is denoted @xmath20 and is equal to the number of edges in @xmath21 .",
    "any edge in @xmath15 is a path with a path length of @xmath35 as @xmath36 .",
    "the binary operation @xmath22 is the concatenation of two paths into a new path such that if @xmath37 and @xmath38 are two edges in @xmath15 , then their concatenation is the path @xmath39 , where @xmath40 and @xmath41 .",
    "concatenation is associative ( i.e.  @xmath42 ) , not commutative ( i.e.  it is generally true that @xmath43 ) , and @xmath25 serves as an identity ( i.e.  @xmath44 ) .",
    "operations exist to extract information out of a path .",
    "the operation @xmath26 is a projection that maps a path to the @xmath27 edge in that path .",
    "for example , if @xmath45 , then @xmath46 and @xmath47 . next , for any path , @xmath28 projects the tail ( first vertex ) of the path such that @xmath48 .",
    "likewise , @xmath29 , where @xmath49 .",
    "similarly , for edge labels , @xmath50 , where @xmath51 .    the _ path label _ of path @xmath21 is defined as the edge labels contained in @xmath21 .",
    "formally , if @xmath21 is a path , then the path label is constructed by @xmath52 , where , using concatenation , @xmath53 the path label of any single edge @xmath54 is simply the edge s label as @xmath55 and @xmath56 .",
    "the binary operation @xmath31 is standard set union .",
    "the binary operation @xmath32 is the concatenative join of two sets of paths such that if @xmath57 , then @xmath58 where @xmath59 ensures that only _ joint _",
    "( i.e.  adjacent ) paths are concatenated .-",
    "join in @xcite , where @xmath60 . in this form ,",
    "its known as an equijoin . a discussion relating concatenative join and the relational algebra",
    "is found in @xcite . ] for example , if @xmath61 and @xmath62 then @xmath63 where @xmath40 , @xmath41 , and @xmath64 .",
    "given that @xmath65 is based on @xmath66 , @xmath65 is associative , but not commutative .",
    "a path is joint is it satisfies the characteristic function @xmath67 with the function rule @xmath68 the function maps to @xmath69 if the path is joint and @xmath70 if it is disjoint .",
    "the binary operation @xmath65 constructs joint paths",
    ". it may be the case that traversing disjoint paths is desirable .",
    "the cartesian product supports the concatenation of potentially disjoint paths . as such , @xmath33 , where @xmath71 .    finally , to conclude this section , the reason why the @xmath72 definition of a multi - relational graph is not used is because when evaluating concatenative joins over binary relations , the edge label information is lost and thus , the path label can not be determined . in other words , if @xmath73 and @xmath74 are edges from two different binary relations , then @xmath75 would only provide a sequence of vertices and as such would not specify from which relations the join was constructed .",
    "this is a deficiency of the algebra in @xcite , where binary relations are used and @xmath76 as opposed to @xmath22 , where @xmath77 .",
    "while the algebra in @xcite is applicable to multi - relational graphs ( as any two relations can be joined ) , it was specifically intended for single - relational graphs , where problems involving path labels are not considered . in contrast , the specification defined in this article preserves path labels .",
    "from the explicit adjacencies ( edges ) defined in the edge set @xmath15 , there exists implicit adjacencies ( paths ) defined by @xmath75 , where @xmath78 and @xmath79 .",
    "given the previously defined operations , different types of common traversal idioms can be affected .      all joint paths through a graph of length @xmath0 can be constructed using @xmath80 .",
    "this type of traversal is called a complete traversal because there is no discrimination when joining except that the join vertex ( i.e.  the head of the first path and tail of the second ) be equal . when it is desirable to limit the set of paths derived by the traversal then the sets @xmath81 need to be defined and joined .",
    "a source traversal emanates from a particular set of vertices .",
    "such a traversal is left restricting as it constructs paths whose tail vertex is an element of @xmath82 .",
    "the first concatenative join must , on its left side , contain the set of all edges in @xmath15 that have their tail vertex in @xmath83 .",
    "therefore , when @xmath84 @xmath85 yields all joint paths of length @xmath0 emanating from the vertices in @xmath83 . when @xmath86 , a complete traversal is evaluated since @xmath87 . for ease of expression ,",
    "the complement of the set @xmath83 can be used to denote where _ not _ to start a traversal from .",
    "for example , @xmath88 states to start the traversal from all vertices in @xmath89 except those in @xmath83 .",
    "a destination traversal is similar to a source traversal , except that it is right restricting as it constructs all paths of length @xmath0 whose head , or terminal , vertex is in @xmath90 . in this way , when @xmath91 @xmath92 is a destination traversal . when @xmath93 , a complete traversal is evaluated because @xmath94 in such situations .    by combining a source and destination traversal , its possible to emanate from particular vertices and arrive at particular vertices , where @xmath95 is the set of all joint paths that start from vertices in @xmath83 , end at vertices in @xmath96 , and are of length @xmath0 .",
    "source and destination traversals can also be used to ensure that each edge in the path goes through a particular set of vertices by specifying , at some particular @xmath65 step , the source ( or destination ) vertex set as @xmath83 ( or @xmath96 ) before enacting the next concatenative join .",
    "a traversal can be constrained to particular path labels by defining an edge set that is a function of its edge labels .",
    "for example , if @xmath97 , @xmath98 , @xmath99 and @xmath100 then @xmath101 denotes all paths where @xmath102 and @xmath103 .",
    "when @xmath104 , a complete traversal is enacted as , in such situations , @xmath105 .",
    "the labeled traversal is possible because the relation type is represented in the edge definition @xmath16 and there exists the label projection function @xmath50 .",
    "the basic traversals defined in  [ sec : basic ] can be mixed and matched to yield different types of joint paths in @xmath106 .",
    "this section will introduce some typical applications of the presented multi - relational path algebra to problems that are specific to multi - relational graphs  focusing primarily on problems involving regular paths .. ]      the presented multi - relational path algebra has application to regular expressions and their corresponding finite state automata . before presenting this application , an example - specific set - builder notation is introduced in order to specify subsets of @xmath15 in a more concise , readable manner than previously presented .",
    "a source edge set can be specified as @xmath107 \\equiv \\bigcup_{\\alpha \\in \\omega } \\bigcup_{j \\in v } ( i,\\alpha , j ) : ( i,\\alpha , j ) \\in e$ ] in order to denote the set of all edges that emanate from vertex @xmath1 .",
    "a destination edge set can be specified as @xmath108 \\equiv \\bigcup_{i \\in v } \\bigcup_{\\alpha",
    "\\in \\omega } ( i,\\alpha , j ) : ( i,\\alpha , j ) \\in e$ ] in order to denote the set of all edges that terminate at vertex @xmath2 .",
    "a labeled edge set can be specified as @xmath109 \\equiv \\bigcup_{i \\in v } \\bigcup_{j \\in v } ( i,\\alpha , j ) : ( i,\\alpha , j ) \\in e$ ] in order to denote the set of all edges that have @xmath110 as their label .",
    "finally @xmath111 = e$ ] .    if @xmath15 is the regular expression alphabet , then @xmath112 , @xmath25 , and any @xmath54 are regular expressions",
    ". if @xmath113 and @xmath114 are regular expressions , then @xmath115 , @xmath116 , and @xmath117 are regular expressions @xcite .",
    "operation can be used to recognize potentially disjoint paths , but in practice , when only joint paths are being recognized then @xmath65 is a more efficient use of resources as @xmath118 . ]",
    "a regular expression over @xmath15 , and corresponding finite state automaton , recognize a set of joint paths in @xmath119 .",
    ", @xmath120 , and @xmath121 used in practice can be represented as @xmath122 , @xmath123 , and @xmath124 , respectively . ] for example , @xmath125 { \\bowtie_\\circ}[\\ _ , \\beta , \\_]^ * \\left(\\left([\\ _ , \\alpha , j ] { \\bowtie_\\circ}\\{(j,\\alpha , i)\\}\\right ) \\ ; \\cup \\ ; [ \\ _ , \\alpha , k]\\right)\\ ] ] recognizes all paths emanating from @xmath1 , terminating at @xmath1 or @xmath126 , with the first and last label traversed being @xmath110 , and all intermediate edge labels ( zero or more ) being @xmath127 .",
    "the corresponding finite state automaton is diagrammed in figure [ fig : fsm ] , where the transition function is based on set membership , not equality .     a finite state automaton to recognize and generate a set of paths in @xmath119 .",
    "the left most state is the start state and the double - circle states denote accepting states.,scaledwidth=47.5% ]    regular paths in graphs are explored in depth in @xcite , where only paths with particular path labels are considered for recognition . in other words , in @xcite ,",
    "a regular expression is defined for the alphabet @xmath17 , where above , its defined for @xmath15 .      by making use of a non - deterministic single - stack automaton with a stack alphabet of @xmath119 , it is possible to generate all paths in @xmath7 that can be recognized by some regular expression .",
    "the non - deterministic aspect of the automaton ensures that all branches in the state machine are taken  in parallel . \"",
    "the single - stack aspect refers to the fact that the automaton ( and thus , its cloned / branched automata ) maintain a first - in / last - out stack memory that can be pushed and popped .",
    "initially , the automaton s stack contains the element @xmath128 .",
    "the automaton will halt whenever its stack element is @xmath112 or is in an accepting state .",
    "for each state transition ( which happens unless the automaton has been halted ) , the path set defined on the transition label is joined on the right with the path set popped off the stack .",
    "the result of the join is then pushed back onto the stack .",
    "whenever a branch in the automaton s state graph is approached , all branches are taken  in parallel . \"",
    "thus , given the automaton diagrammed in figure [ fig : fsm ] , the following joins are evaluated . @xmath129",
    "{ \\bowtie_\\circ}[\\ _ , \\alpha , j ] { \\bowtie_\\circ}\\{(j,\\alpha , i)\\ } \\\\ &",
    "\\{\\epsilon\\ } { \\bowtie_\\circ}[i,\\alpha,\\ _ ] { \\bowtie_\\circ}[\\ _ , \\alpha , k ] \\\\ & \\{\\epsilon\\ } { \\bowtie_\\circ}[i,\\alpha,\\ _ ] { \\bowtie_\\circ}[\\_,\\beta,\\ _ ]   \\ldots { \\bowtie_\\circ}[\\ _ , \\alpha , j ]   { \\bowtie_\\circ}\\{(j,\\alpha , i)\\ } \\\\ & \\{\\epsilon\\ } { \\bowtie_\\circ}[i,\\alpha,\\ _ ] { \\bowtie_\\circ}[\\_,\\beta,\\ _ ]   \\ldots { \\bowtie_\\circ}[\\ _ , \\alpha , k ] \\\\\\end{aligned}\\ ] ] the union of the first ( and only ) element of all the stacks across all branches of accept - state automaton forms the set of all paths in @xmath7 that satisfy the regular expression .",
    "most of the graph algorithms in existence today have been developed for single - relational graphs .",
    "examples of such algorithms include the geodesics ( e.g.  closeness centrality , betweenness centrality ) , spectral ( e.g.  eigenvector centrality , spreading activation ) , and assortative ( e.g.  scalar and discrete ) algorithms ( see @xcite for a consolidate review and analysis of many such algorithms ) .",
    "when applied to multi - relational graphs , these algorithms have the potential drawback of losing their meaning and thus , their applicability .",
    "to explicate this statement , it is important to consider the way in which a single - relational graph algorithm can be formally applied to multi - relational graphs .",
    "one method that can be employed is to simply ignore edge labels and , potentially , repeated edges between the same two vertices . however , when there are numerous ways in which one vertex can be related to another vertex , what is the resulting semantics of , say , a centrality algorithm ?",
    "another method is to extract a single edge relation , based on its label , from the multi - relational graph .",
    "for example , its possible to construct the binary edge set @xmath130 and utilize that subgraph as the source of a single - relational graph algorithm .",
    "however , with multiple ways in which vertices can be related , more abstract relationships can be inferred through paths .",
    "thus , in the final method , single - relational graphs can be generated from the multi - relational graph through the derivation of implicit edges defined through paths . using a simple example ,",
    "if @xmath41 are two edge labels , then all @xmath131-paths can be constructed when @xmath132 , @xmath133 and @xmath101 .",
    "the tail and head vertices of these paths can then be projected to form a new binary edge set @xmath134 thus , @xmath135 can be subjected to all known single - relational graph algorithms . for regular paths ,",
    "a regular path generator can be used as in  [ sec : generator ] .",
    "mapping single - relational graph algorithms over to the multi - relational domain is explored in depth in @xcite .",
    "this article defined a path algebra for multi - relational graphs represented as @xmath136 .",
    "the core traversal types ( complete , source , destination , and labeled ) allow for the expression of more expressive traversals through the restriction of the join set @xmath15 . applications to regular path recognizers (  [ sec : recognizer ] ) , generators (  [ sec : generator ] ) , and  semantically - rich \" single - relational graph construction (  [ sec : rich ] ) were presented . generally , the algebra has applicability to the construction of a multi - relational graph traversal engine .",
    "m.  russling , `` a general scheme for breadth - first graph traversal , '' in _ mathematics of program construction _ ,",
    "lecture notes in computer science , m.  russling , ed . , vol .",
    "380398.1em plus 0.5em minus 0.4emspringer - verlag , 1995 , pp .",
    "380398 .",
    "m.  a. rodriguez and j.  shinavier , `` exposing multi - relational networks to single - relational network analysis algorithms , '' _ journal of informetrics _",
    ", vol .  4 , no .  1 ,",
    "pp . 2941 , 2009 .",
    "[ online ] .",
    "available : http://arxiv.org/abs/0806.2274    p.",
    "pucheral and j .-",
    "thvenin , `` a graph based data structure for efficient implementation of main memory dbms , '' in _ proceedings of the sixth international workshop on database machines_.1em plus 0.5em minus 0.4emlondon , uk : springer - verlag , 1989 , pp .",
    "7396 .",
    "a.  o. mendelzon and p.  t. wood , `` finding regular simple paths in graph databases , '' in _ proceedings of the 15th international conference on very large data bases_.1em plus 0.5em minus 0.4emsan francisco , ca , usa : morgan kaufmann publishers inc .",
    ", 1989 , pp ."
  ],
  "abstract_text": [
    "<S> a multi - relational graph maintains two or more relations over a vertex set . </S>",
    "<S> this article defines an algebra for traversing such graphs that is based on an @xmath0-ary relational algebra , a concatenative single - relational path algebra , and a tensor - based multi - relational algebra . </S>",
    "<S> the presented algebra provides a monoid , automata , and formal language theoretic foundation for the construction of a multi - relational graph traversal engine .    </S>",
    "<S> = 1 </S>"
  ]
}