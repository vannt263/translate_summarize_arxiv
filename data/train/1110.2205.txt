{
  "article_text": [
    "logic programming under the answer set semantics has been introduced as an attractive and suitable knowledge representation language for ai research @xcite , as it offers several desirable properties for this type of applications . among other things ,",
    "the language is declarative and it has a simple syntax ; it naturally supports non - monotonic reasoning , and it is sufficiently expressive for representing several classes of problems ( e.g. , normal logic programs capture the class of np - complete problems ) ; it has solid theoretical foundations with a large body of building block results ( e.g. , equivalence between programs , systematic program development , relationships to other non - monotonic formalisms ) , which is extremely useful in the development and validation of large knowledge bases ; it also has a large number of efficient computational tools . for further discussion of these issues ,",
    "the interested reader is referred to the book of baral @xcite , the overview paper of gelfond and leone @xcite , the paper of marek and truszczyski @xcite , and the paper of niemel @xcite .",
    "a large number of extensions of logic programming , aimed at improving its usability in the context of knowledge representation and reasoning , have been proposed .",
    "the smodels system introduces _",
    "weight _ and _ cardinality _ constraint atoms to facilitate the encoding of constraints on atom definitions @xcite .",
    "these constructs can be generalized to _ aggregates _ ; aggregates have been extensively studied in the general context of logic programming by the work of ( see , e.g. , ) , and further developed in recent years ( see , e.g. , ) .",
    "both * dlv * @xcite and smodels have been extended to deal with various classes of aggregates @xcite .",
    "the semantics of these extensions have been defined either _ indirectly _ , by translating programs with these extensions to normal logic programs , or _ directly _ , by providing new characterizations of the concept of answer sets for programs with such extensions .",
    "each of the above mentioned extensions to logic programming has been introduced to facilitate the representation of a desirable type of knowledge in logic programming .",
    "as such , it is not a surprise that the focus has been on the definition of the semantics and little has been done to investigate the basic building block results for the new classes of logic programs . in this context , the study of a uniform framework covering various classes of extensions will provide us with several benefits .",
    "for example , to prove ( or disprove ) whether a basic building block result ( e.g. , splitting theorem ) can be extended to the new classes of logic programs , we will need to prove ( or disprove ) this result only once ; new results in the study of the generic framework are applicable to the study of one of the aforementioned extensions ; etc .",
    "naturally , for these studies to be possible , a uniform framework whose semantical definition exhibits the behavior of various extensions of logic programming , needs to be developed .",
    "the main goal in this paper is to address this issue .",
    "the concept of logic programs with _ abstract constraint atoms _ ( or _ c - atoms _ ) has been introduced by marek , remmel , and truszczyski as an elegant theoretical framework for investigating , in a uniform fashion , various extensions of logic programming , including cardinality constraint atoms , weight constraint atoms , and more general forms of aggregates @xcite . intuitively , a c - atom @xmath0 represents a _ constraint _ on models of the program containing @xmath0and the description of @xmath0 includes an explicit description of what conditions each interpretation has to meet in order to satisfy @xmath0 .",
    "this view is very general , and it can be shown to subsume the description of traditional classes of aggregates ( e.g. , sum , count , min , etc . ) .",
    "thus , programs with weight constraint atoms or other aggregates can be represented as logic programs with c - atoms .    the first explicit definition of answer sets for positive programs with arbitrary c - atoms ( i.e. , programs without the negation - as - failure operator)called _ programs with set constraints _ or _ sc - programs_has been introduced in the work of marek and remmel @xcite . in this work answer",
    "sets for programs with c - atoms are defined by extending the notion of answer sets for programs with weight constraint atoms proposed in the work of niemel , simons , and soininen @xcite .",
    "nevertheless , this approach provides , in certain cases , unintuitive answer sets ( see , e.g. , examples  [ ex0 ] and [ ex19 ] ) .",
    "in particular , the approach of marek and remmel does not naturally capture some of the well - agreed semantics for aggregates .",
    "one of our main goals in this paper is to investigate alternative solutions to the problem of characterizing answer sets for programs with arbitrary c - atoms .",
    "our aim is to match the semantics provided in the more recent literature for monotone c - atoms , and to avoid the pitfalls of the approach developed in the work of marek and remmel @xcite .",
    "the concept of answer sets for programs with c - atoms has been later revisited by marek and truszczyski @xcite , focusing on answer sets for programs with _",
    "constraint atoms , where a c - atom @xmath0 is monotone if , for each pair of interpretations @xmath1 and @xmath2 with @xmath3 , we have that @xmath1 satisfies @xmath0 implies that @xmath2 satisfies @xmath0 .",
    "this proposal has been further extended to the case of disjunctive logic programs with monotone c - atoms @xcite . in another paper @xcite",
    ", it is extended to deal with convex c - atoms where a c - atom @xmath0 is convex if , for every pair of interpretations @xmath1 and @xmath4 with @xmath5 , we have that @xmath1 and @xmath4 satisfy @xmath0 implies that @xmath2 satisfies @xmath0 for every @xmath6 .",
    "this paper also proves several properties of programs with monotone and convex c - atoms .",
    "it is shown that many well - known properties of standard logic programming under answer set semantics are preserved in the case of programs with monotone c - atoms .    the main advantage of focusing on _ monotone _ c - atoms lies in that monotonicity provides a relatively simpler way for defining answer sets of logic programs with c - atoms . on the other hand",
    ", this restriction does not allow several important classes of problems to be _ directly _ expressed .",
    "for example , the aggregate atom @xmath7 can not be viewed as a monotone aggregate atom  since monotonic extensions of the definition of @xmath8 might make the aggregate false ; e.g. , the aggregate is true if @xmath9 is the definition of @xmath8 , but it becomes false if we consider a definition containing @xmath10 .",
    "similarly , the cardinality constraint atom @xmath11 is not a monotone constraint .",
    "neither of these two examples can be directly encoded using monotone c - atoms .    the studies in and in lead to the following question : `` _ what are the alternatives to the approach to defining answer sets of programs with arbitrary c - atoms developed by ? _ '' furthermore , will these alternatives  if any capture the semantics of programs with monotone c - atoms proposed by and avoid the pitfalls of the notion of answer sets for arbitrary c - atoms in ?",
    "we present two _ equivalent _ approaches for defining answer sets for logic programs with arbitrary c - atoms .    *",
    "the first approach is inspired by the notion of _ conditional satisfaction_originally developed in to characterize the semantics of logic programs with aggregates .",
    "we generalize this notion to the case of programs with c - atoms .",
    "the generalization turns out to be significantly more intuitive and easier to understand than the original definition in . using this notion",
    ", we define an immediate consequence operator @xmath12 for answer set checking .",
    "* the second approach is inspired by the notion of _ well - supportedness _",
    ", proposed by fages  @xcite for normal logic programs .",
    "the approaches are very intuitive , and , we believe , they improve over the only other semantics proposed for logic programs with arbitrary c - atoms in .    we show that the newly defined semantics coincide with the previously introduced semantics in in the case of programs with monotone c - atoms , and they extend the original stable model semantics for normal logic programs .",
    "we discuss different approaches for treating negation - as - failure c - atoms .",
    "we also relate our definitions to several semantics for logic programs with aggregates , since the notion of c - atom can be used to encode arbitrary aggregates .",
    "these results show that the proposed framework naturally subsumes many existing treatments of aggregates in logic programming .    in summary ,",
    "the main contributions of the paper are :    @xmath13    a new notion of fixpoint answer set for programs with arbitrary c - atoms , which is inspired by the fixpoint construction proposed in ( but simpler ) and which differs significantly from the only proposal for programs with arbitrary c - atoms in ; this will lead to two different definitions of answer sets ( answer set by reduct and answer set by complement ) ;    a generalization of the notion of well - supported models in to programs with arbitrary c - atoms , which  to the best of our knowledge  has not been investigated by any other researchers , which leads to the notions of weakly and strongly well - supported models ;    a result showing that the set of answer sets by reduct ( resp . by complement ) is equivalent to the set of weakly ( resp .",
    "strongly ) well - supported models ; and    a number of results showing that the newly defined notions of answer sets capture the answer set semantics of various extensions to logic programming , in those cases all the previously proposed semantics agree .",
    "the rest of this paper is organized as follows .",
    "section  [ prel ] presents preliminary definitions , including the syntax of the language of logic programming with c - atoms , the basic notion of satisfaction , and the notion of answer set for programs with monotone c - atoms in and for positive programs with arbitrary c - atoms in .",
    "section  [ firstapp ] presents our first approach to defining answer sets for logic programs with arbitrary c - atoms based on a fixpoint operator , while section  [ secondapp ] introduces an alternative definition based on well - supportedness .",
    "section  [ general ] extends the semantics to programs with arbitrary c - atoms in the head of rules .",
    "section  [ discuss ] relates the semantics presented in this paper with early work on abstract constraint atoms and aggregates .",
    "section  [ conc ] provides conclusions and future work .",
    "proofs of theorems and propositions are deferred to the appendix .",
    "we follow the syntax used in to define programs with abstract constraint atoms . throughout the paper , we assume a fixed propositional language @xmath14 with a countable set @xmath15 of propositional atoms .      an _ abstract constraint atom _ ( or _ c - atom _ )",
    "is an expression of the form @xmath16 , where @xmath17 is a set of atoms ( the _ domain _ of the c - atom ) , and @xmath18 is a collection of sets of atoms belonging to @xmath19 , i.e. , @xmath20 ( the _ solutions _ of the c - atom ) .",
    "intuitively , a c - atom @xmath16 is a constraint on the set of atoms @xmath19 , and @xmath18 represents its admissible solutions . given a c - atom @xmath21 ,",
    "we use @xmath22 and @xmath23 to denote @xmath19 and @xmath18 , respectively .    a c - atom of the form @xmath24 is called an _ elementary _",
    "c - atom and will be simply written as @xmath8 .",
    "a c - atom of the form @xmath25 , representing a constraint which does not admit any solutions , will be denoted by @xmath26 .",
    "a c - atom @xmath0 is said to be _ monotone _ if for every @xmath27 , @xmath28 implies that @xmath29 .",
    "a _ rule _ is of the form @xmath30 where @xmath0 , @xmath31 s are c - atoms .",
    "the literals @xmath32 ( @xmath33 ) are called _ negation - as - failure c - atoms _ ( or _ naf - atoms _ ) . for a rule @xmath34 of the form ( [ rule ] ) ,",
    "we define :    * @xmath35 , * @xmath36 , * @xmath37 , * @xmath38 .    for a program @xmath39 , @xmath40 denotes the set @xmath41 .",
    "we recognize special types of rules :    1 .",
    "a rule @xmath34 is _ positive _ if @xmath42 ; 2 .",
    "a rule @xmath34 is _ basic _ if @xmath43 is an elementary c - atom ; 3 .",
    "a rule @xmath34 is a _ constraint _",
    "rule if @xmath44 .",
    "a _ logic program with c - atoms _ ( or _ logic program _ , for simplicity ) is a set of rules . a program @xmath39 is called a _",
    "basic _ program if each rule @xmath45 is a basic or a constraint rule .",
    "@xmath39 is said to be _ positive _ if every rule in @xmath39 is positive .",
    "@xmath39 is _ monotone _ ( resp . _",
    "naf - monotone _ ) if each c - atom occurring in @xmath39 ( resp . in a naf - atom in @xmath39 ) is monotone .",
    "clearly , a monotone program is also naf - monotone .      in this subsection",
    ", we introduce the basic definitions for the study of logic programs with constraints .",
    "we will begin with the definition of the satisfaction of c - atoms .",
    "we then introduce the notion of a model of programs with c - atoms .",
    "a set of atoms @xmath46 satisfies a c - atom @xmath0 , denoted by @xmath47 , if @xmath48 .",
    "@xmath49 satisfies @xmath50 , denoted by @xmath51 , if @xmath52 .",
    "it has been shown in and in that the notion of c - atom is more general than extended atoms such as cardinality constraint atoms and aggregate atoms ; thus , c - atoms can be used to conveniently represent weight constraints , cardinality constraints @xcite , and various other classes of aggregates , such as maximal cardinality constraints .",
    "for example ,    * let us consider an arbitrary choice atom of the form @xmath53 ; this can be represented by the c - atom @xmath54 where : * * @xmath55 * * @xmath56 * let us consider an arbitrary aggregate of the form @xmath57 where @xmath58 is a set function ( e.g. , sum , avg ) , @xmath59 is a number , and @xmath60 is a comparison operation ( e.g. , @xmath61 ) .",
    "this can be represented by the c - atom @xmath54 , where : * * @xmath62 * * @xmath63    let us consider the aggregate @xmath64 , defined in a language where @xmath65 . from the considerations above , we have that this aggregate can be represented by the c - atom @xmath66 where @xmath67 @xmath68    let us consider the cardinality constraint atom @xmath69 .",
    "this can be represented by the c - atom @xmath70 where @xmath71 @xmath68    c - atoms allow us to compactly represent properties that would require complex propositional combinations of traditional aggregates .",
    "e.g. , a condition like _ `` either all elements or no elements of the set @xmath72 are true '' _ can be simply written as the single c - atom @xmath73 .",
    "further motivations behind the use of c - atoms can be found in and .    in the rest of the paper",
    ", we will often use in our examples the notation of cardinality constraint atoms , weight constraint atoms , or general aggregate atoms instead of c - atoms , whenever no confusion is possible .",
    "a set of atoms @xmath49 satisfies the body of a rule @xmath34 of the form ( [ rule ] ) , denoted by @xmath74 , if @xmath75 for @xmath76 and @xmath77 for @xmath78 .",
    "@xmath49 satisfies a rule @xmath34 if it satisfies @xmath43 or if it does not satisfy @xmath79 .",
    "a set of atoms @xmath49 is a _ model _ of a program @xmath39 if @xmath49 satisfies every rule of @xmath39 .",
    "@xmath80 is a _",
    "minimal _ model of @xmath39 if it is a model of @xmath39 and there is no proper subset of @xmath80 which is also a model of @xmath39 . in particular , programs may have more than one minimal model ( see , for example , example  [ ex4 ] ) .",
    "given a program @xmath39 , a set of atoms @xmath49 is said to support an atom @xmath81 if there exists some rule @xmath34 in @xmath39 and @xmath82 such that the following conditions are met :    * @xmath74 , * @xmath83 , and * @xmath84 .",
    "[ ex2 ] let @xmath85 is a short form for the c - atom @xmath24 .",
    "] be the program @xmath86 the aggregate notation @xmath87 represents the c - atom @xmath88 where @xmath89 .",
    "@xmath85 has two models : @xmath90 @xmath91 is a minimal model of @xmath85 , while @xmath92 is not .",
    "@xmath68    [ ex3 ] let @xmath93 be the program @xmath94 the aggregate notation @xmath95 represents the c - atom @xmath16 where @xmath96 because of the first rule , any model of @xmath93 will need to contain @xmath97 .",
    "it is easy to see that @xmath98 and @xmath99 are models of @xmath93 but @xmath100 is not a model of @xmath93 .",
    "@xmath68    [ ex4 ] let @xmath101 be the program @xmath102 @xmath101 has three models @xmath103 , @xmath104 , and @xmath105 , of which @xmath103 and @xmath104 are minimal .",
    "@xmath68      in this section , we will overview the semantical characterizations for programs with c - atoms proposed in the existing literature .",
    "in particular , we will review the notion of answer sets for monotone programs ( i.e. , program that contain only monotone c - atoms ) , as defined in .",
    "a formal comparison between these semantics and the novel approach we propose in this paper is described in section  [ discuss ] .",
    "given a set of atoms @xmath49 , a rule @xmath34 is _ applicable _ in @xmath49 if @xmath74 .",
    "the set of applicable rules in @xmath49 is denoted by @xmath106 .",
    "a set @xmath107 is _ nondeterministically one - step provable _ from @xmath49 by means of @xmath39 if @xmath108 and @xmath109 for every @xmath110 .",
    "nondeterministic one - step provability operator _",
    "@xmath111 is a function from @xmath112 to @xmath113 such that for every @xmath46 , @xmath114 consists of all sets @xmath107 that are nondeterministically one - step provable from @xmath49 by means of @xmath39 .",
    "@xmath39-computation _ is a sequence @xmath115 where @xmath116 and for every non - negative integer @xmath117 ,    * ( _ i _ ) @xmath118 , and * ( _ ii _ ) @xmath119    @xmath120 is called the _",
    "result _ of the computation @xmath121 .",
    "a set of atoms @xmath49 is a _",
    "derivable model _ of @xmath39 if there exists a @xmath39-_computation _ @xmath121 such that @xmath122 .",
    "the gelfond - lifschitz reduct for normal logic programs is generalized to monotone programs as follows .",
    "let @xmath39 be a monotone program .",
    "for a set of atoms @xmath80 , the _ reduct _ of @xmath39 with respect to @xmath80 , denoted by @xmath123 , is obtained from @xmath39 by    1 .   removing from @xmath39 every rule containing in the body a literal @xmath50 such that @xmath124 ; and 2 .   removing all literals of the form @xmath50 from the remaining rules .",
    "answer sets for monotone programs are defined next .",
    "[ as - marek ] a set of atoms @xmath125 is an _ answer set _ of a monotone program @xmath39 if @xmath80 is a derivable model of the reduct @xmath123 .",
    "the next example shows that , for programs with non - monotone c - atoms , definition [ as - marek ] is , in general , not applicable .",
    "[ ex41 ]    consider the program @xmath101 from example [ ex4 ] .",
    "we can check that this program does not allow the construction of any @xmath101-computation .",
    "in fact , @xmath126 and @xmath127 . hence , @xmath103 would not be an answer set of @xmath101 ( according to definition [ as - marek ] ) since it is not a derivable model of the reduct of @xmath101 with respect to @xmath103 ( which is @xmath101 ) .    on the other hand",
    ", it is easy to see that @xmath101 is intuitively equivalent to the normal logic program @xmath128 . as such",
    ", @xmath101 should accept @xmath103 as one of its answer sets .",
    "@xmath68    the main reason for the inapplicability of definition [ as - marek ] lies in that the nondeterministic one - step provability operator @xmath111 might become non - monotone in the presence of non - monotone c - atoms .",
    "positive programs are characterized by the lack of negation - as - failure atoms .",
    "positive programs with arbitrary c - atoms have been investigated in , under the name of _ sc - programs_. let us briefly review the notion of answer sets for sc - programs  which , in turn , is a generalization of the notion of answer sets for logic programs with weight constraints , as presented in .",
    "a detailed comparison between the approach in and our work is given in section [ discuss ] .",
    "for a c - atom @xmath0 , the closure of @xmath0 , denoted by @xmath129 , is the c - atom @xmath130 intuitively , the closure is constructed by including all the supersets of the existing solutions .",
    "a c - atom @xmath0 is said to be _ closed _",
    "if @xmath131 . a rule of the form ( [ rule ] ) is a horn - rule if ( _ i _ ) its head is an elementary c - atom ; and ( _ ii _ ) each c - atom in the body is a closed c - atom . a sc - program @xmath39 is said to be a horn sc - program if each rule in @xmath39 is a horn - rule .",
    "the one - step provability operator , defined by @xmath132 , associated to a horn sc - program @xmath39 is monotone .",
    "hence , every horn sc - program @xmath39 has a least fixpoint @xmath133 which is the only minimal model of @xmath39 ( w.r.t . set inclusion ) .",
    "given a set of atoms @xmath80 and a sc - program @xmath39 , the _ nss - reduct _ of @xmath39 with respect to @xmath80 , denoted by @xmath134 , is obtained from @xmath39 by    removing all rules whose body is not satisfied by @xmath80 ; and    replacing each rule @xmath135 where @xmath136 s are elementary c - atoms and @xmath31 s are non - elementary c - atoms by the set of rules @xmath137    a model @xmath49 of a program @xmath39 is an answer set of @xmath39 if it is the least fixpoint of the one - step provability operator of the program @xmath138 , i.e. , @xmath139 .",
    "it sometimes yields answer sets that are not accepted by other extensions to logic programming .",
    "the next example illustrates this point .",
    "[ ex0 ] consider the program @xmath140 : @xmath141 we have that @xmath142 and @xmath143 are models of @xmath140 .",
    "furthermore , @xmath144 is the program @xmath145 and @xmath146 consists of the rules @xmath147 it is easy to see that @xmath148 and @xmath149 .",
    "thus , observe that @xmath140 has a non - minimal answer set @xmath150 according to .",
    "note that the program @xmath140 can be viewed as the following program with aggregates @xmath151 which does not have @xmath150 as an answer set under most of the proposed semantics for aggregates @xcite .",
    "furthermore , all these approaches accept @xmath152 as the only answer set of this program . @xmath68",
    "in this section , we define the notion of answer sets of _ basic _ programs . in this approach ,",
    "we follow the traditional way for defining answer sets of logic programs , i.e. , by :    1 .   first characterizing the semantics of positive programs ( definition [ basic - pos - a.s . ] ) , and then 2 .   extending it to deal with naf - atoms ( definitions [ def - basic ] and [ reduct - a.s . ] ) .",
    "example  [ ex4 ] shows that a basic positive program might have more than one minimal model .",
    "this leads us to define a @xmath12-like operator for answer set checking , whose construction is based on the following observation .    _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ [ observ1 ] let @xmath39 be a propositional normal logic program ( i.e. , without c - atoms)[multiblock footnote omitted ] and let @xmath153 be two sets of atoms . given a set of atoms @xmath80 , we define the operator @xmath154 and the monotone sequence of interpretations @xmath155 as follows",
    ". @xmath156 @xmath157 let us denote with @xmath158 the limit of this sequence of interpretations .",
    "it is possible to prove that @xmath80 is an answer set of @xmath39 w.r.t .",
    "iff @xmath159 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    as we can see from the above observation , the ( modified ) consequence operator @xmath12 takes two sets of atoms , @xmath160 and @xmath49 , as its arguments , and generates one set of atoms which could be viewed as the consequences of @xmath39 given that @xmath160 is true and @xmath49 is assumed to be an answer set of @xmath39 .",
    "it is easy to see that @xmath12 is monotone w.r.t .",
    "its first argument , i.e. , if @xmath161 , then @xmath162 .",
    "thus , the sequence @xmath163 is monotone and converges to @xmath158 for a given @xmath49 .",
    "we will next show how @xmath12 can be generalized to programs with c - atoms .",
    "observe that the definition of @xmath12 requires that @xmath164 or , equivalently , @xmath165 . for normal logic programs ,",
    "this is sufficient to guarantee the monotonicity of @xmath166 .",
    "if this definition is naively generalized to the case of programs with c - atoms , the monotonicity of @xmath167 is guaranteed only under certain circumstances , e.g. , when c - atoms in @xmath168 are monotone . to deal with arbitrary c - atoms ,",
    "we need to introduce the notion of _ conditional satisfaction _ of a c - atom .",
    "[ conditional satisfaction ] [ cond - sat ] let @xmath80 and @xmath49 be sets of atoms .",
    "the set @xmath49 _ conditionally satisfies _ a c - atom @xmath0 w.r.t .",
    "@xmath80 , denoted by @xmath169 , if    1 .",
    "@xmath170 and , 2 .   for every @xmath171 such that @xmath172 and @xmath173 , we have that @xmath174 .",
    "observe that this notion of conditional satisfaction has been inspired by the conditional satisfaction used to characterize aggregates in  , but it is significantly simpler .",
    "we say that @xmath49 conditionally satisfies a set of c - atoms @xmath59 w.r.t .",
    "@xmath80 , denoted by @xmath175 , if @xmath169 for every @xmath176 .",
    "intuitively , @xmath175 implies that @xmath177 for every @xmath107 such that @xmath178 .",
    "thus , conditional satisfaction ensures that if the body of a rule is satisfied in @xmath49 then it is also satisfied in @xmath107 , provided that @xmath178 .",
    "this allows us to generalize the operator @xmath12 defined in observation 1 as follows . for a set of atoms @xmath49 and a positive basic program @xmath39 , let @xmath179",
    "the following proposition holds .",
    "[ prop - tp ] let @xmath80 be a model of @xmath39 , and let @xmath180 .",
    "then @xmath181    let @xmath182 and , for @xmath183 , let @xmath184 then , the following corollary is a natural consequence of proposition  [ prop - tp ] .",
    "[ cr - tp ] let @xmath39 be a positive , basic program and @xmath80 be a model of @xmath39 .",
    "then , we have @xmath185    the above corollary implies that the sequence @xmath186 is monotone and limited ( w.r.t . set inclusion ) by @xmath80 .",
    "therefore , it converges to a fixpoint .",
    "we denote this fixpoint by @xmath187 .",
    "[ basic - pos - a.s .",
    "] let @xmath80 be a model of a basic positive program @xmath39 .",
    "@xmath80 is an _ answer set _ of @xmath39 iff @xmath188 .",
    "observe that the constraint rules present in @xmath39 ( i.e. , rules whose head is @xmath26 ) do not contribute to the construction performed by @xmath12 ; nevertheless , the requirement that @xmath80 should be a model of @xmath39 implies that all the constraint rules will have to be satisfied by each answer set .",
    "we illustrate definition [ basic - pos - a.s . ] in the next examples .",
    "consider the program @xmath85 from example [ ex2 ] .",
    "* @xmath189 is an answer set of @xmath85 since : @xmath190 , @xmath191 , and @xmath192 . @xmath193",
    "* @xmath194 is not an answer set of @xmath85 , since : @xmath195 , @xmath196 @xmath197 .",
    "@xmath198 @xmath68    consider again the program @xmath101 ( example [ ex4 ] ) .",
    "let @xmath199 and @xmath200 .",
    "we have that @xmath201 thus , both @xmath103 and @xmath104 are answer sets of @xmath101 . on the other hand , for @xmath202 , we have that @xmath203 because @xmath204 and @xmath205 .",
    "hence , @xmath105 is not an answer set of @xmath101 .",
    "@xmath68    we conclude this section by observing that the answer sets obtained from the above construction are minimal models .    [ cr - minm ] let @xmath39 be a positive basic program and @xmath80 be an answer set of @xmath39 .",
    "then , @xmath80 is a minimal model of @xmath39 .",
    "the next example shows that not every positive program has an answer set .",
    "consider @xmath93 ( example [ ex3 ] ) .",
    "since answer sets of positive programs are _ minimal _ models ( corollary  [ cr - minm ] ) and @xmath206 is the only minimal model of @xmath93 , we have that @xmath80 is the only possible answer set of @xmath93 .",
    "since @xmath207 we can conclude that @xmath80 is not an answer set of @xmath93 .",
    "thus , @xmath93 does not have answer sets . @xmath68",
    "the example highlights that supportedness , in our approach , is not a sufficient condition for being an answer set@xmath208 is a supported model , but it is not accepted as an answer set .",
    "the reason for rejecting @xmath209 is the fact that the element @xmath210 is essentially self - supporting itself ( cyclically ) in @xmath209 .",
    "note that @xmath209 is rejected , as an answer set , in most approaches to aggregates in logic programming  e.g .",
    ", the approach in   rejects @xmath209 for not being a minimal model of the flp - reduct of the program .",
    "we will now define answer sets for basic programs , i.e. , programs with elementary c - atoms in the head of the rules , and rule bodies composed of c - atoms and naf - atoms .    in the literature ,",
    "two main approaches have been considered to deal with negation of aggregates and of other complex atoms .",
    "various extensions of logic programming ( e.g. , weight constraints in and aggregates in ) support negation - as - failure atoms by replacing each naf - atom @xmath50 with a c - atom @xmath211 , where @xmath211 is obtained from @xmath0 by replacing the predicate relation of @xmath0 with its `` negation '' .",
    "for example , following this approach , the negated cardinality constraint atom @xmath212 can be replaced by @xmath213 .",
    "similarly , the negated aggregate atom @xmath214 can be replaced by @xmath215 .    on the other hand ,",
    "other researchers ( see , e.g. , ) have suggested to handle naf - atoms by using a form of _ program reduct_in the same spirit as in .    following these perspectives , we study two different approaches for dealing with naf - atoms , described in the next two subsections .",
    "it is worth mentioning that both approaches coincide in the case of monotone programs ( proposition  [ prop - equiv ] ) .      in this approach ,",
    "we treat a naf - atom @xmath50 by replacing it with its _",
    "complement_. we define the notion of _ complement _ of a c - atom as follows .    [ compldef ] the complement @xmath216 of a c - atom @xmath0 is the c - atom @xmath217 .",
    "we next define the _ complement _ of a program @xmath39 .    given a basic program @xmath39",
    ", we define @xmath218 ( the complement of @xmath39 ) to be the program obtained from @xmath39 by replacing each occurrence of @xmath50 in @xmath39 with the complement of @xmath0 .",
    "the program @xmath218 is a basic positive program , whose answer sets have been defined in definition [ basic - pos - a.s . ]",
    "this allows us to define the notion of answer sets of basic programs as follows .",
    "[ def - basic ] a set of atoms @xmath80 is an _ answer set by complement _ of a basic program @xmath39 iff it is an answer set of @xmath218 .",
    "it is easy to see that each answer set of a program @xmath39 is indeed a minimal model of @xmath39 .",
    "[ pippo1 ] let us consider the program @xmath219 , which consists of the following rules : @xmath220 the complement of @xmath219 is @xmath221 which has @xmath150 as its only answer set .",
    "thus , @xmath150 is an answer set by complement of @xmath219 .",
    "@xmath68    [ complement ] let @xmath222 be the program @xmath223 we have that @xmath224 is the program @xmath225 this program does not have an answer set ( w.r.t",
    ". definition [ basic - pos - a.s . ] ) ; thus @xmath222 does not have an answer set by complement .",
    "@xmath68      another approach for dealing with naf - atoms is to adapt the gelfond - lifschitz reduction of normal logic programs @xcite to programs with c - atoms  this approach has been considered in and .",
    "we can generalize this approach to programs with arbitrary c - atoms as follows .",
    "for a basic program @xmath39 and a set of atoms @xmath80 , the _ reduct of p w.r.t .",
    "m _ ( @xmath123 ) is the set of rules obtained by    1 .   removing all rules containing @xmath50 s.t .",
    "@xmath124 ; and 2 .   removing all @xmath50 from the remaining rules .",
    "the program @xmath123 is a positive basic program .",
    "thus , we can define answer sets for @xmath39 as follows :    [ reduct - a.s . ]",
    "a set of atoms @xmath80 is an _ answer set by reduct _ of @xmath39 iff @xmath80 is an answer set of @xmath123 ( w.r.t .",
    "definition [ basic - pos - a.s . ] ) .",
    "[ ex41b ] let us reconsider the program @xmath219 from example  [ pippo1 ] and let us consider @xmath226 .",
    "if we perform a reduct , we are left with the rules @xmath227 whose minimal model is @xmath80 itself .",
    "thus , @xmath80 is an answer set by reduct of the program @xmath219 . @xmath68",
    "the next example shows that this approach can lead to different answer sets than the case of negation by complement ( for non - monotone programs ) .",
    "[ ex5 ] consider the program @xmath222 from example [ complement ] .",
    "let @xmath228 .",
    "the reduct of @xmath222 w.r.t .",
    "@xmath80 is the program @xmath229 which has @xmath80 as its answer set , i.e. , @xmath80 is an answer set by reduct of @xmath222 .",
    "@xmath68    one consequence of the negation by reduct approach is the fact that it might lead to _ non - minimal _ answer sets  in the presence of non - monotone atoms .",
    "for instance , if we replace the atom @xmath230 in @xmath85 with @xmath231 , the new program is ( by replacing the aggregate with a c - atom ) : @xmath232 this program admits the following two interpretations as answer sets by reduct : @xmath233 and @xmath234 . since @xmath235",
    ", we have that a non - minimal answer set exists .",
    "this result indicates that , for certain programs with c - atoms , there might be different ways to treat naf - atoms , leading to different semantical characterizations .",
    "this problem has been mentioned in .",
    "investigating other methodologies for dealing with naf - atoms is an interesting topic of research , that we plan to pursue in the future .",
    "we will now show that the notion of answer sets for basic programs with c - atoms is a natural generalization of the notions of answer sets for normal logic programs .",
    "we prove that answer sets of basic positive programs are minimal and supported models and characterize situations in which these properties hold for basic programs .",
    "we begin with a result stating that , for the class of naf - monotone programs , the two approaches for dealing with naf - atoms coincide .",
    "[ prop - equiv ] let @xmath39 be a basic program .",
    "each answer set by complement of @xmath39 is an answer set by reduct of @xmath39 .",
    "furthermore , if @xmath39 is naf - monotone , then each answer set by reduct of @xmath39 is also an answer set by complement of @xmath39 .",
    "the above proposition implies that , in general , the negation - as - failure by complement approach is more ` skeptical ' than the negation - as - failure by reduct approach , in that it may accept fewer answer sets .",
    "furthermore , examples [ complement ] and [ ex5 ] show that a minimal ( w.r.t . set inclusion ) answer set by reduct is not necessarily an answer set by complement of a program .",
    "let @xmath39 be a normal logic program ( without c - atoms ) and let @xmath236 be the program obtained by replacing each occurrence of an atom @xmath237 in @xmath39 with @xmath238 . since @xmath238 is a monotone c - atom",
    ", @xmath236 is a monotone program .",
    "proposition  [ prop - equiv ] implies that , for @xmath236 , answer sets by reduct and answer sets by complement coincide . in the next proposition ,",
    "we prove that the notion of answer sets for programs with c - atoms preserves the notion of answer set for normal logic programs , in the following sense .    [ preserving answer sets ] [ prop - preserv ] for a normal logic program @xmath39",
    ", @xmath80 is an answer set ( by complement or by reduct ) of @xmath236 iff @xmath80 is an answer set of @xmath39 ( w.r.t . the definition in ) .",
    "the above proposition , together with proposition [ prop - equiv ] , implies that normal logic programs can be represented by positive basic programs .",
    "this is stated in the following corollary .",
    "every answer set of a normal logic program @xmath39 is an answer set of @xmath239 and vice versa .    in the next proposition ,",
    "we study the minimality and supportedness properties of answer sets of basic programs .",
    "[ minimality of answer sets ] [ prop - min1 ] the following properties hold :    1 .",
    "every answer set by complement of a basic program @xmath39 is a minimal model of @xmath39 .",
    "every answer set by reduct of a basic , naf - monotone program @xmath39 is a minimal model of @xmath39 .",
    "every answer set ( by complement / reduct ) of a basic program @xmath39 supports each of its members .",
    "[ minimality of answer sets ] [ prop - min1 ] let @xmath39 be a basic logic program and @xmath80 be a set of atoms .    1 .",
    "if @xmath80 is an answer set by complement of @xmath39 then @xmath80 is a minimal model of @xmath39 .",
    "if @xmath80 is an answer set by reduct of @xmath39 and @xmath39 is a naf - monotone program then @xmath80 is a minimal model of @xmath39 .",
    "3 .   if @xmath80 is an answer set",
    "( by complement / reduct ) of @xmath39 , then each @xmath240 is supported by @xmath80 .",
    "the definition of answer sets provided in the previous section can be viewed as a generalization of the answer set semantics for normal logic programs  in the sense that it relies on a fixpoint operator , defined for positive programs . in this section ,",
    "we discuss another approach for defining answer sets for programs with c - atoms , which is based on the notion of _ well - supported models_.    the notion of well - supported models for normal logic programs was introduced in , and it provides an interesting alternative characterization of answer sets . intuitively , a model @xmath80 of a program @xmath39 is a well - supported model iff there exists a level mapping , from atoms in @xmath80 to the set of positive integers , such that each atom @xmath240 is supported by a rule @xmath34 , whose body is satisfied by @xmath80 and the level of each positive atom in @xmath79 is strictly smaller than the level of @xmath237 . and",
    "@xmath241 , i.e. , naf - atoms are dealt with by reduct . ]",
    "fages proved that answer sets are well - supported models and vice versa @xcite .",
    "the notion of well - supportedness has been extended to deal with dynamic logic programs in .",
    "level mapping has also been used as an effective tool to analyze different semantics of logic programs in a uniform way @xcite .    in what follows",
    ", we will show that the notion of well - supported models can be effectively applied to programs with c - atoms .",
    "a key to the formulation of this notion is the answer to the following question : +    _ `` what is the level of a c - atom @xmath0 given a set of atoms @xmath80 and a level mapping @xmath242 of @xmath80 ? '' _    on one hand , one might argue that the level mapping of @xmath0 should be defined independently from the mapping of the other atoms , being @xmath0 an atom itself .",
    "on the other hand , it is reasonable to assume that the level of @xmath0 _ depends _ on the levels of the atoms in @xmath22 , since the satisfaction of @xmath0 ( w.r.t . a given interpretation ) depends on the satisfaction of the elements in @xmath22 .",
    "the fact that every existing semantics of programs with c - atoms evaluates the truth value of a c - atom @xmath0 based on the truth value assigned to elements of @xmath22 stipulates us to adopt the second view .",
    "it is worth to mention that this view also allows us to avoid undesirable circular justifications of elements of a well - supported model : if we follow the first view , the program @xmath243 consisting of the following rules @xmath244 would have @xmath245 as a well - supported model in which @xmath237 , @xmath246 , and @xmath247 are supported by @xmath247 , @xmath237 , and @xmath245 respectively .",
    "this means that @xmath237 is true because _ both _ @xmath237 and @xmath246 are true , i.e. , there is a circular justification for @xmath237 w.r.t . the model @xmath245 .",
    "let @xmath80 be a set of atoms , @xmath248 be a mapping from @xmath80 to positive integers , and let @xmath0 be a c - atom .",
    "we define @xmath249 , and @xmath250 intuitively , the `` level '' of each atom is given by the smallest of the levels of the solutions of the atom compatible with @xmath80where the level of a solution is given by the maximum level of atoms in the solution .",
    "we assume that @xmath251 , while @xmath252 is undefined .",
    "we will now introduce two different notions of well - supported models .",
    "the first notion , called _ weakly well - supported models _ , is a straightforward generalization of the definition given in in that it ignores the naf - atoms .",
    "the second notion , , called _ strongly well - supported models _ , does take into consideration the naf - atoms in its definition .    [ weakly well - supported model ]",
    "[ def - well ] let @xmath39 be a basic program .",
    "a model @xmath80 of @xmath39 is said to be _ weakly well - supported _ iff there exists a level mapping @xmath248 such that , for each @xmath253 , @xmath39 contains a rule @xmath34 with @xmath254 , @xmath255 , and for each @xmath256 , @xmath257 is defined and @xmath258 .",
    "we illustrate this definition in the next example .",
    "let us consider again the program @xmath219 and the set of atoms @xmath259 .",
    "let @xmath260 . obviously , @xmath80 is a model of @xmath219 .",
    "assume that @xmath80 is a weakly well - supported model of @xmath219 .",
    "this means that there exists a mapping @xmath248 from @xmath80 to the set of positive integers satisfying the condition of definition [ def - well ] .",
    "since @xmath253 and there is only one rule in @xmath219 with @xmath246 as head , we can conclude that @xmath261 .",
    "observe that @xmath262 and @xmath263 .",
    "thus , by the definition of @xmath257 , we have that @xmath264 this implies that there exists no rule in @xmath219 , which satisfies the condition of definition [ def - well ] and has @xmath237 as its head .",
    "in other words , @xmath80 is not a weakly well - supported model of @xmath219 . @xmath68",
    "the next proposition generalizes fages result to answer sets by reduct for programs with c - atoms .",
    "[ prop - well ] a set of atoms @xmath80 is an answer set by reduct of a basic program @xmath39 iff it is a weakly well - supported model of @xmath39 .    as we have seen in the previous section , different ways to deal with naf - atoms lead to different semantics for basic programs with c - atoms . to take into consideration the fact that naf - atoms can be dealt with by complement",
    ", we develop an alternative generalization of fages s definition of a well - supported model to programs with abstract c - atoms as follows .",
    "[ strongly well - supported model ] let @xmath39 be a basic program .",
    "a model @xmath80 of @xmath39 is said to be _ strongly well - supported _ iff there exists a level mapping @xmath248 such that , for each @xmath253 , @xmath39 contains a rule @xmath34 with @xmath254 , @xmath255 , for each @xmath256 , @xmath257 is defined and @xmath265 , and for each @xmath266 , @xmath267 is defined and @xmath268 ,    using proposition [ prop - well ] and proposition [ prop - equiv ] , we can easily show that the following result holds .",
    "a set of atoms @xmath80 is an answer set by complement of a basic program @xmath39 iff it is a strongly well - supported model of @xmath218 .    the above two propositions , together with proposition [ prop - equiv ] , lead to the following corollary .    [ cr - wsp ] for every naf - monotone basic program @xmath39 , each weakly well - supported model of @xmath39 is also a strongly well - supported model of @xmath39 and vice versa .",
    "as we have discussed in the previous section , each normal logic program @xmath39 can be easily translated into a monotone basic program with c - atoms of the form @xmath238 , @xmath236 .",
    "thus , corollary [ cr - wsp ] indicates that the notion of weakly / strongly well - supported model is indeed a generalization of fages s definition of well - supported model to programs with c - atoms .",
    "general programs are programs with non - elementary c - atoms in the head . the usefulness of rules with non - elementary c - atoms in the head , in the form of a weight constraint or an aggregate , has been discussed in and in .",
    "for example , a simple atom @xmath269 can be used to represent the constraint that no more than 10 students can take the ai class .",
    "the next example shows how the 3-coloring problem of a graph @xmath270 can be represented using c - atoms .",
    "let the three colors be red ( @xmath34 ) , blue ( @xmath246 ) , and green ( @xmath271 ) .",
    "the program contains the following rules :    * the set of atoms @xmath272 for every edge @xmath273 of @xmath270 , * for each vertex @xmath274 of @xmath270 , the following rule : @xmath275 which states that @xmath274 must be assigned one and only one of the colors red , blue , or green . * for each edge @xmath273 of @xmath270 , three rules representing the constraint that @xmath274 and @xmath276 must have different color : @xmath277    we note that , with the exception of the proposals in , other approaches to defining answer sets of logic programs with aggregates do not deal with programs with aggregates in the head . on the other hand ,",
    "weight constraint and choice atoms are allowed in the head @xcite .",
    "similarly , c - atoms are considered as head of rules in the framework of logic programs with c - atoms by and by .    in this section ,",
    "we define answer sets for general programs  i.e .",
    ", programs where the rule heads can be arbitrary c - atoms .",
    "our approach is to convert a program @xmath39 with c - atoms in the head into a collection of basic programs , whose answer sets are defined as answer sets of @xmath39 . to simplify the presentation , we will talk about `` an answer set of a basic program '' to refer to either an answer set by complement , an answer set by reduct , or a well - supported model of the program .",
    "the distinction will be stated clearly whenever it is needed .",
    "let @xmath39 be a program , @xmath45 , and let @xmath80 be a model of @xmath39 .",
    "the _ instance _ of @xmath34 w.r.t .",
    "@xmath80 , denoted by @xmath278 is defined as follows @xmath279    the _ instance of @xmath39 w.r.t .",
    "@xmath80 _ , denoted by @xmath280 , is the program @xmath281 it is easy to see that the instance of @xmath39 w.r.t .",
    "@xmath80 is a basic program .",
    "this allows us to define answer sets of general programs as follows .",
    "[ def - as ] let @xmath39 be a general program .",
    "@xmath80 is an answer set of @xmath39 iff @xmath80 is a model of @xmath39 and @xmath80 is an answer set of @xmath280 .",
    "this definition is illustrated in the next examples .",
    "let @xmath282 be the program consisting of a single fact : @xmath283 intuitively , @xmath282 is the choice atom @xmath11 in the notation of smodels .",
    "this program has two models , @xmath284 and @xmath285 .",
    "the instance @xmath286 contains the single fact @xmath287 whose only answer set is @xmath284 . similarly , the instance @xmath288 is the single fact @xmath289 whose only answer set is @xmath285 .",
    "thus , @xmath282 has the two answer sets @xmath284 and @xmath285 .",
    "@xmath68    the next example shows that in the presence of non - elementary c - atoms in the head , answer sets might not be minimal .",
    "let @xmath290 be the program consisting of the following rules : @xmath291 intuitively , the first rule of @xmath290 is the cardinality constraint @xmath292 in the notation of smodels .",
    "this program has four models : @xmath293 , @xmath294 , @xmath295 , and @xmath296 .",
    "the instance @xmath297 contains the single fact @xmath287 whose only answer set is @xmath92 .",
    "thus , @xmath92 is an answer set of @xmath290 .",
    "if we consider @xmath298 , the corresponding instance @xmath299 contains the rules @xmath300 whose only answer set is @xmath298 .",
    "this shows that @xmath298 is another answer set of @xmath290 .",
    "similarly , one can show that @xmath91 is also an answer set of @xmath290 .",
    "the instance @xmath301 is the program @xmath302 which has @xmath284 as its only answer set .",
    "hence , @xmath303 is not an answer set of @xmath290 .",
    "thus , @xmath290 has three answer sets , @xmath92 , @xmath91 , and @xmath298 . in particular , observe that @xmath304",
    ".    @xmath68    observe that if @xmath39 is a basic program then @xmath39 is its unique instance .",
    "as such , the notion of answer sets for general programs is a generalization of the notion of answer sets for basic programs . it can be shown that proposition [ prop - equiv ] also holds for general programs .",
    "the relationship between the notion of answer set for general programs and the definition given in and other extensions to logic programming is discussed in the next section .",
    "in this section , we relate our work to some recently proposed extensions of logic programming , and discuss a possible method for computing answer sets of programs with c - atoms using available answer set solvers .      the concept of _ logic programs with c - atoms _ , as used in this paper , has been originally introduced in and in in particular , programs with c - atoms have been named _",
    "sc - programs _ in .",
    "the example  [ ex0 ] shows that our semantical characterization differs from the approach adopted in .",
    "in particular , our approach guarantees that answer sets for basic programs are minimal , while that is not the case for the approach described in  .",
    "consider another example :    consider the program @xmath305 @xmath306 according to our characterization , this program has only one answer set , @xmath307 .",
    "if we consider the approach described in  , then we can verify that @xmath308 is an answer set since the nss - reduct of @xmath305 with respect to @xmath91 is @xmath309 and the least fixpoint of the one - step provability operator is @xmath310 .",
    "@xmath68    in this type of examples , it seems hard to justify the presence of @xmath311 in the answer set of the original program .",
    "we suspect that the replacement of a c - atom by its closure , used in the nss - reduct , might be the reason for the acceptance of unintuitive answer sets in .",
    "the following proposition states that our approach is more skeptical than the approach of .",
    "[ equi - marek - remmel ] let @xmath39 be a positive program . if a set of atoms @xmath80 is an answer set of @xmath39 w.r.t .",
    "definition [ def - as ] then it is an answer set of @xmath39 w.r.t . .",
    "the syntax of _ logic programs with c - atoms _ , as used in this paper , is also used in   and in .",
    "one of the main differences between our work and the work of is that we consider _ arbitrary c - atoms _ , while the proposal of focuses on _ monotone ( and convex ) c - atoms_. the framework introduced in this paper can be easily extended to disjunctive logic programs considered in .",
    "the immediate consequence operator @xmath12 proposed in this paper is different from the nondeterministic one - step provability operator , @xmath111 , adopted in , in that @xmath12 is deterministic and it is applied only to basic positive programs . in   and in , the researchers investigate how several properties of normal logic programs ( e.g. , strong equivalence ) hold in the semantics of programs with monotone c - atoms of  .",
    "we have not directly studied such properties in the context of our semantical characterization ; nevertheless , as we will see later , proposition [ equiv - marek ] implies that the results proved in are immediately applicable to our semantic characterization for the class of monotone programs .",
    "we do , however , focus on the use of well - supported models and level mapping in studying answer sets for programs with c - atoms , an approach that has not been used before for programs with c - atoms",
    ".    we will next present a result that shows that our approach to define answer sets for monotone programs coincides with that of .",
    "[ equiv - marek ] let @xmath39 be a monotone program .",
    "a set of atoms @xmath80 is an answer set of @xmath39 w.r.t .",
    "definition [ def - as ] iff @xmath80 is a stable model of @xmath39 w.r.t . .",
    "as discussed earlier , c - atoms can be used to represent several extensions of logic programs , among them weight constraints and aggregates .",
    "intuitively , an aggregate atom @xmath312 ( see , e.g. , ) can be encoded as a c - atom @xmath16 , where @xmath19 consists of all atoms occurring in the set expression of @xmath312 and @xmath313 is such that every @xmath314 satisfies @xmath312 ( see examples [ ex2]-[ex3 ] ) .",
    "as indicated in , many of the previous proposals dealing with aggregates do not allow aggregates to occur in the head of rules . here",
    ", instead , we consider programs with c - atoms in the head .    with regards to naf - atoms , some proposals ( see , e.g. , ) do not allow aggregates to occur in naf - atoms .",
    "the proposal in treats naf - atoms by complement , although a reduction is used in defining the semantics , while argues that , under different logics , naf - atoms might require different treatments .",
    "we will now present some propositions which relate our work to the recent works on aggregates .",
    "we can prove :    [ equiv - faber ] for a program with monotone aggregates @xmath39 , @xmath80 is an answer set of @xmath39 iff it is an answer set of @xmath39 w.r.t . and .    the proposal presented in and in deals with aggregates by using approximation theory and three - valued logic , building the semantics on the three - valued immediate consequence operator @xmath315 , which maps three - valued interpretations into three - valued interpretations of the program",
    "this operator can be viewed as an operator which maps pairs of set of atoms @xmath316 where @xmath317 into pairs of set of atoms @xmath318 with @xmath319 .",
    "the authors show that the ultimate approximate aggregates provide the most precise semantics for logic programs with aggregates .",
    "let us denote with @xmath320 and @xmath321 the two components of @xmath322 , i.e. , @xmath323 .",
    "the next proposition relates @xmath12 to @xmath315 .",
    "[ equiv - pelov ] let @xmath39 be a positive program with aggregates and @xmath160 and @xmath80 be two set of atoms such that @xmath324 .",
    "then , @xmath325 .    the above proposition , together with the fact that the evaluation of the truth value of aggregate formulas in treats naf - atoms by complement , allows us to conclude that , for a program with aggregates @xmath39 , answer sets by complement of @xmath39 ( w.r.t",
    ". definition [ basic - pos - a.s . ] ) are ultimate stable models of @xmath39 @xcite and vice versa .",
    "this result , together with the results in , allows us to conclude that @xmath12 is a generalization of the immediate consequence operator for aggregates programs in .",
    "before we conclude the discussion on related work , we would like to point out that propositions [ equi - marek - remmel]-[equiv - pelov ] show that the different approaches to dealing with aggregates differ only for non - monotone programs .",
    "the main difference between our approach and others lies in the skepticism of the @xmath12 operator , caused by the notion of conditional satisfaction .",
    "we will illustrate this issue in the next two examples .",
    "[ ex19 ] consider the program @xmath93 of example [ ex3 ] .",
    "this program does not have an answer set w.r.t .",
    "definition [ basic - pos - a.s . ] but has @xmath326 as an answer set according to .",
    "the reason for the unacceptability of @xmath80 as an answer set in our approach lies in that the truth value of the aggregate atom @xmath327 could be either true or false even when @xmath328 is known to be true .",
    "this prevents the third rule to be applicable and hence the second rule as well .",
    "this makes @xmath328 the fixpoint of the @xmath329 operator , given that @xmath80 is considered as an answer set .",
    "in other words , we can not regenerate @xmath80 given the program  and the skepticism of @xmath329 is the main reason . we observe that other approaches ( see , e.g. , ) do not accept @xmath80 as an answer set of @xmath93 as well .",
    "the following example shows the difference between our approach and those in as well as in .",
    "[ exp9 ] consider the program @xmath39 @xmath330 intuitively , the abstract atom @xmath331 represents the aggregate atom @xmath332 .",
    "this program has two models @xmath333 and @xmath334 .",
    "the approaches in , and accept @xmath92 as an answer set , while our approach and that of do not admit any answer sets . in our approach , @xmath335 because @xmath336 does not conditionally satisfy @xmath0 w.r.t @xmath92 since it is not true in every possible extension of @xmath336 that leads to @xmath92 , namely it is not true in @xmath337 . in other words ,",
    "the skepticism of our approach is again the main reason for the difference between our approach and the approaches in and in .",
    "@xmath68      in this section ,",
    "we briefly discuss a possible method for computing answer sets of programs with c - atoms , using off - the - shelf answer set solvers .",
    "the method makes use of a transformation similar to the unfolding transformation proposed in for dealing with aggregates , which has been further studied and implemented in .",
    "we begin our discussion with basic positive programs . given a basic positive program @xmath39 and a c - atom @xmath0 , if @xmath338 , an unfolding of @xmath0 is an expression of the form @xmath339 where @xmath340 and @xmath341 . if @xmath342 , then @xmath26 , denoting _ false _ , is the unique unfolding of @xmath0 .",
    "observe that if @xmath343 then the only unfolding of @xmath0 is @xmath237 .",
    "an unfolding of a rule @xmath344 is a rule obtained by replacing each @xmath345 with one of its unfoldings .",
    "@xmath346 denotes the set of all the unfoldings of a rule @xmath34 .",
    "let @xmath347 .",
    "clearly , @xmath348 is a normal logic program if @xmath39 is a basic positive program .",
    "we can show that @xmath80 is an answer set of @xmath39 iff @xmath80 is an answer set of @xmath348 .",
    "this indicates that we can compute answer sets of basic positive programs with c - atoms by ( _ i _ ) computing its unfolding ; and ( _ ii _ ) using available answer set solvers to compute the answer sets of the unfolded program . following this approach ,",
    "the main additional cost for computing answer sets of a basic positive program is the cost incurred during the unfolding process .",
    "theoretically , this can be very costly as for each rule @xmath34 , we have that @xmath349 , where @xmath350 denotes the cardinality of a set .",
    "this means that the size of the program @xmath348 might be exponential in the size of the original program @xmath39 .",
    "thus , the additional cost might be significant .",
    "in practice , we can expect that this number is more manageable , as a rule might contain only a few c - atoms whose set of solutions is reasonably small .",
    "furthermore , certain techniques can be employed to reduce the size of the unfolding program @xcite .",
    "the above method can be easily extended to deal with naf - atoms and general programs .",
    "if answer sets by complement need to be computed , we need to ( _ i _ ) compute the complement of the program ; and ( _ ii _ ) use the above procedure to compute answer sets of the complement . on the other hand , if answer sets by reduct need to be computed , we will have at hand a tentative answer set @xmath80 . the reduction of the program with respect to @xmath80 can be computed , and the unfolding can then be applied to verify whether @xmath80 is an answer set of the reduct .",
    "observe that the complement or a reduct of a program can be easily computed , and it does not increase the size of the program . as such ,",
    "the main cost for computing answer sets of general programs following this approach is still the cost of the unfolding . so far , in our study on programs with aggregates ( a special type of c - atoms ) , we did not encounter unmanageable situations @xcite .    observe that the specification of a c - atom requires the enumeration of its domain and solutions , whose size can be exponential in the size of the set of atoms of the program .",
    "this does not mean that an explicit representation of c - atoms needs to be used .",
    "in most cases , c - atoms can be replaced by aggregate literals . because of this , several complexity results for programs with aggregates ( see , e.g. , ) can be extended to logic programs with c - atoms .",
    "for example , we can easily show that the problem of determining whether a logic program has an answer set or not is at least np@xmath351 .",
    "however , for programs with c - atoms representable by standard aggregate functions , except those of the form @xmath352 and @xmath353 , the problem of determining whether or not a program has an answer set remains np - complete .",
    "in this paper , we explored a general logic programming framework based on the use of arbitrary constraint atoms .",
    "the proposed approach provides a characterization which is more in line with existing semantics of logic programming with aggregates than the characterization proposed in  .",
    "we provided two alternative characterizations of answer set semantics for programs with arbitrary constraint atoms , the first based on a fixpoint operator , which generalizes the immediate consequence operator for traditional logic programs , and the second built on a generalization of the notion of well - supported models of .    within each characterization of answer set , we investigated two methodologies for treating naf - atoms and we identified the class of naf - monotone programs , on which the two approaches for dealing with naf - atoms coincide .",
    "we also proved that the newly proposed semantics coincides with the semantics proposed in for monotone programs .",
    "finally , we related our work to other proposals on logic programs with aggregates and discussed a possible method for computing answer sets of programs with abstract constraint atoms using available answer set solvers .",
    "the proposal has some unexplored aspects .",
    "the proposed approach is rather `` skeptical '' in the identification of answer sets  while the approach in   is overly `` credulous '' .",
    "we believe that these two approaches represent the two extremes of a continuum that needs to be explored .",
    "in particular , we believe it is possible to identify `` intermediate '' approaches simply by modifying the notion of conditional satisfaction .",
    "work is in progress to explore these alternatives .",
    "the authors wish to thank the anonymous reviewers for their insightful comments .",
    "the research has been partially supported by nsf grants hrd-0420407 , cns-0454066 , and cns-0220590 .",
    "an extended abstract of this paper appeared in the proceedings of the twenty - first national conference on artificial intelligence , 2006 .",
    "first , we will show some lemmas that will be used for the proofs of propositions .",
    "[ lm5 ] for two sets of atoms @xmath358 and a monotone c - atom @xmath0 , if @xmath359 ( resp .",
    "@xmath360 ) and @xmath124 ( resp .",
    "@xmath361 ) then @xmath362 ( resp .",
    "@xmath363 ) .",
    "( recall that @xmath216 denotes the complement of @xmath0 . )      1 .",
    "let us assume that @xmath359 and @xmath124 . from the monotonicity of @xmath0 , we can conclude that , for every @xmath49 , if @xmath364 , we have that @xmath47 . as a result",
    ", we have @xmath362 .",
    "2 .   let us assume that @xmath360 and @xmath361 .",
    "let us assume , by contradiction , that @xmath365 . since we already know that @xmath366 , this implies that there exists @xmath367 , @xmath368 , such that @xmath369 , i.e. , @xmath370 .",
    "since @xmath0 is monotone and @xmath371 , we have that @xmath124 .",
    "this is a contradiction , since we initially assumed that @xmath361 .        1 .   from lemma [ lm - cond ] , the assumption that @xmath373 , and the definition of @xmath12 , we have that @xmath374 .",
    "2 .   let us now show that @xmath375 .",
    "consider an atom @xmath376 .",
    "we need to show that @xmath240 . from the definition of the @xmath12 operator",
    ", there is a rule @xmath34 such that @xmath377 and @xmath378 . but observe that , for each @xmath256 , if @xmath379 then we will have that @xmath124 ( definition [ cond - sat ] ) .",
    "thus , we can conclude that @xmath380 . since the program is positive and @xmath80",
    "is known to be a model of @xmath39 , we must have that @xmath381 , thus @xmath240 .",
    "* @xmath80 is a model of @xmath39 since it is an answer set of @xmath39 ( definition [ basic - pos - a.s . ] ) .",
    "thus , we need to prove that @xmath80 is indeed a _ minimal _ model of @xmath39 .",
    "suppose that there exists @xmath382 such that @xmath209 is a model of @xmath39 .",
    "proposition [ prop - tp ] and lemma [ lm - cond ] imply that @xmath383 for every @xmath384 .",
    "since @xmath80 is an answer set , we have that @xmath385 .",
    "this contradicts the assumption that @xmath382 .    * proposition  [ prop - equiv ] .",
    "* let @xmath39 be a basic program .",
    "each answer set by complement of @xmath39 is an answer set by reduct of @xmath39 .",
    "furthermore , if @xmath39 is naf - monotone , then each an answer set by reduct of @xmath39 is also an answer set by complement of @xmath39 .",
    "* let us start by showing that answer sets by complement are also answer sets by reduct .",
    "let @xmath80 be a model and let us denote with @xmath386 and let @xmath387 .",
    "using the fact that if @xmath388 then @xmath389 we can easily prove by induction that the following result holds : @xmath390 and if @xmath39 is a naf - monotone program then @xmath391 if @xmath80 is an answer set by complement then we have @xmath392 . furthermore , @xmath393 ( proposition [ prop - tp ] ) .",
    "this implies that @xmath80 is an answer set of @xmath39 by reduct as well",
    ".      * proposition  [ prop - preserv ] .",
    "* for a normal logic program @xmath39 , @xmath80 is an answer set ( by complement or by reduct ) of @xmath236 iff @xmath80 is an answer set of @xmath39 ( w.r.t . definition in ) .",
    "* proof . * for convenience , in this proof , we will refer to answer sets defined in as _ gl - answer sets_. because of the monotonicity of @xmath236 and proposition [ prop - equiv ] , it suffices to show that @xmath80 is an answer set of @xmath39 iff @xmath80 is an answer set by reduct of @xmath236 .    let us consider the case where @xmath39 is a positive program .",
    "it follows from observation [ observ1 ] and the fact that @xmath394 iff @xmath395 that the operator @xmath396 for @xmath39 ( defined in observation [ observ1 ] ) coincides with the operator @xmath396 for @xmath236 .",
    "hence , @xmath80 is an answer set of @xmath236 iff @xmath80 is a gl - answer set of @xmath39 .",
    "now suppose that @xmath39 is an arbitrary normal logic program .",
    "let @xmath397 be the gelfond - lifschitz s reduct of @xmath39 w.r.t . @xmath80 .",
    "since @xmath398 iff @xmath240 , we have that @xmath399 . using the result for positive program",
    ", we have that @xmath80 is a gl - answer set of @xmath39 iff @xmath80 is an answer set by reduct of @xmath236 .      1 .   every answer set by complement of a basic program",
    "@xmath39 is a minimal model of @xmath39 .",
    "2 .   every an answer set by reduct of a basic , naf - monotone program @xmath39 is a minimal model of @xmath39 .",
    "every answer set ( by complement / reduct ) of a basic program @xmath39 supports each of its members .      1 .",
    "notice that for a set of atoms @xmath80 and an abstract constraint atom @xmath0 , @xmath400 iff @xmath361 .",
    "this implies that @xmath80 is a model of @xmath39 iff @xmath80 is a model of @xmath218 . from this and from corollary [ cr - minm ]",
    ", we can conclude that if @xmath80 is an answer set by complement of @xmath39 , then it is a minimal model of @xmath39 .",
    "2 .   let us assume that @xmath39 is a naf - monotone basic program , and let @xmath80 be an answer set by reduct of @xmath39 . from proposition [ prop - equiv ] , @xmath80 is also an answer set of @xmath39 by complement .",
    "the previous result implies that @xmath80 is a minimal model of @xmath39 .",
    "3 .   it follows from proposition [ prop - equiv ] that it is enough to prove the conclusion for answer sets by reduct of @xmath39 .",
    "let @xmath80 be an answer set by reduct of @xmath39 . from the definition ,",
    "we have that @xmath401 .",
    "this implies that , if @xmath402 , then there exists @xmath403 such that @xmath404 . in turn",
    ", this allows us to identify a rule @xmath405 such that @xmath406 for @xmath407 and @xmath408 for @xmath409 .",
    "in particular , @xmath410 for @xmath409 . we can easily conclude that the given rule supports @xmath237 .",
    "[ lm - well1 ]",
    "let @xmath39 be a positive , basic program , and let @xmath80 be a weakly well - supported model of @xmath39 .",
    "let @xmath411 be a mapping that satisfies the desired properties of weakly well - supportedness of @xmath80 .",
    "for every atom @xmath237 , @xmath240 implies @xmath412 .      1 .",
    "_ base case : _ consider @xmath240 such that @xmath415 . clearly , we have",
    "that @xmath39 must contain the rule @xmath416 hence , @xmath417 .",
    "inductive step : _ assume that the result holds for every atom @xmath246 such that @xmath418 .",
    "+ consider an atom @xmath240 such that @xmath419 .",
    "we will show that @xmath420 . since @xmath80 is a weakly well - supported model of @xmath39 ,",
    "there exists a rule @xmath421 in @xmath39 such that @xmath422 is defined and @xmath423 for every @xmath424 .",
    "+ let @xmath425 .",
    "for each @xmath426 , since @xmath422 is defined , there is @xmath427 , @xmath428 such that @xmath429 and @xmath430 .",
    "hence , we have @xmath431 . from the inductive hypothesis , since @xmath427 , we can conclude that @xmath83 .",
    "on the other hand , we already proved ( corollary [ cr - tp ] ) that @xmath432 as a result , we have that @xmath433 .",
    "+ from lemma [ lm - cond ] , since @xmath429 , this implies that @xmath434 .",
    "accordingly , we have @xmath420 .          *",
    "* @xmath39 is a positive program . * 1 .",
    "`` @xmath435 '' : suppose @xmath80 is an answer set of @xmath39 .",
    "corollary  [ cr - minm ] implies that @xmath80 is a model of @xmath39 .",
    "thus , it suffices to find a level mapping satisfies @xmath411 the condition of definition [ def - well ] . for each atom @xmath237 , let @xmath436 clearly , @xmath411 is well defined .",
    "we will show that @xmath411 is indeed the mapping satisfying the properties of definition [ def - well ] .",
    "+ let us consider an atom @xmath240 and let @xmath437 . clearly , @xmath438 since @xmath439",
    "so , we have that @xmath440 but @xmath441 .",
    "there are two cases : 1 .",
    "@xmath39 contains a rule @xmath416 in this case , the condition on @xmath411 for the atom @xmath237 is trivially satisfied .",
    "2 .   @xmath39 contains a rule @xmath34 of the form @xmath442 such that @xmath434 for @xmath424 .",
    "+ consider an integer @xmath424 .",
    "let @xmath443 . by the definition of conditional satisfaction , we have that @xmath428 .",
    "it is easy to check that @xmath429 .",
    "in addition , we have @xmath427 . as a result",
    ", @xmath422 is defined .",
    "furthermore , we have @xmath444 .",
    "this shows that the condition on @xmath411 for @xmath237 is also satisfied in this case .",
    "+ the above two cases allow us to conclude that @xmath411 satisfies the condition of definition [ def - well ] , i.e. , @xmath80 is a weakly well - supported model of @xmath39 .",
    "`` @xmath445 '' : suppose @xmath80 is a weakly well - supported model of @xmath39 .",
    "due to lemma [ lm - well1 ] , we have that @xmath446 . on the other hand , from corollary [ cr - tp ]",
    ", we have @xmath447 .",
    "consequently , we have @xmath448 , which implies that @xmath80 is an answer set of @xmath39 .",
    "* * @xmath39 is an arbitrary basic program . *",
    "it is easy to see that a set of atoms @xmath80 is a weakly well - supported model of @xmath39 iff @xmath80 is a weakly well - supported model of @xmath123 . from the previous result",
    ", this means that @xmath80 is an answer set by reduct of @xmath39 iff @xmath80 is a weakly well - supported model of @xmath39 .        *",
    "consider the case that @xmath39 is a basic program . since @xmath134 is a monotone positive programs , the least fixpoint of the one - step provability operator @xmath449 coincides with the least fixpoint of our extended immediate consequence operator @xmath450",
    "( see also proposition [ equiv - marek ] ) .",
    "furthermore , we can easily verify that @xmath451 holds if @xmath80 is an answer set w.r.t .",
    "definition [ def - as ] .",
    "these two observations imply the conclusion of the proposition . *",
    "we now consider the case that @xmath39 is general positive program . without loss of generality",
    ", we can assume that @xmath39 does not contain any constraints .",
    "let @xmath452 .",
    "we have that for a rule @xmath453 if and only if there exists some rule @xmath45 such that @xmath454 , @xmath455 , and @xmath456 .",
    "this implies that @xmath457 . since @xmath80 is an answer set of @xmath458 ( w.r.t .",
    "definition [ def - as ] ) , we conclude that it is also an answer set of @xmath458 w.r.t .",
    "( the basic case ) which implies that @xmath80 is also an answer set of @xmath39 w.r.t",
    ".      * proof .",
    "* let us start by showing the validity of the result for positive programs .",
    "let us assume that @xmath39 is a positive program . without loss of generality , we assume that @xmath39 does not contain any constraints .    1 .",
    "`` @xmath435 '' : let @xmath80 be an answer set of @xmath39 . from definition",
    "[ def - as ] , we have that @xmath80 is a model of @xmath39 and @xmath80 is an answer set of @xmath452 .",
    "+ for every non - negative integer @xmath403 , let @xmath459 because @xmath80 is an answer set of @xmath458 , by definition , we have @xmath460 to show that @xmath80 is a stable model of @xmath39 w.r.t . , all we need to do is to prove that the sequence @xmath461 is a @xmath462 .",
    "we do so by proving that ( i ) @xmath463 and ( ii ) for every @xmath464 , is the set of rules in @xmath39 whose body is satisfied by @xmath465 . ] @xmath466 , and ( iii ) @xmath467 .",
    "1 .   follows from corollary [ cr - tp ] .",
    "2 .   consider a rule @xmath464 . by the definition of @xmath468",
    ", we have that @xmath469 .",
    "because @xmath39 is monotone and @xmath470 , it follows that @xmath255 and @xmath471 .",
    "+ let @xmath472 . by the definition of @xmath278 , we have that @xmath473 as @xmath474 , for every @xmath475 , @xmath476 . by the definition of @xmath477",
    ", it follows that @xmath478 .",
    "hence , @xmath479 .",
    "since @xmath480 , this implies that @xmath481 on the other hand , because @xmath482 , we have @xmath483 accordingly , we have @xmath484 + on the other hand , because @xmath80 is a model of @xmath39 and @xmath255 , we have @xmath454",
    ". therefore , @xmath485 from ( [ eq - equiv - marek : eq1 ] ) and ( [ eq - equiv - marek : eq2 ] ) , we have @xmath486 , i.e. , @xmath466 .",
    "3 .   let @xmath237 be an atom in @xmath477 . from the definition of @xmath477",
    "it is easy to see that @xmath458 must contain a rule @xmath487 whose head is @xmath237 and whose body is satisfied by @xmath465 .",
    "this implies that @xmath468 must contain a rule @xmath34 such that @xmath488 .",
    "it follows that @xmath489 .",
    "accordingly , we have @xmath490 .",
    "2 .   `` @xmath445 '' : let @xmath80 be a stable model of @xmath39 according to   and let @xmath491 be the canonical computation for @xmath80 , i.e. , @xmath492 @xmath493 according to theorem 5 of , we have @xmath494 + let @xmath452 . because @xmath80 is a stable model of @xmath39 , it is also a model of @xmath39 .",
    "so , to prove that @xmath80 is an answer set of @xmath39 , we only need to show that it is an answer set of @xmath458 .",
    "+ let us construct a sequence of sets of atoms @xmath495 as follows @xmath496 @xmath497 clearly , to prove @xmath80 is an answer set of @xmath458 , it suffices to show that @xmath498 let us prove this by induction .",
    "@xmath499 : trivial because @xmath500 .",
    "2 .   suppose ( [ eq - equiv - marek : eq3 ] ) is true for @xmath501 , we will show that it is true for @xmath502 .",
    "+ consider an atom @xmath503 . by the definition of @xmath504",
    ", there exists a rule @xmath45 such that @xmath505 and @xmath506 .",
    "since @xmath507 and @xmath39 is monotone , it follows that @xmath255 .",
    "because a stable model of @xmath39 is also a model of @xmath39 , we have @xmath454 . as a result",
    ", @xmath458 contains the following set of rules : @xmath508 because @xmath505 and @xmath509 , we have @xmath488 . as a result",
    ", the following rule belongs to @xmath278 @xmath510 because @xmath511 ( inductive hypothesis ) , we have @xmath512 and thus @xmath513 ( recall that @xmath514 and @xmath79 consists of monotone abstract constraint atoms only ) . by the definition of @xmath515 , we have @xmath516 .",
    "+ we have shown that for every atom @xmath503 , @xmath237 belongs to @xmath515 .",
    "hence , @xmath517 now , we will show that @xmath518 .",
    "consider an atom @xmath246 in @xmath515 . by definition of @xmath515",
    ", there exists a rule @xmath453 such that @xmath519 and @xmath520 . by the definition of @xmath458",
    "this means that there exists a rule @xmath34 in @xmath39 such that @xmath521 , @xmath522 and @xmath523 . because @xmath524 ( inductive hypothesis ) , from @xmath525 , we have @xmath506 .",
    "this implies that @xmath526 .",
    "hence , @xmath527 therefore we have @xmath528 from ( [ eq - equiv - marek : eq4 ] ) and ( [ eq - equiv - marek : eq5 ] ) , we have @xmath529 .",
    "to prove this proposition , a brief review of the approach in is needed .",
    "the notion of answer set proposed in is based on a new notion of reduct , defined as follows .",
    "given a program @xmath39 and a set of atoms @xmath49 , the _ reduct of p with respect to s _",
    ", denoted by @xmath530 , is obtained by removing from @xmath39 those rules whose body is not satisfied by @xmath49 . in other words , @xmath531 the novelty of this reduct is that it _ does not _",
    "remove aggregate atoms and negation - as - failure literals satisfied by @xmath49 . for a program @xmath39",
    ", @xmath49 is a _ flp - answer set _ of @xmath39 iff it is a minimal model of @xmath532",
    ". we will now continue with the proof of the proposition .",
    "it is easy to see that it is enough to consider programs without negation - as - failure c - atoms .        1",
    ".   `` @xmath435 '' : let @xmath80 be a flp - answer set of @xmath39 .",
    "we will show that @xmath80 is an answer set of @xmath39 ( w.r.t .",
    "definition [ basic - pos - a.s . ] ) .",
    "+ let @xmath533 . from the definition of flp - answer set , @xmath80 is a minimal model of @xmath458 .",
    "let @xmath534 .",
    "as @xmath80 is a model of @xmath458 , it is also a model of @xmath39 .",
    "corollary [ cr - tp ] implies that @xmath358 .",
    "+ consider @xmath535 such that @xmath536 and @xmath537 . from the definition of @xmath458 and the monotonicity of @xmath39",
    ", we have @xmath255 .",
    "it follows from lemma [ lm5 ] that @xmath538 .",
    "hence , @xmath539 ( by the definition of the operator @xmath12 ) .",
    "this implies that @xmath209 is a model of @xmath458 .",
    "+ because of the minimality of @xmath80 and @xmath358 , we have @xmath540 .",
    "hence , @xmath80 is an answer set of @xmath39 .",
    "`` @xmath445 '' : let @xmath80 be an answer set of @xmath39 .",
    "we will prove that @xmath80 is a flp - answer set of @xmath39 by showing that @xmath80 is a minimal model of @xmath541 .",
    "+ let @xmath358 be a model of @xmath458 .",
    "first , we will demonstrate that @xmath209 is a model of @xmath39 .",
    "suppose otherwise , i.e. , @xmath209 is not a model of @xmath39 .",
    "this implies that @xmath39 contains a rule @xmath34 such that @xmath537 for some atom @xmath237 , @xmath359 for @xmath256 , and @xmath542 . due to the monotonicity of @xmath39 we have that @xmath124 for @xmath256 .",
    "hence , @xmath458 contains the rule @xmath34 . as a result",
    ", we have @xmath536 .",
    "thus , @xmath539 because @xmath209 is a model of @xmath458 . this is a contradiction .",
    "+ we have shown that @xmath209 is a model of @xmath39 . on the other hand , by corollary [ cr - minm ] , @xmath80 is a minimal model of @xmath39 .",
    "therefore , we have @xmath385 .",
    "accordingly , we have @xmath540 .",
    "thus , @xmath80 is a minimal model of @xmath458 , i.e. , an flp - answer set of @xmath39",
    ".                      given two interpretations @xmath554 , an aggregate @xmath0 is conditionally satisfied w.r.t .",
    "@xmath554 ( denoted @xmath555 ) if @xmath556 is a solution of @xmath0 .",
    "for simplicity , we define also conditional satisfaction for atoms , by saying that @xmath237 is conditionally satisfied w.r.t .",
    "@xmath554 if @xmath557 .      we wish to show here that , for a positive program with aggregates @xmath39 and for interpretations @xmath554 , @xmath560 . this will allow us to conclude the result of proposition  [ equiv - pelov ] , since it has been proved that @xmath561  @xcite .      * if @xmath237 is a standard atom , then @xmath563 iff @xmath564 iff @xmath565 .",
    "* let @xmath0 be an aggregate .",
    "* * let us assume @xmath566 .",
    "this means that @xmath567 and , for each @xmath568 s.t .",
    "@xmath569 , we have that @xmath570 . + if we consider @xmath571 s.t . @xmath572 and @xmath573 , then @xmath574 , and @xmath575 ( otherwise , if @xmath576 and @xmath577 , then @xmath578 , which would violate the condition @xmath573 ) . from the initial assumption that @xmath566 , we can conclude that @xmath579 .",
    "this allows us to conclude that @xmath566 implies @xmath555 . *",
    "* let us assume @xmath555 .",
    "this means that , for each @xmath571 s.t . @xmath580 and @xmath573",
    ", we have that @xmath579 . + first of all",
    ", note that @xmath581 , thus @xmath582i.e . ,",
    "let us now take some arbitrary @xmath571 , where @xmath583 . since @xmath584 , in particular @xmath585 .",
    "furthermore , @xmath586 , since @xmath587 .",
    "thus , from the initial assumption , we have @xmath588 .",
    "this allows us to conclude that @xmath555 implies @xmath566 .",
    "these results allows us to conclude that for any element @xmath312 in the body of a rule of @xmath39 ( either atom or aggregate ) , @xmath589 iff @xmath590 .",
    "this allows us to immediately conclude that @xmath560 .",
    "banti , f. , alferes , j.  j. , brogi , a. ,  hitzler , p. 2005 .",
    "the well supported semantics for multidimensional dynamic logic programs.in baral , c. , greco , g. , leone , n. ,  terracina , g. , logic programming and nonmonotonic reasoning , 8th international conference , lpnmr 2005 , diamante , italy , september 5 - 8 , 2005 , proceedings ,  3662 of lecture notes in computer science , 356368 .",
    "springer .",
    "denecker , m. , pelov , n. ,  bruynooghe , m. 2001 .",
    "ultimate well - founded and stable semantics for logic programs with aggregates.in codognet , p. , logic programming , 17th international conference , iclp 2001 , paphos , cyprus , november 26 - december 1 , 2001 , proceedings ,  2237 of lecture notes in computer science ,  212226 . springer .",
    "elkabani , i. , pontelli , e. ,  son , t.  c. 2004 .",
    "smodels with clp and its applications : a simple and effective approach to aggregates in asp.in demoen , b.   lifschitz , v. , logic programming , 20th international conference , iclp 2004 , saint - malo , france , september 6 - 10 , 2004 , proceedings ,  3132 of lecture notes in computer science ,  7389 .",
    "springer .",
    "elkabani , i. , pontelli , e. ,  son , t.  c. 2005 . in baral ,",
    "c. , greco , g. , leone , n. ,  terracina , g. , logic programming and nonmonotonic reasoning , 8th international conference , lpnmr 2005 , diamante , italy , september 5 - 8 , 2005 , proceedings ,  3662 of lecture notes in computer science , 427431 .",
    "springer .",
    "faber , w. , leone , n. ,  pfeifer , g. 2004 .",
    "recursive aggregates in disjunctive logic programs : semantics and complexity.in alferes , j.  j.   leite , j.  a. , logics in artificial intelligence , 9th european conference , jelia 2004 , lisbon , portugal , september 27 - 30 , 2004 , proceedings ,  3229 of lecture notes in computer science ,  200212 .",
    "springer .",
    "ferraris , p. 2005 .",
    "answer sets for propositional theories.in baral , c. , greco , g. , leone , n. ,  terracina , g. , logic programming and nonmonotonic reasoning , 8th international conference , lpnmr 2005 , diamante , italy , september 5 - 8 , 2005 , proceedings ,  3662 of lecture notes in computer science , 119131 .",
    "springer .",
    "gelder , a.  v. 1992 .",
    "the well - founded semantics of aggregation.in proceedings of the eleventh acm sigact - sigmod - sigart symposium on principles of database systems , june 2 - 4 , 1992 , san diego , california ,  127138 .",
    "acm press .",
    "kemp , d.  b.   stuckey , p.  j. 1991 .",
    "semantics of logic programs with aggregates.in saraswat , v.  a   ueda , k. , logic programming , proceedings of the 1991 international symposium , san diego , california , usa ,  387 - 401 . mit press .",
    "liu , l.   truszczyski , m. 2005a .",
    "pbmodels - software to compute stable models by pseudoboolean solvers.in baral , c. , greco , g. , leone , n. ,  terracina , g. , logic programming and nonmonotonic reasoning , 8th international conference , lpnmr 2005 , diamante , italy , september 5 - 8 , 2005 , proceedings ,  3662 of lecture notes in computer science , 410415 .",
    "liu , l.   truszczyski , m. 2005b .",
    "properties of programs with monotone and convex constraints.in veloso , m.  m.   kambhampati , s. , proceedings , the twentieth national conference on artificial intelligence and the seventeenth innovative applications of artificial intelligence conference , july 9 - 13 , 2005 , pittsburgh , pennsylvania , usa ,  701706 .",
    "aaai press aaai press / the mit press .",
    "marek , v.  w.   remmel , j.  b. 2004 . set constraints in logic programmingin logic programming and nonmonotonic reasoning , 7th international conference , lpnmr 2004 , fort lauderdale , fl , usa , january 6 - 8 , 2004 , proceedings ,  2923 of lecture notes in computer science ,  167179 .",
    "springer verlag .",
    "marek , v.  w.   truszczyski , m. 2004 .",
    "logic programs with abstract constraint atoms.in proceedings of the nineteenth national conference on artificial intelligence , sixteenth conference on innovative applications of artificial intelligence , july 25 - 29 , 2004 , san jose , california , usa . aaai press / the mit press .",
    "mumick , i.  s. , pirahesh , h. ,  ramakrishnan , r. 1990 . the magic of duplicates and aggregates.in mcleod , d. , sacks - davis , r. ,  schek , h .- j . , 16th international conference on very large data bases , august 13 - 16 , 1990 , brisbane , queensland , australia , proceeding ,  264277 .",
    "morgan kaufmann .",
    "niemel , i. , simons , p. ,  soininen , t. 1999 .",
    "stable model semantics for weight constraint rulesin proceedings of the 5th international conference on on logic programming and nonmonotonic reasoning ,  315332 .",
    "pelov , n.   truszczyski , m. 2004 .",
    "semantics of disjunctive programs with monotone aggregates  an operator - based approach.in delgrande , j.  p.   schaub , t. , 10th international workshop on non - monotonic reasoning ( nmr 2004 ) , whistler , canada , june 6 - 8 , 2004 , proceedings ,  327334 ."
  ],
  "abstract_text": [
    "<S> in this paper , we present two alternative approaches to defining answer sets for logic programs with _ arbitrary _ types of abstract constraint atoms ( c - atoms ) . </S>",
    "<S> these approaches generalize the fixpoint - based and the level mapping based answer set semantics of normal logic programs to the case of logic programs with arbitrary types of c - atoms . </S>",
    "<S> the results are four different answer set definitions which are equivalent when applied to normal logic programs .    </S>",
    "<S> the standard fixpoint - based semantics of logic programs is generalized in two directions , called answer set by reduct and answer set by complement . </S>",
    "<S> these definitions , which differ from each other in the treatment of negation - as - failure ( _ naf _ ) atoms , make use of an immediate consequence operator to perform answer set checking , whose definition relies on the notion of _ conditional satisfaction _ of c - atoms w.r.t . a pair of interpretations .    </S>",
    "<S> the other two definitions , called strongly and weakly well - supported models , are generalizations of the notion of _ well - supported models _ of normal logic programs to the case of programs with c - atoms . as for the case of fixpoint - based semantics , </S>",
    "<S> the difference between these two definitions is rooted in the treatment of naf atoms .    </S>",
    "<S> we prove that answer sets by reduct ( resp . by complement ) are equivalent to weakly ( resp . </S>",
    "<S> strongly ) well - supported models of a program , thus generalizing the theorem on the correspondence between stable models and well - supported models of a normal logic program to the class of programs with c - atoms .    </S>",
    "<S> we show that the newly defined semantics coincide with previously introduced semantics for logic programs with _ monotone _ </S>",
    "<S> c - atoms , and they extend the original answer set semantics of normal logic programs . </S>",
    "<S> we also study some properties of answer sets of programs with c - atoms , and relate our definitions to several semantics for logic programs with aggregates presented in the literature .    </S>",
    "<S> epsf    # 1    [ section ] </S>"
  ]
}