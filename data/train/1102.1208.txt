{
  "article_text": [
    "communication complexity , introduced by yao in 1979 @xcite , is an important concept in complexity theory which tries to determine the amount of communication needed to compute a function whose input has been distributed among two or more participants .",
    "a natural question , especially in the context of the protocols used in distributed computing , is whether _ synchronous _ protocols , in which the participants can use a common clock , are more powerful than _ asynchronous _ ones , in which the players do not have this ability ( note that the standard protocols studied in communication complexity are asynchronous ) .",
    "the synchronization allows the participants to convey some information by _ not _ sending a message at a given moment of time , which naturally leads us to examine the time - communication trade - off of the protocol .    in their recent paper @xcite , impagliazzo and williams",
    "formalized the notion of synchronous protocols and partially solved several interesting questions related to them by introducing two models of communication , called the synchronized bit model and the synchronized connection model , and studying their complexity .",
    "we can briefly summarize the synchronized bit complexity model as an extension of the standard deterministic model of communication , where a player in one step can send 0 , 1 or a blank , and where blanks do not count towards the communication complexity of the protocol .",
    "it is interesting to consider the polytime bit complexity of a problem @xmath3 : the minimum complexity of any synchronized bit protocol for the problem @xmath3 using a polynomial number of steps .",
    "this function is denoted by @xmath4 .",
    "the authors prove in @xcite the following bounds for the polytime bit complexity : @xmath5 and conclude their paper with the following questions :    can the upper bound on the polytime bit complexity in ( [ bit_bounds ] ) be improved ?    what is the complexity of median in this model ?",
    "we answer both of these questions by proving the following result :    [ median_hard ] the median function does not admit a polytime synchronized bit protocol with communication complexity @xmath1 for any @xmath2 .",
    "since the deterministic complexity of the median function is @xmath0 , we get the following lower bound for the synchronized bit complexity of this problem : @xmath6 for each @xmath2 , which of course forbids any significant improvement to the upper bound in ( [ bit_bounds ] ) in general .",
    "theorem [ median_hard ] can be easily translated , using methods established in @xcite , in terms of the round - communication trade - off in the standard deterministic model .",
    "the median function does not admit a deterministic protocol using @xmath1 rounds and a logarithmic amount of communication at each round for any @xmath2 .",
    "our result provides a new round - communication trade - off for the median function .",
    "the study of the round - communication trade - offs for various functions is an important area of communication complexity with significant applications to streaming algorithms ( lower bounds for the rounds - communication trade - off in the deterministic communication complexity model imply the same bounds for the number of passes - memory trade - off in the streaming model ; the opposite implication usually does not hold ) . with median being a central problem in the streaming model ,",
    "the fact that our approach can be used to prove some lower bounds for it in this model ( albeit slightly weaker than those already known , @xcite ) in a completely different manner , can potentially be quite fruitful .    to facilitate our proofs we define a natural problem , strategy , which is easily seen as complete for the class of communication problems solvable in @xmath0 rounds and @xmath0 communication .",
    "our reduction from strategy to median allows us to show that median is also a complete problem for that class .",
    "the structure of the paper is as follows . in section [ preliminaries ]",
    "we briefly describe the relation between synchronized bit complexity and round complexity , and define the problem central to our paper , strategy . in the following section we prove a round - communication trade - off for the strategy problem by showing a reduction from the @xmath7-pointer - jumping problem ,",
    "whose round - communication trade - off has been extensively studied ( @xcite , @xcite ) .",
    "the reduction uses an intermediate problem  @xmath7-level - strategy .",
    "although both reductions are quite straightforward , they do not preserve the size of the instance , which leads us to a system of asymptotic inequalities on the lower bound for strategy .",
    "we then show a reduction from the strategy problem to median .",
    "we assume that the reader is familiar with the basic notions of communication complexity @xcite .",
    "we will use the straightforward two - way translation between the synchronized bit protocols running in time @xmath8 and using @xmath9 bits of communication and deterministic protocols using @xmath9 rounds and @xmath10 communication at each round , which is explained in detail in @xcite .",
    "we can therefore approach the problem in terms of round complexity : the existence of polytime synchronized bit protocol using @xmath9 bits of communication is equivalent to the existence of a deterministic protocol using @xmath9 rounds and @xmath0 communication at each round .",
    "we define the problem strategy of size @xmath11 as follows .",
    "let @xmath12 be a full binary tree with @xmath11 vertices .",
    "a function @xmath13 assigns to each vertex of the tree a number from the set @xmath14 .",
    "alice knows the values of @xmath13 in the vertices in the odd layers of the tree ( the vertices with odd depth ) , and bob knows the values of @xmath13 in the vertices in the even layers .",
    "we define the _ leaf reached by @xmath13 _ to be the leaf which is an endpoint of the path starting at the root and going always downwards  to the left son of @xmath15 if @xmath16 and to the right son otherwise .",
    "the players goal is to determine the index of the leaf they reach .",
    "[ strategy_complete ] the strategy problem is complete for the class of communication problems solvable in @xmath0 rounds and @xmath0 communication .    we will reduce an arbitrary problem @xmath3 of this class to the strategy problem",
    "the problem @xmath3 has a deterministic protocol using @xmath0 rounds and @xmath0 communication . without loss of generality",
    "we can assume that the protocol makes the players alternate in sending messages containing just one bit .",
    "in each alice s ( and analogously bob s ) vertex of the protocol tree and corresponding to a communication history consistent with her input , the message she sends depends only on her input and the communication history ( in all the other vertices of alice we fix her message in an arbitrary way ) .",
    "we can now transform the protocol tree into a strategy tree by setting the value of the function @xmath13 in each vertex of the tree to the message sent in that vertex , and assigning to the leaves the outputs of the protocol for the given communication history .",
    "[ strategy_upper ] the strategy problem can be solved in @xmath17 rounds and @xmath0 communication at each round .",
    "this upper bound may be easily obtained by using the reductions described in @xcite to change the model to the synchronized bit model , use the upper bound proved therein for this model , and then translate the model back to the standard deterministic model .",
    "we define the problem @xmath7-level - strategy of size @xmath11 as follows .",
    "we have an @xmath11-ary tree @xmath12 of height @xmath18 , with leaves indexed from @xmath19 to @xmath20 .",
    "there is a function @xmath21 $ ] for each vertex @xmath22 , alice knows this function for the vertices in the odd layers and bob knows it for the vertices in the even layers . as in strategy , they want to determine the index of the leaf they descend to starting from the root and following the function @xmath13 ( @xmath23 means that if they arrive to the vertex @xmath15 they descend to the @xmath24-th son of @xmath15 ) . note that @xmath11 is a parameter , and not the input size ; both alice and bob have input of size @xmath25 .",
    "the problem @xmath7-pointer - jumping is defined as follows .",
    "alice and bob each hold a list of @xmath11 pointers , each pointing to a pointer in the list of the other .",
    "an initial pointer @xmath26 is marked .",
    "they want to determine the @xmath18-th pointer they reach after following the pointers starting from @xmath26 .    in @xcite",
    "it was proved that if we allow just @xmath27 rounds then @xmath18-pointer - jumping requires @xmath28 communication .",
    "we will prove the following theorem by showing a sequence of reductions from pointer jumping to strategy :    [ strategy_hard ] the strategy function does not admit a deterministic protocol using @xmath1 rounds and a logarithmic amount of communication at each round for any @xmath2 .",
    "let @xmath29 be some function such that @xmath30 ( we will fix it later ) .",
    "we will prove the following easy lemmas :    if the strategy problem of size @xmath31 can be solved in @xmath32 rounds using @xmath33 communication , then , for each @xmath7 , @xmath7-level - strategy can be solved in @xmath34 rounds using @xmath35 communication .    for each @xmath7 , there is a simple reduction from @xmath7-level - strategy of size @xmath11 ( i. e. with @xmath20 leaves ) to strategy of size @xmath36 .",
    "we will create a strategy tree @xmath37 by replacing each alice s vertex @xmath15 of the tree @xmath12 in @xmath7-level - strategy with a binary tree of height @xmath38 , with @xmath11 leftmost leaves corresponding to the sons of @xmath15 in @xmath12 . on every vertex of even depth in the subtree we fix bob s input to be 0 , and",
    "we fix alice s input in the subtree so that the correct leaf is reached .",
    "note that if @xmath11 is not a power of two , then the strategy tree @xmath37 will be slightly larger than @xmath12 , with additional vertices and not corresponding to vertices of @xmath12 , but that is inconsequential , because our construction assures that these vertices are never reached by the protocol .",
    "it is easy to see that this is a proper reduction .",
    "if @xmath7-level - strategy of size @xmath11 can be solved in @xmath34 rounds using @xmath35 communication , then @xmath7-pointer - jumping of size @xmath11 can also be solved in @xmath34 rounds using @xmath35 communication .",
    "given an instance @xmath39 of @xmath7-pointer - jumping of size @xmath11 we will create an instance of @xmath7-level - strategy of size @xmath11 ( with @xmath20 leaves ) , which will be , informally speaking , a tree of possible paths of length @xmath18 in the graph @xmath39 .",
    "in every odd layer ( resp . even layer ) every vertex that is an @xmath40-th son will point its @xmath41-th son if and only if @xmath42 , where @xmath43 is the alice s ( resp .",
    "bob s ) input in the pointer - jumping instance .",
    "it is easy to see that in this reduction every player can locally compute their input , and that the vertex reached by their functions in @xmath7-level - strategy is an @xmath40-th son if and only if the output for the @xmath7-pointer - jumping is @xmath40 .    by combining the two lemmas we obtain the following",
    "if the strategy problem of size @xmath31 can be solved in @xmath32 rounds using @xmath33 communication , then , for each @xmath7 , @xmath7-pointer - jumping of size @xmath11 can be solved in @xmath34 rounds using @xmath35 communication .",
    "we can now prove the main theorem of this section .",
    "in @xcite it was shown that if we allow no more than @xmath27 rounds then @xmath7-pointer - jumping of size @xmath11 requires @xmath28 communication .",
    "we thus know that for every @xmath7 the protocol for strategy must yield , after using the reductions described , a protocol for @xmath7-pointer - jumping using either a greater number of rounds : @xmath44 or a greater amount of communication : @xmath45    a function @xmath29 which for any @xmath18 violates both of these inequalities is thus a viable lower bound for strategy , that is no @xmath46-round , @xmath47-communication protocol for strategy may exist .",
    "it is easy to check that for all @xmath2 the function @xmath48 fails to satisfy both of these inequalities when we set @xmath49 , which proves theorem [ strategy_hard ] .",
    "note here that if we were to prove a lower bound tightly matching the upper bound for strategy , that is @xmath17 ( proved in remark [ strategy_upper ] ) , which we believe may be the case , we would need to use a different method , because close examination of the inequalities obtained by setting @xmath50 reveals that , regardless of the function @xmath18 , at least one of the inequalities must be satisfied .",
    "if the median problem of size @xmath11 can be solved in @xmath46 rounds using @xmath51 communication strategy of size @xmath11 can also be solved in @xmath46 rounds using @xmath51 communication .",
    "we will show here a reduction from strategy@xmath52 to median@xmath53 , where @xmath37 is a set of natural numbers and @xmath54 are subsets of this set held by alice and bob respectively .",
    "the reduction will work inductively on the height @xmath55 of the tree @xmath12 of the strategy problem .",
    "it is easy to reduce strategy on trees of height 1 to median over @xmath56 : we give the empty subset to bob and to alice either the subset @xmath57 or @xmath58 depending on the value of @xmath13 in the root .",
    "the two possible values of median will correspond to the two possible leaves reached by @xmath13 .",
    "let us denote by @xmath59 the size of the set @xmath37 produced by the reduction for the trees of size @xmath40 , and by @xmath60 the the number of elements given to alice and bob ( @xmath61 ) ; we will construct the reduction inductively so that @xmath59 and @xmath60 are well defined",
    ".    we will now show the induction step for the trees of height @xmath55 .",
    "let @xmath62 be the tree of height @xmath63 rooted at the left son of the root , ant @xmath64 be the tree rooted at the right son .",
    "we denote by @xmath65 the root of the tree @xmath12 and by @xmath66 the subset of @xmath67 given to alice by the reduction from strategy@xmath68 ( we define @xmath69 analogously ) .",
    "the reduction will create the sets : @xmath70 where @xmath71 .",
    "it is easy to check that this is a proper reduction .",
    "the basic idea is that we give alice some amount of small numbers if she turns left in @xmath65 , and the same amount of big numbers if she turns to the right , so that the problem reduces either to finding the median in the subproblem of median corresponding to @xmath62 or to finding the median in the subproblem corresponding to @xmath64 , with the roles of the players reversed ( because it is now bob who holds the roots of @xmath62 and @xmath64 ) .",
    "easy calculations of the recurrence relations for @xmath72 and @xmath73 show that these functions are exponential in @xmath55 , so the reduction from strategy on the tree of size @xmath11 produces an instance of median of size @xmath74 .",
    "combining this reduction with theorem [ strategy_hard ] yields the proof of our main result , theorem [ median_hard ] .",
    "it is worth noticing that this reduction , together with remark [ strategy_complete ] , proves as well that median is complete for the class of communication problems solvable in @xmath0 rounds and @xmath0 communication .",
    "our results still hold in the randomized case .    it is possible that a stronger lower bound for median in the synchronized bit complexity model , tightly matching the upper bound of @xmath17 , may be proven",
    ". it would also be interesting to extend the synchronized bit model to the multiparty case and to study the complexity of the model in this setting .    in @xcite",
    "the authors define also another synchronized model : the connection complexity model , which is based on the assumption that in each timestep every party decides whether to try to establish a connection .",
    "some information is exchanged if and only if a connection has been established , and only successful connections count toward the communication cost of the protocol .",
    "the model turns out to be surprisingly powerful , enabling the participants to solve the disjointness problem in polynomial time and only one bit of communication .",
    "we believe that also for this model the possible multiparty extension seems worth further examination .",
    "russell impagliazzo and ryan williams .",
    "communication complexity with synchronized clocks . in _ proceedings of the 2010 ieee 25th annual conference on computational complexity _ , ccc 10 , pages 259269 , washington , dc , usa , 2010 .",
    "ieee computer society .",
    "andrew chi - chih yao .",
    "some complexity questions related to distributive computing(preliminary report ) . in _ proceedings of the eleventh annual acm symposium on theory of computing _ , stoc 79 , pages 209213 .",
    "acm , 1979 ."
  ],
  "abstract_text": [
    "<S> the synchronized bit communication model , defined recently by impagliazzo and williams in @xcite , is a communication model which allows the participants to share a common clock . </S>",
    "<S> the main open problem posed in this paper was the following : does the synchronized bit model allow a logarithmic speed - up for all functions over the standard deterministic model of communication ? </S>",
    "<S> we resolve this question in the negative by showing that the median function , whose communication complexity is @xmath0 , does not admit polytime synchronized bit protocol with communication complexity @xmath1 for any @xmath2 . </S>",
    "<S> our results follow by a new round - communication trade - off for the median function in the standard model , which easily translates to its hardness in the synchronized bit model .    </S>",
    "<S> * keywords : * _ communication complexity , median , synchronized bit model , round complexity _ </S>"
  ]
}