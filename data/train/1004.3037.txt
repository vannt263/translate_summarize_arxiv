{
  "article_text": [
    "key exchange ( ke ) is one of the most important issues in secure communication .",
    "it helps two communicants to securely establish a common session key , with which the subsequent communication can be protected . in the literature",
    ", there are two types of key exchange . in type one ,",
    "two parties own high entropic secrets ( e.g. , a signing key of a digital signature ) .",
    "this type has been extensively studied in the literature ; see a very partial list @xcite .",
    "type two is password authenticated key exchange , in which it is assumed that the two parties share a human - memorable ( low entropy ) password .",
    "the major threat for this type of key exchange is an off - line dictionary attack . in this case ,",
    "an adversary can catch a function value of the password ( say , @xmath5 ) . since the password space is small",
    ", he can find the matching password through an exhaustive search .",
    "see @xcite for an example . in the literature ,",
    "two types of password key exchange protocols are studied . in the first type ,",
    "two parties only own a common password .",
    "this type is studied extensively in the literature . in the second type ,",
    "the client and server share a password while the server additionally owns a high entropic private key of a public key . in this type",
    ", there are simple solutions @xcite . in this paper",
    ", we consider a new threat to this type of protocols : when the server high entropic secret is compromised , the attacker might quickly break lots of passwords and cause uncountable damage .",
    "it is desired that the pace he breaks passwords is very slow . under this",
    ", the server management will have enough time to realize and defend the attack .",
    "unfortunately , previous protocols ( e.g. , @xcite ) is not secure against this threat .",
    "the server key leakage problem does not occur in the password - only key exchange protocol since in this setting the server does not own a high entropic secret key at all .",
    "hence , an asymmetric password key exchange against this threat is meaningful only if we have a construction that is more efficient than the known password - only protocols .",
    "password - only key exchange was first studied by bellovin and merritt @xcite and further studied in @xcite .",
    "the first provably secure solution is due to bellare et al . @xcite but security holds in the random oracle model which is not our main focus .",
    "the first key exchange without random oracles are due to goldreich and lindell @xcite .",
    "but it is very inefficient .",
    "the first reasonably efficient solution without random oracles is koy protocol @xcite which has 15 exponentiations for each party .",
    "this protocol was abstracted into a framework by @xcite and improved by gennaro @xcite(the contribution of the latter is to remove the signature ) .",
    "jiang and gong @xcite ( recently abstracted into a framework by @xcite ) constructed an efficient protocol , where using the fastest cca2 secure encryption @xcite it costs 5 exponentiations for a client and 6 exponentiations for a server .",
    "katz and vaikuntanathan @xcite constructed a one - round password - only key exchange but less efficient than @xcite .",
    "asymmetric password based technique was initiated by gong @xcite .",
    "halevi and krawczyk @xcite ( also full version @xcite ) proposed a very efficient asymmetric password based key exchange , which essentially let the client use a cca2 secure encryption to encrypt the password information . using encryption @xcite , this protocol only needs about two exponentiations for the client and one exponentiation for the server .",
    "it was later improved by boyarsky @xcite for security in the multi - user setting . however , neither of two protocols can prevent the new threat above because the password is encrypted under a server public key and can be adversely decrypted without a dictionary attack if the private key is leaked .",
    "we first provide a formal model for the above server key leakage problem .",
    "it essentially requires that an adversary can break @xmath0 passwords in @xmath1 steps ( for @xmath2 ) only with probability negligibly close to @xmath3 for some @xmath4 . under this assertion",
    ", the adversary can not quickly break a lots of passwords .",
    "then , we construct a framework of asymmetric password based key exchange .",
    "our construction is based on a tag - based projective hash family that is modified from projective hash family ( tag - phf ) of cramer - shoup .",
    "we show that our framework is secure in the multi - user setting of @xcite ( under a different formalization , where our approach is a new quantification on the authentication failure ) .",
    "our proof does not rely on the random oracles .",
    "we also prove that our framework is persistent , where we introduce a new technique to achieve this , which is a probabilistic experiment extracted from the main proof .",
    "we provide a neat analysis for this experiment .",
    "our persistency holds in the random oracle model .",
    "it is open to construct a protocol whose security and persistency both hold without random oracles .",
    "we instantiate our framework with a concrete tag - phf .",
    "our realization only costs 4 exponentiations for the client and 2 exponentiations for the server , which is significantly more efficient than all the known password - only key exchange .",
    "* notions.*for a set @xmath6 , @xmath7 samples @xmath8 from @xmath6 randomly ; @xmath9 means concatenating @xmath10 with @xmath11 .",
    "we use @xmath12 to denote a * negligible * function : for any polynomial @xmath13 , @xmath14 probability distance of two random variables @xmath15 over set @xmath16 is defined as @xmath17=\\frac{1}{2}\\sum_{v\\in \\omega}|\\pr[a = v]-\\pr[b = v]|.\\ ] ] for @xmath18 , define @xmath19=\\{1 , \\cdots , a\\}$ ] .",
    "ppt means probabilistic polynomial time .",
    "in this section , we introduce a security model for asymmetric password key exchange , which is slightly modified from the password - only setting of bellare , _ et al .",
    "_ @xcite . before proceeding ,",
    "we first give some notions .",
    "* @xmath20 : a password dictionary . for simplicity , assume @xmath21 with a uniform distribution .",
    "but our result holds without the uniformity .",
    "* client @xmath22 and server @xmath6 :  asymmetric password key exchange runs between a client @xmath22 and a server @xmath6 .",
    "@xmath6 has a public key @xmath23 and a private key @xmath24 .",
    "he also shares a password @xmath25 with @xmath22 .",
    "@xmath23 is known to all clients . *",
    "@xmath26 and @xmath27 :  @xmath26 is a protocol instance @xmath28 within client @xmath22 , where @xmath29 is unique within @xmath22 for distinguishing different instances in @xmath22 but it is not necessarily globally unique .",
    "similarly , @xmath27 is a protocol instance @xmath30 within server @xmath6 . in this paper , by a general @xmath31 , we mean @xmath32 is either @xmath6 or some client @xmath33 * @xmath34 :  the @xmath35th message in the protocol execution . *",
    "@xmath36 :  session identifier of @xmath31 , where @xmath32 is either a client @xmath35 or server @xmath6 .",
    "this variable is defined for security analysis only .",
    "essentially , if two instances are jointly executing a protocol then they have the same .",
    "is clear only when the protocol description is available .",
    "* @xmath37:session key defined by instance @xmath38 * @xmath39 :  the party @xmath31 presumably interacts with . * @xmath40 : session state of @xmath38 simply , it is the intermediate data ( other than the long term secret ) necessary for the remaining execution of @xmath38 if @xmath31 finishes successfully , by default @xmath41 * @xmath42 for any @xmath31 , either @xmath32 or @xmath39 ( but not both ) is some client .",
    "hence , it is well - defined if we use @xmath43 to denote this client .",
    "* partnering .",
    "* @xmath31 and @xmath44 are _ partnered _ if ( 1 ) @xmath45 and @xmath46 ; ( 2 ) @xmath47 .    * adversarial model .",
    "* there are @xmath48 clients @xmath49 and a server @xmath50 a client @xmath22 will be initialized with a random password @xmath51 , which is shared with his server @xmath6 .",
    "server @xmath6 , besides owning all clients passwords , additionally has a high entropic public key @xmath23 and a private key @xmath24 .",
    "@xmath23 is also available to all clients .",
    "an adversary can fully control the network .",
    "he can inject , modify , block messages . he can also request any session key .",
    "formally , his behaviors are modeled as access to the following oracles .",
    "@xmath52.when this oracle is called , a protocol execution between @xmath26 and @xmath27 takes place .",
    "finally , a complete message transcript is returned .",
    "this oracle call models an eavesdropping attack .",
    "note , literately , it can be replaced by a sequence of queries blow .",
    "but it is defined separately by requiring that queries should not increase adversary success probability .",
    "@xmath53upon this query , @xmath54 is sent to @xmath31 as @xmath55 .",
    "the output is whatever @xmath31 returns . by default , when @xmath56 , @xmath57 .",
    "this query models active attacks .    *",
    "* reveal**@xmath58 when this oracle is called , session key @xmath37 ( if any ) is returned .",
    "it models a session key loss attack .",
    "@xmath59 upon this query , @xmath22 s password @xmath25 as well as his session states @xmath60 is given to adversary .",
    "after this , his role will be taken by adversary .",
    "this query models a break - in attack or insider attack .",
    "we assume @xmath6 is never corrupted ( although a weak corruption of @xmath6 will be considered when defining persistency in the next subsection ) .",
    "@xmath61this query is a security test for session key @xmath37 .",
    "the adversary is allowed to query it only once .",
    "the queried session must have successfully completed . throughout the game , @xmath32 and @xmath39 should not be corrupted ; @xmath31 and its partnered instance ( if any ) should not be issued a * reveal * query .",
    "when * test * oracle is called , it flips a fair coin @xmath62 if @xmath63 then @xmath37 is provided to adversary ; otherwise , a random number of the same length is provided .",
    "the adversary then tries to output a guess bit @xmath64 . if @xmath65 he will be informed * success * ; otherwise , * fail*.    we now define the protocol security , which considers three properties : correctness , authentication and secrecy",
    ".    * correctness .",
    "* if two partnered instances accept , they derive the same session key except for negligible probability .",
    "* authentication*.if some @xmath31 , with @xmath32 and @xmath39 uncorrupted , has successfully completed while it does not have a _",
    "unique _ partnered instance , then we say authentication is _ broken _ , denoted by event * non - auth*. note that since the password dictionary @xmath20 is small , one can always break the authentication by guessing a client s password and impersonating him to @xmath6 ( through * send * queries ) .",
    "hence , if an adversary makes at most @xmath66 * send * queries , we can only hope that @xmath67=q/|{\\cal d}|+negl(\\kappa).$ ] however , this requirement is not enough .",
    "boyarsky @xcite discussed an authentication problem against @xcite which does not violate this requirement .",
    "intuitively , in his attack , an adversary first obtains a transcript @xmath68 between @xmath22 and @xmath6 ; then he corrupts @xmath69 and obtains @xmath70 ; next he , in the name of @xmath69 , communicates with @xmath6 under the help of @xmath68 .",
    "the last stage is launched many times and finally it can obtain @xmath25 and hence can impersonate @xmath22 successfully .",
    "the significance of this attack is that a malicious @xmath69 can break another user s password just through repeated attempts to login his own account . in this case , the rule that @xmath71 consecutive failures of login results in his account closure can be easily defeated during his attack , by @xmath72 malicious login attempts followed by one correct login .",
    "we remark that this attack does not occur in a password - only key exchange essentially because the server only has a password and hence when @xmath69 attempts to key exchange with @xmath6 in his own name , the server s answer can be computed by himself . that is , an interaction with @xmath6 in his own name is useless . to address the above attack , we consider the authentication between client @xmath22 and server @xmath6 for each @xmath35 individually .",
    "define * non - auth*@xmath73 to be the event * non - auth * such that the client in this event is @xmath22 .",
    "obviously , * non - auth*@xmath74 are mutually disjoint and @xmath75 * non - auth*@xmath73=*non - auth*. _ our authentication property is to require that for each @xmath35 , @xmath76\\le q_i/|{\\cal d}|+negl(\\kappa),$ ] _ where @xmath77 is the number of * send*@xmath78 queries such that @xmath79 under our definition , interactions between @xmath69 and @xmath6 are not counted into @xmath77 and hence can not increase the probability to break @xmath25 .",
    "* secrecy*. an adversary can succeed in a * test * session . denote this event by @xmath80 since * non - auth * already implies a break of the protocol , we only consider @xmath81 under @xmath82*non - auth*. as an adversary has a naive success of probability 1/2 , we require @xmath83<1/2+negl(\\kappa)$ ] .",
    "note it is crucial to properly define session i d ( hence _ partnership _ ) so that we do not classify secure protocols as insecure . for instance ( see @xcite ) , if we define a complete protocol transcript as a session i d , then any protocol is insecure since as long as we hold the last message , * non - auth * occurs .",
    "more subtleties of defining and partnership can be seen in @xcite .",
    "now we are ready to state the security definition .",
    "[ def : sec ] let @xmath77 be @xmath84 of @xmath85 queries such that @xmath86 then , an asymmetric password key exchange protocol is * secure * if    @xmath76\\le \\frac{q_i}{|{\\cal d}|}+negl(\\kappa ) , \\forall i$ ] .",
    "@xmath87<1/2+{negl}(\\kappa).$ ] [ def : sec ]    note if @xmath66 is @xmath84 of * send * queries , then @xmath88 hence , authentication in definition [ def : sec ] implies that @xmath67<\\frac{q}{|{\\cal d}|}+negl(\\kappa).$ ] this futher indicates that @xmath89<1/2+\\frac{q_s}{2|{\\cal d}|}+{negl}(\\kappa),$ ] which is the security definition @xcite for the password - only key exchange .",
    "we now formalize the security when the server high entropic key gets compromised .",
    "this threat is possible due to cryptanalysis , virus attack or a poor management . in this case",
    ", we can not hope the protocol is secure against an off - line dictionary attack as otherwise the protocol is in fact a secure password - only protocol ( by making the server secret public ) .",
    "we thus consider a weaker guarantee : the adversary should not be able to quickly break lots of passwords . under this assertion",
    ", the manager will have enough time to realize and defend the attack .",
    "we remark that previous protocols @xcite do not prevent this threat since they essentially encrypt a password using the servery pub key .",
    "it is desired that if an attacker intends to break @xmath0 passwords , he has to do so using an dictionary attack individually on each password and in average costs @xmath90 dictionary guesses .",
    "quantitatively , if any adversary runs @xmath91 steps , then he can break @xmath0 passwords with probability at most @xmath92 for some @xmath4 , where one step is essentially the cost of one dictionary guess and will be defined when the protocol description is available . also note that since @xmath0 does not necessarily depend on the security parameter @xmath93 we can not simply require the above adversarial success probability be @xmath94 .",
    "we notice that it is hard to tell whether an adversary has broken a password @xmath25 or not .",
    "hence , we can not directly use this definition . however , if this occurs , it should be easy for him to successfully impersonate client @xmath35 , in which case @xmath73 occurs .",
    "hence , we instead define the adversary success as the occurrence of @xmath73 for at least @xmath0 different @xmath33 finally , we define the adversary capability .",
    "since persistency only considers a attack that occurs under a very rare circumstance and continues in a short time , oracle queries other than * send * are immaterial .",
    "we thus formally define the persistency as follows .",
    "@xmath95 and @xmath96 @xmath97 is an asymmetric password - based key exchange protocol , where @xmath20 is the password dictionary and @xmath98 is the server s public key and private key pair .",
    "then @xmath97 is * persistent * if for any ppt adversary @xmath99 that runs latexmath:[$t<\\ell \\alpha    * non - auth*@xmath73 occurs to @xmath0 different @xmath35 with probability at most @xmath101 for some @xmath4 , where a basic step is specified in a concrete protocol .",
    "in this section , we introduce a _ tag - based hash proof system _ , revised from the original hash proof system @xcite ( in fact the brief introduction in @xcite suffices ) by adding a tag .",
    "special forms of hash proof system are used by @xcite to construct password - only key exchange protocols .",
    "a hard subset membership problem essentially is a problem that one can efficiently sample a hard instance in it .",
    "formally , is a collection @xmath102 where @xmath103 is a distribution for a random variable @xmath104 that can be sampled in polynomial time :    * generate a _",
    "finite _ non - empty set @xmath105 s.t .",
    "@xmath106 , and distribution @xmath107 over @xmath108 and distribution @xmath109 over @xmath110 * generate a witness set @xmath111 and a * np*-relation @xmath112 such that @xmath113 if and only if there exists @xmath114 s.t .",
    "@xmath115 @xmath116 can be sampled in polynomial time and the sampling procedure also outputs a witness @xmath114 s.t .",
    "@xmath117 we use @xmath118 to denote this procedure .",
    "when @xmath119 is not a concern , we omit it .",
    "further , @xmath120 can be also sampled in polynomial time",
    ".    finally denote @xmath121 @xmath122 is called a * hard subset membership problem * if for @xmath123 , @xmath8 and @xmath124 are indistinguishable when @xmath125 .",
    "let @xmath126 be sampled from a hard subset membership problem @xmath103 .",
    "consider a tuple @xmath127 , where @xmath128 are finite but non - empty sets , @xmath129 is a set of functions from @xmath130 to @xmath131 and @xmath132 is a deterministic function .",
    "@xmath133 is called a _ key space _ , @xmath134 is called the _ projection key _ ; @xmath6 is called the _ projection space _ for @xmath135 .",
    "@xmath136 is called a ( tag - phf ) for @xmath137 if for any @xmath138 and tag @xmath139 , @xmath140 is uniquely determined by @xmath141 .",
    "it is called an if @xmath142 and @xmath140 are both polynomially computable from @xmath143 and if @xmath140 also is polynomially computable from @xmath144 where @xmath145 . in this paper , by , we mean an efficient .    the following notion of _ computational universal@xmath146 _",
    "is slightly revised from @xcite , which in turn is extended from the notion of _ universal@xmath146 _ by relaxing the statistical indistinguishability to the computational indistinguishability .",
    "@xmath147 , where @xmath148 is a hard subset membership problem .",
    "@xmath149 is a tag - based projective hash function for @xmath150 @xmath151 is * computational universal@xmath146 * if any ppt @xmath99 only has a negligible advantage in the following game .",
    "take @xmath152 and provide @xmath153 to @xmath99 .",
    "@xmath99 can do the following .",
    "* @xmath99 can adaptively query @xmath154 to an * evalu * oracle , where oracle * evalu * is defined as follows .",
    "it checks if @xmath138 ( maybe in exponential time ) .",
    "if yes , return @xmath155 ; otherwise @xmath156 .",
    "* @xmath99 can ask _ once _ to compute some @xmath157 . in turn , he will receive @xmath158 . * @xmath99 can ask _ once _ to test some @xmath159 for @xmath160 in turn , he will receive @xmath161 , where @xmath162 and @xmath163    finally , @xmath99 outputs bit @xmath64 for guessing @xmath164 and succeeds if @xmath165 [ def : phf ]      @xmath166 is a hard subset membership problem .",
    "take @xmath167 .",
    "define a tag - based phf @xmath168 for @xmath137 , where @xmath169 take @xmath152 as a private key , @xmath170 , @xmath171 as a public key where @xmath172 is the description of @xmath151 .",
    "let @xmath173 be a message authentication code with key space @xmath174 consider the following game between a ppt adversary @xmath99 and a challenger , where @xmath99 receives @xmath175 and challenger keeps @xmath176 .",
    "let @xmath177 and @xmath178",
    ".    * * challenge query .",
    "* @xmath99 can adaptively query with any tag @xmath179 . upon this",
    ", challenger takes @xmath180 , lets @xmath181 , @xmath182 , returns @xmath183 and updates @xmath184 * * compute query .",
    "* @xmath99 can adaptively query with @xmath185 . if @xmath186 for some @xmath187 , let @xmath188 ; otherwise , let @xmath189 .",
    "if @xmath190 , return @xmath191 ; otherwise @xmath156 .    at the end of the game , @xmath99 outputs a guess bit @xmath192 for @xmath193 he succeeds if @xmath194    denote this game by @xmath195 .",
    "the lemma below states that @xmath99 only has a negligible advantage ( see appendix a for proof ) .",
    "@xmath196 is a hard subset membership problem , @xmath151 is computational universal@xmath146 and @xmath197 is existentially unforgeable",
    ". then @xmath198=1/2+negl(\\kappa)$ ] .",
    "[ le : cu2 ]",
    "we consider an experiment : there are @xmath48 boxes , where each box contains @xmath199 identical balls except for a color difference , where one of them is colored red while the remaining @xmath200 balls are colored white .",
    "algorithm @xmath99 adaptively draws @xmath201 balls from these boxes .",
    "each time it chooses a box and then draws a ball uniformly randomly from it without replacement .",
    "let @xmath202 .",
    "we use @xmath203 to denote the success probability that algorithm @xmath99 draws @xmath201 balls ( from these boxes ) such that @xmath204 of them are red , where box @xmath35 initially contains @xmath205 balls including one red .",
    "when the red ball in the box is taken , set @xmath205=0 since @xmath99 knows all are white in this box and does not need to draw any ball from it any more .",
    "let @xmath206 .",
    "it is easy to see that for any permutation @xmath207 of @xmath208 , @xmath209 holds .",
    "we prove the following important lemma , where the proof is by induction . due to the page limit",
    ", the details are in appendix b.    if @xmath210 then @xmath211\\big{]}. \\label{eq : reduce}\\ ] ] [ le : reduce ]    @xmath212 ^ -{c_i\\ |\\ y\\ |\\ \\tau_0 } & * \\txt<12.3pc>{$x=\\textsf{t}^*(\\pi_i , y),$ $ \\zeta\\leftarrow \\{0 , 1\\}^\\kappa$\\\\ $ ( k_0 ' , k_1')=h_\\theta(i , x)$ \\textsf{using } $ \\theta$\\\\ $ \\tau_0\\stackrel{?}{=}\\textsf{mac}_{k_0'}(c_i|s|y)$\\\\ $ \\omega = c_i|s|y|\\zeta$,\\ $ \\tau_1=\\textsf{mac}_{k_0'}(\\omega|1)$ } \\\\ \\txt<12.6pc > { $ \\omega = c_i|s|y|\\zeta$,\\ $ \\tau_1\\stackrel{?}{=}\\textsf{mac}_{k_0}(\\omega|1)$\\\\ $ \\tau_2=\\textsf{mac}_{k_0}(\\omega|2)$ , \\textsf{output } $ sk = k_1 $ }   & \\ar[l]_-{s\\ |\\ \\tau_1\\ |\\ \\zeta }   \\txt<12pc > { } \\\\ \\txt<12pc>{}\\ar[r]^{\\tau_2 } & \\txt<12pc>{$\\tau_2\\stackrel{?}{=}\\textsf{mac}_{k_0'}(\\omega|2)$ , $ \\textsf{output } sk = k_1'$}}\\ ] ]    if @xmath213 and @xmath214 , then    @xmath215 [ thm : prob ]    * proof .",
    "* by lemma [ le : reduce ] , @xmath216 equals @xmath217\\\\   & { = } & \\pr[\\frac{\\sum_{i=1}^{\\ell } x_i}{\\ell } -\\frac{a}{2}\\le -(\\frac{a}{2}-\\frac{t}{\\ell } ) ] \\\\ & \\stackrel{*}{\\le } & \\exp({-2\\delta^2\\ell /a^2 } ) , \\hspace{0.20 in } \\delta=\\frac{a}{2}-\\frac{t}{\\ell } > ( 0.5-\\alpha)a\\\\ & \\le & \\exp({-2(0.5-\\alpha)^2\\ell } ) , \\end{array}\\ ] ] where inequality @xmath218 holds since @xmath219=\\frac{a}{2}$ ] and the hoefding inequality . @xmath220",
    "we now introduce our client - server password key exchange framework .",
    "let @xmath221 be a hard subset membership problem and @xmath222 .",
    "@xmath223 is a tag - based projective hash family for @xmath137 , where @xmath224 .",
    "@xmath21 is the set of all possible passwords with uniform distribution .",
    "we say @xmath225 are a if they are efficiently computable and also satisfy the following .    * r-1*.for any fixed @xmath226 , @xmath227 , @xmath228 i.e. , @xmath229 is the inverse function of @xmath230 .",
    "* r-2*. for any @xmath231 , there is at most one @xmath232 such that @xmath233    @xmath234 is a secure message authentication code .",
    "the setup is as follows . for the server @xmath6 , take @xmath235 and compute @xmath236 @xmath24",
    "will be the private key for @xmath6 and @xmath23 will be his public key .",
    "@xmath23 is known to all clients . for each client",
    "@xmath22 , take @xmath237 as the password for @xmath22 , shared with @xmath6 .",
    "@xmath22 stores @xmath23 publicly and @xmath25 secretly .",
    "@xmath6 stores @xmath238 secretly and @xmath23 publicly . the key exchange protocol between @xmath6 and @xmath22 is carried out as follows ( also see fig . [",
    "fig : frame ] ) , where we assume that @xmath231 has been verified but in section [ sec : concrete ] we will remove this condition with almost zero price for a concrete and efficient realization of our framework .",
    "* @xmath22 takes @xmath239 .",
    "then he uses @xmath25 to compute @xmath240 , computes @xmath241 using @xmath242 , and generates @xmath243 finally , he sends @xmath244 to server @xmath50 @xmath22 sets his session state @xmath245 * receiving @xmath244 , server @xmath6 uses @xmath25 to de - transform @xmath124 back to @xmath246 computes @xmath247 using @xmath248 he then verifies if @xmath249 if no , reject ; otherwise , he takes @xmath250 and computes @xmath251 for @xmath252 .",
    "finally , he sends @xmath253 to @xmath254 @xmath6 sets his session state @xmath255 * upon @xmath253 , @xmath22 verifies if @xmath256 for @xmath252 .",
    "if no , reject ; otherwise , he computes and sends @xmath257 to @xmath6 and outputs session key @xmath258 @xmath22 updates @xmath259 * upon @xmath260 , server @xmath6 verifies if @xmath261 .",
    "if no , reject ; otherwise , output session key @xmath262 @xmath6 updates @xmath259    * remark . *",
    "we outline how some attacks are prevented in order to better understand our protocol .",
    "( 1 ) _ against impersonation attack . _",
    "if attacker impersonates @xmath22 to generate and send @xmath263 to @xmath6 , then since he does not know @xmath25 and hence @xmath264 with probability @xmath265 .",
    "when @xmath266 , @xmath267 will be rejected since @xmath268 appears random to the attacker .",
    "( 2 ) _ against insider attack ( as in @xcite ) . _",
    "when a malicious @xmath69 eavesdrops a transcript @xmath269 between @xmath22 and @xmath6 , then he executes the protocol with @xmath6 in the name of himself but using @xmath68 as a help . toward this",
    ", he might send @xmath270 to @xmath6 and hope to receive a response from the latter .",
    "@xmath271 is acceptable only if @xmath272 , where @xmath273 for @xmath274 .",
    "the only useful information is @xmath267 which is computed using @xmath275 for @xmath276 .",
    "however , no matter @xmath277 or not , we have that @xmath278 as @xmath279 ( * this is the main reason we use tag - hps instead of hps in this paper * ) .",
    "this allows us to claim that @xmath280 and @xmath281 are computationally independent .",
    "if @xmath282 , this is automatically true by computational universal@xmath146 definition . in our protocol , even if @xmath283 this computational independency still holds ; otherwise , one can simply reduce to break the hardness of @xmath284 .",
    "thus , @xmath6 will always reject @xmath271 .",
    "since this rejection occurs without considering the value of @xmath25 , it follows that the candidate space of @xmath285 in view of adversary does not reduce .",
    "( 3 ) _ session key secrecy . _",
    "the session key @xmath286 is computed by @xmath287 client @xmath22 can compute this since he knows the witness @xmath119 of @xmath138 and server @xmath6 can compute this since he knows @xmath25 ( for recovering @xmath8 from @xmath124 ) and @xmath24 for @xmath288 any outsider can not compute @xmath289 since given @xmath8 and @xmath23 , @xmath290 is indistinguishable from random , which is implied by lemma [ le : cu2 ] .",
    "in this section , we prove the security of our protocol . before this , we define the session i d in the protocol as @xmath291 where @xmath32 is the client @xmath35 or server @xmath50 since the password @xmath25 for @xmath22 and @xmath6 and @xmath24 are both fixed after the system initiation , @xmath290 is determined for given @xmath292 hence , two partnered parties must have the same session key .",
    "it remains to consider the authentication and secrecy , which we will prove using a game - hopping approach .",
    "@xmath221 is a hard subset membership problem .",
    "@xmath293 is an existentially unforgeable message authentication code .",
    "@xmath151 is computational universal@xmath146 for @xmath294 @xmath295 is a regular transformation pair .",
    "then is secure .",
    "[ thm : secure ]    * proof .",
    "* we modify the security game ( denoted by @xmath296 ) into games @xmath297 such that any adversary view ( hence event * non - auth*@xmath73 or * succ * as they are in the adversary view ) between each neighboring pair are negligibly close . for simplicity ,",
    "we regard query as a result of 4 queries ( i.e. , @xmath298 ) and later will remove its effect on * non - auth*@xmath73 and * succ * by analyzing these special queries . for simplicity , we assume the condition : sampling @xmath299 never repeats the same @xmath8 ( otherwise , we can break the hardness of @xmath300 : given challenge @xmath8 , sample @xmath301 .",
    "then @xmath302 for @xmath303 holds non - negligibly while @xmath304 always holds for @xmath305 ) .",
    "* game @xmath306 . *",
    "we modify @xmath307 to @xmath306 with the following differences .",
    "@xmath308 oracle defines @xmath309 ( instead of @xmath268 ) .",
    "@xmath306 maintains a list @xmath310 of record @xmath311 . for consistency ,",
    "@xmath312 is handled as follows .",
    "first check if @xmath313 for some @xmath314 .",
    "if no , process normally using @xmath24 ; otherwise , define @xmath315 and proceed normally .",
    "@xmath316 [ le : 01 ]    _ proof .",
    "_ if the views of @xmath99 are distinguished by @xmath20 , we construct adversary @xmath317 to violate lemma [ le : cu2 ] . upon @xmath318",
    ", @xmath317 simulates @xmath307 as follows .",
    "let @xmath319    * send*@xmath320 upon this query , @xmath317 issues a challenge query with tag @xmath35 and in turn receives @xmath321 .",
    "he defines @xmath322 and normally finishes the simulation in this query .",
    "finally , he define @xmath323 and update @xmath324 . note in this case , the challenger of @xmath317 will update his list @xmath325    * send*@xmath326 upon this query , compute @xmath327 .",
    "then , he issues query @xmath328 . in turn",
    ", he will receive @xmath191 .",
    "if @xmath329 , he rejects ; otherwise , define @xmath330 and finishes the remaining simulation in this query normally . in the later case , also update @xmath331 note if @xmath8 was generated in @xmath332 , then @xmath333 . in this case , the simulation is consistent with @xmath334:if @xmath335 , then oracle returns @xmath336 ; otherwise , it returns @xmath329 ( and @xmath317 will correctly reject @xmath267 ) .",
    "if @xmath8 is not generated in @xmath332 ( note it could be generated by client @xmath337 ) , then @xmath338 and hence @xmath267 will be verified by the challenger of @xmath317 using @xmath339 computed using @xmath24 . in this case , @xmath329 if @xmath267 is invalid ; @xmath340 otherwise . hence , in any case",
    ", the simulation in this query is perfectly consistent with @xmath341    * send*@xmath342 upon this case , use @xmath343 to simulate normally .",
    "finally , if @xmath344 is accepted , update @xmath345 .",
    "* send*@xmath346 upon this case , use @xmath347 to simulate normally . finally , if @xmath260 is accepted , update @xmath348 .    * reveal*@xmath349 and * test*@xmath350 this occurs only when @xmath351 is successfully completed . in this case",
    ", @xmath352 is well defined in @xmath343 above .",
    "hence , the simulation is normal .",
    "* corrupt*@xmath353 as seen above , @xmath343 is well defined and @xmath25 is known .",
    "hence , the simulation is normal .    from the description of @xmath317",
    ", we can see that when challenge bit @xmath354 , the simulated game by @xmath317 is @xmath307 ; otherwise , it is @xmath306 .",
    "hence , the distinguishability between @xmath307 and @xmath306 leads to violate lemma [ le : cu2 ] . @xmath355",
    "* game @xmath356 * we modify @xmath306 to @xmath357 as follows . in oracle",
    "@xmath358 , take @xmath359 ( instead of @xmath360 ) .",
    "note since @xmath119 is not used in the simulation of @xmath306 , no further change is required toward the consistency with this modification . by simply reducing to hardness of @xmath361 , we have    @xmath362 [ le : 12 ]    we analyze @xmath357 .",
    "recall that , in @xmath363 , when @xmath364 , we define @xmath365 and verify @xmath267 with @xmath366 .",
    "consider a event in this query : @xmath364 and @xmath367 but @xmath267 is valid .",
    "we show    @xmath368=negl(\\kappa).$ ] [ le : bad ]    _ proof . _",
    "assume the lemma is not true .",
    "an irregular query _ be a @xmath369 query where @xmath364 and @xmath370 .",
    "let @xmath84 of irregular queries be bounded by @xmath371 use @xmath372 to represent the event : the @xmath35th irregular query is the _ first _ event .",
    "note when occurs , there exists a unique @xmath73 event .",
    "we now construct an adversary @xmath373 to break the computational universal@xmath146 property of @xmath374 upon @xmath375 , @xmath376 takes @xmath377 and initializes @xmath25 for each @xmath22 and simulates @xmath357 , except when he needs to use @xmath24 , which is one of the following scenarios ( especially note @xmath289 in @xmath378 is taken randomly in @xmath379 without using @xmath24 ) .",
    "( 1 ) @xmath6 is corrupted and @xmath24 should be given to @xmath99 .",
    "this will not occur since we assume @xmath6 is uncorrupted ; ( 2 ) in @xmath363 , @xmath373 will use @xmath24 to compute @xmath380 * in case of @xmath381*. in this case , @xmath373 can compute @xmath327 and query his @xmath382 oracle to compute @xmath383 when @xmath138",
    ", he will receive @xmath290 ; when @xmath282 , he will receive @xmath384 for the former case , he proceeds normally ; for the latter case , it is an irregular query .",
    "if this is the @xmath385th irregular query for @xmath386 , then he rejects @xmath267 ; if it is the @xmath201th irregular query , he issues @xmath387 as a challenge query , in turn he will receive @xmath388 for challenge bit @xmath389 . if @xmath335 , he outputs 0 ; otherwise 1 .",
    "first of all , when @xmath390 , @xmath391 is independent of the adversary view prior to the current query , by unforgeability of , @xmath392 holds negligibly only .",
    "we ignore this tiny probability .",
    "when @xmath354 and @xmath201 is correct , the adversary view till the current query is identical to his view in @xmath357 . in this case ,",
    "validity of @xmath267 is a @xmath393 event , in which @xmath373 must output 0 .",
    "since @xmath394 event implies that @xmath267 is valid and that upon such an event the simulation by @xmath373 prior to the @xmath201th irregular query is identical to @xmath356 ( even without considering the output of @xmath373 in the case @xmath354 with an incorrect @xmath201 ) , we always have that @xmath395-\\pr[{\\cal a}^{'{\\bf evalu}(1 , \\cdot)}=0]| \\ge \\pr[{\\bf bad}_t(\\gamma_2)]-negl(\\kappa)\\ge \\frac{\\pr[{\\bf bad}(\\gamma_2)]}{\\nu}-negl(\\kappa),$ ] non - negligible , contradiction ! here",
    "we use the fact that when @xmath201 is random and thus @xmath396=\\pr[{\\bf bad}(\\gamma_2)]/\\nu.$ ] @xmath355    for simplicity , we now assume that * bad * event never occurs .",
    "if initiator @xmath397 accepts @xmath398 , it must have a unique partner @xmath399 .",
    "[ le : part1 ]    _ proof .",
    "_ recall that @xmath400 .",
    "since @xmath6 will not sample the same @xmath401 twice , except for a negligible probability ( which we ignore ) , it follows that the number of partnered instance @xmath399 for @xmath397 is at most one .",
    "it suffices to prove the existence of such @xmath402 if it does not exist , we show is forgeable .",
    "assume @xmath403 after sending @xmath404 is @xmath405 .",
    "then , reviewing the definitions of oracles in @xmath357 , _ besides computing @xmath406 function _",
    ", @xmath280 ( and its identical copy @xmath407 ) will be used only in the following scenarios _ before @xmath397 verifies @xmath408 _ : @xmath280 is revealed due to the corruption of @xmath22 ( note @xmath6 is uncorrupted ) , which is impossible since a corrupted party is controlled by @xmath99 and so @xmath409 query would not have occurred ) .",
    "hence , prior to verifying @xmath410 by @xmath397 , @xmath357 uses @xmath280 only for evaluating @xmath411 to reduce to the unforgeability of @xmath412 , it suffices to show that prior to verifying @xmath408 in @xmath397 , the simulator never evaluates and outputs @xmath413 with input @xmath414 otherwise , since @xmath415 have different input formats , this evaluation must be done by @xmath6 in @xmath416 for some @xmath417 which already implies that @xmath418 is partnered with @xmath419 contradiction to our assumption .",
    "thus , validity of @xmath420 implies breaking .",
    "assume that @xmath421 is uncorrupted .",
    "if @xmath422 in @xmath423 oracle and @xmath424 is accepted in * send*@xmath425 , then @xmath399 has a unique partnered @xmath426 for some @xmath427 . [",
    "le : part2 ]    _ proof .",
    "_ @xmath84 of such @xmath397 is at most one , by @xmath428 condition on @xmath8 .",
    "it suffices to prove the existence of @xmath429 .",
    "assume this is not true . by assumption , in @xmath430",
    ", it holds that @xmath431 for some @xmath432 and it also holds that @xmath433 ( otherwise , @xmath271 in @xmath404 was rejected and it would be impossible for @xmath399 to verify and accept @xmath424 ) .",
    "hence , the fact that @xmath434 was recorded in @xmath435 implies that @xmath397 for some @xmath436 must have sampled @xmath437 . by condition",
    ", @xmath397 is the only instance that samples this value .",
    "since @xmath397 is not partnered with @xmath438 @xmath397 does not compute @xmath413 with input @xmath439 , where @xmath401 is generated by @xmath440 . as in the previous lemma",
    ", @xmath280 is only used in evaluating @xmath413 . to prove the lemma",
    ", it suffices to show that the simulator never evaluates and outputs @xmath441 with input @xmath439 .",
    "otherwise , it must be done by an instance @xmath442 in @xmath22 in generating @xmath443 ( recall inputs for @xmath444 have different formats ) .",
    "hence , since @xmath445 implies @xmath442 samples @xmath446 it follows that @xmath447 , contradicting that @xmath429 is not partnered with @xmath402 hence , if @xmath442 does not exist , then @xmath399 s accepting @xmath424 implies a forgery , contradicting @xmath412 security ! @xmath355    recall * succ * be the success of @xmath99 in the test session .",
    "then , @xmath448=1/2 $ ] in @xmath357 .",
    "[ le : succ ]    _ proof .",
    "_ let @xmath449 be the test instance and @xmath450 .",
    "let @xmath451 .",
    "then , @xmath452 if @xmath453 , then @xmath454 and ( by lemma [ le : part1 ] ) there is the unique partnered @xmath399 for @xmath455 . if @xmath456 then @xmath457 . in this case , if it does not exist a partnered @xmath455 in @xmath458 for @xmath399 , then @xmath399 s accepting @xmath424 implies @xmath459 event .",
    "hence , under @xmath460 event , there is a partnered @xmath455 for @xmath399 and by condition it is unique .",
    "so in any case , conditional on @xmath460 , there is a uniquely partnered @xmath461 for @xmath462 let @xmath463 be the uniformly random keys defined to replace @xmath464 where @xmath465 let @xmath466 be the random number in oracle .",
    "we notice that in @xmath357 , @xmath467 is taken uniformly random from @xmath468 let @xmath469 .",
    "let the randomness in the whole game for @xmath357 , except @xmath470 , be denoted by @xmath471 .",
    "use @xmath472 to denote the adversary view after the @xmath201th query . then to prove the lemma , it suffices to show that @xmath473 for each @xmath201 is deterministic in @xmath474 we actually also show that @xmath475 is also deterministic in @xmath476 .",
    "initially , @xmath477 is public parameters and the conclusion trivially holds .",
    "assume it is true for @xmath478 queries .",
    "consider query @xmath479",
    "@xmath320 the randomness in sampling @xmath8 and the randomness for @xmath281 is from @xmath480 hence , @xmath244 is deterministic in @xmath481 and the randomness @xmath471 .",
    "@xmath482 . when @xmath483 , @xmath484 is determined by @xmath471 .",
    "hence , the conclusion holds after this query .",
    "@xmath485 oracle first checks if @xmath486 .",
    "if yes , extract @xmath281 from it and proceed normally ( using randomness in @xmath471 if needed ) .",
    "if no , compute @xmath365 for @xmath327 and proceed normally .",
    "notice the component @xmath487 in a record from @xmath310 is computed using the randomness @xmath471 ; @xmath488 is generated using @xmath471 too .",
    "@xmath24 is based on the randomness in the initialization of @xmath357 and hence based on @xmath471 too .",
    "so adversary view in this query is deterministic in @xmath481 and @xmath480 if it outputs @xmath410 , then @xmath347 is updated as @xmath489 . by the uniqueness of @xmath490 , when @xmath491 , @xmath484 is computing with @xmath471 .",
    "hence , the conclusion holds after this query .",
    "@xmath492 and @xmath493 is deterministic in the view of @xmath99 before the query and its session state . by the induction , the conclusion holds after this query .",
    "* reveal*@xmath494 .",
    "this query is @xmath495 . by the restriction on definition , @xmath496 and hence by induction , its internal state is deterministic in @xmath481 and @xmath476 .",
    "since @xmath495 is in his internal state , the conclusion holds after this query .",
    "* corrupt*@xmath353 . upon this query @xmath25 as well as",
    "@xmath497 will be available to @xmath99 .",
    "since @xmath498 by restriction , by induction , the conclusion holds after this query .    *",
    "reply in this query is @xmath500 .",
    "the conclusion holds trivially after this query .    as a summary , after any query , our conclusion holds .",
    "hence , adversary view is independent of @xmath62 @xmath355    @xmath501\\le \\frac{q_i}{|{\\cal d}|}+negl(\\kappa).$ ] [ le : non - auth ]    _ proof . _ to prove the lemma , we show how to simulate @xmath357 when the randomness for @xmath502 is unfixed while the remaining randomness in the game is fixed .",
    "let @xmath503 be the probability space for @xmath25 after each oracle query .",
    "we will simulate @xmath357 such that after each query , the adversary view is identical for each @xmath504 .",
    "hence , given the adversary view , @xmath505 is uniformly distributed over @xmath506    initially , the adversary is given @xmath507 which is independent of @xmath508 hence , @xmath509 assume this simulation is done for query @xmath510 consider query @xmath201 , which is one of the following .",
    "* send*@xmath358 .",
    "oracle takes @xmath511 , @xmath512 and computes @xmath243 finally , update @xmath324 .",
    "the adversary view in this query is @xmath513 for any @xmath514 , the adversary view in the current query is identical . by induction assumption , after this query , if @xmath515 remains unchanged , the conclusion holds .",
    "* send*@xmath326 upon this , if @xmath517 , then ( regardless of the concrete value for @xmath25 ) , the oracle will take @xmath289 from it and finish the remaining simulation in this query normally and all @xmath518 remain unchanged . if @xmath519 , oracle will uses @xmath24 and @xmath25 to verify @xmath267 and announce the success of @xmath99 if valid and reject otherwise",
    "the analysis for this case is as follows .    *",
    "* @xmath267 is valid for the case @xmath520 * this case occurs only for at most one @xmath25 ( denoted by @xmath521 ) by regularity property * r-2 * of @xmath522 * * @xmath267 is valid for the case @xmath523 * this event is a event in @xmath357 ( negligible , see lemma [ le : bad ] ) . since we already assume this event never occurs after lemma [ le : bad ]",
    ", this case does not exist .    as a summery ,",
    "item 1 occurs ( hence @xmath524 ) with probability at most @xmath525 by induction assumption ( since , given @xmath526 , vector @xmath527 is uniform in @xmath528 and especially @xmath25 is uniform in @xmath503 ) ; when item 1 does not occur , then the adversary view in this query is identical ( i.e. , ) for any password setup : take @xmath529 and take @xmath530 for all @xmath531 .",
    "hence , in this case , @xmath532 for @xmath531 remain unchanged , @xmath533 and @xmath534 is well defined .",
    "@xmath535 are all processed only with a session state from @xmath378 oracle or @xmath536 oracle , which is well defined as seen above .",
    "hence , the simulation is perfect .",
    "@xmath353 . in this case",
    ", @xmath25 is revealed and hence @xmath503 is updated to a set of a single value . notice that @xmath497 are consistent with all @xmath537 by induction .",
    "thus , if we keep @xmath532 unchanged for @xmath531 , then the conclusion still holds .",
    "now we consider @xmath538 event .",
    "it occurs at either some @xmath442 or @xmath539 with @xmath540 by lemma [ le : part1 ] , it is impossible to the former . for the latter , by lemma [ le : part2 ] , it must hold that @xmath364 in @xmath541 query and hence item 1 ( i.e. , @xmath524 ) must occur ( since item 2 is negligible and ignored ) . it remains to calculate the probability @xmath524 throughout the game . as analyzed above",
    ", it has a probability @xmath525 , conditional on that previous queries with @xmath542 do not have such an event .",
    "hence , as a summery , @xmath524 occurs in the @xmath543th such a @xmath544 query with probability @xmath545 we claim that there are at most @xmath77 @xmath546 queries for fixed @xmath22 such that @xmath547 with @xmath548 . indeed ,",
    "although at the beginning of theorem proof , we decompose * execute * into 4 * send*@xmath549 queries , this treatment does not invalidate the above statement : in the special @xmath550 query ( decomposed from query @xmath551 ) , @xmath552 was recorded by @xmath442 in @xmath553 ( decomposed from the same query ) .",
    "so * non - auth*@xmath73 does not occur to such a special query .",
    "thus , @xmath554\\le\\frac{q_i}{|{\\cal d}|}.$ ] @xmath355    we come back to the proof of theorem .",
    "note that * non - auth*@xmath73 and @xmath555 both are in the view of adversary .",
    "hence , each of them are negligibly close between games @xmath556 by lemmas [ le : succ ] and [ le : non - auth ] , we conclude the theorem proof .",
    "in this section , we show that our protocol is persistent against the leakage of server key @xmath24 . in our analysis , we model as a random oracle , which is reasonable ( say , if we use hmac ) .",
    "we first introduce the following notion .",
    "@xmath557 is a tag - phf and @xmath558 is a deterministic function .",
    "@xmath559 is * locally 1-unique * w.r.t .",
    "@xmath560 if for any ppt adversary @xmath99 , the probability that the first @xmath176 bits of @xmath561 and @xmath562 equal , is negligible , where @xmath563 are distinct and respectively goes over @xmath20 and @xmath564 .",
    "the persistency requires that if the attacker runs @xmath565 basic steps for @xmath2 , then the probability for him to break the authentication w.r.t .",
    "@xmath0 clients , is small .",
    "an authentication break occurs w.r.t .",
    "@xmath22 means that either @xmath344 is accepted at * send*@xmath566 while server @xmath6 never computes it , or @xmath260 is accepted at * send*@xmath567 while @xmath22 never computes it .",
    "this intuitively requires the knowledge of @xmath25 to compute @xmath281 ( hence @xmath568 ) . in our proof , we maintain and update the candidate space @xmath503 for @xmath25 after each oracle query .",
    "we show that each query will either identify @xmath25 with probability @xmath525 for a particular @xmath35 , or remove one candidate of @xmath25 from @xmath503 .",
    "but in any case , other @xmath532 is not affected .",
    "thus , an oracle query is similar to red ball experiment in section 4 : it either hits a password @xmath25 ( red ball ) or remove one incorrect candidate ( white ball ) for @xmath25 . from theorem [ thm : prob ] , we know that if there are at most @xmath565 coupons , then the probability to draw @xmath0 red balls in total is exponentially small .",
    "we now proceed to a formal analysis .",
    "let @xmath569 be a random oracle and @xmath570 is locally 1-unique with respect to @xmath571 then , @xmath572 is persistent , where assume one evaluation is a basic step .",
    "[ thm : per ]    * proof .",
    "* we first modify * send*@xmath573 oracle such that @xmath305 ( instead of @xmath574 ) .",
    "since @xmath575 can be computed using @xmath24 ( known ) , the revised game can be simulated without difficulty .",
    "thus , the probability to break authentication in these two games differs negligibly .",
    "hence , we only need to focus on the revised game . assuming the randomness @xmath471 for the whole game except @xmath576 , is fixed , we show how to simulate * send * oracle and mac oracle without specifying @xmath577 we denote @xmath503 to be the candidate space for @xmath25 , given the current adversary view .",
    "we use @xmath473 to denote the adversary view after @xmath201 queries .",
    "initially , @xmath99 receives @xmath578 , which is independent of @xmath577 hence , given @xmath477 , @xmath579 assume the first @xmath478 queries are answered .",
    "consider query @xmath201 which is one of the following .",
    "* mac * oracle .",
    "it maintains a mac list @xmath580 consisting of records @xmath581    * query * @xmath582 by simulator .",
    "this query always has a format @xmath583 where @xmath584 ( empty ) or @xmath585 or @xmath586 , where @xmath587 is the random variable @xmath281 ( dependent on the random variable @xmath25 ) , where recall that the randomness other than @xmath588 is fixed .",
    "note that @xmath587 is determined if @xmath503 has a single element . by default",
    ", we assume that when @xmath589 , the simulator always realizes @xmath587 with the determined value . upon the mac query",
    ", it checks if it has been queried before .",
    "if no , take @xmath590 and add @xmath591 into @xmath592 in any case , return @xmath179 for @xmath593 as the reply .",
    "note that this query does not change @xmath594 .",
    "that is , the simulation is consistent for any assignment @xmath595    * query * @xmath582 by @xmath99 . upon query @xmath582 , if @xmath582 was queried before , find @xmath124 such that @xmath596 and return @xmath124 . if @xmath582 was not queried before , do the following . if @xmath582 can be parsed into a format @xmath597 where @xmath598 for @xmath584 ( empty ) or @xmath585 or @xmath586 , then check whether there exists some @xmath599 ( unique if any , by assumption on @xmath570 ) s.t .",
    "@xmath600 . if @xmath601 exists , check whether @xmath602 ( in this case , ` = ' occurs with probability @xmath525 since any @xmath537 gives the same adversary view ) . if yes , @xmath603 and set @xmath604 in record @xmath605 of @xmath580 by the first @xmath176bits of @xmath606 ; otherwise , set @xmath607 when query @xmath582 was not recorded in @xmath580 , take @xmath608 ( using random tape @xmath471 ) and add @xmath609 into a list @xmath580 . in any case , return @xmath179 for @xmath610    our simulation above has the property that if any @xmath611 ( also realizing @xmath612 based on this assignment accordingly ) before the mac query is consistent with adversary view , then after the mac query , this still holds for updated @xmath613    * send*@xmath320 upon this , take @xmath511 .",
    "assume no query @xmath614 was previously issued to , which is violated with probability @xmath615 ( tiny and ignored ! ) .",
    "query @xmath616 to oracle and when receiving the reply @xmath179 , define @xmath617 finally , send @xmath244 to @xmath618 .",
    "* send*@xmath326 upon this , query @xmath616 to oracle and when receiving the reply @xmath179 , @xmath267 is accepted if and only if @xmath617 if @xmath619 , normally generate @xmath404 by querying @xmath620 to oracle for computing @xmath344 .",
    "finally send out @xmath253 .",
    "* send*@xmath621 upon this , verify @xmath344 by querying @xmath622 to @xmath412 oracle and if accepted , generate and send out @xmath260 by querying @xmath623 to oracle .",
    "* send*@xmath624 verify @xmath260 by a query @xmath623 to oracle .    by the definition of , after each query",
    ", the adversary view will be consistent with any @xmath625 .",
    "our simulation is perfect consistent with the real game .",
    "it important to know that each oracle only does not change @xmath528 : it only involves a mac query from simulator which does not change @xmath528 and the remaining code in oracle does not change it either",
    ". now violation of authentication w.r.t .",
    "a client @xmath22 occurs only in two cases :    in * send*@xmath626 , where @xmath344 is accepted while tuple @xmath627 was not queried to oracle by * simulator * before this query . by treatment of oracle , when @xmath628 no @xmath629 for any @xmath630 is queried to @xmath412",
    "; otherwise , either @xmath589 ( for case @xmath631 ) or @xmath285 was removed from @xmath503 ( for case @xmath632 ) .",
    "hence , given adversary view , @xmath633 is random in @xmath634 and hence @xmath344 will be rejected ( ignore the probability @xmath635 of acceptance ) , when @xmath25 is set to any value in @xmath503 .",
    "this also implies that after this query , @xmath594 remains unchanged since for any assignment @xmath636 the adversary view in this query is identical : reject .",
    "when @xmath589 , @xmath344 is of course accepted with probability at most @xmath637    in * send*@xmath567 with @xmath638 , * simulator * has never queried @xmath623 to @xmath412 oracle but @xmath260 is valid .",
    "the analysis is similar to @xmath492 above .",
    "now we evaluate @xmath198 $ ] . from the above analysis , authentication breaks occurring w.r.t .",
    "@xmath0 clients implies that @xmath589 for these clients . on the other hand",
    ", we have shown that @xmath503 is reduced only when @xmath99 makes some special queries @xmath597 that defines @xmath601 : if @xmath639 with probability @xmath525 ; otherwise , @xmath640 .",
    "now we can build red ball experiment out of this event : @xmath25 is red ball and @xmath601 is a pick at box i. @xmath601 hits the red ball with probability @xmath525 ; otherwise , box i eliminates one white ball @xmath641 defining @xmath601 involves at least one mac computation .",
    "hence , one pick costs at least one basic step . by theorem [ thm : prob ] , within @xmath565 picks , @xmath0 red balls are selected with probability at most by @xmath642 @xmath220",
    "in this section , we realize framework using a tag - hps , revised cramer - shoup hash proof system @xcite .    *",
    "hard subset membership problem*. sample a prime @xmath643 where @xmath644 is also a large prime .",
    "let @xmath645 be the prime group of @xmath646 of order @xmath647 take @xmath648 .",
    "the set @xmath649 language @xmath284 is defined as @xmath650 the witness for @xmath651 is @xmath471 .",
    "@xmath574 and @xmath652 are uniform distributions over @xmath284 and @xmath653 , respectively .",
    "witness set @xmath654 .",
    "* np*-relation @xmath655 is defined as @xmath656 .",
    "hence , the description @xmath657 this is a hard subset membership problem by decisional diffie - hellman ( ddh ) assumption in @xmath645 .",
    "let @xmath658 and @xmath224 .",
    "let key space @xmath659 @xmath660 , for @xmath661 let @xmath662 be a collision resistent hash function from @xmath663 to @xmath664 , indexed by @xmath665 .",
    "let is a key derivation function ( e.g. , the least half bits of the input ) and is not used in the original hps @xcite .",
    "for @xmath666 and a tag @xmath179 , define @xmath667 where @xmath668 if @xmath669 , then @xmath670      ( @xmath673 ) : for @xmath674 and @xmath675 define @xmath676 and @xmath677 evidently , regularity property * r-1 * is satisfied .",
    "in addition , property * r-2 * is satisfied as long as no @xmath678 s.t .",
    "@xmath679 , which is evident when @xmath21 for @xmath680              * proof . *",
    "since @xmath687 is uniform over @xmath664 , we ignore the probability @xmath688 let @xmath689 be the output of @xmath690 for any distinct @xmath691,$ ] let @xmath692 , @xmath693 where @xmath694 and @xmath695 as @xmath696 , @xmath344 and @xmath260 are independent ( in @xmath664 ) and @xmath697 has an order of @xmath644 .",
    "thus , either @xmath11 or @xmath10 is uniformly distributed over @xmath645 .",
    "assume @xmath11 has an order of @xmath644 .",
    "from independence between @xmath344 and @xmath260 , @xmath11 is uniformly random over @xmath645 for fixed @xmath10 .",
    "so by calculation the first @xmath698 bits of @xmath699 and @xmath700 equal with probability @xmath701",
    ". since there are @xmath702 pairs of @xmath703 , by assumption , the lemma follows .",
    "@xmath220    * efficiency . * client s cost is dominated by 4 exponentiations for @xmath704 and @xmath705 server s cost is dominated by 2 exponentiations for @xmath706 where @xmath707 ( note he can store @xmath708 ) .",
    "here we did not count the verification of @xmath709 by @xmath6 which needs one more exponentiation .",
    "however , we can use a recent technique ( from our separate paper ) to slightly modify the protocol so that we can avoid the verification by exponentiation .",
    "the modification for is as follows . in @xmath404 , instead of sending @xmath710 , client @xmath35 computes @xmath711 and let @xmath712 and replace @xmath124 in the original @xmath404 message by @xmath713 the remaining specification for client is unchanged .",
    "correspondingly , server computation is as follows .",
    "it first recovers @xmath714 from @xmath715 when receiving @xmath404 and the remaining specification in server is unchanged .",
    "denote the modified protocol by .",
    "the cost for client and server each increases by 2 squarings , which is tiny .",
    "then , the security of implies the security of .",
    "the proof uses the fact that for @xmath716 it holds that @xmath717 the security of is obtained by proving that if there is an adversary @xmath373 against with success probability @xmath718 , then there exists an adversary with the same success probability .",
    "the setup of these two protocols are the same .",
    "so when @xmath99 receives the setup parameter @xmath719 , it forwards to @xmath373 .",
    "upon * send * query from @xmath373 , the strategy of @xmath99 is to forward the query from @xmath373 to his own challenger and relay the reply from the latter back to @xmath720 except @xmath124 in @xmath404 of @xmath721 query is replaced by @xmath722 for remaining queries @xmath723 from @xmath373 , @xmath99 forwards it to his own challenger and replays the reply back to @xmath724 from this strategy , we know that whatever @xmath373 breaches , @xmath99 can do the same to @xmath725 hence , the security of follows .",
    "details are omitted here .",
    "bellovin , s.m .",
    "; merritt , m. , encrypted key exchange : password - based protocols secure against dictionary attacks , in _ proceedings of the 1992 ieee computer society symposium on research in security and privacy , _ 72 - 84 .",
    "o. goldreich , y. lindell : session - key generation using human passwords only . _",
    "crypto01_. l. gong , t. mark , a. lomas , r. m. needham , j. h. saltzer : protecting poorly chosen secrets from guessing attacks .",
    "ieee journal on selected areas in communications 11(5 ) : 648 - 656 ( 1993 ) .                                * proof .",
    "* use @xmath726 to denote @xmath195 when the challenge bit is @xmath193 it suffices to show that @xmath727=\\pr[{\\cal a}(\\re_1)=1]+negl(\\kappa).$ ] let @xmath728 denote the variant of @xmath729 , where the first @xmath543 @xmath730 queries are answered as in @xmath731 while the remaining such queries are answered as in @xmath732 let @xmath84 of @xmath730 queries be bounded by @xmath733 then , @xmath734 and @xmath735 if the lemma is violated by @xmath99 , then by hybrid argument , there exists @xmath543 such that @xmath736-\\pr[{\\cal a}(\\re_0^{\\ell } ) = 1]|$ ] is non - negligible .",
    "let @xmath737 be the variant of @xmath738 such that in the @xmath543th @xmath730 query , @xmath739 ( instead of @xmath360 ) , where correspondingly @xmath155 is computed using @xmath176 .",
    "by reduction to the hardness of @xmath300 , we have @xmath740 = \\pr[{\\cal a}(\\hat{\\re}_0^i)=1]+negl(\\kappa).$ ] hence , @xmath741 -\\pr[{\\cal a}(\\hat{\\re}_0^{\\ell})=1]$ ] is non - negligible .",
    "we build an adversary @xmath20 that uses @xmath618 to break computationally universal@xmath146 of @xmath374 upon public key @xmath742 , @xmath20 invokes @xmath99 with @xmath175 and simulates @xmath743 with it as follows .",
    "he defines @xmath389 to be the hidden bit in his challenge key @xmath744 ( parsed as @xmath745 in this proof ) .    * if @xmath746 , take @xmath239 and compute @xmath181 using @xmath119 .",
    "the remaining simulation in this query is normal as in @xmath747 .",
    "if @xmath748 , he takes @xmath749 and sets @xmath750 to be his test pair @xmath751 . in turn , he will receive @xmath744 ( parsed as @xmath745 ) and then he forwards to @xmath99 .",
    "then , he updates @xmath752 .",
    "* @xmath753 if @xmath754 for some @xmath187 , verify @xmath755 using @xmath756 ; otherwise , he issues * evalu * query to his challenger with @xmath757 and in turn receives @xmath191 . if @xmath329 ( hence @xmath282 ) or @xmath758 , he outputs @xmath156 ; otherwise , he outputs @xmath191",
    "denote the simulated game of @xmath20 with bit @xmath389 by @xmath759 then @xmath760 is identical to @xmath761 , except in the case of @xmath282 in @xmath762 query . in this case , the challenger of @xmath20 returns @xmath329 and @xmath20 will output @xmath156 too while in @xmath761 , @xmath755 will be verified using @xmath199 in @xmath763 and ( if valid ) @xmath191 is returned .",
    "hence , inconsistency between the two games occurs only if the following event occurs to some query @xmath185 in @xmath760 : @xmath764 and @xmath282 but @xmath765 .",
    "denote this event by @xmath766 .",
    "we have that @xmath767-\\pr[{\\cal a}(\\bar{\\re}_0^{\\ell -c})=1]|\\le \\pr[\\textsf{e}(\\bar{\\re}_0^{\\ell -c})]$ ] .",
    "we claim that @xmath768=negl(\\kappa ) , c=0 , 1;$ ] otherwise , computational universal@xmath146 of @xmath151 can be broken by adversary @xmath769 as follows .",
    "w.o.l.g , assume @xmath770 $ ] is non - negligible . upon receiving @xmath175",
    ", @xmath769 simulates @xmath771 by playing the role of @xmath20 and the challenger of @xmath20 , where @xmath175 is the public key , except the evaluation of @xmath155 is done under his own challenger s help .",
    "specifically , for the @xmath35th challenge query for @xmath746 , he can take @xmath360 and compute @xmath155 with @xmath119 himself ; for the @xmath543th challenge query , he takes @xmath772 and asks his challenger to evaluate @xmath773 as the first challenge ( i.e , @xmath774 in definition [ def : phf ] ) ; upon a compute query @xmath185 , he asks his own challenger with @xmath757 and in turn he will receive @xmath329 if @xmath282 ; @xmath155 otherwise . in case of the former",
    ", he records @xmath757 in to a list @xmath580 and reject normally ( as in @xmath775 ) ; in case of the latter , answer the query using the received @xmath155 normally .",
    "the remaining simulation is normal .",
    "this simulation is perfectly consistent with @xmath775 for both cases @xmath354 and @xmath776 . at the end of game ,",
    "if @xmath390 ( since we only consider @xmath777 , not @xmath778 ) , he outputs 0/1 randomly ; otherwise , he takes @xmath779 randomly from @xmath580 and ask @xmath779 as his test challenge ( i.e. , @xmath751 in definition [ def : phf ] ) . in turn he will receive @xmath780 , where @xmath781 or @xmath782 then he reviews all the compute queries in @xmath580 with forms @xmath783 for any @xmath784 and denote event @xmath785 by @xmath786 . in case of @xmath786 ,",
    "output 0 ; otherwise output 1 .",
    "note if @xmath787 , then @xmath786 occurs to @xmath788 negligibly by ungorgeability of @xmath412 .",
    "if @xmath789 , then @xmath786 event is event in @xmath771 occurs to @xmath790 . since any @xmath766 event must occur to some @xmath757 in @xmath580 , @xmath786 occurs in @xmath20 s algorithm for @xmath789 with probability at least @xmath791/|{\\cal l}|,$ ] non - negligible .",
    "the non - negligible gap of the two cases implies non - negligible advantage of @xmath769 , contradiction .",
    "hence , @xmath792-\\pr[{\\cal a}(\\bar{\\re}_0^{\\ell -1})=1]$ ] is non - negligible , which is the success advantage of @xmath20 , contradiction . @xmath220",
    "* proof . * use @xmath793 and @xmath794 to denote the left and right side of eq .",
    "( [ eq : reduce ] ) respectively .",
    "first of all , we show @xmath795 by presenting an algorithm @xmath796 achieving @xmath797 @xmath796 simply draws the ball from box 1 until the red ball is picked",
    ". then , he turns to box 2 using the same strategy , then box 3 , @xmath798 .",
    "if he draws a red ball from box @xmath0 before @xmath201 picks are used up , he succeeds ; otherwise , he fails . let the red ball in box @xmath35 be obtained by using @xmath799 picks .",
    "then , it is simple to verify that @xmath800.$ ] hence , the success probability of @xmath801 is exactly the right side of eq .",
    "( [ eq : reduce ] ) .    it remains to show that @xmath802 when @xmath803 , the conclusion holds trivially since both sides are 1 .",
    "assume @xmath804 . when @xmath805 , two sides of eq .",
    "( [ eq : reduce ] ) equal @xmath806 for the ( only ) case @xmath807 . for @xmath808 and @xmath809",
    "we use induction on @xmath479 note @xmath810 can always be achieved by a deterministic algorithm by computing the maximum success probability over the randomness of @xmath99 .",
    "hence , we assume a deterministic @xmath99 achieves it .",
    "when @xmath811 , two sides of eq .",
    "( [ eq : reduce ] ) are zero .",
    "the conclusion holds trivially .",
    "when @xmath812 , assume the first box chosen by @xmath99 is @xmath813 then @xmath814        now assume @xmath816 for @xmath478 , which implies @xmath823 for @xmath478 since @xmath824 is proven at the beginning .",
    "we consider @xmath201 ( @xmath825 ) .",
    "assume the first box chosen by @xmath99 is @xmath385 .",
    "then , @xmath826 there are two cases .",
    "@xmath839\\big{]}= \\pr\\big{[}\\sum_{i=1}^{\\ell-1}x_i\\le t-1:\\quad x_i\\leftarrow [ a_i]\\big{]}.$ ] since @xmath840 , it follows that @xmath841 always holds when @xmath842.$ ] so @xmath843\\big{]}= \\pr\\big{[}\\sum_{i=1}^{\\ell}x_i\\le t:\\quad",
    "x_i\\leftarrow [ a_i]\\big{]}.$ ] the induction holds in this case .    if @xmath844 then @xmath845 .",
    "hence , @xmath846\\big{]}\\\\ & = & \\pr\\big{[}\\sum_{1\\le i\\le \\ell , i\\ne j}x_i\\le t-1:\\quad x_i\\leftarrow [ a_i]\\big{]}\\\\ & = & \\pr\\big{[}\\sum_{i=1}^\\ell x_i\\le t:\\quad x_i\\leftarrow [ a_i]\\big { ] } , \\end{array}\\ ] ] where the last ` = ' holds since @xmath827 and hence @xmath847 holds always .",
    "hence , the induction holds in this case too .",
    "* case @xmath848 and @xmath849 : * in this case , @xmath850 are @xmath831 smallest numbers in @xmath851 by induction assumption on @xmath478 , we have @xmath852\\big { ] } \\end{array}\\ ] ] in addition , if @xmath853 @xmath854 are @xmath0 smallest numbers in @xmath855 .",
    "hence ,      therefore , in eq .",
    "( [ eq : reduce ] ) , we have that @xmath857 equals @xmath858+a_j^{-1}\\cdot \\pr[\\sum_{i=1}^\\ell x_i\\le t-1]-a_j^{-1}\\cdot \\pr[\\sum_{i=1}^{\\ell-1 } x_i\\le t-1]\\ ] ] we need to show @xmath859 we split event @xmath860 into two sub - events @xmath861 and @xmath862 note in case of event @xmath10 , there exists @xmath863 such that @xmath864 hence , @xmath865-\\pr[a]\\ge \\pr[\\sum_{i=1}^\\ell x_i = t\\wedge x_\\ell = x_\\ell^*]-a_j^{-1}\\pr[a ] = a_\\ell^{-1}\\pr[a]-a_j^{-1}\\pr[a]\\ge 0.$ ] in case of event @xmath11 , since @xmath866 always holds , @xmath867\\le a_j^{-1}\\pr[\\sum_{i=1}^\\ell x_i\\le t-1].$ ] hence , @xmath868 holds in this case .",
    "if @xmath869 , then @xmath870 since by assumption @xmath871 for @xmath849 holds always . in this case , @xmath872 are @xmath0 smallest numbers among @xmath873 hence , @xmath874 , x_\\ell^*\\leftarrow [ a_\\ell-1]\\big{]}\\\\   = & ( 1-{a_\\ell^{-1 } } ) \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}x_\\ell^*+\\sum_{i=1}^{\\ell-1}x_i\\le t-1\\wedge x_\\ell^*=u :   x_i\\leftarrow [ a_i ] , x_\\ell^*\\leftarrow [ a_\\ell-1]\\big{]}\\\\   = & { a_\\ell^{-1 } } \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}u+1+\\sum_{i=1}^{\\ell-1}x_i\\le t :    x_i\\leftarrow [ a_i ] , i<\\ell\\big{]}\\\\   = & \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}\\sum_{i=1}^{\\ell}x_i\\le t\\wedge x_\\ell = u+1 :    x_i\\leftarrow [ a_i ] , i\\le\\ell\\big{]}\\\\   = & \\pr\\big{[}\\sum_{i=1}^{\\ell}x_i\\le t\\wedge x_\\ell>1:\\quad x_i\\leftarrow [ a_i]\\big { ] }            * case @xmath848 and @xmath878 : * in this case , @xmath879 are @xmath831 smallest numbers among @xmath851 by induction assumption on @xmath478 , we have @xmath880\\big{]}\\\\   = & \\pr\\big{[}\\sum_{1\\le i\\le \\ell}x_i\\le t\\wedge x_j=1:\\quad x_i\\leftarrow [ a_i]\\big { ] }      @xmath882 , x_j^*\\leftarrow [ a_j-1]\\big{]}\\\\ & = ( 1-{a_j^{-1 } } ) \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}x_j^*+\\sum_{\\stackrel{i=1}{i\\ne j}}^{\\ell}x_i\\le t-1\\wedge x_j^*=u :   x_i\\leftarrow [ a_i],i\\ne j ,   x_j^*\\leftarrow [ a_j-1]\\big{]}\\\\ & = { a_j^{-1 } } \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}u+1+\\sum_{{i=1},{i\\ne j}}^{\\ell}x_i\\le t :   x_i\\leftarrow [ a_i ] , i\\ne j\\big{]}\\\\ & = \\sum_{u=1}^{a_{\\ell}-1}\\pr\\big{[}\\sum_{i=1}^{\\ell}x_i\\le t\\wedge x_j = u+1:\\quad x_i\\leftarrow [ a_i]\\big{]}\\\\ & = \\pr\\big{[}\\sum_{i=1}^{\\ell}x_i\\le t\\wedge x_j>1:\\quad x_i\\leftarrow [ a_i]\\big { ] }"
  ],
  "abstract_text": [
    "<S> asymmetric password based key exchange is a key exchange protocol where a client and a server share a low entropic password while the server additionally owns a high entropic secret for a public key . </S>",
    "<S> there are simple solutions for this ( e.g. halevi and krawczyk ( acm tissec 1999 ) and its improvement by boyarsky ( ccs 1999 ) ) . in this paper </S>",
    "<S> , we consider a new threat to this type of protocol : if a server s high entropic secret gets compromised ( e.g. , due to cryptanalysis , virus attack or a poor management ) , the adversary might _ quickly _ break lots of passwords and cause uncountable damage . in this case , one should not expect the protocol to be secure against an off - line dictionary attack since , otherwise , the protocol is in fact a secure password - only key exchange where the server also only has a password ( by making the server high entropic secret public ) . </S>",
    "<S> of course a password - only key exchange does not suffer from this threat as the server does not have a high entropic secret at all </S>",
    "<S> . however , known password - only key exchange are not very efficient ( note : we only consider protocols without random oracles ) . </S>",
    "<S> this motivates us to study efficient and secure asymmetric password key exchange that avoids the new threat . in this paper , we first provide a formal model for the new threat , where essentially we require that the active adversary can break @xmath0 passwords in @xmath1 steps ( for @xmath2 ) only with a probability negligibly close to @xmath3 for some @xmath4 . </S>",
    "<S> then , we construct a framework of asymmetric password based key exchange . </S>",
    "<S> we prove that our protocol is secure in the usual sense . </S>",
    "<S> we also show that it prevents the new threat . to do this , </S>",
    "<S> we introduce a new technique by abstracting a probabilistic experiment from the main proof and providing a neat analysis of it . </S>"
  ]
}