{
  "article_text": [
    "the notions of tree decomposition and treewidth of a graph @xcite play a central role in algorithmic theory . on the one hand , many natural classes of graphs have small treewidth .",
    "for instance , trees have treewidth at most @xmath18 , series - parallel graphs and outer - planar graphs have treewidth at most @xmath19 , halin graphs have treewidth at most @xmath20 , and @xmath21-outerplanar graphs for fixed @xmath21 have treewidth @xmath22 .",
    "on the other hand , many problems that are hard for @xmath0 on general graphs , and even problems that are hard for higher levels of the polynomial hierarchy , may be solved in polynomial time when restricted to graphs of constant tree - width @xcite . in particular , during the last decade , several algorithms running in time @xmath23 have been proposed for the satisfiability of classical circuits and boolean constraint satisfaction problems of size @xmath2 and treewidth @xmath4 @xcite .    in this work ,",
    "we identify for the first time a natural quantum optimization problem that becomes feasible when restricted to graphs of constant treewidth .",
    "more precisely , we show how to find in polynomial time a classical assignment that maximizes , up to an inverse polynomial additive factor , the acceptance probability of a quantum circuit of constant treewidth . for quantum circuits of unrestricted treewidth",
    "this problem is complete for @xmath9 , a quantum generalization of ma @xcite . before stating our main result",
    ", we fix some notation .",
    "if @xmath1 is a quantum circuit acting on @xmath2 @xmath24-dimensional qudits , and @xmath25 is a quantum state in @xmath26 , then we denote by @xmath27 the probability that the state of the output of @xmath1 collapses to @xmath28 when the input of @xmath1 is initialized with @xmath25 and the output is measured in the standard basis @xmath29 .",
    "if @xmath30 is a string in @xmath31 then we let @xmath32 denote the basis state corresponding to @xmath30 .",
    "we let @xmath33 denote the maximum acceptance probability of @xmath1 among all classical input strings in @xmath34 .",
    "the treewidth of a quantum circuit is defined as the treewidth of its underlying undirected graph .",
    "[ theorem : circuitsatisfiability ] let @xmath1 be a quantum circuit with @xmath2 uninitialized inputs , @xmath3 gates , and treewidth @xmath4 . for each @xmath7 with @xmath35 , one may find in time @xmath5 a string @xmath36 such that @xmath37 .",
    "we note that the algorithm that finds the string @xmath6 in theorem [ theorem : circuitsatisfiability ] is completely deterministic .",
    "the use of treewidth in quantum algorithmics was pioneered by markov and shi @xcite who showed that quantum circuits of logarithmic treewidth can be simulated in polynomial time with exponentially high precision .",
    "note that the simulation of quantum circuits @xcite deals with the problem of computing the acceptance probability of a quantum circuit when all inputs are already initialized , and thus may be regarded as a generalization of the classical p - complete problem circuit - value .",
    "on the other hand , theorem [ theorem : circuitsatisfiability ] deals with the problem of finding a classical assignment that maximizes the acceptance probability of a quantum circuit with uninitialized inputs , and thus may be regarded as a generalization of the classical @xmath0-complete problem circuit - sat . in this sense , theorem [ theorem : circuitsatisfiability ] is the first result showing that a quantum generalization of circuit - sat can be solved in polynomial time when restricted to circuits of constant treewidth .",
    "it is interesting to determine whether the time complexity of our algorithm can be substantially improved . to address this question , we first introduce the _ online - width _ of a circuit , a width measure for dags that is at least as large as the treewidth of their underlying undirected graphs .",
    "if @xmath38 is a directed graph and @xmath39 are two subsets of vertices of @xmath40 with @xmath41 then we let @xmath42 be the set of all edges with one endpoint in @xmath43 and another endpoint in @xmath44 .",
    "if @xmath45 is a total ordering of the vertices in @xmath40 , then we let @xmath46 .",
    "the _ cutwidth _ of @xmath47 is defined as @xmath48 where the minimum is taken over all possible total orderings of the vertices of @xmath47 @xcite . if @xmath47 is a dag , then the _ online - width _ of @xmath47",
    "is defined as @xmath49 where the minimum is taken only among the _ topological orderings _ of @xmath47 .",
    "treewidth , cutwidth and online - width are compared as follows can be found in @xcite . ] .",
    "@xmath50    theorem [ theorem : logarithmictreewidthnp ] below states that finding a classical assignment that maximizes the acceptance probability of a quantum circuit of logarithmic online - width is @xmath0-complete even when @xmath7 is constant .",
    "we note that the same completeness result holds with respect to circuits of logarithmic treewidth .",
    "[ theorem : logarithmictreewidthnp ] for any constant @xmath7 with @xmath51 , the following problem is @xmath0-complete : given a quantum circuit @xmath1 of online - width @xmath52 with @xmath2 uninitialized inputs and @xmath3 gates , determine whether @xmath53 or whether @xmath54 .",
    "an analog completeness result holds when the verifier is restricted to have logarithmic online - width and the witness is allowed to be an arbitrary quantum state .",
    "it was shown by kitaev @xcite that finding a @xmath7-optimal quantum witness for a quantum circuit of unrestricted width is complete for the complexity class @xmath12 for any constant @xmath7 .",
    "interestingly , kitaev s completeness result is preserved when the quantum circuits are restricted to have logarithmic online - width .",
    "if @xmath1 is a quantum circuit with @xmath2 inputs , then we let @xmath55 be the maximum acceptance probability among all @xmath2-qudit quantum states @xmath25 .",
    "[ theorem : logarithmictreewidthqma ] for any constant @xmath7 with @xmath56 , the following problem is @xmath12-complete : given a quantum circuit @xmath1 of online - width @xmath52 with @xmath2 uninitialized inputs and @xmath57 gates , determine whether @xmath58 or whether @xmath59 .",
    "we analyse the implications of theorems [ theorem : logarithmictreewidthnp ] and [ theorem : logarithmictreewidthqma ] to quantum generalizations of merlin - arthur protocols . in this",
    "setting , arthur , a polynomial sized quantum circuit , must decide the membership of a string @xmath60 to a given language @xmath61 by analysing a quantum state @xmath25 provided by merlin . in the case that @xmath62 , there is always a quantum state @xmath25 that is accepted by arthur with probability at least @xmath63 . on the other hand , if @xmath64 then no state is accepted by arthur with probability greater than @xmath65 .",
    "the class of all languages that can be decided via some quantum merlin - arthur protocol is denoted by @xmath12 .",
    "the importance of @xmath12 stems from the fact that this class has several natural complete problems @xcite .",
    "additionally , the oracle version of @xmath12 contains problems , such as the group non - membership problem @xcite which are provably not in in the oracle version of ma and hence not in the oracle version of @xmath0 @xcite .",
    "the class @xmath9 is defined analogously , except for the fact that the witness provided by merlin is a product state encoding a classical string .",
    "below we define width parameterized versions of @xmath12 .    [ definition : widthqma ] a language @xmath66 belongs to the class @xmath67 $ ] if there exists a polynomial time constructible family of quantum circuits @xmath68 such that for every @xmath69 , @xmath70 has treewidth at most @xmath71 and    * if @xmath62 then there exists a quantum state @xmath25 such that @xmath70 accepts @xmath25 with probability at least @xmath63 , * if @xmath64 then for each quantum state @xmath25 , @xmath70 accepts @xmath25 with probability at most @xmath65 .    the class @xmath72 $ ] is defined analogously , except that the witness @xmath73 is required to be the basis state encoding of a classical string @xmath30 .",
    "definition [ definition : widthqma ] can be extended naturally to other width measures such as online - width .",
    "for instance , @xmath74 $ ] and @xmath75 $ ] denote the classes of languages that can be decided by quantum merlin - arthur games with respectively quantum and classical witnesses , in which the verifier is required to have online - width at most @xmath76 .",
    "we note that the classes @xmath12 and @xmath9 can be defined respectively as @xmath77 $ ] and @xmath78 $ ] , since the online - width of a circuit can be at most quadratic in its number of gates . in the next corollary",
    "we analyse the complexity of low - width quantum merlin - arthur protocols with classical and quantum witnesses .",
    "[ corollary : logarithmictreewidthqmaqcma ] @xmath79    a.   [ corollary : o1 ] @xmath80 $ ] @xmath81 p. b.   [ corollary : np ] @xmath82 = \\mathrm{qcma}[{\\mathbf{ow}},o(\\log n ) ] = \\mathrm{np}$ ] . c.   [ corollary : qma ] @xmath83 = \\mathrm{qma}[{\\mathbf{ow}},o(\\log n ) ] = \\mathrm{qma}$ ] .",
    "we note that corollary [ corollary : logarithmictreewidthqmaqcma].[corollary : o1 ] is a consequence of theorem [ theorem : circuitsatisfiability ] , corollary [ corollary : logarithmictreewidthqmaqcma].[corollary : np ] is a consequence of theorem [ theorem : logarithmictreewidthnp ] , and corollary [ corollary : logarithmictreewidthqmaqcma].[corollary : qma ] is a consequence of theorem [ theorem : logarithmictreewidthqma ] . under the plausible assumption that @xmath84 , corollary [ corollary : logarithmictreewidthqmaqcma ] implies that whenever arthur is restricted to be a quantum circuit of logarithmic treewidth , quantum merlin - arthur protocols differ in power with respect to whether the witness provided by merlin is classical or quantum .",
    "we observe that obtaining a similar separation between the power of classical and quantum witnesses when arthur is allowed to be a quantum circuit of polynomial treewidth is equivalent to determining whether @xmath85 .",
    "this question remains widely open .      in section [ section : preliminaries ] we will define basic notions such as quantum circuits , tree decompositions and treewidth .",
    "sections [ section : abstractnetwork ] to [ section : approximatingfeasibility ] will be dedicated to the proof of our main theorem ( theorem [ theorem : circuitsatisfiability ] ) .",
    "the proof of this theorem will be sketched in subsection [ subsection : proofsketch ] . in section [ section : prooflogarithmictreewidthnp ]",
    "we will prove theorem [ theorem : logarithmictreewidthnp ] , and in section [ section : prooflogarithmictreewidthqma ] we will prove theorem [ theorem : logarithmictreewidthqma ] .",
    "we will conclude this paper by making some final considerations and by stating some open problems in section [ section : conclusion ]",
    ".      we will prove theorem [ theorem : circuitsatisfiability ] using a combination of techniques from tensor network theory , structural graph theory and dynamic programming .",
    "we will start by introducing in section [ section : abstractnetwork ] the notion of _ abstract network_. intuitively , an abstract network is a list @xmath86 of finite subsets of positive integers , called _",
    "index sets_. such an abstract network @xmath87 can be naturally associated with a graph @xmath88 .",
    "this graph is obtained by creating a vertex @xmath89 for each index set @xmath90 and by adding @xmath21 edges between two vertices @xmath89 and @xmath91 if and only if @xmath92 .",
    "we will be interested in the process of contracting the vertices of the graph @xmath88 into a single vertex .",
    "such a contraction process will be represented by a data structure called _",
    "contraction tree_. the complexity of a contraction tree will be measured via two parameters : its _ rank _ , and its _ height_. in section [ section : goodcontractiontree ] we will show that if the graph @xmath88 associated with an abstract network @xmath87 has treewidth @xmath4 and maximum degree @xmath93 , then one can efficiently construct a contraction tree for @xmath87 of rank @xmath94 and height @xmath95 ( theorem [ theorem : goodcontractiontree ] ) . as we will argue below , theorem [ theorem : goodcontractiontree ] will play an important role in the proof of our main result .",
    "abstract networks can be used to define both the well known notion of _ tensor network _ ( section [ section : tensornetwork ] ) , and the new notion of _ feasibility tensor network _ ( section [ section : feasibilitytensornetworks ] ) . within this formalism",
    ", a tensor network can be viewed as a pair @xmath96 where @xmath97 is a function that associates a tensor @xmath98 of rank @xmath99 with each index set @xmath100 of @xmath87 .",
    "one can define a notion of contraction for tensor networks with basis on the notion of contraction for abstract networks .",
    "contracting a tensor network @xmath96 yields a complex number @xmath101 , i.e. , a tensor of rank @xmath102 .",
    "the value of the tensor network , denoted by @xmath103 , is defined as the absolute value of @xmath101 .",
    "it can be shown that the problem of computing the acceptance probability of a quantum circuit @xmath1 in which all inputs are initialized can be reduced to the problem of computing the value of a suitable tensor network @xmath104 .",
    "on the other hand , a feasibility tensor network is a pair @xmath105 where @xmath87 is an abstract network and @xmath106 is a function that associates with each index set @xmath90 a _ set _ of tensors @xmath107 of rank @xmath99 .",
    "an initialization of @xmath105 is a function @xmath97 that associates a tensor @xmath108 with each index set of @xmath87 .",
    "each such initialization yields a tensor network @xmath96 .",
    "the value of the feasibility network @xmath105 , is defined as @xmath109 , where @xmath97 ranges over all initializations of @xmath105 . as we will see in section [ section : feasibilitytensornetworks ] , the problem of finding a classical assignment that maximizes the acceptance probability of a quantum circuit with uninitialized inputs can be reduced to the problem of finding an initialization of maximum value for a suitable feasibility tensor network @xmath110 .",
    "let @xmath105 be a feasibility tensor network , and @xmath111 be a real number with @xmath112 . in section [ section : approximatingfeasibility ] we will show that given a contraction tree for @xmath87 of rank @xmath113 and height @xmath114",
    ", one can find in time @xmath115 an initialization @xmath97 of @xmath105 such that @xmath116 ( theorem [ theorem : tensornetworksatisfiability ] ) .",
    "therefore , to obtain a polynomial time algorithm for approximating the value of a feasibility tensor network @xmath105 up to a constant additive factor @xmath7 , we need to keep the rank of the contraction tree bounded by a constant , and its height bounded by @xmath117 .    as mentioned above ,",
    "if the graph @xmath88 has treewidth @xmath4 and maximum degree @xmath93 , then by theorem [ theorem : goodcontractiontree ] one can construct a contraction tree for @xmath87 of rank @xmath94 , and height @xmath118 .",
    "therefore , by setting @xmath119 we can use theorem [ theorem : tensornetworksatisfiability ] to find in time @xmath120 an initialization @xmath97 for @xmath105 such that @xmath121 ( theorem [ theorem : approximationfeasibility ] ) .",
    "finally , let @xmath1 be a quantum circuit with @xmath2 uninitialized inputs , treewidth @xmath4 , and @xmath122 gates drawn from a finite universal set of gates @xmath123 .",
    "let @xmath110 be the feasibility tensor network associated with @xmath1 .",
    "then @xmath124 and the graph @xmath125 has treewidth @xmath4 , and maximum degree bounded by a constant @xmath126 . therefore , as a corollary of theorem [ theorem : approximationfeasibility ] , a classical assignment that maximizes the acceptance probability of @xmath1 up to a @xmath7 additive factor can be found in time @xmath127 . since both @xmath126 and the dimensionality @xmath24 of the qudits over which @xmath1 operates are constant , theorem [ theorem : circuitsatisfiability ] follows .",
    "a @xmath24-dimensional qudit is a unit vector in the hilbert space @xmath128 .",
    "we fix an orthonormal basis for @xmath129 and label the vectors in this basis with @xmath130 .",
    "the @xmath2-fold tensor product of @xmath129 is denoted by @xmath131 .",
    "we denote by @xmath132 the set of all linear operators on @xmath131 .",
    "an operator @xmath133 on @xmath132 is positive semidefinite if all its eigenvalues are non - negative .",
    "a density operator on @xmath2 qudits is a positive semidefinite operator @xmath134 with trace @xmath135 . for a string",
    "@xmath136 we let @xmath137 be the density operator of the state @xmath138 .",
    "a map @xmath139 is positive if @xmath140 is positive semidefinite whenever @xmath141 is positive semidefinite .",
    "the map @xmath142 is completely positive if the map @xmath143 is positive for every @xmath144 , where @xmath145 is the @xmath146 identity matrix .",
    "a quantum gate with @xmath147 inputs and @xmath113 outputs is a linear map @xmath148 that is completely positive , convex on density matrices , and such that @xmath149 for any density matrix @xmath141 .",
    "linear maps satisfying these three properties formalize the notion of physically admissible quantum operation .",
    "we refer to @xcite ( section 8.2.4 ) for a detailed discussion on physically admissible operations . a _ positive - operator valued measure _",
    "( povm ) is a set @xmath150 of positive semidefinite operators such that @xmath151 .",
    "each operator @xmath152 in @xmath153 is called a _ measurement element _ of @xmath153 .",
    "if @xmath153 is a povm then the probability of measuring outcome @xmath154 after applying @xmath153 to @xmath141 is given by @xmath155 .",
    "a single @xmath24-dimensional qudit measurement in the computational basis is defined as the povm @xmath156 .",
    "we adopt the model of quantum circuits with mixed states introduced in @xcite .",
    "let @xmath123 be a finite universal set of quantum gates , and let @xmath126 be the maximum number of inputs plus outputs of a gate in @xmath123 .",
    "a quantum circuit over @xmath123 is a connected directed acyclic graph @xmath157 , of maximum degree at most @xmath126 , where @xmath40 is a set of vertices , @xmath158 a set of edges , @xmath159 is a vertex labeling function and @xmath160 is an injective function that assigns a distinct number to each edge of @xmath1 .",
    "the vertex set is partitioned into a set @xmath161 ( input vertices ) , a set @xmath162 ( output vertices ) , and a set @xmath163 ( internal vertices ) .",
    "each input vertex has in - degree @xmath102 and out - degree @xmath18 , and each output vertex has in - degree @xmath18 and out - degree @xmath102 .",
    "each internal vertex has both in - degree and out - degree greater than @xmath102 .",
    "if @xmath164 is an internal vertex with @xmath21 incoming edges and @xmath165 outgoing edges then @xmath164 is labeled with a quantum gate @xmath166 with @xmath21 inputs and @xmath165 outputs .",
    "each input vertex @xmath164 is either labeled by @xmath167 with an element from the set @xmath168 , indicating that @xmath164 is an initialized input , or with the symbol @xmath169 , indicating that @xmath164 is not initialized .",
    "finally , each output vertex @xmath164 is labeled with an one - qudit measurement element @xmath170 .",
    "we let @xmath171 denote the overall measurement element in @xmath172 defined by @xmath1 .",
    "a quantum circuit @xmath1 with @xmath2 uninitialized inputs and @xmath173 outputs can be regarded as a superoperator @xmath174 . if @xmath25 is a quantum state in @xmath131 then the acceptance probability of @xmath1 when @xmath25 is assigned to the inputs of @xmath1",
    "is defined as @xmath175 $ ] .",
    "a tree is a connected acyclic graph @xmath176 with set of nodes @xmath177 and set of arcs @xmath178 .",
    "a tree decomposition of a graph @xmath179 consists of a pair @xmath180 where @xmath176 is a tree , and @xmath181 is a function that associates a set of vertices @xmath182 with each node @xmath183 , in such a way that    * @xmath184 , * for every edge @xmath185 , there is a node @xmath183 such that @xmath186 , * for every vertex @xmath187 , the set @xmath188 induces a connected subtree of @xmath176 .",
    "the _ width _ of @xmath180 is defined as @xmath189 .",
    "the _ treewidth _",
    "@xmath190 of a graph @xmath47 is the minimum width of a tree decomposition of @xmath47 .",
    "if @xmath157 is a quantum circuit , then the treewidth of @xmath1 is defined as the treewidth of the undirected graph @xmath191 obtained from @xmath1 by forgetting vertex labels , edge labels , and direction of edges .",
    "in this section we will introduce the notion of _ abstract network_. in section [ section : tensornetwork ] we will use abstract networks to model the well known notion of tensor network , a formalism that is suitable for the simulation of quantum circuits . subsequently , in section [ section : feasibilitytensornetworks ] , we will use abstract networks to define the new notion of _ feasibility tensor network _",
    ", a formalism that is suitable for addressing the satisfiability of quantum circuits .",
    "below , we call a possibly empty finite set @xmath100 of positive integers , an _ index set_. we say that each number @xmath154 in an index set @xmath100 is an _",
    "index_.    [ definition : abstractnetwork ] an _ abstract network _ is a finite list @xmath192}\\ ] ] of index sets satisfying the following property : @xmath193    in other words , in an abstract network @xmath87 , each index @xmath154 occurs in precisely two index sets of @xmath87 .",
    "we note that an index set @xmath100 can occur up to two times in an abstract network .",
    "we let @xmath194 denote the size of @xmath87 , i.e. , @xmath173 .",
    "the rank of @xmath87 , denoted by @xmath195 , is defined as the size of the largest index set in @xmath87 .",
    "@xmath196    an abstract network @xmath87 can be intuitively visualized as a graph @xmath88 which has one vertex @xmath89 for each index set @xmath90 , and one edge @xmath197 with endpoints @xmath198 and label @xmath154 , for each pair of index sets @xmath199 with @xmath200 and each index @xmath201 ( fig .",
    "[ figure : abstractnetworkcontraction ] ) . note that our notion of graph of an abstract network admits multiple edges , but no loops .",
    "we say that an abstract network @xmath87 is connected if the graph @xmath88 associated with @xmath87 is connected . in this work",
    "we will only be concerned with connected abstract networks .     of an abstract network",
    "@xmath202 $ ] .",
    "middle : contracting the index sets @xmath203 and @xmath204 yields the abstract network @xmath205 $ ] .",
    "right : after all pairs have been contracted , the only remaining index set is the empty index set . ]",
    "there is a very simple notion of contraction for abstract networks .",
    "abstract network contractions will be used to formalize both the well known notion of tensor network contraction ( section [ section : tensornetwork ] ) , and the notion of feasibility tensor network contraction , which will be introduced in section [ section : feasibilitytensornetworks ] .",
    "we say that a pair of index sets @xmath206 of an abstract network @xmath87 is _ contractible _ if @xmath200 . in this case",
    "the contraction of @xmath206 yields the abstract network @xmath207 where @xmath208 is the symmetric difference of @xmath100 and @xmath209 .",
    "the contraction of a pair of index sets in an abstract network @xmath87 may be visualized as an operation that merges the vertices @xmath89 and @xmath91 in the graph @xmath210 associated with @xmath87 ( fig .",
    "[ figure : abstractnetworkcontraction ] ) .",
    "observe that in a connected abstract network with at least two vertices , there is at least one pair of contractible index sets .",
    "additionally , when contracting a pair @xmath206 of index sets , equation [ equation : conditionnetwork ] ensures that the index set @xmath211 is not in @xmath87 .",
    "thus we have that @xmath212 . starting with an abstract network",
    "@xmath87 we can successively contract pairs of index - sets until we reach an abstract network whose unique index set is the empty set @xmath213 . in graph - theoretic terms , starting from @xmath88 we can successively merge pairs of adjacent vertices until we reach the graph @xmath214)$ ] with a single vertex @xmath215 ( fig .",
    "[ figure : abstractnetworkcontraction ] ) .",
    "below we define the notion of contraction tree , which will be used to address both the problem of simulating an initialized quantum circuit , and the problem of computing the maximum acceptance probability of an uninitialized quantum circuit .",
    "if @xmath176 is a tree , we denote by @xmath216 the set of leaves of @xmath176 .",
    "we say that a node @xmath217 is an _",
    "internal node _ of @xmath176 .",
    "[ definition : carvingdecompositionabstract ] let @xmath218 $ ] be an abstract network .",
    "a _ contraction tree _ for @xmath87 is a pair @xmath219 where @xmath176 is a binary tree and @xmath220 is a function that associates with each node @xmath183 , an index set @xmath221 such that the following conditions are satisfied .",
    "a.   [ definition : carvingdecompositionabstract : conditioni ] @xmath222 and for each @xmath223 , @xmath224 .",
    "b.   [ definition : carvingdecompositionabstract : conditionii ] for each internal node @xmath225 , @xmath226 and @xmath227 .",
    "of the network @xmath228 of fig .",
    "[ figure : abstractnetworkcontraction ] .",
    "]    intuitively , condition @xmath229[definition : carvingdecompositionabstract : conditioni]@xmath230 says that the restriction of @xmath231 to @xmath216 is a bijection from @xmath216 to the index sets occurring in @xmath87 , while condition @xmath229[definition : carvingdecompositionabstract : conditionii]@xmath230 says that it is always possible to contract the index sets labeling the children of each internal node of @xmath176 .",
    "note that the root of @xmath176 is always labeled with the empty index set @xmath213 .",
    "the rank of @xmath219 is the size of the largest index set labeling a node of @xmath176 .",
    "in this section we will show that if @xmath87 is an abstract network whose graph @xmath88 has treewidth @xmath4 and maximum degree @xmath93 , then one can efficiently construct a contraction tree for @xmath87 of rank @xmath94 and height @xmath95 .",
    "more precisely , we will prove the following theorem .",
    "[ theorem : goodcontractiontree ] let @xmath87 be an abstract network such that the graph @xmath88 has treewidth @xmath4 and maximum degree @xmath93 . then one can construct in time @xmath233 a contraction tree @xmath219 for @xmath87 of rank @xmath234 and height @xmath235 .",
    "below we define the notion of rooted carving decomposition , a variant of the notion of carving decomposition introduced by robertson and seymour in @xcite .",
    "[ definition : carvingdecomposition ] a _ rooted carving decomposition _ of a graph @xmath38 is a pair @xmath236 where @xmath237 is a rooted binary tree , and @xmath238 is a bijection mapping each leaf @xmath239 to a single vertex @xmath240 .",
    "observe that the internal nodes of a carving decomposition @xmath236 are unlabeled .",
    "we denote by @xmath241 $ ] the set of nodes of the subtree of @xmath176 rooted at @xmath225 . given a node @xmath183",
    "we let @xmath242=\\gamma({\\mathit{leaves}}(t[u]))=\\{v\\in v\\;|\\;\\exists u\\in { \\mathit{leaves}}(t[u ] ) , \\gamma(u)=v\\}\\ ] ] be the set of vertices of @xmath47 that are associated with some leaf in the subtree of @xmath176 rooted at @xmath225 . for subsets of vertices @xmath39 , let @xmath42 denote the set of edges in @xmath47 with one endpoint in @xmath43 and another endpoint in @xmath44 .",
    "the width of @xmath236 , denoted @xmath243 , is defined as @xmath244,v\\backslash v[u])|.\\ ] ] the carving width of a graph @xmath47 , denoted @xmath245 , is the minimum width of a carving decomposition of @xmath47 .",
    "next , we establish some connections between tree - decompositions and carving decompositions .",
    "let @xmath47 be a graph of treewidth @xmath4 .",
    "using the results in @xcite , one can construct a tree decomposition @xmath180 of @xmath47 of width @xmath246 in time @xmath247 .",
    "from such a tree - decomposition @xmath180 one can construct in time @xmath248 another tree - decomposition @xmath249 of @xmath47 of width @xmath246 and height @xmath250 @xcite .",
    "finally , from @xmath249 one can construct in time @xmath251 a carving decomposition of @xmath47 of width @xmath94 and height @xmath250 @xcite where @xmath93 is the maximum degree of @xmath47 .",
    "we formalize the series of conversions we have just described into the following lemma .",
    "[ lemma : carvinwidthtreewidth ] let @xmath47 be a graph of maximum degree @xmath93 and treewidth @xmath4 .",
    "one can construct in time @xmath252 a rooted carving decomposition of @xmath47 of width @xmath94 , and height @xmath250 .    for the purposes of this work we need a more well behaved notion of carving decomposition , which we call _ contractive carving decomposition_.    [ definition : contractivecarvingdecomposition ]",
    "we say that a rooted carving decomposition @xmath236 of a graph @xmath38 is _ contractive _ if for each internal node @xmath225 of @xmath176 , @xmath253 , v[u.r])\\neq \\emptyset.\\ ] ]    in other words , a rooted carving decomposition is _ contractive _ if for each internal node @xmath225 of @xmath176 there is at least one edge @xmath197 of @xmath47 such that one endpoint of @xmath197 labels a leaf of @xmath254 $ ] and the other endpoint of @xmath197 labels a leaf of @xmath255 $ ] .",
    "the next lemma states that any rooted carving decomposition of width @xmath256 and height @xmath114 can be transformed into a _ contractive _ carving decomposition of width @xmath256 and height @xmath257 .",
    "[ lemma : goodcarving ] let @xmath47 be a connected graph and @xmath236 be a carving decomposition of @xmath47 of width @xmath256 and height @xmath114 . then one can construct in time @xmath258 a contractive carving decomposition of @xmath47 of width @xmath256 and height @xmath257 .",
    "we will prove lemma [ lemma : goodcarving ] in subsection [ subsection : proofoflemmagoodcarving ] . before that",
    ", we will use this lemma to prove theorem [ theorem : goodcontractiontree ] .",
    "[ [ proof - of - theorem - theoremgoodcontractiontree . ] ] * proof of theorem [ theorem : goodcontractiontree ] . *",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath87 be an abstract network such that @xmath259 has treewidth @xmath4 and maximum degree @xmath93 . note that @xmath260 . by lemma [ lemma : carvinwidthtreewidth ] , we can construct a rooted carving decomposition of @xmath88 of width @xmath94 and height @xmath117 . by lemma [ lemma : goodcarving ]",
    "we can convert @xmath236 into a contractive carving decomposition @xmath261 of @xmath88 of width @xmath94 and height @xmath95 .",
    "now , we define a function @xmath262 as follows . for each leaf @xmath225 of @xmath263 labeled with the vertex @xmath264",
    ", we set @xmath265 . therefore , at this point we have that @xmath231 establishes a bijection between leaves of @xmath263 and index sets of @xmath87 .",
    "next , for each internal node @xmath266 we set @xmath267 .",
    "since @xmath261 is a contractive carving decomposition of height @xmath118 , the pair @xmath268 is a contraction tree for @xmath87 of height @xmath118 .",
    "we claim that the rank of @xmath268 is at most @xmath94 . to see this",
    ", note that for each node @xmath225 of @xmath263 , @xmath269 ) } \\iota(u').\\ ] ]    in other words , @xmath221 is constituted by those indices that occur in precisely one leaf of the subtree @xmath270 $ ] rooted at @xmath225 .",
    "@xmath271 $ such that $ j\\in \\iota(u')$}\\right\\}.\\ ] ]    but this implies that @xmath221 is is precisely the set of indices labeling edges of @xmath88 which lie in @xmath272,v\\backslash v[u])$ ] , where @xmath273 = \\{v_{{\\mathcal{i}}}\\in { g}({\\mathcal{n}})\\;|\\ ; \\exists u'\\in { \\mathit{leaves}}(t'[u ] ) , \\gamma(u ' ) = v_{{\\mathcal{i}}}\\}.\\ ] ] since each index @xmath274 labels a unique edge in @xmath88 , we have that @xmath275,v\\backslash v[u])|}.\\ ] ] therefore , the rank of the contraction tree @xmath268 is equal to the width @xmath276 of the carving decomposition @xmath261 ( see equation [ equation : carvingwidth ] ) . since , by construction , @xmath277 , the claim follows .",
    "@xmath278      in this subsection we will prove lemma [ lemma : goodcarving ] , which states that any rooted carving decomposition @xmath236 of width @xmath256 and height @xmath114 of a graph @xmath47 can be transformed into a contractive carving decomposition of width @xmath256 and height @xmath257 .",
    "recall that if @xmath236 is a rooted carving decomposition of a graph @xmath38 then for each node @xmath183 we let @xmath279 $ ] denote the set of nodes associated with the leaves in the subtree of @xmath176 rooted at @xmath225 ( equation [ equation : vu ] ) .",
    "below , we let @xmath280 $ ] denote the subgraph of @xmath47 induced by the vertices in @xmath279 $ ] .    [ proposition : disjointsetssubtree ] let @xmath47 be a connected graph and @xmath236 be a rooted carving decomposition of @xmath47 of width @xmath256 . for each node @xmath225 of @xmath176 , the graph",
    "@xmath280 $ ] has at most @xmath256 connected components .",
    "let @xmath225 be the root of @xmath176 .",
    "since @xmath47 is connected , @xmath280 $ ] has a unique connected component , which is @xmath47 itself .",
    "now let @xmath281 be a node which is not the root of @xmath176 and assume for contradiction that the connected components of @xmath280 $ ] are @xmath282 for some @xmath283 . since @xmath47 is connected , and since there are no edges between distinct connected components @xmath284 and @xmath285 of @xmath280 $ ] , we have that for each @xmath286 , there is at least one edge between a vertex of @xmath284 and a vertex in @xmath287 $ ] . but by equation [ equation : carvingwidth ] , this implies that the width of @xmath236 is at least @xmath21 , contradicting in this way the assumption that the width of @xmath236 is @xmath256 .",
    "@xmath278    let @xmath47 be a connected graph with @xmath2 vertices .",
    "we say that an ordering @xmath288 of the vertices of @xmath47 is a breadth first traversal in @xmath47 if for every @xmath289 with @xmath290 , we have that the distance from @xmath291 to @xmath292 is at most the distance from @xmath291 to @xmath293 . we note that if @xmath288 is a breadth first traversal , then for each @xmath294 , there is an edge connecting @xmath295 to some vertex in @xmath296 .",
    "[ proposition : bipartitewedges ] let @xmath38 be a connected graph with @xmath2 vertices and @xmath256 edges .",
    "there is a contractive carving decomposition of @xmath47 of height @xmath297 and width at most @xmath256 .    since @xmath47 has @xmath256 edges , any rooted carving decomposition of @xmath47 has width at most @xmath256 .",
    "thus we just need to show that some rooted carving decomposition @xmath236 of @xmath47 is contractive .",
    "we let @xmath176 be the unique binary tree with @xmath2 leaves and height @xmath297 . in other words , @xmath176 has @xmath297 internal nodes , and each of these nodes has a child that is a leaf . additionally , if @xmath225 is the internal node of @xmath176 farthest away from the root then both children of @xmath225 are leaves .",
    "now we define the function @xmath298 which is a bijection from the leaves of @xmath176 to the vertices of @xmath47 .",
    "let @xmath299 be a breadth first traversal of the vertices of @xmath47 .",
    "then for each @xmath294 , there is an edge connecting @xmath295 to some vertex in @xmath296 .",
    "let @xmath300 be one of the two leaves of @xmath176 at distance @xmath297 from the root .",
    "we set @xmath301 .",
    "now for each leaf @xmath302 we set @xmath303 if and only if the distance from @xmath225 to the root is equal to @xmath304 ( see fig .",
    "[ figure : trivialcontractivecarvingdecomposition ] ) .     of a graph with @xmath305 vertices . ]",
    "we claim that @xmath236 is contractive .",
    "let @xmath225 be an internal node of @xmath176 .",
    "if both children of @xmath225 are leaves , then both of them are at distance @xmath297 from the root . by definition ,",
    "one of these leaves is @xmath300 , which is labeled with @xmath291 .",
    "the other leaf is labeled with @xmath306 .",
    "since @xmath288 is a breadth first traversal of the vertices of @xmath47 , there is an edge connecting @xmath291 and @xmath306 .",
    "now let @xmath225 be an internal node for which both children are at distance @xmath304 from the root for @xmath307 .",
    "then one of the children of @xmath225 , say @xmath308 , is a labeled with @xmath295 and the other leaf , say @xmath309 is such that @xmath310=\\{v_1, ... ,v_{k-1}\\}$ ] . again , since the sequence @xmath299 is a breadth first traversal of @xmath47 , we have that there is at least one edge from @xmath311=\\{v_k\\}$ ] to @xmath310 $ ] .",
    "this shows that @xmath236 is contractive .",
    "@xmath278    let @xmath38 be a connected graph and let @xmath312 be induced subgraphs of @xmath47 such that @xmath313 for @xmath286 , @xmath314 for @xmath315 , and @xmath316 .",
    "we denote by @xmath317 the graph with vertex set @xmath318 , and whose edge set @xmath319 has one edge @xmath320 for each edge of @xmath47 with one endpoint in some vertex of @xmath284 and another endpoint in some vertex of @xmath285 .",
    "we note that there may be multiple edges between two induced subgraphs @xmath284 and @xmath285 .",
    "let @xmath321 be a contractive carving decomposition of @xmath47 of width at most @xmath256 and , for each @xmath286 , let @xmath322 be a contractive carving decomposition of width at most @xmath256 of @xmath284 .",
    "we denote by @xmath323\\ ] ] the carving decomposition of @xmath47 that is obtained by identifying the root of each @xmath322 with the leaf @xmath225 of @xmath324 for which @xmath325 ( see fig .",
    "[ figure : sumofcarvingdecompositions ] ) .",
    "it is immediate to check that @xmath236 is a contractive carving decomposition of @xmath47 of width at most @xmath256 .    , whose vertices @xmath326 are induced subgraphs of a graph @xmath47 .",
    "middle : @xmath321 is a contractive carving decomposition of @xmath327 .",
    "right : for each @xmath154 , @xmath322 is a contractive carving decomposition of @xmath284 .",
    "@xmath236 is a contractive carvind decomposition of @xmath47 obtained by identifying , for each @xmath154 , the root of @xmath322 with the leaf of @xmath321 labeled with @xmath284 .",
    "if @xmath328 and @xmath322 have width at most @xmath256 , then @xmath236 has width at most @xmath256 . ]",
    "[ observation : verticesedgesplusone ] let @xmath47 be a connected graph with @xmath256 edges",
    ". then @xmath47 has at most @xmath329 vertices .",
    "the proof is by induction on the number of edges . in the base case",
    ", @xmath47 has a unique edge , and therefore the observation holds trivially .",
    "now assume that , for each @xmath330 , the observation holds for every graph with @xmath331 edges , and let @xmath47 be a connected graph with @xmath256 edges .",
    "every such graph @xmath47 can be obtained by adding an edge @xmath197 to a connected graph @xmath332 with @xmath331 edges . by the induction hypothesis",
    ", @xmath332 has at most @xmath256 vertices .",
    "since @xmath47 is connected , at least one of the vertices in @xmath197 belongs to @xmath332 .",
    "therefore @xmath47 has at most @xmath329 vertices .",
    "[ [ proof - of - lemma - lemmagoodcarving ] ] * proof of lemma [ lemma : goodcarving ] * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath38 be a connected graph , and let @xmath236 be a rooted carving decomposition of @xmath47 of width @xmath256 and height @xmath114 .",
    "we will construct a _ contractive _ carving decomposition @xmath261 of @xmath47 of width at most @xmath256 and depth at most @xmath257 .",
    "let @xmath225 be a node of @xmath176 . by proposition [ proposition : disjointsetssubtree ]",
    ", the graph @xmath280 $ ] has at most @xmath256 connected components .",
    "let @xmath333 for @xmath334 be the connected components of @xmath280 $ ] .",
    "let @xmath335 denote the height of node @xmath225 in @xmath176 .",
    "[ claim : contractive ] for each node @xmath225 of @xmath176 and each connected component @xmath336 of @xmath280 $ ] , there exists a _ contractive _ carving decomposition @xmath337 of @xmath336 such that the height of @xmath337 is at most @xmath338 .",
    "we note that claim @xmath339 implies lemma [ lemma : goodcarving ] , since if @xmath225 is the root of @xmath176 and @xmath47 is connected , then the graph @xmath280 $ ] has a single connected component , which is @xmath47 itself .",
    "the proof of claim [ claim : contractive ] is by induction on the height of the node @xmath225 in @xmath176 . in the base case",
    ", @xmath225 is a leaf of @xmath176 . in this case",
    "@xmath280 $ ] consists of a unique connected component @xmath340 which is the vertex @xmath341 of @xmath40 labeling @xmath225 .",
    "and therefore the carving decomposition @xmath342 consists of a unique node @xmath343 labeled with @xmath344 .",
    "now assume that claim [ claim : contractive ] is true for every node of @xmath176 of height at most @xmath114 , and let @xmath225 be a node of height @xmath345 . by the induction hypothesis , each connected component @xmath346 of @xmath347 $ ] has a contractive carving decomposition @xmath348 of height at most @xmath349 .",
    "analogously , each connected component @xmath350 of @xmath351 $ ] has a contractive carving decomposition @xmath352 of height at most @xmath353 .",
    "let @xmath354 be a connected component of @xmath280 $ ] .",
    "then the set of vertices of @xmath354 is the union of the vertex sets of some connected components of @xmath347 $ ] ( say @xmath355 ) , and some connected components of @xmath351 $ ] ( say @xmath356 ) .",
    "note that all edges of @xmath354 that do not belong to some of these components , must connect some vertex of @xmath346 to some vertex of @xmath357 for some @xmath358 and some @xmath359 .",
    "but since the carving decomposition @xmath236 of the graph @xmath47 has width at most @xmath256 , there can be at most @xmath256 such new edges . in other words ,",
    "the graph @xmath360 has at most @xmath256 edges .",
    "since @xmath361 is connected , by observation [ observation : verticesedgesplusone ] we have that @xmath361 has at most @xmath329 vertices . by proposition [ proposition : bipartitewedges ]",
    ", @xmath361 has a contractive carving decomposition @xmath321 of height at most @xmath256 and width at most @xmath256 .",
    "therefore the carving decomposition @xmath362\\ ] ] is contractive and has width at most @xmath256 .",
    "since @xmath321 has height at most @xmath256 , and by assumption , each @xmath348 and @xmath352 has height at most @xmath257 , we have that the height of @xmath337 is at most @xmath363 .",
    "this proves claim [ claim : contractive ] , and therefore also lemma [ lemma : goodcarving ] , by letting @xmath225 be the root of @xmath176 .",
    "in this section we will redefine the well known notion of tensor network in function of abstract networks . within this formalism ,",
    "a tensor network is a pair @xmath96 where @xmath87 is an abstract network , and @xmath97 is a function that associates a tensor @xmath98 of rank @xmath99 with each index set @xmath90 .",
    "we believe that defining tensor networks in this way has the advantage of separating the algorithmic aspects of tensor networks from their quantum aspects .",
    "additionally , the formalism of abstract networks will also be used in section [ section : feasibilitytensornetworks ] to introduce the notion of _ feasibility tensor networks _ which will be used to address the problem of approximating the maximum acceptance probability of quantum circuits with uninitialized inputs .",
    "let @xmath364 . a @xmath24-state tensor with index set @xmath365 is an array @xmath366 consisting of @xmath367 complex numbers .",
    "the entries @xmath368 of @xmath366 are indexed by a sequence of variables @xmath369 , each of which ranges over the set @xmath370 .",
    "we note that if @xmath371 then a tensor with index set @xmath100 is simply a complex number @xmath372 .",
    "if @xmath366 is a tensor with index set @xmath100 then we let @xmath373 be the _ rank _ of @xmath366 .",
    "we denote by @xmath374 the set of all @xmath24-state tensors with index set @xmath100 and by @xmath375 the set of all @xmath24-state tensors .",
    "[ definition : tensornetwork ] a _ tensor network _ is a pair @xmath96 where @xmath87 is an abstract network and @xmath97 is a function that associates with each index set @xmath90 , a tensor @xmath376 .",
    "a tensor network @xmath96 is connected if @xmath87 is connected . in this work",
    "we will only be interested in connected tensor networks .",
    "an important operation involving tensors is the operation of tensor contraction .",
    "if @xmath366 is a tensor with index set @xmath377 and @xmath378 is a tensor with index set @xmath379 then the contraction of @xmath366 and @xmath378 gives rise to the tensor @xmath380 with index set @xmath381 where each entry @xmath382 is defined as    @xmath383    if @xmath96 is a tensor network and @xmath384 is a pair of contractible sets in @xmath87 then we say that the tensor network @xmath385 is obtained from @xmath96 by the contraction of @xmath203 and @xmath204 if @xmath386 , and if @xmath387 satisfies the following conditions .    1 .",
    "2 .   @xmath389 for each @xmath390 .",
    "any connected tensor network with @xmath173 index sets can be contracted @xmath391 times .",
    "the result of this contraction process is a tensor network @xmath392,\\lambda_0)$ ] with a unique index set , namely @xmath213 , which is labeled with a rank-@xmath102 tensor @xmath393 ( that is to say , a complex number ) .",
    "the value of @xmath96 , denoted by @xmath103 , is defined as the absolute value of @xmath393 .",
    "more precisely , @xmath394 .",
    "we observe that the value of a tensor network is well defined , since it does not depend on the order in which the tensors of the network are contracted .",
    "one of the main reasons behind the popularity of tensor networks is the fact that they can be used to simulate quantum circuits .",
    "first , we note that both density operators and quantum gates can be naturally regarded as tensors .",
    "if @xmath141 is a density operator acting on @xmath24-dimensional qudits indexed by @xmath395 , then the tensor @xmath396 associated with @xmath141 is defined as    @xmath397 \\right).\\ ] ]    if @xmath398 is a quantum gate with inputs indexed by @xmath395 and outputs indexed by @xmath399 where @xmath400 , then the tensor @xmath401 associated with @xmath398 is defined as    @xmath402 \\cdot [ \\sigma_{j_1}^{\\dagger}\\otimes ... \\otimes \\sigma_{j_l}^{\\dagger } ] \\right).\\ ] ]    in the sequel , we will not distinguish between gates or density matrices and their associated tensors .",
    "if @xmath403 is a quantum circuit in which all inputs are initialized , then the tensor network @xmath404 associated with @xmath1 is obtained as follows . for each vertex @xmath187 , let @xmath405 be the index set consisting of all integers labeling edges of @xmath1 which are incident with @xmath164 . then we add @xmath405 to @xmath406 and set @xmath407 to be the tensor associated with the gate @xmath408 of @xmath1 .",
    "we say that @xmath409 is the abstract network associated with @xmath1 .",
    "the following proposition , which is well known in tensor - network theory ( see @xcite for a proof ) , establishes a close correspondence between the value of tensor networks and the acceptance probability of quantum circuits .",
    "[ proposition : measurement ] let @xmath1 be a quantum circuit with @xmath2 inputs initialized with the state @xmath73 for some @xmath410",
    ". then @xmath411 .    in other words",
    ", @xmath412 is the acceptance probability of @xmath1 .",
    "the process of computing the value @xmath103 of a tensor network @xmath96 is known as simulation .",
    "given a contraction tree @xmath219 of rank @xmath113 for @xmath87 , the following definition can be used to compute @xmath103 in time @xmath413 .    [ definition : tensornetworksimulation ] let @xmath96 be a tensor network and @xmath219 be a contraction tree for @xmath87 .",
    "a simulation of @xmath96 on @xmath219 is a function @xmath414 satisfying the following conditions :    1 .   for each leaf @xmath225 of @xmath176 , @xmath415 .",
    "2 .   for each internal node @xmath225 of @xmath176 , @xmath416 .    note that if @xmath225 is the root of a contraction tree , then @xmath417 . in this case",
    "the tensor @xmath418 is a rank-0 tensor ( that is , a complex number ) which is obtained by contracting all tensors in @xmath96 .",
    "this implies that @xmath419 . if the contraction tree @xmath219 has rank @xmath113 , then for each node @xmath225 of @xmath176 we have that @xmath420 . in other words , for each @xmath183 , the tensor @xmath418 has rank at most @xmath113 , and for this reason @xmath418 can be represented by @xmath421 complex numbers . in this way",
    ", the simulation @xmath422 can be inductively constructed in time @xmath413 , and therefore , @xmath103 can be computed in time @xmath413 .    by theorem [ theorem : goodcontractiontree ] , if the graph @xmath88 of an abstract network @xmath87 has treewidth @xmath4 and maximum degree @xmath93 , then one can construct in polynomial time a contraction tree for @xmath87 of rank @xmath94 .",
    "therefore , definition [ definition : tensornetworksimulation ] can be used to compute the value @xmath103 of a tensor network @xmath96 in time @xmath423 .",
    "now let @xmath123 be a fixed finite universal set of gates , and let @xmath1 be a quantum circuit of treewidth @xmath4 , whose inputs are initialized with a basis state @xmath73 , and whose gates are drawn from @xmath123 .",
    "let @xmath104 be the tensor network associated with @xmath1 . by proposition",
    "[ proposition : measurement ] , @xmath424 .",
    "therefore , the simulation algorithm described above can be used to compute the acceptance probability of @xmath1 in time @xmath425 , where @xmath426 is the number of vertices of @xmath1 .",
    "we note that this algorithm has the same asymptotic time complexity as the original contraction algorithm for tensor networks devised in @xcite , although our contraction technique based on theorem [ theorem : goodcontractiontree ] is different from that employed in @xcite .",
    "we observe that the fact that the contraction trees constructed in theorem [ theorem : goodcontractiontree ] have logarithmic height is not relevant for the time complexity of the simulation algorithm described above .",
    "nevertheless , as we will see in section [ section : approximatingfeasibility ] , contraction trees of logarithmic height will be essential when devising a polynomial time algorithm for the problem of approximating the maximum acceptance probability of constant - treewidth quantum circuits with uninitialized inputs . even though it is possible to extract contraction trees of constant rank from the contraction sequences defined in @xcite , the contraction trees obtained in this way are not guaranteed to have logarithmic height . therefore , our contraction algorithm can not be directly replaced by the contraction algorithm devised in @xcite when addressing the satisfiability of constant - treewidth quantum circuits .",
    "in section [ section : tensornetwork ] we defined tensor networks in terms of abstract networks and showed how contraction trees can be used to address the problem of computing the value of a tensor network . in this section",
    "we will use abstract networks to introduce _ feasibility tensor networks_. we will then proceed to show that feasibility tensor networks can be used to address the problem of computing an assignment that maximizes the acceptance probability of quantum circuits with uninitialized inputs .",
    "a _ feasibility tensor network _ is a pair @xmath427 where @xmath87 is an abstract network and @xmath428 is a function that associates with each index set @xmath90 a finite set of tensors @xmath429 .",
    "note that the only difference between tensor networks and feasibility tensor networks is that while in the former we associate a tensor with each index set , in the latter we associate a set of tensors with each index set .",
    "if @xmath105 is a feasibility tensor network , then an _ initialization _ of @xmath105 is a function @xmath430 such that @xmath431 for each index set @xmath90 .",
    "intuitively , an initialization @xmath97 chooses one tensor @xmath98 from each set of tensors @xmath107 . observe that for each such an initialization @xmath97 , the pair @xmath96 is a tensor network as defined in section [ section : tensornetwork ] .",
    "the value of a feasibility tensor network is defined as    @xmath432    below we show that the problem of finding an assignment that maximizes the acceptance probability of a quantum circuit with uninitialized inputs can be reduced to the problem of computing an initialization of maximum value for a feasibility tensor network .",
    "therefore , the problem of computing the value of a feasibility tensor network is @xmath9 hard .",
    "the conversion from quantum circuits with uninitialized inputs to feasibility tensor networks goes as follows : each uninitialized input @xmath164 corresponds to the set of tensors @xmath433 . intuitively , this set of tensors consists of all possible values that can be used to initialize @xmath164 . on the other hand ,",
    "each input vertex @xmath164 which is already initialized with a density matrix @xmath434 corresponds to the singleton set @xmath435 .",
    "finally , each gate @xmath101 of the circuit corresponds to the singleton set @xmath436 .",
    "we formalize this construction in definition [ definition : circuitsuninitializedfeasibility ] .",
    "[ definition : circuitsuninitializedfeasibility ] let @xmath437 be a quantum circuit in which some of the inputs are uninitialized . the feasibility tensor network associated with @xmath1 is denoted by @xmath110 , where @xmath438 is the abstract network associated with @xmath1 , and @xmath439 is such that for each @xmath187 , @xmath440    now let @xmath97 be an initialization of the feasibility tensor network @xmath110 . then the tensor network @xmath441 is precisely the tensor network associated with the circuit @xmath1 in which the inputs are initialized with the state    @xmath442    in other words , @xmath443 .",
    "therefore , we have the following observation .",
    "[ observation : quantumcircuitstotensornetworks ] for each quantum circuit @xmath1 , the value @xmath444 of the feasibility tensor network @xmath110 associated with @xmath1 is equal to the maximum acceptance probability @xmath445 of @xmath1 .",
    "in this section we will devise an algorithm that , when given a feasibility tensor network @xmath105 and a real number @xmath446 as input , can be used both to approximate the value @xmath447 up to a @xmath7 additive factor , and to construct an initialization @xmath97 such that @xmath448 .",
    "in particular , our algorithm runs in polynomial time if we are given a contraction tree for @xmath87 of constant rank and logarithmic height . as we saw in section [ section : goodcontractiontree ] if the graph @xmath88 associated with @xmath87 has constant treewidth and constant maximum degree , then a contraction tree with these properties can be efficiently constructed using theorem [ theorem : goodcontractiontree ] .",
    "we start by defining suitable notions of norm and distance for tensors .",
    "if @xmath366 is a tensor with index - set @xmath449 , then the @xmath450 norm of @xmath366 is defined as    @xmath451    where for each @xmath452 , @xmath453 ranges over the set @xmath370 , and @xmath454 is the absolute value of the entry @xmath455 of @xmath366 .",
    "having the definition of norm of a tensor in hands , we define the distance between two tensors @xmath366 and @xmath378 as @xmath456 .",
    "the next step consists in defining a suitable notion of @xmath111-net of tensors .",
    "let @xmath100 be an index set , @xmath457 , and @xmath458 with @xmath459 .",
    "a tensor @xmath460-net is a set @xmath461 of @xmath24-state tensors with index set @xmath100 such that for each @xmath366 in @xmath374 , there exists @xmath462 with @xmath463 .",
    "it is straightforward to construct a @xmath460-net for tensors .",
    "we just need to consider the set of all @xmath24-state tensors with index set @xmath100 in which each entry is a complex number of the form @xmath464 for @xmath465 and @xmath466 integer multiples of @xmath467 .",
    "we observe that we do not need to assume that the tensors in our @xmath460-net correspond to physically realizable operations .",
    "our approximation algorithm does not need this assumption . since a @xmath24-state tensor over the index set @xmath100 has @xmath468 entries , we have the following proposition upper bounding the size of a tensor @xmath460-net .",
    "[ proposition : epsilonnet ] for each index set @xmath100 , each @xmath457 and each @xmath458 with @xmath469 , one can construct a tensor @xmath460-net @xmath461 with at most @xmath470 tensors .",
    "if @xmath366 is a tensor in @xmath374 , then we let @xmath471 be an arbitrary tensor @xmath378 in @xmath461 such that @xmath472 .",
    "going further , if @xmath473 is a set of tensors then we let @xmath474 be the truncated version of @xmath473 .      in this subsection we will address the problem of @xmath7-approximating the value of feasibility tensor networks and the problem of finding @xmath7-optimal initializations for feasibility tensor networks .",
    "first , we define the notion of contraction for pairs of sets of tensors .",
    "let @xmath206 be a pair of index sets with @xmath475 .",
    "let @xmath476 be a finite set of tensors with index set @xmath100 and @xmath477 be a finite set of tensors with index set @xmath209 .",
    "the contraction of @xmath473 and @xmath478 is defined as    @xmath479    subsequently , we define a notion of simulation for feasibility tensor networks that is analog to our definition of simulation for tensor networks introduced in subsection [ subsection : computingvaluetensornetwork ] .",
    "the simulation of a feasibility tensor network @xmath105 on a contraction tree @xmath219 is a function @xmath480 that associates a set of tensors with each node of @xmath176 .",
    "first , with each leaf @xmath225 of @xmath176 such that @xmath481 , we associate the set of tensors @xmath482 . then , with each internal node @xmath225 of @xmath176 , we associate the set of tensors @xmath483 .",
    "we note that the truncation is necessary to keep the size of each set from growing exponentially as the contractions take place .",
    "this construction is given more formally in definition [ definition : truncatedsimulation ] below .",
    "[ definition : truncatedsimulation ] let @xmath105 be a feasibility tensor network and @xmath219 be a contraction tree for @xmath87 .",
    "an @xmath484 of @xmath105 on @xmath219 is a function @xmath485 satisfying the following properties :    1 .   for each leaf @xmath225 of @xmath176 , @xmath486 , 2 .   for each internal node @xmath225 of @xmath176 , @xmath487",
    "intuitively , an @xmath111-simulation @xmath480 is a function that keeps track of all ways of simulating tensor networks @xmath96 where @xmath97 is an arbitrary initialization of @xmath105 . in particular ,",
    "if @xmath225 is the root of @xmath219 then @xmath225 is labeled with a set @xmath488 of complex numbers . for each such complex number @xmath489",
    ", there exists an initialization @xmath97 of @xmath105 such that @xmath490 is an approximation of @xmath491 .",
    "conversely , for each initialization @xmath97 of @xmath105 , there exists some number @xmath492 such that @xmath490 approximates @xmath103 .",
    "therefore , the maximum absolute value @xmath493 of a complex number in @xmath488 is an approximation of @xmath447 .",
    "an actual initialization @xmath97 of @xmath105 such that @xmath494 can be found by backtracking",
    ". theorem [ theorem : tensornetworksatisfiability ] below , which will be proved in subsection [ proof : theorem : tensornetworksatisfiability ] , establishes an upper bound for the time complexity and for the error of the approximation scheme described above .",
    "the error of such process depends exponentially on the height of the contraction tree , while the time complexity depends exponentially on the rank of the contraction tree .",
    "[ theorem : tensornetworksatisfiability ] let @xmath105 be a feasibility tensor network , @xmath219 be a contraction tree for @xmath87 of rank @xmath113 and height @xmath114 , and @xmath111 be a real number with @xmath495 .    1 .   [ tensornetworksatisfiability - itemone ] one can compute a number @xmath493 such that @xmath496 in time @xmath497 .",
    "[ tensornetworksatisfiability - itemtwo ] one can construct in time @xmath498 an initialization @xmath97 of @xmath105 such that @xmath499    we note that to efficiently compute @xmath493 and @xmath97 in theorem [ theorem : tensornetworksatisfiability ] above , we need to have in hands a contraction tree for @xmath87 whose rank is bounded by a constant , and whose height is bounded by @xmath117 . the next theorem ( theorem [ theorem : approximationfeasibility ] )",
    "states that approximately optimal initializations of feasibility tensor networks of constant treewidth and constant maximum degree can be computed in polynomial time .",
    "note that in this case , the existence of a contraction tree of constant rank and logarithmic height is guaranteed by theorem [ theorem : goodcontractiontree ] .",
    "[ theorem : approximationfeasibility ] let @xmath105 be a feasibility tensor network such that the graph @xmath88 has treewidth @xmath4 and maximum degree @xmath93 . for each @xmath7 with @xmath500 , one can compute in time @xmath501 an initialization @xmath97 of @xmath105 such that @xmath502    by theorem [ theorem : goodcontractiontree ] , we can construct a contraction tree for @xmath87 of rank @xmath503 and height @xmath504 . by theorem",
    "[ theorem : tensornetworksatisfiability].[tensornetworksatisfiability - itemtwo ] , we can compute in time @xmath505 an initialization @xmath97 of @xmath506 such that @xmath507 therefore , by setting @xmath119 , we can compute an initialization @xmath97 for @xmath105 such that @xmath508 in time @xmath120 . @xmath278    since the problem of computing a @xmath7-optimal initialization of a quantum circuit can be reduced to the problem of computing a @xmath7-optimal initialization of a feasibility tensor network , our main theorem ( theorem [ theorem : circuitsatisfiability ] ) follows from @xmath509 .",
    "[ [ proof - of - theorem - theoremcircuitsatisfiability ] ] * proof of theorem [ theorem : circuitsatisfiability ] * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath1 be a quantum circuit with @xmath2 uninitialized inputs , treewidth @xmath4 , and @xmath3 gates drawn from a finite universal set of gates @xmath123 .",
    "let @xmath510 be the feasibility tensor network associated with @xmath1 according to definition [ definition : circuitsuninitializedfeasibility ] .",
    "then the graph @xmath511 has treewidth @xmath4 , and maximum degree @xmath126 , where @xmath126 is the maximum number of inputs and outputs of a gate in @xmath123 .",
    "additionally , @xmath512 and , by equation [ equation : assignmentfrominitialization ] , each initialization @xmath97 of @xmath510 corresponds to a classical initialization @xmath513 of @xmath1 such that @xmath514 . using theorem [ theorem : approximationfeasibility ]",
    ", we can compute in time @xmath127 an initialization @xmath97 of @xmath510 such that @xmath515 since @xmath516 , we have @xmath517 . finally , since @xmath126 and @xmath24 are constants , the time complexity of this construction can be simplified to @xmath518 .",
    "@xmath278      in this subsection we will prove theorem [ theorem : tensornetworksatisfiability ] . in the proof we will devise an algorithm to @xmath7-approximate the value of a feasibility tensor network and to compute an initialization which achieves a near optimal value .",
    "we start by stating a couple of auxiliary lemmas . in particular",
    ", the following lemma establishes an upper bound for the distance between the contraction of two given tensors @xmath519 and @xmath520 and the contraction of approximations @xmath521 and @xmath522 of @xmath519 and @xmath520 respectively .",
    "[ lemma : errorcontraction ] let @xmath519 and @xmath521 be tensors with index set @xmath203 and let @xmath520 and @xmath522 be tensors with index set @xmath204 , where @xmath523 .",
    "let @xmath524 and @xmath525 .",
    "then @xmath526    let @xmath527 and @xmath528 be index sets .",
    "let @xmath529 and @xmath530 where @xmath531 and @xmath532 are offset tensors .",
    "since @xmath533 and @xmath534 , we have that @xmath535 and @xmath536 .",
    "let @xmath537 and @xmath538 .",
    "then we have that    @xmath539    by reorganizing the right hand side , @xmath540 is equal to    @xmath541\\ ] ]    the first term of this sum is simply @xmath542 .",
    "the second term can be simplified by noting that @xmath543 , @xmath544 , @xmath545 , @xmath546 and that @xmath547 . additionally , since @xmath548 , there are at most @xmath549 sequences of the form @xmath550 where @xmath551 for each @xmath552 .",
    "therefore , @xmath553 is equal to    @xmath554    @xmath278    we observe that for each three tensors @xmath519 , @xmath520 and @xmath555 , if @xmath556 and @xmath557 then @xmath558 . using this observation ,",
    "the following lemma is a consequence of lemma [ lemma : errorcontraction ] .",
    "[ lemma : errorcontractiontruncated ] let @xmath519 and @xmath521 be tensors with index set @xmath203 , and @xmath520 and @xmath522 be tensors with index set @xmath204 where @xmath559 , @xmath560 and @xmath561 .",
    "let @xmath562 and @xmath563 .",
    "then @xmath564    by our definition of truncation , @xmath565 since @xmath560 and @xmath561 , we have @xmath566 .",
    "therefore , by lemma [ lemma : errorcontraction ] , @xmath567 \\cdot 3d^{2\\cdot r}.\\ ] ] this implies that @xmath568 @xmath278    next , we define the notion of _ partial simulation_. recall that if @xmath176 is a tree , then we denote by @xmath241 $ ] the subtree of @xmath176 rooted at @xmath225 .",
    "[ definition : partialsimulation ] let @xmath105 be a feasibility tensor network , @xmath219 be a contraction tree for @xmath87 and @xmath225 be a node of @xmath176 .",
    "a partial simulation of @xmath105 rooted at @xmath225 is a function @xmath569)\\rightarrow { \\mathbb{t}}(d)$ ] satisfying the following conditions .    1 .   for each leaf @xmath343 of @xmath241 $ ] , @xmath570 .",
    "2 .   for each internal node @xmath343 of @xmath241 $ ] , @xmath571",
    "intuitively , a partial simulation @xmath569)\\rightarrow { \\mathbb{t}}(d)$ ] of @xmath105 can be obtained by the following process .",
    "first , we consider some initialization @xmath97 of @xmath105 .",
    "subsequently , we construct the simulation @xmath414 of the tensor network @xmath96 on the contraction tree @xmath219 . finally , we restrict @xmath422 to the nodes of @xmath241 $ ] . in other words , we set @xmath572)}$ ] .",
    "in particular , we note that if @xmath225 is the root of @xmath176 , then @xmath573 .",
    "the next lemma establishes an upper bound for the error propagation during the process of constructing an @xmath111-simulation for a feasibility tensor network .",
    "[ lemma : errorsimulation ] let @xmath105 be a feasibility tensor network , @xmath219 be a contraction tree for @xmath87 of rank @xmath113 and @xmath485 be an @xmath111-simulation of @xmath105 on @xmath219 .",
    "finally , let @xmath225 be a node of @xmath176 .    1 .   [ item : errorsimulationone ] for each partial simulation @xmath574)\\rightarrow { \\mathbb{t}}(d)}$ ] of @xmath105 rooted at @xmath225 ,",
    "there is a tensor @xmath575 such that @xmath576 .",
    "[ item : errorsimulationtwo ] for each tensor @xmath577 , there is a partial simulation @xmath574)\\rightarrow { \\mathbb{t}}(d)}$ ] of @xmath105 rooted at @xmath225 such that @xmath576 .",
    "the proofs of both lemma [ lemma : errorsimulation].[item : errorsimulationone ] and lemma [ lemma : errorsimulation].[item : errorsimulationtwo ] follow by induction on the height of @xmath225 .",
    "first , we note that since the contraction tree @xmath219 has rank @xmath113 , we have that @xmath578 for each internal node @xmath225 of @xmath176 .",
    "thus , all tensors associated with nodes of @xmath176 have rank at most @xmath113 .",
    "now we proceed with the proof by induction . in the base case , @xmath225 is a leaf and therefore , @xmath579)=\\{u\\}$ ] . in this case , for each partial simulation @xmath580 , the tensor @xmath581 belongs to @xmath582 by definition [ definition : partialsimulation ] .",
    "conversely , for each tensor @xmath583 , the function @xmath580 obtained by setting @xmath584 is a valid partial simulation . now , suppose that the lemma is valid for every node of height at most @xmath114 and let @xmath225 be a node of height @xmath345 .    1 .",
    "let @xmath569)\\rightarrow { \\mathbb{t}}(d)$ ] be a partial simulation .",
    "let @xmath585}$ ] and @xmath586}$ ] be the restrictions of @xmath587 to the nodes of the subtrees @xmath254 $ ] and @xmath255 $ ] respectively .",
    "note that @xmath588 and @xmath589 , and therefore , by definition [ definition : partialsimulation ] , @xmath590 by the induction hypothesis , there exist tensors @xmath591 and @xmath592 such that @xmath593 and @xmath594 by definition [ definition : truncatedsimulation ] , the tensor @xmath595 belongs to @xmath488 . finally , by lemma [ lemma : errorcontractiontruncated ] , @xmath596 2 .",
    "let @xmath366 be a tensor in @xmath488",
    ". by definition [ definition : truncatedsimulation ] , there exist tensors @xmath597 and @xmath598 such that @xmath595 . by the induction hypothesis ,",
    "there exist partial simulations @xmath599)\\rightarrow",
    "{ \\mathbb{t}}(d)$ ] and @xmath600)\\rightarrow { \\mathbb{t}}(d)$ ] such that @xmath601 and @xmath602 now let @xmath603)\\rightarrow { \\mathbb{t}}(d)$ ] be the partial simulation that extends @xmath604 and @xmath605 by one node .",
    "more precisely , restricting @xmath587 to the nodes of @xmath254 $ ] yields @xmath604 , restricting @xmath587 to the nodes of @xmath255 $ ] yields @xmath605 , and the tensor associated by @xmath587 with the node @xmath225 is the contraction of the tensors associated by @xmath604 and @xmath605 with the nodes @xmath309 and @xmath308 respectively .",
    "formally , @xmath587 is defined by setting @xmath606 } = { \\hat{\\lambda}}_{u.r } , \\hspace{0.5 cm }          { \\hat{\\lambda}}_{u}|_{t[u.l ] } = { \\hat{\\lambda}}_{u.l},\\hspace{0.5cm}\\mbox{and}\\ ] ] @xmath607 therefore , by lemma [ lemma : errorcontractiontruncated ] , @xmath608 @xmath278    the next lemma , which is a consequence of lemma [ lemma : errorsimulation ] , states that if @xmath609 is the root of @xmath176 then the maximum absolute value of a complex number in @xmath610 is at most @xmath611 apart from the value @xmath447 of the feasibility tensor network @xmath105 .",
    "[ lemma : truncationwelldefined ] let @xmath105 be a feasibility tensor network and @xmath219 be a contraction tree for @xmath87 of rank @xmath113 and height @xmath114 .",
    "let @xmath485 be an @xmath111-simulation of @xmath105 on @xmath219 .",
    "if @xmath609 is the root of   @xmath176 and @xmath493 is the largest absolute value of a complex number in @xmath610 , then @xmath612 .",
    "first , we note that since @xmath609 is the root of @xmath176 , all elements of @xmath610 are complex numbers , i.e. , rank-0 tensors .    for each initialization @xmath97 of @xmath105",
    "there is a complex number in @xmath610 such that @xmath613 .",
    "conversely , for each @xmath614 there is an initialization @xmath97 of @xmath105 such that @xmath613 .",
    "recall that @xmath447 is defined as @xmath615 where @xmath97 ranges over all initializations of @xmath105 .",
    "therefore , the claim stated above implies that if @xmath493 is the maximum absolute value of a complex number in @xmath610 , then @xmath616    now we proceed to prove our claim .",
    "first , let @xmath97 be an initialization of @xmath105 .",
    "then there exists a partial simulation @xmath617 of @xmath105 rooted at @xmath609 such that @xmath618 , where @xmath422 is the simulation of the tensor network @xmath96 constructed as in definition [ definition : tensornetworksimulation ] .",
    "note that @xmath619 , since @xmath609 is the root of @xmath176 . by lemma [ lemma : errorsimulation].@xmath154",
    ", there exists a complex number @xmath614 such that @xmath620 .",
    "using the fact that @xmath621 for every pair of complex numbers @xmath60 and @xmath30 , we have that @xmath622 .",
    "conversely , let @xmath101 be a complex number in @xmath610 .",
    "by lemma [ lemma : errorsimulation].@xmath623 , there exists a partial simulation @xmath624 of @xmath105 rooted at @xmath609 such that @xmath625 .",
    "since @xmath609 is the root of @xmath176 , there exists an initialization @xmath97 of @xmath105 such that @xmath618 , where @xmath422 is the simulation of the tensor network @xmath96 on @xmath219 constructed according to definition [ definition : tensornetworksimulation ] .",
    "note again that @xmath626 . therefore using the fact that @xmath627 for every pair of complex numbers @xmath60 and",
    "@xmath30 , we have that @xmath622 .",
    "this proves the claim .",
    "@xmath278    finally , we are in a position to prove theorem [ theorem : tensornetworksatisfiability ] .    [ [ proof - of - theorem - theoremtensornetworksatisfiability ] ] * proof of theorem [ theorem : tensornetworksatisfiability ] * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +     + [ tensornetworksatisfiability - itemone ] ) let @xmath105 be a feasibility tensor network and @xmath219 be a contraction tree for @xmath87 of rank @xmath113 and height @xmath114 .",
    "let @xmath628 be the @xmath111-simulation @xmath105 on @xmath219 constructed according to definition [ definition : truncatedsimulation ] .",
    "since @xmath176 is a binary tree with @xmath194 leaves , the total number of nodes in @xmath176 is @xmath629 .",
    "additionally , since @xmath219 has rank @xmath113 , for each node @xmath225 of @xmath176 , the set @xmath488 has at most @xmath630 tensors .",
    "therefore , @xmath480 can be constructed in time @xmath631 .",
    "now let @xmath609 be the root of @xmath176 , and let @xmath493 be the largest absolute value of a complex number in @xmath610 .",
    "then by lemma [ lemma : truncationwelldefined ] , @xmath632 . therefore ,",
    "after having constructed @xmath480 we just need to output @xmath493 .",
    "[ tensornetworksatisfiability - itemtwo ] ) let @xmath609 be the root of @xmath176 and let @xmath101 be the complex number in @xmath610 with largest absolute value @xmath493 .",
    "we construct a simulation @xmath414 of @xmath105 on @xmath219 as follows .",
    "first , we set @xmath633 .",
    "now for each internal node @xmath225 for which @xmath418 has already been determined , let @xmath634 and @xmath635 be respectively the left and right children of @xmath225 .",
    "then we set @xmath636 and @xmath637 where @xmath638 and @xmath639 are respectively tensors in @xmath640 and @xmath641 for which @xmath642 .",
    "we proceed in this way until we have determined @xmath422 on all leaves of @xmath176 .",
    "the searched initialization @xmath97 is then obtained by considering the tensors associated by @xmath422 with the leaves of @xmath176 . in other words , for each leaf @xmath225 labeled with the index set @xmath221 , we set @xmath643 . since @xmath633 , we have that @xmath644 .",
    "since @xmath176 has @xmath629 nodes , once we are given @xmath480 , the construction of the initialization @xmath97 takes time @xmath645 .",
    "since @xmath480 can be constructed in time @xmath631 , the overall time complexity to construct @xmath97 is @xmath631 .",
    "in this section we will prove theorem [ theorem : logarithmictreewidthnp ] , which states that for any constant @xmath7 with @xmath51 , and any quantum circuit @xmath1 with @xmath2 uninitialized inputs , @xmath3 gates , and online - width @xmath52 , it is @xmath0 complete to determine whether @xmath646 or whether @xmath647 .",
    "we note that as an implication of theorem [ theorem : logarithmictreewidthnp ] , we have that @xmath648 = \\mathrm{np}}.$ ] indeed , from the proof of theorem [ theorem : logarithmictreewidthnp ] , it will also follow that @xmath82 = \\mathrm{np}$ ] .",
    "[ [ membership - in - mathrmnp ] ] * membership in @xmath0 : * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as mentioned in the introduction , markov and shi s simulation algorithm @xcite computes ( with polynomially many bits of precision ) the acceptance probability of a quantum circuit of treewidth @xmath4 in deterministic time @xmath649 .",
    "let @xmath1 be a quantum circuit with @xmath2 uninitialized inputs , @xmath57 gates , and treewidth @xmath52 .",
    "given a classical assignment @xmath36 we can use markov and shi s algorithm to compute @xmath650 in time @xmath122 . we accept @xmath30 as a suitable witness if @xmath651 and we reject @xmath30 if @xmath652 .",
    "this shows that the problem of computing a @xmath7-optimal classical witness for a quantum circuit of logarithmic treewidth is in @xmath0 .",
    "since , by equation [ equation : comparisonmeasures ] , the treewidth of any circuit is upper bounded by its online width , we have that the problem of computing a @xmath7-optimal classical witness for a quantum circuit of logarithmic online - width is also in @xmath0 . in summary",
    ", we have just shown that @xmath653 \\subseteq \\mathrm{qcma}[{\\mathbf{tw}},o(\\log n ) ] \\subseteq \\mathrm{np}.\\ ] ]    [ [ mathrmnp - hardness ] ] * @xmath0-hardness : * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to show that the problem of finding a @xmath7-optimal classical assignment for a quantum circuit of logarithmic online - width is @xmath0-hard , we will first consider a probabilistic verifier of logarithmic online - width for the @xmath20-sat problem which has inverse polynomial soundness .",
    "subsequently we will show that the soundness can be amplified to a constant by increasing the online - width of the original verifier by a logarithmic additive factor .",
    "clearly , such hardness result for probabilistic circuits of logarithmic online width implies the same hardness result for quantum circuits of logarithmic online width .",
    "also , since the treewidth of a circuit is always upper - bounded by its online - width , the following sequence of inclusions is implied by the @xmath0-hardness proof provided in this section .",
    "@xmath654 \\subseteq \\mathrm{qcma}[{\\mathbf{tw}},o(\\log n)].\\ ] ]    [ proposition : verificationcircuit ]",
    "let @xmath655 be a @xmath20-sat formula with @xmath2 variables @xmath656 and @xmath657 clauses @xmath658 .",
    "there is a probabilistic circuit @xmath659 of online - width @xmath52 such that the following conditions are satisfied .    1 .   ( completeness )",
    "@xmath660 if @xmath661 is satisfiable then @xmath662 .",
    "( soundness ) @xmath660 if @xmath661 is not satisfiable then @xmath663 .    the circuit @xmath659 simulates the execution of an online verifier that does the following : first it chooses a number @xmath113 from the set @xmath664 at random .",
    "then , when reading the witness provided by merlin , it ignores all bits which assign values to variables that do not belong to @xmath665 , and keeps only those bits which correspond to variables used by @xmath665 .",
    "subsequently it verifies whether @xmath665 is evaluated to true .",
    "if the formula @xmath661 has a satisfying assignment , then the prover can always convince the verifier with probability @xmath18 , since in this case the restriction of a satisfying assignment to the variables occurring in @xmath665 will cause @xmath665 to evaluate to @xmath18 . otherwise ,",
    "if @xmath661 has no satisfying assignment , then no matter what assignment is provided by the prover , there will be at least one clause of @xmath661 which will not be satisfied .",
    "thus the verifier will accept with probability at most @xmath666 .",
    "@xmath278    it remains to show that the same hardness result holds if the soundness in proposition [ proposition : verificationcircuit ] is constant , instead of inverse polynomial .",
    "this can be done by a standard probability amplification argument : first we create polynomially many copies of the original verifier , each with access to independent random bits , and then we consider the majority vote of the answer of all verifiers . we claim that if the original verifier @xmath1 has online - width @xmath256 , then the overall amplified circuit has online - width @xmath667 .",
    "let @xmath668 , and let @xmath669 be an adder with @xmath670 input bits and @xmath671 output bits where @xmath672 .",
    "one of the inputs of @xmath669 is a control bit .",
    "the other @xmath671 inputs of @xmath669 form a counter register .",
    "the circuit @xmath669 increases the value of its counter register by one if the control bit is set to @xmath18 , and does nothing with the input otherwise .",
    "let @xmath673 be a circuit with @xmath671 input bits and one output bit .",
    "the circuit @xmath673 accepts if the value represented by its inputs is greater than @xmath674 , and rejects otherwise .",
    "finally let @xmath675 be a circuit that accepts an input @xmath676 if @xmath677 and rejects otherwise .",
    "then @xmath675 can be implemented as a sequence of sub - circuits @xmath678 , where for each @xmath679 , @xmath680 is an adder with control bit @xmath681 , for each @xmath682 the outputs of @xmath680 are identified with the inputs at the counter register of @xmath683 , the outputs of @xmath684 are identified with the inputs of @xmath673 , and the inputs at the counter register of @xmath685 are set to @xmath102 ( fig .",
    "[ figure : majority - vote ] ) .",
    "now let @xmath659 be the probabilistic circuit of online width @xmath686 considered in proposition [ proposition : verificationcircuit ] .",
    "let @xmath687 be @xmath147 independent copies of the circuit @xmath659 .",
    "finally , let @xmath688 be the circuit obtained from @xmath675 by identifying , for each @xmath679 , the output bit of @xmath689 with the control bit of the sub - circuit @xmath680",
    ". then @xmath690 accepts if and only if at least @xmath674 of the circuits",
    "@xmath689 accept .",
    "for each constant @xmath7 with @xmath51 , we can choose a suitable @xmath691 , such that @xmath690 accepts with probability @xmath18 if the @xmath20-sat formula @xmath661 is satisfiable , and accepts with probability at most @xmath7 if @xmath661 is unsatisfiable . to show that @xmath690 has online - width at most @xmath667",
    ", we note that there is a topological ordering of the gates of @xmath690 which executes all gates of @xmath689 before all gates of @xmath680 , all gates of @xmath680 before all gates of @xmath692 , and all gates of @xmath684 before all gates of @xmath673 ( fig .",
    "[ figure : majority - vote ] ) . @xmath278    . ]",
    "in this section we will prove theorem [ theorem : logarithmictreewidthqma ] , which states that for any constant @xmath7 with @xmath56 , and any quantum circuit @xmath1 with @xmath2 uninitialized inputs , @xmath57 gates and online - width @xmath52 , it is @xmath12-complete to determine whether @xmath693 or whether @xmath694 .",
    "we note that membership in @xmath12 is trivial , since @xmath12 is defined in terms of the quantum satisfiability of quantum circuits of polynomial online - width . on the other hand ,",
    "the proof of @xmath12-hardness will be similar to the proof of @xmath0-hardness for the classical satisfiability of quantum circuits of logarithmic online - width given in section [ section : prooflogarithmictreewidthnp ] .",
    "the only difference is that instead of using a reduction from 3-sat , we will use a reduction from the @xmath12-complete problem @xmath21-local hamiltonian @xcite .",
    "we note that this completeness result implies that @xmath695=\\mathrm{qma}$ ] .",
    "since , by equation [ equation : comparisonmeasures ] , the treewidth of a circuit is always upper bounded by its online width , we also have that @xmath83 = \\mathrm{qma}$ ] .",
    "let @xmath128 .",
    "an operator @xmath696 is called a @xmath21-local hamiltonian if it is expressible in the form @xmath697 where each @xmath698 is an hermitian operator acting on at most @xmath21 qubits .",
    "additionally we assume a normalizing condition requiring both @xmath698 and @xmath699 to be positive semidefinite .",
    "[ definition : localhamiltonianproblem ] let @xmath700 , @xmath701 be a @xmath21-local hamiltonian acting on @xmath2 qubits , and @xmath466 be real numbers such that @xmath702 and @xmath703 for some constant @xmath704 .",
    "the @xmath21-local hamiltonian problem consists in determining whether @xmath705 has an eigenvalue not exceeding @xmath489 , or whether all eigenvalues of @xmath705 are at least @xmath706 .",
    "the @xmath21-local hamiltonian problem was shown to be @xmath12 complete in @xcite .",
    "in particular , the proof that this problem is in @xmath12 follows from a reduction to the problem of approximating the maximum acceptance probability of a quantum circuit with uninitialized inputs .",
    "next , we show that this reduction carry over even if we require the obtained quantum circuits to have logarithmic online - width .",
    "we note that the exposition given below is similar to the one encountered in @xcite , except for some adaptations that take the online - width of the involved circuits into consideration .",
    "[ lemma : localhamiltonianconversion ] let @xmath700 , @xmath701 be a @xmath21-local hamiltonian acting on @xmath2 qubits , and @xmath466 be real numbers such that @xmath702 and @xmath703 for some constant @xmath704 .",
    "then there is a quantum circuit @xmath707 with @xmath2 uninitialized inputs and online - width @xmath52 satisfying the following conditions .    1 .   ( completeness ) if some eigenvalue of @xmath705 is smaller than or equal to @xmath489 , then + @xmath708 .",
    "2 .   ( soundness ) if all eigenvalues of @xmath705 are at least @xmath706 , then @xmath709 .    let @xmath710 be a @xmath21-local hamiltonian .",
    "for each local term @xmath698 we construct a circuit implementing the povm @xmath711 . since @xmath698 can be rewritten as @xmath712 , where @xmath713 are the eigenvectors of @xmath698 , and since @xmath698 acts on a constant number of qubits , the mentioned povm can be implemented by a constant size circuit @xmath714 that acts on the qubits affected by @xmath698 and an auxiliary output qubit .",
    "the action of @xmath714 on the orthogonal system of eigenvectors of @xmath698 is given by @xmath715 the probability of measuring @xmath18 at the output bit of @xmath714 is given by @xmath716    now consider a circuit @xmath707 which implements the following verification process .",
    "first , the verifier selects a number @xmath717 uniformly at random .",
    "subsequently , when reading the witness @xmath718 provided by merlin , the verifier ignores all qubits but those which are affected by @xmath665 .",
    "finally when all relevant qubits have been read , the verifier applies the sub - circuit @xmath665 to these relevant qubits .",
    "the overall acceptance probability of the circuit @xmath707 is given by @xmath719 in particular , if @xmath718 is an eigenvector of @xmath705 with eigenvalue smaller than @xmath489 , then the acceptance probability of @xmath707 is greater than @xmath720 while if every eigenvector of @xmath705 has eigenvalue at least @xmath706 then the acceptance probability of @xmath707 is at most @xmath721 .",
    "the circuit @xmath707 can clearly be implemented in online - width @xmath52 since we just need @xmath52 bits to implement the random choice of @xmath113 .",
    "@xmath278    to prove theorem [ theorem : logarithmictreewidthqma ] , it remains to show that both the soundness and the completeness in lemma [ lemma : localhamiltonianconversion ] can be amplified with only a logarithmic increase in online - width .",
    "let @xmath668 , @xmath722 , and let @xmath723 be a circuit that implements the following variant of the majority function .",
    "let @xmath687 be independent copies of the circuit @xmath707 .",
    "let @xmath725 be the circuit obtained from @xmath723 by identifying the output of @xmath689 with the @xmath154-th input of @xmath723 .",
    "it can be shown ( see @xcite lemma @xmath726 ) that if there exists a witness @xmath727 such that @xmath728 , then there is a witness @xmath729 such that @xmath730 on the other hand , if for every state @xmath727 , @xmath731 , then for every state @xmath732 , the verifier accepts with probability at most @xmath733 . similarly to the circuit computing @xmath675 described in section [ section : prooflogarithmictreewidthnp ] , the circuit @xmath723 can be implemented in @xmath734 as a sequence @xmath735 of adder circuits followed by a comparator circuit @xmath736 which accepts if and only if the value at its input register is at least @xmath737 . as in section [",
    "section : prooflogarithmictreewidthnp ] , this implies that the overall circuit @xmath690 has online - width at most @xmath667 , since we can consider an ordering of the gates of @xmath690 that executes all gates of @xmath689 before the gates of the adder circuit @xmath680 , all gates of @xmath680 before the gates of @xmath692 , and all gates of @xmath684 before all gates of @xmath736 ( fig .",
    "[ figure : majority - vote ] ) . @xmath278",
    "in this work we have introduced the notion of _ feasibility tensor network_. we have shown that the problem of computing a classical assignment @xmath6 that maximizes the acceptance probability of a quantum circuit @xmath1 with @xmath2 uninitialized inputs and @xmath57 gates can be reduced to the problem of finding an initialization of maximum value for a feasibility tensor network . using this reduction ,",
    "we have shown that if @xmath1 has treewidth @xmath4 , then a @xmath7-optimal assignment for @xmath1 can be found in time @xmath738 .",
    "therefore we have provided the first example of quantum optimization problem that can be solved in polynomial time on quantum circuits of constant treewidth .",
    "we have also provided new characterizations of the complexity classes @xmath0 and @xmath12 in terms of merlin - arthur protocols in which the verifier is a circuit of logarithmic treewidth , by showing that @xmath82 = \\mathrm{np}$ ] and that @xmath83 = \\mathrm{qma}$ ] . in other words , we have shown that quantum witnesses are inherently more powerful than classical witnesses for merlin - arthur protocols with verifiers of logarithmic treewidth , assuming @xmath84 .",
    "our main theorem implies that @xmath80 \\subseteq \\mathrm{p}$ ] .",
    "however we were not able to determine whether an analog inclusion can be proved when the verifier has constant width and the witness is allowed to be an arbitrary quantum state .",
    "more precisely , the following question is left open : is @xmath739\\subseteq \\mathrm{p}$ ] ?",
    "the @xmath0-hardness of the problem of computing optimal classical assignments for quantum circuits of logarithmic treewidth imposes some constraints on the possibility of drastically improving the running time of our algorithm .",
    "however we leave the following question open : is the problem of computing @xmath7-optimal classical assignments for quantum circuits in fpt with respect to treewidth ?",
    "more precisely , can this problem be solved in time @xmath740 ?",
    "we observe that while in the case of classical circuits one can determine the existence of a satisfying assignment in time @xmath23 @xcite , the fact that @xmath82 = \\mathrm{np}$ ] implies that in the case of quantum circuits the function @xmath741 should be at least double exponential in @xmath4 , assuming the exponential time hypothesis ( eth ) @xcite .",
    "h.  l. bodlaender .",
    "-algorithms for graphs with small treewidth . in _ proc . of the 14th international workshop on graph - theoretic concepts in computer science _ ,",
    "volume 344 of _ lncs _ , pages 110 , springer , 1989 .",
    "e.  broering and s.  v. lokam .",
    "width - based algorithms for sat and circuit - sat . in _ proc . of the 6th international conference on theory and applications of satisfiability testing _ , volume 2919 of _ lncs _ , pages 162171 .",
    "springer , 2004 .",
    "m. de oliveira oliveira . on the satisfiability of quantum circuits of small treewidth . in _ proc .",
    "of the 10th international computer science symposium in russia _ , volume 9139 of _ lncs _ , pages 157172 , springer , 2015 .",
    "k.  georgiou and p.  a. papakonstantinou .",
    "complexity and algorithms for well - structured k - sat instances . in _ proc . of the 11th international conference on theory and applications of satisfiability testing _ ,",
    "volume 4996 of _ lncs _ , pages 105118 , springer , 2008 .",
    "d.  m. thilikos , m.  j. serna , and h.  l. bodlaender .",
    "constructive linear time algorithms for small cutwidth and carving - width . in _ proc . of the 11th international conference on algorithms and computation _ , volume 1969 of _ lncs _ , pages 192203 , springer , 2000 ."
  ],
  "abstract_text": [
    "<S> it has been known for almost three decades that many @xmath0-hard optimization problems can be solved in polynomial time when restricted to structures of constant treewidth . in this work </S>",
    "<S> we provide the first extension of such results to the quantum setting . </S>",
    "<S> we show that given a quantum circuit @xmath1 with @xmath2 uninitialized inputs , @xmath3 gates , and treewidth @xmath4 , one can compute in time @xmath5 a classical assignment @xmath6 that maximizes the acceptance probability of @xmath1 up to a @xmath7 additive factor . </S>",
    "<S> in particular , our algorithm runs in polynomial time if @xmath4 is constant and @xmath8 . for unrestricted values of @xmath4 </S>",
    "<S> , this problem is known to be complete for the complexity class @xmath9 , a quantum generalization of ma . </S>",
    "<S> in contrast , we show that the same problem is @xmath0-complete if @xmath10 even when @xmath7 is constant .    </S>",
    "<S> on the other hand , we show that given a @xmath2-input quantum circuit @xmath1 of treewidth @xmath10 , and a constant @xmath11 , it is @xmath12-complete to determine whether there exists a quantum state @xmath13 such that the acceptance probability of @xmath14 is greater than @xmath15 , or whether for every such state @xmath16 , the acceptance probability of @xmath14 is less than @xmath7 . as a consequence , under the widely believed assumption that @xmath17 , we have that quantum witnesses are strictly more powerful than classical witnesses with respect to merlin - arthur protocols in which the verifier is a quantum circuit of logarithmic treewidth . </S>"
  ]
}