{
  "article_text": [
    "a clear separation is common between the notions of computing and verification in sequential systems .",
    "a similar separation in the context of distributed systems has been emerging . distributed verification of global properties like minimum spanning trees have been devised  @xcite .",
    "an area of distributed systems that can greatly benefit from this separation is that of self - stabilization .",
    "self - stabilization is the ability of a system to recover from transient faults .",
    "a self - stabilizing distributed system can be started in any arbitrary configuration and must eventually converge to a desired legal behavior .",
    "self - stabilizing algorithms can run a distributed verification algorithm repeatedly to detect the occurrence of faults in the system and take the necessary action for convergence to a legal behavior .",
    "this is the approach we take here in devising a silent - stabilizing dfs algorithm .",
    "the concept of first detecting a fault and then taking the corrective measures for self - stabilization was first introduced by  @xcite ,  @xcite and  @xcite .",
    "the approach taken by katz and perry in  @xcite is that of global detection of faults by a leader node that periodically takes the _ snapshots _ of the global state of the network and resets the system if a fault is detected .",
    "afek , kutten and yung  @xcite , and awebuch et al .",
    "@xcite on the other hand , suggested that the faults in the global state of a system could sometimes be detected by local means - i.e. , by having each node check the states of all its neighbors .",
    "gs and suomela further formalized the idea of local detection of faults in  @xcite .",
    "korman , kutten and peleg  @xcite introduced the concept of _ proof labeling schemes_. a _ proof labeling scheme _ works by assigning a _ label _ to every node in the input network .",
    "the collection of labels assigned to the nodes acts as a locally checkable _ distributed proof _ that the global state of the network satisfies a specific global predicate .",
    "proof labeling scheme _ consists of a pair of algorithms @xmath7 , @xmath8 , where @xmath9 is a _ marker _ algorithm that generates a label for every node and @xmath10 is a _ verifier _ algorithm that checks the _ labels _ of neighboring nodes . in this paper",
    ", we present a _",
    "proof labeling scheme _ for detecting faults in the distributed representation of a dfs spanning tree . for self - stabilization ,",
    "the dfs tree is computed afresh and new labels are assigned to the nodes by the marker on detection of faults .",
    "dijkstra introduced the concept of self - stabilization  @xcite in distributed systems .",
    "self - stabilization deals with the _ faults _ that entail an arbitrary corruption of the state of a system .",
    "these faults are rather severe in nature but do not occur very frequently in reality  @xcite .",
    "+ table  [ table : related work ] summarizes the known complexity results for self - stabilizing dfs algorithms .",
    "collin and dolev presented a silent - stabilizing dfs tree algorithm in  @xcite .",
    "their algorithm works by having each node store its path to the root node in the dfs tree . since the path of a node to the root in a dfs tree can be as long as @xmath3 , the number of nodes in the network , the space complexity of their algorithm is @xmath0 per node , where @xmath2 is the highest degree of a node in the network .",
    "the time complexity of their algorithm under the _ contention _ time model is @xmath11 .",
    "we drop the multiplicative factor of @xmath2 from their time complexity here for the sake of comparison with all the other algorithms that do not count their time under the _ contention _ model .",
    "cournier et al .",
    "presented a snap - stabilizing dfs _ wave _ protocol in  @xcite which snap stabilizes with a space complexity of @xmath12 .",
    "algorithm & space & stabilization time & remarks +  @xcite & @xmath13 & @xmath1 & silent +  @xcite & @xmath12 & 0 & snap stabilizing + & & & _ first _ dfs wave , needs unique ids +  @xcite & @xmath5 & 0 & snap stabilizing + & & & wave takes @xmath14 rounds +  @xcite & @xmath5 & @xmath1 & token circulation , not silent +  @xcite & @xmath5 & @xmath6 & token circulation , not silent +  @xcite & @xmath15 & @xmath1 & token circulation , not silent +  @xcite & @xmath15 & @xmath1 & token circulation , not silent + & & & requires neighbor of neighbor info +  @xcite & @xmath16 & @xmath1 & token circulation , not silent +  @xcite & @xmath15 & @xmath1 & token circulation , not silent + * our results * & @xmath5 & @xmath6 & * two algorithms : silent and * + & & & * token circulation ; * + & & & * both with the same complexity * +    considerable work has been invested in developing self - stabilizing depth - first token circulation algorithms with multiple successive papers improving each other .",
    "all of these algorithms also generate a dfs tree in every token circulation round , however these algorithms are not silent .",
    "self - stabilizing depth - first token circulation on arbitrary rooted networks was first considered by huang and chen in  @xcite .",
    "their algorithm stabilizes in @xmath1 time with a space complexity of @xmath5 bits per node .",
    "subsequently several self - stabilizing dfs token circulation algorithms  @xcite were devised .",
    "all these papers worked on improving the space complexity of  @xcite from @xmath5 to a function of @xmath2 , the highest degree of a node in the network .",
    "the time complexity of all of the above token circulation algorithms  @xcite is @xmath1 rounds , which is much more than the time it takes for one token circulation cycle on a given network .",
    "petit improved the stabilization time complexity of depth - first token circulation to @xmath6 in  @xcite with a space complexity of @xmath5 bits per node .",
    "petit and villain  @xcite presented the first self - stabilizing depth - first token circulation algorithm that works in asynchronous message passing systems .",
    "the main contribution of the current paper is a silent self - stabilizing dfs spanning tree algorithm .",
    "the space complexity of our algorithm is @xmath5 bits per node .",
    "the only other _ silent - stabilizing _",
    "dfs tree algorithm  @xcite has a space complexity of @xmath0 .",
    "dolev et al .",
    "@xcite established a lower bound of @xmath5 bits per node on the memory requirement of silent - stabilizing spanning tree algorithms .",
    "thus , ours is the first memory optimal silent - stabilizing dfs spanning tree algorithm .",
    "the silent - stabilizing dfs construction algorithm is designed in a modular way consisting of separate modules for fault detection and correction .",
    "the distributed verification module of this algorithm can be considered a contribution in itself .",
    "composing self - stabilizing primitives using fair combination of protocols is a well - known technique(see e.g.  @xcite ) to ensure that the resulting protocol is self - stabilizing .",
    "we use this approach of protocol combination to design a self - stabilizing depth - first token circulation algorithm which uses our silent - stabilizing dfs tree as a module of the overall algorithm .",
    "the space and time complexities of our token circulation algorithm are as good as the previously published work on _ fast _ self - stabilizing depth - first token circulation  @xcite .      in the next section ( section  [ sec : definitions ] )",
    ", we describe the model of distributed systems considered in this paper .",
    "that section also includes some basic definitions and notations .",
    "section  [ sec : verification ] addresses the distributed verification algorithm which acts as the _ verifier _ @xmath10 of the proof labeling scheme .",
    "the _ marker _",
    "@xmath9 of the _ proof labeling scheme _ is presented in section  [ sec : marker ] .",
    "section  [ sec : stabilization ] describes the technique used to make the algorithm self - stabilizing .",
    "section  [ sec : analysis ] presents the correctness proofs and performance analysis .",
    "section  [ sec : circulation ] describes a token circulation scheme based on the new silent - stabilizing dfs spanning tree .",
    "a distributed system is represented by a connected undirected graph @xmath17 without self - loops and parallel edges , where each node @xmath18 represents a processor in the network and each edge @xmath19 corresponds to a communication link between its incident nodes .",
    "processors communicate by writing into their own shared registers and reading from the shared registers of the neighboring processors .",
    "the network is assumed to be _",
    "we do not require processors to have unique identifiers .",
    "we do assume the existence of a distinguished processor , called the root of the network .",
    "each node @xmath18 orders its edges by some arbitrary ordering @xmath20 as in  @xcite . for an edge @xmath21 ,",
    "let @xmath22 denote the index of the edge @xmath23 in @xmath24 .",
    "as opposed to collin and dolev  @xcite , we use the ( rather common ) ideal time complexity which assumes that a node reads all of its neighbors in at most one time unit .",
    "our results translate easily to an alternative , stricter , _ contention _ time complexity used by collin and dolev in  @xcite , where a node can access only one neighbor in one time unit .",
    "the time cost of such a translation is a multiplicative factor of @xmath16 , the maximum degree of a node ( it is not assumed that @xmath2 is known to nodes ) .",
    "as is commonly assumed in the case of self - stabilization , each node has only some bounded number of memory bits available to be used . here",
    ", this amount of memory is @xmath5 .",
    "* self - stabilization and silent - stabilization : * a distributed algorithm is self - stabilizing if it can be started in any arbitrary global state and once started , the algorithm converges to a legal state by itself and stays in the legal state unless additional faults occur  @xcite .",
    "a self - stabilizing algorithm is _ silent _ if starting from an arbitrary state it converges to a legal global state after which the values stored in the communication registers do not change , see e.g.  @xcite . while some problems like token circulation are non - silent by nature , many _ input / output _ algorithms allow a silent solution .    *",
    "spanning tree : distributed representation : * a spanning tree @xmath25 of a connected , undirected graph @xmath17 is a tree composed of all the nodes and some of the edges of @xmath26 .",
    "a spanning tree @xmath25 of some graph @xmath26 is represented in a distributed manner by having each node locally mark some of its incident edges such that the collection of marked edges of all the nodes forms a spanning tree of @xmath26 . actually , it is enough that each node marks its edge leading to its parent on the tree in a local variable .",
    "* dfs tree and the _ first _ dfs tree of a graph : * a dfs tree of a connected , undirected graph @xmath17 is the spanning tree generated by a depth first search traversal of @xmath26 . in a dfs traversal , starting from a specified node called the root , all the nodes of the graph are visited one at a time , exploring as far as possible before backtracking , see e.g.  @xcite .",
    "the _ first _",
    "dfs traversal is the one that acts as follows : whenever a node @xmath27 has a set of unexplored edges to choose from , the chosen edge is the edge with the smallest port number in the port ordering @xmath20 .",
    "the tree thus generated is called the _ first dfs _ tree  @xcite . while a connected , undirected graph can have more than one dfs spanning trees , it can have only one _ first dfs _ spanning tree .    *",
    "lexicographic ordering*[sec : lexicordering ] a simple path from the root of a graph @xmath26 to some node @xmath28 can be represented as a string starting with a @xmath29 followed by a sequence of the port numbers of the outgoing edges on the path  @xcite .",
    "given such a string representation of a path , a lexicographic operator @xmath30 can be defined to compare multiple paths of a given node @xmath27 from the root , where @xmath29 is considered the minimum character . in the _ first _ dfs tree of a graph , the path leading from the root to some node @xmath28 is the lexicographically smallest ( w.r.t .",
    "@xmath30 ) among all the simple paths from the root to @xmath27  @xcite .    *",
    "dfs intervals * in a dfs traversal , it is common to assign to each node an interval @xmath31 corresponding to the discovery and finish time of exploration of that node . the discovery time or @xmath32 is the time at which a node is discovered for the first time .",
    "the discovery time of a node @xmath28 is denoted as @xmath33 .",
    "the finish time of node @xmath27 denoted by @xmath34 is the time at which a node has finished exploring all its neighbors .",
    "these intervals have the property that given any two intervals @xmath31 and @xmath35 , either one includes the other or they are totally disjoint . assuming without loss of generality that @xmath36 , we can write this formally as : either @xmath37 or @xmath38  @xcite . in other words ,",
    "the dfs intervals induce a partial order on the nodes of a graph .",
    "we define the following notation to be used throughout :    * @xmath39 denotes the set of neighbors of @xmath27 in @xmath26 .",
    "@xmath40 @xmath41 @xmath42 @xmath43 .",
    "* @xmath44 denotes the @xmath31 _ label _ of @xmath27 . *",
    "@xmath33 denotes the @xmath32 _ label _ of @xmath27 and @xmath34 denotes the @xmath45 _ label _ of @xmath27 .",
    "* relational operator @xmath46 between two intervals @xmath31 and @xmath35 indicates the inclusion of of the first interval in the second one .",
    "for example : @xmath47 indicates that @xmath31 is included in @xmath35 . *",
    "relational operator @xmath48 is defined similarly .",
    "given a graph @xmath17 and the distributed representation of a spanning tree @xmath25 of @xmath26 , the dfs verification algorithm is required to verify that @xmath25 is the _ first _ dfs tree of @xmath26 .",
    "the _ verifier _",
    "@xmath10 takes as input a connected graph @xmath17 where each node @xmath28 bears an @xmath49 label in addition to @xmath27 s parent on @xmath25 .",
    "note that @xmath10 takes @xmath31 labels of nodes as input and is not concerned with how they are generated .",
    "+ we assume that each node can read the labels of all its neighbors in addition to its own label and state",
    ". a node can not look at the state of any of its neighbors , however .",
    "each node @xmath28 periodically reads the labels of all its neighbors and locally computes the following additional information from its own state and label as well as the labels of its neighbors .",
    "each node computes the following _ macros _ to be used for verification .    1 .",
    "there are zero or more neighbors of @xmath27 whose interval includes @xmath27 s interval .",
    "let us call the set of all such nodes the _ neighboring ancestors _ of @xmath27 and denote this set by by @xmath50 .",
    "@xmath51 2 .",
    "the parent of @xmath27 as perceived by the labels : @xmath52 @xmath42 @xmath53 ( @xmath54 @xmath55 @xmath46 @xmath56 ) .",
    "3 .   there are zero or more neighbors of @xmath27 whose interval is included in @xmath27 s interval , let us call the set of all such nodes the _ neighboring descendants _ of @xmath27 and denote this set by @xmath57 .",
    "@xmath58 4 .",
    "a _ child neighbor _ of @xmath27 is a neighboring descendant of @xmath27 whose interval is not included in the interval of any other neighboring descendant of @xmath27 . @xmath59 5 .",
    "@xmath60 @xmath61 @xmath57 is the set of all _ child neighbors _ of @xmath27 .",
    "the subscript @xmath62 in @xmath50 above denotes that the set @xmath50 is computed by the node @xmath27 by just looking at the labels of @xmath27 and those of @xmath27 s neighbors .",
    "the same holds for all the other _ macros _ defined above .",
    "it is worth pointing out that all these are intermediate computations and the data they generate need not be stored on the node .",
    "the verification is performed by having each node compute a set of predicates . if @xmath25 is indeed the _ first _ dfs tree of @xmath26 and the labels on all the nodes are proper ( i.e. they are as if they were generated by an actual _ first _ dfs traversal of the input graph )",
    "; then the verifier * _ accepts _ * continuously on every node until a fault occurs .",
    "if a fault occurs either due to the corruption of the state of some nodes or due to some nodes having incorrect labels , at least one node * _ rejects_*. the node that rejects is called a detecting node . the verifier self - stabilizes",
    "trivially since it runs periodically .",
    "let @xmath63 denote the local variable used to store the parent of @xmath27 in @xmath25 .",
    "following is the set of local predicates that each node has to compute :      1 .",
    "2 .   @xmath66 .      1 .   [ predicate : nonnull ] @xmath67 .",
    "[ predicate : nonempty ] @xmath68 .",
    "[ predicate : sametrees ] @xmath69 .",
    "the parent of @xmath27 on @xmath25 denoted by @xmath63 is the same as @xmath27 s parent as computed by @xmath27 from the labels of @xmath27 and its neighbors .",
    "4 .   [ predicate : childparent ] @xmath44 @xmath46 @xmath70 . 5 .",
    "[ predicate : childanc ] @xmath71 such that @xmath72 ( @xmath70 @xmath46 @xmath56 ) .      1 .",
    "[ predicate : sanity ] @xmath73 .",
    "[ predicate : disjoint ] there is no neighbor of @xmath27 such that its interval is totally disjoint with @xmath27 .",
    "formally + @xmath74 ( @xmath75 ) .",
    "[ predicate : leaf ] if @xmath76 then @xmath77 .",
    "[ predicate : firstlastchild ] if @xmath78 and let @xmath79 denote the list of children of @xmath27 sorted in ascending order of their @xmath32 labels and @xmath80 and @xmath81 be the first and last members of @xmath79 then @xmath82 @xmath83 @xmath84 .",
    "[ predicate : childrenorder ] if @xmath85 and let @xmath86 denote the list of children of @xmath27 sorted in the ascending order of their port numbers in @xmath27 , then @xmath79 and @xmath86 sort the members of @xmath60 in the same order .",
    "[ predicate : childdesc ] let @xmath87 and @xmath88 , @xmath89 , such that @xmath90 and @xmath91 and @xmath92 then @xmath93 .",
    "[ predicate : inout ] @xmath94 such that @xmath87 and @xmath95 are adjacent in @xmath79 and @xmath92 , then @xmath96    the only predicates that deal with the order in which the neighbors of a node are explored are  [ predicate : childrenorder ] and  [ predicate : childdesc ] of section  [ sec : predicates - all ] . omitting these two predicates leaves us with a set of predicates sufficient to verify that @xmath25 is _ some _ dfs tree(may not be same as the initial input to the verifier ) of @xmath26 .",
    "if an algorithm that uses the verifier as a subtask is not concerned about the order , it can simply drop these predicates .",
    "a natural method for assigning the @xmath31 labels is to perform an actual dfs traversal of the network starting from the root .",
    "the required labels can be generated by augmenting some known dfs tree construction algorithm ( e.g.  @xcite ,  @xcite ,  @xcite ) by adding new variables for the labels and specific actions for updating these label variables .",
    "we assume that the dfs construction algorithm of awerbuch  @xcite can be easily translated to shared memory and the resulting algorithm can be easily augmented with actions to update the @xmath32 and @xmath45 labels .",
    "note that translating  @xcite to shared memory is trivial and it decreases the memory from @xmath16 to @xmath97 , if it changes memory at all , since a node does not need to store the _ visited _ message(the message broadcasted by a node to all its neighbors when it is visited for the first time , see  @xcite ) of a neighbor , instead it can read the shared register of the neighbor.the pseudo code of the marker will appear in the full paper .",
    "we have constructed a _ proof labeling scheme _ @xmath98 with a non - stabilizing marker @xmath9 that takes as input a connected graph @xmath26 and assigns @xmath31 labels to every node in @xmath26 .",
    "it also has a verifier @xmath10 that takes as input a labeled ( with @xmath99 intervals ) distributed data structure and verifies whether the input structure is the _ first _ dfs tree .",
    "the proofs for the correctness and the performance of @xmath98 are presented in section  [ sec : analysis ] . in the meanwhile ,",
    "we use them here assuming they are correct .    a simple way to stabilize any input / output algorithm is to run the algorithm repeatedly to maintain the correct output along with a self - stabilizing synchronizer  @xcite .",
    "this however would not be a silent algorithm .",
    "still , let us use this approach to generate a non - silent self - stabilizing algorithm as an exercise , before presenting the silent one .",
    "awerbuch and varghese , in their seminal paper  @xcite , present a transformer algorithm for converting a non - stabilizing input / output algorithm into its self - stabilizing version .",
    "following theorem is taken from the paper of awerbuch and varghese  @xcite :    [ awerbuchvarghesetheorem ] given a non - stabilizing distributed algorithm @xmath100 to compute an input / output relation with a space complexity of @xmath101 and a time complexity of @xmath102 .",
    "the resynchronizer compiler produces a self - stabilizing version of @xmath100 whose time complexity is @xmath103 and whose space complexity is same as that of @xmath100 , where @xmath104 is an upper bound on the diameter of the network .    informally , the transformer that awerbuch and varghese developed to prove the above theorem is a self - stabilizing synchronizer .",
    "the transformer takes as input a non - stabilizing input / output algorithm @xmath100 whose running time and space requirement are @xmath102 and @xmath101 respectively .",
    "another input it takes is @xmath104 which is an _ upper bound _ on the actual diameter @xmath4 of the network . given these inputs , the transformer performs @xmath100 for @xmath102(recall that the transformer is a synchronizer and transforms the network to be synchronous ) .",
    "then it retains the results , performs @xmath100 again and compares the new results to the old ones .",
    "if they are the same , the old results are retained .",
    "if they differ , then some faults occurred , the new results are retained .",
    "this is repeated forever .",
    "since we do not assume the knowledge of @xmath3 ( required for input : @xmath105 ) or @xmath104 , we use a slightly modified version of theorem  [ awerbuchvarghesetheorem ] here , that appeared in  @xcite .",
    "the modified awerbuch varghese theorem presented in  @xcite is as follows :    [ kuttenkormantheorem ] given a non - stabilizing distributed algorithm @xmath100 to compute an input / output relation with a space complexity of @xmath101 and a time complexity of @xmath102 .",
    "the enhanced resynchronizer compiler produces a self - stabilizing version of @xmath100 whose time complexity is @xmath106 for asynchronous networks and @xmath107 for synchronous networks with a space complexity of @xmath108 .    informally , korman et al .",
    "used a better synchronizer plus a simple self - stabilizing algorithm that computes @xmath3 and @xmath4 to prove the above theorem . to obtain a non - silent self - stabilizing dfs construction algorithm",
    ", we just plug the marker @xmath9 of section  [ sec : marker ] into theorem  [ kuttenkormantheorem ] and obtain the following corollary .",
    "[ corollary1 ] there exists a non - silent self - stabilizing dfs construction algorithm that can operate in a dynamic asynchronous network , with a time complexity of @xmath109 and a space complexity of @xmath110 .      before going into the details of achieving silence ,",
    "let us go over how the self - stabilizing synchronizer of the enhanced transformer of theorem  [ kuttenkormantheorem ] helps co - ordinate repeated executions of the marker in the algorithm of corollary  [ corollary1 ] .",
    "a synchronizer simulates a synchronous protocol in an asynchronous network by using a pulse count at each node which is updated in increments of @xmath111 subject to certain rules .",
    "a node @xmath87 executes the @xmath112th step of the algorithm when pulse count at @xmath87 , @xmath113 is equal to @xmath112 .",
    "the synchronizer maintains the _ invariant _ that the pulse count of a node @xmath87 differs from any of its neighbors by at most one .",
    "since the synchronizer module is self - stabilizing , all the nodes may be initialized to an arbitrary pulse count and thus the network may not be synchronized in the beginning .",
    "the stabilization time of the synchronizer module of the enhanced transformer is @xmath6 , thus starting from any arbitrary set of pulse counters , the network is guaranteed to be synchronized after @xmath6 time .",
    "the enhanced transformer waits for _ sufficient _ time for the nodes to get synchronized and then starts the execution of the algorithm to be stabilized , in our case , the marker @xmath9 .",
    "if @xmath114 denotes the pulse count at which all the nodes are synchronized , the nodes run the marker from @xmath114 to @xmath115 . due to an allowed difference of at most @xmath111 between pulse counts of neighboring nodes ,",
    "the maximum difference between the pulse counts of any two nodes is @xmath4 , the diameter of the network .",
    "thus any node with a pulse count of @xmath115 has to wait a maximum of @xmath4 pulses to be sure that all the nodes in the network have written their output  @xcite .",
    "the node with a pulse count of @xmath116 wraps around its pulse count to @xmath117 which destroys the synchronization .",
    "essentially the first node(s ) to _ wrap around _ invoke the _",
    "module of the transformer which brings the nodes back in sync for the next execution of the marker . to make the algorithm silent - stabilizing , we execute the marker(along with the synchronizer ) only once in the beginning to generate the labels .",
    "the silence is achieved by turning the synchronizer off after all the nodes have finished executing the marker . as explained above",
    ", the nodes can easily detect when the marker has finished by looking at their respective pulse counts . when a node reaches a pulse count of @xmath116 , it stops updating its pulse count , thus turning the synchronizer off .",
    "when all the nodes in the neighborhood of a node have reached @xmath116 , it turns on the verifier @xmath10 .",
    "since @xmath10 can detect a fault in exactly one pulse , if one occurs , we can manage without running a synchronizer during the verification .",
    "the verifier keeps running repeatedly until a fault occurs .",
    "if a node @xmath27 detects a fault , it invokes the synchronizer of the enhanced transformer again by dropping @xmath27 s pulse count to @xmath117 .",
    "again , as in case of non - silent algorithm , this invokes a reset which resynchronizes the network and subsequently invokes the marker again . note that the nodes need not know the @xmath105 a priori .",
    "the running time of @xmath9 is a function of @xmath3 , the number of nodes which can be computed in a self - stabilizing manner by the module of the enhanced transformer responsible for computing @xmath3 .",
    "the only communication that takes place at each node during verification is the reading of the shared registers of the neighbors .",
    "the computations performed during verification do not affect the contents of the shared registers at all , thus ensuring silence as defined in  @xcite .",
    "thus we obtain a silent - stabilizing dfs construction algorithm .",
    "the following theorem summarizes our result :    [ thrm : transformermv ] the _ proof labeling scheme _",
    "@xmath98 for a dfs tree implies a silent - stabilizing dfs construction algorithm , that runs in @xmath109 time with a space complexity of @xmath118 .",
    "in this section , we establish the correctness of our algorithm .",
    "the proofs follow easily from the known properties of a dfs tree and the predicates of the verifier .",
    "+ given a labeled ( with @xmath31 labels ) graph @xmath17 and the distributed representation of a spanning subgraph @xmath25 of @xmath26 , the following lemmas holds on @xmath26 , if the local interval predicates ( section  [ sec : predicates ] ) hold true at every node of @xmath26 :    [ lemma : tree ] @xmath25 is a spanning tree of @xmath26 .    in order to prove that a graph is a tree , it is sufficient to prove that it has no cycles and its number of edges is @xmath119 , where @xmath3 is the number of nodes in this graph  @xcite . for the subgraph @xmath25 of @xmath26 to have a cycle ,",
    "one of the ancestors of some node @xmath28 has to mark @xmath27 as its parent .",
    "however , this leads to a contradiction by predicate  [ predicate : childparent ] of section :  [ sec : predicates - nonroot ] which requires that the interval of a node be included in the interval of its parent . applying predicate  [ predicate : childparent ] to @xmath27 and @xmath27 s ancestors",
    ", implies that for an ancestor @xmath87 of @xmath27 which points to @xmath27 as its parent , @xmath120 , a contradiction .",
    "the parent pointer of each node @xmath28 except the root comprises of a single incident edge of @xmath27 and the parent pointer of the root is @xmath121 , therefore there are exactly @xmath3 nodes and @xmath119 edges in @xmath25 .",
    "[ observation : sametree ] the _ macros _ defined in section  [ sec : data ] extract ( periodically ) a perceived tree @xmath122 from the @xmath31 labels of the nodes in @xmath26 .",
    "while input tree @xmath25 is encoded only by the collection of the parent pointers of the nodes , @xmath122 is extracted by having each node compute its perceived parent , denoted by @xmath123 as well as its perceived children , denoted by the set @xmath124 on @xmath122 .",
    "[ lemma : sametree ] for any node @xmath28 , the set of children of @xmath27 in @xmath25 is same as the set of perceived children of @xmath27 in @xmath122 .",
    "the predicate  [ predicate : sametrees ] of section  [ sec : predicates - nonroot ] , ensures that the parent pointer @xmath63 of a node @xmath27 on the input tree @xmath25 is the same as @xmath27 s perceived parent @xmath52 on @xmath122 .",
    "the set of children of a node @xmath27 on @xmath25 is implicitly implied by the parent pointers of @xmath27 s children .",
    "hence , it is sufficient to prove that the set of perceived children of @xmath27 on @xmath122 is the same as those implied by the perceived parent pointers of perceived children of @xmath27 , i.e. , the collection of perceived parents is consistent with the collection of perceived children on @xmath122 .",
    "in what follows , we prove that if a node @xmath27 has a node @xmath125 as its perceived parent ( @xmath126 ) , then @xmath127 .",
    "assume , for contradiction , that the above does not hold .",
    "note that , by the definition of a perceived parent and simple inductive arguments , @xmath125 has the _ narrowest _ interval of any node whose interval includes @xmath44 , i.e. , the interval of @xmath125 does not include the interval of any other node whose interval includes @xmath44 .",
    "having @xmath128 implies that there is a node @xmath129 with @xmath130 and moreover @xmath131 .",
    "this implies that @xmath125 can not be the parent of @xmath27 . in a similar way",
    ", one can prove that if @xmath132 then @xmath27 is the perceived parent of @xmath133 .",
    "following lemma  [ lemma : sametree ] , in the discussion that follows , @xmath60 implies the children of @xmath27 in @xmath25 and vice versa .",
    "[ lemma : disjoint ] for any two children @xmath134 of a node @xmath27 in @xmath25 , the intervals of all the nodes in the subtree of @xmath87 in @xmath25 are disjoint from the intervals of all the nodes in the subtree of @xmath95 in @xmath25 .",
    "the set @xmath79 is the set @xmath60 sorted in the ascending order of the @xmath32 labels of the nodes @xmath135 as defined in section  [ sec : predicates - all ] .",
    "let us assume , without loss of generality , that @xmath136 .",
    "consider a node @xmath137 such that @xmath138 is adjacent to @xmath87 and appears after @xmath87 in @xmath79(possibly @xmath139 ) . applying predicate  [ predicate : inout ] of section  [ sec : predicates - all ] to @xmath87 and @xmath138 , @xmath140 . by predicate  [ predicate : sanity ] of section  [ sec : predicates - all ] , @xmath141 .",
    "thus neither of the two intervals , @xmath142 and @xmath143 , includes the other , i.e. they are totally disjoint . applying predicate  [ predicate : childparent ] of section :  [ sec : predicates - nonroot ] inductively , it is easy to see that the intervals of all the descendants of @xmath87 in @xmath25 are included in @xmath87 s own interval . similarly , the intervals of all the descendants of @xmath138 are included in @xmath138 s interval .",
    "therefore , intervals of all the descendants of @xmath87 are disjoint from the intervals of @xmath138 and all its descendants . by inductively applying the above argument to every adjacent pair of nodes in @xmath79 starting from @xmath138 to @xmath95 , it is easy to show that the subtrees of any two children of a node have disjoint intervals .",
    "[ lemma : cross ] for any two children @xmath134 of some node @xmath27 in @xmath25 , every simple path in @xmath26 from some node in the subtree of @xmath87 to any node in the subtree of @xmath95 in @xmath25 goes through either @xmath27 or @xmath27 s ancestors .",
    "[ ht ! ]",
    "let @xmath138 be some node in the subtree of @xmath87 and @xmath144 be some node in the subtree of @xmath95 .",
    "let us assume , by way of contradiction , that there is a simple path @xmath145 in @xmath26 between @xmath138 and @xmath144 that does not go through @xmath27 or @xmath27 s ancestors .",
    "there are two possibilities :    * @xmath145 goes through a descendant of a sibling of @xmath87 ( possibly @xmath95 ) . * or",
    ", it goes through a descendant of a sibling of an ancestor ( possibly @xmath27 ) of @xmath87 and @xmath95 .",
    "both these cases require an edge to exist in @xmath26 that connects a pair of nodes in two sibling subtrees , known as a _",
    "cross _ edge  @xcite . by lemma  [ lemma : disjoint ] , the intervals of all the nodes in the subtree of some node @xmath146 are disjoint from the intervals of all the nodes in the subtree of a sibling of @xmath146 . thus , the existence of any such edge in @xmath26 is ruled out by predicate  [ predicate : disjoint ] of section  [ sec : predicates - all ] .",
    "the proof of lemma  [ lemma : cross ] shows that there are no cross edges in the input tree @xmath25 which implies that @xmath25 is a dfs(not necessarily the _ first _",
    "dfs ) tree of @xmath26 .",
    "[ thrm : verifierc ] if a graph @xmath147 has every node @xmath28 labeled with its @xmath31 interval and interval assignments are such that all the local interval predicates ( section  [ sec : predicates ] ) hold true at every node , then the spanning tree @xmath25 encoded in a distributed manner in the states of all the nodes of @xmath26 is the _ first _ dfs tree of @xmath26 .",
    "the problem of finding the _ first _ dfs tree of a graph can be thought of as the one of selecting the lexicographically smallest simple path of every node @xmath28 out of all the simple paths from the root to @xmath27 , see  @xcite . let @xmath148 denote the path leading from the root to some node @xmath27 in @xmath25 .",
    "we now prove that for any node @xmath28 , @xmath148 is the lexicographically smallest among all the simple paths from the root to @xmath27 in @xmath26 . by way of contradiction , let us assume that there is another simple path @xmath149 from the root to @xmath27 which is smaller than @xmath148 .",
    "let us assume , @xmath150 , that @xmath148 and @xmath149 are the same up - to(and including ) some node @xmath151 , the @xmath152 node of the common prefix .",
    "let @xmath153 and @xmath154 denote the @xmath155 node of @xmath148 and @xmath149 respectively .    for @xmath149 to be lexicographically smaller than @xmath148 , the edge index ( as defined in section  [ sec : lexicordering ] )",
    "@xmath156 must be smaller than the corresponding index @xmath157 .",
    "there are three possibilities for @xmath149 based on how @xmath154 is related to @xmath151 :    1 .   _",
    "@xmath154 is an ancestor of @xmath151_[ancestor ] : this case is ruled out since any such path will not be a simple path .",
    "@xmath154 is a child of @xmath151_[disjointchildren ] : @xmath154 and @xmath153 are both children of @xmath151 .",
    "according to lemma  [ lemma : cross ] , there is no simple path from @xmath154 to any node in the subtree of @xmath158 that does not go through @xmath151 or any of its ancestors .",
    "since @xmath153 falls on @xmath148 , @xmath27 belongs to the subtree of @xmath153 in @xmath25 .",
    "thus , there is no simple path connecting @xmath154 to @xmath27 that does not go through @xmath151 or its ancestors .",
    "the path from @xmath154 to @xmath27 that goes through either @xmath151 or any of its ancestors would not be a simple path as in case  [ ancestor ] .",
    "therefore , this case is also ruled out .",
    "@xmath154 is a descendant which is not a child of @xmath151 _ :",
    "this case can be further subdivided into two sub cases : 1 .   _",
    "@xmath154 is also a descendant of @xmath159 in addition to being a descendant of @xmath151 _ : this implies that @xmath160 . also , @xmath153 is a child of @xmath151 .",
    "this leads to a contradiction due to local interval predicate  [ predicate : childdesc ] ( section  [ sec : predicates - all ] ) which requires that the edge index of the edge @xmath161 be smaller than the edge index of the edge @xmath162 in @xmath163 .",
    "@xmath154 is a proper descendant of of @xmath151 , but not a descendant of @xmath158 _ :",
    "this case is similar to that of  [ disjointchildren ] .",
    "[ thrm : verifierp ] the verifier @xmath10 described in section  [ sec : verification ] runs in one time unit and requires @xmath5 bits of memory per node .",
    "the running time of @xmath10 follows from the fact that each node needs to look only at the labels of its immediate neighbors in order to compute its predicates .",
    "every node shares its @xmath31 labels with its neighbors .",
    "the maximum value of a label is @xmath164 which can be encoded using @xmath5 bits .",
    "the following theorem establishes the correctness and performance of the marker @xmath9 :    there exists a marker that constructs the _ first _",
    "dfs tree and assigns @xmath31 labels to all the nodes of the input graph @xmath17 in time @xmath6 using @xmath5 bits of memory per node .",
    "as described in section  [ sec : marker ] , it is easy to design a marker that adds new actions to a standard dfs tree construction algorithm for computing the @xmath32 and @xmath45 labels .",
    "the standard dfs tree construction algorithm in shared memory model , without any actions for computing the @xmath31 labels has a space complexity of @xmath15 bits per node .",
    "the variables for updating the @xmath31 labels require @xmath5 bits per node .",
    "therefore the overall space complexity of such a marker is @xmath165 .",
    "+ the actions for computing the labels do not change the values of any of the variables of the original algorithm . also , these actions do not change the algorithm s flow of control .",
    "the addition of these actions can not violate the correctness of the construction algorithm , nor change its time complexity of @xmath6 .",
    "+ it is easy to modify the algorithm such that a node @xmath27 always picks the unvisited neighbor with the smallest port number .",
    "this ensures that the output of the algorithm is the _ first _ dfs tree of the input graph .",
    "the silent - stabilizing dfs tree of section  [ sec : silentstab ] can be combined with a self - stabilizing mutual exclusion algorithm for tree networks to obtain a self - stabilizing token circulation scheme for general networks with a specified root .",
    "self - stabilizing mutual exclusion algorithms that circulate a token in the dfs order on a tree network can be found in  @xcite .",
    "petit and villain presented a space optimal _ snap - stabilizing _ dfs token circulation algorithm for tree networks in  @xcite with a _",
    "waiting time_(see  @xcite for a definition of waiting time ) of @xmath6 .",
    "we can combine our silent - stabilizing dfs tree with the snap stabilizing dfs token circulation protocol of  @xcite using the fair composition method  @xcite to obtain a dfs token circulation for general networks .",
    "the space complexity of  @xcite is @xmath15 and that of our silent - stabilizing dfs tree is @xmath5 .",
    "therefore the space complexity of the resulting self - stabilizing dfs token circulation algorithm is @xmath5 .",
    "+              baruch awerbuch and george varghese .",
    "distributed program checking : a paradigm for building self - stabilizing distributed protocols ( extended abstract ) . in _ proceedings of the 32nd annual symposium on foundations of computer science _ , sfcs 91 , pages 258267 , washington , dc , usa , 1991 .",
    "ieee computer society .",
    "alain cournier , stephane devismes , and vincent villain .",
    "a snap - stabilizing dfs with a lower space requirement . in _ in seventh international symposium on self - stabilizing systems ( sss05 _ ,",
    "pages 3347 , 2005 .",
    "mika gs and jukka suomela . locally checkable proofs . in _ proceedings of the 30th annual acm symposium on principles of distributed computing , podc 2011 , san jose , ca , usa , june 6 - 8 , 2011 _ , pages 159168 , 2011 .",
    "colette johnen and joffroy beauquier .",
    "space - efficient , distributed and self - stabilizing depth - first token circulation . in _ in proceedings of the second workshop on self - stabilizing systems _ , pages 41 , 1995 .",
    "amos korman and shay kutten . distributed verification of minimum spanning trees . in _ proceedings of the twenty - fifth annual acm symposium on principles of distributed computing _ , podc 06 , pages 2634 , new york , ny , usa , 2006 .",
    "amos korman , shay kutten , and toshimitsu masuzawa .",
    "fast and compact self stabilizing verification , computation , and fault detection of an mst . in _ proceedings of the 30th annual acm sigact - sigops symposium on principles of distributed computing _ , podc 11 , pages 311320 , new york , ny , usa , 2011 .",
    "acm .",
    "franck petit .",
    "fast self - stabilizing depth - first token circulation . in _ proceedings of the 5th international workshop on self - stabilizing systems _ , wss 01 , pages 200215 , london , uk , uk , 2001 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> we present algorithms for distributed verification and silent - stabilization of a dfs(depth first search ) spanning tree of a connected network . </S>",
    "<S> computing and maintaining such a dfs tree is an important task , e.g. , for constructing efficient routing schemes . </S>",
    "<S> our algorithm improves upon previous work in various ways . </S>",
    "<S> comparable previous work has space and time complexities of @xmath0 bits per node and @xmath1 respectively , where @xmath2 is the highest degree of a node , @xmath3 is the number of nodes and @xmath4 is the diameter of the network . in contrast </S>",
    "<S> , our algorithm has a space complexity of @xmath5 bits per node , which is optimal for silent - stabilizing spanning trees and runs in @xmath6 time . </S>",
    "<S> in addition , our solution is modular since it utilizes the distributed verification algorithm as an independent subtask of the overall solution . </S>",
    "<S> it is possible to use the verification algorithm as a stand alone task or as a subtask in another algorithm . to demonstrate the simplicity of constructing efficient dfs algorithms using the modular approach </S>",
    "<S> , we also present a ( non - silent ) self - stabilizing dfs token circulation algorithm for general networks based on our silent - stabilizing dfs tree . </S>",
    "<S> the complexities of this token circulation algorithm are comparable to the known ones .    tolerance , self- * solutions , silent - stabilization , dfs , spanning trees </S>"
  ]
}