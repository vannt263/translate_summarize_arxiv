{
  "article_text": [
    "we present the first perfect sampling algorithm ( i.e. unbiased sampling also known as exact simulation ) for the steady - state of so - called generalized jackson networks ( gjns ) .",
    "a precise description of a gjn consists of @xmath0 single server queueing stations , with infinite capacity waiting rooms and each operating under a standard fifo protocol .",
    "the @xmath1-th station receives arrivals from outside the network ( i.e. external arrivals ) according to a renewal process with arrival rate @xmath2 ( note that @xmath3 is possible , meaning that the @xmath1-th station does not receive external arrivals , but we assume that @xmath4 for some @xmath5 ) .",
    "all the renewal arrival processes are independent .",
    "we use @xmath6 to denote the vector of arrival rates .",
    "( throughout this paper all vectors are column vectors unless otherwise stated , and we use @xmath7 to denote transposition . )",
    "all the service requirements are independent .",
    "inter - arrival times and service requirements are all independent .",
    "the mean service time at station @xmath1 is @xmath8 .",
    "we use @xmath9 to denote the vector of service rates",
    ". the service requirements at station @xmath1 are i.i.d .",
    "( independent and identically distributed ) .    immediately after a customer",
    "is served at the @xmath1-th station , he will go to station @xmath10 with probability @xmath11 $ ] for @xmath12 and he will leave the network with probability @xmath13 . we write @xmath14 for the associated @xmath15 substochastic routing matrix .",
    "the network is assumed to be open in the sense that @xmath16 as @xmath17 .",
    "we assume , without the loss of generality , that @xmath18 .",
    "otherwise we can redefine the service requirements via a geometric convolution with success probability equal to @xmath19 and thus represent the network in terms of a model in which @xmath18 .",
    "the so - called flow equations are given by @xmath20 which implies that @xmath21 satisfies @xmath22 .",
    "( note that @xmath23 is well defined because the network is open . )    under the previous setup , the gjn is stable ( in the sense of possessing a steady - state distribution for the workload and queue length processes at each station ) if and only if @xmath24 where the inequality is understood componentwise .    under mild assumptions ( including for example the case of poisson arrivals or phase - type inter - arrival and service times ) we provide the first exact simulation algorithm for a generalized jackson network .",
    "( the precise assumptions , listed as assumptions 1 - 4 , are given in section [ section_description_gjn ] . )",
    "all previous algorithms operate under more - restrictive assumptions relative to what is required in our algorithm .",
    "the more restrictive assumptions include : a ) the networks are markovian ( i.e. inter - arrivals and service times are assumed to be exponential ) , or b ) the networks are bounded ( i.e. the stations are assumed to have rooms with finite buffer sizes ) ; see , for example , @xcite and @xcite .",
    "the work of is closest in spirit to our algorithm here .",
    "the authors in consider a so - called stochastic fluid network ( sfn ) , which is much simpler than a gjn because there is much less randomness in the system .",
    "customers that arrive at station @xmath1 in a sfn bring service requirements which are i.i.d .",
    ", this part is common to the gjn model .",
    "however , the workload is processed and transmitted to the stations in the network in the form of a fluid ; so @xmath25 represents the exact proportion of flow from station @xmath1 to @xmath10 .",
    "therefore , in particular , in a sfn there is no concept of queue - length .",
    "in addition , the sfns treated in has poisson or markov modulated arrivals and so even the arrival processes that we consider here are more general . we extend the algorithm in in order to deal with arbitrary renewal processes ( as opposed to only poisson arrivals ) , the condition on assumption 2 is needed to apply the technique of based on a suitable exponential tilting ( see also and ) , this connection to exponential changes of measure explains the need for assumption 3 .",
    "the algorithm in allows to obtain a sample from the maximum from time 0 to infinity , of a multidimensional random walk with negative drift . here",
    "we extend the algorithm to sample from the running maximum ( componentwise ) , that is , the maximum from time @xmath26 to infinity , for all @xmath27 .",
    "our extension is given in algorithm [ algo last ] .",
    "the real difficulty in doing perfect sampling of gjns , however , arises from the fact that each customer might bring an arbitrarily long sequence of service requirements , because the description of the routing topology admits the possibility of visiting a given station multiple times .",
    "in addition , contrary to sfn s , gjn s are not monotone in their initial condition .",
    "this lack of monotonicity introduces challenges when applying standard perfect simulation techniques .",
    "our strategy is to apply dominated coupling from the past ( dcftp ) , which requires the use of a suitable dominating process simulated backwards in time and in stationarity .",
    "we are able to use sample path comparison results developed by , which allow us to bound the total number of customers in the gjn by a set of suitably defined autonomous queues which are correlated .",
    "in addition , we provide additional sample path comparison results which are of independent interest ( see theorem [ thm_domination ] ) .",
    "we need to simulate , backwards in time , stationary and correlated autonomous queues .",
    "these processes can be represented , componentwise , in terms of an infinite horizon maximum of the difference of superposition of renewal processes ( the difference having negative drift so the infinite horizon maximum is well defined ) .",
    "the fact that the queues are correlated comes from the fact that each jump in the renewal processes may correspond to a departure from one station , and at the same time , an arrival to another station due to the internal routing .",
    "we are able to extend the technique in in order to deal with multidimensional and correlated renewal processes and thus complete the application of the dcftp protocol .",
    "the rest of the paper is organized as follows . in section 2 , we briefly discussing how dcftp operates and describe the gjn . in section 3 , we construct a class of dominating processes which will be useful for our development .",
    "we provide a general overview of our algorithm and the main result of the paper in section 4",
    ". then we proceed by describing how to implement the subroutines of our algorithm in section 5 and finish the paper with a numerical experiment in section 6 .",
    "let us first provide a general description of dcftp . consider a stationary process @xmath28 , we are interested in sampling from @xmath29 .",
    "suppose that the following is available to the simulator :    * a pair of stochastic processes @xmath30 and @xmath31 coupled in such a way that @xmath32 for all @xmath33 , where @xmath34  is any partial order .",
    "* it is possible to simulate @xmath35\\right )   $ ] for a ( finite almost surely ) time @xmath36 in the past such that : a)@xmath37 , and b ) @xmath29 can be obtained from the information used to generate @xmath38 .",
    "a time @xmath36 satisfying the conditions in _ dcftp 2 _ is known as a _",
    "coalescence time_.    generally , at least in the setting of markov processes , the condition that @xmath39 combined with _",
    "dcftp 1 _ above indicates that the value of @xmath40 is known and therefore at least the marginal  evolution of @xmath41 is completely determined , and so is the value of @xmath42 .",
    "however , it is important to keep in mind that the processes @xmath43 and @xmath44 must remain coupled .",
    "the validity of dcftp is proved in @xcite ; the method is an extension of cftp , which was proposed in the seminal paper of .",
    "intuitively , the idea is that if one could simulate the path @xmath45 , from the infinite past , then one could obtain @xmath46 in stationality .",
    "however , since we can simulate @xmath38 in finite time and use this information to reconstruct @xmath29 , we do not need to simulate the process from the infinite past .",
    "obtaining the elements described in bullets _ dcftp 1 - 2 _ above often requires several auxiliary constructions . in our particular application",
    "@xmath41 corresponds to the number in system in each station ( so @xmath41 is a @xmath0-dimensional process ) and we shall set @xmath47 .",
    "the partial order relationship @xmath34  is based on the sum of the coordinates ( i.e @xmath48 if and only if @xmath49 ) .",
    "the process @xmath50 is the one that will require auxiliary constructions , we shall first construct an auxiliary process @xmath51 which dominates @xmath44 based on artificially increasing ( just slightly ) the service requirement of all stations in the gjn .",
    "then we will construct @xmath52 which is a process similar to a gjn , except that the servers will enjoy vacation periods whenever there is no customer waiting in queue to be served .",
    "finally , we will need an additional process , @xmath53 , which is corresponding to the autonomous queues and will allow us to identify the coalescence time @xmath36 .",
    "in this section , we give detailed description and assumptions of the generalized jackson network ( gjn ) we are going to simulate .",
    "we consider a gjn consisting of @xmath0 service stations and each station has a single server . in the rest of our paper",
    ", we shall denote the gjn by @xmath54 .",
    "the basic assumptions of the gjn @xmath54 is as follows : .    * _ arrival times _ : customers arrive ( from the external world ) at station @xmath1 according to some renewal process with i.i.d .",
    "interarrival times @xmath55 .",
    "in particular , @xmath56 where @xmath57 is the arrival time of the @xmath26-th customer of station @xmath1 . the arrival rate @xmath58 is defined as @xmath59 = 1/\\lambda_{i}\\in(0,\\infty]$ ] . if @xmath3 then @xmath60 .",
    "( by convention we let @xmath61 if @xmath3 . ) * _ service times _ : @xmath62 is the service time of the @xmath63-th customer that is served in station @xmath1 .",
    "@xmath64 is a i.i.d .",
    "sequence and independent of the arrival times , routing indicators and service times of the other stations .",
    "the service rate @xmath65 is defined as @xmath66=1/\\mu_{i}$ ] . * _ routing mechanism _ : after finishing service , the @xmath63-th customer in station @xmath1 is assigned with a routing indicator @xmath67 and it will leave the network immediately if @xmath68 , or join the queue of station @xmath69 otherwise .",
    "@xmath70 is a i.i.d .",
    "sequence and independent of the arrival times , service times and routing indicators of the other stations .",
    "the routing probability @xmath71 is defined as @xmath72 .",
    "clearly the sequences @xmath73 together with @xmath74 for @xmath5 are enough to fully describe the evolution of the queueing network , assuming that the initial state of the network is given .",
    "so , let us assume that the network is initially empty and let us write @xmath75 to denote the number of customers in the @xmath1-th service station at time @xmath33 , including both in the queue and in service , for @xmath5 .",
    "as noted in the introduction , the flow equations are given in equation ( [ eq_flow_intro ] ) , the vector @xmath76 s in @xmath21 are called the net - input rates of the gjn .",
    "in addition to the stability condition given in ( [ eq : stability ] ) , throughout this paper we shall impose the following assumptions :    * assumptions : *    1 .",
    "the inter - arrival times have unbounded support .",
    "that is , if @xmath77 then @xmath78 for all @xmath79 .",
    "there exists @xmath80 such that for all @xmath1 @xmath81<\\infty,\\label{eq : as_2}\\\\ \\sup_{t\\geq0}e[\\exp\\left (   \\delta\\left (   \\sigma_{i}\\left (   1\\right ) -t\\right )   \\right )   |\\sigma_{i}\\left (   1\\right )    &   > t]<\\infty.\\nonumber\\end{aligned}\\ ] ] in particular , @xmath82 and @xmath83 have a finite moment generating function for all @xmath1 .",
    "the inter - arrival times and service times can be individually simulated exactly , and moreover , we can simulate from exponentially tiltings ( i.e. the natural exponential family ) associated to these distributions ",
    "see equation ( [ eq : exp_tilt ] ) .",
    "the inter - arrival times and service times have a continuous distribution .",
    "assumptions 1 to 4 are relatively mild and encompass a large class of models of interest including poisson arrivals and phase - type service time distributions ( and mixtures thereof ) .",
    "we shall also discuss immediate extensions to the case of markov modulated gjns .",
    "assumption 1 ensure that the network will empty infinitely often with probability one .",
    "we require the existence of a finite moment generating function because we will apply an extension of a technique developed in , which is based on exponential tiltings and importance sampling , therefore the need for assumption 3 .",
    "we need the uniformity on exponential moments for conditional excess distributions in assumption 2 because we apply a lyapunov bound similar to that developed by .",
    "however , we believe that this uniformity requirement is a technical condition and that our main result holds assuming only that ( [ eq : as_2 ] ) is satisfied for @xmath84 . finally , assumption 4 is introduced for simplicity to avoid dealing with simultaneous events .    under assumptions 1 to 4",
    "we provide an algorithm for sampling from the steady - state queue - length and workload processes at each station in the network .",
    "the number of random variables required to terminate our proposed procedure has a finite moment generating function in a neighborhood of the origin ( in particular the expected termination time of the algorithm is finite ) .",
    "in this section , we shall construct two dominating processes for @xmath85 , related to vacation queues and autonomous queues .      before constructing the two bounding systems , we need to construct an auxiliary upper bound gjn , which we shall denote by @xmath86 .",
    "the auxiliary gjn @xmath86 , is obtained from the original gjn , @xmath54 , by slightly decreasing the service rates at each station while keeping the network stable . in particular , we shall select constants @xmath87 for @xmath5 momentarily .",
    "we define @xmath88 , and correspondingly set @xmath89 for @xmath87 so that @xmath90 , satisfies,@xmath91 componentwise .",
    "it is always possible to pick @xmath87 satisfying ( [ eq : stability_bound ] ) . in order to see this , reason as follows .",
    "first , define @xmath92 ( where @xmath93 is the vector of ones and @xmath80 is to be chosen ) . since @xmath94 and the matrix @xmath95 has non - negative elements",
    ", we can choose @xmath80 small enough so that @xmath96 and therefore @xmath97 .",
    "moreover , by definition @xmath98    the evolution of @xmath86 , initially empty , is also fully described by the sequences @xmath73 and @xmath99 , @xmath5 , where @xmath100 .",
    "let @xmath101 be the number of customers in the @xmath1-th service station at time @xmath33 ( including both in queue and in service ) , for @xmath5 .",
    "as we shall review in theorem [ thm_domination ] , given the same initial condition at time 0 , @xmath102 , for all @xmath33 ; this is intuitive since every customer in @xmath86 needs more service time at every station than in @xmath54 .",
    "we now describe the bonding system consisting of vacation queues , which we shall denote by @xmath103 .",
    "the system @xmath103 evolves following almost the same rules as @xmath86 except that , whenever the @xmath1-th server completes a service _ and _ no customer is waiting in queue to be served , the server enters a vacation period following the same distribution of @xmath104 .",
    "the vacation periods are all independent , and also independent of the arrival times , service times and routing indicators .",
    "if at least one customer is waiting in queue , the server will work on the service requirement of the first customer waiting in queue .    in more detail ,",
    "the vacation periods are not interrupted when a new customer arrives , instead the customer waits until the server finishes its current activity ( current vacation or service ) .",
    "moreover , if after completing a vacation the server still finds the queue empty , a new vacation period starts , and the server keeps taking vacation periods until , upon return of a vacation , the server finds at least one customer present in the queue , waiting to be served .",
    "the evolution of the vacation system @xmath103 , coupled with @xmath86 , is fully described by the sequences @xmath105 @xmath106 , @xmath5 , along with the vacation period sequence @xmath107 .",
    "for each @xmath1 , the sequence @xmath108 is an i.i.d .",
    "copy of the sequence @xmath109 .",
    "the random variable @xmath110 denotes the @xmath63-th vacation period taken by the @xmath1-th server .",
    "let us write @xmath111 to denote the number of customers in the @xmath1-th station at time @xmath33 ( including both in queue and in service ) .",
    "as stated in theorem [ thm_domination ] below , we have that , given the same initial condition at time 0 , @xmath112 for all @xmath33 ; this is intuitive since every customer in @xmath103 keeps the same service time and routing ( relative to @xmath86 ) , but the departure times must occur later due to the vacation periods .      the final bounding system is a set of the so - called autonomous queues which we shall denote by @xmath113 . in this subsection , we shall describe the evolution of this system and provide an expression for its number of customers in queue . in the next subsection",
    ", we shall explain how @xmath113 is coupled with @xmath103 .",
    "define @xmath114 to be the non - delayed renewal process corresponding to the sequence @xmath115 ; that is , defining @xmath116 , by convention we have @xmath117 of course , @xmath118 if @xmath3",
    ".    we let @xmath119 be a sequence of i.i.d .",
    "random variables with the same distribution @xmath120 ( and therefore as @xmath121 ) .",
    "we write @xmath122 and set @xmath123 . then , define a renewal process@xmath124 moreover , for each @xmath5 we define a sequence of i.i.d .",
    "random variables @xmath125 such that @xmath126 for all @xmath127 .",
    "we then define @xmath128    the random variables @xmath129 s and @xmath130 s are all mutually independent and independent of the @xmath131 s for all @xmath5 and @xmath132 .",
    "let @xmath133 be the number of customers in the queue at the @xmath1-th station of @xmath113 . by the definition of autonomous queues",
    ", @xmath134 evolves according to the following stochastic differential equation @xmath135 in simple words , the number of customers in queue at the @xmath1-th station increases when there is an external arrival ( d@xmath136 ) or an arrival ( either virtual or true , see the explanation in section [ section_coupling ] ) from any other station ( @xmath137d@xmath138 ) , and it decreases at time @xmath33 after the completion of an activity ( service or vacation , see the explanation is section [ section_coupling ] ) only if the queue is not empty ( i.e. @xmath139 and d@xmath140 ) .",
    "one nice property of @xmath113 is that we have a convenient expression for @xmath141 , which is essential for our cftp algorithm to work",
    ". let s define @xmath142 recall that @xmath18 so we have that @xmath143 , and thus we also can write @xmath144 in the previous display .",
    "then , one can verify that the ( unique )  solution to equation ( [ sde ] ) is given by ( see for instance , ) @xmath145      in order to describe the coupling between @xmath113 and @xmath103 , let us provide an interpretation of the sde describing @xmath113 .",
    "the evolution of the @xmath1-th queue in @xmath113 can be seen as a single server queue with vacation periods .",
    "customers arrive according to the superposition of the processes @xmath146 and @xmath147 , the server takes a vacation whenever the queue is empty with a distribution which is identical to that of a generic service time .",
    "arriving customers who find the queue empty must wait to be served only until the current vacation epoch finishes .",
    "the difference between @xmath113 and @xmath103 is that in @xmath103 no customers are transferred  from station @xmath1 to @xmath10 at the end of a vacation epoch of server @xmath1 .",
    "note that these types of transfers actually might occur in @xmath113 because it could be the case , for instance , that @xmath148 , @xmath149 and the corresponding @xmath150 so that @xmath151 and a new customer joins the queue at station @xmath10 .",
    "consequently , in @xmath113 there are two types of customers : a ) true customers , as those in @xmath103 , which are the ones that correspond to external arrivals ( i.e. arrivals from the processes @xmath146 for @xmath5 ) , and their corresponding routes through the network , and b ) virtual customers , which does not exist in @xmath103 , are the ones generated by empty stations that transfer customers to other stations by the mechanism just described above .",
    "therefore , to couple @xmath113 and @xmath103 , we essentially need to distinguish between the true and virtual customers in @xmath113 .",
    "recall that the evolution of @xmath113 is fully described by the process @xmath152 ,",
    "@xmath153 and @xmath154 , and @xmath103 by the sequences @xmath155 , @xmath156 and @xmath157 . to describe the coupling of @xmath113 and @xmath103",
    ", we shall explain how to couple the pair of sequences .",
    "roughly speaking , the two systems will share the same external arrivals , and each @xmath158 ( recall that @xmath159 are the inter - renewal times of @xmath153 ) corresponds to a service time @xmath160 when a customer is in service and to a vacation period @xmath161 otherwise .",
    "we provide the details next .    in our algorithm",
    ", we shall first simulate @xmath113 on some finite time interval @xmath162 $ ] , the corresponding processes @xmath163 , @xmath164 and @xmath165 on it , and sequences @xmath155 and @xmath166 .",
    "then , the number of customers @xmath167 of the coupled vacation system @xmath103 evolves according to the following sde : @xmath168 here @xmath169 is the number of customer in service at station @xmath1 at time @xmath33 . in particular , we shall choose a special initial condition for @xmath170 according to the comparison results that we shall explain in section [ sec : comparison ] : @xmath171 the remaining service time of the customer at station @xmath1 is the residual jump time of @xmath153 , i.e. , @xmath172 .",
    "then , the sequences of @xmath173 , @xmath174)@xmath175 can be extracted as follows .",
    "* procedure 0 : coupling of @xmath113 and @xmath103 : *    1 .",
    "input @xmath163 , @xmath164 and @xmath176 for @xmath177 and @xmath178 $ ] .",
    "set @xmath179 , @xmath180 , @xmath181 , and @xmath182 .",
    "2 .   compute @xmath183 and @xmath184 according to and the initial condition .",
    "3 .   for each @xmath1 , while @xmath185 , repeat the following : * @xmath186 ; * if @xmath187 , update @xmath188 and set @xmath189 and @xmath190 .",
    "otherwise , update @xmath191 and set @xmath192 .",
    "* @xmath193 .",
    "the extracted @xmath194 form an i.i.d . sequence and independent of the sequence @xmath155 .",
    "this follows from the strong markov property of the forward recurrence time processes of the renewal processes @xmath152 , @xmath153 and @xmath154 .",
    "now we have a full description of the three systems @xmath86 , @xmath103 and @xmath113 that are coupled with the original gjn @xmath54 , and their corresponding queue length processes .",
    "the following theorem gives the comparison results among the four systems , which are essential in our dcftp algorithm .",
    "its proof is given in the appendix .",
    "[ thm_domination]suppose that the networks @xmath54 , @xmath86 , @xmath103 , and @xmath113 are all initially empty and are coupled as described through section 4.1 to 4.4 , then the following holds :    \\i ) for any @xmath195,@xmath196    \\ii ) moreover , for any @xmath195 , when @xmath197 , then the service station @xmath1 in system @xmath103 must satisfy @xmath198 and @xmath169 .",
    "iii )  the network @xmath103 , driven by the sde ( [ eq : evolution_vacation ] ) , is monotone in the initial condition . in other words , @xmath199 and if @xmath200 @xmath201 @xmath202 satisfy the sdes ( [ eq : evolution_vacation ] ) with initial conditions @xmath203 , @xmath204 ; @xmath205 , @xmath206 , and @xmath207 , then @xmath208 for all @xmath209 .    in the next section",
    "we explain how to use the previous result order to sample from the stationary distribution of @xmath54 , i.e. the joint distribution of customer numbers at each station , the remaining service requirement of the customers in service , and the remaining times to the next external arrivals to each station in steady state .",
    "given the comparison results theorem [ thm_domination ] , we are now ready to given the main procedure of our dcftp algorithm . in the rest of the paper , for any ergodic stochastic process",
    "@xmath210 , we shall denote by @xmath211 its two - sided stationary version .",
    "* main procedure : *    1 .   choose a constant @xmath212 .",
    "initialize @xmath213 .",
    "2 .   simulate the system @xmath113 in steady state and backwards in time from @xmath36 until @xmath214 .",
    "obtain the corresponding processes @xmath215 , @xmath216 , @xmath217 and @xmath218 from @xmath36 to @xmath214 . update @xmath219 .",
    "3 .   initialize a vacation system @xmath220 at time @xmath36 with @xmath221 , all servers occupied ( @xmath222 ) , and the corresponding remaining service time equals to the time from @xmath36 to the next jump time of process @xmath216 .",
    "4 .   compute @xmath223 , forward in time according to in section [ section_coupling ] and compute the corresponding sequences @xmath155 , @xmath224 and @xmath225 according to procedure 0 . 5 .",
    "if there exists @xmath226 $ ] such that @xmath227 for all @xmath1 , then we simulate a gjn @xmath54 forward starting from @xmath228 to time @xmath229 with @xmath230 for all @xmath1 and driven by the sequence @xmath155 and @xmath231 where each @xmath232",
    ". output @xmath233 and terminate . 6 .",
    "otherwise , ( if @xmath234  for @xmath235 $ ] ) , go back to step 2 .",
    "the above procedure can be validated by the following heuristic .",
    "suppose @xmath236 is the stationary vacation system coupled with @xmath237 .",
    "then , according to part ii ) and iii ) of theorem [ thm_domination ] , its queue length process @xmath238 for all @xmath1 and @xmath239 $ ] .",
    "therefore , we can conclude that @xmath240 for all @xmath1 and hence the coupled stationary gjn @xmath54 must be empty at time @xmath241 by part i ) of theorem [ thm_domination ] .",
    "then , we can recover the value of the stationary process @xmath242 for @xmath243 $ ] and the output @xmath244 follows the steady - state distribution .",
    "[ thm_main]the state of the network given by the main procedure , including @xmath29 and the remaining service times at each station , follow the stationary distribution of the target gjn .",
    "moreover , let @xmath245 be the total number of random variables to terminate the main procedure , then there is @xmath80 such that @xmath246 .",
    "step 3 through step 5 in the main procedure can be done according to the coupling mechanism described in section 3.1 , 3.2 , 3.4 , and in particular , procedure 0 .",
    "the most difficult part is the execution of step 2 and we shall explain this in section [ section_step_2 ] .",
    "the proof , which is given at the end of algorithm [ algo last ] , in section [ sec_proof_main ] , mainly constitutes a recapitulation of our development .",
    "this section is devoted to explain how to execute step 2 in main procedure , that is , to simulate a stationary version of @xmath53 backwards in time .",
    "we shall explain this simulation procedure in three steps . in section [ section_step_2].1",
    ", we show a stationary version of @xmath53 can be expressed by a multi - dimensional point process and its maximum .",
    "then , we show the to simulate the point process and its maximum can be reduced to simulating several random walks jointly with their maximum . in the end , in section [ section_step_2].3 ,",
    "we explain how to simulate the random walks and their maximum , following the ideas in .      for each @xmath1 , we define @xmath248 as a two - sided , time stationary , renewal point process with inter - arrival time distribution being i.i.d .",
    "copies of @xmath249 . we write",
    "@xmath250 for the arrival times associated to @xmath248 , so that @xmath251 and define @xmath252\\right )   = \\sum_{n}i\\left (   \\bar{a}\\left (   n\\right ) \\in\\lbrack a , b]\\right )   , \\ ] ] for any @xmath253 .",
    "similarly , we let @xmath254 to be a two - sided , time - stationary version of @xmath255 and write @xmath256 for the arrival times associated to @xmath254 also in increasing order and so that @xmath257 . as before ,",
    "@xmath258\\right )   = \\sum_{n}i\\left (   \\bar{b}_{i}\\left ( n\\right )   \\in\\lbrack a , b]\\right )   .\\ ] ] each @xmath259 is attached to a mark @xmath260 which are i.i.d .",
    "copies of the @xmath261 s .",
    "all the @xmath262 s , the @xmath263 s , and the @xmath264 s are mutually independent",
    ". finally , for any @xmath265 , define @xmath266\\right )   = \\sum_{n}i\\left (   \\bar{b}_{i}\\left ( n\\right )   \\in\\lbrack a , b],\\bar{r}_{i}^{\\prime}\\left (   n\\right )   = j\\right )   .\\ ] ]    intuitively , @xmath267 describes the external arrivals to station @xmath1 , @xmath268 describes the potential departures from station @xmath1 , and @xmath154 describes the potential internal routings from station @xmath1 to @xmath10 . for all @xmath209",
    ", we define @xmath269\\right )   , \\text { } \\bar{n}_{0,i}\\left (   -t\\right )   = -\\bar{n}_{0,i}\\left (   [ -t,0)\\right ) , \\label{eq : two_sided_processes}\\\\ \\bar{d}_{i}\\left (   t\\right )    &   = \\bar{d}_{i}\\left (   [ 0,t]\\right )   , \\text { } \\bar{d}_{i}\\left (   -t\\right )   = -\\bar{d}_{i}\\left (   [ -t,0)\\right ) , \\nonumber\\\\ \\bar{d}_{i , j}\\left (   t\\right )    &   = \\bar{d}_{i , j}\\left (   [ 0,t]\\right )   , \\text { } \\bar{d}_{i , j}\\left (   -t\\right )   = -\\bar{d}_{i , j}\\left (   [ -t,0)\\right ) .\\nonumber\\end{aligned}\\ ] ] and @xmath270 then , @xmath271 is a two - sided stationary process .",
    "finally put for @xmath272 , @xmath273 observe that the for any deterministic time @xmath274 , the process process @xmath275 satisfies the sde ( [ sde ] ) only replacing the renewal processes with their respective stationary versions .",
    "we just need to show that @xmath53 has a unique stationary distribution which is the same as the distribution of @xmath276 and thus we have that @xmath277 is the time - reversed , stationary version of @xmath53 .    [ lemma_lyones_auto]the autonomous queue @xmath278 has a unique stationary distribution and therefore @xmath279 given by ( [ stat_version ] ) is the time - reversed , stationary version of @xmath53 .",
    "_ proof of lemma [ lemma_lyones_auto ] _ : we proceed with a construction procedure similar to the loynes method . for",
    "@xmath235 $ ] and any @xmath280 define @xmath281 we then have that@xmath282 and therefore@xmath283 as @xmath284 we have that @xmath285 and @xmath286 @xmath287 as @xmath284 ( weakly )  and therefore @xmath288 regardless of the initial condition.@xmath289    given the time - reversed , stationary version of @xmath53 , it suffices to simulate @xmath290 jointly with @xmath271 for all @xmath5 .",
    "we note that @xmath292<1 $ ] due to ( [ eq : stability_bound ] ) , therefore , @xmath293 as @xmath294 .",
    "note that @xmath295 to construct a bound for @xmath296 , we will construct a non - increasing process @xmath297 , such that @xmath298 @xmath299 and @xmath300 with probability one .",
    "since @xmath301 is clearly non - decreasing in @xmath302 , our ability to simulate @xmath303 will allow us to sample @xmath304 in finite time .",
    "we now give the definition of @xmath297 .",
    "following ( [ eq : stability_bound ] ) , we can pick @xmath305 small enough so that @xmath306 next we define @xmath307 , @xmath308 and @xmath309 , and split @xmath310 so that @xmath311 finally , we define three non - increasing processes as @xmath312 for all @xmath209 .",
    "observe that by the selection of @xmath313 , @xmath314 , and @xmath315 , all the three processes just defined are non - increasing and go to minus infinity with probability 1 . as a result ,",
    "@xmath316    now we explain how to simulate jointly @xmath317      note that @xmath319 is piecewise linear with jumps , therefore it reaches its maximum only at ( or right before ) the times @xmath320 when it jumps .",
    "so are @xmath153 and @xmath154 .",
    "these results are formalized by the following lemma :    [ lem_aux_eval]for @xmath209 and assuming that @xmath321 in the case of @xmath322 , we have that @xmath323    _ proof of lemma _ [ lem_aux_eval ] : by definition , for any @xmath324 such that @xmath325 , @xmath326 . as a result , @xmath327 and the maximum",
    "is reached at @xmath328 . as @xmath329 , @xmath330 as @xmath331 and @xmath332",
    "we have reach the expression for @xmath333 .",
    "the same argument applies to @xmath334 .",
    "as to @xmath335 , note that @xmath336 and @xmath337 , therefore @xmath338 .",
    "@xmath289    therefore , to simulate the processes @xmath339 and @xmath340 , we only need to observe the processes @xmath341 and @xmath217 at the discrete times when they jump , which can be expressed as random walks .",
    "the random walks have increments @xmath342 defined as @xmath343 and for @xmath344 , @xmath345 for the pair of @xmath346 with @xmath347 , we have that @xmath348 and we can ignore these coordinates .",
    "but in order to keep the notation succinct , let us denote by @xmath349 for @xmath27 , and let @xmath350 observe that @xmath351 is a vector of dimension @xmath352 . to make the notation homogeneous we write @xmath353 for the @xmath10-th coordinate of @xmath351 where @xmath354 .",
    "now we can define a @xmath355-dimensional random walk @xmath356 , for @xmath132 , with @xmath357 .",
    "define its maximum process as @xmath358 following lemma _ _ [ lem_aux_eval ] , to simulate @xmath359 is equivalent to simulate @xmath360 jointly .",
    "fortunately , there is an algorithm that allows us to carry out this simulation problem for @xmath361 , adapted from work of and , we provide details here for completeness .    *",
    "remark : * in the following sections we shall simulate @xmath362 , which is equivalent to simulating the sequence @xmath363 assuming that @xmath364 . in the end , the random variable @xmath365 can be simulated independently from everything else .",
    "let @xmath366 be the coordinate of the random walk corresponding to @xmath367 .",
    "we have that either @xmath368 when @xmath369 , or @xmath370 < 0 $ ] . for those coordinates",
    "for which @xmath371 we have that @xmath372 and there is nothing to do .",
    "so , let us assume for simplicity and without loss of generality that @xmath373   < 0 $ ] for all @xmath374",
    ".    define for each @xmath375@xmath376 , \\ ] ] and set @xmath377   } p\\left ( w_{1}\\left (   k\\right )   \\in dy_{1}, ... ,w_{d}\\left (   k\\right )   \\in dy_{d}\\right )   , \\nonumber\\end{aligned}\\ ] ] where @xmath378 and @xmath379 .",
    "moreover , we impose the following assumption for simplicity .",
    "* assumption 2b ) : * for each @xmath1 there exists @xmath380 such that @xmath381    * remark : * assumption 2b ) is a strengthening of assumption 2",
    ". we can carry out our ideas under assumption 2 following as we explain next .",
    "first , instead of ( @xmath382 , given a vector @xmath383 with non - negative components that we will explain how to choose momentarily , consider the process @xmath384 and @xmath385 defined by @xmath386 note that we can simulate @xmath387 if we are able to simulate @xmath388 .",
    "now , note that @xmath389 is strictly convex and that @xmath390 so there exists @xmath391 large enough to force the existence of @xmath392 such that @xmath393=1 $ ] , but at the same time small enough to keep @xmath394   < 0 $ ] ; again , this follows by strict convexity of @xmath389 at the origin .",
    "so , if assumption a3b ) does not hold , but assumption a3 ) holds , one can then execute algorithm [ algo sampling m_0 ] based on the process @xmath384 .",
    "* *      we will describe the construction of a pair of sequences of stopping times ( with respect to the filtration generated by @xmath396 ) , denoted by @xmath397 and @xmath398 , which track certain downward and upward milestones in the evolution of @xmath399 .",
    "we follow similar steps as described in and .",
    "these milestone events  will be used in the design of our proposed algorithm .",
    "the elements of the two stopping times sequences interlace with each other ( when finite ) and their precise description follows next .",
    "we start by fixing any @xmath400 .",
    "eventually , we shall choose @xmath401 suitably large as we shall discuss in in equation ( [ eq : assumption_m ] ) , but our conceptual discussion here is applicable to any @xmath400 .",
    "now set @xmath402 .",
    "we observe the evolution of the process @xmath403 and detect the time @xmath404 ( the first downward milestone ) , @xmath405 where the inequality is componentwise .",
    "that is , @xmath406 for all @xmath407 .",
    "once @xmath404 is detected we check whether or not @xmath408 ever goes above the height @xmath409 ( the first upward milestone ) ; namely we define @xmath410    for now let us assume that we can check if @xmath411 or @xmath412 ( how exactly to do so will be explained in section [ sec_sampling_m0 ] ) . to continue simulating the rest of the path , namely @xmath413",
    ", we potentially need to keep track of the conditional upper bound implied by the fact that @xmath411 . to this end",
    ", we introduce the conditional upper bound variable @xmath414 ( initially @xmath415 ) .",
    "if at time @xmath404 we detect that @xmath411 , then we set @xmath416 and continue sampling the path of the random walk conditional on never crossing the upper bound @xmath417 in any of the coordinates .",
    "that is , conditional on @xmath418 .",
    "otherwise , if @xmath419 , we simulate the path conditional on @xmath419 , until we detect the time @xmath420 .",
    "we continue on , sequentially checking whenever a downward or an upward milestone is crossed as follows : for @xmath421 , define @xmath422{l}\\lambda_{j}=\\inf\\left\\ {   n\\geq\\gamma_{j-1}i\\left (   \\gamma_{j-1}<\\infty\\right ) \\vee\\lambda_{j-1}:\\,s\\left (   n\\right )   < s\\left (   \\lambda_{j-1}\\right ) -m\\mathbf{e}\\right\\ } \\\\",
    "\\gamma_{j}=\\inf\\left\\ {   n\\geq\\lambda_{j}:\\,s_{i}\\left (   n\\right ) -s_{i}\\left (   \\lambda_{j}\\right )   > m\\text { for some } 1\\leq i\\leq l\\right\\ }   , \\end{array } \\label{eq : construction of d_j and u_j}\\ ] ] with the convention that if @xmath423 , then @xmath424 .",
    "therefore , we have that @xmath425 if and only if @xmath426 .",
    "let us define @xmath427 so , for example , if @xmath411 we have that @xmath428 and the drifted random walk will never reach level @xmath429 again .",
    "this allows us to evaluate @xmath430 by computing @xmath431 the maximum is taken over @xmath26 for each coordinate .",
    "similarly , the event @xmath432 , for some @xmath433 , implies that the level @xmath434 is never crossed for any @xmath1 ( that is @xmath435 ) for all @xmath436 , and we let @xmath437 .",
    "the value of the vector @xmath414 keeps updating as the random walk evolves , at times where @xmath432 .",
    "the advantage of considering these stopping times is the following : once we observed that some @xmath432 , the values of @xmath438 for each @xmath439 are known without a need of further simulation .",
    "proposition [ pro : behavior of delta_n and gamma_n ] ensures that it suffices to sequentially simulate @xmath397 and @xmath398 jointly with the underlying random walk in order to sample from the sequence @xmath440 .",
    "the proof of proposition [ pro : behavior of delta_n and gamma_n ] is easily adapted from the one dimensional case discussed in and thus it is omitted .",
    "[ pro : behavior of delta_n and gamma_n ] set @xmath402 and let @xmath441 and @xmath442 be as ( [ eq : construction of d_j and u_j ] ) .",
    "we have that @xmath422{cccc}p_{0}\\left (   \\lim_{n\\rightarrow\\infty}\\lambda_{n}=\\infty\\right )   = 1 & \\text { and } & p_{0}\\left (   \\lambda_{n}<\\infty\\right )   = 1,\\ , & \\forall n\\geq1 . \\end{array } \\label{eq : behavior of d_n}\\ ] ] furthermore , @xmath443    in the setting of proposition [ pro : behavior of delta_n and gamma_n ] , for each @xmath444 we can define @xmath445 and @xmath446 .",
    "both of them are finite random variables such that@xmath447    in other words , @xmath448 is the time , not earlier than @xmath63 , at which we detect a second unsuccessful attempt at building an upward  patch directly .",
    "the fact that the relation in ( [ eq : connection m_n and stopping times ] ) holds , follows easily by construction of the stopping times in ( [ eq : construction of d_j and u_j ] ) . note that it is important , however , to define @xmath449 so that @xmath450 is computed first . in that way",
    ", we can make sure that the maximum of the sequence @xmath451 is achieved between @xmath63 and @xmath448 .",
    "these observation gives rise to our suggested high - level scheme .",
    "the procedure sequentially constructs the random walk in the intervals @xmath452 for @xmath453 .",
    "here is the * *  * * high - level procedure to construct @xmath454 :    [ algo hueristics for sn mn ] at the @xmath63-th iteration , for @xmath132 : * step 1 : downward patch \" .",
    "* conditional on the path not crossing @xmath414 we simulate the path until we detect @xmath455 , which is the first time when the random walk visits the set @xmath456\\times ... \\times(-\\infty , s_{l}(\\lambda_{k-1})-m]$ ] [ hueristics step_1].*step 2 : upward patch \" .",
    "* check whether or not the level @xmath457 is ever crossed by any of the coordinates @xmath1 .",
    "that is , whether @xmath458 or not .",
    "if the answer is yes  then , conditional on the path crossing @xmath457 for some @xmath1 , but not crossing the level @xmath459 , we simulate the path until we detect @xmath460 , the first time the level @xmath457 for at least one of the coordinates @xmath1 [ hueristics step_2 ] .",
    "otherwise @xmath461 , and we can update @xmath414 : @xmath462    the implementation of the steps in algorithm [ algo hueristics for sn mn ] will be discussed in detail in the next sections , culminating with the precise description given in algorithm [ algo last ] at the end of section [ section_final_rw ] .",
    "the goal of this section is to sample exactly from @xmath430 . to this end",
    "we need to simulate the sample path up to the first @xmath464 such that @xmath432 ( recall that @xmath465 was defined to be the corresponding @xmath466 ) .",
    "this sample path will be used in the construction of further steps in algorithm [ algo hueristics for sn mn ] .",
    "this construction is directly taken from .    for any positive vectors @xmath467 .",
    "let @xmath422{lc}\\tau_{b}=\\inf\\left\\ {   n\\geq0:\\,s_{i}\\left (   n\\right )   >",
    "b_{i}\\text { for some } i\\right\\ }   , & \\\\",
    "\\tau_{-b}=\\inf\\left\\ {   n\\geq0:\\,s_{i}\\left (   n\\right )   < -b_{i}\\text { for all } i\\right\\ }   , & \\\\ p_{a}\\left (   \\cdot\\right )   = p\\left (   \\cdot\\,\\mid s\\left (   0\\right )   = a\\right ) . &",
    "\\end{array } \\label{eq : crossig times t_m t_(-m)}\\ ] ] since we concentrate on @xmath430 , we have that @xmath415 .",
    "we first need to explain a procedure to generate a bernoulli random variable with success parameter @xmath468 , for suitably chosen @xmath400 .",
    "also , this procedure , as we shall see , will allow us to simultaneously simulate @xmath469 given that @xmath470 .",
    "we think of the probability measure @xmath471 as defined on the canonical space @xmath472 endowed with @xmath473-field generated by the borel @xmath474-field of finite dimensional projections ( i.e. the kolmogorov @xmath474-field ) .",
    "our goal is to simulate from the conditional law of @xmath475 given that @xmath470 and @xmath476 , which we shall denote by @xmath477 in the rest of this part .",
    "first , we select @xmath400 such that @xmath478    now let us introduce our proposal distribution @xmath479 , defined on the space @xmath480 .",
    "we endow the probability space with the associated kolmogorov @xmath473-field .",
    "so , a typical element @xmath481 sampled under @xmath482 is of the form @xmath481=((@xmath483),@xmath484 , where @xmath485 .",
    "the distribution of @xmath481 induced by @xmath479 is described as follows , first,@xmath486 now , given @xmath487 , for every set @xmath488(@xmath489,@xmath490.\\ ] ] in particular , the radon - nikodym derivative ( i.e. the likelihood ratio ) between the distribution of @xmath491 under @xmath482 and @xmath471 is given by@xmath492    _ the distribution of @xmath493 under @xmath482 is precisely the proposal distribution that we shall use to apply acceptance / rejection . _",
    "it is straightforward to simulate under @xmath482 .",
    "first , sample @xmath494 according to the distribution ( [ disk ] ) .",
    "then , conditional on @xmath487 , the process @xmath495 is also a multidimensional random walk . indeed , given @xmath487 , under @xmath482",
    "it follows that @xmath496 can be represented as@xmath497 where @xmath498 s are i.i.d . with distribution obtained by exponential titling , such that for all @xmath499,@xmath500 .",
    "\\label{j_p2}\\ ] ]    now , note that we can write @xmath501 where the last inequality follows by convexity of @xmath502 and by definition of @xmath503 .",
    "so , we have that @xmath504 as @xmath505 with probability one under @xmath482 , by the law of large numbers .",
    "consequently @xmath470 a.s . under @xmath482 .",
    "recall that @xmath506 is the conditional law of @xmath507 given that @xmath470 and @xmath364 . in order to assure that we can indeed apply acceptance / rejection theory to simulate from @xmath508 ,",
    "we need to show that the likelihood ratio @xmath509 is bounded . indeed ,",
    "@xmath510 upon @xmath511 , there is an index @xmath512 ( @xmath512 may be different from @xmath494 ) such that @xmath513 , therefore@xmath514 where the last inequality follows by ( [ eq : assumption_m ] ) .",
    "consequently , plugging ( [ b_1 ] ) into ( [ arb ] ) we obtain that@xmath515    now we are ready to fully discuss our algorithm to sample @xmath516 and @xmath517 given @xmath470 . upon termination we will output the pair @xmath518 .",
    "if @xmath519 , then we set @xmath520 . otherwise ( @xmath521 ) , we set @xmath522   $ ] , the empty vector .",
    "[ algo sampling m_0 ]    input : @xmath523 and @xmath401 satisfying ( [ eq : assumption_m ] ) .",
    "output : @xmath524 and @xmath525 .",
    "if @xmath519 , then @xmath526 . otherwise ( @xmath521 ) , @xmath522   $ ]    step 1 : sample @xmath527 according to @xmath482 as indicated via equations ( [ j_prime ] ) and ( [ j_p2 ] ) .",
    "step 2:given @xmath527 , simulate a bernoulli @xmath516 with probability @xmath528    step 3 : if @xmath519 , * output * @xmath518 , where @xmath529 .",
    "else , if @xmath521 , * output * @xmath518 , where @xmath530   $ ] .    the authors in show that the output of the previous procedure indeed follows the distribution of @xmath531 given that @xmath470 and @xmath364 .",
    "moreover , the bernoulli random variable @xmath516 has probability @xmath468 of success .",
    "now we are ready to give the algorithm sampling @xmath532 jointly with @xmath533 .",
    "before we move on to the algorithm let us define the following .",
    "given a vector @xmath534 , of dimension @xmath535 , we let @xmath536 ( i.e. the @xmath0-th component of the vector @xmath534 ) .",
    "[ algo sampling patches of path ]    input same as algorithm [ algo sampling m_0 ]    output the path @xmath537initialization  @xmath538 $ ] , @xmath539 , and @xmath540 .",
    "( initially @xmath534 is the empty array , the variable @xmath541 represents the last position of the drifted random walk .",
    "while @xmath542    @xmath543    call algorithm [ algo sampling m_0 ] and obtain @xmath544 ,    if @xmath519 set @xmath545 $ ] ,    else @xmath546    end while    * output * * * @xmath534 . * *    [ prop_mo_and_upto_delta]the output of algorithm [ algo sampling patches of path ] has the correct distribution according to ( [ eq def delta ] ) and ( [ eq_eval_m0 ] ) . moreover , if @xmath547 is the number of random variables needed to terminate algorithm [ algo sampling patches of path ] , there is @xmath80 such that @xmath548   < \\infty$ ] .",
    "_ proof of proposition _ [ prop_mo_and_upto_delta ] : as noted earlier , this follows directly from the analysis in .@xmath289      in this section we will explain in detail the complete procedure to sample @xmath550 jointly with @xmath551 for @xmath552 , where @xmath26 is a finite number given by the user .",
    "the algorithm is similar as that for sampling @xmath553 and @xmath554 and is also based on simulating the downward and upward patches .",
    "the main difference is that @xmath555 for @xmath550 with @xmath556 and hence we need to simulate the random walk @xmath551 conditional on that it never crosses the level @xmath414 . in particular , we shall use the algorithm for sampling @xmath532 developed in section [ sec_sampling_m0 ] to help us simulate the conditional probability .    in step [ hueristics step_1 ]",
    "we need to sample the maximum of the drifted random walk @xmath557 .",
    "suppose that our current position is @xmath558 and we know that the random walk will never reach position @xmath414 .",
    "in other words , there exist some @xmath559 such that @xmath560 .",
    "let @xmath561 , then @xmath562 .",
    "we now explain how to simulate the path up to the first time @xmath563 , for @xmath564 , such that @xmath565 .",
    "first , we call algorithm [ algo sampling patches of path ] and obtain the output @xmath566 .",
    "we compute @xmath567 according to ( [ eq_eval_m0 ] ) and keep calling algorithm [ algo sampling patches of path ] until we obtain @xmath568 , at which point we set @xmath569 it is clear from the construction of the path that indeed @xmath570 has the correct distribution of @xmath571 given @xmath572 and @xmath364 .",
    "then , we simply update @xmath573 .",
    "we close this section by giving the explicit implementation of our general method outlined in subsections [ sec : construction s_n m_n ] . in order to describe the procedure ,",
    "let us recall some definitions .",
    "given an array @xmath534 of dimensions @xmath574 , let @xmath575 ( the last column vector of dimension @xmath576 in the array ) .",
    "given an array @xmath577 of size @xmath578 , set @xmath579 ( the number of columns in the array ) .",
    "we shall evaluate @xmath580 on arrays that might have different numbers of rows .",
    "[ algo last ]    input same as algorithm [ algo sampling m_0 ]    output @xmath581    initialization @xmath582 $ ] , @xmath583 , @xmath584 $ ] , @xmath585 .",
    "( initialize the sample path with the array containing only one vector of @xmath586-dimensions . )",
    "comments : the vector @xmath245 , which is initially empty records the times @xmath466 such that @xmath432 .",
    "@xmath587 is a boolean variable which detects when we have enough information to compute @xmath588    while @xmath589while @xmath590call algorithm [ algo sampling patches of path ] .",
    "obtain as output @xmath591 , and get @xmath592@xmath593 , update @xmath594 , @xmath595 $ ] , @xmath596 $ ] and @xmath597.end while    if @xmath598 , set @xmath599.end while@xmath600for @xmath601 end for**output : * * @xmath602 .",
    "to test the numerical performance and correctness of our algorithm , we implement our algorithm in matlab .",
    "in particular , we consider a 2-station jackson network with poisson arrivals and exponential service times , so that the true value of the steady - state distribution is known in closed form . in the numerical test",
    ", we shall fix the routing matrix @xmath603 $ ] and run the simulation algorithm for different arrival and service rates @xmath604 and @xmath605 . for each pair of @xmath606",
    ", we generate 10000 i.i.d .",
    "samples of the number of customers @xmath607 .",
    "we estimate the steady - state expectation @xmath608 $ ] and the correlation coefficient of @xmath609 and @xmath610 based on the 10000 i.i.d .",
    "since the 2-station system is a jackson network , the theoretic steady - state distribution of @xmath611 is known and the true value of @xmath608=\\phi/(\\mu-\\phi)$ ] . moreover ,",
    "the true value of the correlation coefficient is 0 as the joint distribution of @xmath612 is of product form . in table 1 , for different @xmath605 and @xmath604 , we report the simulation estimations and compare them with and the true values . in detail",
    ", we report the 95% confidence interval of @xmath608 $ ] estimated from the simulated samples . for the correlation",
    ", we report the sample correlation coefficient and the @xmath613-value of the hypothesis test that the two population are not correlated .",
    "[ c]||l|l|l|l|l|l|| + @xmath604 & ( 0.2250 , 0.7170 ) & ( 0.2200 , 0.7670 ) & ( 0.2180 , 0.7870 ) & ( 0.2160 , 0.8070 ) & ( 0.2140 , 0.8270 ) + @xmath605 & ( 1.0000 , 1.0000 ) & ( 1.0000 , 1.0000 ) & ( 1.0000 , 1.0000 ) & ( 1.0000 , 1.0000 ) & ( 1.0000 , 1.0000 ) +   + truevalue & 0.4286 & 0.4286 & 0.4286 & 0.4286 & 0.4286 + simulation & 0.4265@xmath6140.0152 & 0.4204@xmath6140.0150 & 0.4247@xmath6140.0150 & 0.4376@xmath6140.0153 & 0.4228@xmath6140.0155 +   + truevalue & 3.0000 & 4.0000 & 4.5556 & 5.2500 & 6.1429 + simulation & 2.9355@xmath6140.0676 & 4.0468@xmath6140.0877 & 4.5844@xmath6140.0984 & 5.3057@xmath6140.1156 & 6.1620@xmath6140.1291 +   + simulation & -0.0058 & -0.0128 & 0.0151 & 0.0011 & 0.0116 + @xmath613-value & 55.96% & 19.90% & 13.13% & 91.13% &",
    "24.80% +    figure 1 and 2 compares the histogram of the 10000 simulation samples with the true steady state distribution for two different values of @xmath604 and @xmath615 . in both two cases",
    ", we can see that the empirical distribution of the i.i.d .",
    "simulated samples is very close to the true distribution .    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]    0.5 , @xmath616 . ( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 .",
    ", title=\"fig : \" ]    0.5 , @xmath616 .",
    "( a ) histogram of the 10000 simulated samples of @xmath607 .",
    "( b ) theoretic steady - state distribution of @xmath607 .",
    "( c ) marginal distribution of @xmath609 .",
    "( d ) marginal distribution of @xmath610 . , title=\"fig : \" ]",
    "[ lemma : vacation system initial state]suppose we start the coupled systems @xmath103 and @xmath113 empty from time @xmath229 . then for any @xmath195 , when @xmath197 , then the service station @xmath1 in system @xmath103 must be one of the three following cases :      _ proof of lemma [ lemma : vacation system initial state ] _ : the result follows directly by comparing the evolution of @xmath620 given by ( [ sde ] ) , against the evolution of the number of customers waiting in the @xmath1-th queue of @xmath103 , namely @xmath621 , which satisfies ( [ eq : evolution_vacation ] ) .",
    "the equations are monotone with respect to the input process , which is strictly smaller for the network @xmath103 compared to @xmath113 because @xmath622 so , we conclude that @xmath623 . therefore ,",
    "if @xmath197 , we have @xmath624 . as @xmath625 is the number of customers who are waiting for entering service , we can conclude that either @xmath626 if the server is in service and @xmath627 if the server is on vacation , and hence we are done.@xmath289      let @xmath628 be a fixed vector in @xmath629 .",
    "consider three vacation networks @xmath103 , @xmath220 , @xmath630 that have the same network topology and are driven by the same arrival and activity sequences , namely , @xmath631 and @xmath632 , except for their initial state at time @xmath229 .",
    "in particular , we set @xmath633 with all servers in service for all @xmath1 , and @xmath634 with all servers in vacation .",
    "the state of each service station in @xmath103 at time @xmath229 is of any one of three cases as described in lemma [ lemma : vacation system initial state ] .",
    "more precisely , we have the following system of sdes for @xmath635 , @xmath636 , and @xmath637 with @xmath5,@xmath638 the sdes for @xmath639 , @xmath640 , and @xmath641 , @xmath642are exactly the same , except for the boundary conditions .",
    "in particular , @xmath643 @xmath644 , and @xmath645 @xmath646 . then we have the following comparison result which implies part iii ) of theorem [ thm_domination ] :    [ lemma_comp_vacation_vs_vacation]in order to distinguish servers whenever there might be ambiguity we shall call the server of the @xmath1-th service station in @xmath220 the server @xmath647 , the server of the @xmath1-th station in @xmath103 is called server @xmath1 , and the @xmath1-th server in @xmath630 is called @xmath648 .",
    "we claim that the following three statements hold for all servers @xmath1 , @xmath647 , and @xmath648 @xmath649 and at any @xmath209 ( analogous statements to 2 . and 3 .",
    "hold replacing @xmath647 by @xmath1 and @xmath1 by @xmath648 )    1 .",
    "2 .   if @xmath650 , server @xmath647 and server @xmath1 are both in service or both in vacation .",
    "similarly , @xmath651 , server @xmath1 and server @xmath648 are both in service or both in vacation 3 .",
    "if server @xmath647 is in vacation , server @xmath1 is also in vacation . similarly ,",
    "if @xmath1 is in vacation , server @xmath648 is also in vacation .",
    "first let s check if the claim is true for @xmath84 .",
    "note that @xmath633 and @xmath653 and hence statement ( 1 ) holds . as server",
    "@xmath647 is in service at time 0 , statement ( 2 ) also hold",
    ". finally , if @xmath654 , service station @xmath1 is of the first case in lemma [ lemma : vacation system initial state ] which means both server @xmath1 and @xmath647 are at service . in summary ,",
    "the claim is true for @xmath84 .",
    "let @xmath655 be the counting process of events that occur in the network . define @xmath656 to be the time at which the @xmath26-th event occurs for @xmath453 and set @xmath657 .",
    "we shall prove the statements 1 - 3 only for @xmath1 and @xmath647 first by induction on @xmath27 at times @xmath658 , since there are no changes inside the network population between two event epochs .",
    "we have verified that statements 1 - 3 are valid at @xmath659 .",
    "assume by induction hypothesis , that statements 1 - 3 hold for @xmath660 , we need to consider several cases at time @xmath661 .",
    "_ case 1 _ : @xmath661 corresponds to an arrival from @xmath662.in this case , @xmath663 and @xmath664 . according to the dynamics of vacation system , a new arrival from @xmath267",
    "does not change the type of activity that is going on in servers @xmath647 and @xmath1 .",
    "so statements 1 - 3 hold for server @xmath1 and @xmath647 at @xmath661 . as to all the other servers , there are no changes between @xmath660 and @xmath661 . in summary ,",
    "statement 1 - 3 hold for all servers at @xmath661 .",
    "_ case 2 _ : @xmath661 corresponds to an arrival from @xmath153 and @xmath665.by induction hypothesis , server @xmath1 and @xmath647 are in the same type of activity at time @xmath666 .",
    "suppose that both servers @xmath1 and @xmath647 are at vacation at @xmath660 , it is clear from the dynamics that @xmath667 .",
    "if @xmath668 , it means that there was someone waiting and therefore at time @xmath658 , coming from vacation , now both @xmath647 and @xmath1 are now in service at time @xmath661 ; otherwise , from the same logic , @xmath669 , implies that both @xmath647 and @xmath1 are on vacation at @xmath661 .",
    "besides , there are no changes on other servers between @xmath660 and @xmath661 , because at @xmath660 the servers where on vacation .",
    "therefore , statement 1 - 3 hold for all servers at @xmath661 .",
    "if both server @xmath1 and @xmath647 are in service at @xmath660 and @xmath670 , then @xmath671 and both server @xmath647 and @xmath1 are in vacation at @xmath661 .",
    "let @xmath672 .",
    "if @xmath673 , there are no changes on other servers between @xmath660 and @xmath661 , so statement 1 - 3 hold for all servers at @xmath661 .",
    "if @xmath674 , then we can apply the argument of _ case 1 _ to server @xmath10 , @xmath675 , and there are no changes on the rest servers other than @xmath676 @xmath675 and @xmath10 .",
    "so statements 1 - 3 hold for all servers at @xmath677 .",
    "if server @xmath647 is in vacation at @xmath660 , by induction hypothesis , server @xmath1 is also in vacation at @xmath660 .",
    "then , there are no changes on all other servers .",
    "besides , @xmath680 and @xmath681 and hence @xmath682 . as @xmath668 , server @xmath647 is in service at @xmath661 and",
    "hence we do not contradict statement 3 for servers @xmath647 and @xmath1 at time @xmath661 . in summary , we conclude that statements 1 - 3 hold for all servers at time @xmath661 .",
    "if server @xmath647 is in service and @xmath683 ( and so @xmath684 ) , @xmath671 and server @xmath647 and @xmath1 are both in vacation at time @xmath661 .",
    "let @xmath685 .",
    "if @xmath673 , there are no changes on all other servers and hence statements 1 - 3 hold for all servers at @xmath661 . otherwise , we have @xmath686 and @xmath687 , as @xmath688 by induction hypothesis , @xmath689 .",
    "so statement 1 - 2 hold for server @xmath675 and @xmath10 .",
    "the type of activity that occurs in server @xmath675 and @xmath10 remains the same what was going on at time @xmath660 and hence statement 3 holds .",
    "since there are no changes on the rest servers other than @xmath690 and @xmath10 , statement 1 - 3 hold at time @xmath661 for all servers .    if server @xmath647 is in service at @xmath660 and @xmath691 , @xmath692 and server @xmath647 is still in service at @xmath661 .",
    "so statement 3 holds for servers",
    "@xmath647 and @xmath1 at time @xmath661 . as @xmath693 and @xmath694 , @xmath695 and",
    "statement 1 holds for server @xmath1 . in case @xmath667 ,",
    "@xmath696 and hence both server @xmath647 and @xmath1 are in service at @xmath661 and statement 2 holds .",
    "following a similar argument as when server @xmath647 is in service at @xmath660 and @xmath697 , we can check that statement 1 - 3 hold for all the other servers . as a result",
    ", we can conclude that statement 1 - 2 hold at time @xmath661 for all servers .      to prove that @xmath698",
    ", we can use the same induction arguments simply replacing @xmath699 with @xmath167 , and @xmath167 with @xmath700 in statements 1 - 3 .",
    "the induction part is exactly the same , so we are done if we can check that the three statements all hold at time @xmath701 .    as @xmath634 and all servers @xmath648 are in vacation , statement 1 - 3 immediately hold .",
    "if @xmath702 , then @xmath703 and service station @xmath1 is in the last case as in lemma [ lemma : vacation system initial state ] , hence both @xmath1 and @xmath648 are in vacation and statement 2 holds . in summary ,",
    "statement 1 - 3 all hold for time @xmath657 and thus the result follows.@xmath289    [ [ recapitulation - of - the - main - procedure - and - proof - of - theorem - thm_mainsec_proof_main ] ] recapitulation of the main procedure and proof of theorem [ thm_main][sec_proof_main ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    in order to prove theorem [ thm_main ] , we need to recapitulate on the execution of our main procedure .",
    "let us go back to equation ( [ eq : evolution_vacation ] ) and allow us write @xmath704 to recognize the boundary condition in ( [ eq : evolution_vacation ] ) .",
    "moreover , we recall that @xmath705 , from equation ( [ eq : initialcondition ] ) . for",
    "any @xmath706 define the event @xmath707\\text { there is } i\\text { such that } y_{i}^{+}(k;t,\\bar{y}^{\\prime}\\left (   -t\\right )   ) > 0\\}.\\ ] ] then put @xmath708 occurs@xmath709 . assuming that the output indeed follows the steady state distribution ,",
    "the statement of theorem [ thm_main ] concerning the computational cost measure in terms of random numbers generated will follows if we can show that there exists @xmath80 such that @xmath710   < \\infty$ ] .",
    "we start by noting that @xmath711 in order to compute @xmath712 we can think forward in time , in particular consider @xmath713 note the relation between @xmath714 and @xmath715 , defined in ( [ eq : two_sided_processes ] ) , in particular @xmath716 ( similarly @xmath717 ) .",
    "then let @xmath718 we have that @xmath719\\text { , there is } i\\text { such that } y_{i}^{+}\\left (   t;0,\\bar{y}^{\\prime}\\left (   0\\right ) \\right )   > 0\\right )   .\\ ] ] the strategy is to first describe the evolution of @xmath720 in terms of a markov process .",
    "we need to track the residual times associated with each renewal process and the number of people both in queue and in service in each station .",
    "in particular , define @xmath721 similarly , we define @xmath722 then we let @xmath658 be the times at which events occur , that is , @xmath723 are the discontinuity points of the process @xmath724 defined as @xmath725 .",
    "let us write @xmath726 and define @xmath727 as @xmath728 note that @xmath729 forms a markov chain and we are given the initial condition @xmath730 .",
    "now , define @xmath731 for some @xmath732 .",
    "following a similar approach to , due to assumption 2 , we now can show that there exists @xmath732 such that @xmath733<\\infty$ ] .",
    "moreover , because the inter - arrivals have unbounded support a geometric trial argument will yield that if @xmath80 is chosen sufficiently small then @xmath734<\\infty$ ] . in turn",
    ", this bound implies that @xmath735   < \\infty$ ] .      using the similar notation of @xmath736",
    ", we define @xmath737 as the number of customers in a gjn start with @xmath738 and is driven by the same sequence of inter - arrival times , service requirements and routing indices as @xmath103 on @xmath739 $ ] .",
    "given the comparison results in theorem [ thm_domination ] , given that @xmath740 , we can conclude that for all @xmath741 , @xmath742 and hence @xmath743 .",
    "therefore , for any @xmath744 @xmath745 as the process @xmath746 has a unique stationary distribution ( see @xcite ) , we can conclude @xmath747 follows the stationary distribution ."
  ],
  "abstract_text": [
    "<S> we provide the first perfect sampling algorithm for a generalized jackson network of fifo queues under arbitrary topology and non - markovian assumptions on the input of the network . </S>",
    "<S> we assume ( in addition to stability ) that the interarrival and service times of customers have finite moment generating function in a neighborhood of the origin , and the interarrival times have unbounded support . </S>"
  ]
}