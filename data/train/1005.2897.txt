{
  "article_text": [
    "[ [ algebraic - lambda - calculi . ] ] algebraic @xmath0-calculi .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    two algebraic versions of the @xmath0-calculus arise independently in distinct contexts : the algebraic @xmath0-calculus ( @xmath1 )  @xcite and the linear algebraic @xmath0-calculus ( @xmath2 )  @xcite .",
    "the former has been introduced in the context of linear logic as a fragment of the differential @xmath0-calculus  @xcite : the algebraic structure allows to gather in a non deterministic manner different terms , _",
    "i.e. _ each term represents one possible execution .",
    "the latter has been introduced as a candidate @xmath0-calculus for quantum computation : in @xmath2 , a linear combination of terms reflects the phenomenon of superposition , _",
    "i.e. _ the capability for a quantum system to be in two or more states at the same time .",
    "[ [ four - languages - with - different - behaviours . ] ] four languages with different behaviours .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in both languages , functions which are linear combinations of terms are interpreted pointwise : @xmath3 , where `` @xmath4 '' denotes the scalar multiplication .",
    "the two languages differ on the treatment of the arguments . in @xmath2 , in order to deal with the algebraic structure , any function is considered as a linear map : @xmath5 , reflecting the fact that any quantum evolution is a linear map .",
    "it reflects a call - by - value behaviour in the sense that the argument is evaluated until one has a base term . in the opposite",
    ", @xmath1 has a call - by - name evolution : @xmath6 $ ] , without any restriction on @xmath7 . as a consequence ,",
    "the evolutions are different as illustrated by the following example . in @xmath2 ,",
    "@xmath8 while in @xmath1 , @xmath9 .",
    "because they were designed for different purposes , another difference appears between the two languages : the way the algebraic part of the calculus is treated . in @xmath2 , the algebraic structure is captured with a rewrite system , whereas in @xmath1 terms are considered up to algebraic equivalence .",
    "the two choices  call - by - value versus call - by - name , algebraic equality versus algebraic reduction  allow one to construct four possible calculi .",
    "we name them @xmath10 , @xmath11 , @xmath12 , and @xmath13 , see figure  [ tab : linalg ] where they are presented according to their evolution policy and the way they take care of the algebraic part of the language .",
    "inspired by @xmath2 and @xmath1 , the operational semantics of the four languages we introduce slightly differ from the original ones for focusing on the particularities of the calculi we are interested in : reduction strategy and handling of algebraic structure in _",
    "programs_.    a first modification is that in all four languages , we avoid reduction under lambda abstractions . as a consequence , contrary to @xmath1 ,",
    "the @xmath0-abstraction is not linear anymore : @xmath14 .",
    "this restriction is a common restriction : reducing under @xmath0 could be considered as  optimising the program .",
    "also note that since we consider @xmath15 with algebraic rewrite rules instead of the equalities used in @xmath1 , we need two extra rules : @xmath16 and @xmath17 . these rules were not needed with equalities , since @xmath18 .    concerning @xmath19 and @xmath20 ,",
    "restrictions originally imposed in @xmath2 on the rewrite system to ensure confluence are replaced by restrictions which make @xmath19 and @xmath20 actual call - by - value languages .",
    "for example , the rule @xmath21 when @xmath22 is closed - normal form is replaced by only asking @xmath23 to be a value . notice that even in the original language @xmath2 , waiving the restrictions makes sense when confluence can be ensured by other means , see _ e.g.",
    "_  @xcite .",
    "[ [ contribution - relation - between - the - four - languages - through - simulation . ] ] contribution : relation between the four languages through simulation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    although these languages behave differently , we show in this paper that they simulate each other .",
    "this result connects works done in linear logic  @xcite and works on quantum computation  @xcite .",
    "we show that call - by - value algebraic @xmath0-calculi simulate call - by - name ones and _ vice versa _ by extending the continuation passing style ( cps )  @xcite to the algebraic case .",
    "we also provide simulations between algebraic equality and algebraic reduction in both directions .",
    "the simulations we prove are summed up in figure  [ fig : relation ] .",
    "the solid arrows stand for theorems that do not require confluence in their hypothesis whereas the dashed arrows stands for theorems that do .",
    "a preliminary version of this work was presented in  @xcite .",
    "[ [ consistency . ] ] consistency .",
    "+ + + + + + + + + + + +    without restrictions on the set of terms , both algebraic reductions and algebraic equalities cause problems of consistency , albeit differently .",
    "let @xmath24 . in a system with algebraic reduction",
    ", the term @xmath25 reduces to @xmath26 , but also reduces to @xmath27 and hence to @xmath28 , breaking confluence . to solve this issue ,",
    "several distinct techniques can be used to make an algebraic calculus confluent . in @xcite , restrictions on reduction rules are introduced , e.g. @xmath29 if @xmath28 is closed normal . in @xcite , type systems are set up to forbid diverging terms such as @xmath30 .    in a system with algebraic equalities , if @xmath28 and @xmath7 are any terms , the term @xmath28 reduces to @xmath31 , therefore to @xmath7 . in @xmath1 a restriction to positive scalars is proposed to solve the problem .",
    "however such a solution does not work in a system with algebraic reduction ( _ cf .",
    "_ section  [ sec : consistency ] ) .    in this paper",
    "we do not make a choice _ a priori _ , instead we show that the simulations between the four calculi are correct , providing a general enough methodology to work in a large variety of restrictions on the language .",
    "therefore , we do not force one specific method to make the calculi consistent , leaving the choice to the reader .",
    "[ [ plan - of - the - paper . ] ] plan of the paper .",
    "+ + + + + + + + + + + + + + + + + +    in section  [ sec : alglam ] , we define the set of terms and the rewrite systems we consider in the paper . in section",
    "[ sec : consistency ] , we discuss the confluence of the algebraic rewrite systems .",
    "section  [ sec : sim ] is concerned with the actual simulations . in section  [ sec : redeq ] we consider the correspondence between algebraic reduction and algebraic equality whereas in section  [ subsec : lintoalg ] and  [ subsec : algtolin ] we consider the distinction call - by - name versus call - by - value . in section  [ subsec : compose ] , we show how the simulations can compose to obtain the correspondence between any two of the four languages . in section",
    "[ sec : concl ] we conclude by providing some paths for future work .",
    "most of the omitted and sketched proofs are fully developed in the appendix .",
    "the languages @xmath2 and @xmath1 share the same syntax , defined as follows : @xmath32 where @xmath33 ranges over a ring , the _ ring of scalars_. we use the notation @xmath34 as a shorthand for @xmath35 .",
    "note that we could have asked for a semiring instead ; in fact we shall see in section  [ sec : conf ] that the analysis we develop here can be adapted to semirings of scalars .",
    "we provide a complete formalisation of the rewrite rules and show how they relate to each other .",
    "we summarise in figure  [ tab : rw ] all the rewrite rules that are being used .",
    "the rules are grouped with respect to their intuitive meaning .",
    "we use the usual notation regarding rewrite systems : given a rewrite system @xmath36 , we write @xmath37 for its reflexive and transitive closure .",
    "that is , @xmath38 is valid if @xmath39 or if there exists a rewrite sequence @xmath40 linking @xmath41 and @xmath42 .",
    "we write @xmath43 for the symmetric closure of @xmath36 , that is , the relation that satisfies @xmath44 if and only if @xmath45 or @xmath46 .    the original languages @xmath2 and @xmath1 made particular assumptions both on the reduction strategy and the handling of algebraic structure under the reduction . in this paper , we consider separately the distinction call - by - name / call - by - value and the distinction algebraic equality / algebraic reduction .",
    "we develop therefore four languages : a call - by - value language @xmath20 with algebraic equality , a call - by - value language @xmath19 with algebraic reduction , a call - by - name language @xmath47 with algebraic equality and a call - by - name language @xmath15 with algebraic reduction .",
    "these four languages are summarised in figure  [ tab : linalg ] .",
    "[ def : lang ] we use the following notations for the rewrite systems obtained by combining the rules described in figure [ tab : rw ] : @xmath48 we define the following four languages and their associated rewrite systems :    [ cols=\"^,^\",options=\"header \" , ]",
    "in this section we show that the four languages @xmath19 , @xmath15 , @xmath20 , and @xmath47 are locally confluent . a rewrite system @xmath36 is locally confluent if whenever @xmath49 and @xmath50 there is @xmath51 such that @xmath52 and @xmath53 . in comparison ,",
    "a rewrite system @xmath36 is confluent if whenever @xmath38 and @xmath54 there is @xmath51 such that @xmath52 and @xmath53 .",
    "notice that confluence implies local confluent whereas the inverse is not true .",
    "we first concentrate on the algebraic rules . for each of these calculi",
    ", we use the reductions describing the algebraic structure : @xmath55 and @xmath56 correspond to an oriented rewriting description whereas @xmath57 and @xmath58 correspond to a description by equalities ( since every rewrite rule can be reversed , _ cf . _ definition  [ def : lang ] ) .",
    "[ locallyconfluence ]   the rewrite systems @xmath55 , @xmath56 , @xmath57 and @xmath58 are locally confluent .    for @xmath56 and @xmath55",
    ", we give a semi - automatised proof in the interactive theorem prover coq @xcite .",
    "the interested reader can find the proof in  @xcite which is sketched in the appendix .",
    "since for any rewrite system @xmath36 , its symmetric closure @xmath43 is trivially locally confluent , both @xmath57 and @xmath58 are locally confluent",
    ".    the rewrites systems considered in this paper are also locally confluent in the presence of the @xmath59-rewrite rules .",
    "[ lem : localconf - llinred ] the four languages in  figure [ tab : linalg ] are locally confluent .",
    "the local confluence of the algebraic fragment is proven in lemma  [ locallyconfluence ] .",
    "the beta - reduction is confluent using a straightforward extension of the confluence of lambda calculus .",
    "finally , the beta - reduction and the algebraic fragments commute , making each rewrite system locally confluent .      in this section , we show that the algebraic fragments are confluent modulo associativity and commutativity .",
    "concerning the full languages , we show that they are either not confluent or trivially confluent ( in the sense that any term is reducing to any other ) . as a consequence ,",
    "we introduce a generic notion of language fragment to describe confluent and consistent sub - languages .",
    "in particular , fragments are used in simulations theorems in section [ sec : sim ] for abstractly representing confluent sub - languages .",
    "[ [ the - algebraic - fragment . ] ] the algebraic fragment .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    it is clear that neither @xmath55 nor @xmath56 is strongly normalising : with both systems one can go back and forth between @xmath22 and @xmath60 .",
    "they are however strongly normalising `` modulo associativity and commutativity '' in the sense that any rewrite sequence consists eventually of terms that are equal modulo associativity and commutativity . on the contrary ,",
    "the rewrite systems @xmath57 and @xmath58 are not .    in order to formalise this ,",
    "let us denote @xmath61 the system generated by @xmath62 and @xmath63 the rewrite system obtained by taking off the rules @xmath64 and @xmath65 where @xmath36 stands for @xmath55 or @xmath56 .",
    "hence , @xmath66 stands for the system generated by @xmath67 and @xmath68 for the system generated by @xmath69 .",
    "[ def : acnorm ] let @xmath36 be either @xmath56 or @xmath55 and @xmath70 be a reduction sequence ( finite or not ) characterised by the set of terms @xmath71 and the set of rules @xmath72 used to go from @xmath73 to @xmath74 , where @xmath75 stands for a fixed rule in @xmath36 .",
    "we say that the reduction is _ ac - finite _ if the set of indices @xmath76 such that @xmath77 is finite .",
    "the _ ac - length _ of the rewrite sequence is the cardinal of this set of indices .",
    "the rewrite system @xmath36 is _ ac - strongly - normalising _ ( ac - sn ) if for any term @xmath28 , there exists a number @xmath78 such that the ac - length of any rewrite sequence starting at @xmath28 is less than @xmath78 . a term @xmath28 is _ ac - normal _ with respect to a rewrite system @xmath36 if any rewrite sequence starting with @xmath28 consists only of rules ac .",
    "[ th : acnorm ] the systems @xmath55 and @xmath56 are ac - sn .",
    "we use the technique described in  @xcite .",
    "an auxiliary measure is defined on terms by @xmath79 , @xmath80 , @xmath81 , @xmath82 , @xmath83 and @xmath84 .",
    "this measure is preserved by rules ac and strictly decreasing on the other algebraic rules .",
    "local confluence plus strong normalisation implies confluence ( see for example  @xcite ) .",
    "[ cor : algconf ] the rewrite systems @xmath55 and @xmath56 are confluent , modulo ac .",
    "although we have proved that the four languages under consideration are locally confluent , neither @xmath19 nor @xmath15 is confluent : in each one , the term @xmath25 rewrites both to @xmath26 and @xmath28 , where @xmath24 .",
    "regarding @xmath20 and @xmath47 , without restriction both are trivially confluent since for all terms @xmath28 and @xmath7 , @xmath28 reduces to @xmath7 : @xmath85 .",
    "hence , with the algebraic equality , both languages can simulate any rewrite system .    for getting back consistency , it is of course possible to modify the rewrite systems as in @xcite but it would break the correspondence between call - by - value and call - by - name . in this paper",
    "we propose instead to restrict the set of terms . in the literature ,",
    "there have been two methods :    with algebraic equalities , vaux @xcite considers non - negative scalars ( semiring ) on a language with algebraic equality .",
    "the restriction on scalars is enough for getting unicity of normal forms .",
    "although this solves the consistency problem for the languages with algebraic equality , it does not give confluence for the languages with algebraic reduction .",
    "indeed , consider the critical pair @xmath86 , @xmath87 .",
    "the term @xmath88 can only produce an even number of @xmath28 s : we can not close the pair .    with algebraic reductions , other papers @xcite use type systems for retrieving strong normalisation on a language with algebraic reduction .",
    "this technique could be directly adapted to our setting since it is possible to have subject reduction in these cases .",
    "the simulations theorems that we develop in this paper are correct in a general untyped setting ( and in fact trivially true when we simulate a language with algebraic reduction with a language with algebraic equality as remarked above ) , but also true if one restrict the scalars to a semiring ( as done in @xcite ) , or if we restrict the terms to any typed setting , provided that the languages @xmath19 and @xmath15 satisfy subject reduction and that the cps translations preserve typability .",
    "thus , in this paper we do not restrict the calculi _ a priori _ , instead , we propose a notion of _ language fragments _ to parametrise the simulation results .",
    "the definition of fragment is general enough to capture many settings : various typed systems , but also the restrictions to a given set of terms such as the set of ac - sn terms or taking scalars from a semiring .",
    "we define formally a fragment in the following way :    [ def : subset ] a fragment @xmath89 of @xmath19 ( resp .",
    "@xmath15 ) is a language defined on a subset of terms closed under @xmath90-reduction ( resp .",
    "@xmath91-reduction ) .",
    "the rewrite system of @xmath89 is inherited from the one of @xmath19 ( resp .",
    "@xmath15 ) .    the definition of a fragment in the presence of algebraic equalities should be treated carefully .",
    "indeed , note that the algebraic equalities are defined as @xmath92 if and only if @xmath93 or @xmath94 . as a consequence , for any subset @xmath89 of terms closed under @xmath95-reduction , if @xmath28 is in @xmath89 then for any @xmath7 ( in @xmath89 or not ) , @xmath96 since @xmath97 .",
    "we therefore need to define the algebraic equality with respect to the particular subset of terms under consideration .",
    "[ def : subeq ] a fragment @xmath89 of @xmath20 ( resp .",
    "@xmath47 ) is a fragment of @xmath19 ( resp .",
    "@xmath15 ) together with an algebraic equality defined as @xmath98 ( resp .",
    "@xmath99 ) if and only if @xmath100 and @xmath101 or @xmath102 ( resp . @xmath103 or @xmath104 ) .",
    "the @xmath59-reduction is not modified .    when referring to a fragment of @xmath20 ( resp .",
    "@xmath47 ) , we use the abuse of notation @xmath58 ( resp .",
    "@xmath57 ) instead of @xmath105 ( resp .",
    "@xmath106 ) for the restricted rewrite system , when the fragment under consideration is clear .",
    "the core of the paper is concerned with the mutual simulations of the four languages .",
    "the first class of problems relates algebraic reduction with algebraic equality . if simulating a language with algebraic reduction with a language with algebraic equality is not specially difficult , going in the opposite direction is not possible in general .",
    "indeed , if @xmath107 is possible in @xmath20 , ( where @xmath24 ) it is difficult to see how one could make @xmath26 go to @xmath28 in @xmath19 without further hypotheses . in this section ,",
    "we show that a fragment of a language with algebraic equality can be simulated by the corresponding fragment with algebraic reduction provided that the latter is _ confluent _ ( theorems  [ th : eqred ] and  [ th : eqred2 ] ) .",
    "the second class of problems is concerned with call - by - value and call - by - name . in this paper , the simulations of call - by - name by call - by - value and its reverse",
    "are treated using continuation passing style ( cps ) , extending the techniques described in  @xcite to the algebraic case ( theorems  [ th : sim ] , [ th : simeq ] , [ th : sim2 ] and  [ th : sim2eq ] ) .",
    "the results are summarised in figure  [ fig : relation ] .",
    "solid arrows correspond to results where no particular hypothesis on the language is made .",
    "dashed arrows correspond to results where confluence is required .      as the relation @xmath90 is contained in @xmath108 and the relation @xmath91",
    "is contained in @xmath109 , the first simulation theorems are trivial .",
    "[ th : redeq ] for any term @xmath28 if @xmath110 , then @xmath111 .",
    "[ th : redeq2 ] for any term @xmath28 if @xmath112 , then @xmath113 .",
    "the simulations going in the other direction are only valid in the presence of confluence . in the following two theorems ,",
    "the algebraic equality is defined with respect to the considered fragment ( see definition [ def : subeq ] . )",
    "[ th : eqred ] for any term @xmath28 in a confluent fragment of @xmath19 , if @xmath114 , then @xmath115 , with @xmath116 .    first note that a value can only reduce to another value .",
    "this follows by direct inspection of the rewriting rules .",
    "we proceed by induction on the length of the reduction .    * if @xmath117 , then choose @xmath118 and note that @xmath119 . *",
    "assume the result true for @xmath120 : there is a value @xmath121 such that @xmath115 and @xmath116 .",
    "let @xmath122 .",
    "case distinction : * * @xmath123 , then @xmath124 which implies @xmath125 . * * @xmath126 , then either @xmath127 , and then this case is analogous to the previous one , or @xmath102 . due to the confluence of the subset , there exists a term @xmath23 such that @xmath128 and @xmath129 , implying that @xmath23 is a value , thus @xmath130",
    ". then we have @xmath130 and @xmath116 , so @xmath131 , closing the case .",
    "[ th : eqred2 ] for any term @xmath28 in a confluent fragment of @xmath15 , if @xmath132 , then @xmath133 , with @xmath134 .",
    "similar to the previous theorem .      to prove the simulation of @xmath19 with @xmath15 and the simulation of @xmath20 with @xmath47",
    ", we introduce an algebraic extension of the continuation passing style used to prove that call - by - name simulates call - by - value in the regular @xmath0-calculus @xcite .",
    "let  @xmath135\\!]}:\\lambda_{{\\ensuremath{\\lambda_{{\\it lin}}}}}\\to\\lambda_{{\\ensuremath{\\lambda_{{\\it alg}}}}}$ ] be the following encoding where @xmath136 and @xmath137 are fresh variables . @xmath138\\ ! ] } & = & { \\lambda f\\,\\left(f\\right)~x } , & { [ \\![{0}]\\ ! ] } & = & 0,\\\\ { [ \\![{\\lambda x\\,m}]\\ ! ] } & = & \\lambda f\\,(f)~\\lambda x\\,{[\\![{m}]\\ ! ] } , & { [ \\![{(m)~n}]\\ ! ] } & = & { { \\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{m}]\\!]}})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n}]\\!]}},\\\\ { [ \\![{\\alpha.m}]\\ ! ] } & = & \\lambda f\\,(\\alpha.{[\\![{m}]\\!]})~f , & { [ \\![{m+n}]\\!]}&=&\\lambda f\\,({[\\![{m}]\\ ! ] } + { [ \\![{n}]\\!]})~f .",
    "\\end{array}\\ ] ] let @xmath139 be the encoding for values defined by @xmath140 , @xmath141 , @xmath142\\!]}$ ] , @xmath143 , @xmath144 .",
    "note that this encoding is compatible with substitution ( proof by induction on @xmath28 ) :    [ 2:lem : substitution ] @xmath145}]\\!]}={[\\![{m}]\\!]}[x:=\\psi(b)]$ ] with @xmath146 a base term .    using this encoding",
    ", we can simulate @xmath19 with @xmath15 , as formalised in the following theorem .",
    "the sketch of the proof is developed in the second part of this section .",
    "[ th : sim ] for any term @xmath28 if @xmath147 where @xmath148 is a value , then @xmath149\\!]})~\\lambda x\\,x    { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}\\psi(v)$ ] .",
    "[ ex:1 ] for any terms @xmath28 and @xmath7 , let @xmath150 .",
    "let @xmath151 be the term @xmath152 , and let @xmath153 and @xmath154 be two values . then @xmath155 and @xmath156 .",
    "we consider the simulation @xmath19 to @xmath15 .",
    "the translation @xmath157\\!]}$ ] is @xmath158\\!]})\\ , \\lambda g\\ , ( { [ \\![{u+v}]\\!]})\\lambda h\\ , ( ( g)\\,h)\\,f$ ] , where @xmath159\\!]}$ ] is the term @xmath160\\!]}$ ] , with @xmath161\\!]}$ ] being @xmath162 , @xmath163\\!]}$ ] being @xmath164\\!]}+{[\\![{v}]\\!]})\\,f$ ] , and @xmath165\\!]}$ ] being @xmath166 .",
    "we now rewrite @xmath167\\!]})\\,\\lambda z\\,z$ ] in @xmath15 .",
    "@xmath168\\!]})\\ , \\lambda g\\ , ( { [ \\![{u+v}]\\!]})\\lambda h\\,((g)\\,h)\\,\\lambda z\\,z \\\\ & = & ( \\lambda f\\ , ( f)\\,\\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\ , \\lambda g\\ , ( { [ \\![{u+v}]\\!]})\\lambda h\\ , ( ( g)\\,h)\\,\\lambda z\\ , z \\\\ & { { \\ensuremath{{\\to_{a\\cup\\beta } } } } } & ( \\lambda g\\ , ( { [ \\![{u+v}]\\!]})\\ , \\lambda h\\ , ( ( g)\\,h)\\,\\lambda z\\ , z)\\ , \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\ ! ] } \\\\ & { { \\ensuremath{{\\to_{a\\cup\\beta } } } } } & ( { [ \\![{u+v}]\\!]})\\,\\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z \\\\ & { { \\ensuremath{{\\to_{a\\cup\\beta } } } } } & ( { [ \\![{u}]\\ ! ] }   + { [ \\![{v}]\\!]})\\ , \\,\\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z\\\\ & { { \\ensuremath{{\\to_{a\\cup\\beta } } } } } & ( { [ \\![{u}]\\!]})\\ , \\,\\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z +   ( { [ \\![{v}]\\!]})\\ , \\,\\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z \\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & ( \\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z)\\ , \\psi(u ) +   ( \\lambda h\\ , ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,h)\\,\\lambda z\\ , z)\\ , \\psi(v ) & ( * ) \\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,\\psi(u))\\,\\lambda z\\ , z   +   ( ( \\lambda x\\ , { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]})\\,\\psi(v))\\,\\lambda z\\ , z   \\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & ( { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]}[x:= \\psi(u)])\\,\\lambda z\\ , z   +   ( { [ \\![{{\\left\\langle x , x\\right\\rangle}}]\\!]}[x:= \\psi(v)])\\,\\lambda z\\ , z    \\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & ( { [ \\![{{\\left\\langle u , u\\right\\rangle}}]\\!]})\\,\\lambda z\\ , z   +   ( { [ \\![{{\\left\\langle v , v\\right\\rangle}}]\\!]})\\,\\lambda z\\ , z \\quad \\textrm{(lemma \\ref{2:lem : substitution } ) } \\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & ( \\lambda z\\ , z ) \\ , \\psi({{\\left\\langle u , u\\right\\rangle } } ) +   ( \\lambda z\\ , z ) \\ , \\psi({{\\left\\langle v , v\\right\\rangle}})&(**)\\\\ & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } &   \\psi({{\\left\\langle u , u\\right\\rangle } } ) +    \\psi({{\\left\\langle v , v\\right\\rangle}})\\\\   & = & \\psi({{\\left\\langle u , u\\right\\rangle } } + { { \\left\\langle v , v\\right\\rangle } } ) \\\\ \\end{array}\\ ] ]    similarly , one can relate fragments of @xmath47 to fragments of @xmath20 as follows .    [",
    "th : simeq ] for any two fragments @xmath169 of @xmath20 and @xmath170 of @xmath47 such that @xmath171 , @xmath149\\!]})~\\lambda x\\,x\\in s_{\\it a}$ ] , and for any term @xmath28 in @xmath169 , if @xmath114 where @xmath148 is a value , then @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{{\\tiny $ = $ } $ \\ast$}}}}}}}\\psi(v)$ ] .",
    "again , the sketch of the proof is developed later in the section .    as we already noted several times in this paper , without restricting the languages , theorem  [ th : simeq ] would be trivial .",
    "any term reducing to any other one , the desired reduction would be of course valid without restriction .",
    "this theorem shows that if the calculi are restricted to fragments , the result is still true .",
    "one example of such fragments is found by taking the restriction of scalars to non - negative elements , as in @xcite .",
    "once a term is encoded it can be reduced either by @xmath172 or by @xmath173 ( respectively @xmath174 or @xmath175 ) without distinction , and still obtain the same result .",
    "we state this fact as a corollary :    [ cor : ind ]   ( 1 ) for any term @xmath28 , if @xmath147 where @xmath148 is a value , then @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{\\ell\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}\\psi(v)$ ] ; ( 2 ) for any fragment @xmath89 of @xmath20 such that @xmath176 , @xmath149\\!]})~\\lambda x\\,x\\in s$ ] , and for any term @xmath28 in @xmath89 , if @xmath114 where @xmath148 is a value , then @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{\\ell\\cup\\beta}^{\\textrm{{\\tiny $ = $ } $ \\ast$}}}}}}}\\psi(v)$ ] .",
    "it suffices to check the proofs of theorems  [ th : sim ] and  [ th : simeq ] to verify that all the reductions @xmath172 are done by rules common in both languages .",
    "[ ex:1-indifference ] note that in example  [ ex:1 ] one could have as well rewrite with @xmath90 which illustrates the indifference property ( corollary [ cor : ind ] ) .",
    "now we proceed to prove theorems  [ th : sim ] and [ th : simeq ] . the proof in @xcite",
    "can be extended to the algebraic case .",
    "[ [ an - administrative - operation . ] ] an administrative operation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    we define a convenient infix operation ( @xmath177 ) capturing the behaviour of translated terms . for example , if @xmath146 is a base term , _",
    "i.e. _ a variable or an abstraction , then its translation into @xmath15 is @xmath178\\!]}={\\lambda f\\,\\left(f\\right)~\\psi(b)}$ ] .",
    "if we apply this translated term to a certain @xmath179 , we obtain @xmath180 .",
    "we define @xmath181 and get that @xmath182\\!]})~k{{\\ensuremath{{\\to_{a\\cup\\beta}}}}}b : k$ ] .",
    "this fact will be generalised to @xmath149\\!]})~k{{\\ensuremath{{\\to_{a\\cup\\beta}}}}}m : k$ ] in lemma  [ lem : lemma2 ] .",
    "let @xmath183 be the infix binary operation defined by : @xmath184\\!]})\\,\\lambda\\,h\\,((g)\\,h)\\,k \\\\",
    "\\end{array}\\ ] ]    [ lem : lemma2 ] if @xmath179 is a base term , then for any @xmath28 , @xmath149\\!]})~k{{\\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}m : k$ ] .",
    "structural induction on @xmath28 .",
    "we give the case @xmath185 , as an example .",
    "first an intermediate result is needed : for any @xmath28 , @xmath186\\!]})~\\lambda h\\,((g)~h)~k$ ] @xmath91 @xmath187 .",
    "this can be proved by structural induction on @xmath28",
    ".    then @xmath188\\!]})~k=({{\\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{m'}]\\!]}})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n}]\\!]}})~k$ ] which @xmath91-reduces to @xmath189\\!]})~\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ] .",
    "note that @xmath190\\!]})~\\lambda h\\,((g)~h)~k$ ] is a base term , so by the induction hypothesis the above term reduces to @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] which by the previous intermediate result , @xmath91-reduces to @xmath192 .",
    "the following lemmas and its corollary state that the @xmath193 operation preserves reduction .",
    "[ lem : lemma3alg ] if @xmath102 then @xmath194 base term , @xmath195 .",
    "induction on the possible rule applied from @xmath102 .",
    "we give one simple case as an example .",
    ". then @xmath197 .",
    "[ lem : lemma3 ] if @xmath198 then @xmath194 base term , @xmath199 .    if @xmath102 , then use lemma  [ lem : lemma3alg ] . if @xmath200 , then we prove it by induction on the possible rule applied ( either @xmath201 , @xmath202 or one of @xmath203 ) .",
    "we give the case of the @xmath201-reduction as an example : @xmath204 , @xmath205-reducing to the term @xmath206\\!]})\\,\\psi(b))\\,k$ ] which @xmath205-reduces to @xmath207\\!]}[x:=\\psi(b)]\\,k$ ] , equal by lemma  [ 2:lem : substitution ] to @xmath145}]\\!]}\\,k$ ] . by lemma  [ lem : lemma2 ] , it @xmath172-reduces to @xmath208:k$ ] .",
    "[ cor : lemma3 ] if @xmath113 then @xmath194 base terms , @xmath209 .    by case distinction .",
    "if @xmath198 , then by lemma  [ lem : lemma3 ] , @xmath199 , which implies @xmath209 .",
    "if @xmath127 , then by lemma  [ lem : lemma3alg ] , @xmath210 , which also implies @xmath209 .    finally , the @xmath193 operation also captures the translation of values in the following way :    [ lem : valuestranslation ] for any value @xmath148 , @xmath211    we proceed by structural induction on @xmath148 .",
    "let @xmath148 be a base term .",
    "then @xmath212 . let @xmath213 .",
    "then @xmath214 , which by the induction hypothesis , reduces to @xmath215 .",
    "let @xmath216 .",
    "then @xmath217 , which by the induction hypothesis , reduces to @xmath218 .",
    ". then @xmath220 .",
    "we discuss example  [ ex:1 ] in the light of these results . the term @xmath221 is equal to the terms @xmath222 and @xmath223 .",
    "the term @xmath224 is equal to the term @xmath225 which reduces to @xmath226 .",
    "so we do have the rewrites requested by lemmas  [ lem : lemma2 ] , [ lem : lemma3 ] and  [ lem : valuestranslation ] .",
    "now the proofs of theorems  [ th : sim ] and  [ th : simeq ] go as follows .    from lemma  [ lem : lemma2 ] , @xmath149\\!]})~\\lambda x\\,x{{\\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}m:\\lambda    x\\,x$ ] and from lemma",
    "[ lem : lemma3 ] , it @xmath172-reduces to @xmath227 . from lemma  [ lem : valuestranslation ] , @xmath228 .    from lemma  [ lem : lemma2 ] ,",
    "@xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}m:\\lambda    x\\,x$ ] , and this implies that @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{{\\tiny $ = $ } $ \\ast$}}}}}}}m:\\lambda x\\,x$ ] . from corollary  [ cor : lemma3 ] , this latter term @xmath174-reduces to @xmath227 . from lemma  [ lem :",
    "valuestranslation ] , @xmath228 , which implies that @xmath229 .",
    "note that since @xmath149\\!]})~\\lambda x\\,x\\in s_{\\it a}$ ] , @xmath230 is also in @xmath231 due to the closeness under @xmath57 of @xmath170 .",
    "the same applies to @xmath232 , thus also to @xmath227 and finally to @xmath233 .",
    "[ [ the - simulation - of - lambdato_it - alg - with - lambdato_it - lin . ] ] the simulation of @xmath234 with @xmath235 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to state that @xmath19 simulates @xmath15 , we use an algebraic extension of the continuation passing style encoding following again  @xcite .",
    "let  @xmath236 be the following encoding where @xmath136 and @xmath137 are fresh variables .",
    "@xmath237 this encoding satisfies two useful properties ( the first is a trivial result and the second follows by induction on @xmath28 ) .",
    "[ 3:lem : base ] for all terms @xmath28 , the term @xmath238 is a base term .",
    "[ 3:lem : substitution ] @xmath239\\}\\hspace{-.55em}|\\hspace{.3em}}={\\{\\hspace{-.235em}| m\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]$ ] .",
    "let @xmath240 be the encoding for values defined by @xmath241 , @xmath242 , @xmath243 @xmath244 , @xmath245 , @xmath246 .",
    "simulation theorems , similar to theorems  [ th : sim ] and  [ th : simeq ] , can be stated as follows .",
    "[ th : sim2 ] for any program @xmath28 ( _ i.e. _ closed term ) , if @xmath247 where @xmath148 is a value , then @xmath248 .",
    "[ th : sim2eq][th : simeq2 ] for any two fragments @xmath170 of @xmath47 and @xmath169 of @xmath20 such that @xmath249 , @xmath250 , and for any program @xmath28 in @xmath170 , if @xmath132 where @xmath148 is a value , then @xmath251 .    a result similar to corollary  [ cor : ind ] can also be formulated .",
    "it is proven in a similar manner .",
    "[ cor : ind2 ] ( 1 ) for any program @xmath28 , if @xmath247 where @xmath148 is a value , then @xmath252 ; ( 2 ) for any fragment @xmath89 of @xmath47 such that @xmath176 , @xmath253 , and for any program @xmath28 in @xmath89 , if @xmath132 where @xmath148 is a value , then @xmath254 .    before moving to the description of the proof of theorems  [",
    "th : sim2 ] and  [ th : sim2eq ] , let us consider an example .",
    "[ ex:2 ] we illustrate theorem  [ th : sim2 ] using the term @xmath255 of example  [ ex:1 ] which reduces to @xmath256 in @xmath19 and to @xmath257 in @xmath15 .",
    "the translation @xmath258 is the term @xmath259 , where @xmath260 is @xmath261 .",
    "@xmath262 is @xmath263 , @xmath264 is @xmath265 and @xmath266 is @xmath267 we now rewrite @xmath268 in @xmath15 .",
    "@xmath269 ) \\,\\lambda z\\,z \\\\",
    "\\textrm{(lemma \\ref{3:lem : substitution } ) } & = &   ( { \\{\\hspace{-.235em}| { \\left\\langle u+v , u+v\\right\\rangle}\\}\\hspace{-.55em}|\\hspace{.3em}})\\,\\lambda z\\,z   \\\\   & { { \\ensuremath{{\\to_{\\ell\\cup\\beta } } } } } &   ( \\lambda z\\,z ) \\ , \\phi({{\\left\\langle u+v , u+v\\right\\rangle } } ) & ( { * } { * } { * } { * } )   \\\\   & { { \\ensuremath{{\\to_{\\ell\\cup\\beta } } } } } &   \\phi({{\\left\\langle u+v , u+v\\right\\rangle } } ) \\end{array}\\ ] ]    [ [ proof - of - the - simulation - theorems . ] ] proof of the simulation theorems .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in section  [ subsec : lintoalg ] , the proofs of the simulations theorems were performed using an administrative operation `` @xmath177 '' and three intermediate results , as follows ( the term @xmath179 is taken as a base term ) .",
    "( 1 ) prove that @xmath149\\!]})\\,k { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}m : k$ ] ; ( 2 ) prove that if @xmath198 then @xmath199 ; ( 3 ) prove that if @xmath148 is a value , @xmath270 . for the simulation theorems of the present section , we use a similar procedure .",
    "[ [ an - administrative - operation.-1 ] ] an administrative operation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    we keep the same notation for the administrative , infix operation defined for the purpose of the proof .",
    "let @xmath271 be the infix binary operation defined by : @xmath272    the three lemmas needed for the proof of the simulation theorems now read as follow .    [ lem : lemma2cps ] if @xmath179 is a base term , for any closed term @xmath28 @xmath273 .",
    "the proof is done by structural induction on @xmath28 .",
    "we follow the sketch of the proof of lemma  [ lem : lemma2 ] , and give the case @xmath185 , as an example .",
    "first we prove by induction on @xmath28 that @xmath274 . then @xmath275 .",
    "note that @xmath276 is a base term , so by the induction hypothesis the above term reduces to @xmath277 which by the previous intermediate result , @xmath90-reduces to @xmath192 .",
    "[ lem : lemma3cps ] if @xmath278 then @xmath194 base term , @xmath279    case by case on the rules of @xmath15 .",
    "we give the case of the @xmath205-reduction as an example : @xmath280 which by lemma  [ 3:lem : base ] , @xmath90-reduces to @xmath281)\\,k$ ] .",
    "this , by lemma  [ 3:lem : substitution ] , is equal to @xmath282\\}\\hspace{-.55em}|\\hspace{.3em}})\\,k$ ] and this , by lemma  [ lem : lemma2cps ] , @xmath173-reduces to @xmath283:k$ ] .",
    "note that in the previous derivation , the reduction @xmath284",
    "@xmath90 @xmath285 $ ] is valid since for any term @xmath7 , @xmath286 is a base term .    [",
    "lem : valuestranslation2 ] if @xmath148 is a value and @xmath179 is a base term , @xmath287 .",
    "we discuss example  [ ex:2 ] in the light of these results .",
    "the term @xmath288 is equal to the terms @xmath222 .",
    "the term @xmath289 is equal to the term @xmath290 which reduces to @xmath291 .",
    "again , we have the rewrites requested by lemmas  [ lem : lemma2cps ] , [ lem : lemma3cps ] and  [ lem : valuestranslation2 ] .",
    "we are now ready to prove the simulation theorems .",
    "as advertised , these proofs reflect the exact same structures of the proofs of theorems  [ th : sim ] and  [ th : simeq ] .",
    "from lemma  [ lem : lemma2cps ] , @xmath292 , from lemma  [ lem : lemma3cps ] it @xmath173-reduces to @xmath227 . from lemma",
    "[ lem : valuestranslation2 ] , @xmath293 .    from lemma  [ lem : lemma2cps ] , @xmath294 , and",
    "this implies that @xmath295 . a result equivalent to corollary  [ cor : lemma3 ] can be shown as easily : if @xmath296 then for all base terms @xmath179 , @xmath297",
    "this entails that @xmath232 @xmath175-reduces to @xmath227 . from lemma  [ lem : valuestranslation2 ] , @xmath287 , which implies that @xmath298 .",
    "note that since @xmath299 , @xmath230 is also in @xmath231 due to the closeness under @xmath58 of @xmath169 .",
    "the same applies to @xmath232 , thus also to @xmath227 and finally to @xmath300 .      in figure",
    "[ fig : relation ] , some arrows are missing .",
    "we are now showing that the already existing arrows `` compose '' well .",
    "the first two simulations are @xmath301 and @xmath302 and do not require confluence .    for any program",
    "@xmath28 , if @xmath147 ( resp .",
    "@xmath247 ) where @xmath148 is a value , then @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{{\\tiny $ = $ } $ \\ast$}}}}}}}\\psi(v)$ ] ( resp .",
    "@xmath303 ) .    given that @xmath147 , by theorem  [ th : sim ] , @xmath149\\!]})~\\lambda x\\,x{{\\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}\\psi(v)$ ] , which by theorem  [ th : redeq ] implies @xmath149\\!]})~\\lambda x\\,x{{\\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{{\\tiny $ = $ } $ \\ast$}}}}}}}\\psi(v)$ ] .",
    "analogously , given that @xmath247 , by theorem  [ th : sim2 ] , @xmath304 , which by theorem  [ th : redeq2 ] implies that @xmath305 @xmath175 @xmath300 .",
    "the other two simulations are @xmath306 and @xmath307 and they do require confluence .    for any program @xmath28 in a confluent fragment of @xmath20 ( resp .",
    "@xmath47 ) , if @xmath114 ( respectively @xmath132 ) then @xmath149\\!]})~\\lambda x\\,x { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}\\psi(v')$ ] with @xmath116 ( respectively @xmath308 with @xmath134 ) .    given that @xmath114 and that @xmath28 is in a confluent fragment , theorem  [ th : eqred ] states that @xmath115 with @xmath116 .",
    "in addition , theorem  [ th : sim ] states that @xmath149\\!]})~\\lambda x\\,x{{\\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$}}}}}}}\\psi(v')$ ] .",
    "the other result is similar using theorems  [ th : eqred2 ] and [ th : sim2 ] .",
    "in this paper we described four canonical algebraic lambda - calculi with vectorial structures , recapitulating the few existing means of writing such a language .",
    "we show how each language can simulate the other , by taking care of marking where confluence is used or not .",
    "as already shown by plotkin @xcite , if the simulation of call - by - value by call - by - name is sound , it fails to be complete for general ( possibly non - terminating ) programs . a known solution to this problem is developed in @xcite .",
    "recent work @xcite shown that the technique can be adapted to the algebraic case to retrieve completeness .",
    "the work @xcite develop a galois connection between call - by - name and call - by - value . a direction for study",
    "is to build on this work to also get a galois connection in the algebraic case .",
    "concerning semantics , the algebraic @xmath0-calculus admits finiteness spaces as a model @xcite .",
    "what is the structure of the model of the linear algebraic @xmath0-calculus induced by the continuation - passing style translation in finiteness spaces ?",
    "the algebraic lambda - calculus can be equipped with a differential operator . what is the corresponding operator in call - by - value through the translation ?    [ [ acknowledgements ] ] acknowledgements + + + + + + + + + + + + + + + +    many thanks to pablo arrighi , ali assaf and lionel vaux for fruitful discussions and suggestions .",
    "this work is supported by the cnrs - ins2i peps project quand .",
    "10    a. assaf and s. perdrix .",
    "completeness of algebraic cps simulations . to appear in",
    "dcm11_. http://membres-lig.imag.fr/perdrix/cps-completeness.html    t. altenkirch and j. j. grattage . a functional quantum programming language . in _ proc .",
    "lics05 _ , pp 249258 .",
    "p. arrighi and a. daz - caro .",
    "scalar system f for linear - algebraic @xmath0-calculus : towards a quantumphysical logic . in _ proc.qpl09_,vol .",
    "270 - 2 of _ entcs _ , pp 219229 .",
    "p. arrighi , a. daz - caro , and b. valiron .",
    "a type system for the vectorial aspects of the linear - algebraic lambda - calculus . to appear in _ proc .",
    "dcm11_. http://membres-liglab.imag.fr/diazcaro/vectorial.pdf    p. arrighi and g. dowek . a computational definition of the notion of vectorial space . in _ proc .",
    "wrla04 _ , vol .",
    "117 of _ entcs _ , pp . 249261 .",
    "p. arrighi and g. dowek .",
    "linear - algebraic lambda - calculus : higher - order , encodings , and confluence . in _ proc .",
    "rta08 _ , vol .",
    "5117 of _ lncs _ , pp . 1731 .",
    "p. buiras , a. daz - caro , and m. jaskelioff .",
    "lower bounds for scalars in a typed algebraic @xmath0-calculus .",
    "preprint at arxiv:1102.0749 , february 2011 .    .",
    "inria , 8.2 edition .",
    "a. daz - caro , s. perdrix , c. tasson , and b. valiron .",
    "equivalence of algebraic @xmath0-calculi . in",
    "_ informal pro .",
    "hor10 _ , pp 611 .",
    "a. daz - caro and b. petit .",
    "sums in linear algebraic lambda - calculus .",
    "preprint at arxiv:1011.3542 ,",
    "november 2010 .",
    "t. ehrhard .",
    ", 12(5):579623,2003 .",
    "t. ehrhard .",
    "finiteness spaces . , 15(4):615646 , 2005 .",
    "t. ehrhard . afinitenessstructureonresourceterms .",
    "in_proc.lics10_,pp.402410 .    t.ehrhardandl.regnier .",
    ", 309(1):141,2003 .",
    "m.  j. fischer .",
    "@xmath0-calculus schemata .",
    ", 7(1):104109 , 1972 .",
    "m. pagani and s. ronchi  della rocca .",
    "solvability in resource lambda calculus . in _ proc .",
    "fossacs10 _ , vol .",
    "6014 of _ lncs _ , pp . 358373 .",
    "m. pagani and p. tranquilli .",
    "parallel reduction in resource lambda - calculus . in _ proc .",
    "aplas09 _ ,",
    "5904 of _ lncs _ , pp . 226242 .",
    "g.d.plotkin.callbyname,callbyvalueandthe@xmath0-calculus._tcs_,1(2):125-159,1975 .",
    "areflexiononcall - by - value . 19(6):916941 , 1997 .",
    "c. tasson .",
    "algebraic totality , towards completeness . in _ proc .",
    "tlca09 _ , vol .",
    "5608 of _ lncs _ , pp 325340 .    .",
    "cambridge university press , 2003 .",
    "b. valiron .",
    "semantics of a typed algebraic lambda - calculus . in _ proc .",
    "dcm10 _ , vol .",
    "26 of _ eptcs _ , pp . 147158 .",
    "b. valiron .",
    "coq proof .",
    "http://www.monoidal.net/vectorial-alglin-coqproof-v2.tgz .",
    "b. valiron .",
    "orthogonality and algebraic @xmath0-calculus . in _ proc .",
    "qpl10 _ , pp .",
    "169175 .",
    "l. vaux . on linear combinations of @xmath0-terms . in _ proc .",
    "4533 of _ lncs _ , pp . 374388 .",
    "l. vaux . the algebraic lambda calculus .",
    ", 19(5):10291059 , 2009 .",
    "* if @xmath93 and @xmath309 , using only algebraic rules , then this has been already proven in lemma  [ locallyconfluence ] .",
    "* if @xmath93 and @xmath309 , using only beta - reduction , this is a trivial extension of the confluence of lambda calculus . *",
    "if @xmath93 by an algebraic rule and @xmath309 by beta reduction , then in @xmath19 a term of the form @xmath310 has to be a subterm of @xmath28 , since @xmath28 beta - reduces . note that @xmath311 can not reduce since it is under a lambda and @xmath146 can not reduce since it is a base term .",
    "then the beta - reduction and the algebraic - reduction are independent in @xmath19 , and so this result is trivial . in @xmath15 a term of the form",
    "@xmath312 has to be a subterm of @xmath28 .",
    "note that @xmath311 can not reduce since it is under a lambda and @xmath7 can not reduce since it is an argument . then again the beta - reduction and the algebraic - reduction are independent in @xmath15 , and so this result is trivial .      structural induction on @xmath28 .",
    ". cases : * * @xmath314 . then @xmath208=y$ ] , and so @xmath145}]\\!]}={\\lambda f\\,\\left(f\\right)~y}={\\lambda f\\,\\left(f\\right)~x}[y / x]={[\\![{m}]\\!]}[x:=\\psi(b)]$ ] . * * @xmath315",
    ". then @xmath145}]\\!]}={\\lambda f\\,\\left(f\\right)~\\lambda y\\,{[\\![{n}]\\!]}}={\\lambda f\\,\\left(f\\right)~x}[\\lambda y\\,{[\\![{n}]\\!]}/x]={[\\![{m}]\\!]}[x:=\\psi(b)]$ ] . * @xmath316",
    ". then @xmath145}]\\!]}={[\\![{m}]\\!]}[x:=\\psi(b)]={[\\![{m}]\\!]}$ ] .",
    "* @xmath317 .",
    "analogous to previous case .",
    "* @xmath318 . then @xmath319}]\\!]}&=&{[\\![{\\lambda y\\,(n[x:=b])}]\\!]}\\\\    & = & { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{[\\![{n[x:=b]}]\\!]}}\\\\ & &    \\textrm{by the induction hypothesis}\\\\    & = & { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{[\\![{n}]\\!]}[x:=\\psi(b)]}\\\\    & = & ( { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{[\\![{n}]\\!]}})[x:=\\psi(b)]\\\\    & = & { [ \\![{m}]\\!]}[x:=\\psi(b ) ]   \\end{aligned}\\ ] ] * @xmath320 . then @xmath321}]\\ ! ] } & = & { [ \\![{((n_1)~n_2)[x:=b]}]\\!]}\\\\    & = & { [ \\![{(n_1[x:=b])~n_2[x:=b]}]\\!]}\\\\    & = & { { \\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{n_1[x:=b]}]\\!]}})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n_2[x:=b]}]\\!]}}\\\\ & &    \\textrm{by the induction hypothesis}\\\\    & = & { { \\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{n_1}]\\!]}[x:=\\psi(b)]})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n_2}]\\!]}[x:=\\psi(b)]}\\\\    & = & { { \\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{n_1}]\\!]}})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n_2}]\\!]}}[x:=\\psi(b)]\\\\    & = & { [ \\![{(n_1)~n_2}]\\!]}[x:=\\psi(b)]\\\\    & = & { [ \\![{m}]\\!]}[x:=\\psi(b ) ]    \\end{aligned}\\ ] ] * @xmath322 . then @xmath323}]\\ ! ] } & = & { [ \\![{(\\alpha.n)[x:=b]}]\\!]}\\\\                  & = & { [ \\![{\\alpha.(n[x:=b])}]\\!]}\\\\                  & = & { \\lambda f\\,({\\alpha.{[\\![{n[x:=b]}]\\!]}}\\,f)}\\\\ & &                          \\textrm{by the induction hypothesis}\\\\               & = & { \\lambda f\\,({\\alpha.{[\\![{n}]\\!]}[x:=\\psi(b)]}\\,f)}\\\\                   & = & ( { \\lambda f\\,({\\alpha.{[\\![{n}]\\!]}}\\,f)})[x:=\\psi(b)]\\\\                  & = & { [ \\![{\\alpha.n}]\\!]}[x:=\\psi(b)]\\\\                  & = & { [ \\![{m}]\\!]}[x:=\\psi(b ) ]               \\end{aligned}\\ ] ] * @xmath324",
    ". then @xmath323}]\\ ! ] } & = & { [ \\![{(n_1+n_2)[x:=b]}]\\!]}\\\\                  & = & { [ \\![{n_1[x:=b]+n_2[x:=b]}]\\!]}\\\\                  & = & { \\lambda f\\,({({[\\![{n_1[x:=b]}]\\!]}+{[\\![{n_2[x:=b]}]\\!]})}\\,f)}\\\\                          & & \\textrm{by the induction hypothesis}\\\\              & = & { \\lambda f\\,({({[\\![{n_1}]\\!]}[x:=\\psi(b)]+{[\\![{n_2}]\\!]}[x:=\\psi(b)])}\\,f)}\\\\                  & = & ( { \\lambda f\\,({({[\\![{n_1}]\\!]}+{[\\![{n_2}]\\!]})}\\,f)})[x:=\\psi(b)]\\\\                  & = & { [ \\![{n_1+n_2}]\\!]}[x:=\\psi(b)]\\\\                  & = & { [ \\![{m}]\\!]}[x:=\\psi(b ) ]                  \\end{aligned}\\ ] ]      structural induction on @xmath28 .    * @xmath313 . then @xmath325\\!]})~k=({\\lambda f\\,\\left(f\\right)~x})~k { { \\ensuremath{{\\to_{a\\cup\\beta}}}}}(k)~x = x : k$ ] .",
    "* @xmath326 . then @xmath327\\!]})~k=({\\lambda f\\,\\left(f\\right)~\\lambda x\\,{[\\![{n}]\\!]}})~k$ ] and by definition of @xmath139 this is equal to @xmath328 .",
    "* @xmath317 . then @xmath329\\!]})~k = ( 0)~k { { \\ensuremath{{\\to_{a\\cup\\beta}}}}}0 = 0:k$ ] . * @xmath330 . then @xmath331\\!]})~k = ( \\lambda f\\ , ( { [ \\![{m'}]\\!]}+{[\\![{n}]\\!]})~f)~k$ ] which @xmath91-reduces to @xmath189\\!]}+{[\\![{n}]\\!]})~k { { \\ensuremath{{\\to_{a\\cup\\beta}}}}}({[\\![{m'}]\\!]})~k+({[\\![{n}]\\!]})~k $ ] which @xmath91-reduces by the induction hypothesis to @xmath332 . * @xmath333 . then @xmath334\\!]})~k = ( \\lambda f\\ , ( \\alpha .",
    "{ [ \\![{n}]\\!]})~f)~k { { \\ensuremath{{\\to_{a\\cup\\beta}}}}}(\\alpha . { [ \\![{n}]\\!]})~k$ ] which @xmath91-reduces to @xmath335\\!]})~k)$ ] and this , by the induction hypothesis , @xmath91-reduces to @xmath336 . * @xmath185",
    ". then @xmath188\\!]})~k=({{\\lambda{f}\\,({}})~\\lambda{g}\\,({{[\\![{m'}]\\!]}})~\\lambda{h}\\,(({g})~{h})~{f}}{{[\\![{n}]\\!]}})~k$ ] which @xmath91-reduces to @xmath189\\!]})~\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ] .",
    "notice that the term @xmath190\\!]})~\\lambda h\\,((g)~h)~k$ ] is a value , so by the induction hypothesis the above term reduces to @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] .",
    "we do a second induction , over @xmath311 , to prove that @xmath191\\!]})~\\lambda h\\,((g)~h)~k{{\\ensuremath{{\\to_{a\\cup\\beta}}}}}(m')~n : k$ ] . * * if @xmath337 , then @xmath191\\!]})~\\lambda h\\,((g)~h)~k=((m_1)~m_2)~n : k=(m')~n : k$ ] . * * if @xmath311 is a base term , then @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is equal to @xmath338\\!]})~\\lambda h\\,((g)~h)~k)~\\psi(m'){{\\ensuremath{{\\to_{a\\cup\\beta}}}}}({[\\![{n}]\\!]})~\\lambda h\\,((\\psi(m'))~h)~k$ ] which by the main induction hypothesis @xmath91-reduces to @xmath339 , and this is equal to @xmath192 . * * if @xmath340 , then the term @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is equal to @xmath341\\!]})~\\lambda h\\,((g)~h)~k = \\alpha.(m_1:\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k)$ ] which by the second induction hypothesis @xmath91-reduces to @xmath342 . * * if @xmath343 , then @xmath191\\!]})~\\lambda h\\,((g)~h)~k = m_1+m_2 : \\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ] which is equal to @xmath344\\!]})~\\lambda h\\,((g)~h)~k+m_2 : \\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ] which @xmath91-reduces by the second induction hypothesis to @xmath345 . * * if @xmath346 then @xmath186\\!]})~\\lambda h\\,((g)~h)~k= 0 : \\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k = 0= ( 0)~n : k = ( m')~n : k$ ]      case by case on the rules @xmath56 .    rules @xmath347 : :       +    * @xmath348 ,    with @xmath146 being a base term . then    @xmath349 .",
    "* @xmath350 ,    with @xmath146 base term .",
    "then    @xmath351    @xmath352 .",
    "* @xmath353 , with    @xmath146 a base term . then    @xmath354 .",
    "rules @xmath355 : :       +    * @xmath356 , with    @xmath148 being a value",
    ". then    @xmath357 .",
    "* @xmath358 ,    with @xmath148 being a value",
    ". then    @xmath359 .",
    "* @xmath360 , with    @xmath148 a value .",
    "then @xmath361 .",
    "rules @xmath362 and @xmath89 : :       +    * @xmath363",
    ".    then    @xmath364 .    * @xmath365",
    ".    then    @xmath366 .    * @xmath367 .    then    @xmath368 .    * @xmath369",
    ". then    @xmath370 .    * @xmath371",
    ". then    @xmath372 .",
    ".    then    @xmath374    which @xmath55-reduces to    @xmath375 .    * @xmath376",
    ". then    @xmath377 .    * @xmath378",
    ". then    @xmath379 .    * @xmath380",
    ". then    @xmath381 .",
    "rules @xmath382 and @xmath383 : :       +    * @xmath384",
    ". then    @xmath385 .    * @xmath386 . then    @xmath387 .",
    "rules @xmath203 and @xmath202 : :    assume @xmath388 , and assume that    for all @xmath179 base term ,    @xmath389 .",
    "we show that    the result also holds for each contextual rule .",
    "+    * @xmath390",
    ". then    @xmath391 .",
    "* @xmath392 , analogous to    previous case .    * @xmath393 . then    @xmath394 .    * @xmath395 .",
    "case by    case :    * * @xmath396 .",
    "then    @xmath397 which    @xmath55-reduces by the induction    hypothesis to @xmath398 .    * * @xmath399 .",
    "then @xmath400 .    *",
    ". then    @xmath402    which @xmath55-reduces by the    induction hypothesis to    @xmath403 .    * * @xmath213",
    ". then    @xmath404    which @xmath55-reduces by the    induction hypothesis to    @xmath405 .",
    "* @xmath406 case by case :    * * @xmath407 .",
    "absurd since a base term can not reduce .",
    "* * @xmath408 .",
    "case by case on the possible    @xmath56-reductions of    @xmath28 :    * * * @xmath409 with    @xmath410",
    ". then    @xmath411    which by the induction hypothesis    @xmath55-reduces to    @xmath412 .    * * * @xmath413 and    @xmath414",
    ". then    @xmath415 .    * * * @xmath416 and    @xmath417 .",
    "then    @xmath418 .    * * * @xmath419 and @xmath420",
    ". then    @xmath421 .    * * * @xmath422 and @xmath346",
    ". then    @xmath423 .    * * * @xmath424 and @xmath346",
    ". then    @xmath425 .    * * @xmath426 .",
    "case by case on the possible    @xmath56-reductions of    @xmath28 :    * * * @xmath427 with    @xmath428 . then    @xmath429 which by the induction    hypothesis @xmath55-reduces to    @xmath430 .    * * * @xmath431 with    @xmath432 .",
    "analogous to    previous case .",
    "* * * @xmath433 and @xmath434 . then    @xmath435 and    this @xmath55-reduces to    @xmath436 .    * * * @xmath437 and @xmath438 .",
    "analogous to previous case .    *",
    "* * @xmath439",
    ". then    @xmath440 .    * * * @xmath441 , @xmath442 and    @xmath443",
    ". then    @xmath444 .    * * * @xmath441 , @xmath445 and    @xmath446 .",
    "analogous to previous case .    *",
    "* * @xmath447 and @xmath448 .",
    "analogous to    previous case .    *",
    "* @xmath317 .",
    "absurd since @xmath26 does not reduce .",
    "* * @xmath449 .",
    "then the term    @xmath450 is equal to    @xmath451\\!]})~\\lambda h\\,((g)~h)~k$ ] ,    which by the induction hypothesis    @xmath55-reduces to    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] .",
    "we    do a second induction , over @xmath311 , to prove that    @xmath191\\!]})~\\lambda h\\,((g)~h)~k{{\\ensuremath{{\\to_{a}}}}}(m')~n : k$ ] .    *",
    "* * if @xmath452 , then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to @xmath453 .",
    "* * * @xmath311 can not be a base term since from    @xmath454 it is not possible to arrive to a base term    using only @xmath56 .    * * * if @xmath455 , then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k= \\alpha.m'_1:\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k=\\alpha.(m'_1:\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k)$ ]    which @xmath55-reduces by the    induction hypothesis to    @xmath456 .    * * * if @xmath457 , then the term    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to    @xmath458\\!]})~\\lambda h\\,((g)~h)~k$ ]    which is equal to    @xmath459\\!]})~\\lambda h\\,((g)~h)~k+m'_2 : \\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ]    which @xmath55-reduces by the    induction hypothesis to    @xmath460 .    * * * if @xmath346 then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to    @xmath461\\!]})~\\lambda h\\,((g)~h)~k = 0= ( 0)~n : k = ( m')~n : k$ ]      case by case on the rules of @xmath2 .",
    "rule @xmath201 : :    @xmath462\\!]})\\,\\psi(b))\\,k\\\\            & { { \\ensuremath{{\\to_{\\beta_n}}}}}&{[\\![{m}]\\!]}[x:=\\psi(b)]\\,k\\\\            ( \\textrm{lemma~\\ref{2:lem : substitution}})&=&{[\\![{m[x:=b]}]\\!]}\\,k\\\\            ( \\textrm{lemma~\\ref{lem : lemma2 } } ) & { { \\ensuremath{{{\\to_{a\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & m[x:=b]:k          \\end{aligned}\\ ] ] algebraic rules : :    if @xmath102 , then by    lemma  [ lem : lemma3alg ]    @xmath195 which implies    that    @xmath199 . rules",
    "@xmath203 and @xmath202 : :    if @xmath388 , then we use    lemma  [ lem : lemma3alg ] to close the case .",
    "assume    @xmath463 , and assume that for    all @xmath179 base term ,    @xmath464 .",
    "we show that the result also holds for each contextual rule .",
    "+    * @xmath465",
    ". then    @xmath466 .",
    "* @xmath467 , analogous to    previous case .",
    ".    then    @xmath469 .    *",
    "case by    case :    * * @xmath396 .",
    "then    @xmath397 which    @xmath91-reduces by the    induction hypothesis to    @xmath398 .",
    "* * @xmath399",
    ". then @xmath400 .    *",
    "* @xmath401 .",
    "then    @xmath402    which @xmath91-reduces by the    induction hypothesis to    @xmath403 .    * * @xmath213",
    ". then    @xmath404    which @xmath91-reduces by the    induction hypothesis to    @xmath405 .    * @xmath471 case by    case :    * * @xmath407 .",
    "absurd since a base term can not reduce .    *",
    "* @xmath408 .",
    "the only possible    @xmath472-reduction from    @xmath28 is @xmath409 with    @xmath473",
    ". then    @xmath411    which by the induction hypothesis    @xmath91-reduces to    @xmath412 .",
    "* * @xmath426 .",
    "case by case on the possible    @xmath472-reductions of    @xmath28 :    * * * @xmath427 with    @xmath474 .",
    "then    @xmath429 which by the induction    hypothesis @xmath91-reduces    to @xmath430 .",
    "* * * @xmath431 with    @xmath475 .",
    "analogous to    previous case .    *",
    "* @xmath317 .",
    "absurd since @xmath26 does not reduce .    *",
    "* @xmath449 .",
    "then the term    @xmath450 is equal to    @xmath451\\!]})~\\lambda h\\,((g)~h)~k$ ] ,    which @xmath91-reduces , by    the induction hypothesis , to    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] .",
    "we    do a second induction , over @xmath311 , to prove that    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ]    @xmath91-reduces to    @xmath192 .    *",
    "* * if @xmath452 , then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to @xmath453 .    * * * if @xmath311 is a base term , then the term    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to    @xmath338\\!]})~\\lambda h\\,((g)~h)~k)~\\psi(m')$ ]    which @xmath91-reduces to    @xmath476\\!]})~\\lambda h\\,((\\psi(m'))~h)~k$ ] which , by    lemma  [ lem : lemma2 ] ,    @xmath91-reduces    @xmath477 .    * * * if @xmath455 , then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k= \\alpha.m'_1:\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k=\\alpha.(m'_1:\\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k)$ ]    which @xmath91-reduces by the    induction hypothesis to    @xmath456 .    * * * if @xmath457 , then the term    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to    @xmath458\\!]})~\\lambda h\\,((g)~h)~k$ ]    which is equal to    @xmath459\\!]})~\\lambda h\\,((g)~h)~k+m'_2 : \\lambda g\\,({[\\![{n}]\\!]})~\\lambda h\\,((g)~h)~k$ ]    which @xmath91-reduces by the    induction hypothesis to    @xmath460 .    * * * if @xmath346 then    @xmath191\\!]})~\\lambda h\\,((g)~h)~k$ ] is    equal to    @xmath461\\!]})~\\lambda h\\,((g)~h)~k = 0= ( 0)~n : k = ( m')~n : k$ ]      structural induction on @xmath28 .",
    ". then @xmath478\\}\\hspace{-.55em}|\\hspace{.3em}}={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}=x[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]={\\{\\hspace{-.235em}| x\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]$ ] . * @xmath316",
    ". then @xmath479\\}\\hspace{-.55em}|\\hspace{.3em}}=y={\\{\\hspace{-.235em}| y\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]$ ] . *",
    "analogous to previous case .",
    "* @xmath480 . then @xmath481\\}\\hspace{-.55em}|\\hspace{.3em}}&=&{\\{\\hspace{-.235em}| \\lambda y\\,(m'[x:=n])\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{\\{\\hspace{-.235em}| m'[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}}\\\\ & &        \\textrm{by the induction hypothesis}\\\\        & = & { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{\\{\\hspace{-.235em}| m'\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]}\\\\        & = & ( { \\lambda f\\,\\left(f\\right)~\\lambda y\\,{\\{\\hspace{-.235em}| m'\\}\\hspace{-.55em}|\\hspace{.3em}}})[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| m\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em } } ]      \\end{aligned}\\ ] ] * @xmath320 . then @xmath482\\}\\hspace{-.55em}|\\hspace{.3em } } & = & { \\{\\hspace{-.235em}| ( ( n_1)~n_2)[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & { \\{\\hspace{-.235em}| ( n_1[x:=n])~n_2[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & \\lambda f\\,({\\{\\hspace{-.235em}| n_1[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}})~\\lambda g\\,((g)~{\\{\\hspace{-.235em}| n_2[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}})~f\\\\ & &        \\textrm{by the induction hypothesis}\\\\        & = & \\lambda f\\,({\\{\\hspace{-.235em}| n_1\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}])~\\lambda g\\,((g)~{\\{\\hspace{-.235em}| n_2\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}])~f\\\\        & = & ( \\lambda f\\,({\\{\\hspace{-.235em}| n_1\\}\\hspace{-.55em}|\\hspace{.3em}})~\\lambda g\\,((g)~{\\{\\hspace{-.235em}| n_2\\}\\hspace{-.55em}|\\hspace{.3em}})~f)[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| ( n_1)~n_2\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| m\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em } } ]       \\end{aligned}\\ ] ] * @xmath483 . then @xmath482\\}\\hspace{-.55em}|\\hspace{.3em } } & = & { \\{\\hspace{-.235em}| ( \\alpha.m')[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & { \\{\\hspace{-.235em}| \\alpha.(m'[x:=n])\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & \\lambda f\\ , ( \\alpha.{\\{\\hspace{-.235em}| m'[x:=n]))\\}\\hspace{-.55em}|\\hspace{.3em } } ) ~f\\\\        \\textrm{by the induction hypothesis}\\\\        & = & \\lambda f\\ , ( \\alpha.{\\{\\hspace{-.235em}| m'\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}])~f\\\\        & = & \\lambda f\\ , ( \\alpha.{\\{\\hspace{-.235em}| m'\\}\\hspace{-.55em}|\\hspace{.3em}})~f[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| \\alpha.m'\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| m\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em } } ]       \\end{aligned}\\ ] ] * @xmath324 . then @xmath482\\}\\hspace{-.55em}|\\hspace{.3em } } & = & { \\{\\hspace{-.235em}| ( n_1+n_2)[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & { \\{\\hspace{-.235em}| n_1[x:=n]+n_2[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\\\        & = & \\lambda f\\ , ( { \\{\\hspace{-.235em}| n_1[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}+{\\{\\hspace{-.235em}| n_2[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}})~f\\\\ & &        \\textrm{by the induction hypothesis}\\\\        & = & \\lambda f\\ , ( { \\{\\hspace{-.235em}| n_1\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]+{\\{\\hspace{-.235em}| n_2\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}])~f\\\\        & = & \\lambda f\\ , ( ( { \\{\\hspace{-.235em}| n_1\\}\\hspace{-.55em}|\\hspace{.3em}}+{\\{\\hspace{-.235em}| n_2\\}\\hspace{-.55em}|\\hspace{.3em}})~f [ x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| n_1+n_2\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em}}]\\\\        & = & { \\{\\hspace{-.235em}| m\\}\\hspace{-.55em}|\\hspace{.3em}}[x:={\\{\\hspace{-.235em}| n\\}\\hspace{-.55em}|\\hspace{.3em } } ]      \\end{aligned}\\ ] ]      structural induction on @xmath28 .    * @xmath326 . then @xmath484 and by definition of @xmath240 this is equal to @xmath485 . * @xmath317",
    ". then @xmath486 . *",
    "then @xmath487 which @xmath90-reduces by the induction hypothesis to @xmath332",
    ". * @xmath333 .",
    "then @xmath488 which @xmath90-reduces to @xmath489 and this , by the induction hypothesis , @xmath90-reduces to @xmath336",
    ". * @xmath185 . then @xmath490 which @xmath90-reduces to @xmath491 .",
    "note that @xmath276 is a value , so by the induction hypothesis the above term reduces to @xmath277 .",
    "we do a second induction , over @xmath311 , to prove that @xmath492 . * * if @xmath337 , then @xmath493 . * * if @xmath311 is a base term , @xmath494 which @xmath90-reduces to @xmath495 . * * if @xmath340 , then @xmath496 which @xmath173-reduces by the induction hypothesis to @xmath497 . * * if @xmath343 , then @xmath498 which is equal to @xmath499 which @xmath173-reduces by the induction hypothesis to @xmath345 . * * if @xmath346 then @xmath500      case by case on the rules of @xmath501 .    rule @xmath201 : :    @xmath502\\,k\\\\          ( \\textrm{lemma~\\ref{3:lem : substitution}})&=&{\\{\\hspace{-.235em}| m[x:=n]\\}\\hspace{-.55em}|\\hspace{.3em}}\\,k\\\\          ( \\textrm{lemma~\\ref{lem : lemma2cps } } ) & { { \\ensuremath{{{\\to_{\\ell\\cup\\beta}^{\\textrm{$\\ast$ } } } } } } } & m[x:=n]:k        \\end{aligned}\\ ] ] rules @xmath503 : :    * let    @xmath504 .    @xmath505 .    *",
    "let    @xmath506 .",
    "@xmath507    * let @xmath508 .",
    "@xmath509 rules @xmath362 and @xmath89 : :       +    * @xmath510",
    ".    then    @xmath511 .    * @xmath512",
    ".    then    @xmath513 .",
    ".    then    @xmath515 .    * @xmath516",
    ". then    @xmath517 .    * @xmath518",
    ". then    @xmath519 .",
    ".    then    @xmath374    which @xmath90-reduces to    @xmath375 .    * @xmath521",
    ". then    @xmath522 .",
    ". then    @xmath524 .    * @xmath525",
    ". then    @xmath526 .",
    "rules @xmath382 and @xmath383 : :       +    * @xmath527 .    then    @xmath528 .    *",
    ". then    @xmath530 .",
    "rules @xmath203 : :    assume @xmath531 , and that    for all @xmath179 base term ,    @xmath532 .    we show that the result also holds for each contextual rule .",
    "+    * @xmath533",
    ". then    @xmath534 .    * @xmath535 , analogous    to previous case .    *",
    ".    then    @xmath537 .    * @xmath538 case by    case :    * * @xmath407 .",
    "absurd since a base term can not reduce .",
    "* * @xmath408 .",
    "case by case on the possible    @xmath91-reductions of    @xmath28 :    * * * @xmath409 with    @xmath539",
    ". then    @xmath411    which by the induction hypothesis    @xmath90-reduces to    @xmath412 .    * * * @xmath413 and    @xmath414",
    ". then    @xmath540 .    * * * @xmath416 and    @xmath417 .",
    "then    @xmath541 .    * * * @xmath419 and @xmath420",
    ". then    @xmath542 .    * * * @xmath422 and @xmath346",
    ". then    @xmath543 .    * * * @xmath424 and @xmath346",
    ". then    @xmath544 .    * * @xmath426 .",
    "case by case on the possible    @xmath91-reductions of    @xmath28 :    * * * @xmath427 with    @xmath545 . then    @xmath429 which by the induction    hypothesis    @xmath90-reduces to    @xmath430 .    * * * @xmath431 with    @xmath546 .",
    "analogous to    previous case .    *",
    "* * @xmath433 and @xmath434 . then    @xmath435    which @xmath90-reduces to    @xmath436 .    * * * @xmath437 and @xmath438 .    analogous to previous case .    * * * @xmath439",
    ". then    @xmath547 .    * * * @xmath441 , @xmath442 and    @xmath443 .",
    "then    @xmath548 .    * * * @xmath441 , @xmath445 and    @xmath446 .",
    "analogous to previous case .    *",
    "* * @xmath447 and @xmath448 .",
    "analogous to    previous case .    *",
    "* @xmath317 .",
    "absurd since @xmath26 does not reduce .",
    "* * @xmath449 . then @xmath450 is    equal to    @xmath549 ,    which by the induction hypothesis    @xmath90-reduces to    @xmath277",
    ".    we do a second induction , over @xmath311 , to prove that    @xmath492 .    *",
    "* * if @xmath452 , then    @xmath550 .    * * * if @xmath311 is a base term , then    @xmath277    is equal to    @xmath551 .    * * * if @xmath455 , then    @xmath552    is equal to    @xmath553    which    @xmath173-reduces    by the induction hypothesis to    @xmath456 .    * * * if @xmath457 , then    @xmath554    which is equal to    @xmath555    which    @xmath173-reduces    by the induction hypothesis to    @xmath460 .    *",
    "* * if @xmath346 then    @xmath500",
    "the proof of the local confluence of the algebraic fragments of @xmath19 and @xmath15 are sufficiently monotonous so that one can ask a proof assistant to do them . for this purpose",
    "we use the library locconf setting up some convenient tactics .",
    "the interested reader can find the whole set of files in @xcite :                            hypothesis s_0_1_dec : ~ s1 = s0 .",
    "hypothesis s_0_lunit : forall a , s0 + a = a. hypothesis s_0_lelim : forall a , s0 * a = s0 .",
    "hypothesis s_1_lunit : forall a , s1 * a = a. hypothesis s_rdistrib : forall a b c , a*(b+c ) = ( a*b)+(a*c )",
    ". hypothesis s_ldistrib : forall a b c , ( a+b)*c = ( a*c)+(b*c ) .",
    "hypothesis s_add_assoc : forall a b c , ( a+b)+c = a+(b+c ) .",
    "hypothesis s_mul_assoc : forall a b c , ( a*b)*c = a*(b*c ) .",
    "hypothesis s_add_commut : forall a b , a+b = b+a",
    ". hypothesis s_mul_commut : forall a b , a*b = b*a .                        notation \" a + b \" : = ( tadd a b ) : term_scope .",
    "notation \" a ' * * ' b \" : = ( tmul a b ) ( at level 35 ) : term_scope . notation \" @ a \" : = ( tvar a ) ( at level 10 ) : term_scope . notation \" a ; b \" : = ( tapply a b ) ( at level 30 ) : term_scope .",
    "notation \" \\ a \" : = ( tlambda a ) ( at level 40 ) : term_scope .",
    "( * * elementary rules * ) definition r_t0_runit : = forall t , r ( t + t0 ) t. definition r_s0_anni : = forall t , r ( s0 * * t ) t0 .",
    "definition r_s1_unit : = forall t , r ( s1 * * t ) t. definition r_t0_anni : = forall a , r ( a * * t0 ) t0 .",
    "definition r_mul_abs : =     forall a b t , r ( a * * ( b * * t ) ) ( ( a * s b ) * * t ) .",
    "definition r_ma_dist : =     forall a s t , r ( a * * ( s + t ) ) ( a * * s + a * * t ) .",
    "( * * factorization * ) definition r_add_fact : =     forall a b t , r ( a * * t + b * * t ) ( ( a + s b ) * * t ) .",
    "definition r_add_fact1 : =     forall a t , r ( a * * t + t ) ( ( a + s s1 ) * * t ) .",
    "definition r_add_fact11 : = forall t , r ( t + t ) ( ( s1 + s s1 ) * * t ) .",
    "( * * assoc . and commut .",
    "of addition * ) definition r_add_com : = forall s t , r ( s + t ) ( t + s ) .",
    "definition r_add_rassoc : =     forall r s t , r ( ( r + s ) + t ) ( r + ( s + t ) ) .",
    "definition r_add_lassoc : =     forall r s t , r ( r + ( s + t ) ) ( ( r + s ) + t ) .",
    "( * * congruence * ) definition r_cong_mul : = forall a s t , r s t - > r ( a**s ) ( a**t ) .",
    "definition r_cong_ladd : = forall u s t , r s t - > r ( s+u ) ( t+u ) .",
    "definition r_cong_radd : = forall u s t , r s t - > r ( u+ s ) ( u+t ) .",
    "definition r_cong_lapp : = forall u s t , r s t - > r ( s;u ) ( t;u ) .",
    "definition r_cong_rapp : =    forall u s t , is_value u - > r s t - > r ( u;s ) ( u;t ) .",
    "( * * linearity of application * ) definition r_add_app_ldist : =      forall r s t , is_value",
    "t - > r ( ( r + s);t ) ( r;t + s;t ) .",
    "definition r_mul_app_ldist : =      forall a r s , is_value s - > r ( ( a**r);s ) ( a**(r;s ) ) .",
    "definition r_t0_app_ldist : =      forall s , is_value s - > r ( t0;s ) t0 .",
    "definition r_add_app_rdist : =      forall r s t , is_base t - > r",
    "( t;(r + s ) ) ( t;r + t;s ) .",
    "definition r_mul_app_rdist : =      forall a r s , is_base s - > r ( s;(a**r ) ) ( a**(s;r ) ) .",
    "definition r_t0_app_rdist : =      forall s , is_base s - > r ( s;t0 ) t0 .",
    "( * * elementary rules * ) definition r_t0_runit : = forall t , r ( t + t0 ) t. definition r_s0_anni : = forall t , r ( s0 * * t ) t0 .",
    "definition r_s1_unit : = forall t , r ( s1 * * t ) t. definition r_t0_anni : = forall a , r ( a * * t0 ) t0 .",
    "definition r_mul_abs : =     forall a b t , r ( a * * ( b * * t ) ) ( ( a * s b ) * * t ) .",
    "definition r_ma_dist : =     forall a s t , r ( a * * ( s + t ) ) ( a * * s + a * * t ) .",
    "( * * factorization * ) definition r_add_fact : =     forall a b t , r ( a * * t + b * * t ) ( ( a + s b ) * * t ) .",
    "definition r_add_fact1 : =     forall a t , r ( a * * t + t ) ( ( a + s s1 ) * * t ) .",
    "definition r_add_fact11 : =     forall t , r ( t + t ) ( ( s1 + s s1 ) * * t ) .",
    "( * * assoc . and commut .",
    "of addition * ) definition r_add_com : = forall s t , r ( s + t ) ( t + s ) .",
    "definition r_add_rassoc : =     forall r s t , r ( ( r + s ) + t ) ( r + ( s + t ) ) .",
    "definition r_add_lassoc : =     forall r s t , r ( r + ( s + t ) ) ( ( r + s ) + t ) .",
    "( * * congruence * ) definition r_cong_mul : = forall a s t , r s t - > r ( a**s ) ( a**t ) .",
    "definition r_cong_ladd : = forall u s t , r s t - > r ( s+u ) ( t+u ) .",
    "definition r_cong_radd : = forall u s t , r s t - > r ( u+ s ) ( u+t ) .",
    "definition r_cong_lapp : = forall u s t , r s t - > r ( s;u ) ( t;u ) .",
    "( * * linearity of application * ) definition r_add_app_ldist : =     forall r s t , r ( ( r + s);t ) ( r;t + s;t ) .",
    "definition r_mul_app_ldist : =     forall a r s , r ( ( a**r);s ) ( a**(r;s ) ) .",
    "definition r_t0_app_ldist : = forall s , r ( t0;s ) t0 ."
  ],
  "abstract_text": [
    "<S> we examine the relationship between the _ algebraic @xmath0-calculus _ , a fragment of the differential @xmath0-calculus and the _ linear - algebraic @xmath0-calculus _ , a candidate @xmath0-calculus for quantum computation . </S>",
    "<S> both calculi are algebraic : each one is equipped with an additive and a scalar - multiplicative structure , and their set of terms is closed under linear combinations . </S>",
    "<S> however , the two languages were built using different approaches : the former is a call - by - name language whereas the latter is call - by - value ; the former considers algebraic equalities whereas the latter approaches them through rewrite rules .    in this paper , we analyse how these different approaches relate one to the other . to this end , we propose four canonical languages based on each of the possible choices : call - by - name versus call - by - value , algebraic equality versus algebraic rewriting . </S>",
    "<S> we show that the various languages simulate one another . due to subtle interaction between beta - reduction and algebraic rewriting , to make the languages consistent some additional hypotheses such as confluence might be required . </S>",
    "<S> we carefully devise the required properties for each proof , making them general enough to be valid for any sub - language satisfying the corresponding properties . </S>"
  ]
}