{
  "article_text": [
    "to protect copyrighted content against unauthorized redistribution , distributors may embed watermarks or fingerprints in the content , uniquely linking copies to individual users . then",
    ", if an illegal copy of the content is found , the distributor can extract the watermark from the copy and compare it to the database of watermarks , to determine which user was responsible .    to combat this solution",
    ", pirates may try to form a coalition of several colluders , each owning a differently watermarked copy of the content , and perform a collusion attack . by comparing their different versions of the content",
    ", they will detect differences in their copies which must be part of the watermark .",
    "they can then create a new pirate copy , where the resulting watermark matches the watermark of different pirates in different segments of the content , making it hard for the distributor to find the responsible users .",
    "fortunately , under the assumption that if the pirates do nt detect any differences ( because they all received the same version ) they output this watermark ( known in the literature as the boneh - shaw marking assumption  @xcite ) , it is still possible to find all colluders using suitable fingerprinting codes .      the above fingerprinting game is often modeled as the following two - person game between the distributor @xmath1 and the coalition of pirates @xmath2 .",
    "the set of colluders is assumed to be a random subset of size @xmath3 from the complete set of @xmath4 users @xmath5 , and the identities of these colluders are unknown to the distributor .",
    "the aim of the game for the distributor is ultimately to discover the identities of the colluders , while the colluders want to stay hidden .",
    "the game consists of the following three phases : ( i ) the distributor uses an _ encoder _ to generate the fingerprints ; ( ii ) the colluders employ a _ collusion channel _ to generate the pirate output , and ( iii ) the distributor uses a _ decoder _ to map the pirate output to a set of accused users .",
    "[ [ encoder ] ] encoder + + + + + + +    first , the distributor generates a fingerprinting code @xmath6 , consisting of @xmath4 code words @xmath7 from @xmath8 . is a code with code words of length @xmath9 from an alphabet @xmath10 of size @xmath11 ,",
    "but in this paper we restrict our attention to the binary case @xmath12 . ] the @xmath13th entry of code word @xmath14 indicates which version of the content is assigned to user @xmath14 in the @xmath13th segment .",
    "the parameter @xmath9 is referred to as the code length , and the distributor would like @xmath9 to be as small as possible .    a common restriction on the encoding process is to assume that @xmath6 is created by first generating a probability vector @xmath15^{\\ell}$ ] by choosing each entry @xmath16 independently from a certain distribution function @xmath17 , and then generating @xmath6 according to @xmath18 .",
    "this guarantees that watermarks of different users @xmath14 are independent , and that watermarks in different positions @xmath13 are independent .",
    "schemes that satisfy this assumption are sometimes called _ bias - based schemes _ , and the encoders discussed in this paper also belong to this category .    [ [ collusion - channel ] ] collusion channel + + + + + + + + + + + + + + + + +    after generating @xmath6 , the entries are used to select and embed watermarks in the content , and the content is sent out to all users .",
    "the colluders then get together , compare their copies , and use a certain collusion channel or pirate attack @xmath19 to select the pirate output @xmath20 .",
    "if the pirate attack behaves symmetrically both in the colluders and in the positions @xmath13 , then the collusion channel can be modeled by a vector @xmath21^{c+1}$ ] , consisting of entries @xmath22 indicating the probability of outputting a @xmath23 when the pirates received @xmath24 ones and @xmath25 zeroes .",
    "some common attacks @xmath19 are described in section  [ sec : attacks ] .",
    "[ [ decoder ] ] decoder + + + + + + +    finally , after the pirate output has been generated and distributed , we assume that the distributor intercepts it and applies a decoding algorithm to the pirate output @xmath26 , the code @xmath6 and the ( secret ) bias vector @xmath27 to compute a set @xmath28 of accused users .",
    "this is commonly done by assigning _",
    "scores _ to users , and accusing those users whose score exceeds some predefined threshold @xmath29 .",
    "the distributor wins the game if @xmath30 is non - empty and contains only colluders ( i.e.  @xmath31 ) and loses if this is not the case , which could be because an innocent user @xmath32 is falsely accused ( a false positive error ) , or because no guilty users are accused ( a false negative error ) .",
    "we often write @xmath33 and @xmath34 for upper bounds on the false positive and false negative probabilities respectively .",
    "work on the above bias - based fingerprinting game started in 2003 , when tardos proved that any fingerprinting scheme must satisfy @xmath35 , and that a bias - based scheme is able to achieve this optimal scaling in @xmath9  @xcite .",
    "he proved the latter by providing a simple and explicit construction with a code length of @xmath36 , which is known in the literature as the tardos scheme .",
    "[ [ improved - constructions ] ] improved constructions + + + + + + + + + + + + + + + + + + + + + +    later work on the constructive side of fingerprinting focused on improving upon tardos result by sharpening the bounds  @xcite , optimizing the distribution functions  @xcite , improving the score function  @xcite , tightening the bounds again with this improved score function  @xcite , optimizing the score function  @xcite , and again tightening the bounds with this optimized score function  @xcite to finally end up with a sufficient asymptotic code length of @xmath37 for large @xmath4 . this construction can be extended to larger alphabets , in which case the code length scales as @xmath38 .",
    "other work on practical constructions focused on joint decoders , which are computationally more involved but may work with shorter codes  @xcite , and side - informed fingerprinting games  @xcite , where estimating the collusion channel @xmath19 was considered to get an improved performance .",
    "recently abbe and zheng  @xcite showed that , in the context of fingerprinting  @xcite , if the set of allowed collusion channels satisfies a certain one - sidedness condition , then a decoder that achieves capacity against the information - theoretic worst - case attack is a universal decoder achieving capacity against arbitrary attacks .",
    "the main drawback of using this result is that the worst - case attack is hard to compute , but this does lead to more insight why e.g.  oosterwijk et al .",
    "@xcite obtained a universal decoder by considering the decoder against the ` interleaving attack ' , which is known to be the asymptotic worst - case attack .",
    "[ [ fingerprinting - capacities ] ] fingerprinting capacities + + + + + + + + + + + + + + + + + + + + + + + + +    at the same time , work was also done on establishing bounds on the fingerprinting capacity @xmath39 , which translate to lower bounds on the required asymptotic code length @xmath9 through @xmath40 for large @xmath4 . for",
    "the binary case huang and moulin  @xcite and amiri and tardos  @xcite independently derived exact asymptotics for the fingerprinting capacity for arbitrary attacks as @xmath41 , corresponding to a minimum code length of @xmath37 .",
    "huang and moulin  @xcite further showed that to achieve this bound , an encoder should use the arcsine distribution @xmath42 for generating biases @xmath43 : @xmath44 these capacity - results were later generalized to the @xmath45-ary setting  @xcite showing that a @xmath45-ary code length of @xmath46 is asymptotically optimal .    [ [ dynamic - fingerprinting ] ] dynamic fingerprinting + + + + + + + + + + + + + + + + + + + + + +    there has also been some interest in a variant of the above fingerprinting game where several rounds of the two - player game between the distributor and the coalition are played sequentially .",
    "this allows the distributor to adjust the encoding and decoding steps of the next rounds to the knowledge obtained from previous rounds .",
    "many of the bias - based constructions can also be used effectively in this dynamic setting  @xcite with equivalent asymptotics for the required code length , but allowing the distributor to trace all colluders even if the collusion channel is not symmetric in the colluders , and leading to significantly smaller first order terms than in the ` static ' setting .",
    "these bias - based dynamic schemes may even be able to compete with the celebrated scheme of fiat and tassa  @xcite .",
    "[ [ group - testing ] ] group testing + + + + + + + + + + + + +    finally , a different area of research closely related to fingerprinting is that of group testing , where the set of @xmath4 users corresponds to a set of @xmath4 items , the set of @xmath47 colluders corresponds to a subset of @xmath47 defective items , and where the aim of the distributor is to find all defective items by performing group tests .",
    "this game corresponds to a special case of the fingerprinting game , where the pirate attack is fixed in advance ( and possibly known to the distributor ) to ( a variant of ) the ` all-@xmath23 attack ' . in this game it is significantly easier to find all pirates / defectives ; it is known that a joint decoder asymptotically requires only @xmath48 tests  @xcite , while simple decoders exist requiring as few as @xmath49 tests to find all defectives  @xcite .",
    "recent work has shown that applying results from fingerprinting to group testing may lead to improved results compared to what is known in the group testing literature  @xcite .",
    ".asymptotics for tight lower bounds on @xmath50 , based on the simple and joint capacities , with different amounts of side information ( see section  [ sec : sideinformation ] ) .",
    "the proposed simple decoders are shown to match these bounds , and we conjecture that the proposed joint decoders are also asymptotically optimal.[tab:1 ] [ cols=\"<,^,^,^,^ \" , ]     [ [ capacity - achieving - simple - decoding - without - cut - offs ] ] capacity - achieving simple decoding without cut - offs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    similar to oosterwijk et al .",
    "@xcite , who studied the decoder built against the interleaving attack because that attack is in a sense optimal , we then turn our attention to the simple decoder designed against the interleaving attack , and argue that it is an improved version of oosterwijk et al.s universal decoder . to provide a sneak preview of this result ,",
    "the new score function is the following : @xmath51 this decoder is shown to achieve the uninformed simple capacity , and we argue that with this decoder ( i ) the gaussian assumption always holds ( and convergence to the normal distribution is much faster ) , and ( ii ) no cut - offs on the bias distribution function @xmath17 are ever needed anymore .    [ [ joint - log - likelihood - decoders ] ] joint log - likelihood decoders + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    since it is not hard to extend the definition of the simple decoder to joint decoding , we also present and analyze joint log - likelihood decoders . analyzing these joint decoders turns out to be somewhat harder due to the ` mixed tuples ' , but we give some motivation why these decoders seem to work well .",
    "we also conjecture that the joint decoder tailored against the interleaving attack achieves the joint uninformed capacity , but proving this result is left for future work .    [",
    "[ applications - to - group - testing ] ] applications to group testing + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    since the all-@xmath23 attack in fingerprinting is equivalent to a problem known in the literature as group testing  @xcite , some of our results can also be applied to this area .",
    "in fact , we derive two new results in the area of group testing : ( i ) any simple - decoder group testing algorithm requires at least @xmath52 group tests to find @xmath47 defective items hidden among @xmath4 items , and ( ii ) the decoder discussed in section  [ sec : dec - simple ] provably achieves this optimal scaling in @xmath9 .",
    "this decoder was previously considered in  @xcite , but no provable bounds on the ( asymptotic ) code lengths were given there .",
    "the outline of the paper is as follows .",
    "section  [ sec : models ] first describes the various different models we consider in this paper , and provides a roadmap for sections  [ sec : cap ] and [ sec : dec ] .",
    "section  [ sec : cap ] discusses capacity results for each of these models , while section  [ sec : dec ] discusses decoders which aim to match the lower bounds on @xmath9 obtained in section  [ sec : cap ] .",
    "finally , in section  [ sec : discussion ] we conclude with a brief discussion of the most important results and remaining open problems .",
    "let us first describe how the results in sections  [ sec : cap ] and [ sec : dec ] are structured according to different assumptions , leading to different models .",
    "besides the general assumptions on the model discussed in the introduction , we further make a distinction between models based on ( 1 ) the computational complexity of the decoder , ( 2 ) the information about @xmath19 known to the distributor , and ( 3 ) the collusion channel used by the pirates .",
    "these are discussed in sections  [ sec : complexity ] , [ sec : sideinformation ] and [ sec : attacks ] respectively .",
    "commonly two types of decoders are considered , which use different amounts of information to decide whether a user should be accused or not .    1 .    2 .",
    "using more information generally causes the time complexity of the decoding step to go up , so usually there is a trade - off between a shorter code length and a faster decoding algorithm .",
    "we consider three different scenarios with respect to the knowledge of the distributor about the collusion channel @xmath19 .",
    "depending on the application , different scenarios may apply .    1 .",
    "* fully informed * : even before @xmath6 is generated , the distributor already knows exactly what the pirate attack @xmath19 will be .",
    "this information can thus be used to optimize both the encoding and decoding phases .",
    "this scenario applies to various group testing models , and may apply to dynamic traitor tracing , where after several rounds the distributor may have estimated the pirate strategy .",
    "* partially informed * : the tracer does not know in advance what collusion channel will be used , so the encoding is aimed at arbitrary attacks . however , after obtaining the pirate output @xmath53 , the distributor does learn more about @xmath19 before running an accusation algorithm , e.g.  by estimating the attack based on the available data .",
    "so the encoding is uninformed , but we assume that the decoder is informed and knows @xmath19 . since the asymptotically optimal bias distribution function @xmath17 in fingerprinting is known to be the arcsine distribution @xmath42 , we will assume that @xmath42 is used for generating biases .",
    "this scenario is similar to em decoding  @xcite .",
    "* uninformed * : in this case , both the encoding and decoding phases are assumed to be done without prior knowledge about @xmath19 , so also the decoder should be designed to work against arbitrary attacks .",
    "this is the most commonly studied fingerprinting game .    for simplicity of the analysis , in the partially informed setting we assume that the estimation of the collusion channel is precise , so that @xmath19 is known exactly to the decoder",
    "this assumption may not be realistic , but at least we can then obtain explicit expressions for the capacities , and get an idea of how much estimating the strategy may help in reducing the code length .",
    "this also allows us to derive explicit lower bounds on @xmath9 : even if somehow the attack can be estimated correctly , then the corresponding capacities tell us that we will still need at least a certain number of symbols to find the pirates .      as mentioned in the introduction ,",
    "we assume that collusion channels satisfy the marking assumption , which means that @xmath54 and @xmath55 . for the remaining values of @xmath56 the pirates are free to choose how often they want to output a @xmath23 when they receive @xmath24 ones .",
    "some commonly considered attacks are listed below .    1 .",
    "* interleaving attack * : the coalition randomly selects one of its members and outputs his symbol .",
    "this corresponds to @xmath57 .",
    "this attack is known to be asymptotically optimal ( from the point of view of the colluders ) in the uninformed max - min fingerprinting game  @xcite .",
    "* all-@xmath23 attack * : the pirates output a @xmath23 whenever they can , i.e. , whenever they have at least one @xmath23 .",
    "this translates to @xmath58 .",
    "this attack is of particular interest due to its relation with group testing .",
    "majority voting * : the colluders output the most common symbol among their received symbols .",
    "this means that @xmath59 .",
    "* minority voting * : the traitors output the symbol which they received the least often ( but received at least once ) . for @xmath60 ,",
    "this corresponds to @xmath61 .",
    "* coin - flip attack * : if the pirates receive both symbols , they flip a fair coin to decide which symbol to output .",
    "so for @xmath60 , this corresponds to @xmath62 .    for even @xmath47 , defining @xmath63 in a consistent way for majority and minority voting is not straightforward . for simplicity ,",
    "in the analysis of these two attacks we will therefore assume that @xmath47 is odd .",
    "note that in the uninformed setting , we do not distinguish between different collusion channels ; the encoder and decoder should then work against arbitrary attacks .",
    "the upcoming two sections about capacities ( section  [ sec : cap ] ) and decoders ( section  [ sec : dec ] ) are structured according to the above classification , where first the decoding complexity is chosen , then the side - information is fixed , and finally different attacks are considered . for instance , to find the joint capacity in the fully informed game one has to go to section  [ sec : cap - joint - informed ] , while the new simple uninformed decoder can be found in section  [ sec : dec - simple - uninformed ] .",
    "for simple decoders , we assume that the decision whether to accuse user @xmath14 is based solely on @xmath64 , @xmath26 and @xmath27 . focusing on a single position , and denoting the random variables corresponding to a colluder s symbol , the pirate output , and the bias in this position by @xmath65 , @xmath66 and @xmath67 , the interesting quantity to look at  @xcite is the mutual information @xmath68 .",
    "this quantity depends on the pirate strategy @xmath19 and on the bias @xmath43 . to study this mutual information we will use the following equality  ( * ? ? ?",
    "* equation  ( 61 ) ) , @xmath69 where @xmath70 are defined as @xmath71 note that given @xmath43 and @xmath19 , the above formulas allow us to compute the associated mutual information explicitly .      in the fully informed setting we are free to choose @xmath17 to maximize the capacity , given a collusion channel @xmath19 .",
    "when the attack is known to the distributor in advance , there is no reason to use different values of @xmath43 ; the distributor should always use the value of @xmath43 that maximizes the mutual information payoff @xmath72 .",
    "given an attack strategy @xmath19 , the capacity we are interested in is thus @xmath73 for general attacks finding the optimal value of @xmath43 analytically can be hard , but for certain specific attacks we can investigate the resulting expressions individually to find the optimal values of @xmath43 that maximize the mutual information .",
    "this leads to the following results for the five attacks listed in section  [ sec : attacks ] .",
    "proofs will appear in the full version .",
    "[ thm : cap - simple - informed ] the simple informed capacities and the corresponding optimal values of @xmath43 for the five attacks of section  [ sec : attacks ] are : @xmath74    since fully informed protection against the all-@xmath23 attack is equivalent to noiseless group testing , and since the code length @xmath9 scales in terms of the capacity @xmath39 as @xmath75 , we immediately get the following corollary .",
    "[ cor : cap - simple - informed - group ] any simple group testing algorithm for @xmath47 defectives and @xmath4 total items requires an asymptotic number of group tests @xmath9 of at least @xmath76    note that this seems to contradict earlier results of @xcite , which suggested that under a certain gaussian assumption , only @xmath77 tests are required .",
    "this apparent contradiction is caused by the fact that the gaussian assumption in  @xcite is not correct in the regime of small @xmath43 , for which those results were derived .",
    "in fact , the distributions considered in that paper roughly behave like binomial distributions over @xmath9 trials with probability of success of @xmath78 , which converge to poisson distributions .",
    "numerical inspection shows that the relevant distribution tails are indeed not very gaussian and do not decay fast enough .",
    "rigorous analysis of the scores in  @xcite shows that an asymptotic code length of about @xmath79 is sufficient when @xmath80 , which is well above the lower bound of corollary  [ cor : cap - simple - informed - group ] .",
    "details can be found in the full version .",
    "if the encoder is uninformed , then the best he can do against arbitrary attacks ( for large @xmath47 ) is to generate biases using the arcsine distribution @xmath42 .",
    "so instead of computing the mutual information in one point @xmath81 , we now average over different values of @xmath43 where @xmath43 follows the arcsine distribution .",
    "so the capacity we are interested in is given by @xmath82 the resulting integrals are hard to evaluate analytically , even for large @xmath47 , although for some collusion channels we can use pinsker s inequality ( similar to the proof of  ( * ? ? ?",
    "* theorem 7 ) ) to show that @xmath83 . and",
    "indeed , if we look at the numerics of @xmath84 in figure  [ fig : cap - simple - part ] , it seems that the partially informed capacity usually scales as @xmath85 . as a consequence ,",
    "even if the attack can be estimated exactly , then still a code length of the order @xmath86 is required to get a scheme that works .",
    "note that for the interleaving attack , the capacity scales as @xmath87 .    ) as a function of @xmath47 for different pirate attacks . from top",
    "to bottom these curves correspond to minority voting , the all-@xmath23 attack , majority voting , the coin - flip attack , and the interleaving attack . except for the interleaving attack ,",
    "for which the capacity scales as @xmath87 ( the dashed line ) , these capacities all seem to scale as @xmath85 .",
    "[ fig : cap - simple - part ] ]      for the uninformed fingerprinting game , where both the encoder and decoder are built to work against arbitrary attacks , we are interested in the following max - min game : @xmath88 huang and moulin  @xcite previously solved this uninformed game for asymptotically large coalition sizes @xmath47 as follows .",
    "* theorem 3 ) the simple uninformed capacity is given by @xmath89 and the optimizing encoder @xmath17 and collusion channel @xmath19 achieving this bound for large @xmath47 are the arcsine distribution @xmath42 and the interleaving attack @xmath90 .",
    "note that while for the interleaving attack the capacity is the same ( up to order terms ) for each of the three side - informed cases , for the four other attacks the capacity gradually increases from @xmath91 to @xmath92 to @xmath93 when the distributor is more and more informed .",
    "if the computational complexity of the decoder is not an issue , joint decoding may be an option . in that case ,",
    "the relevant quantity to examine is the mutual information between the symbols of all colluders , denoted by @xmath94 , and the pirate output @xmath66 , given @xmath67 : @xmath95  @xcite .",
    "note that @xmath66 only depends on @xmath94 through @xmath96 , so @xmath97 . to compute the joint capacities ,",
    "we use the following convenient explicit formula  ( * ? ? ? *",
    "equation  ( 59 ) ) : @xmath98,\\end{aligned}\\ ] ] where @xmath99 is the binary entropy function , and @xmath100 is defined as @xmath101      in the fully informed setting , the capacity is again obtained by considering the mutual information and maximizing it as a function of @xmath43 : @xmath102 computing this is very easy for the all-@xmath23 attack , the majority voting attack and the minority voting attack , since one can easily prove that the joint capacity is equal to @xmath103 whenever the collusion channel is deterministic , e.g. when @xmath104 for all @xmath24 .",
    "since the capacity for the interleaving attack was already known , the only non - trivial case is the coin - flip attack .",
    "a proof of the following theorem can be found in the full version .",
    "the joint informed capacities and the corresponding optimal values of @xmath43 for the five attacks of section  [ sec : attacks ] are : @xmath105    recall that there is a one - to - one correspondence between the all-@xmath23 attack and group testing , so the result above establishes firm bounds on the asymptotic number of group tests required by any probabilistic group testing algorithm .",
    "this result was already known , and was first derived by seb  ( * ? ? ?",
    "* theorem 2 ) .      for the partially informed capacity we again average over the mutual information where @xmath43 is drawn at random from the arcsine distribution @xmath42 .",
    "thus the capacity is given by @xmath106 exact results are again hard to obtain , but we can at least compute the capacities numerically to see how they behave .",
    "figure  [ fig : cap - joint - part ] shows the capacities of the five attacks of section  [ sec : attacks ] .",
    "although the capacities are higher for joint decoding than for simple decoding , the joint capacities of all attacks but the interleaving attack also scale as @xmath85 .    , for different attacks . from top to bottom these are minority voting , majority voting , the all-@xmath23 attack , the coin - flip attack and the interleaving attack . except for the interleaving attack ,",
    "these capacities all seem to scale as @xmath85 .",
    "[ fig : cap - joint - part ] ]      finally , if we are working with joint decoders which are supposed to work against arbitrary attacks , then we are interested in the following max - min mutual information game : @xmath107 this joint capacity game was previously solved by huang and moulin  @xcite who showed that also in the joint game , the interleaving attack @xmath90 and the arcsine distribution @xmath108 together form a saddle - point solution to the uninformed fingerprinting game .",
    "* theorem 6 , corollary 7 ) the joint uninformed capacity is given by @xmath109 and the optimizing encoder @xmath17 and collusion channel @xmath19 achieving this bound for large @xmath47 are the arcsine distribution @xmath42 and the interleaving attack @xmath90 .",
    "after deriving `` targets '' for our decoders in the previous section , this section discusses decoders that aim to match these bounds . we will follow the score - based framework introduced by tardos  @xcite , which was later generalized to joint decoders by moulin  @xcite . for simple decoding",
    ", this means that a user @xmath14 receives a score @xmath110 of the form @xmath111 where @xmath112 is called the score function .",
    "user @xmath14 is then accused if @xmath113 for some threshold @xmath29 .    for joint decoding ,",
    "scores are assigned to tuples @xmath114 of @xmath47 distinct users according to @xmath115 in this case , a tuple of users is accused if the joint tuple score exceeds some other threshold @xmath29 . note that this accusation algorithm is not exactly well - defined , since it is possible that a user appears both in a tuple that is accused and in a tuple that is not accused . for the analysis we will assume that the scheme is only successful",
    "if the single tuple consisting of all colluders has a score exceeding @xmath29 and no other tuples have a score exceeding @xmath29 , in which case all users in the guilty tuple are accused .",
    "several different score functions for the simple decoder setting were considered before , but in this work we will restrict our attention to the following log - likelihood scores , which perform well and turn out to be easy to analyze : @xmath116 here @xmath117 corresponds to the probability of seeing the pair @xmath118 when user @xmath14 is guilty , and @xmath119 corresponds to the same probability under the assumption that @xmath14 is innocent . using this score function @xmath112 , the complete score of a user is the logarithm of a neyman - pearson score over the entire codeword : @xmath120 such neyman - pearson scores are known to be optimally discriminative to decide whether to accuse a user or not .",
    "log - likelihood scores were previously considered in the context of fingerprinting in e.g.  @xcite .      for the central theorem below",
    ", we will make use of the following function @xmath121 , which is closely related to the moment generating functions of scores in one position @xmath13 for innocent and guilty users .",
    "this function is defined as @xmath122 and it satisfies @xmath123 and @xmath124 .",
    "[ thm : dec - simple - informed ] let @xmath43 and @xmath19 be fixed and known to the distributor .",
    "let @xmath125 , and let the threshold @xmath29 and code length @xmath9 be defined as @xmath126 then with probability at least @xmath127 no innocent users are accused ( regardless of which collusion channel was used ) , and with probability at least @xmath128 a colluder is caught ( if the collusion channel is indeed @xmath19 ) .",
    "for innocent users @xmath14 , we would like to prove that @xmath129 , where @xmath110 is the user s total score over all positions .",
    "if this can be proved , then it follows that with probability at least @xmath130 no innocent users are accused . using the markov inequality for @xmath131 with @xmath132 and optimizing over @xmath133",
    ", we see that the optimum lies close to @xmath134 . for simplicity",
    "we choose @xmath134 which , combined with the given value of @xmath29 , leads to the following bound : @xmath135    for guilty users , we would like to prove that for an arbitrary guilty user @xmath14 , we have @xmath136 . again using markov s inequality ( but now with a more sophisticated exponent @xmath137 ) we get @xmath138 where the last equality follows from the definitions of @xmath9 and @xmath29 of .    compared to previous papers analyzing provable bounds on the error probabilities , the proof of theorem  [ thm : dec - simple - informed ] is remarkably short and simple .",
    "the only problem is that the given expression for @xmath9 is not very informative as to how @xmath9 scales for large @xmath4 .",
    "the following corollary answers this question , by showing how @xmath9 scales for small @xmath139 .",
    "[ cor : dec - simple - informed ] if @xmath140 then @xmath9 achieves the optimal asymptotic scaling ( achieves capacity ) for arbitrary @xmath43 : @xmath141 , \\label{eq : dec - simple}\\end{aligned}\\ ] ]    first , let us study the behavior of @xmath142 for small @xmath139 , by computing the first order taylor expansion of @xmath142 around @xmath143 : @xmath144 here @xmath145 follows from the fact that if @xmath146 , the factor @xmath147 in front of the exponentiation would already cause this term to be @xmath148 , while if @xmath149 , then also @xmath150 and thus the ratio is bounded and does not depend on @xmath139 . substituting the above result in the original equation for @xmath9 we thus get the result of : @xmath151.\\end{aligned}\\ ] ] since the capacities tell us that @xmath152 , it follows that @xmath9 asymptotically achieves capacity .",
    "since this construction is asymptotically optimal regardless of @xmath43 , in the fully informed setting we can now simply optimize @xmath43 ( using theorem  [ thm : cap - simple - informed ] ) to get the following results .",
    "using the values for @xmath43 of theorem  [ thm : cap - simple - informed ] , the asymptotics for @xmath9 for the five attacks of section  [ sec : attacks ] are : @xmath153 , \\\\ \\ell({{\\bm}{\\theta}_{\\text{all1 } } } ) & = \\frac{c}{\\ln(2)^2 } \\ln(n ) \\left[1 + o(\\sqrt{\\gamma})\\right ] , \\\\ \\ell({{\\bm}{\\theta}_{\\text{maj } } } ) & = \\pi c \\ln(n ) \\left[1 + o(\\sqrt{\\gamma})\\right ] , \\\\ \\ell({{\\bm}{\\theta}_{\\text{min } } } ) & = \\frac{c}{\\ln(2)^2 } \\ln(n ) \\left[1 + o(\\sqrt{\\gamma})\\right ] , \\\\ \\ell({{\\bm}{\\theta}_{\\text{coin } } } ) & = \\frac{4c}{\\ln(2)^2 } \\ln(n ) \\left[1 + o(\\sqrt{\\gamma})\\right].\\end{aligned}\\ ] ]    since the all-@xmath23 attack is equivalent to group testing , we mention this result separately , together with a more explicit expression for @xmath112 .",
    "[ cor : dec - simple - informed - group ] let @xmath154 and let @xmath155 be fixed . then the log - likelihood score function @xmath112 is given by , and for convenience we have scaled @xmath112 by a factor @xmath156 . ]",
    "@xmath157      since the score functions from section  [ sec : dec - simple - informed ] achieve capacity for each value of @xmath43 , using this score function we also trivially achieve the partially informed capacity when the arcsine distribution is used .",
    "estimates of these capacities , and thus the resulting code lengths , can be found in section  [ sec : cap - simple - part ] .",
    "we now arrive at what is arguably one of the most important results of this paper .",
    "just like oosterwijk et al .",
    "@xcite , who specifically studied the score function @xmath158 tailored against the interleaving attack , we now also take a closer look at the log - likelihood score function designed against the interleaving attack . ,",
    "but since it is known to be the asymptotic worst - case attack , the difference between the worst - case attack and the interleaving attack vanishes for large @xmath47 . ] working out the details , this score function is of the form : @xmath159 the first thing to note here is that if we denote oosterwijk et al.s  @xcite score function by @xmath158 , then @xmath112 satisfies @xmath160 if @xmath161 , then by tayloring the logarithm around @xmath162 we see that @xmath163",
    ". since scaling a score function by a constant does not affect its performance , this implies that @xmath112 and @xmath158 are then equivalent . since for oosterwijk",
    "et al.s score function one generally needs to use _ cut - offs _ on @xmath17 that guarantee that @xmath161 ( cf .",
    "@xcite ) , and since the decoder of oosterwijk et al .",
    "is known to asymptotically achieve the uninformed capacity , we immediately get the following result .    [",
    "prop : dec - simple - uninformed ] the score function @xmath112 of asymptotically achieves the uninformed simple capacity when the same cut - offs on @xmath17 as those in  @xcite are used .",
    "so optimizing the decoder so that it is resistant against the interleaving attack again leads to a decoder that is resistant against arbitrary attacks .",
    "[ [ cutting - off - the - cut - offs ] ] cutting off the cut - offs + + + + + + + + + + + + + + + + + + + + + + + +    although proposition  [ prop : dec - simple - uninformed ] is already a nice result , we can do even better .",
    "we can prove a stronger statement , which shows one of the reasons why the log - likelihood decoder is probably more practical than the decoder of oosterwijk et al .",
    "the score function @xmath112 of achieves the uninformed simple capacity when are used",
    ".    first note that in the limit of large @xmath47 , the cut - offs of ibrahimi et al .",
    "converge to @xmath148 .",
    "so for large @xmath47 , the difference between not using cut - offs and using cut - offs is negligible , as long as the contribution of the tails of @xmath43 near @xmath148 or @xmath23 to the distribution of user scores is negligible . since with this score function @xmath112 ,",
    "all moments of both innocent and guilty user scores are finite ( arbitrary powers of logarithms always lose against the @xmath164 of the arcsine distribution and the decreasing width of the interval between @xmath148 and the cut - off ) , the tails indeed decay exponentially . so also without cut - offs",
    "this score function asymptotically achieves the uninformed simple capacity .",
    "note that the same result does not apply to the score function of oosterwijk et al .",
    "@xcite , for which the tails of the distributions are not gaussian enough to omit the use of cut - offs . the main difference is that for small @xmath43 , the score function @xmath158 of @xcite scales as @xmath165 ( which explodes when @xmath43 is really small ) , while the log - likelihood decoder @xmath112 then only scales as @xmath166 which is much smaller .",
    "[ [ all - roads - lead - to - rome ] ] all roads lead to rome + + + + + + + + + + + + + + + + + + + + + +    let us now mention a third way to obtain a capacity - achieving uninformed simple decoder which is again very similar to the two decoders above . to construct this decoder",
    ", we use a bayesian approximation of the proposed empirical mutual information decoder of moulin  @xcite , and again plug in the asymptotic worst - case attack , the interleaving attack .    using bayesian inference with an a priori probability of guilt of @xmath167 ,",
    "the empirical mutual information decoder tailored against the interleaving attack can be approximated with the following score function : @xmath168    for now , let @xmath43 be fixed . the empirical mutual information decoder assigns a score @xmath110 to a user @xmath14 using @xmath169 where @xmath170 denotes the empirical estimate of @xmath171 based on the data @xmath172 , @xmath53 , @xmath173 . for large @xmath9 , these estimates will converge to the real probabilities , so we can approximate @xmath110 by @xmath174 here @xmath175 and @xmath176 can be easily computed , but for computing @xmath177 we need to know whether user @xmath14 is guilty or not .",
    "using bayesian inference , we can write @xmath178 assuming an a priori probability of guilt of @xmath179 , we can work out the details to obtain @xmath180\\right).\\end{aligned}\\ ] ] filling in the corresponding probabilities for the interleaving attack , we end up with the score function of .    for values of @xmath43 with @xmath181 , this decoder is again equivalent to both the log - likelihood score function @xmath112 and oosterwijk et al.s score function @xmath158 .      for the joint decoding setting ,",
    "scores are assigned to tuples of @xmath47 users , and again higher scores correspond to a higher probability of being accused .",
    "the most natural step from the simple log - likelihood decoders to joint decoders seems to be to use the following joint score function : @xmath182 here @xmath183 is under the assumption that in this tuple _ all users are guilty _ , while for @xmath184 we assume that _ all users are innocent_. note that under the assumption that the attack is colluder - symmetric , the score function only depends on @xmath185 : @xmath186      to analyze the joint decoder , we again make use of the moment generating function for the score assigned to tuples of @xmath47 innocent users .",
    "this function is now defined by @xmath187 and it satisfies @xmath188 and @xmath124 . using similar techniques as in section  [ sec : dec - simple - informed ] ,",
    "we obtain the following result .",
    "[ thm : dec - joint - informed ] let @xmath43 and @xmath19 be fixed and known to the distributor .",
    "let @xmath189 , and let the threshold @xmath29 and code length @xmath9 be defined as @xmath190 then with probability at least @xmath127 all all - innocent tuples are not accused , and with probability at least @xmath128 the single all - guilty tuple is accused .",
    "the proof is very similar to the proof of theorem  [ thm : dec - simple - informed ] .",
    "instead of @xmath4 innocent and @xmath47 guilty users we now have @xmath191 all - innocent tuples and just @xmath23 all - guilty tuple , which changes some of the numbers in @xmath139 , @xmath29 and @xmath9 .",
    "we again apply the markov inequality with @xmath134 for innocent tuples and @xmath137 for guilty tuples , to obtain the given expressions for @xmath29 and @xmath9 .",
    "note that theorem  [ thm : dec - joint - informed ] does not prove that we can actually find the set of colluders with high probability , since mixed tuples consisting of both innocent and guilty users also exist , and these may or may not have a score exceeding @xmath29 .",
    "this does prove that with high probability we can find a set @xmath30 of @xmath47 users , for which ( i ) all tuples not containing these users have a score below @xmath29 , and ( ii ) the tuple containing exactly these users has a score above @xmath29 .",
    "regardless of what the scores for mixed tuples are , with probability at least @xmath192 such a set consists and contains at least one colluder .",
    "furthermore , if this set @xmath30 is unique , then with high probability this is exactly the set of colluders .",
    "but there is no guarantee that it is unique without additional proofs .",
    "this is left for future work .    to further motivate why using this joint decoder",
    "may be the right choice , the following proposition shows that at least the scaling of the resulting code lengths is optimal . note that the extra @xmath47 that we get from @xmath193 can be combined with the mutual information @xmath194 to obtain @xmath195 , which corresponds to the joint capacity",
    "[ prop : dec - joint - informed ] if @xmath140 then the code length @xmath9 of theorem  [ thm : dec - joint - informed ] scales as @xmath196,\\end{aligned}\\ ] ] thus asymptotically achieving the optimal code length ( up to first order terms ) for arbitrary values of @xmath43 .",
    "since the asymptotic code length is optimal regardless of @xmath43 , these asymptotics are also optimal when @xmath43 is optimized to maximize the mutual information in the fully informed setting .    finally , although it is hard to estimate the scores of mixed tuples with this decoder , just like in  @xcite we expect that the joint decoder score for a tuple is roughly equal to the sum of the @xmath47 individual simple decoder scores .",
    "so a tuple of @xmath47 users consisting of @xmath197 colluders and @xmath198 innocent users is expected to have a score roughly a factor @xmath199 smaller than the expected score for the all - guilty tuple .",
    "so after computing the scores for all tuples of size @xmath47 , we can get rough estimates of how many guilty users are contained in each tuple , and for instance try to find the set @xmath30 of @xmath47 users that best matches these estimates .",
    "there are several options for post - processing that may improve the accuracy of using this joint decoder , which are left for future work .",
    "as mentioned in proposition  [ prop : dec - joint - informed ] , the code length is asymptotically optimal regardless of @xmath43 , so the code length in the partially uninformed setting is also asymptotically optimal .",
    "asymptotics on @xmath9 can thus be obtained by combining proposition  [ prop : dec - joint - informed ] with the results of section  [ sec : cap - joint - part ] .",
    "note that if the above joint decoder turns out to work well , then we can again plug in the interleaving attack to get something that might just work well against arbitrary attacks .",
    "while we can not prove that this joint decoder is optimal , we can already see what the score function would be , and conjecture that it works against arbitrary attacks .",
    "the joint log - likelihood decoder against the interleaving attack , with the score function @xmath112 defined by @xmath200 works against arbitrary attacks and asymptotically achieves the joint capacity of the uninformed fingerprinting game .",
    "a further study of this universal joint decoder is left as an open problem .",
    "let us now briefly discuss the results from sections  [ sec : cap ] and [ sec : dec ] , their consequences , and some directions for future work .",
    "[ [ informed - simple - decoding ] ] informed simple decoding + + + + + + + + + + + + + + + + + + + + + + + +    for the setting of simple decoders , we derived explicit asymptotics on the informed capacities for various attacks , which often scale as @xmath201 .",
    "we further showed that log - likelihood scores provably match these bounds for large @xmath4 , regardless of @xmath19 and @xmath43 . because these decoders are optimal for any value of @xmath43 , they are also optimal in the partially informed setting , where different values of @xmath43 are used .",
    "if the encoder uses the arcsine distribution to generate biases , we showed that these capacities generally seem to scale as @xmath202 , which is roughly ` halfway ' between the fully informed and uninformed capacities .",
    "[ [ uninformed - simple - decoding ] ] uninformed simple decoding + + + + + + + + + + + + + + + + + + + + + + + + + +    although log - likelihood decoders have already been studied before in the context of fingerprinting , the main drawback was always that to use these decoders , you would either have to fill in ( and know ) the exact pirate strategy , or compute the worst - case attack explicitly .",
    "so if you are in the simple uninformed setting where you do nt know the pirate strategy and where the worst - case attack is not given by a nice closed - form expression  ( * ? ? ?",
    "4b ) , how can you construct such decoders for large @xmath47 ?",
    "the trick seems to be to just fill in the _ asymptotic _ worst - case attack , which huang and moulin showed is the interleaving attack  @xcite , and which is much simpler to analyze .",
    "after previously suggesting this idea to oosterwijk et al .",
    ", we now used the same trick here to obtain two other capacity - achieving score functions using two different methods ( but each time filling in the interleaving attack ) .",
    "so in total we now have three different methods to obtain ( closed - form ) capacity - achieving decoders in the uninformed setting :    * using lagrange - multipliers , oosterwijk et al .",
    "@xcite obtained : @xmath203 * using neyman - pearson - based log - likelihood scores , we obtained : @xmath204 * using a bayesian approximation of the empirical mutual information decoder of moulin  @xcite , we obtained : @xmath205    for @xmath181 and large @xmath206 , these score functions are equivalent up to a scaling factor : @xmath207 and therefore all three are asymptotically optimal .",
    "so there may be many different roads that lead to rome , but they all seem to have one thing in common : to build a universal decoder that works against arbitrary attacks , one should build a decoder that works against the asymptotic worst - case pirate attack , the interleaving attack . and if it does work against this attack , then it probably works against any other attack as well .",
    "[ [ joint - decoding ] ] joint decoding + + + + + + + + + + + + + +    although deriving the joint informed capacities is much easier than deriving the simple informed capacities , actually building decoders that provably match these bounds is a different matter .",
    "we conjectured that the same log - likelihood scores achieve capacity when a suitable accusation algorithm is used , and we conjectured that the log - likelihood score built against the interleaving attack achieves the uninformed joint capacity , but we can not prove any of these statements beyond reasonable doubt . for now this is left as an open problem .    [ [ group - testing-1 ] ] group testing + + + + + + + + + + + + +    since the all-@xmath23 attack is equivalent to group testing , some of the results we obtained also apply to group testing .",
    "the joint capacity was already known  @xcite , but to the best of our knowledge both the simple capacity  ( corollary  [ cor : cap - simple - informed - group ] ) and a simple decoder matching this simple capacity  ( corollary  [ cor : dec - simple - informed - group ] ) were not yet known before .",
    "attempts have been made to build efficient simple decoders with a code length not much longer than the joint capacity  @xcite , but these do not match the simple capacity .",
    "future work will include computing the capacities and building decoders for various noisy group testing models , where the marking assumption may not apply .",
    "[ [ dynamic - fingerprinting-1 ] ] dynamic fingerprinting + + + + + + + + + + + + + + + + + + + + + +    although this paper focused on applications to the ` static ' fingerprinting game , the construction of  @xcite can trivially be applied to the decoders in this paper as well to build efficient dynamic fingerprinting schemes .",
    "although the asymptotics for the code length in this dynamic construction are the same , ( i ) the order terms are significantly smaller in the dynamic game , ( ii ) one does not need the assumption that the pirate strategy is colluder - symmetric , and ( iii ) one does not necessarily need to know ( a good estimate of ) @xmath47 in advance  ( * ? ? ? * section  v ) .",
    "an important open problem remains to determine the dynamic uninformed fingerprinting capacity , which may prove or disprove that the construction of @xcite is optimal .",
    "[ [ further - generalizations ] ] further generalizations + + + + + + + + + + + + + + + + + + + + + + +    while this paper already aims to provide a rather complete set of guidelines on what to do in the various different fingerprinting games ( with different amounts of side - information , and different computational assumptions on the decoder ) , there are some further generalizations that were not considered here due to lack of space .",
    "we mention two in particular :    * * larger alphabets * : in this work we focused on the binary case of @xmath12 different symbols , but it may be advantageous to work with larger alphabet sizes @xmath208 , since the code length decreases linearly with @xmath45 . for the results about decoders we did not really use that we were working with a binary alphabet , so it seems a straightforward exercise to prove that the @xmath45-ary versions of the log - likelihood decoders also achieve capacity .",
    "a harder problem seems to be to actually compute these capacities in the various informed settings , since the maximization problem then transforms from a one - dimensional optimization problem to a @xmath209-dimensional optimization problem . * * tuple decoding * : as in  @xcite , we can consider a setting in between the simple and joint decoding settings , where decisions to accuse are made based on looking at tuples of users of size at most @xmath210 .",
    "tuple decoding may offer a trade - off between the high complexity , low code length of a joint decoder and the low complexity , higher code length of a simple decoder , and so it may be useful to know how the capacities scale in the region @xmath211 .",
    "the author is very grateful to pierre moulin for his insightful comments and suggestions during the author s visit to urbana - champaign that inspired work on this paper .",
    "the author would also like to thank teddy furon for pointing out the connection between decoders designed against the interleaving attack and the results of abbe and zheng  @xcite , and for finding some mistakes in a preliminary version of this manuscript . finally , the author thanks jeroen doumen , jan - jaap oosterwijk , boris kori , and benne de weger for valuable discussions and comments .",
    "chan , s.  jaggi , v.  saligrama , and s.  agnihotri .",
    "non - adaptive group testing : explicit bounds and novel algorithms . in _",
    "ieee international symposium on information theory ( isit ) _ , pages 18371841 , 2012 .",
    "y .- w .  huang and p.",
    "saddle - point solution of the fingerprinting capacity game under the marking assumption . in _",
    "ieee international symposium on information theory ( isit ) _ , pages 22562260 , 2009 .",
    "y .- w .  huang and p.",
    "maximin optimality of the arcsine fingerprinting distribution and the interleaving attack for large coalitions . in _",
    "ieee workshop on information forensics and security ( wifs ) _ ,",
    "pages 16 , 2010 .",
    "t.  laarhoven , j .- j .",
    "oosterwijk , and j.  doumen .",
    "dynamic traitor tracing for arbitrary alphabets : divide and conquer . in _",
    "ieee workshop on information forensics and security ( wifs ) _",
    ", pages 240245 , 2012 .                          j .- j .",
    "oosterwijk , b.  kori , and j.  doumen .",
    "optimal suspicion functions for tardos traitor tracing schemes . in _",
    "1st acm workshop on information hiding and multimedia forensics ( ih&mmsec ) _ , pages 1928 , 2013 ."
  ],
  "abstract_text": [
    "<S> combining an information - theoretic approach to fingerprinting with a more constructive , statistical approach , we derive new results on the fingerprinting capacities for various informed settings , as well as new log - likelihood decoders with provable code lengths that asymptotically match these capacities . the simple decoder built against the interleaving attack is further shown to achieve the simple capacity for unknown attacks , and is argued to be an improved version of the recently proposed decoder of oosterwijk et al . with this new universal decoder , cut - offs on the bias distribution function </S>",
    "<S> can finally be dismissed .    </S>",
    "<S> besides the application of these results to fingerprinting , a direct consequence of our results to group testing is that ( i ) a simple decoder asymptotically requires a factor @xmath0 more tests to find defectives than a joint decoder , and ( ii ) the simple decoder presented in this paper provably achieves this bound . </S>"
  ]
}