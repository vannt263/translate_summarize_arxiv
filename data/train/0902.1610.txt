{
  "article_text": [
    "free and open source software ( _ foss _ ) has attracted the attention of software engineers in the past decade  @xcite due to its peculiarities . among them , release management  @xcite is the most relevant for software upgrades : software bundles  like an operating system with a basic stack of applications  in the foss bazaar are made of components developed and released independently without a priori coordination or central authority able to control the involved parties  @xcite .",
    "the volunteer nature , the licensing terms , and the need to reuse , have produced a huge amount of components , which is unparalleled in the proprietary software world .",
    "interactions among such components are non trivial , and this is the main reason why early approaches to software upgrades , where users had to manually download , compile , install , etc . , were doomed to fail .",
    "distributions _ were therefore introduced around 15 years ago to reduce the complexity of installations and upgrades for final users .",
    "distribution maintainers act as intermediaries between `` upstream '' software authors and users , by encapsulating software components within abstractions called _",
    "packages_.    distributions have been really successful : nowadays every gnu / linux user is running one of the hundreds of available distributions .",
    "still , distributions have inherited some properties from the foss bazaar : complex inter - package dependencies and frequently available package upgrades .",
    "sysadmins unsurprisingly perform package upgrades at least once a month  @xcite : _ new software requirements _ of users require new programs to be installed and old programs to be removed ; _ routine upgrades _ are required regularly to address security issues , bug fixes , or to add new features ; _ release - wide upgrades _ are less frequent ( typically once or twice a year ) , but can have higher impact as a significant fraction of the installed packages are involved .",
    "since a large part of foss software is installed from packages , the damages caused by failed upgrades are potentially higher than in proprietary systems .",
    "this paper is structured around three claims .",
    "the first one is that _ foss package upgrades have underestimated peculiarities_. the claim is supported by section  [ sec : foss - package - upgrade ] which reviews all the actors involved in foss package upgrades  packages as the involved entities , the upgrade process and its decomposition in clear - cut phases , the possible failures which can occur during upgrades  and highlights their peculiarities .",
    "this paper provides a detailed description of foss package upgrade which , to the best of our knowledge , was missing from the literature .",
    "the second claim is that _ current rollback and snapshot techniques are not enough to cope with unpredictable package upgrade failures_. rollback and snapshot techniques are the only countermeasures currently being proposed against upgrade failures . exploiting filesystem - level details , snapshots can be taken before performing an upgrade , and the possibility to rollback to them can then be offered to users in case of failures .",
    "section  [ sec : rollback - state ] gives an overview of mainstream snapshot and rollback solutions and argues that no such solution is satisfactory ( in part because of excessive disk - space requirements induced by long - term upgrade rollbacks , and in part because it is not always possible to define the rollback scope , i.e. , what should be rolled - back and what should not ) .",
    "the third claim is that some of these problems can be tackled by : ( 1 ) adopting lightweight rollback techniques to address short - term rollback needs , and integrating version control system within package managers to better handle system - wide configuration files ; ( 2 ) designing a domain specific language , equipped with an undo semantics , for the implementation of scripts which are executed during the upgrade process and which have side - effects outside the control of package managers .",
    "details are given in section  [ sec : undo ] which also highlights a novel problem in the specification of upgrade requests , namely the need of expressing preferences to discriminate among package statuses which are equivalent from the point of view of dependency soundness , but which can be sensibly different from that of user - specified criteria .",
    "_ packages _ are abstractions defining the granularity at which users can act ( add , remove , upgrade , etc . ) on available software .",
    "a _ distribution _ is a collection of packages maintained ( hopefully ) coherently .",
    "the subset of a distribution corresponding to the actual packages installed on a machine is called _ package status _ and is meant to be altered with the _ package managers _ offered by a given distribution .",
    "they can be classified in two categories : _ installers _ which deploy individual packages on the filesystem , possibly aborting the operation if problems ( e.g. , unsatisfied dependencies ) are encountered , and _ meta - installers _ which act at the inter - package level , solving dependencies and conflicts , and retrieving packages from remote repositories as needed ; ` dpkg ` and ` rpm ` are representative examples of installers , ` apt ` and ` urpmi ` of meta - installers .",
    "we use the term _ upgrade problem _ to refer generically to any request to change the package status ; such problems are usually solved by meta - installers .",
    "[ [ packages ] ] packages + + + + + + + +    abstracting over format - specific details , a _ package _ is a bundle of 3 main parts : @xmath0      \\hline\\hline      2 . &   set of valued \\emph{meta - information } \\\\      ~ 2.1 . & ~ ~ \\fbox{\\emph{inter - package relationships } } \\\\[1ex ]      \\hline\\hline      3 . &   executable \\emph{configuration scripts } \\\\      \\hline    \\end{tabular } \\right.\\ ] ] the set of files ( 1 ) is common in all software packaging solutions , it is the filesystem encoding of what the package is delivering : executable binaries , data , documentation , etc .",
    "_ configuration files _ ( 1.1 ) is a distinguished subset of shipped files , identifying those affecting the runtime behavior of the package and meant to be locally customized with or without package manager mediation .",
    "configuration files need to be present in the bundle ( e.g. , to provide sane defaults or documentation ) , but need special treatment : during installation of new versions of a package , they can not be simply overwritten , as they may contain local changes .",
    "package meta - information ( 2 ) contains information which varies from distribution to distribution .",
    "a common core provides : a unique identifier , software version , maintainer and package description , but most notably , distributions use meta - information to declare _ inter - package relationships _ ( 2.1 ) .",
    "the relationship kinds vary with the installer , but there exists a de facto common subset including : dependencies ( the need of other packages to work properly ) , conflicts ( the inability of being co - installed with other packages ) , feature provisions ( the ability to declare named features as provided by a given package , so that other packages can depend on them ) , and restricted boolean combinations of them  @xcite .",
    "packages come with a set of executable configuration ( or _ maintainer _ ) scripts ( 3 ) .",
    "their purpose is to let package maintainers attach actions to hooks executed by the installer ; actions usually come as posix shell scripts .",
    "three aspects of maintainer scripts are noteworthy : ( a ) they are ordinary programs that can do anything permitted to the installer ( usually run with administrator rights ) ; ( b ) the functionality of maintainer scripts can not be obtained by just shipping extra files : the scripts may customize part of the package using data which is available only in the target installation machine , and not necessarily in the package itself ; sometimes the same result obtained using scripts can be precomputed ( increasing package size ) , sometimes it can not ; ( c ) maintainer scripts are required to work `` properly '' : upgrade runs in which they fail trigger upgrade failures .",
    ".the package upgrade process [ cols=\"<\",options=\"header \" , ]     [ [ upgrades ] ] upgrades + + + + + + + +    table  [ tab : upgrade - phases ] summarizes the different phases of what we call the _ upgrade process _ , using as an example the popular ` apt ` meta - installer ( others follow a similar process ) .",
    "phase ( 1 ) is a user specification of how she wants the local package status to be altered .",
    "the expressiveness of the language available to formulate this _ user request _ varies with the meta - installer : it can be as simple as requesting the installation / removal of a single package , or as complex as ` apt ` pinning that allows to express preferences to discriminate among multiple versions of the same package .",
    "an _ upgrade problem _ is a triple @xmath1 , where @xmath2 is a distribution ( i.e. , a set of packages ) , @xmath3 is a package status , and @xmath4 a user request ; its _ solutions _ are all possible package status @xmath5 , satisfying :    1 .",
    "the user request @xmath4 is satisfied by @xmath6 ; 2 .",
    "if @xmath6 contains a package @xmath7 , it contains all its dependencies ; 3 .",
    "@xmath6 contains no two conflicting packages ; 4 .",
    "@xmath6 has been obtained executing all required hooks and none of the involved maintainer scripts has failed .",
    "phase ( 2 ) performs dependency resolution : it checks whether a package status satisfying ( b ) and ( c ) exists ; if this is the case one is chosen in this phase .    deploying the new status",
    "consists of package retrieval ( 3 ) and unpacking ( 4 ) .",
    "unpacking is the first phase actually changing both the package status ( to keep track of installed packages ) and the filesystem ( to add or remove the involved files ) . during unpacking ,",
    "configuration files are treated checking whether local configuration files have been manually modified or not ; if they have , _ merging _ is required .",
    "the naive solution of asking the user to manually do so is still the most popular .",
    "intertwined with package retrieval and unpacking , there are several configuration phases ( 5 ) where maintainer scripts get executed .",
    "[ [ failures ] ] failures + + + + + + + +    each phase of the upgrade process can fail .",
    "dependency resolution can fail either because the user request is unsatisfiable ( e.g. , user error or inconsistent distributions  @xcite ) or because the meta - installer is unable to find a solution .",
    "completeness  the guarantee that a solution will be found whenever one exists  is a desirable meta - installer property  @xcite , unfortunately missing in most meta - installers , with too few claimed exceptions  @xcite",
    ".    sat solving has been proven to be a suitable and complete technique to solve dependencies  @xcite , what is still missing is wide adoption . in that respect",
    "recent off - springs are really promising . _",
    "handling complex user preferences _ is a novel problem for software upgrade .",
    "it boils down to letting users specify which solution to choose among all acceptable solutions .",
    "example of preferences are policies  @xcite , like minimizing the download size or prioritizing popular packages , and also more specific requirements such as blacklisting packages maintained by an untrusted maintainer .",
    "package deployment can fail as well .",
    "trivial failures , e.g. , network or disk shortages , can be easily dealt with when considered in isolation : the whole upgrade process can be aborted and unpack can be undone , since all the involved files are known ; no upgrade is performed so , the system is unchanged .",
    "maintainer script failures can not be as easily undone , nor prevented .",
    "scripts are implemented in turing - complete languages , and all non - trivial properties about them are undecidable , including determining _ a priori _ their effects to be able to revert them upon failure .",
    "a subtle type of upgrade failure deserves mention : _ undetected failures _ , those failures not observable by the package manager while the newly installed software can be misbehaving ( e.g. , a network service happily restarting after upgrade , but refusing connections ) .",
    "undetected failures can take very long ( weeks , months ) before being discovered .",
    "often they can be fixed by configuration tuning , but there are cases in which the desired behavior can no longer be obtained , leaving upgrade undo as the only solution ( in cases where undoing the upgrade is possible ) .",
    "current countermeasures to package upgrade failures are based on the principle of undoing residual effects of failed upgrades .",
    "three strategies have been proposed : rollbacks , filesystem snapshots , and purely functional distributions .",
    "_ rollback _ capabilities depend on the package manager ; the most well - known implementations are : rpm transactions  @xcite which work at the installer level , re - creating packages as they are removed , so that they can be re - installed to undo upgrades ; apt - rpm  @xcite which implements transactions at the meta - installer level and additionally handles past versions of configuration files .",
    "all package - based rollback approaches can track only files which are under package manager control , and only at package manager invocation time ; therefore none of such approaches can undo maintainer script effects as they can span the whole system .    _",
    "snapshots _ are used to cheaply save copies of physical filesystems as they were at a given time in the past .",
    "zfs snapshot ( based on _ copy on write _ ) was the first implementation that made filesystem snapshots popular .",
    "zfs snapshot is integrated with ` apt - clone ` ( nexenta os meta - installer ) to automatically take snapshots upon upgrades .",
    "the logical volume manager ( lvm ) is a disk abstraction layer implemented by the linux kernel , which include support for copy on write snapshots , without relying on any particular filesystem implementation .",
    "these snapshot techniques work at the _ physical _ filesystem level , hence are unsuitable for recovering from upgrade failures , for various reasons .",
    "the first reason is a granularity mismatch with package managers that work at the _ logical _ file system level : changes induced by upgrades can span several partitions and it can not be taken for granted that all support snapshots ; since even the set of files of a single package can span multiple partitions , rolling back only some of them will be too prone to additional problems like `` half - installed '' packages .",
    "how to split the logical filesystem to support rollbacks is not clear either : while should not be rolled back ( it contains user data ) , is a hard choice , since it contains data which are usually affected by maintainer scripts ( and hence needs to be rolled back upon failure ) as well as system logs and database data which usually should not be rolled back .",
    "this problem can be mitigated by a wider acceptance of the filesystem hierarchy standard or similar initiatives to model the purpose of specific paths .",
    "the second reason of the unsuitability of snapshot techniques is disk usage : even though copy on write requires less space than full copying , snapshots consume as much space as the divergence between the snapshot and the live instance .",
    "the longer a snapshot is kept alive , the more physical space is needed to store deltas .",
    "snapshots are then useful only against quickly discoverable failures ( modulo the filesystem granularity problem ) , because it can not be usually afforded to keep snapshots for the time span of undetected failures .    _ functional distribution _ are embodied by nixos  @xcite that proposes a functional approach to package management , where files never change after installation and are built deterministically evaluating simple functional expressions .",
    "package deployment is based on garbage collection , hence packages can never break due to disappearing dependencies .",
    "nixos suffers from various issues , most notably unconventional configuration handling intermixed with package building , and the fact that some actions related to upgrade deployment can not be made purely functional ( e.g. , user database management ) .",
    "nixos made no attempt to make maintainer scripts purely functional , despite that being the place where functional purity is needed the most .",
    "while for detectable failures trade - offs can be made using snapshot and appropriate partitioning , no fully generic solution exists to counter upgrade failures .",
    "each of the discussed technologies focuses on one or more of the axes :    domain : :    : what can and should be undone upon failures ( e.g. , binary files ,    configuration files , user files ) ?",
    "time : :    : for how long a specific upgrade can be undone ?",
    "granularity : :    : does the undo of one unit imply the undo of other units ? should the    unit be file , package , filesystem ?",
    "as it is unlikely that a `` one size fits all '' solution exists , we are pursuing several research directions to improve resilience to upgrade failures in foss distributions :    1 .",
    "improve meta - installers by the means of ( a ) lightweight snapshot integration and ( b ) versioning ; 2 .",
    "define a proper domain specific language ( dsl ) to be proposed as maintainer script implementation language ; 3 .   define ad - hoc optimized algorithms for handling complex user preferences to choose package statuses .",
    "simple technical improvements can sensibly improve support for upgrade failures in meta - installers .",
    "for example , porting nexenta ideas to lvm poses no conceptual problems , and will enable gnu / linux users to enjoy similar benefits , no matter the used filesystem .",
    "the need of lvm can be further relaxed by exploiting lightweight snapshot techniques as implemented by unionfs  @xcite .",
    "neither of these two solutions mitigates the problem of long term snapshot persistence , which will still be too expensive in terms of disk usage .",
    "hence we also propose to exploit filesystem notifications ( e.g. , linux ` inotify ` ) to cheaply spot during package upgrades exactly which files are being modified .",
    "this would enable to trim down snapshots at the end of the upgrade , reducing space requirements .",
    "the need of snapshots can be completely avoided by running upgrades inside controlled environments as supported by linux out of the box ( e.g. , ` ld_preload ` to replace the system call library , and ` ptrace ` , a debugging interface to trace process execution ) . using these approaches , one can save on the fly the files being altered by the upgrade process just before they get modified  @xcite .",
    "proper handling of configuration file changes and their undo seems the easiest goal to achieve , at least at the work - flow level : it is enough to properly integrate version control systems ( vcss ) with meta - installers . `",
    "etckeeper ` is a promising example of such an approach . with ` etckeeper ` the whole directory can be put under version control and enjoy integration with ` apt ` via hooks that commit changes to configuration files performed by upgrades , so that they can be recognized and reverted .",
    "this does not address yet the complexity of merging user changes .",
    "a noteworthy example is the need of better integrating the merge capabilities of modern distributed vcss . by simply keeping the pristine configuration files in a separate branch , we can isolate changes and have a clear view of the differences when manual merge is required .",
    "a related issue is the heterogeneity of languages used to write configuration files , which inhibits relying on a single diff / merge tool . to mitigate this problem",
    "we observe that for specific classes of configuration languages ( e.g. , xml or other structured syntaxes ) , syntax - level diff / merge tools can be employed , instead of the legacy vcs tools , to get rid of bogus merge failures caused by semantically irrelevant changes .",
    "regarding maintainer scripts , the only way we see to reliably address the undo of their effects is by properly formalizing such effects .",
    "previous attempts to prove properties about shell scripts  @xcite have given pale results very far even from the minimal requirement of determining a priori the set of files touched by their execution , letting aside how restricted were the considered shell language subsets . given these premises , we are skeptical that static analysis can fully solve this problem . hence , we are developing a sound dsl equipped with undo semantics , to be proposed as the implementation language for maintainer scripts .",
    "although it will be hard to migrate thousands of existing scripts , empirical analysis on a distribution sample has shown that most scripts are just a few lines of code , and are mostly automatically generated .",
    "the fact that scripts are maintained by distribution maintainers will enable us to test - drive the dsl on a distribution among the mancoosi partners .",
    "the dsl will probably not be able to address all of maintainer script needs , but if it can handle most of them , we can resort to other techniques only for the remaining scripts .",
    "as a first step in dsl design , we are applying fingerprinting techniques  @xcite to cluster all debian s maintainer scripts and get a clear view of all their use cases .",
    "it is already clear that about a half of such scripts only invokes external idempotent tools to update caches of some data ; this class of effects can be undone by removing the involved data  usually shipped as files by the owner package  and then re - running the script .",
    "what is still not clear is how heterogeneous are the remaining scripts which escape the former class .    considering the intrinsic complexity of the sole dependency resolution , designing good optimizing algorithms to handle complex user preferences for package status choices is a rather ambitious goal .",
    "however , the particular shape of inter - package relationships has enabled deriving rather efficient ad - hoc dependency solvers ( e.g. , ` edos - debcheck ` ) .",
    "we believe similar successes can be obtained for user preferences .",
    "hence we are not only working to apply multicriteria optimization techniques  @xcite , but also looking for a tentative `` social '' solution .",
    "we are organizing a competition  @xcite whose participants will compete in finding the `` best '' algorithm to address the static part of the upgrade process .",
    "we believe the competition has chances to attract researchers attention , as it will offer real problems collected from user machines , instead of the usual _ in vitro _ problems .",
    "this paper argues that upgrades in foss distributions have underestimated peculiarities .",
    "we have discussed the nature of packages as well as their role in the upgrade process and the potential failures .",
    "we surveyed related work and technologies , showing their shortcomings , especially in dealing with misbehaving maintainer scripts .",
    "finally , we presented ongoing research ideas to improve the state of the art : designing a dsl for implementing maintainer scripts , and attracting the research community to work on the static part of package upgrade , including the novel problem of supporting complex user preferences among packages .",
    "f.  mancinelli , j.  boender , r.  d. cosmo , j.  vouillon , b.  durak , x.  leroy , and r.  treinen .",
    "managing the complexity of large free and open source package - based software distributions . in _",
    "ase 2006 _ , 199208 , sept .",
    "ieee cs press ."
  ],
  "abstract_text": [
    "<S> the _ upgrade problems _ faced by free and open source software distributions have characteristics not easily found elsewhere . </S>",
    "<S> we describe the structure of _ packages _ and their role in the _ </S>",
    "<S> upgrade process_. we show that state of the art package managers have shortcomings inhibiting their ability to cope with frequent upgrade failures . </S>",
    "<S> we survey current countermeasures to such failures , argue that they are not satisfactory , and sketch alternative solutions .    </S>",
    "<S> [ life cycle ] [ software selection ] management , reliability , verification foss , upgrade , packages , distribution , rollback </S>"
  ]
}