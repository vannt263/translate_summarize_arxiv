{
  "article_text": [
    "first introduced in 1998 @xcite , an _ identifying code _ for a graph @xmath0 is a subset of the vertices , @xmath1 , such that for each @xmath2 the subset of vertices of @xmath3 that are adjacent to @xmath4 is non - empty and unique .",
    "that is , each vertex of the graph is uniquely identifiable by the non - empty subset of vertices of @xmath3 to which it is adjacent .",
    "more formally , let @xmath5 be the set of vertices adjacent to @xmath4 and @xmath6 .",
    "then we require that any two vertices @xmath7 have different identifying sets , or more precisely that we must have @xmath8 , and also that both @xmath9 .",
    "the combinatorial problem of finding minimum identifying codes has been shown to be np - complete @xcite , but also has many potential real - world applications .",
    "the most commonly discussed application illustrates one use of identifying codes : placing sensors on a network .",
    "if we place sensors on the nodes corresponding to our identifying code , then the set of sensors alerted gives us location information on the trigger .",
    "for example , if we place smoke detectors in a house using an identifying code , then based off of which smoke detectors are set off we can pinpoint exactly which room of the house is on fire @xcite .",
    "other applications appearing in the literature refer to similar scenarios , such as fault diagnosis of multiprocessor systems @xcite .    as some np - complete problems are notorious for having special graph classes on which there are simple solutions , previous research has focused on the class of de bruijn networks @xcite .",
    "this paper explores the problem of finding the minimum size of an identifying code over the undirected de bruijn graph using three different methods .",
    "section [ dwave ] describes an approach for solving the miminum identifying code problem using adiabatic quantum optimization @xcite , which for small enough problem instances can be implemented on a d - wave quantum annealing processor @xcite . while to our knowledge",
    "this is the first time adiabatic quantum optimization has been applied to the identifying code problem , it has been studied for other graph - theoretic problems including graph coloring @xcite and the graph isomorphism problem @xcite , @xcite ; in addition , @xcite showed how to formulate a number of np - complete problems as ising models .",
    "other approaches are considered as follows : subsection [ parallel ] explores a parallel computing algorithm and subsection [ stan ] illustrates the method of using satisfiability modulo theory ( smt ) solvers .    while many of our examples and data revolve around the class of de bruijn graphs , the methods discussed throughout can easily be applied to arbitrary graphs .",
    "as this problem has not been considered before outside of @xcite , no results exist on the minimum size of identifying codes on this class of graphs . in this paper ,",
    "we provide initial data on these values .",
    "a summary of our complete contribution to these values is given in figure [ smtres ] .",
    "for reference , we provide some of the basic definitions and background for the class of de bruijn graphs here .",
    "the undirected @xmath10-ary de bruijn graph of order @xmath11 , denoted @xmath12 , is the graph with the following vertex and edge sets .",
    "@xmath13    for example , the graph @xmath14 is illustrated in figure [ dbg ] .",
    "these graphs have many useful properties for applications , such as having a relatively high number of nodes , a low degree at each node , and many short paths between any two nodes .",
    "additionally , many notoriously difficult problems such as the traveling salesman problem are solvable in polynomial time on this class of graphs .",
    "for that reason , they have many interesting applications such as interconnection networks @xcite and fault - tolerant wireless sensor networks @xcite .",
    "\\(0 ) 000 ; ( 1 ) [ above right of=0 ] 001 ; ( 2 ) [ below right of=1 ] 010 ; ( 4 ) [ below right of=0 ] 100 ; ( 5 ) [ right of=2 ] 101 ; ( 6 ) [ below right of=5 ] 110 ; ( 3 ) [ above right of=5 ] 011 ; ( 7 ) [ below right of=3 ] 111 ;    \\(0 ) edge node [ left ] ( 1 ) ( 1 ) edge node [ left ] ( 3 ) edge node [ right ] ( 2 ) ( 2 ) edge node ( 5 ) edge node [ right ] ( 4 ) ( 3 ) edge node [ right ] ( 6 ) edge node [ right ] ( 7 ) ( 4 ) edge node [ left ] ( 0 ) edge node [ right ] ( 1 ) ( 5 ) edge node [ right ] ( 3 ) ( 6 ) edge node [ right ] ( 5 ) edge node [ right ] ( 4 ) ( 7 ) edge node [ right ] ( 6 ) ;",
    "this section describes our approach for solving the minimum identifying code problem using quantum annealing .",
    "quantum annealing processors , such as those made by d - wave systems @xcite , operate on the principle of adiabatic quantum optimization ( aqo)@xcite . in aqo , the system hamiltonian evolves according to the equation @xmath15 where @xmath16 is the initial hamiltonian with a known and easily prepared ground state ; @xmath17 is the final hamiltonian whose ground state corresponds to the solution of our optimization problem ; and @xmath18 increases from @xmath19 to @xmath20 . according to the adiabatic theorem @xcite , for a large enough @xmath21 and a smooth enough function @xmath22 determined by the minimum spectral gap , a system starting in the ground state of @xmath16 at time @xmath23 will be in the ground state of @xmath17 at time @xmath24 .",
    "however , since a physical implementation of aqo does not strictly meet the conditions of the adiabatic theorem , in particular the assumption of a closed system , we refer to the process as _ quantum annealing _ , which may be viewed as a heuristic method for optimization .",
    "the d - wave processor is designed to solve quadratic binary minimization problems that can be expressed in terms of an _ ising spin glass _ energy functional .",
    "namely , a ground state of @xmath17 is a minimum of @xmath25 where @xmath26 are the final qubit states in the computational basis , and the @xmath27 and @xmath28 are programmable qubit biases and coupling strengths respectively .",
    "while there are various ways of expressing the minimum identifying code problem as a binary minimization problem , we found that the most efficient approach , as measured by the number of qubits needed to solve the problem on the d - wave processor , was to formulate the problem in terms of boolean satisfiability .",
    "this approach , described in subsection [ subsec : satform ] , leads to a conjunctive normal form ( cnf ) proposition containing clauses of various sizes .",
    "since the energy functional must be at most quadratic , we use `` gadgets '' ( similar to those found in @xcite ) to reduce the higher order clauses and generate an ising model whose ground state encodes the solution to the satisfiability problem .",
    "these gadgets add overhead in the form of ancillary binary variables that augment the problem variables ; however we found that the overall qubit resource requirements for this approach are less than with other approaches we considered .",
    "our approach for mapping sat clauses to an ising model is described in subsection [ subsec : sat2ising ] .",
    "the physical limitations of the d - wave architecture present some additional challenges :    @xmath29    not every pair of qubits on the chip are physically connected ; rather , the connectivity can be represented as a square lattice of @xmath30 bipartite graphs , that d - wave calls a _",
    "chimera graph_. thus if the binary variables in the optimization problem are mapped 1-to-1 to qubits , not all of the quadratic coefficients @xmath28 can be programmed .",
    "this challenge can be overcome using _",
    "graph minor embedding _",
    "@xcite , in which case a single binary variable may be mapped to multiple physical qubits .",
    "furthermore , an actual d - wave chip may contain a small number of faulty qubits ( due to fabrication defects or calibration failures ) which can not be used in the graph minor embedding process @xcite . while determining the optimal embedding for an arbitrary graph is itself an np - hard problem , heuristic embedding techniques have been developed that provide reasonably efficient mappings @xcite .",
    "finally , the d - wave processor has a small amount of intrinsic control error ( ice ) , meaning that the actual values of biases and coupling strengths may differ slightly from the values programmed by the user .",
    "some of the effects contributing to the ice can be mitigated using _ gauge transformations _",
    "@xcite , which are explained below .",
    "subsection [ subsec : ising2dwave ] describes the embedding and gauge transformation techniques we used to map the problem onto the d - wave architecture .",
    "the examples given in subsections [ subsec : satform ] through [ subsec : solnusingdwave ] are for the undirected de bruijn graph @xmath12 with @xmath31 and @xmath32 .",
    "this was the largest case we were able to solve on a d - wave machine operated by lockheed martin and the university of southern california , which had 504 working qubits .",
    "in subsection [ subsec : scaling ] , we also estimate the number of qubits that would be needed to solve the larger @xmath31 cases with @xmath33 .",
    "compared to other types of optimization problems that have been studied using quantum annealing and the d - wave machine , it appears that the qubit resource requirements for the minimum identifying code problem on de bruijn graphs scale relatively well .",
    "while the satisfiability - based approach proved to be the most efficient for this study , we also explored various approaches for expressing the minimum identifying code problem as a binary minimization problem .",
    "for sake of completeness , subsection [ subsec : otherforms ] describes two other approaches that we considered .      in this subsection ,",
    "we describe how to formulate the minimum identifying code problem in terms of boolean satisfiability .",
    "while the method is presented here for a de bruijn graph , the same approach can be applied to any graph .",
    "we label the vertices of the de bruijn graph @xmath12 in lexicographic order @xmath34 . for a subset @xmath3 of @xmath12",
    ", we define boolean variables @xmath35    we will construct a conjunctive normal form ( cnf ) formula that must be satisfied if @xmath3 is an identifying code . later , in the full optimization problem , we will add a penalty term of the form @xmath36 to obtain the minimum identifying code .    for @xmath3 to be an identifying code , it must intersect the above - defined ball @xmath37 for every @xmath38 . in other words , for every @xmath38 the clause @xmath39 must be satisfied for all @xmath38 .",
    "similarly , the condition @xmath40 for all @xmath41 implies that @xmath42 must be satisfied for all @xmath41 , where @xmath43 is the exclusive or operator .",
    "thus an identifying code must satisfy the proposition @xmath44    for the de bruijn graph @xmath45 , we can compute @xmath46 explicitly and simplify the cnf to obtain @xmath47    unfortunately , the above formula , consisting of 50 clauses over 16 variables , was slightly too large to map onto the architecture of the d - wave processor we were using for this study .",
    "we can decompose the problem into smaller subproblems by observing that @xmath46 contains the clauses @xmath48 and @xmath49 .",
    "hence if @xmath46 is satisfied , at least one of @xmath50 and @xmath51 must be true , and similarly at least one of @xmath52 and @xmath53 must be true .",
    "so we consider the following 4 cases :    @xmath54    while these 4 cases are not disjoint , if we find the minimum identifying codes for each case and take the union of the solutions , then the minimum length codes over the union will be the solutions of the original minimum identifying code problem .",
    "we will illustrate the procedure for case 1 .",
    "if we set @xmath55 in @xmath46 , we obtain the reduced formula ( 24 clauses over 14 variables ) @xmath56    this formula is small enough to map onto the d - wave processor , as will be described in the following sections .",
    "the reduced proposition @xmath57 for an identifying code has the cnf form @xmath58 where each @xmath59 is a subset of the vertices of the de bruijn graph .    to map this to an ising model , we define `` spin '' variables @xmath60 for each @xmath38 : @xmath61 we will also define as needed , some `` ancillary '' variables @xmath62 .",
    "we construct an ising hamiltonian of the form @xmath63 the hamiltonian is a function of the problem variables @xmath64 and ancillary variables @xmath65 . each of the terms @xmath66 will be a function of the @xmath67 , and possibly some of the ancillary variables @xmath65 , with the following properties :    @xmath29    @xmath66 is at most quadratic in @xmath67 , and @xmath65    @xmath64 is a minimum of @xmath66 iff @xmath68 .",
    "we will show momentarily how the @xmath66 are constructed .",
    "the last term @xmath69 is a penalty term that rewards smaller size codes .",
    "therefore , the minimum solutions ( or ground states ) of @xmath70 are the minimum identifying codes .    to illustrate how the @xmath66 are constructed , consider the 3-or clause @xmath71 .",
    "if we define    @xmath72    then it can be easily checked that @xmath73 attains its minimum value iff at least one of the @xmath74 , which corresponds to the clause @xmath71 being satisfied . note that @xmath73 contains no higher than quadratic terms .",
    "\\(21 ) @xmath75 ; ( 21l ) [ above of=21 ] @xmath76 ; ( 22 ) [ right of=21 ] @xmath77 ; ( 22l ) [ above of=22 ] @xmath76 ; ( 2 ) [ above right of=21 ] 2-or ;    \\(31 ) [ right of=22 ] @xmath75 ; ( 31l ) [ above of=31 ] @xmath78 ; ( 32 ) [ right of=31 ] @xmath77 ; ( 32l ) [ above of=32 ] @xmath78 ; ( 3z1)[below right of=31 ] @xmath79 ; ( 3z1l ) [ left of=3z1 ] @xmath80 ; ( 33 ) [ right of=3z1 ] @xmath81 ; ( 33l ) [ above of=33 ] @xmath76 ; ( 3 ) [ above right of=31 ] 3-or ;    \\(4 ) [ below of=22 ] 4-or ; ( 41 ) [ below left of=4 ] @xmath75 ; ( 41l ) [ above of=41 ] @xmath78 ; ( 42 ) [ right of=41 ] @xmath77 ; ( 42l ) [ above of=42 ] @xmath78 ; ( 4z1)[below left of=42 ] @xmath79 ; ( 4z1l ) [ left of=4z1 ] @xmath80 ; ( 43 ) [ right of=42 ] @xmath81 ; ( 43l ) [ above of=43 ] @xmath78 ; ( 44 ) [ right of=43 ] @xmath82 ; ( 44l ) [ above of=44 ] @xmath78 ; ( 4z2)[below right of=43 ] @xmath83 ; ( 4z2l ) [ right of=4z2 ] @xmath80 ;    \\(5 ) [ below of=4z2 ] 5-or ; ( 52 ) [ below left of=5 ] @xmath77 ; ( 52l ) [ above of=52 ] @xmath78 ; ( 53 ) [ below right of=5 ] @xmath81 ; ( 53l ) [ above of=53 ] @xmath78 ; ( 51 ) [ left of=52 ] @xmath75 ; ( 51l ) [ above of=51 ] @xmath78 ; ( 54 ) [ right of=53 ] @xmath82 ; ( 54l ) [ above of=54 ] @xmath78 ; ( 5z1)[below left of=52 ] @xmath79 ; ( 5z1l ) [ left of=5z1 ] @xmath76 ; ( 5z2)[below right of=53]@xmath83 ; ( 5z2l ) [ right of=5z2 ] @xmath76 ; ( 5z3)[below right of=5z1]@xmath84 ; ( 5z3l ) [ left of=5z3 ] @xmath80 ; ( 55 ) [ right of=5z3 ] @xmath85 ; ( 55l ) [ above of=55 ] @xmath76 ;    \\(6 ) [ below of=5z3 ] 6-or ; ( 62 ) [ below left of=6 ] @xmath77 ; ( 62l ) [ above of=62 ] @xmath78 ; ( 63 ) [ below right of=6 ] @xmath81 ; ( 63l ) [ above of=63 ] @xmath78 ; ( 61 ) [ left of=62 ] @xmath75 ; ( 61l ) [ above of=61 ] @xmath78 ; ( 64 ) [ right of=63 ] @xmath82 ; ( 64l ) [ above of=64 ] @xmath78 ; ( 6z1 ) [ below left of=62 ] @xmath79 ; ( 6z1l ) [ left of=6z1 ] @xmath76 ; ( 6z2 ) [ below right of=63 ] @xmath83 ; ( 6z2l ) [ right of=6z2 ] @xmath76 ; ( 6z3 ) [ below right of=6z1]@xmath84 ; ( 6z3l ) [ left of=6z3 ] @xmath80 ; ( 6z4 ) [ right of=6z3 ] @xmath86 ; ( 6z4l ) [ right of=6z4 ] @xmath80 ; ( 65 ) [ above left of=6z4 ] @xmath85 ; ( 65l ) [ below of=65 ] @xmath78 ; ( 66 ) [ above right of=6z4]@xmath87 ; ( 66l ) [ below of=66 ] @xmath78 ;    \\(21 ) edge node [ above ] + 1 ( 22 )    ( 31)edge node [ above ] + 1 ( 32 ) edge node [ left ] -2 ( 3z1 ) ( 32)edge node [ right ] -2 ( 3z1 ) ( 33)edge node [ below ] + 1 ( 3z1 )    \\(41 ) edge node [ above ] + 1 ( 42 ) ( 41 ) edge node [ left ] -2 ( 4z1 ) ( 4z1 ) edge node [ right ] -2 ( 42 ) ( 4z1 ) edge node [ below ] + 1 ( 4z2 ) ( 4z2 ) edge node [ left ] -2 ( 43 ) ( 4z2 ) edge node [ right ] -2 ( 44 ) ( 43 ) edge node [ above ] + 1 ( 44 )    \\(51 ) edge node [ above ] + 1 ( 52 ) ( 51 ) edge node [ left ] -2 ( 5z1 ) ( 52 ) edge node [ right ] -2 ( 5z1 ) ( 5z1 ) edge node [ above ] + 1 ( 5z2 ) ( 5z1 ) edge node [ left ] -2 ( 5z3 ) ( 5z3 ) edge node [ above ] + 1 ( 55 ) ( 5z3 ) edge node [ right ] -2 ( 5z2 ) ( 5z2 ) edge node [ left ] -2 ( 53 ) ( 5z2 ) edge node [ right ] -2 ( 54 ) ( 53 ) edge node [ above ] + 1 ( 54 )    \\(61 ) edge node [ above ] + 1 ( 62 ) ( 61 ) edge node [ left ] -2 ( 6z1 ) ( 62 ) edge node [ right ] -2 ( 6z1 ) ( 63 ) edge node [ above ] + 1 ( 64 ) ( 63 ) edge node [ left ] -2 ( 6z2 ) ( 64 ) edge node [ right ] -2 ( 6z2 ) ( 6z1 ) edge node [ above ] + 1 ( 6z2 ) ( 6z1 ) edge node [ left ] -2 ( 6z3 ) ( 6z2 ) edge node [ right ] -2 ( 6z3 ) ( 6z3 ) edge node [ above ] + 1 ( 6z4 ) ( 66 ) edge node [ left ] -2 ( 6z4 ) ( 65 ) edge node [ above ] + 1 ( 66 ) ( 65 ) edge node [ right ] -2 ( 6z4 ) ;    we refer to the mapping from the 3-or clause to @xmath73 as a `` gadget '' .",
    "the gadget can be represented diagrammatically as in figure [ fig : gadgets ] , which also shows gadgets for 4-or through 6-or clauses , which are the gadgets we need to map our satisfiability formula @xmath57 for @xmath12 to an ising model . in the diagrams , numbers attached to a node",
    "represent the linear coefficients in the ising model , while numbers attached to an edge represent the quadratic ( coupling ) coefficients in the ising model .",
    "this technique is similar to the ones described in @xcite , except that those gadgets were designed for use with 0/1 variables instead of @xmath88 variables .",
    "note that the choice of gadget coefficients is far from unique , and it may be possible to tune these coefficients , for example to accommodate the limited control precision of the quantum processor .",
    "however , the coefficients shown in figure [ fig : gadgets ] were sufficient for the problem at hand .",
    "when larger d - wave processors become available that enable solving the minimum identifying code problem for larger @xmath89 , tuning of the gadget coefficients may be needed , along with the gauge transformation techniques described in the next subsection .    using the gadgets shown in figure [ fig : gadgets ] , we mapped the satisfiability formula @xmath57 to an ising model with 49 ancillary variables @xmath65 , for a total of 63 variables .",
    "we furthermore added the penalty term @xmath90 so that the ground state will be a minimum identifying code . since this ising model could in principle be implemented on an ideal quantum annealing machine with 63 qubits",
    ", we say that the model has 63 _ logical qubits _ , and we refer to this model as the _ logical ising model_.    while the overhead incurred in the satisfiability - based approach to obtain a quadratic ising model is substantial ( going from 14 boolean variables in @xmath57 to 63 logical qubits in the ising model ) , one advantage of this approach is that the connectivity of the resulting ising model ( i.e. pairs of variables with nonzero coefficients ) is relatively sparse .",
    "this can be seen from figure [ fig : logicalgraph ] . in the figure ,",
    "nodes corresponding to the original 14 boolean variables are shown in green ; the remaining nodes represent the ancillary variables added during the sat - to - ising mapping process .",
    "edges represent pairs of variables with nonzero coefficients ( @xmath91 ) .",
    "the relative sparsity of this graph will facilitate mapping the problem onto the d - wave architecture , as described in the next subsection .    .",
    "nodes corresponding to the original 14 boolean variables are shown in green ; the remaining nodes represent the ancillary variables added during the sat - to - ising mapping process.,scaledwidth=80.0% ]      this subsection describes additional pre - processing steps that take place before the logical ising model is solved on the d - wave processor .",
    "_ graph minor embedding _",
    "enables the logical ising model to be mapped onto the limited qubit connectivity of the d - wave architecture , by utilizing potentially multiple physical qubits per logical qubit . to improve solution accuracy , _ gauge transformations _ are used to partially mitigate the intrinsic control errors that occur when programming the d - wave hardware .",
    "the physical connectivity between qubits on the d - wave chip can be represented as a square lattice of @xmath30 bipartite graphs , that d - wave calls a _",
    "chimera graph_. even for ising models with relatively sparse graphs , it may not be possible to directly map the ising model onto the chimera graph .    for example , even the simple ising model for 3-or ( the @xmath73 gadget ) shown in figure [ fig : gadgets ] can not be directly mapped onto the chimera graph . an easy way to see",
    "this is to observe that the graph of @xmath73 contains a 3-cycle , whereas the smallest cycle possible on the chimera graph is a 4-cycle .",
    "however , the graph of @xmath73 can be mapped onto the chimera graph using minor embedding .",
    "one such embedding is shown in figure [ fig:3-orembedding ] . in the figure ,",
    "the logical qubit @xmath79 is mapped to two physical qubits , which are ferromagnetically coupled with a coupling strength @xmath92 .",
    "the @xmath93 and @xmath94 values shown in the figure define an embedded hamiltonian which only uses connections that are available in the chimera graph .",
    "it is easily verified that the ground state of the embedded hamiltonian corresponds to the ground state of the original hamiltonian @xmath73 .",
    "\\(1 ) @xmath75 ; ( 1l ) [ left of=1 ] @xmath78 ; ( 12l ) [ below right of=1,anchor = east ] @xmath95 ; ( 2 ) [ right of=1 ] @xmath77 ; ( 22l ) [ below left of=2,anchor = west ] @xmath95 ; ( 2l ) [ right of=2 ] @xmath78 ; ( z1 ) [ below of=1 ] @xmath79 ; ( z1l ) [ left of = z1 ] @xmath96 ; ( z2 ) [ right of = z1 ] @xmath79 ; ( z2l ) [ right of = z2 ] @xmath96 ; ( 3 ) [ below of = z2 ] @xmath81 ; ( 3l ) [ right of=3 ] @xmath76 ;    \\(1 ) edge node [ above ] + 1 ( 2 ) ( 1 ) edge node [ above left , distance=2 mm ] ( z2 ) ( 2 ) edge node [ above right ] ( z1 ) ( z1 ) edge node [ above ] @xmath92 ( z2 ) ( z1 ) edge node [ above ] + 1 ( 3 ) ;    choi @xcite showed that any graph can be minor embedded into a sufficiently large chimera graph .",
    "heuristic embedding algorithms have been developed @xcite to generate minor embeddings for chimera graphs with faulty qubits .",
    "the d - wave software includes a heuristic embedding tool that can be used to find embeddings using the working qubits on an actual d - wave chip .    using the d - wave heuristic embedding tool , we mapped the graph of the logical ising model , that was shown in figure [ fig : logicalgraph ] , into the hardware graph of our d - wave processor which had 504 working qubits .",
    "figure [ fig : chimeraembedding ] shows the embedding that we used , consisting of 253 physical qubits , with a maximum chain length ( number of physical qubits per logical qubit ) of 8 .",
    "the coefficients of the physical ising model are determined as in @xcite .          in the context of quantum annealing , a _ gauge transformation _",
    "@xcite is a transformation of the ising spin variables @xmath97 where @xmath98 .",
    "the gauge transformation induces a transformation on the physical ising model coefficients @xmath99 so that the hamiltonian is invariant .    while the gauge transformation generates a problem that is mathematically equivalent to the original problem , in practice it has been found that gauge transformations can mitigate some of the intrinsic control error ( ice ) of the d - wave hardware @xcite and that the choice of the gauge @xmath0 can affect the probability of finding optimal solutions @xcite .",
    "consider for example the gauge transformation @xmath0 shown in figure [ fig : gt ] .",
    "the figure depicts the action of @xmath0 on the first unit cell , where the red qubits are flipped by @xmath0 while the blue qubits are unchanged ; i.e. all of the horizontal qubits are flipped while the vertical qubits are unchanged . in the next unit cell ,",
    "all of the vertical qubits are flipped while the horizontal qubits are unchanged ; and so on in an alternating pattern .",
    "\\(8 ) at ( 0,1 ) 8 ; ( 7 ) at ( 0,2 ) 7 ; ( 6 ) at ( 0,3 ) 6 ; ( 5 ) at ( 0,4 ) 5 ; ( 1 ) at ( 1,5 ) 1 ; ( 2 ) at ( 2,5 ) 2 ; ( 3 ) at ( 3,5 ) 3 ; ( 4 ) at ( 4,5 ) 4 ; ( 0.5,0.5 ) rectangle ( 4.5,4.5 ) ; ( 0.2,4 )  ( 5,4 ) ; ( 0.2,3 )  ( 5,3 ) ; ( 0.2,2 )  ( 5,2 ) ; ( 0.2,1 )  ( 5,1 ) ; ( 1,4.8 )  ( 1,0.2 ) ; ( 2,4.8 )  ( 2,0.2 ) ; ( 3,4.8 )  ( 3,0.2 ) ; ( 4,4.8 )  ( 4,0.2 ) ; ( 4,1 ) circle ( 1 mm ) ;",
    "( 4,2 ) circle ( 1 mm ) ; ( 4,3 ) circle ( 1 mm ) ; ( 4,4 ) circle ( 1 mm ) ; ( 3,1 ) circle ( 1 mm ) ; ( 3,2 ) circle ( 1 mm ) ; ( 3,3 ) circle ( 1 mm ) ; ( 3,4 ) circle ( 1 mm ) ; ( 2,1 ) circle ( 1 mm ) ; ( 2,2 ) circle ( 1 mm ) ; ( 2,3 ) circle ( 1 mm ) ; ( 2,4 ) circle ( 1 mm ) ; ( 1,1 ) circle ( 1 mm ) ; ( 1,2 ) circle ( 1 mm ) ; ( 1,3 ) circle ( 1 mm ) ; ( 1,4 ) circle ( 1 mm ) ;    \\(16 ) at ( 6,1 ) 16 ; ( 15 ) at ( 6,2 ) 15 ; ( 14 ) at ( 6,3 ) 14 ; ( 13 ) at ( 6,4 ) 13 ; ( 9 ) at ( 7,5 ) 9 ; ( 10 ) at ( 8,5 ) 10 ; ( 11 ) at ( 9,5 ) 11 ; ( 12 ) at ( 10,5 ) 12 ; ( 6.5,0.5 ) rectangle ( 10.5,4.5 ) ; ( 6.3,4 )  ( 11,4 ) ; ( 6.3,3 )  ( 11,3 ) ; ( 6.3,2 )  ( 11,2 ) ; ( 6.3,1 )  ( 11,1 ) ; ( 7,4.8 )  ( 7,0.2 ) ; ( 8,4.8 )  ( 8,0.2 ) ; ( 9,4.8 )  ( 9,0.2 ) ; ( 10,4.8 )  ( 10,0.2 ) ; ( 7,1 ) circle ( 1 mm ) ; ( 7,2 ) circle ( 1 mm ) ; ( 7,3 ) circle ( 1 mm ) ; ( 7,4 ) circle ( 1 mm ) ; ( 8,1 ) circle ( 1 mm ) ; ( 8,2 ) circle ( 1 mm ) ; ( 8,3 ) circle ( 1 mm ) ; ( 8,4 ) circle ( 1 mm ) ; ( 9,1 ) circle ( 1 mm ) ; ( 9,2 ) circle ( 1 mm ) ; ( 9,3 ) circle ( 1 mm ) ; ( 9,4 ) circle ( 1 mm ) ; ( 10,1 ) circle ( 1 mm ) ; ( 10,2 ) circle ( 1 mm ) ; ( 10,3 ) circle ( 1 mm ) ; ( 10,4 ) circle ( 1 mm ) ;    we have found that this gauge transformation @xmath0 is particularly helpful in connection with embedding . as mentioned earlier",
    ", the embedding process maps a single logical qubit to multiple physical qubits that are `` chained '' together with a ferromagnetic coupling @xmath92 .",
    "furthermore , to enforce the embedding constraints ( i.e. that all the physical qubits in a chain should take the same value ) , the coupling strength @xmath100 is generally made to be the dominant coupling in the hamiltonian .",
    "the gauge transformation @xmath0 has the property that all the ferromagnetic couplings @xmath92 in each chain are replaced by antiferromagnetic couplings @xmath101 . this can help to mitigate certain types of systematic ice errors that are magnified by long ferromagnetically coupled chains .",
    "using the reduced proposition @xmath57 , mapped to a logical ising model using the gadgets shown in figure [ fig : gadgets ] , and the embedding shown in figure [ fig : chimeraembedding ] , we used the 504-qubit lm / usc d - wave processor to solve the resulting physical ising model using quantum annealing .    since the minimum identifying code problem for @xmath45 is small enough to solve by brute force , we know that the reduced proposition @xmath57 should be satisfied by @xmath102 ( and the rest of the variables zero ) . combined with the assumption @xmath103 , this correspond to a minimum code size of 6 .    for the non - gauge",
    "transformed problem , we found that the d - wave machine did not obtain the optimal solution . in 480 experiments totaling 630,000 annealing runs , over a range of different settings for the annealing time",
    ", we obtained zero occurrences of the optimal solution ; the best that we found were solutions corresponding to a code size of 7 .    on the other hand , using the gauge transformation",
    "@xmath0 shown in figure [ fig : gt ] , in 240 experiments totaling 825,000 annealing runs ( again using a range of settings for the annealing time ) , we obtained the solution @xmath102 corresponding to the minimum code size of 6 in 25 experiments .",
    "so , while the ground state probability was still very low in the gauge transformed problem , there was a noticeable difference using the gauge transformation .",
    "while the @xmath45 case was the largest that could be solved on the 504-qubit lm / usc d - wave processor , we can make some rough estimates of how the qubit resource requirements scale for larger cases . for binary ( @xmath31 ) de bruijn graphs",
    ", we extended the techniques described above to generate ising models for the minimum identifying code problem for the cases @xmath104 through @xmath105 .",
    "these models were then embedded into ideal chimera graphs of various sizes using the d - wave heuristic embedding tool .",
    "figure [ qubitscaling ] shows how the number of qubits needed for the embedding grows as a function of @xmath11 .    ]",
    "since the embedding algorithm is heuristic , it is possible that smaller embeddings could be found , so the embedding sizes shown here should be viewed as upper bounds .",
    "we computed embeddings firstly for larger versions of the current @xmath30 chimera architecture , which has 8-qubit unit cells , as well as for hypothetical @xmath106 ( 16-qubit unit cell ) chimera graphs . for the @xmath30 chimera graphs , we started with the current vesuvius architecture , which contains 64 8-qubit unit cells arranged in an 8x8 square grid , and increased the grid size to 12x12 , 16x16 , 24x24 , 32x32 , and so on until the embedding was successful . for the @xmath106 graphs , we started with an 8x8 grid of 16-qubit unit cells , and increased the grid size to 16x16,24x24 , and 32x32 , until the embedding was successful .",
    "the plots show that for any given case , the embedding size on the @xmath106 chimera is smaller than on the @xmath30 chimera due to the higher graph connectivity of the @xmath106 chimera architecture ; in other words , qubit resource requirements depend on the hardware graph connectivity .    from the figure",
    ", we can project roughly when the d - wave processor would have sufficient qubits to accommodate the larger cases of the minimum identifying code problem for undirected binary de bruijn graphs .",
    "if we define a processor generation to be 4 times the number of qubits as the previous generation ( e.g. the `` vesuvius '' generation had a 512-qubit design whereas the prior `` rainier '' generation had a 128-qubit design ) , we can state that in roughly 1.5 generations we would be able to fit the @xmath107 case on the processor .",
    "this is the largest @xmath31 case for which the minimum identifying code size is presently known . in one more generation beyond that , we would be able to fit the @xmath108 case on the processor , for which the minimum identifying code size is presently not known .    whether these hypothetical d - wave processors would actually be able to solve these larger cases ,",
    "will depend on the performance characteristics of those machines which is yet to be demonstrated .",
    "the hardware intrinsic control errors would need to be significantly reduced from the current levels .",
    "for example , the embedding we found for the @xmath108 case on the @xmath30 chimera architecture had a maximum chain length of 63 qubits .",
    "solving a problem with chain lengths this large would probably require greater control precision ( the current vesuvius design has 4 bits of precision @xcite ) . on the @xmath106 chimera architecture ,",
    "the embeddings are less complex ; e.g. the embedding we found for the @xmath108 case only had a maximum chain length of 25 qubits .",
    "however , it is not clear how difficult it would be for d - wave to achieve a 16-qubit unit cell design .    due to risk factors such as these",
    ", it could take longer than the projected number of processor generations before a solution can be found to the @xmath108 case . on the other hand",
    ", it may be possible to break the problem down into subproblems , as illustrated earlier in subsection [ subsec : satform ] , which may make it easier to fit the problem onto the d - wave processor .",
    "while the satisfiability formulation provided the best result , we include two other methods here for the sake of completeness .",
    "it should be noted that while these methods were not practical for our sample problem , they may provide advantages for other problems .      from @xcite , we have the following integer program formulation of the minimum identifying code problem in graphs .",
    "first , we define the modified adjacency matrix as follows .",
    "it is the adjacency matrix plus the identity matrix .",
    "@xmath109    using this definition , we see that a ball of radius 1 centered at vertex @xmath38 is given by the following vector .",
    "@xmath110^t\\ ] ] our vertex subset @xmath3 is defined as the following vector .",
    "@xmath111^t \\hbox { where } s_i = \\left\\ { \\begin{array}{ll } 1 , & \\hbox{if $ i \\in s$ ; } \\\\ 0 , & \\hbox{otherwise.}\\end{array}\\right.\\ ] ]    to compare two identifying sets with respect to @xmath3 for vertices @xmath38 and @xmath112 , the following expression computes the size of @xmath113 .",
    "@xmath114    this implies that in order for @xmath3 to be a valid identifying code , we must have the following inequality satisfied for all pairs of vertices @xmath38 and @xmath112 .",
    "@xmath115    for the dominating property to be satisfied , we require the following additional inequality",
    ". @xmath116    thus our integer program is given by the following .",
    "@xmath117    in order to use these ideas for the d - wave machine , our constraints must be equalities .",
    "this means we must add binary slack variables for each inequality .",
    "for the first set of inequalities , we must determine an upper bound for each inequality . since these correspond to the constraint @xmath118",
    ", an easy upper bound is given by the following .",
    "@xmath119    for the class of de bruijn graphs , we are able to use this to get a bound on the number of slack variables needed .",
    "since the maximum size of any ball in @xmath12 is @xmath120 , this gives us an upper bound of size @xmath121 for this class of graphs .",
    "hence for each inequality in this set , we must add @xmath121 binary slack variables to convert the inequality to an equality . using a variable reduction method from @xcite",
    ", we can further reduce this number of variables to @xmath122 .",
    "since there are @xmath123 possible pairs @xmath124 , this implies that we must add a huge number of binary slack variables , equal to the following expression , just to satisfy the first set of inequalities .",
    "@xmath125 even in the case of @xmath45 , this means that we will need to add 320 variables to our list - an enormous number when compared to the graph size of 16 nodes .",
    "hence , this method is not going to be an efficient way to map our problem onto the d - wave machine .",
    "we present a binary optimization formula for the minimum identifying code problem .",
    "adjustments must be made to create a quadratic version ( qubo ) , making this approach impractical for large scale results .",
    "we will define this model using three separate functions : one to show that the set has the correct size , one to show that the set is dominating , and one to show that the set is separating ( or identifying ) .",
    "* variable definitions *    we will use the notation @xmath126 for @xmath127 , where @xmath128 .",
    "in other words , @xmath126 is the set containing all vertices adjacent to @xmath4 , plus @xmath4 itself .",
    "this is referred to in graph theory as the ball of radius one centered at @xmath4 .",
    "we define the variables as follows .",
    "@xmath129    * set @xmath3 has size @xmath130 *    we define the first function , @xmath131 , as follows .    @xmath132    * set @xmath3 is a dominating set *    by definition , this is equal to @xmath133 , @xmath134 .",
    "this is equivalent to the following .",
    "@xmath135    from this statement , we get the following equation for our second function .",
    "@xmath136    * set @xmath3 is a separating set *    by definition , this is equal to @xmath137 , @xmath138 .",
    "this is equivalent to the following for a specific pair @xmath139 .",
    "@xmath140    from this statement , we get the following equation for our third function , summed over all pairs @xmath141 .    @xmath142    * the binary optimization model *    from these three functions , our binary optimization model is the following .",
    "ccccc h(s ) & = & h_a(s ) + h_b(s ) + h_c(s ) + & = & 0 & & @xmath3    @xmath143    note that while this does provide a binary optimization model for our problem , it is not quadratic . in order to convert @xmath144 to a quadratic binary equation , each higher order term must be replaced with several new variables . while this is possible , it is a time - consuming and arduous process that introduces many new variables .",
    "hence this approach is not the most efficient implementation .",
    "the traditional brute force approach to solving the minimum identifying code problem constructs all possible subsets from smallest to largest size , and checks whether or not the set is a valid identifying code .",
    "parallelizing our algorithm ( implemented in matlab using the parallel computing toolbox ) requires moving the construction of subsets inside the parallelized loop . because of the exponential increase in the number of subsets created , it is more efficient to generate each subset within the loop and discard it after the iteration than to store all @xmath145 @xmath130-subsets and traverse through the list",
    "this is done using a @xmath130-subset unranking algorithm .",
    "two of these algorithms ( from @xcite ) are listed as algorithms [ unrank1 ] and [ unrank2 ] .",
    "these unranking functions allow us to completely parallelize the brute force algorithm , and the results obtained are listed in figure [ hpcres ] .",
    "@xmath146 @xmath147 @xmath148 @xmath149 * return * @xmath150    @xmath151 @xmath152 @xmath153 @xmath154 @xmath153 * return * @xmath155    0.4 @xmath156    0.4 @xmath157      satisfiability modulo theory ( smt ) is a current area of research that is concerned with the satisfiability of formulas with respect to some background theory @xcite .",
    "smt solvers combine boolean sat solving with decision procedures for specific theories . for example , consider the following problem . @xmath158 in the theory of the integers , this problem is not satisfiable ( there are no integers a , b , c where all the expressions are true ) , however in the theory of the real numbers it is satisfiable ( for example , with a=11 , b=10 , c=10.5 ) . in general , solving an smt problem consists of first solving a sat problem , then doing theory - specific reasoning , and then possibly going back and changing the sat problem .",
    "this process is repeated if necessary .",
    "in addition , multiple theories can also be used in the same smt problem instance , which may require additional repeats of this method .    to use smt solvers on our identifying code problem for the undirected de bruijn graph , we must first come up with a formulation of the problem using decision procedures .",
    "the graph @xmath12 , contains @xmath159 nodes . for each of these",
    ", we create a boolean variable that denotes whether or not the node is part of the identifying code .",
    "we then also create an array of boolean variables for that node s identifying set .",
    "an assertion is added to make sure that each element of the array is true if and only if the corresponding neighbor s boolean variable is true ( i.e. if and only if the neighbor is part of the identifying code ) .",
    "to ensure unique codes , we add a statement to require that each node s identifying set is unique from every other node s identifying set .",
    "then , to get codes of a fixed size , we create an integer variable for each node and add the constraints that the integer is at least 0 and no greater than 1 .",
    "next we add an assertion that each node s integer variable is 1 if and only if its boolean variable is true .",
    "finally , we add a constraint that the sum of all of the integer variables is equal to the desired identifying code size .",
    "now that the formulation of the problem has been determined , we can use a commercial smt solver to find solutions . for this work",
    ", we used the solver z3 , made by microsoft research .",
    "we begin by first picking a code size , and asking if there exists an identifying code of that size .",
    "if not , then the code size is increased by 1 and the problem is posed to z3 again .",
    "this continues until an identifying code of a specific size is found . to find _ all _ satisfying models , after a single model was found an assertion is inserted into the formulation that requires that the the previously found identifying code be eliminated as an option .",
    "this forces z3 to produce a different solution , or to state that the formulation is unsatisfiable ( and hence no more identifying codes of that size exist ) .",
    "this process is repeated in a loop to obtain all identifying codes .    using this approach on a single core",
    ", we were able to reproduce our results for @xmath12 from the hpc method in much less time . see figure [ smtres ] for a summary of these results . the numbers in parentheses denote that we found a code of that size , but did not eliminate the possibility of a smaller code existing .",
    "the times given are determined by the time required to find one solution of minimum size in addition to the time required to determine that no smaller code exists .",
    "0.4 @xmath160    0.4 @xmath161    because of the advancements in current sat and smt solvers , they offer the potential to scale much better than a parallelized brute force approach .",
    "this is due in part to the fact that many of today s solvers are capable of realizing which subsets of assignments will define an unsatisfiable result , and hence they will avoid models in which those statements are set . in our problem , this might correspond to a case in which nodes @xmath162 and @xmath163 have the same identifying set . in this case , the solver would not bother looking at combinations of true / false assignments on the other nodes that do not affect the identifying sets of @xmath162 or @xmath163 .",
    "in addition to the sophistication of today s solvers , there is also the possibility of parallelizing the search .",
    "while some instances were run manually in a parallel manner for this experiment , there is some research to be done on automatically parallelizing the search in order to further our known minimum results .",
    "the various methods discussed provide pure mathematicians with a range of opportunities for collaboration with scientists from several disciplines , such as computer science and physics .",
    "the methods explored in this study included a parallel computing approach using matlab , an adiabatic quantum optimization approach using a d - wave quantum annealing processor , and lastly using satisfiability modulo theory ( smt ) and corresponding smt solvers . from the base cases that we constructed using our variety of approaches , several new conjectures have been developed and eventually proven true @xcite , however the leg work needed to compute the base cases required a deep understanding of various computing techniques .",
    "work using the d - wave quantum annealing machine was performed jointly by afrl / ri and lockheed martin under air force cooperative research and development agreement 14-ri - crada-02 .",
    "s. adachi was supported by internal research and development funding from lockheed martin .",
    "s. adachi would also like to thank todd belote and dr .",
    "andy dunn of lockheed martin for their assistance respectively with the sat - to - ising mapping in section [ subsec : sat2ising ] , and with the generation of models for the scaling analysis of larger cases in section [ subsec : scaling ] .",
    "johnson , m.h.s .",
    "amin , s. gildert , t. lanting , f. hamze , n. dickson , r. harris , a.j .",
    "berkley , j. johansson , p. bunyk , e.m .",
    "chapple , c. enderud , j.p .",
    "hilton , k. karimi , e. ladizinsky , n. ladizinsky , t. oh , i. perminov , c. rich , m.c .",
    "thom , e. tolkacheva , c.j.s .",
    "truncik , s. uchaikin , j. wang , b. wilson , and g. rose , `` quantum annealing with manufactured spins '' , _ nature _ * 473 * ( 2011 ) , 194 - 198 .                v. mishra , j. mathew , and d.k",
    ". pradhan , `` fault - tolerant de bruijn graph base multipurpose architecture and routing protocol for wireless sensor networks '' , _ int .",
    "j. sensor networks _ , * 10*:3 ( 2011 ) , 160 - 175 .",
    "e.g. rieffel , d. venturelli , b. ogorman , m.b .",
    "do , e. prystay , and v.n .",
    "smelyanskiy , `` a case study in programming a quantum annealer for hard operational planning problems '' , arxiv:1407.2887v1 [ quant - ph ]"
  ],
  "abstract_text": [
    "<S> in order to formulate mathematical conjectures likely to be true , a number of base cases must be determined . </S>",
    "<S> however , many combinatorial problems are np - hard and the computational complexity makes this research approach difficult using a standard brute force approach on a typical computer . </S>",
    "<S> one sample problem explored is that of finding a minimum identifying code . to work around the computational issues , a variety of methods </S>",
    "<S> are explored and consist of a parallel computing approach using matlab , an adiabatic quantum optimization approach using a d - wave quantum annealing processor , and lastly using satisfiability modulo theory ( smt ) and corresponding smt solvers . each of these methods requires the problem to be formulated in a unique manner . in this paper , we address the challenges of computing solutions to this np - hard problem with respect to each of these methods . </S>"
  ]
}