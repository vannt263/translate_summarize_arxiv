{
  "article_text": [
    "with the proliferation of text data available in relational databases , simple ways to exploring such information effectively are of increasing importance . _",
    "keyword search in relational databases _ , with which a user specifies his / her information need by a set of keywords , is a popular information retrieval method because the user needs to know neither a complex query language nor the underlying database schemas .",
    "it has attracted substantial research effort in recent years , and a number of methods have been developed @xcite .",
    "[ egkeywordsearch ] consider a sample publication database shown in fig .",
    "[ fig : runningexample ] . fig .",
    "[ fig : runningexample ] ( a ) shows the three relations _ papers _ , _ authors _ , and _ writes_. in the following , we use the initial of each relation name ( @xmath1 , @xmath2 , and @xmath3 ) as its shorthand .",
    "there are two foreign key references : @xmath4 and @xmath5 .",
    "[ fig : runningexample ] ( b ) illustrates the tuple connections based on the foreign key references . for the keyword query `` james p2p '' consisting of two keywords `` james '' and `` p2p '' , there are six tuples in the database that contain at least one of the two keywords ( underlined in fig .",
    "[ fig : runningexample ] ( a ) ) .",
    "they can be regraded as the results of the query .",
    "however , they can be joined with other tuples according to the foreign key references to form more meaningful results , several of which are shown in fig .",
    "[ fig : runningexample ] ( c ) .",
    "the arrows represent the foreign key references between the corresponding pairs of tuples .",
    "finding such results which are formed by the tuples containing the keywords is the task of keyword search in relational databases .",
    "as described later , results are often ranked by relevance scores evaluated by a certain ranking strategy .",
    "_ pid _ & + @xmath7 & `` leveraging identity - based cryptography for node i d assignment in structured systems . ''",
    "+ @xmath8 & `` or not ? : in 2003 '' + @xmath9 & `` a system for predicting subcellular localization . ''",
    "+ @xmath10 & `` logical queries over views : decidability . ''",
    "+ @xmath11 & `` a conservative strategy to protect file sharing systems from pollution attacks . ''",
    "+ @xmath12 & +     + ( a ) database ( matched keywords are underlined )        \\(b ) tuple connections ( matched tuples + are solid circles )        \\(c ) examples of query results    most of the existing keyword search methods assume that the databases are static and focus on answering _ snapshot _ keyword queries . in practice , however , a database is often updated frequently , and the result of a snapshot query becomes invalid once the related data in the database is updated . for the database in fig .",
    "[ fig : runningexample ] , if publication data comes continually , new publication records are inserted to the three tables .",
    "such new records may be more relevant to `` james '' and `` p2p '' . hence , after getting the initial top-@xmath0 results , the user may demand the top-@xmath0 results to reflect the latest database updates .",
    "such demands are common in real applications .",
    "suppose a user want to do a top-@xmath0 keyword search in a micro - blogging database , which is being updated continually : not only the weblogs and comments are continually being inserted or deleted by bloggers , but also the follow relationship between bloggers are being updated continually .",
    "thus , a continual evaluation facility for keyword queries is essential in such databases .    for continual keyword query evaluation ,",
    "when the database is updated , two situations must be considered :    1 .",
    "database updates may change the existing top-@xmath0 results : some top-@xmath0 results may be replaced by new ones that are related to the new tuples , and some top-@xmath0 results may be invalid due to deletions .",
    "database updates may change the relevance scores of existing results because the underlying statistics ( e.g. , word frequencies ) are changed .    in this paper",
    ", we describe a system which can efficiently report the top-@xmath0 results of every monitoring query while the database is being updated continually .",
    "the outline of the system is as follows :    * when a continual query is issued , it is evaluated in a pipelined way to find the set of results whose upper bounds of relevance scores are higher than a threshold @xmath13 by calculating the upper bound of the future relevance score for every query result .",
    "* when the database is updated , we first update the relevance scores of the computed results , then find the new results whose upper bounds of relevance scores are larger than @xmath13 and delete the results containing the deleted tuples . *",
    "the pipelined evaluation of the keyword query is resumed if the number of computed results whose relevance scores are larger than @xmath13 falls below @xmath0 , or is reversed if the above number is much larger than @xmath0 .",
    "* at any time , the @xmath0 computed results whose relevance scores are the largest and are larger than @xmath13 are reported as the top-@xmath0 results .    in section  [ s :",
    "preliminaries ] , some basic concepts are introduced and the problem is defined .",
    "section  [ s : relwork ] discusses related work .",
    "section  [ s : continual ] presents the details of the proposed method .",
    "section  [ s : experiments ] gives the experimental results .",
    "conclusion is drawn in section  [ s : concl ] .",
    "in this section , we introduce some important concepts for top-@xmath0 keyword querying evaluation in relational databases .      we consider a relational database schema as a directed graph @xmath14 , called a schema graph , where @xmath15 represents the set of relation schemas @xmath16 and @xmath17 represents the foreign key references between pairs of relation schemas .",
    "given two relation schemas , @xmath18 and @xmath19 , there exists an edge in the schema graph , from @xmath19 to @xmath18 , denoted @xmath20 , if the primary key of @xmath18 is referenced by the foreign key defined on @xmath19 .",
    "for example , the schema graph of the publication database in fig .",
    "[ fig : runningexample ] is @xmath21 .",
    "a relation on relation schema @xmath18 is an instance of @xmath18 ( a set of tuples ) conforming to the schema , denoted @xmath22 .",
    "a tuple can be inserted into a relation .",
    "below , we use @xmath18 to denote @xmath22 if the context is obvious .",
    "the results of keyword queries in relational databases are a set of connected trees of tuples , each of which is called a _",
    "joint - tuple - tree _",
    "( _ jtt _ for short ) .",
    "a jtt represents how the _ matched tuples _ , which contain the specified keywords in their text attributes , are interconnected through foreign key references .",
    "two adjacent tuples of a jtt , @xmath23 and @xmath24 , are interconnected if they can be joined based on a foreign key reference defined on relational schema @xmath18 and @xmath19 in @xmath25 ( either @xmath26 or @xmath20 ) .",
    "the foreign key references between tuples in a jtt can be denoted using arrows or notation @xmath27 .",
    "for example , the second jtt in fig .",
    "[ fig : runningexample](c ) can be denoted as @xmath28 or @xmath29 . to be a valid result of a keyword query @xmath30",
    ", each leaf of a jtt is required to contain at least one keyword of @xmath30 . in fig .",
    "[ fig : runningexample](c ) , tuples @xmath7 , @xmath8 , @xmath31 and @xmath32 are matched tuples to the keyword query as they contain the keywords .",
    "hence , the four jtts are valid results to the query . in contrast",
    ", @xmath33 is not a valid result because tuple @xmath34 does not contain any required keywords .",
    "the number of tuples in a jtt @xmath35 is called the _ size _ of @xmath35 , denoted by @xmath36 .      given a keyword query @xmath30 , the _ query tuple set _",
    "@xmath37 of relation @xmath18 is defined as @xmath38 contains some keywords of @xmath39 .",
    "for example , the two query tuple sets in example  [ egkeywordsearch ] are @xmath40 and @xmath41 , respectively .",
    "free tuple set _",
    "@xmath42 of a relation @xmath18 with respect to @xmath30 is defined as the set of tuples that do not contain any keywords of @xmath30 . in example",
    "[ egkeywordsearch ] , @xmath43 , @xmath44 . if a relation @xmath18 does not contain text attributes ( e.g. , relation @xmath3 in fig .",
    "[ fig : runningexample ] ) , @xmath18 is used to denote @xmath42 for any keyword query .",
    "we use @xmath45 to denote a _",
    "tuple set _ , which may be either @xmath37 or @xmath42 .",
    "each jtt belongs to the result of a relational algebra expression , which is called a _",
    "candidate network _",
    "( _ cn _ )  @xcite .",
    "a cn is obtained by replacing each tuple in a jtt with the corresponding tuple set that it belongs to .",
    "hence , a cn corresponds to a join expression on tuple sets that produces jtts as results , where each join clause @xmath46 corresponds to an edge @xmath47 in the schema graph @xmath25 , where @xmath27 represents a equi - join between relations .",
    "for example , the cns that correspond to two jtts @xmath8 and @xmath48 in example  [ egkeywordsearch ] are @xmath49 and @xmath50 , respectively . in the following ,",
    "we also denote @xmath50 as @xmath51 . as the leaf nodes of jtts",
    "must be matched tuples , the leaf nodes of cns must be query tuple sets . due to the existence of @xmath52 relationships ( for example",
    ", an article may be written by multiple authors ) , a cn may have multiple occurrences of the same tuple set .",
    "the _ size _ of cn @xmath53 , denoted as @xmath54 , is defined as the number of tuple sets that it contains . obviously , the size of a cn is the same as that of the jtts it produces .",
    "[ figcnexample ] shows the cns corresponding to the four jtts shown in fig .",
    "[ fig : runningexample ] ( c ) .",
    "a cn can be easily transformed into an equivalent sql statement and executed by an rdbms . as : select * from w w , p p , a a where w.pid = p.pid and w.aid = a.aid and p.pid in ( @xmath7 , @xmath8 , @xmath11 ) and a.aid in ( @xmath31 , @xmath32 , @xmath55 ) . ]        when a continual keyword query @xmath56 is specified , the non - empty query tuple set @xmath37 for each relation @xmath18 in the target database are firstly computed using full - text indices .",
    "then all the non - empty query tuple sets and the database schema are used to generate the set of valid cns , whose basic idea is to expand each partial cn by adding a @xmath42 or @xmath37 at each step ( @xmath18 is adjacent to one relation of the partial cn in @xmath25 ) , beginning from the set of non - empty query tuple sets .",
    "the set of cns shall be sound / complete and duplicate - free .",
    "there are always a constraint , @xmath57 ( the maximum size of cns ) to avoid generating complicated but less meaningful cns . in the implementation",
    ", we adopt the state - of - the - art cn generation algorithm proposed in  @xcite .",
    "[ eg : cngenerate ] in example  [ egkeywordsearch ] , there are two non - empty query tuple sets @xmath49 and @xmath58 . using them and the database schema graph , if @xmath59 , the generated cns are : @xmath60 , @xmath61 , @xmath62 , @xmath63 , @xmath64 , @xmath65 and @xmath66 .",
    "the problem of _ continual top-@xmath0 keyword search _ we study in this paper is to continually report top-@xmath0 jtts based on a certain scoring function that will be described below .",
    "we adopt the scoring method employed in @xcite , which is an ordinary ranking strategy in the information retrieval area .",
    "the following function @xmath67 is used to score jtt @xmath35 for query @xmath30 , which is based on the tf - idf weighting scheme : @xmath68 where @xmath69 is a tuple ( a node ) contained in @xmath35 .",
    "@xmath70 is the _",
    "tuple score _ of @xmath71 with regard to @xmath30 defined as follows : @xmath72 where @xmath73 is the _ term frequency _ of keyword @xmath3 in tuple @xmath71 , @xmath74 is the number of tuples in relation @xmath75 ( the relation corresponds to tuple @xmath71 ) that contain @xmath3 .",
    "@xmath74 is interpreted as the _ document frequency _ of @xmath3 .",
    "@xmath76 represents the size of tuple @xmath71 , i.e. , the number of letters in @xmath71 , and is interpreted as the _ document length _ of @xmath71 .",
    "@xmath77 is the _ total number _ of tuples in @xmath75 , @xmath78 is the _ average tuple size _ ( _ average document length _ ) in @xmath75 , and @xmath79  ( @xmath80 ) is a constant which usually be set to 0.2 .    table  [ tuplescores1 ] shows the tuple scores of the six matched tuples in example  [ egkeywordsearch ] . we suppose all the matched tuples are shown in fig .",
    "[ fig : runningexample ] , and the numbers of tuples of the two relations are 150 and 180 , respectively . therefore , the top-3 results are @xmath81 ( @xmath82 ) , @xmath83 ( @xmath84 ) and @xmath85 ( @xmath86 ) .",
    "[ tuplescores1 ]    the score function in eq .",
    "( [ eq : score ] ) has the property of _ tuple monotonicity _ , defined as follows .",
    "for any two jtts @xmath87 and @xmath88 generated from the same cn @xmath53 , if for any @xmath89 , @xmath90 , then we have @xmath91 .",
    "as shown in the following discussion , this property is relied by the existing top-@xmath0 query evaluation algorithms .",
    "given @xmath92-keyword query @xmath93 , the task of keyword search in a relational database is to find structural information constructed from tuples in the database  @xcite .",
    "there are two approaches .",
    "the _ schema - based approaches _ @xcite in this area utilize the database schema to generate sql queries which are evaluated to find the structures for a keyword query .",
    "they process a keyword query in two steps .",
    "they first utilize the database schema to generate a set of relation join templates ( i.e. , the cns ) , which can be interpreted as select - project - join views .",
    "then , these join templates are evaluated by sending the corresponding sql statements to the dbms for finding the query results .",
    "@xcite proved how to generate a complete set of cns when the @xmath94 has a user - given value and discussed several query processing strategies when considers the common sub - expressions among the cns . @xcite all focused on finding all jtts , whose sizes are @xmath95 , which contain all @xmath92 keywords , and there is no ranking involved . in @xcite and @xcite , several algorithms are proposed to get top-@xmath0 jtts .",
    "we will introduce them in detail in section  [ ss : topk ] .",
    "the _ graph - based methods _",
    "@xcite model and materialize the entire database as a directed graph where the nodes are relational tuples and the directed edges are foreign key references between tuples . fig .",
    "[ egkeywordsearch](b ) shows such a database graph of the example database .",
    "then for each keyword query , they find a set of structures ( either steiner trees  @xcite , distinct rooted trees  @xcite , @xmath96-radius steiner graphs  @xcite , or multi - center subgraphs  @xcite ) from the database graph , which contain all the query keywords and are connected by the paths in database graph .",
    "such results are found by graph traversals that start from the nodes that contain the keywords .",
    "for the details , please refer the survey papers  @xcite .",
    "the materialized data graph should be updated for any database changes ; hence this model is not appropriate to the databases that change frequently  @xcite .",
    "therefore , this paper adopts the schema - based framework and can be regarded as an extension for dealing with continual keyword search .",
    "discover2 @xcite proposed the  _ global - pipelined _ ( _ gp _ ) algorithm to get the top-@xmath0 results which are ranked by the ir - style ranking strategy shown in section [ ss : scoreingmethod ] .",
    "the aim of the algorithm is to find a proper order of generating jtts in order to stop early before all the jtts are generated .",
    "it employs the _ priority preemptive _ , _ round robin _",
    "protocol @xcite to find results from each query tuple set prefix in a pipelined way , thus each cn can avoid being fully evaluated .    for a keyword query @xmath30 , given a cn @xmath53 , let the set of query tuple sets of @xmath53 be @xmath97 .",
    "tuples in each @xmath37 are sorted in non - increasing order of their scores computed by eq .",
    "[ eq : tscore ] .",
    "let @xmath98 be the @xmath99-th tuple in @xmath37 .",
    "in each @xmath37 , we use @xmath100 to denote the current tuple such that the tuples before the position of the tuple are all processed , and we use @xmath101 to move @xmath100 to the next position .",
    "@xmath102 ( where @xmath103 is a tuple , and @xmath104 ) denotes the parameterized query which checks whether the @xmath105 tuples can form a valid jtt . for each tuple @xmath98",
    ", we use @xmath106 to denote the upper bound score for all the jtts of @xmath53 that contain the tuple @xmath98 , defined as follows : @xmath107 according to the tuple monotonicity property of eq .",
    "( [ eq : score ] ) and the sorting order of tuples , among the unprocessed tuples of @xmath108 , @xmath109 has the maximum value .    algorithm  gp initially mark all tuples in @xmath108 ( @xmath110 ) of each cn @xmath53 as un - processed except for the top - most ones .",
    "then in each while iteration ( one round ) , the un - processed tuple which maximizes the @xmath111 value is selected for processing .",
    "suppose tuple @xmath112 maximizes @xmath111 , processing @xmath112 is done by joining it with the processed tuples in the other query tuple sets of @xmath113 to find valid jtts : all the combinations as @xmath114 are tested , where @xmath103 is a processed tuple of @xmath115 ( @xmath110 , @xmath116 ) .",
    "if the @xmath0-th relevance score of the found results is larger than @xmath111 values of all the un - processed tuples in all the cns , it can stop and output the @xmath0 found results with the largest relevance scores because no results with higher scores can be found in the further evaluation .",
    "one drawback of the gp algorithm is that when a new tuple @xmath117 is processed , it tries all the combinations of processed tuples @xmath118 to test whether each combination can be joined with @xmath117 .",
    "this operation is costly due to extremely large number of combinations when the number of processed tuples becomes large @xcite .",
    "spark @xcite proposes the _ skyline - sweeping _ algorithm to reduce the number of combinations test .",
    "spark uses a priority queue @xmath119 to keep the set of seen but not tested combinations ordered by the priority defined as the score of the hypothetical jtt corresponding to each combination . in each round , the combination in @xmath119 with the maximum priority is tested , then all its adjacent combinations are inserted into @xmath119 but only the combinations that have the high priorities are tested .",
    "spark still can not avid testing a huge number of combinations which can not produce results , though the number of combinations test is highly reduced compared to discover2 .",
    "this paper evaluates the cns in a pipelined way like @xcite and @xcite , but also employs the following two optimization strategies , whose high efficiencies are shown in @xcite :    sharing the computational cost among cns ; and    adopting tuple reduction .",
    "the most related projects to our paper are _ s - kws _",
    "@xcite and _ kdynamic _",
    "@xcite , which try to find new results or expired results for a given keyword query over an open - ended , high - speed large relational data stream  @xcite .",
    "they adopt the schema - based framework since the database is not static .",
    "this paper deals with a different problem from _ s - kws _ and _ kdynamic _ , though all need to respond to continual queries in a dynamic environment . _ s - kws _ and _ kdynamic _ focus on finding all query results . on the contrary ,",
    "our methods maintain the top-@xmath0 results , which is less sensitive to the updates of the underlying databases because not every new or expired results change the top-@xmath0 results .",
    "_ s - kws _ maps each cn to a left - deep _ operator tree _ , where leaf operators ( nodes ) are tuple sets , and interior operators are joins",
    ". then the operator trees of all the cns are compacted into an _ operator mesh _ by collapsing their common subtrees .",
    "joins in the operator mesh are evaluated in a bottom - to - top manner .",
    "a join operator has two inputs and is associated with an output buffer which saves its results ( partial jtts ) .",
    "the output buffer of a join operator becomes input to many other join operators that share the join operator .",
    "a new result that is newly outputted by a join operator will be a new arrival input to those joins sharing it .",
    "the operator mesh has two main shortcomings  @xcite :    only the left part of the operator trees can be shared ; and    a large number of intermediate tuples , which are computed by many join operators in the mesh with high processing cost , will not be eventually output in the end .    for overcoming the above shortcomings of _ s - kws _ ,",
    "_ kdynamic _ formalizes each cn as a rooted tree , whose root is defined to be the node @xmath96 such that the maximum path from @xmath96 to all leaf nodes of the cn is minimized ; and then compresses all the rooted trees into a @xmath120-lattice by collapsing the common subtrees .",
    "[ fig : lattice](a ) shows the lattice of two hypothetical cns .",
    "each node @xmath15 in the lattice is also associated with an output buffer , which contains the tuples in @xmath15 that can join at least one tuple in the output buffer of its each child node .",
    "thus , each tuple in the output buffer of each top - most node @xmath15 , i.e. , the root of a cn , can form jtts with tuples in the output buffers of its descendants . the new jtts involving a new tuple",
    "are found in a two - phase approach . in the filter phase , as illustrated in fig .",
    "[ fig : lattice](b ) , when a new tuple @xmath121 is inserted into node @xmath122 , _ kdynamic _ uses selections and semi - joins to check if    @xmath121 can join at least a tuple in the output buffer of each child node of @xmath122 ; and    @xmath121 can join at least a tuple in the output buffers of the ancestors of @xmath122 .",
    "the new tuples that can not pass the checks are pruned ; otherwise , in the join phase ( shown in fig .  [ fig : lattice](c ) ) , a joining process is initiated from each tuple in the output buffer of each root node that can join @xmath121 , in a top - down manner , to find the jtts involving @xmath121 .    ,",
    "scaledwidth=90.0%,height=98 ]    \\(a ) @xmath120-lattice of two cns    , scaledwidth=95.0% ]    \\(b ) filter phase    , scaledwidth=95.0% ]    \\(c ) join phase    in this paper , we incorporate the ranking mechanisms and the pipelined evaluation into the query processing method of _ kdynamic _ to support efficient top-@xmath0 keyword search in relational databases .",
    "database updates bring two orthogonal effects on the current top-@xmath0 results :    1 .",
    "they change the values of @xmath74 , @xmath77 , and @xmath78 in eq .",
    "( [ eq : tscore ] ) and hence change the relevance scores of existing results .",
    "new jtts may be generated due to insertions .",
    "existing top-@xmath0 results may be expired due to deletions .    although the second effect is more drastic , the first effect is not negligible for long - term database modifications .",
    "thus , we can not neglect all the jtts that are not the current top-@xmath0 results because some of them have the potential of becoming the top-@xmath0 results in the future .",
    "this paper solves this problem by bounding the future relevance score of each result .",
    "we use @xmath123 to denote the upper bound of relevance score for each result .",
    "then , the results whose @xmath123 values are not larger than relevance score of the top-@xmath0-th results can be safely ignored .",
    "the second challenge is shortage of top-@xmath0 results because they can be expired due to deletions .",
    "since the value @xmath0 is rather small compared to the huge number of all the valid jtts , the possibility of deleting a top-@xmath0 result is rather small .",
    "in addition , new top-@xmath0 results can also be formed by new tuples .",
    "thus , if the insertion rate is not much smaller than the deletion rate , the possibility of occurring of top-@xmath0 results shortage would be small . however , this possibility would be high if the deletion rate is much larger , which can result in frequent top-@xmath0 results refilling operations .",
    "it worth noting that the top-@xmath0 results shortage can also be caused by the relevance score changing of results .",
    "our solution to this problem is to compute the top-@xmath124 ( @xmath125 ) results instead of the necessary @xmath0 .",
    "@xmath126 is a margin value .",
    "then , we can stand up to @xmath126 times of deletion of top results when maintaining the top-@xmath0 results .",
    "the setting of @xmath126 is important .",
    "if @xmath126 is too small , it may has a high possibility to refill .",
    "if @xmath126 is too large , the efficiency of handling database modifications is decreased . instead of analyzing the update behavior of the underlying database to estimate an appropriate @xmath126 value ,",
    "we enlarge @xmath126 on each time of top-@xmath0 results shortage until it reaches a value such that the occurring frequency of top-@xmath0 results shortage falls below a threshold .    on the contrary , after maintaining the top-@xmath0 results for a long time , the number of computed top results maybe larger than @xmath124 , especially when the insertion rate is high .",
    "in such cases , the top-@xmath0 results maintaining efficiency is decreased because we need to update the relevance scores for more results and join the new tuples with more tuples than necessary . as shown in the experimental results ,",
    "such extra cost is not negligible for long - term database modifications .",
    "therefore , we need to reverse the pipelined query evaluation if there are too many computed top results .    in brief ,",
    "when a continual keyword query is registered , we first generate the set of cns and compact them into a lattice @xmath120 .",
    "then , the initial top-@xmath0 results is found by processing tuples in @xmath120 in a pipelined way until the @xmath123 values of the un - seen jtts are not larger than relevance score of the top-@xmath124-th result ( which is denoted by @xmath127 ) . when maintaining the top-@xmath0 results , we only find the new results that are with @xmath128 .",
    "the pipelined evaluation of @xmath120 is resumed if the number of found results with @xmath128 falls below @xmath0 , or is reversed if the above number is larger than @xmath124 .",
    "the method of computing @xmath123 for results is introduced in section  [ ss : upperbound ] .",
    "section  [ ss : cnevaluation ] and section  [ ss : topkmaintain ] describe our method of computing the initial top-@xmath0 results and maintaining the top-@xmath0 results , respectively .",
    "then , two techniques which can highly improve the query processing efficiency are presented in section  [ ss : cachingjoinedtuples ] and section  [ ss : cnclustering ] .",
    "let us recall the function for computing tuple scores given in eq .",
    "( [ eq : tscore ] ) : @xmath129 we assume that the future values of each @xmath130 and @xmath78 both have an upper bound @xmath131 and @xmath132 , respectively .",
    "then , we can derive the upper bound of the future tuple score for each tuple @xmath71 as : @xmath133 hence , the upper bound of the future relevance score of a jtt @xmath35 is : @xmath134 note that the function in eq .",
    "( [ scoreupperbound ] ) also has the tuple monotonicity property on @xmath135 .    on query registration , each @xmath131",
    "is computed as @xmath136 , and each @xmath132 is computed as @xmath137 , where @xmath138 and @xmath139 both are set as small values ( @xmath140 ) . when maintaining the top-@xmath0 results , we continually monitor the change of statistics to determine whether all the @xmath141 and @xmath78 values below their upper bounds . at each time that any @xmath142 or @xmath78 value exceeds its upper bound , the @xmath138 or @xmath139 is enlarged until the frequencies of exceeding the upper bounds fall below a small number .",
    "table  [ fig : tscorebound ] shows the @xmath135 values of the six matched tuples in example  1 by setting @xmath143 and @xmath144 .",
    "hence , @xmath145 , @xmath146 and @xmath147 .",
    "[ fig : tscorebound ]      fig .",
    "[ fig : latticeall ] shows the @xmath120-lattice of the seven cns in example  [ eg : cngenerate ] .",
    "we use @xmath148 to denote a node in @xmath120 .",
    "particularly , @xmath149 denotes a lattice node of query tuple set , and @xmath150 denotes the query tuple set of @xmath149 .",
    "the dual edges between two nodes , for instance , @xmath151 and @xmath152 , indicate that @xmath152 is a dual child of @xmath151 .",
    "a node @xmath148 in @xmath120 can belongs to multiple cns .",
    "we use @xmath153 to denote the set of cns that node @xmath148 belongs to .",
    "for example , @xmath154 .",
    "tuples in each query tuple set @xmath150 are sorted in non - increasing order of @xmath135 .",
    "we use @xmath155 to denote the current tuple such that the tuples before the position of the tuple are all processed , and we use @xmath156 to move @xmath155 to the next position . initially , for each node @xmath157 in @xmath120 , @xmath155 is set as the top tuple in @xmath150 . in fig .",
    "[ fig : latticeall ] , @xmath155 of the four nodes are denoted by arrows . for a node @xmath148 that is of a free tuple set @xmath42 , we regard all the tuples of @xmath42 as its processed tuples for all the times .",
    "we use @xmath158 to indicate the output buffer of @xmath148 , which contains its processed tuples that can join at least one tuple in the output buffer of each child node of @xmath148 .",
    "tuples in @xmath158 are also referred as the outputted tuples of @xmath148 .    in order to find the top-@xmath0 results in a pipelined way",
    ", we need to bound the @xmath159 values of the un - found results . for each tuple @xmath160 of @xmath150",
    ", the maximal @xmath159 values of jtts that @xmath160 can form is defined as follows : @xmath161 where @xmath162 indicates the maximal @xmath163 for all the jtts of @xmath53 that contain tuple @xmath160 , and is obtained by replacing @xmath164 in eq .",
    "( [ eq : scoretuple ] ) with @xmath165 .",
    "if a child of @xmath149 has empty output buffer , processing any tuple at @xmath149 can not produce jtts ; hence @xmath166 in such cases , which can choke the processing tuples at @xmath149 until all its child nodes have non - empty output buffers .",
    "according to eq .",
    "( [ eq : scoreuupperbound ] ) and the tuples sorting order , among the un - processed tuples of @xmath150 , @xmath167 has the maximum value .",
    "we use @xmath168 to denote @xmath167 . in fig .",
    "[ fig : latticeall ] , @xmath168 values of the four @xmath149 nodes are shown next to the arrows .",
    "for example , @xmath169 .",
    "algorithm  [ alg : evalstatic ] outlines our pipelined algorithm of evaluating the lattice @xmath120 to find the initial top-@xmath0 results , which is similar to the gp algorithm .",
    "lines  [ declarequeue2]-[initvqcursor ] are the initialization step to sort tuples in each query tuple set and to initialize each @xmath155 .",
    "then in each while iteration ( lines  [ whilestart2]-[whileend2 ] ) , the un - processed tuple in all the @xmath157 nodes that maximizes @xmath170 is selected to be processed .",
    "processing the selected tuples is done by calling the procedure @xmath171 .",
    "algorithm  [ alg : evalstatic ] stops when @xmath172 is not larger than the relevance score of the top-@xmath124-th found results .",
    "the procedure @xmath173 is provided in _ kdynamic _",
    ", which updates the output buffers for @xmath148 ( line  [ updatevoutput ] ) and all its ancestors ( lines  [ updatefatherbegin]-[updatefatherend ] ) , and finds all the jtts containing tuple @xmath71 by calling the procedure @xmath174 ( line  [ findnewjttsend ] ) .",
    "we will explain procedure @xmath171 using examples later .",
    "the recursive procedure @xmath175 is provided in _ kdynamic _ too , which constructs jtts using the outputted tuples of @xmath148 s descendants that can join @xmath71 .",
    "the stack @xmath176 , which records where the join sequence comes from , is used to reduce the join cost .",
    "@xmath177 : the priority queue for storing found jtts ordered by @xmath178[declarequeue2 ] sort tuples of each @xmath150 in non - increasing order of @xmath135[sorttuples ] output the first @xmath0 results in @xmath179 @xmath180.score$][setthetavalue ]    procedure @xmath171(lattice node @xmath148 , tuple @xmath71 ) procedure @xmath174(lattice node @xmath148 , tuple @xmath71 , stack @xmath176 ) @xmath181 @xmath182    in the first round , tuple @xmath183 is processed by calling @xmath184 . since @xmath185 is the root node of @xmath186 , @xmath174",
    "is called and jtt @xmath81 is found .",
    "then , for the two father nodes of @xmath185 , @xmath187 and @xmath188 , @xmath189 is not updated because @xmath190 , @xmath191 is updated to @xmath192 because @xmath8 can join @xmath193 and @xmath194 . and",
    "then , for the two father nodes of @xmath188 , @xmath195 and @xmath196 , @xmath197 is not updated since @xmath195 has no processed tuples , @xmath198 is set as @xmath199 because there is only one tuple @xmath34 in @xmath200 that can join @xmath193 and @xmath194 . since @xmath196 is the root node ( of @xmath201 ) , @xmath202 is called but no results are found because the only one found jtt @xmath203 is not a valid result . after processing tuple @xmath183 , @xmath204 and @xmath205 . in the second round , tuple @xmath206",
    "is processed , which finds results @xmath83 and @xmath85 .",
    "then , @xmath207 , @xmath208 , @xmath209 , @xmath210 , and @xmath211 . in the third - fifth rounds , tuples @xmath212 , @xmath213 and @xmath214 are processed , which insert @xmath31 into @xmath197 and no results found . in the sixth round , tuple @xmath215 is processed , which finds results @xmath32 and @xmath216 .",
    "then , algorithm  [ alg : evalstatic ] stops because the relevance score of the third result in the queue @xmath179 ( suppose @xmath217 ) is larger than all the @xmath218 values .",
    "[ fig : latticeall2 ] shows the snapshot of @xmath120 after finding the top-3 results .",
    "thus , @xmath219 after the evaluation .",
    "after the execution of algorithm  [ alg : evalstatic ] , @xmath123 values of all the un - found results are not larger than @xmath127 .",
    "results in the queue @xmath220 can be categorized into three kinds .",
    "the first kind are the @xmath124 results that are with @xmath221 , which are the initial top-@xmath124 results .",
    "the second kind are with @xmath222 and @xmath221 , which are called the _ potential _",
    "top-@xmath124 results because they have the potential to become the top-@xmath124 results .",
    "the third kind are with @xmath223 .",
    "as shown in the experiment , the results of the last kind may have a large number .",
    "however , we can not discard them because some of them may become the first two kinds when maintaining the top-@xmath0 results .",
    "algorithm  [ alg : maintenance ] shows our algorithm of maintaining top-@xmath0 results .",
    "a database update operator is denoted by @xmath224 , which represents a tuple @xmath71 of relation @xmath225 is inserted ( if @xmath226 is a insertion ) or deleted ( if @xmath226 is a deletion ) . note that the database updates is modeled as deletions followed by insertions . for a new arrival @xmath224 , algorithm  [ alg : maintenance ] first checks whether the @xmath130 and @xmath78 values of relation @xmath225 exceed their upper bounds .",
    "if some @xmath130(s ) or @xmath78 exceeds their upper bounds , we enlarge , @xmath139 and @xmath126 are introduced in detail in the experiments . ] the corresponding @xmath138(s ) or @xmath139 ( line  [ enlargeupperbound ] ) , and then update the @xmath178 and @xmath163 values for all the tuples in @xmath227 and all the results in the queue @xmath220 using the enlarged @xmath130(s ) or @xmath78 ( line  [ updateallrelevancescore ] ) ; otherwise , we update the relevance scores for the results in @xmath220 that are with @xmath221 ( line  [ updateportionrelevancescore ] ) .",
    "then , we insert @xmath71 into @xmath120 to find the new results if @xmath226 is an insertion ( lines  [ insertionbegin]-[insertionend ] ) , or delete the expired jtts and @xmath71 from @xmath120 if @xmath226 is a deletion ( lines  [ deletionbegin]-[deletionend ] ) . lines  [ insertionbegin]-[deletionend ] are explained in detail latter . and",
    "then , the @xmath228 of some nodes may be large than @xmath127 , which can be caused by three reasons :    the upper bound scores of tuples of relation @xmath225 are increased ;    the @xmath228 of some nodes are increased from 0 after inserting the new tuple into @xmath120 ; and    new cns are added into @xmath120 .    therefore , in lines  [ poststart]-[postevaluateonenode ] , we process tuples using procedure @xmath171 until all the @xmath228 values are not larger than @xmath127 .",
    "procedure @xmath229 delete @xmath71 from @xmath158    finally , in lines  [ resume]-[rollback ] , we count the number of results that are with @xmath221 . if the number is smaller than @xmath0 , @xmath126 is enlarged , and then the @xmath230 algorithm ( without the initialization step ) is called to further evaluate @xmath120 . if the number is larger than @xmath231 , the algorithm @xmath232 , which is described at the end of this subsection , is called to rollback the evaluation of @xmath120 . in any case , at the end of handling the @xmath226 , we have @xmath233.score$ ] .",
    "therefore , the @xmath0 results in @xmath220 that have the largest relevance scores are the top-@xmath0 results .",
    "we do not process the results in @xmath179 that are with @xmath234 in line  [ updateportionrelevancescore ] and line  [ deleteresults ] , because they can have a large number and do not have the potential to become top-@xmath0 results .",
    "however , after the execution of lines  [ updateallrelevancescore ] and [ enlargedeltak ] , @xmath123 of some of them may become larger than @xmath127 , because their @xmath123 values may be enlarged in line  [ updateallrelevancescore ] and the @xmath127 may be decreased in line  [ enlargedeltak ] .",
    "therefore , all the results in @xmath179 need to be considered in lines  [ updateallrelevancescore ] and [ enlargedeltak ] .",
    "note that we have to firstly check whether some of them have expired due to deletions .    in lines",
    "[ insertionbegin]-[insertionend ] , the new tuple @xmath71 is processed differently according to whether it contains the keywords . if @xmath71 is an un - matched tuple , it is inserted into each node of @xmath235 using the procedure @xmath171 ( line  [ insertnewtupletofreetupleset ] ) .",
    "if @xmath71 is a matched tuple , inserting it into @xmath120 is more complicated .",
    "first , if @xmath71 introduces a new non - empty query tuple set @xmath227 , we add the new cns involving @xmath227 into the lattice .",
    "[ fig : latticeinsertnewcn ] illustrates the process of inserting a new cn into the lattice shown in fig .",
    "[ fig : latticeall2 ] . assuming that @xmath236 is the largest common subtree of the new cn and @xmath120 , and @xmath237 is the father node of @xmath236 in the new cn , then the new cn is added by setting @xmath188 as the child of @xmath237 .",
    "if @xmath237 is a free tuple set and it does not have other child nodes as shown in fig .",
    "[ fig : latticeinsertnewcn ] , @xmath238 is called for each tuple @xmath239 of @xmath237 that can join tuples in @xmath191 . further evaluation at the nodes of the new cn , if necessary , will be done in lines  [ poststart]-[postevaluateonenode ] .",
    "second , @xmath71 is added into the query tuple set @xmath240 ( line  [ insertnewtupletotupleset ] ) , and then for each node @xmath149 of @xmath227 , @xmath241 is called when @xmath242 ( line  [ measurenewtuplepotential ] ) , i.e. , @xmath71 has the potential to form jtts that are with @xmath128 .",
    "[ fig : latticeinsertnewcn ]    if @xmath243 is a deletion , for each node @xmath148 in @xmath120 such that @xmath244 , we delete @xmath71 from @xmath158 using the procedure @xmath245 , which is provided by _",
    "kdynamic_. procedure @xmath245 first removes @xmath71 from @xmath158 , and then checks whether some outputted tuples of the ancestors of @xmath148 need to be removed ( lines  [ deletefathertuplebegin]-[deletefathertupleend ] ) .",
    "for instance , if the tuple @xmath32 is deleted from the lattice node @xmath246 shown in fig .",
    "[ fig : latticeall2 ] , tuples @xmath247 and @xmath248 are deleted from @xmath249 too because they can join @xmath32 only , among tuples in @xmath250 .",
    "algorithm  [ alg : rollback ] outlines out algorithm to reverse the execution of the pipelined evaluation of the lattice . in the beginning",
    ", @xmath127 is set as the relevance score of the @xmath124-th result in the queue @xmath179 ( line  [ resetthetavalue ] ) .",
    "then , the processing on each processed tuple @xmath251 that is of @xmath252 is reversed ( lines  [ rollbackbegin]-[rollbackend ] ) .",
    "we use @xmath253 to denote the tuple just before @xmath254 . if @xmath255 , the results involving by @xmath71 are firstly deleted from @xmath179 , and then @xmath71 is deleted from @xmath256 by calling the procedure @xmath245 .",
    "@xmath180.score$][resetthetavalue ]      in algorithm  [ alg : evalstatic ] and algorithm  [ alg : maintenance ] , procedure @xmath171 and @xmath245 may be called by multiple times upon multiple nodes for the the same tuple .",
    "the core of the two procedures are the _ select operations _ ( or semi - joins @xcite ) . for example , in line  [ checkiftcanoutput ] and line  [ selecttuplescanjoint ] of procedure @xmath171 , we need to select the tuples that can join @xmath71 from the output buffer of each child node of @xmath148 and the set of processed tuples of each father node of @xmath148 , respectively .",
    "although such select operations can be done efficiently by the dbms using indexes , the cost of handling @xmath71 is high due to the large number of database accesses .",
    "for example , in our experiments , for a new tuple @xmath71 , the maximal number of database accesses can be up to several hundred .",
    "these select operations done for the same tuple @xmath71 can be done efficiently by sharing the computational cost among them .",
    "assume a new tuple @xmath257 is inserted into the lattice shown in fig .",
    "[ fig : latticeall2 ] , then procedure @xmath171 is called by three times ( @xmath258 , @xmath259 and @xmath260 ) and at most eight selections are done .",
    "all the eight select operations can be expressed using following two relational algebra expressions : @xmath261 and @xmath262 , where @xmath263 and @xmath264 represent the set of tuples in the output buffer of a node or the set of processed tuples of a node .",
    "since @xmath263 and @xmath264 can be different from each other , the eight select operations need to be evaluated individually .",
    "however , if we rewrite the above expressions as @xmath265 and @xmath266 , the eight select operations would have two common sub - operations : @xmath267 and @xmath268 .",
    "if the results of the two common sub - operations can be shared and do selections @xmath269 and @xmath270 in the main memory , the eight select operations can be evaluated involving only two database accesses .",
    "let @xmath18 be the relation corresponding to the tuple set of @xmath148    * false *    algorithm  [ alg : canjoinoneoutputtuple ] shows our procedure to check whether tuple @xmath71 can join at least one tuple in the output buffer of a lattice node @xmath148 , which is called in line  [ checkiftcanoutput ] of procedure @xmath171 . in line  [ queryjoinedtuples ] ,",
    "all the tuples in relation @xmath18 that can join @xmath71 are queried and cached in the main memory .",
    "this set of cached joined tuples can be reused every time when they are queried .",
    "the procedures for the select operations in line  [ selecttuplescanjoint ] of @xmath171 and line  [ selectfathertuplestodelete ] of @xmath245 are also designed in this pattern , which are omitted due to the space limitation .",
    "note that when the two procedures @xmath171 and @xmath245 are called recursively , select operations done in the above lines are also evaluated by these procedures .",
    "therefore , for each tuple @xmath71 , a tree of tuples , which is rooted at @xmath71 and consist of all the tuples than can join @xmath71 , is created .",
    "the tree of tuples can be seen as the cached localization information of @xmath71 .",
    "it is created on - the - fly , i.e. , along with the execution of procedures @xmath171 and @xmath245 , and its depth is determined by the recursion depth of the two procedures .",
    "the maximum recursion depth of procedures @xmath171 and @xmath245 is @xmath271 @xcite , where @xmath57 indicates the maximum size of the generated cns .",
    "hence , the height of this tree of tuples is bounded by @xmath271 too .",
    "suppose a new tuple @xmath272 of @xmath273 is inserted into the two nodes of @xmath273 in the lattice shown in fig .",
    "[ fig : latticeall2 ] , fig .",
    "[ fig : latticecache ] illustrates the select operations done in the procedure @xmath171 ( denoted as arrows in the left part ) and the cached joined tuples of @xmath272 ( shown in the right part ) .",
    "for instance , the arrows form @xmath185 to @xmath188 selects the tuples in relation @xmath3 that can join @xmath272 .",
    "the three select operations are denoted by dashed arrows because they would not be done if results of the two select operations , from @xmath185 to @xmath188 and from @xmath185 to @xmath187 , are empty .",
    "for the same reason , the stored tuples of relation @xmath2 that can join @xmath272 are denoted using dashed rectangles .",
    "when computing the initial top-@xmath0 results , the database is static ; hence the cached joined tuples of each tuple unchange and can be reused before the database is updated .",
    "when maintain the top-@xmath0 results , although the database is continually updated , we can assume the database unchange before @xmath71 is handled .",
    "however , the cached joined tuples of @xmath71 is expired after @xmath71 is handled by algorithm  [ alg : maintenance ] . as shown in the experimental results , caching the joined tuples can highly improve the efficiency of computing the initial top-@xmath0 results and maintaining the top-@xmath0 results .      according to eq .",
    "( [ eq : scoretuple ] ) , @xmath274 values of tuples in different cns have great differences . for example , @xmath274 values of tuples in @xmath201 and @xmath275 are smaller than that of tuples in @xmath276 due to the large cn size . in algorithm",
    "gp , no tuples or only a small portion are joined in the cns whose tuples have small @xmath111 values .",
    "if the cns in example  [ eg : cngenerate ] are evaluated by algorithm gp , @xmath277 of @xmath278 and @xmath273 of @xmath279 would have no processed tuples .",
    "however , in the lattice , a node @xmath37 can be shared by multiple cns .",
    "thus , when inserting a tuple @xmath71 into @xmath37 , @xmath71 is processed in all the cns in @xmath280 . as shown in fig .",
    "[ fig : latticeall2 ] , since @xmath246 is shared by @xmath281 , @xmath282 , @xmath283 and @xmath278 in the lattice , tuples @xmath31 and @xmath32 are processed in all these four cns when processing them at @xmath246 , which results in _ un - needed _ operations at nodes @xmath284 and @xmath152 two un - needed results @xmath32 and @xmath216 .",
    "we call the operations at @xmath284 and @xmath152 and the two jtts as un - needed because they wound not occur or be found if the cns are evaluated separately .",
    "these un - needed operations can cause further un - needed operations when maintaining the top-@xmath0 results .",
    "for example , we have to join a new unmatched tuple of relation @xmath1 with four tuples in @xmath249 .",
    "the essence of the above problem is that cns have different potentials in producing top-@xmath0 results , and then the same tuple set can have different numbers of processed tuples in different cns if they are evaluated separately . in order to avoid finding the un - needed results ,",
    "the optimal method is merely to share the tuple sets that have the same number of processed tuples among cns when they are evaluated separately .",
    "however , we can not get these numbers without evaluating the cns . as an alternative , we attempt to estimate this number for the tuple sets of each cn @xmath53 according to following heuristic rules :    * if @xmath285 , which indicates the maximum @xmath123 of jtts that @xmath53 can produce , is high , tuple sets of @xmath53 have more processed tuples . * if two cns have the same @xmath286 values , tuple sets of the cn with larger size have more processed tuples .",
    "therefore , we can cluster the cns using their @xmath287 values , where @xmath288 is used to normalize the effect of cn sizes . then , when constructing the lattice , only the subtrees of cns in the same cluster can be collapsed .",
    "for example , @xmath289 values of the seven cns of example  [ eg : cngenerate ] are : 5.15 , 2.93 , 5.39 , 6.84 , 5.32 , 5.70 and 3.03 ; hence they can be clustered into two clusters : @xmath290 and @xmath291 .",
    "[ fig : latticeall3 ] shows the lattice after finding the top-3 results if the cns are clustered , where the three un - needed jtts in fig .",
    "[ fig : latticeall2 ] can be avoided . as shown in the experimental section , clustering the cns",
    "can highly improve the efficiency in computing the initial top-@xmath0 results and handling the database updates .",
    "we cluster the cns using the @xmath292-mean clustering algorithm @xcite , which needs an input parameter to indicate the number of expected clusters .",
    "we use @xmath293 to indicate the ratio of this input parameter to the number of cns .",
    "the value of @xmath293 represents the trade - off between sharing the computation cost among cns and considering their different potentials in producing top-@xmath0 results . when @xmath294 , the cns is not clustered , then the cns share the computation cost at the maximum extent .",
    "when @xmath295 , all the cns are evaluated separately . in our experiments , we find that @xmath296 is optimal both for computing the initial top-@xmath0 results and handling the database updates .",
    "we conducted extensive experiments to test the efficiency of our methods .",
    "we use the dblp dataset .",
    "note that dblp is not continuously growing and is updated on a monthly basis .",
    "the reason we use dblp to simulate a continuously growing relational dataset is because there is no real growing relational datasets in public , and many studies @xcite on top-@xmath0 keyword queries over relational databases use dblp .",
    "the downloaded xml file is decomposed into relations according to the schema shown in fig .",
    "[ figdblp ] .",
    "the two arrows from _ papercite _ to _ papers _ denote the foreign - key - references from _ paperid _ to _ paperid _ and _ citedpaperid _ to _ paperid _ , respectively .",
    "the dbms used is mysql ( v5.1.44 ) with the default `` dedicated mysql server machine '' configuration .",
    "all the relations use the myisam storage engine .",
    "indexes are built for all primary key and foreign key attributes , and full - text indexes are built for all text attributes .",
    "all the algorithms are implemented in c++ .",
    "we conducted all the experiments on a 2.53 ghz cpu and 4 gb memory pc running windows 7 .",
    "[ figdblp ]      we use the following five parameters in the experiments :    @xmath0 : the top-@xmath0 value ;    @xmath92 : the number of keywords in a query ;    @xmath297 : the ratio of the number of matched tuples to the number of total tuples , i.e. , @xmath298 ;    @xmath94 : the maximum size of the generated cns ; and    @xmath293 : the ratio of the number of clusters of cns to the number of cns .",
    "the parameters with their default values ( bold ) are shown in table .",
    "[ tbparameters ] .",
    "the keywords selected are listed in table .",
    "[ tbkeywords ] with their @xmath297 values , where the keywords in bold fonts are keywords popular in author names .",
    "ten queries are constructed for every @xmath297 value , each of which contains three selected keywords . for each @xmath92 value ,",
    "ten queries are constructed by selecting @xmath92 keywords from the row of @xmath299 in table .",
    "[ tbkeywords ] . to avoid generating a small number of cns for each query",
    ", one author name keyword of each @xmath297 value always be selected for each query .",
    "when @xmath0 grows , the cost of computing the initial top-@xmath0 results increases since we need to compute more results , and the cost of maintaining the top-@xmath0 results also increases since there are more tuples in the output buffers of the lattice nodes .",
    "the parameter @xmath94 has a great impact on keyword query processing because the number of generated cns increases exponentially while @xmath94 increases . and",
    "the number of matched tuples increases as @xmath297 and @xmath92 increase .",
    "hence , the first four parameters @xmath0 , @xmath92 , @xmath297 and @xmath94 have effects on the scalability of our method .      in this experiment",
    ", we want to study the effects of the five parameters on computing the initial top-@xmath0 results .",
    "we retrieve the data in the xml file sequentially until number of tuples in the relations reach the numbers shown in table .",
    "[ tuplenumbers ] .",
    "then we run the algorithm @xmath230 on different values of each parameter while keeping the other four parameters in their default values .",
    "we use two measures to evaluate the effects of the parameters .",
    "the first is @xmath300 , the number of found results in the queue @xmath179 .",
    "the second measure is @xmath301 , the time cost of running the algorithm .",
    "ten top-@xmath0 queries are selected for each combinations of parameters , and the average values of the metrics of them are reported in the following . in this experiment ,",
    "@xmath138 ( @xmath140 ) , @xmath139 ( @xmath140 ) and @xmath126 ( @xmath302 ) all have very small values because they will be enlarged adaptively when maintaining the top-@xmath0 results .",
    "the main results of this experiment are given in fig .",
    "[ figeffects ] .",
    "note that the units for the @xmath303-axis are different for the three measures .",
    "[ figeffects](a ) , ( b ) and ( c ) show that the two measures all increases as @xmath0 , @xmath304 and @xmath57 grow",
    ". however , they do not show rapid increase in fig .",
    "[ figeffects](a ) , ( b ) and ( c ) , which imply the good scalability of our method . on the contrary , we can find rapid increase while @xmath57 grows from the time cost of the method of @xcite in finding the top-@xmath0 results , which is shown in fig .",
    "[ figeffects](c ) and are denoted by @xmath305 $ ] .",
    "[ figeffects](c ) presents that , compared to the existing method , algorithm @xmath230 is very efficient in finding the top-@xmath0 results .",
    "the reason is that evaluating the cns using the lattice can achieve full reduction because all the tuples in the output buffer of the root nodes can form jtts and can save the computation cost by sharing the common sub - expressions @xcite .",
    "[ figeffects](d ) shows that the effect of @xmath92 seems more complicated : all the two measures may decrease when @xmath92 increases . as shown in fig .",
    "[ figeffects](d ) , @xmath300 and @xmath35 even both achieve the minimum values when @xmath306 .",
    "this is because the probability that the keywords to co - appear in a tuple and the matched tuples can join is high when the number of keywords is large .",
    "therefore , there are more jtts that have high relevance scores , which results in larger @xmath13 and small values of the two measures",
    ".    [ tuplenumbers ]     results , height=151 ]    \\(a ) varying @xmath0     results , height=151 ]    \\(b ) varying @xmath307     +     results , title=\"fig:\",height=151 ] ( c ) varying @xmath94     results , title=\"fig:\",height=151 ] ( d ) varying @xmath92     +     results , title=\"fig:\",height=151 ] ( e ) varying @xmath293     +     results , title=\"fig:\",height=151 ] ( f ) effect of storing joined tuples     +    fig .",
    "[ figeffects](e ) presents the changing of the two measures when @xmath293 varies . since the results of the @xmath292-means clustering may be affected by the starting condition @xcite , for each @xmath308 value , we run algorithm  [ alg : evalstatic ] for 5 times on different starting condition for each keyword query and report the average experimental results .",
    "note that the algorithm @xmath309 in _ kdynamic _ corresponding to @xmath294 since there is no cn clustering in _ kdynamic_. from fig .",
    "[ figeffects](e ) , we can find that clustering the cns can highly improve the efficiency of computing the top-@xmath0 results and the time cost decreases as @xmath293 increases .",
    "however , when @xmath295 , which indicates that all the cns are evaluated separately , the time cost grows to a higher value than that when @xmath293 is 0.6 or 0.8 .",
    "therefore , it is important to select a proper @xmath293 value .",
    "the minimum @xmath35 in this experiment is achieved on @xmath296 ; hence the default value of @xmath293 is 0.6 in our experiments .",
    "as can be seen in the next section , @xmath296 also results in the minimum time cost of handling database modifications .    fig .",
    "[ figeffects](f ) compares the time cost of our method in finding the top-@xmath0 results with that of _ kdynamic _ , while varying @xmath94 .",
    "the time cost of _ kdynamic _ is denoted by `` ! cache '' because it does not cache the joined tuples for each tuple .",
    "we can find that caching the joined tuples for each tuple highly improves the efficiency of computing the top-@xmath0 results .",
    "more important , the improvement increases as @xmath94 grows .",
    "this is because when @xmath94 grows , the times of calling the procedure @xmath171 on each tuple increases fast since the number of lattice nodes increases exponentially ; hence the saved cost due to storing the joined tuples of each tuple grows as @xmath94 grows .    from the curves of @xmath310 in fig .",
    "[ figeffects ] , we can find that @xmath310 values are large in all the settings : about several thousand .",
    "recall that @xmath179 contains three kinds of results .",
    "the number of the first kind of results is @xmath231 , which is small compared to the @xmath310 values . since @xmath138 ( @xmath140 ) , @xmath139 and @xmath126 all have very small values , the number of potential top-@xmath124 results in @xmath179 is very small ( @xmath311 ) .",
    "therefore , the third kind of results , which are with @xmath312 , is in the majority and has a lager number .      in this experiment",
    ", we want to study the efficiency of algorithm  [ alg : maintenance ] in maintaining top-@xmath0 results .",
    "we use the same keyword queries as exp-1 . after calculating the initial top-@xmath0 results for them , we sequentially insert additional tuples into the database by retrieving data from the dblp xml file . at the same time , we delete randomly selected tuples from the database .",
    "algorithm  [ alg : maintenance ] is used to maintain the top-@xmath0 results for the queries while the database being updated .",
    "the database update records are read from the database log file ; hence the database updating rate has no directly impact on the efficiency of top-@xmath0 results maintenance because the database is updated by another process .",
    "we first add 713,084 new tuples into the database and delete 250,000 tuples from the database .",
    "the new data is roughly 90 percent of the data used in exp-1 .",
    "the composition of the additional tuples is shown in table .",
    "[ newtuples ] .",
    "[ figefficiency](a ) and ( b ) show the change of the average execution times of algorithm  [ alg : maintenance ] in handling the above database updates when varying the five parameters , which presents the efficiency of algorithm  [ alg : maintenance ] .",
    "note that the units for the @xmath313-axis are different for the five measures , whose minimum and maximum values are labeled in fig .",
    "[ figefficiency](a ) and ( b ) , and their other values can be found in table .",
    "[ tbparameters ] .",
    "we can find that the time cost of handling database updates for the default queries is smaller than 1.5ms .",
    "comparing fig .",
    "[ figefficiency](a ) and ( b ) with the curves of measure @xmath35 in fig .",
    "[ figeffects ] ( especially the curves in fig .",
    "[ figeffects](d ) and fig .",
    "[ figeffects](e ) ) , we can find that the time cost to handle database updates and the time cost to compute the initial top-@xmath0 results have the same changing trends .",
    "this is because there are more outputted tuples in the lattice when more time is needed to compute the initial top-@xmath0 results ; hence more time is required to do the selections in procedures @xmath171 and @xmath245 and the recursive depthes of them are more larger . fig .",
    "[ figefficiency](c ) compares the time cost of our method in handling database updates with that of _ kdynamic _ , while varying @xmath94 .",
    "the time cost of _ kdynamic _ is also denoted as `` ! cache '' .",
    "we can find that caching the joined tuples for each tuple can also improve the efficiency of handling database updates , and the larger the @xmath94 , the higher the improvement of the efficiency is .",
    "[ newtuples ]     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( a ) time for handling database updates while varying @xmath308 and @xmath94     +     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( b ) time for handling database updates while varying @xmath92 , @xmath0 and @xmath307     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( c ) effect of storing joined tuples in handling database updates   +     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( d ) changes of the times of enlarging @xmath138     +     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( e ) changes of the times of calling procedure @xmath232   +     result maintenance , title=\"fig:\",scaledwidth=97.0%,height=151 ] + ( f ) changes of the times of enlarging @xmath126     +    secondly , we only insert the 713,084 additional tuples into the database while maintaining top-@xmath314 results for the default ten keyword queries .",
    "we adopt two different growing rates of @xmath138 : @xmath315 and @xmath316 , which mean that when a @xmath141 exceed its upper bound , the corresponding @xmath138 value is increased by @xmath317 and @xmath318 , respectively . after inserting each 100,000 additional tuples ,",
    "we record the average frequency of enlarging @xmath138 and calling the procedure @xmath232 for the ten queries , whose changes are shown in fig .",
    "[ figefficiency](d ) and ( e ) , respectively , whose @xmath313-axis ( with unit of @xmath319 ) indicate the number of additional tuples . note that we do not report the frequency of enlarging @xmath78 because it is very small in the experiment ( @xmath320 )",
    ".    fig .",
    "[ figefficiency](d ) shows rapid decrease after inserting the first 100,000 additional tuples .",
    "although the frequency of enlarging @xmath138 is larger when the growing rate of @xmath138 is lower , after inserting 300,000 additional tuples , the times of enlarging @xmath138 , i.e. , the times of exceeding the upper bound of @xmath141 , falls below 5 for both the two growing rates of @xmath138 . after inserting 300,000 additional tuples , the maximum @xmath138 value of all the relations is 15 ; hence it is reasonable to set 15 as the maximum value for @xmath138 .",
    "there is only one curve in fig .",
    "[ figefficiency](e ) because the growing rate of @xmath138 has no great impact on the times of calling the procedure @xmath232 , which is mainly affected by the frequency of finding new results that are with @xmath128 .",
    "note that @xmath127 is increased after each time of calling the procedure @xmath232 .",
    "therefore , the times of calling the procedure @xmath232 is decreasing since it is more and more harder to find new results that are with @xmath128 . in order to study the impact of reversing the pipelined evaluation on the efficiency of handling database updates , we also redo the experiment without calling the procedure @xmath232 .",
    "then , the average time cost of handling database updates is increased by @xmath321 , which confirms the necessity of reversing the pipelined evaluation .",
    "then , we delete 500,000 randomly selected tuples from the database after inserting the 713,084 additional tuples .",
    "two different @xmath126 growing rates are adopted : @xmath322 and @xmath323 , which mean that when the number of results that are with @xmath128 falls below @xmath0 , the corresponding @xmath126 value is increased by @xmath324 and @xmath325 , respectively .",
    "we record the average times of enlarging @xmath126 of the ten queries after deleting each 100,000 tuples , whose changes are shown in fig .  [ figefficiency](f ) .",
    "[ figefficiency](f ) shows that the frequency of shortage of top-@xmath0 results falls below a very small number after deleting 200,000 tuples , i.e. , after @xmath126 being enlarged to about 20 . as indicated by the curve of @xmath0 in fig .",
    "[ figefficiency](b ) , a large @xmath126 value can highly decrease the efficiency of handling database updates .",
    "therefore , it is reasonable to set the maximum value of @xmath138 as @xmath326 .",
    "in this paper , we have studied the problem of finding the top-@xmath0 results in relational databases for a continual keyword query .",
    "we proposed an approach that finds the answers whose upper bounds of future relevance scores are larger than a threshold .",
    "we adopt an existing scheme of finding all the results in a relational database stream , but incorporate the ranking mechanisms in the query processing methods and make two improvements that can facilitate efficient top-@xmath0 keyword search in relational databases .",
    "the proposed method can efficiently maintain top-@xmath0 results of a keyword query without re - evaluation .",
    "therefore , it can be used to solve the problem of answering continual keyword search in databases that are updated frequently .",
    "this research was partly supported by the national natural science foundation of china ( nsfc ) under grant no .  60873040 , 863 program under grant no .",
    "jihong guan was also supported by the `` shu guang '' program of shanghai municipal education commission and shanghai education development foundation ."
  ],
  "abstract_text": [
    "<S> _ keyword search in relational databases _ has been widely studied in recent years because it does not require users neither to master a certain structured query language nor to know the complex underlying database schemas . </S>",
    "<S> most of existing methods focus on answering _ snapshot keyword queries _ in static databases . in practice , however , databases are updated frequently , and users may have long - term interests on specific topics . to deal with such a situation , </S>",
    "<S> it is necessary to build effective and efficient facility in a database system to support _ continual keyword queries_.    in this paper , we propose an efficient method for answering continual top-@xmath0 keyword queries over relational databases . </S>",
    "<S> the proposed method is built on an existing scheme of keyword search on relational data streams , but incorporates the ranking mechanisms into the query processing methods and makes two improvements to support efficient top-@xmath0 keyword search in relational databases . </S>",
    "<S> compared to the existing methods , our method is more efficient both in computing the top-@xmath0 results in a static database and in maintaining the top-@xmath0 results when the database continually being updated . </S>",
    "<S> experimental results validate the effectiveness and efficiency of the proposed method .    relational databases , keyword search , continual queries , results maintenance . </S>"
  ]
}