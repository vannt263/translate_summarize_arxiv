{
  "article_text": [
    "in contemporary communication networks , the nodes perform only routing , _ i.e. _ , they copy the data on incoming links to the outgoing links . in order to transmit messages generated simultaneously from multiple sources to multiple sinks",
    "the network may need to be used multiple times .",
    "this limits the throughput of the network and increases the time delay too .",
    "it is known that if intermediate nodes in a network are permitted to perform coding operations , _",
    "i.e. _ , encode data received on the incoming links and then transmit it on the outgoing links ( each outgoing link can get differently encoded data ) , the throughput of the network increases .",
    "this is called network coding @xcite .",
    "thus , network coding subsumes routing .",
    "for example , consider the butterfly network @xcite of fig .",
    "[ b_fly ] wherein each link can carry one bit per link use , source node @xmath0 generates bits @xmath1 and @xmath2 , and both sink nodes @xmath3 and @xmath4 demand both source bits . with routing only ,",
    "two uses of link @xmath5 are required while with network coding only one .",
    "above is an example of single - source multi - sink linear multicast network coding , wherein there is a single source ( @xmath0 ) , generating a finite number of messages , ( @xmath6 ) , and multiple sinks , each demanding all the source messages and the encoding operations at all nodes are linear . in general , there may be several source nodes , each generating different number of source messages , and several sink nodes , each demanding only a subset , and not all , of source messages .",
    "decoding at sink nodes with such general demands is studied in this paper .",
    "we represent a network by a finite directed acyclic graph @xmath7 , where @xmath8 is the set of vertices or nodes and @xmath9 is the set of directed links or edges between nodes .",
    "all links are assumed to be error - free .",
    "let @xmath10=\\{1,2,\\ldots , n\\}$ ] .",
    "the network has @xmath11 sources , @xmath12 $ ] , and @xmath13 sinks , @xmath14 $ ] .",
    "the source @xmath15 generates @xmath16 messages , @xmath17 $ ] .",
    "let @xmath18 be the total number of source messages .",
    "the @xmath19-tuple of source messages is denoted by @xmath20}=(x_1,x_2,\\ldots , x_\\omega)$ ] , where @xmath21 $ ] and @xmath22 is a finite field . by @xmath23",
    "we denote the column vector of the source messages .",
    "the demand of the @xmath24 sink node is denoted by @xmath25 $ ] .",
    "given a set @xmath26 $ ] , let @xmath27 , _",
    "i.e. _ , @xmath20}$ ] _ restricted _ to @xmath28 .",
    "let @xmath29 , _",
    "i.e. _ , the set of all @xmath28-tuples over @xmath22 . for a multi - variable binary - valued function @xmath30 , the subset of @xmath31 whose elements are mapped to @xmath32 by @xmath30",
    "is called its support and is denoted by @xmath33}))$ ] and @xmath34}))$ ] denotes the @xmath35-tuples in the support restricted to @xmath28 .",
    "a source message is denoted by edges without any originating node and terminating at a source node .",
    "data on a link @xmath36 is denoted by @xmath37 .",
    "a network code ( nc ) is a set of coding operations to be performed at each node such that the requisite source messages can be faithfully reproduced at the sink nodes .",
    "it can be specified using either local or global description @xcite .",
    "the former specifies the data on a particular outgoing edge as a function of data on the incoming edges while the latter specifies the data on a particular outgoing edge as a function of source messages . throughout the paper we use global description for our purposes .",
    "global description of an nc @xcite : an @xmath19-dimensional nc on an acyclic network over a field @xmath22 consist of @xmath38 global encoding maps @xmath39 ( i.e. , @xmath40 ) .",
    "let @xmath41 , be the incoming edges at the source , then @xmath42 .",
    "when the intermediate nodes perform only linear encoding operations then such an nc is said to be a linear network code ( lnc )",
    ".    global description of an lnc @xcite : an @xmath19-dimensional lnc on an acyclic network over a field @xmath22 consist of @xmath38 @xmath43 global encoding vectors @xmath44 such that @xmath45 .",
    "the global encoding vectors for the incoming edges at the source are standard basis vectors for the vector space @xmath46 .",
    "the global encoding vectors of the lnc for butterfly network is given in fig .",
    "[ b_fly](b ) .",
    "hereafter we assume that the network is feasible , _",
    "i.e. _ , demands of all sink nodes can be met using network coding and the global description of a network code ( linear or non - linear ) is given .",
    "if a sink node demands @xmath47 ( @xmath48 @xmath19 ) source messages , it will have at least @xmath47 incoming edges .",
    "the decoding problem is to reproduce the desired source messages from the coded data received at the incoming edges .",
    "thus , decoding amounts to solving for a specified set of @xmath47 unknowns using a set of at least @xmath47 simultaneous equations in @xmath19 unknowns .",
    "hence , the global description of the nc is more useful for decoding .    while decoding of non - linear nc has not been studied , the common technique used for decoding a lnc is to perform gaussian elimination @xcite , which requires @xmath49 operations , followed by backward substitution , which requires @xmath50 operations ( @xmath51 is the number of variables ) @xcite .",
    "this is not recommendable when the number of equations and/or variables is very large . in such cases ,",
    "iterative methods are used .",
    "convergence and initial guess are some issues that arise while using iterative methods @xcite .",
    "we propose to use the sum - product ( sp ) algorithm to perform iterative decoding at the sinks .",
    "a similar scheme for decoding multicast network codes using factor graph @xcite was studied in @xcite .",
    "the authors considered the case of lnc .",
    "the problems associated with the proposed decoding scheme in @xcite are :    * in order to construct the factor graph , full knowledge of network topology is assumed at the sinks which is impractical if the network topology changes . for a particular sink node ( say @xmath52 ) , the factor graph constructed will have @xmath53 variable nodes and @xmath54 factor nodes , where @xmath55 is the set of incoming edges at node @xmath52 . *",
    "complete knowledge of local encoding matrix @xcite of each node is assumed at the sinks which again is impractical since local encoding matrix for different nodes will have different dimensions and hence variable number of overhead bits will be required to communicate to downstream nodes which will incur huge overhead .",
    "we also point out that the motivating examples , _ viz .",
    "_ , examples 1 and 4 , given in @xcite for which the proposed decoding method claims to exploit the network topology admits a simple routing solution and no network coding is required to achieve maximum throughput . solving linear equations in boolean variables",
    "is also studied in @xcite .",
    "the contributions and organization of the paper are as follows :    * in section iii - a we pose the problem of decoding of linear and non - linear nc as _ marginalize a product function problem _ ( mpf ) and construct factor graph using the global description of network codes . for a particular sink node , the constructed graph will have fewer vertices than in @xcite and hence the number of messages and operations performed will also be fewer . unlike in @xcite ,",
    "our scheme requires only the knowledge of global encoding maps / vectors of incoming edges at a sink node and not the entire network structure and coding operation performed at each node . * in sections iii - b ,",
    "we utilize _ traceback _ instead of running multiple - vertex version of algorithm , thus , further reducing the number of operations . some examples illustrating the proposed techniques are given in section iii - d .",
    "* we discuss utility and computational complexity of the proposed technique in section iii - c . for sink nodes which demand all the source messages , the notion of _ fast decodable network codes _ is defined and a sufficient condition for the same is identified .",
    "we present a brief overview of the sp algorithm in section ii and conclude the paper with a discussion on scope for further work in section iv .",
    "in this section , we review the computational problem called the mpf problem and specify how sp algorithm can be used to efficiently solve such problems .",
    "an equivalent method to efficiently solve mpf problems is given in @xcite and is called the _ generalized distributive law _",
    "( gdl ) or the _ junction tree algorithm_. the simplest example of sp algorithm offering computational advantage is the distributive law on real numbers , @xmath56 ; the left hand side of the equation requires fewer operation than the right hand side .",
    "generalization of addition and multiplication is what is exploited by the sp ( or the junction tree ) algorithm in different mpf problems .",
    "the mathematical structure in which these operations are defined is known as commutative semirings .",
    "a commutative semiring @xcite is a set @xmath57 , together with two binary operations `` @xmath58 '' ( _ addition _ ) and `` @xmath59 '' ( _ multiplication _ ) , which satisfy the following axioms :    1 .",
    "the operation `` @xmath58 '' satisfies closure , associative , and commutative properties ; and there exists an element `` @xmath60 '' ( _ additive identity _ ) such that @xmath61 .",
    "the operation `` @xmath59 '' satisfies closure , associative , and commutative properties ; and there exists an element `` @xmath32 '' ( _ multiplicative identity _ ) such that @xmath62 .",
    "3 .   the operation `` @xmath59 '' _ distributes _ over `` @xmath58 '' , _",
    "i.e. _ , @xmath63    for different problems , we use different semirings with different notion of `` @xmath58 and @xmath59 '' .",
    "some examples are listed below .",
    "1 .   application of the sp algorithm to fourier transform yields the fft algorithm ; the semiring is the set of complex numbers with the usual addition and multiplication @xcite .",
    "ml decoding of binary linear codes is also an mpf problem and application of sp algorithm yields the gallager - tanner - wiberg decoding algorithm over a tanner graph ; the semiring is the set of positive real numbers with `` @xmath64 '' as sum and `` @xmath58 '' as product , called the min - sum semiring @xcite . the bcjr algorithm for decoding turbo codes and ldpc deocoding algorithm are some other applications of sp algorithm .",
    "application to the ml sequence estimation , for instance in decoding convolutional codes , yields the viterbi algorithm @xcite ; the semiring is again the min - sum semiring .",
    "recently , the gdl has been shown to reduce the ml decoding complexity of space - time block codes in @xcite ; the semiring applicable is the min - sum semiring of complex number .",
    "the authors introduced _ traceback _ for gdl and used it to further lower the number of operations .",
    "thus , both these algorithms subsume as special cases many well known algorithms .",
    "a boolean semiring is the set @xmath65 together with the usual boolean operations @xmath66 ( or ) and @xmath67 ( and ) .",
    "we denote it by @xmath68 .",
    "the elements @xmath60 and @xmath32 are the _ additive _ and _ multiplicative identities _ respectively .",
    "the mpf problem defined for this semiring is described below .",
    "let @xmath69 $ ] be @xmath51 variables taking values in finite alphabets @xmath70 $ ]",
    ". for @xmath71 $ ] , let @xmath72 @xmath73 .",
    "let @xmath74 $ ] , such that for each @xmath75 $ ] , there is a function @xmath76 .",
    "the functions @xmath77s are called the _ local kernels _ , the set of variables in @xmath78 is called the _ local domain _ associates with @xmath77 and @xmath79 is the associated _",
    "configuration space_. the _ global kernel _ , @xmath80}\\rightarrow r$ ] and its @xmath81 _ marginalization _ , @xmath82 , are defined below .",
    "@xmath83    @xmath84\\backslash i}\\ } } \\beta ( x_1,x_2,\\ldots , x_n )   \\end{aligned}\\ ] ]      brute force computation of marginalizations require @xmath85})$ ] computations ; the sp algorithm is an efficient way of computing these .",
    "it involves iteratively passing _ messages _ along the edges of the _ factor graph _ , @xmath86 , associated with the given mpf problem .",
    "the factor graph is a bipartite graph .",
    "vertices in @xmath87 are called variable nodes ; one for each variable @xmath88 , @xmath89 $ ] ( @xmath90 ) . the vertices in @xmath91",
    "are called the factor nodes ; one for each local kernel @xmath77 , @xmath92 $ ] ( @xmath93 ) .",
    "a variable node @xmath88 is connected to a factor node @xmath77 iff @xmath88 is an argument of @xmath77 . for convenience",
    "we assume that for a variable node @xmath94 the local domain and local kernel are @xmath94 and @xmath32 respectively .",
    "let @xmath95 denote the set of factor nodes adjacent to the variable node @xmath88 , _",
    "i.e. _ , set of local kernels with @xmath94 as an argument and @xmath96 denote the set of variable nodes adjacent to the factor node @xmath77 , _",
    "i.e. _ , the local domain of @xmath77 .",
    "the directed message passed from a variable node @xmath88 to an adjacent factor node @xmath77 and vice versa are as follows : @xmath97 @xmath98    depending on the requirement , we may need to evaluate marginal(s ) at only one , a few or all variable nodes .",
    "the algorithm starts at the leaf nodes ( nodes with degree one ) with the leaves passing messages to the adjacent nodes .",
    "once a vertex has received messages from all but one of its neighbor , it computes its own message and passes it to the neighbor from which it has not yet received the message . this message passing terminates when",
    "all the variable nodes at which marginals are required to be evaluated have received from all its neighbors .",
    "a node after receiving messages from all of its neighbors , computes its _ state _ as the product of messages received from all the adjacent nodes . for a variable node , @xmath88",
    ", it is denoted by @xmath99 and is given as follows : @xmath100 similarly , the state for a factor node is computed as follows : @xmath101    as stated in @xcite , after sufficient number of messages have been passed , the state of a variable node @xmath88 will be equal to @xmath102 .    to obtain the correct value of the required marginal(s ) , it is essential that the factor graph be free of cycles . if there are cycles these may not be the correct values .",
    "the cycles can be eliminated by _ stretching _ variable nodes or _ clustering _ variable or factor nodes ( refer to ( * ? ? ?",
    "vi ) for a detailed description ) .",
    "these methods are exemplified in section iii - d .",
    "both these graph transformations lead to enlargement of the local domain(s ) , and hence the configuration space of the node(s ) . in the new graph ,",
    "the directed message passed from a vertex @xmath103 to @xmath104 is @xmath105 where @xmath106 is the set of neighboring vertices of @xmath103 and its state @xmath107 is @xmath108 these are the general forms of messages and states ; - can be obtained from these .",
    "let @xmath109 be the node with the largest configuration space @xmath110 ( choose any one if there are multiple such nodes ) .",
    "then the number of operations required for computing messages and states in the sp algorithm will be @xmath111 .",
    "thus , at the cost of possibly increased computational cost , the sp algorithm on the transformed graph yields the exact value of the marginals . in the sequel",
    ", we assume that the factor graph is acyclic .",
    "in this section , we show that decoding a nc is an mpf problem over a boolean semiring .",
    "we provide a method to construct factor graph for decoding at a sink node using the sp algorithm .",
    "though the factor graph approach and the junction tree approach are equivalent formulations to solve mpf problems , we prefer the former because of the amount of preprocessing required to obtain junction tree as argued below :    1 .   the construction of a junction tree for an mpf problem requires : _ ( a ) _ construction of a _ moral graph _ , _ ( b ) _ its _ minimum complexity triangulation _ if it is not already triangulated , _ ( c ) _ construction of the _ clique graph _ of the triangulated moral graph , and _ ( d ) _ finding a spanning tree which leads to minimum computational cost .",
    "to the nodes of this clique tree the local kernels and variables of the mpf problem are attached @xcite to obtain the junction tree ( a kernel or a variable is attached to a node of clique tree iff its local domain is a subset of the local domain of the said clique tree node ) .",
    "thus , the gdl always gives the exact solution of the mpf problems .",
    "a factor graphs is easily described by the local kernels associated with the mpf problem ; it is a bipartite graph involving set of variable and a set of local kernels of the mpf kernels as the two vertex sets .",
    "if it is acyclic , then the sp algorithm gives the exact solution , if not , it gives an approximate solution .",
    "the sp algorithm is known to perform well even if the factor graph has cycles , for example , in decoding of ldpc and turbo codes .",
    "factor graphs with cycles can be transformed into acyclic ones to obtain exact solutions ( * ? ? ?",
    "vi ) .      given an acyclic network @xmath7 , the demands at each sink ,",
    "@xmath112 $ ] and a set of global encoding maps , @xmath113 , that satisfy all the sink demands , the objectives at a sink , say @xmath24 , is to find the instance of @xmath114 that was generated by the source(s ) using the data it receives on its incoming edges , _",
    "i.e. _ , @xmath115}\\in f^{\\omega } } \\underbrace{\\bigwedge _ { e \\in in(t_k ) } \\delta \\left ( \\tilde{f}_e ( x_{[\\omega]})\\ , , \\ , y_e \\right)}_{\\beta ^{(k)}(x_{[\\omega ] } ) } \\end{aligned}\\ ] ] here @xmath116 is the global kernel of the mpf problem at the @xmath24 sink and @xmath117 is a function that indicates whether its two input arguments are equal or not,_i.e .",
    "_ , @xmath118 for lnc , becomes @xmath119    thus , decoding a nc has the form of a special class of mpf problems over boolean semiring wherein we are interested only in some coordinates ( specified by @xmath120 ) of the @xmath19-tuples in the support set and not the value of the global kernel .",
    "since the solution @xmath121 is unique , individual coordinates @xmath122 can be separately computed , _",
    "i.e. _ , @xmath123\\backslash j}\\}}\\beta ^{(k)}(x_{[\\omega ] ) } , \\end{aligned}\\ ] ] where @xmath124 is the @xmath125 marginalization of the global kernel @xmath116 .",
    "the factor graph for decoding at sink @xmath126 $ ] is constructed as follows :    1 .",
    "install @xmath19 _ variable nodes _ , one for each source message .",
    "these vertices are labeled by their corresponding source messages , @xmath88 .",
    "2 .   install @xmath127 _ factor nodes _ and label them @xmath128 .",
    "the associated local domain of each such vertex is the set , @xmath129}$ ] , of source messages that participate in that encoding map and the local kernel is @xmath130})\\ , , \\ , y_e)$ ] .",
    "these vertices are labeled by their corresponding local kernels , @xmath131 .",
    "a variable node is connected to a factor node iff the source message corresponding to that variable node participates in the encoding map corresponding to the said factor node .",
    "we use thicker lines for factor nodes to differentiate them from variable nodes .",
    "the factor graph so constructed will be a bipartite graph .",
    "general form of a factor graph and the same for the two sink nodes of the butterfly network are given in fig .",
    "[ junc_grph ] ( cf .",
    "3 ) ) .     and ( c ) @xmath4 of the butterfly network .",
    "local kernels are given adjacent to the function vertices . ]",
    "messages and states are computed using and respectively . as stated before ,",
    "once a node ( say @xmath103 ) , has received message from all the adjacent nodes , its state , @xmath132 , can be computed .",
    "let @xmath133 .",
    "the value of the subset @xmath134 of the requisite source messages at the @xmath24 sink node is @xmath135    as specified in section ii , the sp algorithm yields the correct value of the source messages if the factor graph is a tree .",
    "if not then the cycles in the factor graph will have to be removed .",
    "since we are interested in the value of the source messages and not the value of the marginalizations of the global kernel , we can use _ traceback _ @xcite to further lower the number of computations .",
    "assume that the single - vertex sp algorithm is run with vertex @xmath103 as the root ( all messages are directed towards @xmath103 ) and the value @xmath136 of some source messages in the demand set of the @xmath24 sink has been ascertained .",
    "now , partition the local domain of a neighboring node @xmath104 , as @xmath137 , where @xmath138 and @xmath139 . since @xmath140 is known , the value @xmath141 that causes @xmath142 to take value @xmath32 is also known .",
    "the value of the source messages @xmath143 can then be obtained using as follows : @xmath144 where @xmath145 is the partial state computed at @xmath104 while passing the message @xmath146 to the root @xmath103 .",
    "thus , @xmath147 does not need to be computed or passed , leading to saving of operations .",
    "here we have exploited the fact that we require only @xmath148 and not the value of @xmath149 which would have required passing of the message @xmath147 from @xmath103 to @xmath104 too .",
    "hence , the traceback step reduces the computational complexity .",
    "the traceback step can be used repeatedly until values of all the source messages in @xmath114 are obtained .",
    "this can be done by using on other neighbors of @xmath103 and then neighbors of neighbors of @xmath103 and so on .",
    "this can lead to considerable reduction in number of operations and is exemplified in section iii - d .",
    "we suggest using sp algorithm for decoding a network code only when the code is either non - linear or it is linear but the number of messages is very large . for linear network codes with manageable value of @xmath19 , gaussian elimination with backward substitution",
    "is advisable .",
    "if using sp algorithm for decoding network codes ( when warranted ) leads to computational complexity strictly better than brute - force decoding complexity , then the code is called _ fast decodable network code_.    we now discuss the computational complexity of sp algorithm based decoding of network codes .",
    "as in @xcite , by complexity we mean the number of semiring operations required to obtain the desired source message . for convenience ,",
    "we assume that all the source messages take value from a @xmath150-ary alphabet ; results for variable alphabet size can be obtained similarly .",
    "as stated above , in order to recover the requisite source messages at a sink we need only run single - vertex sp algorithm followed by traceback steps . for a given sink node ,",
    "if the factor graph constructed using the method given in section iii - a is cycle - free and the network code is such that the local domains of all factor nodes have cardinality at most @xmath151 , then the number of operations required for decoding using the sp algorithm is @xmath152 . if the sink demands all the source messages , then the brute - force decoding would require @xmath153 operations .",
    "thus , an acyclic factor graph with at most @xmath151 variables per equation is a sufficient condition for fast decodability of the network code at a sink which demands all the source messages .",
    "if the graph is not cycle - free then we remove the cycles using the methods specified above and let @xmath154 be the size of maximum cardinality local domain in the transformed cycle - free factor graph .",
    "the number of computations required now will be @xmath155 and the code is fast decodable iff @xmath156 .",
    "we now present some examples illustrating use of the sp algorithm to decode nc .",
    "consider the butterfly network of fig.[b_fly ] . here",
    "the factor graphs for two sink nodes are given in are given in fig .",
    "[ junc_grph](b ) and ( c ) . the messages passed and state computations for decoding at @xmath3 are as follows : @xmath158 @xmath159 it is easy to verify that @xmath160 .",
    "hence , @xmath161 .",
    "similar computations apply for @xmath4 also .",
    "this network code is not fast decodable since the number of computations required is @xmath162 .",
    "@xmath163    now we present a multicast network which admits no linear solution over @xmath164 , but a non - linear solution exists .    consider the multicast combination network given in fig.[trcbk](a ) .",
    "all messages take value from @xmath165 .",
    "each sink is connected to a distinct size @xmath166 subset of intermediate node .",
    "multicast , in @xmath165 , is feasible over such a network iff a @xmath167 binary error correcting code exists @xcite .",
    "the nadler s code is one such systematic code with the requisite parameters .",
    "note that since there exist no @xmath167 binary linear code , the above multicast network , admits no linear solution over @xmath165 .",
    "apart from the systematic part of the nadler s code , the @xmath168 redundant bits are encoded using non - linear functions @xcite;these are : @xmath169 \\\\",
    "\\nonumber \\tilde{f}_6 & = x_1+x_2+x_3+(x_1+x_5)(x_3+x_4 )   \\\\ \\nonumber \\tilde{f}_7 & = x_1+x_2+x_4+(x_1+x_3)(x_4+x_5 )   \\\\",
    "\\nonumber \\tilde{f}_8 & = x_1+x_2+x_5+(x_1+x_4)(x_3+x_5 )   \\\\ \\nonumber \\tilde{f}_9 & = x_2+x_3+x_4+x_1x_4+x_4x_5+x_5x_1 \\\\",
    "\\nonumber \\tilde{f}_{10 } & = x_2+x_3+x_5+x_1x_3+x_3x_5+x_5x_1   \\\\",
    "\\nonumber \\tilde{f}_{11 } & = x_2+x_4+x_5+x_1x_3+x_3x_5+x_5x_1 \\\\",
    "\\nonumber \\tilde{f}_{12 } & = x_1+x_2+x_3+x_4+x_5 + x_3x_4 + x_4x_5 + x_5x_3 \\end{aligned}\\ ] ] these functions are the global encoding maps of the @xmath170 source to intermediate node links .",
    "the intermediate nodes simply route the data on incoming edges to the connected sink nodes , hence , the global encoding maps of the incoming and outgoing edges of an intermediate node is same .",
    "consider decoding at the @xmath171 sink whose global encoding maps of incoming edges are @xmath172 .",
    "the factor graph constructed using the method stipulated above will have cycles ( fig .  [ trcbk](c ) ) . to eliminate the cycles , we cluster @xmath173 function vertices into a single one with the local kernel as the product of @xmath168 original ones ( fig .",
    "[ trcbk](c ) ) .",
    "the computational complexity of sp decoding is same as that of brute - force decoding ( @xmath174 ) .",
    "this is true for all the sink nodes and hence this code is not fast decodable for any of the sinks .",
    "@xmath163    in the next example we present a network with general demands at sinks and employ the sp algorithm for decoding a vector non - linear network code for it .",
    "we also demonstrate usefulness of traceback for saving computations of some messages in the factor graph .",
    "consider the network given in fig .",
    "the sinks ( nodes @xmath175 ) have general demands which are specified by variables below them . in @xcite",
    ", the authors showed that this network admits no linear solution over any field and gave a vector non - linear solution .",
    "the source message @xmath176 $ ] are 2-bit binary words ( @xmath177 ) , @xmath58 denotes addition in ring @xmath178 , @xmath179 denotes the bitwise xor and the function @xmath180 reverses the order of the 2-bit input .    the factor graphs for nodes @xmath181 , @xmath182 and @xmath183 , denoted by @xmath184 and @xmath185 respectively , are given in fig .",
    "[ fano_junc ] ; the same for other nodes have similar structure and can be constructed using method given in section iii - a .",
    "note that @xmath186 has a cycle of length @xmath187 and @xmath185 has two cycles of length @xmath188 each .",
    "the cycles are removed as follows :    * the cycle in @xmath186 is removed by clustering the variable vertices @xmath189 and @xmath190 ; the local domain and kernel of the new variable vertex are @xmath191 ( union of the local domains of the clustered vertices ) and @xmath32 ( product of the local kernels of the clustered vertices ) ( fig .  [ fano_junc ] ) . * the cycles @xmath192 and @xmath193 in @xmath185",
    "are removed by deleting the dotted edges and _ stretching _ variable vertex @xmath194 around the respective cycles ; this involves adding the stretched variable to all the local domain in the cycle and leaving the local kernels unchanged ( fig .",
    "[ fano_junc ] ) .",
    "we infer from @xmath185 that the number of computations required to reproduce all the source messages at @xmath195 is only @xmath196 instead of @xmath174 ( as brute - force decoding would have required ) and hence this code is fast decodable for @xmath195 .",
    "the decoding process at @xmath195 , using single - vertex sp algorithm with node `` f '' in @xmath185 as root followed by traceback to compute @xmath197 , is demonstrated below : @xmath198 at `` f '' , decoding of @xmath194 is performed as follows : @xmath199 we can now use traceback to compute @xmath189 and @xmath190 without having to compute @xmath200 or @xmath201 as follows : @xmath202 note that @xmath203 and @xmath204 were already computed . without traceback , @xmath189 and @xmath190",
    "are decoded at variable nodes `` d '' and `` b '' respectively as follows : @xmath205 similarly @xmath206 and @xmath207 can be obtained .",
    "the number of semiring operations required to compute all the messages passed and states computed is given in table  i.    > m0.2 in > m1 in > m0.6 in > m0.6 in & * messages / states * & * no .",
    "of @xmath208 * & * no . of @xmath209 * + c1 & @xmath210 & @xmath60 & @xmath60 + c2 & @xmath211 & @xmath60 & @xmath60 + c3 & @xmath212 & @xmath213 & @xmath214 + c4 & @xmath215 & @xmath60 & @xmath60 + c5 & @xmath216 & @xmath217 & @xmath218 + c6 & @xmath219 & @xmath150 & @xmath60 + c7 & @xmath220 & @xmath150 & @xmath60 + c8 & @xmath221 & @xmath150 & @xmath60 + c9 & @xmath222 & @xmath60 & @xmath60 + c10 & @xmath223 & @xmath217 & @xmath60 + c11 & @xmath224 & @xmath217 & @xmath218 + c12 & @xmath225 & @xmath60 & @xmath60 + c13 & @xmath226 & @xmath60 & @xmath60 + c14 & @xmath227 & @xmath217 & @xmath218 +    the number of computations required with traceback are 2 ( c1+c2+@xmath228+c5)+c6+c7+c8 which is @xmath229 products ( @xmath67 ) and @xmath230 sums ( @xmath66).without traceback , the number of operations required are 2(c1@xmath228+c5)+c6 + 2(c9+c10)+c11 + 2(c12+c13)+c14 which is @xmath231 products and @xmath232 sums .",
    "thus , running single - vertex sp algorithm followed by traceback step affords computational advantage over multiple - vertex version .",
    "in this paper , we proposed a sp algorithm based decoder for decoding nc .",
    "subsequently , a method for constructing the factor graph for a given sink node using the global encoding maps ( or vectors in case of lnc ) of the incoming edges and demands of the sink was provided .",
    "the graph so constructed had fewer nodes and led to fewer message being passed lowering the number of operations as compared to the scheme of @xcite .",
    "next we discussed how cycles in factor graph affect the solution of the mpf problem and illustrated with examples how to circumvent them .",
    "we introduced and discussed the advantages of traceback over multiple - vertex sp algorithm .",
    "next , for the sinks demanding all the source messages , we introduced the concept of fast decodable network codes and provided a sufficient condition for a network code to be fast decodable .",
    "g. strang , _ introduction to linear algebra _",
    ", @xmath233 edn . , wellesley - cambridge press , 2003 .",
    "f.  r. kschischang , b.  j. frey and h .- a .",
    "loeliger , `` the generalized distributive law , '' ieee trans .",
    "theory , vol .",
    "325 - 343 , mar ."
  ],
  "abstract_text": [
    "<S> while feasibility and obtaining a solution of a given network coding problem are well studied , the decoding procedure and complexity have not garnered much attention . </S>",
    "<S> we consider the decoding problem in a network wherein the sources generate multiple messages and the sink nodes demand some or all of the source messages . </S>",
    "<S> we consider both linear and non - linear network codes over a finite field and propose to use the sum - product ( sp ) algorithm over boolean semiring for decoding at the sink nodes in order to reduce the computational complexity . </S>",
    "<S> we use _ traceback _ to further lower the computational cost incurred by sp decoding . </S>",
    "<S> we also define and identify a sufficient condition for _ fast decodability _ of a network code at a sink that demands all the source messages . </S>"
  ]
}