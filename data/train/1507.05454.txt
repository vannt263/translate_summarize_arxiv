{
  "article_text": [
    "essentially , software validation aims at ensuring that the developed software complies with the original requirements .",
    "one of the most popular validation approaches is _ software testing _ , a process that involves producing a test suite and then executing the system with these test cases .",
    "the main drawback of this approach is that designing a test suite with a high code coverage |i.e .",
    ", covering as many execution paths as possible| is a complex and time - consuming task . as an alternative , one can use a tool for the random generation of test cases , but then we are often faced with a poor code coverage .",
    "some hybrid approaches exist where random generation is driven by the user , as in quickcheck @xcite , but then again the process may become complex and time - consuming .",
    "another popular , fully automatic approach to test case generation is based on _ symbolic execution _ @xcite .",
    "basically , symbolic execution considers unknown ( symbolic ) values for the input parameters and , then , explores all feasible execution paths in a non - deterministic way .",
    "symbolic states include now a _ path condition _ that stores the current constraints on symbolic values , i.e. , the conditions that must hold to reach a particular execution point . for each final state , a test case is produced by solving the constraints in the associated path condition .",
    "a drawback of the previous approach , though , is that the constraints in the path condition may become very complex . when these constraints are not solvable , the only sound way to proceed is to stop the execution path , often giving rise to a poor coverage .",
    "recently , a new variant called _ concolic execution _ @xcite that combines both _",
    "_ conc__rete and symb__olic _ _ execution has been proposed as a basis for both model checking and test case generation .",
    "the main advantage is that , now , when the constraints in the symbolic execution become too complex , one can still take some values from the concrete execution to simplify them .",
    "this is sound and often allows one to explore a larger execution space .",
    "some successful tools that are based on concolic execution are , e.g. , sage @xcite and java pathfinder @xcite .    in the context of the logic programming paradigm ,",
    "one can find a flurry of _ static _ , complete techniques for software analysis and verification .",
    "however , only a few dynamic techniques for program validation have been proposed .",
    "dynamic , typically incomplete , techniques have proven very useful for software validation in other paradigms .",
    "in general , these techniques are sound so that they avoid _",
    "false positives_. this contrasts with typical static verification methods which may produce some false positives due to the abstraction techniques introduced to ensure completeness .",
    "therefore , we expect concolic execution to complement existing analysis and verification techniques for logic programs .    in this paper , we introduce a new , fully automatic scheme for _ concolic testing _ in logic programming . as in other paradigms , concolic testing may help the programmer to systematically find program bugs and generate test cases with a good code coverage . as it is common",
    ", our approach is always sound but usually incomplete . in the context of logic programming , we consider that `` full path coverage '' involves calling each predicate in all possible ways .",
    "consider , e.g. , the logic program @xmath0 .",
    "here , one could assume that the execution of the goals in @xmath1 is enough for achieving a full path coverage .",
    "however , in this paper we consider that full path coverage requires , e.g. , the set @xmath2 so that we have a goal that matches both clauses , one that only matches the first clause , one that only matches the second clause , and one that matches no clause .",
    "we call this notion _ choice _ coverage , and it is specific of logic programming . to the best of our knowledge ,",
    "such a notion of coverage has not been considered before .",
    "typically , only a form of _ statement _ coverage has been considered , where only the clauses used in the considered executions are taken into account . for guaranteeing choice coverage ,",
    "a new type of unification problems must be solved : we have to produce goals in which the selected atom @xmath3 matches the heads of some clauses , say @xmath4 , but does not match the heads of some other clauses , say @xmath5 .",
    "we provide a constructive algorithm for solving such unifiability problems .",
    "a prototype implementation of the concolic testing scheme for pure prolog , called , is publicly available from ` http://kaz.dsic.upv.es/contest.html ` .",
    "the results from an experimental evaluation point out the usefulness of the approach . besides logic programming and prolog",
    ", our technique might also be useful for other programming languages since there exist several transformational approaches that `` compile in '' programs to prolog , like , e.g. , @xcite .    omitted proofs as well as some extensions can be found in the online appendix .",
    "the semantics of a logic program is usually given in terms of the sld relation on goals @xcite . in this section ,",
    "we present instead a _ local _ semantics which is similar to that of .",
    "basically , this semantics deals with states that contain all the necessary information to perform the next step ( in contrast to the usual semantics , where the sld tree built so far is also needed , e.g. , for dealing with the cut ) .",
    "in contrast to @xcite , for simplicity , in this paper we only consider definite logic programs . however , the main difference w.r.t .",
    "@xcite comes from the fact that our concrete semantics only considers the computation of the first solution for the initial goal .",
    "this is the way most prolog applications are used and , thus , our semantics should consider this behaviour in order to measure the coverage in a realistic way .    before presenting the transition rules of the concrete semantics ,",
    "let us introduce some auxiliary notions and notations .",
    "we refer the reader to @xcite for the standard definitions and notations for logic programs .",
    "the semantics is defined by means of a transition system on _ states _ of the form @xmath6 , where @xmath7 is a sequence of goals labeled with substitutions ( the answer computed so far , when restricted to the variables of the initial goal ) .",
    "we denote sequences with @xmath8 , where @xmath9 denotes the empty sequence . in some cases",
    ", we label a goal @xmath10 both with a substitution and a program clause , e.g. , @xmath11 , which is used to determine the next clause to be used for an sld resolution step ( see rules and in fig .",
    "[ fig : concrete2 ] ) .",
    "note that the clauses of the program are not included in the state but considered a global parameter since they are static . in the following , given an atom @xmath3 and a logic program @xmath12",
    ", @xmath13 returns the sequence of renamed apart program clauses @xmath14 from @xmath12 whose head unifies with @xmath3 .",
    "a syntactic object @xmath15 is _ more general _ than a syntactic object @xmath16 , denoted @xmath17 , if there exists a substitution @xmath18 such that @xmath19 .",
    "@xmath20 denotes the set of variables of the syntactic object @xmath21 . for a substitution @xmath18 ,",
    "@xmath22 is defined as @xmath23 .    ' '' ''    @xmath24         \\mathsf{(failure ) } & { \\displaystyle         \\frac{~ }           { \\tuple{({\\mathsf{fail}},\\cb)_\\delta } \\to \\tuple{{\\mbox{\\footnotesize \\textsc{fail}}}_\\delta } }          }          \\hspace{24ex }      \\mathsf{(backtrack ) } ~ { \\displaystyle         \\frac{s\\neq\\epsilon }           { \\tuple{({\\mathsf{fail}},\\cb)_\\delta{\\!\\mid\\!}s } \\to \\tuple{s } }          } \\\\[4ex ]         \\textsf{(choice ) } &   { \\displaystyle         \\frac {         { \\mathsf{clauses}}(a,\\cp ) = ( c_1,\\ldots , c_n)\\wedge n>0        }           { \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s } \\to                                \\tuple{(a,\\cb)_\\delta^{c_1 } { \\!\\mid\\!}\\ldots{\\!\\mid\\!}(a,\\cb)_\\delta^{c_n}{\\!\\mid\\!}s } }          }          \\hfill\\hspace{1ex }      \\mathsf{(choice\\_fail ) } ~ { \\displaystyle         \\frac {         { \\mathsf{clauses}}(a,\\cp)={\\{\\ } } }           { \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s } \\to \\tuple{({\\mathsf{fail}},\\cb)_\\delta{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(unfold ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(a , h_1)=\\sigma }           { \\tuple{(a,\\cb)_\\delta^{h_1\\leftarrow\\cb_1}{\\!\\mid\\!}s }            \\to \\tuple{(\\cb_1\\sigma,\\cb\\sigma)_{\\delta\\sigma}{\\!\\mid\\!}s } }          } \\\\",
    "\\end{array}\\ ] ]    ' '' ''    for simplicity , w.l.o.g .",
    ", we only consider _ atomic _ initial goals .",
    "therefore , given an atom @xmath3 , an initial state has the form @xmath25 , where @xmath26 denotes the identity substitution .",
    "the transition rules , shown in figure  [ fig : concrete2 ] , proceed as follows :    * in rules and , we use fresh constants to denote a final state : @xmath27 denotes that a sucessful derivation ended with computed answer substitution @xmath28 , while @xmath29 denotes a finitely failing derivation ; recording @xmath28 for failing computations might be useful for debugging purposes . * rule applies when the first goal in the sequence finitely fails , but there is at least one alternative choice .",
    "* rule represents the first stage of an sld resolution step .",
    "if there is at least one clause whose head unifies with the leftmost atom , this rule introduces as many copies of a goal as clauses returned by function @xmath30 . if there is at least one matching clause , unfolding is then performed by rule .",
    "otherwise , if there is no matching clause , rule returns so that either rule or applies next .    [ ex1 ] consider the following logic program : @xmath31 given the initial goal @xmath32 , we have the following successful computation ( for clarity , we label each step with the applied rule ) : @xmath33 therefore , we have a successful computation for @xmath32 with computed answer @xmath34 .",
    "observe that only the first answer is considered .",
    "we do not formally prove the correctness of the concrete semantics , but it is an easy consequence of the correctness of the semantics in @xcite .",
    "note that our rules can be seen as an instance for pure prolog without negation , where only the computation of the first answer for the initial goal is considered .",
    "in this section , we introduce a concolic execution semantics for logic programs that is a conservative extension of the concrete semantics of the previous section . in this semantics ,",
    "_ concolic states _ have the form @xmath35\\![\\;}}s'}$ ] , where @xmath36 and @xmath37 are sequences of ( possibly labeled ) concrete and symbolic goals , respectively . in logic programming ,",
    "the notion of _ symbolic _ execution is very natural : the structure of both @xmath36 and @xmath37 is the same , and the only difference is that some atoms might be less instantiated in @xmath37 than in @xmath36 .    in the following ,",
    "we let @xmath38 denote the sequence of syntactic objects @xmath39 .",
    "given an atom @xmath3 , we let @xmath40 if @xmath41 . now , given an atom @xmath3 with @xmath42 , an _ initial concolic state _ has the form @xmath43\\![\\;}}p({\\overline{x_n}})_{{\\mathit{id}}}}$ ] , where @xmath44 are different fresh variables .",
    "in the following , we assume that every clause @xmath45 has a corresponding unique label , which we denote by @xmath46 . by abuse of notation , we also denote by @xmath47 the set of labels @xmath48 .",
    "the semantics is given by the rules of the labeled transition relation @xmath49 shown in figure  [ fig : concolic ] .",
    "here , we consider two kinds of labels for the transition relation :    * the empty label , @xmath50 , which is often implicit . * a label of the form @xmath51 , which represents a choice step . here , @xmath47 are the labels of the clauses matching the selected atom in the concrete goal , while @xmath52 are the labels of the clauses matching the selected atom in the corresponding symbolic goal .",
    "note that @xmath53 since the concrete goal is always an instance of the symbolic goal ( see theorem  [ th : invariant ] below ) .    for each transition step @xmath54 , the first set of labels , @xmath55 , is used to determine the execution _ trace _ of a concrete goal ( see below ) .",
    "traces are needed to keep track of the execution paths already explored .",
    "the second set of labels , @xmath56 , is used to compute new goals that follow alternative paths not yet explored , if any .    ' '' ''     + @xmath57\\![\\;}}\\mathsf{true}_{\\theta}{\\!\\mid\\!}s ' }             \\leadsto_\\diamond            \\tuple{{\\mbox{\\footnotesize \\textsc{success}}}_\\delta { \\mathit{\\;]\\![\\;}}{\\mbox{\\footnotesize \\textsc{success}}}_\\theta } }          } \\\\[4ex ]        \\mathsf{(failure ) } & { \\displaystyle         \\frac{~ }           { \\tuple{(\\mathsf{fail},\\cb)_\\delta            { \\mathit{\\;]\\![\\;}}(\\mathsf{fail},\\cb')_\\theta } \\leadsto_\\diamond           \\tuple{{\\mbox{\\footnotesize \\textsc{fail}}}_\\delta { \\mathit{\\;]\\![\\;}}{\\mbox{\\footnotesize \\textsc{fail}}}_\\theta } }          } \\\\[4ex ]        \\mathsf{(backtrack ) } & { \\displaystyle         \\frac{s\\neq\\epsilon }           { \\tuple{(\\mathsf{fail},\\cb)_\\delta{\\!\\mid\\!}s { \\mathit{\\;]\\![\\;}}(\\mathsf{fail},\\cb')_\\theta{\\!\\mid\\!}s ' } \\leadsto_\\diamond \\tuple{s{\\mathit{\\;]\\![\\;}}s ' } }          } \\\\[4ex ]         \\mathsf{(choice ) } &   { \\displaystyle         \\frac{{\\mathsf{clauses}}(a,\\cp ) = { \\overline{c_n}}\\wedge n>0 \\wedge { \\mathsf{clauses}}(a',\\cp)={\\overline{d_k } } }           { \\begin{array}{l@{~}l }              \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s { \\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta{\\!\\mid\\!}s ' }               \\leadsto_{\\!c(\\ell({\\overline{c_n}}),\\ell({\\overline{d_k } } ) ) }             \\tuple{(a,\\cb)_\\delta^{c_1 } { \\!\\mid\\!}\\ldots{\\!\\mid\\!}(a,\\cb)_\\delta^{c_n}{\\!\\mid\\!}s\\\\[1ex ]          \\hspace{47ex}{\\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta^{c_1 } { \\!\\mid\\!}\\ldots{\\!\\mid\\!}(a',\\cb')_\\theta^{c_n}{\\!\\mid\\!}s '          } \\end{array } }          } \\\\[8ex ]         \\mathsf{(choice\\_fail ) } & { \\displaystyle         \\frac {           { \\mathsf{clauses}}(a,\\cp)={\\{\\}}\\wedge { \\mathsf{clauses}}(a',\\cp)={\\overline{c_k } } }           { \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s { \\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta{\\!\\mid\\!}s ' }             \\leadsto_{c({\\{\\}},\\ell({\\overline{c_k } } ) ) }            \\tuple{({\\mathsf{fail}},\\cb)_\\delta{\\!\\mid\\!}s{\\mathit{\\;]\\![\\;}}({\\mathsf{fail}},\\cb')_\\theta{\\!\\mid\\!}s ' } }          } \\\\[5ex ]        \\mathsf{(unfold ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(a , h_1)=\\sigma\\wedge{\\mathsf{mgu}}(a',h_1)=\\sigma ' }           { \\tuple{(a,\\cb)_\\delta^{h_1\\leftarrow\\cb_1}{\\!\\mid\\!}s{\\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta^{h_1\\leftarrow\\cb_1}{\\!\\mid\\!}s ' }            \\leadsto_\\diamond \\tuple{(\\cb_1\\sigma,\\cb\\sigma)_{\\delta\\sigma}{\\!\\mid\\!}s            { \\mathit{\\;]\\![\\;}}(\\cb_1\\sigma',\\cb'\\sigma')_{\\theta\\sigma'}{\\!\\mid\\!}s ' } }          } \\\\",
    "\\end{array}\\ ] ]    ' '' ''    in the concolic execution semantics , we perform both concrete and symbolic execution steps in parallel",
    ". however , the symbolic execution does not explore all possible execution paths but only mimics the steps of the concrete execution ; observe , e.g. , rule in figure  [ fig : concolic ] , where the clauses labeling the copies of the symbolic goal are the same clauses @xmath58 matching the concrete goal , rather than the set of clauses @xmath59 ( a superset of @xmath58 ) .    [ ex2 ] consider again the logic program of example  [ ex1 ] , now with clause labels : @xmath60 given the initial goal @xmath32 , we have the following concolic execution : @xmath61\\![\\;}}p(n)_{{\\mathit{id } } } } & \\leadsto^\\mathsf{choice}_{c(\\cl_1,\\cl'_1 ) } &        \\tuple{p(f(x))_{{\\mathit{id}}}^{p(f(y ) ) \\leftarrow r(y)}{\\mathit{\\;]\\![\\;}}p(n)_{{\\mathit{id}}}^{p(f(y ) ) \\leftarrow r(y ) } } \\\\        & \\leadsto^\\mathsf{unfold}_\\diamond & \\tuple{r(x)_{{\\mathit{id}}}{\\mathit{\\;]\\![\\;}}r(y)_{\\{n / f(y)\\ } } } \\\\        & \\leadsto^\\mathsf{choice}_{c(\\cl_2,\\cl'_2 ) } & \\tuple{r(x)_{{\\mathit{id}}}^{r(a)}{\\!\\mid\\!}r(x)_{{\\mathit{id}}}^{r(c)}{\\mathit{\\;]\\![\\;}}r(y)_{\\{n / f(y)\\}}^{r(a)}{\\!\\mid\\!}r(y)_{\\{n / f(y)\\}}^{r(c ) } } \\\\        & \\leadsto^\\mathsf{unfold}_\\diamond & \\tuple{\\mathsf{true}_{\\{x / a\\}}{\\!\\mid\\!}r(x)_{{\\mathit{id}}}^{r(c ) } { \\mathit{\\;]\\![\\;}}\\mathsf{true}_{\\{n / f(a)\\}}{\\!\\mid\\!}r(y)_{\\{n / f(y)\\}}^{r(c ) } } \\\\        & \\leadsto^\\mathsf{success}_\\diamond & \\tuple{{\\mbox{\\footnotesize \\textsc{success}}}_{\\{x / a\\}}{\\mathit{\\;]\\![\\;}}{\\mbox{\\footnotesize \\textsc{success}}}_{\\{n / f(a)\\ } } }       \\end{array}\\ ] ] where @xmath62 , @xmath63 , and @xmath64 .    in this paper",
    ", we only consider finite concolic executions for initial goals .",
    "this is a reasonable assumption since one can expect concrete goals to compute the first answer finitely ( unless the program is erroneous ) .",
    "we associate a _ trace _ to each concolic execution as follows :    let @xmath12 be a program and @xmath65 an initial concolic state .",
    "let @xmath66 , @xmath67 , be a concolic execution for @xmath65 in @xmath12 .",
    "let @xmath68 , @xmath69 , be the sequence of labels in @xmath70 which are different from @xmath50 .",
    "then , the trace associated to the concolic execution @xmath71 is @xmath72 .",
    "roughly speaking , a trace is just a sequence with the sets of labels of the matching clauses in each choice step .",
    "for instance , the trace associated to the concolic execution of example  [ ex2 ] is @xmath73 , i.e. , we have two unfolding steps with matching clauses @xmath74 and @xmath75 , respectively .",
    "note that traces ending with @xmath76 represent failing derivations .",
    "the following result states an essential invariant for concolic execution :    [ th : invariant ] let @xmath12 be a program and @xmath77\\![\\;}}p({\\overline{x_n}})_{{\\mathit{id}}}}$ ] be an initial concolic state .",
    "let @xmath78 , @xmath79 , be a finite ( possibly incomplete ) concolic execution for @xmath65 in @xmath12 .",
    "then , for all concolic states @xmath80\\![\\;}}\\cd^{c'}_\\theta{\\!\\mid\\!}s'}$ ] , @xmath81 , the following invariant holds : @xmath82 , @xmath83 , @xmath84 ( if any ) , and @xmath85 .",
    "in this section , we introduce a concolic testing procedure for logic programs based on the concolic execution semantics of the previous section .",
    "as we have seen in section  [ concolic ] , the concolic execution steps labeled with @xmath86 give us a hint of ( potential ) alternative execution paths .",
    "consider , for instance , the concolic execution of example  [ ex2 ] .",
    "the first step is labeled with @xmath87 .",
    "this means that the selected atom in the concrete goal only matched clause @xmath88 , while the selected atom in the symbolic goal matched clauses @xmath89 , @xmath90 and @xmath88 . in principle",
    ", there are as many alternative execution paths as elements in @xmath91 ; e.g. , @xmath76 denotes an execution path where the selected atom matches no clause , @xmath92 another path in which the selected atom _ only _ matches clause @xmath89 , @xmath93 another path where the selected atom matches all three clauses @xmath89 , @xmath90 and @xmath88 , and so forth .    when aiming at full choice coverage , we need to solve both unification and disunification problems .",
    "consider , e.g. , that @xmath3 is the selected atom in a goal , and that we want it to unify with the head of clause @xmath89 but not with the heads of clauses @xmath90 and @xmath88 . for this purpose , we introduce the following auxiliary function @xmath94 , which also includes some groundness requirements ( see below ) . in the following ,",
    "we let @xmath95 denote the unifiability relation , i.e. , given atoms @xmath96 , @xmath97 holds if @xmath98 ; correspondingly , @xmath99 holds if @xmath100 .",
    "[ def : alt ] let @xmath3 be an atom and @xmath101 be sets of clause labels .",
    "let @xmath102 be a set of variables .",
    "the function @xmath103 returns a substitution @xmath18 such that the following holds : @xmath104 where @xmath4 are the heads of the ( renamed apart ) clauses labeled by @xmath105 and @xmath106 are the heads of the ( renamed apart ) clauses labeled by @xmath107 , respectively .",
    "if such a substitution does not exist , then function @xmath94 returns @xmath108 .",
    "when the considered signature is finite , the following semi - algorithm is trivially sound and complete for solving the above unifiability problem : first , bind @xmath3 with terms of depth @xmath109 . of a term @xmath110",
    "is defined as usual : @xmath111 if @xmath110 is a variable or a constant symbol , and @xmath112 , otherwise . ]",
    "if the condition above does not hold , then we try with terms of depth @xmath113 , and check it again .",
    "we keep increasing the considered term depth until a solution is found .",
    "if a solution exists , this naive semi - algorithm will find it ( otherwise , it may run forever ) . in practice , however , it may be very inefficient .",
    "observe that , in general , there might be several most general solutions to the above problem .",
    "consider , e.g. , @xmath114 , @xmath115 and @xmath116 .",
    "then , both @xmath117 and @xmath118 are most general solutions . in principle , any of them is equally good in our context .",
    "we postpone to the next section the introduction of a constructive algorithm for function @xmath94 . here",
    ", we present an algorithm to systematically produce concrete initial goals so that all _ feasible _ choices in the execution paths are covered ( unless the process runs forever ) .",
    "first , we introduce the following auxiliary definitions :    [ defn : conc : symb ] let @xmath119\\![\\;}}\\cd^1_{\\theta_1}{\\!\\mid\\!}\\ldots{\\!\\mid\\!}\\cd^n_{\\theta_n}}$ ] be a concolic state .",
    "then , we let @xmath120 denote the first concrete goal and @xmath121 the first symbolic goal .    [ def : alttrace ] let @xmath12 be a program , @xmath65 an initial concolic state , and @xmath122 be a ( possibly incomplete ) concolic execution for @xmath65 in @xmath12 . then",
    ", the function @xmath123 denotes the following set of ( potentially ) alternative traces : @xmath124    for instance , given the following ( partial ) concolic execution @xmath71 from example  [ ex2 ] : @xmath125\\![\\;}}p(n)_{{\\mathit{id } } } } & \\leadsto^\\mathsf{choice}_{c(\\cl_1,\\cl'_1 ) }         & \\tuple{p(f(x))_{{\\mathit{id}}}^{p(f(y ) ) \\leftarrow r(y)}{\\mathit{\\;]\\![\\;}}p(n)_{{\\mathit{id}}}^{p(f(y ) ) \\leftarrow r(y ) } } \\\\        & \\leadsto^\\mathsf{unfold}_\\diamond & \\tuple{r(x)_{{\\mathit{id}}}{\\mathit{\\;]\\![\\;}}r(y)_{\\{n / f(y)\\ } } } \\\\         & \\leadsto^\\mathsf{choice}_{c(\\cl_2,\\cl'_2 ) } & \\tuple{r(x)_{{\\mathit{id}}}^{r(a)}{\\!\\mid\\!}r(x)_{{\\mathit{id}}}^{r(c)}{\\mathit{\\;]\\![\\;}}r(y)_{\\{n / f(y)\\}}^{r(a)}{\\!\\mid\\!}r(y)_{\\{n / f(y)\\}}^{r(c ) } }      \\end{array}\\ ] ] where @xmath126 , @xmath63 , @xmath127 , we have @xmath128 , @xmath129 , and @xmath130 .",
    "now , we introduce our concolic testing procedure .",
    "it takes as input a program and a random |e.g . , provided by the user| initial atomic goal rooted by the distinguished predicate @xmath131 . in the following , we assume that each concrete initial goal @xmath132 is existentially terminating w.r.t .",
    "prolog s leftmost computation rule , i.e. , either computes the _ first _ answer in a finite number of steps or finitely fails @xcite .",
    "for this purpose , we assume that @xmath131 has some associated _ input _ arguments , determined by a function @xmath133 , so that an initial goal @xmath132 existentially terminates if the terms @xmath134 are ground .",
    "one could also consider that there are several combinations of input arguments that guarantee existential termination |this is similar to the modes of a predicate| but we only consider one set of input arguments for simplicity ( extending the concolic testing algorithm would be straightforward ) . as mentioned before , assuming that concrete initial goals are existentially terminating is a reasonable assumption in practice .",
    "[ def : concolic ]    * input : * : :    a logic program @xmath12 and an atom    @xmath132 with    @xmath134 ground .",
    "* output : * : :    a set @xmath135 of test cases .    1 .",
    "let @xmath136 , @xmath137 , @xmath138 .",
    "2 .   while @xmath139 do 1 .   take @xmath140 , @xmath141 , @xmath142 .",
    "2 .   let @xmath143\\![\\;}}main({\\overline{x_n}})_{{\\mathit{id}}}}$ ] and compute a successful or finitely failing derivation @xmath144 .",
    "3 .   let @xmath145 .",
    "we update @xmath146 as follows : * for each prefix @xmath147 of @xmath71 and * for each ( possibly partial ) trace @xmath148 @xmath149 which is not the prefix of any trace in @xmath150 , * add @xmath151 to @xmath146 if @xmath152 , where @xmath153 and @xmath154 . is the first atom of the symbolic goal @xmath155 of the concolic state @xmath156 , see definition [ defn : conc : symb ] . ]",
    "return the set @xmath135 of test cases    the soundness of concolic testing is immediate , since each atom from @xmath135 is indeed a test case of the form @xmath157 with @xmath158 ground .",
    "completeness and termination are more subtle properties though .    in principle",
    ", one could argue that the concolic testing algorithm is a complete semi - algorithm in the sense that , if it terminates , the generated test cases cover all feasible paths .",
    "our assumptions trivially guarantee that every considered concrete execution is finite ( i.e. , step ( 2b ) in the loop of the concolic testing algorithm ) .",
    "unfortunately , the algorithm will often run forever by producing infinitely many test cases .",
    "consider , e.g. , the following simple program : @xmath159 even if every goal @xmath160 with @xmath110 ground is terminating , our algorithm will still produce infinitely many test cases , e.g. , @xmath161 , @xmath162 , @xmath163 , ",
    ", since each goal will explore a different path ( i.e. , will produce a different execution trace : @xmath164 , @xmath165 , @xmath166 , etc ) . in practice , though , the quality of the generated test cases should be experimentally evaluated using a coverage tool .",
    "therefore , in general , we will sacrifice completeness in order to guarantee the termination of concolic testing . for this purpose",
    ", one can use a time limit , a bound for the length of concolic executions , or a maximum term depth for the arguments of the generated test cases . in this paper , we consider the last approach .",
    "then , one can replace the use of a particular function @xmath94 in step ( 2d ) of definition  [ def : concolic ] by a function @xmath167 with @xmath168 if @xmath169 for all @xmath170 , and @xmath171 otherwise .",
    "this is the solution we implemented in the concolic testing tool described in section  [ tool ] .",
    "for instance , by requiring a maximum term depth of @xmath113 , the generated test cases for the program @xmath172 above would be @xmath161 , @xmath173 , @xmath162 and @xmath174 , where @xmath113 is a fresh constant symbol , with associated traces @xmath164 ,",
    "@xmath175 , @xmath165 , and @xmath176 , respectively .",
    "termination of the algorithm in definition  [ def : concolic ] is then guaranteed since only a finite number of new atoms can be added in step ( 2d ) |up to variable renaming| and , moreover , only those ( possibly partial ) traces which are not a prefix of any trace already in the set @xmath177 are considered .",
    "observe that these facts suffice to ensure termination of the algorithm since one can not have infinitely many traces with a finite number of atoms .",
    "in this section , we present a constructive algorithm for function @xmath94 .",
    "let us first reformulate our unification problem in slightly more general terms than in definition  [ def : alt ] .",
    "let @xmath3 be an atom and @xmath178 , @xmath179 be two sets of atoms the elements of which are variable disjoint with @xmath3 and unify with @xmath3 , and a set of variables @xmath180 .",
    "the problem consists in finding a substitution @xmath181 such that @xmath182 we introduce a stepwise method that , roughly speaking , proceeds as follows :    * first , we produce some `` maximal '' substitutions @xmath18 ( called _ maximal unifying substitution _ below ) for @xmath3 such that @xmath183 still unifies with the atoms in @xmath178 . here",
    ", we use a special set @xmath184 of fresh variables with @xmath185 .",
    "the elements of @xmath184 are denoted by @xmath186 , @xmath187 , @xmath188  then , in @xmath18 , the variables from @xmath184 ( if any ) denote positions where further binding will prevent @xmath183 from unifying with some atom in @xmath178 .",
    "in contrast , @xmath189 still unifies with all the atoms in @xmath178 as long as @xmath190 does not bind any variable from @xmath184 . roughly speaking ,",
    "we apply some ( minimal ) generalizations to the atoms in @xmath178 so that they unify , and then return their most general unifier .",
    "+ for this stage , we use well known techniques like _ variable elimination _ @xcite and _ generalization _ ( from the algorithm for most specific generalization @xcite ) ; see definition  [ alg1 ] below . * in a second stage , we look for another substitution @xmath191 such that @xmath192 is a solution for @xmath193 . here , we basically follow a generate and test algorithm ( as in the naive algorithm above ) , but it is now much more restricted thanks to @xmath18 .      here , we will use the variables from the special set @xmath184 to replace _ disagreement pairs _",
    "( see  @xcite p.  27 ) .",
    "roughly speaking , given terms @xmath194 and @xmath110 , a subterm @xmath195 of @xmath194 and a subterm @xmath196 of @xmath110 form a disagreement pair if the root symbols of @xmath195 and @xmath196 are different , but the symbols from @xmath195 up to the root of @xmath194 and from @xmath196 up to the root of @xmath110 are the same .",
    "for instance , @xmath197 and @xmath198 are disagreement pairs of the terms @xmath199 and @xmath200 .",
    "a disagreement pair @xmath201 is called _ simple _ if one of the terms is a variable that does not occur in the other term and no variable of @xmath184 occurs in @xmath201 .",
    "we say that the substitution @xmath202 is determined by @xmath201 if @xmath203 .    basically , given an atom @xmath3 and a set of atoms @xmath178",
    ", the following algorithm nondeterministically computes a substitution @xmath18 such that @xmath189 still unifies with all the atoms in @xmath178 as long as @xmath190 does not bind any variable from @xmath184 .",
    "[ alg1 ]    * input : * : :    an atom @xmath3 and a set of atoms    @xmath178 such that    @xmath204    and @xmath97 for all    @xmath205 .",
    "* output : * : :    a substitution @xmath18 .    1",
    ".   [ algo - msa - init ] let @xmath206 .",
    "[ algo - msa - while - simple ] while simple disagreement pairs occur in @xmath10 do 1 .",
    "nondeterministically choose a simple disagreement pair @xmath207 ( resp .",
    "@xmath208 ) in @xmath10 such that there is no other simple disagreement pair of the form @xmath209 ( or @xmath210 ) with @xmath211 ( i.e. , a strict instance ) ; 2 .",
    "[ algo - msa - simple - pair ] set @xmath10 to @xmath212 where @xmath213 .",
    "[ algo - msa - while - not - simple ] while @xmath214 do 1 .",
    "nondeterministically choose a disagreement pair @xmath201 in @xmath10 ; 2 .",
    "[ algo - msa - not - simple - pair ] replace all disagrement pairs @xmath201 in @xmath10 by a fresh variable of @xmath184 .",
    "4 .   [ algo - msa - return ] return @xmath18 , where @xmath215 , @xmath216 , and @xmath217 .",
    "we note that the algorithm assumes that the input atom @xmath3 is always more general than the final atom @xmath218 so that the last step is well defined .",
    "an invariant proving that this is indeed the case can be found in the online appendix ( appendix b ) .",
    "observe that the step ( 2a ) is nondeterministic since there may exist several disagreement pairs @xmath207 ( or @xmath208 ) for the same variable @xmath219 . consider the atom @xmath220 and the set @xmath221 .",
    "then , both @xmath222 and @xmath223 are maximal unifying substitutions , as the following example illustrates :    [ ex-1-g ] let @xmath114 and @xmath221 , with @xmath224 .",
    "the algorithm then considers the simple disagreement pairs in @xmath10 . from @xmath225 , we get @xmath226 and the action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath227 .",
    "the substitution @xmath228 is determined by @xmath229 and the action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath230 .",
    "now , we have two non - deterministic possibilities :    * if we consider the disagreement pair @xmath231 , we have a substitution @xmath232 and action  ( [ algo - msa - simple - pair ] ) then sets @xmath10 to @xmath233 .",
    "now , no simple disagreement pair occurs in @xmath10 , hence the algorithm jumps to the loop at line  [ algo - msa - while - not - simple ] .",
    "action  ( [ algo - msa - not - simple - pair ] ) replaces the disagreement pair @xmath234 with a fresh variable @xmath235 , hence @xmath10 is set to @xmath236 . as @xmath237 the loop at line  [ algo - msa - while - not - simple ] stops and the algorithm returns the substitution @xmath222 . *",
    "if we consider the disagreement pair @xmath238 instead , we have a substitution @xmath239 , and action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath240 .",
    "now , by proceeding as in the previous case , the algorithm returns @xmath223 .",
    "now we deal with the negative atoms by means of the following algorithm which is the basis of our implementation of function @xmath94 :    [ alg2 ]    * input : * : :    an atom @xmath3 and two sets of atoms    @xmath178 ,    @xmath179 , the elements of which are    variable disjoint with @xmath3 and unify with @xmath3 ,    and a set of variables @xmath180 .",
    "* output : * : :    @xmath108 or a substitution    @xmath192 ( restricted to the variables of    @xmath3 ) .    1 .",
    "let @xmath18 be the substitution returned by the algorithm of definition  [ alg1 ] with input @xmath3 and @xmath178 .",
    "2 .   let @xmath191 be an idempotent substitution such that @xmath241 is ground .",
    "3 .   check that @xmath242 and @xmath243 , otherwise return @xmath108 .",
    "4 .   check that for each @xmath244 , @xmath245 , otherwise return @xmath108 .",
    "return @xmath192 ( restricted to the variables of @xmath3 ) .",
    "the correctness of this algorithm is stated as follows :    [ theorem : correction - algo - posneg ] let @xmath3 be an atom and @xmath246 be two sets of atoms such that @xmath185 and @xmath97 for all @xmath247 , and a set of variables @xmath180 .",
    "the algorithm in definition  [ alg2 ] always terminates and , if it returns a substitution @xmath181 , then @xmath248 holds and @xmath249 is ground .",
    "let @xmath250 , @xmath251 , @xmath252 , and @xmath253 .",
    "the algorithm of definition  [ alg1 ] returns @xmath254 .",
    "we take @xmath255 , it is idempotent and @xmath241 is ground . @xmath256 and @xmath257 does not intersect with @xmath184 .",
    "finally , @xmath258 does not unify with @xmath259 . the algorithm",
    "thus returns @xmath260 restricted to the variables of @xmath3 , i.e. , @xmath261 .",
    "let @xmath250 , @xmath262 , @xmath263 , and @xmath264 .",
    "the algorithm of definition  [ alg1 ] applied to @xmath3 and @xmath178 returns @xmath265 .",
    "however , we can not find @xmath191 such that @xmath266 does not unify with @xmath267 without binding @xmath186 .",
    "the algorithm thus returns @xmath108 .",
    "theorem  [ theorem : correction - algo - posneg ] states the soundness of our procedure for computing function @xmath94 . as for completeness",
    ", we claim that binding an atom @xmath3 with all possible maximal unifying substitutions for @xmath3 and @xmath178 does not affect to the existence of a solution to the unification problem ( * ) above ( see the online appendix ( appendix b ) for more details ) .      in this section",
    ", we present a prototype implementation of the concolic testing scheme .",
    "the tool , called , is publicly available from the following url    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` http://kaz.dsic.upv.es/contest.html ` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    it consists of approx .",
    "1000 lines of prolog code and implements the concolic testing algorithm of definition  [ def : concolic ] with function @xmath94 as described in section  [ sec : unif ] and a maximum term depth that can be fixed by the user in order to guarantee the termination of the process .",
    "moreover , we also introduced a bound for the number of alternatives when computing function @xmath123 ( see definition  [ def : alttrace ] ) . roughly speaking ,",
    "when the number of alternatives is too high , we give up aiming at full _ choice _ coverage and return sets with only one clause label ( which suffice for clause coverage ) .",
    "@xmath268    table  [ table : coverage ] shows a summary of the coverage achieved by the test cases automatically generated using .",
    "the complete benchmarks including the source code , initial goal , input arguments and maximum term depth can be found in the above url .",
    "we used the coverage analysis tool of sicstus prolog 4.3.1 , which basically measures the number of times each clause is used .",
    "the results are very satisfactory , achieving a full coverage in most of the examples .",
    "the current version is a proof - of - concept implementation and only deals with pure prolog without negation .",
    "we plan to extend it to cope with full prolog .",
    "the concrete semantics can be extended following @xcite , and concolic execution is in general a natural extension of the semantics in figure  [ fig : concolic ] . for relational",
    "built - in s or equalities , we should label the execution step with an associated constraint , which can then be used to produce alternative execution paths by solving its negation . in this context",
    ", our tool will be useful not only for test case generation , but also to detect program errors during concolic testing ( e.g. , negated atoms which are not instantiated enough , incorrect calls to arithmetic built - in s , etc ) .",
    "see the online appendix ( appendix a ) for more details on extending concolic execution to full prolog .",
    "present a framework unifying unit testing and run - time verification for the ciao system  @xcite .",
    "the @xmath269 constraint programming system  @xcite and sicstus prolog  @xcite both provide tools which run a given goal and compute how often program points in the code were executed .",
    "swi - prolog  @xcite offers a unit testing tool associated to an optional interactive generation of test cases .",
    "it also includes an experimental coverage analysis which runs a given goal and computes the percentage of the used clauses and failing clauses . and consider automatic generation of test inputs for strongly typed and moded logic programming languages like the mercury programming language  @xcite , whereas we only require moding the top - level predicate of the program .",
    "one of the closest approaches to our work is the test case generation technique by @xcite .",
    "the main difference , though , is that their technique is based solely on traditional symbolic execution . as mentioned before ,",
    "concolic testing may scale better since one can deal with more complex constraints by using data from the concrete component of the concolic state .",
    "another difference is that we aim at full path coverage ( i.e. , choice coverage ) , and not only a form of statement coverage .",
    "another close approach is @xcite , where a concolic execution semantics for logic programs is presented .",
    "however , this approach only considers a simpler statement coverage and , thus , it can be seen as a particular instance of the technique in the present paper .",
    "another significant difference is that , in @xcite , concolic execution proceeds in a stepwise manner : first , concrete execution produces an execution _ trace _ , which is then used to drive concolic execution .",
    "although this scheme is conceptually simpler , it may give rise to poorer results in practice since one can not use concrete values in symbolic executions , one of the main advantages of concolic execution over traditional symbolic execution .",
    "moreover , presents no formal results nor an implementation of the concolic execution technique .    summarizing the paper",
    ", we have introduced a novel scheme for concolic testing in logic programming .",
    "it offers a sound and fully automatic technique for test case generation with a good code coverage .",
    "we have stated the particular type of unification problems that should be solved to produce new test cases .",
    "we have proposed a correct algorithm for such unification problems .",
    "furthermore , we have developed a publicly available proof - of - concept implementation of the concolic testing scheme , , that shows the usefulness of our approach . to the best of our knowledge ,",
    "this is the first fully automatic testing tool for prolog that aims at full path coverage ( here called choice coverage ) .    as future work",
    ", we plan to extend the scheme to full prolog ( see the remarks in section  [ tool ] ) .",
    "another interesting subject for further research is the definition of appropriate heuristics to drive concolic testing w.r.t .  a given coverage criterion .",
    "this might have a significant impact on the quality of the test cases when the process is incomplete .",
    "finally , from the experimental evaluation , we observed that the results could be improved by introducing type information , so that the generated values are restricted to the right type .",
    "hence , improving concolic testing with type annotations is also a promising line of future work .    , arenas , p. , gmez - zamalloa , m. , and rojas , j. 2014 . .",
    "in _ sfm 2014_. springer lncs 8483 , 263309 .    \\1997 . .",
    "prentice hall .",
    "implementation - based analysis and testing of prolog programs . in _",
    ".    \\2012 .",
    "- the first 25 years .",
    "_ 12 , _  1 - 2 , 3566 .",
    "in _ proc .  of ( icfp 2000)_. acm , 268279 .",
    "\\1976 . a program testing system . in _ proceedings of the 1976 annual conference ( acm76)_. 488491 .    ,",
    "schrijvers , t. , and vanhoof , w. 2008 .",
    "automatic generation of test inputs for mercury . in _ logic - based program synthesis and transformation , 18th international symposium ,",
    "lopstr 2008_. 7186 .    , klarlund , n. , and sen , k. 2005 . .",
    "in _ proc .  of pldi05_. acm , 213223 .    ,",
    "levin , m. , and molnar , d. 2012 .",
    "sage : whitebox fuzzing for security testing .",
    "_ 55 , _  3 , 4044 .    ,",
    "albert , e. , and puebla , g. 2010 . .",
    "_ 10 , _  4 - 6 , 659674 .    ,",
    "bueno , f. , carro , m. , lpez - garca , p. , mera , e. , morales , j.  f. , and puebla , g. 2012 .",
    "an overview of ciao and its design philosophy .",
    "_ 12 , _  1 - 2 , 219252 .",
    "symbolic execution and program testing .",
    "_ 19 , _  7 , 385394 .",
    "springer - verlag , berlin .",
    "2nd ed .",
    "an efficient unification algorithm .",
    "_ 4 _ , 258282 .    , lpez - garca , p. , and hermenegildo , m.  v. 2009 .",
    "integrating software testing and run - time checking in an assertion verification framework . in _",
    "25th international conference on logic programming , iclp 2009 , pasadena_. 281295 .",
    "in _ ase _ , c.  pecheur , j.  andrews , and e.  d. nitto , eds .",
    "acm , 179180 .",
    "\\1970 . a note on inductive generalization .",
    "_ 5 _ , 153163 .",
    "@xmath270ps@xmath271 - from lp to clp .",
    "_ 12 , _  1 - 2 , 127156 .    ,",
    "marinov , d. , and agha , g. 2005 . .",
    "in _ proc .  of esec / sigsoft fse",
    "2005_. acm , 263272 .    ,",
    "henderson , f. , and conway , t. 1996 .",
    "the execution algorithm of mercury , an efficient purely declarative logic programming language .",
    "_ 29 , _  13 , 1764 .    ,",
    "emmes , f. , schneider - kamp , p. , giesl , j. , and fuhs , c. 2011 . .",
    "lopstr11_. springer lncs 7225 , 237252 .",
    "characterization of terminating logic programs . in _ proc . of the 1986 intl .",
    "symp . on logic programming_. ieee , 140147 .",
    "in _ proc .  of the 24th international symposium on logic - based program synthesis and transformation ( lopstr14 ) _ , m.  proietti and h.  seki , eds .",
    "springer lncs 8981 , 167181 .    ,",
    "schrijvers , t. , triska , m. , and lager , t. 2012 . .",
    "_ 12 , _  1 - 2 , 6796 .",
    "+    online appendix for the paper + _ concolic testing in logic programming + published in theory and practice of logic programming _",
    "fred mesnard , tienne payet + _ lim - universit de la runion , france +   + germn vidal + _ mist , dsic , universitat politcnica de valncia + _ _    _ submitted 29 april 2015 ; revised 3rd july 2015 ; accepted 14 july 2015 _    in this appendix we report , for the sake of completeness , some auxiliary contents that , for space limitations , we could not include in the paper .",
    "' '' ''    @xmath272         \\mathsf{(failure ) } & { \\displaystyle         \\frac{~ }           { \\tuple{({\\mathsf{fail}},\\cb)_\\delta } \\to \\tuple{{\\mbox{\\footnotesize \\textsc{fail}}}_\\delta } }          }          \\hfill\\hspace{5ex }      \\mathsf{(backtrack ) } ~ { \\displaystyle         \\frac{s\\neq\\epsilon }           { \\tuple{({\\mathsf{fail}},\\cb){\\!\\mid\\!}s } \\to \\tuple{s } }          } \\\\[3ex ]         \\textsf{(choice ) } &   { \\displaystyle         \\frac{{\\mathsf{defined}}(a ) \\wedge          { \\mathsf{clauses}}(a,\\cp ) = ( c_1,\\ldots , c_n)\\wedge n>0 \\wedge m~\\mbox{is fresh } }           { \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s } \\to            \\tuple{(a,\\cb)_\\delta^{c_1[!/!^m ] } { \\!\\mid\\!}\\ldots{\\!\\mid\\!}(a,\\cb)_\\delta^{c_n[!/!^m]}{\\!\\mid\\!}~?^m_\\delta{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(choice\\_fail ) } & { \\displaystyle         \\frac{{\\mathsf{defined}}(a,\\cp)\\wedge { \\mathsf{clauses}}(a,\\cp)={\\{\\ } } }           { \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}s } \\to \\tuple{({\\mathsf{fail}},\\cb)_\\delta{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(unfold ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(a , h_1)=\\sigma }           { \\tuple{(a,\\cb)_\\delta^{h_1\\leftarrow\\cb_1}{\\!\\mid\\!}s }            \\to \\tuple{(\\cb_1\\sigma,\\cb\\sigma)_{\\delta\\sigma}{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(cut ) } & { \\displaystyle         \\frac{~ }           { \\tuple{(!^m,\\cb)_\\delta{\\!\\mid\\!}s'{\\!\\mid\\!}~?^m_{\\delta'}{\\!\\mid\\!}s }            \\to \\tuple{\\cb_{\\delta}{\\!\\mid\\!}~?^m_{\\delta'}{\\!\\mid\\!}s } }          }          \\hfill\\hspace{5ex }      \\mathsf{(cut\\_fail ) } ~ { \\displaystyle         \\frac{~ }           { \\tuple{?^m_\\delta { \\!\\mid\\!}s }            \\to \\tuple{{\\mathsf{fail}}_\\delta { \\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(call ) } & { \\displaystyle         \\frac{a\\not\\in\\cv\\wedge m~\\mbox{is fresh } }           { \\tuple{(call(a),\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{(a[\\cv/{\\mathsf{call}}(\\cv),!/!^m],\\cb)_{\\delta}{\\!\\mid\\!}~?^m_{\\delta}{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(call\\_error ) } & { \\displaystyle         \\frac{a\\in\\cv }           { \\tuple{(call(a),\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{{\\mbox{\\footnotesize \\textsc{error}}}_{\\delta } } }          } \\\\[3ex ]        \\mathsf{(not ) } & { \\displaystyle         \\frac{m~\\mbox{is fresh } }           { \\tuple{(\\backslash\\!\\!+\\!\\!(a),\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{({\\mathsf{call}}(a),!^m,{\\mathsf{fail}})_{\\delta}{\\!\\mid\\!}\\cb_\\delta{\\!\\mid\\!}~?^m_\\delta{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(unify ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(t_1,t_2)=\\sigma\\neq{\\mathsf{fail } } }           { \\tuple{(t_1=t_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{\\cb\\sigma_{\\delta\\sigma}{\\!\\mid\\!}s } }          }          \\hfill\\hspace{3ex }      \\mathsf{(unify\\_fail ) } ~ { \\displaystyle         \\frac{{\\mathsf{mgu}}(t_1,t_2)={\\mathsf{fail } } }           { \\tuple{(t_1=t_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{{\\mathsf{fail}}_{\\delta}{\\!\\mid\\!}s } }          } \\\\[3ex ]        \\mathsf{(is ) } & { \\displaystyle         \\frac{\\mathsf{eval}(e_2 ) = t_2 \\neq { \\mathsf{error } } }           { \\tuple{(t_1~\\mathsf{is}~e_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{(t_1=t_2,\\cb)_\\delta{\\!\\mid\\!}~ s } }          }          \\hfill\\hspace{1ex }      \\mathsf{(is\\_error ) } ~ { \\displaystyle         \\frac{\\mathsf{eval}(e_2 ) = { \\mathsf{error } } }           { \\tuple{(t_1~\\mathsf{is}~e_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{{\\mbox{\\footnotesize \\textsc{error}}}_\\delta } }          } \\\\[3ex ]        \\mathsf{(rel ) } & { \\displaystyle         \\frac{\\mathsf{eval}(t_1\\oplus t_2 ) = a \\in\\{\\mathsf{true},\\mathsf{fail}\\ } }           { \\tuple{(t_1~{\\oplus}~t_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{(a,\\cb)_\\delta{\\!\\mid\\!}~ s } }          }          \\hfill\\hspace{1ex }      \\mathsf{(rel\\_error ) } ~ { \\displaystyle         \\frac{\\mathsf{eval}(t_1\\oplus t_2 ) = { \\mathsf{error } } }           { \\tuple{(t_1\\oplus t_2,\\cb)_\\delta{\\!\\mid\\!}s }            \\to            \\tuple{{\\mbox{\\footnotesize \\textsc{error}}}_\\delta } }          }      \\end{array}\\ ] ]    ' '' ''    in this section , we show a summary of our preliminary research on extending concolic execution to deal with full prolog .",
    "first , we consider the extension of the concrete semantics . here , we mostly follow the linear semantics of ( strder et al . 2011 ) , being the main differences that we consider built - ins explicitly , we excluded dynamic predicates for simplicity |but could be added along the lines of ( strder et al .",
    "2011)| and that , analogously to what we did in section  [ concrete ] , only the first answer for the initial goal is considered .    in the following ,",
    "we let the boolean function @xmath273 return true when its argument is an atom rooted by a defined predicate symbol , and false otherwise ( i.e. , a built - in ) .",
    "moreover , for evaluating relational and arithmetic expressions , we assume a function @xmath274 such that , given an expression @xmath275 , @xmath276 either returns the evaluation of @xmath275 ( typically a number or a boolean value ) or the special constant @xmath277 when the expression is not instantiated enough to be evaluated .",
    "e.g. , @xmath278 , @xmath279 , but @xmath280 .",
    "the transitions rules are shown in figure  [ fig : concrete3 ] . in the following ,",
    "we briefly explain the novelties w.r.t",
    ".  the rules of section  [ concrete ] :    * in rule we use the notation @xmath281 $ ] to denote a copy of clause @xmath45 where the occurrences of ( possibly labeled ) cuts @xmath282 at predicate positions ( e.g. , not inside a ) , if any , are replaced by a _ labeled _ cut @xmath283 , where @xmath284 is a fresh label .",
    "also , in the derived state , we add a _ scope delimiter _ @xmath285 .",
    "* rule removes some alternatives from the current state , while rule applies when a goal reaches the scope delimiter without success .",
    "* the rules for and negation should be clear .",
    "let us only mention that the notation @xmath286 $ ] denotes the atom @xmath3 in which all variables @xmath219 on predicate positions are replaced by @xmath287 and all ( possibly labeled ) cuts on predicate positions are replaced by @xmath283 .",
    "* calls to the built - in predicate @xmath288 are dealt with rules and by means of the auxiliary function @xmath289 .",
    "rules and proceed analogously with relational operators like @xmath290 , @xmath291 , @xmath292 , etc .    ' '' ''    @xmath293\\![\\;}}\\mathsf{true}_{\\theta}\\mid s ' }             \\leadsto_\\diamond            \\tuple{{\\mbox{\\footnotesize \\textsc{success}}}_\\delta { \\mathit{\\;]\\![\\;}}{\\mbox{\\footnotesize \\textsc{success}}}_\\theta } }          } \\\\[3ex ]        \\mathsf{(failure ) } & { \\displaystyle         \\frac{~ }           { \\tuple{(\\mathsf{fail},\\cb)_\\delta            { \\mathit{\\;]\\![\\;}}(\\mathsf{fail},\\cb')_\\theta } \\leadsto_\\diamond           \\tuple{{\\mathsf{fail}}_\\delta { \\mathit{\\;]\\![\\;}}{\\mathsf{fail}}_\\theta } }          } \\\\[3ex ]        \\mathsf{(backtrack ) } & { \\displaystyle         \\frac{s\\neq\\epsilon }           { \\tuple{(\\mathsf{fail},\\cb)\\mid s { \\mathit{\\;]\\![\\;}}(\\mathsf{fail},\\cb')\\mid s ' } \\leadsto_\\diamond \\tuple{s{\\mathit{\\;]\\![\\;}}s ' } }          } \\\\[3ex ]         \\mathsf{(choice ) } &   { \\displaystyle         \\frac{\\mathsf{defined}(a ) \\wedge          { \\mathsf{clauses}}(a,\\cp ) = { \\overline{c_n}}\\wedge n>0 \\wedge m~\\mbox{is fresh }        \\wedge { \\mathsf{clauses}}(a',\\cp)={\\overline{d_k } } }           { \\begin{array}{l@{~}l }              \\tuple{(a,\\cb)_\\delta\\mid s { \\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta\\mid s ' } \\\\               \\hspace{15ex}\\leadsto_{c(\\ell({\\overline{c_n}}),\\ell({\\overline{d_k } } ) ) }             \\tuple{(a,\\cb)_\\delta^{c_1[!/!^m ] } \\mid \\ldots\\mid            ( a,\\cb)_\\delta^{c_n[!/!^m]}\\mid ~?^m_\\delta\\mid   s\\\\          \\hspace{33ex}{\\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta^{c_1[!/!^m ] } \\mid \\ldots\\mid            ( a',\\cb')_\\theta^{c_n[!/!^m]}\\mid ~?^m_\\theta\\mid   s '          } \\end{array } }          } \\\\[11ex ]        \\mathsf{(choice\\_fail ) } & { \\displaystyle         \\frac{\\mathsf{defined}(a,\\cp)\\wedge { \\mathsf{clauses}}(a,\\cp)={\\{\\}}\\wedge { \\mathsf{clauses}}(a',\\cp)={\\overline{c_k } } }           { \\tuple{(a,\\cb)_\\delta\\mid s { \\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta\\mid s ' }             \\leadsto_{c({\\{\\}},\\ell({\\overline{c_k } } ) ) }             \\tuple{({\\mathsf{fail}},\\cb)_\\delta\\mid s{\\mathit{\\;]\\![\\;}}({\\mathsf{fail}},\\cb')_\\theta\\mid s ' } }          } \\\\[4ex ]        \\mathsf{(unfold ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(a , h_1)=\\sigma\\wedge{\\mathsf{mgu}}(a',h_1)=\\sigma ' }           { \\tuple{(a,\\cb)_\\delta^{h_1\\leftarrow\\cb_1}\\mid s{\\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta^{h_1\\leftarrow\\cb_1}\\mid s ' }            \\leadsto_\\diamond \\tuple{(\\cb_1\\sigma,\\cb\\sigma)_{\\delta\\sigma}\\mid s            { \\mathit{\\;]\\![\\;}}(\\cb_1\\sigma',\\cb'\\sigma')_{\\theta\\sigma'}\\mid s ' } }          } \\\\[3ex ]        \\mathsf{(cut ) } & { \\displaystyle         \\frac{~ }           { \\tuple{(!^m,\\cb)_\\delta\\mid s_1\\mid ~?^m_{\\delta'}\\mid s            { \\mathit{\\;]\\![\\;}}(!^m,\\cb')_\\theta\\mid s'_1\\mid ~?^m_{\\theta'}\\mid s ' }            \\leadsto_\\diamond \\tuple{\\cb_{\\delta}\\mid~?^m_{\\delta'}\\mid s            { \\mathit{\\;]\\![\\;}}\\cb'_{\\theta}\\mid~?^m_{\\theta'}\\mid s ' } }          } \\\\[3ex ]        \\mathsf{(cut\\_fail ) } & { \\displaystyle         \\frac{~ }           { \\tuple{?^m_\\delta \\mid s{\\mathit{\\;]\\![\\;}}?^m_\\theta \\mid s ' }            \\leadsto_\\diamond \\tuple{\\mathsf{fail}_\\delta \\mid s{\\mathit{\\;]\\![\\;}}\\mathsf{fail}_\\theta \\mid s ' } }          } \\\\[3ex ]        \\mathsf{(call ) } & { \\displaystyle         \\frac{a\\not\\in\\cv\\wedge m~\\mbox{is fresh } }         { \\begin{array}{l }            \\tuple{(call(a),\\cb)_\\delta\\mid s          { \\mathit{\\;]\\![\\;}}(call(a'),\\cb')_\\theta\\mid s ' } \\\\",
    "\\hspace{10ex}\\leadsto_\\diamond            \\tuple{(a[\\cv/\\mathsf{call}(\\cv),!/!^m],\\cb)_{\\delta}\\mid ~?^m_{\\delta}\\mid s            { \\mathit{\\;]\\![\\;}}(a'[\\cv/\\mathsf{call}(\\cv),!/!^m],\\cb')_{\\theta}\\mid ~?^m_{\\theta}\\mid s ' }        \\end{array } }          } \\\\[6ex ]        \\mathsf{(call\\_error ) } & { \\displaystyle         \\frac{a\\in\\cv }           { \\tuple{(call(a),\\cb)_\\delta\\mid s { \\mathit{\\;]\\![\\;}}(call(a'),\\cb')_\\theta\\mid s ' }            \\leadsto_\\diamond            \\tuple{{\\mathsf{error}}_{\\delta}{\\mathit{\\;]\\![\\;}}{\\mathsf{error}}_{\\theta } } }          } \\\\[3ex ]        \\mathsf{(not ) } & { \\displaystyle         \\frac{m~\\mbox{is fresh } }           { \\begin{array}{l }              \\tuple{(\\backslash\\!\\!+\\!\\!(a),\\cb)_\\delta\\mid s            { \\mathit{\\;]\\![\\;}}(\\backslash\\!\\!+\\!\\!(a'),\\cb')_\\theta\\mid s ' } \\\\",
    "\\hspace{10ex}\\leadsto_\\diamond            \\tuple{(\\mathsf{call}(a),!^m,\\mathsf{fail})_{\\delta}\\mid \\cb_\\delta\\mid ~?^m_\\delta\\mid s            { \\mathit{\\;]\\![\\;}}(\\mathsf{call}(a'),!^m,\\mathsf{fail})_{\\theta}\\mid \\cb'_\\theta\\mid ~?^m_\\theta\\mid s ' }        \\end{array } }          } \\\\[6ex ]        \\mathsf{(unify ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(t_1,t_2)=\\sigma \\wedge { \\mathsf{mgu}}(t'_1,t'_2)=\\sigma ' }           { \\tuple{(t_1=t_2,\\cb)_\\delta\\mid s{\\mathit{\\;]\\![\\;}}(t'_1=t'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_{u(t'_1,t'_2 ) }            \\tuple{\\cb\\sigma_{\\delta\\sigma}\\mid s{\\mathit{\\;]\\![\\;}}\\cb'\\sigma'_{\\delta\\sigma'}\\mid s ' } }          } \\\\[3ex ]        \\mathsf{(unify\\_fail ) } & { \\displaystyle         \\frac{{\\mathsf{mgu}}(t_1,t_2)=\\mathsf{fail } }           { \\tuple{(t_1=t_2,\\cb)_\\delta\\mid s{\\mathit{\\;]\\![\\;}}(t'_1=t'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_{d(t'_1,t'_2 ) }            \\tuple{\\mathsf{fail}_{\\delta}\\mid s{\\mathit{\\;]\\![\\;}}\\mathsf{fail}_{\\theta}\\mid s '            } }          } \\\\[3ex ]        \\mathsf{(is ) } & { \\displaystyle         \\frac{\\mathsf{eval}(e_2 ) = t_2",
    "\\neq \\mathsf{error }        \\wedge \\mathsf{sym\\_eval}(e'_2 ) = t'_2\\wedge \\mbox{$x$ is fresh } }           { \\tuple{(t_1~\\mathsf{is}~e_2,\\cb)_\\delta\\mid s            { \\mathit{\\;]\\![\\;}}(t'_1~\\mathsf{is}~e'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_{is(x , t'_2 ) }            \\tuple{(t_1=t_2,\\cb)_\\delta\\mid ~ s{\\mathit{\\;]\\![\\;}}(t'_1=x,\\cb')_\\theta\\mid ~ s ' } }          } \\\\[3ex ]        \\mathsf{(is\\_error ) } & { \\displaystyle         \\frac{\\mathsf{eval}(e_2 ) = \\mathsf{error } }           { \\tuple{(t_1~\\mathsf{is}~e_2,\\cb)_\\delta\\mid s            { \\mathit{\\;]\\![\\;}}(t'_1~\\mathsf{is}~e'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_\\diamond            \\tuple{{\\mathsf{error}}_\\delta{\\mathit{\\;]\\![\\;}}{\\mathsf{error}}_\\theta } }          } \\\\[3ex ]        \\mathsf{(rel ) } & { \\displaystyle         \\frac{\\mathsf{eval}(t_1\\oplus t_2 ) = a \\in\\{\\mathsf{true},\\mathsf{fail}\\ }        \\wedge \\mathsf{sym\\_eval}(t'_1\\oplus t'_2 ) = a ' }         { \\tuple{(t_1~{\\oplus}~t_2,\\cb)_\\delta\\mid s{\\mathit{\\;]\\![\\;}}(t'_1~{\\oplus}~t'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_{r(a',a ) }            \\tuple{(a,\\cb)_\\delta\\mid ~ s{\\mathit{\\;]\\![\\;}}(a',\\cb')_\\theta\\mid ~ s ' } }          } \\\\[3ex ]        \\mathsf{(rel\\_error ) } & { \\displaystyle         \\frac{\\mathsf{eval}(t_1\\oplus t_2 ) = \\mathsf{error } }           { \\tuple{(t_1\\oplus t_2,\\cb)_\\delta\\mid s{\\mathit{\\;]\\![\\;}}(t'_1\\oplus t'_2,\\cb')_\\theta\\mid s ' }            \\leadsto_\\diamond            \\tuple{{\\mathsf{error}}_\\delta{\\mathit{\\;]\\![\\;}}{\\mathsf{error}}_\\theta } }          } \\\\[3ex ]        \\end{array}\\ ] ]    ' '' ''    regarding the concolic execution semantics , we follow a similar approach to that of section  [ concolic ] .",
    "the labeled transition rules can be seen in figure  [ fig : concolic3 ] .",
    "now , we consider six kinds of labels for @xmath49 :    * the labels @xmath50 and @xmath86 with the same meaning as in the concolic semantics of section  [ concolic ] . * the label @xmath294 , which is used to denote a unification step , i.e. , the step implies that @xmath295 and @xmath296 should unify . * in contrast , the label @xmath297 denotes a disunification , i.e. , the step implies that @xmath295 and @xmath296 should not unify . * the label @xmath298 denotes a step where @xmath288 is evaluated ( see below ) . *",
    "finally , the label @xmath299 denotes that the relational expression @xmath300 should be equal to @xmath301 .",
    "in particular , in rules and , the labels store the unification that must hold in the step .",
    "note that the fact that @xmath302 does not imply @xmath303 since @xmath304 and @xmath305 might be less instantiated than @xmath295 and @xmath296 .    in rule , we label the step with @xmath306 which means that the fresh variable @xmath219 should be bound to the evaluation of @xmath305 after grounding it .",
    "note that introducing such a fresh variable is required to avoid a failure in the subsequent step with rule because of , e.g. , a non - ground arithmetic expression that could not be evaluated yet to a value using function @xmath307 .",
    "note that rule does not include any label since we assume that an error in the concrete computation just aborts the execution and also the test case generation process .",
    "finally , in rule we label the step with @xmath299 where @xmath3 is the value @xmath308 of the relational expression in the concrete goal , and @xmath300 is a ( possibly nonground ) corresponding expression in the symbolic goal . here , we use the auxiliary function @xmath307 to simplify the relational expression as much as possible .",
    "e.g. , @xmath309 but @xmath310 .",
    "these labels can be used for extending the concolic testing algorithm of section  [ testing ] .",
    "for instance , given a concolic execution step labeled with @xmath311 , we have that solving @xmath312 will produce a binding for @xmath219 ( e.g. , @xmath313 ) that will follow an alternative path . here , the concolic testing procedure will integrate a constraint solver for producing solutions to negated constraints .",
    "we find this extension of the concolic testing procedure an interesting topic for future work .",
    "since the base case @xmath314 trivially holds , in the following we only consider the inductive case @xmath315 .",
    "let @xmath316\\![\\;}}\\cd^{c'}_\\theta{\\!\\mid\\!}s'}$ ] . by the inductive hypothesis",
    ", we have @xmath82 , @xmath83 , @xmath84 ( if any ) , and @xmath85 .",
    "now , we consider the step @xmath317 and distinguish the following cases , depending on the applied rule :    * if the rule applied is @xmath318 , @xmath319 , @xmath320 or @xmath321 , the claim follows trivially by induction . *",
    "if the rule applied is @xmath322 , let us assume that we have @xmath323 , @xmath324 and @xmath325 , @xmath326 .",
    "therefore , we have @xmath327\\![\\;}}\\cd^{c_1}_\\theta{\\!\\mid\\!}\\ldots{\\!\\mid\\!}\\cd^{c_j}_\\theta{\\!\\mid\\!}s'}$ ] , and the claim follows straightforwardly by the induction hypothesis . * finally , if the applied rule is @xmath328 , then we have that @xmath329 , @xmath330 for some clause @xmath331 . therefore",
    ", we have @xmath332\\![\\;}}(\\cb_1\\sigma',\\cd'\\sigma')_{\\theta\\sigma'}{\\!\\mid\\!}s'}$ ] , where @xmath333 and @xmath334 .",
    "first , @xmath84 holds by vacuity since the goals are not labeled with a clause . also , the number of concrete and symbolic goals is trivially the same since @xmath82 by the inductive hypothesis .",
    "now , by the inductive hypothesis , we have @xmath83 and thus @xmath335 and @xmath336 .",
    "then , since @xmath337 , @xmath338 , @xmath339 , and @xmath340 , it is easy to see that @xmath341 ( and thus @xmath342 ) and @xmath343 when restricted to the variables of @xmath344 ( and thus @xmath345 )",
    ". therefore , we can conclude @xmath346 . finally , using a similar argument",
    ", we have @xmath347 .",
    "first , we prove the following invariant which justifies that the algorithm in definition  [ alg1 ] is well defined .",
    "the following statement is an invariant of the loops at lines  [ algo - msa - while - simple ] and [ algo - msa - while - not - simple ] of the algorithm in definition  [ alg1 ] :    @xmath348 : :    \\(a ) @xmath97 for all @xmath349 and ( b )    @xmath350 for some @xmath351 .",
    "let us first consider the loop at line [ algo - msa - while - simple ] .",
    "clearly , the invariant holds upon initialization .",
    "therefore , let us assume that it holds for some arbitrary set @xmath10 and we prove it also holds for @xmath352 with @xmath213 for some simple disagreement pair @xmath207 ( or @xmath208 ) .",
    "let us consider part ( a ) . since @xmath97 for all @xmath353 , there exist a substitution @xmath18 such that @xmath354 for all @xmath353 .",
    "consider such an arbitrary @xmath353 .",
    "if @xmath355 , then part ( a ) of the invariant holds trivially in @xmath356 . otherwise , @xmath357 is clearly a unifier @xmath3 and @xmath218 , and it also holds .",
    "consider now part ( b ) . since @xmath350 for some @xmath351",
    ", there exists a substitution @xmath181 such that @xmath358 . using a similar argument as before , either @xmath358 with @xmath359 or @xmath360 with @xmath361 , and part ( b ) of",
    "the invariant also holds in @xmath356 .",
    "let us now consider the loop at line [ algo - msa - while - not - simple ] .",
    "clearly , the invariant holds when the previous loop terminates .",
    "let @xmath201 be the selected disagreement pair .",
    "then @xmath201 is replaced in @xmath10 by a fresh variable @xmath235 , thus obtainining a new set @xmath356 .",
    "let @xmath362 and @xmath363 . both @xmath364 and @xmath365 are idempotent substitutions because @xmath366 and @xmath367 since @xmath186 is fresh .",
    "let @xmath368 be the atoms of @xmath10 where @xmath201 come from and @xmath369 be the atoms obtained by replacing @xmath201 in @xmath368 by @xmath186 . then @xmath370 and @xmath371 .",
    "now , we want to prove that the invariant also holds in @xmath372 .",
    "part ( a ) is trivial , since we only generalize some atoms : if @xmath3 unify with @xmath373 and @xmath374 , it will also unify with @xmath375 and @xmath376 .",
    "regarding part ( b ) , we have that @xmath350 for some @xmath351 . clearly , part ( b ) also holds in @xmath356 if @xmath377 is different from @xmath373 and @xmath374 .",
    "otherwise , w.l.o.g .",
    ", assume that @xmath378 and @xmath379 .",
    "since @xmath380 and @xmath381 , and @xmath201 is a disagreement pair for @xmath368 , we have that the subterm of @xmath3 that corresponds to the position of @xmath201 should be more general than @xmath201 ( otherwise , it would not unify with both terms ) .",
    "therefore , replacing @xmath110 by a fresh variable @xmath186 will not change that , and we have @xmath382 for some @xmath383 .",
    "the following auxiliary results are useful to prove the correctness of the algorithms in definitions  [ alg1 ] and [ alg2 ] .",
    "[ lemma : technical-1 ] suppose that @xmath354 for some atoms @xmath3 and @xmath218 and some substitution @xmath18 .",
    "then we have @xmath384 for any substitution @xmath191 with @xmath385\\cap{\\mathit{dom}}(\\theta)={\\{\\}}$ ] and @xmath386 .    for any @xmath387 ,",
    "* either @xmath388 and then @xmath389 * or @xmath390 and then @xmath391 because @xmath392 .",
    "moreover , @xmath393 because @xmath385\\cap{\\mathit{dom}}(\\theta)={\\{\\}}$ ] , so @xmath394 . finally , @xmath389 .",
    "consequently , @xmath395 . as @xmath354 , we have @xmath396 i.e. @xmath384 .    [",
    "proposition : invariant - correction - algo - pos-1 ] the loop at line  [ algo - msa - while - simple ] always terminates and the following statement is an invariant of this loop .",
    "@xmath397 : :    for each @xmath398    there exists @xmath353 and a substitution    @xmath18 such that @xmath399 and    @xmath400 .",
    "action  ( [ algo - msa - simple - pair ] ) reduces the number of simple disagreement pairs in @xmath10 which implies termination of the loop at line  [ algo - msa - while - simple ] .",
    "let us prove that @xmath397 is an invariant .",
    "first , @xmath397 clearly holds upon initialization of @xmath10 .",
    "suppose it holds prior to an execution of action  ( [ algo - msa - simple - pair ] ) .",
    "therefore , for each @xmath398 there exists @xmath353 and a substitution @xmath18 such that @xmath399 and @xmath400 .",
    "let @xmath201 be the selected simple disagreement pair .",
    "then , we consider a substitution @xmath191 determined by @xmath201 .",
    "for any @xmath401 , we have @xmath402",
    ". thus @xmath393 by @xmath397 . hence @xmath403 .",
    "moreover , as @xmath201 is a simple pair we have @xmath404 .",
    "hence , @xmath405 since @xmath353 , we have @xmath385\\cap{\\mathit{dom}}(\\theta)={\\{\\}}$ ] .",
    "consequently , by  ( [ eq : ran - eta ] ) and lemma  [ lemma : technical-1 ] we have @xmath406 now , we want to prove that @xmath397 holds for @xmath212 , i.e. , that for each @xmath398 there exists @xmath407 and a substitution @xmath408 such that @xmath409 and @xmath410 .",
    "we let @xmath411 , so @xmath412 holds . now ,",
    "suppose by contradiction that @xmath413 , and let @xmath219 be one of its elements .",
    "we have @xmath388 because @xmath404 , so @xmath414",
    ". moreover , @xmath415 by  ( [ eq : ran - eta ] ) so @xmath402",
    ". therefore , @xmath416 which by @xmath397 gives a contradiction .",
    "consequently , @xmath417 and the claim follows .    [ proposition : invariant - correction - algo - pos-2 ] the loop at line  [ algo - msa - while - not - simple ] always terminates and the following statement is an invariant of this loop .",
    "@xmath418 : :    for each @xmath398    there exists @xmath353 and a substitution    @xmath18 such that @xmath399 and    @xmath419 .",
    "action  ( [ algo - msa - not - simple - pair ] ) reduces the number of disagreement pairs in @xmath10 which implies termination of the loop at line  [ algo - msa - while - not - simple ] .",
    "let us prove that @xmath418 is an invariant . by proposition  [ proposition : invariant - correction - algo - pos-1 ] , @xmath397 holds upon termination of the loop at line  [ algo - msa - while - simple ] , hence @xmath418 holds just before execution of the loop at line  [ algo - msa - while - not - simple ] .",
    "suppose it holds prior to an execution of action  ( [ algo - msa - not - simple - pair ] ) , so we have that , for each @xmath398 there exists @xmath353 and a substitution @xmath18 such that @xmath399 and @xmath420 .",
    "let @xmath201 be the selected disagreement pair .",
    "then @xmath201 is replaced in @xmath10 by a fresh variable @xmath235 , thus obtainining a new set @xmath356 .",
    "let @xmath362 and @xmath363 . both @xmath364 and @xmath365 are idempotent substitutions because @xmath366 and @xmath367 since @xmath186 is fresh .",
    "let @xmath368 be the atoms of @xmath10 where @xmath201 come from and @xmath369 be the atoms obtained by replacing @xmath201 in @xmath368 by @xmath186 . then @xmath370 and @xmath371 .",
    "now , we want to prove that @xmath418 holds in @xmath372 , i.e. , that for each @xmath398 there exists @xmath421 and a substitution @xmath18 such that @xmath399 and @xmath422 .",
    "since @xmath418 holds in @xmath10 , we have @xmath399 .",
    "moreover , @xmath423 because @xmath186 does not occur in @xmath300 .",
    "so if @xmath424 then @xmath425 and if @xmath426 then @xmath427 . consequently , let us set    * @xmath428 and @xmath429 if @xmath430 * @xmath431 and @xmath432 if @xmath424 * @xmath433 and @xmath434 if @xmath426",
    ".    then we have @xmath435 moreover , @xmath436 i.e. @xmath437 as @xmath438 then @xmath439 because @xmath440 by @xmath418 and @xmath441 and @xmath442 .",
    "moreover , by @xmath418 we have @xmath443 so by  ( [ eq : dom - theta - prime ] ) @xmath444 hence , @xmath445 . with  ( [ eq : a - unifies ] ) this implies that upon termination of action  ( [ algo - msa - not - simple - pair ] ) the invariant @xmath418 holds because @xmath373 is set to @xmath375 and @xmath374 to @xmath376 .",
    "the correctness of the algorithm in definition  [ alg1 ] is then stated as follows .",
    "[ theorem : correction - algo - pos ] let @xmath3 be an atom and @xmath178 be a set of atoms such that @xmath204 and @xmath97 for all @xmath205 .",
    "the algorithm in definition  [ alg1 ] with input @xmath3 and @xmath178 always terminates and returns a substitution @xmath18 such that @xmath266 unifies with all the atoms of @xmath178 for any idempotent substitution @xmath191 with @xmath242 and @xmath446 .",
    "proposition  [ proposition : invariant - correction - algo - pos-1 ] and proposition  [ proposition : invariant - correction - algo - pos-2 ] imply termination of the algorithm . upon termination of the loop at line",
    "[ algo - msa - while - not - simple ] we have @xmath237 .",
    "let @xmath218 be the element of @xmath10 with @xmath447 .",
    "now , we want to prove that @xmath266 unifies with all the atoms in @xmath178 for any idempotent substitution @xmath191 ( i.e. , @xmath448 ) such that @xmath449 and @xmath446 . by proposition  [ proposition : invariant - correction - algo - pos-2 ]",
    ", we have that , for all @xmath450 , there exists a substitution @xmath408 such that @xmath451 and @xmath452 . from all the previous conditions , it follows that @xmath453\\cap{\\mathit{dom}}(\\theta')={\\{\\}}$ ] and @xmath454 .",
    "therefore , by lemma  [ lemma : technical-1 ] , we have @xmath455 .",
    "finally , since @xmath447 , we have @xmath456 and , thus , @xmath266 unifies with @xmath377 .",
    "each step of the algorithm terminates , hence the algorithm terminates .",
    "assume that the algorithm returns a substitution @xmath181 .",
    "the set @xmath249 is ground by construction . by theorem  [ theorem : correction - algo - pos ]",
    ", we have that @xmath457 unifies with all the atoms in @xmath178 as long as @xmath191 is idempotent , @xmath242 and @xmath446 .",
    "finally , the last check ensures that @xmath458 does not unify with any atom of @xmath179 .      for simplicity",
    ", we ignore the groundness constraint in this section .",
    "therefore , we now focus on the completeness of the following unification problem : let @xmath3 be an atom and @xmath246 be sets of atoms such that @xmath97 for all @xmath247 . then",
    ", we want to find a substitution @xmath181 such that @xmath459 we further assume that all atoms are renamed apart .    let us first formalize the notion of unifying substitution :    let @xmath3 be an atom and let @xmath10 be a set of atoms such that @xmath460 and @xmath97 for all @xmath353 .",
    "we say that @xmath181 is a unifying substitution for @xmath3 w.r.t .",
    "@xmath10 if @xmath461 for all @xmath353 .",
    "in particular , we are interested in _ maximal _ unifying substitutions computed by the algorithm in definition  [ alg1 ] .",
    "the relevance of maximal unifying substitutions is that variables from @xmath184 identify where further instantiation would result in a substitution which is not a unifying substitution anymore . for the remaining positions",
    ", we basically return their most general unifier .",
    "now , we prove that binding an atom @xmath3 with a maximal unifying substitution for @xmath3 w.r.t .",
    "@xmath178 does not affect to the existence of a solution to our unification problem ( * * ) above . here , for simplicity , we assume that only _ most specific _ solutions are considered , where a solution @xmath181 is called a _ most specific _ solution for @xmath3 and @xmath246 if there exists no other solution which is strictly less general than @xmath181 .",
    "furthermore , we also assume that the atom @xmath3 has the form @xmath462 .",
    "let @xmath3 be an atom and @xmath246 be sets of atoms such that @xmath97 for all @xmath247 .",
    "if there exists a substitution @xmath181 such that @xmath461 for all @xmath205 and @xmath463 for all @xmath464 , then there exists a maximal unifying substitution @xmath18 and a substitution @xmath190 such that @xmath465 for all @xmath205 and @xmath466 for all @xmath464 .",
    "( _ sketch _ ) let us consider the stages of the algorithm in definition  [ alg1 ] with input @xmath178 ( atom @xmath3 is not needed since it has the form @xmath462 and , thus , imposes no constraint ) .",
    "the first stage just propagates simple disagreement pairs of the form @xmath207 or @xmath208 .",
    "when @xmath219 only occurs once , it is easy to see that @xmath181 is also a ( most specific ) unifying substitution for @xmath3 w.r.t .",
    "@xmath467 . consider , e.g. , that @xmath181 contains a binding of the form @xmath468 $ ] for some @xmath469 and context @xmath470 $ ] and such that @xmath196 corresponds to the same position of @xmath219 and @xmath110 in @xmath178 . depending on the terms in the corresponding position of the remaining atoms , we might have @xmath471 or @xmath472 .",
    "either case , replacing @xmath219 by @xmath110 will not change the fact that @xmath181 is still a most specific unifying substitution for @xmath467 .",
    "the step is more subtle when there are several simple disagreement pairs for a given variable , e.g. , @xmath473 and @xmath474 ( we could generalize it to an arbitrary number of pairs , but two are enough to illustrate how to proceed ) . in this case , if @xmath475 , we choose @xmath474 and the reasoning is analogous to the previous case .",
    "when neither @xmath475 not @xmath476 , the algorithm in definition  [ alg1 ] is non - deterministic and allows us to choose any of them . as before , let us consider that @xmath181 contains bindings of the form @xmath477 $ ] and @xmath478 $ ] for some @xmath479 and contexts @xmath470,c'[~]$ ] and such that @xmath304 and @xmath305 correspond to the same positions of @xmath295 and @xmath296 in @xmath178 , respectively . here",
    ", assuming there are no further constraints from the remaining atoms , a most specific unifying substitution might either bind @xmath480 to @xmath481 $ ] and leave @xmath482 unconstrained ( e.g. , bound to a fresh variable ) or the other way around : bind @xmath480 to @xmath483 $ ] and leave @xmath482 unconstrained . here , we choose the same alternative as in the considered solution @xmath181 ,",
    "say @xmath480 is bound to @xmath481 $ ] .",
    "therefore , @xmath181 is still a unifying substitution for @xmath3 w.r.t .",
    "note that the new ( non - simple ) disagreement pair @xmath485 introduced in @xmath484 will be generalized away in the next stage ( and replaced by a fresh variable from @xmath184 ) .",
    "therefore , when the first stage is completed ( i.e. , step 2 in definition  [ alg1 ] ) , we have propagated some terms from one atom to the remaining ones as in the computation of a most general unifier thus producing a new set @xmath486 such that @xmath181 is still a ( most specific ) unifying substitution for @xmath3 w.r.t . @xmath486 .    by definition , after this stage , there are no simple disagreement pairs in @xmath486 .",
    "then , in the second stage ( step 3 in definition  [ alg1 ] ) , we replace every ( non - simple ) disagreement pair @xmath485 by a fresh variable @xmath186 from @xmath184 .",
    "since @xmath181 was a unifying substitution for @xmath486 , it should have a binding @xmath487 $ ] for some @xmath469 and context @xmath470 $ ] and such that @xmath488 corresponds to the same position of @xmath295 and @xmath296 in @xmath486 , where @xmath488 is a variable .",
    "therefore , replacing @xmath201 by a fresh variable @xmath186 will not change the fact that @xmath181 is still a unifying substitution for the resulting set ( up to variable renaming ) .    hence , when the second stage is finished , we have a new set @xmath489 without any disagreement pair at all , i.e. , @xmath490 with @xmath447 .",
    "moreover , since @xmath181 is a most specific uniyfing substitution for @xmath3 w.r.t .",
    "@xmath489 , we have @xmath491 $ ] .",
    "therefore , there exists a substitution @xmath190 such that @xmath492 such that @xmath190 is a solution for @xmath183 and @xmath246 , which concludes the proof .",
    "let @xmath220 and @xmath493 .",
    "first the algorithm of definition  [ alg1 ] sets @xmath494 , then it considers the simple disagreement pairs in @xmath10 .",
    "the substitution @xmath495 is determined by @xmath496 .",
    "action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath497 i.e. to @xmath498 the substitution @xmath499 is determined by @xmath500 .",
    "action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath501 .",
    "the substitution @xmath502 is determined by @xmath503 .",
    "action  ( [ algo - msa - simple - pair ] ) sets @xmath10 to @xmath504 i.e. to @xmath505 now no simple disagreement pair occurs in @xmath10 hence the algorithm skips to the loop at line  [ algo - msa - while - not - simple ] .    * action  ( [ algo - msa - not - simple - pair ] ) replaces the disagreement pair @xmath506 with a fresh variable @xmath235 , hence @xmath10 is set to @xmath507 . *",
    "action  ( [ algo - msa - not - simple - pair ] ) replaces the disagreement pair @xmath508 with a fresh variable @xmath509 , hence @xmath10 is set to @xmath510 .",
    "note that there are several non - deterministic possibilities for @xmath364 , @xmath365 and @xmath512 .",
    "for instance , if we consider @xmath513 , which is determined by @xmath514 , then @xmath10 is set to @xmath515 .",
    "the loop at line  [ algo - msa - while - not - simple ] finally sets @xmath10 to @xmath516 , so the algorithm returns the substitution @xmath517 .",
    "let @xmath220 and @xmath519 .",
    "first the algorithm sets @xmath520 .",
    "then the loop at line  [ algo - msa - while - simple ] considers the simple disagreement pairs in @xmath10 and , for instance , it sets @xmath10 to @xmath521 ( it may also set @xmath10 to @xmath522 or to @xmath523 ) . as no simple disagreement pair now occurs in @xmath10 , the algorithm jumps at line  [ algo - msa - while - not - simple ] .",
    "the pair @xmath506 occurs twice in @xmath524 .",
    "action  ( [ algo - msa - not - simple - pair ] ) replaces each occurrence with the same variable @xmath525 , so the loop at line  [ algo - msa - while - not - simple ] sets @xmath10 to @xmath526 and the algorithm returns @xmath527 .",
    "let @xmath220 and @xmath528 .",
    "first the algorithm sets @xmath529 .",
    "then the loop at line  [ algo - msa - while - simple ] considers the simple disagreement pairs in @xmath10 and , for instance , it sets @xmath10 to @xmath530 ( it may also set @xmath10 to @xmath531 or to @xmath532 ) . as no simple disagreement pair now occurs in @xmath10 , the algorithm jumps at line  [ algo - msa - while - not - simple ] .",
    "the pairs @xmath506 and @xmath234 occur once in @xmath524 and action  ( [ algo - msa - not - simple - pair ] ) replaces them with two different variables @xmath533 . so the loop at line  [ algo - msa - while - not - simple ] sets @xmath10 to @xmath534 and the algorithm returns @xmath535 ."
  ],
  "abstract_text": [
    "<S> software testing is one of the most popular validation techniques in the software industry . surprisingly </S>",
    "<S> , we can only find a few approaches to testing in the context of logic programming . in this paper </S>",
    "<S> , we introduce a systematic approach for dynamic testing that combines both concrete and symbolic execution . </S>",
    "<S> our approach is fully automatic and guarantees full path coverage when it terminates . </S>",
    "<S> we prove some basic properties of our technique and illustrate its practical usefulness through a prototype implementation . </S>",
    "<S> + _ to appear in theory and practice of logic programming ( tplp ) , proc .  of iclp 2015 . _ </S>",
    "<S> +    [ firstpage ]    symbolic execution , logic programming , testing . </S>"
  ]
}