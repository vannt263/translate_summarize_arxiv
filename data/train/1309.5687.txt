{
  "article_text": [
    "finding the shortest paths between pairs of vertices in a graph is one of the most extensively studied problems in algorithms research .",
    "the shortest paths problem is often categorized into the single source shortest paths ( sssp ) problem , which is to compute the shortest paths between one source vertex to all other vertices in the graph , and the all pairs shortest paths ( apsp ) problem , which is to compute the shortest paths between all possible pairs of vertices on the graph .",
    "arguably the most famous algorithm for the apsp problem is floyd s algorithm that runs in @xmath6 time .",
    "there have been many attempts at providing sub - cubic time bounds for solving the apsp problem on dense graphs with real edge costs @xcite , all achieving time improvements by logarithmic factors .",
    "the current best time bound is @xmath7 by han and takaoka @xcite .",
    "if the graph has integer edge costs , faster matrix multiplication over a ring @xcite can be utilized to achieve deeply sub - cubic time bounds .",
    "alon , galil and margalit achieved @xmath8 time bound for solving the apsp problem on directed unweighted graphs , where @xmath9 is the time bound on multiplying two @xmath1-by-@xmath1 matrices over a ring @xcite .",
    "this time complexity translates to @xmath10 with @xmath11 @xcite . the best time bound for this problem",
    "is currently @xmath12 by zwick @xcite , thanks to le gall s recent achievement in rectangular matrix multiplication @xcite .",
    "another well studied problem in graph theory is finding the maximum bottleneck between pairs of vertices .",
    "the bottleneck of a path is the minimum capacity of all edges on the path .",
    "the problem of finding the paths that give the maximum bottlenecks for all pairs of vertices is formally known as the all pairs bottleneck paths ( apbp ) problem .",
    "vassilevska , williams and yuster achieved @xmath13 time bound for solving the apbp problem on graphs with real edge capacities @xcite , and this has subsequently been improved to @xmath14 by duan and pettie @xcite .",
    "let us consider a path that gives us the bottleneck value of @xmath15 from vertex @xmath16 to vertex @xmath17 .",
    "in other words , we can push flows of amounts up to @xmath15 from @xmath16 to @xmath17 using this path . if the flow demand from @xmath16 to @xmath17 is less than @xmath15 , however , there may be a shorter path .",
    "this information is useful if we wish to minimize the path cost ( distance ) for varying flow demands .",
    "thus we combine the two well known apsp and apbp problems and compute the shortest paths for all pairs for all possible flow demands .",
    "we call this new problem the all pairs shortest paths for all flows ( apsp - af ) problem .",
    "note that this is different from the all pairs bottleneck shortest paths ( apbsp ) problem @xcite , which is to compute the bottlenecks of the shortest paths for all pairs .",
    "there are obvious practical applications for the apsp - af problem in any form of network analysis , such as computer networks , transportation and logistics , etc .",
    "in this paper we present two algorithms for solving the apsp - af problem on directed graphs with positive integer edge costs and real edge capacities .",
    "firstly we present an algorithm to solve the problem on graphs with unit edge costs in @xmath18 time , where @xmath2 is the number of distinct edge capacities .",
    "we then extend this algorithm to solve the problem on graphs with positive integer edge costs of at most @xmath5 in @xmath19 time , which is reduced to the complexity of the first algorithm when @xmath20 .",
    "let @xmath21 be a directed graph with non - negative integer edge costs and real edge capacities .",
    "let @xmath22 and @xmath23 .",
    "vertices ( or nodes ) are given by integers such that @xmath24 .",
    "let @xmath25 denote the edge from vertex @xmath26 to vertex @xmath27 .",
    "let @xmath28 denote the cost and @xmath29 denote the capacity of the edge @xmath25 .",
    "let @xmath2 be the number of distinct @xmath29 , and let @xmath5 be the upper bound on @xmath29 .",
    "we define path _ length _ as the number of edges on the path , irrespective of their costs or capacities .",
    "we define path _ cost _ or _ distance _ as the sum of all edge costs on the path .",
    "we represent @xmath30 in a series of matrices .",
    "let @xmath31 be the reachability matrix , for @xmath32 , where @xmath33 if @xmath27 is reachable from @xmath26 via some path of length up to @xmath34 and @xmath35 otherwise .",
    "@xmath36 for all @xmath34 .",
    "@xmath37 if an edge exists from @xmath26 to @xmath27 , and 0 otherwise .",
    "@xmath38 is called the adjacency matrix of @xmath30 .",
    "let @xmath39 be the capacity matrix , where @xmath40 represents the maximum possible capacity ( or bottleneck ) from @xmath26 to @xmath27 via any paths of lengths up to @xmath34 .",
    "@xmath41 for all @xmath34 .",
    "@xmath42 if there is an edge from @xmath26 to @xmath27 , and 0 otherwise .",
    "let @xmath43 be the distance matrix , where @xmath44 represents the shortest possible distance from @xmath26 to @xmath27 via any paths of lengths up to @xmath34 .",
    "@xmath45 for all @xmath34 .",
    "@xmath46 if there is an edge from @xmath26 to @xmath27 , and @xmath47 otherwise .",
    "let @xmath48 denote the @xmath49-product and @xmath50 denote the @xmath51-product of the two matrices @xmath52 and @xmath53 , where : @xmath54 clearly the @xmath49-product is applicable to the distance matrix whereas the @xmath51-product is applicable to the capacity matrix .",
    "our algorithm for solving the apsp - af problem is largely based on the algorithm given by alon _",
    "therefore we provide a review of this algorithm using the same set of terminologies as an earlier review of the same algorithm by takaoka @xcite .",
    "the algorithm under review computes the all pairs shortest distances ( apsd ) on directed graphs with unit edge costs . in summary this algorithm achieves sub - cubic time bound by utilizing faster matrix multiplication over a ring to perform boolean matrix multiplication , and also using the novel idea of _ bridging sets_.     @xmath33 and @xmath55  @xmath56  @xmath57  @xmath58    algorithm [ alg : agm ] consists of two phases .",
    "we refer to the first part of the algorithm as the _ acceleration phase _ , and the second part of the algorithm as the _ cruising phase_. the acceleration phase repeatedly performs boolean matrix multiplication with the adjacency matrix to compute apsd for all pairs with distances up to @xmath59 , where @xmath60 is a constant such that @xmath61 .",
    "clearly this only works on graphs with unit edge costs where the path length and the path cost are equivalent .",
    "the algorithm then switches to the cruising phase where the ordinary multiplication method is used with the help of bridging sets , @xmath62 , where @xmath62 is a set of `` via '' vertices for all rows @xmath26 of the distance matrix @xmath63 .",
    "that is , when computing @xmath64 for the @xmath49-product , we inspect only the set of vertices in @xmath62 for @xmath65 rather than inspecting all @xmath66 elements .",
    "_ have shown that with path lengths equal to @xmath60 , the size of the bridging set @xmath62 for each row @xmath26 is bounded by @xmath67 @xcite .",
    "hence we start the cruising phase with @xmath68 for each row @xmath26 .",
    "the acceleration phase takes @xmath69 time , and the cruising phase performs repeated squaring of the distance matrix in @xmath70 time .",
    "et al . _ chose to increase the path length by a factor of @xmath71 in each iteration of the cruising phase .",
    "this factor of @xmath71 is somewhat arbitrary , as any factor greater than @xmath72 and less than @xmath73 can be used . because the size of the bridging set decreases by a constant factor in each iteration , we end up with a geometric series if we add up the time complexities of each iteration , and hence the first squaring dominates the time complexity .",
    "the total time complexity of @xmath74 of this algorithm comes from balancing the time complexities of the two phases to retrieve the best value for @xmath60 , that is , setting @xmath75 then solving for @xmath60 .",
    "we first consider solving the all pairs shortest distances for all flows ( apsd - af ) problem on directed graphs with unit edge costs , that is , computing only the shortest distances rather than actual path .",
    "path lengths and path distances are used interchangeably in this section .",
    "to re - iterate the apsd - af problem , for each pair of vertices @xmath25 for each possible flow amount , we want to compute the shortest distance .",
    "thus our aim here is to obtain a set of @xmath76 pairs for all pairs of vertices , where @xmath77 is the maximum flow amount that can be pushed through the shortest path whose length ( distance ) is @xmath78 .",
    "we refer to the distinct capacity values as _",
    "maximal flows_. i.e. there are @xmath2 maximal flows .",
    "assume that the maximal flows are sorted in increasing order .",
    "if we wish to push @xmath77 such that @xmath79 for consecutive maximal flows @xmath80 and @xmath81 , then clearly @xmath77 is represented by @xmath81 .",
    "let @xmath82 be a matrix such that @xmath83 is a set of @xmath76 pairs as described above .",
    "let both @xmath76 and @xmath84 be in @xmath83 such that @xmath85 .",
    "we keep @xmath84 _ iff _ @xmath86 . in other words ,",
    "a longer path is only useful to us if it can accommodate a greater flow . if @xmath87 , we keep the pair that provides the bigger flow .",
    "since there can only be @xmath88 different values of @xmath78 , each @xmath83 has at most @xmath88 pairs of @xmath89 .",
    "we assume the pairs are sorted in ascending order of @xmath78 .",
    "we make an interesting observation here that once all @xmath76 pairs for all @xmath83 are computed ( i.e. the apsp - af problem is solved ) , the first pairs for all @xmath83 is the solution to the apbsp problem , and the last pairs for all @xmath83 is the solution to the apbp problem .",
    "if the graph in figure [ fig : graph ] had unit edge costs instead of the varying integer edge costs , solving apsd - af on the graph would result in three @xmath76 pairs from vertex 1 to vertex 6 , that is , @xmath90 .",
    "we now introduce algorithm [ alg : apsdaf ] to solve the apsd - af problem on directed graphs with unit edge costs .",
    "let @xmath91 be the approximate distance matrix for shortest paths that can accommodate flows up to @xmath77 . in the acceleration phase ,",
    "we compute the maximum bottleneck values for all possible path lengths up to @xmath60 for all pairs , where @xmath60 is a constant such that @xmath61 .",
    "then from the results gathered in the acceleration phase , we prepare a series of distance matrices , @xmath91 , one for each maximal flow value @xmath77 , and move onto the cruising phase where we compute the shortest distances for all pairs for all flows by repeatedly squaring each @xmath91 .    / * @xmath92 is empty * /    algorithm [ alg : apsdaf ] correctly solves apsd - af on directed graphs with unit edge costs .    in the acceleration phase , instead of performing boolean matrix multiplication as in algorithm [ alg : agm ] ,",
    "we compute the @xmath51-product with the capacity matrices @xmath93 and @xmath94 .",
    "after each matrix multiplication , if a path of greater capacity has been found for the vertex pair @xmath25 , we append the pair @xmath95 to @xmath83 since we have found a longer path that can accommodate a greater flow .",
    "thus after the @xmath96 iteration of the acceleration phase , all relevant @xmath76 pairs for all @xmath83 are found such that @xmath97 .",
    "after the acceleration phase we initialize the approximate distance matrices @xmath91 from @xmath82 , one matrix for each maximal flow @xmath77 , in preparation for the cruising phase .",
    "note that if the @xmath76 pair for a given flow value @xmath77 does not exist in @xmath83 , we take the next pair @xmath84 in @xmath83 ( if one exists ) and let @xmath98 .    at this stage , if @xmath99 , @xmath100 is already the length of the shortest path from @xmath26 to @xmath27 that can push flow @xmath77 .",
    "thus the actual aim of the cruising phase of this algorithm is to compute the shortest distance for all other elements in @xmath91 such that @xmath101 at the start of the cruising phase . note",
    "that unless @xmath30 is strongly connected , some elements of @xmath91 will remain at @xmath47 until the end of the algorithm .",
    "the aim of the cruising phase is achieved by repeatedly squaring each @xmath91 with the help of the bridging set , as proven in @xcite .",
    "retrieving sets of @xmath76 pairs after the cruising phase from each resulting @xmath91 is simply a reverse process of the initialization for the cruising phase , and thus our search for all sets of @xmath76 pairs for all @xmath25 is complete after finalization .",
    "algorithm [ alg : apsdaf ] runs in @xmath18 worst case time .    for the acceleration phase we use the the current best known algorithm to compute the @xmath51-product in each iteration , which gives us the time bound of @xmath102 @xcite .",
    "the time complexity for the cruising phase is @xmath103 since there are a total of @xmath2 maximal flows , each taking @xmath104 time to finish the computation of apsd .",
    "the time bound for the initialization for the cruising phase and the finalization is @xmath105 , which is absorbed by @xmath103 since @xmath106 .",
    "we balance the time complexities of the acceleration phase and the cruising phase by setting @xmath107 , and this gives us the total worst case time complexity of @xmath108 .    if @xmath109 , the value we choose for @xmath60 may exceed @xmath1 . in such a case",
    ", we simply stay in the acceleration phase until @xmath110 .",
    "thus a more accurate worst case time complexity of algorithm [ alg : apsdaf ] is actually @xmath111 .    a straightforward method of solving the apsd - af problem is to repeatedly compute apsd for each maximal flow value @xmath77 using only edges that have capacities greater than or equal to @xmath77",
    "this method is equivalent to starting the cruising phase at @xmath112 , giving us the time complexity of @xmath113 if we use zwick s algorithm to solve apsd for each maximal flow value @xcite . for @xmath114 , algorithm",
    "[ alg : apsdaf ] is faster .",
    "note that a simple decremental algorithm where edges are removed in the reverse order of capacities while repeatedly solving apsd can not be used to solve the apsd - af problem because edges with larger capacities may later be required to provide shorter paths for a smaller maximal flow values .",
    "[ the : apsdaf ] there exists an algorithm that can solve apsp - af on directed graphs with uni edge costs in @xmath115 worst case time .",
    "as noted earlier there can be @xmath66 @xmath76 pairs for each vertex pair @xmath25 .",
    "since the lengths of each path can be @xmath66 , explicitly listing all paths takes @xmath116 time .",
    "we get around this by modifying algorithm [ alg : apsdaf ] to extend the @xmath76 pair to the @xmath117 triplet , where @xmath118 is the _ successor _ node , such that retrieving the actual path from @xmath117 can be performed by simply following the successor nodes . in the acceleration phase witnesses for the @xmath51-product",
    "can be retrieved with an extra polylog factor @xcite , and the successor nodes can be computed from the witnesses in each iteration in @xmath119 time @xcite . in the cruising phase retrieving the witnesses , and hence the successor nodes , is a simple exercise since ordinary matrix multiplication is performed . therefore extending @xmath76",
    "to @xmath117 only takes an additional polylog factor .",
    "the explicit path for a given flow demand from @xmath26 to @xmath27 can be generated in time linear to the path length as follows .",
    "firstly we perform binary search for the triplet @xmath117 in @xmath83 with @xmath77 as the key to find the minimum distance @xmath78 such that @xmath77 is greater than or equal to the given flow requirement .",
    "we then traverse the successor nodes @xmath118 one by one , using @xmath78 to look up each subsequent successor node in @xmath120 time .",
    "we now consider solving the apsd - af problem on directed graphs with integer edge costs and real edge capacities , where the edge cost is bounded by @xmath5 .",
    "note that with integer edge costs we need to make a clear distinction between path lengths and distances .",
    "one approach for solving this problem is to use the method described in @xcite to replace @xmath30 with an expanded graph @xmath121 such that all edges in @xmath121 have unit edge costs , then applying the algorithm on @xmath121 to solve the problem on @xmath30 .",
    "@xmath121 is created by attaching a chain of @xmath122 artificial vertices to each real vertex such that the artificial edges linking the artificial vertices in each chain have unit edge costs and capacities of @xmath47 .",
    "we then replace each real edge @xmath25 with an artificial edge with unit edge cost and capacity of @xmath29 by choosing one of the artificial vertices of @xmath26 ( or @xmath26 itself ) as the source vertex and the real vertex @xmath27 as the destination , such that there exists a path from @xmath26 to @xmath27 with length equal to @xmath28 .",
    "see figure [ fig : g_prime ] for an illustration of how a graph is expanded . the expanded graph @xmath121 has @xmath123 vertices , and we can clearly solve apsd - af on @xmath30 by solving apsd - af on @xmath121 in @xmath124 time .",
    "we can do better , however , with the key observation that only the acceleration phase of algorithm [ alg : apsdaf ] is restricted to graphs with unit edge costs . in other words , we can complete the acceleration phase on the expanded graph @xmath121 , gather the intermediate results , and then finish off the remaining computation after contracting the graph back to @xmath30 .",
    "we need care here , as the path lengths in @xmath121 are actually equivalent to the path costs in @xmath30 , and the bridging sets in the cruising phase are determined from the path lengths rather than the path costs",
    ". therefore we need to make substantial changes to algorithm [ alg : apsdaf ] to keep track of both the path lengths and the path costs of @xmath30 in the acceleration phase , as well as modifying the cruising phase to correctly use the path lengths of @xmath30 in determining the bridging sets .",
    "firstly we extend the pair @xmath76 to the triplet @xmath126 , where @xmath127 is the path length in @xmath30 , @xmath78 is the path cost in @xmath30 ( i.e. the path length in @xmath121 ) and @xmath77 is the maximal flow .",
    "we introduce @xmath128 where @xmath129 is a set of triplets",
    "@xmath126 for all pairs of vertices in @xmath121 .",
    "we omit the superscript @xmath34 that denotes the path length in the following matrix definitions .",
    "let @xmath130 be the capacity matrix of @xmath121 and let @xmath131 be the witness matrix for the @xmath51-product .",
    "let @xmath132 such that @xmath133 is the length of the path that gives the path cost ( distance ) of @xmath100 , where @xmath134 is the distance matrix as defined in section [ sec : apspaf ] .",
    "that is , @xmath100 is the minimum path cost ( distance ) of all paths from @xmath26 to @xmath27 that can push flow of amount @xmath77 .",
    "note that @xmath127 in the triplet @xmath126 is no longer required once all @xmath135 are initialized before the start of the cruising phase .",
    "we start by creating @xmath121 from @xmath30 then proceed to the acceleration phase .",
    "we only need to show that the actual path length @xmath127 in the triplet @xmath126 is correctly determined , since we have already discussed the @xmath76 pairs in section [ sec : apspaf ] .",
    "what is effectively happening in the acceleration phase of algorithm [ alg : apsdaf2 ] is that the path length information is carried from one real vertex to the next real vertex by the artificial vertices in between .",
    "since we are multiplying by @xmath140 in each iteration , the witness @xmath141 will always be the vertex that comes straight before the destination vertex @xmath27 on the path from @xmath26 to @xmath27 .",
    "that is , it is not possible for any vertices ( real or artificial ) to exist between @xmath142 and @xmath27 .",
    "therefore we retrieve the last @xmath126 triplet from @xmath143 and increment the given @xmath127 _ iff _",
    "@xmath27 is a real vertex .",
    "thus the correct path length in @xmath30 is given by @xmath127 at the end of the acceleration phase since we are not counting the artificial vertices in the path .",
    "the changes made to the cruising phase is to ensure that the bridging sets @xmath62 is correctly determined from the path lengths rather than the path costs .",
    "note that in algorithm [ alg : apsdaf ] this distinction was unnecessary because we were only considering graphs with unit edge costs .",
    "clearly the correctness of the crusing phase remains intact by keeping @xmath144 updated alongside @xmath145 .",
    "the time complexity of the acceleration phase is @xmath146 since there are @xmath123 vertices in @xmath121 . after the @xmath96 iteration in the acceleration phase ,",
    "we have computed the bottleneck for all paths of lengths up to @xmath60 , but this is path lengths in the expanded graph @xmath121 , and not @xmath30 .",
    "we divide @xmath60 by @xmath5 to retrieve the lower bound on the path lengths in the original graph @xmath30 after the acceleration phase .",
    "therefore the time complexity of the cruising phase is @xmath147 .",
    "both the time complexities for initialization for cruising phase and finalization are again absorbed by the time complexity of the cruising phase .",
    "we balance the time complexities of the acceleration phase and the cruising phase by setting @xmath148 , which gives us the total worst case time complexity of @xmath149 .",
    "clearly we can take a similar approach to the method described in the proof of theorem [ the : apsdaf ] .",
    "we can still use the path cost ( distance ) to look up each successor node in @xmath120 time .",
    "we note that the witnesses in the acceleration phase can be artificial vertices , but the corresponding real vertices can be retrieved in @xmath120 time simply by storing this information when @xmath30 is expanded to @xmath121 .",
    "if @xmath20 , @xmath149 becomes @xmath150 , hence we have successfully generalized the apsp - af problem from graphs with unit edge costs to graphs with integer edge costs . to compare with the straightforward method of repeatedly solving the apsp problem for each maximal flow value using zwick s algorithm",
    ", we use the formula @xmath151 where @xmath152 is the time taken to multiply an @xmath1-by-@xmath153 matrix with an @xmath153-by-@xmath1 matrix , and @xmath154 is a constant such that multiplying an @xmath1-by-@xmath155 matrix with an @xmath155-by-@xmath1 remains within the @xmath156 time bound .",
    "we let @xmath157 and @xmath158 in this comparison @xcite .",
    "the time complexity of the straightforward method becomes @xmath159 , where @xmath160 such that the equation @xmath161 is satisfied . with @xmath109 , algorithm [ alg : apsdaf2 ] is faster for @xmath162 .",
    "finally we make a note that the idea of expanding the graph to @xmath121 for the acceleration phase then contracting it back to @xmath30 for the cruising phase can retrospectively be applied to algorithm [ alg : agm ] to give a sharper time bound than @xmath163 , which is the time bound given by alon _",
    "_ in their original paper @xcite .",
    "the time bound of @xmath163 is sub - cubic for @xmath164 . using our new approach of contracting the graph after the acceleration phase , the time bound",
    "can be improved to @xmath165 , which is sub - cubic for @xmath166 . for solving the same problem as algorithm [ alg : agm ] ,",
    "however , other algorithms are already known that remain sub - cubic for larger values of @xmath5 @xcite .",
    "the key achievements of this paper are : 1 ) the introduction of a new problem that clearly has numerous practical applications in network analysis involving both path costs and capacities , 2 ) non - trivial extension of algorithm [ alg : agm ] to solve the new problem that is more complex than the apsp problem , and 3 ) a better method to utilize the artificial graph for integer edge costs resulting in an improved time bound for not only our new algorithm , but also an existing algorithm for solving the apsp problem .    solving the new apsp - af problem on other types of graphs ( e.g. undirected , real edge costs , etc ) as well as finding efficient algorithms for the single source version of the problem remain on the agenda for future research ."
  ],
  "abstract_text": [
    "<S> we introduce a new problem that combines the well known all pairs shortest paths ( apsp ) problem and the all pairs bottleneck paths ( apbp ) problem to compute the shortest paths for all pairs of vertices for all possible flow amounts . </S>",
    "<S> we call this new problem the all pairs shortest paths for all flows ( apsp - af ) problem . </S>",
    "<S> we firstly solve the apsp - af problem on directed graphs with unit edge costs and real edge capacities in @xmath0 time , where @xmath1 is the number of vertices , @xmath2 is the number of distinct edge capacities ( flow amounts ) and @xmath3 is the time taken to multiply two @xmath1-by-@xmath1 matrices over a ring . secondly we extend the problem to graphs with positive integer edge costs and present an algorithm with @xmath4 worst case time complexity , where @xmath5 is the upper bound on edge costs . </S>"
  ]
}