{
  "article_text": [
    "pile - up ( pu ) represents a challenge for hep event reconstruction , both in terms of physics performance and in terms of processing time .",
    "in fact , for pu values exceeding 100 , as expected at the high luminosity lhc ( hl - lhc ) , the time needed for event reconstruction diverges ( fig .",
    "[ reco - time - pu ] ) ; due to power density limitations to moore s law , such a large increase is not sufficiently compensated by an increase in cpu clock frequency . for this reason ,",
    "the reconstruction model currently used is most hep experiments , based on traditional computers both for offline and online processing , can not be sustained at hl - lhc without compromises between timing and physics performance that will impact the final sensitivity of the experiments .    as a solution to this problem",
    "we investigate a transition to highly parallel computing architectures such as e.g. intel s xeon phi and nvidia gpgpus .",
    "the challenge in this context is that , due to distinct features of these architectures , a simple porting of the current , serial , implementation of the algorithms would be highly suboptimal : code and data - structures need to be redesigned with a strong emphasis on hardware capabilities and limitations .",
    "we initially focus our study on the xeon phi architecture .",
    "the main reason for this choice is that it shares many features with more conventional architectures , like the intel xeon , so that we can optimize and test the algorithm performance on both architectures at the same time ; however , there is no real prejudice on the choice of the architectures and in the future we plan to explore also other options , including gpgpus .",
    "xeon phi coprocessors are characterized by 60 cores running up to 4 threads each and featuring 512-bit wide vector units ; thus , in order to achieve optimal performance all cores must be kept occupied , usage of vector units must be maximized , and code branching must be minimized .",
    "we tackle the problem starting from the the most challenging algorithm , track reconstruction ; tracking is by far the most time consuming process in event reconstruction ( fig .",
    "[ reco - time - pu ] ) so that , if the proposed approach does not work in this case , there is little to gain from the rest of event reconstruction .",
    "other algorithms , such as vertexing , jet clustering and so on will be studied at a later stage .",
    "the present report describes the result of early studies and outlines the next steps of the project .",
    "timing vs luminosity for @xmath0+pu samples with 25 ns bunch crossing .",
    "samples with different average pile - up are used as reported on the plot .",
    "shown is timing of full cms reconstruction and of the iterative tracking sequence  @xcite . ]",
    "below is a brief summary of the test setup and of previous results ; a more detailed description can be found in  @xcite .    in order to study the problem with maximum flexibility and with gradually increasing complexity",
    ", we developed a standalone tracking code based on kalman filter and running on a simplified setup consisting of an ideal barrel geometry , a uniform and longitudinal magnetic field , gaussian - smeared hit positions , a particle gun simulation with flat transverse momentum distribution between 0.5 and 10 gev , no material interaction and no correlation between particles nor decays .",
    "the track reconstruction process can be divided in 3 steps : track seeding , building and fitting .",
    "the track fit is the simple application of the kalman filter to a pre - determined set of hits , so it was a natural choice as a starting point .",
    "it is implemented using matriplex , a library for vectorized matrix operations we developed .",
    "matriplex is a matrix - major representation , where vector units elements are separately filled by the same element from different matrices ; in other terms , @xmath1 matrices - and thus @xmath1 tracks - work in sync so that vectorization is used as an additional resource for parallelism .",
    "the track fit using matriplex gives same physics results and , even in serial case , it is faster than an equivalent version based on smatrix .",
    "we tested the track fit both on intel xeon and xeon phi ( native application ) with openmp , obtaining similar qualitative results .",
    "we observed a large speedup both from vectorization ( 4x/8x on xeon / xeon phi ) and parallelization ( 10x/80x ) .",
    "the effective utilization efficiency of vector units is about 50% ; time scaling is close to ideal in case of 1 thread / core , while there is some overhead with 2 threads / core .",
    "main performance limitations are related to data availability in l1 cache and data re - packing in matriplex format .    as steps",
    "forward , we followed two distinct lines of development . on the one side we consolidated the track fitting results , identifying the performance bottlenecks to vectorization and progressing towards a fully realistic setup . on the other side",
    ", we tackled the most time consuming part of the track reconstruction algorithm , redesigning the track building in order to exploit vectorization and parallelization .",
    "a detailed profiling of the code showed that the relative fraction of time used for data input is large with respect to total fit time , where input refers both to data transfer to l1 cache and re - packing into matriplex format .",
    "figure  [ vectorize - data - input ] compares the time spent for data input using different methods to the actual fit time with xeon phi on a single - threaded execution using the vector units to the extent possible .",
    "we explored different approaches ( methods 1 - 3 ) and different intrinsics ( 4 - 6 ) , either with a direct copy approach ( 1 and 6 ) or with a two - stage copy using temporaries ( 2 - 5 ) , resulting in substantially different performance .",
    "the best method ( # 4 ) relies on two - stage copy and employs the vgather intrinsic .",
    "scatter data into matriplexes , track by track , using simple for - loops + 2 .",
    "copy 16 tracks into contiguous memory , transpose into matriplexes via loops + 3 .",
    "copy 16 tracks into memory , use intel mkl to transpose each mplex + 4 . copy 16 tracks into memory , vgather into matriplexes by rows + 5 .",
    "copy 16 tracks into memory by rows , vscatter into matriplexes + 6 .",
    "scatter data into matriplexes , track by track , using intel intrinsics ]    we also made significant progress towards the larger goal of implementing an end - to - end tracking chain in a realistic simulation , with track fitting as the final step .",
    "our initially simple setup was designed to allow increases in complexity , so we can add more realistic features in an incremental way .",
    "in particular , we included a more realistic detector description implementing different barrel - like layouts by using the usolids geometry package  @xcite .",
    "such changes are transparent to the actual fitting code since the track parameters are propagated to the radius of the next hit in global coordinates .",
    "we verified that the timing and physics performance of the track fit are not affected ( fig .",
    "[ ptpull - cylindrical ] and [ ptpull - polyhedric ] ) .",
    "further improvements include the options to account for the effects of multiple scattering in the simulation and , instead of fitting the track hits as obtained from the simulation , to fit the tracks returned by the track building .",
    "pull of the track transverse momentum using an barrel geometry composed of polyhedral layers . ]",
    "pull of the track transverse momentum using an barrel geometry composed of polyhedral layers . ]",
    "the track building is the part of the track reconstruction process that , starting from a proto - track made of a 2 - 3 hits ( the seed ) , identifies all other hits belonging to the track . from the computing point of view , it is by far to most expensive task in hep event reconstruction .    while it entails similar calculations as the track fitting ( i.e. track parameter propagation and update , @xmath2 of each measurement ) , it adds two big complications to the problem .",
    "first , while during fitting the set of hits to process is already defined , in the building case a large number of hits is present at each layer , typically of the same order of the track multiplicity in the event .",
    "second , when more than one compatible hit is identified on the same layer , the combinatorial nature of the algorithm requires that a new track candidate is created for each compatible hit .",
    "data locality is the key for reducing the large number of hits problem , so that only a reduced set of hits is considered at a given time and thus needs to be available in lower caches levels . for this purpose , we partition the space both in pseudorapidity ( @xmath3 ) and in azimuthal angle ( @xmath4 ) .",
    "we exploit the fact that tracks do not bend in @xmath3 to define self - consistent @xmath3 partitions which are redundant in terms of hits , so that there are no boundary effects and track candidates never search outside their @xmath3 bin ( fig .",
    "[ eta - segmentation ] ) ; @xmath3 bins constitute a natural splitting for thread definitions .",
    "a simple partitioning in @xmath4 is used for fast look - up of hits in the 3@xmath5 compatibility window , where @xmath5 is the uncertainty on the propagated track @xmath4 on the considered layer .",
    "diagrams illustrating one single @xmath3 bin ( left ) and the full @xmath3 partitioning ( right ) . ]",
    "the two issues described above ( i.e. hit multiplicity and branching of candidates ) can be addressed separately by factorizing the problem in two stages . in a first version of the algorithm , at each layer all hits within the compatibility window of a given track are probed and only the hit with the lowest @xmath2 is chosen , so that there is no multiplication of candidates ; this simple and fast version already achieves good hit collection performance : running over 10 events with 20k tracks each , 70% ( 93% ) of tracks are reconstructed with @xmath690% ( 60% ) of the hits . in this setup we studied the performance in terms of vectorization , obtaining a maximum speedup of @xmath72x both on xeon and xeon phi ( fig .",
    "[ vector - host ] and [ vector - mic ] ) .",
    "the scaling with vector unit size is monotonic on xeon while an overhead is observed when vectorization is enabled on xeon phi , followed by a gradual speedup ; the usage of prefetching and gathering instrinsics gives a further time reduction when the vector units are maximally used .",
    "it should be noted that , with respect to the fitting case , worse vectorization performance is expected since the latency due to data input is amplified by the much larger number of hits processed at each layer .",
    "track building time ( best hit version ) vs number of elements in vector unit for xeon phi . ]",
    "track building time ( best hit version ) vs number of elements in vector unit for xeon phi . ]",
    "the second version is more advanced and targets ultimate physics performance . in this case",
    "we allow the branching of candidates , so that at each layer new candidates are created for all hits passing a @xmath2 cut of 30 ; also , in order to account for outlier hits and detector inefficiencies , candidates are allowed to miss the hit on one layer .",
    "up to 10 candidates per seed are considered and , when this number is exceeded , candidates are sorted based on the number of hits and the total @xmath8 and those in excess are discarded .",
    "running over the same set of events of 20k tracks each , the hit collection performance is significantly improved and 85% ( 95% ) of the tracks are reconstructed with @xmath690% ( 60% ) of the hits .",
    "we tested the performance of this algorithm in terms of parallelization .",
    "threads are evenly distributed threads across 21 eta bins , so that when the number of eta bins ( netabins ) is a multiple of the number of threads ( nthreads ) , n = netabins / nthreads eta bins are processed in each thread , while for nthreads multiple of netabins , seeds in each eta bin are distributed across n = nthreads / netabins threads .",
    "a speedup of 5x on xeon and @xmath710x on xeon phi is achieved ( fig .",
    "[ parallel - host ] and [ parallel - mic ] ) ; on xeon phi , we observe a saturation above nthreads=42 that will require further investigations .",
    "track building time vs number of threads for xeon phi . ]",
    "track building time vs number of threads for xeon phi . ]",
    "in summary , a first implementation of a vectorized and parallelized track building in a simplified setup achieves significant speedup both on xeon and xeon phi : 2x from vectorization on both architectures , 5x on xeon and 10x on xeon phi from parallelization .",
    "track fitting studies have been consolidated by implementing an improved data input method and a more realistic detector geometry description .",
    "the current results are definitely promising but many developments are still needed to deploy a complete tracking on parallel architectures .",
    "the comparison with the scaling for ideal performance suggests a large margin for further improvements , so the first task is clearly to identify and address the current bottlenecks in the track building algorithm , both for vectorization and parallelization .",
    "in addition , the study of how to exploit vectorization in presence of branching points in the algorithm is far from being trivial and still needs to be addressed .",
    "lastly , the performance gain obtained on our simplified and standalone configuration will have to be propagated to an end - to - end track reconstruction sequence on a fully realistic setup .",
    "this work was partially supported by the national science foundation , partially under cooperative agreement phy-1120138 , and by the u.s .",
    "department of energy .",
    "9        g.  cerati , p.  elmer , s.  lantz , i.  macneill , k.  mcdermott , d.  riley , m.  tadel and p.  wittich _ et al .",
    "_ , `` traditional tracking with kalman filter on parallel architectures , '' arxiv:1409.8213 [ physics.ins-det ]",
    ".    m.  gayer , j.  apostolakis , g.  cosmo , a.  gheata , j.  m.  guyader and t.  nikitina , `` new software library of geometrical primitives for modeling of solids used in monte carlo detector simulations , '' j.  phys .",
    "ser .   * 396 * , 052035 ( 2012 ) ."
  ],
  "abstract_text": [
    "<S> power density constraints are limiting the performance improvements of modern cpus . to address this </S>",
    "<S> we have seen the introduction of lower - power , multi - core processors , but the future will be even more exciting . in order to stay within the power density limits but still obtain moore s law performance / price gains , it will be necessary to parallelize algorithms to exploit larger numbers of lightweight cores and specialized functions like large vector units . </S>",
    "<S> example technologies today include intel s xeon phi and gpgpus . </S>",
    "<S> + track finding and fitting is one of the most computationally challenging problems for event reconstruction in particle physics . at the high luminosity lhc , for example , </S>",
    "<S> this will be by far the dominant problem . </S>",
    "<S> the need for greater parallelism has driven investigations of very different track finding techniques including cellular automata or returning to hough transform . </S>",
    "<S> the most common track finding techniques in use today are however those based on the kalman filter  @xcite . </S>",
    "<S> significant experience has been accumulated with these techniques on real tracking detector systems , both in the trigger and offline . </S>",
    "<S> they are known to provide high physics performance , are robust and are exactly those being used today for the design of the tracking system for hl - lhc . </S>",
    "<S> + our previous investigations showed that , using optimized data structures , track fitting with kalman filter can achieve large speedup both with intel xeon and xeon phi . </S>",
    "<S> we report here our further progress towards an end - to - end track reconstruction algorithm fully exploiting vectorization and parallelization techniques in a realistic simulation setup . </S>"
  ]
}