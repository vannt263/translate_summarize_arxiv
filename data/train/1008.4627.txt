{
  "article_text": [
    "a database instance may contain several tuples and values in them that refer to the same external entity that is being modeled through the database . in consequence",
    ", the database may be modeling the same entity in different forms , as different entities , which most likely is not the intended representation .",
    "this problem could be caused by errors in data , by data coming from different sources that use different formats or semantics , etc . in this case , the database is considered to contain dirty data , and it must undergo a cleansing process that goes through two interlinked phases : detecting tuples ( or values therein ) that should be matched or identified , and , of course , doing the actual matching . this problem is usually called _ entity resolution _ , _ data fusion _ , _ duplicate record detection _ , etc .",
    "@xcite for some recent surveys and @xcite for recent work in this area .",
    "quite recently , and generalizing entity resolution , @xcite introduced _ matching dependencies _ ( mds ) , which are declarative specifications of matchings of attribute values that should hold under certain conditions .",
    "mds help identify duplicate data and enforce their merging by exploiting semantic knowledge expressed .",
    "loosely speaking , an md is a rule defined on a database which states that , for any pair of tuples from given relations within the database , if the values of certain attributes of the tuples are similar , then the values of another set of attributes should be considered to represent the same object . in consequence , they should take the same values . here ,",
    "similarity of values can mean equality or a domain - dependent similarity relationship , e.g. related to some metric , such as the edit distance .",
    "[ ex : md ] consider the following database instance of a relation @xmath0 .",
    "    [ cols=\"^,^,^\",options=\"header \" , ]     [ thm : rewrite ] for a set @xmath1 of non - interacting mds and a query @xmath2 in the class @xmath3 , the query @xmath4 computed by algorithm _ rewrite _ returns the resolved answers to @xmath5 when posed to any instance . @xmath6",
    "as expected , the rewriting algorithm that produced the rewritten query does not depend upon the dirty instance at hand , but only on the mds and the input query , and runs in polynomial time .",
    "algorithm _ rewrite _ can be easily adapted and extended to handle hsc sets of mds .",
    "all that is required is a modification to the tuple - attribute closure in definition [ def : taclosure ] , as follows : for an hsc set of mds @xmath1 and @xmath7 , a pair of tuples @xmath8 and @xmath9 satisfies @xmath10 iff @xmath11\\approx t_2[\\bar b]$ ] and @xmath12 appears as a corresponding pair to the right of the arrow in some md in the same connected component of the md graph as @xmath13 .",
    "tuple - attribute closure is redefined as the transitive closure of this new relation . as with theorem [ thm : rewrite ] , the correctness proof is based on the simple form of the mris , and is proved using the same technique as in the proof of proposition [ lem : mri ] .",
    "mds can be seen as a new form of integrity constraint ( ic ) .",
    "an instance @xmath14 violates an md @xmath13 if there are unresolved duplicates , i.e. tuples @xmath8 and @xmath9 in @xmath14 that satisfy the similarity condition of @xmath13 , but differ on some pair of attributes that are matched by @xmath13 .",
    "the instances that are consistent with a set of mds @xmath1 are resolved instances of themselves with respect to @xmath1 . among classical ics ,",
    "the closest analogues of mds are functional dependencies ( fds ) .",
    "given a database instance @xmath14 and a set of ics @xmath15 , possibly not satisfied by @xmath14 , consistent query answering ( cqa ) is the problem of characterizing and computing the answers to queries @xmath5 that are true in all the instances @xmath16 that are consistent with @xmath15 and minimally differ from @xmath14 @xcite .",
    "the consistent instances @xmath16 are called _",
    "repairs_. minimal difference can be defined in different ways .",
    "most of the research in cqa has concentrated on the case where the symmetric difference of instances , as sets of tuples , is made minimal under set inclusion @xcite . however , also the minimization of the cardinality of this difference has been investigated @xcite .",
    "other forms of minimization measure the differences in attribute values between @xmath14 and @xmath16 @xcite .",
    "because of their practical importance , much work on cqa has been done for the case where @xmath15 is a set of functional dependencies ( fds ) , in particular , key constraints ( kcs ) @xcite .    actually , for a set of kcs @xmath17 and repairs based on tuple deletions , a _ repair",
    "_ @xmath16 of an instance @xmath14 can be characterized as a maximal subset of @xmath14 that satisfies @xmath17 : @xmath18 and there is no @xmath19 with @xmath20 , with @xmath21 @xcite .",
    "now , for a fo query @xmath22 and a set of kcs @xmath17 , the _ consistent query answering problem _ is about deciding membership of the set [ eq : cqa ] _ cqa _ _ , = \\{(d,|a )  |  |a + d}.a @xmath23 satisfying the above is called a _",
    "consistent answer _ to @xmath2 from @xmath14 .",
    "notice that this notion of minimality involved in repairs wrt fds is tuple and set - inclusion oriented , whereas the one related to mris ( cf .",
    "definition [ def : minim ] ) is attribute and cardinality oriented .",
    "however , the connection can still be established . in particular",
    ", the following result can be obtained from ( * ? ? ?",
    "[ thm : chom ] consider a relational predicate @xmath24 $ ] , the md [ eq : intmd ] m :  r[a ] = r[a]r[b , c]r[b , c ] , and the query @xmath25 .",
    "@xmath26 is @xmath27-complete .",
    "@xmath6    notice that the conjunctive query in this result does not belong to the @xmath3 class .    for certain classes of conjunctive queries and ics consisting of a single kc per relation",
    ", cqa has been proved to be tractable .",
    "this is the case for the @xmath28 class of conjunctive queries @xcite .",
    "actually , for this class there is a fo rewriting of the original query that returns the certain answers .",
    "@xmath28 excludes repeated relations and allows joins only between non - key and key attributes .",
    "similar results were subsequently proved for a larger class of queries that includes some queries with repeated relations and joins between non - key attributes @xcite .",
    "the following result allows us to take advantage of tractability results for cqa in our md setting .",
    "[ thm : red ] let @xmath14 be a database instance with a single relation @xmath29 .",
    "let @xmath13 be a md of the form @xmath30 = r[\\bar a]\\ra r[\\bar b]\\rl r[\\bar b]$ ] , where the set of attributes of @xmath29 is @xmath31 and @xmath32 .",
    "then there is a polynomial time reduction from @xmath33 to @xmath34 , where @xmath35 is the key constraint @xmath36 .",
    "@xmath6    proposition [ thm : red ] can be easily generalized to several relations with one such md defined on each .",
    "the reduction takes an instance @xmath14 for @xmath33 and produces an instance @xmath16 for @xmath34 .",
    "the schema of @xmath16 is the same for @xmath14 , but the extensions of the relational predicates in it are changed wrt @xmath14 via counting . since definitions for those aggregations can be included ( or inserted ) in the query @xmath5 , we obtain :    [ theo : comp]let @xmath37 be a database schema with relation predicates @xmath38 , @xmath39 with a set @xmath17 of kcs @xmath40\\ra r_i[\\bar b_i]$ ] , @xmath39 .",
    "let @xmath2 be a fo query , and suppose there exists a polynomial time computable fo query @xmath41 , such that @xmath41 returns the consistent answers to @xmath2 from @xmath14 .",
    "then there exists a polynomial time computable fo query @xmath42 with aggregation that returns the resolved answers to @xmath2 from @xmath14 wrt the mds @xmath43 = r_i[\\bar a_i ] \\ra r_i[\\bar b_i]\\rl r_i[\\bar b_i],~~1\\leq i\\leq n$ ] . @xmath6",
    "the aggregation in @xmath42 in theorem [ theo : comp ] arises from the transformation of the instance that is used in the reduction in proposition [ thm : red ] .",
    "we emphasize that @xmath42 is _ not _ obtained using algorithm _",
    "rewrite _ from section [ sec : tr ] , which is not guaranteed to work for queries outside the class @xmath3 .",
    "rather , a first - order transformation of the @xmath38 relations with @xmath44 is composed with @xmath41 to produce @xmath42 .",
    "similar to algorithm _",
    "rewrite _ in section [ sec : tr ] , they are used to express the most frequently occurring values for the changeable attributes for a given set of tuples with identical values for the unchangeable attributes .",
    "this theorem can be applied to decide / compute resolved answers through composition in those cases where a fo rewriting for cqa has been identified . in consequence , it extends the tractable cases identified in section [ sec : tr ] .",
    "they can be applied to queries that are not in @xmath3 .",
    "the query @xmath45 is in the class @xmath28 for relational predicates @xmath46 $ ] and @xmath47 $ ] and fds @xmath48 and @xmath49 . by theorem [ theo : comp ] and",
    "the results in @xcite , this implies the existence of a polynomial time computable fo query with counting that returns the resolved answers to @xmath5 wrt mds @xmath50 = r[a]\\ra r[b]\\rl r[b]$ ] and @xmath51 = s[c]\\ra s[e]\\rl s[e]$ ] .",
    "notice that @xmath2 is not in @xmath3 , since the bound variable @xmath52 is associated with the changeable attribute @xmath53 $ ] .",
    "in this paper we have proposed a revised semantics for matching dependency ( md ) satisfaction wrt the one originally proposed in @xcite .",
    "the main outcomes from that semantics are the notions of _ minimally resolved instance _ ( mri ) and _ resolved answers _ ( ras ) to queries . the former capture the intended , clean instances obtained after enforcing the mds on a given instance .",
    "the latter are query answers that persist across all the mris , and can be considered as robust and semantically correct answers .",
    "we investigated the new semantics , the mris and the ras .",
    "we considered the existence of mris , their number , and the cost of computing them .",
    "depending on syntactic criteria on mds and queries , tractable and intractable cases of resolved query answering were identified .",
    "the tractable cases coincide with those where the original query can be rewritten into a new , polynomial - time evaluable query that returns the resolved answers when posed to the original instance .",
    "it is interesting that the rewritings make use of counting and recursion ( for the transitive closure ) .",
    "the original queries considered in this paper are all conjunctive",
    ". other classes of queries will be considered in future work .",
    "many of our results apply to cases for which the resolved instances can be obtained after a single ( batch ) update operation .",
    "the investigation of cases requiring multiple updates is a subject of ongoing research .",
    "we have obtained several tractability and intractability results . however , understanding the complexity landscape requires still much more research .",
    "we established interesting connections between resolved query answering wrt mds and consistent query answers .",
    "there are still many issues to explore in this direction , e.g. the possible use of logic programs with stable model semantics to specify the mris , so as it has been done with database repairs @xcite .",
    "we have proposed some efficient algorithms for resolved query answering .",
    "implementing them and experimentation are also left for future work . notice that those algorithms use different forms of transitive closure .",
    "to avoid unacceptably slow query processing , it may be necessary to compute transitive closures off - line and store them .",
    "the use of datalog with aggregate functions should also be investigated in this direction .    in this paper",
    "we have not considered cases where the matchings of attribute values , whenever prescribed by the mds conditions , are made according to matching functions .",
    "this element adds an entirely new dimension to the semantics and the problems investigated here .",
    "it certainly deserves investigation .    10    s.  abiteboul , r.  hull , and v.  vianu . .",
    "addison - wesley , don mills , ontario , 1995 .",
    "f.  afrati and p.  kolaitis .",
    "repair checking in inconsistent databases : algorithms and complexity . in _ proc .",
    ", pages 3141 , 2009 .",
    "m.  arenas , l.  bertossi , and j.  chomicki .",
    "consistent query answers in inconsistent databases . in _ proc . pods _ , pages 6879 , 1999 .",
    "m.  arenas , l.  bertossi , and j.  chomicki .",
    "answer sets for consistent query answering in inconsistent databases . , 3(4 - 5):393424 , 2003 .",
    "p.  barcel , l.  bertossi , and l.  bravo .",
    "characterizing and computing semantically correct answers from databases with annotated logic and answer sets . in _ semantics in databases _ , pages 733 , 2003 .",
    "o.  benjelloun , h.  garcia - molina , d.  menestrina , q.  su , s.  euijong  whang , and j.  widom .",
    "swoosh : a generic approach to entity resolution .",
    ", 18(1):255276 , 2009 .",
    "l.  bertossi .",
    "consistent query answering in databases .",
    ", 35(2):6876 , 2006 .",
    "l.  bertossi , l.  bravo , e.  franconi , and a.  lopatenko .",
    "the complexity and approximation of fixing numerical attributes in databases under integrity constraints .",
    ", 33(4):407434 , 2008 .",
    "l.  bertossi and j.  chomicki .",
    "query answering in inconsistent databases . in _",
    "logics for emerging applications of databases _ , pages 4383 .",
    "springer , 2003 .",
    "j.  bleiholder and f.  naumann .",
    "data fusion . , 41(1):141 , 2008 .",
    "j.  chomicki .",
    "consistent query answering : five easy pieces . in _ proc .",
    "icdt _ , pages 117 , 2007 .",
    "j.  chomicki and j.  marcinkowski .",
    "minimal - change integrity maintenance using tuple deletions .",
    ", 197(1/2):90121 , 2005 .",
    "a.  elmagarmid , p.  ipeirotis , and v.  verykios .",
    "duplicate record detection : a survey .",
    "19(1):116 , 2007 .    j.  fan .",
    "dependencies revisited for improving data quality . in _ proc . pods _ , pages 159170 , 2008 .",
    "j.  fan , x.  jia , j.  li , and s.  ma .",
    "reasoning about record matching rules . in _ proc .",
    "vldb _ , pages 407418 , 2009 .",
    "s.  flesca , f.  furfaro , and f.  parisi .",
    "consistent query answers on numerical databases under aggregate constraints . in _ proc .",
    "dbpl _ , pages 279294 , 2005 .",
    "e.  franconi , a.  laureti  palma , n.  leone , s.  perri , and f.  scarcello .",
    "census data repair : a challenging application of disjunctive logic programming . in _ proc .",
    "lpar _ , pages 561578 , 2001 .",
    "a.  fuxman and r.  miller .",
    "first - order query rewriting for inconsistent databases .",
    ", 73(4):610635 , 2007 .",
    "g.  greco , s.  greco , and e.  zumpano . a logical framework for querying and repairing inconsistent databases .",
    ", 15(6):13891408 , 2003 .",
    "a.  lopatenko and l.  bertossi .",
    "complexity of consistent query answering in databases under cardinality - based and incremental repair semantics . in _ proc .",
    "icdt _ , pages 179193 , 2007 .",
    "j.  wijsen .",
    "database repairing using updates .",
    ", 30(3):722768 , 2005 .",
    "j.  wijsen .",
    "consistent query answering under primary keys : a characterization of tractable cases . in _ proc .",
    "icdt _ , pages 4252 , 2009 .",
    "j.  wijsen . on the consistent rewriting of conjunctive queries under primary key constraints .",
    ", 34(7):578601 , 2009 .    j.  wijsen .",
    "on the first - order expressibility of computing certain answers to conjunctive queries over uncertain databases . in _ proc . pods _ , pages 179190 , 2010 .",
    "* proof of theorem [ thm : arb]:*consider an undirected graph @xmath54 whose vertices are labelled by pairs @xmath55 , where @xmath56 is a tuple identifier and @xmath57 is an attribute of @xmath56 .",
    "there is an edge between two vertices @xmath58 and @xmath59 iff @xmath60 and @xmath56 satisfy the similarity condition of some md @xmath7 such that @xmath57 and @xmath61 are matched by @xmath13 .",
    "update @xmath14 as follows . choose a vertex @xmath62 such that there is another vertex @xmath63 connected to @xmath62 by an edge and @xmath64 $ ] and @xmath65 $ ] must be made equal to satisfy the equalities in condition 1 . of definition [ def : new ] .",
    "for convenience in this proof , we say that @xmath9 is unequal to @xmath8 for such a pair of tuples @xmath8 and @xmath9 .",
    "perform a breadth first search ( bfs ) on @xmath54 starting with @xmath62 as level 0 . during the search ,",
    "if a tuple is discovered at level @xmath66 that is unequal to an adjacent tuple at level @xmath67 , the value of the attribute in the former tuple is modified so that it matches that of the latter tuple .",
    "when the bfs has completed , another vertex with an adjacent unequal tuple is chosen and another bfs is performed .",
    "this continues until no such vertices remain .",
    "it is clear that the resulting updated instance @xmath16 satisfies condition 1 . of definition [ def : new ] .",
    "we now show by induction on the levels of the breadth first searches that for all vertices @xmath55 visited , @xmath68 $ ] is modifiable .",
    "this is true in the base case , by choice of the starting vertex .",
    "suppose it is true for all levels up to and including the @xmath69 level . by definition of the graph @xmath54 and",
    "condition 2 . of definition [ def :",
    "mod ] , the statement is true for all vertices at the @xmath70 level .",
    "this proves the first statement of the theorem .    to prove the second statement",
    ", we show that , to satisfy condition 1 . of definition [ def :",
    "new ] , the attribute values represented by each vertex in each connected component of @xmath54 must be changed to a common value in the new instance .",
    "the statement then follows from the fact that the update algorithm can be modified so that the attribute value for the initial vertex in each bfs is updated to some arbitrary value at the start ( since it is modifiable ) . by condition 1 . of definition [ def :",
    "new ] , the pairs of values that must be equal in the updated instance @xmath16 correspond to those vertices that are connected by an edge in @xmath54 .",
    "this fact and transitivity of equality imply that all attribute values in a connected component must be updated to a common value .",
    "@xmath6    * proof of theorem [ theo : resolv]:*we give an algorithm to compute a resolved instance , and use a monotonicity property to show that it always terminates . for attribute domain @xmath71 in @xmath14 ,",
    "consider the set @xmath72 of pairs @xmath55 such that attribute @xmath57 of the tuple with identifier @xmath56 has domain @xmath71 .",
    "let @xmath73 be a partition of @xmath72 into sets such that all tuple / attribute pairs in a set have the same value in @xmath14 .",
    "define the level of @xmath55 to mean @xmath74 where @xmath75 .",
    "the algorithm first applies all mds in @xmath1 to @xmath14 by setting equal pairs of unequal values according to the mds .",
    "specifically , consider a connected component @xmath76 of the graph in the proof of theorem [ thm : arb ] .",
    "if the values of @xmath68 $ ] for all pairs @xmath55 in @xmath76 are not all the same , then their values are modified to a common value which is that of the pair with the highest level .",
    "this update is allowed by theorem [ thm : arb ] . in the case of a tie , the common value is chosen as the largest of the values according to some total ordering of the values from the domain that occur in the instance .",
    "it is easily verified that this operation increases the sum over all the levels of the elements of @xmath72 , where @xmath71 is the domain of the attributes of the pairs in @xmath76 .",
    "these updates produce an instance @xmath77 such that @xmath78 .",
    "the mds of @xmath1 are then applied to the instance @xmath77 to obtain a new instance @xmath79 such that @xmath80 and so on , until a stable instance is reached . for each new instance , the sum over all domains @xmath71 of the levels of the @xmath81 is greater than for the previous instance .",
    "since this quantity is bounded above , the algorithm terminates with a resolved instance .",
    "[ lem : tc ] let @xmath14 be an instance and let @xmath13 be the md in definition [ def : tc ] .",
    "let @xmath82 be the transitive closure of @xmath83 .",
    "an instance @xmath16 obtained by changing modifiable attribute values of @xmath14 satisfies @xmath84 iff for each equivalence class of @xmath82 , there is a constant vector @xmath85 such that , for all tuples @xmath56 in the equivalence class , t[|c ] =      _ proof_:suppose @xmath84 . by definition [ def :",
    "new ] , for each pair of tuples @xmath87 and @xmath88 such that @xmath11\\approx t_2[\\bar b]$ ] , @xmath89 = t_2'[\\bar e]\\nn\\ ] ] therefore , if @xmath90 is true , then @xmath91 and @xmath92 must be in the transitive closure of the binary relation expressed by @xmath93 = t_2'[\\bar e]$ ] .",
    "but the transitive closure of this relation is the relation itself ( because of the transitivity of equality ) .",
    "therefore , @xmath93 = t_2'[\\bar e]$ ] .",
    "the converse is trivial .",
    "* proof of proposition [ lem : mri]:*consider an input @xmath14 , @xmath1 to _ computemri _ with @xmath1 a simple - cycle set of mds given by @xmath94\\approx_0 s[\\bar b_0]&\\ra & r[\\bar a_0']\\rl s[\\bar b_0 ' ] \\nn\\\\ r[\\bar a_1]\\approx_1 s[\\bar b_1]&\\ra & r[\\bar a_1']\\rl s[\\bar b_1']\\nn\\\\ & \\vdots&\\nn\\\\ r[\\bar a_{n-1}]\\approx_{n-1 } s[\\bar b_{n-1}]&\\ra & r[\\bar a_{n-1}']\\rl s[\\bar b_{n-1}']\\nn \\label{eq:1}\\end{aligned}\\ ] ] let @xmath95 denote the transitive closure of the relation @xmath96 .",
    "let @xmath97 denote an instance obtained by updating @xmath14 @xmath67 times according to @xmath1 , and for a tuple @xmath98 , denote the tuple with the same identifier in @xmath97 by @xmath99 . by lemma [ lem : tc ] and",
    "straightforward induction , it can be seen that , after @xmath14 has been updated @xmath67 times , @xmath100 modifications . in this case , the  update \" is the identity mapping on all values . ] according to @xmath1 to obtain an instance @xmath97 , for all tuples @xmath56 in a given equivalence class @xmath101 of @xmath95 , [ eq:7 ] t^i[|a_(j+i-1)n ] =    [ eq:8 ] t^i[|b_(j+i-1)n ] = |v_ij^e  ts(d ) for some vector of values @xmath102 .",
    "let @xmath16 be a resolved instance .",
    "@xmath16 satisfies the property that any number of applications of the mds does not change the instance .",
    "therefore , @xmath16 must satisfy ( [ eq:7 ] ) and ( [ eq:8 ] ) for all @xmath67 .",
    "that is , for any @xmath95 , @xmath103 , for any equivalence class of @xmath95 , for all tuples @xmath56 in the equivalence class , and for @xmath39 , [ eq:9 ] t[|a_i ] =      let @xmath82 be the transitive closure of the set @xmath104 ( cf .",
    "definition [ def : tcset ] ) . by ( [ eq:9 ] ) and ( [ eq:10 ] ) , for any pair of tuples @xmath8 and @xmath9",
    "satisfying @xmath105 , @xmath91 and @xmath92 must satisfy @xmath106 , where @xmath107 is the transitive closure of the binary relation on tuples expressed by @xmath108 = t_2'[\\bar b_i']$ ] , @xmath39 .",
    "since the equality relation is closed under transitive closure , this implies the following property : [ eq:11 ] t(t_1,t_2 ) t_1[|a_i ] = t_2[|b_i ] ,   1 in it remains to show that the instances produced by _",
    "computemri _ are resolved instances . that they are the mris",
    "will then follow from the fact that they have the fewest changes among all instances satisfying ( [ eq:11 ] ) . for any equivalence class @xmath101 of @xmath82 ,",
    "let @xmath109 be a list of values chosen by _",
    "computemri _ as the common values for the pair of attribute lists @xmath110 for tuples in @xmath101 . to obtain the instance output by _ computemri",
    "_ for this choice of values , @xmath14 can be updated as follows . for the @xmath69 update , if the values of the attributes @xmath111 and @xmath112 must be modified to achieve ( [ eq:7 ] ) and ( [ eq:8 ] ) , take @xmath113 , where @xmath114 is the equivalence class of @xmath82 that contains the equivalence class @xmath101 of @xmath95 .",
    "note that such an @xmath114 always exists , and the assignment of values is consistent since overlapping equivalence classes @xmath115 and @xmath95 will be contained in the same equivalence class of @xmath82 . then after @xmath116 updates , the resulting instance satisfies ( [ eq:11 ] ) , with common values as chosen by _ computemri_.",
    "we must show that the resolved instance produced by this update process is the same instance that _ computemri _ returns for the given choice of update values . for any intermediate instance @xmath117 obtained in this update process , let @xmath118 denote the tuple in @xmath117 with the same identifier as @xmath56",
    ". we will show by induction on the number of updates that were made to obtain @xmath117 that for any @xmath67 , whenever @xmath119 for tuples @xmath56 and @xmath86 , it holds that @xmath120 .",
    "this implies that updates made to @xmath68 $ ] for tuple @xmath56 and attribute @xmath57 can only set it equal to the common value for the equivalence class of @xmath82 to which @xmath56 belongs . since _ computemri _ also sets @xmath68 $ ] to this value , this will prove the theorem .    by definition of @xmath82 ,",
    "if 0 updates were used to obtain @xmath117 , @xmath119 implies @xmath121 implies @xmath120 .",
    "assume it is true for instances obtained after at most @xmath122 updates .",
    "let @xmath117 be an instance obtained after @xmath123 updates .",
    "suppose for the sake of contradiction that there exist tuples @xmath118 and @xmath124 such that for some @xmath67 , @xmath119 but @xmath125 .",
    "since @xmath125 implies @xmath126 , at least one of @xmath127 $ ] and @xmath128 $ ] was updated so that @xmath119 .",
    "we will assume that only @xmath127 $ ] was updated .",
    "the other cases are similar",
    ". then it must have been updated to @xmath129 $ ] or @xmath130 $ ] for some @xmath131 or @xmath132 , respectively , such that , for the instance @xmath133 on which the update was performed , it holds that @xmath134 and @xmath135 . by the induction hypothesis , @xmath136 and @xmath137 , which by the transitivity of @xmath82 implies @xmath120 , a contradiction .",
    "@xmath6    * proof of theorem [ theo : hsc ] : * if it can be verified in polynomial time that an instance is an mri of a given instance wrt a set @xmath1 of mds , then @xmath138 is in co - np for any fo @xmath139 .",
    "this is because , for a given instance @xmath140 of @xmath138 , @xmath56 can be shown not to be a certain answer by guessing an instance @xmath16 , verifying that it is an mri , and verifying that @xmath56 is not an answer to @xmath139 for @xmath16 .",
    "computemri _ can easily be modified to produce such a polynomial time verifier : compute the transitive closure relation @xmath82 but instead of setting values equal , check that they are equal in the candidate mri .",
    "@xmath6    [ lem : onestep ] let @xmath1 be a non - interacting set of mds of the form [ eq:2n ] m_1 :  & & r_1[a_1]_1 r_2[b_1]r_1[|a_2]r_2[|b_2 ] + m_2 :  & & r_3[a_3]_2 r_4[b_3]r_3[|a_4]r_4[|b_4 ] + & & + m_n :  & & r_2n-1[a_2n-1]_n r_2n[b_2n-1 ] + & & r_2n-1[|a_2n]r_2n[|b_2n]let @xmath82 be the transitive closure of the set @xmath141 , where @xmath142 is the tuple - attribute closure of @xmath143 .",
    "then , for any instance @xmath14 , an instance @xmath16 obtained by updating modifiable values of @xmath14 is a resolved instance of @xmath14 iff whenever @xmath144 , @xmath145 = t_2'[b]$ ] , where @xmath86 is the tuple in @xmath16 with the same identifier as @xmath56 .    _ proof _ : suppose @xmath16 is a resolved instance .",
    "since @xmath1 is non - interacting , this implies @xmath146 .",
    "it is a corollary of lemma [ lem : tc ] that whenever @xmath144 , @xmath145 = t_2'[b]$ ] , for all @xmath39 .",
    "the converse follows from the fact that , whenever a pair of tuples @xmath8 and @xmath9 satisfies the similarity condition of an md , @xmath144 for every pair @xmath147 of matched attributes in the md . @xmath6    [ cor : mris ] let @xmath14 be an instance and @xmath1 a set of non - interacting mds .",
    "let @xmath82 be the transitive closure of the set of tuple - attribute closures of the mds in @xmath1 .",
    "then the set of mris is obtained by setting , for each equivalence class @xmath101 of @xmath82 , the value of each attribute in @xmath101 to a value that occurs in @xmath101 at least as frequently as any other value in @xmath101 .",
    "@xmath6    * proof of theorem [ thm : rewrite ] : * we express the query in the form [ eq : form ] ( |y ) = |z q_1(|z,|y ) let @xmath148 denote the variable of @xmath149 or @xmath150 which holds the value of the @xmath151 attribute in the @xmath69 conjunct @xmath38 in @xmath152 .",
    "denote this attribute by @xmath153 .",
    "note that , since variables and conjuncts can be repeated , it can happen that @xmath148 is the same variable as @xmath154 for @xmath155 , that @xmath153 is the same attribute as @xmath156 for @xmath155 , or that @xmath38 is the same as @xmath157 for @xmath158 .",
    "let @xmath61 and @xmath159 denote the set of bound and free variables in @xmath152 , respectively .",
    "let @xmath76 and @xmath160 denote the variables in @xmath152 holding the values of changeable and unchangeable attributes , respectively .",
    "let @xmath161 denote the rewritten query returned by algorithm _",
    "rewrite _ , which we express as @xmath162 we show that , for any constant vector @xmath163 , @xmath164 is true for an instance @xmath14 iff @xmath165 is true for all mris of @xmath14 .",
    "suppose that @xmath164 is true for an instance @xmath14 .",
    "then there exists a @xmath166 such that @xmath167 .",
    "we will refer to this assignment of constants to variables as @xmath168 . from the form of @xmath41",
    ", it is apparent that , for any fixed @xmath67 , there is a tuple @xmath169 such that @xmath170 is true in @xmath14 with the following properties .    1 .   for all @xmath148 except those in @xmath171",
    ", @xmath172 is the value assigned to @xmath148 by @xmath168 .",
    "[ enum : two ] 2 .   for all @xmath173 ,",
    "there is a tuple @xmath9 with attribute @xmath61 such that @xmath174 , where @xmath82 is the transitive closure of the tuple - attribute closures of the mds in @xmath1 , such that the value of @xmath65 $ ] is the value assigned to @xmath148 by @xmath168 .",
    "moreover , this value occurs more frequently than that of any other tuple / attribute pair in the same equivalence class of @xmath82 .    for any given mri @xmath16 ,",
    "consider the tuple @xmath91 in @xmath16 with the same identifier as @xmath8 .",
    "clearly , this tuple will have the same values as @xmath8 for all unchangeable attributes , which by 1 .",
    ", are the values assigned to the variables @xmath175 . also , by 2 . and corollary [ cor : mris ] , for any @xmath176 such that @xmath173 is free",
    ", the value of the @xmath151 attribute of @xmath91 is that assigned to @xmath148 by @xmath168 .",
    "thus , for each mri @xmath16 , there exists an assignment @xmath177 of constants to the @xmath148 that makes @xmath2 true , and this assignment agrees with @xmath168 on all @xmath178 .",
    "this assignment is consistent in the sense that , if @xmath148 and @xmath154 are the same variable , they are assigned the same value .",
    "indeed , for @xmath178 , consistency follows from the consistency of @xmath168 , and for @xmath179 , it follows from the fact that the variable represented by @xmath148 occurs only once in @xmath139 , by assumption . therefore , @xmath165 is true for all mris @xmath16 , and @xmath163 is a resolved answer .",
    "conversely , suppose that a tuple @xmath163 is a resolved answer .",
    "then , for any given mri @xmath16 there is a satisfying assignment @xmath180 to the variables in @xmath2 such that @xmath149 as defined by ( [ eq : form ] ) is assigned the value @xmath163 .",
    "we write @xmath41 in the form [ eq : form2 ] (|y)|z_1inq_i(|v_i ) with @xmath181 the rewritten form of the @xmath69 conjunct of @xmath2 . for any fixed @xmath67 ,",
    "let @xmath182 be a tuple in @xmath16 such that @xmath183 is the constant assigned to @xmath148 by @xmath180 .",
    "we construct a satisfying assignment @xmath168 to the free and existentially quantified variables of @xmath41 as follows .",
    "consider the conjunct @xmath181 of @xmath41 as given on line 16 of _",
    "rewrite_. assign to @xmath184 the tuple @xmath56 in @xmath14 with the same identifier as @xmath86 .",
    "this fixes the values of all the variables except those @xmath185 , which are set to @xmath183 .",
    "it follows from corollary [ cor : mris ] that @xmath168 satisfies @xmath41 .",
    "since @xmath177 and @xmath168 match on all variables that are not local to a single @xmath181 , @xmath168 is consistent .",
    "therefore , @xmath163 is an answer for @xmath41 on @xmath14 . @xmath6    * proof of theorem [ thm : chom]:*hardness follows from the fact that , for the instance @xmath14 resulting from the reduction in the proof of theorem 3.3 in @xcite , the set of all repairs of @xmath14 with respect to the given key constraint is the same as the set of mris with respect to ( [ eq : intmd ] ) .",
    "the key point is that attribute modification in this case generates duplicates which are subsequently eliminated from the instance , producing the same result as tuple deletion .",
    "containment follows from theorem [ theo : hsc ] . @xmath6    * proof of proposition [ thm : red]:*take @xmath186 and @xmath187 @xmath188 . for any tuple of constants @xmath189 ,",
    "define @xmath190 .",
    "let @xmath191 denote the single attribute relation with attribute @xmath192 whose tuples are the most frequently occurring values in @xmath193 .",
    "that is , @xmath194 iff @xmath195 and there is no @xmath196 such that @xmath197 occurs as the value of the @xmath192 attribute in more tuples of @xmath198 than @xmath199 does .",
    "note that @xmath191 can be written as an expression involving @xmath29 which is first order with a @xmath44 operator .",
    "the reduction produces @xmath200 from @xmath201 , where r_|k [_|ar^|k b_1^|kb_n^|k ] the repairs of @xmath202 are obtained by keeping , for each set of tuples with the same key value , a single tuple with that key value and discarding all others . by corollary a.[cor : mris ] , in a mri of @xmath14 , the group @xmath203 of tuples such that @xmath204 for some constant @xmath189 has a common value for @xmath205 also , and the set of possible values for @xmath205 is the same as that of the tuple with key @xmath189 in a repair of @xmath14 .",
    "since duplicates are eliminated from the mris , the set of mris of @xmath14 is exactly the set of repairs of @xmath202 ."
  ],
  "abstract_text": [
    "<S> matching dependencies ( mds ) were introduced to specify the identification or matching of certain attribute values in pairs of database tuples when some similarity conditions are satisfied . </S>",
    "<S> their enforcement can be seen as a natural generalization of entity resolution . in what we call the _ pure case _ of mds </S>",
    "<S> , any value from the underlying data domain can be used for the value in common that does the matching . </S>",
    "<S> we investigate the semantics and properties of data cleaning through the enforcement of matching dependencies for the pure case . </S>",
    "<S> we characterize the intended clean instances and also the _ clean answers _ to queries as those that are invariant under the cleaning process . </S>",
    "<S> the complexity of computing clean instances and clean answers to queries is investigated . </S>",
    "<S> tractable and intractable cases depending on the mds and queries are identified . </S>",
    "<S> finally , we establish connections with database _ repairs _ under integrity constraints . </S>"
  ]
}