{
  "article_text": [
    "most computer programs are _ concurrent _ programs , which need to perform several tasks at the same time . for example , a network server needs to serve multiple clients at a time ; a gui needs to handle multiple keyboard and mouse inputs ; and a network program with a graphical interface ( e.g.  a web browser ) needs to do both simultaneously .",
    "there are many different techniques to implement concurrent programs .",
    "a very common abstraction is provided by _ threads _ , or _",
    "lightweight processes_. in a threaded program , concurrent tasks are executed by a number of independent threads which communicate through a shared memory heap .",
    "an alternative to threads is _ event - driven _ programming .",
    "an event - driven program interacts with its environment by reacting to a set of stimuli called _",
    "events_. at any given point in time , to every event is associated a piece of code known as the _ handler _ for this event . a global scheduler , known as the _ event loop _ , repeatedly waits for an event to occur and invokes the associated handler .",
    "performing a complex task requires to coordinate several event handlers by exchanging appropriate events .    unlike threads ,",
    "event handlers do not have an associated stack ; event - driven programs are therefore more lightweight and often faster than their threaded counterparts . however , because it splits the flow of control into multiple tiny event handlers , event - driven programming is generally deemed more difficult and error - prone . additionally , event - driven programming alone is often not powerful enough , in particular when accessing blocking apis or using multiple processor cores ; it is then necessary to write _ hybrid _ code , that uses both _",
    "preemptively - scheduled _ threads and _ cooperatively - scheduled _ event handlers , which is even more difficult .",
    "since event - driven programming is more difficult but more efficient than threaded programming , it is natural to want to at least partially automate it .",
    "_ continuation - passing c _",
    "( cpc @xcite ) is an extension of the c programming language for writing concurrent systems .",
    "the cpc programmer manipulates very lightweight threads , choosing whether they should be cooperatively or preemptively scheduled at any given point .",
    "the cpc program is then processed by the _ cpc translator _ , which produces highly efficient sequentialised event - loop code , and uses native threads to execute the preemptive parts .",
    "the translation from threads into events is performed by a series of classical source - to - source program transformations : splitting of the control flow into mutually recursive inner functions , lambda lifting of these functions created by the splitting pass , and cps conversion of the resulting code .",
    "this approach retains the best of both worlds : the relative convenience of programming with threads , and the low memory usage of event - loop code .",
    "not all event - driven programs look the same : several styles and implementations exist , depending on the programmer s taste .",
    "since event - driven programming consists in manually handling the control flow and data flow of each task , a tedious and error - prone activity , the programmer often choses a style based on some trade - off between ( his intuition of ) efficiency and code - readability , and then sticks with it in the whole program .",
    "even if the representation of control or data turns out to be suboptimal , changing it would generally require a complete refactoring of the program , not likely to be undertaken for an uncertain performance gain . in large event - driven programs , written by several people or over a long timespan , it is even possible to find a mix of several styles making the code even harder to decipher .",
    "for example , the transformations performed by the cpc translator yield event - driven code where control flow is encoded as long , intricate chains of callbacks , and where local state is stored in tiny data structures , repeatedly copied from one event - handler to the next .",
    "we can afford these techniques because we generate the code automatically .",
    "hand - written programs often use less tedious approaches , such as state machines to encode control flow and coarse long - lived data structures to store local state ; these are easier to understand and debug but might be less efficient .",
    "since the transformations performed by the cpc translator are completely automated , it offers an ideal opportunity to generate several event - driven variants of the same threaded program , and compare their efficiency .",
    "we first review existing translators from threads to events ( [ sec : related ] ) , and analyse several examples of event - driven styles found in real - world programs ( [ sec : flow ] ) .",
    "we identify two typical kinds of control - flow and data - flow encodings : callbacks or state machines for the control flow , and coarse - grained or minimal data structures for the data flow .",
    "we then propose a set of automatic program transformations to produce each of these four variants ( [ sec : generating ] ) .",
    "control flow is translated by splitting and cps conversion to produce callbacks ; adding a pass of defunctionalisation yields state machines .",
    "data flow is translated either by lambda lifting , to produce minimal , short - lived data structures , or using shared environments for coarse - grained ones .",
    "finally , we implement ecpc , a variant of cpc using shared environments instead of lambda lifting to handle the data flow in the generated programs ( [ sec : ecpc ] ) .",
    "we find out that , although rarely used in real - world event - driven programs because it is tedious to perform manually , lambda lifting yields faster code than environments in most of our benchmarks . to the best of our knowledge , cpc is currently the only threads - to - events translator using lambda lifting .",
    "the translation of threads into events has been rediscovered many times @xcite . in this section ,",
    "we review existing solutions , and observe that each of them generates only one particular kind of event - driven style . as we shall see in [ sec : generating ] , we believe that these implementations are in fact a few classical transformation techniques , studied extensively in the context of functional languages , and adapted to imperative languages , sometimes unknowingly , by programmers trying to solve the issue of writing events in a threaded style .",
    "the first example known to us is _ weave _ , an unpublished tool used at ibm in the late 1990 s to write firmware and drivers for ssa - scsi raid storage adapters @xcite .",
    "it translates annotated woven - c code , written in threaded style , into c code hooked into the underlying event - driven kernel .",
    "adya et al .",
    "@xcite provide a detailed analysis of control flow in threads and events programs , and implement adaptors between event - driven and threaded code to write hybrid programs mixing both styles .",
    "duff introduces a technique , known as _",
    "duff s device _",
    "@xcite , to express general loop unrolling directly in c , using the ` switch ` statement . much later",
    ", this technique has been employed multiple times to express state machines and event - driven programs in a threaded style : _ protothreads _",
    "fairthreads_ automata @xcite .",
    "these libraries help keep a clearer flow of control but they provide no automatic handling of data flow : the programmer is expected to save local variables manually in his own data structures , just like in event - driven style .    _ tame _ @xcite is a c++ language extension and library which exposes events to the programmer but does not impose event - driven style : it generates state machines to avoid the stack ripping issue and retain a thread - like feeling . similarly to weave",
    ", the programmer needs to annotate local variables that must be saved across context switches .",
    "_ taskjava _ @xcite implements the same idea as tame , in java , but preserves local variables automatically , storing them in a state record .",
    "@xcite is a message - passing framework for java providing actor - based , lightweight threads .",
    "it is also implemented by a partial cps conversion performed on annotated functions , but contrary to taskjava , it works at the jvm bytecode level .",
    "@xcite is a conservative extension of javascript for writing asynchronous rpc , compiled to plain javascript using some kind of ad - hoc splitting and cps conversion .",
    "interestingly enough , the authors note that , in spite of javascript s support for nested functions , they need to perform `` function denesting '' for performance reasons ; they store free variables in environments ( `` closure objects '' ) rather than using lambda lifting .",
    "@xcite is a set of language constructs for composable asynchronous i / o in c and c++ .",
    "harris et al .",
    "introduce ` do ..",
    "finish ` and ` async ` operators to write asynchronous requests in a synchronous style , and give an operational semantics .",
    "the language constructs are somewhat similar to those of tame but the implementation is very different , using llvm code blocks or macros based on gcc s nested functions rather than source - to - source transformations .",
    "because event - driven programs do not use the native call stack to store return addresses and local variables , they must encode the control flow and data flow in data structures , the bookkeeping of which is the programmer s responsibility .",
    "this yields a diversity of styles among event - driven programs , depending on the programmer s taste , creativity , and his perception of efficiency . in this section ,",
    "we analyse how control flow and data flow are encoded in several examples of real - world event - driven programs , and compare them to equivalent threaded - style programs .",
    "two main techniques are used to represent the control flow in event - driven programming : callbacks and state machines .",
    "[ [ callbacks ] ] callbacks",
    "+ + + + + + + + +    most of the time , control flow is implemented with _",
    "callbacks_. instead of performing a blocking function call , the programmer calls a non - blocking equivalent that cooperates with the event loop , providing a function pointer to be called back once the non - blocking call is done .",
    "this callback function is actually the continuation of the blocking operation .",
    "developing large programs raises the issue of composing event handlers . whereas threaded code has return addresses stored on the stack and a standard calling sequence to coordinate the caller and the callee , event - driven code needs to define its own strategy to layer callbacks , storing the callback to the next layer in some data structure associated with the event handler .",
    "the `` continuation stack '' of callbacks is often split in various places of the code , each callback encoding its chunk of the stack in an ad - hoc manner .    consider for instance the accept loop of an http server that accepts clients and starts two tasks for each of them : a client handler , and a timeout to disconnect idle clients . with cooperative threads ,",
    "this would be implemented as a mere infinite loop with a cooperation point .",
    "the following code is an example of such an accept loop written with cpc .    ....",
    "cps int cpc_accept(int fd ) {    cpc_io_wait(fd , cpc_io_in ) ;    return accept(fd , null , null ) ; } cps int accept_loop(int fd ) {    int client_fd ;    while(1 ) {      client_fd = cpc_accept(fd ) ;      cpc_spawn httptimeout(client_fd , clienttimeout ) ;      cpc_spawn httpclienthandler(client_fd ) ;    } } ....    the programmer calls ` cpc_spawn accept_loop(fd ) ` to create a new thread that runs the accept loop ; the function ` accept_loop ` then waits for incoming connections with the cooperating primitive ` cpc_io_wait ` , and creates two new threads for each client ( ` httptimeout ` and ` httpclienthandler ` ) , which kill each other upon completion .",
    "note that cooperative functions are annotated with the ` cps ` keyword ; such _ cps _ functions are to be converted into event - driven style by the cpc translator .    shows the ( very simplified ) code of the accepting loop in polipo , a caching web - proxy written by chroboczek .",
    "this code is equivalent to the threaded version above , and uses several levels of callbacks .    0.8    [ source , numberlines ] ---- fdeventhandlerptr schedule_accept(int fd ,      int ( * handler)(int , fdeventhandlerptr , acceptrequestptr ) ,      void * data ) {    fdeventhandlerptr event ;    acceptrequestrec request ;    int done ;      request.fd = fd ;    request.handler = handler ;                         /*@\\label{l : pol1}@*/    request.data = data ;    event = registerfdevent(fd , pollout|pollin ,        /*@\\label{l : pol2}@*/                do_scheduled_accept ,                sizeof(request ) , & request ) ;    return event ; }    int do_scheduled_accept(int status , fdeventhandlerptr event ) {    acceptrequestptr request = ( acceptrequestptr)&event->data ;    int rc , done ;      rc = accept(request->fd , null , null ) ;              /*@\\label{l : pol3}@*/    done = request->handler(rc , event , request ) ;       /*@\\label{l : pol4}@*/    return done ; }    int httpaccept(int fd , fdeventhandlerptr event ,             acceptrequestptr request ) {    httpconnectionptr connection ;    timeeventhandlerptr timeout ;      connection = httpmakeconnection();/*@\\label{l : pol7}@*/    timeout = scheduletimeevent(clienttimeout ,         /*@\\label{l",
    ": pol5}@*/                  httptimeouthandler ,                  sizeof(connection ) , & connection ) ;    connection->fd = fd ;    connection->timeout = timeout ;    connection->flags = conn_reader ;    do_stream_buf(io_read | io_notnow ,                 /*@\\label{l : pol6}@*/           connection->fd , 0 , & connection->reqbuf ,            chunk_size , httpclienthandler , connection ) ;    return 0 ; } ----    in polipo , the accept loop is started by a call to ` schedule_accept(fd , httpaccept , null ) ` .",
    "this function stores the pointer to the ( second - level ) callback ` httpaccept ` in the ` handler ` field of the ` request ` data structure ( [ l : pol1 ] ) , and registers a ( first - level ) callback to ` do_scheduled_accept ` , through ` registerfdevent ` .",
    "each time the file descriptor ` fd ` becomes ready ( not shown ) , the event loop calls the ( first - level ) callback ` do_scheduled_accept ` , which performs the actual ` accept ` system call ( [ l : pol3 ] ) and finally invokes the ( second - level ) callback ` httpaccept ` stored in ` request->handler ` ( [ l : pol4 ] ) .",
    "this callback schedules two new event handlers , ` httptimeout ` and ` httpclienthandler ` .",
    "the former is a timeout handler , registered by ` scheduletimeevent ` ( [ l : pol5 ] ) ; the latter reacts i / o events to read requests from the client , and is registered by ` do_stream_buf ` ( [ l : pol6 ] ) .",
    "note that those helper functions that register callbacks with the event loop use other intermediary callbacks themselves , just like ` schedule_accept ` uses ` do_schedule_accept ` .    in the original polipo code",
    ", things are even more complex since ` schedule_accept ` is called from ` httpacceptagain ` , yet another callback that is registered by ` httpaccept ` itself in some error cases .",
    "the control flow becomes very hard to follow , in particular when errors are triggered : each callback must be prepared to cope with error codes , or to follow - up the unexpected value to the next layer . in some parts of the code , this style looks a lot like an error monad manually interleaved with a continuation monad . without a strict discipline and well - defined conventions about composition",
    ", the flexibility of callbacks easily traps the programmer in a control - flow and storage - allocation maze .",
    "[ [ state - machines ] ] state machines + + + + + + + + + + + + + +    when the multiplication of callbacks becomes unbearable , the event - loop programmer might refactor his code to use a state machine . instead of splitting a computation into as many callbacks as it has atomic steps , the programmer registers a single callback that will be called over and over until the computation is done .",
    "this callback implements a state machine : it stores the current state of the computation into an ad - hoc data structure , just like threaded code would store the program counter , and uses it upon resuming to jump to the appropriate location .",
    "shows how the initial handshake of a bittorrent connection is handled in _ transmission _",
    ", a popular and efficient bittorrent client written in ( mostly ) event - driven style .",
    "until the handshake is over , all data arriving from a peer is handed over by the event loop to the ` canread ` callback .",
    "this function implements a state machine , whose state is stored in the ` state ` field of a ` handshake ` data structure .",
    "this field is initialised to ` awaiting_handshake ` when the connection is established ( not shown ) and updated by the functions responsible for each step of the handshake .    0.8    [ source , numberlines ] ---- static readstate canread(struct evbuffer * inbuf , tr_handshake * handshake ) {    readstate ret = read_now ;      while(ret = = read_now ) {      switch(handshake->state ) {        case awaiting_handshake :                       /*@\\label{l : tr1}@*/          ret = readhandshake   ( handshake , inbuf ) ;          break ;        case awaiting_peer_id :                         /*@\\label{l : tr7}@*/          ret = readpeerid     ( handshake , inbuf ) ;          break ;        / * ... cases dealing with encryption omitted * /      }    }    return ret ;                                        /*@\\label{l : tr3}@*/ }    static int readhandshake(tr_handshake * handshake ,                struct evbuffer * inbuf ) {    uint8_t pstr[20 ] , reserved[handshake_flags_len ] ,        hash[sha_digest_length ] ;      if(evbuffer_get_length(inbuf )",
    "< incoming_handshake_len )      return read_later ;                               /*@\\label{l : tr2}@*/    tr_peerioreadbytes(handshake->io , inbuf , pstr , 20 ) ;    if(memcmp(pstr , \" \\023bittorrent protocol \" , 20 ) )    /*@\\label{l : tr4}@*/      return tr_handshakedone(handshake , false ) ;    tr_peerioreadbytes(handshake->io , inbuf , reserved , ... ) ;    tr_peerioreadbytes(handshake->io , inbuf , hash , ... ) ;    / * ... parsing of handshake and sending reply omitted   * /    handshake->state = awaiting_peer_id ;               /*@\\label{l : tr5}@*/    return read_now ;                                   /*@\\label{l :",
    "tr6}@*/ }    static int readpeerid(tr_handshake * handshake , struct evbuffer * inbuf ) {    uint8_t peer_id[peer_id_len ] ;      if(evbuffer_get_length(inbuf ) <",
    "peer_id_len )       /*@\\label{l : tr8}@*/      return read_later ;    tr_peerioreadbytes(handshake->io , inbuf , peer_id , ... ) ;    / * ... parsing of peer i d omitted * /    return tr_handshakedone(handshake , true ) ;          /*@\\label{l : tr9}@*/ } ----    the first part of the handshake is dispatched by ` canread ` to the ` readhandshake ` function ( [ l : tr1 ] ) .",
    "it receives the buffer ` inbuf ` containing the bytes received so far ; if not enough data has yet been received to carry on the handshake , it returns ` read_later ` to ` canread ` ( [ l : tr2 ] ) , which forwards it to the event loop to be called back when more data is available ( [ l : tr3 ] ) .",
    "otherwise , it checks the bittorrent header ( [ l : tr4 ] ) , parses the first part of the handshake , registers a callback to send a reply handshake ( not shown ) , and finally updates the state ( [ l : tr5 ] ) and returns ` read_now ` to indicate that the rest of the handshake should be processed immediately ( [ l : tr6 ] ) .",
    "note what happens when the bittorrent header is wrong ( [ l : tr4 ] ) : the function ` tr_handshakedone ` is called with ` false ` as its second parameter , indicating that some error occurred . this function (",
    "not shown ) is responsible for invoking the callback ` handshake->donecb ` and then deallocating the ` handshake ` structure .",
    "this is another example of the multiple layers of callbacks mentioned above .",
    "if the first part of the handshake completes without error , ` canread ` then dispatches the buffer to ` readpeerid ` which completes the handshake ( [ l : tr7 ] ) .",
    "just like ` readhandshake ` , it returns ` read_later ` if the second part of the handshake has not arrived yet ( [ l : tr8 ] ) and finally calls ` tr_handshakedone ` with ` true ` to indicate that the handshake has been successfully completed ( [ l : tr9 ] ) .    in the original code ,",
    "ten additional states are used to deal with the various steps of negotiating encryption keys .",
    "the last of these steps finally rolls back the state to ` awaiting_handshake ` and the keys are used by the function ` tr_peerioreadbytes ` to decrypt the rest of the exchange transparently .",
    "the state machine approach makes the code slightly more readable than using pure callbacks .",
    "since each callback function performs only a small part of the whole computation , the event - loop programmer needs to store temporary data required to carry on the computation in heap - allocated data structures , whereas stack - allocated variables would sometimes seem more natural in threaded style .",
    "the content of these data structures depends heavily on the program being developed but we can characterise some common patterns .",
    "event loops generally provide some means to specify a ` void * ` pointer when registering an event handler .",
    "when the expected event triggers , the pointer is passed as a parameter to the callback function , along with information about the event itself .",
    "this allows the programmer to store partial results in a structure of his choice , and recover it through the pointer without bothering to maintain the association between event handlers and data himself .",
    "[ [ coarse - grained - long - lived - data - structures ] ] coarse - grained , long lived data structures + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    these data structures are usually large and coarse - grained .",
    "each of them correponds to some meaningful object in the context of the program , and is passed from callback to callback through a pointer . for instance , the ` connection ` structure used in polipo ( ) is allocated by ` httpmakeconnection ` when a connection starts ( [ l : pol7 ] ) and passed to the callbacks ` httptimeouthandler ` and ` httpclienthandler ` through the registering functions ` scheduletimeevent ` ( [ l : pol5 ] ) and ` do_stream_buf ` ( [ l : pol6 ] ) .",
    "it lives as long as the http connection it describes and contains no less than 22 fields : ` fd ` , ` timeout ` , ` buf ` , ` pipelined ` ,  _ etc_. the ` tr_handshake ` structure passed to ` canread ` in transmission is similarly large , with 18 fields .",
    "some of these fields need to live for the whole connection ( eg .  ` fd ` which stores the file descriptor of the socket ) but others are used only transiently ( eg .  ` buf ` which is filled only when sending a reply ) , or even not at all in some cases ( eg .",
    "the structure ` httpconnectionptr ` is used for both client and server connections , but the ` pipelined ` field is never used in the client case ) .",
    "even if it wastes memory in some cases , it would be too much of a hassle for the programmer to track every possible data flow in the program and create ad - hoc data structures for each of them .",
    "[ [ minimal - short - lived - data - structures ] ] minimal , short - lived data structures + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in some simple cases , however , the event - loop programmer is able to allocate very small and short - lived data structures .",
    "these minimal data structures are allocated directly within an event handler and are deallocated when the associated callback returns .",
    "they might even be allocated on the stack by the programmer and copied inside the event - loop internals by the helper function registering the event handler .",
    "the overhead is therefore kept as low as possible .",
    "for instance , the function ` schedule_accept ` passes a tiny , stack - allocated structure ` request ` to the helper function ` registerfdevent ` ( [ fig : polipo ] , [ l : pol2 ] ) .",
    "this structure is of type ` acceptrequestrec ` ( not shown ) , which contains only three fields : an integer ` fd ` and two pointers ` handler ` and ` data ` .",
    "it is copied by ` registerfdevent ` in the event - loop data structure associated with the event , and freed automatically after the callback ` do_scheduled_accept ` has returned ; it is as short - lived and ( almost ) as compact as possible .",
    "as it turns out , creating truly minimal structures is hard : ` acceptrequestrec ` could in fact be optimised to get rid off the fields ` data ` , which is always ` null ` in practice in polipo , and ` fd ` , which is also present in the encapsulating ` event ` data structure .",
    "finding every such redundancy in the data flow of a large event - driven program would be a daunting task , hence the spurious and redundant fields used to lighten the programmer s burden .",
    "in this section , we first demonstrate the effect of cpc transformation passes on a small example ; we show that code produced by the cpc translator is very close to event - driven code using callbacks for control flow , and minimal data structures for data flow ( [ sec : cpc ] ) .",
    "we then show how two other classical translation passes produce different event - driven styles : _ defunctionalising _ inner function yields state machines ( [ sec : defun ] ) , and encapsulating local variables in _ shared environments _ yields larger , long - lived data structures with full context ( [ sec : env ] ) .",
    "consider the following function , which counts seconds down from an initial value  ` x ` to zero .",
    ".... cps void countdown(int x ) {    while(x > 0 ) {      printf(\"%d\\n \" , x-- ) ;      cpc_sleep(1 ) ;    }    printf(\"time is over!\\n \" ) ; } ....    this function is annotated with the ` cps ` keyword to indicate that it yields to the cpc scheduler .",
    "this is necessary because it calls the cpc primitive ` cpc_sleep ` , which also yields to the scheduler .",
    "the cpc translator is structured in a series of proven source - to - source transformations @xcite , which turn a threaded - style cpc program into an equivalent event - driven c program .",
    "_ boxing _ first encapsulates a small number of variables in environments . _",
    "splitting _ then splits the flow of control of each cps function into a set of inner functions . _",
    "lambda lifting _ removes free local variables introduced by the splitting step ; it copies them from one inner function to the next , yielding closed inner functions . finally , the program is in a form simple enough to perform a one - pass partial _",
    "cps conversion_. the resulting continuations are used at runtime to schedule threads .    in the rest of this section ,",
    "we show how splitting , lambda lifting and cps conversion transform the function ` countdown ` .",
    "the boxing pass has no effect on this example because it only applies to _ extruded _ variables , the address of which is retained by the `` address of '' operator ( ` & ` ) .",
    "[ [ splitting ] ] splitting + + + + + + + + +    the first transformation performed by the cpc translator is _",
    "splitting_. splitting has been first described by van wijngaarden for algol  60 @xcite , and later adapted by thielecke to c , albeit in a restrictive way @xcite .",
    "it translates control structures into mutually recursive functions .",
    "splitting is done in two steps .",
    "the first step consists in replacing every control - flow structure , such as ` for ` and ` while ` loops , by its equivalent in terms of ` if ` and ` goto ` .",
    ".... cps void countdown(int x ) {   loop :    if(x < = 0 ) goto timeout ;    printf(\"%d\\n \" , x-- ) ;    cpc_sleep(1 ) ;    goto loop ;   timeout :    printf(\"time is over!\\n \" ) ; } ....    the second step uses the fact that ` goto ` are equivalent to tail calls @xcite .",
    "it translates every labelled block into an inner function , and every jump to that label into a tail call ( followed by a ` return ` ) to that function .",
    "[ source , numberlines ] ---- cps void countdown(int x ) {   cps void loop ( ) {     if(x < = 0 ) { timeout ( ) ; return ; } /*@\\label{l : tp1}@*/     printf(\"%d\\n \" , x-- ) ;     cpc_sleep(1 ) ; loop ( ) ; return ; /*@\\label{l : tp2}@*/   }   cps void timeout ( ) { printf(\"time is over!\\n \" ) ; return ; } /*@\\label{l : tp3}@*/   loop ( ) ; return ; } ----    splitting yields a program where each cps function is split in several mutually recursive , atomic functions , very similar to event handlers .",
    "additionally , the tail positions of these inner functions are always either :    * a ` return ` statement ( for instance , on [ l : tp3 ] in the previous example ) , * a tail call to another cps function ( [ l : tp1 ] ) , * a call to an external cps function followed by a call to an inner cps function ( [ l : tp2 ] ) .",
    "we recognise the typical patterns of an event - driven program that we studied in [ sec : flow ] : respectively returning a value to the upper layer ( [ fig : polipo ] ( 4 ) ) , calling a function to carry on the current computation ( [ fig : transmission ] ( 1 ) ) , or calling a function with a callback to resume the computation once it has returned ( [ fig : polipo ] ( 2 ) ) .",
    "another effect of splitting is the introduction of free variables , which are bound to the original encapsulating function rather than the new inner ones .",
    "for instance , the variable ` x ` is free in the function ` loop ` above .",
    "because inner functions and free variables are not allowed in c , we perform a pass of lambda lifting to eliminate them .",
    "[ [ lambda - lifting ] ] lambda lifting + + + + + + + + + + + + + +    the cpc translator then makes the data flow explicit with a lambda - lifting pass .",
    "lambda lifting , also called closure conversion , is a standard technique to remove free variables introduced by johnsson @xcite .",
    "it is also performed in two steps : parameter lifting and block floating .",
    "parameter lifting binds every free variable to the inner function where it appears ( for instance ` x ` to ` loop ` on [ l : ll1 ] below ) .",
    "the variable is also added as a parameter at every call point of the function ( [ l : ll2,l : ll3 ] ) .",
    "[ source , numberlines ] ---- cps void countdown(int x ) {   cps void loop(int x ) { /*@\\label{l : ll1}@*/     if(x < = 0 ) { timeout ( ) ; return ; }     printf(\"%d\\n \" , x-- ) ;     cpc_sleep(1 ) ; loop(x ) ; return ; /*@\\label{l : ll2}@*/   }   cps void timeout ( ) { printf(\"time is over!\\n \" ) ; return ; }   loop(x ) ; return ; /*@\\label{l : ll3}@*/ } ----    note that because c is a call - by - value language , lifted parameters are duplicated rather than shared and this step is not correct in general .",
    "it is however sound in the case of cpc because lifted functions are called in tail position : they never return , which guarantees that at most one copy of each parameter is reachable at any given time @xcite .",
    "block floating is then a trivial extraction of closed , inner functions at top - level .",
    "lambda lifting yields a program where the data is copied from function to function , each copy living as long as the associated handler .",
    "if some piece of data is no longer needed during the computation , it will not be copied in the subsequent handlers ; for instance , the variable ` x ` is not passed to the function ` timeout ` . hence , lambda lifting produces short - lived , almost minimal data structures .",
    "[ [ cps - conversion ] ] cps conversion + + + + + + + + + + + + + +    finally , the control flow is made explicit with a cps conversion @xcite .",
    "the continuations store callbacks and their parameters in a regular stack - like structure ` cont ` with two primitive operations : ` push ` to add a function on the continuation , and ` invoke ` to call the first function of the continuation .    ....",
    "cps void loop(int x , cont * k ) {    if(x < = 0 ) { timeout(k ) ; return ; }    printf(\"%d\\n \" , x-- ) ;    cpc_sleep(1 , push(loop , x , k ) ) ; return ; } cps void timeout(cont * k ) {    printf(\"time is over!\\n \" ) ;    invoke(k ) ; return ; } cps void countdown(int x , cont * k ) { loop(x , k ) ; return ; } ....    cps conversion turns out to be an efficient and systematic implementation of the layered callback scheme described in [ sec : control - flow ] . note that , just like lambda lifting , cps conversion is not correct in general in an imperative call - by - value language , because of duplicated variables on the continuation .",
    "it is however correct in the case of cpc , for reasons similar to the correctness of lambda lifting @xcite .",
    "defunctionalisation is a compilation technique introduced by reynolds to translate higher - order programs into first - order ones @xcite .",
    "it maps every first - class function to a first - order structure that contains both an index representing the function , and the values of its free variables .",
    "these data structures are usually a constructor , whose parameters store the free variables .",
    "function calls are then performed by a dedicated function that dispatches on the constructor , restores the content of the free variables and executes the code of the relevant function .",
    "the dispatch function introduced by defunctionalisation is very close to a state automaton .",
    "it is therefore not surprising that defunctionalising inner functions in cpc yields an event - driven style similar to state machines ( [ sec : control - flow ] ) .",
    "[ [ defunctionalisation - of - cpc - programs ] ] defunctionalisation of cpc programs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    usually , defunctionalisation contains an implicit lambda - lifting pass , to make free variables explicit and store them in constructors . for example , a function ` fn x = >",
    "x + y ` would be replaced by an instance of ` lambda of int ` , with the free variable ` y ` copied in the constructor ` lambda ` .",
    "the dispatch function would then have a case : ` dispatch ( lambda y , x ) = x + y ` .    in this discussion",
    ", we wish to decouple this data - flow transformation from the translation of the control flow into a state machine .",
    "therefore , we define the dispatch function as an inner function which merges the content of the other inner functions but still contains free variables .",
    "this is possible because the splitting pass does not create any closure : it introduces inner functions with free variables , but these are always called directly , not stored as first - class values whose free variables must be captured .",
    "consider again our countdown example after the splitting pass ( [ lst : split ] ) .",
    "once defunctionalised , it contains a single inner function ` dispatch ` that dispatches on an enumeration representing the former inner function ` loop ` and ` timeout ` .",
    "[ source , numberlines ] ---- enum state { loop , timeout } ; cps void countdown(int x ) {    cps void dispatch(enum state s ) {      switch(s ) {       case loop :        if(x",
    "< = 0 ) { dispatch(timeout ) ; return ; } /*@\\label{l : df1}@*/        printf(\"%d\\n \" , x-- ) ;        cpc_sleep(1 ) ; dispatch(loop ) ; return ; /*@\\label{l : df2}@*/       case timeout :        printf(\"time is over!\\n \" ) ; return ;      }    }    dispatch(loop ) ; return ; } ----    as an optimisation , the recursive call to ` dispatch ` on [ l : df1 ] can be replaced by a ` goto ` statement . however",
    ", we can not replace the call that follows the cps function ` cpc_sleep(1 ) ` on [ l : df2 ] , since we will need to provide ` dispatch ` as a callback to ` cpc_sleep ` during cps conversion , to avoid blocking .",
    "we must then eliminate free variables and inner functions , with a lambda - lifting pass .",
    "it is still correct because defunctionnalisation does not break the required invariants on tail calls .",
    "we finally reach code that is similar in style to the state - machine shown in [ fig : transmission ] .",
    ".... cps void dispatch(enum state s , int x ) {    switch(s ) {     case loop :      if(x < = 0 ) goto timeout_label ;      printf(\"%d\\n \" , x-- ) ;      cpc_sleep(1 ) ; dispatch(loop , x ) ; return ;     case timeout : timeout_label :      printf(\"time is over!\\n \" ) ; return ;    } } cps void countdown(int x ) { dispatch(loop , x ) ; return ; } ....    in this example , we have also replaced the first occurrence of ` dispatch ` with ` goto timeout_label ` , as discussed above , which avoids the final function call when the counter reaches zero .",
    "if we ignore the ` switch `  which serves mainly as an entry point to the dispatch function ,  la duff s device @xcite  we recognise the intermediate code generated during the first step of splitting , as having an explicit control flow using gotos but without inner functions .",
    "in retrospect , the second step of splitting , which translates gotos to inner functions , can be considered as a form a _ refunctionalisation _ , the left - inverse of defunctionalisation @xcite .",
    "[ [ benefits ] ] benefits + + + + + + + +    the translation presented here is in fact a _ partial _ defunctionalisation : each cps function in the original program gets its own dispatch function , and only inner functions are defunctionalised . a global defunctionalisation would imply a whole program analysis , would break modular compilation , and would probably not be very efficient because c compilers are optimised to compile hand - written , reasonably - sized functions rather than a giant state automaton with hundreds of states .",
    "on the other hand , since it is only partial , this translation does not eliminate the need for a subsequent cps conversion step to translate calls to external cps functions into operations on continuations .    despite adding a new translation step while keeping the final cps conversion ,",
    "this approach has several advantages over the cps conversion of many smaller , mutually recursive functions performed by the current cpc translator .",
    "first , we do not pay the cost of a cps call for inner functions .",
    "this might bring significant speed - ups in the case of tight loops or complex control flows .",
    "moreover , it leaves with much more optimisation opportunities for the c compiler , for instance to store certain variables in registers , and reduces the number of operations on the continuations .",
    "it also makes debugging easier , avoiding numerous hops through ancillary cps functions .",
    "the two main compilation techniques to handle free variables are lambda lifting , illustrated in [ sec : cpc ] and discussed extensively in a previous article @xcite , and _ environments_. an environment is a data structure used to capture every free variable of a first - class function when it is defined ; when the function is later applied , it accesses its variables through the environment .",
    "environments add a layer of indirection , but contrary to lambda lifting they do not require free variables to be copied on every function call .    in most functional languages ,",
    "each environment represents the free variables of a single function ; a pair of a function pointer and its environment is called a closure",
    ". however , nothing prevents in principle an environment from being _ shared _ between several functions , provided they have the same free variables .",
    "we use this technique to allocate a single environment shared by inner functions , containing all local variables and function parameters .",
    "[ [ an - example - of - shared - environments ] ] an example of shared environments + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    consider once again our countdown example after splitting ( [ lst : split ] ) .",
    "we introduce an environment to contain the local variables of ` countdown ` ( here , there is only ` x ` ) .",
    "[ source , numberlines ] ---- struct env_countdown { int x } ; cps void countdown(int x ) {    struct env_countdown * e =       malloc(sizeof(struct env_countdown ) ) ; /*@\\label{l : env1}@*/    e->x = x ;   /*@\\label{l : env2}@*/    cps void loop(struct env_countdown * e ) {      if(e->x < = 0 ) { timeout ( ) ; return ; } /*@\\label{l : env3}@*/      printf(\"%d\\n \" , e->x-- ) ; /*@\\label{l : env4}@*/      cpc_sleep(1 ) ; loop(e ) ; return ; /*@\\label{l : env5}@*/    }    cps void timeout(struct env_countdown * e ) {      printf(\"time is over!\\n \" ) ;      free(e ) ; return ; /*@\\label{l : env6}@*/    }    loop(e ) ; return ; } ----    the environment is allocated ( [ l : env1 ] ) and initialised ( [ l : env2 ] ) when the function ` countdown ` is entered . the inner functions access ` x ` through the environment , either to read ( [ l : env3 ] ) or to write it ( [ l : env4 ] ) .",
    "a pointer to the environment is passed from function to function ( [ l : env5 ] ) ; hence all inner functions share the same environment .",
    "finally , the environment is deallocated just before the last inner function exits ( [ l : env6 ] ) .",
    "the resulting code is similar in style to hand - written event - driven code , with a single , heap - allocated data structure sharing the local state between a set of callbacks .",
    "note that inner functions have no remaining free variable and can therefore be lambda - lifted trivially .    [ [ benefits-1 ] ] benefits + + + + + + + +    encapsulating local variables in environments avoids having to copy them back and forth between the continuation and the native call stack .",
    "however , it does not necessarily mean that the generated programs are faster ; in fact , lambda - lifted programs are often more efficient ( [ sec : ecpc ] ) .",
    "another advantage of environments is that they make programs easier to debug , because the local state is always fully available , whereas in a lambda - lifted program `` useless '' variables are discarded as soon as possible , even though they might be useful to understand what went wrong before the program crashed .",
    "in this section , we describe the implementation of ecpc , a cpc variant using shared environments instead of lambda lifting to encapsulate the local state of cps functions .",
    "we then compare the efficiency of programs generated with ecpc and cpc , and show that the latter is more efficient in most cases .",
    "this demonstrates the benefits of generating events automatically : most real - world event - driven programs are based on environments , because they are much easier to use , although systematic lambda lifting would probably yield faster code .",
    "the implementation of ecpc is designed to reuse as much of the existing cpc infrastructure as possible .",
    "the ecpc translator introduces two new passes : _ preparation _ and _ generation _ of environments .",
    "the former replaces the boxing pass ; the latter replaces lambda lifting .",
    "[ [ environment - preparation ] ] environment preparation + + + + + + + + + + + + + + + + + + + + + + +    environments must be introduced before the splitting pass for two reasons .",
    "first , it is easier to identify the exit points of cps functions , where the environments must be deallocated , before they are split into multiple , mutually recursive , inner functions .",
    "furthermore , these environment deallocations occur in tail position , and have therefore an impact on the splitting pass itself .",
    "although deallocation points are introduced before splitting , neither allocation nor initialisation or indirect memory accesses are performed at this stage .",
    "environments introduced during this preparatory pass are empty shells , of type ` void * ` , that merely serve to mark the deallocation points .",
    "this is necessary because not all temporary variables have been introduced at this stage ( the splitting pass will generate more of them ) .",
    "deciding which variables will be stored in environments is delayed to a later pass .",
    "this preparatory pass also needs to modify how return values are handled . in the original cpc ,",
    "return values are written directly in the continuation when the returning function invokes its continuation .",
    "this is made possible by the convention that the return value of a cps function is the last parameter of its continuation , hence at a fixed position on the continuation stack .",
    "such is not the case in ecpc , where function parameters are kept in the environment rather than copied on the continuation .    in ecpc ,",
    "the caller function passes a pointer to the callee , indicating the address where the callee must write its return value .",
    "the preparatory pass transforms every cps function returning a type @xmath0 ( different from ` void ` ) into a function returning ` void ` with an additional parameter of type @xmath1 ; call and return points are modified accordingly . the implementation of cpc primitives in the cpc runtime is also modified to reflect this change .",
    "[ [ environment - generation ] ] environment generation + + + + + + + + + + + + + + + + + + + + + +    after the splitting pass , the ecpc translator allocates and initialises environments , and replaces variables by their counterpart in the environment .",
    "first , it collects local variables ( except the environment pointer itself ) and function parameters and generates the layout of the associated environment .",
    "then , it allocates the environment and initialises the fields corresponding to the function parameters .",
    "because this initialisation is done at the very beginning of the translated function , it does not affect the tails , thus preserving the correctness of cps conversion .",
    "finally , every use of variables is replaced by its counterpart in the environment , local variables are discarded , and inner functions are modified to receive the environment as a parameter instead .    the cps conversion is kept unchanged : the issue of return values is dealt with completely in the preparatory pass and every cps function returns ` void ` at this stage .",
    "we previously designed a set of benchmarks to compare cpc to other thread libraries , and have shown that cpc is as fast as the fastest thread libraries available to us while providing at least an order of magnitude more threads @xcite .",
    "we reuse these benchmarks here to compare the speed of cpc and ecpc ; our experimental setup is unchanged , and detailed in our previous work .    [ [ primitive - operations ] ] primitive operations + + + + + + + + + + + + + + + + + + + +    we first measure the time of individual cpc primitives . shows the relative speed of ecpc compared with cpc for each of our micro - benchmarks : @xmath2 .",
    "a value greater than 1 indicates that ecpc is slower than cpc .",
    "the slowest primitive operation in cpc is a cps function call ( _ cps - call _ ) , mostly because of the multiple layers of indirection introduced by continuations .",
    "this overhead is even larger in the case of ecpc : performing a cps function call is 2  to 3  times slower than with cpc .",
    ".ratio of speeds of ecpc to cpc [ cols=\"<,>,>,>,>\",options=\"header \" , ]     [ tab : speed ]    this difference of cost for cps function calls probably has an impact on the other benchmarks , making them more difficult to interpret .",
    "context switches ( _ switch _ ) are around 50% slower on every architecture , which is surprisingly high since they involve almost no manipulation of environments .",
    "thread creation ( _ spawn _ ) varies a lot across architectures : more than 3  times slower on the pentium  m , but only 59% slower on a mips embedded processor .",
    "finally , condition variables ( _ condvar _ ) are even more surprising : not much slower on x86 and x86 - 64 , and even 9% faster on mips .",
    "it is unclear which combination of factors leads ecpc to outperform cpc on this particular benchmark only : we believe that the larger number of registers helps to limit the number of memory accesses , but we were not able to quantify this effect precisely .",
    "these benchmarks of cpc primitives show that the allocation of environments slows down ecpc in most cases , and confirms our intuition that avoiding boxing as much as possible in favour of lambda lifting is very important in cpc .",
    "[ [ tic - tac - toe - generator ] ] tic - tac - toe generator + + + + + + + + + + + + + + + + + + + + +    unfortunately , benchmarking individual cpc primitives gives little information on the performance of a whole program , because their cost might be negligible compared to other operations . to get a better understanding of the performance behaviour of ecpc",
    ", we wrote a trivial but highly concurrent program with intensive memory operations : a tic - tac - toe generator that explores the space of grids .",
    "it creates three threads at each step , each one receiving a copy of the current grid , hence @xmath3 threads and as many copies of the grid .",
    "we implemented two variants of the code , to test different schemes of memory usage .",
    "the former is a manual scheme that allocates copies of the grids with ` malloc ` before creating the associated threads , and frees each of them in one of the `` leaf '' threads , once the grid is completed .",
    "the latter is an automatic scheme that declares the grids as local variables and synchronises their deallocation with barriers ; the grids are then automatically encapsulated , either by the boxing pass ( for cpc ) or in the environment ( for ecpc ) .",
    "our experiment consists in launching an increasing number of generator _ tasks _ simultaneously , each one generating the 19683 grids and threads mentioned above .",
    "we run up to 100 tasks simultaneously , ie .",
    "almost 2000000 cpc threads in total , and the slowest benchmark takes around 3  seconds to complete on an intel centrino 1,87  ghz , downclocked to 800  mhz .    finally , we compute the mean time per tic - tac - toe task .",
    "this ratio turns out to be independent of the number of simultaneous tasks : both cpc and ecpc scale linearly in this benchmark .",
    "we measured that ecpc is 20% slower than cpc in the case of manual allocation ( 13.2 vs. 11.0 ms per task ) , and 18% slower in the automatic case ( 31.3 vs. 26.5 ms per task ) .",
    "this benchmark confirms that environments add a significant overhead in programs performing a lot a memory accesses , although it is not as important as in benchmarks of cpc primitives .",
    "[ [ web - servers ] ] web servers + + + + + + + + + + +    to evaluate the impact of environments on more realistic programs , we reuse our web server benchmark @xcite .",
    "we measure the mean response time of a small web server under the load of an increasing number of simultaneous clients .",
    "the server is deliberately kept minimal , and uses one cpc thread per client .",
    "the results are shown in [ fig : ecpc - servers ] . in this benchmark ,",
    "the web server compiled with ecpc is 12% slower than the server compiled with cpc . even on programs that spend most of their time",
    "performing network i / o , the overhead of environments remains measurable .",
    "through the analyse of real - world programs , we have identified several typical styles of control - flow and data - flow encodings in event - driven programs : callbacks or state machines for the control flow , and coarse - grained or minimal data structures for the data flow .",
    "we have then shown how these various styles can be generated from a common threaded description , by a set of automatic program transformations .",
    "finally , we have implemented ecpc , a variant of the cpc translator using shared environments instead of lambda lifting .",
    "we have found out that , although rarely used in real - world programs because it is tedious to perform manually , lambda lifting yields better performance than environments in most of our benchmarks .",
    "an interesting extension of our work would be to try and reverse our program transformations , in order to reconstruct threaded code from event - driven programs .",
    "this could help analysing and debugging event - driven code , or migrating legacy , hard - to - maintain event - driven programs like polipo towards cpc or other cooperative threads implementations .",
    "adya , a. , howell , j. , theimer , m. , bolosky , w.j . ,",
    "douceur , j.r .",
    ": cooperative task management without manual stack management . in : ellis ,",
    "usenix annual technical conference , general track .",
    ". 289302 .",
    "usenix ( 2002 )          dunkels , a. , schmidt , o. , voigt , t. , ali , m. : protothreads : simplifying event - driven programming of memory - constrained embedded systems . in : campbell , a.t . ,",
    "bonnet , p. , heidemann , j.s .",
    "acm ( 2006 )                                van wijngaarden , a. : recursive definition of syntax and semantics . in : formal language description languages for computer programming .",
    "north - holland publishing company , amsterdam , netherlands ( 1966 )"
  ],
  "abstract_text": [
    "<S> threads and events are two common abstractions for writing concurrent programs . because threads are often more convenient , but events more efficient , it is natural to want to translate the former into the latter . </S>",
    "<S> however , whereas there are many different event - driven styles , existing translators often apply ad - hoc rules which do not reflect this diversity .    </S>",
    "<S> we analyse various control - flow and data - flow encodings in real - world event - driven code , and we observe that it is possible to generate any of these styles automatically from threaded code , by applying certain carefully chosen classical program transformations . </S>",
    "<S> in particular , we implement two of these transformations , lambda lifting and environments , in cpc , an extension of the c language for writing concurrent systems . </S>",
    "<S> finally , we find out that , although rarely used in real - world programs because it is tedious to perform manually , lambda lifting yields better performance than environments in most of our benchmarks . </S>"
  ]
}