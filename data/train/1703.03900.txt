{
  "article_text": [
    "as a basic index describing the cohesiveness of a graph , the core number of vertex has been broadly utilized in graph analytics .",
    "specifically , in a graph @xmath0 , the @xmath1-core is the connected subgraph in @xmath0 , such that each vertex in the subgraph has at least @xmath1 neighbors . the core number of a vertex @xmath2 is then defined as the largest @xmath1 such that there exists a @xmath1-core containing @xmath2 .",
    "the parameter of core number is also extensively used in a large number of other applications , to analyze the structure of a network , such as analyzing the topological structure of internet @xcite , identifying influential spreader in complex networks @xcite , analyzing the structure of large - scale software systems @xcite@xcite , predicting the function of biology network @xcite , and visualizing large networks @xcite and so on .    in static graphs ,",
    "the computation of the core number of each vertex is known as the @xmath1-core decomposition problem , which has been extensively studied .",
    "the state - of - the - art algorithm is the one proposed in @xcite .",
    "it can compute the core number of each vertex in @xmath3 time and @xmath4 is the number of edges in the graph .",
    "however , in many real - world applications , graphs are changing continuously , due to edge / vertex insertions / deletions . in such dynamic graphs ,",
    "many applications need to maintain the core number for each vertex in real - time .",
    "hence , it is very necessary to study the core maintenance problem , i.e. , update the core numbers of vertices in dynamic graphs .    an intuitive way to solve",
    "the core maintenance problem is recomputing the core numbers of vertices after every change of the graph . but clearly , this manner is too expensive in large - scale graphs where there might be billions of vertices and trillions of edges .",
    "another manner is just to find the set of vertices whose core numbers will be definitely changed and then update the core numbers of these vertices . however , this manner faces several challenges .",
    "first , the exact change value of core number of a vertex is not easy to determine , even if the same number of edges are inserted to a vertex , as shown in fig .",
    "[ insert2edges ] .",
    "second , the set of vertices that will change the core number after a graph change is also hard to identify . as shown in fig  [ insert1edge ]",
    ", the core numbers of all vertices may change even if we only insert an edge to the graph .    due to the great challenge posed in solving the core maintenance problem in dynamic graphs , previous works all focus on the case that only one edge is inserted into / deleted from the graph . in this scenario , it is easy to check that the core number of each vertex can be changed by at most 1 .",
    "hence , the first challenge discussed above is avoided , and it only needs to overcome the second difficulty . when multiple edges are inserted / deleted , these edges are processed sequentially , and the core numbers of vertices are updated after each execution of the single - edge update algorithm . however , the sequential processing approach incurs extra overheads when multiple edges are inserted / deleted , since it may unnecessarily repeatedly visit a vertex , as shown in fig . [ insertmatching ] . and",
    "on the other hand , it does not make full use of the multi - core machine and distributed systems .",
    "therefore , one natural question is whether we can investigate the parallelism in the edge processing procedure and devise parallel algorithm that suits to implement in multi - core machine and distributed systems . in this paper , we answer this question affirmatively by proposing parallel algorithms for core maintenance .",
    "the core maintenance in the scenarios of vertex insertion / deletion can be solved using algorithms for edge insertions / deletions .",
    "take vertex insertion as an example . by setting the initial core number of the inserted vertex as 0 and executing an algorithm for edge insertion to handle the inserted edges generated by the inserted vertices , the core maintenance with respect to vertex insertion can be solved .",
    "therefore , in this paper , we focus on the scenarios that there are only edges inserted into / deleted from the graph .",
    "specifically , the core maintenance problem with respect to edge insertions and deletions are called the _ incremental _ and _ decremental _ core maintenance respectively .",
    "our parallel algorithms are inspired by the single - edge insertion / deletion algorithms , such as those in @xcite .",
    "to overcome the two difficulties discussed before , we first study the available set of edges whose insertions / deletions only make the core numbers of vertices change by at most one . if the feature of an available set can be determined , then when such an available set of edges are inserted / deleted , each edge can be processed in parallel : by finding the set of vertices whose core number changes due to each particular edge in the available set , the union of these sets of vertices are just those that will change core numbers after inserting the available set of edges , as inserting / deleting the available set can make each vertex change the core number by at most one .",
    "based on this idea , we devise parallel algorithms consisting of two main steps : 1 ) split the inserted / deleted edges into multiple available sets , and 2 ) identify the vertices whose core numbers change after inserting / deleting each particular available set and update the core number of the vertices .",
    "@xmath5@xmath6 , all vertices increase the core number by one.,width=288 ]    @xmath7@xmath6,@xmath8@xmath9@xmath6,@xmath8@xmath10@xmath11@xmath12@xmath6 will be inserted into the graph .",
    "* traversal * algorithm in @xcite handle the inserted edges one by one .",
    "first for edge @xmath8@xmath7@xmath6 , it will visit vertices @xmath13 and update core numbers for @xmath13 from 2 to 3 . then inserting @xmath8@xmath10@xmath6",
    ", it will visit @xmath14 , and update core numbers of @xmath15 from 3 to 4 .",
    "the same goes for @xmath8@xmath9@xmath6 and @xmath8@xmath16@xmath6 . during the process",
    ", @xmath17 and @xmath18 will be visited for multiple times , but their core numbers are only changed for once . however in our parallel algorithm , all four edges can be processed in parallel using three processors , and duplicate visitings of @xmath13 can be avoided .",
    ", width=278 ]    our contributions are summarized as follows .",
    "* we show that if a matching ( a set of edges any pair in which do not have common endpoints ) is inserted / deleted , the core number of each vertex can change by at most one . *",
    "based on the structure of matching , we present parallel algorithms for incremental and decremental core maintenance respectively . because a matching can contain an edge connected to each vertex that have edges inserted / deleted , the parallel algorithms reduce the iterations for processing all inserted / deleted edges from @xmath19 in sequential approaches to @xmath20 , where @xmath19 denotes the number of inserted / deleted edges and @xmath21 denotes the maximum number of inserted / deleted edges connecting to a vertex . though the number of inserted / deleted edges can be large , it is still very small in contrast with the number of vertices in a large - scale graph",
    "hence , @xmath21 is small in real - world cases",
    ". our algorithms will provide good parallelism in reality .",
    "* we then conduct extensive experiments on both real - world and synthetic graphs , to evaluate the efficiency , stability , parallelism and scalability of the proposed algorithms .",
    "the experiment results show that our algorithms exhibit good stability and scalability .",
    "especially , our algorithms achieves better efficiency in handling graph changes of large size . comparing with sequential algorithms ,",
    "our algorithms speed up the core number update process on all datasets .",
    "in large - scale graphs , such as livejournal graph ( refer to table [ table_graph ] in section  [ sec : experiment ] ) , the speedup ratio can be up to 3 orders of magnitude when handling the insertion / deletion of 20000 edges .    the rest of this paper",
    "is organized as follows . in section  [ sec : relate ] , we briefly review closely related works . in section  [ sec : problem ] , the problem definitions are given .",
    "theoretical results supporting the algorithm design are presented in section  [ sec : basis ] .",
    "the incremental and decremental parallel algorithms are proposed in section  [ sec : in ] and section  [ sec : de ] respectively . in section  [ sec : experiment ] , the experiment results are illustrated and analyzed .",
    "the whole paper is concluded in section  [ sec : conclusion ] .",
    "in static graphs , the core decomposition problem , which is to compute the core numbers of vertices , have been widely studied . in @xcite ,",
    "an @xmath3 time algorithm was presented , where @xmath4 is the number of edges in the graph .",
    "this result is the state - of - the - art one . in @xcite ,",
    "an external - memory algorithm was proposed when the graph is too large to hold in memory .",
    "core decomposition in the distributed setting was studied in @xcite .",
    "the above three algorithms were compared in @xcite under the graphchi and webgraph models .",
    "parallel core decomposition was studied in @xcite .",
    "in contrast , the work on core maintenance in dynamic graphs are fewer , and all known results focus on the single - edge insertion / deletion case .",
    "specifically , in @xcite , it was shown that when one edge is inserted / deleted , the core number of any vertex can change by at most one .",
    "based on this observation , a linear algorithm named * traversal * was proposed to identify vertices that change core numbers due to the inserted / deleted edges .",
    "a similar result was also given in @xcite .",
    "in @xcite , how to improve the i / o efficiency was studied , when computing and maintaining the core numbers of vertices .",
    "distributed solutions for core maintenance of single - edge change were studied in @xcite and @xcite .",
    "we consider an undirected , unweighted simple graph @xmath22 , where @xmath23 is the set of vertices and @xmath24 is the set of edges .",
    "let @xmath25 and @xmath26 .",
    "for a vertex @xmath27 , the set of its neighbors in @xmath0 is denoted as @xmath28 , i.e. , @xmath29 .",
    "the number of @xmath30 s neighbors in @xmath0 is called the degree of @xmath30 , denoted as @xmath31 .",
    "so @xmath32 .",
    "the maximum and minimum degree of nodes in @xmath0 is denoted as @xmath33 and @xmath34 respectively .",
    "we next give formal definitions for the _ core number _ of a vertex and other related concepts .",
    "[ de : kcore ] given a graph @xmath35 and an integer @xmath1 , the @xmath1-core is a connected subgraph @xmath36 of @xmath0 , in which each vertex has at least @xmath1 neighbors , i.e. , @xmath37 .    given a graph @xmath35",
    ", the core number of a vertex @xmath38 , denoted by @xmath39 , is the the largest @xmath1 , such that there exists a @xmath1-core containing @xmath30 . for simplicity",
    ", we use @xmath40 to denote @xmath39 when the context is clear .",
    "the max - k - core associated with a vertex @xmath30 , denoted by @xmath41 , is the @xmath1-core with @xmath42 .    in this work",
    ", we aim at maintaining the core numbers of vertices in dynamic graphs .",
    "specifically , we define two categories of graph changes : _ incremental _ , where a set of edges @xmath43 are inserted to the original graph , and _ decremental _ , where a set of edges are deleted .",
    "based on the above classification , we distinguish the core maintenance problem into two scenarios , as defined below .    given a graph @xmath35 , the incremental core maintenance problem is to update the core numbers of vertices after an incremental change to @xmath0 .",
    "given a graph @xmath35 , the decremental core maintenance problem is to update the core numbers of vertices after a decremental change to @xmath0 .",
    "the _ core number _ of an edge is defined as the larger value of the core numbers of its endpoints .",
    "a set of edges @xmath44 is called a _ matching _ , if for each pair of edges in @xmath43 , they do not have common endpoints . if all edges in a matching have the same core number @xmath1 , the matching",
    "is called a _",
    "@xmath1-matching_.    we next give some notations that help identify the set of vertices which will change core numbers after graph change . given a graph @xmath35 , let @xmath45 be the graph obtained after inserting / deleting an edge set @xmath43 into / from @xmath0 .    [ de : sd ] for a vertex @xmath27 , @xmath2 is a _ superior neighbor _ of @xmath30 if @xmath2 is a neighbor of @xmath30 in @xmath45 and @xmath46 .",
    "the number of @xmath30 s superior neighbors is called the _ superior degree _ of @xmath30 , denoted as @xmath47 .",
    "the @xmath48 value of a vertex @xmath30 represents the number of neighbors that have a core number no less than @xmath39 .",
    "it is easy to see that only superior neighbors of @xmath30 may affect its core number change .",
    "the _ constraint superior degree _",
    "@xmath49 of a vertex @xmath30 is the number of @xmath30 s neighbors @xmath50 in @xmath45 that satisfies @xmath51 or @xmath52 .",
    "the constraint superior degree of a vertex @xmath30 counts for two categories of neighbors that will affect the increase of @xmath30 s core number : the ones that have larger core numbers and those that have the same core number but have enough neighbors which may make themselves increase the core number .    when the context is clear , we use @xmath53 and @xmath54 to present the @xmath48 and @xmath55 values of vertex @xmath30 in the current new graph .    in the insertion case , for a vertex @xmath30 , if @xmath56 , then @xmath30 can not increase its core number , since it does not have enough support neighbors .",
    "we summarize this necessary condition formally as below and will use it to determine whether a vertex is impossible to increase the core number .",
    "[ le : inserne ] for a vertex @xmath30 , if @xmath56 , @xmath2 will not increase its core number .    similarly , we can get a sufficient condition for a vertex to decrease the core number in the deletion case .",
    "[ corollary : sd ] for a vertex @xmath30 with core number @xmath1 , if @xmath57 , then @xmath30 will decrease the core number .",
    "in this section , we show some theoretical lemmas that constitute the theoretical basis of our algorithms .    the following lemma shows how the core number change after inserting an edge @xmath58 , which is presented in @xcite .    for a graph @xmath59 ,",
    "if an edge is inserted into or deleted from @xmath0 , then the core number of vertex @xmath60 can change by at most 1 .    as the lemma shown , if an edge @xmath61 is inserted into the graph , for any vertex in @xmath0 , its core number can change by at most 1 .",
    "we denote the vertices whose core numbers change after the insertion as the updated vertex set @xmath62 .",
    "so after inserting an edge @xmath58 , we just need to find the updated vertex set @xmath62 and increase their core numbers by 1 .    in the following",
    ", we will show that the core number of every vertex can change by at most 1 after inserting / deleting a specific edge set ( lemma [ lem : matchinginsert ] and lemma [ lem : matchingdelete ] ) .",
    "then we give a sufficient condition for identifying vertices whose core numbers change ( lemma [ lem : expt ] and corollary [ corollary : sd ] ) .      in this section ,",
    "we first give the definition of * k - matching edge set * which can be inserted together and    an edge set @xmath63 is called an @xmath1-matching edge set , if for each edge @xmath64 , it satisfies :    \\(i ) @xmath65 is an edge with core number @xmath1 .",
    "\\(ii ) for all @xmath65 and @xmath66 there is no common endpoint .    in other words , in a @xmath1-matching edge set @xmath67 , each edge has a core number @xmath1 , and all edges are disjoint .",
    "[ lem : decreaseby1 ] for a graph @xmath68 , @xmath69 , that is to say , @xmath36 is a @xmath1-core .",
    "@xmath70 , @xmath71 , if a @xmath1-matching edge set is removed from @xmath36 , and @xmath36 becomes @xmath72 , then all vertices will has a core number no less than @xmath73 .",
    "first for each vertex @xmath2 that has @xmath74 , we should know that @xmath75 .",
    "then if a @xmath1-matching edge set is removed from @xmath36 , all vertices can decreases its degree by at most 1 , so @xmath76 . and because @xmath36 is a @xmath1-core , all vertices in @xmath36 has a degree of no less than @xmath1",
    ", so all vertices will has a degree no less than @xmath73 in @xmath72 .",
    "thus @xmath77 .",
    "[ lem : kmatchinginsert ] given a graph @xmath35 , if a @xmath1-matching edge set @xmath63 is inserted into @xmath0 , where @xmath78 , for each vertex @xmath2 , it holds that : + @xmath79 if @xmath74 , @xmath80 can increase by at most 1 ; + @xmath81 if @xmath82 , @xmath80 will not change .    for @xmath79 , we need to show that for a vertex @xmath2 with @xmath83 , @xmath80 can increase by at most 1 .",
    "otherwise , assume @xmath80 increases by @xmath84 to @xmath85 , where @xmath86 .",
    "let @xmath87 and @xmath88 be the max-@xmath1-core of @xmath2 before edge insertion and the max-@xmath89-core of @xmath2 after edge insertion respectively . then , @xmath90 .",
    "it can be concluded that one of inserted edges must belong to @xmath88 , as otherwise @xmath91 before insertion as well .",
    "let @xmath92 , then @xmath93 .",
    "according to lemma [ lem : decreaseby1 ] , @xmath94 , which is a contradiction since @xmath95 .",
    "hence , @xmath80 can increase by at most 1 .    for @xmath81",
    ", we need to show that for a vertex @xmath2 if @xmath82 , @xmath80 can not change .",
    "we consider two cases : @xmath96 and @xmath97 .",
    "assume @xmath98 increases by @xmath84 to @xmath99 , where @xmath100 .",
    "let @xmath87 and @xmath88 be the max-@xmath101-core of @xmath2 before edge insertion and the max-@xmath102-core after edge insertion respectively .",
    "then we have @xmath103 , @xmath104 .",
    "we first consider the @xmath105k@xmath106 case .",
    "there must be at least one of the edges @xmath65 in @xmath67 belonging to @xmath88 , as otherwise @xmath107 before edge insertion .",
    "consider the edge @xmath65 .",
    "at least one of its endpoints has a core number @xmath1 , since @xmath67 is a @xmath1-matching edge set .",
    "denote by @xmath108 the endpoint of @xmath65 with core number @xmath1 .",
    "as shown before , @xmath109 can increase by at most 1 .",
    "hence , after the edge insertion , @xmath110 .",
    "this means that @xmath108 is not in @xmath88 , which is a contradiction .",
    "therefore , if @xmath111 , @xmath80 will not change after the edge insertion .",
    "we next consider the @xmath112 case .",
    "similar as before , it can be shown that at least one of the edges @xmath113 in @xmath67 that is contained in @xmath88 .",
    "let @xmath92 .",
    "let @xmath30 be a vertex in @xmath114 , we consider three cases . if @xmath115 and as proved before , it can be obtained that @xmath116 .",
    "if @xmath117 , as shown before , the core number of @xmath30 will not be affected by the edge insertions .",
    "if @xmath118 , because @xmath104 , and @xmath30 does not connect to edges in @xmath67 , we can get that @xmath119 .",
    "let @xmath120 .",
    "based on above , it can be obtained that @xmath114 is a @xmath121-core and @xmath122 .",
    "but this contradicts with the fact that @xmath123",
    ". then we can get that the core number of @xmath2 does not change after inserting @xmath67 .    combining all above together",
    ", the lemma is proved .    in this section",
    ", we present some theoretical results that constitute the basis of our parallel algorithms .",
    "in particular , we first show that the core number of every vertex can change by at most one , if the inserted / deleted edges form a matching .",
    "and then we depict the feature of vertices whose core numbers will change after inserting / deleting a matching .      the main results are given in lemma [ lem : matchinginsert ] and lemma [ lem : matchingdelete ] below .",
    "at first , we prove the following lemma  [ lem : decreaseby1 ] , which is useful in proving lemma [ lem : matchinginsert ] and lemma [ lem : matchingdelete ] .",
    "[ lem : decreaseby1 ] for a @xmath1-core @xmath124 , @xmath69 , if after deleting a set of edges , @xmath36 becomes @xmath72 , where @xmath72 is still connected , and the degree of each vertex in @xmath36 is decreased by at most 1 , then @xmath72 will be a @xmath1-@xmath125-core .    after deleting the edges , it can be concluded that @xmath126 .",
    "then the result is obtained by definition  [ de : kcore ] .",
    "[ lem : matchinginsert ] given a graph @xmath35 , if a matching @xmath127 is inserted into @xmath0 , then the core number of every vertex @xmath128 can increase by at most 1 .",
    "first we assume that after the insertion , a vertex @xmath50 with core number @xmath1 increases the core number to @xmath85 , where @xmath86 .",
    "we denote the max-@xmath89-core of @xmath50 after the insertion is @xmath129 and the max-@xmath1-core of @xmath50 before insertion is @xmath130 , then @xmath131 and @xmath132",
    ". it must be true that at least one of the inserted edges @xmath133 for @xmath134 , as otherwise @xmath135 and @xmath136 , which is a contradiction .",
    "let @xmath137 , then @xmath93 . if @xmath114 is connected , @xmath114 will be a @xmath138-core by lemma [ lem : decreaseby1 ] , since the degree of every vertex in @xmath129 decreases by at most 1 due to the removal of a matching .",
    "this leads to a contradiction , since @xmath139 and @xmath130 is max-@xmath1-core in @xmath0 .",
    "if @xmath114 is disconnected , each connected component will be a @xmath138-core by lemma [ lem : decreaseby1 ] , since the degree of every vertex in each connected component decreases by at most 1 due to the removal of edges in @xmath140 .",
    "this also leads to a contradiction .",
    "the result is then proved .    using a similar argument as that for proving lemma [ lem : matchinginsert ]",
    ", we can get the result for deletion of a matching , as shown in the following lemma [ lem : matchingdelete ] .",
    "[ lem : matchingdelete ] given a graph @xmath35 , if a matching @xmath127 is deleted from @xmath0 , then for every @xmath141 , @xmath142 can decrease by at most 1",
    ".    * discussion . * in some sense , the matching may be the maximal structure of edges whose insertion / deletion only makes vertices change core number by at most 1 , as shown by the example given in fig .",
    "[ morethanmatching ] .",
    "@xmath7 @xmath6,@xmath8 @xmath10 @xmath6,@xmath8 @xmath9 @xmath6,@xmath8 @xmath12 @xmath143and an extra edge @xmath8 @xmath144 @xmath6 are inserted .",
    "the core number of vertex @xmath145 will increase by 2 , from 1 to 3.,width=288 ]    , after inserting the matching @xmath146 , the _ expath - tree _ of @xmath146 consists of k - path - tree of vertex @xmath147.notice that @xmath13 are in the same tree.,width=240 ]      we next identify the set of vertices whose core numbers change after a matching is inserted into / deleted from the graph .",
    "some notations will be first defined .",
    "consider the scenario defined as follows : given a graph @xmath35 and an edge set @xmath148 = \\{@xmath149 } , w.l.o.g . , assume that for each @xmath65 = @xmath150 , @xmath151 , where @xmath152 , @xmath153 , and @xmath154 .",
    "after @xmath148 is inserted into or deleted from @xmath0 , @xmath0 becomes a new graph @xmath155 .",
    "next , we define the @xmath1-path - tree and expath - tree in the following definitions  [ def : kpt_u ] and [ def : expath - tree ] .",
    "as shown later , after inserting / deleting a matching , only vertices on the expath - tree will change the core number .",
    "[ def : kpt_u ] for the new graph @xmath155 , @xmath156 , assume @xmath157 , the _ @xmath158-path - tree _ of @xmath30 is a dfs tree rooted at @xmath30 and each vertex @xmath50 in the tree satisfies @xmath159 .",
    "for simplicity we use @xmath160 to represent the k - path - tree of @xmath30 in @xmath45 .",
    "[ def : expath - tree ] for the new graph @xmath155 and the edge set @xmath148 , the union of k - path - tree for every @xmath161 is called the _ expath - tree _ of @xmath148 , denoted as @xmath162 .",
    "fig.[kpt ] shows an example of the _ @xmath158-path - tree _ and _ expath - tree_.    we first consider the case of inserting / deleting a @xmath1-matching .",
    "[ lem : kmatching ] given a graph @xmath35 , if a @xmath1-matching @xmath63 is inserted into or deleted from @xmath0 , where @xmath163 , we have    @xmath79 only vertices in @xmath164 may change the core number , where @xmath45 is the graph obtained from @xmath0 after inserting / deleting @xmath67 ;    @xmath81 the change is at most 1 .    we prove ( i ) first . in the insertion case",
    ", we first prove that if a vertex @xmath128 such that @xmath165 can not change its core number .",
    "assume @xmath166 increases to @xmath167 , denote the max - k - core of @xmath50 after insertion is @xmath168 , before insertion is @xmath41 .",
    "we know that @xmath41 is a @xmath169core and @xmath168 is a @xmath167-core .",
    "then at least one of the new edges must belong to @xmath168 , as otherwise @xmath41 would be a @xmath167-core before insertion .",
    "assume @xmath170 , and the core number change of @xmath50 is caused by the core number change of @xmath161 .",
    "then we have @xmath171 since @xmath172 and @xmath173 .",
    "removing the k - matching @xmath67 from @xmath0 will decrease the degree of @xmath174 by 1 and decrease their core number to at least @xmath167 .",
    "this implies @xmath175 is a @xmath167-core before insertion , which is a contradiction .",
    "so if a vertex has a core number not equal to @xmath1 , it can not change core number .",
    "then we prove that if a vertex @xmath128 such that @xmath176 but @xmath177 can not change its core number .",
    "assume @xmath50 increase its core number to @xmath167 .",
    "we can have that @xmath50 must either have a new neighbor or at least one of its neighbors increases core number .",
    "obviously @xmath50 do not have any new neighbor and we have proved that vertices whose core number is not equal to @xmath1 wont increase core number .",
    "so @xmath50 must have a neighbor whose core number is @xmath1 and increases core number . applying this recursively",
    ", we will finally reach a vertex @xmath30 whose core number change due to gaining a new neighbor , and vertices on the recursive path all have a core number @xmath1 , say , @xmath50 is in the @xmath178 , which is a contradiction .",
    "we have proved that for a vertex @xmath50 , if @xmath179 or @xmath180 but @xmath177 can not change its core number , so only vertices in the @xmath181 may have their core numbers increased , the insertion proof is completed .",
    "then the deletion case can be proved based on the insertion .",
    "we first insert the matching and then remove them from @xmath45 , we can have only vertices who increase core numbers after the insertion will decrease core number back to what they are in @xmath0 .",
    "that is to say , only vertices in the @xmath181 can have their core numbers decreased .",
    "\\(ii ) can be easily gained since @xmath182 and lemma [ lem : matchinginsert ] has proved inserting / deleting a matching @xmath140 makes all vertices change core number by at most 1 . combining all above together ,",
    "the lemma is proved .",
    "based on lemma [ lem : kmatching ] , we next consider the case of inserting / deleting a matching .",
    "[ lem : expt ] given a graph @xmath35 , if a matching @xmath183 is inserted into or deleted from @xmath0 , then we can have that only vertices @xmath50 on @xmath184 can change the core number and the change is at most 1 .",
    "it is easy to see that inserting / deleting a matching @xmath140 can have the same result as inserting / deleting the k - matchings in @xmath140 one by one .",
    "assume @xmath185 and @xmath186 where @xmath187 .",
    "we insert / delete the k - matchings one by one , and denote the graph after inserting / deleting @xmath188 as @xmath189 .    first for the insertion case , when inserting @xmath188 , by lemma [ lem : kmatching ] , we can know that , only vertices on @xmath190 can increase the core number by at most 1 . here",
    "notice that the core numbers of some vertices on @xmath190 may be @xmath191 in @xmath192 and increase by 1 to @xmath193 after inserting @xmath194 .",
    "we denote these vertices as @xmath195 . to prove our result ,",
    "we need to show that vertices in @xmath195 will not increase the core number any more .",
    "this can be obtained by lemma [ lem : matchinginsert ] , since every vertex can change the core number by at most 1 after the insertion of a matching .",
    "the deletion case can be proved using a similar argument as above .",
    "the proof is completed .",
    "in this section , we present the parallel algorithm for incremental core maintenance after inserting an arbitrary edge set @xmath196 to graph @xmath35 . let @xmath197 denote the set of vertices connecting to edges in @xmath196 .",
    "we define the _ maximum insertion degree _ @xmath198 as the maximum number of edges inserted to each vertex in @xmath23 .    by the definition of @xmath55 and corollary [",
    "lem : expt ] , we can have the following result .",
    "[ corollary : csd ] given a graph @xmath35 and a vertex @xmath30 with core number @xmath1 . after inserting a matching @xmath140 into @xmath0 ,",
    "if @xmath199 and @xmath200 , then @xmath30 can not be in a @xmath201-core .    as @xmath54 is the number of neighbors that have a core number larger than @xmath1 and neighbors have the same core number as @xmath30 but have a @xmath48 value larger than @xmath1 , @xmath200 implies that @xmath30 does not have enough neighbors to help @xmath30 to increase core number .",
    "so we can use this condition to check if a vertex can increase its core number .",
    "[ htb][alg : matchinginsert ]    * input * + the graph , @xmath35 ; + the inserted edge set , @xmath196 ; + the set of vertices @xmath202 connected to edges in @xmath196 the core number @xmath80 of each vertex in @xmath0 ; + * initially * @xmath203 empty core set properly color the inserted edges in @xmath196 using @xmath204 colors @xmath205 by executing the coloring algorithm in @xcite @xmath206the max color of edges in @xmath196 , @xmath207    * algorithm . * the detailed algorithm is given in algorithm [ alg : matchinginsert ] .",
    "the algorithm consists of two main steps . at first",
    ", a preprocessing procedure is executed , to split the edges into several matchings . then the algorithm is executed in iterations in each of which a matching is inserted into the graph , and the set of vertices that change core numbers are found .    more specifically , the preprocessing is done by properly coloring the inserted edges , such that any pair of edges with common endpoint receive different colors .",
    "it is easy to see that the edges with the same color constitute a matching .    in the second step ,",
    "as shown in lemma  [ lem : matchingdelete ] , when inserting a matching into the graph , the core number of every vertex can increase by at most one .",
    "this means that we only need to find the set of vertices that increase core numbers because of the insertion of each particular edge , and the union of these vertices is just the set of vertices which will increase the core number by one .",
    "hence , in each iteration , the edges are processed in parallel .",
    "but it deserves to pointing out that we do not make each edge processed by a processor . instead , the edges with the same core number in the inserted matching are processed on a processor .",
    "this is to decrease duplicated processing of vertices . by lemma  [ lem : kmatching ]",
    ", the edges in a @xmath1-matching , i.e. , the edges with core number @xmath1 in the inserted matching , affect the core number change of the same set of vertices , those on @xmath208 , where @xmath67 is the @xmath1-matching . and",
    "by lemma  [ lem : matchingdelete ] , each vertex can increase the core number by at most one .",
    "this means that when a vertex is determined to increase its core number , after inserting an edge in @xmath67 , it is unnecessary to visit it any more when inserting other edges in @xmath67 . hence , by processing the edges with the same core number on a process can greatly decrease unnecessarily repeated visiting to vertices .",
    "[ htb][alg : insertk ]    * input * + the current new graph , @xmath209 ; + the inserted edges with core number @xmath1 , @xmath67 ; + the current core number @xmath80 of each vertex @xmath2 * initially * , @xmath210 empty stack for each vertex @xmath211 , @xmath212\\gets{false } , removed[v]\\gets{false } , cd[v]\\gets{0}$ ] compute @xmath48 value for each vertex @xmath2 in @xmath208 * return * @xmath213 ;    [ alg : insertremove ]    * input * + the current new graph , @xmath209 ; + the @xmath214,removed[v]$ ] of each vertex the core number @xmath1 and root @xmath215 ; + @xmath216 @xmath217 , @xmath218 \\gets{true}$ ]    algorithm [ alg : insertk ] is used to search the vertices with core number changes when inserting a @xmath1-matching @xmath67 .",
    "algorithm [ alg : insertk ] first computes @xmath48 values for vertices on @xmath208 , then handles the insertion of these edges one by one .",
    "in particular , for each edge @xmath65 = @xmath8 @xmath174 @xmath6 @xmath219 , it conducts a @xmath220 search from the root which is the one in @xmath221 with smaller core number ( if @xmath222 , the tie is broken arbitrarily ) .",
    "each vertex is maintained a value @xmath223 which counts the number of neighbors that may help it increase the core number .",
    "the initial value of @xmath223 of a vertex is set as its constraint superior degree .",
    "vertices in @xmath208 that are connected to the root are pushed into the stack , if they satisfy that the @xmath48 value is larger than @xmath1 .",
    "only these vertices are possible to increase the core number by the definition of @xmath48 .",
    "then we use the condition that @xmath224 to determine that a particular vertex is impossible to increase the core number .",
    "specifically , at every time , a vertex @xmath2 is fetched from the stack .",
    "if @xmath225 > k$ ] which means @xmath2 may be in a @xmath1 + 1-core , its neighbors are then visited .",
    "otherwise , @xmath2 can not be in a @xmath1 + 1-core , and a _ negative _ dfs search as shown in algorithm [ alg : insertremove ] are executed to remove it and spread the influence to other vertices caused by the removal of @xmath2 , i.e. , update the @xmath223 values of other vertices .",
    "* performance analysis . * in this part , we analyze the correctness and efficiency of our incremental algorithm . to depict the complexity of the algorithm , we first define some notations .    for graph @xmath35 , the inserted edge set @xmath196 and a subset @xmath226 of @xmath196 , let @xmath227 and @xmath228 be the set of core numbers of vertices in @xmath229 .    for @xmath229 ,",
    "let @xmath230 .",
    "as shown later , @xmath231 is the maximum times a vertex @xmath30 can be visited by @xmath232 procedure in the algorithm in the iteration when inserting edges to @xmath229 .",
    "let @xmath228 denote the set of core numbers of vertices in @xmath229 .",
    "for a @xmath233 , let @xmath234 be the set of vertices with core number @xmath1 , and @xmath235 be the neighbors of vertices in @xmath234 .",
    ".    denoted by @xmath237 $ ] the set of edges in @xmath229 that are connected to vertices in @xmath238 .",
    "then we define a parameter @xmath239 as follows , which represents the maximum number of edges travelled when computing @xmath48 after inserting edges to @xmath229 .",
    "@xmath240|\\}.\\ ] ]    with the above notations , we prove the correctness and bound the running time of our algorithm in the following theorem [ insertcorrectness ] .",
    "[ insertcorrectness ] algorithm [ alg : matchinginsert ] can update the core numbers of vertices in @xmath241 time , after inserting an edge set @xmath196 to a graph @xmath0 , where @xmath202 is the set of vertices in @xmath0 connecting to edges in @xmath196 and @xmath198 is the maximum insertion degree .",
    "we first prove the correctness .",
    "as discussed before , a proper coloring can split the inserted edges into multiple matchings .",
    "when inserting a matching into the graph , it is only necessary to find the vertices that change their core numbers and increase their core numbers by one .",
    "hence , the edges in a matching can be processed in parallel .",
    "this constitutes the base of our parallel algorithm .",
    "then when processing a particular matching @xmath67 in a process , by lemma  [ lem : kmatching ] and lemma  [ lem : expt ] , only vertices in @xmath208 are possible to increase the core number .",
    "hence , algorithm  [ alg : insertk ] visit all vertices that may change the core number .",
    "furthermore , based on the definitions of @xmath55 and @xmath223 and lemma  [ le : inserne ] , if @xmath242 for a vertex @xmath2 , it is impossible for @xmath2 to increase the core number",
    ". therefore , the algorithm removes vertices that will not increase the core number definitely . and",
    "the negative dfs process in algorithm [ alg : insertremove ] ensures to spread the influence of a removed vertex , i.e. , update the @xmath223 values ( which count the number of neighbors that may support a particular vertex s core number change ) of vertices in @xmath208 . by lemma [ alg : matchinginsert ] , each vertex being determined to increase the core number is unnecessary to visit any more , as shown in algorithm [ alg : insertk ] , since these vertices will not increase their core numbers any more . finally , after executing the algorithm , vertices that are visited but not removed will increase their core numbers , as these vertices all have at least @xmath201 neighbors and they constitute @xmath201-cores . combining the above together , the correctness of the algorithm is guaranteed .    as for the time complexity",
    ", there are two stages in the algorithm : first , the inserted edges are split into matchings by coloring , and second , in each iteration , edges in a matching with the same core number are inserted to the graph and the core numbers of vertices are updated . as shown in @xcite , the coloring of inserted edges takes @xmath243 time .",
    "we next analyze the time used in the second stage .",
    "we first bound the number of iterations . in each iteration ,",
    "the edges with one particular color are processed .",
    "as shown in @xcite , the number of colors used is at most @xmath204 .",
    "hence , the number of iterations is also upper bounded by @xmath204 .",
    "now consider an iteration @xmath244 in the second stage of the algorithm execution .",
    "denote by @xmath245 the graph obtained after iteration @xmath246 as @xmath245 , and by @xmath140 the matching gained in iteration @xmath244 .",
    "the computation of @xmath55 values for vertices in @xmath247 takes @xmath248 time . in the algorithm , each vertex",
    "is visited for once to determine whether to update its core number .",
    "but it needs to notice that each vertex may be visited for multiple times in the negative dfs procedures that disseminate the influence of a removed vertex .",
    "however , if a vertex @xmath2 is visited in the negative dfs procedure , @xmath249 is decreased by 1 .",
    "hence , each vertex can be visited by at most @xmath231 times , since a vertex will be removed if its @xmath223 value is decreased to its core number .",
    "then we can get that the total time for an iteration is upper bounded by @xmath250 .    by all",
    "above , the running time of the whole algorithm can be bounded as stated .",
    "the algorithm for decremental core maintenance , as given in algorithm  [ alg : matchingdelete ] , is very similar to the incremental one .",
    "the only difference is that we use lemma  [ corollary : sd ] instead of lemma  [ le : inserne ] to determine whether a vertex will decrease the core number after deleting edges .",
    "the maximum number of edges deleted from each vertex is defined as the _ maximum deletion degree _ , denoted as @xmath251 .",
    "[ htb][alg : matchingdelete ]    * input * + the graph , @xmath35 ; + the deleted edge set , @xmath252 ; + the set of vertices @xmath253 connected to edges in @xmath252 the core number @xmath80 of each vertex in @xmath0 ; + * initially * @xmath203 empty core set properly color the deleted edges in @xmath252 using @xmath254 colors @xmath255 by executing the coloring algorithm in @xcite @xmath206the max color of edges , @xmath207    [ htb][alg : deletek ]    * input * + the current new graph , @xmath209 ; + the edges with core number @xmath1 , @xmath67 ; + the core number @xmath80 of each vertex in @xmath23 * initially * , @xmath210 empty stack for each vertex @xmath211 , @xmath212\\gets{false } , removed[v]\\gets{false } , cd[v]\\gets{0}$ ]    * return * @xmath62 ;    [ alg : deleteremove ]    * input * + the current new graph , @xmath209 ; + the @xmath214,removed[v]$ ] of each vertex the core number @xmath1 and root @xmath215 ; + @xmath217 , @xmath218 \\gets{true}$ ]    * performance analysis . *",
    "the correctness and efficiency of the proposed decremental algorithm can be analyzed similarly as the incremental one . at first",
    ", we define some notations . for graph @xmath35 , the deleted edge set @xmath252 and a subset @xmath256 of @xmath252 , let @xmath257 and @xmath258 be the set of core numbers of vertices in @xmath259 .    for @xmath259 ,",
    "let @xmath260 .    for @xmath261 ,",
    "let @xmath262 be the set of vertices with core number @xmath1 and @xmath263 .    denote by @xmath264 the set of edges connected to vertices in @xmath262 .",
    "we then define @xmath265 as follows , @xmath266|\\}. m_r=\\max_{k\\in k(g_r)}\\{|e(v_r(k))|\\}.\\ ] ] @xmath267 , @xmath268 and @xmath265 will depict the time used in each iteration in the algorithm execution .    using a similar argument as that for analyzing the incremental algorithm , we can get the following result , which states the correctness and efficiency of the decremental algorithm .    [ deletecorrectness ]",
    "algorithm [ alg : matchingdelete ] can update the core numbers of vertices in @xmath269 time , after deleting an edge set @xmath252 from a graph @xmath0 , where @xmath253 is the set of vertices in @xmath0 connecting to edges in @xmath252 and @xmath251 is the maximum deletion degree .",
    "we prove the correctness first .",
    "similarly as the insertion case , the coloring algorithm split the deleted edges into multiple matchings , and edges in a matching can be processed in parallel .",
    "then when dealing with a matching @xmath140 , we distribute the @xmath1-matchings of it into several child processes . in a child process , by lemma",
    "[ lem : kmatching ] and lemma  [ lem : expt ] , only vertices in @xmath270 are able to decrease the core number , which is conducted in algorithm  [ alg : deletek ] .",
    "furthermore , by the definition of @xmath48 and @xmath223 , we can get that for a vertex @xmath2 with @xmath74 , if @xmath242 , @xmath80 will decrease and can not be @xmath1 any more .",
    "so the algorithm will remove the vertices that can not keep its current core number @xmath1 , which is done in algorithm [ alg : deleteremove ] through a @xmath220 . besides , algorithm [ alg : deleteremove ] updates the @xmath223 values of vertices in @xmath270 . by lemma",
    "[ alg : matchingdelete ] , vertices that will decrease the core number are not supposed to be visited any more , as their core numbers can only decrease by at most 1 .",
    "finally , after executing the algorithm , vertices that have been visited and removed will decrease their core numbers , as these vertices do not have enough neighbors to keep the core number @xmath1 . combining the above together , the correctness of the algorithm is guaranteed .    as for the time complexity , there are two stages in the algorithm : first , the deleted edges are split into matching by edge coloring , and second , in each iteration , edges in a matching with the same core number are deleted from the graph and the core numbers of vertices are updated . as shown in @xcite , the coloring of @xmath43 takes @xmath271 time .",
    "we next analyze the time used in the second stage .",
    "we first bound the number of iterations . in each iteration ,",
    "the edges with one particular color are processed .",
    "as shown in @xcite , the number of colors used is at most @xmath204 .",
    "hence , the number of iterations is also upper bounded by @xmath254 .",
    "now consider an iteration @xmath244 in the second stage of the algorithm execution .",
    "denote by @xmath245 the graph obtained after iteration @xmath246 as @xmath245 , and by @xmath140 the matching gained in iteration @xmath244 .",
    "the computation of @xmath48 values for vertices in @xmath272 takes @xmath248 time . in the algorithm , each vertex",
    "may be visited for multiple times in the dfs procedures that disseminate the influence of a removed vertex . however ,",
    "if a vertex @xmath2 is visited in the dfs procedure , @xmath249 is decreased by 1 .",
    "hence , each vertex can be visited by at most @xmath267 times , since a vertex will be removed if its @xmath223 value is decreased to its core number .",
    "then we can get that the total time for an iteration is upper bounded by @xmath273 .    by all above , the running time of the whole algorithm can be bounded as stated .",
    "in this section , we evaluate the performances of our algorithms by experiments .",
    "the experiments use three synthetic data sets and seven real - world graphs , as shown in table [ table_graph ] .",
    "there are two main variations in our experiments , the original graph and the inserted / deleted edge set .",
    "we first evaluate the efficiency of our algorithms on real - world graphs , by changing the size and core number distribution of inserted / deleted edges .",
    "then we evaluate the scalability of our algorithms using synthetic graphs , by keeping the inserted / deleted edge set the same and changing the size of synthetic graphs .",
    "besides , we show the parallelization of our algorithms for several typical graphs , the number of iterations and the number of edges handled per iteration are showed . at last , we compare our algorithms with the state - of - the - art sequential core maintenance algorithms , traversal algorithms given in @xcite , to evaluate the speedup ratio of our parallel algorithms .",
    "the comparison experiments are conducted on four typical real - world data sets .",
    "all experiments are conducted on a linux machine having 8 intel xeon e5 - 2670@2.60ghz cpus with support for 16 concurrent threads and 64 gb main memory .",
    "the algorithm is implemented in c++ and compiled with g++ compiler using the -o3 optimization option .    * data sets .",
    "* we use seven real - world graphs and random graphs generated by three different models .",
    "the seven real - world graphs can be downloaded from snap @xcite , including social network graphs ( livejournal , youtube , gowalla ) , collaboration network graphs ( dblp , ca - condmat ) , communication network graphs ( wikitalk ) and web graphs ( web - berkstan ) .",
    "the synthetic graphs are generated by the snap system using three models : the erds - r**@xmath274**nyi ( er ) graph model @xcite , which generates a random graph ; the barabasi - albert ( ba ) preferential attachment model @xcite , in which each vertex has @xmath1 connected edges ; and the r - mat ( rm ) graph model @xcite , which can generate large - scale realistic graphs similar to social networks .",
    "for all generated graphs , the average degree is fixed to 8 , such that when the number of vertices in the generated graphs is the same , the number of edges is the same as well .",
    "[ core1 ] and fig . [ core2 ]",
    "show the core number distributions of the seven real - world graphs and the generated graphs with @xmath275 vertices . from fig .",
    "[ core1 ] , it can be seen that in real - world graphs , most of the vertices have core numbers smaller than 10 .",
    "especially , in wt , more than 70% of vertices have core number 1 .",
    "for the generated graphs , as shown in fig .",
    "[ core2 ] , all vertices have a core number of 8 in the ba graphs . in the er graph ,",
    "the max core number of vertices is 10 , and almost all vertices have core numbers close to the max one . in the rm graph",
    "most vertices have small core numbers which are more close to real - world graphs , and as the core number @xmath1 increases the number of vertices with core number @xmath1 decreases . as shown later , the core number distribution of a graph will affect the performances of our algorithms .",
    "we use the _ average processing time per edge _ as the efficiency measurement of the algorithms , such that the efficiency of the algorithms can be compared in different cases .",
    ".real - world graph datasets [ cols=\"^,^,^,^\",options=\"header \" , ]     [ table_graph ]      we evaluate the impacts of three factors on the algorithm performance : the number of inserted / deleted edges , the core numbers of edges inserted / deleted , and the size of the original graph .",
    "the first factor mainly influences the iterations needed to process the inserted / deleted edges , and the other two factors affect the processing time in each iteration .",
    "we use the real - world graphs to conduct the first two evaluations , and the synthetic graphs on the third one .",
    "first we change the number of updated edges .",
    "we randomly insert / delete @xmath276 edges from the original graph , where @xmath277 for @xmath278 .",
    "[ size_ins ] and fig .",
    "[ size_del ] show the processing time per edge for insertion and deletion cases respectively .",
    "it can be seen that the processing time per edge is less than @xmath279 in the deletion case and less than @xmath280 in the insertion case for all graphs . besides it is found that , when more edges are updated , the time needed per edge is decreased in general . this is because our algorithms have better parallelism in the case of large amount of updates . in this case , more edges can be selected into the matching processed in each iteration . therefore , our algorithms are more suitable for processing large amount of updates .    then , we vary the core number distributions of the update edges to evaluate the performance of our algorithms . this kind of tests can help us understand how our algorithms behave over changes on different areas of the graph .",
    "the results are illustrated in fig .",
    "[ corechange ] . by the core distributions showed in fig .",
    "[ core1 ] , we choose five typical core numbers \\{@xmath281 } in an increasing order for each of the seven graphs . for each core number",
    ", we randomly select 20% edges of that core as the update edge set .",
    "it can be seen from fig .",
    "[ corechange ] that larger core number needs a larger average processing time for most of the graphs .",
    "this is because though the amount of vertices with larger core number is small , each vertex has a large degree , so these vertices tend to have more neighbors when we choose the edges randomly . while in our algorithm a vertex may decrease its degree by only one in an iteration , so more iterations will be needed , which results in longer running time .",
    "however the running time per edge does not vary so much when the core number of edge changes , which demonstrates that our algorithms are stable upon changes on different parts of the graph .    additionally , we test the scalability of our algorithms using the three synthetic datasets . with",
    "the average degree fixed as 8 , we vary the number of vertices @xmath282 from @xmath283 to @xmath275 . for each graph , we randomly select 10000 edges from each graph and show the processing time per edge as the graph size ranges . it can be seen from fig .",
    "[ graphchange ] that when the graph size increases at an exponential rate , the processing time just increases linearly .",
    "this indicates that our algorithms is stable upon different graph size and can handle graphs with extremely large size in acceptable time .",
    "as the figure shows , the processing time for ba graph is a bit longer than the other two graphs .",
    "this is because in ba graphs all vertices have the same core number 8 , the parallelism of our algorithms is very poor in this case , since initially there is only one processor used in the algorithm execution .",
    "this situation can also be seen as the worst case for our algorithms . however",
    ", real - world graphs do not exhibit this property as shown in fig .",
    "[ core1 ] and [ core2 ] .    at last , we exhibit the parallelism of our algorithms on the three graphs lj , db and gw repectively , which is shown in fig [ parallel ] . here",
    ", we randomly choose 20000 edges as the update edges . in fig [ edgenum ]",
    ", the x - axis represents the iteration number during the algorithm execution and the y - axis represents the number of edges that are processed in one iteration .",
    "it can be seen that for all three graphs , almost 10000 edges are selected into the matching in the first iteration and can be processed . besides , for graphs db and gw , more than 18000 edges are handled in the first three iterations and there are less than 20 iterations in total . for the graph lj , due to the edge distribution over vertices , the insertion / deletion degree is larger , and",
    "hence there are more iterations .",
    "however , we can see that more than 1000 edges are processed in each of the first 6 iterations . as the iteration increases",
    ", it can be found that the number of edges processed in each iteration decreases .",
    "this is because less vertices still have unprocessed edges as the algorithm execution , and only one edge connected to every vertex is selected into the matching in each iteration .",
    "hence , the number of selected edge decreases as the algorithm execution . the number of threads used in each iteration is shown in fig [ thread ] .",
    "we next evaluate the speedup ratio of our parallel algorithms , comparing with algorithms that sequentially handle edge insertions / deletions .",
    "we compare with the state - of - the - art sequential algorithms , * traversal * algorithms given in @xcite .",
    "the comparison is conducted on four typical real - world graphs , yt , bs , wt and lj as given in table [ table_graph ] . for each graph ,",
    "we randomly select \\{5k , 10k , 15k , 20k } edges as the update set .",
    "the comparison results are illustrated in fig .",
    "[ cmp_ins ] and fig .",
    "[ cmp_del ] .",
    "in the figures , the y - axis represents the speedup ratio of our algorithm over the * traversal * algorithms .",
    "[ cmp_ins ] and fig .",
    "[ cmp_del ] show that in almost all cases , our algorithms achieve a speedup ratio of around @xmath284 in both incremental and decremental core maintenance . especially for the large - scase graph lj ,",
    "the speedup ratio is more than 1000 .",
    "it can also be found that the speedup ratio increase as the number of edges inserted / deleted and the graph size increase .",
    "hence , our algorithms provide better efficiency in large - scale graphs and processing large amount of graph changes .",
    "* evaluation summary .",
    "* the experiment results show that our algorithms exhibit good stability and scalability . comparing with sequential algorithms ,",
    "our algorithms speed up the core maintenance procedure significantly .",
    "additionally , our algorithms are suitable for handling large amount of edge insertions / deletions in large - scale graphs , which is desirable in realistic implementations .",
    "in this paper , we present the parallel algorithms for core maintenance in dynamic algorithms .",
    "our algorithms exhibit significant acceleration comparing with sequential processing algorithms that handle inserted / deleted edges sequentially . experiments on real - world and synthetic graphs illustrate that our algorithms implement well in reality , especially in scenarios of large - scale graphs and large amounts of edge insertions / deletions .",
    "the authors would like to thank ...                                              j. misra , d. gries . a constructive proof of vizing s theorem , in _ information processing letters _ ,",
    "41(3 ) : 131133 , 1992 .",
    "a. montresor , f.d .",
    "pellegrini , d. miorandi . distributed k - core decomposition . in _ ieee transactions on parallel & distributed systems _ , 24(2):288 - 300 , 2011 .",
    "the deletion algorithm is executed in iterations , and each iteration includes two parts . the first part is similarly as the insertion case , which computes the superior edge set in parallel , and then deletes the computed superior edge set from graph @xmath0 . by lemma [ lem : superioredgesetdelete ] , after deleting such a superior edge set @xmath67 from the graph , each vertex can decrease its core by at most 1 .",
    "then in the second part , we identifiy vertices that will decrease core numbers by executing algorithm [ alg : deletek ] in parallel . in each child process , it is sufficient to visit vertices in the exkpt of @xmath67 to find all vertices whose core numbers may decrease according to lemma [ le : exkpaths ] . for each edge",
    ", we start a negative dfs to remove vertices that are confirmed to decrease core numbers . and by lemma  [ corollary : sd ] , for a vertex @xmath2 , if @xmath285 \\le k$ ] , @xmath2 will decrease its core number , and this will affect the @xmath48 value of its neighbors .",
    "so we use a variable value @xmath223 to represent the dynamic changes of @xmath48 value .",
    "after all edges are handled , vertices in exkpt are visited and the ones that can not be in the current @xmath1-core are marked as removed .",
    "all above ensures the corretness of the algorithm .",
    "now consider an iteration @xmath244 , denote the superior edge set computed in current iteration @xmath244 as @xmath256 .",
    "the computation of @xmath48 values for vertices in exkpt of @xmath256 takes @xmath287 time . for the negative dfs procedures ,",
    "if a vertex @xmath2 is visited , @xmath249 is decreased by 1 .",
    "hence , each vertex can be visited by at most @xmath267 times , since a vertex will be removed if its @xmath223 values is decreased below to its core number .",
    "combining together , the total time for an iteration is @xmath288 ."
  ],
  "abstract_text": [
    "<S> the core number of a vertex is a basic index depicting cohesiveness of a graph , and has been widely used in large - scale graph analytics . in this paper </S>",
    "<S> , we study the update of core numbers of vertices in dynamic graphs with edge insertions / deletions , which is known as the core maintenance problem . </S>",
    "<S> different from previous approaches that just focus on the case of single - edge insertion / deletion and sequentially handle the edges when multiple edges are inserted / deleted , we investigate the parallelism in the core maintenance procedure . </S>",
    "<S> specifically , we show that if the inserted / deleted edges constitute a matching , the core number update with respect to each inserted / deleted edge can be handled in parallel . based on this key observation </S>",
    "<S> , we propose parallel algorithms for core maintenance in both cases of edge insertions and deletions . </S>",
    "<S> we conduct extensive experiments to evaluate the efficiency , stability , parallelism and scalability of our algorithms on different types of real - world and synthetic graphs . comparing with sequential approaches </S>",
    "<S> , our algorithms can improve the core maintenance efficiency significantly . </S>"
  ]
}