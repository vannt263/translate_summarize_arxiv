{
  "article_text": [
    "one of the fundamental security services in modern computer systems is _ access control _ , a mechanism for constraining the interaction between ( authenticated ) users and protected resources .",
    "generally , access control is enforced by a trusted component ( historically known as the _ reference monitor _ ) , which typically implements two functions : an _ authorization enforcement function _ ( aef ) and an _ authorization decision function _ ( adf ) .",
    "the aef traps all attempts by a user to interact with a resource ( usually known as a _ user request _ ) and transforms that request into one or more _ authorization queries _ ( also known as _ authorization requests _ ) which are forwarded to the adf .",
    "most access control systems are policy - based .",
    "that is , an administrator specifies an authorization policy , which , in its simplest form , encodes those authorization requests that are authorized .",
    "the adf takes an authorization query and an authorization policy as input and returns an authorization decision .",
    "for this reason , it is common to refer to the aef and adf as the _ policy enforcement point _ ( pep ) and _ policy decision point _ ( pdp ) , respectively ; it is this terminology that we will use henceforth .",
    "an authorization policy is merely an encoding of the access control requirements of an application using the authorization language that is understood by the pdp .",
    "it is necessary , therefore , to make a distinction between an _ ideal policy _ and a _ realizable policy _ : the former is an arbitrary function from requests to decisions ; the latter is a function that can be evaluated by the pdp . given a particular policy language",
    ", there might be some ideal policies that are not realizable , which may be a limitation of the policy language in practice .",
    "the access control system used in early versions of unix , for example , is rather limited  @xcite .",
    "an important consideration , therefore , when designing an access control system is the _ expressivity _ of the policy language .",
    "the increasing prevalence of open , distributed , computing environments means that we may not be able to rely on a centralized authentication function to identify authorized users .",
    "this means that authorization decisions have to be made on the basis of ( authenticated ) user attributes ( rather than user identities ) . in turn",
    ", this means that the structure of authorization queries needs to be rather more flexible than that used in closed , centralized environments .",
    "the draft xacml 3.0 standard , for example , uses a much `` looser '' query format than its predecessor xacml 2.0 .",
    "however , if we have no control over the attributes that are presented to the pdp , then a malicious user ( or a user who wishes to preserve the secrecy of some attributes ) may be able to generate authorization decisions that are more `` favorable '' by withholding attributes from the pep  @xcite .",
    "a second important consideration , therefore , is whether authorization policies are guaranteed to be `` monotonic '' in the sense that providing fewer attributes in an authorization query yields a less favorable outcome ( from the requester s perspective ) .",
    "there is an extensive literature on languages for specifying authorization policies , most approaches proposing a new language or an extension of an existing one .",
    "the proliferation of languages led ferraiolo and atluri to raise the question in  @xcite of whether a _ meta - model _ for access control was needed and possible to achieve , hinting at xacml  @xcite and rbac  @xcite as potential candidates . in response",
    ", barker proposed a meta - model  @xcite , which sought to identify the key components required to specify access control policies , based on a term - rewriting evaluation .    in this paper , we do not present `` yet another language '' for access control policies , nor do we claim to have a `` unifying meta - model '' .",
    "we focus instead on reasoning about the properties of a language .",
    "indeed , we advocate the idea that a language is just a tool for policy designers : just as some programming languages are better suited to particular applications , it seems unlikely that there exists a single access control model ( or meta - model ) that is ideal in all possible contexts . on the contrary , we believe that providing the structure to formally analyse a language might be valuable to a policy designer , in order to understand the suitability of a particular language as the basis for a specific access control system .",
    "we conclude this section by summarizing the structure and contributions of the paper . in sec .",
    "[ sec : framework ] we propose a general framework for access control , whose role is not to be used as an off - the - shelf language , but as a way to identify and reason about the key aspects of a language . in sec .",
    "[ sec : monotonicity ] we define monotonicity and completeness in the context of our framework . then in sec .",
    "[ sec : general - abac ] we define two attribute - based models , respectively monotonic and complete , by building on existing results from the literature on multi - valued and partial logic .",
    "the main body of the paper ends with discussions of related and future work .",
    "in this section we describe the various components of our framework and introduce our formal definition of access control models and policies . broadly speaking",
    ", we provide a generic method for designing access control models and for furnishing access control policies , which are written in the context of a model , with authorization semantics .",
    "we also introduce the notion of an ideal policy , which is an abstraction of the requirements of an organization , and relate this concept to that of an access control policy .      from an external viewpoint ,",
    "an access control mechanism is a process that constrains the interactions between users and data objects .",
    "those interactions are modeled as access requests , with the mechanism incorporating two functions : one to determine whether a request is authorized or not and one to enforce that decision .",
    "the overall process must be total , in the sense that its behavior is defined for _ every _ possible interaction ( which may include some default behavior that is triggered when the decision function is unable to return a decision ) . in general , designing a particular access control mechanism for a particular set of requests is the final concrete objective of any access control framework ( although we are also clearly interested in expressing general properties of the framework ) .",
    "we define an access control mechanism using an _ access control policy _ , together with an _ interpretation function _ which provides the authorization semantics for a policy .",
    "intuitively , a policy is simply a syntactical object , built from _ atomic policies _ and _ policy connectives_. the interpretation function provides the denotational semantics of the policy , by returning a function from requests to decision , thus defining the expected behavior of the pdp . clearly , a policy can be interpreted in different ways , and an interpretation function can interpret different policies , as long as they are built from the same atomic policies and connectives .    an _ access control model _ defines an _ access control language _ , which consists of a set of atomic polices and policy connectives , and an interpretation function .",
    "in other words , an access control model specifies a set of access control policies and a unique way to interpret each of these policies .",
    "an _ access control mechanism _",
    ", then , is an instance of an access control model if its policy belongs to the language of the model and if its interpretation function is that of the model .      in order to provide a framework within which policies can be constructed ,",
    "we introduce the notion of access control model , which is a tuple @xmath0 , where @xmath1 is a set of _ requests _ , @xmath2 a set of _ atomic authorization policies _",
    ", @xmath3 a set of _ policy connectives _ , @xmath4 a set of ( authorization ) _ decisions _ , and , for each @xmath5 , @xmath6 is a total function from @xmath1 to @xmath4 defining the _ evaluation _ of policy @xmath7 for all requests in @xmath1 .    each @xmath8-ary policy connective @xmath9 in @xmath3",
    "is identified with a function @xmath10 .",
    "we construct an authorization policy @xmath11 using elements of @xmath2 and @xmath3 .",
    "we extend the evaluation function for atomic policies to arbitrary policies : that is , @xmath12 provides a method of evaluating requests with respect to a policy @xmath11 .",
    "we say that @xmath13 defines the _ authorization semantics _ of the model .",
    "the syntax by which policies are defined and the extension of the authorization semantics for atomic policies to non - atomic policies are fixed ( for all models ) , as specified in definition  [ def : policy - term ] below .",
    "nevertheless , different choices for @xmath4 , @xmath14 and @xmath13 give rise to very different models having very different properties . a _ policy term",
    "@xmath11 is defined by a ( rooted ) _ policy tree _ , in which leaf nodes are _ atomic policies _ and each non - leaf node is a policy connective ( we may also use the term _ policy operator _ ) .",
    "more formally we have the following definition :    [ def : policy - term ] let @xmath0 be a model .",
    "then every atomic policy in @xmath2 is a _ policy term_. if @xmath15 are policy terms , then for each @xmath8-ary operator @xmath16 , @xmath17 is a policy term . for each policy term @xmath17 , we define @xmath18    in other words , authorization policies are represented as policy trees and policies are evaluated from the bottom up by    [ ( a ) ]    evaluating atomic policies    combining the decisions returned for atomic policies using the relevant policy connectives .",
    "we write @xmath19 to denote the set of policies that can be expressed within @xmath20 .",
    "given a set of queries @xmath1 and a set of decisions @xmath4 , an _",
    "ideal access control policy _ is a total function @xmath21 .",
    "we say that an ideal policy @xmath22 is _ realizable _ by an access control model @xmath23 if , and only if , there exists a policy term @xmath24 such that for any query @xmath25 , @xmath26 ; in the interests of simplicity we will abuse notation and write @xmath27 and @xmath28 .    figure  [ fig : pol - tree ] shows two policy trees each having the same atomic policies , @xmath29 and @xmath30 .",
    "the figure also shows two evaluations of the tree for the same request @xmath25 , where @xmath31 and @xmath32 .",
    "the symbols @xmath33 , @xmath34 and @xmath35 denote allow , deny and inapplicable decisions , respectively .",
    "the policy trees are evaluated using a post - order traversal , in which each leaf node is assigned a value according to the semantics defined by @xmath13 and each interior node is assigned a value by combining the values assigned to its child nodes .",
    "the policies in figure  [ fig : pol - tree ] make use of three operators taken from table  [ tab : operators ] .",
    "both @xmath36 and @xmath37 are similar to the allow - overrides operator familiar from xacml ( and also the two conjunction operators from kleene s 3-valued logic ) and only differ in the way in which @xmath38 is combined with @xmath39 .",
    "the @xmath40 unary operator implements a deny - by - default rule , thus @xmath41 .",
    "[ h ]    in general , an access control model does not specify any policy in particular ( unless the language is so restricted that it can only specify one policy ) .",
    "to some extent , an access control model ( in the sense in which we use the term in this paper ) is analogous to a programming language : it describes the syntax that is used to build access control policies ( analogous to programs ) and the semantics of the run - time mechanisms that will be used to handle input data ( access control requests in this context ) .",
    "a realizable policy is in this case analogous to a program @xmath11 written in the syntax of the model @xmath23 , that is interpreted using the authorization semantics of the model , while an ideal policy is analogous to the set of functional requirements .",
    "note that an ideal policy can be realized by different access control models : @xmath42 and @xmath43 with @xmath44 .",
    "in other words , different access control mechanisms may be able to enforce the same security requirements . and @xmath22 may be realizable by different policy terms from the same access control model : @xmath45 and @xmath46 with @xmath47 .",
    "in other words , security requirements can be enforced by the same mechanism using different policies .",
    "however , an ideal policy may not be realizable by any policy term for a given model ; the extent to which a model can realize the set of ideal policies provides us with a notion of the _ completeness _ of a model ( as we discuss in section  [ sec : completeness ] ) .",
    "a model provides the global structure from which access control policies can be built .",
    "a simple example of a model is the protection matrix model  @xcite , which can be viewed as a set of triples @xmath48 , where @xmath49 is a subject , @xmath50 an object and @xmath51 an access mode .",
    "a query is also a triple @xmath48 , and is authorized if , and only if , it belongs to the set representing the matrix .",
    "hence , we define the set of queries @xmath52 to be the set of all triples @xmath48 , the set of decisions @xmath53 , where @xmath39 stands for an authorized access and @xmath54 for a denied one , the set of atomic policies @xmath55 , the set of operators @xmath56 , where @xmath57 is the standard boolean disjunction , and the interpretation function @xmath58 to be : @xmath59 for instance , the policy authorizing only the accesses @xmath60 and @xmath61 can be defined as @xmath62 .    models can also consider richer sets of queries .",
    "indeed , recent work considers the possibility that , in order to make a decision , an access control system might require more attributes than the traditional subject - object - action triple  @xcite . in order to define requests and atomic policies it is necessary to identify sets of attributes and the values that each of those attributes may take .",
    "role - based access control , to take a simple example , defines the sets of roles , users and permissions , together with user - role and permission - role assignment relations .",
    "we now introduce the notions of attribute vocabulary and attribute - based access control , which are intended to be as general as possible and allow for the construction of requests and policies .",
    "[ def : abac ] let @xmath63 denote a set of attribute names , and @xmath64 denote a set of attribute domains .",
    "let @xmath65 be a function , where @xmath66 denotes the set of attribute values associated with attribute @xmath67 .",
    "then @xmath68 defines an _ attribute vocabulary_.    when no confusion can occur , we will simply write @xmath69 to denote an attribute vocabulary .",
    "a request is modeled as a set of name - value pairs of the form @xmath70 , where @xmath71 .",
    "we denote the set of requests by @xmath72 , omitting @xmath63 when it is obvious from context .",
    "we say an attribute name - value pair @xmath70 is _ well - formed _ if @xmath71 and @xmath73 .",
    "we assume that a pdp can recognize ( and discard ) name - value pairs in a request that are not well - formed .",
    "attribute - based access control ( abac ) policies are modular .",
    "hence , a policy component may be incomplete or two policy components may return contradictory decisions .",
    "thus , it is common to see additional decisions used to denote a policy `` gap '' or `` doubt '' indicating different reasons why policy evaluation could not reach a conclusive ( allow or deny ) decision  @xcite .",
    "we write @xmath74 , where @xmath75 indicates that @xmath76 is neither @xmath34 nor @xmath33 .",
    "@xmath77    in table  [ tab : operators ] we summarize the characteristics of some useful 3-valued operators , most of which are self - explanatory .",
    "the @xmath78 operator acts as a policy filter : @xmath79 if @xmath80 , and evaluates to @xmath35 otherwise .",
    "the @xmath81 operator models policy unanimity : @xmath82 evaluates to a conclusive decision only if both @xmath83 and @xmath84 do . in sec .",
    "[ app : conflict - abac ] we describe a model with a 4-valued decision set .",
    "abac is designed for open distributed systems , meaning that authenticated attributes and policy components may need to be retrieved from multiple locations .",
    "thus , some languages assume that policy evaluation may fail : it may be , for example , that a policy server or policy information point is down .",
    "ptacl  @xcite relies on a three - valued logic , and considers sets of decisions in order to model indeterminacy .",
    "xacml 3.0  @xcite considers a six - valued decision set , three of those decisions representing different indeterminate answers .",
    "an access control model provides a policy designer with a language to construct a policy . that language may well have an impact on the policies that can be expressed and the properties of those policies . in this section",
    "we study two specific properties of access control models , monotonicity ( a kind of safety property ) and completeness ( an expressivity property ) , and we present two models satisfying these properties in section  [ sec : general - abac ] .",
    "informally , a policy is monotonic whenever removing information from a request does not lead to a `` better '' policy decision .",
    "such a property is of particular relevance in open systems , where users might be able to control what information they supply to the access control mechanism .",
    "a model in which all realizable policies are monotonic implies that they are not vulnerable to attribute hiding attacks  @xcite .",
    "that is , a malicious user gains no advantage by suppressing information when making a request .",
    "we model information hiding using a partial ordering @xmath85 on @xmath86 ; the intuitive interpretation of @xmath87 is that @xmath25 contains less information than @xmath88 . for instance , an attribute query @xmath25 is less than another query @xmath88 when @xmath89 . we also need to specify what it means for a decision to `` benefit '' a user , and thus we assume the existence of an ordering relation @xmath90 on @xmath4 ; again , the intuitive interpretation of @xmath91 is that the decision @xmath92 is of greater benefit than @xmath93 .",
    "for instance , we can consider the ordering @xmath94 over @xmath95 , such that @xmath96 if and only if @xmath97 or @xmath98",
    ".    given a set of authorization queries @xmath99 and a set of decisions @xmath100 , a policy @xmath101 is _ monotonic _ if , and only if , for all @xmath102 , @xmath87 implies @xmath103 .",
    "we say that an access control model @xmath104 is _ monotonic _ if for all @xmath24 , @xmath105 is monotonic .",
    "note that our definition of a monotonic policy applies equally well to an ideal policy @xmath106 or a realizable policy term @xmath11 with authorization semantics @xmath107 .",
    "however , the notion of monotonicity is dependent on the request ordering .",
    "for instance , without further characterization , the request ordering for the access matrix could be reduced to equality , making any policy trivially monotonic .",
    "however , more complex situations can be considered by adding extra information , such as an ordering over subjects or objects .",
    "tschantz and krisnamurthi have shown that xacml 2.0 is not monotonic ( although they called the property `` safety '' rather than monotonicity )  @xcite .",
    "we show in section  [ sec : abacm]provided certain restrictions are imposed on the structure of requests  that it is possible to develop a monotonic , attributed - based ( xacml - like ) access control model , using results from partial logic  @xcite .      given a model @xmath104 , any realizable policy @xmath24 clearly corresponds to an ideal policy @xmath108 .",
    "however , there may exist an ideal policy @xmath22 ( for @xmath86 and @xmath4 ) that does not belong to @xmath19 and can not , therefore , be enforced by the policy decision point .",
    "trivially , for example , a model without any atomic policies does not realize any policies .",
    "it follows that the set of ideal policies that can be realized by a model represents an intuitive notion of expressivity .",
    "a model that can realize every ideal policy is said to be complete . more formally :    an access control model @xmath104 is _ complete _ if , and only if for any ideal policy @xmath108 , @xmath42 .",
    "the completeness of a model @xmath109 will depend on the authorization vocabulary , the definition of atomic policies , the set @xmath3 and @xmath13 .",
    "the access matrix model defined in section  [ sec : examples ] , for example , is complete .",
    "[ thm : am_complete ] the model @xmath110 is complete .    on the other hand , it is easy to show that xacml is not complete , unless we allow the inclusion of xacml conditions , which are arbitrary functions .",
    "indeed , consider two attributes @xmath111 and @xmath112 with two respective attribute values @xmath113 and @xmath114 , it is not possible to construct a policy that evaluates @xmath115 to @xmath116and @xmath117 to @xmath118 , intuitively because any target not applicable to @xmath119 can not be applicable to @xmath120 .",
    "we propose an attribute - based access control model in section  [ sec : abacc ] in which the representation of atomic policies can distinguish attribute name - value pairs , from which we can prove a completeness result .",
    "however , it is worth observing that , in general , if a model is both monotonic and complete , then the ordering over requests is limited to the identity relation , as illustrated above with the access matrix .",
    "[ thm : monotonicity - completeness ] given any model @xmath121 , if @xmath122 is complete and monotonic and if @xmath123 , then @xmath85 is the identity relation .",
    "informally , this result states that if we wish to have a ( non - trivial ) monotonic model then we can not expect to have a complete model . instead",
    ", what we should aim for is a model that realizes at least all _ monotonic ideal policies _ , and such a model is said to be _ monotonically - complete_. in section  [ sec : general - abac ] , we show how to define monotonically - complete and complete attribute - based access control models that have similar characteristics to xacml .",
    "it could be argued that the main objective of xacml is to provide a standard addressing as many practical concerns as possible , rather than a language with formal semantics .",
    "nevertheless , the design choices can and should be analyzed with respect to the properties they entail .",
    "we do not claim here that xacml _ should _ be monotonic , complete , or monotonically - complete , but we show instead how , building from existing logical results , one can instantiate an access control model with these properties .",
    "the results in this section can provide guidance to the designer of an access control system .",
    "she can choose , for example , between a system that realizes only and all monotonic policies , and a system in which all policies are realizable , but some may be non - monotonic .",
    "clearly , the choice depends on the demands of the application and the constraints of the underlying environment .",
    "while we can not make this choice for the policy designer , our framework can only help her make an informed decision .",
    "if the attribute vocabulary were countably infinite ( and the cardinality of the decision set is greater than @xmath33 ) then the number of ideal policies would be uncountably infinite ( by a standard diagonalization argument ) .",
    "however , the number of realizable policies can , at best , be countably infinite , by construction .",
    "accordingly , it is only meaningful to consider completeness if we assume that the attribute vocabulary is finite ( but unbounded ) . in practice , of course , all attribute values will be stored as variables and there will be an upper limit on the size of such variables , so the attribute vocabulary will be finite and bounded , albeit by a very large number .      recall from definition  [ def : abac ] that , given a vocabulary @xmath63 , we write @xmath72 to denote the set of requests .",
    "note that a request may contain ( well - formed ) pairs @xmath125 having the same attribute name and different values .",
    "one obvious example arises when @xmath67 is the `` role '' attribute name and @xmath126 is the identifier of a role .",
    "we define the set of atomic policies @xmath127 to be the set of well - formed name - value pairs .",
    "that is @xmath128 .",
    "then we define @xmath129 note that the above interpretation of atomic policies is by no means the only possibility . in the context of a three - value decision set",
    ", we might return @xmath54 if @xmath130 and @xmath131 , @xmath35 if @xmath132 and @xmath39 otherwise . in the context of a four - value decision set",
    ", we could return @xmath133 if @xmath134 , since such a request both matches and does not match the attribute value @xmath135 for attribute @xmath67 .",
    "we discuss these possibilities in more detail in sec .",
    "[ app : conflict - abac ] .",
    "the ordering on @xmath136 , denoted by @xmath85 , is simply subset inclusion .",
    "we define the ordering @xmath94 on @xmath137 , where @xmath96 if and only if @xmath97 or @xmath98 .",
    "it is worth observing that if a request contains at most one value for each attribute , then each atomic policy is monotonic .",
    "more formally , if we define the set of queries @xmath138 , we can prove the following proposition .",
    "[ thm : single_monotonicity ] for all requests @xmath139 such that @xmath140 and for all atomic policies @xmath141 , we have @xmath142 .",
    "we will see in the following section that we can define a complete abac model that accepts requests from @xmath143 , but we can no longer ensure monotonicity .",
    "we now define a monotonic and monotonically - complete attribute - based access control ( abac ) model .",
    "@xmath144is defined to be @xmath145 .",
    "@xmath144is not merely of academic interest because it incorporates a number of features that are similar to xacml .",
    "in particular , we can    * construct targets from conjunctions and disjunctions of atomic policies ; * use the operators @xmath37 and @xmath146 to model deny - overrides and allow - overrides policy - combining algorithms ; * construct ( xacml ) rules , policies and policy sets using policies of the form @xmath147 , since @xmath79 if @xmath148 ( corresponding to `` matching '' a request to `` target '' @xmath83 and then evaluating policy @xmath84 ) .    the correspondence between @xmath144and xacml can not be exact , given that xacml is not monotonic .",
    "the main difference lies in the way in which @xmath37 and @xmath146 handle the @xmath35 decision .",
    "the operators @xmath37 and @xmath146 are what crampton and huth called intersection operators  @xcite , whereas the policy - combining algorithms in xacml are union operators .",
    "informally , an intersection operator requires both operands to have conclusive decisions , while a union operator ignores inconclusive decisions .",
    "thus , for example , @xmath149 , whereas the xacml deny - overrides algorithm would return @xmath39 given the same arguments .    a practical consequence of the design goals of @xmath144is that the @xmath35 decision will be returned more often than for analogous policies in xacml ( or other non - monotonic languages ) . in practice ,",
    "the policy enforcement point will have to either    ask the requester to supply additional attributes in the request ; or    deny all requests that are not explicitly allowed .",
    "[ thm : abac - monotonically - complete ] @xmath144is monotonic and monotonically complete .",
    "let us first observe that the operators @xmath150,@xmath37,@xmath146,@xmath81 and @xmath78 , as defined in table  [ tab : operators ] , are monotonic with respect to @xmath94 . following proposition  [ thm : single_monotonicity ] , we know that atomic policies are monotonic , and by direct induction , we can conclude that any policy in @xmath151 is monotonic , and thus that @xmath124 is monotonic .",
    "now , let @xmath152 be a monotonic ideal policy .",
    "we show that there exists a policy @xmath153 such that @xmath154 realizes @xmath22 .",
    "@xmath155 is a finite partially ordered set , so we may enumerate its elements using a topological sort .",
    "that is we may write @xmath156 $ ] , for some @xmath157 determined by @xmath63 and @xmath66 , @xmath71 ; and for all @xmath158 , @xmath159 . in particular , we have @xmath160 .    for any non - empty request @xmath161",
    ", we define the policy @xmath162 .",
    "note that @xmath163 for all @xmath164 .",
    "now , we have @xmath165 for all @xmath166 . moreover , for @xmath167 , we have @xmath168 and @xmath169 . in other words , for every request @xmath25 there is a value @xmath170 such that @xmath171 and @xmath172 for all @xmath173 .",
    "we now define the policy @xmath174 , where @xmath175 defines an @xmath157-ary operator @xmath176 .",
    "we now prove that @xmath176 is monotonic . intuitively , we want to prove that the order over tuples of decisions implies the order over requests , in order to use the monotonicity of @xmath22 .",
    "let @xmath177 and @xmath178 with @xmath179 , @xmath180 .",
    "let @xmath88 and @xmath25 be the requests identified by @xmath181 and @xmath182 , respectively . by definition , we have @xmath183 and @xmath184 .",
    "furthermore , let @xmath185 be the maximal index such that @xmath186 , it follows that @xmath187 . since @xmath188",
    ", we can deduce that @xmath189 , implying that @xmath190 , that is , @xmath191 . by hypothesis , @xmath22 is monotonic , and thus we have @xmath192 , allowing us to conclude that @xmath176 is monotonic .    finally , we know , by a result of blamey  @xcite , that any monotonic operator can be built from @xmath193 . in other words",
    ", the policy @xmath194 belongs to @xmath124 , and therefore we can conclude that @xmath22 can be realized by @xmath195 .",
    "theorem  [ thm : abac - monotonically - complete ] demonstrates that all access control policies built and evaluated using @xmath124 are monotonic , and that all monotonic ideal policies can be realized by a policy in @xmath124 .",
    "hence , if policy monotonicity is an important feature for a system designer , then @xmath124 provides that guarantee .",
    "however , @xmath124 is not complete , since some ( non - monotonic ) ideal policies can not be built from it .",
    "we propose in the following section a complete model .      in some situations",
    ", one might want to define non - monotonic policies or we might want to consider a query set in which the same attribute can have different values within a given query . in such situations , we consider the model @xmath196 which , in addition to being complete , is defined over the set of queries @xmath143 .",
    "@xmath197is defined to be @xmath198 .    [ thm : abacc - complete ] @xmath197is complete .",
    "the structure of this proof is similar to that of theorem  [ thm : abac - monotonically - complete ] , with the difference that the ideal policy @xmath22 need not be monotonic .",
    "we show that there exists a policy @xmath199 in @xmath196 that realizes @xmath22 .",
    "concretely , we consider the enumeration over the requests , and we build the same operator @xmath176 . however , in this case , we do not need to prove the monotonicity of @xmath176 , and we use instead the fact that the logic @xmath200 is functionally complete  @xcite , which ensures that @xmath176 can be built from @xmath201 .",
    "it is trivial to see that by considering @xmath143 , we lose the monotonicity with respect to the inclusion ordering @xmath202 .",
    "in particular , for @xmath203 with @xmath131 , we have @xmath204 , but @xmath205 .",
    "the function @xmath13 is monotonic for atomic policies and requests in @xmath143 if we adopt the ordering @xmath206 .",
    "this means that omitting attributes can cause the evaluation of an atomic policy to change from @xmath39 to @xmath54 or @xmath35 , or from @xmath54 to @xmath35 .",
    "while this seems to be reasonable , when combined with operators such as @xmath36 , omitting attributes can cause the evaluation of a policy to change from @xmath54 to @xmath39 .",
    "( thus a user may be able to construct a request @xmath89 that is allowed when @xmath88 is not .",
    "any non - monotonic language , such as xacml , incorporates this vulnerability . )",
    "the above choice to evaluate an atomic policy @xmath70 to @xmath39 if both @xmath70 and @xmath207 belongs to the query with @xmath131 and @xmath203 could be regarded as being logically inconsistent in the sense that the request also contains a non - matching value .",
    "one could equally well argue , for example , that the request should evaluate to @xmath54 .    in order to cope with such situations",
    ", we might , therefore , choose to work with the @xmath208-valued logic @xmath209 , using @xmath210 to denote conflicting information ( in contrast to @xmath35 which signifies lack of information ) .",
    "we introduce the ordering @xmath211 , where @xmath212 if , and only if , @xmath213 , @xmath214 or @xmath215 , and we define @xmath216 the definition of the policy operators @xmath217 and @xmath36 can be extended to unary operators on @xmath218 , where @xmath219 then the policy @xmath220 allows a request @xmath25 whenever @xmath25 contains a matching attribute , while the policy @xmath221 denies a request @xmath25 whenever @xmath25 contains a non - matching attribute value .",
    "although the notion of conflicting policy decision has already been studied  @xcite , to the best of our knowledge , this is the first time this notion of conflict has been used to evaluate targets .",
    "intuitively , a conflict indicates that the request provides too much information for this particular policy .",
    "it is worth observing that atomic policies are monotonic with respect to the ordering @xmath211 , i.e. , for all requests @xmath25 and @xmath88 such that @xmath222 and for all atomic policies @xmath70 , we have : @xmath223    a possible way to extend the operators defined in table  [ tab : operators ] is to consider the value @xmath210 as absorbing : for any operator @xmath224 , we define the operator @xmath225 as follows : @xmath226 $ } , \\\\",
    "\\oplus(d_1 , \\dots , d_k ) & \\text{otherwise}. \\end{cases}\\ ] ] clearly , given an operator @xmath227 defined over @xmath137 , if @xmath227 is monotonic according to @xmath94 , then @xmath228 is also monotonic with respect to @xmath211 .",
    "it follows that we can still safely use the operators generated by the operators @xmath150 , @xmath37 , @xmath146 and @xmath81 , and we can deduce that any realizable policy is also monotonic .",
    "however , we lose the result of monotonic completeness , and we can no longer ensure that any monotonic operator can be generated from this set of operators . obtaining such a result",
    "requires a deeper study of four - valued logic , and we leave it for future work .",
    "much of the work on specification of access control languages can be traced back to the early work of woo and lam , which considered the possibility that different policy components might evaluate to different authorization decisions  @xcite .",
    "more recent work has considered larger sets of policy decisions or more complex policy operators ( or both ) , and propose a formal representation of the corresponding metamodel  @xcite .",
    "the `` metamodels '' in the literature are really attempts to fix an authorization vocabulary , by identifying the sets and relations that will be used to define access control policies .    in contrast",
    ", our framework makes very few assumptions about access control models and policies that are written in the context of a model . in this",
    ", our framework most closely resembles the work of tschantz and krishnamurthi  @xcite , which considered a number of properties of a policy language , including determinism , totality , safety and monotonicity .",
    "the notion of a monotonic operator ( as defined by  @xcite ) is somewhat different from ours .",
    "this is in part because a different ordering on the set of decisions @xmath137 is used and because monotonicity is concerned with the inclusion of sub - policies and the effect this has on policy evaluation .",
    "this contrasts with our approach , where we are concerned with whether the exclusion of information from a request can influence the decision returned .",
    "( in fact , our concept of monotonicity is closer to the notion of safety defined in  @xcite : if a request @xmath25 is `` lower '' than @xmath88 , then the decision returned for @xmath25 is `` lower '' than that of @xmath88 . )",
    "we would express their notion of monotonicity in the following way : a policy operator @xmath227 is monotonic ( in the context of model @xmath122 ) if for all @xmath229 and all @xmath230 , if @xmath231 , then @xmath232 for any @xmath233 and any policy @xmath234 .",
    "moreover , our framework is concerned with arbitrary authorization vocabularies and queries , unlike that of tschantz and krishnamurthi , which focused on the standard subject - object - action request format .",
    "the only assumption we make is that all policies can be represented using a tree - like structure and that policy decisions can be computed from the values assigned to leaf nodes and the interpretation of the operators at each non - leaf node .",
    "in addition , we define the notion of _ completeness _ of a model , which is concerned with the expressivity of the policy operators .",
    "there exists prior work on comparing the expressive power of different access control models or the extent to which one model is able to simulate another  @xcite . in this paper , we show how our framework enables us to establish whether a model based on a particular set of atomic policies , decision set and policy connectives is complete .",
    "we can , therefore , compare the completeness of two different models by , for example , fixing an authorization vocabulary and comparing the completeness of models that differ in one or more of the models components ( that is , ones that differ in the set of connectives , decision sets , atomic policies and authorization semantics ) .",
    "while this is similar in spirit to earlier work , this is not the primary aim of this paper , although it would certainly be a fertile area for future research .",
    "we have presented a generic framework for specifying access control controls , within which a large variety of access control models arise as special cases , and which allows us to reason about the global properties of such systems .",
    "a major strength of our approach is that we do not provide `` yet another access control language '' .",
    "the framework is not intended to provide an off - the - shelf policy language or pdp ( unlike xacml , for example ) , nor is it intended to be an access control model ( in the style of rbac96 , say ) .",
    "rather , we try to model all aspects of an access control system at an abstract level and to provide a framework that can be instantiated in many different ways , depending on the choices made for request attributes , atomic policies , policy decisions and policy evaluation functions . in doing",
    "so we are able to identify        there are many opportunities for future work .",
    "the notions of monotonicity and completeness are examples of general properties of an access control model that we can characterize formally within our framework .",
    "we have already noted that there are at least two alternative semantics for atomic policies having the form @xmath70 for a three - valued decision set and even more alternatives for a four - valued decision set . it would be interesting to see how these alternative semantics affect monotonicity and completeness .",
    "we would like to study the composition of access control models , and under what circumstances composition preserves monotonicity and completeness .",
    "further properties that are of interest include policy equivalence , policy ordering ( where , informally , one policy @xmath235 is `` more restrictive '' than @xmath236 if it denies every request that is denied by @xmath236 ) , which may allow us to define what it means for a realizable policy to be `` optimal '' with respect to an ( unrealizable ) ideal policy .",
    "moreover , our definition of monotonicity is dependent on the ordering on the set of decisions .",
    "monotonicity , in the context of the ordering @xmath237 , for example , is a stronger property than the one we have considered in this paper .",
    "again , it would be interesting to investigate the appropriateness of different forms of monotonicity . furthermore",
    ", although xacml is proven not to be monotonic , it is not known under which conditions it can be monotonically - complete , and if additional operators are needed to prove this property , which is also likely to depend on the decision orderings considered . in this paper , we have assumed that there exists an ideal policy and that such a policy is fixed .",
    "generally , however , a system evolves over time , and an access control policy will need to be updated to cope with changes to that system that affect the users , resources , or context . thus it may be more realistic to specify an initial ideal policy , which might be extremely simple , and the access control policy that best approximates it , and then define rules by which the access control policy may evolve . with this in mind , it makes sense to regard the access control policy ( or components thereof ) as a protected object .",
    "security is then defined in terms of properties that `` reachable '' access control policies must satisfy .",
    "typical examples of such properties are `` liveness '' and `` safety ''  @xcite . including administrative policies within our framework and investigating",
    "properties such as liveness and safety will be an important aspect of our future work in this area .",
    "j.  crampton and c.  morisset , `` ptacl : a language for attribute - based access control in open systems , '' in _ principles of security and trust - first international conference , ( post 2012 ) , proceedings _ , ser .",
    "lecture notes in computer science , vol . 7215 , 2012 , pp . 390409 .",
    "a.  griesmayer and c.  morisset , `` automated certification of authorisation policy resistance , '' in _ esorics _ , ser .",
    "lecture notes in computer science , j.  crampton , s.  jajodia , and k.  mayes , eds .",
    "8134.1em plus 0.5em minus 0.4emspringer , 2013 , pp",
    ". 574591 .",
    "d.  ferraiolo and v.  atluri , `` a meta model for access control : why is it needed and is it even possible to achieve ? '' in _ proceedings of the 13th acm symposium on access control models and technologies_.1em plus 0.5em minus 0.4emacm , 2008 , pp . 153154 .",
    "p.  rao , d.  lin , e.  bertino , n.  li , and j.  lobo , `` an algebra for fine - grained integration of xacml policies , '' in _ sacmat _",
    ", b.  carminati and j.  joshi , eds.1em plus 0.5em minus 0.4emacm , 2009 , pp . 6372 .      m.  c. tschantz and s.  krishnamurthi , `` towards reasonability properties for access - control policy languages , '' in _ sacmat _ , d.  f. ferraiolo and i.  ray , eds.1em plus 0.5em minus 0.4emacm , 2006 , pp .",
    "160169 .",
    "j.  crampton and m.  huth , `` an authorization framework resilient to policy evaluation failures , '' in _ esorics _ , ser .",
    "lecture notes in computer science , d.  gritzalis , b.  preneel , and m.  theoharidou , eds .",
    "1em plus 0.5em minus 0.4emspringer , 2010 , pp . 472487 .",
    "e.  bertino , b.  catania , e.  ferrari , and p.  perlasca , `` a logical framework for reasoning about access control models , '' _ acm transactions on information and system security _ , vol .  6 , no .  1 , pp . 71127 , 2003 .      j.  crampton and m.  huth , `` a framework for the modular specification and orchestration of authorization policies , '' in _ nordsec _ , ser .",
    "lecture notes in computer science , t.  aura , k.  jrvinen , and k.  nyberg , eds .",
    "7127.1em plus 0.5em minus 0.4emspringer , 2010 .",
    "n.  damianou , n.  dulay , e.  lupu , and m.  sloman , `` the ponder policy specification language , '' in _ policy _ , ser .",
    "lecture notes in computer science , m.  sloman , j.  lobo , and e.  lupu , eds .",
    "1995.1em plus 0.5em minus 0.4emspringer , 2001 , pp .",
    "1838 .",
    "n.  li , q.  wang , w.  h. qardaji , e.  bertino , p.  rao , j.  lobo , and d.  lin , `` access control policy combining : theory meets practice , '' in _ sacmat _ ,",
    "b.  carminati and j.  joshi , eds.1em plus 0.5em minus 0.4emacm , 2009 , pp . 135144 .",
    "q.  ni , e.  bertino , and j.  lobo , `` d - algebra for composing access control policy decisions , '' in _ asiaccs _ , w.  li , w.  susilo , u.  k. tupakula , r.  safavi - naini , and v.  varadharajan , eds.1em plus 0.5em minus 0.4emacm , 2009 , pp .",
    "298309 .",
    "l.  habib , m.  jaume , and c.  morisset , `` a formal comparison of the bell & lapadula and rbac models , '' in _ ias _",
    ", m.  rak , a.  abraham , and v.  casola , eds.1em plus 0.5em minus 0.4emieee computer society , 2008 , pp .",
    "s.  osborn , r.  sandhu , and q.  munawer , `` configuring role - based access control to enforce mandatory and discretionary access control policies , '' _ acm transactions on information and system security _ ,",
    "vol .  3 , no .  2 , pp .",
    "85106 , 2000 ."
  ],
  "abstract_text": [
    "<S> there have been many proposals for access control models and authorization policy languages , which are used to inform the design of access control systems . </S>",
    "<S> most , if not all , of these proposals impose restrictions on the implementation of access control systems , thereby limiting the type of authorization requests that can be processed or the structure of the authorization policies that can be specified . in this paper </S>",
    "<S> , we develop a formal characterization of the features of an access control model that imposes few restrictions of this nature . </S>",
    "<S> our characterization is intended to be a generic framework for access control , from which we may derive access control models and reason about the properties of those models . in this paper </S>",
    "<S> , we consider the properties of monotonicity and completeness , the first being particularly important for attribute - based access control systems . </S>",
    "<S> xacml , an xml - based language and architecture for attribute - based access control , is neither monotonic nor complete . using our framework , </S>",
    "<S> we define attribute - based access control models , in the style of xacml , that are , respectively , monotonic and complete . </S>"
  ]
}