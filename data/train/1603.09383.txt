{
  "article_text": [
    "two quantum algorithms threaten to dramatically reduce the security of currently deployed cryptosystems : shor s algorithm solves the abelian hidden subgroup problem in polynomial time @xcite , and grover s algorithm provides a quadratic improvement in the number of queries needed to solve black - box search problems @xcite .",
    "efficient quantum algorithms for integer factorization , finite field discrete logarithms , and elliptic curve discrete logarithms can all be constructed by reduction to the abelian hidden subgroup problem . as such",
    ", cryptosystems based on these problems can not be considered secure in a post - quantum environment .",
    "diffie - hellman key exchange , rsa encryption , and rsa signatures will all need to be replaced before quantum computers are available .",
    "some standards bodies have already begun discussions about transitioning to new public key cryptographic primitives @xcite .",
    "the situation is less dire for hash functions and symmetric ciphers . in a pre - quantum setting ,",
    "a cryptographic primitive that relies on the hardness of inverting a one - way function is said to offer @xmath8-bit security if inverting the function is expected to take @xmath9 evaluations of the function .",
    "an exhaustive search that is expected to take @xmath10 queries with classical hardware can be performed with @xmath11 queries using grover s algorithm on quantum hardware .",
    "hence , grover s algorithm could be said to reduce the bit - security of such primitives by half ; one might say that a 128-bit pre - quantum primitive offers only 64-bit security in a post - quantum setting .",
    "a conservative defense against quantum search is to double the security parameter ( e.g. the key length of a cipher , or the output length of a hash function ) .",
    "however , this does not mean that the true cost of grover s algorithm should be ignored .",
    "a cryptanalyst may want to know the cost of an attack even if it is clearly infeasible , and users of cryptosystems may want to know the minimal security parameter that provides `` adequate protection '' in the sense of @xcite .    in the context of pre - image search on a hash function ,",
    "the cost of a pre - quantum attack is given as a number of invocations of the hash function .",
    "if one assumes that quantum queries have the same cost as classical queries , then the query model provides a reasonable comparison between quantum and classical search .",
    "however , realistic designs for large quantum computers call this assumption into question .",
    "the main difficulty is that the coherence time of physical qubits is finite .",
    "noise in the physical system will eventually corrupt the state of any long computation . if the physical error rate can be suppressed below some threshold , then",
    "_ logical qubits _ with arbitrarily long coherence times can be created using quantum error correcting codes .",
    "preserving the state of a logical qubit is an active process that requires periodic evaluation of an error detection and correction routine .",
    "this is true even if no logical gates are performed on the logical qubit .",
    "hence the classical processing required to evaluate a quantum circuit will grow in proportion to both the depth of the circuit and the number of logical qubits on which it acts .",
    "we suggest that a cost model that facilitates direct comparisons of classical and quantum algorithms should take the classical computation required for quantum error correction into consideration .",
    "clearly such estimates will be architecture dependent , and advances in quantum computing could invalidate architectural assumptions .    to better understand the impact of costing quantum error correction , we present an estimate of the cost of pre - image attacks on sha-2 and sha-3 assuming a quantum architecture based on the surface code with a logical clifford+@xmath12 gate set . we execute the following procedure for each hash function .",
    "first , we implement the function as a reversible circuit over the clifford+@xmath12 gate set .",
    "we use a quantum circuit optimization tool , `` @xmath12-par '' @xcite , to minimize the circuit s @xmath12-count and @xmath12-depth gate is significantly more expensive than clifford group gates on the surface code . ] . with the optimized circuit in hand",
    "we estimate the additional overhead of fault tolerant computation .",
    "in particular , we estimate the size of the circuits needed to produce the ancillary states that are consumed by @xmath12-gates .",
    "grassl et al . presented a logical - layer quantum circuit for applying grover s algorithm to aes key recovery @xcite . separately , fowler et al .",
    "have estimated the physical resources required to implement shor s factoring algorithm on a surface code based quantum computer @xcite .",
    "our resource estimates combine elements of both of these analyses .",
    "we focus on the number of logical qubits in the fault - tolerant circuit and the overall depth of the circuit in units of surface code cycles . while our cost model ties us to a particular quantum architecture , we segment our analysis into several layers so that the impact of a different assumptions at any particular level can be readily evaluated . we illustrate our method schematically in fig .",
    "[ fig : flowchart_lite ] .",
    "the structure of this article reflects our workflow . in section  [ sct : grover ] we state the problem of pre - image search using grover s algorithm .",
    "section [ sct : cost_metric ] introduces our framework for computing costs , and section [ sct2 ] applies these principles to compute the intrinsic cost of performing grover search .",
    "sections  [ sct : sha2 ] and [ sct : sha3 ] detail our procedure for generating reversible circuits for sha-256 and sha3 - 256 respectively . in section [ sct :",
    "fault_tol ] we embed these reversible implementations into a surface code , and estimate the required physical resources .",
    "we summarize our results and propose avenues of future research in section [ sct : conclusions ] .",
    "let @xmath13 be an efficiently function . for a fixed @xmath14 , the value @xmath15 such that @xmath16 is called a _",
    "pre - image _ of @xmath17 . in the worst case ,",
    "the only way to compute a pre - image of @xmath17 is to systematically search the space of all inputs to @xmath18 . a function that must be searched in this way",
    "is known as a _",
    "one - way function_. a one - way function that is bijective is a _ _ one - way permutation _",
    "_ inputs is expected to behave roughly like a one - way permutation .",
    "the degree to which it fails to be injective should not significantly affect the expected probability of success for grover s algorithm . ] .    given a one - way permutation @xmath18",
    ", one might ask for the most cost effective way of computing pre - images . with a classical computer one must query @xmath18 on the order of @xmath19 times before finding a pre - image . by contrast , a quantum computer can perform the same search with @xmath20 queries to @xmath18 by using grover s algorithm @xcite .",
    "of course , counting only the queries to @xmath18 neglects the potentially significant overhead involved in executing @xmath18 on a quantum computer .",
    "figure [ fig : full_algorithm ] gives a high - level description of grover s algorithm .",
    "the algorithm makes @xmath21 calls to @xmath22 , the _ grover iteration_. the grover iteration has two subroutines .",
    "the first , @xmath23 , implements the predicate @xmath24 that maps @xmath15 to @xmath25 if and only if @xmath26 .",
    "each call to @xmath23 involves two calls to a reversible implementation of @xmath18 and one call to a comparison circuit that checks whether @xmath16 .",
    "the second subroutine in @xmath22 implements the transformation @xmath27 and is called the _",
    "diffusion operator_. the diffusion operator is responsible for amplifying the probability that a measurement of the output register would yield @xmath15 such that @xmath16 .",
    "as it involves only single - qubit gates and a one @xmath8-fold controlled - not , the cost of the diffusion operator is expected to be small compared with that of @xmath23 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ without significant future effort , the classical processing will almost certainly limit the speed of any quantum computer , particularly one with intrinsically fast quantum gates . _",
    "fowler  whiteside ",
    "hollenberg  @xcite + _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the majority of the overhead for quantum computation , under realistic assumptions about quantum computing architectures , comes from error detection and correction",
    ". there are a number of error correction methods in the literature , however the most promising , from the perspective of experimental realizability , is the surface code @xcite .",
    "the surface code allows for the detection and correction of errors on a two - dimensional array of nearest - neighbor coupled physical qubits .",
    "a distance @xmath28 surface code encodes a single logical qubit into an @xmath29 array of physical qubits @xmath30 .",
    "a classical error detection algorithm must be run at regular intervals in order to track the propagation of physical qubit errors and , ultimately , to prevent logical errors .",
    "every surface code _ cycle _ involves some number of one- and two - qubit physical quantum gates , physical qubit measurements , and classical processing to detect and correct errors .",
    "the need for classical processing allows us to make a partial comparison between the cost of classical and quantum algorithms for any classical cost metric .",
    "the fact that quantum system engineers consider classical processing to be a bottleneck for quantum computation @xcite suggests that an analysis of the classical processing may serve as a good proxy for an analysis of the cost of quantum computation itself .    performing this analysis",
    "requires that we make a number of assumptions about how quantum computers will be built , not least of which is the assumption that quantum computers will require error correcting codes , and that the surface code will be the code of choice .",
    "[ assume : scqc ] the resources required for any large quantum computation are well approximated by the resources required for that computation on a surface code based quantum computer .",
    "fowler et al .",
    "@xcite give an algorithm for the classical processing required by the surface code . a timing analysis of this algorithm",
    "was given in @xcite , and a parallel variant was presented in @xcite . under a number of physically motivated assumptions , the algorithm of @xcite runs in constant time per round of error detection .",
    "it assumes a quantum computer architecture consisting of an @xmath31 grid of logical qubits overlaid by a constant density mesh of classical computing units .",
    "more specifically , the proposed design involves one asic ( application - specific integrated circuit ) for each block of @xmath32 physical qubits .",
    "these asics are capable of nearest - neighbor communication , and the number of rounds of communication between neighbors is bounded with respect to the error model .",
    "the number of asics scales linearly with the number of logical qubits , but the constant @xmath33 , and the amount of computation each asic performs per time step , is independent of the number of logical qubits .",
    "each logical qubit is a square grid of @xmath34 physical qubits where @xmath35 depends on the length of the computation and the required level of error suppression .",
    "we are able to estimate @xmath35 directly ( section [ sct : fault_tol ] ) .",
    "following @xcite we will assume that @xmath36 .",
    "the number of classical computing units we estimate is therefore equal to the number of logical qubits in the circuit . note that assuming @xmath37 introduces a dependence between @xmath33 and the length of the computation , but we will ignore this detail . since error correction must be performed on the time scale of hundreds of nanoseconds ( @xmath38 in @xcite ) , we do not expect it to be practical to make @xmath33 much larger than @xmath35 .",
    "furthermore , while @xmath35 depends on the length of the computation it will always lie in a fairly narrow range . a value of @xmath39 is sufficient even for the extremely long computations we consider .",
    "the comparatively short modular exponentiation computations in @xcite require @xmath40 . as long as it is not practical to take @xmath33 much larger than @xmath41 , the assumption that @xmath37 will introduce only a small error in our analysis .",
    "[ assume : asics ] the classical error correction routine for the surface code on an @xmath31 grid of logical qubits requires an @xmath31 mesh of classical processors ( i.e. @xmath37 ) .",
    "the algorithm that each asic performs is non - trivial and estimating its exact runtime depends on the physical qubit error model . in @xcite evidence was presented that the error correction algorithm requires @xmath42 operations , on average , under a reasonable error model .",
    "this work considered a single qubit in isolation , and some additional overhead would be incurred by communication between asics .",
    "a heuristic argument is given in @xcite that the communication overhead is also independent of @xmath43 , i.e. that the radius of communication for each processor depends on the noise model but not on the number of logical qubits in the circuit .",
    "each asic performs a constant number of operations per surface code cycle .",
    "finally we ( arbitrarily ) peg the cost of a surface code cycle to the cost of a hash function invocation . if we assume , as in @xcite , that a surface code cycle time on the order of @xmath44 is achievable",
    ", then we are assuming that each logical qubit is equipped with an asic capable of performing several million hashes per second .",
    "this would be on the very low end of what is commercially available for bitcoin mining today @xcite , however the asics used for bitcoin have very large circuit footprints .",
    "one could alternatively justify this assumption by noting that typical hash functions require @xmath45 cycles per byte on commercial desktop cpus @xcite .",
    "this translates to approximately @xmath46 cycles per hash function invocation . since commercial cpus",
    "operate at around 4  ghz , this again translates to a few million hashes per second .",
    "[ assume : equalcost ] the temporal cost of one surface code cycle is equal to the temporal cost of one hash function invocation .    combining assumptions [ assume : scqc ] , [ assume : asics ] , and [ assume : equalcost ] we arrive at the following metric for comparing the costs of classical and quantum computations .",
    "[ metric ] the cost of a quantum computation involving @xmath47 logical qubits for a duration of @xmath48 surface code cycles is equal to the cost of classically evaluating a hash function @xmath49 times .",
    "equivalently we will say that _ one logical qubit cycle _",
    "is equivalent to _ one hash function invocation_.    we will use the term `` cost '' to refer either to logical qubit cycles or to hash function invocations .",
    "suppose there is polynomial overhead per grover iteration , i.e. @xmath50 grover iterations cost @xmath51 logical qubit cycles for some real @xmath52 independent of @xmath8",
    ". then an adversary who is willing to execute an algorithm of cost @xmath53 can use grover s algorithm to search a space of @xmath8 bits provided that @xmath54    we define the _ overhead _ of the circuit as @xmath52 and the _ advantage _ of the circuit as @xmath55 . note that if we view @xmath8 as a function of @xmath52 and @xmath56 then for any fixed @xmath52 we have @xmath57 i.e. asymptotically , grover s algorithm provides a quadratic advantage over classical search . however , here we are interested in non - asymptotic advantages .    when costing error correction , we must have @xmath58 purely from the space required to represent the input .",
    "however , we should not expect the temporal cost to be independent of @xmath8 .",
    "even if the temporal cost is dominated by the @xmath8-fold controlled - not gate , the clifford+@xmath12 depth of the circuit will be at least @xmath59 @xcite .",
    "hence , @xmath60 for @xmath61 .",
    "this still neglects some spatial overhead required for magic state distillation , but @xmath62 may be used to derive strict upper bounds , in our cost model , for the advantage of grover search .    in practice",
    "the overhead will be much greater .",
    "the aes-256 circuit from @xcite has depth @xmath63 and requires @xmath64 logical qubits .",
    "this yields overhead of @xmath65 from the reversible layer alone .",
    "substituting @xmath66 , the case of equality in equation [ eq : fixedcostk ] is @xmath67 where @xmath68 is the lambert w - function .",
    "table [ tab : kctov ] in appendix [ app : tables ] gives the advantage of quantum search as a function of its cost @xmath56 and overhead @xmath52 ; @xmath8 is computed using equation [ eq : kfromcv ] .",
    "the secure hash algorithm @xmath69 ( sha-2 ) @xcite is a family of collision resistant cryptographic hash functions .",
    "there are a total of six functions in the sha-2 family : sha-224 , sha-256 , sha-384 , sha-512 , sha-512/224 and sha-512/256 .",
    "there are currently no known classical pre - image attacks against any of the sha-2 algorithms which are faster then brute force .",
    "we will focus on sha-256 , a commonly used variant , and will assume a message size of one block ( 512 bits ) .",
    "first the message block is stretched using algorithm  [ alg : sha2stretch ] and the result is stored in @xmath70 .",
    "the internal state is then initialized using a set of constants .",
    "the round function is then run 64 times , each run using a single entry of @xmath70 to modify the internal state .",
    "the round function for sha-256 is shown in algorithm  [ alg : sha2 ] .",
    "@xmath71 @xmath72 @xmath73 + \\mathbf{w}[i]$ ] @xmath74",
    "@xmath75 @xmath76 @xmath77 @xmath78 @xmath79 @xmath80 @xmath81 @xmath82 @xmath83 @xmath84    @xmath85 @xmath86 @xmath87 \\gets   \\mathbf{w}_{i-16 } + \\sigma_0 + \\mathbf{w}_{i-7 } + \\sigma_1 $ ]      our implementation of the sha-256 algorithm as a reversible circuit is similar to the one presented in @xcite ( with the addition of the stretching function ) .",
    "each round can be performed fully reversibly ( with access to the input ) so no additional space is accumulated as rounds are performed .",
    "the in - place adders shown in the circuit are described in @xcite .",
    "the adders perform the function @xmath88 where the @xmath89 is a single ancilla bit used by the adder .",
    "since the @xmath90 blocks use only rotate and xor operations , they are constructed using cnot gates exclusively .",
    "@xmath91 is the bitwise majority function .",
    "the majority function is computed using a cnot gate and two toffoli gates as show in fig .",
    "[ fig : maj ] .",
    "@xmath92    @xmath93    the @xmath94 function is @xmath95 which can be rewritten as @xmath96 .",
    "this requires a single toffoli gate as shown in fig .",
    "[ fig : ch ] .",
    "there are a few options for constructing the round circuit .",
    "for example if space is available some of the additions can be performed in parallel , and the cleanup of the @xmath90 , @xmath94 , and @xmath91 functions can be neglected if it is desirable to exchange space for a lower gate count .",
    "we select the round implementation shown in fig .",
    "[ fig : sha2 ] .      for the quantum implementation we converted the toffoli - cnot - not circuit ( fig .",
    "[ fig : sha2 ] ) discussed above into a clifford+@xmath12 circuit . to expand the toffoli gates we used the @xmath12-depth @xmath97 toffoli reported in @xcite .",
    "@xmath12-par was then used to optimize a single round .",
    "the results are shown in table [ table : shaopt ] . due to the construction of the adders every toffoli gate shares two controls with another toffoli gate .",
    "this allows @xmath12-par to remove a large number of @xmath12-gates ( see @xcite ) .    .",
    "@xmath12-par optimization results for a single round of sha-256 , one iteration of the stretch algorithm and full sha-256 .",
    "note that 64 iterations of the round function and 48 iterations of the stretch function are needed .",
    "the stretch function does not contribute to overall depth since it can be performed in parallel with the rounds function .",
    "no @xmath98 gates are used so an @xmath98 column is not included .",
    "the circuit uses 2402 total logical qubits . [ cols=\"<,>,>,>,>,>,>,>,>\",options=\"header \" , ]",
    "classical search is easily parallelized by distributing the @xmath19 bitstrings among @xmath99 processors .",
    "each processor fixes the first @xmath100 bits of its input to a unique string and sequentially evaluates every setting of the remaining @xmath101 bits .",
    "since our cost metric counts only the number of invocations of @xmath102 , the cost of parallel classical search is @xmath19 for all @xmath100 . if one is more concerned with time ( i.e. the number of sequential invocations ) than with area , or vice versa , it may be more useful to report the cost as @xmath103 . or , in this case , @xmath104 .",
    "quantum computation has a different time / area trade - off curve .",
    "in particular , parallel quantum strategies have strictly greater cost than sequential quantum search .",
    "consider sequential quantum search with cost @xmath105 .",
    "parallelizing this algorithm across @xmath99 quantum processors reduces the temporal cost per processor by a factor of @xmath106 and increases the area by a factor of @xmath99 .",
    "fixing @xmath100 bits of the input does not change the overhead of the grover iteration , so the cost for parallel quantum search on @xmath99 processors is @xmath107 ."
  ],
  "abstract_text": [
    "<S> we investigate the cost of grover s quantum search algorithm when used in the context of pre - image attacks on the sha-2 and sha-3 families of hash functions . </S>",
    "<S> our cost model assumes that the attack is run on a surface code based fault - tolerant quantum computer . </S>",
    "<S> our estimates rely on a time - area metric that costs the number of logical qubits times the depth of the circuit in units of surface code cycles . </S>",
    "<S> as a surface code cycle involves a significant classical processing stage , our cost estimates allow for crude , but direct , comparisons of classical and quantum algorithms .    </S>",
    "<S> we exhibit a circuit for a pre - image attack on sha-256 that is approximately @xmath0 surface code cycles deep and requires approximately @xmath1 logical qubits . </S>",
    "<S> this yields an overall cost of @xmath2 logical - qubit - cycles . </S>",
    "<S> likewise we exhibit a sha3 - 256 circuit that is approximately @xmath3 surface code cycles deep and requires approximately @xmath4 logical qubits for a total cost of , again , @xmath5 logical - qubit - cycles . </S>",
    "<S> both attacks require on the order of @xmath6 queries in a quantum black - box model , hence our results suggest that executing these attacks may be as much as @xmath7 billion times more expensive than one would expect from the simple query analysis . </S>"
  ]
}