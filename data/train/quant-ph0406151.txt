{
  "article_text": [
    "a central problem in quantum computation is the hidden subgroup problem ( hsp ) . here , we are given a black box that computes a function on elements of a group @xmath0 .",
    "the function is known to be constant and distinct on left cosets of a subgroup @xmath1 and our goal is to find @xmath2 .",
    "interestingly , most known quantum algorithms that provide a super - polynomial advantage over classical algorithms solve special cases of the hsp on abelian groups .",
    "there has also been considerable interest in the hsp on noncommutative groups ( see , e.g. , @xcite ) .",
    "for example , one important group is the symmetric group : it is known that solving the hsp on the symmetric group leads to a solution to graph isomorphism  @xcite .    in this paper",
    "we will be interested in the hsp on the dihedral group .",
    "the dihedral group of order @xmath3 , denoted @xmath4 , is the group of symmetries of an @xmath5-sided regular polygon .",
    "it consists of @xmath5 rotations , which we denote by @xmath6 , and @xmath5 reflections , which we denote by @xmath7 .",
    "it is isomorphic to the abstract group generated by the element @xmath8 of order @xmath9 and the element @xmath10 of order 2 subject to the relation @xmath11 .",
    "regev  @xcite showed that under certain conditions , an efficient solution to the dihedral hsp implies a quantum algorithm for lattice problems .",
    "this gives a strong incentive to finding an efficient solution to the dihedral hsp .",
    "however , although the dihedral group is one of the simplest noncommutative groups , no efficient solution to the dihedral hsp is known .",
    "ettinger and hyer  @xcite showed that one can obtain sufficient statistical _ information _ about the hidden subgroup with only a polynomial number of queries to the black box .",
    "however , there is no efficient algorithm that solves the hsp using this information .",
    "in fact , it was shown in @xcite that solving hsp using this information is a hard problem in a certain precise sense .",
    "recently , kuperberg @xcite presented the first subexponential time algorithm for the dihedral hsp .",
    "namely , his algorithm runs in time @xmath12 ( the input size is @xmath13 ) .",
    "this is currently the best known algorithm for the dihedral hsp .",
    "however , in order to achieve this running time , kuperberg s algorithm requires @xmath12 space .",
    "essentially , this happens since the algorithm keeps many qubits around until certain collisions occur .",
    "our main result in this paper is an algorithm that requires only polynomial space , i.e. , @xmath14 .",
    "the running time of our algorithm is still subexponential and only slightly higher than kuperberg s algorithm , namely , @xmath15 .",
    "our algorithm combines ideas from kuperberg s algorithm @xcite and a paper by regev @xcite .",
    "our classical abstraction of the problem is influenced by a paper by blum , kalai and wasserman @xcite .",
    "we start in section [ sec : kup ] with a simplified description of kuperberg s algorithm .",
    "then , in section [ sec : new ] , we describe our new algorithm .",
    "in this section we present a simplified description of kuperberg s algorithm .",
    "we concentrate on the basic idea and try to omit some of the more technical issues .",
    "we start with describing an algorithm for a certain classical problem .",
    "we will later show that this algorithm corresponds exactly to kuperberg s algorithm .      for simplicity",
    ", we only consider the case where @xmath16 and @xmath17 for some integer @xmath18 .",
    "the algorithm can be modified to work without this assumption .",
    "let us consider the following classical scenario .",
    "we are dealing with ` objects ' that are labelled with numbers modulo @xmath16 ( eventually , these objects will turn out to be qubits , but let s forget about that for now ) .",
    "our goal is to obtain an object whose label is @xmath19 .",
    "these objects are created by a ` machine ' that we have at our disposal . this machine outputs both an object and its label .",
    "we are guaranteed that the machine outputs objects whose label is chosen uniformly at random from @xmath20 .",
    "each time we ask the machine for a new object we pay one time unit .",
    "so here is our first algorithm : call the machine repeatedly until it happens to output an object whose label is @xmath19 .",
    "clearly , this algorithm requires @xmath21 time units on average .",
    "it turns out that these objects have a nice property : given two objects , labelled with @xmath22 and @xmath23 , we can _ combine _ them and obtain a new object whose label is @xmath24 ( the two original objects are gone ) .",
    "this combination operation succeeds with probability 50% ; with probability 50% , the operation fails and then both original objects are gone .",
    "let us now show how to obtain an algorithm whose running time is @xmath25 .",
    "this is the basic idea underlying @xcite .",
    "the overall structure of the algorithm is that of a ` pipeline ' of @xmath18 routines , as in figure [ fig : pipeline ] .",
    "that is , the input to routine @xmath26 is the output of the routine @xmath27 .",
    "the input to routine @xmath28 are ` fresh ' objects from the machine , i.e. , objects whose labels are chosen uniformly at random . for any @xmath29 , the output of routine @xmath27 ( and the input to routine @xmath26 ) are objects whose labels have the following distribution : the @xmath30 least significant bits equal 0 and the remaining @xmath31 bits are chosen uniformly at random . in other words , each routine is supposed to output objects whose labels have @xmath18 additional bits zeroed out .",
    "notice that with probability 50% , the last routine ( i.e. , routine @xmath18 ) outputs an object whose label is @xmath19 .",
    "it remains to describe how to implement the routines .",
    "let us describe routine @xmath27 for some @xmath29 .",
    "the routine maintains a pile of objects .",
    "initially , the pile is empty .",
    "whenever a new object arrives , the routine compares the @xmath18 bits in positions @xmath32 of its label to the same bits in all of the objects currently in its pile ( notice that the bits in positions @xmath33 are guaranteed to be zero ) .",
    "if no match is found ( i.e. , no object currently in the pile has the same setting to these @xmath18 bits ) then the routine adds the new object to the pile .",
    "if a match is found then the routine _ combines _ the new object with the matching object in the pile . with probability 50% ,",
    "the combination is successful and the machine outputs the resulting object .",
    "notice that the @xmath30 least significant bits of the label of the resulting object are all zero .",
    "moreover , the remaining @xmath31 bits are still random since the behavior of the routine does not depend on them .    finally , let us show that the expected running time of the algorithm is indeed @xmath25 .",
    "in other words , we will show that this is the amount of time it takes to obtain one object from the last routine in the pipeline .",
    "the intuitive idea is the following .",
    "initially , the pile of a routine is empty and matches rarely occur .",
    "however , after around @xmath34 objects the pile gets rather full ; from that point on , the routine needs an average of four objects in order to produce one output object ( since we are combining two objects in order to produce one output object and our success probability is 50% ) .",
    "hence , the number of objects needed from the machine in order to produce one object by the final routine is roughly @xmath35 .",
    "let us make this argument more formal .",
    "first we observe that with very high probability , a routine that gets as input @xmath36 objects for some @xmath37 , outputs at least @xmath38 objects .",
    "this follows by noting that at most @xmath34 of these objects can remain in the pile . on the remaining @xmath39 objects , the routine performs combination operations .",
    "the expected number of output objects is therefore @xmath40 ; a simple application of the chernoff bound shows that with very high probability , the number of output objects is at least @xmath38 . we can now complete the proof by noting that if the first routine is given @xmath41 objects then with very high probability the last routine outputs at least one object ( and in fact , at least @xmath34 objects ) .",
    "we now show how to obtain from the above an algorithm for the dihedral hidden subgroup problem .",
    "we are given oracle access to a function @xmath42 from the dihedral group to some arbitrary set @xmath43 .",
    "the function is promised to be constant on cosets of some subgroup @xmath44 and distinct on different cosets .",
    "our goal is to extract the subgroup @xmath2 .",
    "ettinger and hyer @xcite showed that it is enough to solve the problem for the case where @xmath45 is generated by a reflection @xmath46 .",
    "hence , our goal now is to find @xmath47 , a number between @xmath48 and @xmath49 .",
    "in fact , finding the _ least significant bit _ of @xmath47 is enough .",
    "indeed , let us show how to find @xmath47 given an algorithm that only finds the least significant bit of @xmath47 .",
    "we start by calling the algorithm once with the given oracle .",
    "this allows us to obtain the least significant bit of @xmath47 .",
    "assume the answer is ` 0 ' .",
    "then , consider the function @xmath50 given by @xmath51 .",
    "notice that this function hides the subgroup @xmath52 of @xmath53 .",
    "similarly , if the answer is ` 1 ' , consider the function @xmath54 given by @xmath55 .",
    "this function hides the subgroup @xmath56 of @xmath53 .",
    "we can now obtain the second least significant bit of @xmath47 by calling the algorithm with either @xmath57 or @xmath58 . by continuing this process",
    ", we can find all the bits of @xmath47 .",
    "hence , in the following we show how to obtain the least significant bit of @xmath47 .",
    "we start with a simple quantum routine that produces certain one - qubit states .",
    "first , we create the uniform superposition over all elements of @xmath4 .",
    "namely , we create the state @xmath59 where @xmath23 ranges over @xmath60 and @xmath61 ranges over @xmath62 . here and in the following we omit the normalizing factor",
    "we now add some qubits and call the oracle .",
    "the resulting state is @xmath63 after measuring the last register , the state collapses to @xmath64 for some arbitrary @xmath61 .",
    "we perform a standard ( abelian ) fourier transform on the second register and obtain @xmath65 finally , we measure @xmath66 and obtain the one - qubit state @xmath67 notice that @xmath66 is distributed uniformly on @xmath68 and is known to us .    the above routine can be seen as the ` machine ' in the classical scenario described above .",
    "namely , an object with label @xmath69 is simply the one - qubit state @xmath70 . combining two objects",
    "is done as follows .",
    "given @xmath71 and @xmath72 we tensor them together and obtain @xmath73 we now measure the parity of the two qubits . with probability 50% , we measure ` odd ' and the state collapses to @xmath74 by omitting the global phase and renaming the basis states , this is equivalent to @xmath75 as required .",
    "hence , we can apply the algorithm described above and obtain , after @xmath25 operations , the state @xmath76 measuring this state in the hadamard basis yields the least significant bit of @xmath47 .",
    "in this section we present our new algorithm .",
    "as can be seen from the above description , each routine has to store @xmath77 objects ( i.e. , qubits ) before a collision is found .",
    "hence , the space requirement is @xmath25 .",
    "the space requirement of the algorithm we present in this section is only polynomial .",
    "the running time is only slightly larger , namely , @xmath78",
    ".    for simplicity , assume that @xmath79 where @xmath80 and @xmath81 are both integer ( we could also take @xmath82 as before but this would lead to a slightly worse running time ) . our algorithm is based on a different combination operation .",
    "this operation takes as input @xmath83 labelled objects whose labels are uniformly distributed and with constant probability outputs one object that has its @xmath84 least significant bits zeroed out .",
    "this operation is performed as follows .",
    "assume our input is @xmath85 we tensor together all these qubits and obtain @xmath86 where @xmath87 denotes @xmath88 and @xmath89 denotes @xmath90 .",
    "since we know @xmath91 we can compute @xmath92 in an extra register and obtain @xmath93 we now measure the second register and obtain some value @xmath94 .",
    "we then compute ( classically ) the number @xmath95 of bit strings @xmath96 for which @xmath97 .",
    "this is done in a brute - force way and hence takes time @xmath98 .",
    "if @xmath95 is less than two or more than , say , 32 , then we say that the combination operation failed .",
    "otherwise , the state that we have is @xmath99 where @xmath100 are the bit strings that we found .",
    "we would like to remain with exactly two terms in the above sum .",
    "so we perform a projective measurement on the subspace spanned by @xmath101 and @xmath102 ( we can do this since we know the @xmath103 s ) . with constant probability",
    "we have the state @xmath104 by omitting the global phase and renaming , we obtain the one - qubit state @xmath105 this is exactly the object whose label is @xmath106 . since @xmath107 , the @xmath84",
    "least significant bits of this label are all zero .",
    "it remains to show why the event that @xmath108 happens with constant probability over the choice of @xmath87 .",
    "fix some @xmath109 . for each @xmath110",
    "we define an indicator random variable @xmath111 that is @xmath28 if @xmath97 and @xmath48 otherwise ( for convenience we ignore the all zero string since @xmath112 is always zero ) . each random variable has expected value @xmath113 and variance @xmath114 .",
    "these random variables are pairwise independent .",
    "let @xmath115 over all @xmath110 .",
    "its expected value is @xmath116 .",
    "its variance is @xmath117 . by chebyshev",
    "s inequality we obtain that @xmath118 with some constant probability .",
    "hence , the expected fraction of @xmath119 s that have this number of @xmath120 s mapped to them is constant .",
    "hence , the above procedure is successful with constant probability .",
    "we note that a similar combination operation can be performed on other @xmath84-bit blocks .",
    "for example , given @xmath83 objects whose labels have their @xmath84 least significant bits all zero and the next @xmath84 bits ( from location @xmath121 to @xmath122 ) are uniformly distributed , we can extract with constant probability one object such that its label has its @xmath122 least significant bits zero .    using this combination operation",
    ", we can now describe our new algorithm . as before",
    ", the algorithm operates as a pipeline of @xmath18 routines .",
    "the output of routine @xmath27 consists of objects whose labels have their @xmath123 least significant bits zeroed out . unlike the previous algorithm , there is no need for a pile .",
    "each routine simply waits until it receives @xmath83 objects from the previous routine and then it uses the combination operation to obtain one object with @xmath84 additional bits zeroed out .",
    "recall that with constant probability the combination operation is successful . by using the chernoff bound",
    ", one can show that if we input @xmath124 objects to the pipeline then with very high probability , the last routine outputs at least one object .",
    "each combination operation takes @xmath125 time and hence the total running time is also @xmath78 .",
    "i would like to thank gbor ivanyos , julia kempe , and miklos santha for useful discussions .",
    "m.  grigni , l.  j. schulman , m.  vazirani , and u.  v. vazirani .",
    "quantum mechanical algorithms for the nonabelian hidden subgroup problem . in _ proc .",
    "33rd acm symp . on theory of computing _ , pages 6874 , 2001 ."
  ],
  "abstract_text": [
    "<S> in a recent paper , kuperberg described the first subexponential time algorithm for solving the dihedral hidden subgroup problem . </S>",
    "<S> the space requirement of his algorithm is super - polynomial . </S>",
    "<S> we describe a modified algorithm whose running time is still subexponential and whose space requirement is only polynomial . </S>"
  ]
}