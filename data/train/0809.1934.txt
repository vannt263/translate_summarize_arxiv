{
  "article_text": [
    "in its most basic form , the scenario we consider can be described as follows .",
    "on one side we have a provider , bob , who controls an ordered classical database composed of @xmath0 memory cells .",
    "each cell of the data - base contains an @xmath1 bit string , so that the database consists of @xmath2 strings @xmath3 . on the other side",
    ", we have the person querying the database , alice , who wants to recover the string associated with a memory cell ( say the @xmath4-th one ) but at the same time does not want bob to know which cell she is interested in ( _ user privacy _ ) . in a purely classical setting the simplest strategy for alice consists in placing a large number of decoy queries , i.e. she `` hides '' her query among a large number @xmath5 of randomly selected queries . in this case",
    ", she will be able to get the information she is looking for , while limiting bob s intrusion in her privacy . [ in fact , the mutual information between alice s true query @xmath4 and bob s estimate of such value is upper bounded by @xmath6 .",
    "the drawbacks associated with such procedures are evident .",
    "first of all , the method does not allow alice to check whether bob is retaining information on her queries .",
    "moreover , to achieve a high level of privacy alice is forced to submit large amounts of fake queries , increasing the communication cost of the transition : in particular , absolute privacy is obtained only for @xmath7 , i.e. by asking bob to send _ all _ his database .",
    "this may not be acceptable if the database is huge or if it is an asset for bob ( _ data privacy _ ) .",
    "user and data privacy are apparently in conflict : the most straightforward way to obtain user privacy is for alice to have bob send her the entire database , leading to no data privacy whatsoever .",
    "conversely , techniques for guaranteeing the server s data privacy typically leave the user vulnerable  @xcite . at the information theoretical level , this problem has been formalized as the symmetrically - private information retrieval ( spir )  @xcite generalizing the private information retrieval ( pir ) problem  @xcite which deals with user privacy alone .",
    "spir is closely related to oblivious transfer  @xcite , in which bob sends to alice @xmath2 bits , out of which alice can access exactly one  which one , bob does nt know .",
    "no efficient solutions in terms of communication complexity  @xcite are known for spir . indeed , even rephrasing them at a quantum level  @xcite , the best known solution for the spir problem ( with a single database server ) employs @xmath8 qubits to be exchanged between the server and the user , and ensures data privacy only in the case of _ honest users _ ( i.e. users who do not want to compromise their chances of getting the information about the selected item in order to get more ) .",
    "better performance is obtained for the case of multiple non - mutually communicating servers  @xcite ( although the user can not have any guarantee that the servers are not secretly cooperating to violate her privacy ) , while sub - linear communication complexity is possible under the some computational complexity assumption , e.g.  @xcite .",
    "pir admits protocols that are more efficient in terms of communication complexity  @xcite .    the quantum private queries ( qpq ) protocol we have introduced in ref .",
    "@xcite is a cheat sensitive strategy  @xcite which addresses both user and data privacy while allowing an exponential reduction in the communication and computational complexity with respect to the best ( quantum or classical ) single - server spir protocol proposed so far .",
    "specifically qpq provides a method to check whether or not bob is cheating and does not need the exchange of the whole database ( i.e. @xmath8 qubits ) : in its simplest form it only requires bob to transfer two database elements , identified by @xmath9 qubits , for each query . the qpq protocol is ideally composed by a preliminary signaling stage where the user and the database provider exchange some quantum messages ( specifically alice addresses bob receiving some feedback from him ) and by a subsequent _ retrieval&check _ stage where alice performs some simple quantum information processing on the received messages to recover the information she is interested in and to check bob s honesty .",
    "the qpq security relies on the fact that if bob tries to infer the query alice is looking for , she has a nonzero probability of discovering it .",
    "most importantly , one can verify that the more information bob gets on alice query , the higher is the probability that he will not pass alice s honesty test . in this paper",
    "we will derive analytical bounds for such a theoretical trade - off , and we analyze different variants of the qpq protocol .    the main idea behind the protocol is the following .",
    "alice submits her request to bob using some quantum information carrier , so that she can either submit a plain query @xmath10 or a quantum superposition of different queries @xmath11 .",
    "alice randomly alternates superposed queries and non - superposed queries .",
    "thus , bob does not know whether the request he is receiving at any given time is a superposition of queries or not , so that he does not know which measurement will leave the information carrier unperturbed : he can not extract information without risking to introduce a disturbance that alice can detect .",
    "bob can , however , respond to alice s request without knowing which kind of query was submitted",
    ". his response will be either of the form @xmath12 or of the form @xmath13 , where the first ket is the register that alice had sent him , the second ket is a register that contains bob s answer ( @xmath14 being the answer to the @xmath15th query ) , and which may be entangled with the first . from these answers alice",
    "can both obtain the reply to her query and check that bob has not tried to breach her privacy .",
    "the main assumption we adopt is that , for each @xmath4 , there exists a _ unique _",
    "answer string @xmath16 that can be independently checked by alice .",
    "[ this does not prevent different queries from having the same answer : indeed we do admit the possibility to have @xmath17 for @xmath18 . ] for example , alice may be asking bob the prime factors of one out of @xmath2 very large integer numbers ( say the rsa collection ) which she can not factorize by herself",
    ". the above requirements can be relaxed ( examples will be provided in sec .",
    "[ sec : soluzione ] ) , but they are useful as they permit a considerable simplification of the security proof . for the same reason , we will focus on the simplest version of the qpq protocol , where there exists a reference query @xmath19 ( dubbed _ rhetoric _ query ) which has a known standard answer @xmath20 . as discussed in ref .",
    "@xcite , this assumption is not fundamental , but it is very useful since it allows us to minimize the amount of exchanged signals in the protocol ( as a matter of fact alternative versions of the qpq protocol with higher security level can be devised which do not employ the rhetoric query ) .    the paper is organized as follows . in sec .",
    "[ sec : notations ] we describe the rhetoric version of qpq in its basic form and introduce the notation .",
    "this is followed by the technical sec .",
    "[ sec : bob ] where we analyze in detail the most general transformations bob can perform on alice s queries .",
    "section  [ sec : security ] contains the main result of the paper : here we introduce the trade - off between bob s information on alice s query and the success probability of him passing her honesty test . in sec .  [",
    "sec : ent ] we present some variations of the qpq protocol , one of which exploits entanglement as a resource to strengthen alice s privacy . finally in sec .",
    "[ sec : what ] we analyze what happens when relaxing some of the assumptions adopted in the security proof .",
    "in particular we show that the basic version of the qpq described here does not guarantee privacy if the queries have multiple answers , and we point out a possible solution in sec .  [",
    "sec : soluzione ] .",
    "th record of bob s database ( composed of @xmath0 records ) .",
    "she then prepares two @xmath21-qubit registers .",
    "the first contains the state @xmath22 , while the second contains the quantum superposition @xmath23 between her query and the rhetoric question `` @xmath19 '' , to which she knows the standard answer @xmath20 .",
    "she then sends , in random order ( i.e.  randomly choosing either scenario * a * or scenario * b * ) , these two registers to bob , waiting for his first reply before sending the next register .",
    "bob uses each of the two registers to interrogate his database using a qram device , which records the reply to her queries in the two `` reply '' registers @xmath24 . at the end of their exchange",
    ", alice possesses the states @xmath25 and @xmath26 , where the @xmath16 is the content of the @xmath4th record in the database . by measuring the first she obtains the value of @xmath16 , with which she can check whether the superposition in the second state was preserved .",
    "if this is not the case , then she can be confident bob that bob has violated her privacy , and has tried to obtain information on what @xmath4 was . ]    in the rhetoric version of the qpq protocol ( see fig .",
    "[ f : proto ] ) alice uses two quantum registers each time she needs to interrogate bob s database .",
    "the first register contains @xmath10 , the address of the database memory cell she is interested in ; the other register is prepared in a quantum superposition of the type @xmath27 , `` @xmath19 '' being the rhetoric query .",
    "alice then _ secretly _ and _ randomly _ chooses one of the two registers and sends it to bob .",
    "he returns the register alice has sent to him , together with an extra register in which the corresponding answer is encoded . in order to reply to alice s query without knowing whether it is the superposed query or not , bob needs to employ the quantum random access memory ( qram ) algorithm  @xcite .",
    "after alice has received bob s first reply , she sends her second register and waits for bob s second reply .",
    "again bob returns her register together with an extra register which encodes his reply obtained through a qram application .",
    "if bob has followed the protocol accurately , without trying to extract information , alice now should possess a state which encodes the information she is looking for and an entangled state involving the rhetoric query , whose coherence can be tested to check bob honesty , i.e. the two states @xmath12 and @xmath28 .",
    "alice recovers the value of @xmath16 by measuring the second register in the first state , and then she uses this value to prepare a measurement to test whether the superposition has been retained in the second state ( `` honesty test '' ) .",
    "such a measurement is simply a projective measurement on the state @xmath28 .",
    "if this test fails , namely if she finds out that the state bob has sent her back is orthogonal to the one she is expecting , she can be confident that bob has cheated and has violated her privacy . if , instead , the test passes , she can not conclude anything .",
    "in fact , suppose that bob has measured the state and collapsed it to the form @xmath12 or to the form @xmath29 , it still has a probability 1/2 to pass alice s test of it being of the form @xmath28 .",
    "so alice s cheat test allows her to be confident that bob has cheated if the test fails , but she can never be completely confident that bob has not cheated if the test passes .",
    "we now introduce the notation which will be used .",
    "we define @xmath30 the source space which contains the addresses @xmath4 of the memory cells which compose bob s database , identifying with @xmath31 the address of the rhetoric query . for each @xmath4",
    "we define @xmath16 to be the information associated with the @xmath4-th address .",
    "as mentioned in the introduction the @xmath16 are _ classical messages _ composed of @xmath1 bits , and they need not represent distinct messages ( i.e. we allow the possibility that @xmath32 for @xmath33 ) , but they are uniquely determined by the value of @xmath4 . in this context ,",
    "bob s database is defined as the ordered set @xmath34 formed by the strings @xmath16 .",
    "we define @xmath35 the two quantum registers alice uses to submit her queries ; according to the protocol , she will first send @xmath36 , wait for bob s answer and then send @xmath37 . in this notation , for @xmath38 , the vector @xmath39 is the state of the @xmath40-th register which carries the address of the @xmath4-th database memory . for all @xmath41",
    "we use the vector @xmath42 to represent the superposition of the @xmath4-th query and the rhetoric query , i.e. @xmath43 ( for @xmath31 we have @xmath44 ) .",
    "we define @xmath45 the registers on which bob writes the information to send back to alice . after having received @xmath36 from alice",
    ", bob encodes the necessary information on @xmath46 and sends back to her both @xmath36 and @xmath46 .",
    "analogously , after having received @xmath47 , he will encode information on @xmath48 and send her back both @xmath47 and @xmath48 .",
    "it is useful to also define the vectors @xmath49 ( as in eq .",
    "( [ defq1 ] ) for @xmath31 we set @xmath50 ) .",
    "according to the protocol , the vectors @xmath51 or @xmath52 are the states that an honest bob should send back to alice when she is preparing @xmath53 into the states @xmath39 or @xmath42 , respectively .",
    "in fact , the states @xmath51 and @xmath52 are the result of the qram transformation when it is fed @xmath39 and @xmath42 , respectively .",
    "we also introduce an ancillary system @xmath54 to represent any auxiliary systems that bob may employ when performing his local transformation on the alice queries , plus ( possibly ) an external environment .",
    "let us use this notation to better formalize the qpq protocol described above .",
    "suppose then that alice wants to address the @xmath4-th entry of the database .",
    "the protocol goes as follows :",
    "alice randomly chooses between the two alternative scenarios * a * and * b * ( see fig .  [",
    "f : proto ] ) . in the scenario * a * , she prepares the qubits @xmath36 in @xmath55 and the qubits @xmath37 in @xmath56 . instead , in the scenario",
    "* b * she prepares the states @xmath57 and @xmath58 .",
    "this means that , in the scenario * a * , she first sends the plain query and then the superposed query . on the contrary , in the scenario * b * , she first sends the superposed query and then the plain query .",
    "consequently , the input state of the system @xmath59 is described by the vectors @xmath60 where the index @xmath61 refers to the selected scenario and @xmath62 is the fiducial initial state of the systems @xmath63 and @xmath54 ( it is independent on @xmath61 because bob does not know which scenario alice has chosen ) .",
    "2 .   now alice sends @xmath36 and waits until bob gives her back @xmath36 and @xmath46 .",
    "then , she sends @xmath37 and waits until she gets back @xmath37 and @xmath48 .",
    "3 .   _ honesty test _ : alice checks the states she has received . if she had selected scenario * a * , she performs a von neumann measurement to see if @xmath64 is in the state @xmath65 see eq .",
    "( [ check ] ) . of course",
    ", this can be done in two steps : first she measures @xmath66 to learn @xmath16 and then she uses this value to prepare an appropriate measurement on @xmath67 .",
    "if the measurement fails , then alice can definitely conclude that bob was cheating , otherwise she can assume he was honest ( although she has no guarantee of it ) .",
    "if she had chosen scenario * b * , she proceeds analogously , using a von neumann measurement to check if @xmath64 is in the state @xmath68 .",
    "in the qpq protocol , alice s privacy relies essentially on the fact that bob is not allowed to operate jointly on @xmath36 and @xmath37 .",
    "this a fundamental constraint : without it , bob would be able to discover the index @xmath4 without alice knowing it .",
    "in fact , the subspaces @xmath69 spanned by the two vectors @xmath70 and @xmath71 ( associated to the two different scenarios * a * and * b * for the query @xmath4 ) are mutually orthogonal . thus , such vectors ( and then the corresponding queries ) could be easily distinguished by performing on @xmath72 a simple von neumann measurement defined by the projectors associated with the spaces @xmath73 .",
    "this is a measurement that would allow bob to recover alice s query without disturbing the input states of @xmath72 . to prevent this cheating strategy , the qpq protocol forces bob to address @xmath36 and @xmath37 separately ( i.e.  he has to send the register @xmath36 back , before alice provides him the register @xmath37 ) .    bob s action",
    "when he receives alice s first register can be described by a unitary operator @xmath74 which acts on the first register @xmath36 , on @xmath63 , and on @xmath54 ( and not on the second register @xmath37 which is still in alice s possession ) .",
    "analogously , bob s action when he receives the second register is described by the unitary operator @xmath75 which acts on @xmath37 , @xmath48 , and @xmath54 ( and not on @xmath36 and @xmath46 which are now in alice s possession ) . [ note that the above framework describes also the situation in which bob is employing non - unitary transformations ( i.e. cp - maps ) , since the space @xmath54 can be thought to contain also the naimark extension that transforms any cp - map into a unitary . ]",
    "the above transformations can not depend on the selected scenario @xmath61 ( as bob does not know which one , among @xmath76*a * and @xmath76*b * , has been selected by alice ) .",
    "therefore , within the @xmath61th scenario , the global state at the end of the protocol is described by the vectors @xmath77 with @xmath78 given in eq .",
    "( [ equation1 ] ) .",
    "consider the transformation @xmath79 . in the scenario * a * for all @xmath4 we can write @xmath80 where @xmath81 stands for the separable state @xmath82 and where @xmath83 is a vector orthogonal to @xmath84 , i.e. @xmath85 with this choice , @xmath86 is the probability that the state  ( [ eecc ] ) will be found in @xmath87 . in the scenario",
    "* b * , instead , for @xmath41 we can write @xmath88 as before @xmath89 and @xmath90 is a vector orthogonal to the `` check state '' @xmath91 alice is expecting , i.e. @xmath92 consequently @xmath93 is the probability that the state  ( [ eecc1 ] ) will pass the test of being in @xmath94 .",
    "the state on the first line of eq .",
    "( [ eecc1 ] ) can be expanded on a basis of which the state on the first line of eq .",
    "( [ eecc ] ) is a component .",
    "therefore @xmath93 and @xmath86 must be related . the security analysis given in the following sections",
    "is based on the study of this relation .",
    "1    analogous decompositions can be given for @xmath95 : in this case , however , it is useful to describe them not in terms of the input states , but in terms of the state of the system _ after it has passed the test on the subsystems @xmath66_. for @xmath41 , in the scenario * a * this gives : @xmath96 here @xmath97 is a vector orthogonal to @xmath98 of eq .",
    "( [ check ] ) i.e. @xmath99 thus @xmath100 is the probability that the state  ( [ eecc ] ) will pass the test of being in @xmath101 .",
    "notice that the vector @xmath102 in the first line of eq .",
    "( [ eecc ] ) is the state of @xmath103 one obtains in the scenario * a * if , after the first round , the state @xmath66 passes the test of being @xmath104  see eq .",
    "( [ eecc ] ) . in the scenario",
    "* b * , instead , we have @xmath105 where @xmath106 is a vector orthogonal to the state @xmath107 , i.e. @xmath108 and @xmath109 is the probability that the state  ( [ eecc1 ] ) will be found in @xmath107 . 1    the case @xmath31 has to be treated separately : indeed , if alice sends this query then both @xmath36 and @xmath37 will be prepared into @xmath110 . in this case , it is then useful to define @xmath95 by considering its action on the vector @xmath111 defined as in eq .",
    "( [ eecc ] ) , i.e. @xmath112 where again one has @xmath113    1from the above equations , it follows that for @xmath41 the final state ( [ finale ] ) , after bob has finished his manipulations , can be written as follows for scenario * a * @xmath114 where all the terms in the second and third line are orthogonal to @xmath115 .",
    "analogously , we have for scenario * b * @xmath116 where , again , the states in the last two lines are orthogonal to the state in the first . instead , for @xmath31 we have @xmath117",
    "in this section we present an information - disturbance analysis of the qpq protocol .",
    "this will yield a trade - off which shows that , if bob tries to get some information on alice s queries , then she has a nonzero probability of detecting that he is cheating .",
    "the same analysis can be easily reproduced for more complicated versions of the protocol .",
    "for instance alice may hide her queries into superpositions of randomly selected queries . in this case , the derivation , although more involved , is a straightforward generalization of the one presented here .    according to eq .",
    "( [ finale ] ) , to measure bob s information gain , it is sufficient to study how the final state of the ancillary subsystem @xmath54 depends upon alice s query @xmath4 . exploiting the decompositions introduced in sec .",
    "[ sec : bob ] we can then show that one can force @xmath54 to keep no track of alice s query by bounding the success probabilities that bob will pass the qpq honesty test . specifically , indicating with @xmath118 the success probability associated with alice s query @xmath4 in the @xmath61-th scenario and defining @xmath119 the corresponding output state of @xmath54 , in sec .",
    "[ sec : ancilla ] we will prove the following theorem    * theorem : * _ choose @xmath120 $ ] so that @xmath121 for all @xmath4 and @xmath61 . then there exists a state @xmath122 of @xmath54 and a positive constant @xmath123 such that the fidelities  @xcite @xmath124 are bounded as follows , latexmath:[\\ ] ] where the system @xmath276 is an ancillary system that alice does not hand over to bob .",
    "the protocol now follows the same procedure as the `` canonical '' qpq described previously , but employing the state @xmath277 in place of the state @xmath158 .",
    "of course , alice s honesty test must be appropriately modified , as she has to test whether bob s actions have destroyed the entanglement between the ancillary system @xmath276 and the @xmath278 register .",
    "the main difference with the canonical qpq is that here half of the times bob has only access to a part of an entangled state : he is even more limited in re - preparing the states for alice than in the canonical qpq .",
    "it is easy to see that the security proof given in the previous sections can be straightforwardly extended to this version of the protocol , and that the security bounds derived above still apply : indeed they can be made even more stringent as bob has only a limited capacity in his transformations on alice s queries , since he does not have access to the ancillary space @xmath276 . in the situations in which the information carriers employed in the queries can be put in a superposition of traveling in different directions  @xcite , this version of the protocol",
    "can easily be reduced to the canonical qpq by simply supposing that alice is in the possession of the database element @xmath31 corresponding to the rhetoric question , while , obviously , bob is in possession of all the remaining database elements .",
    "in deriving the qpq protocol it is assumed that for each query @xmath279 there is a _ unique _ possible answer @xmath16 ( notice however that two distinct queries can have the same answer  i.e. @xmath16 can coincides with @xmath280 ) .",
    "one way to enforce this condition in a realistic scenario is to admit the possibility that alice can independently verify the answer that bob is sending to her is difficult to compute for alice , but once a solution is given to her , she can easily check if it is correct . ] . in this section",
    "we will show that if this is not the case then the basic structure of qpq does not prevent bob to cheat without being discovered by alice . in sec .",
    "[ sec : soluzione ] we will discuss how one can overcome these limitations , at least temporarily , by allowing alice ( or third parties that collaborate with her ) to reiterate her query at random times .      here",
    "we drop the above hypothesis and give two examples of successful cheating strategies that allow bob to spy on alice s query , and still pass the honesty test with probability @xmath236 .",
    "let us start by considering the case of a database with @xmath281 possible entries in which both the query @xmath282 and the query @xmath283 admit two distinguishable answers . in particular let @xmath284 , @xmath285 be the answers for @xmath282 and @xmath286 , @xmath287 those for @xmath283 .",
    "now , suppose that the unitary @xmath288 of eq .",
    "( [ finale ] ) that bob applies to @xmath289 performs the following mapping @xmath290 where @xmath291 is the answer to the rhetoric query and where @xmath292 with @xmath293 and @xmath294 being orthonormal states of bob s space @xmath54 .",
    "analogously define @xmath295 as the unitary operator which performs the following transformation @xmath296 of @xmath54 and @xmath297 according to the above assumptions , if alice s query is the rhetoric one ( i.e @xmath31 ) the final state  ( [ finale ] ) of the qpq protocol is @xmath298 as output state . for @xmath299 , instead",
    ", we have two possibilities . in the scenario @xmath76*a * the final state will be latexmath:[\\[\\begin{aligned } & \\tfrac {         & + \\tfrac{|j\\rangle_{q_2 } | a_j^{(- ) } \\rangle_{r_2 } + |0\\rangle_{q_2 }     while in the scenario @xmath76*b * it will be @xmath301 alice will receive the answer @xmath302 half of the times and the answer @xmath303 in the other half of the times , while bob will always pass the honesty test .",
    "moreover in the case in which alice receives the answer @xmath302 , bob will get the state @xmath304 while in the case in which alice receives the answer @xmath303 bob will get the state @xmath305 . in average",
    "the state @xmath54 is @xmath306 .    in conclusion , using @xmath79 and @xmath95 as in the previous paragraphs , bob will always pass the honesty test .",
    "furthermore the output state of @xmath54 he gets at the end of the protocol will be partially correlated with the query @xmath4 as follows : @xmath307 therefore by performing a simple von neumann measurement on @xmath54 , bob will be able to extract some information on @xmath4 , without alice having any chance of detecting it .",
    "notice that , in the example presented here , bob s info is limited by the partial overlap between the states @xmath308 , @xmath309 and @xmath310 . however",
    ", this is not a fundamental limitation as one can construct more complex examples ( e.g. databases with more than two possible answers for a single query ) for which the amount of info that bob acquires on @xmath4 can be arbitrarily high .",
    "it is also important to stress that the above example can be used also to show that bob will be able to cheat also in the case in which alice adopts qpq strategies more sophisticated then the simple rhetoric version discussed in this paper ( e.g. instead of sending superpositions of the form @xmath311 with @xmath271 and @xmath272 arbitrary amplitudes that only she knows ) .      here we analyze how multiple valid answers may affect the performance of the non - rhetoric version of the qpq protocol ( i.e. where alice is not using the rhetoric question @xmath31 ) .",
    "we give an example of a successful cheating strategy for a database with @xmath281 queries .",
    "for the sake of simplicity , we will assume that @xmath312 have single answers @xmath20 and @xmath313 respectively , but that @xmath283 is associated with two distinguishable answers @xmath314 .",
    "as an example of a non - rhetoric qpq protocol we consider the case in which alice , to get the information associated with the @xmath4 query , chooses another query ( say the @xmath315-th one ) and sends sequentially , in random order , states of the form @xmath316 , @xmath10 and @xmath317 ( @xmath271 and @xmath272 being amplitudes that only she knows ) .",
    "as in the case of the rhetoric version of the protocol , bob s action can be described by unitaries . in this case",
    "they are @xmath79,@xmath95 and @xmath318 .",
    "notice that the first acts on @xmath289 the second on @xmath319 and the third on @xmath320 , with obvious choice of the notation for the subspaces involved . for our present purpose ,",
    "it is sufficient to assume that for @xmath321 , @xmath322 acts non - trivially only on @xmath323 ( this is a particular instance of the general case ) .",
    "we can also assume that @xmath79,@xmath95 and @xmath318 are identical .",
    "we then define such operators according to the following rules : latexmath:[\\[\\begin{aligned } u^{(k)}_{q_kr_kb } ( |j\\rangle_{q_k } |0\\rangle_{r_k}|0\\rangle_b ) & = &    u^{(k)}_{q_kr_kb } ( |j\\rangle_{q_k } |0\\rangle_{r_k}|2\\rangle_b ) & = &    if @xmath312 while , for @xmath283 , @xmath325 are defined in eq .",
    "( [ defff ] ) .",
    "if initial state of the @xmath54 is @xmath326 , one can easily verify that bob will always pass alice s honesty test ( no matter which superposition @xmath327 she is using ) and that he can recover part of the information associated with the query . in this simple example , for instance , he has a not null probability to identify the query @xmath283 .",
    "as before , this counterexample can be easily generalized and improved .",
    "the case in which different answers may correspond to the same query is , of course , quite relevant , so that it is natural to ask if the qpq protocol can be modified to apply also to this situation . in this section",
    "we give some methods that allow alice to foil the cheating strategies described in the previous section temporarily , for as long as bob is expecting further queries .    in the case",
    "in which alice can independently check how many different replies correspond to the each query ( and which are they ) , then there is a simple solution that prevents bob from cheating : we must require bob to provide all possible replies in a pre - established order ( e.g.  alphabetically ) when he is presented the @xmath4th query . in this way , each query has again a unique _ composite _ answer ( composed by the ordered succession of all the possible answers ) , so that we are reduced to the canonical qpq protocol , and bob is prevented from cheating .",
    "if , however , alice can not independently establish the number of different replies to each query , then a different strategy is necessary .",
    "[ note that the security proofs given in sects .",
    "[ sec : bob ] and  [ sec : security ] cease to apply to this version of the protocol , although conceivably they may be extended to cover also this situation . ]",
    "first of all , we must require that each of the possible replies to the @xmath4th query is uniquely indexed by bob .",
    "this means that there should be a unique answer to the question `` what is the @xmath40th possible reply to the @xmath4th query ? '' of course , this by itself is insufficient to guarantee that bob can not employ the cheating strategies of the previous section , as alice can not independently check the uniqueness of bob s indexing ( since she does not know all the possible answers to the @xmath4th query ) .",
    "however , she can check whether bob will always answer in the same way to repeated queries . from eqs .",
    "( [ llll ] ) and ( [ llla ] ) , it follows that , as soon as bob measures his system @xmath54 , he might gain information on the value of @xmath4 , but at the same time he loses information on which ( among all the possible answers to the @xmath4th query ) he had presented to alice .",
    "if he wants to be sure that he keeps on providing always the same answer to repeated queries on alice s part , he must preserve his system @xmath54 without trying to extract information from it .",
    "he can measure the system @xmath54 only when he is confident that alice will not be asking him the same query anymore . in a multi - party scenario",
    ", we can also think of a situation where multiple cooperating parties ask bob the same queries and compare the replies they receive from him .",
    "if they find that his answers when he is asked the @xmath40th reply to the @xmath4th query to do not match , then they can conclude that he has been cheating : he has not assigned a unique index to all the possible replies to the @xmath4th query , and he has taken advantage of the cheating strategies detailed in the previous section .",
    "bob is thus placed in the awkward situation of possessing information on alice s query in the system @xmath54 entirely in his possession , but of being prevented from accessing such information .",
    "this is a temporary solution , since , as soon as bob is certain that he will not be asked the @xmath4th query anymore , he can measure the system @xmath54 and extract the information stored on it .",
    "he is kept honest only as long as he is in business ( and , of course , he is in business only as long as he is honest ) .",
    "in conclusion , we have given a security proof of the qpq protocol introduced in  @xcite .",
    "it is based on quantitative information - disturbance tradeoffs which place an upper bound on the information bob can retain on alice s query in terms of the disturbance he is producing on the states that he is handing back to her ( see sects .  [",
    "sec : bob ] and  [ sec : security ] ) .",
    "a nonzero information retained by bob implies a nonzero disturbance on alice s states , which she can detect with a simple measurement ( the `` honesty test '' ) .",
    "if the honesty test fails , she can conclude that bob has certainly cheated . if , on the other hand , the test passes , she can tentatively conclude that bob has not cheated ( although she can not be certain of it ) .",
    "in addition , we have given some variants of the protocol to further increase alice s security , i.e.  to reduce bob s probability of evading detection when cheating .",
    "these variants either exploit secret parameters , or exploit entanglement with an ancillary system alice retains in her possession ( see sect .  [ sec : ent ] ) .",
    "finally , we have seen that bob can successfully cheat without being detected if we drop the assumption ( which is at the basis of the qpq protocol ) that to each query there can be associated only a single answer @xmath16 ( see sect .  [",
    "sec : what ] ) .",
    "in fact , if we assume that there exist two ( or more ) different replies @xmath328 to the query @xmath4 , then bob can find out the value of @xmath4 , evading detection by alice with certainty .",
    "we discussed some strategies that allow alice to protect herself also in this situation , at least as long as bob can expect further queries from her or from other parties who may cooperate with her ( see sect .",
    "[ sec : soluzione ] ) .",
    "we acknowledge discussions with e. kushilevitz , s. micali , f. sciarrino , and m.  sudan .",
    "v.  g.  acknowledges support from the quantum information research program of centro di ricerca ennio de giorgi of sns .",
    "s.  l.  acknowledges fruitful discussions with s.  brin and l.  page .",
    "100 y. gertner , y. ishai , e. kushilevitz , and t. malkin , journal of computer systems sciences , * 60 * 592 ( 2000 ) .",
    "b. chor , o. goldreich , e. kushilevitz , and m. sudan , journal of the acm , * 45 * , 965 ( 1998 ) ; c. cachin , s. micali , and m. stadler , in advances in cryptology - eurocrypt99 ( 1999 ) ; c. gentry and z. ramzan , in proc .",
    "32nd icalp , 803 - 815 , ( 2005 ) ; s. yekhanin , technical report eccc tr06 - 127 ( 2006 ) .",
    "e.  kushilevitz and r.  ostrovsky in proc .",
    "38th ieee symposium focs97 , 364 ( 1997 ) .",
    "s. wiesner , acm sigact news , * 15*(1 ) , 78 - 88 , winter - spring ( 1983 ) ; m. o. rabin , ` how to exchange secrets with oblivious transfer , ' technical report tr-81 , harvard aiken computational laboratory ( 1981 ) ; a. jakoby , m. liskiewicz , a. madry , arxiv : quant - ph/0605150v1 .",
    "a. ambainis , in _ proceedings of the 24ht icalp _ ,",
    "_ lecture notes in computer science _ , * 1256 * 401 ( 1997 ) .",
    "i. kerenidis and r. de wolf , arxiv : quant - ph/0208062 ; i. kerenidis and r. de wolf , arxiv : quant - ph/0307076 . v. giovannetti , s. lloyd , and l. maccone , phys .",
    "* 100 * , 230502 ( 2008 ) , eprint arxiv:0708.2992 .",
    "l. hardy , a. kent , phys . rev",
    ". lett . * 92 * , 157901 ( 2004 ) .",
    "m. a. nielsen and i. l. chuang , _ quantum computation and quantum information _",
    "( cambridge university press , cambridge , 2000 ) . v. giovannetti , s. lloyd , and l. maccone , _ phys .",
    "_ vol . * 100 * , pag 160501 ( 2008 ) .",
    "d. bures , _ trans . am .",
    "* 135 * , 199 ( 1969 ) ; a. uhlmann , _ rep . math . phys . _ * 9 * , 273 ( 1979 ) .",
    "t. cover and j. thomas , _ elements of information theory _ , ( john wiley & sons , new york , 1991 ) . v. giovannetti and a. s. holevo , _ quantum information processing _ * 7 * , 55 ( 2008 ) .",
    "a. s. holevo _ probabilistic and statistical aspects of quantum theory _ ( north holland , amsterdam , 1982 )",
    ". r. f. streater , _ statistical dynamics _ ( imperial college press , england , 1995 ) .",
    "v. giovannetti , s. lloyd , l. maccone , f. sciarrino , _ experimental quantum private queries _ , unpublished ( 2008 ) ."
  ],
  "abstract_text": [
    "<S> we present a security analysis of the recently introduced quantum private query ( qpq ) protocol . </S>",
    "<S> it is a cheat sensitive quantum protocol to perform a private search on a classical database . </S>",
    "<S> it allows a user to retrieve an item from the database without revealing which item was retrieved , and at the same time it ensures data privacy of the database ( the information that the user can retrieve in a query is bounded and does not depend on the size of the database ) . </S>",
    "<S> the security analysis is based on information - disturbance tradeoffs which show that whenever the provider tries to obtain information on the query , the query ( encoded into a quantum system ) is disturbed so that the person querying the database can detect the privacy violation . </S>"
  ]
}