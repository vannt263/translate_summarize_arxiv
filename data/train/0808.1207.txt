{
  "article_text": [
    "peer - to - peer networks are typically divided into _ unstructured _ and _ structured _ networks , depending on how the overlay is constructed and how content is placed in the network . in an unstructured network ,",
    "nodes are free to choose their overlay neighbors and are free to offer any content they want .",
    "in contrast , in a structured network , the structuring mechanism ( typically one or more hash functions ) uniquely determine the location of a peer in the overlay and its neighbors , as well as the placement of content on peers .",
    "both these kinds of networks have their strengths and weaknesses .",
    "unstructured networks are based on _ searching _ for content , which allows us to use complex queries for determining which objects match which requests .",
    "however , this comes at the expense of having to flood the search query through the network which causes significant amount of network traffic .",
    "the original gnutella network was a completely flat overlay which relied on locating objects by flooding the network up to a given time - to - live ( ttl ) .",
    "newer unstructured networks , like kazaa and edonkey , build a two - tier hierarchy with ordinary peers and superpeers .",
    "ordinary peers connect to one superpeer and the superpeers build a gnutella - like overlay between them .",
    "although such a hierarchical network scales better than the plain gnutella network , we still can not guarantee that an object can be found and the amount of network traffic caused by flooding between the superpeers can still be high .",
    "a structured network , on the other hand , clearly defines the overlay structure and object placement through hash functions .",
    "the main advantage is that it allows for very efficient key - value lookups , similar to traditional hash tables .",
    "however , because the content is placed with hash functions , real search queries are not feasible in dhts .",
    "for example , it is not feasible to query a dht for all objects whose name begins with `` foo '' .",
    "this would usually require asking _ every peer _ whether it has any matching objects .",
    "we tackle the problem of implementing a prefix search on a structured p2p network .",
    "our algorithm selects a subset of the overlay network , and creates a spanning tree for that subset rooted at any of the peers in that set .",
    "typical applications which benefit from prefix search are all systems which need to deal with structured data .",
    "structured data is very commonly used in many applications .",
    "for example storing data based on geographical location ( e.g. , tourist information ) or any kind of classification systems lend themselves readily to our algorithm .",
    "the more attributes are available in the user provided search term ( i.e. , the more precise the user s query ) , the less nodes will be queried . in the case of a user performing a very precise search",
    ", the query will reduce itself to a standard dht key lookup . because we create a spanning tree , our solution is not limited to implementing prefix search ; other applications , such as multicast and broadcast ,",
    "can also be implemented with our algorithm .",
    "multicast ( and also broadcast ) is extremely useful in cases where the dht is built according to some specific criteria ( as opposed to a standard hash function ; see section  [ sec : hashing ] ) , since it gives us the possibility of reaching a given set of nodes with minimal overhead .",
    "the key feature of our algorithm is that it creates a spanning tree _ without any communication between the peers _ , using only local information available to every participating peer .",
    "because it is a tree , we are guaranteed that only the minimum number of messages needs to be sent . these key features set our algorithm apart from previous work , such as the application - level multicast proposed by ratnasamy et al .",
    "@xcite or splitstream  @xcite .",
    "previous work typically either has a high number of duplicate messages , requires additional coordination traffic or needs a second overlay network",
    ". additionally range and origin of the spanning tree can freely be set to any value and any peer .",
    "our distributed tree construction algorithm ( dtc ) presented in section  [ sec : flooding_algorithm ] has none of the shortcomings of the previous algorithms . it can be used on top of most existing dhts and it works using information available at each peer about the peer s neighbors . as we show in section  [ sec : flooding_algorithm ] , this standard information maintained by the dht is sufficient for spanning a tree .",
    "as our evaluation shows , our dtc algorithm yields optimal performance in terms of messages sent .",
    "we also show that the overhead of duplicate messages in existing solutions is at least 30% but can in several cases be up to 250% .",
    "this paper is organized as follows . in section  [ sec : flooding_algorithm ] , we present how we construct the distributed spanning tree and prove its properties .",
    "section  [ sec : hashing ] shows an example of how to build a prefix search using hash functions and our tree construction algorithm .",
    "section  [ sec : evaluation ] evaluates our algorithm on different dhts and compares its performance against existing algorithms . in section  [ sec : robustness - security ]",
    ", we discuss the robustness of our algorithm and present mechanisms for improving its resilience against malicious peers .",
    "section  [ sec : related - work ] discusses related work .",
    "finally , section  [ sec : conclusion ] concludes the paper .",
    "in unstructured networks , more than 70% of the messages are redundant , even with a moderate ttl  @xcite . this high overhead is one of the main reasons for the poor scalability of unstructured networks . with our _ distributed tree construction _",
    "algorithm ( dtc ) , we are able to eliminate this overhead .",
    "note that dtc builds on top of a standard , structured overlay network .",
    "we first discuss the requirements on the structured overlay , and then present the dtc algorithm with optimality proofs .",
    "finally , in section  [ sec : sample - applications ] we discuss different applications and how to build them using dtc .",
    "the idea behind dtc is to build a spanning tree to connect all the nodes we want to search .",
    "when a query is sent from the root , every node in the tree receives it exactly once .",
    "the challenge lies in constructing the tree without any overhead and using only local information available in each node .",
    "our dtc algorithm works on any structured overlay ( a.k.a .",
    "distributed hash table ) which fulfills the property that every node knows _ all _ of its immediate neighbors in the overlay hash space .",
    "networks like chord  @xcite , can  @xcite and voronet  @xcite obviously fulfill this property . in case of chord",
    ", the critical information is knowing the successor and for can , knowing all neighbors in all coordinate directions . in case of pastry  @xcite",
    "the condition is fulfilled since the leaf sets of all nodes always contain the closest neighbors in the hash space .",
    "although tapestry  @xcite is very similar to pastry , it does not have the equivalent of the leaf set and thus might not be suitable without modifications .",
    "kademlia  @xcite also fulfills the required condition , since the buckets for the shorter distances contain the closest nodes in the hash space and they should be complete .    in the remainder of this paper , we consider only chord and can as overlay networks .",
    "although the principle of dtc in both networks is the same , differences in the overlay structures lead to performance differences ( see section  [ sec : evaluation ] ) .      in the distributed tree construction algorithm",
    ", we start spanning the tree from a point in the overlay and expand from that point through the overlay according to the overlay routing .",
    "the area of the overlay which the spanning tree is supposed to cover is explicitly defined .",
    "the information about the root of the tree and the area are sufficient to construct the spanning tree in a purely distributed manner .",
    "we will now show how this can be done in chord and can .",
    "note that even though the algorithm constructs a spanning tree , no peer has a complete view of the tree .",
    "the tree is always constructed on - demand by having the root send a message which constructs the tree as it gets passed through the peers .",
    "thus , when we say below that a peer adds some other peers to the tree as its children , it means in practice that the peer in question forwards a message to the other peers .",
    "* example : chord *    in case of chord , the area is an arc on the chord ring and the root of the tree is the first node on the arc .",
    "the simplest solution is simply to add nodes to the tree along the chain of successors until the end of the arc has been reached .",
    "however , this is not very efficient for large areas .",
    "instead , we should use the fingers to create shortcuts and broaden the spanning tree .",
    "the root of the tree selects all of its fingers that are in the area as its children .",
    "each of them will recursively perform the same operation until all peers in the area ( the arc ) have been included in the tree .",
    "any of the peers can easily determine which of its fingers it should include , since it knows the root and the length of the arc .",
    "the successor of the last point of the arc _ is _ part of the tree , since the last points in the arc might contain objects which are stored on their successor .    * example : can *    in case of can , the area is a convex area of the @xmath0-dimensional coordinate space , with the root somewhere in this area . the restriction to convex search areas is imposed by our algorithm .",
    "non - convex areas can be searched by splitting the search into non - overlapping convex searches which cover the desired area .",
    "the root first adds its immediate neighbors ( @xmath1 neighbors in a @xmath0-dimensional can ) , which then continue adding their neighbors , according to the rules defined below . as in the chord - case above , the information about the root of the tree and the area it is supposed to cover are available to the peers .",
    "the area can be defined either with simply the radius of the area , or by specifying for each dimension separately how far the area reaches in that dimension . as mentioned",
    ", the only restriction on the search area is that it must be convex .",
    "we assume every node knows the following :    * size of the zone of each neighbor ( maintained by standard can routines ) * root of the tree and the area it is supposed to cover ( available in the message which is used to create the tree )        -5 mm    figure  [ fig : flooding ] shows in an example a spanning tree of a two dimensional can .",
    "the tree is rooted at the white zone marked @xmath2 at coordinates ( 5 ,  5 ) .",
    "the other white zones are the children of the root , and the levels of the tree are shown in increasingly darker shades of gray .",
    "the result is a spanning tree consisting of all nodes within the can overlay .",
    "the tree is constructed as follows .",
    "when a peer @xmath3 receives the query , it computes for every one of its neighbors the vector from the center of the root s zone to the center of the neighbor s zone .",
    "if that vector intersects the common border surface between @xmath3 and the neighbor , then @xmath3 should add that neighbor as its child .",
    "the vector has to intersect the common border surface between the two nodes ; it is not sufficient for the vector to pass through @xmath3 s zone .",
    "consider the third zone from the left on the bottom row in figure  [ fig : flooding ] , marked @xmath4 .",
    "this zone has one light gray neighbor @xmath5 on the top and one medium gray @xmath6 neighbor to the right .",
    "the vector from the root passes through both of these neighbors , but the one on the right ( marked @xmath6 ) is the parent of node @xmath4 .",
    "it is important to note that every node is able to compute the vectors and determine whether it should add any of its neighbors as children ( and thus forward the message ) by using only information available locally through normal overlay communications .",
    "no coordination between nodes is needed , nor is any additional traffic generated .",
    "we prove the following properties of our dtc algorithm :    1 .",
    "the dtc algorithm creates a spanning tree over the area 2 .",
    "the depth of the tree is proportional to message complexity of the underlying dht    for the simple version of a chord - based dtc ( i.e. , every node passes the query to its successor ) , the first property is obvious .",
    "the proof of the first property with fingers is also straight - forward and is omitted for space reasons .    in the following",
    ", we will prove the properties for a can - based dtc .",
    "we make the simplifying assumption that the overlay network is able to heal itself under churn without loss of messages .",
    "note that this assumption explicitly _ allows _ churn as long as changes to the overlay structure are performed in a locally atomic manner and no node departs between receiving and forwarding a query .",
    "we also assume that the area over which the tree is to be spanned is convex .",
    "[ thm : at - least - once ] all nodes are added to the tree at least once .    for every zone @xmath7 in the convex area , there is a single vector which connects the center points of that zone with the zone of the root of the tree .",
    "starting from zone @xmath7 , the vector determines @xmath8 , a neighbor of @xmath7 who will add @xmath7 as its child .",
    "considering zone @xmath8 , we can draw the vector between the center of @xmath8 and the starting zone , which determines a zone @xmath3 , neighbor of @xmath8 which adds @xmath8 as a child .",
    "continuing in a similar manner , we arrive at the zone of the root of the tree .",
    "thus , we are able to find a chain of zones which leads us from the root zone to zone @xmath7 .",
    "thus , all nodes have at least one path from the root , i.e. , are part of the tree .    in some cases , it is possible that the vector between the root and a zone @xmath7 does not pass through any direct can neighbor of @xmath7 .",
    "for example , in figure  [ fig : flooding ] , the vector between the root and the zone marked @xmath9 passes directly through the corner point of the two zones . depending on how the ownership of edges is defined , it is possible that there is no neighbor through whose zone the vector passes on its way from root to @xmath9 .",
    "( note that regardless of how the ownership of edges is defined , it is always possible to construct the zones such that this problem persists . ) in general , this issue arises when two zones share up to @xmath10 dimensions in a @xmath0-dimensional can ( e.g. , a point in 2-dimensional can and a point or a line in a 3-dimensional can ) . in this case",
    ", the forwarding algorithm does not reach all nodes .",
    "we have defined the following tie breaker for these cases .",
    "* the tie breaker : * we use the following rule for determining how to construct the tree in the above case .",
    "the two problematic zones differ in at least 2 and up to @xmath0 dimensions .",
    "we order the dimensions beforehand .",
    "the forwarding path should be such that the smallest dimensions with differences are used first .",
    "the length of the tie breaker path will be the same as the number of dimensions in which the two problem zones differ ( i.e. , between 2 and @xmath0 ) .",
    "note that none of the nodes on the path would normally forward the query , but _ all of them _ are able to compute locally that they are part of the tie breaker procedure and are able to perform their duties correctly . in the example of figure  [ fig : flooding ] , the tie breaker would mean that @xmath11 is the node responsible for adding @xmath9 as its child , since x - coordinate is considered before y - coordinate .",
    "[ thm : at - most - once ] all nodes are added to the tree at most once .",
    "we prove this by contradiction . if a node @xmath5 were to be added to the tree twice",
    ", this would imply that two of its neighbors would think that the vector between @xmath5 and the root passes through their zones .",
    "this is clearly impossible , since the responsibility is defined by the vector and the vector between @xmath5 s center point and the center of the root s zone intersects only one of the borders between @xmath5 and its neighbors .",
    "thus , @xmath5 can be added to the tree by at most one of its neighbors .",
    "-5 mm    theorems  [ thm : at - least - once ] and  [ thm : at - most - once ] prove that every node in the area is added to the tree exactly once , thus the dtc algorithm creates a spanning tree rooted at the root zone and covering all the nodes in the area .",
    "note that the spanning tree is only _ a _ spanning tree ; it might not be the minimal spanning tree ( but this property is not a requirement of the applications we are considering ) .",
    "figure  [ fig : example - dtc - constr ] shows a larger example of how the dtc algorithm constructs the spanning tree . in figure  [ fig : flood - onlyarrows-64 ] , we show the spanning tree overlaid on the underlying can topology and show which peers add which other peers as their children .",
    "figure  [ fig : flood - ant-64 ] shows only the resulting spanning tree .",
    "depth of the spanning tree is proportional to message complexity of the underlying dht .",
    "we prove this for both chord- and can - based dtc . in case of a chord - based dtc",
    ", we can construct the spanning tree using fingers , as mentioned above .",
    "the links in the chord - dtc spanning tree are determined by the fingers and successor pointers of the nodes .",
    "the claim of the theorem refers to the depth of the spanning tree .",
    "note that every path in the spanning tree is a legal dht - routing path between the root and the chosen node .    in a chord - based system with fingers ,",
    "the spanning tree is simply a mapping from the fingers and successor pointers to the nodes , and every path in the tree exactly corresponds to the routing path that the standard chord routing would take to reach that node .",
    "hence , the depth of the tree is @xmath12 .    in a can - based system ,",
    "every hop is also a legal can routing hop , however , not necessarily a hop that the standard greedy can routing would take in a given situation .",
    "the dtc algorithm always follows the vectors , but the greedy can routing might take shortcuts over large zones . nevertheless , the length of the path in the spanning tree is still @xmath13{n})$ ] .",
    "the ability to construct a spanning tree from any point in the dht is very powerful , and allows us to develop many different kinds of applications .",
    "we now discuss some of the applications which can be built with dtc .",
    "* prefix search in dhts *    as mentioned in the introduction , searching in dhts is extremely inefficient . with dtc and the hashing scheme from section  [ sec : hashing ] ,",
    "we are able to implement a prefix search over a freely selectable prefix with only the minimum number of messages needed .",
    "we achieve this through a slight modification of how content is mapped on the nodes ( see below ) and by spanning a tree over a pre - determined area .",
    "as discussed in the introduction , many applications can benefit from prefix searches .",
    "in particular , applications which use any kind of structured data lend themselves readily to prefix searches .",
    "structured data is very common and easily maps to hierarchical concepts which are used in many different applications .",
    "* group communication primitives *    if the root sends a message along the tree ( as is done during the tree construction ) , then every node in the area will receive the message exactly once . by tuning the area which the tree spans",
    ", we can easily define different multicast groups and reach them with the minimum number of messages .",
    "( as the comparison in section  [ sec : evaluation ] shows , the application - level multicast on can  @xcite has significant overhead compared to our dtc - based approach . )",
    "it is even possible to let the area be the complete hash space of the dht , in which case we have an optimal broadcast mechanism .    an important point to keep in mind when designing applications running with dtc",
    "is whether there will be feedback to the root of the tree or not . in other words",
    ", a search requires an answer , i.e. , all the nodes in the tree with matching content should answer .",
    "in contrast , a multicast or a broadcast might not require any acknowledgement from the receivers . the presence or absence of feedback is thus application - dependent , and we will return to this issue in section  [ sec : robustness - security ] .",
    "we now present a way of mapping objects to peers in a dht , such that the dtc algorithm allows us to perform prefix searches on the dht .",
    "we achieve this by placing all objects matching a prefix in a certain area of the dht and the prefix search corresponds simply to spanning a tree with the dtc algorithm over this area . as an example of how to implement a prefix search , we consider the case of a @xmath0-dimensional can .",
    "( note that other dhts mentioned as candidates in section  [ sec : structured - overlay ] are 1-dimensional , thus they are simply special cases of the example . )      the standard hashing algorithm of the dht needs to be replaced by a function which maps equal names to equal places .",
    "we use a region quad tree  @xcite to preserve the lexical order of all keys .",
    "the result is one is able to spot in advance the area where a set of keys with the same prefix is located .",
    "one example of such a mapping is shown in figure  [ fig : quad ] .",
    "the hash space is divided into 4 quadrants , according to the first character of the object name ( in the example , object names can only contain capital letters a  z and numbers 09 ; the approach easily generalizes to any character set ) .",
    "each of the quadrants is further divided into four quadrants according to the same mapping , and so on . as a result ,",
    "any object whose name starts with the prefix `` jos '' , would be mapped to the shaded area near the top right corner of the area .",
    "combined with the dtc algorithm , this mapping enables an efficient prefix search in a dht .",
    "we simply pick any node at random from the area of the desired prefix and span a tree over the area covered by the prefix .",
    "we can also adjust the granularity of the mapping in order to control how many peers are present in the areas for prefixes of different lengths .",
    "we call this the _ split factor _ and it works as follows .",
    "as example , consider the mapping shown in figure  [ fig : quad ] .",
    "the whole hash space is divided into 4 quadrants and each quadrant is assigned a set of letters . when objects are stored , we look at the first character of the object name and select the quadrant which matches . then we split that quadrant again into 4 according to the same rules and map the second character of the object name . because the space gets split once per each character , we call this split factor 1 .    table  [ tab : quad - tree - f1 ] shows how many nodes need to be searched for a given prefix .",
    "( note that we consider prefixes as characters of object names , since this would be how users would use a prefix search . )",
    "the numbers have been calculated for a can of 1 million nodes and uniform distribution of peers . as we can see , already relatively short prefixes of 45 characters map to a relatively small number of peers , on the order of a few thousands .",
    "already with a prefix of 10 characters , we would typically end up with only 1 peer being responsible .",
    ".split factor 1 and 1 million nodes [ cols=\"<,^,^,^ \" , ]     -5 mm    as expected , the two dtc - based solutions do not generate any duplicate messages .",
    "alm performs relatively well , generating about 50% too many messages .",
    "we return to the evaluation of the overhead of alm below . as table  [",
    "tab : hopcountsformulticastincan ] shows , simple flooding has an extremely high overhead in terms of messages sent .",
    "the factor-13 overhead shown is typical of the performance of simple flooding .",
    "the performance of the dtc - based algorithms was as expected in all investigated parameter combinations ( e.g. , network size , dimensions ) .",
    "both of them were able to perform their task always with the _ minimum _ number of messages , i.e. , as many messages as nodes .",
    "we also evaluated the depth of the spanning tree , since this directly affects the time it takes to complete the operation ( e.g. , search or broadcast ) .",
    "we compared different network sizes from 200 to 20000 nodes and different dimensions in can ( ranging from 2 to 20 ) .",
    "figure  [ fig : query - depth ] shows 5- and 10-dimensional cans with 20000 nodes . in figure",
    "[ fig : averagehops-10dim ] we also plot dtc - chord .",
    "the x - axis shows the number of hops and the y - axis shows how many nodes were reached with that many hops ( i.e. , how many nodes are at that depth in the spanning tree ) .",
    "as we can see , simple flooding has the smallest depth .",
    "it always takes the shortest path to each node , since it forwards a message to all neighbors but to the sender",
    ". therefore all nodes are reached with the minimum number of hops .",
    "dtc - can and alm have performance which is slightly lower than simple flooding and are very close to each other . in the case of the 5-dimensional network and 20000 nodes",
    "the optimum would be about 7 hops , while alm needs 9 and dtc - can 8 hops in the average .",
    "the greater the number of dimensions used for the can network , the smaller is the difference between the approaches .",
    "differences in the 10-dimensional can network ( see figure [ fig : averagehops-10dim ] ) with 20000 nodes are almost non - existent ; both alm and dtc - can need about 7 - 8 hops on an average , while the optimal case would be about 6 hops .",
    "dtc - chord ( shown only in figure  [ fig : averagehops-10dim ] ) has performance similar to dtc - can and alm in the 10-dimensional case .",
    "dtc - chord is independent of the number of dimensions , so it would be in the same place in figure  [ fig : averagehops-5dim ] .",
    "the finger tables of chord reduce the number of needed hops effectively .",
    "while the can network is able to be further optimized by using more dimensions , the optimum number of hops for chord is proportional to the density of the finger tables .",
    "we investigated the performance with dimensions ranging up to 20 , but we did not observe any significant improvement in performance of dtc - can or alm after 10 dimensions .",
    "we now turn to evaluating the overhead of alm , which was already shown in table  [ tab : hopcountsformulticastincan ] .",
    "we compare alm against dtc - can .",
    "figures  [ fig:500 - 20000-messages - dim5 - 20 ] and  [ fig:500 - 20000-messages - dim5 - 15-r ] show how the overhead evolves as function of network size .",
    "the x - axis shows the number of simulated nodes ; we started from 200 nodes and simulated up to 20000 nodes .",
    "the y - axis shows the average number of generated messages .",
    "we show several variants of alm , each with different number of dimensions .",
    "note that dtc - can was always able to perform optimally , i.e. , as many messages as there were nodes .",
    "figure  [ fig:500 - 20000-messages - dim5 - 20 ] shows the absolute overhead , i.e. , how many unnecessary messages alm sent and figure  [ fig:500 - 20000-messages - dim5 - 15-r ] shows the relative overhead compared to dtc - can .",
    "as the network size grows , the relative overhead of alm in figure  [ fig:500 - 20000-messages - dim5 - 15-r ] tends to about 32% .",
    "however , figure  [ fig:500 - 20000-messages - dim5 - 20 ] shows the interesting behavior of alm . for every number of dimensions , the curve has several sharp corners where the overhead changes considerably",
    "the reason for this is as follows .",
    "the message overhead is heavily influenced by the absolute number of dimensions and nodes .",
    "the more dimensions , the more nodes are needed to populate the @xmath0-dimensional i d space uniformly .",
    "as soon as @xmath14{n}\\ge 2 $ ] , the overhead starts to converge to the estimated 32% ( see figure  [ fig:500 - 20000-messages - dim5 - 15-r ] ) . below the critical threshold ,",
    "the number of duplicate messages steadily increases with more nodes .",
    "this explains the high peaks for the smaller networks in figures  [ fig:500 - 20000-messages - dim5 - 20 ] and as figure  [ fig:500 - 20000-messages - dim5 - 15-r ] shows , the resulting overhead can be up to 250% .    in summary ,",
    "the dtc - based approaches have the advantage of generating only the minimum amount of traffic , while keeping the depth of the spanning tree similar to alm .",
    "alm , on the other hand , has a message overhead of at least 32% , in many cases up to 250% .",
    "the simple flooding approach turns out to be unusable since the enormous message overhead would cause unacceptable congestions within the overlay",
    ". however , simple flooding has the fastest response time of all compared approaches .",
    "because the dtc algorithm ( and other similar approaches like  @xcite ) builds a tree , it is especially vulnerable to defective peers , where a defective peer could either be the result of a crash or it could be a malicious peer . if a peer does not forward the message , then all its children and their children will not be included in the spanning tree .    because all dhts have mechanisms in place to detect crashed peers and recover from those crashes , we do not consider such system failures to be a problem . the only case a message could be lost is if a peer crashes between receiving a message and forwarding it , which is extremely rare . in all other cases , we assume that the standard dht maintenance takes precedence over the tree spanning messages and that in such cases , the overlay will first be healed and thus no message loss or duplication can occur .    in the following ,",
    "we consider the case of a malicious peer not forwarding the message correctly onwards .",
    "the case of a malicious peer modifying the message can easily be detected by picking a random public / private keypair , signing the original message , and including the public key in the query .",
    "we first evaluated the severity of this problem by selecting a randomly generated 20000-peer network and spanning a tree with the dtc algorithm over the whole network .",
    "the can networks in this test had 10 dimensions .",
    "we varied the fraction of malicious peers and selected the malicious peers uniformly at random from all the peers .",
    "for each case , we measured the number of peers who were not part of the tree .",
    "each parameter combination was repeated 30 times and the results we present are averaged over all the runs .",
    "figure  [ fig : malpeers ] shows the fraction of unreached peers as a function of malicious peers for 3 systems from section  [ sec : evaluation ] ( dtc - can , dtc - chord , and alm ) .",
    "already 10% of malicious peers are able to cut off on an average 20% of the peers from the spanning tree .",
    "because the dtc algorithm eliminates all duplicate messages , it is particularly vulnerable to malicious peers , but the alm does not fare much better . only when the fraction of malicious peers is between 10% and 50% does alm have any marked improvement over dtc - based systems . although not shown on figure  [ fig : malpeers ] , the simple flooding approach is extremely resistant against malicious peers .",
    "peers become unreached only when the fraction of malicious peers is very high ( typically over 7080% ) .",
    "there is an interesting point to note about the effects of the underlying dht on the performance of dtc - algorithms . for the case of 1% malicious peers ,",
    "chord - based dtc performed much worse than a can - based dtc . in case of dtc - chord , 8.6% of the peers",
    "were not reached , whereas in a dtc - can , only 4.2% of the nodes were unreached . for comparison , in alm 3.7% of the nodes",
    "were unreached for that fraction of malicious peers . for other fractions of malicious peers ,",
    "the difference between chord- and can - based dtcs was in practice negligible , although usually the chord - based system had the higher number of unreached peers .",
    "the explanation for this is that in a 10-dimensional can , even if a malicious node is near the root in the spanning tree , it can not do much damage .",
    "in contrast , if the longest finger of the root in chord is malicious , it is able to cut half of the spanning tree . thus , a chord - based dtc is slightly more vulnerable to malicious peers than a can - based dtc .",
    "we now propose solutions for remedying the problems caused by malicious peers .",
    "the fundamental problem is that a single malicious peer can eliminate the complete sub - tree rooted at that peer from the spanning tree .",
    "our primary goal is thus _ detecting _ the presence of malicious peers , with as little overhead as possible .",
    "the mechanisms below are not always able to pinpoint the malicious peer ; they only aim at discovering malicious behavior in the tree .",
    "the effectiveness of dtc greatly depends on the kind of application using dtc .",
    "if we are searching for objects stored in the dht ( as in section  [ sec : hashing ] ) , then the problem simplifies greatly .",
    "this is because all peers should return a response to the root of the tree indicating whether they have any objects which match the search . by requiring _",
    "all _ peers to send a response , the root can easily check the responses to see whether the complete area has been searched .",
    "any malicious peer would easily be found out with such responses .    in the interest of scalability",
    ", the responses should be propagated back along the tree .",
    "furthermore , each peer should sign its response with a key that is tied to its zone of responsibility in the dht and its ip address .",
    "these signatures increase the likelihood of discovering malicious peers , because the malicious peer would have to invent the zones of responsibility and ip addresses for all the peers in its subtree .",
    "these might overlap with legitimate zones from other parts of the tree , thus indicating the presence of a malicious peer .",
    "furthermore , the root could also verify some of the leafs of the tree ( using additional communications ) that the responses were actually sent by them .",
    "although this would reduce the effects of malicious peers , in the absence of a centralized identity management scheme , it can not completely eliminate them .",
    "another solution is to split the root of the spanning tree and instead of a single tree , generate several spanning trees , each covering a small area of the total tree and in such a manner that the union of the smaller trees covers the whole area .",
    "this is easy to perform , since the dtc algorithm allows us to define the area freely .",
    "the advantage is that each individual search area becomes relatively small and allows for an easier detection of malicious peers .",
    "as discussed in section  [ sec : hashing ] , a prefix length of 4 digits results in a search area of about 4000 peers . by splitting the query into 10 queries ,",
    "each query needs to cover about 400 peers .",
    "requiring a response in such small trees does not present a significant overhead and thus malicious peers would be easier to detect .",
    "note that the response traffic is required by the application and is thus independent of the way the spanning tree is created ( dtc , alm , flooding , etc . ) .",
    "the above solutions work well in the case where the tree is spanned for a purpose where a response is required , e.g. , a search . in the case of a pure one - way tree , such as broadcast ,",
    "no natural feedback channel exists .",
    "acknowledgements , similar to the responses in the search application , would work as described above , but in this case they would generate additional traffic in the network .",
    "however , without such an acknowledgement mechanism , it is not possible to detect malicious peers . thus , we propose to use the same mechanism for any kind of application .",
    "the second solution , the creation of several , non - overlapping spanning trees , is likely to be more efficient at detecting malicious peers , but a full evaluation of the proposed mechanisms is part of our future work .",
    "flooding approaches for p2p networks in general have been extensively investigated  @xcite . while simple flooding approaches may apply to unstructured networks",
    ", dht networks can take advantage of the structured neighbor lists and reduce the number of duplicate messages .    in the case of can , work by ratnasamy et al .",
    "@xcite implemented an application - level multicast on top of can .",
    "as our evaluation shows , this approach can have a significant overhead and even in the best case , will have an overhead of about 32% .",
    "as we have shown , the overhead is a function of the network size and can dimensions and in smaller search areas , the overhead can grow considerably higher . an improved version of alm is described in  @xcite .",
    "they reduce duplicate messages , but duplicates may still occur , especially in the case of uneven zone sizes within the can overlay .",
    "one approach for range queries within dhts  @xcite is to form a tree similar to our quad tree approach .",
    "the difference is that they explicitly use a dht in order to store a generated tree for accessing objects .",
    "our approach , in contrast , does not use the dht interface for generating a tree ; it directly restructures the mapping from object to nodes .",
    "the advantage is that our solution enables prefix searching without any overhead .",
    "another approach for prefix search is presented in  @xcite by joung et al .",
    "the idea is that the prefixes build a sub - hypercube within a hypercube which spans a binomial tree  @xcite . in general a binomial tree",
    "can be traversed without generating duplicate messages . on the downside",
    ", the hypercube needs to have as many dimensions as bits in the i d space . given a common 160  bit i d space ,",
    "this would lead to 160 dimensions , which in turn leads to 160 neighbors per node for a binomial tree .",
    "further overhead is generated , because each of the @xmath15 bits needs to be addressable .",
    "therefore a prohibitevely large number of logical nodes are necessary in smaller networks . in contrast , our dtc algorithm achieves the same optimal number of messages with _ no overhead _ over a standard dht .",
    "a different approach for prefix searching  @xcite uses a combination of different overlay networks , one for file management and for site ( participants ) management .",
    "the combination of a dht based overlay ( e.g. can ) with another independent overlay enables prefix search as well , but at much higher costs .",
    "our solution does not require any additional maintenance costs or additional links ; all required knowledge can be calculated locally . while our work concentrates on raw address coding and message distribution ,",
    "additional performance optimizations applied to routing for keyword search in dht based p2p networks  @xcite can be used with dtc , since they are complementary to our solution .",
    "we do not alter the underlying routing scheme and therefore all optimizations used for the dht apply to dtc as well .    applying multi - attribute range queriers to current dhts",
    "has been done by choosing hubs  @xcite .",
    "the idea of hubs , which are responsible for one attribute each is independent form the underlying dht .",
    "a hub can be seen as a separate overlay for each attribute .",
    "our prefix and multicast approach can also be applied to hubs which would lead to an optimized i d space for each attribute . on the one hand",
    "less nodes would need to be queried , on the other hand a separate overlay network needs to be maintained for each attribute .",
    "in this paper we have presented a distributed tree construction algorithm , which is able to create a spanning tree over a part of a dht , with no inter - node communication and using only information available locally on each node .",
    "we have also presented a mapping based on region quad trees for mapping objects to nodes in a dht in such a manner that the dtc algorithm is able to perform prefix searches on content stored in the dht .",
    "our solution is not limited to searches , but can also handle broadcast and multicast communications .",
    "our evaluation shows that dtc performs as expected and the comparison to similar approaches from literature shows that the message overhead of existing solutions is considerably higher than the optimal number of messages sent by dtc .",
    "the depth of the spanning trees are similar in all studied cases .",
    "we have also discussed the robustness of dtc against malicious peers and presented solutions for strengthening dtc .",
    "our future investigation will concentrate on evaluating more schemes for exploiting the structured geometry of dht overlays for improving security aspects , multicast performance , and expressiveness of search queries .",
    "we will investigate caching mechanisms to overcome the potential hotspots which may occur using a location sensitive object to node mapping .",
    "a.  rowstron and p.  druschel , `` pastry : scalable , distributed object location and routing for large - scale peer - to - peer systems , '' in _",
    "ifip / acm international conference on distributed systems platforms ( middleware ) _ , 2001 ."
  ],
  "abstract_text": [
    "<S> searching in p2p networks is fundamental to all overlay networks . </S>",
    "<S> p2p networks based on distributed hash tables ( dht ) are optimized for single key lookups , whereas unstructured networks offer more complex queries at the cost of increased traffic and uncertain success rates . our distributed tree construction ( dtc ) approach enables structured p2p networks to perform prefix search , range queries , and multicast in an optimal way . </S>",
    "<S> it achieves this by creating a spanning tree over the peers in the search area , using only information available locally on each peer . </S>",
    "<S> because dtc creates a spanning tree , it can query all the peers in the search area with a minimal number of messages . </S>",
    "<S> furthermore , we show that the tree depth has the same upper bound as a regular dht lookup which in turn guarantees fast and responsive runtime behavior . by placing objects with a region quadtree </S>",
    "<S> , we can perform a prefix search or a range query in a freely selectable area of the dht . </S>",
    "<S> our dtc algorithm is dht - agnostic and works with most existing dhts . </S>",
    "<S> we evaluate the performance of dtc over several dhts by comparing the performance to existing application - level multicast solutions , we show that dtc sends 30250% fewer messages than common solutions . </S>"
  ]
}