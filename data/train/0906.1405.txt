{
  "article_text": [
    "networks are useful constructs to schematize the organization of interactions in social and biological systems",
    ". networks are particularly valuable for characterizing _",
    "interdependent _ interactions , where the interaction between components a and b influences the interaction between components b and c , and so on . for most such integrated systems , it is a flow of some entity  passengers traveling among airports , money transferred among banks , gossip exchanged among friends , signals transmitted in the brain  that connects a system s components and generates their interdependence .",
    "network structures constrain these flows .",
    "therefore , understanding the behavior of integrated systems at the macro - level is not possible without comprehending the network structure with respect to the flow , the _",
    "dynamics on _ the network",
    ".    one major drawback of networks is that , for visualization purposes , they can only depict small systems .",
    "real - world networks are often so large that they must be represented by coarse - grained descriptions .",
    "deriving appropriate coarse - grain descriptions is the basic objective of community detection @xcite .",
    "but before we decompose the nodes and links into modules that represent the network , we must first decide what we mean by  appropriate . \"",
    "that is , we must decide which aspects of the system should be highlighted in our coarse - graining .",
    "if we are concerned with the process that _ generated _ the network in the first place , we should use methods based on some underlying stochastic model of network formation . to study the formation process , we can , for example , use modularity @xcite , mixture models at two @xcite or more @xcite levels , bayesian inference @xcite , or our cluster - based compression approach @xcite to resolve community structure in undirected and unweighted networks .",
    "if instead we want to infer system behavior from network structure , we should focus on how the structure of the extant network constrains the dynamics that can occur on that network . to capture",
    "how local interactions induce a system - wide flow that connects the system , we need to simplify and highlight the underlying network structure with respect to how the links drive this flow across the network .",
    "for example , both markov processes on networks and spectral methods can capture this notion @xcite . in this paper , we present a detailed description of the flow - based and information - theoretic method known as the map equation @xcite . for a given network partition ,",
    "the map equation specifies the theoretical limit of how concisely we can describe the trajectory of a random walker on the network . with the random walker as a proxy for real flow , minimizing the map equation over all possible network partitions reveals important aspects of network structure with respect to the dynamics on the network . to illustrate and further explain how the map equation operates",
    ", we compare its action with the topological method modularity maximization @xcite . because the two methods can yield different results for some network structures ,",
    "it is illuminating to understand when and why they differ .",
    "there is a duality between the problem of compressing a data set , and the problem of detecting and extracting significant patterns or structures within those data .",
    "this general duality is explored in the branch of statistics known as mdl , or minimum description length statistics @xcite .",
    "we can apply these principles to the problem at hand : finding the structures within a network that are significant with respect to how information or resources flow through that network .    to exploit the inference - compression duality for dynamics on networks ,",
    "we envision a communication process in which a sender wants to communicate to a receiver about movement on a network .",
    "that is , we represent the data that we are interested in  the trace of the flow on the network  with a compressed message .",
    "this takes us to the heart of information theory , and we can employ shannon s source coding theorems to find the limits on how far we can compress the data @xcite . for some applications , we may have data on the actual trajectories of goods , funds , information , or services as they travel through the network , and we could work with the trajectories directly . more often , however , we will only have a characterization of the network structure along which these objects can move , in which case we can do no better than to approximate likely trajectories as random walks guided by the directed and weighted links of the network .",
    "this is the approach that we take with the map equation .    in order to effectively and concisely describe where on the network a random walker is , an effective encoding of position",
    "will necessarily exploit the regularities in patterns of movement on that network .",
    "if we can find an optimal code for describing places traced by a path on a network , we have also solved the dual problem of finding the important structural features of that network .",
    "therefore , we look for a way to assign codewords to nodes that is efficient with respect to the dynamics on the network .        a straightforward method of assigning codewords to nodes is to use a huffman code @xcite .",
    "huffman codes are optimally efficient for symbol - by - symbol encoding and save space by assigning short codewords to common events or objects , and long codewords to rare ones , just as morse code uses short codes for common letters and longer codes for rare ones .",
    "figure [ fig1](b ) shows a prefix - free huffman coding for a sample network .",
    "it corresponds to a lookup table for coding and decoding nodes on the network , a _ codebook _ that connects nodes with codewords . in this codebook",
    ", each huffman codeword specifies a particular node , and the codeword lengths are derived from the ergodic node visit frequencies of a random walk ( the average node visit frequencies of an infinite - length random walk ) .",
    "because the code is prefix - free , that is , no codeword is a prefix of any other codeword , codewords can be sent concatenated without punctuation and still be unambiguously decoded by the receiver . with the huffman code pictured in fig .",
    "[ fig1](b ) , we are able to describe the nodes traced by the specific 71-step walk in 314 bits . if we instead had chosen a uniform code , in which all codewords are of equal length , each codeword would be @xmath0 bits long ( logarithm taken in base 2 ) , and @xmath1 bits would have been required to describe the walk .    this huffman code is optimal for sending a one - time transmission describing the location of a random walker at one particular instant in time .",
    "moreover , it is optimal for describing a list of locations of the random walker at arbitrary ( and sufficiently distant ) times .",
    "however , if we wish to list the locations visited by our random walker in a sequence of successive steps , we can do better . sequences of successive steps are of critical importance to us ; after all , this is flow .",
    "many real - world networks are structured into a set of regions such that once the random walker enters a region , it tends to stay there for a long time , and movements between regions are relatively rare .",
    "as we design a code to enumerate a succession of locations visited , we can take advantage of this regional structure .",
    "we can take a region with a long persistence time and give it its own separate codebook .",
    "so long as we are content to reuse codewords in other regional codebooks , the codewords used to name the locations in any single region will be shorter than those in the global huffman code example above , because there are fewer locations to be specified .",
    "we call these regions `` modules '' and their codebooks `` module codebooks . ''",
    "however , with multiple module codebooks , each of which re - uses a similar set of codewords , the sender must also specify which module codebook should be used .",
    "that is , every time a path enters a new module , both sender and receiver must simultaneously switch to the correct module codebook or the message will be nonsense .",
    "this is implemented by using one extra codebook , an index codebook , with codewords that specify which of the module codebooks is to be used .",
    "the coding procedure is then as follows .",
    "the index codebook specifies a module codebook , and the module codebook specifies a succession of nodes within that module .",
    "when the random walker leaves the module , we need to return to the index codebook . to indicate this , instead of sending another node name from the module codebook",
    ", we send the `` xit command '' from the module codebook .",
    "the codeword lengths in the index codebook are derived from the relative rates at which a random walker enters each module , while the codeword lengths for each module codebook are derived from the relative rates at which a random walker visits each node in the module or exits the module .",
    "here emerges the duality between coding a data stream and finding regularities in the structure that generates that stream . using multiple codebooks",
    ", we transform the problem of minimizing the description length of places traced by a path into the problem of how we should best partition the network with respect to flow .",
    "how many modules should we use , and which nodes should be assigned to which modules to minimize the map equation ?",
    "figure [ fig1](c ) illustrates a two - level description that capitalizes on structures with long persistence time and encodes the walk in panel ( a ) more efficiently than the one - level description in panel ( b ) . we have implemented a dynamic visualization and made it available for anyone to explore the inference - compression duality and the mechanics of the map equation ( http://www.tp.umu.se/~rosvall/livemod/mapequation/ ) .",
    "figure [ codebooks ] visualizes the use of one or multiple codebooks for the network in fig .",
    "the sparklines show how the description length associated with between - module movements increases with the number of modules and more frequent use of the index codebook .",
    "contrarily , the description length associated with within - module movements decreases with the number of modules and with the use of smaller module codebooks .",
    "the sum of the two , the full description length , takes a minimum at four modules .",
    "we use stacked boxes to illustrate the rates at which a random walker visits nodes and enters and exits modules .",
    "the codewords to the right of the boxes are derived from the within - module relative rates and within - index relative rates , respectively .",
    "both relative rates and codewords change from the one - codebook solution with all nodes in one module , to the optimal solution , with an index codebook and four module codebooks with nodes assigned to four modules ( see online dynamic visualization @xcite ) .",
    "we have described the huffman coding process in detail in order to make it clear how the coding structure works .",
    "but of course the aim of community detection is not to encode a particular path through a network . in community detection , we simply want to find the modular structure of the network with respect to flow and our approach is to exploit the inference - compression duality to do so . in fact , we do not even need to devise an optimal code for a given partition to estimate how efficient that optimal code would be .",
    "this is the whole point of the map equation .",
    "it tells us how efficient the optimal code would be for any given partition , without actually devising that code .",
    "that is , it tells us the theoretical limit of how concisely we can specify a network path using a given partition structure . to find an optimal partition of the network ,",
    "it is sufficient to calculate this theoretical limit for different partitions of the network and pick the one that gives the shortest description length .    for a module partition @xmath2 of @xmath3 nodes @xmath4 into @xmath5 modules @xmath6",
    ", we define this lower bound on code length to be @xmath7 . to calculate @xmath8 for an arbitrary partition ,",
    "we first invoke shannon s source coding theorem @xcite , which implies that when you use @xmath3 codewords to describe the @xmath3 states of a random variable @xmath9 that occur with frequencies @xmath10 , the average length of a codeword can be no less than the entropy of the random variable @xmath9 itself : @xmath11 ( we measure code lengths in bits and take the logarithm in base 2 ) .",
    "this provides us with a lower bound on the average length of codewords for each codebook .",
    "to calculate the average length of the code describing a step of the random walk , we need only to weight the average length of codewords from the index codebook and the module codebooks by their rates of use .",
    "this is the map equation :    @xmath12    here @xmath13 is the frequency - weighted average length of codewords in the index codebook and @xmath14 is frequency - weighted average length of codewords in module codebook @xmath15 .",
    "further , the entropy terms are weighted by the rate at which the codebooks are used . with @xmath16 for the probability to exit module @xmath15 , the index codebook is used at a rate @xmath17 , the probability that the random walker switches modules on any given step . with @xmath18 for the probability to visit node @xmath19 , module codebook @xmath15 is used at a rate @xmath20 , the fraction of time the random walk spends in module @xmath15 plus the probability that it exits the module and the exit message is used .",
    "now it is straightforward to express the entropies in @xmath21 and @xmath22 . for the index codebook ,",
    "the entropy is    @xmath23    and for module codebook",
    "@xmath15 the entropy is @xmath24    by combining eqs .",
    "[ map_master ] and [ map_module ] and simplifying , we can write the map equation as : @xmath25    in this expanded form of the map equation , we note that the term @xmath26 is independent of partitioning , and elsewhere in the expression @xmath22 appears only when summed over all nodes in a module .",
    "consequently , when we optimize the network partition , it is sufficient to keep track of changes in @xmath27 , the rate at which a random walker enters and exits each module , and @xmath28 , the fraction of time a random walker spends in each module .",
    "they can easily be derived for any partition of the network , and updating them is a straightforward and fast operation .",
    "any numerical search algorithm developed to find a network partition that optimizes an objective function can be modified to minimize the map equation .    [ cols= \"",
    "< , < , < , < \" , ]      for undirected networks , the node visit frequency of node @xmath19 simply corresponds to the relative weight @xmath29 of the links connected to the node . the relative weight is the total weight of the links connected to the node divided by twice the total weight of all links in the network , which corresponds to the total weight of all link - ends . with @xmath29 for the relative weight of node @xmath19 , @xmath30 for the relative weight of module @xmath15 , @xmath31 for the relative weight of links exiting module @xmath15 , and @xmath32 for the total relative weight of links between modules ,",
    "the map equation takes the form    @xmath33      for directed weighted networks , we use the power iteration method to calculate the steady state visit frequency for each node . to guarantee a unique steady state distribution for directed networks ,",
    "we introduce a small teleportation probability @xmath34 in the random walk that links every node to every other node with positive probability and thereby converts the random walker into a _",
    "random surfer_. the movement of the random surfer can now be described by an irreducible and aperiodic markov chain that has a unique steady state by the perron - frobineous theorem . as in google s pagerank algorithm @xcite",
    ", we use @xmath35 .",
    "the results are relatively robust to this choice , but as @xmath36 , the stationary frequencies may poorly reflect the important nodes in the network as the random walker can get trapped in small clusters that do not point back into the bulk of the network @xcite .",
    "the surfer moves as follows : at each time step , with probability @xmath37 , the random surfer follows one of the outgoing links from the node @xmath19 that it currently occupies to the neighbor node @xmath38 with probability proportional to the weights of the outgoing links @xmath39 from @xmath19 to @xmath38 .",
    "it is therefore convenient to set @xmath40 . with the remaining probability @xmath34 , or with probability @xmath41 if the node does not have any outlinks , the random surfer `` teleports '' with uniform probability to a random node anywhere in the system .",
    "but rather than averaging over a single long random walk to generate the ergodic node visit frequencies , we apply the power iteration method to the probability distribution of the random surfer over the nodes of the network .",
    "we start with a probability distribution of @xmath42 for the random surfer to be at each node @xmath19 and update the probability distribution iteratively . at each iteration",
    ", we distribute a fraction @xmath37 of the probability flow of the random surfer at each node @xmath19 to the neighbors @xmath38 proportional to the weights of the links @xmath39 and distribute the remaining probability flow uniformly to all nodes in the network .",
    "we iterate until the sum of the absolute differences between successive estimates of @xmath22 is less than @xmath43 and the probability distribution has converged .",
    "given the ergodic node visit frequencies @xmath22 for @xmath44 and an initial partitioning of the network , it is easy to calculate the ergodic module visit frequencies @xmath28 for module @xmath15 . the exit probability for module @xmath15 , with teleportation taken into account , is then @xmath45 where @xmath46 is the number of nodes in module @xmath15 .",
    "this equation follows since every node teleports a fraction @xmath47 and guides a fraction @xmath48 of its weight @xmath22 to nodes outside of its module @xmath15 .    if the nodes represent objects that are inherently different it can be desirable to nonuniformly teleport to nodes in the network .",
    "for example , in journal - to - journal citation networks , journals should receive teleporting random surfers proportional to the number of articles they contain , and , in air traffic networks , airports should receive teleporting random surfers proportional to the number of flights they handle .",
    "this nonuniform teleportation nicely corrects for the disproportionate amount of random surfers that small journals or small airports receive if all nodes are teleported to with equal probability . in practice",
    ", nonuniform teleportation can be achieved by assigning to each node @xmath19 a normalized teleportation weight @xmath49 such that @xmath50 . with teleportation flow distributed nonuniformly , the numeric values of the ergodic node visit probabilities @xmath22 will change slightly and the exit probability for module @xmath15 becomes @xmath51 this equation follows since every node now teleports a fraction @xmath52 of its weight @xmath22 to nodes outside of its module @xmath15 .",
    "conceptually , detecting communities by mapping flow is a very different approach from inferring module assignments for underlying network models .",
    "whereas the former approach focuses on the interdependence of links and the dynamics on the network once it has been formed , the latter one focuses on pairwise interactions and the formation process itself .",
    "because the map equation and modularity take these two disjoint approaches , it is interesting to see how they differ in practice . to highlight one important difference",
    ", we compare how the map equation and the generalized modularity , which makes use of information about the weight and direction of links @xcite , operate on networks with and without flow .    for weighted and directed networks ,",
    "the modularity for a given partitioning of the network into @xmath5 modules is the sum of the total weight of all links in each module minus the expected weight @xmath53 here @xmath54 is the total weight of links starting and ending in module @xmath15 , @xmath55 and @xmath56 the total in- and out - weight of links in module @xmath15 , and @xmath57 the total weight of all links in the network . to estimate the community structure in a network , eq .",
    "[ modularity ] is maximized over all possible assignments of nodes into any number @xmath5 of modules .",
    "figure [ compare ] shows two different networks , each partitioned in two different ways .",
    "both networks are generated from the same underlying network model in the modularity sense : 20 directed links connect 16 nodes in four modules , with equal total in- and out - weight at each module .",
    "the only difference is that we switch the direction of two links in each module . because the weights @xmath57 , @xmath54 , @xmath55 , and @xmath56 are all the same for the four - module partition of the two different networks in fig .",
    "[ compare](a ) and ( c ) , the modularity takes the same value .",
    "that is , from the perspective of modularity , the two different networks and corresponding partitions are identical .",
    "however , from a flow - based perspective , the two networks are completely different .",
    "the directed links shown in the network in panel ( a ) and panel ( b ) induce a structured pattern of flow with long persistence times in , and limited flow between , the four modules highlighted in panel ( a ) .",
    "the map equation picks up on these structural regularities , and thus the description length is shorter for the four - module network partition in panel ( a ) than for the unpartitioned network in panel ( b ) .",
    "by contrast , for the network shown in panels ( c ) and ( d ) , there is no pattern of extended flow at all .",
    "every node is either a source or a sink , and no movement along the links on the network can exceed more than one step in length . as a result , random teleportation will dominate and any partition into multiple modules will lead to a high flow between the modules . for networks with links that do not induce a pattern of flow , the map equation will always be minimized by one single module .",
    "the map equation captures small modules with long persistence times , and modularity captures small modules with more than the expected number of link - ends , incoming or outgoing .",
    "this example , and the example with directed and weighted networks in ref .",
    "@xcite , reveal the effective difference between them . though modularity can be interpreted as a one - step measure of movement on a network @xcite , this example demonstrates that one - step walks can not capture flow .",
    "any greedy ( fast but inaccurate ) or monte carlo - based ( accurate but slow ) approach can be used to minimize the map equation . to provide a good balance between the two extremes ,",
    "we have developed a fast stochastic and recursive search algorithm , implemented it in c++ , and made it available online both for directed and undirected weighted networks @xcite . as a reference ,",
    "the new algorithm is as fast as the previous high - speed algorithms ( the greedy search presented in the supporting appendix of ref .",
    "@xcite ) , which were based on the method introduced in ref .  @xcite and refined in ref .",
    "@xcite . at the same time , it is also more accurate than our previous high - accuracy algorithm ( a simulated annealing approach ) presented in the same supporting appendix .",
    "the core of the algorithm follows closely the method presented in ref .",
    "@xcite : neighboring nodes are joined into modules , which subsequently are joined into supermodules and so on . first , each node is assigned to its own module . then , in random sequential order , each node is moved to the neighboring module that results in the largest decrease of the map equation .",
    "if no move results in a decrease of the map equation , the node stays in its original module .",
    "this procedure is repeated , each time in a new random sequential order , until no move generates a decrease of the map equation .",
    "now the network is rebuilt , with the modules of the last level forming the nodes at this level . and exactly as at the previous level , the nodes are joined into modules .",
    "this hierarchical rebuilding of the network is repeated until the map equation can not be reduced further . except for the random sequence order ,",
    "this is the algorithm described in ref .",
    "@xcite .    with this algorithm",
    ", a fairly good clustering of the network can be found in a very short time .",
    "let us call this the core algorithm and see how it can be improved .",
    "the nodes assigned to the same module are forced to move jointly when the network is rebuilt . as a result ,",
    "what was an optimal move early in the algorithm might have the opposite effect later in the algorithm .",
    "because two or more modules that merge together and form one single module when the network is rebuilt can never be separated again in this algorithm , the accuracy can be improved by breaking the modules of the final state of the core algorithm in either of the two following ways :    * _ submodule movements .",
    "_ first , each cluster is treated as a network on its own and the main algorithm is applied to this network .",
    "this procedure generates one or more submodules for each module .",
    "then all submodules are moved back to their respective modules of the previous step . at this stage , with the same partition as in the previous step but with each submodule being freely movable between the modules , the main algorithm is re - applied . *",
    "_ single - node movements . _",
    "first , each node is re - assigned to be the sole member of its own module , in order to allow for single - node movements .",
    "then all nodes are moved back to their respective modules of the previous step . at this stage , with the same partition as in the previous step but with each single node being freely movable between the modules , the main algorithm is re - applied .    in practice , we repeat the two extensions to the core algorithm in sequence and as long as the clustering is improved .",
    "moreover , we apply the submodule movements recursively .",
    "that is , to find the submodules to be moved , the algorithm first splits the submodules into subsubmodules , subsubsubmodules , and so on until no further splits are possible .",
    "finally , because the algorithm is stochastic and fast , we can restart the algorithm from scratch every time the clustering can not be improved further and the algorithm stops . the implementation is straightforward and , by repeating the search more than once , 100 times or more if possible , the final partition is less likely to correspond to a local minimum . for each iteration ,",
    "we record the clustering if the description length is shorter than the previously shortest description length . in practice , for networks with on the order of 10,000 nodes and 1,000,000 directed and weighted links , each iteration takes about 5 seconds on a modern pc .",
    "in this paper and associated interactive visualization @xcite , we have detailed the mechanics of the map equation for community detection in networks @xcite . our aim has been to differentiate flow - based methods such as spectral methods and the map equation , which focus on system behavior once the network has been formed , from methods based on underlying stochastic models such as mixture models and modularity methods , which focus on the network formation process . by comparing how the map equation and modularity operate on networks with and without flow , we conclude that the two approaches are not only conceptually different , they also highlight different aspects of network structure . depending on the sorts of questions that one is asking ,",
    "one approach may be preferable to the other .",
    "for example , to analyze how networks are formed and to simplify networks for which links do not represent flows but rather pairwise relationships , modularity @xcite or other topological methods @xcite may be preferred .",
    "but if instead one is interested in the dynamics on the network , in how local interactions induce a system - wide flow , in the interdependence across the network , and in how network structure relates to system behavior , then flow - based approaches such as the map equation are preferable ."
  ],
  "abstract_text": [
    "<S> many real - world networks are so large that we must simplify their structure before we can extract useful information about the systems they represent . </S>",
    "<S> as the tools for doing these simplifications proliferate within the network literature , researchers would benefit from some guidelines about which of the so - called community detection algorithms are most appropriate for the structures they are studying and the questions they are asking . here </S>",
    "<S> we show that different methods highlight different aspects of a network s structure and that the the sort of information that we seek to extract about the system must guide us in our decision . for example , many community detection algorithms , including the popular modularity maximization approach , infer module assignments from an underlying model of the network formation process . </S>",
    "<S> however , we are not always as interested in how a system s network structure was formed , as we are in how a network s extant structure influences the system s behavior . to see how structure influences current behavior </S>",
    "<S> , we will recognize that links in a network induce movement across the network and result in system - wide interdependence . </S>",
    "<S> in doing so , we explicitly acknowledge that most networks carry flow . to highlight and simplify the network structure with respect to this flow </S>",
    "<S> , we use the map equation . </S>",
    "<S> we present an intuitive derivation of this flow - based and information - theoretic method and provide an interactive on - line application that anyone can use to explore the mechanics of the map equation . </S>",
    "<S> the differences between the map equation and the modularity maximization approach are not merely conceptual . </S>",
    "<S> because the map equation attends to patterns of flow on the network and the modularity maximization approach does not , the two methods can yield dramatically different results for some network structures . to illustrate this and build our understanding of each method , we partition several sample networks . </S>",
    "<S> we also describe an algorithm and provide source code to efficiently decompose large weighted and directed networks based on the map equation . </S>"
  ]
}