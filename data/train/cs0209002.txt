{
  "article_text": [
    "as the mass of international communication and exchange increases , icons as a mean to cross the language barriers have come through in some specific contexts of use , where language independent symbols are needed ( e.g. on some machine command buttons ) .",
    "the renewed interest in iconic communication has given rise to important works in the field of design @xcite , on reference books on the history and development of the matter @xcite , as well as newer studies in the fields of human - computer interaction and digital media @xcite or semiotics @xcite .",
    "we are here particularly interested in the field of information technology .",
    "icons are now used in nearly all possible areas of human computer interaction , even office software or operating systems . however , there are contexts where richer information has to be managed , for instance : alternative & augmentative communication systems designed for the needs of speech or language impaired people , to help them communicate ( with icon languages like minspeak , bliss , commun - i - mage ) ; second language learning systems where learners have a desire to communicate by themselves , but do not master the structures of the target language yet ; cross - language information retrieval systems , with a visual symbolic input .    in these contexts ,",
    "the use of icons has many advantages : it makes no assumption about the language competences of the users , allowing impaired users , or users from a different linguistic background ( which may not include a good command of one of the major languages involved in research on natural language processing ) , to access the systems ; it may trigger a communication - motivated , implicit learning process , which helps the users to gradually improve their level of literacy in the target language .",
    "however , icons suffer from a lack of expressive power to convey ideas , namely , the expression of _ abstract relations between concepts _ still requires the use of linguistic communication .",
    "an approach to tackle this limitation is to try to `` analyse '' sequences of icons like natural language sentences are parsed , for example .",
    "however , icons do not give grammatical information as clues to automatic parsers .",
    "hence , we have defined a method to interpret sequences of icons by implementing the use of `` natural '' semantic knowledge .",
    "this method allows to build knowledge networks from icons as is usually done from text .",
    "the analysis method that will be presented here is logically equivalent to the parsing of a dependency grammar with no locality constraints .",
    "therefore , the complexity of a fully recursive parsing method grows more than exponentially with the length of the input .",
    "this makes the reaction time of the system too long to be acceptable in normal use .",
    "we have now defined a new parsing algorithm which stores intermediate results in `` charts '' , in the way chart parsers @xcite do for natural language .",
    "assigning a _ signification _ to a sequence of information items implies building conceptual relations between them .",
    "human linguistic competence consists in manipulating these dependency relations : when we say that the cat drinks the milk , for example , we perceive that there are well - defined conceptual connections between ` cat ' , ` drink ' , and ` milk'that ` cat ' and ` milk ' play given roles in a given process .",
    "symbolic formalisms in ai @xcite reflect this approach .",
    "linguistic theories have also been developed specifically to give account of these phenomena @xcite , and to describe the transition between semantics and various levels of syntactic description : from deep syntactic structures which actually reflect the semantics contents , to the surface structure whereby messages are put into natural language .",
    "human natural language reflects these conceptual relations in its messages through a series of linguistic clues .",
    "these clues , depending on the particular languages , can consist mainly in word ordering in sentence patterns ( `` syntactical '' clues , e.g. in english , chinese , or creole ) , in word inflection or suffixation ( `` morphological '' clues , e.g. in russian , turkish ) , or in a given blend of both ( e.g. in german ) .",
    "_ parsers _ are systems designed to analyse natural language input , on the base of such clues , and to yield a representation of its informational contents .    in contexts where icons have to be used to convey complex meanings ,",
    "the problem is that morphological clues are of course not available , when at the same time we can not rely on a precise sentence pattern .",
    "we thus should have to use a parser based on computing the dependencies , such as some which have been written to cope with variable - word - order languages @xcite .",
    "however , since no morphological clue is available either to tell that an icon is , e.g. , accusative or dative , we have to rely on semantic knowledge to guide role assignment . in other words ,",
    "an icon parser has to know that drinking is something generally done by living beings on liquid objects .",
    "the icon parser we propose performs semantic analysis of input sequences of icons by the use of an algorithm based on best - unification : when an icon in the input sequence has a `` predicative '' structure ( it may become the head of at least one dependency relation to another node , labeled `` actor '' ) , the other icons around it are checked for compatibility .",
    "compatibility is measured as a unification score between two sets of feature structures : the intrinsic semantic features of the candidate actor , and the `` extrinsic '' semantic features of the predicative icon attached to a particular semantic role ( i.e. the properties `` expected '' from , say , the agent of _ kiss _ , the direct object of _ drink _ , or the concept qualified by the adjective _ fierce _ ) .",
    "the result yielded by the semantic parser is the graph that maximizes the sum of the compatibilities of all its dependency relations .",
    "it constitutes , with no particular contextual expectations , and given the state of world knowledge stored in the iconic database in the form of semantic features , the `` best '' interpretation of the users input .",
    "the input is a sequence of icons @xmath0 , @xmath1 , ",
    "@xmath2 , each of which has a set of intrinsic features :    @xmath3    ( where @xmath4 is a set of simple attribute - value semantic features , used to represent intrinsic features of the concept  like \\{`<human,+1>`,`<male,+1 > ` } for _ daddy _ ) .",
    "some of the symbols also have selectional features , which , if grouped by case type , form a case structure :    @xmath5    ( where each of the @xmath6 @xmath7 is a case type such as _ agent _ , _ object _ , _ goal _ ... , and each @xmath8 a set of simple attribute - value semantic features , used to determine what features are _ expected _ from a given case - filler  e.g . ` < human,+1 > ` is a feature that the _ agent _ of the verb _ write _ should possess ) .",
    "every couple @xmath9 present in the case structure means that @xmath8 is a set of attribute - value couples which are attached to @xmath10 as selectional features for the case @xmath7 :    @xmath11    for example , we can write :    @xmath12(_write_,_agent_)@xmath13\\{`<human,+1 > ` }    the _ semantic compatibility _ is the value we seek to maximize to determine the best assignments .",
    "\\1 . at the feature level ( compatibility between two features )",
    ", it is defined so as to `` match '' extrinsic and intrinsic features .",
    "this actually includes a somehow complex definition , taking into account the modelling of conceptual inheritance between semantic features ; but for the sake of simplicity in this presentation , we may assume that the semantic compatibility at the semantic feature level is defined as in eq .  [ c - feature - level ] , which would be the case for a `` flat '' ontology .    @xmath14    \\2 . at the feature structure level , i.e. where the semantic contents of icons are defined",
    ", semantic compatibility is calculated between two homogeneous sets of attribute - value couples : on one side the selectional features attached to a given case slot of the predicate icon  stripped here of the case type , on the other side the intrinsic features of the candidate icon .",
    "the basic idea here is to define the compatibility as the sum of matchings in the two sets of attribute - value pairs , in ratio to the number of features being compared to .",
    "it should be noted that semantic compatibility is not a symmetric norm : it has to measure how good the candidate actor fills the expectations of a given predicative concept in respect to one of its particular cases .",
    "hence there is a _ filtering _ set ( @xmath12 ) and a _ filtered _ set ( @xmath15 ) , and it is the cardinal of the filtering set which is used as denominator :     @xmath16}{\\sum_{i \\in [ 1,m]}{{\\cal c}(f_{1i},f_{2j})}}}{n } \\label{c - feature - structure - level}\\end{aligned}\\ ] ]    ( where the @xmath17 and the @xmath18 are simple features of the form @xmath19 and @xmath20 , respectively ) .    a threshold of acceptability is used to shed out improbable associations without losing time .",
    "even with no grammar rules , though , it is necessary to take into account the distance between two icons in the sequence , which make it more likely that the actor of a given predicate should be just before or just after it , than four icons further , out of its context .",
    "hence we also introduce a `` fading '' function , to weight the virtual semantic compatibility of a candidate actor to a predicate , by its actual distance to the predicate in the sequence :     @xmath21    where :    @xmath22 is the value of the assignment of candidate icon @xmath23 as filler of the role @xmath7 of predicate @xmath10 ;    @xmath24 is the fading function ( decreasing from 1 to 0 when the distance between the two icons goes from 0 to @xmath25 ) ;    and @xmath26 the ( virtual ) semantic compatibility of the intrinsic features of @xmath23 to the selectional features of @xmath10 for the case @xmath7 , with no consideration of distance ( as defined in eq",
    ".  [ c - feature - structure - level ] ) .",
    "eventually a global * assignment * of actors ( chosen among those present in the context ) to the case slots of the predicate , has to be determined .",
    "an assignment is an application of the set of icons ( other than the predicate being considered ) into the set of cases of the predicate .",
    "the semantic compatibility of this global assignment is defined as the sum of the _ values _ ( as defined in eq .",
    "[ weighted - value ] ) of the individual case - filler allotments .",
    "\\4 . for a sequence of icon containing more than one predicative symbol",
    ", the calculus of the assignments is done for every one of them . a global * interpretation * of the sequence",
    "is a set of assignments for every predicate in the sequence .",
    "in former works , this principle was implemented by a recursive algorithm ( purely declarative prolog ) .",
    "then , for a sequence of @xmath27 concepts , and supposing we have the ( mean value of ) @xmath28 ( valency ) roles to fill for every predicate , let us evaluate the time we need to compute the possible interpretations of the sequence , when we are in the worst case , i.e. the @xmath27 icons are all predicates .    \\1 . for every assignment ,",
    "the number of semantic compatibility values corresponding to a single role / filler allotment , on an @xmath29 couple ( i.e. at the feature structure level , as defined in eq .  [ c - feature - structure - level ] ) is : @xmath30 .",
    "\\2 . for every icon ,",
    "the number of possible assignments is :    @xmath31    ( we suppose that @xmath32 , because we are only interested in what happens when @xmath27 becomes big , and @xmath28 typically lies around 3 ) .    \\3 . for every assignment ,",
    "the @xmath33 allotment possibilities for the first case are computed only once .",
    "then , for every possibility of allotment of the first case , the @xmath33 possibilities for the second case are recomputed  hence , there are @xmath34 calculations of role / filler allotment scores for the second case . similarly ,",
    "every possible allotment for the third case is recomputed for every possible choice set on the first two cases  so , there are @xmath35 computations on the whole for the third case .",
    "this goes on until the @xmath36 case .    in the end , for one single assignment , the number of times a case / filler score has been computed is @xmath37 .    then , to compute all the possible interpretations :    \\1 .",
    "number of times the system computes every possible assignment of the first icon : 1 .",
    "number of times the system computes every possible assignment of the second icon : @xmath38 ( once for every assignment of the first icon , backtracking every time  still supposing we are in the worst case , i.e. all the assignments pass over the acceptability threshold ) .",
    "number of times the system computes every possible assignment of the third icon : @xmath39 ( once for every possible assignment of the second icon , each of them being recomputed once again for every possible assignment of the first icon ) .",
    "(  )    \\4 .",
    "number of times the system computes every possible assignment of the @xmath40 icon : @xmath41 .",
    "number of assignments computed on the whole : every assignment of the first icon ( there are @xmath38 of them ) is computed just once , since it is at the beginning of the backtracking chain ; every assignment of the second icon is computed @xmath38 times for every assignment of the first icon , so @xmath42 times ,  every assignment of the @xmath40 icon is computed @xmath43 times .",
    "total number of assignment calculations : @xmath44 .",
    "every calculation of an assignment value involves , as we have seen , @xmath37 calculations of a semantic compatibility at a feature structure level .",
    "so , totally , for the calculation of all possible interpretations of the sentence , the number of such calculations has been :    @xmath45    \\7 .",
    "lastly , the final scoring of every interpretation involves summing the scores of the @xmath27 assignments , which takes up @xmath33 elementary ( binary ) sums . this sum is computed every time an interpretation is set , i.e. every time the system reaches a leaf of the choice tree , i.e. every time an assignment for the @xmath40 icon is reached , that is @xmath43 times .",
    "so , there is an additional computing time which also is a function of @xmath27 , namely , expressed in number of elementary sums :    @xmath46    hence , if we label @xmath47 the ratio of the computing time used to compute the score of a role / filler allotment to the computing time of an elementary binary sum is a constant in relation to @xmath27 : the computation of the semantic compatibility at the feature structure level , defined in eq",
    ".  [ c - feature - structure - level ] , roughly involves @xmath48 computations of the semantic compatibility at the feature level , defined in eq .  [ c - feature - level ] ( @xmath6 being the average number of selectional features for a given role on a given predicate , and @xmath49 the average number of intrinsic features of the entries in the semantic lexicon ) , which itself involves a sequence of elementary operations ( comparisons , floating point number multiplication ) . it does not depend on @xmath27 , the number of icons in the sequence . ] , the number of elementary operations involved in computing the scores of the interpretations of the whole sequence is :    @xmath50",
    "to avoid this major impediment , we define a new algorithm which stores the results of the low - level operations uselessly recomputed at every backtrack :    * the low - level role / filler compatibility values , in a chart called ` compatibility_table ' .",
    "the values stored here correspond to the values defined at eq .",
    "[ c - feature - structure - level ] . *",
    "the value of every assignment , in ` assignments_table ' .",
    "the values stored here correspond to assignments of multiple case slots of a predicate , as defined at point 3 of section  [ method ] ; they are the sum of the values stored at level ( a ) , multiplied by a fading function of the distance between the icons involved . * the value of the interpretations of the sentence , in ` interpretations_table ' .",
    "the values stored here correspond to global interpretations of the sentence , as defined at point 4 of section  [ method ] .    with this system , at level ( b )",
    "( calculation of the values of assignments ) , the value of the role / filler couples are re - used from the compatibility table , and are not recomputed many times . in the same way , at level ( c ) , the computation of the interpretations values by adding the assignments values does not recompute the assignments values at every step , but simply uses the values stored in the assignments table .    furthermore , the system has been improved for the cases where only partial modifications are done to the graph , e.g. when the users want to perform an incremental generation , by generating the graph again at every new icon added to the end of the sequence ; or when they want to delete one of the icons of the sequence only , optionally to replace it by another one . in these cases ,",
    "a great part of the information remains unchanged . to take this property into account , the system stores the current sequence and the charts resulting from the parse in memory , allowing them to be only partially replaced afterwards .",
    "finally , we have implemented three basic interface functions to be performed by the parser .",
    "the first one implements a full parse , the second partially re - parses a sequence where new icons have been added , the third partially re - parses a sequence where icons have been removed .",
    "the three functions can be described as follows .",
    "[ [ parsing - from - scratch ] ] parsing from scratch : + + + + + + + + + + + + + + + + + + + + +    1 .",
    "spot the icons in the new sequence which are potential predicates ( which have a valency frame ) .",
    "2 .   run through the sequence and identify every possible pair @xmath51predicate , role@xmath52,candidate@xmath52 .",
    "+ for each one of them , calculate the semantic compatibility + @xmath53candidate@xmath54predicate , role@xmath55 . + store all the values found in compatibility_table : + [ cols= \" < , < , < , < \" , ]    4 .",
    "calculate the list of all the possible interpretation ( 1 interpretation is 1 sequence of assignments ) . store them along with their values in interpretations_table .",
    "[ [ add - a - list - of - icons - to - the - currently - stored - sequence ] ] add a list of icons to the currently stored sequence : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    1 .",
    "add the icons of _ list of icons _ to the currently stored sequence .",
    "2 .   for every pair @xmath51predicate , role@xmath52,candidate@xmath52 . + where either the predicate , or the candidate , is a new icon ( is a member of _ list of icons _ ) , calculate the value of + @xmath53candidate@xmath54predicate , role@xmath55 . + and store the value in : + compatibility_table .",
    "3 .   calculate the new assignments made possible by the new icons from _ list of icons _ : * the assignments of new predicates ; * for every predicate already present in the sequence before , the assignments where at least one of the roles is allotted to one of the icons of _ list of icons_. + for each of them , calculate its value , and store it in assignments_table .",
    "recompute the table of interpretations totally ( no get - around ) .",
    "[ [ remove - a - list - of - icons - from - the - currently - stored - sequence ] ] remove a list of icons from the currently stored sequence : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    1 .",
    "remove the icons of _ list of icons _ from the sequence stored in memory .",
    "2 .   remove the entries of compatibility_table or assignments_table involving at least one of the icons of _ list of icons_. 3 .",
    "recompute the table of interpretations .",
    "first , let us evaluate the complexity of the algorithm presented in section  [ chart - algorithm ] assuming that only the first interface function is used ( parsing from scratch every time a new icon is added to the sequence ) .    in the worst case",
    ": the @xmath27 icons are all predicates ; no possible role / filler allotment in the whole sequence is below the threshold of acceptability .",
    "* for every predicate , every combination between one single role and one single other icon in the sequence is evaluated : there are @xmath30 such possible couples @xmath29 .",
    "* since there are ( worst case ) @xmath27 predicates , there are @xmath56 such combinations to compute for the whole sequence , in order to fill the compatibility table .",
    "* after the compatibility table has been filled , its values are used to compute the score of every possible assignment ( of surrounding icons ) for every predicate ( to its case roles ) . computing the score of an assignment involves summing @xmath28 values of the compatibility table , multiplied by a value of the fading function @xmath24 , typically for a small integer .",
    "thus , for every line in the assignments table ( table  [ assignments ] ) , the computing time is constant in respect to @xmath27 . * for every predicate , there are + @xmath31 + possible assignments ( see section  [ complexity - recursive ] ) .",
    "since there are @xmath27 predicates , there is a total number ( in the worst case ) of @xmath57 different possible assignments , i.e. different lines to fill in the assignments table .",
    "so , the time to fill the assignment table in relation to @xmath27 is @xmath58 multiplied by a constant factor .",
    "* after the assignments table has been filled , its values are used to compute the score of the possible interpretations of the sentence .",
    "the computation of the score of every single interpretation is simply a sum of scores of assignments : since there possibly are @xmath27 predicates , there might be up to @xmath27 figures to sum to compute the score of an interpretation . *",
    "an interpretation is an element of the cartesian product of the sets of all possible assignments for every predicate .",
    "since every one of these sets has @xmath38 elements , there is a total number of + @xmath59 + interpretations to compute . as each computation might involve @xmath33 elementary sums ( there are @xmath27 figures to sum up )",
    ", we may conclude that the time to fill the interpretations table is in a relation to @xmath27 which may be written so : @xmath60 .",
    "* in the end , the calculation time is not the product , but the sum , of the times used to fill each of the tables .",
    "so , if we label @xmath47 and @xmath61 two constants , representing , respectively , the ratio of the computing time used to get the score of an elementary role / filler allotment to the computing time of an elementary binary addition , and the ratio of the computing time used to get the score of an assignment from the scores of the role / filler allotments ( adding up @xmath28 of them , multiplied by values of the @xmath24 function ) , to the computing time of an elementary binary addition , the total computing time for calculating the scores of all possible interpretations of the sentence is :    @xmath62",
    "we have presented a new algorithm for a completely semantic parse of a sequence of symbols in a graph - based formalism . the new algorithm has a temporal complexity like in eq .",
    "[ eq - complexity - chart ] , to be compared to the complexity of a purely recursive algorithm , like in eq .",
    "[ eq - complexity - recursive ] .    in the worst case , the second function is still dominated by a function which grows hyperexponentially in relation to @xmath27 : the number of possible interpretations multiplied by the time used to sum up the score of an interpretation . ] . in practice ,",
    "the values of the parameters @xmath47 and @xmath61 are fairly large , so this member is still small during the first steps , but it grows very quickly .    as for the other member of the function , it is hyperexponential in the case of eq .",
    "[ eq - complexity - recursive ] , whereas it is of order @xmath63 , i.e. it is @xmath64 , in the case of eq .",
    "[ eq - complexity - chart ] .",
    "practically , to make the semantic parsing algorithm acceptable , the problem of the hyperexponential growth of the number of interpretations has to be eliminated at some point . in the system",
    "we have implemented , a threshold mechanism allows to reject , for every predicate , the unlikely assignments .",
    "this practically leaves up only a small maximum number of assignments in the assignments table , for every predicate  typically 3 .",
    "this means that the number of interpretations is no longer of the order of @xmath65 , but `` only '' of @xmath66 : it becomes `` simply '' exponential .",
    "this implementation mechanism makes the practical computing time acceptable when running on an average computer for input sequences of no more than approximately 15 symbols .    in order to give a comprehensive solution to the problem",
    ", future developments will try to develop heuristics to find out the best solutions without having to compute the whole list of all possible interpretations and sort it by decreasing value of semantic compatibility .",
    "for example , by trying to explore the search space ( of all possible interpretations ) from maximum values of the assignments , it may be possible to generate only the 10 or 20 best interpretations without having to score all of them to start with ."
  ],
  "abstract_text": [
    "<S> in some contexts , well - formed natural language can not be expected as input to information or communication systems . in these contexts , </S>",
    "<S> the use of grammar - independent input ( sequences of uninflected semantic units like e.g. language - independent icons ) can be an answer to the users needs . </S>",
    "<S> however , this requires that an intelligent system should be able to interpret this input with reasonable accuracy and in reasonable time . </S>",
    "<S> here we propose a method allowing a purely semantic - based analysis of sequences of semantic units . </S>",
    "<S> it uses an algorithm inspired by the idea of `` chart parsing '' known in natural language processing , which stores intermediate parsing results in order to bring the calculation time down . </S>"
  ]
}