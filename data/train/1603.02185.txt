{
  "article_text": [
    "multi - task learning is widely used learning framework in which similar tasks are considered jointly for the purpose of improving performance compared to learning the tasks separately @xcite . by transferring information between related tasks",
    "it is hoped that samples will be better utilized , leading to improved generalization performance .",
    "multi - task learning has been successfully applied , for example , in natural language understanding @xcite , speech recognition @xcite , remote sensing @xcite , image classification @xcite , spam filtering @xcite , web search @xcite , disease prediction @xcite , and eqtl mapping @xcite among other applications .    here , we study multi - task learning in a distributed setting , where each task is handled by a different machine and communication between machines is expensive .",
    "that is , each machine has access to data for a different task and needs to learn a predictor for that task , where machines communicate with each other in order to leverage the relationship between the tasks .",
    "this situation lies between a homogeneous distributed learning setting ( e.g. * ? ? ?",
    "* ) , where all machines have data from the same source distribution , and inhomogeneous consensus problems ( e.g. * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ) where the goal is to reach a single consensus predictor or iterate which is the same on all machines .",
    "the main argument for this setting is that if each machine indeed has access to different data ( e.g.  from a different geographical region or different types of users ) , as in the consensus problems studied by @xcite , then we should allow a different predictor for each distribution , instead of insisting on a single consensus predictor , while still trying to leverage the relationship and similarity between data distributions , as in classical multi - task learning . as was recently pointed out by @xcite , allowing separate predictors for each task instead of insisting on a consensus predictor changes the fundamental nature of the distributed learning problem , allows for different optimization methods , and necessitates a different analysis approach , more similar to homogeneous distributed learning as studied by @xcite .",
    "the success of multi - task learning relies on the relatedness between tasks .",
    "while @xcite studied tasks related through shared sparsity , here we turn to a more general , powerful and empirically more successful model of relatedness , where the predictors for different tasks lie in some ( a - priori unknown ) shared low - dimensional subspace and so the matrix of predictors is of low rank @xcite . in a shared sparsity model ,",
    "information from all tasks is used to learn a subset of the input features which are then used by all tasks .",
    "in contrast , in a shared subspace model , novel features , which are linear functions of the input features , are learned .",
    "the model can thus be viewed as a two - layer neural network , with the bottom layer learned jointly across tasks and the top layer task - specific .",
    "being arguably the most complex multi - layer network that we can fully analyze , studying such models can also serve as a gateway to using deeper networks for learning shared representations .",
    "multi - task learning with a shared subspace is well - studied in a centralized setting , where data for all tasks are on the same machine , and some global centralized procedure is used to find a good predictor for each task .",
    "in such a situation , nuclear norm regularization is often used to leverage the low rank structure ( e.g. * ? ? ?",
    "* ; * ? ? ?",
    "* ) and learning guarantees are known ( @xcite and see also section [ sec : baseline ] ) . with the growth of modern massive data sets , where tasks and data often too big to handle on a single machine , it is important to develop methods also for the distributed setting",
    ". unfortunately , the distributed multi - task setting is largely unexplored and we are not aware of any prior for on distributed multi - task learning with shared subspaces .",
    "in this paper we focus on methods with efficient communication complexity ( i.e.  with as small as possible communication between machines ) , that can still leverage most of the statistical benefit of shared - subspace multi - task learning .",
    "although all our methods are also computationally tractable and can be implemented efficiently , we are less concerned here with minimizing the runtime on each machine separately , considering communication , instead , as the main bottleneck and the main resource to be minimized @xcite .",
    "this is similar to the focus in distributed optimization approaches such as admm @xcite and dane @xcite where optimization within each machine is taken as an atomic step .    [",
    "cols=\"^,^,^,^,^,^,^,^\",options=\"header \" , ]     [ [ contribution ] ] contribution + + + + + + + + + + + +    the main contributions of this article are :    * present and formalize the shared - subspace multi - task learning @xcite in the novel distributed multitask setting , identifying the relevant problems and possible approaches .",
    "we analyze two baselines , several representative first - order distributed optimization methods , with careful sample and communication complexity analysis .",
    "* we proposed and analyzed two subspace pursuit approaches which learns the shared representation in a greedy fashion , which leverage the low - dimensional predictive structure in a communication efficient way .",
    "* we conducted comprehensive experimental comparisons of the discussed approaches on both simulated and real datasets , where we demonstrated that the proposed approaches are more communication efficient than first - order convex optimization methods .",
    "table [ table : summary ] summarized the approaches studied in this paper , which will be discussed in detail in the following sections .    [ [ homogeneous - inhomogeneous - and - multi - task - distributed - learning . ] ] homogeneous , inhomogeneous and multi - task distributed learning .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we briefly review the relationship between homogeneous , inhomogeneous and multi - task learning , as recently presented by @xcite .",
    "a typical situation considered in the literature is one in which data on different machines are all drawn i.i.d from the same source distribution . in this",
    "setting , tasks on different machines are all the same , which should be taken advantage of in optimization @xcite . furthermore",
    ", as each machine has access to samples from the source distribution it can perform computations locally , without ever communicating with other machines .",
    "while having zero communication cost , this approach does not compare favorably with the centralized approach , in which all data are communicated to the central machine and used to obtain one predictor , when measured in terms of statistical efficiency .",
    "the goal in this setting is to obtain performance close to that of the centralized approach , using the same number of samples , but with low communication and computation costs @xcite .",
    "another setting considered in the distributed optimization literature is that of consensus optimization . here",
    "each machine has data from a different distribution and the goal is to find one vector of coefficients that is good for all the separate learning or optimization problems @xcite .",
    "the difficulty of consensus problems is that the local objectives might be rather different , and , as a result , one can obtain lower bounds on the amount of communication that must be exchanged in order to reach a joint optimum .",
    "in this paper we suggest a novel setting that combines aspects of the above two settings . on one hand , we assume that each machine has a different source distributions @xmath0 , corresponding to a different task , as in consensus problems .",
    "for example , each machine serves a different geographical location , or each is at a different hospital or school with different characteristics .",
    "but if indeed there are differences between the source distributions , it is natural to learn different predictors @xmath1 for each machine , so that @xmath1 is good for the distribution typical to that machine . in this",
    "regard , our distributed multi - task learning problem is more similar to single - source problems , in that machines could potentially learn on their own given enough samples and enough time .",
    "furthermore , availability of other machines just makes the problem easier by allowing transfer between the machine , thus reducing the sample complexity and potentially runtime .",
    "the goal , then , is to leverage as much transfer as possible , while limiting communication and runtime . as with single - source problems ,",
    "we compare our method to the two baselines , where we would like to be much better than the local approach , achieving performance nearly as good as the centralized approach , but with minimal communication and efficient runtime .",
    "we consider a setting with @xmath2 tasks , each characterized by a source distribution @xmath3 over feature vectors @xmath4 and associated labels @xmath5 , and out goal is to find linear predictors @xmath6 minimizing the overall expected loss ( risk ) across tasks : @xmath7 where for convenience we denote @xmath8 for the matrix with columns @xmath9 , and @xmath10 is some specified instantaneous loss function .    in the learning setting ,",
    "we can not observe @xmath11 directly and only have access to i.i.d .",
    "sample @xmath12 from each distribution @xmath0 , @xmath13 . for simplicity of presentation",
    ", we will assume that @xmath14 , @xmath13 , throughout the paper .",
    "we will denote the empirical loss @xmath15 where @xmath16 is the local ( per - task ) empirical loss .",
    "we consider a distributed setting , where each task is handled on one of @xmath2 separate machines , and each machine @xmath17 has access only to the samples drawn from @xmath0 .",
    "communication between the machines is by sending real - valued vectors .",
    "our methods work either in a broadcast communication setting , where at each iteration each machine sends a vector which is received by all other machines , or in a master - at - the - center topology where each machine sends a vector to the master node , whom in turn performs some computation and broadcasts some other vectors to all machines . either way , we count to total number of vectors communicated .",
    "as in standard agnostic - pac type analysis , our goal will be to obtain expected loss @xmath11 which is not much larger then the expected loss of some ( unknown ) reference predictor need _ not _ be the minimizer of the expected loss .",
    "we can think of it as the minimizer inside some restricted hypothesis class , though all analysis and statements hold for any chosen reference predictor @xmath18 . ]",
    "@xmath18 , and we will measure the _ excess error _ over this goal . to allow obtaining such guarantees we will assume :    [ assum : lipschitz ] the loss function @xmath19 is @xmath20-lipschitz and bounded by @xmath20 , be twice differentiable and @xmath21-smooth , that is @xmath22 all the data points are bounded by unit length , i.e. @xmath23 and the reference predictors have bounded norm : @xmath24 } \\norm{\\wb_j^*}_2 ^ 2 \\leq a^2\\ ] ] for some @xmath25 .    the simplest approach , which we refer to as ` local",
    "` , is to learn a linear predictor on each machine independently of other machines .",
    "this single task learning approach ignores the fact that the tasks are related and that sharing information between them could improve statistical performance .",
    "however , the communication cost for this procedure is zero , and with enough samples it can still drive the excess error to zero .",
    "however , compared to procedures discussed later , sample complexity ( number of samples @xmath26 required to achieve small excess error ) is larger .",
    "a standard rademacher complexity argument @xcite gives the following generalization guarantee , which is an extension of theorem 26.12 in @xcite .",
    "suppose assumption [ assum : lipschitz ] holds .",
    "then with probability at least @xmath27 , @xmath28 where @xmath29 $ ] with @xmath30 .    that is , in order to ensure @xmath31 excess error , we need @xmath32 samples from each task .    at the other extreme ,",
    "if we ignore all communication costs , and , e.g.  communicate all data to a single machine , we can significantly leverage the shared subspace . to understand this , we will first need to introduce two assumptions : one about the existence of a shared subspace ( i.e.  that the reference predictor is indeed low - rank ) , and the other about the spread of the data :    [ assum : rank ] @xmath33    [ assum : spectral ] there is a constant @xmath34 , such that @xmath35    since the data is bounded , we always have @xmath36 , with @xmath34 being a measure of how spread out the data is in different direction .",
    "a value of @xmath37 indicates the data is entirely contained in a one - dimensional line . in this case",
    ", the predictor matrix will also always be rank - one , imposing a low - rank structure is meaningless and we ca nt expect to gain from it .",
    "however , when @xmath34 is close to @xmath38 , or at least high , the data is spread in many directions and the low - rank assumption is meaningful",
    ". we can think of @xmath34 as the `` effective dimensionality '' of the data , and hope to gain when @xmath39 .    with these two assumptions in hand",
    ", we can think of minimizing the empirical error subject to a rank constraint on @xmath40 .",
    "this is a hard and non - convex optimization task , but we can instead use the nuclear norm ( aka trace - norm ) @xmath41 as a convex surrogate for the rank .",
    "this is because if assumptions [ assum : lipschitz ] and [ assum : rank ] hold , then we also have : @xmath42 with this in mind , we can define the following _ centralized _ predictor : @xmath43 which achieves the improved excess error guarantee :    ( theorem 1 in @xcite ) suppose assumptions [ assum : lipschitz ] , [ assum : rank ] and [ assum : spectral ] hold .",
    "then with probability at least @xmath27 , @xmath44    the sample complexity per task , up to logarithmic factors , is thus only : @xmath45 when @xmath46 , this is a reduction by a factor of @xmath47 .",
    "that is , it is as if we needed to only learn @xmath48 linear predictors instead of @xmath2 .",
    "the problem is that a naive computation of @xmath49 requires collecting all data on a single machine , i.e.  communicating @xmath50 samples per machine . in the next sections , we aim at developing methods of approximating @xmath51 using communication efficient methods , or computing an alternate predictor with similar statistical properties but using much less communication .",
    "in this section , we study how to obtain the sharing benefit of the centralized approach using distributed convex optimization techniques , while keeping the communication requirements at low .    to enjoy the benefit of nuclear - norm regularization while avoid heavy communication cost of ` centralize ` , a flexible strategy is to solve the convex objective via distributed optimization techniques .",
    "let @xmath52 be the solution at @xmath53-iteration for some iterative distributed optimization algorithm for the following constrained objective : @xmath54 by the generalization error decompsition @xcite , @xmath55    suppose @xmath52 satisfying @xmath56 with @xmath57 .",
    "then @xmath52 will have the generalization error of order @xmath58 . therefore in order to study the generalization performance , we will study how the optimization error decreases as the function of the number of iterations @xmath53 .    [ [ constrained - vs - regularized - objective ] ] constrained vs regularized objective + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    note that the constrained objective is equivalent to the following regularized objective with a proper choice of @xmath59 : @xmath60 though they are equivalent , specific optimization algorithms might sometimes be more suitable for one particular type of objectives . for convenience in the following discussion we did nt distinguish between these two formulations .",
    "maybe the simplest distributed optimization algorithm for is the proximal gradient descent .",
    "it is not hard to see that computation of the gradient @xmath61 can be easily done in a distributed way as the losses are decomposable across machines : @xmath62 where @xmath63 thus each machine @xmath17 needs to compute the gradient @xmath64 on the local dataset and send it to the master .",
    "the master concatenates the gradient vectors to form the gradient matrix @xmath61 .",
    "finally , the master computes the proximal step @xmath65 which has the following closed form solution @xcite : let @xmath66 be the svd of @xmath67 , then @xmath68 with @xmath69 applied element - wise .",
    "the algorithm is summarized in algorithm [ alg : prox_gd ] ( in appendix ) , which has well established convergence rates @xcite : @xmath70 to obtain @xmath71-generalization error , the distributed proximal gradient descent requires @xmath72 rounds of communication , with a total @xmath73 bits communications per machine . +      it is also possible to use nesterov s acceleration idea @xcite to improve the convergence of the proximal gradient algorithm from @xmath74 to @xmath75 @xcite . using the distributed accelerated proximal gradient descent , one needs @xmath76 rounds of communication with a total @xmath77 bits communicated per machine to achieve @xmath71-generalization error .",
    "the algorithm is summarized in algorithm [ alg : acc_prox_gd ] ( in appendix ) , where the master maintains two sequences : @xmath40 and @xmath78 .",
    "first , a proximal gradient update of @xmath40 is done based on @xmath78 @xmath79 and then @xmath78 is updated based on a combination of the current @xmath40 and the difference with previous @xmath40 @xmath80    [ [ admm - and - dfw ] ] admm and dfw + + + + + + + + + + + +    we also discuss the implementation and guarantees for two other popular optimization methods : admm and frank - wolfe , which are presented in the appendix [ sec : admm ] and [ sec : dfw ] .",
    "in this section we propose two distributed algorithms which select the subspaces in a greedy fashion , instead of solving the nuclear norm regularized convex program .",
    "our greedy approach is inspired by the methods used for sparse signal reconstruction @xcite . under the assumption that the optimal model @xmath18 is low - rank ,",
    "say rank @xmath48 , we can write @xmath18 as a sum of @xmath48 rank-@xmath20 matrices : @xmath81 where @xmath82 , and @xmath83 . in the proposed approach , the projection matrix @xmath84 is learned in a greedy fashion . at every iteration",
    ", a new one - dimensional subspace is identified that leads to an improvement in the objective .",
    "this subspace is then included into the existing projection matrix . using the new expanded projection matrix as the current feature representation ,",
    "we refit the model to obtain the coefficient vectors @xmath85 . in",
    "the distributed setting , there is a master that gathers local gradient information from each task .",
    "based on this information , it then computes the subspace to be added to the projection matrix and sends it to each machine .",
    "the key step in the distributed greedy subspace pursuit algorithm is the addition of the subspace .",
    "one possible choice is the principle component of the gradient direction ; after the master collected the gradient matrix @xmath86 , it computes the top left and right singular vectors of @xmath86 .",
    "let @xmath87 be the largest singular vectors of @xmath88 .",
    "the left singular vector @xmath89 is used as a new subspace to be added to the projection matrix @xmath84 .",
    "this vector is sent to each machine , which then concatenate it to the projection matrix and refit the model with the new representation .",
    "algorithm  [ alg : dgsp ] details the steps .    distributed gradient subspace pursuit ( `",
    "dgsp ` ) , detailed in algorithm  [ alg : dgsp ] , creates subspaces that are orthogonal to each other , as shown in the following proposition which is proved in appendix [ sec : orthogonal ] :    at every iteration of algorithm [ alg : dgsp ] , the columns of @xmath84 are orthonormal .",
    "[ prop : orthogonal ]    both the distributed gradient subspace pursuit and the distributed frank - wolfe use the leading singular vector of the gradient matrix iteratively .",
    "moreover , leading singular vectors of the gradient matrix have been used in greedy selection procedures for solving low - rank matrix learning problems @xcite . however , ` dgsp ` utilize the learned subspace in a very different way : ` geco ` @xcite re - fit the low - rank matrix under a larger subspace which is spanned by all left and right singular vectors ; while ` or1mp ` @xcite only adjust the linear combination parameters @xmath90 of the rank-1 matrices .",
    "the ` dgsp ` algorithm do not restrict on the joint subspaces @xmath91 , but focused on the low - dimensional subspace induced the projection matrix @xmath84 , and estimate the task specific predictors @xmath85 based on the learned representation .",
    "next , we present convergence guarantees for the distributed gradient subspace pursuit .",
    "first , note that the smoothness of @xmath19 implies the smoothness property for any rank-1 update .",
    "suppose assumption  [ assum : lipschitz ] holds .",
    "then for any @xmath40 and unit length vectors @xmath92 and @xmath93 , we have @xmath94 [ prop : smoothness ]    we defer the proof in appendix [ sec : proofprop ] .",
    "the following theorem states the number of iterations needed for the distributed gradient subspace pursuit to find an @xmath71-suboptimal solution .",
    "[ thm : dgsp ] suppose assumption  [ assum : lipschitz ] holds",
    ". then the distributed gradient subspace pursuit finds @xmath52 such that @xmath95 when @xmath96    we defer the proof in appendix [ sec : proofthm ] .",
    "theorem [ thm : dgsp ] tells us that for the distributed gradient subspace pursuit requires @xmath97 iterations to reach @xmath98 accuracy .",
    "since each iteration requires communicating @xmath38 number , the communication cost per machine is @xmath99 . in some applications",
    "this communication cost might be still too high and in order to improve it we will try to reduce the number of rounds of communication . to that end , we develop a procedure that utilizes the second - order information to improve the convergence .",
    "algorithm [ alg : dnsp ] describes the distributed newton subspace pursuit algorithm ( ` dnsp ` ) .",
    "note that distributed optimization with second - order information have been studied recently to achieve communication efficiency @xcite .",
    "compared to the gradient based methods , the ` dnsp ` algorithm uses second - order information to find subspaces to work with . at each iteration",
    ", each machine computes the newton direction    @xmath100^{-1 } \\nabla \\lcal_{nj}(\\wb_j ) \\\\",
    "= & \\sbr{\\frac{1}{mn } \\sum_{i=1}^{n } \\ell''(\\wb_j^t \\xb_{ji},y_{ji } ) \\xb_{ji } \\xb_{ji}^t } ^{-1 }   \\nabla \\lcal_{nj}(\\wb_j),\\end{aligned}\\ ] ]    based on the current solution and sends it to the master .",
    "the master computes the overall newton direction by concatenating the newton direction for each task @xmath101\\end{aligned}\\ ] ] and computes the top singular vectors of @xmath102 .",
    "the top left singular vector @xmath89 is is sent back to every machine , which is then concatenated to the current projection matrix .",
    "each machine re - fits the predictors using the new representation .",
    "note that at every iteration a gram - schmidt step is performed to ensure that the learned basis are orthonormal .    `",
    "dnsp ` is a newton - like method which uses second - order information , thus its generic analysis is not immediately apparent .",
    "however empirical results in the next section illustrate good performance of the proposed ` dnsp ` .",
    "we first illustrate performance of different procedures on simulated data . we generate data according to @xmath103 for regression problems and @xmath104 for classification problems .",
    "we generate the low - rank @xmath18 as follows .",
    "we first generate two matrices @xmath105 with entries sampled independently from a standard normal distribution .",
    "then we extract the left and right singular vectors of @xmath106 , denoted as @xmath107 . finally , we set @xmath108 , where @xmath109 is a diagonal matrix with exponentially decaying entries : @xmath110 $ ] .",
    "the feature vectors @xmath111 are sampled from a mean zero multivariate normal with the covariance matrix @xmath112}$ ] , @xmath113 .",
    "the regularization parameters for all approaches were optimized to give the best prediction performance over a held - out validation dataset . for ` proxgd ` and ` accproxgd ` , we initialized the solution from ` local ` .",
    "our simulation results are averaged over 10 independent runs .",
    "we investigate how the performance of various procedures changes as a function of problem parameters @xmath114 .",
    "we compare the following procedures : i ) ` local ` , where each machine solves an empirical risk minimization problem ( ordinary least squares or logistic regression ) .",
    "ii ) nuclear - norm regularization : which is a popular ` centralize ` approach : all machines send their data to the master , the master solves a nuclear - norm regularized loss minimization problem .",
    "iii ) learning with the best representation ( ` bestrep ` ) : which assumes the true projection matrix @xmath84 is known , and just fit ordinal least squares or logistic regression model in the projected low - dimensional subspace . note that this is not a practical approach since in practice we do not know the best low - dimensional representations of the data .",
    "iv ) convex optimization approach which runs distributed optimization algorithms over the nuclear norm - regularized objective : here we implemented and compared the following algorithms : distributed proximal gradient ( ` proxgd ` ) ; distributed accelerated proximal gradient , ( ` accproxgd ` ) ; distributed alternating direction method of multipliers ( ` admm ` ) ; distributed frank - wolfe ( ` dfw ` ) .",
    "v ) the proposed ` dgsp ` and ` dnsp ` approaches .",
    "the simulation results for regression and classification problems are shown in figure [ fig : simulation_regression ] and [ fig : simulation_classification ] , respectively .",
    "we plot how the excess prediction error decreases as the number of rounds of communications increases ( ` local ` , ` centralize ` and ` bestrep ` are one shot approaches thus the lines are horizontal ) . from the plots",
    ", we have the following observations :    * nuclear norm regularization boosts the prediction performance over plain single task learning significantly , which shows clear advantage of leveraging the shared representation in multi - task learning . * ` admm ` and ` accproxgd ` perform reasonably well , especially ` admm ` .",
    "one reason for the effectiveness of ` admm ` is that for the problem of nuclear norm regularized multi - task learning considered here , the ` admm ` update solves regularized erm problems at every iteration . `",
    "admm ` and ` accproxgd ` clearly outperform ` proxgd ` . * ` proxgd ` and ` dgsp ` perform similarly . `",
    "dgsp ` usually becomes worse as the iterations increases , while ` proxgd ` converges to a global optimum of the nuclear norm regularized objective . * ` dnsp ` is the most communication - efficient method , and usually converges to a solution that is slightly better compared to the optimum of the nuclear regularization .",
    "this shows that second - order information helps a lot in reducing the communication cost .",
    "* the ` dfw ` performs the worst in most cases , even though ` dfw ` shares some similarity with ` dgsp ` in learning the subspace .",
    "the empirical results suggest the re - fitting step in ` dgsp ` is very important .",
    "[ [ one - shot - svd - truncation ] ] one - shot svd truncation + + + + + + + + + + + + + + + + + + + + + + +    a natural question to ask is whether there exists a one - shot communication method for the shared representation problem considered here , that still matches the performance of centralized methods .",
    "one reasonable solution is to consider the following svd truncation approach , which is based on the following derivation : consider the following well specified linear regression model : @xmath115 where @xmath116 is drawn from mean - zero gaussian noise .",
    "it is easy to verify the following equation for ols estimation : @xmath117 since @xmath118 is just @xmath18 plus some mean - zero gaussian noise , it is natural to consider the following low - rank matrix denoising estimator : @xmath119 where the solution is a simple svd truncation , and can be implemented in a one - shot way : each worker send its ` local ` solution to the master , which then performs an svd truncation step to maintain the top-@xmath48 components @xmath120 and send the resulting estimation back to each worker , where @xmath121 are top-@xmath48 components of @xmath122 . though this approach might work well for some simple scenarios , but will generally fail when the features are highly correlated : although the ` local ` solution @xmath123 can output normal estimation of @xmath18 , the estimation noise @xmath124 might be highly correlated ( depend on the correlation between features ) , which makes the svd truncation estimation not reliable . to illustrate this , consider a more complex simulation which follows the same setup as above setting , except that now the feature vectors @xmath111 are sampled from a higher correlation matrix @xmath112}$ ] , @xmath125 .",
    "the regression simulation results are shown in figure [ fig : simulation_regression_hard ] , where we see that the one - shot svd truncation approach does not significantly outperforms ` local ` , sometimes even slightly worse .",
    "besides simulation , we also conducted extensive experiments on real world datasets , which are presented in appendix [ sec : realworld ] due to space limitation .",
    "we studied the problem of distributed representation learning for multiple tasks , discussed the implementation and guarantees for distributed convex optimization methods , and presented two novel algorithms to learn low - dimensional projection in a greedy way , which can be communication more efficient than distributed convex optimization approaches .",
    "all approaches are extensively evaluated on simulation and real world datasets .",
    "the alternating direction methods of multipliers ( admm ) is also a popular method for distributed optimization @xcite and can be used to solve the distributed low - rank multi - task learning problem .",
    "we first write the objective as @xmath126 by introducing the lagrangian and augmented terms , we get the following unconstrained problem : @xmath127 where @xmath128 is a parameter controlling the augmentation level . note that except for @xmath78 , the augmented lagrangian objective are decomposable across tasks . to implement the distributed admm algorithm , we let the workers maintain the data and @xmath40 , while the master maintains @xmath78 and @xmath129 . at round @xmath53",
    ", each machine separately solves @xmath130 which is minimizing the local loss plus a regularization term .",
    "next , each worker sends their solution to the master , which performs the following updates for @xmath78 and @xmath129 @xmath131 which have closed - form solutions .",
    "the algorithm ` admm ` is summarized in algorithm [ alg : admm ] .",
    "note that compared to methods discussed before , ` admm ` needs to communicate three @xmath38-dimensional vectors between each worker and the master at each round , while the proximal gradient approaches only communicate two @xmath38-dimensional vectors per round .",
    "based on convergence results of admm @xcite , @xmath132 rounds of communication are needed to obtain @xmath71-generalization error .",
    "another approach we consider is the distributed frank - wolfe method @xcite .",
    "this methods does not require performing svd , which might bring additional computational advantages . instead of directly minimizing the nuclear norm regularized objective",
    ", the frank - wolfe algorithm considers the equivalent constrained minimization problem @xmath133 at each step , frank - wolfe algorithm considers the following direction to update @xmath134 where @xmath87 is the leading singular vectors of @xmath88 .",
    "the next iterate is obtained as @xmath135 where @xmath136 is a step size parameter . to implement this algorithm in a distributed way",
    ", the master first collects the gradient matrix @xmath88 and computes @xmath89 and @xmath137 .",
    "the vector @xmath138 is sent to @xmath17-th machine , which performs the following update : @xmath139    the algorithm is summarized in algorithm [ alg : dfw ] .",
    "similar to the distributed ( accelerated ) proximal gradient descent , the distributed frank - wolfe only requires communication of two @xmath38-dimensional vectors per round . though computationally cheaper",
    "compared to other methods considered in this section , the distributed frank - wolfe algorithm enjoys similar convergence guarantees to the distributed proximal gradient descent @xcite , that is , after @xmath140 iterations , the solution will be @xmath71 suboptimal .",
    "it is sufficient to prove that at every iteration , the current projection matrix @xmath84 and the subspace to be added @xmath89 are orthogonal to each other .",
    "note that by the optimality condition : @xmath141 since @xmath89 is the leading left singular vector of @xmath88 , we have @xmath142 .",
    "each column of @xmath84 has unit length , since it is a left singular vector of some matrix .",
    "it is sufficient to prove that the largest eigenvalue of @xmath143 does not exceed @xmath21 .",
    "since @xmath143 is a block diagonal matrix , it is sufficient to show that for every block @xmath144 $ ] , the largest eigenvalue of the block @xmath145 is not larger than @xmath21 .",
    "this is true by the @xmath21-smoothness of @xmath19 and the fact that the data points have bounded length : @xmath146",
    "by the smoothness of @xmath147 , we know @xmath148 let @xmath149 .",
    "since @xmath85 is a minimizer of @xmath150 with respect to @xmath85 , we have @xmath151 and therefore @xmath152 . from convexity of @xmath153",
    ", we have @xmath154 combining with the display above @xmath155 by choosing @xmath156 we have @xmath157 using lemma [ lemma : recursion ] in appendix we know that after @xmath158 iterations , we have @xmath159 .",
    "( lemma b.2 of @xcite ) let @xmath160 and let @xmath161 be a sequence such that @xmath162 for all @xmath53 .",
    "let @xmath71 be a positive scalar and @xmath53 be a positive integer such that @xmath163",
    ". then @xmath164 .",
    "[ lemma : recursion ]",
    "we also evaluate discussed algorithms on several real world data sets , with @xmath165 of the whole dataset as training set , @xmath165 as held - out validation , then report the testing performance on the remaining @xmath166 . for the real data ,",
    "we have observed that adding @xmath167 regularization usually helps improving the generalization performance . for the",
    "` local ` procedure we added an @xmath167 regularization term ( leads to ridge regression or @xmath167 regularized logistic regression ) . for ` dgsp ` and ` dnsp ` , we also add an @xmath167 regularization in finding the subspaces and refitting .",
    "we have worked on the following multi - task learning datasets :    * school . *",
    "the dataset consists of examination scores of students from london s secondary schools during the years 1985 , 1986 , 1987 .",
    "there are 27 school - specific and student - specific features to describe each student .",
    "the instances are divided by different schools , and the task is to predict the students performance .",
    "we only considered schools with at least @xmath168 records , which results in 72 tasks in total .",
    "the maximum number of records for each individual school is 260 .    *",
    "computer survey . *",
    "the data is taken from a conjoint analysis experiment @xcite which surveyed 180 persons about the probability of purchasing 20 kinds of personal computers .",
    "there are 14 variables for each computer , the response is an integer rating with scale @xmath169 .",
    "the task here is to predict the airline ticket price @xcite .",
    "we are interested in the minimum prices next day for some specific observation date and departure date pairs .",
    "each case is described by 411 features , and there are 6 target minimum prices for different airlines to predict .",
    "the sample size is 337",
    ".    * protein . * given the amino acid sequence , we are interested predicting the protein secondary structure @xcite .",
    "we tackle the problem by considering the following three binary classification tasks : coil vs helix , helix vs strand , strand vs coil .",
    "each sequence is described by 357 features .",
    "there are 24,387 instances in total .",
    "* landmine . *",
    "the data is collected from 19 landmine detection tasks @xcite . each landmine field",
    "is represented by a 9-dimensional vector extracted from radar images , containing moment - based , correlation - based , energy ratio , and spatial variance features .",
    "the sample size for each task varies from 445 to 690 .",
    "* this music dataset @xcite consists of 502 songs , where for each song 68 features are extracted .",
    "each task is to predict whether a particular musically relevant semantic keyword should be an annotation for the song .",
    "we only consider tags with at least 50 times apperance , which results in 78 prediction tasks .    0",
    "the dataset was used in @xcite .",
    "the optical character recognition data were gathered by the mit spoken language systems group .",
    "each character is represented by @xmath170 binary pixels .",
    "we consider 9 binary classification task : c vs e , g vs y , g vs s , m vs n , a vs g , i vs j , a vs o , f vs t , h vs n , following the setting of @xcite .",
    "* this is a handwritten digit recognition dataset , gathered from envelopes by the u.s .",
    "postal service .",
    "each image is represented by @xmath171 pixels .",
    "we consider the following 5 binary classification task : 2 vs 4 , 0 vs 9 , 3 vs 5 , 1 vs 7 , 6 vs 8 .",
    "* 20 newsgroups .",
    "* this is a collection of 16,242 newsgroup documents , we uses the appearance of @xmath168 words to represent each document , the goal is to classify them into 4 meta - groups .",
    "we compared various approaches as in the simulation study , except the ` bestrep ` as the best low - dimensional representation is unknown . we also compared with ` altmin ` , which learns low - rank prediction matrix using the alternating minimization @xcite .",
    "the results are shown in figure [ fig : real_data ] . since the labels for the real world classification datasets are often unbalanced , we report averaged area under the curve ( auc ) instead of classification accuracy .",
    "we have the following observations :    * the distributed first - order approaches converge much slower than in simulations , especially on atp and cal500 .",
    "we suspect this is because in the simulation study , the generated data are usually well conditioned , which makes faster convergence possible for such methods @xcite . on real data , the condition number can be much worse . * in most case , ` dnsp ` is the best in terms of communication - efficiency . `",
    "dgsp ` also has reasonable performance with fewer round of communications compared to distributed first - order approaches .",
    "* among the first - order distributed convex optimization methods , ` accproxgd ` is overall the most communication - efficient , while ` dfw ` is the worst , though it might have some advantages in terms of computation .",
    "also , we observed significant zig - zag behavior of the ` dfw ` algorithm , as discussed in @xcite ."
  ],
  "abstract_text": [
    "<S> we study the problem of distributed multi - task learning with shared representation , where each machine aims to learn a separate , but related , task in an unknown shared low - dimensional subspaces , i.e.  when the predictor matrix has low rank . </S>",
    "<S> we consider a setting where each task is handled by a different machine , with samples for the task available locally on the machine , and study communication - efficient methods for exploiting the shared structure . </S>"
  ]
}