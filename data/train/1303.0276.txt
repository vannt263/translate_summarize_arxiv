{
  "article_text": [
    "multicore hardware is now ubiquitous . programming these multicore processors is still a challenging task due to bugs resulting from concurrency and synchronization .",
    "although there is widespread acknowledgement of difficulties in programming these systems , it is surprising that by and large the most prevalent methods of dealing with synchronization are based on ideas that were developed in early 70 s @xcite .",
    "for example , the most widely used threads package in c++ @xcite , pthreads @xcite , and the most widely used threads package in java @xcite , java.util.concurrent @xcite , are based on the notion of monitors @xcite(or semaphores @xcite ) . in this paper",
    ", we propose a new method called _ autosynch _ based on automatic signaling monitor that allows gains in productivity of the programmer as well as gain in performance of the system .",
    "both pthreads and java require programmers to explicitly signal threads that may be waiting on certain condition .",
    "the programmer has to explicitly declare condition variables and then signal one or all of the threads when the associated condition becomes true . using the wrong waiting notification ( _ signal _ versus",
    "_ signalall _ or notify versus notifyall ) is a frequent source of bugs in java multithreaded programs . in our proposed approach ,",
    "_ autosynch _ , there is no notion of condition variables and it is the responsibility of the system to signal appropriate threads .",
    "this feature significantly reduces the program size and complexity .",
    "in addition , it allows us to completely eliminate signaling more than one thread resulting in reduced context switches and better performance .",
    "the idea of automatic signaling was initially explored by hoare in @xcite , but rejected in favor of condition variables due to efficiency considerations . the belief that automatic signaling is extremely inefficient compared to explicit signaling is widely held since then and all prevalent concurrent languages based on monitors use explicit signaling .",
    "for example , buhr , fortier , and coffin claim that automatic monitors are @xmath0 to @xmath1 times slower than explicit signals @xcite .",
    "the reason for this drastic slowdown in previous implementations of automatic monitor is that they evaluate all possible conditions on which threads are waiting whenever the monitor becomes available .",
    "we show in this paper that the widely held belief is wrong .    with careful analysis of the conditions on which the threads are waiting and evaluating as few conditions as possible , automatic",
    "signaling can be as efficient as explicit signaling . in _ autosynch _ , the programmer simply specifies the predicate @xmath2 on which the thread is waiting using the construct _",
    "waituntil(p ) _ statement .",
    "when a thread executes the statement , it checks whether @xmath2 is true .",
    "if it is true , the thread can continue ; otherwise , the thread must wait for the system to signal it .",
    "the _ autosynch _",
    "system has a condition manager that is responsible for determining which thread to signal by analyzing the predicates and the state of the shared object .",
    "[ fig : bb_exp ] shows the difference between the java and the _ autosynch _ implementation for the parameterized bounded - buffer problem , a variant bounded - buffer problem ( also known as the producer - consumer problem ) @xcite . in this problem , producers put items into the shared buffer , while consumers take items out of the buffer .",
    "the _ put _ function has a parameter @xmath3 ; the _ take _ function has a parameter , _ num _ , indicating the number of items taken .",
    "there are two requirements for synchronization .",
    "first , every operation on a shared variable , such as _ buff _ , should be done under mutual exclusion .",
    "second , we need _ conditional synchronization _ ; a producer must wait when the buffer has no sufficient space , and a consumer must wait when the buffer has no sufficient items .",
    "the explicit - signal bounded - buffer is written in java .",
    "a lock variable and two associated condition variables are used to maintain mutual exclusion and conditional synchronization . a thread needs to acquire the lock before entering member functions .",
    "in addition , programmers need to explicitly associate conditional predicates with condition variables and call _ signal _ ( _ signalall _ ) or _ await _ statement manually .",
    "note that , the _ unlock _",
    "statement should be done in a _ finally _ block , _ try _ and _ catch _ blocks are also need for the _ interruptedexception _ that may be thrown by _",
    "await_. however , for simplicity , we avoid the exception handling in fig .",
    "[ fig : bb_exp ] . the automatic - signal bounded - buffer",
    "is written using _",
    "autosynch _ framework . as in line @xmath4",
    ", we use _ autosynch _ modifier to indicate that the class is a monitor , all member functions of the class is mutual exclusion . for conditional synchronization",
    ", we use _ waituntil _ as in line 9 .",
    "there are no _ signal _ or _ signalall _ calls in the _ autosynch _ program .",
    "clearly , the automatic - signal monitor is much simpler than the explicit - signal monitor .",
    "2    ....          class boundedbuffer {            object [ ] buff ;              int putptr , takeptr , count ;            lock mutex = new reentrantlock ( ) ;            condition insufficientspace = mutex.newcondition ( ) ;            condition insufficientitem = mutex.newcondition ( ) ;            public boundedbuffer(int n ) {              buff = new object[n ] ;              putptr = takeptr = count = 0 ;            }            public void put(object [ ] items ) {              mutex.lock ( ) ;              while ( items.length + count > buff.length ) {                insufficientspace.await ( ) ;              }              for ( int i = 0 ; i < items.length ; i++ ) {                buff[putptr++ ] = items[i ] ;                putptr % = buff.length ;              }              count + = items.length ;              insufficientitem.signalall ( ) ;              mutex.unlock ( ) ;            }            public object [ ] take(int num ) {              mutex.lock ( ) ;              while ( count < num ) {                insufficientitem.await ( ) ;              }              object [ ] ret = new object[num ] ;              for ( int i = 0 ; i < num ; i++ ) {                ret[i ] = buff[takeptr++ ] ;                takeptr % = buff.length ;              }              count -= num ;              insufficientspace.signalall ( ) ;              mutex.unlock ( ) ;              return ret ;            }          }       ....    ....          autosynch class boundedbuffer {             object [ ] buff ;             int putptr , takeptr , count ;             public boundedbuffer(int n ) {              buff = new object[n ] ;              putptr = takeptr = count = 0 ;            }            public void put(object [ ] items ) {               waituntil(count + items.length < = buff.length ) ;               for ( int i = 0 ; i < items.length ; i++ ) {                buff[putptr++ ] = items[i ] ;                putptr % = buff.length ;              }              count + = items.length ;             }             public object [ ] take(int num ) {               waituntil(count > = num ) ;              object [ ] ret = new object[num ] ;              for ( int i = 0 ; i < num ; i++ ) {                ret[i ] = buff[takeptr++ ] ;                 takeptr % = buff.length ;               }              count -= num ;              return ret ;            }          }       ....        to facilitate the automatic - signal mechanism in java , we have implemented the framework of _ autosynch _ illustrated in fig .",
    "[ fig : fw ] .",
    "the framework is composed of a preprocessor and a java condition manager library .",
    "the preprocessor translates _ autosynch _ code into traditional java code . our automatic - signal mechanism and",
    "developed techniques were implemented in the java condition manager library , which is responsible for monitoring the state of the monitor object and signaling an appropriate thread .    in this paper , we argue that automatic signaling is generally as fast as explicit signaling ( and even faster for some examples ) . in section [ sec :",
    "sigall ] , we give reasons for the efficiency of automatic signaling . in short , the explicit",
    "signaling has to resort to _ signalall _ in some examples ; however , our automatic signaling never uses _",
    "signalall_. thus _ autosynch _ is considerably faster for synchronization problems with _",
    "the design principle underlying _ autosynch _ is to reduce the number of context switches and predicate evaluations .    *",
    "context switch : * a context switch requires a certain amount of time to save and load registers and update various tables and lists . reducing unnecessary context switches boosts the performance of the system .",
    "signalall _ call introduces unnecessary context switches ; therefore , _ signalall _ calls are never used in _",
    "* predicate evaluation : * in the automatic - signal mechanism , signaling a thread is the responsibility of the system .",
    "the number of predicate evaluations is crucial for efficiency in deciding which thread should be signaled . by analyzing the structure of the predicate , our system reduces the number of predicate evaluations .",
    "there are three important novel concepts in _ autosynch _ that enables efficient automatic signaling  _ globalization of predicates , relay invariance _ , and _",
    "predicate tagging_.    the technique of _ globalization _ of a predicate @xmath2 is used to reduce the number of context switches for its evaluation . in the current systems ,",
    "only the thread that is waiting for the predicate @xmath2 can evaluate it . when the thread is signaled , it wakes up , acquires the lock to the monitor and then evaluates the predicate @xmath2 .",
    "if the predicate @xmath2 is false , it goes back to wait resulting in an additional context switch . in _ autosynch _",
    "system , the thread that is in the monitor evaluates the condition for the waiting thread and wakes it only if the condition is true .",
    "since the predicate @xmath2 may use variables local to the thread waiting on it , _ autosynch _ system derives a globalization predicate @xmath5 of the predicate @xmath2 , such that other threads can evaluate @xmath5 .",
    "the details of globalization are in section [ sec : globalization ] .",
    "the idea of _ relay invariance _ is used to avoid _ signalall _ calls in _",
    "autosynch_. the relay invariance ensures that if there is any thread whose waiting condition is true , then there exists at least one thread whose waiting condition is true and is signaled by the system . with this invariance ,",
    "the _ signalall _ call is unnecessary in our automatic - signal mechanism .",
    "this mechanism reduces the number of context switches by avoiding _",
    "the details of this approach are in section [ sec : relay ] .",
    "the idea of _ predicate tagging _ is used to accelerate the process of deciding which thread to signal .",
    "all the waiting conditions are analyzed and tags are assigned to every predicate according to its semantics .",
    "to decide which thread should be signaled , we identify tags that are most likely to be true after examining the current state of the monitor .",
    "then we only evaluate the predicates with those tags .",
    "the details of predicate tagging are in section [ sec : tag ] .",
    "our experimental results indicate that _ autosynch _ can significantly improve performance compared to other automatic - signal mechanisms @xcite . in @xcite",
    "the automatic - signal mechanism is 10 - 50 times slower than the explicit - signal mechanism ; however , _",
    "autosynch _ is only 2.6 times slower than the explicit - signal mechanism even in the worst case of our experiment results .",
    "furthermore , _ autosynch _ is 26.9 times faster than the explicit - signal mechanism in the parameterized bounded - buffer problem that relies on _ signalall _ calls . besides",
    ", the experimental results also show that _ autosynch _ is scalable ; the performance of _ autosynch _ is stable even if the number of threads increases for many problems conducted in the paper .",
    "although the experiment results show that _ autosynch _ is 2.6 times slower than the explicit - signal mechanism in the worst case , it is still desirable to have automatic signaling",
    ". first , automatic signaling simplifies the task of concurrent programming .",
    "in explicit - signal monitor , it is the responsibility of programmers to explicitly invoke a _ signal _ call on some condition variable for conditional synchronization . using the wrong notification , and signaling a wrong condition variable are frequent sources of bugs .",
    "the idea is analogous to automatic garbage collection .",
    "although garbage collection leads to decreased performance because of the overhead in deciding which memory to free , programmers avoid manual memory deallocation . as a consequence ,",
    "memory leaks and certain bugs , such as dangling pointers and double free bugs , are reduced .",
    "similarly , automatic - signal mechanism consumes computing resources in deciding which thread to be signaled ; programmers avoid explicitly invoking _ signal _ calls . as a result ,",
    "some bugs , such as using wrong notification and signaling a wrong condition variable , are eliminated .",
    "secondly , in explicit - signal monitor , the principle of separation of concerns is violated . any method that changes",
    "the state of the monitor must be aware of all the conditions , which other threads could be waiting for , in other methods of the monitor .",
    "the intricate relation between threads for conditional synchronization breaks the modularity and encapsulation of programming . finally , _",
    "autosynch _ can provide rapid prototyping in developing programs and accelerating product time to market .",
    "moreover , a correct automatic - signal implementation is helpful in debugging an explicit - signal implementation .",
    "although this paper focuses on java , our techniques are also applicable to other programming languages and models , such as pthread and c # @xcite .",
    "this paper is organized as follows .",
    "section [ sec : bg ] gives the background of the monitor .",
    "section [ sec : sigall ] explains why _ signalall _ is required for explicit - signal monitor but not automatic - signal monitor .",
    "the concepts of _ autosynch _ are presented in section [ sec : concept ] and the practical implementation details are discussed in section [ sec : imp ] .",
    "the proposed methods are then evaluated with experiments in section [ sec : eval ] .",
    "section [ sec : conclu ] gives the concluding remarks .",
    "monitor is an abstract object or module containing shared data to be used safely by multiple threads in concurrent programming .",
    "monitor can be defined by two characteristics , mutual exclusion and conditional synchronization .",
    "mutual exclusion guarantees that at most one thread can execute any member function of a monitor at any time .",
    "threads acquire the lock of the monitor to acquire the privilege for accessing it .",
    "conditional synchronization maintains the execution order between threads .",
    "threads may wait for some condition to be met and release the monitor lock temporarily .",
    "after the condition has been met , threads then re - acquire the lock and continue to execute . according to buhr and harji @xcite ,",
    "monitors can be divided into two categories according to the different implementations of conditional synchronization .    *",
    "explicit - signal monitor * in this type of monitor , condition variables , _ signal _ and _ await _ statements are used for synchronization .",
    "programmers need to associate assertions with condition variables manually .",
    "this mechanism involves two or more threads .",
    "a thread waits on some condition variable if its predicate is not true .",
    "when another thread detects that the state has changed and the predicate is true , it explicitly signals the appropriate condition variable .    *",
    "automatic - signal ( implicit - signal ) monitor * this kind of monitor uses _ waituntil _ statements , such as line 9 in automatic - signal program in fig .  [",
    "fig : bb_exp ] , instead of condition variables for synchronization .",
    "programmers do not need to associate assertions with variables , but use _ waituntil _ statements directly . in monitor",
    ", a thread will wait as long as the condition of a _ waituntil _",
    "statement is false , and execute the remaining tasks only after the condition becomes true .",
    "the responsibility of signaling a waiting thread is that of the system rather than of the programmers .",
    "the _ signalall _ call is essential in explicit - signal mechanism when programmers do not know which thread should be signaled . in fig .",
    "[ fig : bb_exp ] , a producer must wait if there is no space to put @xmath6 items , while a consumer has to wait when the buffer has insufficient items . since producers and consumers can put and take different numbers of items every time , they may wait on different conditions to be met .",
    "programmers do not know which producer or consumer should be signaled at runtime .",
    "therefore , the _ signalall _ call is used instead of _ signal _ calls in line @xmath7 and @xmath8 .",
    "although programmers can avoid using _ signalall _ calls by writing complicated code that associates different conditions to different condition variables ; the complicated code makes the maintenance of the program bad .",
    "the _ signalall _ call is expensive ; it may decreases the performance because it introduces redundant context switches , requiring computing time to save and load registers and update various tables and lists .",
    "furthermore , _ signalall _ calls can not increase parallelism because threads are forbidden to access a monitor simultaneously .",
    "although multiple threads are signaled at a time , only one thread is able to acquire the monitor .",
    "other threads may need to go back to waiting state since another thread may change the status of the monitor .",
    "suppose in fig .",
    "[ fig : bb_exp ] , the buffer has 64 items after a producer finishes a put call .",
    "the producer calls _ insufficientitem.signalall ( ) _ in line @xmath7 before completing the call .",
    "@xmath0 waiting consumers are signaled ; each of them is waiting to take @xmath9 items .",
    "suppose the consumer @xmath10 re - acquires the lock first and takes @xmath9 items .",
    "the remaining items , @xmath11 , are insufficient for the other threads ; they make context switches , re - evaluate their predicates , and go back to waiting state .",
    "theses context switches are redundant since the @xmath12 threads do not make any progress but only go back to waiting state . therefore ,",
    "if we avoid using the _ signalall _ call and only signal a thread that is most likely to make progress , the unnecessary context switches can be reduced .",
    "in _ autosynch _ , it is the responsibility of the system to signal appropriate threads automatically .",
    "the predicate evaluation is crucial in deciding which thread should be signaled .",
    "we discuss how to preform predicate evaluations of _ waituntil _ statements .",
    "a predicate @xmath13 is a boolean condition , where @xmath14 is the space spanned by the variables @xmath15 .",
    "a variable of a monitor object is a shared variable if it is accessible by every thread that is accessing the monitor .",
    "the set of shared variables is denoted by @xmath16 .",
    "the set of local variables , denoted by @xmath17 , is accessible only by a thread calling a function in which the variables are declared .",
    "predicates can be used to describe the properties of conditions . in our approach , every condition of _ waituntil _ statement is represented by a predicate .",
    "we say a condition has been met if its representing predicate is true ; otherwise , the predicate is false .",
    "furthermore , we assume that every predicate , @xmath18 , is in disjunctive normal form ( dnf ) , where @xmath19 is defined as the conjunction of a set of atomic boolean expressions . for example , a predicate @xmath20 is dnf , where @xmath21 and @xmath22 .",
    "note that , every boolean formula can be converted into dnf using de morgan s laws and distributive law .    predicates can be divided into two categories based on the type of their variables @xcite .",
    "consider a predicate @xmath13 . if @xmath23 , @xmath2 is a shared predicate .",
    "otherwise , it is a complex predicate .",
    "the automatic - signal monitor has an efficient implementation @xcite by limiting the predicate of a _ waituntil _ to a shared predicate ; however , we do not limit the predicate of a _ waituntil _ statement to a shared predicate .",
    "the reason is that this limitation will lead _ autosynch _ to be less attractive and practical since conditions including local variables can not be represented in _",
    "autosynch_.    evaluating",
    "a complex predicate in all threads is unattainable because the accessibility of the local variables in the predicate is limited to the thread declaring them . to evaluate a complex predicate in all threads , we treat local variables as constant values at runtime and define globalization as follows .    given a complex predicate @xmath24 , where @xmath25 and @xmath26 .",
    "the globalization of @xmath2 at runtime * t * is the new shared predicate @xmath27 where @xmath28 is the values of @xmath29 at runtime * t*.    the globalization can be applied to any complex predicate ; a shared predicate can be derived from the globalization .",
    "for example , in fig .",
    "[ fig : bb_exp ] , the consumer @xmath10 wants to take @xmath9 items at some instant of time . applying the globalization to the complex predicate @xmath30 in line 19",
    ", we derive the shared predicate @xmath31 .",
    "the following proposition shows that the complex predicate evaluation of _ waituntil _ statement in all threads can be achieved through the globalization .",
    "[ pro : glob ] consider a complex predicate @xmath32 in a * waituntil * statement . @xmath32 and",
    "its globalization @xmath33 are semantically equivalent during the * waituntil * period , where @xmath34 is the time instant immediately before invoking the * waituntil * statement .",
    "only the thread invoking the _ waituntil _ statement can access the local variables of the predicate ; all other threads are unable to change the values of those local variables .",
    "therefore , the value of @xmath29 can not be changed during the _ waituntil _ period . since @xmath28 is the value of @xmath29 immediately before invoking the _ waituntil _ statement , @xmath32 and @xmath33 are semantic equivalent during the _ waituntil _ period .",
    "proposition [ pro : glob ] enables the complex predicate evaluation of _ waituntil _ statement in all threads .",
    "given a complex predicate in a _ waituntil _ statement , in the sequel we substitute all the local variables with their values immediately before invoking the statement .",
    "the predicate can now be evaluated in all other threads during the _ waituntil _ period .      as mentioned in section  [ sec : sigall ] , _ signalall _ calls are sometimes unavoidable in the explicit - signal mechanism . in _ autosynch _ , _ signalall _ calls are avoided by providing the _ relay invariance_.    consider a thread that tries to access a monitor .",
    "if it is not waiting in a _ waituntil _ statement or has been signaled , then it is an _ active _ thread for the monitor .",
    "otherwise , it is an _ inactive _ thread .",
    "if there is a thread waiting for a predicate that is true , then there is at least one active thread ; i.e. , suppose @xmath35 is the set of waiting threads whose conditions have become true , @xmath36 is the set of active threads , then @xmath37 holds at all time .",
    "_ autosynch _ uses the following mechanism for signaling .",
    "_ relay signaling rule _ : when a thread exits a monitor or goes into waiting state , it checks whether there is some thread waiting on a condition that has been true .",
    "if at least one such waiting thread exists , it signals that thread .",
    "[ pro : relay_signal ] the relay signaling rule guarantees relay invariance .",
    "suppose a thread @xmath38 is waiting on the predicate @xmath2 that is true .",
    "since @xmath38 is waiting on @xmath2 , @xmath2 must be false before @xmath38 went to waiting state .",
    "there must exist another active thread @xmath39 after @xmath38 such that @xmath39 changed the state of the monitor and made @xmath2 true . according to the rule",
    ", @xmath39 must signal @xmath38 or another thread waiting for a condition that is true before leaving the monitor or going into waiting state .",
    "the thread signaled by @xmath39 then becomes active .",
    "therefore , the relay invariance holds .",
    "the concept behind relay invariance is that , the privilege to enter the monitor is transmitted from one thread to another thread whose condition has become true .",
    "for example , in fig .",
    "[ fig : bb_exp ] , the consumer @xmath10 tries to take @xmath40 items ; however , only @xmath41 items are in the buffer at this moment .",
    "then , @xmath10 waits for the predicate @xmath42 to be true .",
    "a producer , @xmath43 , becomes active after @xmath10 ; @xmath43 puts @xmath11 items into the buffer and then leaves the monitor . before leaving",
    ", @xmath43 finds that @xmath2 is true and then signals @xmath10 ; therefore , @xmath10 becomes active again and takes @xmath40 items of the buffer .",
    "proposition [ pro : relay_signal ] shows that the relay invariance holds in our automatic - signaling mechanism .",
    "thus , _ signalall _ calls are avoidable in _",
    "autosynch_. the problem is now reduced to finding a thread waiting for a condition that is true .      in order to efficiently find an appropriate thread waiting for a predicate that is true , we analyze every waiting condition and assign different tags to every predicate according to its semantics .",
    "these tags help us prune predicates that are not true by examining the state of the monitor .",
    "the idea behind the predicate tag is that , local variables can not be changed during the _ waituntil _ period ; thus the values of local variables are used as keys when we evaluate predicates .",
    "first , we define two types of predicates according to their semantics .",
    "consider an expression @xmath44 , where @xmath45 represents one of the primitive data types in java .",
    "if @xmath46 , then @xmath47 is a local expression . otherwise , if @xmath25 , @xmath47 is a shared expression .",
    "we use @xmath48 to denote a shared expression , and @xmath49 to denote a local expression .",
    "a predicate @xmath50 is an equivalence predicate .",
    "a predicate @xmath51 is a threshold predicate , where @xmath52 .",
    "note that , many predicates that are not equivalence or threshold predicates can be transformed into them .",
    "consider the predicate @xmath53 , where @xmath54 and @xmath55 .",
    "this predicate is equivalent to @xmath56 which is an equivalence predicate .",
    "thus , these two types of predicates can represent a wide range of conditions in synchronization problems .",
    "given an equivalence or a threshold predicate , we can apply the _ globalization _ operation to derive a constant value on the right hand side of the predicate . in _ autosynch _",
    ", there are three types of tags , @xmath57 , @xmath58 , and @xmath59 .",
    "every @xmath57 or @xmath58 tag represents an equivalence predicate or a threshold predicate , respectively . if the predicate is neither equivalence nor threshold , it acquires the @xmath59 tag . for example , consider the @xmath58 predicate @xmath60 where @xmath61 and @xmath62 are local variables with values @xmath63 and @xmath64 .",
    "we first use the globalization to convert it to @xmath65 , which is represented by the tag @xmath66 .",
    "the formal definition of tag is as follows .",
    "a tag is a four - tuple @xmath67 , where    * @xmath68 ; * @xmath69 is a shared expression if @xmath70 ; otherwise , @xmath71 ; * @xmath72 is the value of a local expression after applying globalization if @xmath70 ; otherwise , @xmath73 ; * @xmath74 if @xmath75 ; otherwise , @xmath76 .",
    "we say that a tag is true ( false ) if the predicate representing the tag is true ( false ) .      a tag is assigned to every conjunction .",
    "the tags of conjunctions of a predicate constitute the set of tags of the predicate .",
    "tags are given to every predicate by the algorithm shown in fig .",
    "[ fig : tagging ] .",
    "when assigning a tag to a conjunction , the equivalence tag has the highest priority .",
    "the reason is that the set of values to make an equivalence predicate true is smaller than the set of values to make a threshold predicate true .",
    "the equivalence predicate is true only when its shared expression equals a specific value .",
    "for example , consider an equivalence predicate @xmath77 and a threshold predicate @xmath78 .",
    "the predicate @xmath77 is true only when the value of @xmath79 is @xmath80 , whereas @xmath78 is true for a much larger set of values .",
    "therefore , the @xmath57 tags can help us prune predicates that are false more efficiently than other kinds of tags .",
    "if a conjunction does not include any equivalence predicate , then we check whether it includes any threshold predicate .",
    "if yes , then a @xmath58 tag is assigned to the conjunction ; otherwise , the conjunction has a @xmath59 tag .",
    "....           tags = empty           foreach conjunction c              if c contains an equivalence predicate se = le               tag t = ( equivalence , se , globalization(le ) , null )             else if c contains a threshold predicate se op le               tag t = ( threshold , se , globalization(le ) , op )             else                tag t = ( none , null , null , null )              add t to tags            return tags       ....    creating all tags for a conjunction is unnecessary .",
    "if a conjunction includes multiple equivalence predicates or threshold predicates , only one arbitrary @xmath57 tag or @xmath58 tag is assigned to the conjunction .",
    "if there are a large number of tags , then the performance may decrease because of the cost of maintaining tags . as a result , we assign only one tag to every conjunction . assigning multiple tags to a conjunction can not accelerate the searching process .",
    "for example , consider a conjunction @xmath81 .",
    "if only a tag @xmath82 is assigned to the conjunction , we check the predicate when the tag is true . adding another tag @xmath83 can not accelerate the searching process since we need to check both the tags .",
    "note that multiple predicates with a shared conjunct may share a tag .",
    "for example , the predicates @xmath84 and @xmath85 would have a shared equivalence tag of @xmath86 .      signaling mechanism is based on tags in _",
    "autosynch_. since the equivalence tag is more efficient in pruning the search space than the threshold tag , the predicates with equivalence are checked prior to the predicates with other tags . if no predicate that is true can be found after checking @xmath57 tags and @xmath58 tags , our algorithm does the exhaustive search for the predicates with a @xmath59 tag .",
    "[ [ equivalence - tag - signaling ] ] equivalence tag signaling : + + + + + + + + + + + + + + + + + + + + + + + + + +    observes that , an equivalence predicate becomes true only when its shared expression equals the specific value of its local expression after applying _",
    "globalization_. for distinct equivalence tags related to the same shared expression , at most one tag can be true at a time because the value of its local expression is deterministic and unique at any time . by observing the value of its local expression ,",
    "the appropriate tag can be identified .",
    "for example , suppose there are three @xmath57 tags for predicates @xmath87 , @xmath88 , and @xmath77 .",
    "we examine @xmath79 and find that its value is @xmath80 .",
    "then we know that only the third predicate @xmath77 is true . based on this observation , for each unique shared expression of an equivalence tag , we create a hash table , where the value of the local expression is used as the key . by using this hash table and evaluating the shared expression at runtime , we can find a tag that is true in @xmath89 time if there is any .",
    "then we check the predicates with the tag .",
    "[ [ threshold - tag - signaling ] ] threshold tag signaling : + + + + + + + + + + + + + + + + + + + + + + + +    consider the following example .",
    "suppose there are two predicates , @xmath90 and @xmath78 .",
    "we know that if @xmath78 is false , then @xmath90 can not be true .",
    "hence , we only need to check the predicate with the smallest local expression value for @xmath91 and @xmath92 operations .",
    "furthermore , consider the predicates with the same local expression value but different operations , @xmath78 and @xmath93 .",
    "the predicate @xmath78 can not be true when @xmath93 is false ; i.e. , we only need to check the predicate @xmath93 .",
    "we use a min - heap data structure for storing the threshold tags related to a same shared expression with @xmath94 . if two predicates have the same local expression value but different operations , then the predicate with @xmath92 is considered to have a smaller value than the predicate with @xmath91 in the min - heap .",
    "similarly , the max - heap can be used for threshold tags with @xmath95 . the signaling mechanism for @xmath58 tag",
    "is shown if fig .",
    "[ fig : th_sig ] . in general , the tag in the root of a heap is checked . if the tag is false , all the descendant nodes are also false",
    "otherwise , all predicates with the tag need to be checked for finding a true predicate . to maintain the correctness ,",
    "if no predicate is true , the tag is removed from the heap temporarily .",
    "then the tag in the position of the new heap root is checked again until a true predicate is found or a false tag is found . those tags removed",
    "temporarily are reinserted to the heap .",
    "the reason to remove the tags is that the descendants of the tags may also be true since the tags are true .",
    "so we also need to check the descendant tags .",
    "for example , consider the predicates @xmath96 and @xmath97 .",
    "@xmath98 has the tag @xmath99 and @xmath100 has the tag @xmath101 .",
    "@xmath102 is the root and @xmath103 is its descendant .",
    "suppose at some time instant @xmath104 , then @xmath102 is false ; thus , there is no need to check @xmath103 .",
    "now , suppose @xmath105 and @xmath106 , then @xmath102 is true .",
    "we check all predicates that have tag @xmath102 .",
    "since @xmath98 is false , no predicate having tag @xmath102 is true .",
    "then @xmath102 is removed form the heap temporarily .",
    "we find the new root @xmath103 is true and @xmath100 that has tag @xmath103 is also true .",
    "we signal a thread waiting for @xmath100 and then add @xmath102 back to the heap .    ....           // peek ( ) : retrieve but does not remvoe the root            // poll ( ) : retrieve and remove the root            list backup = empty ;           tag t = heap.peek ( ) ;           while t is true             foreach predicate p with t               if p is true                 signal a thread waiting on p                 foreach b in backup                    heap.add(b )                 return              backup.insert(heap.poll ( ) )             t = heap.peek ( )           foreach b in backup              heap.add(b )       ....    suppose there are @xmath107 @xmath58 tags for a shared expression with different keys .",
    "suppose that these tags are assigned to @xmath108 predicates .",
    "the time complexity for maintaining the heap is @xmath109 however , the performance is generally much better because we only need to check the predicates of the tags in the root position in the most cases .",
    "the time complexity for finding the root is @xmath89 . in the worst case ,",
    "we need to check all predicates ; thus , the time complexity is @xmath110 .",
    "however , this situation is rare .",
    "furthermore , this algorithm is optimized for evaluating threshold predicates by sacrificing performance in tag management .",
    "the _ autosynch _ implementation involves two parts , the preprocessor and the java library of condition manager .",
    "the preprocessor , built using javacc @xcite , translates _",
    "code to java code .",
    "our signal - mechanism is implemented in the condition manager library that creates condition variables , and maintains the association between predicates and condition variables .",
    "furthermore , predicate tags are also maintained by the condition managers .",
    "it is the responsibility of the condition manager to decide which thread should be signaled .",
    "the _ autosynch _ class provides both mutual exclusion and conditional synchronization . to maintain these two properties",
    ", our preprocessor adds some additional variables for any _ autosynch _ class .",
    "[ fig : pre_cnst ] summarizes the definitions of additional variables in the constructor of an _ autosynch _ class .",
    "the lock variable , @xmath111 , is declared for mutual exclusion , which is acquired at the beginning of every member function and released before the return statement .",
    "in addition , a condition manager , @xmath112 , is declared for synchronization .",
    "the details of the condition manager are discussed in the next section .    ....",
    "lock mutex          conditionmanager condmgr           foreach shared predicate p            tags = analyzepredicate(todnf(p ) )            condmgr.registersharedpredicate(p , tags )          foreach shared expression e            condmgr.registersharedexpression(e )       ....    all predicates are transformed to dnf in the preprocessing process by de morgan s laws and distributive law .",
    "then we analyze predicates to derive their tags .",
    "the condition manager registers the predicates and shared expressions for predicate evaluation .",
    "the shared predicates and shared expressions are identified in the preprocessing stage and added in the constructor of the class as in fig .  [",
    "fig : pre_cnst ] .",
    "we add shared predicates and shared expressions ( but not complex predicates ) in the construct because their semantics is static and never changes .",
    "a complex predicate is registered dynamically because its globalization may change according to the value of its local variables at runtime . in java ,",
    "the shared predicates and shared expressions are created as inner classes that can access the shared variables appearing in them with @xmath113 or @xmath114 functions for the condition manager to evaluate .",
    "the function @xmath113 returns the evaluation of the shared predicate and the function @xmath114 returns the value of the shared expression .    for every member function of an _ autosynch _ class , the _",
    "mutex.lock ( ) _ and _ mutex.unlock ( ) _ are inserted at the beginning of the function and immediately before the _ return _ statement , respectively . in the _ waituntil _ statement ,",
    "the predicate is checked initially .",
    "if it is true , then the thread can continue .",
    "otherwise , the type of predicate is checked .",
    "if the predicate is complex , then we apply globalization to it for deriving a new shared predicate .",
    "then we query the condition manager to determine whether the derived predicate has been added earlier . if not , we add the predicate with its tags to the condition manager .",
    "then , the corresponding condition variable can be obtained by calling _",
    "getcondition ( ) _ function of the condition manager .",
    "the _ relaysignal ( ) _ function maintains relay invariance and signals an appropriate thread .",
    "then , the thread goes into the waiting state until the predicate becomes true . after exiting the waiting state ,",
    "if the predicate is complex and the corresponding condition has no other waiting thread , and then it is deactivated by the condition manager .    ....          if p is false             if p is a complex predicate               p : = globalization(todnf(p ) )              if p is not in condmgr                tags = analyzepredicate(p )                condmgr.registercomplexpredicate(p , tags )            c = condmgr.getcondition(p )            do               condmgr.relaysignal ( )              wait c            while p is false            if p is complex predicate and c has no waiting thread              condmgr.inactive(p )        ....      the condition manager maintains the predicates and condition variables , and provides the signaling mechanism . to avoid creating redundant predicates and condition variables , predicates that have the same meaning",
    "should be mapped to the same condition variable .",
    "two predicates are syntax equivalent if they are identical after applying globalization . a predicate table , which is implemented by a hash table , records predicates and their associated condition variables .        when a predicate is added to the condition manager , its tags are stored in an appropriate data structure depending upon the type of its tag .",
    "[ fig : mgr ] shows an example .",
    "the symbol @xmath115 indicates a condition variable .",
    "the gray blank indicates that the predicate is inactive , that is , no thread waits on it .",
    "a hash table is used for storing equivalence tags with the shared expression @xmath79 . in addition , a min - heap and a max - heap are used for storing threshold tags .    for finding a predicate that is true in fig .",
    "[ fig : mgr ] , the value of the shared expression @xmath79 is evaluated .",
    "we first check the hash table ( with @xmath89 time complexity ) using the value of the shared expression as the key .",
    "if we find a tag in the hash table , then we evaluate predicates that have the tag .",
    "if there exists a predicate is true , then we signal its corresponding condition variable .",
    "otherwise , we check the max - heap and the min - heap . if we find that both tags in the roots are false , we search for the predicates with the @xmath59 tag exhaustively .",
    "if one of these predicates is true we signal the corresponding condition variable . as can be expected , the equivalence and threshold tags are helpful for searching predicates that are true .    a predicate must be removed from the tag once no thread waits on it to avoid unnecessary predicate evaluation .",
    "a threshold tag also needs to be removed once it has no predicate .",
    "predicates may be reused . instead of removing those predicate with no waiting thread , we move those predicate to an inactive list .",
    "if they are used later , then we remove them from the inactive list . otherwise , when the length of the inactive list exceeds some predefined threshold , we remove the oldest predicates from the list .",
    "note that , the shared predicates are never removed since they are static and are added only at the constructor .",
    "we discuss the experiments conducted for evaluating the performance of _ autosynch _ in this section .",
    "we compare the performances of different signaling mechanisms in three sets of classical conditional synchronization problems .",
    "the first set of problems relies on only shared predicates for synchronization .",
    "next , we explore the performance for problems using complex predicates .",
    "finally , we evaluate the problems on which _ signalall _ calls are required in the explicit - signal mechanism .",
    "all of the experiments were conducted on a machine with 16 intel(r ) xeon(r ) x5560 quad core cpus ( 2.80 ghz ) and 64 gbs memory running linux 2.6.18 .",
    "our experiments are _ saturation _ tests @xcite , in which only monitor accessing function is performed .",
    "that is , no extra work is in the monitor or out of the monitor . for every experimental setting ,",
    "we perform 25 times , and remove the best and the worst results .",
    "then we compare the average runtime for different signaling mechanisms .",
    "four implementations using different signaling mechanisms have been compared .",
    "explicit - signal : :    using the original java explicit - signal mechanism .",
    "baseline : :    using the automatic - signal mechanism relying on only one condition    variable .",
    "it calls _ signalall _ to wake every waiting thread . then each    waken thread re - evaluates its own predicate after re - acquiring the    monitor . _",
    "autosynch - t _ : :    using the approach described in this paper but excluding predicate    tagging .",
    "_ autosynch _ : :    using the approach described in this paper .",
    "seven conditional synchronization problems are implemented for evaluating our approach .",
    "bounded - buffer @xcite : :    this is the traditional bounded - buffer problem .",
    "every producer waits    if the buffer is full , while every consumer waits if the buffer is    empty .",
    "sleeping barber @xcite : :    the problem is analogous to a barbershop with one barber .",
    "a barber has    number of waiting chairs .",
    "every time when he finishes cut , he checks    whether some customers are waiting . if there are , he cuts hair for one    customer .",
    "if no customers waiting , the barber goes to sleep .",
    "every    customer arrives and checks what the barber is doing .",
    "if the barber is    sleeping , then he wakes the barber and has haircut . otherwise , the    customer checks whether there is any free waiting chair .",
    "if there is ,    the customer waits ; otherwise , the customer leaves .",
    "@xmath116 problem @xcite : :    this is the simulation of water generation .",
    "every @xmath117 atom    waits if there is no @xmath118 atom or another @xmath117    atom .",
    "every @xmath118 atom waits if the number of    @xmath117 atom is less than @xmath64 .",
    "round - robin access pattern : :    every test thread accesses the monitor in round - robin order .",
    "readers / writers @xcite : :    we use the approach given in @xcite , where a ticket is used to    maintain the accessing order of readers and writers . every reader and    writer",
    "gets a ticket number indicating its arrival order .",
    "readers and    writers wait on the monitor for their turn .",
    "dining philosophers @xcite : :    a number of philosophers are siting around at a table with a dish in    front of them and a chopstick in between each philosopher .",
    "a    philosopher needs to pick two chopsticks at the same time for eating    and he does not put down a chopstick until he finishes eating .",
    "a    philosopher that wants to eat must wait if one of his shared    chopsticks is hold by another philosopher .",
    "parameterized bounded - buffer @xcite : :    the parameterized bounded - buffer problem shown in fig .",
    "[ fig : bb_exp ] .      fig .",
    "[ fig : pc_eval ] to [ fig : sb_eval ] plot the results for the bounded - buffer , the @xmath116 , and the sleeping barber problem .",
    "the y - axis shows the runtime in seconds .",
    "the x - axis represents the number of simulating threads .",
    "note that , in the @xmath116 problem , only one thread simulating an @xmath118 atom . the x - axis represents the number of thread simulating @xmath117 atoms . as expected ,",
    "the baseline is much slower than other three signaling mechanisms , which have similar performance in the bounded - buffer problem and the @xmath116 problem .",
    "this phenomenon can be explained as follows .",
    "there is only a constant number of shared predicates in _ waituntil _",
    "statements for automatic - signal mechanisms . for example , in the bounded - buffer problem , there are two _ waituntil _ statements with global predicates , _",
    "count @xmath91 0 _ ( not empty condition ) and _ count @xmath119 buff.length_ ( not full condition ) .",
    "therefore , the complexity for signaling a thread in _ autosynch _ and _ autosynch - t _ is also constant .",
    "hence , both _",
    "autosynch _ and _ autosynch - t _ are as efficient as the explicit - signal mechanism .",
    "an interesting point is that the performance of the baseline is as efficient as others in the sleeping barber problem .",
    "the reason is that the _ signalall _ calls of the baseline do not increase the number of context switches .",
    "whenever a signaled customer re - acquires the monitor , he can have a haircut since the previous customer has had haircut .",
    "these experiments illustrate that the automatic - signal mechanisms are as efficient as the explicit - signal mechanisms for synchronization problems relying on only shared predicates .",
    "problem , width=264 ]        fig .",
    "[ fig : rr_eval ] to [ fig : dp_eval ] presents the experimental results for the round - robin access pattern , the readers / writers problem , and the dining philosophers problem .",
    "the result of the baseline is not plotted in these figures since its performance is extremely inefficient in comparison to other mechanisms . in this set of experiments ,",
    "the explicit - signal mechanism has an advantage since it can explicitly signal the next thread to enter the monitor .",
    "for example , in the round - robin access patter , an array of condition variables is used for associating the i d of each thread and its condition variable .",
    "each thread waits on its condition variable until its turn .",
    "when a thread leaves the monitor , it signals the condition variable of the next thread .",
    "as can be seen , the performance of explicit - signal mechanism is steady as the number of thread increases in the round - robin access pattern and the reader / writers problem . in _ autosynch - t _ , its runtime increases significantly as the number of thread increase . for _ autosynch _ , the performance is slower than the explicit - signal mechanism between 1.2 to 2.6 times for the round - robin access pattern .",
    "however , the performance of _ autosynch _ does not decrease as the number of threads increases .",
    "note that , in the readers / writers problem , the _ autosynch - t _ is more efficient than _ autosynch _ when the number of threads is small .",
    "the reason is that _ autosynch _ sacrifices performance for maintaining predicate tags .",
    "the benefit of predicate tagging increases as the number of threads increases .",
    "another interesting point is that the performance of the explicit signal mechanism does not outperform implicit signal mechanisms much in the dining philosophers problem .",
    "the reason is that a philosopher only competes with two other philosophers sitting near him even when the number of philosophers increases .",
    "table [ tab : cpu ] presents the cpu usage ( profiled by yourkit @xcite ) for the round - robin access pattern with 128 threads .",
    "relaysignal _ is the process of deciding which thread should be signaled in both _",
    "autosynch _ and _ autosynch - t_. _ tag mger _ is the computation for maintaining predicate tags in _ autosynch_. as can be seen , the predicate tagging significantly improves the process for finding a predicate that is true .",
    "the cpu time of _ relaysingal _ process is reduced @xmath120 with a slightly cost in tag management .    [ cols=\"^,^,^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     in fig .",
    "[ fig : rpc_eval ] , we compare the results of the parameterized bounded - buffer in which _ signalall _ calls are required in the explicit - signal mechanism . in this experiment , there is one producer , which randomly puts 1 to 128 items every time .",
    "the y - axis indicates the number of consumers .",
    "every consumer randomly takes 1 to 128 items every time .",
    "as can be seen , the performance of the explicit - signal mechanism decreases as the number of consumers increases .",
    "_ autosynch _ outperforms the explicit - signal mechanism by 26.9 times when the number of thread is 256 .",
    "this can be explained by fig .  [",
    "fig : csrpc_eval ] that depicts the number of contexts switches .",
    "the number of context switches increases in the explicit - signal mechanism in which the number of context switches is around 2.7 millions when thread is 256 .",
    "however , the numbers of context switches are stable in _ autosynch _ even the number of threads increase .",
    "it has around 5440 context switches when the number of thread is 256 .",
    "this experiment demonstrates that the number of context switches can be dramatically reduced and the performance can be increased in _",
    "autosynch _ for the problems required _ signalall _ calls in the explicit - signal mechanism .",
    "in this paper , we have proposed _ autosynch _ framework that supports automatic - signal mechanism with _",
    "autosynch _ class and _ waituntil _ statement .",
    "_ autosynch _ uses the _ globalization _ operation to enable the complex predicate evaluation in every thread .",
    "next , it provides _ relay invariance _ that some thread waiting for a condition has met is always signaled to avoid _ signalall _ calls .",
    "_ autosynch _ also uses predicate tag to accelerate the process in deciding which thread should be signaled .    to evaluate the effectiveness of _ autosynch _ , we built a prototype implementation using javacc @xcite , java compiler compiler , and applied it to seven conditional synchronization problems .",
    "the experimental results indicate that _ autosynch _ implementations of these problems perform significantly better than other automatic - signal monitors .",
    "even though _ autosynch _ is around 2.6 times slower than the explicit in the worst case of our experiments , _ autosynch _ is around 26.9 times faster than the explicit - signal in the parameterized bounded - buffer problem that relies on _ signalall _ calls .    in the future",
    ", we plan to optimize our framework through using the architecture information .",
    "for example , we can get the number of cores of a machine , and then limit the number of executing threads to avoid unnecessary contention .",
    "our current implementation of _ autosynch _ is built upon constructs provided by java .",
    "thus , there is possibility of further performance improvement if the approach was to be implemented within the jvm .",
    "we thank himanshu chauhan , yen - jung chang , john bridgman , and craig chase for the helpful comments to improve the paper .",
    "g. r. andrews .",
    "_ multithreaded , parallel , and distributed programming_. addison - wesley , ma , 2000 .",
    "p. brinch hansen , _ the programming language concurrent pascal_. ieee trans .",
    "software engineering , 1(2 ) , 199207 , june , 1975 .",
    "c. a. r. hoare , _ monitors : an operating system structuring concept_. commun .",
    "acm , 17(10 ) , 549557 , oct .",
    "joung , _ asynchronous group mutual exclusion_. acm symposium on principles of distributed computing , 5160 , aug .",
    "j. l. w. kessels .",
    "_ an alternative to event queues for synchronization in monitors_. commun .",
    "acm , 20(7 ) , 500503 , july 1977 ."
  ],
  "abstract_text": [
    "<S> most programming languages use monitors with _ </S>",
    "<S> explicit signals _ for synchronization in shared - memory programs . requiring programmers to signal threads explicitly results in many concurrency bugs due to missed notifications , or notifications on wrong condition variables . in this paper </S>",
    "<S> , we describe an implementation of an automatic signaling monitor in java called _ autosynch _ that eliminates such concurrency bugs by removing the burden of signaling from the programmer . </S>",
    "<S> we show that the belief that automatic signaling monitors are prohibitively expensive is wrong . for most problems , programs based on _ autosynch _ are almost as fast as those based on explicit signaling . </S>",
    "<S> for some , _ autosynch _ is even faster than explicit signaling because it never uses _ signalall _ , whereas the programmers end up using _ signalall _ with the explicit signal mechanism .    </S>",
    "<S> _ autosynch _ achieves efficiency in synchronization based on three novel ideas . </S>",
    "<S> we introduce an operation called _ globalization _ that enables the predicate evaluation in every thread , thereby reducing context switches during the execution of the program . secondly , _ autosynch </S>",
    "<S> _ avoids _ signalall _ by using a property called _ relay invariance _ that guarantees that whenever possible there is always at least one thread whose condition is true which has been signaled . finally , _ </S>",
    "<S> autosynch _ uses a technique called _ predicate tagging _ to efficiently determine a thread that should be signaled . to evaluate the efficiency of _ autosynch </S>",
    "<S> _ , we have implemented many different well - known synchronization problems such as the producers / consumers problem , the readers / writers problems , and the dining philosophers problem . </S>",
    "<S> the results show that _ autosynch _ is almost as efficient as the explicit - signal monitor and even more efficient for some cases .    </S>",
    "<S> = 10000 = 10000    algorithms , languages , performance    automatic signal , explicit signal , implicit signal , monitor , concurrency , parallel </S>"
  ]
}