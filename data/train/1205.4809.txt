{
  "article_text": [
    "dolev et al . @xcite introduced the notion of _ approximate byzantine consensus _ by relaxing the requirement of _ exact _ consensus @xcite . the goal in approximate consensus is to allow the fault - free nodes to agree on values that are approximately equal to each other ( and not necessarily exactly identical ) . in presence of byzantine faults , while _ exact _ consensus is impossible in _ asynchronous _",
    "systems @xcite , approximate consensus is achievable @xcite .",
    "the notion of approximate consensus is of interest in _ synchronous _ systems as well , since approximate consensus can be achieved using distributed algorithms that do not require complete knowledge of the network topology @xcite .",
    "the rest of the discussion in this paper assumes a _ synchronous _ systems .",
    "the fault model assumed in much of the work on byzantine consensus allows up to @xmath0 byzantine faulty nodes in the network .",
    "we will refer to this fault model as the `` @xmath0-total '' fault model @xcite . in prior work ,",
    "other fault models have been explored as well .",
    "for instance , in the `` @xmath0-local '' fault model , up to @xmath0 neighbors of _ each _ node in the network may be faulty @xcite , and in the @xmath0-fraction model @xcite , up to @xmath0 fraction of the neighbors of each node may be faulty . in this paper",
    ", we consider a _",
    "generalized _ fault model ( to be described in the next section ) .",
    "the _ generalized fault _",
    "model specifies a `` fault domain '' , which is a collection of feasible fault sets ( a similar fault model is recently presented in @xcite ) .",
    "for example , in a system consisting of four nodes , namely , nodes @xmath1 and @xmath2 , the fault domain could be specified as @xmath3 .",
    "thus , in this case , either node 1 may be faulty , or any subset of nodes in @xmath4 may be faulty . however , node 1 may not be faulty simultaneously with another node .",
    "the new fault model is general in the sense that the other fault models studied in the literature , such as @xmath0-total , @xmath0-local and @xmath0-fraction models , are special cases of the generalized fault model .",
    "analysis of consensus under the generalized fault model offers some new insights into how the choice of the fault model affects algorithm design .",
    "in particular , we consider `` iterative '' algorithms for achieving approximate byzantine consensus in synchronous point - to - point networks that are modeled by arbitrary _ directed _ graphs . the _ iterative approximate byzantine consensus _ ( iabc ) algorithms of interest have the following properties , which we will soon state more formally :    * _ initial state",
    "_ of each node is equal to a real - valued _ input _ provided to that node . *",
    "_ validity _ condition : after each iteration of an iabc algorithm , the state of each fault - free node must remain in the _ convex hull _ of the states of the fault - free nodes at the end of the _ previous _ iteration . *",
    "_ convergence _ condition : for any @xmath5 , after a sufficiently large number of iterations , the states of the fault - free nodes are guaranteed to be within @xmath6 of each other .",
    "this paper is a generalization of our recent work on iabc algorithms under the @xmath0-total fault model @xcite .",
    "the contributions of this paper are as follows :    * we identify a necessary condition on the communication graph for the existence of a correct iabc algorithm under the _",
    "generalized _ fault model ( sections [ sec : iabc ] and [ s_necessity ] ) .",
    "* we introduce a new iabc algorithm for the generalized fault model ( section [ s_algo ] ) that uses only `` local '' information . *",
    "a transition matrix representation of the new iabc algorithm is presented ( section [ s_sufficiency ] ) .",
    "this representation is then used to prove the correctness of the proposed algorithm ( section [ s_proof ] ) .",
    "since the results here generalize our prior results @xcite , naturally the proof techniques used here have some similarities to the prior work .",
    "the material in section [ s_proof ] bears the strongest similarity to our prior work .",
    "the rest of the paper , however , presents results that provide new intuition on the problem of approximate consensus .",
    "in particular , materials in sections [ s_necessity ] and [ s_algo ] shed light on how the fault model influences the design of iabc algorithms .",
    "[ [ communication - model ] ] communication model : + + + + + + + + + + + + + + + + + + + +    the system is assumed to be _",
    "synchronous_. the communication network is modeled as a simple _ directed _ graph @xmath7 , where @xmath8 is the set of @xmath9 nodes , and @xmath10 is the set of directed edges between the nodes in @xmath11 .",
    "we assume that @xmath12 , since the consensus problem for @xmath13 is trivial .",
    "node @xmath14 can reliably transmit messages to node @xmath15 if and only if the directed edge @xmath16 is in @xmath10 .",
    "each node can send messages to itself as well , however , for convenience , we exclude self - loops from set @xmath10 .",
    "that is , @xmath17 for @xmath18 . with a slight abuse of terminology",
    ", we will use the terms _ edge _ and _ link _ interchangeably in our presentation .    for each node @xmath14 ,",
    "let @xmath19 be the set of nodes from which @xmath14 has incoming edges .",
    "that is , @xmath20 .",
    "similarly , define @xmath21 as the set of nodes to which node @xmath14 has outgoing edges .",
    "that is , @xmath22 .",
    "nodes in @xmath19 and @xmath21 are , respectively , said to be incoming and outgoing neighbors of node @xmath14 . since we exclude self - loops from @xmath10 , @xmath23 and @xmath24 .",
    "however , we note again that each node can indeed send messages to itself .    [ [ generalized - byzantine - failure - model ] ] generalized byzantine failure model : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we consider the byzantine failure model , with possible faulty nodes specified using a `` fault domain '' @xmath25 ( defined below ) .",
    "a faulty node may _ misbehave _ arbitrarily .",
    "possible misbehavior includes transmitting incorrect and mismatching ( or inconsistent ) messages to different neighbors .",
    "the faulty nodes may collaborate with each other .",
    "moreover , the faulty nodes are assumed to have a complete knowledge of the execution of the algorithm , including the states of all the nodes , the algorithm specification , and the network topology .",
    "the generalized fault model is characterized using _ fault domain _ @xmath26 as follows : nodes in set @xmath27 may fail during an execution of the algorithm only if there exists set @xmath28 such that @xmath29 .",
    "set @xmath27 is then said to be a _",
    "feasible _ fault set .",
    "set @xmath30 is said to be a fault set , if there exists @xmath31 such that @xmath29 .",
    "thus , each set in @xmath25 specifies nodes that may all potentially fail during a single execution of the algorithm ( a similar fault model is also considered in @xcite ) .",
    "this feature can be used to capture the notion of correlated failures .",
    "for example , consider a system consisting of four nodes , namely , nodes 1 , 2 , 3 , and 4 .",
    "suppose that @xmath32 this definition of @xmath25 implies that during an execution either ( i ) node 1 may fail , or ( ii ) node 2 may fail , or ( iii ) any subset of @xmath33 may fail , and no other combination of nodes may fail ( e.g. , nodes 1 and 3 can not both fail in a single execution ) . in this case",
    ", the reason that the set @xmath34 is in the fault domain may be that the failures of nodes 3 and 4 are correlated .",
    "the generalized fault model is also useful to capture variations in node reliability . for instance , in the above example , nodes 1 and 2 may be more reliable than nodes 3 and 4 . therefore , while simultaneous failure of nodes 3 and 4 may occur , simultaneous failure of nodes 1 and 2 is less likely . therefore , @xmath35 .",
    "_ local knowledge of @xmath25 : _ to implement our iabc algorithm presented in section [ s_algo ] , it is sufficient for each node @xmath14 to know @xmath36 , for each feasible fault set @xmath27 . in other words , each node only needs to know the set of its incoming neighbors that may fail simultaneously .",
    "thus , the iterative algorithm can be implemented using only `` local '' information regarding @xmath25 .",
    "in this section , we describe the structure of the iabc algorithms of interest , and state the validity and convergence conditions that they must satisfy .",
    "each node @xmath14 maintains state @xmath37 , with @xmath38 $ ] denoting the state of node @xmath14 at the _ end _ of the @xmath39-th iteration of the algorithm .",
    "initial state of node @xmath14 , @xmath40 $ ] , is equal to the initial _ input _ provided to node @xmath14 . at the",
    "_ start _ of the @xmath39-th iteration ( @xmath41 ) , the state of node @xmath14 is @xmath42 $ ] .",
    "the iabc algorithms of interest will require each node @xmath14 to perform the following three steps in iteration @xmath39 where @xmath41 . note that the faulty nodes may deviate from this specification .    1 .",
    "_ transmit step : _ transmit current state , namely @xmath42 $ ] , on all outgoing edges and self - loop ( to nodes in @xmath21 and node @xmath14 itself ) .",
    "2 .   _ receive step : _ receive values on all incoming edges and self - loop ( from nodes in @xmath19 and itself ) .",
    "denote by @xmath43 $ ] the vector of values received by node @xmath14 from its incoming neighbors and itself .",
    "the size of vector @xmath43 $ ] is @xmath44 .",
    "3 .   _ update step : _",
    "node @xmath14 updates its state using a transition function @xmath45 as follows .",
    "@xmath45 is a part of the specification of the algorithm , and takes the vector @xmath43 $ ] as the input . @xmath46 & = &   z_i ~ ( ~r_i[t]~ ) \\label{eq : z_i}\\end{aligned}\\ ] ]    the following conditions must be satisfied by an iabc algorithm when the set of faulty nodes ( in a given execution ) is @xmath27 :    * _ validity : _",
    "@xmath47 , and all fault - free nodes @xmath48 , + @xmath38 \\geq \\min_{j\\in{\\mathcal{v}}-f}~ v_j[t-1]$ ]    @xmath38 \\leq \\max_{j\\in{\\mathcal{v}}-f}~ v_j[t-1]$ ] . and",
    "@xmath49 , @xmath50 contains elements that are in @xmath51 but not in @xmath49 .",
    "that is , @xmath52 . ]",
    "* _ convergence : _ for all _ fault - free _",
    "nodes @xmath53 ,   @xmath54-v_j[t ] ) = 0 $ ]    an iabc algorithm is said to be _ correct _ if it satisfies the above validity and convergence conditions in the given graph @xmath55 . for a given fault domain @xmath25 for graph @xmath7 ,",
    "the objective here is to identify the necessary and sufficient conditions for the existence of a _ correct _ iabc algorithm .",
    "in this section , we develop a necessary condition for the existence of a correct iabc algorithm .",
    "the necessary condition will be proved to be also sufficient in section [ s_sufficiency ] .      to facilitate the statement of the necessary condition",
    ", we first introduce the notions of `` source component '' and `` reduced graph '' using the following three definitions .",
    "[ def : decompose ] * graph decomposition : * let @xmath56 be a directed graph .",
    "partition graph @xmath56 into strongly connected components , @xmath57 , where @xmath58 is a non - zero integer dependent on graph @xmath56 , such that    * every pair of nodes * within * the same strongly connected component has directed paths in @xmath56 to each other , and * for each pair of nodes , say @xmath14 and @xmath15 , that belong to two * different * strongly connected components , either @xmath14 does not have a directed path to @xmath15 in @xmath56 , or @xmath15 does not have a directed path to @xmath14 in @xmath56 .    construct a graph @xmath59 wherein each strongly connected component @xmath60 above is represented by vertex @xmath61 , and there is an edge from vertex @xmath61 to vertex @xmath62 if and only if the nodes in @xmath60 have directed paths in @xmath56 to the nodes in @xmath63 .",
    "@xmath59 is called the of @xmath56 .",
    "it is known that for any directed graph @xmath56 , the corresponding decomposition graph @xmath59 is a directed _ acyclic _ graph ( dag ) @xcite .",
    "* source component * : let @xmath56 be a directed graph , and let @xmath59 be its decomposition graph as per definition  [ def : decompose ] .",
    "strongly connected component @xmath60 of @xmath56 is said to be a _ source component _ if the corresponding vertex @xmath61 in @xmath59 is reachable from any other vertex in @xmath59 .",
    "[ def : reduced ] * reduced graph : * for a given graph @xmath7 and a feasible fault set @xmath27 , a @xmath64 is obtained as follows :    * node set is obtained as @xmath65 . * for each node @xmath66 , a feasible fault set @xmath67 is chosen , and then the edge set @xmath68 is obtained as follows : * * remove from @xmath10 all the links incident on the nodes in @xmath27 , and * * for each @xmath69 and each @xmath70 , remove link @xmath71 from @xmath10 .",
    "+ feasible fault sets @xmath67 and @xmath72 chosen for @xmath73 may or may not be identical .    note that for a given @xmath55 and a given @xmath27 , multiple reduced graphs @xmath74 may exist , depending on the choice of @xmath75 sets above .      for a correct iabc algorithm to exist",
    ", the network graph @xmath55 must satisfy the necessary condition stated in theorem [ thm : nc ] below .",
    "[ thm : nc ] suppose that a correct iabc algorithm exists for @xmath55 .",
    "then , any reduced graph @xmath74 , corresponding to any feasible fault set @xmath27 , must contain exactly one _ source component_.    a complete proof is presented in appendix [ app_s_necessity ] .",
    "the proof is by contradiction .",
    "let us assume that a correct iabc algorithm exists , and for some feasible fault set @xmath27 , and feasible sets @xmath67 for each @xmath48 , the resulting reduced graph contains two source components .",
    "let @xmath76 and @xmath77 denote the nodes in the two source components , respectively .",
    "thus , @xmath76 and @xmath77 are disjoint and non - empty .",
    "let @xmath78 be the remaining nodes in the reduced graph .",
    "@xmath79 may or may not be non - empty .",
    "assume that the nodes in @xmath27 ( if non - empty ) are all faulty , and all the nodes in @xmath76 , @xmath77 , and @xmath79 ( if non - empty ) are fault - free .",
    "suppose that each node in @xmath76 has initial input equal to @xmath80 , each node in @xmath77 has initial input equal to @xmath81 , where @xmath82 , and each node in @xmath79 has an input in the range @xmath83 $ ] . as elaborated in appendix [ app_s_necessity ] , the faulty nodes can behave in such a manner that , in each iteration , nodes in @xmath76 and @xmath77 are forced to maintain their updated state equal to @xmath80 and @xmath81 , respectively , so as to satisfy the _",
    "validity _ condition .",
    "this ensures that , no matter how many iterations are performed , the _ convergence _ condition can not be satisfied .",
    "we will prove that there exists an iabc algorithm  particularly _ algorithm 1 _ below  that satisfies the _ validity _ and _ convergence _ conditions provided that the graph @xmath7 satisfies the necessary condition in theorem  [ thm : nc ] .",
    "this implies that the necessary condition in theorem  [ thm : nc ] is also sufficient .",
    "_ algorithm 1 _ has the three - step structure described in section [ sec : iabc ] .",
    "this algorithm is a generalization  to accommodate the generalized fault model  of iterative algorithms that were analyzed in prior work @xcite , including in our own prior work as well",
    "the key difference from previous algorithms is in the _ update _ step below .       ' '' ''    * algorithm 1 *    ' '' ''    1 .   _",
    "transmit step : _ transmit current state @xmath42 $ ] on all outgoing edges and self - loop .",
    "2 .   receive step : receive values on all incoming edges and self - loop .",
    "these values form vector @xmath43 $ ] of size @xmath44 ( including the value from node @xmath14 itself ) . when a fault - free node expects to receive a message from an incoming neighbor but",
    "does not receive the message , the message value is assumed to be equal to some _",
    "default value_. 3 .",
    "_ update step : _ sort the values in @xmath43 $ ] in an increasing order ( breaking ties arbitrarily ) .",
    "let @xmath84 be a vector of nodes arranged in an order `` consistent '' with @xmath43 $ ] : specifically , @xmath85 is the node that sent the smallest value in @xmath43 $ ] , @xmath86 is the node that sent the second smallest value in @xmath43 $ ] , and so on .",
    "the size of vector @xmath84 is also @xmath44 .",
    "+ from vector @xmath43 $ ] , eliminate the smallest @xmath87 values , and the largest @xmath88 values , where @xmath87 and @xmath88 are defined as follows : * @xmath87 is the largest number such that there exists a feasible fault set @xmath89 containing nodes @xmath90 . recall that @xmath91 .",
    "* @xmath88 is the largest number such that there exists a feasible fault set @xmath92 containing nodes @xmath93 .",
    "+ @xmath94 and @xmath95 above may or may not be identical .",
    "+ let @xmath96 $ ] denote the set of nodes from whom the remaining @xmath97 values in @xmath43 $ ] were received , and let @xmath98 denote the value received from node @xmath99 $ ] .",
    "note that @xmath100 $ ] .",
    "hence , for convenience , define @xmath101 $ ] to be the value node @xmath14 `` receives '' from itself .",
    "observe that if @xmath99 $ ] is fault - free , then @xmath102 $ ] .",
    "+ define @xmath46 ~ = ~ z_i(r_i[t ] ) ~ = ~\\sum_{j\\in n_i^*[t ] } a_i \\ , w_j \\label{e_z}\\end{aligned}\\ ] ] where @xmath103| } = \\frac{1}{|n_i^-|+1-f_1 - f_2}\\ ] ] + the `` weight '' of each term on the right - hand side of ( [ e_z ] ) is @xmath104 , and these weights add to 1 .",
    "also , @xmath105 .",
    "although @xmath106 and @xmath104 may be different for each iteration @xmath39 , for simplicity , we do not explicitly represent this dependence on @xmath39 in the notations .    ' '' ''       observe @xmath107 nodes whose values are eliminated in the _ update _ step above are all in @xmath19 .",
    "thus , the above algorithm can be implemented by node @xmath14 if it knows which of its incoming neighbors may fail simultaneously ; node @xmath14 does not need to know the entire fault domain @xmath25 as such .",
    "the main difference between the above algorithm and iabc algorithms in prior work is in the choice of the values eliminated from vector @xmath43 $ ] in the _ update _ step .",
    "the manner in which the values are eliminated ensures that the values received from nodes @xmath108 and @xmath109 ( i.e. , the smallest and largest values that survive in @xmath43 $ ] ) are within the convex hull of the state of fault - free nodes , even if nodes @xmath108 and @xmath109 may not be fault - free .",
    "this property is useful in proving algorithm correctness ( as discussed below ) .",
    "we will show that algorithm 1 satisfies validity and convergence conditions , provided that @xmath55 satisfies the condition below , which matches the necessary condition stated in theorem [ thm : nc ] .",
    "* sufficient condition : * _ any reduced graph @xmath74 corresponding to any feasible fault set @xmath27 contains exactly one _ source component_. _    in the rest of this section , we assume that @xmath110 satisfies the above condition . to prove its sufficiency , we first develop a _ transition matrix _ representation of the _ update _ step in algorithm 1 .      in our discussion",
    "below , @xmath111 $ ] is a square matrix , @xmath112 $ ] is the @xmath14-th row of the matrix , and @xmath113 $ ] is the element at the intersection of the @xmath14-th row and @xmath15-th column of @xmath111 $ ] .    for a given execution of algorithm 1 , let @xmath27 denote the actual set of faulty nodes in that execution .",
    "let @xmath114 .",
    "without loss of generality , suppose that nodes @xmath115 through @xmath116 are fault - free , and if @xmath117 , nodes @xmath118 through @xmath9 are faulty .",
    "denote by @xmath119 $ ] the column vector consisting of the initial states of all the fault - free nodes .",
    "denote by @xmath120 $ ] , where @xmath121 , the column vector consisting of the states of all the fault - free nodes at the end of the @xmath39-th iteration .",
    "the @xmath14-th element of vector @xmath120 $ ] is state @xmath38 $ ] .",
    "the size of vector @xmath120 $ ] is @xmath122 .",
    "we will show that the iterative update of the state of a fault - free node @xmath123 performed in ( [ e_z ] ) in algorithm 1 can be expressed using the matrix form below .",
    "@xmath124 = { \\textbf{m}}_i[t]~v[t-1]\\ ] ]    where @xmath112 $ ] is a _",
    "stochastic row _ vector of size @xmath125 .",
    "that is , @xmath113 \\geq 0 $ ] , for @xmath126 , and @xmath127 = 1 $ ] .",
    ", the row vector @xmath112 $ ] may depend on the state vector @xmath128 $ ] as well as the behavior of the faulty nodes in @xmath27 . for simplicity , the notation @xmath112 $ ] does not explicitly represent this dependence .",
    "] by `` stacking '' ( [ matrix : e_z ] ) for different @xmath14 , @xmath129 , we will represent the _ update _ step of algorithm 1 at all the fault - free nodes together using ( [ matrix : alg1 ] ) below .",
    "@xmath130 = { \\textbf{m}}[t]~v[t-1]\\ ] ] where @xmath111 $ ] is a @xmath131 _ row stochastic _ matrix , with its @xmath14-th row being equal to @xmath112 $ ] in ( [ matrix : e_z ] ) . @xmath111 $ ]",
    "is said to be a .    in the rest of this section",
    ", we will first `` construct '' a transition matrix @xmath111 $ ] that satisfies certain desirable properties .",
    "then , we will identify a connection between the transition matrix and the sufficiency condition stated above , and use this connection to establish _ convergence _",
    "property for algorithm 1 .",
    "validity _ property also follows from the transition matrix representation .",
    "we will construct a transition matrix with the property described in lemma [ lemma : tm2 cm ] below .",
    "[ lemma : tm2 cm ] the _ update step _ of algorithm 1 at the fault - free nodes can be expressed using row stochastic transition matrix @xmath111 $ ] , such that there exists a feasible fault set @xmath67 for each @xmath132 such that , for all @xmath133 ,    @xmath134 ~ \\geq ~ \\beta$}}\\ ] ]    where @xmath135 is a constant ( to be defined later ) , and @xmath136 .    in @xcite as well",
    ", we construct a transition matrix to prove correctness of an iabc algorithm under the @xmath0-total fault model .",
    "however , the _ generalized _ fault model introduces additional complexity , which is handled here using a new approach to construct the transition matrix .",
    "we prove the correctness of lemma [ lemma : tm2 cm ] by constructing @xmath112 $ ] for @xmath137 that satisfies the conditions in lemma [ lemma : tm2 cm ] .",
    "recall that @xmath27 is the set of faulty nodes , and @xmath114 . as stated before , without loss of generality , nodes @xmath115 through @xmath138 are assumed to be fault - free , and the remaining @xmath139 nodes faulty .",
    "consider a fault - free node @xmath14 performing the _ update _ step in algorithm 1 . in the _ update _",
    "step , recall that the smallest @xmath87 and the largest @xmath88 values are eliminated from @xmath43 $ ] , where the choice of @xmath87 and @xmath88 is described in algorithm 1 .",
    "let us denote by @xmath140 and @xmath141 , respectively , the set of nodes and @xmath141 may be different for each @xmath39 , for simplicity , we do not explicitly represent this dependence on @xmath39 in the notations @xmath140 and @xmath141 . ] from whom the smallest @xmath87 and the largest @xmath88 values",
    "were received by node @xmath14 in iteration @xmath39 .",
    "define sets @xmath142 and @xmath143 to be subsets of @xmath140 and @xmath141 that contain all the fault - free nodes in @xmath140 and @xmath141 , respectively .",
    "that is , @xmath144 and @xmath145 .",
    "construction of @xmath112 $ ] differs somewhat depending on whether sets @xmath146 and @xmath96 \\cap f$ ] are empty or non - empty .",
    "we divide the possibilities into 6 separate cases . due to space limitation",
    ", here we present the construction for one of the cases ( named case i ) .",
    "the construction for the remaining cases is presented in appendix [ app_s_construction ] .",
    "@xmath157 + \\frac{l_k}{|{\\mathcal{l}}_g| } \\sum_{j \\in { \\mathcal{l}}_g } v_j[t-1 ] \\label{eq : casei}\\end{aligned}\\ ] ]    clearly , at least one of @xmath158 and @xmath159 must be @xmath160 .",
    "we now define elements @xmath113 $ ] of row @xmath112 $ ] :    * for @xmath161\\cap({\\mathcal{v}}-f)$ ] : in this case , @xmath15 is either a fault - free incoming neighbor of @xmath14 , or @xmath14 itself . for each such @xmath15 , define @xmath113 = a_i$ ] .",
    "this is obtained by observing in ( [ e_z ] ) that the contribution of such a node @xmath15 to the new state @xmath38 $ ] is @xmath162 $ ] .",
    "+ the elements of @xmath112 $ ] defined here add up to @xmath163 \\cap ( { \\mathcal{v}}- f)|~a_i\\ ] ] * for @xmath164 : in this case , @xmath15 is a fault - free node in @xmath140 or @xmath141 .",
    "+ for each @xmath165 , @xmath166 ~=~ a_i",
    "\\ , \\sum_{k \\in n_i^*[t ] \\cap f } \\frac{s_k}{|{\\mathcal{s}}_g|}\\ ] ] and for each node @xmath167 , @xmath166 ~=~ a_i \\ , \\sum_{k \\in n_i^*[t ] \\cap f } \\frac{l_k}{|{\\mathcal{l}}_g|}\\ ] ] to obtain these two expressions , we represent value @xmath168 sent by each faulty node @xmath169 in @xmath96 $ ] , i.e. , @xmath170 \\cap f$ ] , using ( [ eq : casei ] ) .",
    "recall that this node @xmath169 contributes @xmath171 to ( [ e_z ] ) .",
    "the above two expressions are then obtained by summing ( [ eq : casei ] ) over all the faulty nodes in @xmath96\\cap f$ ] , and replacing this sum by equivalent contributions by nodes in @xmath142 and @xmath143 .",
    "+ the elements of @xmath112 $ ] defined here add up to @xmath172 \\cap f } ( s_k + l_k ) = |n_i^*[t ] \\cap f|~a_i.\\ ] ] * for @xmath173 \\cup { \\mathcal{s}}_g \\cup { \\mathcal{l}}_g)$ ] : these fault - free nodes have not yet been considered above . for each such node @xmath15 , define @xmath113 = 0 $ ] .    with the above definition of @xmath112 $ ]",
    ", it should be easy to see that @xmath112\\,v[t-1]$ ] is , in fact , identical to @xmath38 $ ] obtained using ( [ e_z ] ) .",
    "thus , the above construction of @xmath112 $ ] results in the contribution of the faulty nodes in @xmath96 $ ] to ( [ e_z ] ) being replaced by an equivalent contribution from fault - free nodes in @xmath143 and @xmath142 .",
    "[ [ properties - of - textbfm_it ] ] properties of @xmath112 $ ] : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    first , we show that @xmath111 $ ] is row stochastic .",
    "observe that all the elements of @xmath112 $ ] are non - negative .",
    "also , all the elements of @xmath112 $ ] above add up to @xmath163 \\cap ( { \\mathcal{v}}- f)|~a_i + |n_i^*[t ] \\cap f|~a_i = |n_i^*[t]|~a_i = 1\\ ] ] because @xmath174|$ ] as defined in algorithm 1 .",
    "thus , @xmath112 $ ] is a stochastic row vector .    recall that from the above discussion , for @xmath170 $ ] , one of @xmath158 and @xmath159 must be @xmath160 .",
    "without loss of generality , assume that @xmath175 for some @xmath176 \\cap f$ ] .",
    "consequently , for each node @xmath165 , @xmath113 \\geq \\frac{a_i}{|{\\mathcal{s}}_g| } s_s \\geq \\frac{a_i}{2|{\\mathcal{s}}_g|}$ ] . also , for each fault - free node @xmath15 in @xmath96 $ ] , @xmath113 = a_i$ ] .",
    "thus , if @xmath135 is chosen such that @xmath177 and @xmath67 is defined to be equal to @xmath141 , then the condition in the lemma holds for node @xmath14 .",
    "that is , @xmath113 \\geq \\beta$ ] for @xmath133 .",
    "[ [ all - cases - together ] ] all cases together : + + + + + + + + + + + + + + + + + + +    using similar constructions in other cases as well ( presented in appendix [ app_s_construction ] ) and a suitable choice of @xmath135 ( presented in appendix [ a_s_together ] ) , we can obtain a row stochastic matrix @xmath111 $ ] , and for each @xmath132 identify a feasible fault set @xmath67 , such that @xmath113 \\geq \\beta$ ] for all @xmath133 .",
    "thus , lemma [ lemma : tm2 cm ] can be proved correct .",
    "the rest of the proof structure is derived from our previous work wherein we proved the correctness of an iabc algorithm for the @xmath0-total fault model @xcite .",
    "let @xmath178 denote the set of all the reduced graphs of @xmath55 corresponding to a feasible fault set @xmath27 .",
    "let @xmath179 .",
    "@xmath180 depends on @xmath27 and the underlying network , and is finite .    in this discussion , let us denote a reduced graph by an italic upper case letter , and the corresponding `` connectivity matrix '' ( defined below ) using the same letter in boldface upper case .",
    "thus , @xmath181 denotes the connectivity matrix for graph @xmath182 .",
    "non - zero elements of connectivity matrix @xmath181 are defined as follows : ( i ) for @xmath183 , @xmath184 if and only if @xmath185 , and ( ii ) @xmath186 for @xmath129 .",
    "that is , non - zero elements of row @xmath187 correspond to the incoming links at node @xmath14 , and the self - loop at node @xmath14 .",
    "thus , the connectivity matrix for any reduced graph in @xmath178 has a non - zero diagonal .",
    "based on the _ sufficient condition _ stated at the start of section [ s_sufficiency ] and lemma [ lemma : tm2 cm ] , we can show the following key lemmas .",
    "the proofs are presented in appendix [ a_s_non - zero ] and [ a_s_cm ] .",
    "[ lemma : non - zero ] for any @xmath188 has at least one non - zero column .",
    "[ lemma : cm ] for any @xmath121 , there exists a graph @xmath182 such that @xmath189 $ ] .",
    "[ thm : sufficiency ] suppose that @xmath55 satisfies the sufficient condition stated above .",
    "algorithm 1 satisfies both the validity and convergence conditions .    a complete proof is presented in appendix [ a_sufficiency ] . by repeated application of ( [ matrix : alg1 ] )",
    ", we can represent the _ update _ step of algorithm 1 at the @xmath39-th iterations ( @xmath121 ) as : @xmath190 & = & \\left(\\,\\pi_{i=1}^t { \\textbf{m}}[i]\\,\\right)\\ , v[0 ] \\label{e_v_t}\\end{aligned}\\ ] ] where @xmath191 $ ] is constructed as described above .",
    "when presenting matrix products , for convenience of presentation , we adopt the following convention : for @xmath192 , @xmath193 $ ] denotes the `` backward '' product @xmath194{{\\bf a}}[b-1]\\cdots{{\\bf a}}[a]$ ] . thus , @xmath195 $ ] in ( [ e_v_t ] ) above represents @xmath196{{\\bf m}}[t-1]\\cdots{{\\bf m}}[1]$ ] .",
    "since @xmath191 $ ] is row stochastic , then from ( [ matrix : alg1 ] ) , it follows that algorithm 1 satisfies the validity condition .",
    "based on lemmas [ lemma : non - zero ] and [ lemma : cm ] , we can also show that the rows of @xmath197 $ ] become identical in the limit ( as elaborated in appendix [ a_sufficiency ] ) .",
    "this observation and ( [ e_v_t ] ) together imply that the states of the fault - free nodes satisfy the convergence condition too .",
    "this paper considers a _ generalized _ fault model , which can be used to specify more complex failure patterns , such as correlated failures or non - uniform node reliabilities . under this fault model , we prove a _ tight _ necessary and sufficient condition for the existence of synchronous iterative approximate byzantine consensus algorithms in arbitrary directed graphs .",
    "the analysis of consensus under the generalized fault model sheds new light on how the fault model affects algorithm design .    10    d.  p. bertsekas and j.  n. tsitsiklis . .",
    "optimization and neural computation series .",
    "athena scientific , 1997 .",
    "v.  bhandari and n.  h. vaidya . on reliable broadcast in a radio network .",
    "in _ proceedings of the twenty - fourth annual acm symposium on principles of distributed computing _ , podc 05 , pages 138147 , new york , ny , usa , 2005 .",
    "s.  dasgupta , c.  papadimitriou , and u.  vazirani . .",
    "mcgraw - hill higher education , 2006 .",
    "d.  dolev , n.  a. lynch , s.  s. pinter , e.  w. stark , and w.  e. weihl .",
    "reaching approximate agreement in the presence of faults .",
    ", 33:499516 , may 1986 .",
    "m.  j. fischer , n.  a. lynch , and m.  s. paterson . impossibility of distributed consensus with one faulty process . , 32:374382 , april 1985 .",
    "j.  hajnal .",
    "weak ergodicity in non - homogeneous markov chains . in _ proceedings of the cambridge philosophical society _ , volume  54 , pages 233246 , 1958 .",
    "r.  m. kieckhafer and m.  h. azadmanesh .",
    "low cost approximate agreement in partially connected networks .",
    ", 3(1):5385 , 1993 .",
    "broadcast in radio networks tolerating byzantine adversarial behavior . in _ proceedings of the twenty - third annual acm symposium on principles of distributed computing _ , podc 04 , pages 275282 , new york , ny , usa , 2004 .",
    "p.  kuznetsov .",
    "understanding non - uniform failure models .",
    ", 106:5377 , 2012 .",
    "l.  lamport , r.  shostak , and m.  pease .",
    "the byzantine generals problem . , 1982 .",
    "h.  leblanc , h.  zhang , s.  sundaram , and x.  koutsoukos .",
    "consensus of multi - agent networks in the presence of adversaries using only local information . , 2012",
    ".    n.  a. lynch . .",
    "morgan kaufmann , 1996 .",
    "n.  h. vaidya .",
    "matrix representation of iterative approximate byzantine consensus in directed graphs .",
    "n.  h. vaidya , l.  tseng , and g.  liang .",
    "iterative approximate byzantine consensus in arbitrary directed graphs .",
    "volume abs/1201.4183 , 2012 .",
    "j.  wolfowitz .",
    "products of indecomposable , aperiodic , stochastic matrices . in _ proceedings of the american mathematical society _ , volume  14 , pages 733737 , 1963 .",
    "h.  zhang and s.  sundaram .",
    "robustness of information diffusion algorithms to locally bounded adversaries .",
    ", abs/1110.3843 , 2011 .",
    "* appendix *",
    "now , we present the proof for theorem [ thm : nc ] .",
    "the proof is by contradiction .",
    "let us assume that a correct iabc algorithm exists , and for some feasible fault set @xmath27 , and feasible sets @xmath67 for each @xmath48 , the resulting reduced graph contains two source components .",
    "let @xmath76 and @xmath77 denote the nodes in the two source components , respectively .",
    "thus , @xmath76 and @xmath77 are disjoint and non - empty .",
    "let @xmath78 be the remaining nodes in the reduced graph .",
    "@xmath79 may or may not be non - empty .",
    "let us now assume that the nodes in @xmath27 ( if non - empty ) are all faulty , and all the nodes in @xmath76 , @xmath77 , and @xmath79 ( if non - empty ) are fault - free .",
    "consider the case when ( i ) each node in @xmath76 has initial input @xmath80 , ( ii ) each node in @xmath77 has initial input @xmath81 , such that @xmath198 , and ( iii ) each node in @xmath79 ( if non - empty ) has an input in the interval @xmath199 $ ] .    in the _ transmit step _ of iteration 1 of the iabc algorithm ,",
    "suppose that the faulty nodes in @xmath27 ( if non - empty ) send @xmath200 on outgoing links to nodes in @xmath76 , send @xmath201 on outgoing links to nodes in @xmath77 , and send some arbitrary value in interval @xmath199 $ ] on outgoing links to nodes in @xmath79 ( if non - empty ) .",
    "this behavior is possible since nodes in @xmath27 are byzantine faulty .",
    "note that @xmath202 .",
    "each fault - free node @xmath203 sends to nodes in @xmath204 value @xmath205 $ ] in iteration 1 .",
    "consider any node @xmath206 .",
    "since @xmath76 is a source component in the reduced graph , it must be true that @xmath207 . from nodes in @xmath208 .",
    "thus , any incoming links in @xmath10 from the nodes in @xmath208 must have been removed when constructing @xmath68 for the reduced graph .",
    "recall that when constructing @xmath68 , incoming links from nodes in @xmath209 are removed .",
    "it should be noted that the algorithm is performed using the links in @xmath10 , not the reduced graph .",
    "thus , in the _ transmit step _ , all links in @xmath10 are used . ]    now , node @xmath14 receives @xmath210 from the nodes in @xmath211 , and values in @xmath83 $ ] from the nodes in @xmath208 , and @xmath80 from the nodes in @xmath212 .",
    "figure [ f_necessity ] illustrates the behavior of faulty nodes in @xmath27 and the value received by node @xmath14 .     and",
    "the value received at node @xmath14.,scaledwidth=70.0% ]    consider the following two cases :    * * @xmath211 and @xmath208 are both non - empty : * in this case , @xmath213 and @xmath214 .",
    "from node @xmath14 s perspective , consider two possible scenarios : ( a ) nodes in @xmath211 are all faulty , and the other nodes are fault - free , and ( b ) nodes in @xmath215 are all faulty , and the other nodes are fault - free . note that , since @xmath67 is a feasible fault set , @xmath216 is also a feasible fault set .",
    "similarly , since @xmath27 is a feasible fault set , @xmath211 is also a feasible fault set .",
    "+ in scenario ( a ) , from node @xmath14 s perspective , the fault - free nodes have sent values in interval @xmath199 $ ] , whereas the faulty incoming neighbors , i.e. , nodes in @xmath211 , have sent value @xmath210 . according to the validity condition , @xmath217 \\geq m$ ] . on the other hand , in scenario ( b ) ,",
    "the fault - free incoming neighbors have sent values @xmath210 and @xmath80 , where @xmath200 ; so @xmath217 \\leq m$ ] , according to the validity condition .",
    "since node @xmath14 does not know whether the correct scenario is ( a ) or ( b ) , it must update its state to satisfy the validity condition in both cases .",
    "thus , it follows that @xmath217 = m$ ] . * * at most one of @xmath211 and @xmath208 is non - empty : * recall that @xmath36 and @xmath215 are both feasible fault sets . since at least one of these two sets is empty , their union , i.e. , @xmath218 , is also a feasible fault set .",
    "+ then , from node @xmath14 s perspective , it is possible that all the nodes in @xmath218 are faulty , and the rest of the nodes are fault - free . in this situation ,",
    "the values sent to node @xmath14 by the fault - free nodes ( which are all in @xmath212 ) are all @xmath80 , and therefore , @xmath217 $ ] must be set to @xmath80 as per the validity condition .",
    "hence , @xmath217 = m$ ] for each node @xmath206 .",
    "similarly , we can show that @xmath219 = m$ ] for each node @xmath220 .",
    "now consider the nodes in set @xmath79 ( if non - empty ) .",
    "all the values received by the nodes in @xmath79 are in @xmath199 $ ] , therefore , their new state must also remain in @xmath83 $ ] , as per the validity condition .",
    "the above discussion implies that , at the end of iteration 1 , the following conditions hold true : ( i ) state of each node in @xmath76 is @xmath80 , ( ii ) state of each node in @xmath77 is @xmath81 , and ( iii ) state of each node in @xmath79 ( if non - empty ) is in the interval @xmath199 $ ] .",
    "these conditions are identical to the initial conditions listed previously .",
    "then , by a repeated application of the above argument ( proof by induction ) , it follows that for any @xmath221 = m$ ] for all nodes @xmath206 , @xmath222 = m$ ] for all nodes @xmath220 and @xmath223 \\in [ m , m]$ ] for all nodes @xmath224 .    since @xmath76 and @xmath77 both contain fault - free nodes , and @xmath225 , the _ convergence _ requirement is not satisfied .",
    "this is a contradiction to the assumption that a correct iterative algorithm exists in @xmath55 .",
    "when discussing case i in section [ s_construction ] , we deferred discussion of the other cases .",
    "we present the construction for the rest of the cases here .",
    "there are six cases in total :    * case i : @xmath147 , and @xmath96 \\cap f \\neq \\phi$ ] . * case ii : @xmath147 , and @xmath96 \\cap f = \\phi$ ] .",
    "* case iii : @xmath226 , and @xmath96 \\cap f \\neq \\phi$ ] . * case iv",
    ": @xmath227 , and @xmath96 \\cap f \\neq \\phi$ ] . * case v : @xmath228 , and @xmath96 \\cap f \\neq \\phi$ ] .",
    "* case vi : at most one of @xmath142 and @xmath143 is non - empty , and @xmath96 \\cap f = \\phi$ ] .",
    "note that the choice of @xmath87 and @xmath88 in algorithm 1 ensures that the value from node @xmath14 itself is never dropped from @xmath43 $ ] ; therefore , @xmath100 $ ] , and @xmath96 $ ] is always non - empty .",
    "now , we consider the case when @xmath147 , and @xmath96 \\cap f = \\phi$ ] . that is , when each of @xmath140 and @xmath141 contains at least one fault - free node , and @xmath96 $ ] contains only fault - free node(s ) .",
    "in fact , the analysis of case ii is very similar to the analysis presented in section [ s_construction ] for case i when @xmath96 $ ] does contain a faulty node .",
    "we now discuss how the analysis of case i can be applied to case ii . rewrite ( [ e_z ] ) as follows :    @xmath46 & = & \\frac{a_i}{2 } v_i[t-1 ]   + \\frac{a_i}{2 } v_i[t-1 ]      + \\sum_{j\\in n_i^*[t ] - \\{i\\ } } a_iw_j \\\\ & = & a_iw_z + a_i w_i      + \\sum_{j\\in n_i^*[t ] - \\{i\\ } } a_iw_j \\end{aligned}\\ ] ]    in the above equation , @xmath229 is to be viewed as a `` virtual '' incoming neighbor of node @xmath14 , which has sent value @xmath230}{2}$ ] to node @xmath14 in iteration @xmath39 . with the above rewriting of state update",
    ", the value received by node @xmath14 from itself should be viewed as @xmath231}{2}$ ] instead of @xmath42 $ ] . with this transformation , case",
    "ii now becomes identical to case i , with virtual node @xmath229 being treated as an incoming neighbor of node @xmath14 .",
    "in essence , a part of node @xmath14 s contribution ( half , to be precise ) is now replaced by equivalent contribution by nodes in @xmath143 and @xmath142 .",
    "we now define elements @xmath113 $ ] of row @xmath112 $ ] :    * for @xmath232 : @xmath113 = \\frac{a_i}{2}$ ] .",
    "this is obtained by observing in ( [ e_z ] ) that node @xmath14 s contribution to the new state @xmath38 $ ] is @xmath233}{2}$ ] . * for @xmath161 - \\{i\\}$ ] : in this case , @xmath15 is a fault - free incoming neighbor of @xmath14 . for each such @xmath15 , define @xmath113 = a_i$ ] .",
    "this is obtained by observing in ( [ e_z ] ) that the contribution of node j to the new state @xmath38 $ ] is @xmath234 $ ] . * for @xmath235 : in this case , @xmath15 is a fault - free node in @xmath140 or @xmath141 .",
    "+ for each @xmath165 , @xmath166 ~=~ \\frac{a_i}{2 } \\ , \\frac{s_z}{|{\\mathcal{s}}_g|}\\ ] ] and for each node @xmath167 ,",
    "@xmath166 ~=~ \\frac{a_i}{2 } \\ , \\frac{l_z}{|{\\mathcal{l}}_g|}\\ ] ] + where @xmath236 and @xmath237 are chosen such that @xmath238 and @xmath239}{2 } = \\frac{s_z}{2 } m_{{\\mathcal{s } } } + \\frac{l_z}{2 } m_{{\\mathcal{l}}}$ ] .",
    "note that such @xmath236 and @xmath237 exist because by definition of @xmath142 and @xmath143 , @xmath42 \\geq w_j,~\\forall j \\in s_g$ ] and @xmath42 \\leq w_j,~\\forall j \\in l_g$ ] .",
    "then the two expressions above are obtained by replacing the contribution of the virtual node @xmath229 by an equivalent contribution by the nodes in @xmath142 and @xmath143 , respectively . * for @xmath173 \\cup { \\mathcal{s}}_g \\cup { \\mathcal{l}}_g)$ ] : these fault - free nodes have not yet been considered above . for each such node @xmath15 , define @xmath113 = 0 $ ] .    by argument",
    "similar to that in section [ s_construction ] , @xmath111 $ ] is row stochastic . without loss of generality ,",
    "suppose that @xmath240 .",
    "then for each node @xmath165 , @xmath113 = \\frac{a_i}{2|{\\mathcal{s}}_g|}s_z \\geq \\frac{a_i}{4|{\\mathcal{s}}_g|}$ ] . also , for fault - free node @xmath15 in @xmath96-\\{i\\}$ ] , @xmath113 = a_i$ ] , and @xmath241 = \\frac{a_i}{2}$ ] .",
    "recall that by definition , @xmath242 . hence ,",
    "if @xmath135 is chosen such that    @xmath243    and @xmath67 is defined to be equal to @xmath141 , then the condition in the lemma [ lemma : tm2 cm ] holds for node @xmath14 .",
    "that is , @xmath113 \\geq \\beta$ ] for @xmath244 .",
    "now , we describe the construction of case iii .",
    "the construction for case iv is very similar , and thus , is omitted here .    in case iii , @xmath226 , and @xmath96\\cap f\\neq \\phi$ ] .",
    "thus , @xmath140 does not contain any fault - free nodes ( hence @xmath142 is empty ) .",
    "this may be due to one of the following two reasons : ( i ) the set @xmath140 is non - empty , but all the nodes in @xmath140 are faulty , or ( ii ) set @xmath140 is empty .",
    "assume that @xmath245 is a fault - free node , and that all the nodes in @xmath140 are faulty ( i.e. , @xmath246 ) or that @xmath140 is empty ( i.e. , @xmath247 ) .",
    "in this case , observe that node @xmath108 must be fault - free ( otherwise , @xmath87 can not be the largest value as defined in algorithm 1 ) .",
    "now , consider any node @xmath152 $ ] .",
    "similar to the argument in case i , we can find weights @xmath154 and @xmath155 such that @xmath248 and @xmath249 + l_k~v_{l}[t-1]\\ ] ] we now define @xmath113 $ ] for all fault - free @xmath15 .    * for @xmath250 - \\{d(f_1 + 1)\\})\\cap ( { \\mathcal{v}}-f)$ ] .",
    "that is , @xmath15 is a fault - free node in @xmath96 $ ] with the exception of @xmath108 . + for each such @xmath15 , define @xmath113 = a_i$ ] .",
    "this is obtained by observing in ( [ e_z ] ) that the contribution of node @xmath15 to the new state @xmath38 $ ] is @xmath251 $ ] .",
    "+ the elements of @xmath112 $ ] defined here ( including the case of @xmath252 ) add up to @xmath253 \\cap ( { \\mathcal{v}}- f)|-1)~a_i.\\ ] ] * for nodes @xmath108 and @xmath254 : define + @xmath255 = a_i + \\sum_{k \\in n_i^*[t ] \\cap f } a_i~s_k\\ ] ] + and + @xmath256 = \\sum_{k \\in n_i^*[t ] \\cap f } a_i~l_k\\ ] ] + similar to case i presented in section [ s_construction ] , these two expressions are obtained by summing up the contribution over the faulty nodes in @xmath96 $ ] , and replacing the sum by an equivalent contribution by the nodes @xmath108 and @xmath254 , respectively , according to ( [ eq : caseii ] ) .",
    "+ the above elements of @xmath112 $ ] add up to @xmath257 \\cap f}(s_k + l_k)\\right ) = ( 1+|n_i^*[t ] \\cap f|)~a_i.\\ ] ] * for @xmath173 \\cup \\{l\\})$ ] : these fault - free nodes have not yet been considered above . for each such @xmath15 , define @xmath258 = 0 $ ] .",
    "similar to case i , in case iii as well , it should be easy to see that @xmath259\\,v[t-1]\\ ] ] is identical to @xmath38 $ ] obtained using ( [ e_z ] ) .",
    "[ [ properties - of - textbfm_it-1 ] ] properties of @xmath112 $ ] : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    all the elements of @xmath112 $ ] are non - negative .",
    "the elements of @xmath112 $ ] defined in case ii add up to @xmath253 \\cap ( { \\mathcal{v}}- f)|-1)~a_i + ( 1+|n_i^*[t ] \\cap f|)~a_i = |n_i^*[t]|~a_i = 1\\ ] ] thus , @xmath112 $ ] is a stochastic row vector .    in case iii , recall that for any fault - free node @xmath15 in @xmath96 $ ] ( including @xmath260 and @xmath252 ) , @xmath113 \\geq a_i$ ] .",
    "thus , if @xmath135 is chosen such that @xmath261 and @xmath67 is defined to be equal to @xmath141 , then the condition in the lemma [ lemma : tm2 cm ] holds for node @xmath14 .",
    "consider case v , where @xmath96 \\cap f \\neq \\phi$ ] , and @xmath262 . in this case",
    ", it should be easy to see that @xmath96 $ ] contains at least 3 nodes .",
    "in particular , @xmath263 must be fault - free ( otherwise , @xmath87 can not be maximum possible ) , @xmath264 must be fault - free ( otherwise , @xmath88 can not be maximum possible ) , and there is a faulty node in @xmath96 $ ] .    now this case can be handled similar to case iii analyzed above . in particular , entries in",
    "@xmath112 $ ] are defined similarly with @xmath254 being defined equal to @xmath265 . also , define @xmath266 .",
    "hence , it is easy to see that the properties of @xmath112 $ ] are identical to case iii presented above .      here",
    ", we consider the case when at most one of @xmath140 and @xmath141 contains a fault - free node and @xmath96 \\cap f = \\phi$ ] . without loss of generality ,",
    "suppose that @xmath140 contains only faulty nodes , and @xmath141 may contain a fault - free node .    in this case",
    ", define @xmath113=a_i$ ] for @xmath99 $ ] ; define @xmath267 for all other fault - free nodes @xmath15 . also , define @xmath268 .",
    "the properties of @xmath112 $ ] thus defined are identical to case iii above .",
    "now , let us consider cases i - vi together . from the definition of @xmath104 in algorithm 1 , observe that @xmath269 ( because @xmath270 )",
    "let us define @xmath271 moreover , observe that @xmath272 and @xmath273 . then define @xmath135 as @xmath274 this definition satisfies constraints on @xmath135 in cases i through vi ( conditions ( [ eq : beta_casei ] ) , ( [ eq : beta - caseii ] ) and ( [ eq : beta - caseiii ] ) ) .",
    "thus , lemma [ lemma : tm2 cm ] holds for all six cases with this choice of @xmath135 .",
    "here , we present the proof of the first key lemma used in the sufficiency proof .",
    "+ * lemma [ lemma : non - zero ] * _ for any @xmath188 has at least one non - zero column . _",
    "@xmath7 satisfies the _ sufficient condition _ stated at the start of section [ s_sufficiency ] .",
    "therefore , there exists at least one non - faulty node @xmath169 in the reduced graph @xmath275 that has directed paths to all the nodes in @xmath275 ( consisting of the edges in @xmath275 ) .",
    "since the length of the path from @xmath169 to any other node in @xmath275 is at most @xmath276 , the @xmath169-th column of matrix @xmath277 will be non - zero .",
    "we use the loose bound of @xmath138 to simplify the presentation . ]      here , we present the proof of the second key lemma used in the sufficiency proof .",
    "we start with two definitions :    for matrices @xmath278 and @xmath279 of identical size , and a scalar @xmath280 , @xmath281 provided that @xmath282 for all @xmath283 .",
    "we want to prove the following lemma .       * lemma [ lemma : cm ] * _ for any @xmath121 , there exists a graph @xmath182 such that @xmath189 $ ] .",
    "_    observe that the @xmath14-th row of the transition matrix @xmath111 $ ] corresponds to the state update ( in algorithm 1 ) performed at fault - free node @xmath14 .",
    "recall from lemma [ lemma : tm2 cm ] that @xmath113 \\geq \\beta$ ] for @xmath133 , where @xmath67 is a feasible fault set .",
    "let us obtain a reduced graph @xmath56 by choosing @xmath67 for each @xmath14 as defined in lemma [ lemma : tm2 cm ] . then from the definition of connectivity matrix @xmath181 , lemma [ lemma : cm ] then follows .",
    "when presenting matrix products , for convenience of presentation , we adopt the following convention : for @xmath192 , @xmath193 $ ] denotes the `` backward '' product @xmath194{{\\bf a}}[b-1]\\cdots{{\\bf a}}[a]$ ] .        in the discussion",
    "below , we use boldface upper case letters to denote matrices , rows of matrices , and their elements . for instance",
    ", @xmath284 denotes a matrix , @xmath285 denotes the @xmath14-th row of matrix @xmath284 , and @xmath286 denotes the element at the intersection of the @xmath14-th row and the @xmath15-th column of matrix @xmath284 .    [ d_stochastic ] a vector is said to be _ stochastic _",
    "if all the elements of the vector are _ non - negative _ , and the elements add up to 1 .",
    "a matrix is said to be stochastic if each row of the matrix is a stochastic vector .    for a row",
    "stochastic matrix @xmath287 , coefficients of ergodicity @xmath288 and @xmath289 are defined as follows @xcite : @xmath290 it is easy to show that @xmath291 and @xmath292 , and that the rows of @xmath287 are all identical if and only if @xmath293 .",
    "also , @xmath294 if and only if @xmath295 .",
    "the next result from @xcite establishes a relation between the coefficient of ergodicity @xmath296 of a product of row stochastic matrices , and the coefficients of ergodicity @xmath297 of the individual matrices defining the product .",
    "lemma [ claim_zelta ] is proved in @xcite .",
    "it implies that if , for all @xmath14 , @xmath301 for some @xmath280 , where @xmath302 , then @xmath303 will approach zero as @xmath298 approaches @xmath304 .",
    "we now define a _ scrambling _ matrix @xcite .",
    "[ l_lambda_bound ] if any column of a row stochastic matrix @xmath284 contains only non - zero elements that are all lower bounded by some constant @xmath280 , where @xmath302 , then @xmath284 is a scrambling matrix , and @xmath307 .",
    "since the above product consists of @xmath310 connectivity matrices corresponding to graphs in @xmath312 , at least one of the connectivity matrices corresponding to the @xmath180 distinct graphs in @xmath312 , say matrix @xmath313 , will appear in the above product at least @xmath138 times .",
    "now observe that : ( i ) by lemma [ lemma : non - zero ] , @xmath314 contains a non - zero column , say the @xmath169-th column is non - zero , and ( ii ) all the @xmath309 $ ] matrices in the product contain a non - zero diagonal . these two observations together imply that the @xmath169-th column in the above product is non - zero .",
    "let us now define a sequence of matrices @xmath315 , @xmath316 , such that each of these matrices is a product of @xmath310 of the @xmath196 $ ] matrices . specifically ,",
    "@xmath317 \\label{e_q_i}\\end{aligned}\\ ] ] from ( [ e_v_t ] ) and ( [ e_q_i ] ) observe that @xmath318 & = & \\left(\\ , \\pi_{i=1}^k ~ { { \\bf q}}(i ) \\,\\right)~{v}[0]\\end{aligned}\\ ] ]      @xmath315 is a product of row stochastic matrices ( @xmath196 $ ] ) ; therefore , @xmath315 is row stochastic . from lemma [ lemma :",
    "cm ] , for each @xmath320 , @xmath321 ~ \\leq ~ { { \\bf m}}[t]\\ ] ] therefore , @xmath322 ~",
    "\\leq   ~ \\pi_{t=(i-1)\\tau(n-\\psi)+1}^{i\\tau(n-\\psi ) } ~ { { \\bf m}}[t ] ~ = ~ { { \\bf q}}(i)\\ ] ] by using @xmath323 in lemma [ l_product_h ] , we conclude that the matrix product on the left side of the above inequality contains a non - zero column",
    ". therefore , @xmath315 on the right side of the inequality also contains a non - zero column .",
    "observe that @xmath310 is finite , and hence , @xmath324 is non - zero . since the non - zero terms in",
    "@xmath309 $ ] matrices are all 1 , the non - zero elements in @xmath325 $ ] must each be @xmath326 1 . therefore , there exists a non - zero column in @xmath315 with all the elements in the column being @xmath327 .",
    "therefore , by lemma [ l_lambda_bound ] , @xmath328 , and @xmath315 is a scrambling matrix .          using lemma [ claim_zelta ] and the definition of @xmath315 , and using the inequalities @xmath330)\\leq 1 $ ] and @xmath331",
    ", we get @xmath332 ) ~=~ \\lim_{t\\rightarrow\\infty }   \\delta\\left ( \\left(\\pi_{i=(\\lfloor\\frac{t}{\\tau(n-\\psi)}\\rfloor)\\tau(n-\\psi)+1}^t { { \\bf m}}[i]\\right ) \\left(\\pi_{i=1}^{\\lfloor\\frac{t}{\\tau(n-\\psi)}\\rfloor } { { \\bf q}}(i)\\right)\\right )",
    "\\\\   ~ \\leq ~ \\lim_{t\\rightarrow\\infty } \\pi_{i=1}^{\\lfloor\\frac{t}{\\tau(n-\\psi)}\\rfloor } \\lambda({{\\bf q}}(i ) )   ~ = ~ 0 \\end{aligned}\\ ] ] thus , the rows of @xmath195 $ ] become identical in the limit . this observation , and the fact that @xmath329=(\\pi_{i=1}^t { { \\bf m}}[i]){v}[0]$ ] together imply that the states of the fault - free nodes satisfy the convergence condition"
  ],
  "abstract_text": [
    "<S> in this work , we consider a _ </S>",
    "<S> generalized _ fault model that can be used to represent a wide range of failure scenarios , including correlated failures and non - uniform node reliabilities . </S>",
    "<S> this fault model is general in the sense that fault models studied in prior related work , such as @xmath0-total and @xmath0-local models , are special cases of the generalized fault model . under the generalized fault model , </S>",
    "<S> we explore iterative approximate byzantine consensus ( iabc ) algorithms in arbitrary directed networks . </S>",
    "<S> we prove a necessary and sufficient condition for the existence of iabc algorithms . </S>",
    "<S> the use of the generalized fault model helps to gain a better understanding of iabc algorithms . </S>"
  ]
}