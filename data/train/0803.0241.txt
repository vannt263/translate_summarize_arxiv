{
  "article_text": [
    "the phenomenon of synchronization is displayed by many biological systems  @xcite .",
    "it presumably plays an important role in these systems .",
    "for example , the heart of the lobster is regularly activated by the synchronized firing of four interneurons in the cardiac pacemaker network  @xcite .",
    "it was concluded that the organism can not survive if all four interneurons fire out of synchrony for prolonged times  @xcite .",
    "this system inspired the present work .",
    "other examples of biological synchronization include the _ malaccae _ fireflies in southeast asia where thousands of male fireflies congregate in mangrove trees , flashing in synchrony  @xcite ; oscillations of the neurons in the circadian pacemaker , determining the day - night rhythm ; crickets that chirp in unison  @xcite ; coordinated mass spawning in corals and even audience clapping together after a `` good '' performance  @xcite .",
    "synchronization in these systems is typically attained despite the inherent variations among the participating elements , or the presence of noise from external sources or from participating elements . a generic mathematical model for synchronous firing of biological oscillators based on a model of the human cardiac pacemaker",
    "is given in  @xcite .",
    "this model does not account for noise or for the inherent differences among biological elements .    in computer science ,",
    "synchronization is both a goal by itself and a building block for algorithms that solve other problems . in the `` clock synchronization '' problem ,",
    "it is required of computers to have their clocks set as close as possible to each other as well as to keep a notion of real - time ( @xcite ) .    in general , it is desired for algorithms to guarantee correct behavior of the system in face of faults or failing elements , without strong assumptions on the initial state of the system .",
    "it has been suggested in  @xcite that similar fault considerations may have been involved in the evolution of distributed biological systems . in the example of the cardiac pacemaker network of the lobster , it was concluded that at least four neurons are needed in order to overcome the presence of one faulty neuron , though supposedly one neuron suffices to activate the heart .",
    "the cardiac pacemaker network must be able to adjust the pace of the synchronized firing according to the required heartbeat , up to a certain bound , without losing the synchrony ( e.g. while escaping a predator a higher heartbeat is required  though not too high ) . due to the vitality of this network",
    ", it is presumably optimized for fault tolerance , self - stabilization , tight synchronization and for fast re - synchronization .",
    "the apparent resemblance of the synchronization and fault tolerance requirements of biological networks and distributed computer networks makes it very appealing to infer from models of biological systems onto the design of distributed algorithms in computer science .",
    "especially when assuming that distributed biological networks have evolved over time to particularly tolerate inherent heterogeneity of the cells , noise and cell death . in the current paper , we show that in spite of obvious differences , a biological fault tolerant synchronization model ( @xcite ) can inspire a novel solution to an apparently similar problem in computer science .",
    "we propose a relaxed version of the clock synchronization problem , which we call `` pulse synchronization '' , in which all the elements are required to invoke some regular pulse ( or perform a `` task '' ) in tight synchrony , but allows to deviate from exact regularity . though nodes need to invoke the pulses synchronously , there is a limit on how frequently it is allowed to be invoked ( similar to the linear envelope clock synchronization limitation ) .",
    "the `` pulse synchronization '' problem resembles physical / biological pulse - coupled synchronization models  @xcite , though in a computer system setting an algorithm needs to be supplied for the nodes to reach the synchronization requirement . to the best of our knowledge",
    "this problem has not been formally defined in the settings of distributed computer systems .",
    "we present a novel algorithm in the settings of self - stabilizing distributed algorithms , instructing the nodes how and when to invoke a pulse in order to meet the synchronization requirements of `` pulse synchronization '' .",
    "the core elements of the algorithm are analogous to the neurobiological principles of _ endogenous _",
    "( self generated ) _",
    "periodic spiking , summation _ and _ time dependent refractoriness_. the basic algorithm is quite simple : every node invokes a pulse regularly and sends a message upon invoking it ( _ endogenous periodic spiking _ ) .",
    "the node sums messages received in some `` window of time '' ( _ summation _ ) and compares this to the continuously decreasing time dependent firing threshold for invoking the pulse ( _ time dependent refractory function _ ) .",
    "the node fires when the counter of the summed messages crosses the current threshold level , and then resets its cycle . for in - depth explanations of these neurobiological terms see  @xcite .",
    "the algorithm performs correctly as long as less than a third of the nodes behave in a completely arbitrary ( `` byzantine '' ) manner concurrently .",
    "it ensures a tight synchronization of the pulses of all correct nodes , while not using any central clock or global pulse .",
    "we assume the communication network allows for a broadcast environment and has a bounded delay on message transmission .",
    "the algorithm may not reach its goal as long as these limitations are violated or the network graph is disconnected .",
    "the algorithm is self - stabilizing byzantine and thus copes with a more severe fault model than the traditional byzantine fault model .",
    "classic byzantine algorithms , which are not designed with self - stabilization in mind , typically make use of assumptions on the initial state of the system such as assuming all clocks are initially synchronized , ( c.f .",
    "@xcite ) . observe that the system might temporarily be thrown out of the assumption boundaries , e.g. when more than one third of the nodes are byzantine or messages of correct nodes get lost .",
    "when the system eventually returns to behave according to these presumed assumptions it may be in an arbitrary state . a classic byzantine algorithm ,",
    "being non - stabilizing , might not recover from this state .",
    "on the other hand , a self - stabilizing protocol converges to its goal from any state once the system behaves well again , but is typically not resilient to permanent faults .",
    "for our protocol , once the system complies with the theoretically required bound of @xmath0 permanent byzantine faulty nodes in a network of @xmath1 nodes then , regardless of the state of the system , tight pulse synchronization is achieved within finite time .",
    "it overcomes transient failures and permanent byzantine faults and makes no assumptions on any initial synchronized activity among the nodes ( such as having a common reference to time or a common event for triggering initialization ) .",
    "our algorithm is uniform , all nodes execute an identical algorithm .",
    "it does not suffer from communication deadlock , as can happen in message - driven algorithms ( @xcite ) , since the nodes have a time - dependent state change , at the end of which they fire endogenously .",
    "the faulty nodes can not ruin an already attained synchronization ; in the worst case , they can slow down the convergence towards synchronization and speed up the synchronized firing frequency up to a certain bound .",
    "the convergence time is @xmath2 cycles with a near optimal synchronization of the pulses to within @xmath3 real - time ( the bound on the end to end network and processing delay ) .",
    "we show in subsection  [ sec : iagree ] how the algorithm can be executed in a non - broadcast network to achieve synchronization of the pulses to within @xmath4 real - time .",
    "* applications and contribution of this paper : * we have shown in @xcite how to stabilize general byzantine algorithms using synchronized pulses . in @xcite",
    "we have presented a very efficient , besides being the first , self - stabilizing byzantine token passing algorithm .",
    "the efficient self - stabilizing byzantine clock synchronization algorithm in @xcite is also the first such algorithm for clock synchronization .",
    "all these algorithms assume a background self - stabilizing byzantine pulse synchronization module though the particular pulse synchronization procedure presented in @xcite suffers from a flaw .",
    "the only other self - stabilizing byzantine pulse synchronization algorithm ( besides the current work ) , is to the best of our knowledge , the one in @xcite , which is a correction to the one in @xcite . in comparison to the current paper",
    ", the pulse synchronization algorithm in @xcite has a much higher message complexity and worse tightness , is more complicated but it converges in @xmath5 does not assume broadcast and scales better .",
    "the current paper is simpler , uses much shorter messages ; it has a smaller message complexity and introduces novel and interesting elements to distributed computing .    in the discussion , in section  [ sec : discussion ] , we postulate that our result elucidates the feasibility and adds a solid brick to the motivation to search for and to understand biological mechanisms for robustness that can be carried over to computer systems .",
    "the environment is a network of @xmath1 nodes , out of which @xmath6 are faulty nodes , that communicate by exchanging messages .",
    "the nodes regularly invoke `` pulses '' , ideally every @xmath7 real - time units .",
    "the invocation of the pulse is expressed by sending a message to all the nodes ; this is also referred to as * firing*. we assume that the message passing allows for an authenticated identity of the senders .",
    "the communication network does not guarantee any order on messages among different nodes .",
    "individual nodes have no access to a central clock and there is no external pulse system .",
    "the hardware clock rate ( referred to as the _ physical timers _ ) of correct nodes has a bounded drift , @xmath8 from real - time rate .",
    "when the system is not coherent then there can be an unbounded number of concurrent byzantine faulty nodes , the turnover rate between faulty and non - faulty nodes can be arbitrarily large and the communication network may behave arbitrarily .",
    "eventually the system settles down in a coherent state in which there at most @xmath0 permanent byzantine faulty nodes and the communication network delivers messages within bounded time .",
    "a node is * non - faulty * at times that it complies with the following :    1 .   _",
    "( bounded drift ) _ obeys a global constant @xmath9 ( typically @xmath10 ) , such that for every real - time interval @xmath11:$ ] @xmath12 2 .   _",
    "( obedience ) _ operates according to the correct protocol .",
    "( bounded processing time ) _ processes any message of the correct protocol within @xmath13 real - time units of arrival time .",
    "a node is considered * faulty * if it violates any of the above conditions .",
    "the faulty nodes can be byzantine .",
    "a faulty node may recover from its faulty behavior once it resumes obeying the conditions of a non - faulty node . in order to keep the definitions",
    "consistent the `` correction '' is not immediate but rather takes a certain amount of time during which the non - faulty node is still not counted as a correct node , although it supposedly behaves `` correctly '' .",
    "we later specify the time - length of continuous non - faulty behavior required of a recovering node to be considered * correct*.    the communication network is * non - faulty * at periods that it complies with the following : [ def : net_nonfaulty ]    * _ ( bounded transmission delay ) _ any message sent or received by a non - faulty node will arrive at every non - faulty node within @xmath14 real - time units .",
    "thus , our communication network model is an `` eventual bounded - delay '' communication network .    * basic definitions and notations : *   + we use the following notations though nodes do not need to maintain all of them as variables .",
    "* @xmath15 thus , when the communication network is non - faulty , @xmath3 is the upper bound on the elapsed real - time from the sending of a message by a non - faulty node until it is received and processed by every correct node . * a * @xmath16 * is an internal event targeted to happen in `` tight '' for some small constant @xmath17 as tight . ]",
    "synchrony at all correct nodes . a * @xmath7 * is the `` ideal '' time interval length between two successive pulses that a node invokes , as given by the user .",
    "the actual length , denoted in regular caption , has upper and lower bounds as a result of faulty nodes and the physical clock skew .",
    "* @xmath18 represents the upper bound on the real - time window within which all correct nodes invoke a pulse ( _ tightness of pulse synchronization _ ) .",
    "our solution achieves @xmath19 we assume that @xmath20 * @xmath21 @xmath22 denotes , at real - time @xmath23 the elapsed real - time since the last pulse invocation of @xmath24 it is also denoted as the `` @xmath25 of node @xmath26 '' .",
    "we occasionally omit the reference to the time in case it is clear out of the context . for a node , @xmath27 that has not fired since initialization of the system , @xmath28 *",
    "@xmath29 and @xmath30 are values that define the bounds on the actual length during correct behavior .",
    "we achieve @xmath31 * @xmath32 represents the maximal real - time a non - faulty node will keep a message or a reference to it , before deleting it . ] .    in accordance with definition  [ def : net_nonfaulty ] , the network model in this paper is such that every message sent or received by a non - faulty node arrives within bounded time , @xmath33 at all non - faulty nodes .",
    "the algorithm and its respective proofs are specified in a stronger network model in which every message received by a non - faulty node arrives within @xmath14 time at all non - faulty nodes .",
    "the subtle difference in the latter definition equals the assumption that every message received by a non - faulty node , even a message from a byzantine node , will eventually reach every non - faulty node .",
    "this weakens the possibility for two - faced behavior by byzantine nodes .",
    "the algorithm is able to utilize this fact so that if executed in such a network environment , then it can attain a very tight , near optimal , pulse synchronization of @xmath3 real - time units .",
    "we show in subsection  [ sec : iagree ] how to execute in the background a self - stabilizing byzantine reliable - broadcast - like primitive , which executes in the network model of definition  [ def : net_nonfaulty ] .",
    "this primitive effectively relays every message received by a non - faulty node so that the latter network model is satisfied .",
    "in such a case the algorithm can be executed in the network model of definition  [ def : net_nonfaulty ] and achieves synchronization of the pulses to within @xmath4 real - time .",
    "note that the protocol parameters @xmath34 @xmath6 and @xmath7 ( as well as the system characteristics @xmath3 and @xmath35 ) are fixed constants and thus considered part of the incorruptible correct code .",
    "thus we assume that non - faulty nodes do not hold arbitrary values of these constants .",
    "a recovering node should be considered correct only once it has been continuously non - faulty for enough time to enable it to have decayed old messages and to have exchanged information with the other nodes through at least a cycle .",
    "a node is * correct * following @xmath36 real - time of continuous non - faulty behavior .",
    "the communication network is * correct * following @xmath36 real - time of continuous non - faulty behavior .",
    "[ def : system - coherence ] _ ( system coherence ) _ the system is said to be * coherent * at times that it complies with the following :    1 .   _",
    "( quorum ) _ there are at least @xmath37 correct nodes , where @xmath6 is the upper bound on the number of potentially non - correct nodes , at steady state .",
    "( network correctness ) _ the communication network is correct .    hence , if the system is not coherent then there can be an unbounded number of concurrent faulty nodes ; the turnover rate between the faulty and non - faulty nodes can be arbitrarily large and the communication network may deliver messages with unbounded delays , if at all .",
    "the system is considered coherent , once the communication network and a sufficient fraction of the nodes have been non - faulty for a sufficiently long time period for the pre - conditions for convergence of the protocol to hold .",
    "the assumption in this paper , as underlies any other self - stabilizing algorithm , is that the system eventually becomes coherent .",
    "all the lemmata , theorems , corollaries and definitions hold as long as the system is coherent .",
    "+    we now seek to give an accurate and formal definition of the notion of pulse synchronization .",
    "we start by defining a subset of the system states , which we call _ pulse_states _ , that are determined only by the elapsed real - time since each individual node invoked a pulse ( the @xmath25 s ) .",
    "we then identify a subset of the pulse_states in which some set of correct nodes have  tight `` or ' ' close ",
    "@xmath25 s .",
    "we refer to such a set as a _",
    "synchronized _ set of nodes . to complete the definition of synchrony",
    "there is a need to address the recurring brief time period in which a correct node in a synchronized set of nodes has just fired while others are about to fire .",
    "this is addressed by adding to the definition nodes whose @xmath25 s are almost a  apart .",
    "if all correct nodes in the system comprise a synchronized set of nodes then we say that the pulse_state is a _ synchronized_pulse_states of the system_. the objective of the algorithm is hence to reach a synchronized_pulse_state of the system and to stay in such a state .",
    "the methodology to prove that our algorithm does exactly this will be to show firstly that a synchronized set of correct nodes stay synchronized .",
    "secondly , we show that such synchronized sets of correct nodes incessantly join together to form bigger synchronized sets of nodes .",
    "this goes on until a synchronized set that encompasses all correct nodes in the system is formed .    *",
    "the * pulse_state * of the system at real - time @xmath38 is given by : @xmath39 * let @xmath40 be the set of all possible pulse_states of a system .",
    "* a set of nodes , @xmath41 is called * synchronized * at real - time @xmath38 if + @xmath42 @xmath43 and one of the following is true : 1 .",
    "@xmath44 2 .",
    "@xmath45 and @xmath46 * @xmath47 is a * synchronized_pulse_state * _ of the system _ at real - time @xmath38 if the set of correct nodes is synchronized at real - time @xmath48    [ def : pulse - synch]*the self - stabilizing pulse synchronization problem * +    * convergence : * starting from an arbitrary system state , the system reaches a synchronized_pulse_state after a finite time . +",
    "* closure : * if @xmath49 is a synchronized_pulse_state of the system at real - time @xmath50 then @xmath51 real - time @xmath52    1 .",
    "pulse_state(t ) is a synchronized_pulse_state , 2 .   in the real - time interval [ @xmath53",
    "every correct node will invoke at most a single pulse if @xmath54 and will invoke at least a single pulse if @xmath55    the second closure condition intends to tightly bound the effective pulse invocation frequency within a priori bounds .",
    "this is in order to defy any trivial solution that could synchronize the nodes , but be completely unusable , such as instructing the nodes to invoke a pulse every @xmath18 time units .",
    "note that this is a stronger requirement than the `` linear envelope progression rate '' typically required by clock synchronization algorithms , in which it is only required that clock time progress as a linear function of real - time .",
    "we now present the bio - pulse - synch algorithm that solves the `` pulse synchronization '' problem defined in definition  [ def : pulse - synch ] , inspired by and following a neurobiological analog .",
    "the * refractory function * describes the time dependency of the firing threshold . at threshold level @xmath56",
    "the node invokes a pulse ( _ fires _ ) * endogenously*. the algorithm uses several sub - procedures . with the help of the * summation * procedure , each node sums the pulses that it learns about during a recent time window . if this sum ( called the _ counter _ ) crosses the current ( time - dependent ) threshold for firing , then the node will fire , i.e broadcasts its counter value at the firing time .",
    "the exact properties of the time window for summing messages is determined by the message decay time in the prune procedure ( see fig .  [",
    "alg : prune ] ) .",
    "we now show in greater detail the elements and procedures described above .    *",
    "the refractory function *   + the is the predefined time a correct node will count on its timer before invoking an endogenous pulse .",
    "the refractory function , @xmath57 determines at every moment the threshold for invoking a new pulse .",
    "the refractory function is determined by the parameters @xmath1 , @xmath6 , @xmath3 and @xmath58 all correct nodes execute the same protocol with the same parameters and have the same refractory function .",
    "the refractory function is shaped as a monotonously decreasing step function comprised of @xmath59 steps , @xmath60 where step @xmath61 is the time length on the node s timer of threshold level @xmath62 the refractory function @xmath63 starts at threshold level @xmath64 and decreases with time towards threshold level @xmath65 the time length of each threshold step is formulated in eq .",
    "[ eq : ref ] :    @xmath66    subsequent to a pulse invocation the refractory function is restarted at @xmath67 the node will then commence threshold level @xmath1 only after measuring @xmath68 time units on its timer .",
    "threshold level 0 ( @xmath69 ) is reached only if exactly  time units have elapsed on a node s timer since the last pulse invocation , following which threshold level @xmath64 is reached immediately .",
    "hence , by definition , @xmath70 it is proven later in lemma  [ lem : ref_prop_6 ] that @xmath71 in eq .",
    "[ eq : ref ] is consistent with this .",
    "the special step @xmath68 is called the * absolute refractory period * of the cycle . following the neurobiological analogue with the same name ,",
    "this is the first period after a node fires , during which its threshold level is in practice `` infinitely high '' ; thus a node can never fire within its absolute refractory period .",
    "see fig .",
    "[ fig : figure1 ] for a graphical presentation of the refractory function and its role in the main algorithm .    *",
    "the message sent when firing * + the content of a message @xmath72 sent by a node @xmath73 is the counter , which represents the number of messages received within a certain time window ( whose exact properties are described in the appendix ) that triggered @xmath74 to fire .",
    "we use the notation @xmath75 to mark the local counter at node @xmath74 and @xmath76 to mark the counter contained in a received message @xmath72 sent by node @xmath77      a full account of the proof of correctness of the summation procedure is provided in the appendix .",
    "the summation procedure is executed upon the arrival of a new message .",
    "its purpose is to decide whether this message is eligible for being counted .",
    "it is comprised of the following sub - procedures :    upon arrival of the new message , the * timeliness * procedure determines if the counter contained in the message seems `` plausible '' ( _ timely _ ) with respect to the number of other messages received recently ( it also waits a short time for such messages to possibly arrive ) .",
    "the bound on message transmission and processing time among correct nodes allows a node to estimate whether the content of a message it receives is plausible and therefore timely .",
    "for example , it does not make sense to consider an arrived message that states that it was sent as a result of receiving @xmath78 messages , if less than @xmath6 messages have been received during a recent time window . such a message",
    "is clearly seen as a faulty node by all correct nodes . on the other , a message that states that it was sent as a result of receiving @xmath78 messages , when @xmath79 messages have been received during a recent time window does not bear enough information to decide whether it is faulty or not , as other correct nodes may have decided that this message is timely , due to receiving a faulty message .",
    "such a message needs to be temporarily tabled so that it can be reconsidered for being counted in case some correct node sends a message within a short time , and which has counted that faulty message .",
    "thus , intuitively , a message will be timely if the counter in that messages is less or equal to the total number of tabled or timely messages that were received within a short recent time window .",
    "the exact length of the `` recent '' time window is a crucial factor in the algorithm .",
    "there is no fixed time after which a message is too old to be timely .",
    "the time for message exchange between correct nodes is never delayed beyond the network and processing delay .",
    "thus , the fire of a correct node , as a consequence of a message that it received , adds a bounded amount of relay time .",
    "this is the basis for the time window within which a specific counter of a message is checked for plausibility .",
    "hence , a particular counter of a message is plausible only if there is a sufficient number of other messages ( tabled or not ) that were received within a sufficiently small time window to have been relayed from one to the other within the bound on relaying between correct nodes .",
    "as an example , consider that the bound on the allowed relay interval of messages is taken to be @xmath80 time units .",
    "suppose that a correct node receives a message with counter that equals @xmath81 that message will only be considered as timely if there are at least @xmath82 messages that were received ( including the last one ) in the last @xmath83 time window .",
    "this is the main criterion for being timely . on termination of the procedure",
    "the message is said to have been * assessed*.    if a message is assessed as timely then the * make - accountable * procedure determines by how much to increment the counter .",
    "it does so by considering the minimal number of recently tabled messages that were needed in order to assess the message as timely .",
    "this number is the amount by which the counter is incremented by .",
    "a tabled message is marked as `` uncounted '' because the node s counter does not reflect this message .",
    "tabled messages that are used for assessing a message as timely become marked as `` counted '' because the node s counter now reflect these message as if they were initially timely .",
    "a node s counter at every moment is exactly the number of messages that are marked as `` counted '' at that moment .    the * prune * procedure is responsible for the tabling of messages .",
    "a correct node wishes to mark as counted , only those messages which considering the elapsed time since their arrival , will together pass the criterion for being timely at any correct nodes receiving the consequent counter to be sent .",
    "thus , messages that were initially assessed as timely are tabled after a short while .",
    "this is what causes the counter to dissipate .",
    "after a certain time messages are deleted altogether ( _ decayed _ ) .    the target of the summation procedure is formulated in the following two properties :    * summation properties : * following the arrival of a message from a correct node :    1 .",
    "the message is assessed within @xmath3 real - time units . 2 .   following assessment of the message the receiving node s counter is incremented to hold a value greater than the counter in the message .",
    "the summation procedure satisfies the summation properties by the following heuristics :    * when the counter crosses the threshold level , either due to a sufficient counter increment or a threshold decrement , then the node sends a message ( fires ) .",
    "the message sent holds the value of counter at sending time . *",
    "the timeliness procedure is employed at the receiving node to assess the credibility ( timeliness ) of the value of the counter contained in this message .",
    "this procedure ensures that messages sent by correct nodes with counter less than @xmath1 will always be assessed as timely by other correct nodes receiving this message .",
    "* when a received message is declared timely and therefore accounted for it is stored in a `` counted '' message buffer ( `` counted set '' ) .",
    "the receiving node s counter is then updated to hold a value greater than the counter in the message by the make - accountable procedure . *",
    "if a message received is declared untimely then it is temporarily stored in an `` uncounted '' message buffer ( `` uncounted set '' ) and will not be accounted for at this stage . over time",
    ", the timeliness test of previously stored timely messages may not hold any more . in this case",
    ", such messages will be moved from the counted set to the uncounted set by the prune procedure .",
    "* all messages are deleted after a certain time - period ( message decay time ) by the prune procedure .    * definitions and state variables : * +    * counter * : an integer representing the node s estimation of the number of timely firing events received from distinct nodes within a certain time window .",
    "counter is updated upon receiving a timely message .",
    "the node s counter is checked against the refractory function whenever one of them changes .",
    "the value of counter is bounded and changes non - monotonously ; the arrival of timely events may increase it and the decay / untimeliness of old events may decrease it .",
    "+    * stored message * : is a basic data structure represented as ( @xmath84 ) and created upon arrival of a message @xmath85 @xmath86 is the @xmath87 ( or signature ) of the sending node @xmath74 and @xmath88 is the local arrival time of the message .",
    "we say that two stored messages , ( @xmath89 ) and ( @xmath90 ) , are * distinct * if @xmath91 +    * counted set ( cs ) * : is a set of distinct stored messages that determine the current value of counter .",
    "the counter reflects the number of stored messages in the counted set .",
    "a stored message is * accounted for * in counter , if it was in cs when the current value of counter was determined .",
    "+    * uncounted set ( ucs ) * : is a set of stored messages , not necessarily distinct , that have not been accounted for in the current value of counter and that are not yet due to decay .",
    "a stored message is placed ( tabled ) in the ucs when its message clearly reflects a faulty sending node ( such as when multiple messages from the same node are received ) or because it is not timely anymore .",
    "+    * retired ucs ( rucs ) * : is a set of distinct stored messages not accounted for in the current value of counter due to the elapsed local time since their arrival .",
    "these stored messages are awaiting deletion ( decaying ) .",
    "+ the cs and ucs are mutually exclusive and together reflect the messages received from other nodes in the preceding time window .",
    "their union is denoted the node s * .",
    "*   + : denotes the local - time at which a node @xmath74 sent a message @xmath85 an equivalent definition of @xmath92 is the local - time at which a receiving node @xmath74 is ready to assess whether to send a message consequent to the arrival and processing of some other message .",
    "+ : is the elapsed time , at time @xmath23 on a node @xmath93 s clock since the most recent arrival of a message from node @xmath94 which arrived at local - time @xmath95 thus , its value at node @xmath93 at current local - time @xmath38 is given by @xmath96 where @xmath72 is the most recent message that arrived from @xmath77 if no stored message is held at @xmath93 for @xmath74 then @xmath97 + : denotes , at local - time @xmath23 the largest @xmath98 among the stored messages in cs of node @xmath93 .",
    "+ : denotes the function @xmath99 + * the set of procedures used by the summation procedure ( at node @xmath93 ) : *    we now cite the main theorems of the summation procedure .",
    "the proofs are given in the appendix .",
    "[ thm : timely ] any message , @xmath100 sent by a correct node @xmath74 will be assessed as timely by every correct node @xmath101    [ lem : counter_inc ] following the arrival of a timely message @xmath100 at a node @xmath102 then at time @xmath103 @xmath104    [ thm : summ_r1 ] the summation procedure satisfies the summation properties .",
    "let @xmath74 denote a correct node that sends @xmath85 theorem  [ thm : timely ] ensures that @xmath72 is assessed as timely at every correct node .",
    "lemma  [ lem : counter_inc ] ensures that the value of @xmath105 will not decrease below @xmath106 until local - time @xmath107 thereby satisfying the summation properties .",
    "[ alg : pulse - synch - alg ] shows the main algorithm .",
    "[ fig : figure1 ] illustrates the mode of operation of the main algorithm .",
    "[ sec : iagree ]    in the current subsection we show that the bio - pulse - synch algorithm can also operate in networks in which byzantine nodes may exhibit true two - faced behavior .",
    "this is done by executing in the background a self - stabilizing byzantine reliable - broadcast - like primitive , which assumes no synchronicity whatsoever among the nodes .",
    "it has the property of relaying any message received by a correct node .",
    "hence , this primitive satisfies the broadcast assumption of definition  [ def : net_nonfaulty ] by supplying a property similar to the relay property of the reliable - broadcast primitive in @xcite .",
    "that latter primitive assumes a synchronous initialization and can thus not be used as a building block for a self - stabilizing algorithm .    in @xcite",
    "we presented the primitive .",
    "we say that a node does an * * of a message @xmath108 sent by some node @xmath74 ( denoted @xmath109 ) if it accepts that this message was sent by node @xmath77    the primitive essentially satisfies the following two properties ( rephrased for our purposes ) : +    1 .",
    "( _ correctness _ ) if all correct nodes invoke @xmath109 within @xmath3 real - time of each other then all correct nodes @xmath109 within @xmath80 real - time units of the time the last correct node invokes the primitive @xmath110 2 .",
    "( _ relay _ ) if a correct node @xmath93 s @xmath109 at real - time @xmath38 , then every correct node @xmath111 s @xmath112 at some real - time @xmath113 with @xmath114    the primitive requires a correct node not to send two successive messages within less than @xmath115 real - time of each other . following the bio - pulse - synch algorithm ( see timeliness condition 2 , in the timeliness procedure ) , non - faulty nodes can not fire more than once in every @xmath116 real - time interval even if the system is not coherent , which thus satisfies this requirement .    the use of the primitive in our algorithm is by executing it in the background .",
    "when a correct node wishes to send a message it does so through the primitive , which has certain conditions for @xmath117ing a message .",
    "nodes may also  messages that where not sent or received through the primitive , if the conditions are satisfied . in our algorithm nodes will deliver messages only after they have been @xmath117ed ( also for the node s own message ) . from [ ia-1a ]",
    "we get that all messages from correct nodes are delivered within @xmath4 real - time units subsequent to sending . from [ ia-3a ]",
    "we have that all messages are delivered within @xmath80 real - time units of each other at all correct nodes , even if the sender is faulty .",
    "thus , we get that the new network delay @xmath118 hence , the cost of using the primitive is an added @xmath80 real - time units to the achieved pulse synchronization tightness which hence becomes @xmath119",
    "[ sec : s4 ] in this section we prove closure and convergence of the bio - pulse - synch algorithm . in the first subsection , [ ssec : notations ] , we present additional notations that facilitate the proofs . in the second subsection , [ ssec : closure ] , we prove closure and in the third , [ ssec : convergence ] , we prove convergence .",
    "the proof that bio - pulse - synch satisfies the pulse synchronization problem follows the steps below :    subsection  [ ssec : notations ] introduces some notations and procedures that are for proof purposes only .",
    "one such procedure partitions the correct nodes into disjoint sets of synchronized nodes ( `` synchronized clusters '' ) .",
    "in subsection  [ ssec : closure ] ( lemma  [ lem : l1 ] ) , we prove that `` synchronized clusters '' once formed stay as synchronized sets of nodes , this implies that once the system is in a synchronized_pulse_state it remains as such ( _ closure _ ) .    in subsection  [ ssec :",
    "convergence ] ( theorem  [ thm : convergence ] ) , we prove that within a finite number of cycles , the synchronized clusters repeatedly absorb to form ever larger synchronized sets of nodes , until a synchronized_pulse_state of the system is reached ( _ convergence _ ) .",
    "note that the the synchronization tightness , @xmath120 of our algorithm , equals @xmath121    it may ease following the proofs by thinking of the algorithm in the terms of non - liner dynamics , though this is not necessary for the understanding of any part of the protocol or its proofs .",
    "we show that the state space can be divided into a small number of stable fixed points ( `` synchronized sets '' ) such that the state of each individual node is attracted to one of the stable fixed points .",
    "we show that there are always at least two of these fixed points that are situated in the basins of attraction ( `` absorbance distance '' ) of each other .",
    "following the dynamics of these attractors , we show that eventually the states of all nodes settle in a limit cycle in the basin of one attractor .",
    "* first node * in a synchronized set of nodes @xmath41 is a node of the subset of nodes that `` fire first '' in @xmath122 that satisfies :    @xmath123    equivalently , we define * last node * :    @xmath124    the second cases in both definitions serve to identify the first and last nodes in case @xmath38 falls in - between the fire of the nodes of the set .",
    "* synchronized clusters * + at a given time @xmath38 the nodes are divided into disjoint * synchronized clusters * in the following way :    1 .",
    "assign the maximal synchronized set of nodes at time",
    "@xmath38 as a synchronized cluster .",
    "in case there are several maximal sets choose the set that is harboring the first node of the unified set of all these maximal sets .",
    "2 .   assign the second maximal synchronized set of nodes that are not part of the first synchronized cluster as a synchronized cluster .",
    "3 .   continue until all nodes are exclusively assigned to a synchronized cluster .",
    "the synchronized cluster harboring the node with the largest ( necessarily finite ) @xmath25 among all the nodes is designated @xmath125 the rest of the synchronized clusters are enumerated inversely to the @xmath25 of their first node , thus if there are @xmath108 synchronized clusters then @xmath126 is the synchronized cluster whose first node has the lowest @xmath25 ( besides perhaps @xmath127 ) .",
    "note that at most one synchronized cluster may have nodes whose actual @xmath25 differences is larger than @xmath120 as it can contain nodes that have just fired and nodes just about to fire .",
    "the definition of @xmath127 implies that at the time the nodes are partitioned into synchronized clusters ( time @xmath38 above ) it may be the only synchronized cluster in such a state .",
    "the clustering is done only for illustrative purposes of the proof .",
    "it does not actually affect the protocol or the behavior of the nodes . in the proof we `` assign '' the nodes to synchronized clusters at some time @xmath48 from that time on we consider the synchronized clusters as a constant partitioning of the nodes into disjoint synchronized sets of nodes and we follow the dynamics of these sets .",
    "thus , once a node is exclusively assigned to some synchronized cluster it will stay a member of that synchronized cluster .",
    "we aim at showing that eventually all synchronized clusters become one synchronized set of nodes .",
    "once such a clustering is fixated we ignore nodes that happen to fail and forthcoming recovering nodes .",
    "our proof is based on the observation that eventually we reach a time window within which the permanent number of non - correct nodes at every time is bounded by @xmath6 and during that window the whole system converges .",
    "[ cor : synch_clu ] the synchronized clustering procedure assigns every correct node to exactly one synchronized set of nodes .    [ cor : synch_clu2 ] immediately following the synchronized clustering procedure no two distinct synchronized clusters comprise one synchronized set of nodes .",
    "we use the following definitions and notations : + @xmath128 synchronized cluster number @xmath62 + @xmath129 cardinality of @xmath130 ( i.e. number of correct nodes associated with synchronized cluster @xmath130 ) .",
    "+ @xmath131 current number of synchronized clusters in the current state ; @xmath132 + @xmath133 is the * distance * ( @xmath25 difference ) between nodes @xmath134 and @xmath135 at real - time @xmath48 + @xmath136 is the @xmath137 of the first node in synchronized cluster @xmath138 + @xmath139 at real - time @xmath48 + if at real - time @xmath38 there exists no other synchronized cluster @xmath140 such that @xmath141 then we say that the synchronized clusters @xmath130 and @xmath142 are * adjacent * at real - time @xmath48    we say that two synchronized clusters , @xmath130 and @xmath143 have * absorbed * if their union comprises a synchronized set of nodes .",
    "if a node in @xmath142 fires due to a message received from a node in @xmath144 then , as will be shown in lemma  [ lem : abs_lem ] , the inevitable result is that their two synchronized clusters absorb .",
    "the course of action from the arrival of the message at a node in @xmath142 until @xmath142 has absorbed with @xmath130 is referred to as the * absorbance * of @xmath142 by @xmath138    we refer throughout the paper to the * fire of a synchronized cluster * instead of referring to the sum of the fires of the individual nodes in the synchronized cluster . in lemma",
    "[ lem : l3 ] we prove that these two notations are equivalent . + in theorem  [ thm : abs_thm ] we show that we can explicitly determine a threshold value , @xmath145 that has the property that if for two synchronized clusters @xmath130 and @xmath143 @xmath146 then @xmath130 * absorbs * @xmath147 we will call that value the `` * * absorbance distance * * '' of @xmath138    [ def : ad ] the absorbance distance , @xmath148 of a synchronized cluster @xmath144 is @xmath149 real - time units .",
    "* properties used for the proofs * + we identify and prove several properties ; one property of the summation procedure ( property 1 ) and several properties of @xmath71 ( properties 2 - 7 ) .",
    "these are later used to prove the correctness of the algorithm .",
    "see the summation properties in subsection  [ ssec : summation - sect ] .",
    "* property 2 : * @xmath150 is a monotonic decreasing function of @xmath151 @xmath152 for @xmath153 + * property 3 : * @xmath154 for @xmath155 + * property 4 : * @xmath156 for @xmath157 + * property 5 : * @xmath158 + * property 6 : * @xmath159 + consider any clustering of @xmath37 correct nodes into @xmath160 synchronized clusters , in which @xmath161 denotes the largest synchronized .",
    "thus @xmath162 is the number of nodes in the largest synchronized cluster and is less or equal to @xmath163 the number of nodes in the second largest cluster is less or equal to @xmath164 + * property 7 : * @xmath165    we require the following restriction on the relationship between @xmath166 and @xmath6 in order to prove that properties  3 - 4 hold : + * restriction 1 : * @xmath167}{\\frac{1-\\rho}{n - f}-3\\rho+\\rho^2}\\enspace .\\label{eq : f - vs - cycle}\\ ] ] + we now prove that properties 2 - 7 are properties of @xmath71 :    [ lem : ref_props ] properties 2 - 5 are properties of @xmath71 under restriction 1 .",
    "the proof for properties 2 and 5 follows immediately from the definition of @xmath71 in eq .",
    "[ eq : ref ] .",
    "note that @xmath168 for @xmath169 and @xmath170 moreover , for @xmath171 property  4 is more restrictive than property  3 .",
    "hence , for showing that properties  3 and 4 are properties of @xmath71 it is sufficient to show that @xmath172 ( where @xmath173 ) satisfies property  4 :    @xmath174(f+1 ) \\rightarrow\\nonumber\\\\ & & \\frac{1}{1-\\rho}{\\mbox{\\slshape cycle}}-\\frac{\\rho}{1-\\rho}(n - f){\\mbox{\\slshape cycle}}- \\frac{2\\rho}{1+\\rho}(n - f){\\mbox{\\slshape cycle}}\\nonumber\\\\&&{\\makebox[1.9cm]{}}{\\makebox[1.2cm]{}}>[d(1-\\rho ) ( f+1)+2d(1+\\rho)\\cdot\\frac{(\\frac{1+\\rho}{1-\\rho})^{n+3}-1}{(\\frac{1+\\rho}{1-\\rho})-1}](n - f ) \\rightarrow\\nonumber\\\\ & & [ \\frac{1-\\rho(n - f)}{1-\\rho}- \\frac{2\\rho}{1+\\rho}(n - f)]{\\mbox{\\slshape cycle}}\\nonumber\\\\&&{\\makebox[1.9cm]{}}{\\makebox[1.2cm]{}}>d[(1-\\rho ) ( f+1)+2(1+\\rho)\\cdot\\frac{(\\frac{1+\\rho}{1-\\rho})^{n+3}-1}{(\\frac{1+\\rho}{1-\\rho})-1}](n - f ) \\rightarrow\\nonumber\\\\ & & [ \\frac{(\\frac{1}{n - f}-\\rho)(1+\\rho)-2\\rho(1-\\rho)}{1-\\rho^2}]{\\mbox{\\slshape cycle}}>d[(1-\\rho ) ( f+1)+2(1+\\rho)\\cdot\\frac{(\\frac{1+\\rho}{1-\\rho})^{n+3}-1}{(\\frac{1+\\rho}{1-\\rho})-1 } ] \\rightarrow\\nonumber\\\\ & & \\frac{\\frac{1-\\rho}{n - f}-3\\rho+\\rho^2}{1-\\rho^2}{\\mbox{\\slshape cycle}}>d[(1-\\rho ) ( f+1)+2(1+\\rho)\\cdot\\frac{(\\frac{1+\\rho}{1-\\rho})^{n+3}-1}{(\\frac{1+\\rho}{1-\\rho})-1 } ] \\rightarrow\\nonumber\\\\ & & { \\mbox{\\slshape cycle}}>d\\cdot\\frac{(1-\\rho^2)[(1-\\rho ) ( f+1)+2(1+\\rho)\\cdot\\frac{(\\frac{1+\\rho}{1-\\rho})^{n+3}-1}{(\\frac{1+\\rho}{1-\\rho})-1}]}{\\frac{1-\\rho}{n - f}-3\\rho+\\rho^2 } \\enspace .",
    "\\label{eq : props2 - 5}\\end{aligned}\\ ] ]    this inequality is exactly satisfied by restriction 1 and thus eq .  [ eq : ref ] satisfies properties  3 and 4 .    note that for @xmath175 the inequality becomes @xmath176    [ lem : ref_prop_6 ] property 6 is a property of @xmath177    @xmath178    [ lem : ref_prop_7 ] property 7 is a property of @xmath71 .",
    "we will prove that the constraint in eq .",
    "[ eq : prop7 ] is always satisfied by the refractory function in eq .",
    "[ eq : ref ] .",
    "note that eq .",
    "[ eq : prop7 ] is a linear equation of the @xmath150 values of @xmath71 .",
    "we denoted @xmath162 to be the number of nodes in the largest synchronized cluster , following some partitioning of the correct nodes into synchronized clusters .",
    "we want to find what is the largest value of @xmath179 such that @xmath150 is a value with a non - zero coefficient in the linear equation eq .",
    "[ eq : prop7 ] .",
    "this value is determined by either the largest possible cluster , which may be of size @xmath180 ( in case all but one of the correct nodes are in one synchronized cluster correct nodes are in one synchronized cluster implies the objective has been reached . ] ) , or by the second - largest possible cluster , which may be of size @xmath181 ( in case all correct nodes are in two possibly equally sized synchronized clusters ) .",
    "thus the largest value of @xmath179 such that @xmath150 is a value with a non - zero coefficient equals max[@xmath182=n - f-1,$ ] for @xmath183    thus , following eq .",
    "[ eq : ref ] , each of these @xmath150 values equals @xmath184 there are exactly @xmath37 ( not necessarily different ) @xmath150 values in eq .",
    "[ eq : prop7 ] . hence ,",
    "incorporating eq .",
    "[ eq : ref ] into eq .",
    "[ eq : prop7 ] reduces eq .",
    "[ eq : prop7 ] to the linear equation : @xmath185 where @xmath186 it remains to show that eq .",
    "[ eq : ref ] satisfies this constraint : @xmath187      we now show that a synchronized set of nodes stays synchronized .",
    "this also implies that the constituent nodes of a synchronized clusters stay as a synchronized set of nodes , as a synchronized cluster is in particular a synchronized set of nodes .",
    "this proves the first closure requirement of the `` pulse synchronization '' problem in definition  [ def : pulse - synch ] .",
    "[ lem : l1 ] a set of correct nodes that is a synchronized set at real - time @xmath188 remains synchronized @xmath189    let there be a synchronized set of nodes at real - time @xmath190 from the definition of a synchronized set of nodes , this set of nodes will stay synchronized as long as no node in the set fires .",
    "this is because the @xmath25 difference between nodes ( in real - time units ) does not change as long as none of them fires .",
    "we therefore turn our attention to the first occasion after @xmath191 at which a node from the set fires .",
    "let us examine the extreme case    of a synchronized set consisting of at least two nodes at the maximal allowed @xmath25 difference ; that is to say that at time @xmath188 @xmath192 further assume that the first node in the set fires with a counter=@xmath193 @xmath194 at some time @xmath195 at the very beginning of its threshold level @xmath193 and without loss of generality is also the first node in the set to fire after time @xmath190 we will show that the rest of the nodes in the set will fire within the interval @xmath196 $ ] and thus remains a synchronized set .",
    "property  1 ensures that the last node s counter will read at least @xmath82 subsequently to the arrival and assessment of the first node s fire , since its counter should be at least the first node s counter plus @xmath197 the proof of the lemma will be done by showing that right after the assessment of the first node s fire , the last node can not be at a threshold higher than @xmath82 and thus will necessarily fire .    the proof is divided into the following steps :    1 .",
    "show that when the first node is at threshold level @xmath198 then the last node is at threshold level @xmath82 or lower .",
    "2 .   show that if the first node fires with a counter=@xmath198 then due to property 1 and step 1 the last node will fire consequently .",
    "3 .   show that the last node fires within a @xmath3 real - time window of the first node , and as a result , the new distance between the first and last node is less than or equal to @xmath199    observe that the extreme case considered is a worst case since if the largest @xmath25 difference in the set is less than @xmath18 then the threshold level of the last node may only be lower .",
    "the same argument also holds if the first node fires after its beginning of its threshold level @xmath81 thus the steps of the proofs also apply to any intermediate node in the synchronized set and thus remains as a synchronized set of nodes .",
    "* step 1 : * in this step we aim at calculating the amount of time on the last node s clock remaining until it commences its threshold level @xmath193 counting from the event in which the first nodes commences its threshold level @xmath81 by showing that this remaining time is less than the length of threshold level @xmath200 as counted on the clock of the last and slowest node we conclude that this node must be at most at threshold level @xmath201 the calculations are done on the slow node s clock .",
    "assume the first node to be the fastest permissible node and the last one the slowest .",
    "hence , when the first node s threshold level @xmath198 commences , @xmath202 real - time units actually passed since it last fired .",
    "the last node `` counted '' this period as : @xmath203    the last node has to count on its clock , from the time that the first node fired , at most @xmath204 local - time units ( max .",
    "@xmath25 difference of correct nodes in a synchronized set as counted by the slowest node ) , and    @xmath205    in order to reach its own threshold level @xmath81 as a result , the maximum local - time difference between the time the first node starts its threshold level @xmath198 till the last node starts its own threshold level @xmath198 as counted by the last node is therefore @xmath206 plus the difference eq .",
    "[ eq : slowk ]  eq .",
    "[ eq : e7 ] , which yields    @xmath207    property  4 ensures that @xmath208 is greater than eq .",
    "[ eq : e8 ] for @xmath209 thus when the first node commences threshold level @xmath198 the last node must be at a threshold level that is less or equal to @xmath201    * step 2 : * let the first node fire as a result of its counter equalling @xmath198 at time @xmath38 at threshold level @xmath81 in case that the last node receives almost immediately the first node s fire ( and thus increments its counter to at least @xmath82 following property  1 ) , it must be at a threshold level that is less or equal to @xmath82 ( following step  1 ) and will therefore fire .",
    "all the more so if the first node s fire is received later , since the threshold level can only decrease in time before a node fires .",
    "* step 3 : * we now need to estimate the new distance between the first and last node in order to show that they still comprise a synchronized set .",
    "the last node assesses the first node s fire within @xmath3 real - time units after the first node sent its message ( per definition of @xmath3 ) .",
    "this yields a distance of @xmath210 as seen by the last node , which equals the maximal allowed real - time distance , @xmath211 between correct nodes in a synchronized set at real - time @xmath188 and thus they stay a synchronized set at time  @xmath190    [ cor : closure1 ] ( closure 1 ) lemma  [ lem : l1 ] implies the first closure condition .",
    "[ lem : closure2 ] ( closure 2 ) as long as the system state is in a + synchronized_pulse_state then the second closure condition holds .    due to lemma  [ lem : l1 ] the first node to fire in the synchronized set following its previous pulse , may do so only if it receives the fire from faulty nodes or if it fires endogenously .",
    "this may happen the earliest if it receives the fire from exactly @xmath6 distinct faulty nodes . thus following eq .",
    "[ eq : ref ] its cycle might have been shortened by at most @xmath212 real - time units . hence , in case the first node to fire is also a fast node , it follows that @xmath213 real - time units .",
    "a node may fire at the latest if it fires endogenously .",
    "if in addition it is a slow node then it follows that @xmath214 real - time units .",
    "thus in any real - time interval that is less or equal to @xmath29 any correct node will fire at most once . in any real - time interval that is greater or equal to @xmath30 any correct node will fire at least once .",
    "this concludes the second closure condition .",
    "the proof of convergence is done through several lemmata .",
    "we begin by presenting sufficient conditions for two synchronized clusters to absorb . in subsection",
    "[ ssec : s4.2 ] , we show that the refractory function @xmath71 ensures the continuous existence of a pair of synchronized clusters whose unified set of nodes is not synchronized , but are within an absorbance distance and hence absorb . thus , iteratively , all synchronized clusters will eventually absorb to form a unified synchronized set of nodes .",
    "+    [ lem : abs_lem ] ( conditions for absorbance ) given two synchronized clusters , @xmath130 preceding @xmath143 if :    1 .",
    "@xmath130 fires with counter=@xmath193 at real - time @xmath215 where @xmath216 2 .",
    "@xmath217    then @xmath130 will absorb @xmath218    the proof is divided into the following steps :    1 .   1 .   if @xmath130 fires before @xmath143 then @xmath142 consequently fires",
    "subsequent to the previous step : @xmath219 2 .",
    "following the previous step , within one cycle the constituent nodes of the two synchronized clusters comprise a synchronized set of nodes .    *",
    "step 1a : * let us examine the case in which @xmath130 fires first at some real - time denoted @xmath215 and in the worst case that @xmath142 does nt fire before it receives all of @xmath130 s fire .",
    "all the calculations assume that at @xmath215 @xmath220 has still not been reset to 0 .",
    "specifically , assume that the first node in @xmath130 fired due to incrementing its counter to @xmath198 @xmath221 at the beginning of its threshold level @xmath81 following property 1 and lemma  [ lem : l3 ] the nodes of @xmath142 increment their counters to @xmath222 after receiving the fire of @xmath138 additionally , in the worst case , assume that the first node in @xmath142 receives the fire of @xmath130 almost immediately .",
    "we will now show that this fire is received at a threshold level @xmath223    we will calculate the upper - bound on the @xmath25 of the first node in @xmath142 at real - time @xmath215 and hence deduce the upper - bound on its threshold level .",
    "assume the nodes of @xmath130 are fast and the nodes of @xmath142 are slow .",
    "should the nodes of @xmath142 be faster , then the threshold level may only be lower .",
    "@xmath224 \\nonumber\\\\   & & = \\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g\\nonumber -[\\frac{1}{1-\\rho}\\sum_{g = k+1 } ^{k+n_i } \\!\\!r_g- \\frac{2\\rho}{1-\\rho^2}\\sum_{g = k+1}^{n+1}\\!\\!r_g]\\enspace\\\\ & & = \\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g\\nonumber - [ \\frac{1}{1-\\rho}\\sum_{g = k+1 } ^{k+n_i } \\!\\!r_g+ ( \\frac{1}{1+\\rho}-\\frac{1}{1-\\rho})\\sum_{g = k+1}^{n+1}\\!\\!r_g]\\enspace\\\\ & & = \\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g\\nonumber -[(\\frac{1}{1+\\rho}-(\\frac{1}{1+\\rho}-\\frac{1}{1-\\rho}))\\sum_{g = k+1 } ^{k+n_i } \\!\\!r_g+ ( \\frac{1}{1+\\rho}-\\frac{1}{1-\\rho})\\sum_{g = k+1}^{n+1}\\!\\!r_g]\\enspace\\\\ & & = \\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g\\nonumber -[\\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1 } ^{k+n_i } \\!\\!r_g+ ( \\frac{1}{1+\\rho}-\\frac{1}{1-\\rho})\\!\\!\\sum_{g = k+1+n_i } ^{n+1 } \\!\\!\\!\\!\\!r_g]\\enspace\\\\ & & = \\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g\\nonumber -[\\frac{1}{1+\\rho}\\!\\!\\sum_{g = k+1}^{n+1}\\!\\!r_g - \\frac{1}{1-\\rho}\\!\\!\\sum_{g = k+1+n_i}^{n+1}\\!\\!\\!\\!\\!r_g]\\enspace\\\\ & & = \\frac{1}{1-\\rho}\\!\\!\\sum_{g = k+1+n_i}^{n+1}\\!\\!\\!\\!\\!r_g\\;.\\nonumber\\enspace\\\\ & & \\label{eq : phase_cj}\\end{aligned}\\ ] ]    we now seek to deduce the bound on @xmath142 s threshold level at the time of @xmath130 s fire .",
    "thus , following eq .",
    "[ eq : phase_cj ] , at real - time @xmath225 the @xmath25 of the first node in @xmath142 is at most @xmath226 we assumed the worst case in which the constituent correct nodes of @xmath142 are slow , thus these nodes have counted on their timers at least @xmath227 time units since their last pulse . hence , the correct nodes of @xmath142 are at real - time @xmath225 at most in threshold level @xmath228 should @xmath229 or the fire of @xmath130 be received at a delay , then this may only cause the threshold level at time of assessment of the fire from @xmath130 to be equal or even smaller than @xmath228 thus , lemma  [ lem : l1 ] and property  1 guarantee that the first node in @xmath142 will thus fire and that the rest of the nodes in both synchronized clusters will follow their respective first ones within @xmath18 real - time units . + * step 1b : * we seek to estimate the maximum distance between the two synchronized clusters following the fire of @xmath147 the first node in @xmath142 will fire at the latest upon receiving and assessing the message of the last node in @xmath138 more precisely , fire at the latest @xmath3 real - time units following the fire of the last node in @xmath144 yielding a new @xmath230 of at most @xmath80 real - time units regardless of the previous @xmath231 @xmath232 @xmath198 and @xmath233 the last node of @xmath142 is at most at a distance of @xmath3 from the first node of @xmath142 therefore making the maximal distance between the first node of @xmath130 and the last node of @xmath143 at the moment it fires , equal @xmath4 real - time units . +",
    "* step 2 : * we will complete the proof by showing that after @xmath130 causes @xmath142 to fire , the two synchronized clusters actually absorb .",
    "we need to show that in the cycle subsequent to step 1 , the nodes that constituted @xmath130 and @xmath142 become a synchronized set .",
    "examine the case in which following step 1 , either one of the two synchronized clusters increment its counter to @xmath234 and fires at the beginning of threshold level @xmath235 we will observe the @xmath25 of the first node to fire , denoted by @xmath236 following the same arguments as in step 1 , all other nodes increment their counters to @xmath237 after receiving this node s fire .",
    "consider that this happens at the moment that this first node incremented its counter to @xmath234 and fired , denoted @xmath238 below we compute , using property  3 , the lower bound on the @xmath25 of the rest of the nodes at real - time @xmath239 denoted @xmath240    @xmath241    in the worst case , the rest of the constituent nodes that were in @xmath130 and @xmath142 are slow nodes and thus , at real - time @xmath239 counted :    @xmath242    time units since their last pulse .",
    "due to property  3 all these correct nodes receive the fire and increment their counters to @xmath237 in a threshold level which is less or equal to @xmath237 and will fire as well within @xmath3 real - time units of the first node in the second cycle .",
    "[ thm : abs_thm ] ( conditions for absorbance ) given two synchronized clusters , @xmath130 preceding @xmath143 if :    1 .",
    "@xmath130 fires with counter=@xmath193 at real - time @xmath215 where @xmath243 and 2 .",
    "@xmath244 @xmath245 for which @xmath246    then @xmath130 will absorb @xmath147    denote @xmath247 the real - time at which @xmath142 previously fired before time @xmath248 given that at some time @xmath23 where @xmath249 @xmath250 we wish to calculate the maximal possible distance between the two synchronized clusters at real - time @xmath215 the time at which @xmath130 fires with counter=@xmath193 where @xmath251 + under the above assumptions , the maximal possible distance at real - time @xmath225 is obtained when @xmath252 and when at time @xmath247 the distance between @xmath130 and @xmath142 was exactly @xmath148 i.e",
    "@xmath253 the upper bound on @xmath254 takes into account that from @xmath255 previous real - time firing time , @xmath256 and until real - time @xmath215 the nodes of @xmath130 were fast and that from real - time @xmath247 and until @xmath215 the nodes of @xmath142 were slow .",
    "thus the bound on @xmath257 becomes the real - time difference between these :    @xmath258    eq .",
    "[ eq : calc_ad ] is the upper bound on the distance between the two synchronized clusters at real - time @xmath215 thus following lemma  [ lem : abs_lem ] , the two synchronized clusters absorb .      in the coming subsection",
    "we look at the correct nodes as partitioned into synchronized clusters ( at some specific time ) .",
    "observation  [ cor : synch_clu2 ] ensures that no two of these synchronized clusters comprise one synchronized set of nodes .",
    "the objective of theorem  [ thm : t2 ] is to show that within finite time , at least two of these synchronized clusters will comprise one synchronized set of nodes .",
    "specifically , we show that in any state that is not a synchronized_pulse_state of the system , there are at least two synchronized clusters whose unified set of nodes is not a synchronized set but that are within absorbance distance of each other , and consequently they absorb .",
    "thus , eventually all synchronized clusters will comprise a synchronized set of nodes .",
    "we claim that if the following relationship between @xmath71 and @xmath7 is satisfied , then absorbance ( of two synchronized clusters whose unified set is not a synchronized set ) , is ensured irrespective of the states of the synchronized clusters .",
    "let @xmath259 denote the largest synchronized cluster .",
    "the theorem below , theorem  [ thm : t2 ] , shows that for a given clustering of @xmath37 correct nodes into @xmath260 synchronized clusters and for @xmath34 @xmath261 @xmath7 and @xmath71 that satisfy    @xmath262    there exist at least two synchronized clusters , whose unified set is not a synchronized set of nodes , that will eventually undergo absorbance . + note that eq .",
    "[ eq : e14 ] is derived from property 7 ( eq .",
    "[ eq : prop7 ] ) :    eq .",
    "[ eq : prop7 ] derives the following equation ( since the @xmath263 values are non - negative ) ,    @xmath264    incorporating the absorbance distance of definition  [ def : ad ] into eq .  [",
    "eq : e141 ] yields exactly eq .",
    "[ eq : e14 ] .",
    "we use eq .",
    "[ eq : e14 ] in theorem  [ thm : t2 ] instead of eq .",
    "[ eq : prop7 ] ( property 7 ) for readability of the proof .",
    "[ thm : t2 ] ( absorbance ) assume a clustering of @xmath37 correct nodes into @xmath260 synchronized clusters at real - time @xmath265 further assume that eq .",
    "[ eq : e14 ] holds for the resulting clustering",
    ". then there will be at least one synchronized cluster that will absorb some other synchronized cluster by real - time @xmath266    note that following the synchronized cluster procedure , the unified set of the two synchronized clusters that will be shown to absorb , are not necessarily a synchronized set of nodes at time @xmath265 assume without loss of generality that @xmath259 is the synchronized cluster with the largest number of nodes , consequent to running the clustering procedure .",
    "exactly one out of the following two possibilities takes place at @xmath50 :    1 .",
    "@xmath267 such that @xmath268 2 .",
    "@xmath269    consider case 1 .",
    "following the protocol , @xmath130 must fire within @xmath7 local - time units of @xmath265 observe the first real - time , denoted @xmath270 at which @xmath130 fires subsequent to real - time @xmath265 assume that @xmath271 is the number of distinct inputs that causes the counter of at least one node in @xmath130 to reach the threshold and fire ( not counting the fire from nodes in @xmath130 itself ) . if @xmath272 then at least one correct node outside of @xmath130 caused some node in @xmath130 to fire .",
    "this correct node must belong to some synchronized cluster which is not @xmath138 we denote this synchronized cluster @xmath273 as its identity is irrelevant for the sake of the argument .",
    "we assumed that at least one node in @xmath130 fired due to a node in @xmath274 following lemma  [ lem : l1 ] the rest of the nodes in @xmath138 will follow as well , as a synchronized cluster is in particular a synchronized set of nodes .",
    "this yields a new @xmath275 of at most @xmath276 following the same arguments as in step 2 of lemma  [ lem : abs_lem ] , @xmath273 and @xmath130 hence absorb .",
    "therefore the objective is reached .",
    "hence assume that @xmath277 and that @xmath130 did not absorb with any preceding synchronized cluster .",
    "thus , the last real - time that @xmath278 fired , denoted @xmath279 was before or equal to real - time @xmath280 i.e. @xmath281 and @xmath268 by theorem  [ thm : abs_thm ] , @xmath130 will absorb @xmath282 + consider case 2 .",
    "we do not assume that @xmath283 assume that there is no absorbance until @xmath259 fires ( otherwise the claim is proven ) .",
    "let @xmath284 denote the real - time at which the first node in @xmath259 fires , at which @xmath285 there are two possibilities at @xmath284 :    * @xmath286 such that at @xmath287 * @xmath288    consider case 2a .",
    "this case is equivalent to case 1 . the last real - time that @xmath278 fired , denoted @xmath279 was before or equal to real - time @xmath289 denote @xmath290 the real - time at which the first node of @xmath130 fires",
    "thus , @xmath291 and @xmath292 by theorem  [ thm : abs_thm ] , @xmath130 will absorb @xmath282 + consider case 2b .",
    "we wish to calculate @xmath293 and from this deduce the upper bound on the threshold level of the first node in @xmath294 at real - time @xmath289 we first want to point out that @xmath295 this stems from the fact that @xmath259 has just fired and that @xmath259 and @xmath294 are adjacent synchronized clusters which implies that @xmath296 recall that @xmath285 from the case considered in 2b we have that @xmath297 thus eq .  [ eq : calc_phi_ciplus1 ] follows .",
    "following eq .",
    "[ eq : e14 ] and eq .",
    "[ eq : calc_phi_ciplus1 ] we get :    @xmath298    in the worst case the nodes of @xmath294 are slow .",
    "thus at real - time @xmath284 they have measured , from their last pulse , at least @xmath299=\\sum_{g = n_{j^\\prime+1}}^{n+1}\\!\\!r_g$ ] local - time units .",
    "thus , following property 1 , the first node in @xmath294 receives the fire from @xmath259 and increment its counter to at least @xmath162 in a threshold level which is less or equal to @xmath162 and will thus fire as well .",
    "following lemma  [ lem : l1 ] the rest of the synchronized cluster will follow as well .",
    "this yields a new @xmath300 of at most @xmath276 following the same arguments as in step 2 of lemma  [ lem : abs_lem ] , @xmath259 and @xmath294 hence absorb .",
    "thus at least two synchronized clusters will absorb within @xmath301 of @xmath50 which concludes the proof .",
    "the following theorem assumes the worst case of @xmath302    [ thm : convergence ] ( convergence ) within at most @xmath303 real - time units the system reaches a synchronized_pulse_state .",
    "assume that @xmath302 thus , the maximal number of synchronized clusters is @xmath304 and since following theorem  [ thm : t2 ] at least two synchronized clusters absorb in every two cycles we obtain the bound .",
    "the protocol operates in two epochs : in the first epoch there is no limitations on the number of failures and faulty nodes . in this epoch",
    "the system might be in any state . in the second epoch",
    "there are at most @xmath6 nodes that may behave arbitrarily at the same time , from which the protocol may start to converge .",
    "nodes may fail and recover and nodes that have just recovered need time to synchronize .",
    "therefore , we assume that eventually we have a window of time within which the turnover between faulty and non - faulty nodes is sufficiently low and within which the system inevitably converges ( theorem  [ thm : t2 ] )",
    ".    * authentication and fault ratio : * the algorithm does not require the power of unforgeable signatures , only an equivalence to an authenticated channel is required .",
    "note that the shared memory model ( @xcite ) has an implicit assumption that is equivalent to an authenticated channel , since a node `` knows '' the identity of the node that wrote to the memory it reads from .",
    "a similar assumption is also implicit in many message passing models by assuming a direct link among neighbors , and as a result , a node `` knows '' the identity of the sender of a message it receives .",
    "many fundamental problems in distributed networks have been proven to require @xmath305 nodes to overcome @xmath6 concurrent byzantine faults in order to reach a deterministic solution without authentication  @xcite .",
    "we have not shown this relationship to be a necessary requirement for solving the `` pulse synchronization '' problem but the results for related problems lead us to believe that a similar result should exist for the `` pulse synchronization '' problem .",
    "there are algorithms that have no lower bound on the number of nodes required to handle @xmath6 byzantine faults , but unforgeable signatures are required as all the signatures in the message are validated by the receiver  @xcite .",
    "this is costly time - wise , it increases the message size , and it introduces other limitations , which our algorithm does not have .",
    "moreover , within the self - stabilizing paradigm , using digital signatures to counter byzantine nodes exposes the protocols to `` replay - attack '' which might empty its usefulness .    *",
    "convergence time : * we have shown in @xcite that self - stabilizing byzantine clock synchronization can be derived from self - stabilizing byzantine pulse synchronization .",
    "conversely , self - stabilizing byzantine clock synchronization can be used to trivially produce self - stabilizing byzantine pulse synchronization .",
    "thus the two problems are supposedly equally hard .",
    "the only self - stabilizing byzantine clock synchronization algorithms besides @xcite are found in  @xcite .",
    "the randomized self - stabilizing byzantine clock synchronization algorithm published there synchronizes in @xmath306 steps , where @xmath307 is the upper bound on the clock values held by individual processors .",
    "the algorithm uses message passing , it allows transient and permanent faults during convergence , requires at least @xmath305 processors , but utilizes a global pulse system . an additional algorithm in  @xcite ,",
    "does not use a global pulse system and is thus partially synchronous similar to our model .",
    "the convergence time of the latter algorithm is @xmath308 this is drastically higher than our result , which has a cycle length of @xmath309 time units and converges within @xmath310 cycles .",
    "the convergence time of the only other correct self - stabilizing byzantine pulse synchronization algorithm @xcite has a cycle length of @xmath311 time units and converges within 6 cycles .",
    "* message and space complexity : * the size of each message is @xmath312 bits .",
    "each correct node multicasts exactly one message per cycle .",
    "this yields a message complexity of at most @xmath1 messages per cycle .",
    "the system s message complexity to reach synchronization from any arbitrary state is at most @xmath313 messages per synchronization from any arbitrary initial state .",
    "the faulty nodes can not cause the correct nodes to fire more messages during a cycle .",
    "comparatively , the self - stabilizing clock synchronization algorithm in  @xcite sends @xmath1 messages during a pulse and thus has a message complexity of @xmath314 this is significantly larger than our message complexity irrespective of the time interval between the pulses .",
    "the message complexity of the only other correct self - stabilizing byzantine pulse synchronization @xcite equals @xmath315 per cycle .",
    "the space complexity is @xmath316 since the variables maintained by the processors keep only a linear number of messages recently received and various other small range variables .",
    "the number of possible states of a node is linear in @xmath1 and the node does not need to keep a configuration table .    the message broadcast assumptions , in which every message , even from a faulty node , eventually arrives at all correct nodes , still leaves the faulty nodes with certain powers of multifaced behavior since we assume nothing on the order of arrival of the messages .",
    "consecutive messages received from the same source within a short time window are ignored , thus , a faulty node can send two concomitant messages with differing values such that two correct nodes might receive and relate to different values from the same faulty node .",
    "* tightness of synchronization : * in the presented algorithm , the invocation of the pulses of the nodes will be synchronized to within the bound on the relay time of messages sent and received by correct nodes . in the broadcast version ,",
    "this bound on the relay time equals @xmath3 real - time units .",
    "note that the lower bound on clock synchronization in completely connected , fault - free networks  @xcite is @xmath317 we have shown in section  [ sec : iagree ] how the algorithm can be executed in non - broadcast networks to achieve a synchronization tightness of @xmath318 comparatively , the clock synchronization algorithm of  @xcite reaches a synchronization tightness typical of clock synchronization algorithms of @xmath319 where @xmath320 is the time between re - synchronizations . the second byzantine clock synchronization algorithm in  @xcite reaches a synchronization tightness which is in the magnitude of @xmath321",
    "this is significantly less tight than our result .",
    "the tightness of the self - stabilizing byzantine pulse synchronization in @xcite equals @xmath4 real - time units .",
    "* firing frequency bound : * the firing frequency upper bound during normal steady - state behavior is around twice that of the endogenous firing frequency of the nodes .",
    "this is because @xmath322 this bound is influenced by the fraction of faulty nodes ( the sum of the first @xmath6 threshold steps relative to ) . for @xmath323",
    "this translates to @xmath324 thus , if required , the firing frequency bound can be closer to the endogenous firing frequency of @xmath325 if the fraction of faulty nodes is assumed to be lower .",
    "for example , for a fraction of fault nodes of @xmath326 the lower bound on the cycle length , @xmath327 becomes approximately @xmath328 that of the endogenous cycle length .",
    "@xmath329 real - time units .",
    "we developed and presented the `` pulse synchronization '' problem in general , and an efficient linear - time self - stabilizing byzantine pulse synchronization algorithm , bio - pulse - synch , as a solution in particular .",
    "the pulse synchronization problem poses the nodes with the challenge of invoking regular events synchronously .",
    "the system may be in an arbitrary state in which there can be an unbounded number of byzantine faults .",
    "the problem requires the pulses to eventually synchronize from any initial state once the bound on the permanent number of byzantine failures is less than a third of the network .",
    "the problem resembles the clock synchronization problem though there is no `` value '' ( e.g. clock time ) to agree on , rather an event in time .",
    "furthermore , to the best of our knowledge , the only efficient self - stabilizing byzantine clock synchronization algorithm assumes a background pulse synchronization module .",
    "the algorithm developed is inspired by and shares properties with the lobster cardiac pacemaker network ; the network elements ( the neurons ) fire in tight synchrony within each other , whereas the synchronized firing pace can vary , up to a certain extent , within a linear envelope of a completely regular firing pattern .",
    "a number of papers have recently postulated on the similarity between elements connected with biological robustness and design principles in engineering @xcite . in the current paper",
    "we have observed and understood the mechanisms for robustness in a comprehensible and vital biological system and shown how to make specific use of analogies of these elements in distributed systems in order to attain high robustness in a practical manner .",
    "the same level of robustness has not been practically achieved earlier in distributed systems .",
    "we postulate that our result elucidates the feasibility and adds a solid brick to the motivation to search for and to understand biological mechanisms for robustness that can be carried over to computer systems .",
    "the neural network simulator sonn ( @xcite ) was used in early stages of developing the algorithm for verification of the protocol in the face of probabilistic faults and random initial states .",
    "it is worth noting that the previous pulse synchronization procedure found in @xcite was mechanically verified at nasa larc ( @xcite ) which greatly facilitated uncovering its flaw .",
    "a natural next step should thus be to undergo simulation and mechanical verification of the current protocol that can mimic a true distributed system facing transient and byzantine faults .",
    "xx u. alon , m.g .",
    "surette , n. barkai , s. leibler , `` _ robustness in bacterial chemotaxis _ '' , nature , 397(6715):168 - 71 , jan 14 1999 .",
    "g. e. andrews , `` _ the theory of partitions _ '' , encyclopedia of mathematics and its applications , vol .",
    "2 , addison - wesley , reading , ma , 1976 .",
    "j. brzezinski , and m. szychowiak ,  _ self - stabilization in distributed systems - a short survey _ , foundations of computing and decision sciences , vol .",
    "25 , no . 1 , 2000 .",
    "j. buck , and e. buck , `` _ synchronous fireflies _ '' , scientific american , vol .",
    "234 , pp . 74 - 85 , may 1976 .",
    "a. daliot , d. dolev and h. parnas , `` _ linear time byzantine self - stabilizing clock synchronization _ '' , proc . of 7th international conference on principles of distributed systems ( opodis03 la martinique , france ) , december , 2003 .",
    "note : a full revised version appears in http://arxiv.org/abs/cs.dc/0608096    a. daliot and d. dolev , `` _ self - stabilization of byzantine protocols _ '' , proc . of the 7th symposium on self - stabilizing systems ( sss05 barcelona ) , pp .",
    "48 - 67 , 2005 .",
    "a. daliot and d. dolev , `` _ self - stabilizing byzantine agreement _ '' , proc . of twenty - fifth acm symposium on principles of distributed computing ( podc06 ) , denver ,",
    "colorado , july 2006 .",
    "a. daliot and d. dolev , ",
    "_ self - stabilizing byzantine token circulation _ \" , technical report tr2005 - 77 , school of engineering and computer science , the hebrew university of jerusalem , june 2005 .",
    "url : http://leibniz.cs.huji.ac.il/tr/834.pdf    a. daliot and d. dolev ,  _ self - stabilizing byzantine pulse synchronization _ \" , cornell arxiv , aug . 2005 .",
    "url : http://arxiv.org/abs/cs.dc/0608092    d. dolev , j. halpern , and h. r. strong , `` _ on the possibility and impossibility of achieving clock synchronization _ '' , j. of computer and systems science , vol .",
    "32:2 , pp .",
    "230 - 250 , 1986 .",
    "d. dolev , j. y. halpern , b. simons , and r. strong , `` _ dynamic fault - tolerant clock synchronization _ '' , j. assoc .",
    "computing machinery , vol .",
    "42 , no.1 , pp .",
    "143 - 185 , jan . 1995 .",
    "s. dolev , `` _ self - stabilization _ , '' the mit press , 2000 .",
    "s. dolev and j. l. welch , `` _ self - stabilizing clock synchronization in the presence of byzantine faults _ '' , journal of the acm , vol .",
    "51 , issue 5 , pp .",
    "780 - 799 , 2004 .",
    "s. dolev and j. l. welch , `` _ wait - free clock synchronization _ '' , algorithmica , 18(4):486 - 511 , 1997 .",
    "f. c. freiling and s. ghosh , `` _ code stabilization _ '' , proc . of the 7th symposium on self - stabilizing systems ( sss05 barcelona ) ,",
    "128 - 139 , 2005 .    wo .",
    "friesen , `` _ physiological anatomy and burst pattern in the cardiac ganglion of the spiny lobster panulirus interuptus _ '' , j. comp .",
    ", vol . 101 , pp .",
    "173 - 189 , 1975 .",
    "wo . friesen , `` _",
    "synaptic interaction in the cardiac ganglion of the spiny lobster panulirus interuptus _ '' , j. comp .",
    ", vol . 101 , pp .",
    "191 - 205 , 1975 .",
    "m. j. fischer , n. a. lynch and m. merritt , `` _ easy impossibility proofs for distributed consensus problems _ '' , distributed computing , vol .",
    "1 , pp . 26 - 39 , 1986 .",
    "h. kitano , `` _ biological robustness _ '' , nature , vol . 5 ,",
    "2004 .    c. koch , `` _ biophysics of computation : information processing in single neurons _ '' , oxford university press ; october 31 , 2004 .    l. lamport and p. m. melliar - smith , `` _ synchronizing clocks in the presence of faults _ '' , journal of the acm , vol .",
    "32(1 ) , pp . 52 - 78 , 1985 .",
    "b. liskov , `` _ practical use of synchronized clocks in distributed systems _ '' , proceedings of @xmath330 acm symposium on the principles of distributed computing , 1991 , pp . 1 - 9 .",
    "j. lundelius , and n. lynch , `` _ an upper and lower bound for clock synchronization _ , '' information and control , vol .",
    "190 - 205 , aug / sep .",
    "n. lynch , `` _ distributed algorithms _ '' , morgan kaufmann , 1996 .",
    "m. r. malekpour , r. siminiceanu , `` _",
    "comments on the byzantine self - stabilizing pulse synchronization protocol : counterexamples _ '' , nasa technical memorandum nasa - tm213951 , feb-2006 .",
    "+ http://hdl.handle.net/2002/16159",
    "r. mathar and j. mattfeldt , `` _ pulse - coupled decentral synchronization _ '' , siam j. appl .",
    "math , vol .",
    "1094 - 1106 , aug .",
    "r. e. mirollo and s. h. strogatz , `` _ synchronization of pulse - coupled biological oscillators _ '' , siam j. appl .",
    "math , vol .",
    "50 , pp . 1645 - 1662 , 1990 .",
    "z. nda , e. ravasz , y. brechet , t. vicsek , and a. l. barabsi , `` _ self - organizing process : the sound of many hands clapping _ '' , nature , 403 , pp . 849 - 850 , 2000 .",
    "h. parnas and e. sivan , `` _ sonn - simulator of neuronal networks _ '' , hebrew university , jerusalem , israel , 1996 .",
    "+ http://www.ls.huji.ac.il/@xmath331parnas/sonn2/sonn.html .",
    "e. sivan , h. parnas and d. dolev , `` _ fault tolerance in the cardiac ganglion of the lobster _ '' , biol .",
    "11 - 23 , 1999 .",
    "s. toueg , k. j. perry , t. k. srikanth , `` _ fast distributed agreement _ '' , siam journal on computing , 16(3):445 - 457 , june 1987 .    s. h. strogatz and i. stewart , `` _ coupled oscillators and biological synchronization _ '' , scientific american , vol .",
    "102 - 109 , dec .",
    "1993    t. j. walker , `` _ acoustic synchrony : two mechanisms in the snowy tree cricket _ '' , science , 166 , pp .",
    "891 - 894 , 1969 .",
    "* proof of correctness of the summation procedure : * +        [ lem : messageagetau ] let a correct node @xmath93 receive a message @xmath72 from a correct node @xmath74 at local - time @xmath95 for every one of @xmath74 s stored messages @xmath337 that is accounted for in @xmath338 then at @xmath102 from some time @xmath38 in the local - time interval @xmath339 $ ] and at least until the end of the interval :      following the prune procedure at @xmath73 the oldest of its stored messages accounted for in @xmath76 was at most @xmath341 time units old on @xmath74 s clock at the time it sent @xmath85 this oldest stored message could have arrived at @xmath102 @xmath342 local - time units on @xmath93 s clock , prior to its arrival at @xmath77 within this time @xmath74 should also have received all the messages accounted for in @xmath85 another @xmath343 local - time units could then have passed on @xmath93 s clock until @xmath72 was sent .",
    "@xmath72 could have arrived at @xmath102 @xmath342 time units on @xmath93 s clock after it was sent by @xmath77 by this time @xmath93 would also have received all the messages that are accounted for in @xmath100 irrespective if @xmath93 had previous messages from the same nodes .",
    "another @xmath343 time units can then pass on @xmath93 s clock until all messages are processed .",
    "thus , in the worst case that node @xmath74 is slow and node @xmath93 is fast and by lemma  [ lem : powerseries ] , for every stored message accounted for in @xmath344,$ ] we have :          for a correct node to have a counter that equals exactly @xmath1 it needs its own stored message to be in its cs , as a consequence of a message it sent . consider the moment after it sent this message , say before the node s counter reached @xmath34 that is accounted for in its cs .",
    "this message was concomitant to its pulse invocation and cycle reset .",
    "the node assesses its own message at most @xmath348 local - time units after sending it thus , following the prune procedure , its own stored message will decay at most @xmath349 local - time units after it was sent .",
    "thus at the moment the node reaches threshold level @xmath350 its own message will already have decayed and the counter will decrease and will be at most @xmath351 implying that any message sent by the node can carry a counter of at most @xmath346    [ lem : notinrucs ] a stored message , @xmath352 that has been moved to the rucs of a correct node @xmath93 up to @xmath348 local - time units subsequent to the event of sending a message @xmath72 by @xmath73 ( or was moved at an earlier time ) can not have been accounted for in @xmath353    assume that the stored message @xmath337 was moved to the rucs of node @xmath93 at a local - time @xmath23 @xmath348 local - time units subsequent to the event @xmath92 at node @xmath73 ( or it was moved at an earlier time ) .",
    "thus at @xmath93 at local - time @xmath23 @xmath354 therefore at node @xmath74 at local - time @xmath107 @xmath355 this is because @xmath74 could have received the message @xmath356 up to @xmath348 local - time units later than @xmath93 did , and @xmath93 could have received @xmath72 up to @xmath348 local - time units after it was sent .    following the prune procedure at @xmath73 @xmath357",
    "would have been accounted for at the sending time of @xmath72 only if @xmath358 therefore by lemma  [ lem : l4 ] node @xmath74 did not account for the stored message of @xmath359 in @xmath353        [ cor : statesize ] let a correct node @xmath93 receive a message @xmath72 from a correct node @xmath74 at local - time @xmath95 then , at @xmath102 from some time @xmath38 in the local - time interval @xmath360 $ ] and at least until the end of the interval :                  timeliness condition 1 : @xmath363 as implied by lemma  [ lem : l4 ] and by the fact that the cs can not hold a negative number of stored messages . + timeliness condition 2 : following lemma  [ lem : l4 ] a correct node will not fire during the absolute refractory period .",
    "property 5 therefore implies that a correct node can not count less than @xmath364 local - time units between its consecutive firings",
    ". a previous message from a correct node will therefore be at least @xmath365 local - time units old at any other correct node before it will receive an additional message from that same node .",
    "following the prune procedure , the former message will therefore have decayed at all correct nodes and therefore can not be present in the @xmath366 at the arrival time of the subsequent message from the same sender .",
    "+ timeliness condition 3 : this timeliness condition validates @xmath353 the validation criterion relies on the relation imposed at the sending node by the prune procedure , between the @xmath367 of its accounted stored messages and its current counter .",
    "we first show that at time @xmath23 the time of execution of the make - accountable procedure , @xmath376\\le   \\|\\mbox{ucs}\\|,$ ] ensuring the existence of a sufficient number of stored messages in ucs to be moved to cs .",
    "@xmath377 + 1 + \\|\\mbox{ucs}\\|\\\\ & \\rightarrow &   0 < - \\max[1,\\ ; ( counter_{m_p } - counter_q + 1 ) ] + 1 + \\|\\mbox{ucs}\\|\\\\ & \\rightarrow &    \\max[1,\\ ; ( counter_{m_p } - counter_q + 1 ) ] - 1 < \\|\\mbox{ucs}\\|\\\\ & \\rightarrow &    \\max[1,\\ ; ( counter_{m_p } - counter_q +",
    "1 ) ] \\le \\|\\mbox{ucs}\\|\\enspace .\\end{aligned}\\ ] ]                let @xmath88 denote the local - time of arrival of @xmath72 at @xmath101 recall that @xmath387 is the local - time at which @xmath93 is ready to assess whether to send a message consequent to the arrival and processing of @xmath85 in the local - time interval @xmath388 $ ] at least one prune procedure is executed at @xmath93 , the one which is triggered by the arrival of @xmath85 following lemma  [ lem : l8 ] , @xmath389 subsequent to the execution of the make - accountable procedure .",
    "note that @xmath390 by lemma  [ lem : notinrucs ] all stored messages accounted for in @xmath76 will not be moved out of the @xmath366 by any prune procedure executed up to local - time @xmath391 thus , @xmath392 must stay with a value greater than @xmath76 up to time @xmath393      [ lem : l3 ] let @xmath394 and @xmath395 denote three correct nodes belonging to two different synchronized clusters .",
    "following the arrival and assessment of @xmath74 s and @xmath93 s fires , both will be accounted for in the counter of @xmath396    without loss of generality , assume that @xmath74 fires before node @xmath101 following lemma  [ lem : l1 ] node @xmath93 will fire within @xmath18 of @xmath74 ( @xmath397 on @xmath359 s clock ) .",
    "node @xmath359 will receive and assess @xmath93 s fire at a time @xmath398 at most @xmath399 after @xmath74 fired .",
    "summation property [ p2 ] ensures that @xmath359 will account for each one after their arrival and assessments .",
    "furthermore , @xmath400 and therefore node @xmath359 did not decay or move @xmath72 to rucs by time @xmath401 therefore , @xmath72 is still accounted for by node @xmath359 at time @xmath398 and thus , both @xmath74 and @xmath93 are accounted for in @xmath402 at time @xmath401"
  ],
  "abstract_text": [
    "<S> we define the `` pulse synchronization '' problem that requires nodes to achieve tight synchronization of regular pulse events , in the settings of distributed computing systems . </S>",
    "<S> pulse - coupled synchronization is a phenomenon displayed by a large variety of biological systems , typically overcoming a high level of noise . </S>",
    "<S> inspired by such biological models , a robust and self - stabilizing byzantine pulse synchronization algorithm for distributed computer systems is presented . </S>",
    "<S> the algorithm attains near optimal synchronization tightness while tolerating up to a third of the nodes exhibiting byzantine behavior concurrently . </S>",
    "<S> pulse synchronization has been previously shown to be a powerful building block for designing algorithms in this severe fault model . </S>",
    "<S> we have previously shown how to stabilize general byzantine algorithms , using pulse synchronization . to the best of our knowledge </S>",
    "<S> there is no other scheme to do this without the use of synchronized pulses .    </S>",
    "<S> * keywords * : self - stabilization , byzantine faults , distributed algorithms , robustness , pulse synchronization , biological synchronization , biological oscillators . </S>"
  ]
}