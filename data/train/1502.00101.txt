{
  "article_text": [
    "when the first microprocessor was released , its memory operations were relatively short when compared to their corresponding arithmetic operations . since then , microprocessors have been trending strongly in the other directions , with today s load and store operations being several orders of magnitude slower than arithmetic operations .",
    "this so called memory wall has only been exacerbated by the coming of microprocessors .",
    "the added complexity of trying to synchronize memory operations and , more importantly , cache contents between cores can tremendously slow down performance if not executed intelligently . in this paper",
    ", we will discuss variations of the standard moesi cache coherence scheme that allow a cache to either update or invalidate during a write request , depending on the situation .",
    "+      the most common and widely used state - based coherence scheme in multi - core machines is the moesi scheme .",
    "it consists of the following five states : + _",
    "( m)odified _  the cache block is the sole owner of dirty data . + _ ( o)wned _ - the cache block owns the dirty data , but there are other sharers .",
    "a cache with a block in the o state processes requests for that block from other cores . + _",
    "( e)xclusive _ - the cache is the sole owner of clean data .",
    "+ ( _ s)hared _ - the cache is one of several possessors of a block , but it is not the owner and its data is clean . + _",
    "( i)nvalid _ - the cache block does not hold valid data + in general , most machines will use an invalidate protocol with nmoesi . that is , when two caches contain blocks with the same tag , a write to one cache causes an invalidation signal to be sent to the other cache . a cache will send out this invalidate signal unless it knows it is the sole owner of the data , such as in the m or e state . in the case of the o , s or i state",
    ", the cache will generate and invalidate signal that will tell all other caches to set their copies of the data to i. + invalidate schemes can be thought of a reactive approach to cache coherence .",
    "a cache will only receive modified data from another cache if it asks for it . for a more proactive approach",
    ", one would look to an update scheme .",
    "+ an update signal is sent with data in the same scenarios where an invalidate scheme would send an invalidate signal , but rather than set their blocks to i , these cores would replace their old data with the block s new value and set it to the s state .",
    "both schemes have their advantages and disadvantages .",
    "it s good to be proactive and use and update scheme if you know that a block written to by one core will soon be read by another core , but updates can also generate a lot of unnecessary bus traffic .",
    "+ meanwhile , invalidate schemes will avoid this bus traffic up front , but may still generate it later if they need to read a block that has been invalidated .",
    "like most things , _ it is possible that a good answer lies somewhere in between_. below , we propose hybrid schemes that switch between invalidating and updating depending on the cores recent behavior .",
    "+      a fair amount of research was done on the advantages and disadvantages of updating or invalidating in the mid-80s . since then",
    ", most research has gone towards other aspects of coherence , but many of these papers present a reasonable starting place . + a method called the rb protocol was proposed by rudolf and segall @xcite for write - through caches .",
    "the scheme updates all other cores on the write - through by default , but if two writes occurred back to back , data in all other cores would be invalidated .",
    "this likely saved traffic for write - through machines , but as most machines today have write - back caches , updating on every write would create an excessive amount of extra bus traffic .",
    "+ karlin , manasse , rudolf and sleator @xcite would later propose a scheme called competitive snooping which would rely on amortized analysis to allow updates to occur so long as there was enough allotted cost for them to occur .",
    "this cost was related to the amount of time it would have taken if invalidation had occurred instead , but that invalidation eventually resulted in cache misses . while interesting , this scheme would likely also struggle on write - back machines . as we will show later",
    ", it is much better to invalidate by default and update when necessary .",
    "+ while both above methods relied mainly on the patterns of their own cores , archibald @xcite proposed a scheme that would take into account the actions of other cores .",
    "once again , it updated by default , but if any core had three writes to a single location without any other core accessing that location , invalidation would occur instead .",
    "we also see a potential profit of hybrid schemes in various fields such as large - scale systems with shared memory @xcite@xcite , memory - optimized protocols @xcite , and others .",
    "our proposed schemes all begin by invalidating first , then allowing updates when certain criteria have been met .",
    "they also heavily take into account the actions of other cores on the network .",
    "for our research , we decided to implement and compare several different schemes for performance : +      this is the basic scheme that is used by many multicore systems .",
    "when a cache writes to a block in the o , s or i state , it sends an invalidate signal to the network .",
    "all other cores that receive this signal invalidate their copies of the block .",
    "+      the opposite of the invalidate - only scheme , caches writing to a block in the o , s or i state send an update signal with data to the network .",
    "all other cores that receive this signal update their copies with the correct value and set themselves to s. +      this is the first of our proposed hybrid schemes that we implemented ourselves . in this scheme ,",
    "each cache block carries with it an associated counter that is used to determine whether updates or invalidates should occur upon a write .",
    "it is defined by the following three scenarios : +    1 .   upon entry to the cache from main memory ,",
    "counter is initialized to zero . 2 .   whenever a read request is seen by a cache and it contains a valid block with matching address , that block s counter is increased by one",
    "3 .   after a block",
    "is successfully written to , its value decreases by one .",
    "when we write to a block , we check the counter value against the threshold .",
    "if the counter is above or equal to the threshold , we send an update signal to the network .",
    "otherwise , we send an invalidate signal .",
    "the logic behind this scheme is two - fold .",
    "when we sense multiple reads to a block , we increase the counter and aim to update rather than invalidate .",
    "when we sense more writes , we have a lower counter and invalidate other blocks instead .",
    "+      this scheme is the same as the invalidate - only scheme except that when writing to a block that is in the o state , we send an update signal to the network rather than an invalidate signal .",
    "invalidation still occurs when writing to a block in the s or i state . as we will discuss later",
    ", the threshold scheme works best with a threshold of one .",
    "when a block s counter is set to one , its state is almost always zero , so this scheme attempts to approximate the effects of the threshold scheme without the extra hardware .",
    "+      our final scheme is an alternate version of the threshold scheme . rather than",
    "keep track of read and write requests to a memory location , whether or not to do an update is determined by the number of sharers any given data block has . if the number is above or equal to a certain number of sharers",
    ", an update will occur in place of an invalidate .",
    "this is particularly relevant due to its ease of implementation in directory schemes , whose popularity is on the rise in highly parallel machines .",
    "in order to simulate each of these different schemes , our team developed a simple cache simulating program in c++ .",
    "the program takes as input a list of loads and stores , with each string in the list containing a load / store identifier , a core number , and an address . when run with one of these inputs , the program simulates the operation of anywhere from 1 to 16 separate caches under the standard moesi protocol . during the run",
    ", it keeps track of the number of reads , writes , read request , write requests ( invalidates ) and update requests at each core .",
    "since our program simulates the scheme functionality independent of timing , we are looking at the total number of read requests , write requests and update requests as our metric for performance .",
    "the total number of requests is proportional to the amount of traffic that would exist on the network and therefore is an acceptable means of judging performance .",
    "we chose to develop our own simulator mainly for speed of simulation and ease of programming .",
    "doing so gave us the freedom to keep track of whatever metrics we liked , while also being able to easily add in various different versions of the coherence scheme .",
    "other simulators like multi2sim , which is discussed in the next section , proved to be incredibly difficult to make changes to and were significantly slower due to all of the additional work that goes into the full timing simulation .",
    "ultimately , it was decided that timing simulation was less important than the functional simulation , since timing varies so greatly from machine to machine .",
    "+      our simulator can simulate anywhere from 2 to 16 caches at once .",
    "the simulator only uses one level of caches . beyond the first level",
    ", all caches are connected to main memory .",
    "each cache contains 64 sets with 4 blocks in each set .",
    "each dataset that we generated to run on the simulator contains roughly five million loads / stores , so the metric used in this paper will be the total number of read requests , invalidates and updates on all cores per five million instructions .",
    "in order to run our simulator , we needed to generate files containing list of loads and stores to the various cores .",
    "we chose to look at a diverse array of datasets in order to gain the best possible understanding of our various schemes .",
    "also , we made sure that generated datasets are reasonably representative of their benchmark .",
    "+ each of these benchmarks was run on 2 , 4 , 8 and 16 cores .",
    "each scenario was simulated _ using invalidate - only , update - only , threshold , adapted - moesi and number of sharers _ schemes .",
    "+      we certainly wanted to include datasets corresponding to commercial benchmarks . to do this , we took advantage of the multi2sim timing simulator @xcite .",
    "while it was very difficult to implement the new hybrid schemes in the multi2sim timing simulator , we found that it was easy to adapt the simulator to generate datasets .",
    "while running a timing simulation , we had the simulator output to a file the information for five million consecutive loads and stores .",
    "we usually waited several tens of millions of instructions for the parallel programs to get warmed up before starting the output .",
    "this way , we were able to generate a more representative sample of the benchmark s performance .",
    "we generated datasets from the following four benchmarks in this way .",
    "+ _ bodytrack _  computer vision algorithm + _ dedup _  compression of a data stream through local and global means + _ streamcluster _  solves online clustering problem + _ swaptions _  uses monte carlo techniques to price a portfolio of swaptions +      finally , we created a handful of pseudo - random datasets meant to represent common multicore scenarios , such as many cores sharing a lock , many cores updating an array based on an element s neighbors , and a server model .",
    "these datasets were generated with simple c++ programs .",
    "+ our _ locks _ dataset established 3 shared locks between any number of cores .",
    "each core had a 10% chance of accessing the lock .",
    "when doing so , the core would write to the lock to free it if it possessed it .",
    "if it did not possess the lock , it would read from the lock and then write to take the lock if no one else possessed it . only blocks containing the locks were shared between cores .",
    "all other data accesses were restricted to their own private range of addresses . + our _ arrays",
    "_ dataset represents an array that is constantly updated by comparing elements . in this scenario ,",
    "an array element is read by one core , as are its neighbors above , below to the right and to the left of it .",
    "each core traversed through a row in this array , and during each cycle , a core would be randomly chosen to process the next element in its row . note that in a real program , this would result in non - deterministic behavior .",
    "+ our _ pseudo - server _ dataset represents a very basic server - client model with public and private data where one core is allowed to write to shared data and each other core may only read from it .",
    "the server core can write to any block in the whole address range .",
    "the address range itself is split into two sections .",
    "the first section is public and can be read by any client core .",
    "the second section represents private space and is divided between all of the client cores which are only allowed to read from their own space .",
    "below we present results and analysis for each scheme using the various benchmarks .",
    "note that all graphs only display the total sum of all bus transactions for each scenario .",
    "detailed breakdown of how those transactions are split between read requests , invalidates and updates is provided in the appendix .",
    "+      first , we will simply look at the base _ invalidate - only _ and _ update - only _ schemes . to limit the amount of data presented in this section , only graphs for 8-core scenarios",
    "are presented , although results from scenarios with other numbers of cores will be discussed . additionally , as mentioned above , the numbers presented are bus transactions per five million memory instructions .",
    "results for the commercial and artificial workloads are shown below ( * figure 1 * ) .",
    "+ the primary point gained from this data is that , for many applications , there is a large gap between the number of transactions that occur with an update - only scheme and an invalidate - only scheme . in many workloads ,",
    "the amount of data that is heavily shared between cores is much less than the amount of data that is primarily used by one core but is occasionally accessed by others . in an update - only scheme , we are updating any core that has ever accessed the shared data , when we ideally only want to update those cores that have accessed it recently .",
    "the one exception to this pattern is the _ bodytrack _ benchmark .",
    "the difference between the two schemes is relatively small , indicating denser sharing between the caches .",
    "as we will see later , this makes this benchmark a good candidate to improve performance under a hybrid scheme ( * figure 2 * ) .",
    "+ our artificially generated benchmarks present much less variation between the two extremes .",
    "the pseudo - server benchmark , due to its unique structure , actually performs better under the update - only scheme . + another interesting note to take away is that the _ arrays _ benchmark maintains a consistent number of transactions regardless of scheme , even though the distribution of updates / invalidates is different . due to the enforced order of the memory transactions ( they happen in order on each core , although the core that may proceed in each iteration is chosen randomly ) , the benchmark never really benefits from any updates .",
    "+      in this section , we will analyze the results from running the benchmarks with the _ threshold _ scheme at several different thresholds , as well as under the _ adapted - moesi scheme _ ( * figure 3 * ) .",
    "+                for the most part , there is a much smaller gap between the number of transactions that occur with the _ invalidate - only _ scheme and the hybrid scheme .",
    "still , for those benchmarks that originally had a large gap , the _ invalidate - only _ scheme outperforms any hybrid scheme . for _ bodytrack _ , however , the hybrid schemes of _ threshold 1 _ and _ adapted - moesi _ actually outperform the other schemes . since the benchmark was relatively dense , and because the update and invalidate schemes both performed relatively well , having a smart way to choose whether to update or invalidate ends up improving performance .",
    "+ when it came to the value to set the _ threshold _ to , only a value of one really showed any difference from an invalidate - only scheme .",
    "the _ threshold _ of 3 was in most cases identical to running _ with invalidate - only_. + due to this result , we believed that it may be worthwhile to implement a scheme that updates when the state of the block being written to was ( o)wned . this logic stemmed from the observation that when the threshold of one was met , the block was most commonly in the o state . in practice , however , this performed not better that a _ threshold _ of one , but at times would perform significantly worse . while blocks with a counter value that met the threshold of one were often in the o state , not all blocks in the o state",
    "would necessarily have a threshold value of one ( * figure 4 * ) . + it is somewhat difficult to tell because of the scale of the graph , but the _ locks _ benchmark performed slightly worse with the _ threshold _ scheme than it did with the _ invalidate - only _ scheme , while the server benchmark did slightly better .",
    "the arrays benchmark still did not see any change . + the server benchmark is interesting because it was the only one to do better under the _ update - only _ scheme . in this case , the _ threshold _ and _ adapted - moesi _ schemes did better than always invalidating , but worse than always updating . while these hybrid schemes will not necessarily be the best possible scheme for each benchmark , they may provide a decent compromise between schemes that perform best always invalidating and those that perform best always updating .",
    "+                  finally , we will address the results gained from running each benchmark under the _ number of sharers _ scheme ( * figure 5 * ) .",
    "+ the _ number of sharers _",
    "scheme actually performs relatively well in most cases . like the _ threshold _ scheme , it performs better on the _ bodytrack _ benchmark than either always updating or always invalidating .",
    "interestingly , the _ swaptions _ benchmark also sees improvement . unlike the _ threshold _ scheme , this scheme has the benefit of always knowing exactly how many other caches share data with a cache that is being written to , and this seems to be reflected as an increase in performance on some benchmarks .",
    "+ on other benchmarks , specifically _ streamcluster _ , this scheme seems to perform worse .",
    "because of how the updating works , the only way for a core not to become a sharer again is to be evicted from the cache , since it will never be invalidated once updates start happening .",
    "if a core does nt access a block regularly but also does nt evict it often enough , the scheme may update when it does nt need to .",
    "this effect is reflected in the poor performance of the _ streamcluster _ benchmark ( * figure 6 * ) .",
    "+ finally , the results for the _ number of sharers _ scheme on the artificial benchmarks look very similar to the _ threshold scheme _ , except the results are more exaggerated . it does worse on the _ locks _ benchmark but better on the _ server _ benchmark .",
    "because of the factors discussed above , this scheme seems to be more of a win - more / lose - more scheme than the _ threshold _ scheme . if a benchmark benefitted from the _ threshold _ scheme relative to the _ invalidate - only _ scheme , it benefits more with the number of sharers scheme .",
    "if it did worse with _ threshold _ , it does even worse with number of sharers .",
    "+ the minimum number of sharers required for updates to occur seemed to be best set around half of the number of cores .",
    "if it was too little , such as two sharers in the case of eight cores , then too many updates occurred .",
    "when the required number of sharers got above half , the performance usually stagnated at a constant value , since anything that is shared between half of the cores is generally shared between almost all of them .",
    "in this final section of the paper , we will discuss what conclusions can be drawn from the above analyzed data , what additional considerations need to be taken into account when judging the results , and suggest further research that can be done in this area .",
    "+      there certainly exist examples of benchmarks that perform better with either an _ invalidate - only _ scheme or an _ update - only _ scheme . in some instances , such as the bodytrack benchmark , there exist hybrids that perform better than either _ invalidate - only _ or _ update - only_. in other instances , there are hybrid schemes that will perform better than one of _ invalidate - only _ or _ update - only _ but worse than the other .",
    "+ when considering different threshold values for the _ threshold _ scheme , a value of 1 provided the most dramatic result .",
    "high threshold values functioned almost identically to _ invalidate - only _ schemes . employing the _ threshold _ scheme with a value of one resulted in the lowest number of transactions on some benchmarks , while providing a reasonable compromise on others .",
    "+ the adapted - moesi scheme did not perform as well as expected , as it led to more bus transactions than the threshold scheme in every scenario .",
    "+ finally , the _ number of sharers _",
    "scheme performed reasonably well , especially when the required number of sharers needed to perform an update was around half the number of cores .",
    "however , it varied more from the average than the threshold scheme did .",
    "because of this , the threshold scheme seems to be the correct choice for a scheme that will provide the optimal compromise between benchmarks that perform best with more updates and those that perform best with more invalidates .",
    "+      our simulator did not take timing into account , as we were only concerned with counting the total number of transactions . since the timing would vary from machine to machine",
    ", metrics such as ipc would be less informative than the total number of transactions . in a real machine",
    ", the timing of updates and invalidates plays an important role .",
    "updating results in longer stores but potentially much faster loads , while invalidation can do the reverse .",
    "+ we also did not consider hardware cost when evaluating the various schemes .",
    "updating on its own requires more hardware since more complex transactions must be sent over the bus . the _ threshold _ scheme requires substantial extra hardware , since each cache block must contain its own counter .",
    "the _ adapted - moesi _ scheme requires virtually no extra hardware .",
    "the number of sharers requires some sort of centralized index of the number of sharers on all data blocks in all caches .",
    "this can be easily accomplished by the directory in any cache coherence protocol that uses one .",
    "+      while the _ adapted - moesi _ scheme was meant to emulate a _ threshold _",
    "scheme with a threshold value of one using less hardware , it ultimately failed in that endeavor . still there is certainly a way to get the same effect with significantly less hardware .",
    "+ while we chose not to concern ourselves with the timing effects of the various schemes , they would certainly be interesting to address .",
    "+ finally , since our simulator used a snoopy protocol combined with _",
    "moesi _ , it would be interesting to see how each of these schemes interacts with a directory - based protocol",
    ". it would be especially interesting for the _ number of sharers _ scheme , as that scheme would be so easy to implement in a directory - protocol ."
  ],
  "abstract_text": [
    "<S> _ in general when considering cache coherence , write back schemes are the default . </S>",
    "<S> these schemes invalidate all other copies of a data block during a write . in this paper </S>",
    "<S> we propose several hybrid schemes that will switch between updating and invalidating on processor writes at runtime , depending on program conditions . </S>",
    "<S> we created our own cache simulator on which we could implement our schemes , and generated data sets from both commercial benchmarks and through artificial methods to run on the simulator . </S>",
    "<S> we analyze the results of running the benchmarks with various schemes , and suggest further research that can be done in this area . _    2 </S>"
  ]
}