{
  "article_text": [
    "prolog is an old language with a long history , and its user community has seen a large number of implementations that evolved largely independently . this situation is totally different from more recent languages , e.g , java , python or perl .",
    "these language either have a single implementation ( python , perl ) or are controlled centrally ( a language can only be called java if it satisfies certain standards  @xcite ) .",
    "the prolog world knows dialects that are radically different , even with different syntax and different semantics ( e.g. , visual prolog  @xcite ) .",
    "arguably , this is a handicap for the language because every publically available significant piece of code must be carefully examined for portability issues before it can be applied . as an anecdotal example ,",
    "answers to questions on _ comp.lang.prolog _ typically include `` on prolog xyz , this can be done using  '' or `` which prolog implementation are you using ? '' .    in this work we will investigate portability issues in a number of modern prolog implementations",
    ". we shall use systems that implement the iso standard to a large extend  @xcite .",
    "we remark that , although any program larger than a few pages requires modularity , the iso standard for modules was never accepted by most prolog developers . to address this problem , we restrict ourselves to prolog systems that implement a module system descending from the quintus module system .",
    "this includes quintus prolog itself  @xcite , sicstus prolog  @xcite , ciao  @xcite , swi - prolog  @xcite , and yap  @xcite .",
    "we further assume that all target systems provide a term - expansion facility ( a macro - facility inherited from the edinburgh tradition ) , a second requirement for our approach .",
    "software portability is a problem since the day the second computer was built . in the case of prolog , we expect that at least basic portability requirements are fulfilled : there are few syntactic incompatibilities , and the core language primitives have to a large extent the same semantics .",
    "this is the case for the family of implementation that is subject in this study . beyond that , the implementations vary widely ; notably in * ( i ) * the organisation of the libraries ; * ( ii ) * available library primitives ; and * ( iii ) * access to external resources such as ` c`-code , processes , etc .",
    "our problem is to some extent similar to porting ` c`-programs between different compilers and operating systems .",
    "although today s ` c`-environments have made significant progress in standardising the structure of the library ( e.g. , ` c99 ` internationalisation support ) and posix has greatly simplified operating system portability , writing portable ` c`-code still relies on judicious use of the ` c`-preprocessor and a principled approach to portability .",
    "we will take advantage of the underlying principles and choices that affect portability in the ` c`-world , both because we believe the examples are widely known and because the ` c`-community has a long - standing experience with portability issues .",
    "note that the described approaches are not mutually exclusive .",
    "[ [ the - abstraction - approach ] ] the abstraction approach + + + + + + + + + + + + + + + + + + + + + + + +    a popular approach to make an application portable is to define an _ interface _ for facilities that are needed by the application and that are typically not portable .",
    "next , the interface is implemented for the various target platforms .",
    "targets that are completely different ( e.g. windows vs. x11 graphics ) use completely distinct implementations , while small differences are handled using compile - time or run - time conditions .",
    "typically , the `` portable '' part of the application still needs some conditional statements , for example if vital features are simply not available on one of the target platforms .",
    "abstractions come in two flavours : specifically designed and implemented in the context of an application ; and designed as high - level general - purpose abstractions .",
    "we find instances of the latter class notably in areas where portability is hard , such as user - interface components ( e.g. , wxwindows , qt , various libraries for threading ) .",
    "logtalk  @xcite is an example from the prolog world : it provides a portable program - structuring framework ( objects ) and extensive libraries that are portable over a wide range of prolog implementation . on the other hand",
    ", we could claim that logtalk is a _ language _ developed by a community that just happens to be using a variety of prolog implementations as backend .",
    "the portability of logtalk itself is based on application - specific abstraction .",
    "[ [ the - emulation - approach ] ] the emulation approach + + + + + + + + + + + + + + + + + + + + + +    another popular approach is to write applications for environment @xmath0 and completely _ emulate _",
    "environment @xmath0 on top of the target environment @xmath1 .",
    "one of the most extreme examples here is _ _ wine _ _ , that completely emulates the windows - api on top of posix systems .",
    "the opposite is cygwin  @xcite , that emulates the posix api on windows platforms .",
    "this approach has large advantages in reducing the porting effort .",
    "however , it comes at a price .",
    "cygwin and wine are very large projects because emulating one os api is approaching the complexity of an os itself .",
    "this means that applications ported using this approach become heavyweight .",
    "moreover , they tend to become slow due to small mismatches . for example",
    ", both windows and posix provide a function to enumerate members of a directory and a function to get details on each member .",
    "the initial enumeration already provides more than just the name , but the set of attributes provided differs .",
    "this implies that a full emulation of the directory - scanning function also needs to call the ` get - details ' function to fill the missing attributes , causing a huge slow - down .",
    "the real pain is that often , the application is not interested in these painfully extracted attributes .",
    "similar arguments hold for the differences between the thread - synchronisation primitives .",
    "for example , the initial implementation of swi - prolog message - queues that establish a fifo queue between threads was based on posix thread ` condition variables ' and ported using the pthread - win32 library .",
    "the windows version was over 100 times slower than the posix version . rewriting the queue logic using windows ` event",
    "' object duplicates a large part of the queue - handling code , but provides comparable performance .",
    "[ [ the - conditional - approach ] ] the conditional approach + + + + + + + + + + + + + + + + + + + + + + + +    traditionally , ( small ) compatibility problems are ` fixed ' using conditional code .",
    "there are two approaches : compile - time and run - time . in the prolog - world , we ve seen mostly run - time solution with the promise that partial evaluation can turn this into the equivalent of the compile - time approach .",
    "conditions themselves often come from version information ( e.g.  if ( currentbrowser = = ie & & browserversion = = 6.0 ) ... ) . at some point in time , the variation in the unix - world was so large that this was no longer feasible .",
    "large packages came with a configuration file where the installer could indicate which features where supported by the target unix version .",
    "of course , most system managers had no clue .",
    "a major step forward was gnu ` autoconf `  @xcite , a package that provides clear guidelines for portability , plus a collectively maintained suite of tests that can automatically execute in the target environment ( ` configure ` ) .",
    "there is one important lesson to be learned from gnu autoconf : _ do not test versions , but features_. e.g.  if you want to know whether * member/2 * is available without loading library(lists ) , use a test like the one below rather than a test for a specific prolog implementation and version .",
    "feature - tests like this are the basis of autoconf",
    ". where autoconf requires writing an m4 specification file that is translated into the well - known configure program and the test results must be queries using ` # ifdef have_`@xmath2 , the reflexive capabilities of prolog avoid the need for external toolchains .",
    "feature tests work regardless of your knowledge of the availability of a predicate in a specific prolog implementation and they keep working if implementations change this aspect or new implementations arrive on the market .    ....",
    "catch(member(a , [ a ] ) , _ , fail ) ....",
    "before we can answer the question on the best approach for prolog , we must investigate the situation .",
    "the relevant situation does not only include the target prolog systems , but also the user and developer communities .",
    "our target prolog systems have been influenced by the edinburgh tradition , namely through quintus prolog , ` c`-prolog , dec10-prolog and its dec10 prolog library .",
    "they all support the iso core standard .",
    "in addition , resources such as logtalk , and the leuven and vienna constraint libraries have recently helped enhancing the compatibility of prolog dialects due to a mutual interest of the resource developers ( a wider audience ) and prolog implementors ( valuable resources ) .",
    "logtalk has pioneered this field , pointing prolog implementors at non - compliance with the iso standard and other incompatibilities .",
    "the constraint libraries have settled around the attributed variable and global variable api designed for hprolog ( @xcite ) .",
    "these apis are either directly implemented or easily emulated .",
    ".core features provided by the target prolog environment [ cols=\"<,^,^,^,^\",options=\"header \" , ]     below we summarise the non - trivial issues encountered and their resolution .",
    "* the sicstus block directive declares predicates to suspend until an instantiation pattern is reached .",
    "swi - prolog has no such concept .",
    "term - expansion was used to rename the clauses and generate a wrapper that implements the coroutining using * when/2*. * operator declarations are mapped to declarations in the user module , swi - prolog s deprecated support for system - wide operators .",
    "the code below illustrates dialect handling here : * alpino depends on predicates from library(lists ) that we do not consider for including into swi - prolog .",
    "therefore , we add library(dialect / sicstus / lists ) with the following content + note that in addition , we must map explicitly qualified calls ( e.g. , lists : nth(n , l , e ) ) to sicstus_lists : nth(n , l , e ) if the current dialect is sicstus .",
    "the mapping rule is in ` sicstus.pl ` , while clauses for the mapping are provided by the renamed modules .",
    "* database references ( * assert/2 * , * clause/3 * , * recorda/3 * , * erase/1 * ) are safe in sicstus and goals fail if the reference does not exist . swi - prolog references used to be unsafe : references were heuristically tested for validity and an existence_error was raised if the reference was known to be invalid . in case",
    "the heuristics incorrectly claims that a reference is valid , the system could crash .",
    "programming around this in alpino was considered more effort than providing a compatible api in swi - prolog , so we decided for the latter .",
    "* we added support for the mode to the swi - prolog runtime .",
    "we also resolved that @xmath3:clause(h , b ) does not qualify if the predicate is in module @xmath3 .",
    "* sicstus ( and ciao ) provide prolog streams that can both the read and written to .",
    "swi - prolog s streams are either read or write .",
    "this makes it hard to provide a compatible emulation of the sockets library .",
    "we decided to support stream - pairs in the swi - prolog runtime system .",
    "all i / o predicates are aware of these pairs and will pick the appropriate member ( * close/1 * addresses both streams ) .",
    "after this addition , emulating the required features of the socket library was simple .",
    "* sicstus assert and friends can deal with attributed variables , as illustrated below .",
    "+ swi - prolog has no such support and adding this is a non - trivial exercise . as a work - around",
    ", we use goal - expansion to map calls to the assert - predicates onto clp_assert .",
    "this predicate uses to extract the constraints from the term and inserts all constraints at the start of the body , creating the clause below .",
    "+ we consider the approach so specific that we decided to make the emulation part of the alpino source - tree rather than the swi - prolog system .",
    "* we provide an implementation for the libraries ` arrays.pl ` , ` system.pl ` and ` timeout.pl ` using swi - prolog primitives .",
    "* at some places , we decided that both sicstus and swi - prolog provided already compatible alternatives for legacy sicstus code and adjusted the alpino sources accordingly .",
    "* we emulate the declaration of foreign predicates using the sicstus primitives * foreign_resource/2 * , * foreign/3 * and load * foreign_resource/1*. the wrapper - generation is an extension of the older generator for quintus ( qpforeign.pl ) .",
    "in addition we wrote a script emulating the features of splfr that we need .",
    "this sicstus program extracts the foreign declaration from a prolog file , generates a wrapper and calls the c - compiler to create a loadable foreign module .",
    "the swi - prolog replacement swipl-lfr.pl takes the same steps , using the c - compiler and linker front - end swipl - ld for the platform - specific linking .",
    "+ in addition , we added sicstus.h to the swi - prolog include directory that provides the necessary mapping from sp _ api functions to pl _ api functions .",
    "the total amount of code involved is 664 lines of prolog code and 244 lines of c - header ( which satisfies our requirements , but is otherwise incomplete ) .",
    "no changes were required to the alpino c - files , neither to the prolog code .",
    "for the alpino zlib - interface , creating a compressed serialisation of a prolog term based on sicstus fastrw.pl library and zlib , we decided on an alternative route for swi that was easier to realise than providing fastrw for swi - prolog .",
    "the alpino code selects the implementation using the * if/1 * conditional compilation .",
    "* alpino uses the sicstus tcl / tk interface .",
    "license issues make it impossible to use the sicstus library here , while reimplementing from scratch is non - trivial .",
    "initially , we ported library(tcltk ) from ciao prolog using the same emulation - approach . because ciao uses a much finer grained module infrastructure , emulating enough of ciao to run the tcltk library requires 17 files containing 971 lines of prolog .",
    "in addition , swi - prolog s * write_term/3 * had to be modified to ( by default ) omit an extra space after a comma that separates two arguments ( e.g. , ` term(a , b ) ` instead of ` term(a , b ) ` ) .",
    "+ unfortunately , ciao s tcltk library could not sufficiently emulate the sicstus library for running alpino .",
    "eventually , the ciao code was used to realise a new and portable tcl / tk interface that could support alpino .",
    "this interface is part of the alpino source - tree .",
    "the above changes required about 20 person - days joined effort from the swi - prolog team and the alpino team and resulted in a fully operational application running on the two target platforms . as mentioned above , swi - prolog was enhanced in several places . also the alpino code has been improved .",
    "it now relies less on sicstus legacy code ; the application now supports utf-8 on both prolog platforms ; the modularity was enhanced and the performance has been improved , also on sicstus .",
    "the initial alpino source contained 19 places of conditional compilation based of the * if/1 * -directive .",
    "since then , more conditional code was added to enhance performance on swi - prolog and use additional features of swi - prolog , such as ( partial ) support for multi - threading and its interface to gnu readline .",
    "the current code contains 59 places of conditional compilation .",
    "this small amount of conditional code has no significant impact of the maintainability of the alpino code - base .",
    "portability of prolog source - code is important .",
    "portability prevents vendor lock - in , provides backup if an implementation is discontinued or is no longer suitable for sustaining an application because it lacks features that are important for future development .",
    "portability is also needed if we want to combine packages developed on different prolog implementations . for a long time , the prolog community consisted of separated sub - communities associated to an implementation .",
    "the iso standard has resolved many low - level compatibility issues .",
    "logtalk and the leuven / vienna constraint libraries have created bridges , causing participating prolog systems to resolve various incompatibilities . currently , portability among four systems with common inspiration ( yap , sicstus , ciao and swi - prolog ) is comparable to other multi - vendor programming environments such as c on unix in the 90s .",
    "we have presented a framework that provides conditional compilation , where the reflexive capabilities of prolog replace the analysis provided by gnu autoconf .",
    "we also presented a framework that allows sources for multiple dialects to co - exist on the same prolog host .",
    "this framework can be extended on ` as - needed ' basis .",
    "we identified a number of issues that hinder the development of portable prolog resources .",
    "some of these involve major decisions and require major effort .",
    "examples are non - portable types such as string - objects , advanced numeric types ( unbounded , rationals , complex ) , and non - portable features ( e.g. , unicode support , threads , tabling ) .",
    "there are a number of issues that are less involved and can greatly facilitate portability if agreement is reached and implemented .",
    "examples are ` environment predicates ' , such as * absolute_file_name/3 * , * prolog_load_context/2 * , a mechanism to deliver ( translated ) messages to the user , further standardisation of prolog flags , including a mechanism to define new flags and a clear vision on handling extensions to the option - list processed by predicates such as * write_term/3*.    we strongly advice anyone interested in porting a prolog resource to get into contact with the vendors of the targeted prolog systems .",
    "many incompatibilities are much easier resolved by the vendor(s ) and as a result both systems improve and get more compatible .",
    "bart demoen .",
    "ynamic attributes , their hprolog implementation , and a first evaluation .",
    "report cw 350 , department of computer science , k.u.leuven , leuven , belgium , oct 2002 .",
    "url = http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/cw350.abs.html .",
    "manuel  v. hermenegildo , francisco bueno , manuel carro , pedro lpez , jos  f. morales , and germn puebla .",
    "an overview of the ciao multiparadigm language and program development environment and its design philosophy . in pierpaolo degano ,",
    "rocco  de nicola , and jos meseguer , editors , _ concurrency , graphs and models , essays dedicated to ugo montanari on the occasion of his 65th birthday _ , volume 5065 of _ lecture notes in computer science _ , pages 209237 .",
    "springer , 2008 .",
    "christian holzbaur .",
    "metastructures versus attributed variables in the context of extensible unification . in maurice bruynooghe and martin wirsing ,",
    "editors , _ plilp _ , volume 631 of _ lecture notes in computer science _ , pages 260268 .",
    "springer , 1992 .",
    "leslie  de koninck , tom schrijvers , and bart demoen . a flexible search framework for chr . in tom schrijvers and thom  w. frhwirth , editors ,",
    "_ constraint handling rules _ , volume 5388 of _ lecture notes in computer science _ , pages 1647 .",
    "springer , 2008 .",
    "peter szab and pter szeredi . improving the iso prolog standard by analyzing compliance test results . in sandro etalle and miroslaw",
    "truszczynski , editors , _ iclp _ , volume 4079 of _ lecture notes in computer science _ , pages 257269 .",
    "springer , 2006 .",
    "markus triska . generalising constraint solving over finite domains . in maria",
    "garcia de  la banda and enrico pontelli , editors , _ iclp _ , volume 5366 of _ lecture notes in computer science _ , pages 820821 .",
    "springer , 2008 .    gertjan van noord .",
    "t * l*ast * p*arsing * i*s * n*ow * o*perational . in _",
    "taln 2006 verbum ex machina , actes de la 13e conference sur le traitement automatique des langues naturelles _ , pages 2042 , leuven , 2006 ."
  ],
  "abstract_text": [
    "<S> ( non-)portability of prolog programs is widely considered as an important factor in the lack of acceptance of the language . since 1995 </S>",
    "<S> , the core of the language is covered by the iso standard 13211 - 1 . since 2007 , </S>",
    "<S> yap and swi - prolog have established a basic compatibility framework . </S>",
    "<S> this article describes and evaluates this framework . </S>",
    "<S> the aim of the framework is running the same code on both systems rather than migrating an application . </S>",
    "<S> we show that today , the portability within the family of edinburgh / quintus derived prolog implementations is good enough to allow for maintaining portable real - world applications . </S>"
  ]
}