{
  "article_text": [
    "we study the following problem , called the oracle identification problem ( oip ) : given a hidden @xmath12-bit vector @xmath13 , called an _ oracle _ , and a _ candidate set _",
    "@xmath14 , oip requires us to find which oracle in @xmath0 is equal to @xmath2 .",
    "oip has been especially popular since the emergence of quantum computation , e.g. , @xcite . for example",
    ", suppose that we set @xmath15 .",
    "then this oip is essentially the same as grover search @xcite . in @xcite , ambainis et al . extended the problem to a general @xmath0 .",
    "they proved that the total cost of _ any _ oip with @xmath16 is @xmath17 , which is optimal within a constant factor since this includes the grover search as a special case and for the latter an @xmath18 lower bound is known ( e.g. , @xcite ) . for a larger @xmath0 , they obtain nontrivial upper and lower bounds , @xmath19 and @xmath20 , respectively , but unfortunately , there is a fairly large gap between them .    * our result .  *",
    "let @xmath21 .",
    "( @xmath3 ) if @xmath22 for a constant @xmath23 ( @xmath24 ) , then the cost of our new algorithm is @xmath25 which matches the lower bound obtained in @xcite .",
    "( previously we have an optimal upper bound only for @xmath26 ) .",
    "( @xmath7 ) for the range between @xmath8 and @xmath9 , our algorithm works without any modification and the ( gradually growing ) gap to the lower bound is at most a factor of @xmath27 .",
    "( @xmath11 ) our algorithm is robust , namely , it exhibits the same performance ( up to a constant factor ) against the _ noisy _ oracles as shown in the literatures @xcite for special cases of oip .",
    "our algorithms use two operations : ( @xmath3 ) the first one is a simple query ( _ s - query _ ) to the hidden oracle , i.e. , to obtain the value ( @xmath28 or @xmath29 ) of @xmath30 by specifying the @xmath31-bit index @xmath3 .",
    "the cost for this query is one per each .",
    "( @xmath7 ) the second one is called a _",
    "g - query _ to the oracle : by specifying a set @xmath32 of indices , we can obtain , if any , an index @xmath33 s.t . @xmath34 and",
    "nill otherwise .",
    "if there are two or more such @xmath35 s then one of them is chosen at random .",
    "the cost for this query is @xmath36 where @xmath37 .",
    "this query is stochastic , i.e. , the answer is correct with a constant probability .",
    "obviously our goal is to minimize the cost for solving the oip with a constant success probability .",
    "note that we incur the cost for only s- and g - queries ( i.e. , the cost for any other computation is zero ) , and it turns out that our query model is equivalent to the standard query complexity one , e.g. , @xcite .",
    "s - queries are standard and may not need any explanation .",
    "g - queries are , as one can see , the grover search themselves .",
    "so , they can not be implemented in the framework of classical computation , and hence our paper is definitely a quantum paper .",
    "however , if we use the two queries as blackbox subroutines and follow the above complexity measure , then our algorithm design will be completely classical .",
    "now it is important to observe the `` efficiency '' of g - queries .",
    "since its cost is sublinear in @xmath38 , our general idea is that it is more cost - effective to use them for a larger @xmath39 .",
    "for example , the cost for a single g - query for @xmath40 is less than the total cost of three g - queries for @xmath41 .",
    "however , it is also true that the former is less informative since it gives us only one bit - position in @xmath39 which has value one , while the latter gives us three .",
    "thus , as one would expect , selecting the size of @xmath39 is a key issue when using g - queries .",
    "as mentioned earlier , if we use the two queries as blackbox subroutines together with their cost rule , then any knowledge about quantum computation is not needed in the design and analysis of our algorithms . since @xmath0 is a set of @xmath1   @xmath42-vectors of length @xmath12 , it is naturally given as a @xmath42 matrix @xmath43 of @xmath12 columns and @xmath1 rows .",
    "for a given @xmath43 , our basic strategy is quite simple : if there is a column which includes a balanced number of @xmath28 s and @xmath29 s , then we ask the value of the oracle at that position by using an s - query .",
    "this reduces the number of candidates by a constant factor .",
    "otherwise , i.e. , if every column has , say , a small fraction of @xmath29 s , then s - queries may seldom reduce the candidates . in such a situation",
    ", the idea is that it is better to use a g - query by selecting a certain number of columns in @xmath39 than repeating s - queries . in order to optimize this strategy",
    ", our new algorithm controls the size of @xmath39 very carefully .",
    "this contrasts with the previous method  @xcite that uses g - queries always with @xmath44    * previous work .",
    "* suppose that we wish to solve some problem over input data of @xmath12 bits .",
    "presumably , we need all the values of these @xmath12 bits to obtain a correct answer , which in turn requires @xmath12 ( simple ) queries to the data . in a certain situation",
    ", we do not need all the values , which allows us to design a variety of sublinear - time ( classical ) algorithms , e.g. , @xcite .",
    "this is also true when the input is given with some premise , for which giving a candidate set as in this paper is the most general method . quickly approaching to the hidden data using the premise information",
    "is the basis of algorithmic learning theory .",
    "in fact , atici et al . in @xcite independently use techniques similar to ours in the context of quantum learning theory .",
    "one of their results , which states the existence of a quantum algorithm for learning a concept class @xmath0 whose parameter is @xmath45 with @xmath46 queries , almost establishes a conjecture of @xmath47 queries in @xcite .",
    "recall that our complexity measure is the ( quantum ) query complexity , which has been intensively studied as a central issue of quantum computation .",
    "the most remarkable result is due to grover @xcite , which provided a number of applications and extensions , e.g. , @xcite .",
    "recently quite many results on efficient quantum algorithms are shown by `` sophisticated '' ways of using the grover search .",
    "( our present paper is also in this category . )",
    "brassard et al .",
    "@xcite showed a quantum counting algorithm that gives an approximate counting method by combining the grover search with the quantum fourier transformation .",
    "quantum algorithms for the claw - finding and the element distinctness problems given by buhrman  et al .",
    "@xcite also exploited classical random and sorting methods with the grover search .",
    "( ambainis  @xcite developed an optimal quantum algorithm with @xmath48 queries for element distinctness problem , which makes use of the quantum walk and matches to the lower bounds shown by shi @xcite . )",
    "aaronson et al .",
    "@xcite constructed quantum search algorithms for spatial regions by combining the grover search with the divided - and - conquer method .",
    "magniez et al .",
    "@xcite showed efficient quantum algorithms to find a triangle in a given graph by using combinatorial techniques with the grover search .",
    "drr et al .",
    "@xcite also investigated quantum query complexity of several graph - theoretic problems .",
    "in particular , they exploited the grover search on some data structures of graphs for their upper bounds .",
    "recently , two papers , by hyer et al .",
    "@xcite and buhrman et al .",
    "@xcite , raised the question of how to cope with `` imperfect '' oracles for the quantum case using the following model : the oracle returns , for the query to bit @xmath49 , a quantum pure state from which we can measure the correct value of @xmath49 with a constant probability .",
    "this noise model naturally fits the motivation that a similar mechanism should apply when we use bounded - error quantum subroutines . in @xcite hyer",
    "gave a quantum algorithm that robustly computes the grover s problem with @xmath17 queries , which is only a constant factor worse than the noiseless case .",
    "buhrman et al .",
    "@xcite also gave a robust quantum algorithm to output all the @xmath12 bits by using @xmath10 queries .",
    "this obviously implies that @xmath10 queries are enough to compute the parity of the @xmath12 bits , which contrasts with the classical @xmath50 lower bound given in  @xcite .",
    "thus , robust quantum computation does not need a serious overhead at least for several important problems , including the oip discussed in this paper .",
    "recall that an instance of oip is given as a set @xmath51 of oracles , each @xmath52 , and a hidden oracle @xmath53 which is not known in advance .",
    "we are asked to find the index @xmath3 such that @xmath54 .",
    "we can access the hidden oracle @xmath2 through a unitary transformation @xmath55 , which is referred to as an _ oracle call _ , such that @xmath56 where @xmath57 denotes the bit - position of @xmath2 whose value ( @xmath28 or @xmath29 ) we wish to know .",
    "this bit - position might be a superposition of two or more bit - positions , i.e. , @xmath58 .",
    "then the result of the oracle call is also a superposition , i.e. , @xmath59 .",
    "the query complexity counts the number of oracle calls being necessary to obtain a correct answer @xmath3 with a constant probability .    in this paper we will not use oracle calls directly but through two subroutines , s - queries and g - queries .",
    "( both can be viewed as classical subroutines when used . )",
    "an s - query , @xmath60 , is simply a single oracle call with the index @xmath3 plus observation .",
    "it returns @xmath61 with probability one and its query complexity is obviously one . a g - query , @xmath62 , where @xmath63 , returns @xmath64 such that @xmath65 and @xmath66 if such @xmath3 exists and nill otherwise .",
    "we admit an error , namely , the answer may be incorrect but should be correct with a constant probability , say , @xmath67 .",
    "although details are omitted , it is easy to see that @xmath62 can be implemented by applying grover search only to the selected positions @xmath39 .",
    "its query complexity is given by the following lemma .",
    "@xmath62 needs @xmath36 oracle calls , where @xmath68 .    if @xmath2 is a _ noisy oracle _",
    ", then its unitary transformation is given as follows @xcite : @xmath69 where @xmath70 , @xmath71 and @xmath72 ( the states of working registers ) may depend on @xmath73 .",
    "as before @xmath74 ( and hence the result also ) may be a superposition of bit - positions .",
    "since an oracle call itself includes an error , an s - query should also be stochastic .",
    "@xmath75 returns @xmath61 with probability at least @xmath67 ( and @xmath76 with at most @xmath77 ) .",
    "g - queries , @xmath78 , are already stochastic , i.e. , succeed to find an answer with probability at least @xmath67 if there exists one , and they do not need modification .",
    "[ noisymtgs ] let @xmath79 and @xmath39 be as before .",
    "then @xmath78 needs @xmath36 noisy oracle calls .    in this paper",
    "our oracle mode is almost always noisy .",
    "therefore we simply use the notation @xmath80 and @xmath81 instead of @xmath82 and @xmath83 .",
    "recall that the candidate set @xmath0 ( @xmath84 is given as an @xmath85 matrix @xmath43 .",
    "before we give our main result in the next section , we discuss the case that @xmath43 is small , i.e. , @xmath86 in this section , which we need in the main algorithm and also will be nice to understand the basic idea . since our goal is to find a single row from the @xmath1 ones , a natural strategy is to reduce the number of candidate rows ( a subset of rows denoted by @xmath0 ) step by step .",
    "this can be done easily if there is a column , say , @xmath87 which is  balanced , \" i.e. , which has an approximately equal number of @xmath28 s and @xmath29 s in @xmath88 , where @xmath88 denotes the matrix obtained from @xmath43 by deleting all rows not in @xmath0 .",
    "then by asking the value of @xmath89 by an @xmath90 , we can reduce the _ size _ of @xmath0 ( i.e. , the number of oracle candidates ) by a constant factor .",
    "suppose otherwise , that there are no such good columns in @xmath88 .",
    "then we gather a certain number of columns such that the set @xmath39 of these columns is  balanced , \" namely , such that the number of rows which has @xmath29 somewhere in @xmath39 is a constant fraction of @xmath91 .",
    "( see fig .  1 where the columns in @xmath39 are shifted to the left .",
    ") now we execute @xmath62 and we can reduce the size of @xmath0 by a constant fraction according to whether @xmath62 returns nill ( @xmath0 is reduced to @xmath92 in fig .",
    "1 ) or not ( @xmath0 is reduced to @xmath93 in fig .  1 )",
    ". then we move to the next iteration until @xmath91 becomes one .",
    "the merit of using @xmath62 is obvious since it needs at most @xmath94 queries while we may need roughly @xmath38 queries if asking each position by s - queries .",
    "even so , if @xmath38 is too large , we can not tolerate the cost for @xmath62 .",
    "so , the key issue here is to set a carefully chosen upper bound for the size of @xmath39 .",
    "if we can select @xmath39 within this upper bound , then we are happy",
    ". otherwise , we just give up constructing @xmath39 and use another strategy which takes advantage of the sparseness of the current matrix @xmath88 .",
    "( obviously @xmath88 is sparse since we could not select a @xmath39 of small size . )",
    "it should be also noted that in each iteration the matrix @xmath88 should be _ one - sensitive _ , namely the number of 1 s is less than or equal to the number of 0 s in every column .",
    "( the reason is obvious since it does not make sense to try to find 1 if almost all entries are 1 . ) for this purpose we implicitly apply the _ column - flipping _ procedure in each iteration .",
    "suppose that some column , say @xmath87 , of @xmath88 has more 1 s than 0 s .",
    "then this procedure  flips \" the value of @xmath89 by adding an extra circuit to the oracle ( but without any oracle call ) .",
    "let this oracle be @xmath95 and @xmath96 be the matrix obtained by flipping the column @xmath87 of @xmath88 .",
    "then obviously @xmath53 iff the matrix @xmath96 contains the row @xmath95 , i.e. , the problem does not change essentially .",
    "note that the column - flipping is the same as that in @xcite , where the oip matrix was written as a @xmath97 ( number of columns @xmath98 number of rows ) @xmath28-@xmath29 matrix instead of the more common @xmath99 one .",
    "this procedure narrows @xmath0 in each iteration , where @xmath39 is a set of columns and @xmath101 is an integer @xmath102 necessary for error control . see procedure 1 for its pseudocode . : if @xmath2 has one or more @xmath29 s in @xmath39 like @xmath103 in fig .  1",
    ", then @xmath104 gives us one of the positions of these @xmath29 s , say the circled one in the figure .",
    "the procedure returns with the set @xmath105 of rows in the figure , i.e. , the rows having a @xmath29 in the position selected by the @xmath62 . :",
    "if @xmath2 has no @xmath29 s in @xmath39 like @xmath106 in the figure , then @xmath107 ( i.e. , @xmath62 correctly answered ) . even if @xmath108 ( @xmath62 failed ) then @xmath109 , i.e.",
    ", the majority of @xmath110 samples of @xmath111 , is @xmath28 with high probability regardless of the value of @xmath112 .",
    "therefore the procedure returns with the set @xmath92 of rows , i.e. , the rows having no @xmath29 s in @xmath39 .",
    "the parameter @xmath101 guarantees the success probability of this procedure as follows .",
    "[ rowreduct ] the success probability and the number of oracle calls in @xmath113 are @xmath114 and @xmath115 , respectively .    in each repetition , we need @xmath94 oracle calls for the g - queries and @xmath116 calls ( s - queries ) for @xmath109",
    ". thus the total number of calls is @xmath115 . for the success probability , let us first consider case @xmath29 above . since the g - queries are repeated up to @xmath101 times , the probability that all tries fail ( i.e. , the next @xmath117 ) is @xmath118 .",
    "when it succeeds , the following @xmath119 fails with probability @xmath118 also ( here , the number of samples ( @xmath120 ) for majority is set appropriately so that the error probability is at most @xmath118 by the chernoff bound ) .",
    "hence the total failure probability is at most @xmath121 . in case @xmath122 , since @xmath119 fails with probability @xmath121 in each iteration , the total probability of failure is at most @xmath123 .      as mentioned in sec .",
    "3.1 , we need to make a set @xmath39 of columns being balanced as a whole .",
    "this procedure is used for this purpose where @xmath88 is the current matrix and @xmath125 controls the size of @xmath39 .",
    "see procedure 2 for its pseudocode . as shown in fig .  2",
    ", the procedure adds columns @xmath126 to @xmath39 as long as a new addition @xmath127 increases the number of covered rows ( @xmath128 ) by a factor of @xmath129 or until the number of covered rows becomes @xmath130 .",
    "we say that rowcover _ succeeds _",
    "if it finishes with @xmath131 such that @xmath132 and _ fails _ otherwise .",
    "suppose that we choose a smaller @xmath129 .",
    "then this guarantees that the resulting @xmath88 when rowcover fails is more sparse , which is desirable for us as described later . however since @xmath133 ,",
    "a smaller @xmath129 means a larger @xmath39 when the procedure succeeds , which costs more for g - queries in rowreduction .",
    "thus , we should choose the minimum @xmath129 such that the query complexity for the case that rowcover keeps succeeding as long as the total cost does not exceed the total limit ( @xmath134 ) .",
    "now we are ready to prove our first theorem :    [ n_times_n ] the @xmath85 oip can be solved with a constant success probability by querying the blackbox oracle @xmath17 times if @xmath86 .",
    "see procedure 5 for the pseudocode of the algorithm roips(@xmath135 ) ( robust oip algorithm for small @xmath43 ) .",
    "we call this procedure with @xmath136 ( we need this parameter since roips is also used in the later algorithm ) and the given matrix @xmath43 . as described in sec .  3.1 , we narrow the candidate set @xmath0 at lines 2 and 3 .",
    "if rowcover at line 2 succeeds , then @xmath91 is sufficiently reduced .",
    "even if rowcover fails , @xmath91 is also reduced similarly if rowreduction at line 3 can find a @xmath29 by g - queries .",
    "otherwise line 7 is executed where the current oracle looks like @xmath106 in fig .",
    "1 . in this case , by finding a @xmath29 in the positions @xmath137 by the g - query at line 7 , @xmath91 is reduced to @xmath138 , because we set @xmath139 at line 2 . since the original size of @xmath0 is @xmath140 for a constant @xmath141 , line 7",
    "is executed at most @xmath142 times .",
    "note that the selection of the value of @xmath129 at line @xmath122 follows the rule described in sec .  3.3",
    ": since @xmath139 , the size of @xmath39 at line 3 is at most @xmath143 .",
    "this implies that the number of oracle calls at line 3 is @xmath144 .",
    "since line 3 is repeated at most @xmath145 times , the total number of oracle calls at line 3 is at most @xmath17 .",
    "line 7 needs @xmath17 oracle calls , but the number of its repetitions is @xmath146 as mentioned above .",
    "thus the total number of oracle calls is @xmath17 .    also by lemma  1 ,",
    "the error probability of line 3 is at most @xmath147 .",
    "since the number of repetitions is @xmath145 , this error probability is obviously small enough .",
    "the error probability of line 7 is constant but again this is not harmful since it is repeated only @xmath146 times , and thus the error probability can be made as small as it is needed at constant cost .",
    "in this section , our @xmath85 input matrix @xmath43 is large , i.e. , @xmath1 is superpolynomial .",
    "we first observe how the previous algorithm , roips , would work for such a large @xmath43 . due to the rule given in sec .",
    "3.3 , the value of @xmath129 at line 2 should be @xmath148 .",
    "the calculation is not hard : since we need @xmath149 repetitions for the main loop , we should assign roughly @xmath150 to @xmath101 of rowreduction for a sufficiently small error in each round",
    ". then the cost of rowreduction will be @xmath151 .",
    "furthermore , we have to multiply the number of repetitions by @xmath149 factor , which gives us @xmath152 , the desired complexity .",
    "thus it would be nice if rowcover keeps succeeding .",
    "however , once rowcover fails , each column can still include as many as @xmath153  @xmath29 s which obviously needs too many repetitions of rowreduction at line 7 of roips .",
    "recall that the basic idea of roips is to reduce the number of candidates in the candidate set @xmath0 by halving ( the first phase ) while the matrix is dense and to use the more direct method ( the second phase ) after the matrix becomes sufficiently sparse .",
    "if the original matrix is large , this strategy fails because , as mentioned above , the matrix does not become sufficiently sparse after the first phase .",
    "now our idea is to introduce an `` intermediate '' procedure which reduces the number of the candidates more efficiently than the first phase . for this purpose , we use rowreductionexpire_mtgs , which tries to find a position of `` 1 '' in the oracle with multi - target grover search ( @xmath154 in lemma  [ mtgs ] ) by assuming that the portion of such position , @xmath155 , is sufficiently larger than @xmath156 .",
    "if the assumption is indeed true then we apply rowreduction as before and moreover the number of g - queries in the main loop of rowreduction is repeated for a constant time of @xmath157 on average .    however , it is of course possible that the actual number of repetitions is far different from the expected value .",
    "that is why we limit the maximum number of oracle calls spent in g - queries by max_queries(@xmath158 ) , a properly adjusted number which depends on the size of the oip matrix , and will be referred in the hereafter without its arguments for simplicity .",
    "if the value of count gets this value , then the procedure expires ( just stops ) with no answer , but this probability is negligibly small by selecting max_queries appropriately .",
    "notice also that because of the failure of phase 1 , it is guaranteed that the number of @xmath29 s in each column is `` fairly '' small , which in turn guarantees that the degree of row reduction is satisfactory for us .",
    "see procedure 8 for our new algorithm roipl .",
    "finally , when the assumption is false , rowreductionexpire_mtgs finishes after @xmath159 iterations of its main loop . in this case",
    ", we can prove that the matrix of the remaining candidates is very sparse and the number of its rows decreases exponentially by a single execution of rowreductionexpire_mtgs .",
    "thus one can achieve our upper bound also ( details are given in the next section ) .",
    "one can see that in roipl , oracle calls take place only at lines 6 and 11 .",
    "as described in the previous overview , the total number of oracle calls in rowreduction at line 6 is @xmath6 , and the whole execution of this part succesfully ends up with high probability .",
    "for the cost of line 11 , we can prove the following lemma .",
    "the main loop ( line 4 to 13 ) of roipl finishes with high probability before the value of count reaches max_queries(@xmath158 ) .",
    "note that there are two types of oracle calls in rowreductionexpire_mtgs at lines 11 .",
    "the first type , type a , is when portion of `` 1 '' in the hidden oracle is at least @xmath160 , and the other type , type b , is when the portion of `` 1 '' is smaller .",
    "let @xmath161 be the expected number of oracle calls , where @xmath162 is the expected number of type a calls and @xmath163 , that of type b calls .",
    "it is enough to prove that @xmath164 and @xmath165 .",
    "we defer the rigorous proofs in the appendix and give instead the following more simple averaging argument on the bounds of @xmath162 and @xmath163 .",
    "we first prove that @xmath166 .",
    "first , note that rowreductionexpire_mtgs for type a should require an @xmath146 expected number of iterations of @xmath81 , each of which requires @xmath167 queries .",
    "now , since phase 1 has failed , the number of rows having a `` 1 '' at some position in @xmath168 is at most @xmath169 .",
    "thus , after the above @xmath167 queries the number of candidates is reduced by a factor of @xmath170 .",
    "therefore , intuitively , to reduce the number of candidates by half , the number of queries spent in @xmath62 is @xmath171 .",
    "thus we have the following recurrence relation : @xmath172 where @xmath173 is the number of type a queries to distinguish the candidate set @xmath0 .",
    "since roipl starts with @xmath174 and ends with @xmath175 ( note that @xmath176 if @xmath175 ) , the above recurrence relation resolves to the following : @xmath177 where @xmath178 is a sufficiently large constant .",
    "therefore , the total number of queries is @xmath6 since @xmath179 if @xmath180 .",
    "note that if the above averaging argument is correct then @xmath91 can be reduced into a constant by just repeating line  11 .",
    "however , this is not exactly true for roipl since @xmath91 can only be reduced until becoming @xmath181 in order to obtain the desired number of query complexity ( see the proof of lemma  6 in appendix ) .",
    "fortunately , in this case we can resort to roips for identifying the hidden oracle out of @xmath182 candidates with just @xmath17 queries as in line  16 , and thus achieve a similar result with the averaging argument .    for technical details of roipl ,",
    "note that @xmath183 is ten times the expected total number of queries supposing all queries are at line 11 , i.e. , the case with the biggest number of type a queries . by markov bound , the probability that the number of queries exceeds this amount is negligible ( at most @xmath184 ) .",
    "we summarize the property of rowreductionexpire_mtgs in the following lemma which can be proven similarly as lemma  [ rowreduct ] .",
    "[ mtgs ] the success probability and the number of oracle calls of the procedure + @xmath185 are @xmath114 and @xmath186 , respectively . moreover ,",
    "if there are more than @xmath129 fraction of @xmath29 s in the current oracle , then the average number of queries is @xmath187 .",
    "we next prove that @xmath188 . in this case",
    ", multitargetgq fails and therefore the density of `` 1 '' at every row of the candidates is less than @xmath189 .",
    "note that any two rows in @xmath190 ( the new s at the left - hand side of line 11 ) must be different , i.e. , we have to generate @xmath191 different rows by using at most @xmath192  @xmath29 s for each row .",
    "let @xmath193 be the number of rows in @xmath190 which include at most @xmath194  @xmath29 s .",
    "then @xmath195 rows include at least @xmath194  @xmath29 s , and hence the number of such rows must be at most @xmath196 .",
    "thus we have @xmath197 and it follows that @xmath198 the right - hand side is at most @xmath199 ( see e.g. , @xcite , page 33 ) , which is then bounded by @xmath200 since @xmath201 for a small @xmath73 .",
    "thus , we have @xmath202 iterations of rowreductionexpire_mtgs to reduce the number of the candidates from @xmath1 to @xmath203 .",
    "note that we let @xmath204 at line 11 and therefore the error probability of its single iteration is at most @xmath205 .",
    "considering the number of iterations mentioned above , this is enough to claim that @xmath206 ( see appendix for the proof in detail , where the actual bound of @xmath163 is shown to be much smaller ) .",
    "now here is our main theorem in this paper .",
    "[ n_times_m_u ] the @xmath99 oip can be solved with a constant success probability by querying the blackbox oracle @xmath207 times if @xmath208 for some constant @xmath23 ( @xmath209 ) .",
    "the total number of oracle calls at line 6 is within the bound as described in sec .",
    "4.1 and the total number of oracle calls at line 11 is bounded by lemma  4 . as for the success probability ,",
    "we have already proved that there is no problem for the total success probability of line 6 ( sec .",
    "4.1 ) and lines 11 ( lemma  4 ) . thus the theorem has been proved .",
    "next , we consider the case when @xmath211 .",
    "note that when @xmath212 , for a constant @xmath213 , the lower bound of the number of queries is @xmath214 instead of @xmath215 .",
    "therefore , it is natural to expect that the number of queries exceeds our bound as @xmath1 approaches @xmath216 .",
    "indeed , when @xmath217 , the number of queries of roipl is bigger than @xmath6 but still better than @xmath10 , as shown in the following theorem .",
    "[ n_times_m_u1 ] for @xmath218 , the @xmath99 oip can be solved with a constant success probability by querying the blackbox oracle @xmath219 times for @xmath220 .",
    "the algorithm is the same as roipl excepting the following : at line 1 , we set @xmath221 as before if @xmath222 . otherwise , i.e. , if @xmath223 , we set @xmath224 .",
    "then , we can use almost the same argument to prove the theorem , which may be omitted .",
    "* remark  1  * actually the query complexity of theorem  3 changes smoothly from @xmath6 to @xmath225 and to @xmath10 as @xmath1 changes from @xmath226 to @xmath227 and to @xmath9 , respectively .",
    "when @xmath228 , the lower bound @xmath215 in @xcite becomes @xmath229 .",
    "so it seems that our upper bound is worse than this lower bound by a factor of @xmath31 .",
    "however , if @xmath1 is this large , then we can improve the lower bound to @xmath230 and hence our upper bound is worse than the lower bound only by at most a factor of @xmath27 in this range ( see appendix ) .",
    "as mentioned above , our upper bound becomes trivial @xmath10 when @xmath231 , while for bigger @xmath1 @xcite has already given a nice robust algorithm which can be used for oip with @xmath10 queries .",
    "a challenging question is whether or not there exists an oip algorithm whose upper bound is @xmath210 for @xmath232 , say , for @xmath233 .",
    "even more challenging is to design an oip algorithm which is optimal in the whole range of @xmath1 .",
    "there are two possible scenarios : the one is that the lower bound becomes @xmath214 for some @xmath234 .",
    "the other is that there is no such case , i.e. , the bound is always @xmath210 if @xmath234 . at this moment",
    ", we do not have any conjecture about which scenario is more likely .",
    "@xmath63 and @xmath235 @xmath236  @xmath237  @xmath238    @xmath239 and @xmath240 @xmath241 @xmath242 @xmath243 @xmath244  @xmath39    @xmath245    the majority of @xmath246 samples of @xmath111 if @xmath247 , else @xmath28 .",
    "@xmath248 @xmath249 @xmath250 @xmath251 @xmath252    ( @xmath7 ) for @xmath253 : @xmath62 is replaced by @xmath254 , a g - query on @xmath39 assuming that there are more than @xmath129 fraction of @xmath29 s in the current oracle , and at line 7 the set of all rows that have at most @xmath129 fraction of @xmath29 s is returned instead .",
    "@xmath255 0 - 1 matrix and @xmath256 + @xmath257 @xmath258 + @xmath259 + @xmath260 @xmath261 @xmath250 @xmath250 @xmath262 @xmath263 relabel @xmath0 and @xmath264 so that the answer to oip of @xmath43 can be deduced from that of @xmath264 @xmath265    1 s.  aaronson and a.  ambainis .",
    "quantum search of spatial regions . in _ proc .  of stoc 03 _ ,",
    "pages 200209 , 2003 .",
    "m.  adcock and r.  cleve . a quantum goldreich - levin theorem with cryptographic applications . in _ proc .  of stacs",
    "02 _ , lncs 2285 , pages 323334 , 2002 .",
    "a.  ambainis .",
    "quantum walk algorithm for element distinctness . in _ proc .  of focs 04 _ , pages 2231 , 2004 .",
    "a.  ambainis , k.  iwama , a.  kawachi , h.  masuda , r.  h. putra , and s.  yamashita . quantum identification of boolean oracles . in _ proc .  of stacs",
    "04 _ , lncs 2996 , pages 105116 , 2004 .",
    "a.  atici and r.  a.  servedio .",
    "improved bounds on quantum learning algorithms .",
    "quantum information processing , pages 132 , jan .",
    "2006 . also in arxiv :",
    "quant - ph/0411140 r.  beals , h.  buhrman , r.  cleve , m.  mosca , and r.  de  wolf .",
    "quantum lower bounds by polynomials . in _",
    "ieee symposium on foundations of computer science _ , pages 352361 , 1998 .",
    "e.  bernstein and u.  vazirani .",
    "quantum complexity theory .",
    ", 26(5):14111473 , 1997 .",
    "d.  biron , o.  biham , e.  biham , m.  grassl , and d.  a. lidar .",
    "generalized grover search algorithm for arbitrary initial amplitude distribution . in _ proc .  of qcqc 98",
    "_ , lncs 1509 , pages 140147 , 1998 .",
    "m.  boyer , g.  brassard , p.  hyer , and a.  tapp .",
    "tight bounds on quantum searching .",
    ", vol . 46(4 - 5 ) , 493505 , 1998 .",
    "g.  brassard , p.  hyer , m.  mosca , a.  tapp . quantum amplitude amplification and estimation . in _",
    "ams contemporary mathematics series millennium volume entitled `` quantum computation & information '' _ , vol 305 , pages 5374 , 2002 .",
    "h.  buhrman , c.  drr , m.  heiligman , p.  hyer , f.  magniez , m.  santha and r.  de  wolf . quantum algorithms for element distinctness . in _ proc .  of ccc 01",
    "_ , pages 131137 , 2001 .",
    "h.  buhrman , i.  newman , h.  rhrig , and r.  de  wolf .",
    "robust quantum algorithms and polynomials . in _ proc .  of stacs",
    "05 _ , lncs 3404 , pages 593604 , 2005 . b.  chazelle , d.  liu and a.  magen .",
    "sublinear geometric algorithms . in _ proc .  of stoc 03",
    "_ , 531 - 540 , pages 531540 , 2003 .",
    "d.  p. chi and j.  kim .",
    "quantum database searching by a single query . in _ proc .  of qcqc 98",
    "_ , lncs 1509 , pages 148151 , 1998 .",
    "g.  d.  cohen , i.  honkala , s.  n.  litsyn and a.  lobstein .",
    "covering codes , north holland , amsterdam , the netherlands , 1997 . c.  drr , m.  heiligman , p.  hyer , and m.  mhalla .",
    "quantum query complexity of some graph problems . in _ proc .",
    "of icalp 04 _ , lncs 3142 , pages 481493 , 2004 .",
    "e.  farhi , j.  goldstone , s.  gutmann , and m.  sipser .",
    "how many functions can be distinguished with @xmath112 quantum queries ? in _ phys .",
    "a 60 _ , 6 , 43314333 , 1999 ( quant - ph/9901012 ) .",
    "u.  feige , p.  raghavan , d.  peleg , and e.  upfal .",
    "computing with noisy information .",
    ", 23(5):10011018 , 1994 . o.  goldreich , s.  goldwasser , and d.  ron .",
    "property testing and its connection to learning and approximation . in _ proc . of focs 96 _ , pages 339348 , 1996 .",
    "l.  k. grover . a fast quantum mechanical algorithm for database search . in _ proc .  of stoc 96 _",
    ", pages 212218 , 1996 .",
    "p.  hyer , m.  mosca , and r.  de  wolf .",
    "quantum search on bounded - error inputs . in _ proc .  of icalp 03",
    "_ , lncs 2719 , pages 291299 , 2003 .",
    "m.  hunziker , d.  a.  meyer , j.  park , j.  pommersheim and m.  rothstein the geometry of quantum learning .",
    "arxiv : quant - ph/0309059 , to appear in quantum information processing .",
    "r.  krauthgamer and o.  sasson .",
    "property testing of data dimensionality . in _ proc .  of soda 03 _ ,",
    "pages 1827 , 2003 .",
    "f.  magniez , m.  santha and m.  szegedy .",
    "quantum algorithms for the triangle problem . in _ proc .  of soda 05 _ , pages 11091117 , 2005 .",
    "quantum lower bounds for the collision and the element distinctness problems . in _ proc .  of focs 02 _ , pages 513519 , 2002 .",
    "theorem  2 can be shown by proving lemma  4 , concluding that roipl succeeds to identify the blackbox oracle with constant probability using at most @xmath266 queries . here , we provide its detailed proof by showing the following lemmas .",
    "notice that @xmath178 is the constant factor in lemma  2 which can be computed from @xcite .",
    "[ lemmacandidaterowwithcounter ] with high probability , the total number of type a queries at line 11 in the whole rounds of roipl does not exceed @xmath267 .",
    "[ lemmacandidaterow ] with high probability , the total number of type b queries at line 11 in the whole rounds of roipl is less than @xmath268 .",
    "now it is left to prove the above two lemmas .",
    "* proof of lemma  [ lemmacandidaterowwithcounter ] . * before proving lemma  [ lemmacandidaterowwithcounter ] , we show the following :    rowreductionexpire_mtgs at line 11 of roipl is executed for at most @xmath269 times .",
    "rowreductionexpire_mtgs at line 11 is executed when the first rowreduction at line 6 can not reduce @xmath270 fraction of the rows .",
    "thus , finding a position of `` 1 '' reduces the number of candidates by a @xmath221 fraction .",
    "thus , denoting the set of oracle candidates at round @xmath112 as @xmath271 , @xmath272 is at most @xmath273 .",
    "therefore , it follows that rowreductionexpire is executed for at most @xmath269 times .",
    "now , let us first bound the number of queries of type a at rowreductionexpire_mtgs at line 11 .",
    "for this purpose , let @xmath274 and @xmath275 be the random variables denoting the number of queries of the rowreductionexpire at round @xmath112 and the total number of queries of the rowreductionexpire in the whole rounds , respectively .",
    "clearly , since for each trial of @xmath276 the success probability is at least @xmath67 , the average number of queries is : @xmath277 = \\sum_{k=0}^{m^ * } e[x_k ] & \\le &   \\sum_{k=0}^{m^*}\\sum_{m=1}^{\\infty}\\sigma \\cdot \\frac{2}{3 } \\cdot \\frac{1}{3^{m-1 } } \\cdot m \\cdot   \\sqrt{\\frac{n\\log{n}}{\\log{|s_k|}}}\\\\     & \\le & \\frac{3}{2}\\sigma \\cdot   \\sum_{k=0}^{m^*}\\sqrt{\\frac{n\\log{n}}{\\log{|s_k|}}}\\\\   & = & \\frac{3}{2}\\sigma \\cdot   \\sqrt{n\\log{n } } \\sum_{k=0}^{m^ * }   1/\\sqrt{\\log{m } + k \\log{\\beta } } \\\\   & = & \\frac{3}{2}\\sigma \\cdot   \\sqrt{n\\log{n } } \\sum_{k=0}^{m^ * }   1/\\sqrt{10\\log{n } + k \\log{(1/\\beta)}}\\ \\mbox{(reordering the   summation)}\\\\    & \\le & \\frac{3}{2}\\sigma \\cdot   \\sqrt{n\\log{n } }   \\sum_{k=1}^{\\log({\\log{m}/\\log{n}})-1 }   \\frac{2^k\\log{n}}{\\log{(1/\\beta)}}\\cdot\\frac{1}{\\sqrt{2^k\\log{n}}}\\\\    & = & \\frac{3}{2}\\sigma \\cdot   \\frac{\\sqrt{n\\log{n}\\log{m}}}{\\log{(1/\\beta)}}. \\end{aligned}\\ ] ] note that the fifth inequality is obtained from bounding the sum of terms whose values are between @xmath278 and @xmath279 ; there are at most @xmath280 of them .    when @xmath208 , @xmath281 and by markov bound , @xmath282   \\le 1/t$ ] , i.e. , the probability that stage  2 ends in failure is at most @xmath283 \\le 1/10 $ ] .",
    "this proves the lemma . *",
    "proof of lemma  [ lemmacandidaterow ] .",
    "* since type b queries are considered , the portion of `` 1 '' in the oracle is less than @xmath284 .",
    "therefore if rowreductionexpire_mtgs does not finish after @xmath285 repetitions , by lemma  [ mtgs ] this case can be detected with probability at least @xmath286 . and",
    "fortunately , since @xmath272 , the number of the candidate oracles at round @xmath112 , is at most @xmath287 , this case happens only @xmath288 times in the whole course of the algorithm .",
    "thus we have the following recurrence relation : @xmath289 where @xmath290 is the number of type b queries to distiguish the candidate set @xmath271 .",
    "this resolves to @xmath291 which is much smaller than @xmath292 since @xmath293 for @xmath294 and @xmath295 for @xmath22 . as can be seen in the above inequality , the number of queries at the last rounds , namely , when @xmath296 , is the dominant factor because @xmath272 decreases doubly exponentially .",
    "this concludes the proof .",
    "here , we will show that for @xmath297 roipl is only @xmath298 worse than the query - optimal algorithm .",
    "the following theorem is by @xcite .",
    "similar to the proof in theorem  2 in @xcite .",
    "in fact , the proof of theorem  2 of @xcite already achieved the above lower bound but there @xmath301 is substituted for @xmath302 which is not done here because the substitution can weaken the statement .",
    "* remark  2  * a similar but weaker lower bound can be found in @xcite where it is shown that the lower bound for oip with the number of candidates @xmath1 is @xmath302 such that @xmath302 is the smallest integer satisfying @xmath303 .        for @xmath228",
    ", we can take @xmath305 since @xmath306 ( see , e.g. , @xcite , page 33 ) where here , @xmath307 for a small @xmath73 . by the previous theorem",
    ", there exists an oip whose query complexity is @xmath230 while by theorem  3 the query complexity of roipl is only @xmath10 ."
  ],
  "abstract_text": [
    "<S> the oracle identification problem ( oip ) was introduced by ambainis et al .  </S>",
    "<S> @xcite . </S>",
    "<S> it is given as a set @xmath0 of @xmath1 oracles and a blackbox oracle @xmath2 . </S>",
    "<S> our task is to figure out which oracle in @xmath0 is equal to the blackbox @xmath2 by making queries to @xmath2 . </S>",
    "<S> oip includes several problems such as the grover search as special cases . in this paper , we improve the algorithms in @xcite by providing a mostly optimal upper bound of query complexity for this problem : ( @xmath3 ) for any oracle set @xmath0 such that @xmath4 ( @xmath5 ) , we design an algorithm whose query complexity is @xmath6 , matching the lower bound proved in @xcite . </S>",
    "<S> ( @xmath7 ) our algorithm also works for the range between @xmath8 and @xmath9 ( where the bound becomes @xmath10 ) , but the gap between the upper and lower bounds worsens gradually . ( @xmath11 ) our algorithm is robust , namely , it exhibits the same performance ( up to a constant factor ) against the noisy oracles as also shown in the literatures @xcite for special cases of oip .    quantum computing , query complexity and algorithmic learning theory </S>"
  ]
}