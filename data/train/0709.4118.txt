{
  "article_text": [
    "abstraction techniques are widely used in model checking to hide some properties of the concrete model in order to define a reduced abstract model where to run the verification algorithm  @xcite .",
    "abstraction provides an effective solution to deal with the state - explosion problem that arises in model checking systems with parallel components  @xcite .",
    "the reduced abstract structure is required at least to weakly preserve a specification language @xmath8 of interest : if a formula @xmath9 is satisfied by the reduced abstract model then @xmath10 must hold on the original unabstracted model as well .",
    "ideally , the reduced model should be strongly preserving w.r.t .",
    "@xmath8 : @xmath9 holds on the concrete model if and only if @xmath10 is satisfied by the reduced abstract model . one common approach for abstracting a model consists in defining a logical equivalence or preorder on system states that weakly / strongly preserves a given temporal language .",
    "moreover , this equivalence or preorder often arises as a behavioural relation in the context of process calculi  @xcite .",
    "two well - known examples are bisimulation equivalence that strongly preserves expressive logics such as @xmath11 and the full @xmath12-calculus  @xcite and the simulation preorder that ensures weak preservation of universal and existential fragments of the @xmath12-calculus like @xmath13 and @xmath14 as well as of linear - time languages like @xmath15  @xcite . simulation equivalence ,",
    "namely the equivalence relation obtained as symmetric reduction of the simulation preorder , is particularly interesting because it can provide a significantly better state space reduction than bisimulation equivalence while retaining the ability of strongly preserving expressive temporal languages like @xmath13 .",
    "[ [ state - of - the - art . ] ] state of the art .",
    "+ + + + + + + + + + + + + + + + +    it is known that computing simulation is harder than computing bisimulation  @xcite .",
    "let @xmath16 denote a kripke structure on the state space @xmath0 , with transition relation @xmath1 and labeling function @xmath17 , for a given set @xmath18 of atomic propositions .",
    "bisimulation equivalence can be computed by the well - known paige and tarjan s  @xcite algorithm that runs in @xmath19-time .",
    "a number of algorithms for computing simulation equivalence exist , the most well known are by henzinger , henzinger and kopke  @xcite , bloom and paige  @xcite , bustan and grumberg  @xcite , tan and cleaveland  @xcite and gentilini , piazza and policriti  @xcite , this latter subsequently corrected by van glabbeek and ploeger  @xcite .",
    "the algorithms by henzinger , henzinger , kopke and by bloom and paige run in @xmath3-time and , as far as time - complexity is concerned , they are the best available algorithms . however , both these algorithms have the drawback of a space complexity that is bounded from below by @xmath20 .",
    "this is due to the fact that the simulation preorder is computed in an explicit way , i.e. , for any state @xmath21 , the set of states that simulate @xmath22 is explicitly given as output .",
    "this quadratic lower bound in the size of the state space is clearly a critical issue in model checking .",
    "there is therefore a strong motivation for designing simulation algorithms that are less demanding on space requirements .",
    "bustan and grumberg  @xcite provide a first solution in this direction .",
    "let @xmath2 denote the partition corresponding to simulation equivalence on @xmath23 so that @xmath24 is the number of simulation equivalence classes .",
    "then , bustan and grumberg s algorithm has a space complexity in @xmath25 corresponding to bisimulation equivalence . under the simplifying assumption of dealing with a total transition relation ,",
    "this procedure has a time complexity in @xmath26 and a space complexity in @xmath27 does not appear in @xcite and takes into account the relation that maps each state into its bisimulation equivalence class ) .",
    "the algorithm by gentilini , piazza and policriti  @xcite appears to provide the best compromise between time and space complexity .",
    "gentilini et al.s algorithm runs in @xmath4-time , namely it remarkably improves on bustan and grumberg s algorithm and is not directly comparable with tan and cleaveland s algorithm , while the space complexity @xmath28 main contributions .",
    "+ + + + + + + + + + + + + + + + + + +    this work presents a new efficient simulation algorithm , called @xmath29 , that runs in @xmath6-time and @xmath30-space .",
    "thus , while retaining an acceptable space complexity that is in general less than quadratic in the size of the state space , our algorithm improves the best known time bound .",
    "+ let us recall that a relation @xmath31 between states is a simulation if for any @xmath32 such that @xmath33 , @xmath34 and for any @xmath35 such that @xmath36 , there exists @xmath37 such that @xmath38 and @xmath39 .",
    "then , @xmath40 simulates @xmath22 , namely the pair @xmath41 belongs to the simulation preorder @xmath42 , if there exists a simulation relation @xmath31 such @xmath33 .",
    "also , @xmath22 and @xmath40 are simulation equivalent , namely they belong to the same block of the simulation partition @xmath2 , if @xmath40 simulates @xmath22 and vice versa .",
    "+ our simulation algorithm @xmath29 is designed as a modification of henzinger , henzinger and kopke s  @xcite algorithm , here denoted by @xmath43 .",
    "the space complexity of @xmath43 is in @xmath44 .",
    "this is a consequence of the fact that @xmath43 computes explicitly the simulation preorder , namely it maintains for any state @xmath21 a set of states @xmath45 , called the simulator set of @xmath22 , which stores states that are currently candidates for simulating @xmath22 .",
    "our algorithm @xmath29 computes instead a symbolic representation of the simulation preorder , namely it maintains : ( i ) a partition @xmath46 of the state space @xmath0 that is always coarser than the final simulation partition @xmath2 and ( ii ) a relation @xmath47 on the current partition @xmath46 that encodes the simulation relation between blocks of simulation equivalent states .",
    "this symbolic representation is the key both for obtaining the @xmath48 time bound and for limiting the space complexity of @xmath29 in @xmath49 , so that memory requirements may be lower than quadratic in the size of the state space .",
    "+ the basic idea of our approach is to investigate whether the logical structure of the @xmath43 algorithm may be preserved by replacing the family of sets of states @xmath50 with the following state partition @xmath46 induced by @xmath51 : two states @xmath52 and @xmath53 are equivalent in @xmath46 iff for all @xmath21 , @xmath54 .",
    "additionally , we store and maintain a preorder relation @xmath47 on the partition @xmath46 that gives rise to a so - called partition - relation pair @xmath55 . the logical meaning of this data structure",
    "is that if @xmath56 and @xmath57 then any state in @xmath58 is currently candidate to simulate each state in @xmath59 , while two states @xmath52 and @xmath53 in the same block @xmath59 are currently candidates to be simulation equivalent .",
    "hence , a partition - relation pair @xmath55 represents the current approximation of the simulation preorder and in particular @xmath46 represents the current approximation of simulation equivalence .",
    "it turns out that the information encoded by a partition - relation pair is enough for preserving the logical structure of @xmath43 .",
    "in fact , analogously to the stepwise design of the @xmath43 procedure , this approach leads us to design a basic procedure @xmath60 based on partition - relation pairs which is then refined twice in order to obtain the final simulation algorithm @xmath29 .",
    "the correctness of @xmath29 is proved w.r.t .",
    "the basic algorithm @xmath60 and relies on abstract interpretation techniques  @xcite .",
    "more specifically , we exploit some previous results  @xcite that show how standard strong preservation of temporal languages in abstract kripke structures can be generalized by abstract interpretation and cast as a so - called completeness property of abstract domains . on the other hand ,",
    "the simulation algorithm @xmath29 is designed as an efficient implementation of the basic procedure @xmath60 where the symbolic representation based on partition - relation pairs allows us to replace the size @xmath61 of the state space in the time and space bounds of @xmath43 with the size @xmath24 of the simulation partition in the corresponding bounds for @xmath29 .",
    "+ both @xmath43 and @xmath29 have been implemented in c++ .",
    "this practical evaluation considered benchmarks from the vlts ( very large transition systems ) suite  @xcite and some publicly available esterel programs .",
    "the experimental results showed that @xmath29 outperforms @xmath43 .",
    "[ [ notations . ] ] notations .",
    "+ + + + + + + + + +    let @xmath62 and @xmath63 be sets . if @xmath64 and @xmath62 is understood as a universe set then @xmath65 .",
    "if @xmath66 then the image of @xmath67 is denoted by @xmath68 .",
    "when writing a set @xmath69 of subsets of a given set of integers , e.g.  a partition , @xmath69 is often written in a compact form like @xmath70 or @xmath71 , [ 12 ] , [ 13]\\}$ ] that stands for @xmath72 .",
    "if @xmath73 is any relation then @xmath74 denotes the reflexive and transitive closure of @xmath31 . also , if @xmath75 then @xmath76[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{x'\\in x~|~ ( x , x')\\in r\\}$ ] .",
    "[ [ orders . ] ] orders .",
    "+ + + + + + +    let @xmath77 be a poset , that may also be denoted by @xmath78 .",
    "we use the symbol @xmath79 to denote pointwise ordering between functions : if @xmath62 is any set and @xmath80 then @xmath81 if for all @xmath75 , @xmath82 . if @xmath83 then @xmath84[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\ { x\\in s~|~ \\forall y\\in s.\\ ; x\\leq y { \\rightarrow}x = y\\}$ ] denotes the set of maximal elements of @xmath69 in @xmath85 . a complete lattice @xmath86 is also denoted by @xmath87 where @xmath88 , @xmath89 , @xmath90 and @xmath91 denote , respectively , lub , glb , greatest element and least element in @xmath58 . a function @xmath92 between complete lattices is additive when @xmath67 preserves least upper bounds",
    "let us recall that a reflexive and transitive relation @xmath73 on a set @xmath62 is called a preorder on @xmath62 .",
    "[ [ partitions . ] ] partitions .",
    "+ + + + + + + + + + +    a partition @xmath46 of a set @xmath0 is a set of nonempty subsets of @xmath0 , called blocks , that are pairwise disjoint and whose union gives @xmath0 .",
    "@xmath93 denotes the set of partitions of @xmath0 . if @xmath94 and @xmath21 then @xmath95 denotes the block of @xmath46 that contains @xmath22 .",
    "@xmath93 is endowed with the following standard partial order @xmath96 : @xmath97 , i.e.  @xmath98 is coarser than @xmath99 ( or @xmath99 refines @xmath98 ) iff @xmath100 . if @xmath101 , @xmath102 and @xmath103 then @xmath104 ( when clear from the context the subscript @xmath98 may be omitted ) denotes the unique block in @xmath98 that contains @xmath59 . for a given nonempty subset @xmath105 called splitter ,",
    "we denote by @xmath106 the partition obtained from @xmath46 by replacing each block @xmath107 with the nonempty sets @xmath108 and @xmath109 , where we also allow no splitting , namely @xmath110 ( this happens exactly when @xmath69 is a union of some blocks of @xmath46 ) .    [",
    "[ kripke - structures . ] ] kripke structures .",
    "+ + + + + + + + + + + + + + + + + +    a transition system @xmath111 consists of a set @xmath0 of states and a transition relation @xmath112 .",
    "the relation @xmath1 is total when for any @xmath113 there exists some @xmath35 such that @xmath114 .",
    "the predecessor / successor transformers @xmath115 ( when clear from the context the subscript @xmath1 may be omitted ) are defined as usual :    * @xmath116[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\ { a\\in \\sigma ~|~\\exists b\\in y.\\ ; a { { \\shortrightarrow}}b\\}$ ] ; * @xmath117[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\ { b \\in \\sigma~|~ \\exists a\\in y.\\ ; a{{\\shortrightarrow}}b\\}$ ] .",
    "let us remark that @xmath118 and @xmath119 are additive operators on the complete lattice @xmath120 .",
    "if @xmath121 then @xmath122 iff there exist @xmath123 and @xmath124 such that @xmath125 .",
    "given a set @xmath126 of atomic propositions ( of some specification language ) , a kripke structure @xmath127 over @xmath126 consists of a transition system @xmath111 together with a state labeling function @xmath128 .",
    "a kripke structure is called total when its transition relation is total .",
    "we use the following notation : for any @xmath21 , @xmath129_\\ell { \\mbox{\\raisebox{0ex}[1ex][1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{s'\\in \\sigma~|~ \\ell(s)=\\ell(s')\\}$ ] denotes the equivalence class of a state @xmath22 w.r.t .",
    "the labeling @xmath130 , while @xmath131[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{[s]_\\ell~|~ s\\in \\sigma\\}\\in\\operatorname{part}(\\sigma)$ ] is the partition induced by @xmath130 .",
    "recall that a relation @xmath132 is a simulation on a kripke structure @xmath133 over a set @xmath18 of atomic propositions if for any @xmath32 such that @xmath33 :    * @xmath34 ; * for any @xmath35 such that @xmath36 , there exists @xmath37 such that @xmath38 and @xmath39 .",
    "if @xmath33 then we say that @xmath40 simulates @xmath22 .",
    "the empty relation is a simulation and simulation relations are closed under union , so that the largest simulation relation exists .",
    "it turns out that the largest simulation is a preorder relation called simulation preorder ( on @xmath23 ) and denoted by @xmath42 .",
    "simulation equivalence @xmath134 is the symmetric reduction of @xmath42 , namely @xmath135 .",
    "@xmath136 denotes the partition corresponding to @xmath137 and is called simulation partition .",
    "it is a well known result in model checking @xcite that the reduction of @xmath23 w.r.t .",
    "simulation equivalence @xmath137 allows us to define an abstract kripke structure @xmath138 that strongly preserves the temporal language @xmath13 , where : @xmath2 is the abstract state space , @xmath139 is the abstract transition relation between simulation equivalence classes , while for any block @xmath140 , @xmath141[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\ell(s)$ ] for any representative @xmath142 .",
    "it turns out that @xmath143 strongly preserves @xmath13 , i.e. , for any @xmath144 , @xmath140 and @xmath142 , we have that @xmath145 if and only if @xmath146 .      [ [ abstract - domains - as - closures . ] ] abstract domains as closures .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in standard abstract interpretation , abstract domains can be equivalently specified either by galois connections / insertions or by ( upper ) closure operators ( uco s )  @xcite .",
    "these two approaches are equivalent , modulo isomorphic representations of domain s objects .",
    "we follow here the closure operator approach : this has the advantage of being independent from the representation of domain s objects and is therefore appropriate for reasoning on abstract domains independently from their representation .    given a state space @xmath0 , the complete lattice @xmath120 plays the role of concrete domain .",
    "let us recall that an operator @xmath147 is a uco on @xmath148 , that is an abstract domain of @xmath148 , when @xmath12 is monotone , idempotent and extensive ( viz . , @xmath149 ) .",
    "it is well known that the set @xmath150 of all uco s on @xmath148 , endowed with the pointwise ordering @xmath79 , gives rise to the complete lattice @xmath151 of all the abstract domains of @xmath148 .",
    "the pointwise ordering @xmath79 on @xmath150 is the standard order for comparing abstract domains with regard to their precision : @xmath152 means that the domain @xmath153 is a more precise abstraction of @xmath148 than @xmath154 , or , equivalently , that the abstract domain @xmath153 is a refinement of @xmath154 .",
    "a closure @xmath155 is uniquely determined by its image @xmath156 , which coincides with its set of fixpoints , as follows : @xmath157 . also , a set of subsets @xmath158 is the image of some closure operator @xmath159 iff @xmath160 is a moore - family of @xmath148 , i.e. , @xmath161[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{\\cap s~|~ s\\subseteq { { \\mathcal{x}}}\\}$ ] ( where @xmath162 ) .",
    "in other terms , @xmath160 is a moore - family ( or moore - closed ) when @xmath160 is closed under arbitrary intersections . in this case",
    ", @xmath163 is the corresponding closure operator .",
    "for any @xmath158 , @xmath164 is called the moore - closure of @xmath160 , i.e. , @xmath164 is the least set of subsets of @xmath0 which contains all the subsets in @xmath160 and is moore - closed .",
    "moreover , it turns out that for any @xmath165 and any moore - family @xmath158 , @xmath166 and @xmath167 .",
    "thus , closure operators on @xmath148 are in bijection with moore - families of @xmath148 .",
    "this allows us to consider a closure operator @xmath168 both as a function @xmath147 and as a moore - family @xmath169 .",
    "this is particularly useful and does not give rise to ambiguity since one can distinguish the use of a closure @xmath12 as function or set according to the context .",
    "[ [ abstract - domains - and - partitions . ] ] abstract domains and partitions .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as shown in @xcite , it turns out that partitions can be viewed as particular abstract domains .",
    "let us recall here that any abstract domain @xmath168 induces a partition @xmath170 that corresponds to the following equivalence relation @xmath171 on @xmath0 : @xmath172    [ simple ] let @xmath173 and consider the following abstract domains in @xmath150 that are given as intersection - closed subsets of @xmath148 : @xmath174 , @xmath175 , @xmath176 .",
    "these abstract domains all induce the same partition @xmath177,[3],[4]\\}\\in \\operatorname{part}(\\sigma)$ ] .",
    "for example , @xmath178 , @xmath179 so that @xmath180 .",
    "[ [ forward - completeness . ] ] forward completeness .",
    "+ + + + + + + + + + + + + + + + + + + + +    let us consider an abstract domain @xmath181 , a concrete semantic function @xmath182 and a corresponding abstract semantic function @xmath183 ( for simplicity of notation , we consider 1-ary functions ) .",
    "it is well known that the abstract interpretation @xmath184 is sound when @xmath185 holds : this means that a concrete computation @xmath186 on an abstract object @xmath187 is correctly approximated in @xmath12 by @xmath188 , that is , @xmath189 .",
    "forward completeness corresponds to require the following strengthening of soundness : @xmath184 is forward complete when @xmath190 : the intuition here is that the abstract function @xmath191 is able to mimic @xmath67 on the abstract domain @xmath12 with no loss of precision .",
    "this is called forward completeness because a dual and more standard notion of backward completeness may also be considered ( see e.g.@xcite ) .    as a toy example , let us consider the following abstract domain @xmath192 for representing the sign of an integer variable : @xmath193 .",
    "the concrete pointwise addition @xmath194 on sets of integers , that is @xmath195[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$ } } } } \\{x+y~|~ x\\in x,\\ , y\\in y\\}$ ] , is approximated in @xmath192 by the abstract addition @xmath196 that is defined as expected by the following table : @xmath197    it turns out that @xmath198 is forward complete , i.e. , for any @xmath199 , @xmath200 .",
    "it turns out that the possibility of defining a forward complete abstract interpretation on a given abstract domain @xmath12 does not depend on the choice of the abstract function @xmath201 but depends only on the abstract domain @xmath12 .",
    "this means that if @xmath184 is forward complete then the abstract function @xmath191 indeed coincides with the best correct approximation @xmath202 of the concrete function @xmath67 on the abstract domain @xmath12 .",
    "hence , for any abstract domain @xmath12 and abstract function @xmath191 , it turns out that @xmath184 is forward complete if and only if @xmath203 is forward complete .",
    "this allows us to define the notion of forward completeness independently of abstract functions as follows : an abstract domain @xmath204 is forward complete for @xmath67 ( or forward @xmath67-complete ) iff @xmath205 . let us remark that @xmath12 is forward @xmath67-complete iff the image @xmath156 is closed under applications of the concrete function @xmath67 .",
    "if @xmath206 is a set of concrete functions then @xmath12 is forward complete for @xmath206 when @xmath12 is forward complete for all @xmath207 .",
    "[ [ forward - complete - shells . ] ] forward complete shells .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    it turns out @xcite that any abstract domain @xmath165 can be refined to its forward @xmath206-complete shell , namely to the most abstract domain that is forward complete for @xmath206 and refines @xmath12 .",
    "this forward @xmath206-complete shell of @xmath12 is thus defined as @xmath208[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\sqcup \\ { \\rho \\in \\operatorname{uco}(\\wp(\\sigma))~|~ \\rho",
    "\\sqsubseteq \\mu,\\ , \\rho",
    "\\text{~is forward $ f$-complete}\\}.\\ ] ]    forward complete shells admit a constructive fixpoint characterization . given @xmath209 , consider the operator @xmath210 defined by @xmath211[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\operatorname{cl_\\cap}(\\mu \\cup \\{f(x)~|~f\\in f,\\ : x\\in \\rho\\}).\\ ] ] thus , @xmath212 refines the abstract domain @xmath12 by adding the images of @xmath213 for all the functions in @xmath206 .",
    "it turns out that @xmath214 is monotone and therefore admits the greatest fixpoint , denoted by @xmath215 , which provides the forward @xmath206-complete shell of @xmath12 : @xmath216 .",
    "[ [ disjunctive - abstract - domains . ] ] disjunctive abstract domains .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    an abstract domain @xmath209 is disjunctive ( or additive ) when @xmath12 is additive and this happens exactly when the image @xmath156 is closed under arbitrary unions .",
    "hence , a disjunctive abstract domain is completely determined by the image of @xmath12 on singletons because for any @xmath217 , @xmath218 .",
    "the intuition is that a disjunctive abstract domain does not lose precision in approximating concrete set unions .",
    "we denote by @xmath219 the set of disjunctive abstract domains .    given any abstract domain @xmath209 , it turns out  @xcite that @xmath12 can be refined to its disjunctive completion @xmath220 : this is the most abstract disjunctive domain @xmath221 that refines @xmath12 .",
    "the disjunctive completion @xmath220 can be obtained by closing the image @xmath156 under arbitrary unions , namely @xmath222[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{\\cup \\mathcal{s}~|~ \\mathcal{s}\\subseteq \\operatorname{img}(\\mu)\\}$ ] , where @xmath223 .",
    "it turns out that an abstract domain @xmath12 is disjunctive iff @xmath12 is forward complete for arbitrary concrete set unions , namely , @xmath12 is disjunctive iff for any @xmath224 , @xmath225 .",
    "thus , when @xmath0 is finite , the disjunctive completion @xmath220 of @xmath12 coincides with the forward @xmath226-complete shell @xmath227 of @xmath12 . also , since the predecessor transformer @xmath228 preserves set unions , it turns out that the forward complete shell @xmath229 for @xmath230 can be obtained by iteratively closing the image of @xmath12 under @xmath228 and then by taking the disjunctive completion , i.e. , @xmath231 .",
    "[ simple2 ] let us consider the abstract domain @xmath232 in example  [ simple ] .",
    "we have that @xmath12 is not disjunctive because @xmath233 while @xmath234 .",
    "the disjunctive completion @xmath220 is obtained by closing @xmath12 under unions : @xmath235 .",
    "[ [ some - properties - of - abstract - domains . ] ] some properties of abstract domains .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let us summarize some easy properties of abstract domains that will be used in later proofs .",
    "[ prop ] let @xmath209 , @xmath236 , @xmath237 such that @xmath238 and @xmath239 .",
    "* for any @xmath107 , @xmath240 .",
    "* for any @xmath241 , @xmath242 .",
    "* for any @xmath241 , @xmath243 .",
    "* @xmath244 .",
    "ranzato and tapparo @xcite showed how strong preservation of specification languages in standard abstract models like abstract kripke structures can be generalized by abstract interpretation and cast as a forward completeness property of generic abstract domains that play the role of abstract models .",
    "we rely here on this framework in order to show that the simulation preorder can be characterized as a forward complete shell for set union and the predecessor transformer .",
    "let @xmath263 be a kripke structure .",
    "recall that the labeling function @xmath130 induces the state partition @xmath264_\\ell ~|~ s\\in \\sigma\\}$ ]",
    ". this partition can be made an abstract domain @xmath265 by considering the moore - closure of @xmath266 that simply adds to @xmath266 the empty set and the whole state space , namely @xmath267[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\operatorname{cl_\\cap}(\\{[s]_\\ell ~|~ s\\in \\sigma\\})$ ] .",
    "[ fcs ] let @xmath268 be the forward @xmath269-complete shell of @xmath270 . then , @xmath271 and @xmath272",
    ".    given a disjunctive abstract domain @xmath273 , define @xmath274[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{(s , s')\\in\\sigma\\times \\sigma~|~s'\\in \\mu(\\{s\\})\\}$ ] .",
    "we prove the following three preliminary facts :    * @xmath12 is forward complete for @xmath275 iff @xmath276 satisfies the following property : for any @xmath277 such that @xmath278 and @xmath279 there exists @xmath280 such that @xmath281 and @xmath282 .",
    "observe that the disjunctive closure @xmath12 is forward complete for @xmath275 iff for any @xmath283 , if @xmath284 then @xmath285 , and this happens iff for any @xmath283 , if @xmath286 then @xmath285 .",
    "this latter statement is equivalent to the fact that for any @xmath287 such that @xmath278 and @xmath288 , there exists @xmath289 such that @xmath281 , namely , for any @xmath287 such that @xmath278 and @xmath279 , there exists @xmath290 such that @xmath282 and @xmath281 . *",
    "@xmath291 iff @xmath276 satisfies the property that for any @xmath292 , if @xmath279 then @xmath293 : in fact , @xmath291 @xmath294 @xmath295_\\ell$ ] @xmath294 @xmath296_\\ell)$ ] @xmath294 @xmath297 . *",
    "clearly , given @xmath298 , @xmath299 iff @xmath300 .",
    "let us show that @xmath301 . by definition",
    ", @xmath302 is the most abstract disjunctive closure that is forward complete for @xmath275 and refines @xmath270 .",
    "thus , by the above points ( 1 ) and ( 2 ) , it turns out that @xmath303 is a simulation on @xmath23 .",
    "consider now any simulation @xmath69 on @xmath23 and the function @xmath304[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\ok{\\operatorname{post}_{s^*}}:\\wp(\\sigma ) { \\rightarrow}\\wp(\\sigma)$ ] .",
    "let us notice that @xmath305 and @xmath306 . also , the relation @xmath307 is a simulation because @xmath69 is a simulation .",
    "since @xmath307 is a simulation , we have that @xmath308 satisfies the conditions of the above points ( 1 ) and ( 2 ) so that @xmath309 is forward complete for @xmath275 and @xmath310 .",
    "moreover , @xmath309 is disjunctive so that @xmath309 is also forward complete for @xmath226 .",
    "thus , @xmath311 .",
    "hence , by point ( 3 ) above , @xmath312 so that @xmath313 .",
    "we have therefore shown that @xmath303 is the largest simulation on @xmath23 .",
    "the fact that @xmath272 comes as a direct consequence because for any @xmath283 , @xmath314 iff @xmath315 and @xmath316 .",
    "from @xmath301 we obtain that @xmath314 iff @xmath317 and @xmath318 iff @xmath319 .",
    "this holds iff @xmath22 and @xmath320 belong to the same block in @xmath321 .",
    "thus , the simulation preorder is characterized as the forward complete shell of an initial abstract domain @xmath270 induced by the labeling @xmath130 w.r.t .  set union @xmath226 and the predecessor transformer @xmath275 while simulation equivalence is the partition induced by this forward complete shell .",
    "let us observe that set union and the predecessor @xmath275 provide the semantics of , respectively , logical disjunction and the existential next operator @xmath322 .",
    "as shown in @xcite , simulation equivalence can be also characterized in a precise meaning as the most abstract domain that strongly preserves the language @xmath323    [ esempio ] let us consider the kripke structure @xmath23 depicted below where the atoms @xmath324 and @xmath325 determine the labeling function @xmath130 .",
    "it is simple to observe that @xmath326 because : ( i )  while @xmath327 we have that @xmath328 so that @xmath329 and @xmath330 are not simulation equivalent to @xmath331 ; ( ii )  while @xmath332 we have that @xmath333 so that @xmath329 is not simulation equivalent to @xmath330 .",
    "the abstract domain induced by the labeling is @xmath334 .",
    "as observed above , the forward complete shell @xmath335 so that this domain can be obtained by iteratively closing the image of @xmath270 under @xmath275 and then by taking the disjunctive completion :    * @xmath336 ; * @xmath337 @xmath338 ; * @xmath339 ; * @xmath340  ( fixpoint ) .",
    "@xmath341 is thus given by the disjunctive completion of @xmath154 , i.e. , @xmath342 @xmath343 .",
    "note that @xmath344 , @xmath345 , @xmath346 and @xmath347 .",
    "hence , by theorem  [ fcs ] , the simulation preorder is @xmath348 , while @xmath349 .",
    "theorem  [ fcs ] is one key result for proving the correctness of our simulation algorithm @xmath29 while it is not needed for understanding how @xmath29 works and how to implement it efficiently .",
    "let @xmath94 and @xmath350 be any relation on the partition @xmath46 .",
    "one such pair @xmath351 is called a _ partition - relation pair_. a partition - relation pair @xmath351 induces a disjunctive closure @xmath352 as follows : for any @xmath353 , @xmath354[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\cup\\ { c\\!\\in\\ !",
    "p\\ , |\\ , \\exists b\\!\\in\\ !",
    "p.\\ , b\\cap x \\!\\neq\\ ! \\varnothing , ( b , c)\\in r^*\\}.\\ ] ] it is easily shown that @xmath355 is indeed a disjunctive uco .",
    "note that , for any @xmath107 and @xmath356 , @xmath357    this correspondence is a key logical point for proving the correctness of our simulation algorithm . in fact , our algorithm maintains a partition - relation pair , where the relation is a preorder , and our proof of correctness depends on the fact that this partition - relation pair logically represents a corresponding disjunctive abstract domain .",
    "[ simplebis ] let @xmath173 , @xmath358 and @xmath359 .",
    "note that @xmath360 .",
    "the disjunctive abstract domain @xmath355 is such that @xmath361 and @xmath362 , so that the image of @xmath355 is @xmath363 .",
    "on the other hand , any abstract domain @xmath165 induces a partition - relation pair @xmath364 as follows :    * @xmath365[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\operatorname{par}(\\mu)$ ] ; * @xmath366[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{(b , c)\\in p_\\mu\\times p_\\mu~|~c \\subseteq \\mu(b)\\}$ ] .",
    "the following properties of partition - relation pairs will be useful in later proofs .",
    "[ prprop ] let @xmath351 be a partition - relation pair and @xmath165 .",
    "* @xmath367 .",
    "* @xmath368 .",
    "it turns out that the above two correspondences between partition - relation pairs and disjunctive abstract domains are inverse of each other when the relation is a partial order .",
    "[ luno ] for any partition @xmath94 , partial order @xmath350 and disjunctive abstract domain @xmath374 , we have that @xmath375 and @xmath376 .",
    "let us show that @xmath377 .",
    "we first prove that @xmath378 , i.e.   @xmath379 .",
    "on the one hand , by lemma  [ prprop ]  ( i ) , @xmath380 . on the other hand , if @xmath381 , @xmath382 and @xmath383 and @xmath384 then @xmath385 and @xmath386 .",
    "since @xmath31 is a partial order , we have that @xmath387 is a partial order as well , so that @xmath388 , namely @xmath389 .",
    "our simulation algorithm relies on the following condition on a partition - relation pair @xmath351 w.r.t .",
    "a transition system @xmath400 which guarantees that the corresponding disjunctive abstract domain @xmath355 is forward complete for the predecessor @xmath275 .",
    "[ ltre ] let @xmath400 be a transition system and @xmath351 be a partition - relation pair where @xmath31 is reflexive .",
    "assume that for any @xmath56 , if @xmath401 then @xmath402 .",
    "then , @xmath355 is forward complete for @xmath275 .",
    "we preliminarily show the following fact :      let us now turn to show the lemma . by lemma  [ prprop ]  ( i ) , we have that @xmath380 . by the above fact  @xmath429 , in order to prove that @xmath355 is forward complete for @xmath275 it is sufficient to show that for any @xmath56 , if @xmath401 then @xmath430 .",
    "thus , assume that @xmath401 .",
    "we need to show that @xmath431 .",
    "assume that @xmath432 , namely that there exist @xmath433}\\subseteq p$ ] , for some @xmath434 , such that @xmath435 , @xmath436 and for any @xmath437 , @xmath438 .",
    "we show by induction on @xmath439 that @xmath440 .",
    "( @xmath441 ) : :    this means that @xmath442 .",
    "since @xmath31 is assumed to    be reflexive , we have that @xmath443 . by hypothesis ,",
    "@xmath444 so that we obtain    @xmath445 .",
    "( @xmath446 ) : :    assume that @xmath447 . by    inductive hypothesis ,    @xmath448 .",
    "note    that , by additivity of @xmath275 ,    @xmath449 .",
    "thus , there exists some    @xmath450 such that @xmath451 and    @xmath452 .",
    "hence ,    by hypothesis , @xmath453 .",
    "observe that    @xmath454 so that    @xmath455 .",
    "@xmath456 @xmath457    @xmath458    @xmath459 @xmath457    @xmath458    @xmath460 @xmath457    @xmath458",
    "our simulation algorithm @xmath29 is designed as a symbolic modification of henzinger , henzinger and kopke s simulation algorithm @xcite .",
    "this algorithm is designed in three incremental steps encoded by the procedures @xmath461 , @xmath462 and @xmath43 ( called @xmath463 in @xcite ) in figure  [ hhkfig ] .",
    "consider any ( possibly non total ) finite kripke structure @xmath464 .",
    "the idea of the basic @xmath461 algorithm is simple . for each state @xmath465",
    ", the simulator set @xmath466 contains states that are candidates for simulating @xmath467 .",
    "hence , @xmath468 is initialized with all the states having the same labeling as @xmath467 , that is @xmath469_\\ell$ ]",
    ". the algorithm then proceeds iteratively as follows : if @xmath470 , @xmath471 but there is no @xmath472 such that @xmath473 then @xmath474 can not simulate @xmath475 and therefore @xmath476 is refined to @xmath477 .",
    "this basic procedure is then refined to the algorithm @xmath462 .",
    "the key point here is to store for each state @xmath465 an additional set of states @xmath478 that is a superset of @xmath468 ( invariant @xmath479 ) and contains the states that were in @xmath468 in some past iteration where @xmath467 was selected . if @xmath470 then the invariant @xmath480 allows to refine @xmath476 by scrutinizing only the states in @xmath481 instead of all the possible states in @xmath0 : in fact , while in @xmath461 , @xmath476 is reduced to @xmath482 , in @xmath462 , @xmath476 is reduced in the same way by removing from it the states in @xmath483[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\operatorname{pre}(\\mathit{prevsim}(v))\\smallsetminus \\operatorname{pre}(\\mathit{sim}(v))$ ] .",
    "the initialization of @xmath468 that distinguishes the case @xmath484 allows to initially establish the invariant @xmath480 .",
    "let us remark that the original @xmath462 algorithm presented in  @xcite contains the following bug : the statement @xmath485 is placed just after the inner for - loop instead of immediately preceding the inner for - loop .",
    "it turns out that this is not correct as shown by the following example .",
    "[ contro ] let us consider the kripke structure in example  [ esempio ] .",
    "we already observed that the simulation relation is @xmath486 .",
    "however , one can check that the original version of the @xmath462 algorithm in @xcite    where the assignment @xmath485 follows the inner for - loop    provides as output @xmath487 , @xmath488 , @xmath489 , @xmath490 , namely the state @xmath330 appears to simulate the state @xmath329 while this is not the case .",
    "the problem with the original version in @xcite of the @xmath462 algorithm lies in the fact that when @xmath491    like in this example for state 1    it may happen that during the inner for - loop the set @xmath468 is refined to @xmath492 so that if the assignment @xmath485 follows the inner for - loop then @xmath478 might be computed as an incorrect subset of the right set .",
    "@xmath462 is further refined to the final @xmath43 algorithm .",
    "the idea here is that instead of recomputing at each iteration of the while - loop the set @xmath493 for the selected state @xmath467 , a set @xmath494 is maintained and incrementally updated for each state @xmath465 in such a way that it satisfies the invariant @xmath495 .",
    "the original version of @xmath43 in @xcite also suffers from a bug that is a direct consequence of the problem in @xmath462 described above : within the main while - loop of @xmath43 , the statement @xmath496 is placed just after the outermost for - loop instead of immediately preceding the outermost for - loop .",
    "it is easy to show that this is not correct by resorting again to example  [ contro ] .",
    "the implementation of @xmath43 exploits a matrix @xmath497 , indexed on states @xmath498 , such that @xmath499 , i.e. , @xmath497 stores the number of transitions from @xmath475 to some state @xmath500 .",
    "hence , the test @xmath501 in the innermost for - loop can be done in @xmath502 by checking whether @xmath503 is 0 or not .",
    "this provides an efficient implementation of @xmath43 that runs in @xmath3 time , while the space complexity is in @xmath504 , namely it is more than quadratic in the size of the state space",
    ". let us remark that the key property for showing the @xmath3 time bound is as follows : if a state @xmath467 is selected at some iterations @xmath505 and @xmath506 of the while - loop and the iteration @xmath505 precedes the iteration @xmath506 then @xmath507 , so that the sets in @xmath508 is selected at some iteration i @xmath458 are pairwise disjoints .",
    "let us consider any ( possibly non total ) finite kripke structure @xmath464 . as recalled above",
    ", the @xmath43 procedure maintains for each state @xmath21 a simulator set @xmath45 and a remove set @xmath509 .",
    "the simulation preorder @xmath42 is encoded by the output @xmath510 as follows : @xmath511 iff @xmath512 .",
    "hence , the simulation equivalence partition @xmath2 is obtained as follows : @xmath22 and @xmath40 are simulation equivalent iff @xmath513 and @xmath512 .",
    "our algorithm relies on the idea of modifying the @xmath43 procedure in order to maintain a partition - relation pair @xmath55 in place of @xmath510 , together with a remove set @xmath514 for each block @xmath107 .",
    "the basic idea is to replace the family of sets @xmath515 with the following state partition @xmath46 induced by @xmath51 : @xmath516 iff for all @xmath21 , @xmath517 .",
    "then , a reflexive relation @xmath518 on @xmath46 gives rise to a partition - relation pair where the intuition is as follows : given a state @xmath22 and a block @xmath107 ( i )  if @xmath142 then the current simulator set for @xmath22 is a the union of blocks in @xmath46 that are in relation with @xmath59 , i.e.@xmath519 ; ( ii ) if @xmath520 then @xmath22 and @xmath40 are currently candidates to be simulation equivalent . thus , a partition - relation pair @xmath55 represents the current approximation of the simulation preorder and in particular @xmath46 represents the current approximation of simulation equivalence .",
    "partition - relation pairs have been used by henzinger , henzinger and kopke s  @xcite to compute the simulation preorder on effectively presented infinite transition systems , notably hybrid automata .",
    "henzinger et al .",
    "provide a symbolic procedure , called @xmath521 in @xcite , that is derived as a symbolization through partition - relation pairs of their basic simulation algorithm @xmath461 in figure  [ hhkfig ] .",
    "moreover , partition - relation pairs are also exploited by gentilini et al .",
    "@xcite in their simulation algorithm for representing simulation relations .",
    "the distinctive feature of our use of partition - relation pairs is that , by relying on the results in section  [ prp ] , we logically view partition - relation pairs as abstract domains and therefore we can reason on them by using abstract interpretation .",
    "following henzinger et al .",
    "@xcite , our simulation algorithm is designed in three incremental steps .",
    "we exploit the following results for designing the basic algorithm .",
    "* theorem  [ fcs ] tells us that the simulation preorder can be obtained from the forward @xmath269-complete shell of an initial abstract domain @xmath270 induced by the labeling @xmath130 . *",
    "as shown in section  [ prp ] , a partition - relation pair can be viewed as representing a disjunctive abstract domain . *",
    "lemma  [ ltre ] gives us a condition on a partition - relation pair which guarantees that the corresponding abstract domain is forward complete for @xmath275 .",
    "moreover , this abstract domain is disjunctive as well , being induced by a partition - relation pair .",
    "@xmath522 @xmath457    @xmath458    thus , the idea consists in iteratively and minimally refining an initial partition - relation pair @xmath55 induced by the labeling @xmath130 until the condition of lemma  [ ltre ] is satisfied : for all @xmath56 , @xmath523 let us observe that @xmath524 means that @xmath525 .",
    "the basic algorithm , called @xmath60 , is in figure  [ fig : basic ] .",
    "the current partition - relation pair @xmath55 is refined by the following three steps in @xmath60 .",
    "if @xmath59 is the block of the current partition @xmath46 selected by the while - loop then :    * the current partition @xmath46 is split with respect to the set @xmath526 ; * if @xmath58 is a newly generated block after splitting the current partition and @xmath527 is its parent block in the partition @xmath528 before the splitting operation then @xmath529 is modified so as that @xmath530 ; * the current relation @xmath531 is refined for the ( new and old ) blocks @xmath58 such that @xmath525 by removing from @xmath529 those blocks that are not contained in @xmath69 ; observe that after having split @xmath46 w.r.t . @xmath69",
    "it turns out that one such block @xmath532 either is contained in @xmath69 or is disjoint with @xmath69 .",
    "let us remark that although the symbolic simulation algorithm for infinite graphs @xmath521 in @xcite may appear similar to our @xmath60 algorithm , it is instead inherently different due to the following reason : the role played by the condition : @xmath533 in the while - loop of @xmath60 is played in @xmath521 by : @xmath534 , and this latter condition is computationally harder to check .",
    "the following correctness result formalizes that @xmath60 can be viewed as an abstract domain refinement algorithm that allows us to compute forward complete shells for @xmath269 . for any abstract domain @xmath209 ,",
    "we write @xmath535 when the algorithm @xmath60 on an input partition - relation @xmath536 terminates and outputs a partition - relation pair @xmath537 such that @xmath538 .",
    "[ mainalgo ] let @xmath0 be finite .",
    "then , @xmath60 terminates on any input domain @xmath209 and @xmath539 .",
    "let @xmath540 and @xmath541 be , respectively , the current and next partition - relation pair in some iteration of @xmath542 . by line 5 , @xmath543 always holds .",
    "moreover , if @xmath544 then it turns out that @xmath545 : in fact , if @xmath546 , @xmath547 and @xmath548 then , by lines 6 and 7 , @xmath549 because there exists @xmath550 such that @xmath551 so that if @xmath552 is the block that contains @xmath398 then @xmath553 while @xmath554 .",
    "thus , either @xmath555 or @xmath545 , so that , since the state space @xmath0 is finite , the procedure @xmath60 terminates .",
    "let @xmath556 , namely , let @xmath538 where @xmath537 is the output of @xmath60 on input @xmath536 .",
    "let @xmath557}$ ] be the sequence of partition - relation pairs computed by @xmath60 , where @xmath558 and @xmath559 .",
    "let us first observe that for any @xmath437 , @xmath560 because the current partition is refined by the splitting operation in line 5 .",
    "moreover , for any @xmath437 and @xmath561 , note that @xmath562 , because the current relation is modified only at lines 6 and 7 .",
    "let us also observe that for any @xmath563 $ ] , @xmath564 is a reflexive relation because @xmath565 is reflexive and the operations at lines 6 - 7 preserve the reflexivity of the current relation .",
    "let us show this latter fact . if @xmath566 is such that @xmath567 then because , by hypothesis , @xmath568 , we have that @xmath569 so that @xmath570 .",
    "hence , if @xmath571 then @xmath572 ,",
    "while if @xmath573 then , by hypothesis , @xmath574 so that , by line 6 , @xmath575 also in this case .        thus , @xmath309 is a refinement of @xmath12 . we have that @xmath578 , @xmath582 is ( as shown above ) reflexive and because @xmath537 is the output partition - relation pair , for all @xmath583 , if @xmath401 then @xmath584 .",
    "hence , by lemma  [ ltre ] we obtain that @xmath309 is forward complete for @xmath275 .",
    "thus , @xmath309 is a disjunctive refinement of @xmath12 that is forward complete for @xmath275 so that @xmath585 .    in order to conclude the proof ,",
    "let us show that @xmath586 .",
    "we first show by induction that for any @xmath563 $ ] and @xmath587 , we have that @xmath588 :    ( @xmath589 ) : :    we have that @xmath590 so that    for any @xmath591 , by lemma  [ prop ]  ( ii ) ,    @xmath592 . hence ,    @xmath593 .",
    "( @xmath594 ) : :    let    @xmath595    for some @xmath596 . if    @xmath597 then , by    lines 6 - 7 ,    @xmath598    so that , by inductive hypothesis , @xmath599 .    on the other hand , if    @xmath600 then , by    lines 6 - 7 ,    @xmath601 . by inductive hypothesis , we have    that @xmath602    and    @xmath603 .    also , since    @xmath604 is    forward complete for @xmath275 ,    @xmath605 .",
    "hence , @xmath599 .",
    "thus , @xmath60 computes the forward @xmath269-complete shell of any input abstract domain . as a consequence ,",
    "@xmath60 allows us to compute both simulation relation and equivalence when @xmath270 is the initial abstract domain .",
    "[ maincoro ] let @xmath613 be a finite kripke structure and @xmath614 be the abstract domain induced by @xmath130 .",
    "then , @xmath615 where @xmath616 and , for any @xmath617 , @xmath618 .",
    "let @xmath619 . by theorem  [ mainalgo ] , if @xmath620 then @xmath621 . by theorem  [ fcs ] , @xmath622 . by lemma  [ prprop ]  ( i ) ,",
    "it remains to show that @xmath624 .",
    "let @xmath557}$ ] be the sequence of partition - relation pairs computed by @xmath60 , where @xmath625 and @xmath559 .",
    "we show by induction that for any @xmath563 $ ] , we have that @xmath626 .",
    "( @xmath589 ) : :    since @xmath627 , we have that    @xmath628 .",
    "( @xmath594 ) : :    consider @xmath629 .",
    "we have that    @xmath630    for some @xmath596 .",
    "we have shown in the proof of    theorem  [ mainalgo ] that @xmath631 .",
    "since    @xmath632 is forward complete for    @xmath275 , we also have that    @xmath633 .",
    "hence , @xmath634 .    by inductive hypothesis ,",
    "@xmath635 so that there exists some @xmath636 such that    @xmath637 . since @xmath638 ,    note that if @xmath639    then @xmath640    and if @xmath641    then    @xmath642 .",
    "moreover , if @xmath643    then @xmath644 , while if    @xmath645 then    @xmath646 . in both    cases , there exists some @xmath647 such that @xmath648 .",
    "@xmath654 @xmath457    @xmath458      the @xmath60 algorithm is refined to the @xmath655 procedure in figure  [ simequiv2 ] .",
    "this is obtained by adapting the ideas of henzinger et al.s @xmath462 procedure in figure  [ hhkfig ] to our @xmath60 algorithm .",
    "the following points show that this algorithm @xmath655 remains correct , i.e.the input - output behaviours of @xmath60 and @xmath655 are the same .    * for any block @xmath59 of the current partition @xmath46 , the predecessors of the blocks in the `` previous '' relation @xmath656 are maintained as a set @xmath657 .",
    "initially , at line  2 , @xmath657 is set to contain all the states in @xmath0 .",
    "then , when a block @xmath59 is selected by the while - loop at some iteration @xmath505 , @xmath657 is updated at line  7 in order to save the states in @xmath658 at this iteration @xmath505 .",
    "* if @xmath58 is a newly generated block after splitting @xmath46 and @xmath527 is its corresponding parent block in the partition before splitting then @xmath659 is set at line  12 as @xmath660 .",
    "therefore , since the current relation @xmath531 decreases only    i.e. , if @xmath505 and @xmath506 are iterations such that @xmath506 follows @xmath505 and @xmath661 are blocks such that @xmath662 then @xmath663    at each iteration , the following invariant @xmath479 holds : for any block @xmath107 , @xmath664 .",
    "initially , @xmath479 is satisfied because for any block @xmath59 , @xmath657 is initialized to @xmath0 at line  2 . *",
    "the crucial point is the invariant @xmath480 : if @xmath525 and @xmath665 then @xmath666 .",
    "initially , this invariant property is clearly satisfied because for any block @xmath59 , @xmath657 is initialized to @xmath0 .",
    "morever , @xmath480 is maintained at each iteration because at line  6 @xmath667 is set to @xmath668 and for any block @xmath58 such that @xmath669 if some block @xmath532 is contained in @xmath667 then @xmath532 is removed from @xmath529 at line  14 .",
    "thus , if the exit condition of the while - loop of @xmath655 is satisfied then , by invariant @xmath480 , the exit condition of @xmath60 is satisfied as well .",
    "finally , let us remark that the exit condition of the while - loop , namely @xmath670 , is strictly weaker than the exit condition that we would obtain as counterpart of the exit condition of the while - loop of henzinger et al.s @xmath462 procedure , i.e.  @xmath671 .",
    "@xmath672 @xmath457    @xmath458      following the underlying ideas that lead from @xmath462 to @xmath43 , the algorithm @xmath655 is further refined to its final version @xmath29 in figure  [ simequiv3 ] .",
    "the idea is that instead of recomputing at each iteration of the while - loop the set @xmath673 for the selected block @xmath59 , we maintain a set of states @xmath514 for each block @xmath59 of the current partition .",
    "for any block @xmath58 , @xmath674 is updated in order to satisfy the invariant condition @xmath495 : @xmath674 contains exactly the set of states that belong to @xmath659 but are not in @xmath675 , where @xmath659 is logically defined as in @xmath655 but is not really stored .",
    "moreover , the invariant condition @xmath676 ensures that , for any block @xmath58 , @xmath659 is a union of blocks of the current partition .",
    "this allows us to replace the operation @xmath677 in @xmath655 with the equivalent split operation @xmath678 .",
    "the correctness of such replacement follows from the invariant condition @xmath676 by exploiting the following general remark .",
    "[ lemparti ] let @xmath46 be a partition , @xmath679 be a union of blocks in @xmath46 and @xmath680 .",
    "then , @xmath681 .",
    "assume that @xmath682 , so that @xmath683",
    ". then , @xmath684 and @xmath685 so that @xmath59 is split neither by @xmath686 nor by @xmath69 .",
    "+ otherwise , if @xmath687 , because @xmath679 is a union of blocks , then @xmath688 . then , @xmath689 and @xmath690 so that @xmath59 is split by @xmath686 into @xmath691 and @xmath692 if and only if @xmath59 is split by @xmath69 into @xmath691 and @xmath692 .",
    "we have thus shown that @xmath681 .",
    "the equivalence between @xmath29 and @xmath655 is a consequence of the following observations .    * initially , the invariant properties @xmath495 and @xmath676 clearly hold because for any block @xmath59 , @xmath693 .",
    "* when a block @xmath694 of the current partition is selected by the while - loop , the corresponding remove set @xmath695 is set to empty at line  9 .",
    "the invariant @xmath495 , namely @xmath696 , is maintained at each iteration because for any block @xmath58 such that @xmath697 the for - loop at lines  23 - 24 incrementally adds to @xmath674 all the states @xmath22 that are in @xmath659 but not in @xmath675 . *",
    "if @xmath58 is a newly generated block after splitting @xmath46 and @xmath527 is its corresponding parent block in the partition before splitting then @xmath674 is set to @xmath698 by the for - loop at lines 13 - 17 .",
    "* as in @xmath655 , for any block @xmath58 such that @xmath669 , all the blocks that are contained in @xmath695 are removed from @xmath529 by the for - loop at lines  20 - 22 .",
    "if the exit condition of the while - loop of @xmath29 is satisfied then , by @xmath479 and @xmath495 , the exit condition of @xmath655 is satisfied as well .",
    "@xmath29 is implemented by using the following data structures .    *",
    "the set of states @xmath0 is represented as a doubly linked list where each state @xmath21 ( represented as an integer ) stores the list of its predecessors in @xmath699 .",
    "this provides a representation of the input transition system .",
    "any state @xmath21 also stores a pointer to the block of the current partition that contains @xmath22 . *",
    "the states of any block @xmath59 of the current partition are consecutive in the list @xmath0 , so that @xmath59 is represented by a record that contains two pointers to the first and to the last state in @xmath59 ( see figure  [ partitionfig ] ) .",
    "this structure allows us to move a state from a block to a different block in constant time .",
    "moreover , any block @xmath59 stores its corresponding remove set @xmath700 , which is represented as a list of ( pointers to ) states . *",
    "any block @xmath59 additionally stores an integer array @xmath701 that is indexed over @xmath0 and is defined as follows : for any @xmath395 , @xmath702 is the number of transitions from @xmath398 to some block @xmath703 .",
    "the array @xmath701 allows to implement in constant time the test @xmath704 at line  23 as @xmath705 . *",
    "the current partition is stored as a doubly linked list @xmath46 of blocks .",
    "newly generated blocks are appended or prepended to this list .",
    "blocks are scanned from the beginning of this list by checking whether the corresponding remove set is empty or not .",
    "if an empty remove set of some block @xmath59 becomes nonempty then @xmath59 is moved to the end of @xmath46 .",
    "* the current relation @xmath531 on the current partition @xmath46 is stored as a resizable @xmath706 boolean matrix ( * ? ? ?",
    "* section  17.4 ) .",
    "the algorithm adds a new entry to this matrix , namely a new row and a new column , as long as a block @xmath59 is split at line  12 into two new blocks @xmath707 and @xmath708 : the new block @xmath707 replaces the old block @xmath59 in @xmath46 while a new entry in the matrix @xmath531 corresponds to the new block @xmath708 .",
    "we will observe later that the overall number of newly generated blocks by the splitting operation at line  12 is exactly given by @xmath709 .",
    "hence , the total number of insert operations in the matrix @xmath531 is @xmath710 .",
    "since an insert operation in a resizable array ( whose capacity is doubled as needed ) takes an amortized constant time , the overall cost of inserting new entries to the matrix @xmath531 is in @xmath711-time .",
    "let us recall that the standard c++ vector class implements a resizable array so that a resizable boolean matrix can be easily implemented as a c++ vector of boolean vectors : in this implementation , the algorithm adds a new entry to a @xmath712 matrix by first inserting a new vector of size @xmath713 containing @xmath714 values and then by inserting @xmath713 @xmath714 values in the @xmath713 boolean vectors .",
    "let @xmath715 be some block of the initial partition @xmath716 and let @xmath717 be the sequence of all the blocks selected by the while - loop in a sequence @xmath718 of iterations such that :    * for any @xmath719 , @xmath720 ; * if an iteration @xmath721 follows an iteration @xmath719 , denoted by @xmath722 , then @xmath723 is contained in @xmath724 .    observe that @xmath59 is the parent block in @xmath725 of all the @xmath724 s .",
    "then , one key property of the @xmath29 algorithm is that the remove sets in @xmath726 are pairwise disjoint so that @xmath727 at line  20 is positive at some iteration @xmath728 then for any block @xmath729 and for any successive iteration @xmath730 , with @xmath721 , the test @xmath731 will be negative .",
    "moreover , if the test @xmath665 at line  21 is positive at some iteration @xmath719 , so that @xmath532 is removed from @xmath529 , then for all the blocks @xmath732 and @xmath733 such that @xmath729 and @xmath734 the test @xmath735 will be negative for all the iterations @xmath730 . as a further consequence ,",
    "since a splitting operation @xmath678 can be executed in @xmath736-time , it turns out that the overall cost of all the splitting operations is in @xmath737-time .",
    "furthermore , by using the data structures described by points  ( iii ) and  ( v ) in section  [ ds ] , the tests @xmath665 at line  21 and @xmath704 at line  23 can be executed in constant time . a careful analysis that exploits these key facts",
    "allows us to show that the total running time of @xmath29 is in @xmath6 .",
    "[ complexity ] the algorithm @xmath29 runs in @xmath6-time and @xmath738-space .",
    "let @xmath739 denote the sequence of iterations of the while - loop for some run of @xmath29 , where for any @xmath740 , @xmath722 means that @xmath506 follows @xmath505 .",
    "moreover , for any @xmath741 , @xmath724 denotes the block selected by the while - loop at line  4 , @xmath742 denotes the corresponding nonempty remove set , @xmath743 denotes the corresponding set for @xmath724 , while @xmath744 denotes the partition - relation pair at the entry point of the for - loop at line  19 .",
    "consider the set @xmath745[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\{b_i\\in p_i ~|~i\\in { \\mathit{it}}\\}$ ] of selected blocks and the following relation on @xmath746 : @xmath747 it turns out that @xmath748 is a poset .",
    "in fact , @xmath749 is trivially reflexive .",
    "also , @xmath749 is transitive : assume that @xmath750 and @xmath751 ; if @xmath752 then @xmath753 so that @xmath754 ; otherwise either @xmath755 or @xmath756 so that @xmath757 and therefore @xmath754 .",
    "finally , @xmath749 is antisymmetric : if @xmath750 and @xmath758 then @xmath759 and @xmath760 so that @xmath761 .",
    "moreover , @xmath762 denotes the corresponding strict order : this happens when either @xmath755 or @xmath763 and @xmath764 .",
    "the time complexity bound is shown incrementally by the following points .      *",
    "the overall time complexity of lines  11 - 17 is in @xmath6 .",
    "+ _ proof .",
    "_ figure  [ fi ] describes a c++ pseudocode implementation of lines 11 - 17 . by using the data structures described in section  [ ds ] , and in particular in figure  [ partitionfig ] , all the operations of the procedure @xmath820 take constant time so that any call @xmath821 takes @xmath822 time .",
    "let us now consider @xmath823 .",
    "* * the overall time complexity of the splitting operation at line  24 is in @xmath824 .",
    "each call @xmath825 takes @xmath826 time .",
    "then , analogously to the proof of point  ( d ) , the overall time complexity of line  24 is bounded by latexmath:[$\\sum_{i\\in { \\mathit{it } } } |\\operatorname{\\mathit{remove}}(b_i)| \\leq    * * the overall time complexity of the for - loop at lines  26 - 29 is in @xmath824 .",
    "it is only worth noticing that since the boolean matrix that stores @xmath531 is resizable , each operation at line  27 that adds a new entry to this resizable matrix has an amortized cost in @xmath828 : in fact , the resizable matrix is just a resizable array @xmath829 of resizable arrays so that when we add a new entry we need to add a new entry to @xmath829 and then a new entry to each array in @xmath829 ( cf .  point  ( v ) in section  [ ds ] ) .",
    "thus , the overall time complexity of line  26 is in @xmath830 . * * the overall time complexity of the for - loop at lines  30 - 31 is in @xmath830 . * * the overall time complexity of the for - loop at lines  32 - 35 is in @xmath48 .",
    "this is a consequence of the fact that the overall time complexity of the for - loops at lines  33 and  34 is in @xmath48 .",
    "+ thus , the overall time complexity of @xmath831 is in @xmath6 . *",
    "the overall time complexity of lines  19 - 21 is in @xmath6 .",
    "+ _ proof .",
    "_ for any @xmath832 , let @xmath833[1ex]{$\\:\\stackrel{{\\scriptscriptstyle \\mathrm{def}}}{=}\\:$}}}\\sum_{x\\in b_i }          summing up , we have shown that the overall time - complexity of @xmath29 is in @xmath6 .",
    "the space complexity is in @xmath892 to the block of the current partition that contains @xmath22 are stored in @xmath893 space . *",
    "the current partition @xmath46 is stored in @xmath828 space .",
    "* the current relation @xmath531 is stored in @xmath830 space .",
    "* each block of the current partition stores the corresponding remove set in @xmath894 space and the integer array @xmath701 in @xmath895 , so that these globally take @xmath896 space .",
    "@xmath897$](partitionrelation p ) forall b in p do b.remove = @xmath898(@xmath226c in p | rel(b , c ) ) ; forall x in @xmath0 do b.relcount(x ) = 0 ; forall b in p do forall y in b do forall x in @xmath275(y ) do forall c in p such that rel(c , b ) do c.relcount(x)++ ;    @xmath29(partitionrelation p ) @xmath897$](p ) ; forall b in p such that ( b.remove @xmath899 ) do set remove = b.remove ; b.remove = @xmath771 ; set b@xmath808 $ ] = b ; @xmath807$](p , remove ) ; listofblocks removelist = d @xmath811 p",
    "| d @xmath900 remove ; forall c in p such that ( c @xmath901 @xmath275(b@xmath808 $ ] ) @xmath899 ) do forall d in removelist do if ( rel(c , d ) ) then rel(c , d ) = 0 ; forall d in d do forall x in @xmath275(d ) do c.relcount(x) ; if ( c.relcount(x ) = = 0 ) then c.remove = c.remove @xmath226 x ; p.moveattheend(c ) ;",
    "a pseudocode implementation of the algorithm @xmath29 that shows how the data structures in section  [ ds ] are actually used is in figure  [ fig : sim ] , where @xmath823 has been introduced above in figure  [ fi ] .",
    "we implemented in c++ both our simulation algorithm @xmath29 and the @xmath43 algorithm in order to experimentally compare the time and space performances of @xmath29 and @xmath43 . in order to make the comparison as meaningful as possible ,",
    "these two c++ implementations use the same data structures for storing transitions systems , sets of states and tables .",
    "our benchmarks include systems from the vlts ( very large transition systems ) benchmark suite  @xcite and some publicly available esterel programs .",
    "these models are represented as labeled transition systems ( ltss ) where labels are attached to transitions . since the versions of @xmath29 and @xmath43 considered in this paper both need as input a kripke structure , namely a transition system where labels are attached to states , we exploited a procedure by dovier et al .",
    "@xcite that transforms a lts @xmath902 into a kripke structure @xmath903 in such a way that bisimulation and simulation equivalences on @xmath902 and @xmath903 coincide .",
    "this transformation acts as follows : any labeled transition @xmath904 is replaced by two unlabeled transitions @xmath905 and @xmath906 , where @xmath907 is a new node that is labeled with @xmath908 , while all the original states in @xmath902 have the same label .",
    "this labeling provides an initial partition on @xmath903 which is denoted by @xmath725 . hence , this transformation grows the size of the model as follows : the number of transitions is doubled and the number of states of @xmath903 is the sum of the number of states and transitions of @xmath902 . also , the models cwi_3_14 , vasy_5_9 , vasy_25_25 and vasy_8_38 have non total transition relations .",
    "the vasy _ and cwi _ systems are taken from the vlts suite , while the remaining systems are the following esterel programs : wristwatch and shockdance are taken from the programming examples of esterel  @xcite , obsarbitrer4 and atleastoneack4 are described in the technical report  @xcite , lift , noackwithoutreq and one_pump are provided together with the fc2symbmin tool that is used by xeve , a graphical verification environment for esterel programs  @xcite .",
    "our experimental evaluation was carried out on an intel core 2 duo 1.86 ghz pc , with 2 gb ram , running linux and gnu g++ 4 .",
    "the results are summarised in table  [ results ] , where we list the name of the transition system , the number of states and transitions of the transformed transition system , the number of blocks of the initial partition , the number of blocks of the final simulation equivalence partition ( that is known when one algorithm terminates ) , the execution time in seconds and the allocated memory in mb ( this has been obtained by means of glibc - memusage ) both for @xmath43 and @xmath29 , where o.o.m .  means that the algorithm ran out of memory ( 2 gb ) .",
    "the comparative experimental evaluation shows that @xmath29 outperforms @xmath43 both in time and in space .",
    "in fact , the experiments demonstrate that @xmath29 improves on @xmath43 of about two orders of magnitude in time and of one order of magnitude in space .",
    "the sum of time and space measures on the eight models where both @xmath43 and @xmath29 terminate is 64.555 vs.1.39 seconds in time and 681.303 vs.  52.102 mb in space .",
    "our experiments considered 18 models : @xmath43 terminates on 8 models while @xmath29 terminates on 14 of these 18 models . also , the size of models ( states plus transitions ) where @xmath29 terminates w.r.t.@xmath43 grows about one order of magnitude .",
    ".results of the experimental evaluation . [ cols=\"<,<,<,<,<,<,<,<,<\",options=\"header \" , ]",
    "we presented a new efficient algorithm for computing the simulation preorder in @xmath6-time and @xmath7-space , where @xmath2 is the partition induced by simulation equivalence on some kripke structure @xmath400 .",
    "this improves the best available time bound @xmath3 given by henzinger , henzinger and kopke s  @xcite and by bloom and paige s  @xcite simulation algorithms that however suffer from a space complexity that is bounded from below by @xmath20 .",
    "a better space bound is given by gentilini et al.s  @xcite algorithm    subsequently corrected by van glabbeek and ploeger  @xcite    whose space complexity is in @xmath909 cav _ , lncs  1427 , pp .",
    "500 - 504 , 1998 .",
    "r.  cleaveland and o.  sokolsky .",
    "equivalence and preorder checking for finite - state systems . in j.a .",
    "bergstra , a.  ponse , s.a .",
    "smolka eds . , _ handbook of process algebra _ , north - holland , pp .",
    "391 - 424 , 2001 .",
    "p.  cousot and r.  cousot .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _ proc .",
    "4@xmath910 acm popl _ , pp .",
    "238252 , 1977 ."
  ],
  "abstract_text": [
    "<S> a number of algorithms for computing the simulation preorder are available . </S>",
    "<S> let @xmath0 denote the state space , @xmath1 the transition relation and @xmath2 the partition of @xmath0 induced by simulation equivalence . </S>",
    "<S> the algorithms by henzinger , henzinger , kopke and by bloom and paige run in @xmath3-time and , as far as time - complexity is concerned , they are the best available algorithms </S>",
    "<S> . however , these algorithms have the drawback of a space complexity that is more than quadratic in the size of the state space . </S>",
    "<S> the algorithm by gentilini , piazza , policriti    subsequently corrected by van glabbeek and ploeger    appears to provide the best compromise between time and space complexity . </S>",
    "<S> gentilini et al.s algorithm runs in @xmath4-time while the space complexity is in @xmath5 . </S>",
    "<S> we present here a new efficient simulation algorithm that is obtained as a modification of henzinger et al.s algorithm and whose correctness is based on some techniques used in applications of abstract interpretation to model checking . </S>",
    "<S> our algorithm runs in @xmath6-time and @xmath7-space . </S>",
    "<S> thus , this algorithm improves the best known time bound while retaining an acceptable space complexity that is in general less than quadratic in the size of the state space . </S>",
    "<S> an experimental evaluation showed good comparative results with respect to henzinger , henzinger and kopke s algorithm . </S>"
  ]
}