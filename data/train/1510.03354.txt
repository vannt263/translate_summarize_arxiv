{
  "article_text": [
    "with the emergence of commodity multicore architectures , exploiting tightly - coupled parallelism has become increasingly important .",
    "most of the parallelization efforts are addressed to applications that compute with large amounts of data in memory and in general have a regular behavior .",
    "frameworks that implements mapreduce are a great success .",
    "a huge amount of papers show the willingness of using this program schema to solve problems .",
    "one can say that having a framewok , helps in testing the goodness of the solution but also because implementations deal with errors and the programmer need not take care of the deployment in parallel architectures is also done by the implementation .    in the scenario of tiny artifacts , interactive / reactive applications , big graphs , do not deal with huge amounts of data in memory , but streams of data .",
    "but still can exploit several cores and even distributed architectures .",
    "the rest of the paper is organized as follows . in the next section ,",
    "we provide a brief background about the typical strategy used to count triangles and a summary of the previous work that is most related to our paper .",
    "section [ informal ] provides an informal description of our algorithm using a nimo implementation .",
    "section [ formal ] presents the algorithms and the proof of correctness .",
    "we conclude in section [ cr ]",
    "very recently , a parallel algorithm for triangle counting using mapreduce framework @xcite has been proposed .",
    "their algorithm is exact and do not require to keep the entire input graph in memory at each individual machine .",
    "we describe this algorithm in [ ctmapreduce ] .    a divide an conquer approach to the problem",
    "is given in @xcite , using the bsp model to synchronize the parallel workers and mpi to implement the algorithm .",
    "a collection of subgraphs , of size equal to the number of processors , of the given graph are constructed and due to the collection construction , triangles are counted by counting on each subgraph and accumulate the result .",
    "the improvement over @xcite is due to the fact that their algorithm generates a huge volume of intermediate data , which are all possible 2-paths centered at each node .",
    "our improvement over @xcite is that we do not collect in a single machine all the adjacent nodes to a core node ( responsible node ) , but only those that are not been collected by some other responsible node .",
    "also they need to do preconditioning in order to balance work load .",
    "our dynamic scheduler is able to balance work load based on the size of the neighbors of each responsible node .",
    "in @xcite we can find a good surveys on algorithms based on the streaming model of computation .    in the semi - streaming model of computation ,",
    "the input graph , g = ( v , e ) , is presented as a stream of edges ( in any order ) , and the storage space of an algorithm is bounded by @xmath0 .",
    "we are particularly interested in algorithms that use only one pass over the input , but , for problems where this is provably insufficient , we also look at algorithms using constant or , in some cases , logarithmically many passes .",
    "mapreduce can be described as a two face algorithm : first the set of input values are tansformed element by element into another set using the _ map _ operator , preserving o not the cardinality of the set . in the second phase",
    ", this newly generated set is partitioned into equivalence classes that are to be reduced using the _ reduce _ operation .",
    "for example , for multiplying two matrices , the set of values @xmath1 is generated in some order and then collect in the same class all the values with the same @xmath2 . each equivalence class is reduced by adding all the elements in the class . in this case",
    "the communication cost is @xmath3 .",
    "there are several sequential algorithms for counting the number of triangles in a graph .",
    "if the graph is described as a matrix , there is a very simple algorithm :    @xmath4 ;    for @xmath5 do    for @xmath6 do    for @xmath7 do    if @xmath8 then    @xmath9 ;    @xmath10 ;    as seen in the algorithm each triangle is counted six times .",
    "this algorithm assumes that the graph fits in memory , but for most problems the matrix describing the graph is sparse or do not fit in memory .",
    "in @xcite they present a composition of two mapreduce algorithms . in the application of mapreduce it geneartes the set of 2-path , having a given responsible node .",
    "he adds up the edges present in the graph and the 2-path described by their end nodes and cluster the elements using the pair of nodes as key .",
    "if both types of elements are present in the same cluster , the number of triangles is equal the cluster size minus one .",
    "otherwise the number of triangles in the cluster is zero . adding the number of triangles in each cluster gives the total number of triangles in the graph .    *",
    "round 1 : generate the possible 2-paths in the graph .",
    "the reduce step collects pairs of edges having a common node .",
    "* round 2 : check which of the the 2-paths generated in round 1 can be closed by an edge in the graph and count the triangles accordingly .",
    "as all the mapreduce algorithms , a hashing function is used to cluster elements that are to be treated by a single reducer .",
    "it is usual that the number of reducers coincides with the number of available processors .",
    "so the behavior is not smooth in he number of processors .",
    "if the solution needs to be optimized , a more specific hashing function will be required , depending on the key structures .",
    "algorithms having several rounds use the same hashing function no matter that the key domain can change . in section",
    "[ informal ] we will informally present a pipeline algorithm for solving the triangle counting problem .",
    "we will use the nimo language to describe the algorithm because nimo has the ability of dynamically generating programs and also because we can analyze the program execution behavior as we will see in sec .",
    "[ informal ] . in sect .",
    "[ language ] a small language description is given in order to be able to follow the algorithm .",
    "[ language ]    nimo ( * * n**ets * * i**n * * mo**tion ) is a graphic - functional - data flow language designed to visualize computer systems and their execution in an understandable way .",
    "this visualization ( edition and/or execution ) helps to understand where and when resources are used in the program , thus giving clues to optimize solutions .",
    "the language is very simple and is addressed to programmers ( domain knowledge experts - dke ) and is platform independent .",
    "the language is design to be simple : no variables and therefore no declarations .",
    "but strongly typed .",
    "the only element is the program , which is a net of processes communicating using fifo channels of unbounded capacity .",
    "this boxes have input and output typed ports .",
    "the dke deals only with data and processes dependency , which is described using a data flow graph .",
    "this graph can have nodes having different degrees of granularity ( basic processes ( atomic ) , processes that have a net as definition , black box processes ) .",
    "there are no parallelization constructs in the language . at run time",
    "the schedulers are in charge of assigning processors to processes .",
    "the execution model is an asynchronous version of the bsp model@xcite allowing communication and execution taking place at the same time without race conditions .    for testing algorithms",
    ", there is a ide called nimotoons , that assumes an unbounded number of processors .",
    "the system gives the function plot showing the available parallelism at each execution step in fine grain parallelism .",
    "this gives an upper bound on obtainable parallelism for the given solution .",
    "once certified the solution , if necessary , an expert on code parallelization can tune the code to assist schedulers in their task of assigning processes to processors .",
    "the solution need not to be changed , only tunned by defining an scheduler for it .",
    "as the language inherits from functional programming , and processes are first class citizens ( can be manipulated , created and destroyed as any other data element ) , problems with low natural parallel ( imperative or functional ) solutions , can be solved in different approaches , using dynamic data structures .",
    "this allows a systematic way of generating dynamically communication paths .",
    "another characteristic derived from the combination of data flow and functional programming is the ability to do concurrently processing and communication using pipeline parallelism .",
    "the characteristic of the language is that allows to see and analyze data flow in a system at different levels of granularity and also as a workbench for designing high tunned problem solutions .",
    "another characteristic is that the programs are deterministic unless non - deterministic constructs are used @xcite .",
    "a nimo programmer need not to be aware of the number of processor that will be used in running the program . a dynamic scheduler for executing transformations on a nimo program scales up to the number of available processors .    rather than a series of imperative commands sequentially executed , a dataflow program is more like a network of workers in an assembly line who do their work to the extent that they have the necessary material .",
    "but unlike a worker , processes can receive several inputs and provide several outputs .",
    "in particular , workers in nimo have different attitudes toward work , allowing a better division of labor .",
    "a worker can awake other workers in order to complete his task .",
    "nimo , having very few constructs , is not a visual interpreter for a textual language because there is no textual code at all .",
    "it is a true graphical programming language .",
    "programs are process networks ( pn ) according to @xcite or operator nets as in @xcite . unlike operator nets , nimo nets deal with partial operators , allowing processes to be blocked on erroneous inputs .",
    "the program exploits the bi - dimensional description to express data dependency and color to describe modes and states .",
    "the two - dimensional display eliminates the need for operator precedence .",
    "processes can be specialized by parameters on the top .",
    "processes communicate through unbound capacity channels , acting as fifo queues that carry references any type of value from basic nimo types : integers , reals , booleans , processes . but also references to structured types as lists or tuples .",
    "fifo queues can also carry references to expressions , implementing _",
    "it has additional characteristics as wait by necessity , also called blocking read , no explicit put or get operations and value sharing . programs in execution fully exhibit their state .",
    "ready processes act concurrently assuring no data races .",
    "nimo programs are strong typed , but the language does not have type declarations .",
    "processes may be polymorphic , higher oder and have multiple outputs .",
    "the language has a set of primitive processes well suited for stream processing and supports executing programs and interactive debugging .",
    "the system provides an also graphical and incremental type inference system that guarantees program type - safeness by construction .",
    "a more complete description can be found in @xcite .",
    "some program examples can be seen in @xcite .",
    "fine grain concurrency is supported by independent computation and by the language construct : pipelining .",
    "nimo systems can be deployed in a distributed architecture .",
    "we will use the notation used in @xcite , because although galois is an extension of @xmath11 , shares a set of concepts with nimo .",
    "one measure of amorphous data - parallelism is the number of active nodes ( fireable processes ) that can be processed in parallel at each step of the algorithm for a given input , assuming that :    * there is an unbounded number of processors , * an activity takes one time step to execute , * the system has perfect knowledge of neighborhood and ordering constraints so it only executes activities that can complete successfully , and * a maximal set of activities , subject to neighborhood and ordering constraints , is executed at each step .",
    "this is called the available parallelism at each step , and a function plot showing the available parallelism at each step of execution of an irregular algorithm for a given input is called a _",
    "parallelism profile_.      we assume the input is a large graph given by the enumeration of its edges .",
    "we assume a non oriented graph and there are no duplicated edges .",
    "the general idea of the two round schema we use is identical to the node - iterator schema used by @xcite .",
    "the main difference is the way the possible 2-two path are identified and the program structure .",
    "we use the same principle of a single node is  responsible \" for making sure the triangle gets counted . in @xcite",
    "this is obtained via the knowledge of the degree of each node . dealing with graphs large enough that do not fit in memory",
    ", this additional knowledge requires an additional traversal on the edges of the graph which is not needed in our approach .",
    "the algorithm we present is implemented in nimo as a sequence of actors ( processes ) that will change their role ( mutate its behavior ) when enough knowledge has been collected .",
    "our actors first role is to acquire an edge and become a process that is `` responsible '' for this first node in the edge .",
    "the responsible actor receiving an edge will collect in his memory all the nodes , not being collected by another responsible , adjacent to the``responsible '' node .",
    "other edges , not adjacent to the responsible node , are passed to his neighbor . when there are no more edges in the first input , each actor changes again his role , receiving again the sequence of edges and counting a triangle , whenever the edge forms a triangle with the `` responsible '' node and two adjacent ones .",
    "whenever all the edges are analyzed , the process passes its triangle count to its neighbor and dies .",
    "we will use a small graph to show the algorithm behavior in this case .                in fig .",
    "[ data ] we see the nimo graph representation .",
    "is represented as a sequence of pairs ( 2-tuples ) ending by an end of sequence symbol : .",
    "the sequence represents the graph in fig .",
    "[ graph ] .",
    "the algorithm starts with a program that generates a composition of @xmath12 actors / processes , called _ pick - a - responsible _ , having the same role .",
    "they are represented by penguins .",
    "the process name and icon are chosen arbitrarily .",
    "they shake 3 hands with each neighbor as can be see in fig .",
    "[ pick ] . the graph , described as a sequence of edges , flows through the first hand .",
    "the algorithm will be described in two rounds : each round reads the sequence of edges describing the graph .",
    "* round 1 : whenever _ pick - a - responsible_/penguin receives an edge @xmath13 changes its role becoming _ collect - adjacent_/lion process having as parameters a responsible node @xmath14 and a list of adjacent nodes , with only one element @xmath15 .",
    "_ collect - adjacent _ processes are represented by lions .",
    "the icon used for processes serves to find on the screen when several instances of the same process is present during a computation and easily identifying processes without reading its name .",
    "+ in figure fig [ stage0.1 ] we see the program execution , where _",
    "collect - adjacent _ has collected 2 adjacent node for the responsible node 2 .",
    "+    + if there are no more edges , _ pick - a - responsible_/penguin exits .",
    "+ therefore _ pick - a - responsible_/penguin is present only in the first round and is changed by another process or fades away whenever a single input shows in its input parameter .",
    "+ the role of _ collect - adjacent_/lion , having as responsible node @xmath14 , is to receive the edges , one after the other and when receiving an edge @xmath16 , pass it to the left neighbor if @xmath17 .",
    "otherwise it adds to the set of adjacent nodes the node which is not equal to @xmath14 .",
    "+ in figure fig .",
    "[ stage1 ] the _ collect - adjacent_/lion process for responsible node 2 is to receive an end .",
    "the _ collect - adjacent_/lion process for responsible node 3 has collected only one adjacent node .",
    "+ when _ collect - adjacent_/lion receives an end i.e. there are no more edges , it mutates its behavior into the role of _ count - triangles_/toucan and sends an end to his neighbor using his firsthand . before mutating _",
    "collect - adjacent_/lion has collected a subset of the edges adjacent to the responsible node . +    +",
    "_ count - triangles_/toucan will keep the responsible node and all its adjacent ones collected by the corresponding _ collect - adjacent_/lion actor and record that no triangles showed up so far as shown in fig .",
    "[ stage2 ] having a third parameter set to @xmath18 .",
    "the actors will have only two hands to shake with its neighbors : one hand to deal with the graph and the second hand to propagate the local triangle count .",
    "+ in figure fig : [ stage2 ] we see the process _ count - triangles_/toucan prepared to count triangles that include the resposible node ( 2 ) . * round 2 : _ count - triangles_/toucan receives an edge and checks if both ends are adjacent to the responsible node .",
    "if so , it adds one to number of triangles found . in any case the edge is passed to its left neighbor ( produced on its output ) , using its first hand .",
    "+ if _ count - triangles_/toucan receives the signal that there are no more edges , it passes on its first hand the signal that there are no more edges and it passes its count to the left neighbor added to the input in his second hand , using its second hand and dies .        in fig .",
    "[ stage0.0 ] we see that the penguin is about to transform node 5 into a responsible node . as we can see there are three diffent animals in the picture , showing that nimo evaluation model , implements bsp without barriers i.e. communication and execution can take place at the same time .        in fig",
    "[ stage2.1 ] the toucan has already found a triangle .",
    "the given graph is denoted by @xmath19 , where @xmath20 and @xmath21 are the sets of vertices ( nodes ) and edges , respectively , with @xmath22 edges and @xmath23 vertices labeled , label that can be compared by equality .",
    "we use the words node and vertex interchangeably .",
    "we assume that the input graph is undirected , without loops or multiple edges . if @xmath24 , we say @xmath25 and @xmath26 are neighbors of each other .",
    "the set of all neighbors of @xmath27 is denoted by @xmath28 , i.e. , @xmath29 .",
    "a triangle is a set of three nodes @xmath30 such that there is an edge between each pair of these three nodes , i.e. , @xmath31 .",
    "the number of triangles containing node v ( in other words , triangles incident on v ) is denoted by @xmath32 .",
    "notice that the number of triangles containing node @xmath26 is as same as the number of edges among the neighbors of @xmath26 , i.e. , @xmath33 .",
    "the algorithm for counting triangles is design using two rounds i.e. reading twice the graph .",
    "the first round collects adjacent nodes to a `` responsible '' node that can become part of a triangle that includes the responsible node .",
    "nimo implements bounded and unbounded minimization @xcite as a program schema .",
    "this schema is generalized to allow processes having multiple outputs .",
    "this schema , having sequences as input and the process being composed can be applied element by element , allows to describe computations that can exploit pipeline parallelism .",
    "the program is implemented as a fixed point solution of the composition of _ pick - a - responsible_/penguin processes that will produce a sequence of integers counting the number of tiangles found fo each `` responsible '' node .",
    "_ pick - a - responsible_/penguin is the process obtained from the _ combination _ , denoted by @xmath34 , of three processes : the first acting on the first port and the other two the blocking process acting on the second and third inputs .",
    "@xmath35    _ collectadjacent_/lion is a pocess obtained as the combination of three process as _ pick - a - responsible_.    @xmath36    _ count - triangles _ is a process , obtained from the transformation of _ collectadjacent _ , loosing its first input .",
    "the second input serves only to tie together the individual results .",
    "@xmath37    the auxiliary function @xmath38 is used to simulate a function that do not consume its input and is used to describe that _ pick - a - responsible_/penguin does not consume inputs on the second and third inputs .",
    "same happens with _ collectadjacent _ process .    @xmath39    @xmath40 ) ( m )   & \\quad",
    "\\text{if } c = ( a , b ) : m\\\\      eof & \\quad \\text{if }    c= eof\\\\    \\end{cases}\\ ] ]    @xmath41 ) \\times f \\times f)(u , x , y )   & \\quad \\text{if } c = ( m , n ) : u\\and \\\\                                          &   \\quad ( m = r   \\lor n = r )   \\ s \\neq r\\\\                                          & \\quad ( s = m \\lor s = n)\\\\      ( c : f_2 ( r , ad )   \\times f \\times f ) ( u , x , y )   & \\quad \\text{if } c = ( m , n ) : u \\and   \\\\                                                  & \\quad ( m\\neq r   \\land   n \\neq",
    "( f_3(r , ad,0 )   \\times f ) ( x , y ) & \\quad \\text{if }    c= eof\\\\    \\end{cases}\\ ] ]    @xmath42 in round 1 , the program is a sequence / composition of _ pick - a - responsible _ processes transformed , due to the information collected from the incoming edges into a sequence of _ collect - adjacent _ processes , with edges flowing on the first hand .",
    "the leftmost _ collect - adjacent _ process has the first output hand not bound .",
    "no edge will arrive to this port .",
    "the initial program is a sequence of _ pick - a - responsible _ processes has length @xmath12 .",
    "the total number of responsible nodes is bound by @xmath43 .",
    "therefore , every edge will be consumed by either a _ pick - a - responsible _ process or by a _",
    "collect - adjacent _ process therefore no edge will show at the leftmost process .",
    "every edge in the graph is encoded by exactly one _ collect - adjacent _ process .",
    "if an edge @xmath13 shows up in the first input of a _ pick - a - responsible _ process , it means that neither @xmath14 nor @xmath15 where chosen as responsible nodes yet .",
    "so @xmath14 becomes a responsible node and the edge is recorded in the corresponding _ collect - adjacent _ process and not passed to the neighbor .",
    "the only thing to prove is that there are enough _ pick - a - responsible _ processes to become _ collect - adjacent _ processes .",
    "but the number of possible _ pick - a - responsible _ processes is bounded by @xmath12 by construction .",
    "if an edge @xmath13 shows up in the first input of a _ collect - adjacent _ processes having as responsible @xmath14 or @xmath15 , will be encoded by the process .",
    "otherwise the edge will be passes to the neighbor process .",
    "when starting to count triangles , every 2-path that forms a triangle ( closed wedge according to @xcite ) is encoded in exactly one filter : the actor that holds it has a responsible node which is the path middle node .    if there is a triangle in the graph we need to show that one and only one of its path of length two is recorded in some filter .",
    "each filter @xmath44 encodes paths @xmath45 with @xmath46 .",
    "if there is a triangle , it includes three 2-paths .",
    "as edges are consumed by filters , edges are present in at most one filter .",
    "if there is a triangle that includes nodes @xmath47 , lets assume that the first edge of the triangle that shows up in the enumeration of edges is the edge @xmath13 .",
    "this edge is recorded by some process having @xmath14 or @xmath15 as responsible .",
    "lets assume @xmath14 is the responsible node .",
    "there are four possible subsequences that represent the given triangle :    1 .",
    "@xmath48 2 .",
    "@xmath49 3 .",
    "@xmath50 4 .",
    "@xmath51    in any case , edge @xmath52 is sent to other filter and this filter keeps the edge ( @xmath53 .",
    "so no more 2-path of the triangle can be retained by any other filter because two edges are already retained by the filter that has @xmath14 as responsible .    in round 2 , data flows in the first hand , until all the input is consumed and then the second hand collects all the locally counted triangles .",
    "the final result is a sequences of integers , each integer counting the number of triangles including a responsible node .",
    "adding up this sequence gives the desired result .",
    "in @xcite signal out the problem of estimating triangles when the graph is not simple .",
    "they show that approximate algorithms does not behave the same as the graph is not simple and its size increases .",
    "they mention that for eliminating duplicated edges requires an additional pass over the edges . due to the structure of our algorithm ,",
    "duplicates can be eliminated by replacing the operation of prefixing the newly arrived node in the _ collectadjacent _ processes by an union operation on sets .",
    "if instead , we want to count the number of triangles , even if they a repeated ones , instead of adding to a set , the operation will be adding the newly arrived to the multiset i.e. the set remembers the number of times the edge has appeared .",
    "when counting triangles , a closing edge , closes as many triangles as the minimum of the multiplicity of their endpoints .",
    "the algorithm modularity allows to replace processes to easily adapt the algorithm to other input characteristics .",
    "the algorithm assumes that there is enough memory in each processor to hold the nodes adjacent to the responsible node .",
    "if it is not the case , this set can be stored in another memory .",
    "also , if necessary to speed up the process , this adjacent nodes can be stored in a hash table .",
    "this change amounts to change the _ close ?",
    "_ process to verify the condition on a pair of hash tables , instead of operating with a pair of node lists . in case of error ,",
    "a similar schema can be followed .",
    "changing channels by processes that can retry reading in case of processors unable to complete the processing of a particular edge .",
    "introduced by gilles kahn , the kahn process networks approached this problem by having sequential processes ( nodes ) to communicate via unbounded fifo queues as message passing protocol@xcite .",
    "difference between kahn processes networks and nimo programs , is that nimo processes need not to be sequential .",
    "nimo processes have different granularities : black boxes written in another language or nimo nets written in nimo .    in @xcite the swift / t",
    "language is described .",
    "is a language implementing the `` implicitly parallel functional dataflow '' ( ipfd ) model centered mainly in being able to have as input a variety of data sources .",
    "the programming model is very simple and forces the user to think on in - memory data .",
    "the language has the ability of integrating leaf tasks written in other languages . using this feature",
    "has proven very effective in implementing solutions in several domains .",
    "but the simplicity of the language does not allow some solutions that fully exploit architectures with a massive number of processors .",
    "the promote many - task computing .",
    "swift does 4 important things for you :    1 .   makes parallelism more transparent + implicitly parallel functional dataflow programming 2 .",
    "makes computing location more transparent + runs your script on multiple distributed sites and diverse computing resources ( desktop to petascale ) 3 .   makes basic failure recovery transparent retries / relocates failing tasks can restart failing runs from point of failure 4 .",
    "records provenance of data derivation made possible through functional encapsulation    the mechanism used is the instruction forall that spawns processes for each body in the iteration . in dependent iterations",
    "it does not give a high level of parallelism .",
    "nimo has the _ map _ process and recursion as mechanisms for spawning new processes required by the program execution .",
    "we have used counting triangles problem on a graph described as a sequence of edges as a nimo programming example . in the example",
    "we see that a big amount of processors can be exploited , but the algorithm is correct even in a single processor semantics .",
    "the solution exhibits nimo characteristics as the generation of a pipe of processes that simulate the well known bucket sorting method that separates the input set into disjoint classes .",
    "processes in the pipe , change behavior as soon as enough data has been consumed .",
    "nimo uses a bsp model of computation without barriers .",
    "therefore the algorithm presented here has in some sense wavefront behavior when executed as bsp without barriers .",
    "shaikh arifuzzaman , maleq khan , and madhav marathe .",
    "patric : a parallel algorithm for counting triangles in massive networks . in _ proceedings of the 22nd",
    "acm international conference on conference on information & # 38 ; knowledge management _ , cikm 13 , pages 529538 , new york , ny , usa , 2013 .",
    "e.  ashcroft .",
    "dataflow and eduction : data - driven and demand - driven distributed computation . in j.  de  bakker , w.  de  roever , and g.  rozenberg , editors , _ current trends in concurrency _ , volume 224 of _ lecture notes in computer science _ , pages 150 .",
    "springer berlin / heidelberg , 1986 .",
    "10.1007/bfb0027039 .",
    "robert  l. bocchino , jr .",
    ", vikram  s. adve , sarita  v. adve , and marc snir .",
    "parallel programming must be deterministic by default . in _",
    "proceedings of the first usenix conference on hot topics in parallelism _ , hotpar09 , pages 44 , berkeley , ca , usa , 2009 .",
    "usenix association .",
    "oconnell . a survey of graph algorithms under extended streaming models of computation . in s.s .",
    "ravi and sandeepk .",
    "shukla , editors , _ fundamental problems in computing _ , pages 455476 . springer netherlands .",
    "siddharth suri and sergei vassilvitskii .",
    "counting triangles and the curse of the last reducer . in _ proceedings of the 20th international conference on world wide web _ , www 11 , pages 607614 , new york , ny , usa , 2011 ."
  ],
  "abstract_text": [
    "<S> the generalized method to have a parallel solution to a computational problem , is to find a way to use _ divide & conquer _ paradigm in order to have processors acting on its own data and therefore all can be scheduled in parallel . </S>",
    "<S> mapreduce is an example of this approach : input data is transformed by the mappers , in order to feed the reducers that can run in parallel . in general </S>",
    "<S> this schema gives efficient problem solutions , but it stops being true when the replication factor grows . </S>",
    "<S> we present another program schema that is useful for describing problem solutions , that can exploit dynamic pipeline parallelism without having to deal with replication factors . </S>",
    "<S> we present the schema in an example : counting triangles in graphs , in particular when the graph do not fit in memory . </S>",
    "<S> we describe the solution in nimo , a graphical programming language that implements the _ implicitly functional parallel dataflow _ model of computation .    </S>",
    "<S> the solution obtained using nimo , is architecture agnostic and can be deployed in any parallel / distributed architecture adapting dynamically the processor usage to input characteristics .    </S>",
    "<S> * keywords : * pipelining , triangle - counting , parallel algorithms </S>"
  ]
}