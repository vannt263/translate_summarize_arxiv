{
  "article_text": [
    "an auto - encoder is a conceptually simple neural network used for obtaining useful data representations through unsupervised training .",
    "it is composed of an encoder which outputs a hidden ( or latent ) representation and a decoder which attempts to reconstruct the input using the hidden representation as its input .",
    "training consists of minimizing a reconstruction cost such as @xmath0 error .",
    "however this cost is merely a proxy for the true objective : to obtain a useful latent representation .",
    "auto - encoders can implement many dimensionality reduction techniques such as pca and sparse coding ( sc ) @xcite@xcite@xcite .",
    "this makes the study of auto - encoders very appealing from a theoretical standpoint . in recent years ,",
    "renewed interest in auto - encoders networks has mainly been due to their empirical success in unsupervised feature learning @xcite@xcite@xcite@xcite .",
    "+ when minimizing only reconstruction cost , the standard auto - encoder does not typically learn any meaningful hidden representation of the data .",
    "well known theoretical and experimental results show that a linear auto - encoder with trainable encoding and decoding matrices , @xmath1 and @xmath2 respectively , learns the identity function if @xmath1 and @xmath2 are full rank or over - complete .",
    "the linear auto - encoder learns the principle variance directions ( pca ) if @xmath1 and @xmath2 are rank deficient @xcite .",
    "it has been observed that other representations can be obtained by regularizing the latent representation .",
    "this approach is exemplified by the contractive and sparse auto - encoders @xcite @xcite @xcite .",
    "intuitively , an auto - encoder with limited capacity will focus its resources on reconstructing portions of the input space in which data samples occur most frequently . from an energy based perspective ,",
    "auto - encoders achieve low reconstruction cost in portions of the input space with high data density ( recently , @xcite has examined this perspective in depth ) .",
    "if the data occupies some low dimensional manifold in the higher dimensional input space then minimizing reconstruction error achieves low energy on this manifold .",
    "useful latent state regularizers raise the energy of points that do not lie on the manifold , thus playing an analogous role to minimizing the partition function in maximum likelihood models . in this work",
    "we introduce a new type of regularizer that does this explicitly for auto - encoders with a non - linearity that contains at least one flat ( zero gradient ) region .",
    "we show examples where this regularizer and the choice of nonlinearity determine the feature set that is learned by the auto - encoder .",
    "several auto - encoder variants which regularize their latent states have been proposed , they include the sparse auto - encoder and the contractive auto - encoder@xcite@xcite@xcite .",
    "the sparse auto - encoder includes an over - complete basis in the encoder and imposes a sparsity inducing ( usually @xmath3 ) penalty on the hidden activations .",
    "this penalty prevents the auto - encoder from learning to reconstruct all possible points in the input space and focuses the expressive power of the auto - encoder on representing the data - manifold .",
    "similarly , the contractive auto - encoder avoids trivial solutions by introducing an auxiliary penalty which measures the square frobenius norm of the jacobian of the latent representation with respect to the inputs .",
    "this encourages a constant latent representation except around training samples where it is counteracted by the reconstruction term .",
    "it has been noted in @xcite that these two approaches are strongly related .",
    "the contractive auto - encoder explicitly encourages small entries in the jacobian , whereas the sparse auto - encoder is encouraged to produce mostly zero ( sparse ) activations which can be designed to correspond to mostly flat regions of the nonlinearity , thus also yielding small entries in the jacobian .",
    "our goal is to introduce a simple new regularizer which explicitly raises reconstruction error for inputs not near the data manifold .",
    "consider activation functions with at least one flat region ; these include shrink , rectified linear , and saturated linear ( figure  [ fig : nonlin ] ) .",
    "auto - encoders with such nonlinearities lose their ability to accurately reconstruct inputs which produce activations in the zero - gradient regions of their activation functions .",
    "let us denote the auto - encoding function @xmath4 , @xmath5 being the input , @xmath6 the trainable parameters in the auto - encoder , and @xmath7 the reconstruction .",
    "one can define an energy surface through the reconstruction error : @xmath8 let s imagine that @xmath9 has been trained to produce a low reconstruction error at a particular data point @xmath10 . if @xmath9 is constant when @xmath5 varies along a particular direction @xmath11 , then the energy will grow quadratically along that particular direction as @xmath5 moves away from @xmath10 .",
    "if @xmath9 is trained to produce low reconstruction errors on a set of samples while being subject to a regularizer that tries to make it constant in as many directions as possible , then the reconstruction energy will act as a _ contrast function _ that will take low values around areas of high data density and larger values everywhere else ( similarly to a negative log likelihood function for a density estimator ) .",
    "the proposed auto - encoder is a simple implementation of this idea . using the notation @xmath12 ,",
    "the auto - encoder function is defined as @xmath13 where @xmath1 , @xmath14 , @xmath2 , and @xmath15 are the encoding matrix , encoding bias , decoding matrix , and decoding bias , respectively , and @xmath16 is the vector function that applies the scalar function @xmath17 to each of its components .",
    "@xmath17 will be designed to have `` flat spots '' , i.e. regions where the derivative is zero ( also referred to as the saturation region ) .",
    "the loss function minimized by training is the sum of the reconstruction energy @xmath18 and a term that pushes the components of @xmath19 towards the flat spots of @xmath17 .",
    "this is performed through the use of a _ complementary function _",
    "@xmath20 , associated with the non - linearity @xmath21 .",
    "the basic idea is to design @xmath22 so that its value corresponds to the distance of @xmath23 to one of the flat spots of @xmath21 .",
    "minimizing @xmath22 will push @xmath23 towards the flat spots of @xmath21 . with this in mind ,",
    "we introduce a penalty of the form @xmath24 which encourages the argument to be in the saturation regime of the activation function ( @xmath17 ) .",
    "we refer to auto - encoders which include this regularizer as saturating auto - encoders ( sataes ) . for activation functions with zero - gradient regime(s )",
    "the complementary nonlinearity ( @xmath20 ) can be defined as the distance to the nearest saturation region .",
    "specifically , let @xmath25 then we define @xmath22 as :    @xmath26        figure 1 shows three activation functions and their associated complementary nonlinearities .",
    "the complete loss to be minimized by a satae with nonlinearity @xmath17 is :    @xmath27    where @xmath28 denotes the number of hidden units .",
    "the hyper - parameter @xmath29 regulates the trade - off between reconstruction and saturation .",
    "we will examine the effect of the saturation regularizer on auto - encoders with a variety of activation functions .",
    "it will be shown that the choice of activation function is a significant factor in determining the type of basis the satae learns .",
    "first , we will present results on toy data in two dimensions followed by results on higher dimensional image data .      given a trained auto - encoder the reconstruction error can be evaluated for a given input @xmath5 . for low - dimensional spaces ( @xmath30 , where @xmath31 ) we can evaluate the reconstruction error on a regular grid in order to visualize the portions of the space which",
    "are well represented by the auto - encoder .",
    "more specifically we can compute @xmath32 for all @xmath5 within some bounded region of the input space .",
    "ideally , the reconstruction energy will be low for all @xmath5 which are in the training set and high elsewhere .",
    "figures  [ fig : toyshrink ] and  [ fig : toysatlinear ] depict the resulting reconstruction energy for inputs @xmath33 , and @xmath34 .",
    "black corresponds to low reconstruction energy .",
    "the training data consists of a one dimensional manifold shown overlain in yellow .",
    "figure  [ fig : toyshrink ] shows a toy example for a satae which uses ten basis vectors and a shrink activation function .",
    "note that adding the saturation regularizer decreases the volume of the space which is well reconstructed , however good reconstruction is maintained on or near the training data manifold .",
    "the auto - encoder in figure  [ fig : toysatlinear ] contains two encoding basis vectors ( red ) , two decoding basis vectors ( green ) , and uses a saturated - linear activation function .",
    "the encoding and decoding bases are unconstrained .",
    "the unregularized auto - encoder learns an orthogonal basis with a random orientation .",
    "the region of the space which is well reconstructed corresponds to the outer product of the linear regions of two activation functions ; beyond that the error increases quadratically with the distance . including the saturation regularizer induces the auto - encoder basis to align with the data and to operate in the saturation regime at the extreme points of the training data , which limits the space which is well reconstructed . note that because the encoding and decoding weights are separate and unrestricted , the encoding weights were scaled up to effectively reduce the width of the linear regime of the nonlinearity .",
    "consider a satae with a shrink activation function and shrink parameter @xmath35 .",
    "the corresponding complementary nonlinearity , derived using equation 1 is given by : @xmath36             note that @xmath37 , which corresponds to an @xmath3 penalty on the activations .",
    "thus this satae is equivalent to a sparse auto - encoder with a shrink activation function . given the equivalence to the sparse auto - encoder we anticipate the same scale ambiguity which occurs with @xmath3 regularization .",
    "this ambiguity can be avoided by normalizing the decoder weights to unit norm .",
    "it is expected that the satae - shrink will learn similar features to those obtained with a sparse auto - encoder , and indeed this is what we observe .",
    "figure  [ fig : results](c ) shows the decoder filters learned by an auto - encoder with shrink nonlinearity trained on gray - scale natural image patches .",
    "one can recognize the expected gabor - like features when the saturation penalty is activated . when trained on the binary mnist dataset the learned basis is comprised of portions of digits and strokes .",
    "nearly identical results are obtained with a satae which uses a rectified - linear activation function .",
    "this is because a rectified - linear function with an encoding bias behaves as a positive only shrink function , similarly the complementary function is equivalent to a positive only @xmath3 penalty on the activations .    0.225   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.225   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.2   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively . ,",
    "title=\"fig:\",width=94,height=377 ]    0.2   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]     +    0.225   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.225   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.2   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.2   and @xmath38 , respectively , ( g)-(h ) satae - sl trained on cifar-10 with @xmath39 and @xmath40 , respectively .",
    ", title=\"fig:\",width=94,height=377 ]    0.15   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ] +   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ]    0.15   were initialized using the filter corresponding to the previous @xmath29 . the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ] +   were initialized using the filter corresponding to the previous @xmath29 . the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ]    0.15   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ] +   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ]    0.15   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ] +   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ]    0.15   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ]   were initialized using the filter corresponding to the previous @xmath29 .",
    "the regularization parameter was varied from 0.1 to 0.5 ( left to right ) in the top five images and 0.5 to 1 in the bottom five , title=\"fig : \" ] +      unlike the satae - shrink , which tries to compress the data by minimizing the number of active elements ; the satae saturated - linear ( satae - sl ) tries to compress the data by encouraging the latent code to be as close to binary as possible . without a saturation penalty",
    "this auto - encoder learns to encode small groups of neighboring pixels .",
    "more precisely , the auto - encoder learns the identity function on all datasets .",
    "an example of such a basis is shown in figure [ fig : results](b ) . with this basis",
    "the auto - encoder can perfectly reconstruct any input by producing small activations which stay within the linear region of the nonlinearity . introducing the saturation penalty",
    "does not have any effect when training on binary mnist .",
    "this is because the scaled identity basis is a global minimizer of equation 2 for the satae - sl on any binary dataset .",
    "such a basis can perfectly reconstruct any binary input while operating exclusively in the saturated regions of the activation function , thus incurring no saturation penalty .",
    "on the other hand , introducing the saturation penalty when training on natural image patches induces the satae - sl to learn a more varied basis ( figure [ fig : results](d ) ) .",
    "satae auto - encoders with 100 and 300 basis elements were trained on the cifar-10 dataset , which contains small color images of objects from ten categories . in all of our experiments",
    "the auto - encoders were trained by progressively increasing the saturation penalty ( details are provided in the next section ) .",
    "this allowed us to visually track the effect of the saturation penalty on individual basis elements .",
    "figure [ fig : results](e)-(f ) shows the basis learned by satae - shrink with small and large saturation penalty , respectively . increasing the saturation penalty",
    "has the expected effect of reducing the number of nonzero activations . as the saturation penalty increases ,",
    "active basis elements become responsible for reconstructing a larger portion of the input .",
    "this induces the basis elements to become less spatially localized .",
    "this effect can be seen by comparing corresponding filters in figure [ fig : results](e ) and ( f ) .",
    "figures [ fig : results](g)-(h ) show the basis elements learned by satae - sl with small and large saturation penalty , respectively .",
    "the basis learned by satae - sl with a small saturation penalty resembles the identity basis , as expected ( see previous subsection ) .",
    "once the saturation penalty is increased small activations become more heavily penalized . to increase their activations",
    "the encoding basis elements may increase in magnitude or align themselves with the input .",
    "however , if the encoding and decoding weights are tied ( or fixed in magnitude ) then reconstruction error would increase if the weights were merely scaled up .",
    "thus the basis elements are forced to align with the data in a way that also facilitates reconstruction .",
    "this effect is illustrated in figure [ fig : horse ] where filters corresponding to progressively larger values of the regularization parameter are shown .",
    "the top half of the figure shows how an element from the identity basis ( @xmath39 ) transforms to a localized edge ( @xmath38 ) .",
    "the bottom half of the figure shows how a localized edge ( @xmath38 ) progressively transforms to a template of a horse ( @xmath41 ) .",
    "because the regularizer explicitly encourages activations in the zero gradient regime of the nonlinearity , many encoder basis elements would not be updated via back - propagation through the nonlinearity if the saturation penalty were large . in order to allow the basis elements to deviate from their initial random states we found it necessary to progressively increase the saturation penalty . in our experiments",
    "the weights obtained at a minimum of equation 2 for a smaller value of @xmath29 were used to initialize the optimization for a larger value of @xmath29 .",
    "typically , the optimization began with @xmath42 and was progressively increased to @xmath41 in steps of @xmath43 .",
    "the auto - encoder was trained for 30 epochs at each value of @xmath29 .",
    "this approach also allowed us to track the evolution of basis elements as a function of @xmath29 ( figure [ fig : horse ] ) . in all experiments data samples were normalized by subtracting the mean and dividing by the standard deviation of the dataset .",
    "the auto - encoders used to obtain the results shown in figure [ fig : results ] ( a),(c)-(f ) used 100 basis elements , others used 300 basis elements . increasing",
    "the number of elements in the basis did not have a strong qualitative effect except to make the features represented by the basis more localized .",
    "the decoder basis elements of the sataes with shrink and rectified - linear nonlinearities were reprojected to the unit sphere after every 10 stochastic gradient updates .",
    "the sataes which used saturated - linear activation function were trained with tied weights .",
    "all results presented were obtained using stochastic gradient descent with a constant learning rate of 0.05 .",
    "in this work we have introduced a general and conceptually simple latent state regularizer .",
    "it was demonstrated that a variety of feature sets can be obtained using a single framework .",
    "the utility of these features depend on the application . in this section",
    "we extend the definition of the saturation regularizer to include functions without a zero - gradient region .",
    "the relationship of sataes with other regularized auto - encoders will be discussed .",
    "we conclude with a discussion on future work .",
    "we would like to extend the saturation penalty definition ( equation 1 ) to differentiable functions without a zero - gradient region .",
    "an appealing first guess for the complimentary function is some positive function of the first derivative , @xmath44 for instance",
    ". this may be an appropriate choice for monotonic activation functions which have their lowest gradient regions at the extrema ( e.g. sigmoids ) .",
    "however some activation functions may contain regions of small or zero gradient which have negligible extent , at the extrema for instance .",
    "we would like our definition of the complimentary function to not only measure the local gradient in some region , but to also measure it s extent .",
    "for this purpose we employ the concept of average variation over a finite interval .",
    "we define the average variation of @xmath17 at @xmath5 in the positive and negative directions at scale @xmath45 , respectively as :      where @xmath47 denotes the continuous convolution operator .",
    "@xmath48 and @xmath49 are uniform averaging kernels in the positive and negative directions , respectively .",
    "next , define a directional measure of variation of @xmath17 by integrating the average variation at all scales .      where @xmath51 is chosen to be a sufficiently fast decreasing function of @xmath45 to insure convergence of the integral .",
    "the integral with which @xmath52 is convolved in the above equation evaluates to some decreasing function of @xmath5 for @xmath53 with support @xmath54 .",
    "similarly , the integral involving @xmath55 evaluates to some increasing function of @xmath5 with support @xmath56 .",
    "this function will depend on @xmath51 .",
    "the functions @xmath57 and @xmath58 measure the average variation of @xmath59 at all scales @xmath45 in the positive and negative direction , respectively .",
    "we define the complimentary function @xmath60 as :        an example of a complimentary function defined using the above formulation is shown in figure  [ fig : diff_cc ] . whereas @xmath52 is minimized at the extrema of @xmath17 , the complimentary function only plateaus at these locations .",
    "let @xmath62 be the output of the @xmath63 hidden unit of a single - layer auto - encoder with point - wise nonlinearity @xmath64 .",
    "the regularizer imposed by the contractive auto - encoder ( cae ) can be expressed as follows :      where @xmath5 is a @xmath66-dimensional data vector , @xmath67 is the derivative of @xmath64 , @xmath68 is the bias of the @xmath63 encoding unit , and @xmath69 denotes the @xmath63 row of the encoding weight matrix .",
    "the first term in the above equation tries to adjust the weights so as to push the activations into the low gradient ( saturation ) regime of the nonlinearity , but is only defined for differentiable activation functions .",
    "therefore the cae indirectly encourages operation in the saturation regime . computing the jacobian , however , can be cumbersome for deep networks .",
    "furthermore , the complexity of computing the jacobian is @xmath70 , although a more efficient implementation is possible @xcite , compared to the @xmath71 for the saturation penalty .      in section 3.2",
    "it was shown that sataes with shrink or rectified - linear activation functions are equivalent to a sparse auto - encoder .",
    "interestingly , the fact that the saturation penalty happens to correspond to @xmath3 regularization in the case of satae - shrink agrees with the findings in @xcite . in their efforts to find an architecture to approximate inference in sparse coding , gregor et al",
    ". found that the shrink function is particularly compatible with @xmath3 minimization .",
    "equivalence to sparsity only for some activation functions suggests that sataes are a generalization of sparse auto - encoders . like the sparsity penalty",
    ", the saturation penalty can be applied at any point in a deep network for the same computational cost . however , unlike the sparsity penalty the saturation penalty is adapted to the nonlinearity of the particular layer to which it is applied .",
    "we intend to experimentally demonstrate that the representations learned by sataes are useful as features for learning common tasks such as classification and denoising",
    ". we will also address several open questions , namely : ( i ) how to select ( or learn ) the width parameter ( @xmath35 ) of the nonlinearity , and ( ii ) how to methodically constrain the weights .",
    "we will also explore sataes that use a wider class of non - linearities and architectures .",
    "marcaurelio ranzato , christopher poultney , sumit chopra and yann lecun .",
    "efficient learning of sparse representations with an energy- based model , in j. platt et al .",
    "( eds ) , _ advances in neural information processing systems ( nips 2006 ) _ , 19 , mit press , 2006 .",
    "marcaurelio ranzato , fu - jie huang , y - lan boureau and yann lecun : unsupervised learning of invariant feature hierarchies with applications to object recognition , proc .",
    "computer vision and pattern recognition conference ( cvpr07 ) _ , ieee press , 2007    rifai , s. and vincent , p. and muller , x. and glorot , x. and bengio , y. contractive auto - encoders : explicit invariance during feature extraction , _ proceedings of the twenty - eight international conference on machine learning , icml 2011 _    p. vincent , h. larochelle , y. bengio , p.a .",
    "manzagol . extracting and composing robust features with denoising autoencoders _ proceedings of the 25th international conference on machine learning ( icml2008 )"
  ],
  "abstract_text": [
    "<S> we introduce a simple new regularizer for auto - encoders whose hidden - unit activation functions contain at least one zero - gradient ( saturated ) region . </S>",
    "<S> this regularizer explicitly encourages activations in the saturated region(s ) of the corresponding activation function . </S>",
    "<S> we call these saturating auto - encoders ( satae ) . </S>",
    "<S> we show that the saturation regularizer explicitly limits the satae s ability to reconstruct inputs which are not near the data manifold . </S>",
    "<S> furthermore , we show that a wide variety of features can be learned when different activation functions are used . </S>",
    "<S> finally , connections are established with the contractive and sparse auto - encoders . </S>"
  ]
}