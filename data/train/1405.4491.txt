{
  "article_text": [
    "the concept of _ classsification problems _ was introduced by m. ziegler ( [ 1 ] ) as a generalization of _ promise problems _ due to s. even ( [ 5 ] ) .",
    "promise problems are a generalization of _ decision problems_. a classification problem is a vector @xmath0 where the @xmath1 are pairwise disjoint infinite subsets of a given basic set @xmath2 . for a set family @xmath3",
    "such a classification problem is @xmath4-_solvable _ , if a vector @xmath5 exists with @xmath6 , @xmath7 for @xmath8 and @xmath9 if @xmath10 we are faced with promise problems . in applications",
    "@xmath11 where @xmath12 is a finite nonempty alphabet and @xmath13 a language family and/or a complexity class . from an algorithmic point of view solutions of classification problems can be used to obtain constant size _",
    "advices_. in this case advices indicate the inputs to belong to certain subsets ( c.f . [ 1 ] for further details ) .",
    "we extend the results about unsolvability cores in promise problems ( [ 4 ] ) to unsolvability cores in classification problems .",
    "again cohesiveness is the characterizing indicator . for unsolvable promise problems we can find in general unsolvability cores , if the set family is closed under union , intersection and finite variation .",
    "but for unsolvable classification problems with @xmath14 the existence of unsolvability cores needs further conditions .",
    "we show , that we can assert the existence of unsolvability cores for @xmath15 under the same assumption as needed for promise problems , if we fix one of the components . in this approach the fixed component",
    "is called the _ condition _ for the classification problem .",
    "the results are proven under assumptions which involve closure properties of @xmath16 against some or all boolean operations _",
    "union , intersection _ and _ complementation_. moreover , we can relate unsolvability cores for conditional classification problems to so called _ proper hard cores _ introduced by r. book and d .- z .",
    "du in a general form ( [ 3 ] ) and first defined by n. lynch ( [ 6 ] ) for complexity classes .",
    "using results and proof techniques from [ 3 ] we can apply our results to language families and complexity classes .",
    "especially , we are able to construct unsolvability cores where the components are recursive . to do this , the language family or complexity class under consideration must allow an enumeration where the word problem has a uniform solution .",
    "we assume the reader to be familiar with the theory of recursive functions , languages and complexity ( cf.[2],[7 ] ) .",
    "in the following an infinite _ basic _ set @xmath2 is given .",
    "we assume that the elements of set families @xmath16 are subsets of s. moreover , sets @xmath17 are always subsets of @xmath2 and _ singletons _ @xmath18 are identified with @xmath19 .",
    "we mainly deal with denumerable set families @xmath16 ; i.e. a function @xmath20 with @xmath21 exists ( _ enumeration _ of @xmath16 ) .",
    "consider the _",
    "operations @xmath22 _ union _ , @xmath23 _ intersection _ and @xmath24\\@xmath25 _ complementation _ in connection with set families @xmath16 .",
    "these operations can be lifted to binary operations between set families @xmath26 and @xmath27 and unary operations for @xmath16 .",
    "define @xmath28 and the closure operations @xmath29 we will frequently use @xmath30 .",
    "note , that @xmath31 , @xmath32 and @xmath33 .",
    "furthermore , @xmath34 ( @xmath35 , @xmath36 ) if and only if @xmath37 ( @xmath38 , @xmath39 , respectively ) .",
    "let @xmath40 finite@xmath41 .",
    "then @xmath16 is closed under _ finite variation _ if @xmath42 and @xmath43 .",
    "we call @xmath16 _ nontrivial _ if @xmath44 and @xmath16 is closed under finite variation . in this case @xmath45",
    ". note , that @xmath46 .",
    "moreover , @xmath47 , @xmath48 , @xmath49 and @xmath50 are nontrivial , if @xmath16 is nontrivial .",
    "+ consider the case @xmath51 , where @xmath52 is the _ _ free monoid over__@xmath12 ( a nonempty , finite _ alphabet _ ) with _ concatenation _ of _ words _ as monoid operation and * 1 * as identity . as usual @xmath53",
    "is called a _ language _ and @xmath54 a _ language family_. for a word @xmath55 @xmath56 for @xmath57 @xmath58 is the _ length _ of @xmath59 and @xmath60 . for languages @xmath61 and @xmath62 the _ complex product _",
    "is defined by @xmath63 .",
    "there are various kinds of quotients available , for example the _ left quotient _ defined by @xmath64 : @xmath65 . in this context",
    "we are mainly interested in handling _ leftmarkers _ , i.e. we consider the products @xmath66 and the quotients @xmath67 where @xmath68 and @xmath69 is a language .",
    "with respect to language families @xmath70 we get the closure operations @xmath71 and @xmath72 . in handling the leftmarkers ( for example complementation of a leftmarked language ) we use variation by @xmath73 , the family of _ regular _ languages ( for details see [ 4 ] ) . a language family @xmath70 is closed under _ regular variation _ if @xmath74 and @xmath75 .",
    "looking at ( partial ) orderings on @xmath52 the _ lexicographic _ ordering is important for our purposes",
    ". for @xmath76 let @xmath77_0 = \\{0 ,   \\dots , n - 1\\}$ ] and @xmath77 = \\{1 , \\dots , n\\}$ ] . given a bijection @xmath78_0 \\",
    "( b=\\#(x))$ ] define @xmath79 if and only if ( @xmath80 or ( @xmath81 and @xmath82 and @xmath83 .",
    "this is a well - ordering , hence we can define a successor function @xmath84 for @xmath85 by @xmath86 and @xmath87 where the minimum is taken with respect to the lexicographic ordering . then @xmath88 defines a bijection @xmath89 with inverse @xmath90 .",
    "consider the language families @xmath91 ( _ recursively enumerable _ languages ) and @xmath92 + @xmath93 ( _ recursive _ languages ) . let @xmath94 be the set of _ n - ary recursive _ functions .",
    "using @xmath95 as truth values define for a language @xmath69 the function @xmath96",
    ". then a language @xmath69 is recursive if and only if @xmath97 .",
    "alternatively , a nonempty language @xmath69 is recursive if and only if a function @xmath98 exists such that @xmath99 is nondecreasing and recursive .",
    "classical language families and complexity classes are always denumerable . of special interest",
    "are families with enumerations which are in a certain sense `` effective '' . for our purpose",
    "it is important to assert that these enumerations allow a uniform solution for the word problem .",
    "more formular , we define for an enumeration * e * of a language family @xmath70 the function @xmath100.@xmath101 .",
    "if @xmath102 then * e * is called _ wp - recursive_. @xmath70 is called _ wp - recursive _",
    ", if a wp - recursive enumeration * e * of @xmath70 exists .",
    "note , that any wp - recursive @xmath70 is a ( proper ) subfamily of @xmath92 and every complexity class with reasonable ressource bounds ( _ time- _ and _ space - constructability _ [ 2 ] ) is wp - recursive .",
    "let @xmath103 .",
    "we consider vectors @xmath104 with @xmath105 for @xmath106 . to such an * a * we associate two functions @xmath107 and @xmath108 . moreover ,",
    "if @xmath109 with @xmath110 is another vector , then @xmath111 if and only if an injective @xmath112 \\rightarrow [ k ] $ ] exists with @xmath113 for @xmath114 . *",
    "a * is a _ classification problem _ if @xmath1 is infinite and @xmath115 for all @xmath8 . for a given @xmath4",
    "a vector @xmath116 is an @xmath16 _ -partition _ if @xmath117 , @xmath118 and @xmath119 for @xmath8 .",
    "a classification problem @xmath120 is @xmath16-_solvable _ ( @xmath121 ) if and only if an @xmath16-partition * q * exists with @xmath122 and @xmath123 , where @xmath124 .    if @xmath125 then @xmath16-solvability of promise problems corresponds to the _ separation principle _ defined in [ 7 ] ( exercise 5 - 33 ) . our definition of @xmath16-solvability for classification problems is stronger than the definition of @xmath16-_separability _ given in [ 1 ] , where a classification problem @xmath120 is @xmath16-_separable _ , if there exists a @xmath126 , which satisfies the conditions of definition 2.1 . except the condition `` @xmath117 '' , which may not necessarily be valid .",
    "note that for such a @xmath126 , we always obtain @xmath127 .",
    "hence , the class of @xmath16-solvable classification problems with more than one components is identical with the class of @xmath16-separable classification problems , if @xmath16 is a boolean algebra . that @xmath16-solvability is stronger than @xmath16-separability , follows from results in [ 7 ] .",
    "consider @xmath91 where x is a one - letter alphabet .",
    "then a promise problem @xmath128 consisting of recursively enumerable sets exists , which is not @xmath91-solvable ( [ 7 ] exercise 5 - 34 ) .",
    "but @xmath128 is clearly @xmath91-separable .",
    "we also find the interesting result that any promise problem @xmath128 with @xmath129 is @xmath130-solvable ( [ 7 ] exercise 5 - 33 ) .",
    "hence all promise problems , which are @xmath130-separable are @xmath130-solvable . but @xmath130 is not closed under complementation .",
    "for @xmath131 we identify @xmath132 with @xmath133 .",
    "if @xmath16 is nontrivial then every @xmath132 is @xmath16-solvable .",
    "if @xmath14 and @xmath16 satisfies appropriate closure properties , then we can reduce the question of solvability of classification problems to solvability of promise problems . directly from the definition we get    if @xmath134 then for all classification problems * a * and * b * with @xmath135 @xmath136 implies @xmath137 .",
    "suppose @xmath138 where @xmath126 is an @xmath16-partition .",
    "let @xmath139 and @xmath140 .",
    "then we can assume without loss of generality @xmath141 for all i. consider p = @xmath142",
    ". then @xmath143 .",
    "hence , @xmath144 is an @xmath16-partition with @xmath145 .",
    "if @xmath146 and @xmath147 is a classification problem then @xmath148 if and only if @xmath149 for all @xmath8 .",
    "the `` if part '' follows by proposition 2.2 .",
    "suppose that @xmath149 for @xmath8 .",
    "now we proceed by induction over @xmath108 . if k = 2 nothing is to prove .",
    "let @xmath150 and suppose @xmath151 .",
    "then an @xmath16-partition @xmath152 with @xmath153 exists .",
    "assume without loss of generality @xmath154 for @xmath155 .",
    "on the other side @xmath156 exist with @xmath157 and @xmath158 for @xmath155 .",
    "consider @xmath159 .",
    "then @xmath160 for @xmath155 and @xmath161 with @xmath162 .",
    "this shows @xmath163 is an @xmath16-partition with @xmath123 .    as indicated in the introduction",
    "we generalize the notion of a classification problem to conditional classification problems by fixing one component as condition .",
    "consider @xmath164 and a classification problem * a*. then @xmath165 is a _ conditional classification problem _ if @xmath166 , referring to @xmath167 as the _ problem condition_. @xmath167 could be finite , even empty . if @xmath168 is finite , then no conditional classification problems @xmath165 exist .    a conditional classification problem @xmath169 is called @xmath16-_solvable _ ( @xmath170 ) if and only if an @xmath16-partition @xmath171 exists with @xmath172 and @xmath173 where @xmath124 .    the following facts follow directly from the definition",
    "let @xmath16 and @xmath103 be given .",
    "1 .   @xmath174 .",
    "2 .   @xmath175 .",
    "3 .   @xmath176 .",
    "4 .   @xmath177 .",
    "@xmath16 nontrivial and @xmath178 .",
    "consider @xmath179 .",
    "let @xmath180 a nontrivial language family , which is closed under regular variation .",
    "if @xmath25 is a set with @xmath181 , then @xmath182 and by our assumption on @xmath70 @xmath183 for @xmath184 ( lemma 5.4 . in [ 4 ] ) . clearly , @xmath185 , but @xmath186 .",
    "hence @xmath187 .",
    "as in the case of promise problems unsolvability of classification problems is closely related to cohesiveness .",
    "@xmath188 is @xmath16-cohesive ( @xmath189 ) if and only if @xmath25 is infinite and for all @xmath190 either @xmath191 or @xmath192 is finite ( cf.[4 ] and [ 7 ] ) .",
    "it is interesting to compare our definition of cohesiveness with related classical definitions , as they are presented in [ 7 ] .",
    "consider the families @xmath193 , @xmath91 and @xmath92 . then @xmath194 if and only if @xmath69 is cohesive in the classical sense .",
    "moreover , @xmath195 , since a language @xmath196 is recursive if and only if @xmath196 and @xmath197 are recursively enumerable . furthermore the definition of recursively indecomposability coincides with the definition of @xmath198-cohesiveness . in [ 7 ]",
    "we also find the notion of indecomposability .",
    "@xmath69 is indecomposable if there exist no infinite sets @xmath199 such that @xmath200 is infinite and @xmath201 is infinite .",
    "then we find the following results in [ 7 ] . if @xmath194 then it is indecomposable and any indecomposable @xmath69 is @xmath92-cohesive . none of the converse implications hold .    in [ 4 ] ( theorem 5.1 .",
    ") it is proven , that for a promise problem @xmath128 and a nontrivial set family @xmath16 @xmath202 if and only if @xmath203 and @xmath204 .",
    "this result leads to a much stronger one . in the theory of complexity",
    "we find the notion of _ hard cores _ inside those sets which can be computed with bounded ressources ( time , space , e.t.c . [ 3 ] ) .",
    "similarily , we can consider _ unsolvability cores _ of classification problems which are not solvable .",
    "for @xmath205 a classification problem @xmath206 with @xmath207 is a _ k - core _ of @xmath16 ( @xmath208 if and only if for all classification problems @xmath209 with @xmath210 and @xmath211 .",
    "clearly , any subproblem of a core is itself a core .",
    "this is especially true for subproblems , which are promise problems .",
    "this enables us to use the results about unsolvability cores for promise problems from [ 4 ] .",
    "if @xmath212 and @xmath213 is a classification problem then @xmath214 if and only if @xmath215 for all @xmath8 .",
    "suppose @xmath216 , then by definition @xmath217 and therefore @xmath218 .",
    "conversely , suppose that @xmath219 , i. e. @xmath220 exists with @xmath221 , @xmath222 and @xmath223 . since @xmath212 we know @xmath224 .",
    "moreover , @xmath225 and @xmath226 for some @xmath8 .",
    "but then @xmath227 .",
    "now we can characterize cores by cohesiveness . using theorem 5.1 . and theorem 6.7 . of [ 4 ]",
    "we can prove    if @xmath212 is nontrivial and * a * a classification problem with @xmath228 then @xmath229 if and only if @xmath230 .    if @xmath231 , then @xmath218 for all @xmath8 . by theorem 6.7 . in [ 4 ] we know @xmath232 for all @xmath233 .",
    "but then @xmath234 . since @xmath235 for all",
    "@xmath236 and @xmath132 is infinite , a simple induction proof shows @xmath237 .",
    "conversely , if @xmath238 then for all @xmath239 , @xmath240 .",
    "again by theorem 6.7 . of [ 4 ]",
    "@xmath241 and therefore by lemma 3.4 .",
    "@xmath242 we can find to any classification problem @xmath120 with @xmath243 and @xmath244 a @xmath135 such that @xmath245 if @xmath246 is denumerable ( [ 4 ] ) .",
    "but this is not true for classification problems @xmath120 with @xmath247 . to see this we prove the following theorem , where we use @xmath248 with @xmath249 .",
    "define for @xmath250 the classification problem @xmath251 , where @xmath252 for @xmath253 .",
    "let @xmath70 be a nontrivial language family with @xmath254 , which is closed under regular variation .",
    "if @xmath255 with @xmath256 or @xmath257 , then @xmath258 and for all @xmath259 with @xmath260 : @xmath261 .",
    "\\(1 ) we know @xmath262 ( [ 4 ] ) .",
    "but then by lemma 5.4 .",
    "of [ 4 ] @xmath263 for all @xmath264",
    ". now @xmath265 , @xmath266 and @xmath267 .",
    "this shows @xmath268 for all @xmath269 , @xmath270 and @xmath271 .",
    "\\(2 ) suppose @xmath259 exists with @xmath272 . then by theorem 3.5 .",
    "assume without loss of generality that @xmath274 and @xmath275 for @xmath276 with @xmath277 .. in the following let @xmath278 and @xmath279 .",
    "* assertion * : @xmath280 for all @xmath281 with @xmath269 .",
    "+ suppose to the contrary ( without loss of generality ) @xmath282 .",
    "but then @xmath283",
    ". otherwise we obtain @xmath284 . since @xmath285 , @xmath286 - a contradiction .",
    "but now @xmath287 is infinite and @xmath288 , hence both @xmath289 and @xmath290 are infinite - a contradiction to @xmath273 .",
    "+ now consider @xmath291 and @xmath292 .",
    "then both sets are infinite and @xmath293 - a contradiction to @xmath294 .",
    "this completes the proof .    the basic idea behind the proof of theorem 3.6 .",
    "is due to m. ziegler ( [ 1 ] ) .",
    "note , that complexity classes and most of the known language families satisfy the conditions of theorem 3.6 .    using conditional unsolvability",
    ", we can derive an existence theorem for cores .",
    "let @xmath295 be denumerable and nontrivial .",
    "if @xmath296 is a classification problem and @xmath297 is @xmath16-cohesive with @xmath298 for @xmath299 , then there exists @xmath135 with @xmath300 and @xmath301 .",
    "since @xmath298 , we can find @xmath302 and @xmath303 with @xmath304 ( theorem 6.14 .",
    "in [ 4 ] ) . by theorem 3.5 .",
    "@xmath305 and therefore @xmath306 .",
    "now @xmath307 and @xmath308 . by theorem 5.1 . in [ 4 ]",
    "we know @xmath309 .",
    "but then @xmath310 , since for all @xmath311 @xmath167 is infinite and @xmath312 .",
    "it follows @xmath313 and we obtain @xmath314 and by theorem 3.5 .",
    "@xmath301 .",
    "consider the situation of theorem 3.6 .",
    "then @xmath315 and there is no room for an infinite condition @xmath167 to make the conditional classification problem @xmath316 @xmath70-solvable .",
    "unsolvability of conditional classification problems can be related to cohesiveness , too .",
    ". then @xmath25 is @xmath16__-cohesive under condition _",
    "_ @xmath167 ( in short : @xmath318 , if and only if @xmath25 is infinite and for all @xmath319 with @xmath320 either @xmath191 or @xmath321 is finite .    clearly , if @xmath322 , then * * _ ccohesive_**@xmath323 * * _ ccohesive_**@xmath324 .",
    "especially , we get @xmath325 and therefore @xmath326 for all @xmath164 . rewriting the definition",
    ", we also find @xmath327 where @xmath328 and @xmath329 .",
    "analogously , we define conditional cores by    let @xmath164 and @xmath120 a classification problem . then @xmath120 is a @xmath167-@xmath330 of @xmath16 ( @xmath331 if and only if for all @xmath210 with @xmath332 .",
    "in contrast to the definition of @xmath333 subproblems @xmath209 with @xmath334 are considered , too .",
    "note , that @xmath335 is a conditional - classification problem , if @xmath210 .",
    "moreover , if @xmath336 , then @xmath337 .",
    "the following lemma characterizes @xmath338 by conditional cohesiveness .",
    "let @xmath16 be nontrivial and @xmath317 with @xmath25 infinite and @xmath339",
    ". then the following statements are equivalent    1 .",
    "@xmath340 2 .",
    "@xmath341 and @xmath342 .",
    "\\(i ) @xmath343 ( ii ) : suppose @xmath340 .",
    "then @xmath341 .",
    "assume to the contrary that @xmath344 .",
    "then @xmath319 exists with @xmath345 and @xmath346 .",
    "let @xmath347 .",
    "then @xmath348 , but @xmath349 , hence @xmath350 .",
    "moreover , @xmath351 , i.e. @xmath352 .    \\(ii ) @xmath343 ( i ) : suppose that @xmath341 and @xmath353 .",
    "assume to the contrary that an infinite set @xmath354 exists , such that @xmath355 and @xmath356 for some @xmath319",
    ". then @xmath357 .",
    "since @xmath358 , @xmath359 , too .",
    "hence @xmath360 , because @xmath353 .",
    "consider @xmath361 .",
    "since @xmath16 is nontrivial , @xmath362 . note that @xmath363 .",
    "on the other side , @xmath364 and @xmath365 , i.e. @xmath366 . hence @xmath367 .",
    "this shows that @xmath341 - a contradiction .",
    "let @xmath4 be nontrivial with @xmath368 and @xmath165 a conditional k - classification problem . if @xmath369 then the following statements are equivalent    1 .",
    "@xmath370 2 .",
    "@xmath371 and @xmath372 for all @xmath155 .",
    "\\(i ) @xmath343 ( ii ) : suppose that @xmath373 .",
    "then for all @xmath374 , since @xmath375 . applying lemma 4.3 .",
    "we get the result .",
    "\\(ii ) @xmath343 ( i ) : let the @xmath1 be given according to the assumption",
    ". assume to the contrary that @xmath135 exists with @xmath376 .",
    "then an injective @xmath377 \\rightarrow [ k]$ ] exists with @xmath378 for @xmath379 . since @xmath380 . but",
    "@xmath381 and @xmath382 .",
    "this is a contradiction .",
    "now , we are able to assert the existence of conditional cores in the case that both @xmath167 and @xmath383 are infinite . observe that under this assumption @xmath384 if and only if @xmath385 considered as a promise problem is solvable for @xmath4 , i.e. @xmath386 .",
    "let @xmath4 be denumerable and nontrivial with @xmath295 .",
    "if @xmath387 , @xmath388 , @xmath339 and @xmath341 , then @xmath354 exists with @xmath389 .    if @xmath341 , i.e. @xmath390 . by cor.5.16 .",
    "in[4 ] we can find @xmath354 such that for all infinite @xmath391 @xmath392 , i.e. @xmath389 . using this lemma in connection with theorem 4.4 .",
    "we get    let @xmath16 be denumerable and nontrivial with @xmath295 and @xmath169 a conditional classification problem where @xmath167 and @xmath383 are infinite . if @xmath369 with @xmath393 for @xmath394 then a @xmath111 exists with @xmath395 and @xmath396 .    by lemma 4.5 .",
    "we find for each @xmath397 @xmath398 and @xmath303 .",
    ". then @xmath135 and @xmath395 .",
    "by theorem 4.4 . @xmath400 .",
    "for wp - recursive language families we can prove a much stronger result .",
    "this depends on the relation between @xmath401 and proper hard cores introduced by n. lynch [ 6 ] for complexity classes and in a very general form by r. book- d .- z .",
    "du [ 3 ] .",
    "@xmath402 is a @xmath16-_hardcore _ of @xmath25 if and only if @xmath402 is infinite and for all @xmath403 : @xmath404 . if additionally @xmath354 then @xmath402 is a _ proper _ @xmath16-hardcore of @xmath25 .",
    "( remind @xmath405 for @xmath16 and @xmath25 . )",
    "note , that for @xmath406 with @xmath407 infinite every @xmath16-hardcore of @xmath25 is a @xmath16-hardcore of @xmath407 .",
    "rephrasing lemma 7.2 .",
    "of [ 4 ] we get the following    if @xmath4 is nontrivial with @xmath408 and @xmath385 a conditional classification problem then @xmath25 is a proper @xmath16-hardcore of @xmath383 if and",
    "only if @xmath401 .    now we can use a construction for proper hard cores from [ 3 ] in a modified form .",
    "if @xmath409 is a nontrivial and wp - recursive language family with @xmath410 and @xmath385 a conditional classification problem with @xmath411 and @xmath412 are recursive then a recursive @xmath354 exists with @xmath413 .",
    "consider an enumeration @xmath414 of @xmath70 such that @xmath415 .",
    "furthermore , let @xmath416 .",
    "now define for all @xmath417 @xmath418 and @xmath419 by the following algorithm : +    @xmath420 @xmath421 ; @xmath422 @xmath423 ; @xmath424 ; @xmath425 ; @xmath426 ; @xmath427 and @xmath428 @xmath429 ; @xmath430    ( for @xmath431 we get the construction of [ 3 ] ) . + now , let @xmath432 and @xmath433",
    ". assume for the moment that @xmath402 is infinite .",
    "@xmath402 is recursive and @xmath354 , since all basic functions are recursive , @xmath434 is finite for all @xmath435 and the elements of @xmath402 are added in increasing order with respect to @xmath436 .",
    "moreover , @xmath437 .",
    "hence @xmath438 and we get @xmath439 and by construction @xmath440 for @xmath441 ( cf . [ 3 ] ) . in conclusion , @xmath402 is a proper @xmath70-hardcore of @xmath383 and by lemma 4.9 .",
    "@xmath442 . it remains to show the    * assertion : * @xmath443 .",
    "+ suppose to the contrary , that @xmath402 is finite .",
    "then @xmath444 exists with @xmath445 for almost all @xmath435 .",
    "moreover , for every @xmath446_0 $ ] with @xmath447 there must exist @xmath448 with @xmath449 .",
    "let @xmath450_0 $ ] with @xmath451 .",
    "then we know that for all @xmath446_0 $ ] with @xmath452 .",
    "choose @xmath453 sufficiently large such that additionally card@xmath454 for every @xmath455 .",
    "consider @xmath456 with @xmath457 .",
    "since @xmath458 , @xmath446_0 $ ] exists with @xmath459 .",
    "this shows @xmath460 and @xmath461 and therefore @xmath462 . since @xmath70 is nontrivial and @xmath463 , we know @xmath464 .",
    "moreover , @xmath465 implies @xmath466 , hence @xmath411 - a contradiction .",
    "now we can derive a stronger result than lemma 4.6 .",
    ":    let @xmath70 be a nontrivial and wp - recursive language family with @xmath467 and @xmath165 a conditional k - classification problem . if @xmath167 is recursive and @xmath369 such that @xmath468 and @xmath1 is recursive for @xmath155 then @xmath399 exists with @xmath469 and @xmath470 is recursive for @xmath155 .    by theorem 5.3 .",
    "we find for each @xmath155 @xmath471 with @xmath303 and @xmath470 is recursive .",
    "let @xmath399 .",
    "then @xmath135 and by theorem 4.4 .",
    "@xmath472 .",
    "the @xmath470 s constructed in theorem 5.4 .",
    "are all infinite . by the dekker - myhill theorem (  12.3 theorem vi in [ 7 ] )",
    ", we can find in every @xmath470 a @xmath70-cohesive @xmath473 , but we can not show , that @xmath473 is recursive under the conditions of theorem 5.4 . the best result to",
    "our knowledge is the result of friedberg (  12.4 theorem xi in [ 7 ] ) .",
    "the construction ( due to yates ) in the proof given in [ 7 ] can be easily modified in such a way , that to any infinite , recursive @xmath25 a @xmath474-cohesive subset @xmath402 with @xmath475 can be found .",
    "since any wp - recursive language family @xmath70 is a subfamily of @xmath474 this @xmath402 is @xmath70-cohesive , too .",
    "this paper continues our research about unsolvability cores in promise problems ( [ 4 ] ) generalizing the results to classification problems .",
    "our approach is very general , though the applications in this paper deal mainly with language families and complexity classes .",
    "the main open problem in our approach is to construct cohesive sets with `` nice '' properties .",
    "we acknowledge seminal discussions with martin ziegler .",
    "k. ambos - spies , u. brandt , m. ziegler : `` real benefit of promises and advice '' , pp . 1 - 11 , cie 2013 _ _ 2 .",
    "j.l.balcazar , j.diaz , j.gabarro :  structural complexity i \" _ eatcs monographs on theoretical computer sciences _ , springer verlag ( 1988 ) 3 .",
    "r.v.book , ding - zhu du : `` the existence and density of generalized complexity cores '' , pp.718730 in _ jacm _ vol.*34:3 * ( july 1987 ) .",
    "u.brandt , h.k .- g.walter : `` cohesiveness in promise problems '' , _ rairo - theoretical informatics and applications _ vol . * 47:4 * ( november 2013 ) .",
    "s.even , a.l.selman and y.yacobi : `` the complexity of promise problems with applications to public - key cryptography '' , pp.159173 in _ information and control _ vol.*61 * ( 1984 ) . 6 .",
    "n.lynch :  on reducibility to complex or sparse sets \" _ jacm _ , vol.*3*(july 1975 ) , pp.341 - 345 7 .",
    "hartley rogers jun.:``__theory of recursive functions and effective computability _ _ '' , macgraw - hill book company ( 1967 ) ."
  ],
  "abstract_text": [
    "<S> classification problems have been introduced by m.  ziegler as a generalization of promise problems . in this paper </S>",
    "<S> we are concerned with solvability and unsolvability questions with respect to a given set or language family , especially with cores of unsolvability . </S>",
    "<S> we generalize the results about unsolvability cores in promise problems to classification problems . </S>",
    "<S> our main results are a characterization of unsolvability cores via cohesiveness and existence theorems for such cores in unsolvable classification problems . </S>",
    "<S> in contrast to promise problems we have to strengthen the conditions to assert the existence of such cores </S>",
    "<S> . in general unsolvable classification problems with more than two components exist , which possess no cores , even if the set family under consideration satisfies the assumptions which are necessary to prove the existence of cores in unsolvable promise problems . </S>",
    "<S> but , if one of the components is fixed we can use the results on unsolvability cores in promise problems , to assert the existence of such cores in general . in this case </S>",
    "<S> we speak of conditional classification problems and conditional cores . </S>",
    "<S> the existence of conditional cores can be related to complexity cores . using this connection we can prove for language families , that conditional cores with recursive components exist , provided that this family admits an uniform solution for the word problem . </S>"
  ]
}