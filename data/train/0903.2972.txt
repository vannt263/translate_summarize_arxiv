{
  "article_text": [
    "in reinforcement learning@xcite an agent collects rewards in an environment . the environment is not known in advance .",
    "the agent has to explore it to learn where to go .",
    "a reward could be received when taking an action in a state .",
    "the agent aims to maximize her long - term reward in the environment .",
    "she should not miss any state with an important reward or a shorter path to it .",
    "there are many existing exploration techniques@xcite that are optimistic in the face of uncertainty .",
    "their optimism assumes that a greater reward will be obtained when taking an unknown action .",
    "the problem is how to do exploration in environments with the unlimited number of states . in these environments , it is not possible to try every action in every possible state .",
    "i study a new way to do exploration in environments with the unlimited number of states .",
    "i use simulated exploration as an incentive for real exploration .",
    "the simulated exploration proposes promising paths to explore .",
    "i describe how to use this kind of exploration in section [ idea ] .",
    "my experiments in section [ experiments ] demonstrate how simulated exploration reduced the needed amount of real exploration .",
    "i also discuss when it is possible .",
    "many works touched related problems .",
    "they inspired me and i discuss them in section [ relatedwork ] .",
    "there is an example of a reinforcement learning task in figure [ img_example ] .",
    "the environment is a grid world .",
    "the agent has to find a path from the start to the goal .",
    "this environment gives a reward just when the goal is reached .",
    "the task is then repeated .",
    "a state is represented as a tile on the grid and the agent could choose from four different actions : _ north _ , _ east _ , _ south _ , _ west_. but the agent does not know their meanings",
    ".    the agent does not know that the environment is a 2d grid world with manhattan distance metric .",
    "she sees it just as a graph and has yet to explore its structure .",
    "a _ value _ of a state represents the summed expected reward that the agent expects to see if she continues to follow her policy form that state .",
    "q - learning@xcite is typically used to learn the values of state - action transitions .    in an environment with the limited number of states",
    ", we could use exploration that is optimistic about rewards from unknown actions .",
    "this exploration would try to explore every action in every state to see if there is a greater reward .",
    "such wide exploration is impossible if the environment is without boundaries .",
    "the idea is to use simulated exploration to discover promising paths for real exploration .",
    "this reduces the needs for real exploration .",
    "an approximate model of the environment is used to simulate the exploration .",
    "an approximate model is an approximation of the real environment .",
    "it predicts how the environment will behave when executing an action in a state .",
    "the model predicts the next state of the environment and what reward will be obtained for the action .",
    "an approximate model could be optimistic or pessimistic .",
    "an optimistic model assume a greater reward or better transitions than it is possible in the real environment .",
    "for example , an optimistic model could assume no barriers on the path .",
    "it is better to use optimistic models than the pessimistic ones@xcite .",
    "using an optimistic model will lead to discovery of a more accurate model of the environment or to discovery of better paths .",
    "a pessimistic model would assume that no better path exists and would miss it .",
    "the optimistic model should be as accurate as possible to prevent too many mistakes and corrections .",
    "an overly optimistic model would assume that every state transition will lead to a state with the highest reward .",
    "a model could aim to be more accurate at the risk to become pessimistic in some states .",
    "that is a risk we accept when we do nt want to explore all states in unlimited state space .",
    "for example , a model aiming to be more accurate could assume that already tried actions will have similar effects in new states .",
    "this does not need to be true when a wall is hit , but that would be corrected if the model is optimistic .",
    "an example of one such model is given in section [ experiments ] .",
    "these less optimistic models may not need to work as an incentive for exploration on their own .",
    "a greedy agent sees no reason to try new actions when they do nt lead directly to states with a higher value .",
    "a simulated exploration is needed to discover the promising paths .",
    "when given an approximate model , the simulated exploration will try to find promising paths under that model .",
    "it tries different actions in the model and explores where they lead .",
    "the exploration is not real , it is simulated without taking such actions in the real environment .    to work as an incentive for real exploration , values of environment states continue to be updated during the simulation as if it were a real experience .",
    "when an unexplored state leads to a state with a high value , the value of the unexplored state is also increased .",
    "the simulation is done as any other planning method .",
    "it is executed to do a few simulated explorations and then it is interleaved by real acting .",
    "the following code shows a body of a typical agent",
    ". the simulated exploration would be inside the ` self.planner.plan ( ) ` method , possibly with some other planning .",
    "caption = body of a typical agent expressed in python .",
    "def agent_step(self , s , r = none ) : `` ' ' `` does a single step and returns a selected action .",
    "the agent sees the current state ` s ' and the reward ` r ' obtained for the last action . ' ' `` '' if r is not none : self.learner.learn ( self.last_s , self.last_a , r , s )    if rl.is_terminal(s ) : return none    self.planner.plan(s )    a = self.policy.select_action(s ) self.last_s = s self.last_a = a return self.last_a    the simulated exploration could discover a promising path that leads to an existing or predicted reward",
    ". the promising path would be visible for the agent as a set of states that got a high value .",
    "some of these states could still be unexplored in the real environment .",
    "i will describe two ways how to spread the simulated exploration : _ trajectory sampling _ and _ prioritized sweeping_. but any method that will simulate experience within a given approximate model could be used .",
    "the simulated exploration could follow a trajectory generated by an exploration policy",
    ". the trajectory could start from any state .",
    "for example , it could start from the agent s real current state .",
    "that restricts the simulated state space to the states near the agent .",
    "code [ code_sampling ] shows an example of simulated exploration along a trajectory .",
    "the maximal depth of the sampled trajectory is limited to limit the amount of computation done inside one planning step .",
    "caption = simulating exploration by trajectory sampling.,label = code_sampling def plan_along_trajectory(self , s ) : `` ' ' `` simulates exploration of a trajectory from the given state . ' ' `` '' path = [ ] while len(path ) < = self.max_depth : if rl.is_terminal(s ) : break    a = self.exploration_policy.select_action(s ) next_s_probs , r = self.model.predict(s , a ) if len(next_s_probs ) = = 0 : break    path.append((s , a ) ) next_s = choose_probable(next_s_probs ) if next_s = = s : break s = next_s    for s , a in reversed(path ) : self.updater.estimate_q(s , a )    the simulated exploration policy could be completely different from the policy used for acting in the real environment .",
    "the simulated exploration policy is just used to sample states from the state space .",
    "the approximate model is used to estimate values of the sampled states .      prioritized sweeping@xcite schedules updates of values when one of their children changed its value .",
    "a priority queue is typically used for that .",
    "the amount of change in a child serves as a priority to process its parents .",
    "prioritized sweeping could be used to simulate exploration on its own or in combination with other methods .",
    "when used on its own , it is needed to have an approximate model that is able to return parents of a state .",
    "related unexplored states have to be also returned as possible parents .",
    "the depth of sweeping of unexplored states is limited by setting a minimal considered priority .",
    "the states where the amount of change is below this threshold are not swept .",
    "this will work unless the approximate model repeatedly predicts a reward in new unexplored states .",
    "when the model does not give information about parents , it is still possible to use prioritized sweeping in combination with another simulated exploration .",
    "it is just needed to correct the remembered parents when the optimistic model is corrected .",
    "otherwise a wrong parent would continue to be updated by optimistic values .",
    "remembered parents could be easily corrected when the used model produces a distribution of all possible next states .",
    "these next states are all possible children of a parent and its old children could be discarded .",
    "the experiments test how simulated exploration reduces the amount of needed real exploration .",
    "it is assumed that a suitable optimistic model of the environment could be used .      in my experiments ,",
    "i used the 3277-state grid world mentioned inside the _ _ reinforcement learning : a survey__@xcite .",
    "figure [ img_grid_maze ] shows the used environment .",
    "the environment is fully deterministic .",
    "i specified an initial suboptimal path inside the grid world .",
    "the suboptimal path gives a hint where the reward is in the unlimited state space .",
    "this allows to use the simulated exploration without optimistic assumptions about the reward .",
    "the start position of the agent is fixed to the top - right corner of the grid world .",
    "the aim to reduce the amount of exploration is most relevant when the start position is fixed . in that case , the state space used for acting is smaller than the whole available state space .      the used approximate model was composed as a combination two models : model based on observations and a model based on recent action effects .",
    "the * model based on observations * is a classical model that records frequencies of different outcomes for every state - action transition .",
    "the frequencies are used to estimate the probabilities of the outcomes .",
    "this model does not predict anything about yet unexplored states .",
    "the * model based on recent action effects * records the last seen effects of each action .",
    "it then predicts that a seen action will have the same effects in a new state .",
    "it also tries to be optimistic and ignores when an action does not have any effects on the state .",
    "that could happen when a wall is hit .",
    "so it does not remember any wall .",
    "the following code shows a code of such a model .",
    "caption = a model that tries to predict state changes .",
    "class recenteffectbasedmodel : def _ _",
    "init__(self , actions , initial_r ) : self.actions = actions",
    "self.initial_r = initial_r self.increments = [ none ] * len(actions )    def predict(self , s , a ) : `` ' ' `` predicts probabilities of next states and the returned reward . ' ' `` '' a_index = self.actions.index(a ) increment = self.increments[a_index ] if increment is none : return [ ] , 0    return [ ( s + increment , 1.0 ) ] , self.initial_r    def learn(self , s , a , r , next_s ) : `` ' ' `` remembers state changes from experience .",
    "it remembers the last seen increment for the given action . ' ' `` '' if rl.is_terminal(next_s ) : return    # walls are not learned by this model .",
    "# it is kept optimistic for the grid world .",
    "increment = next_s - s if increment !",
    "= 0 : a_index = self.actions.index(a ) self.increments[a_index ] = increment    the above shown code assumes that a state is represented by a single numeric variable .",
    "but an analogous approach could be used when the state is represented by a vector of multiple variables@xcite .",
    "the used initial suboptimal path should use every action at least once . that allows",
    "the model based on action effects to predict unexplored states in all directions . an alternative would be to do an additional small amount of exploration at the beginning of the task .",
    "the two used models provide different predictions about state transitions and rewards .",
    "the model based on observations predicts just already seen transitions and rewards .",
    "the model based on recent action effects tries to predict future state transitions and assumes no extra reward from them .",
    "the prediction based on recent action effects is wrong when a wall is hit , so it is considered to be less accurate .",
    "these two models are combined together to compose a final approximate model .",
    "the final model uses the most accurate prediction available .",
    "it asks the models for a prediction starting from the most accurate model .",
    "when the asked model knows nothing about the given transition , a less accurate model is asked .",
    "the code of the combined model follows .",
    "caption = a model that combines multiple approximate models .",
    "class combinedmodel : def _ _",
    "init__(self , models ) : `` ' ' `` accepts a given list of models that have decreasing accuracy . ' ' `` '' self.models = models    def predict(self , s , a ) : `` ' ' `` returns the most accurate available prediction for the given transition . ' ' `` '' for model in self.models : next_s_probs , r = model.predict(s , a ) if len(next_s_probs ) > 0 : return next_s_probs , r return [ ] , 0    def learn(self , s , a , r , next_s ) : for model in self.models : model.learn(s , a , r , next_s )      i compare exploration with optimistic initial values with two simulated explorations : trajectory sampling and prioritized sweeping of unexplored states",
    ".    the exploration with * optimistic initial values * assumes value 1.0 inside every state - action transition .",
    "this strategy is incentive enough to find an optimal policy in a deterministic environment .",
    "the initial state - action values for the other exploration algorithms were set to @xmath0 .",
    "such a low value does not serve as an incentive for exploration , but it remains possible to decrease it .",
    "it is important to be able to decrease the value of tried state - action transitions .",
    "it prevents the agent to get stuck .",
    "the simulated * trajectory sampling * was tested with three different maximal depths : 3 , 6 and 12 .",
    "the used simulated exploration policy selects a random action for every step .",
    "the sampled trajectory always starts from the current agent s state .",
    "the simulated exploration tries 10 trajectories per each real step .",
    "the prioritized * sweeping of unexplored * states uses parents supplied by the approximate model of the environment .",
    "our approximate model consists of multiple models , so it has to combine the parents predicted by the different models .",
    "i do this by letting the least accurate model predict some parents .",
    "the more accurate models are then used to prune the list of possible parents .",
    "the second least accurate model then predicts some other parents .",
    "the algorithm is depicted by code [ code_get_parents ] .",
    "caption = a method to return combined parents from multiple models .",
    "the used models have decreasing accuracy.,label = code_get_parents def get_parents(self , s ) : `` ' ' `` returns possible parents of the given state . ' ' `` '' parents = set ( ) for i , model in reversed(list ( enumerate(self.models ) ) ) : subparents = model.get_parents(s ) for parent in subparents : if is_possible_transition(parent , s , self.models[:i ] ) : parents.add(parent )    return parents    all mentioned explorations were aided with prioritized sweeping of explored states .",
    "i implemented the improved prioritized sweeping algorithm of wiering and schmidhuber@xcite .",
    "i measured the amount of exploration done under the different exploration algorithms .",
    "the exploration is finished when the shortest path is found and used for subsequent episodes .",
    "the initial path was 217 steps long .",
    "the shortest path was 203 steps long and all used algorithms were able to find it .",
    "the numbers of explored states and state - actions are given in table [ tab_results ] .",
    "= .2 cm    .the performance of different explorations .",
    "the columns report the number of steps until finding the final policy and the numbers of explored states and state - actions . the trajectory sampling used maximal depths 3 , 6 and 12 . [",
    "cols=\"<,>,>,>\",options=\"header \" , ]     it is interesting to note the relation between the number of explored states and the number of explored state - actions . the exploration equipped with simulated exploration tried on average about two actions in every visited state . on the other hand ,",
    "the exploration with optimistic initial values tried all four actions in almost every visited state .",
    "all measured simulated explorations had lower amount of exploration than the overly optimistic exploration with optimistic initial values .",
    "the trajectory sampling required the lowest amount of exploration to find the shortest path .",
    "but it does not guarantee that it will find the shortest path .",
    "the maximal depth of the sampled trajectory limits the space where to search for promising paths . that limits the amount of exploration done , but it also allows to miss an optimal path .    the prioritized sweeping of unexplored states performed very well .",
    "it required to explore 3.6 times less than the exploration with optimistic initial values . and",
    "the sweeping of unexplored states guarantees to find any possible promising path that exists under the used approximate model .",
    "the lower amount of real exploration was possible thanks to simulated exploration in an approximate optimistic model .",
    "these methods are not suitable for environments where it is impossible to learn an optimistic model of unexplored states of the environments .",
    "these methods risk that they will miss the optimal path when a pessimistic model is used .",
    "the used approximate model does not predict any unexplored reward . it was needed to start with an initial suboptimal path to show some reward .",
    "more sophisticated approximate models could also try to predict the reward .",
    "the using of an observed model for planning was pioneered by the dyna architecture by sutton@xcite .",
    "the dyna planning continues to update seen transitions with changes in the estimated state - action value .",
    "its extensions provide prioritized sweeping@xcite and a usage with linear function approximation to represent the environment@xcite .",
    "the idea to use optimistic models came from the book _ _ reinforcement learning : an introduction__@xcite .",
    "it discusses how optimistic models do not miss a promising path .",
    "it also proposes to use trajectory sampling on large tasks .",
    "many works touched the problem of exploration in large spaces .",
    "smart and kaelbling@xcite reduced the amount of exploration by using initial knowledge .",
    "they supplied the agent with example trajectories . during these trajectories ,",
    "the agent was driven by a human operator or by a piece of code .",
    "the example trajectories do not needed to be optimal .",
    "they just have to give hints where the reward is .",
    "envelope methods@xcite limit the amount of planning by restricting the state space of a known environment .",
    "they do not need to explore , because the environment is fully known , but they still needed to limit the number of states to consider .",
    "apprenticeship learning@xcite aims to prevent destructive exploration .",
    "a teacher first demonstrates the task .",
    "that demonstration serves to learn an approximate model of environment .",
    "an optimal policy is learned off - line in the model and tested later in the real environment .",
    "the new experience serves to improve the model and the cycle continues . the apprenticeship learning is not intended to propose new promising paths , so unexplored states are not considered in the model .",
    "an extension to the apprenticeship learning uses the learned approximate model to find a policy improvement direction@xcite .",
    "it could be viewed as a search for a promising direction where to steer the policy parameters .",
    "the needed amount of steering is then tested in the real environment .",
    "i proposed a new way how to do exploration in unlimited state spaces .",
    "it uses a simulated exploration and an optimistic model of the environment .",
    "it remains to be discovered how to learn optimistic models for a wide range of environments .",
    "they should provide optimistic predictions about unexplored states , but their optimism should be as low as possible .",
    "my experiments show the possibility to reduce the real exploration when given an optimistic model .",
    "i thank jefferson provost for releasing plastk ( python learning agent software toolkit ) .",
    "it allowed me to do pleasant experimenting with various environments .",
    "sutton , r. s. integrated architectures for learning , planning , and reacting based on approximating dynamic programming .",
    "_ proceedings of the seventh international conference on machine learning _ , 1990 ,",
    "p. 216 - 224 .",
    "sutton , r. s. , szepesvari , c. , geramifard , a. , bowling , m. dyna - style planning with linear function approximation and prioritized sweeping . _",
    "proceedings of the 24th conference in uncertainty in artificial intelligence _ , 2008 ,",
    "p. 528 - 536 .",
    "ivo danihelka is a phd student at the department of cybernetics at ctu in prague .",
    "previously , he was a software engineer working on billing systems , tv over the internet , games , data mining and multiple web sites",
    ". he still likes to read well written source code ."
  ],
  "abstract_text": [
    "<S> many reinforcement learning exploration techniques are overly optimistic and try to explore every state . </S>",
    "<S> such exploration is impossible in environments with the unlimited number of states . </S>",
    "<S> i propose to use simulated exploration with an optimistic model to discover promising paths for real exploration . </S>",
    "<S> this reduces the needs for the real exploration .    </S>",
    "<S> reinforcement learning , model - based , environment prediction , exploration . </S>"
  ]
}