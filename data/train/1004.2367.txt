{
  "article_text": [
    "gist ( game solver from ist ) is a tool for ( a )  qualitative analysis of _ turn - based probabilistic games ( @xmath1-player games ) _ with @xmath0-regular objectives , and ( b )  computing environment assumptions for synthesis of unrealizable specifications .",
    "the class of @xmath1-player games arise in several important applications related to verification and synthesis of reactive systems .",
    "some key applications are : ( a ) synthesis of stochastic reactive systems ; ( b ) verification of probabilistic systems ; and ( c ) synthesis of unrealizable specifications .",
    "we believe that our tool will be useful for the above applications",
    ".    * @xmath1-player games .",
    "* @xmath1-player games are played on a graph by two players along with probabilistic transitions .",
    "we consider @xmath0-regular objectives over infinite paths specified by parity , rabin and streett ( strong fairness ) conditions that can express all @xmath0-regular properties such as safety , reachability , liveness , fairness , and most properties commonly used in verification . given a game and an objective",
    ", our tool determines whether the first player has a strategy to ensure that the objective is satisfied with probability  1 , and if so , it constructs such a witness strategy .",
    "our tool provides the first implementation of qualitative analysis ( probability  1 winning ) of @xmath1-player games with @xmath0-regular objectives .",
    "* synthesis of environment assumptions .",
    "* the synthesis problem asks to construct a finite - state reactive system from an @xmath0-regular specification . in practice , initial specifications",
    "are often unrealizable , which means that there is no system that implements the specification .",
    "a common reason for unrealizability is that assumptions on the environment of the system are incomplete .",
    "the problem of correcting an unrealizable specification @xmath2 by computing an environment assumption @xmath3 such that the new specification @xmath4 is realizable was studied in  @xcite . the work  @xcite constructs an assumption @xmath3 that constrains only the environment and is as weak as possible .",
    "our tool implements the algorithms of  @xcite .",
    "we believe our implementation will be useful in analysis of realizability of specifications and computation of assumptions for unrealizable specifications .",
    "we first present the basic definitions of games and objectives .",
    "* game graphs . * a _ turn - based probabilistic game graph _ ( _ @xmath1-player game graph _ ) @xmath5 consists of a directed graph @xmath6 , a partition @xmath7 , @xmath8,@xmath9 of the finite set @xmath10 of states , and a probabilistic transition function @xmath11 : @xmath12 , where @xmath13 denotes the set of probability distributions over the state space  @xmath10 .",
    "the states in @xmath14 are the _",
    "player-@xmath15 _ states , where player  @xmath15 decides the successor state ; the states in @xmath8 are the _ player-@xmath16 _ states , where player  @xmath16 decides the successor state ; and the states in @xmath17 are the _ probabilistic _ states , where the successor state is chosen according to the probabilistic transition function  @xmath11 .",
    "we assume that for @xmath18 and @xmath19 , we have @xmath20 iff @xmath21 . the _ turn - based deterministic game graphs _ ( _ 2-player game graphs _ ) are the special case of the @xmath1-player game graphs with @xmath22",
    ".    * objectives . *",
    "we consider the three canonical forms of @xmath0-regular objectives : streett and its dual rabin objectives ; and parity objectives .",
    "the streett objective consists of @xmath23 request - response pairs @xmath24 where @xmath25 denotes a request and @xmath26 denotes the corresponding response ( each @xmath25 and @xmath26 are subsets of the state space ) . the objective requires that if a request @xmath25 happens infinitely often , then the corresponding response must happen infinitely often .",
    "the rabin objective is its dual .",
    "the parity ( or rabin - chain objective ) is the special case of streett objectives when the set of request - responses @xmath27 form a chain .",
    "* qualitative analysis . *",
    "the qualitative analysis for @xmath1-player games is as follows : the input is a @xmath1-player game graph , and an objective @xmath3 ( streett , rabin or parity objective ) , and the output is the set of states such that player  0 can ensure @xmath3 with probability  1 . for detailed description of game graphs , plays , strategies , objectives and",
    "notion of winning see  @xcite .",
    "we focus on qualitative analysis because : a )  in applications like synthesis the relevant analysis is qualitative analysis : the goal is to synthesize a system that behaves correctly with probability  1 ; ( b )  qualitative analysis for probabilistic games is independent of the precise probabilities , and thus robust with imprecision in the exact probabilities ( hence resilient to probabilistic modeling errors ) .",
    "the qualitative analysis can be done with discrete graph theoretic algorithms .",
    "thus qualitative analysis is more robust and efficient , and our tools implements these efficient algorithms .",
    "our tool presents a solution of the following two problems .    *",
    "qualitative analysis of @xmath1-player games . *",
    "our tool presents the first implementation for the qualitative analysis of @xmath1-player games with streett , rabin and parity objectives .",
    "we have implemented the linear - time reduction for qualitative analysis of @xmath1-player rabin and streett games to @xmath28-player rabin and streett games of  @xcite , and the linear - time reduction for @xmath1-player parity games to @xmath28-player parity games of  @xcite . the @xmath28-player rabin and streett games",
    "are solved by reducing them to the @xmath28-player parity games using the lar ( latest appearance records ) construction  @xcite .",
    "the @xmath28-player parity games are solved using the tool pgsolver  @xcite .    * environment assumptions for synthesis . * our tool implements a two - step algorithm for computing the environment assumptions as presented in  @xcite .",
    "the algorithm operates on the game graph that is used to answer the realizability question .",
    "first , a safety assumption that removes a minimal set of environment edges from the graph is computed .",
    "second , a fairness assumption that puts fairness conditions on some of the remaining environment edges is computed .",
    "the problem of finding a minimal set of fair edges is computationally hard  @xcite , and a reduction to @xmath1-player games was presented in  @xcite to compute a locally minimal fairness assumption .",
    "the details of the implementation are as follows : given an ltl formula @xmath29 , the conversion to an equivalent deterministic parity automaton is achieved through goal  @xcite .",
    "our tool then converts the parity automaton into a @xmath28-player parity game by splitting the states and transitions based on input and output symbols .",
    "our tool then computes the safety assumption by solving a safety model - checking problem .",
    "the computation of the fairness assumption is achieved in the following steps :    convert the parity game with fairness assumption into a @xmath1-player game .",
    "solve the @xmath30-player game ( using our tool ) to check whether the assumption is sufficient ( if so , go to the previous step with a weaker fairness assumption ) .    the synthesized system is obtained from a witness strategy of the parity game .",
    "the flow is illustrated in figure  [ fig : example ] .",
    "( -1.5,0)(10,2.7 )    & & + & & +    we illustrate the working of our tool on a simple example shown in figure  [ fig : worked_example ] consider an ltl formula @xmath31 , where @xmath32 and @xmath33 denote globally and eventually , respectively .",
    "the propositions ` grant ` and ` cancel ` are abbreviated as ` g ` and ` c ` , respectively . from @xmath3",
    "our tool obtains a deterministic parity automaton ( figure  [ fig : parity_automaton ] ) that accepts exactly the words that satisfies @xmath3 .",
    "the parity automaton is then converted into a parity game . in figure",
    "[ fig : synthesis_game ] , @xmath34 represents player  0 states and @xmath35 represents player  1 states .",
    "it can be shown that in this game no safety assumption required .",
    "we illustrate how to compute a locally minimal fairness assumption .",
    "given an fairness assumption on edges , our tool reduces the game with the assumption to a @xmath1-player parity game ( see details in  @xcite ) .",
    "if the initial state in the @xmath1-player game is in winning with probability  1 for player  0 , then the assumption is sufficient .",
    "figure  [ fig : probabilistic_game ] illustrates the @xmath1-player game obtained with the fairness assumption on the edge @xmath36 .",
    "the @xmath37 state is the probabilistic state with uniform distribution over its successors .",
    "the assumption on this edge is the minimal fairness assumption for the example .",
    "our tool then converts this game back into an automaton to obtain the environment assumption as an automaton(figure  [ fig : environment_assumption ] ) .",
    "this assumption is equivalent to the formula @xmath38 . from a witness strategy in figure",
    "[ fig : probabilistic_game ] our tool obtains the system that implements the specification with the assumption ( figure  [ fig : transducer_system ] ) .",
    "* performance of gist . *",
    "our implementation of reduction of @xmath1-player games to @xmath28-player games is linear time and efficient , and the computationally expensive step is solving @xmath28-player games . for qualitative analysis of @xmath1-player games , gist  can handle game graphs of size that can be typically handled by tools solving @xmath28-player games .",
    "typical run - times for qualitative analysis of @xmath1-player parity games of various sizes are summarized in table  [ table : runtimes ] .",
    "the games used were generated using the benchmark tools of pgsolver and then converting one - tenth of the states into probabilistic states .",
    "[ table : runtimes ]    .runtimes for solving @xmath1-player parity games [ cols=\"^,^,^,^,^ \" , ]     in the case of synthesis of environment assumptions , the expensive step is the reduction of ltl formula to deterministic parity automata .",
    "our tool can handle formulas that are handled by classical tools for translation of ltl formula to deterministic parity automata .",
    "* other features of gist . *",
    "our tool is compatible with several other game solving and synthesis tools : gist is compatible with pgsolver and goal .",
    "our tool provides a graphical interface to describe games and automata , and thus can also be used as a front - end to pgsolver to graphically describe games .",
    "1    k.  chatterjee . .",
    "phd thesis , uc berkeley , 2007 .",
    "k.  chatterjee , l.  de  alfaro , and t.  a. henzinger .",
    "the complexity of stochastic rabin and streett games . in _ icalp _ , 2005 .",
    "k.  chatterjee , t.  a. henzinger , and b.  jobstmann .",
    "environment assumptions for synthesis . in _ concur _ , 2008 .",
    "k.  chatterjee , m.  jurdziski , and t.a .",
    "henzinger . quantitative stochastic parity games . in _ soda _ , 2004 .",
    "y.  gurevich and l.  harrington .",
    "trees , automata , and games . in _ stoc _",
    ", 1982 .",
    "m.  lange and o.  friedmann .",
    "the pgsolver collection of parity game solvers .",
    "technical report , institut fr informatik , ludwig - maximilians - universitt , 2009 .    the jung framework  development team .",
    ": java universal network / graph framework .",
    "http://jung.sourceforge.net .",
    "y.  tsay , y.  chen , m.  tsai , w.  chan , and c.  luo . goal extended : towards a research tool for omega automata and temporal logic . in _ tacas _ , 2008 .",
    "gist  is available for download at http://pub.ist.ac.at/gist  for unix - based architectures .",
    "all the libraries that gist  uses are packaged along with it .",
    "* language , tools and installation . *",
    "gist  is written in scala and it uses several other tools . for the graphical interface to draw game graphs and automata it uses the jung library  @xcite for graph layout algorithms .",
    "for translation of an ltl formula to a deterministic parity automata it uses goal  @xcite . the solution of @xmath28-player parity games is achieved by using pgsolver  @xcite . for compilation and installation : ( a ) an installation of the scala compiler and runtime environment is required ; ( b ) the pgsolver build process requires an ocaml compiler to be installed ; and ( c ) goal and jung require a java runtime environment to be installed .      1",
    ".   module * newgames * mainly consists of the classes for probabilistic @xmath0-regular games , i.e.  games with bchi , cobchi , rabin , streett and parity objectives .",
    "each of these classes contains routines for the reduction of the @xmath1-player version to the @xmath28-player version which preserves the probability 1 winning region of player 1 .",
    "each of these classes also returns a witness strategy for the player as required .",
    "2 .   module * specification * consists of classes implementing the specifications for the synthesis problem , i.e. ltl formulae , bchi automata and parity automata .",
    "the class for ltl formulae contains a routine to convert ltl formulae into an equivalent nondeterministic bchi automata and the class for bchi automata has a routine for converting it into a deterministic parity automaton .",
    "the parity automata class can generate the synthesis game ( by splitting transitions ) for the automaton as described in  @xcite .",
    "3 .   module * synthesis * contains the classes relevant to the process of synthesis .",
    "the class for synthesis games contains routines ( a )  to compute transducers implementing the specification ; ( b )  to compute minimal safety assumption and locally minimal fairness assumption in case of an unrealizable specification ; ( c )  to check whether user - specified assumptions are sufficient to make the specification realizable ; and ( d )  to get the assumptions as a streett automaton .",
    "modules * gui * and * cui * contain classes for graphical and text based user interfaces .",
    "most of the functionality in the * cui * module is contained in the * console * class , which interprets a command line .",
    "the * gui * module contains forms and windows to display various automata and games ; and provide an interface for the various operations on them .",
    "module * basic * contains the definitions which are needed by all other packages , namely , the classes for alphabet , symbols and generic automata .        in this section",
    "we describe the usage of the graphical and text - based interface of the tool . + * format of files . *",
    "the file format used by the tool is based on the format used by goal .",
    "the format for games and automata structures is presented below :    .... < structure label - on=\"transition \" type=[\"game\"|\"fa \" ] >    < alphabet type=\"propositional \" >      < prop type=[\"input\"|\"output\"]>text</prop >      ...    < /alphabet >    < stateset >      < state sid=\"numeric \" >        [ < player>[0|1|-1]</player > ]        [ < label > text</label > ]      < /state >      ...",
    "< /stateset >    < transitionset >      < transition tid=\"numeric \" >        < from > numeric(state id)</from >        < to > numeric(state id)</to >        < read > text(symbol)</read >",
    "< /transition >      ...",
    "< /transitionset >    < initialstateset >      < stateid > numeric</stateid >    < /initialstateset",
    ">    < acc type=\"[buchi|parity|rabin|streett ] \" >      < accset > % ony one set for buchi acceptance condition .        < stateid > numeric(state id)</stateid >        ...",
    "< /accset >      < accset > % multiple sets for parity acceptance condition .",
    "% one for each priority        < stateid > numeric(state id)</stateid >        ...",
    ">      < accset > % multiple sets for rabin and streett acceptance conditions .               % different format from the other conditions .",
    "< e >          < stateid > numeric(state id)</stateid >          ...",
    "< /e >        < f >          < stateid > numeric(state id)</stateid >          ...",
    "< /f >      ...",
    "< /accset >    < /acc",
    "> < /structure > ....    * graphical interface .",
    "* the graphical interface for gist  consists of a window for each kind of game graph , automata , and formula the tool handles .",
    "when gist is invoked , a window is shown with buttons for each kind .",
    "a window for a specific kind contains buttons that represent relevant actions that can be performed .",
    "there are also generic options such as saving and loading .    for automata and game graphs",
    ", the window contains an area in which the graph is laid out visually .",
    "the layout can be changed by dragging the vertices and the edges of the graph .",
    "gist  uses the layout algorithms of jung to automatically layout the graph .",
    "the layout algorithms can be chosen by right - clicking on the window and selecting * layout * from a pop - up menu that appears .",
    "also , sets of vertices or edges can be highlighted for other operations ( such as finding sufficiency of assumptions containing these edges ) by choosing * highlight mode * on the pop - up menu .",
    "the tool also includes interfaces for building automata and games graphically . in these windows",
    ", one can insert states or edges into a structure by selecting the appropriate mode from the pop - up menu .",
    "when an edge is created , the user can label the edge appropriately .",
    "the alphabet for the symbols ( for labeling edges ) must be set before the edges are created . states and edges can also be deleted using the * delete mode*.    * text - based interface . *",
    "the text - based interface for gist  is an interactive prompt .",
    "the user can define and use variable for any object .",
    "variables need not be declared before use .",
    "all variable names need to begin with a $ .",
    "the syntax for the statements is defined below .    ....",
    "variable : = $ [ a - za - z0 - 9 ] * statement : =    variable                --prints the value of the variable               | variable = variable     --assignment               | variable = expression   --assignment expression : = object action object : =    \" ltl \" | \" buchiautomaton \" | \" parityautomaton \"                 | \" synthesisgame \" | \" streettautomaton \" | \" paritygame \"                 | \" rabingame \" | \" streettgame \" action : = readfile ... | writefile ... | help | ... ....    the  action \" as seen in the above syntax definition varies depending upon the object .",
    "the * help * action for any object displays all the other actions available for this object along with an explanation .",
    "all objects which represent games have the following actions : * winningregion * , * cooperativewinningregion * , and * todeterministicgame*. the action * winningregion * takes an argument , either 0 or 1 ( for a player ) , and computes the set of states from which the player wins with probability  1 .",
    "the action * cooperativewinningregion * is invoked only for @xmath28-player games , and it computes the set of states such that there is a path to satisfy the objective of player  0 .",
    "the action * todeterministicgame * is invoked on @xmath1-player games and it returns a @xmath28-player game in which probability  1 winning of player 0 is preserved .",
    "in addition , the action * winningstrategy * computes the winning strategy of each player in @xmath28-player games , and the probability  1 winning strategy in @xmath1-player games .",
    "the objects for bchi automata have an action * toparityautomaton * to convert it into equivalent deterministic parity automata .",
    "similarly , the objects for ltl formulae and parity automata have actions to convert them into nondeterministic bchi automata and synthesis games respectively .",
    "the objects for synthesis games have actions related to synthesis and computation of environment assumptions .",
    "the text - based interface for gist  is also available online at http://pub.ist.ac.at/gist .",
    "figure  [ fig : text_interface ] shows the screenshot for the text - interface with input and output for example  1 ( described in the following subsection ) .",
    "figure  [ fig : web_interface ] shows the screenshot of the web interface for a similar example .",
    "in this section , we present two examples to illustrate the usage of gist .",
    "we have chosen small examples for the simplicity of the presentation to illustrate the usage of gist .",
    "these examples demonstrate the usage of gist  for computation of environment assumptions for synthesis and uses solution of @xmath1-player games . in these examples , we compute the assumptions for two unrealizable specifications given in ltl .",
    "both the specifications are about request - response systems and are chosen to illustrate safety and fairness assumptions respectively .",
    "_ example 1 .",
    "_ consider a request - response system in which there are two inputs , ` request ` and ` cancel ` , and one output ` grant ` .",
    "now , consider the specification @xmath39 .",
    "this specification is unrealizable : any input in which both ` request ` and ` cancel ` are set at the same time does not have an output which satisfies the specification .",
    "we can compute an environment assumption for this specification using gist .",
    "intuitively , we would want an assumption that says ` request ` and ` cancel ` must not be set at the same time provided the specification was not already violated earlier .",
    "we show that the assumption can be computed automatically by gist .",
    "to compute the assumption using gist , we select ltl formula from the main window of options and then enter the formula above , specifying the inputs and outputs .",
    "this formula is then converted into a nondeterministic bchi automaton and then to a deterministic parity automaton , and finally to a synthesis game . in this game",
    ", we attempt to compute the safety assumption .",
    "the safety assumption is highlighted ( green arrows in a box ; ( 0,4 ) and ( 2,7 ) ) as shown in figure  [ fig : safety_assumption ] . as shown in figure  [ fig : safety_assumption ] , the safety assumption includes all the edges where ` request ` and ` cancel ` are set at the same time .",
    "but , if there has been an instance of a ` request ` not being granted already , then there is no restriction on the inputs .",
    "this is the same assumption as was expected intuitively .",
    "now , we can obtain a synthesis game where the safety assumption is enforced . in this new game , if the fairness assumption is computed the output shows no fairness assumption is necessary .",
    "a transducer that implements the modified specification can be obtained from the solution of this game .",
    "_ example 2 .",
    "_ consider the request - response system as in example 1 .",
    "but , with the specification @xmath40 .",
    "this specification says that we should have infinitely many grants and that at every step , if ` cancel ` is set , then there should be no grant at that step .",
    "this specification is also unrealizable as any input where the ` cancel ` is always set has no acceptable output .",
    "we can see that if ` cancel ` is not set always after a point , then the specification becomes realizable .",
    "this condition can be computed using gist following the same steps as in the above example : first the tool finds that no safety assumption is necessary , and then it computes the fairness assumption in the synthesis game .",
    "the fairness assumption is computed internally by reduction to @xmath1-player games .",
    "the fairness assumption is highlighted ( by green arrow in a box ; ( 0,4 ) ) in the screenshot figure  [ fig : fairness_assumption ] .",
    "the computed assumption can be interpreted as follows : the highlighted edge must be taken infinitely often if the source vertex of the edge is visited infinitely often . translating this into propositions ,",
    "it means that at any step , ` cancel ` can not be set forever in the future ."
  ],
  "abstract_text": [
    "<S> gist is a tool that ( a ) solves the qualitative analysis problem of turn - based probabilistic games with @xmath0-regular objectives ; and ( b ) synthesizes reasonable environment assumptions for synthesis of unrealizable specifications . </S>",
    "<S> our tool provides the first and efficient implementations of several reduction - based techniques to solve turn - based probabilistic games , and uses the analysis of turn - based probabilistic games for synthesizing environment assumptions for unrealizable specifications . </S>"
  ]
}