{
  "article_text": [
    "counting the number of self - avoiding walks on a regular lattice is a fundamental problem in combinatorics and statistical physics .",
    "a _ self - avoiding walk _ ( saw ) is a path in a lattice where each step goes from a lattice point to an adjacent point in the lattice , and where a previously visited point can not be visited again .",
    "the saw enumeration problem is of importance in physics because a saw can be used to model the conformation of a polymer , where two monomers are forbidden to occupy the same location ( the excluded - volume principle ) .",
    "furthermore , this problem has been a challenge to mathematicians and physicists alike , because counting the exact number of saws is difficult .",
    "the number @xmath0 of saws of length @xmath1 grows quickly with @xmath1 , asymptotically as @xmath4 here , the factor @xmath5 dominates ; it depends on the lattice , e.g. @xmath6 for the 3d cubic lattice .",
    "the factor @xmath7 is a relatively small correction to this , but knowledge of the exponent @xmath8 is very useful since it is a lattice - independent ( universal ) exponent .",
    "a straightforward attack on the problem that generates all saws can only reach a limited length ( currently about @xmath9 for the 3d cubic lattice ) , because of the large number of saws .",
    "for most lattices , the value of the _ connective constant _",
    "@xmath10 is known only in approximation , with a few exceptions such as the honeycomb lattice in 2d , with @xmath11  @xcite . for all regular two - dimensional lattices ,",
    "the exponent @xmath8 is believed ( but not proven ) to be @xmath12  @xcite ; its value in three dimensions is not known exactly and is estimated at @xmath13 .",
    "the history of counting saws goes back at least six decades , to a paper by orr  @xcite from 1947 , who gave the counts @xmath14 for the 3d cubic lattice .",
    "the number of steps in an enumeration for this lattice was successively increased by fisher and sykes  @xcite , guttmann  @xcite , macdonald et al .",
    "@xcite , and clisby , liang , and slade  @xcite , who reached @xmath15 .",
    "recently , we further increased the number of steps to @xmath16 by the length - doubling method  @xcite , see section  [ sec : lengthdoubling ] , giving @xmath17 . for the 2d square lattice ,",
    "the current record is held by jensen  @xcite , with @xmath18 . for more detail on many aspects of the saw problem ,",
    "see the monograph by madras and slade  @xcite .",
    "the main goal of this article is to present an algorithm and its implementation for counting saws on a regular lattice , which is based on the length - doubling method  @xcite we have published previously . essentially , this method counts the number of saws of the double length @xmath19 by taking statistics from the @xmath20 subsets of sites visited by each saw of length @xmath1 , thereby reducing the computational effort from @xmath21 to @xmath22 .",
    "we also discuss the use of symmetry to speed up the computation , and the use of parallelism .",
    "our presentation is accompanied by a computer program sawdoubler , available from http://www.staff.science.uu.nl/~bisse101/saw/ under the gnu lgpl license .",
    "the program can in principle handle any regular lattice , and provides a sample implementation for the 3d cubic lattice .",
    "it is relatively straightforward to adapt the program to other lattices , by replacing the program file with functions specifying the lattice , while keeping the file with all the counting functions and data structures unchanged . for brevity and ease of illustration",
    ", we will often use examples from the 2d square lattice in this article .",
    "a saw of length @xmath1 on a regular lattice starting in the origin can be written as a sequence @xmath23 with @xmath24 , meaning that we walk from the origin @xmath25 to lattice site @xmath26 , and so on , until we reach the end point @xmath27 .",
    "figure  [ fig : walk2d_10 ] illustrates a walk of length 10 on the square lattice in 2d .     on the 2d square lattice .",
    "the walk starts in the origin ( middle of the picture ) . ]",
    "the length - doubling method is based on combining two walks of length @xmath1 into one walk of length @xmath19 .",
    "let @xmath28 be two saws . we can start a walk from the end point @xmath27 of @xmath29 in the reverse direction of @xmath29 towards the origin and then continue to walk in the direction of the end point @xmath30 of @xmath31 .",
    "this yields a walk of length @xmath19 .",
    "if we translate the resulting walk by @xmath32 , we have a walk of length @xmath19 starting in the origin .",
    "the result of combining two saws in this way may be self - avoiding or not , depending on the presence of an intersection point @xmath33 .",
    "let @xmath34 be the set of pairs of saws @xmath35 that both pass through the lattice point @xmath33 .",
    "then @xmath36 because every pair @xmath35 of saws of length @xmath1 can be used to construct a saw of length @xmath19 , except if they both pass through a lattice point @xmath33 .",
    "applying the inclusion ",
    "exclusion principle from combinatorics  @xcite to compute the number of elements of a union of sets from their intersections yields the length - doubling formula @xmath37 where @xmath38 is a subset of the lattice points and @xmath39 the number of saws that pass through all elements of @xmath38 .",
    "the numbers @xmath39 can be obtained by creating all saws of length @xmath1 ( but not those of length @xmath19 ) and maintaining a bookkeeping of all the possible sets @xmath38 encountered and their number of saws @xmath39 .",
    "the implementation of the length - doubling method poses two main challenges .",
    "first , all sets @xmath38 have to be generated and , because of their large number , be stored efficiently or only part of the sets should be stored at the same time ; the data structure used in our implementation is discussed in sec .",
    "[ sec : storage ] .",
    "second , the summation over these sets as given in eq .",
    "( [ eqn : doubling ] ) has to be performed ; this is discussed in sec .",
    "[ sec : algo ] .",
    "we then also pay attention to how symmetry properties of the saws can be exploited in sec .",
    "[ sec : symmetry ] .",
    "our implementation sawdoubler is tested with respect to time and memory scaling in sec .",
    "[ sec : experiments ] .",
    "we draw conclusions and discuss future extensions in sec .",
    "[ sec : conclusions ] .",
    "since all saws start at the origin , we do not need to store the starting point .",
    "furthermore , since the length - doubling method only cares about whether walks of length @xmath1 intersect , the order of the sites visited in a walk is irrelevant . a walk can therefore be written as a set @xmath40 note that the same set of points @xmath41 can result from several different saws .",
    "the number of lattice sites that can be reached by a saw of length @xmath1 is finite , and hence the sites can be numbered by a finite numbering @xmath42 , irrespective of the dimensionality of the lattice . for the 2d square lattice , for instance , only the @xmath43 points @xmath44 with @xmath45",
    "can be reached . a suitable numbering",
    "could be @xmath46 .",
    "the _ canonical numbering _",
    "@xmath47 for the 2d square lattice is defined by site number @xmath48 , where @xmath49 is the width of the smallest square lattice enclosing all reachable points .",
    "this leads to a numbering @xmath50 , where not all sites are reachable . in section",
    "[ sec : symmetry ] , a different numbering will be presented which facilitates exploitation of symmetry . using a numbering , a walk to be stored",
    "can be concisely represented by @xmath51 note that the sites of @xmath41 are now ordered by increasing site number , and not by the order in which the sites are visited .",
    "our aim is to store all saws of length @xmath1 in a data structure that requires as little memory as possible , but still enables operations such as finding all subsets @xmath38 of a particular walk @xmath41 .",
    "we could store all saws simply as lists of length @xmath1 , but this would cause a lot of repetition , since saws are often similar to each other .",
    "we choose a tree as our data structure , with a special extra site as the root , with sites as nodes , and with parent  child relations defined by @xmath52 for each walk @xmath53 .",
    "the parent of @xmath54 is the root .",
    "this tree data structure is illustrated by fig .",
    "[ fig : tree ] .",
    "note that the same site number may occur several times in the tree .",
    "the tree is constructed by consecutively adding the saws to be stored , each time checking whether the lower numbered part @xmath55 already exists in the tree when adding site @xmath56 .",
    "if so , no new nodes need to be added for this part .",
    "only when the new walk deviates from the tree , new nodes are introduced for the remainder @xmath57 of the walk .     on the 2d square lattice .",
    "each tree node points to its parent .",
    "the root node is denoted by 0 .",
    "the site numbering is the same as in fig .",
    "[ fig : symmnumbering ] .",
    "the walk @xmath29 from @xmath58 through @xmath59 , @xmath60 , @xmath61 , to @xmath62 corresponds to the walk @xmath63 in this site numbering , and is stored as the set @xmath64 in the tree .",
    "this tree is used for the computation of @xmath39 for all sets of sites @xmath38 that have 29 as their highest site number . only walks that contain 29 are stored , and only their sites @xmath65 . ]    at every node of the tree , the following information is stored :    * @xmath66 , site number of the node ; * @xmath67 , number of saws with this node as highest site ; * @xmath68 , first child ; * @xmath69 , next sibling ; * @xmath70 , parent ; * @xmath71 , a time stamp ( not used while building the tree ) ; * @xmath72 , next node with the same site number ( not used while building the tree ) .",
    "the variable @xmath66 can be stored using a standard ( 32-bit ) integer , as site numbers remain small , growing for instance as @xmath73 for the 2d square lattice .",
    "the variable @xmath67 initially ( i.e. , immediately after building the tree ) contains the count of the number of saws with this node as highest site .",
    "if all walks have the same length @xmath1 , the initial @xmath67 is nonzero only at the leaves of the tree .",
    "the initial counts are modified during the computation by adding counts together so that the largest counts in the tree thus may become of order @xmath74 .",
    "therefore , the variable @xmath67 needs a 64-bit integer .",
    "different walks visiting the same sites , but in a different order , will have the same set @xmath41 , and hence the initial count can be larger than one . to enable storing walks of different lengths in the same tree , the variable @xmath67 is also present in nonleaf nodes . in the length - doubling method , counts @xmath39",
    "are squared , cf .",
    "( [ eqn : doubling ] ) , and hence a few extra long ( 128-bit ) integer variables such as @xmath2 must be used in order to match the size of the counts , but such variables are not needed in the nodes of the tree .    the variables @xmath68 , @xmath69 , and @xmath70 are needed for traversing the tree .",
    "they point to other nodes in the tree and are set to a dummy if no respective child , sibling , or parent exists .",
    "finding the parent of a node is an immediate @xmath75 operation . finding all children",
    "requires finding the first child using @xmath68 , and then following the linked list of siblings implemented by @xmath69 . in our implementation , the siblings are ordered by increasing site number , which yields a rather modest savings in computation time when processing a new sibling .",
    "the savings are obtained in case the new sibling is already present in the sibling list ; otherwise , the list has to be searched until the end .",
    "ordering by increasing site number gives preference to lower - numbered sites , and these are closer to the origin and hence have more likely been encountered already .",
    "two variables @xmath71 and @xmath72 are added to the node to facilitate operations of the counting algorithm , algorithm  [ algo : correct ] , see section  [ sec : correction ] .",
    "the variable @xmath71 represents a time stamp , which records when we pass a certain node while traversing the tree in the counting algorithm .",
    "this variable needs a 64-bit integer for storage .",
    "sometimes , we need to connect a set of nodes in the tree with the same site number @xmath76 into a linked list . this list is implemented using the variable @xmath72 .",
    "the total required storage per node is one 32-bit integer and six 64-bit integers , which amounts to 52 bytes per tree node .",
    "the variables @xmath67 , @xmath71 , and @xmath72 may change during the counting algorithm , but the tree structure as defined by @xmath66 , @xmath68 , @xmath69 , @xmath70 remains the same after the tree has been built by the saw - creating algorithm , algorithm  [ algo : go ] , see section  [ sec : go ] .",
    "after the tree has been created , we will only use the variable @xmath70 , and the variables @xmath68 and @xmath69 are not used any more ; in contrast , @xmath71 and @xmath72 are not used during creation of the saws .",
    "therefore , some space can be saved by storing @xmath68 and @xmath71 in one field , and the same for @xmath69 and @xmath72 . in our exposition",
    ", we will use the original field names , but in our program sawdoubler , we save the memory of two 64-bit integers per node , reducing the required size for the tree to 36 bytes per node .    the width and the depth of the tree",
    "are influenced by the numbering of the lattice sites .",
    "a careful numbering will limit the number of children of each node , especially near the root , and this will enhance the reuse of initial parts of walks in the tree . a suitable way to do",
    "this is to number the sites by increasing euclidean distance from the origin . for the 2d square lattice ,",
    "this limits the number of children of the root to four , whereas an arbitrary numbering could have a much larger number of children and hence would lead to little reuse .",
    "algorithm  [ algo : go ] gives the function go , which creates all saws of length @xmath1 by recursively exploring all unvisited adjacent lattice sites of the current site @xmath77 .",
    "when a saw of length @xmath1 has been created , it is converted to site numbers , sorted in increasing order , and inserted into the tree data structure .",
    "the walk @xmath78 is stored in the array @xmath79 , with @xmath80 = { \\mathbf{r}}_j$ ] for @xmath81 .",
    "the initial call of the function is go@xmath82 , where the whole array @xmath83 has been initialised to false , and the tree contains only the special root node .",
    "@xmath84 @xmath85 sort@xmath86 insert@xmath87 @xmath88 go@xmath89 @xmath90      algorithm  [ algo : correct ] gives the function correct , which calculates all correction terms @xmath91 of saws of length @xmath1 passing through a set @xmath38 of lattices sites , by recursively expanding the set @xmath38 to a superset @xmath92 .",
    "the initial call of the function is correct(@xmath93 ) , where @xmath94 has been filled by algorithm  [ algo : go ] with all saws of length @xmath1 .",
    "the algorithm works as follows .    to expand the current set @xmath38",
    ", the algorithm first finds the maximum site number @xmath95 for the active tree nodes .",
    "a tree node is called _ active _ if its walk count contributes to the computation of the current @xmath39 . to access all active nodes with the same site number , the algorithm uses a bin data structure",
    ". this structure stores the active nodes with site number @xmath76 together in a bin @xmath96 $ ] ; each bin is implemented as a linked list . at the start of the whole computation ,",
    "all nodes with a nonzero count are active .",
    "active nodes have the current @xmath97 of the algorithm as a time stamp .",
    "use of such a global clock makes it easy to render many nodes inactive by just updating the time variable .",
    "the variable @xmath97 equals the number of different sets @xmath38 created so far .    as a first contribution ,",
    "the set @xmath38 , which does not contain @xmath95 , is expanded by smaller sites than @xmath95 .",
    "let @xmath98 be an active node with site number @xmath95 .",
    "if its parent @xmath99 is already active , the count of @xmath98 must be added into that of @xmath99 , in order to give the total number of walks that pass through all sites of @xmath38 and have the path from the root to @xmath99 as their lowest - numbered part .",
    "if the parent is not active , its count should simply be replaced by that of @xmath98 and it will become active .",
    "after that , the function correct is recursively called to handle all supersets @xmath100 with @xmath101 .",
    "the result is added to @xmath102 , with a positive sign since the size of @xmath38 is unaltered , cf .",
    "the sign @xmath103 in eqn .",
    "( [ eqn : doubling ] ) . following the call ,",
    "all node counts are restored to the situation at the start of the function , using an undoing mechanism , details of which we omit for the sake of brevity .    as a second contribution ,",
    "the set @xmath38 is expanded by smaller sites than @xmath95 and also @xmath95 itself is included .",
    "all walks that do not contain @xmath95 must now be discarded , which is done by incrementing the time , emptying the bins of active nodes , making the parents @xmath99 active , inserting them into bins , and stamping them with the new time . also here , the function correct is recursively called , but now the result is subtracted as the sign @xmath103 has changed , due to the expansion of @xmath38 by one site . in our implementation , we also use a time stamping mechanism for the bins , making emptying all bins a cheap operation .    finally , we collect and sum the squares of the counts for the case where @xmath95 is the final site added to @xmath38 , i.e.",
    ", the site with minimum site number of @xmath38 , and the set @xmath38 is not expanded further .",
    "@xmath104 @xmath105 \\neq \\emptyset \\}$ ] @xmath102    @xmath106 contribution for @xmath100 with @xmath101 @xmath107 @xmath108",
    "@xmath109 insert@xmath110 @xmath111 @xmath112 restore the counts    @xmath106 contribution for @xmath113 @xmath114 @xmath96 \\gets \\emptyset$ ] @xmath107",
    "@xmath109 insert@xmath110 @xmath111 @xmath115 ) restore the counts    @xmath106 contribution for @xmath116 @xmath117    @xmath102",
    "for the 2d square lattice , the number of saws that end in a point @xmath118 is the same as the number ending in @xmath119 because of symmetry , and similarly it is the same as the number for @xmath120 , @xmath121 , @xmath122 , @xmath123 , @xmath124 , and @xmath125 .",
    "thus , we have 8-fold symmetry which we should exploit for an efficient computation of @xmath0 . for the 3d cubic lattice ,",
    "the potential gain is even larger , since we have 48-fold symmetry , obtained by composing the 8 reflections @xmath126 with the 6 permutations of the variables @xmath127 .",
    "the symmetry operations of a lattice form a group @xmath128 , where every symmetry operation @xmath129 has an inverse symmetry operation @xmath130 , and where there is an identity operation @xmath131 , and the operations are associative . in general , the group need",
    "not be commutative .",
    "we denote the _ order _ , i.e. the number of elements , of group @xmath128 by @xmath132 . for the 2d square lattice ,",
    "the group is isomorphic to the group of _ signed @xmath133 permutation matrices _ , and its order is 8 .    for a given lattice point @xmath33 , the symmetry operations that leave it invariant form a subgroup @xmath134 of @xmath128 , defined by @xmath135 by lagrange s theorem  @xcite , the order @xmath136 of the subgroup divides the order @xmath137 of @xmath128 .",
    "furthermore , the symmetry number of @xmath33 , defined as @xmath138 satisfies @xmath139 thus , the symmetry number of a lattice point for the 2d square lattice is a divisor of @xmath140 . for the 3d cubic lattice , it is a divisor of 48 ; this means that up to 48 different lattice points can be obtained by symmetry operations executed on @xmath33 .",
    "we call these points _ symmetrically equivalent _ or , for short , _",
    "equivalent_. together , these points form an equivalence class @xmath141 = \\ { q { \\mathbf{r}}~:~ q \\in g \\}.\\ ] ]    to exploit the symmetry , the numbering should make it easy to determine whether two lattice points are equivalent .",
    "this can be achieved by numbering the points from the same equivalence class within a range of @xmath137 numbers , from @xmath142 to @xmath143 , for a certain @xmath144",
    ". there may be less than @xmath137 numbers from the range that are actually used . to check whether sites @xmath76 and @xmath145 are equivalent",
    ", we just need to divide by @xmath137 and round down : @xmath146 figure  [ fig : symmnumbering ] shows a numbering that respects the symmetry for the 2d square lattice .     as produced by the sawdoubler numbering function .",
    "only reachable sites are numbered .",
    "lattice points @xmath118 with @xmath147 ( the grey area ) are numbered first in their equivalence class , and their site numbers are a multiple of @xmath140 .",
    "numbering of these points is by increasing the euclidean distance from @xmath58 .",
    "lattice point @xmath148 has site number 32 and symmetry number @xmath149 .",
    "its equivalence class consists of the sites 3239 .",
    "lattice point @xmath59 has site number 8 and symmetry number @xmath150 .",
    "its equivalence class consists of the sites 8 , 10 , 12 , 13 .",
    "there are no sites 9 , 11 , 14 , 15 in this numbering . ]",
    "let @xmath151 denote the site obtained from site @xmath76 by applying symmetry operation @xmath152 , and @xmath153 the set of sites obtained from set @xmath38 by applying @xmath152 to the sites of @xmath38 .",
    "note that @xmath154 , because @xmath152 is a bijection .",
    "similar to eqn .",
    "( [ eqn : symm_r ] ) for a single lattice point , we can define the symmetry number of a set of sites @xmath38 , @xmath155 we can order sets of the same size lexicographically , by comparing the highest site numbers first .",
    "for example , the set @xmath156 is lexicographically smaller than @xmath157 , because we first compare the highest sites and find that @xmath158 , and then we find that @xmath159 .",
    "we denote this by @xmath160 .",
    "our aim is to compute @xmath39 for every subset @xmath38 of lattice sites that occurs in a walk of length @xmath1 .",
    "let @xmath161 be such a subset , with @xmath162 and @xmath163 .",
    "we call the highest site @xmath164 the _ terminal site _ of @xmath38 . note that this is not necessarily the end point of a walk through @xmath38",
    ". we can write @xmath165 where @xmath166 is the _ terminal part _ of @xmath38 , which is the set of sites equivalent to its terminal site .",
    "checking whether @xmath167 belongs to @xmath168 , reduces to checking whether @xmath169 it is easy to prove that @xmath170 as a disjoint union , and that @xmath171 for all subsets @xmath38 and all @xmath129 .    for a set of sites",
    "@xmath38 , we can find an operation @xmath172 such that @xmath173 is lexicographically the largest among the sets @xmath174 .",
    "the operation @xmath175 is not unique , but the set @xmath173 is . since @xmath176",
    ", we need not compute @xmath39 , but we can compute @xmath177 instead .",
    "this means that we only have to compute @xmath39 for sets @xmath38 with @xmath178 for all @xmath129 .    for every lexicographically largest set @xmath168",
    ", there are @xmath179 symmetry operations @xmath129 that lead to different sets @xmath174 .",
    "these operations also give different sets @xmath153 , because their terminal parts @xmath180 are different .",
    "note that for the same reason , we have @xmath181 we now just have to multiply @xmath39 by the symmetry number @xmath182 to account for all the omitted sets @xmath38 ; this symmetry number is most easily computed by using @xmath183 similar to eqn .",
    "( [ eqn : symmnr ] ) .",
    "this method fully exploits the available symmetry of @xmath168 , and asymptotically for large @xmath1 this will approach the full symmetry of @xmath38 , as in most cases the terminal part will only contain one site and it will have the maximum symmetry number , @xmath137 .",
    "furthermore , the overhead caused by computing the symmetry number is limited , as we only need to compute it for every @xmath168 , and not for every @xmath38 . when expanding @xmath38 , i.e. when adding a new , smaller site @xmath95 , we compute the symmetry number if we leave the equivalence class of the terminal site ( i.e. , @xmath184 ) .",
    "from then onwards , @xmath168 can not change anymore , and we use its value for all @xmath38 with the same terminal part @xmath168 .",
    "it would also be possible to exploit the full symmetry of @xmath38 instead of only that of @xmath168 , but this would yield only limited gain and would cause some extra overhead .",
    "in this section , we will test the performance of the sawdoubler program both with respect to computation time and memory . in our previous work",
    "@xcite , we used 200 processing cores of a supercomputer and spent about 50,000 core hours for the computation of @xmath185 for the 3d cubic lattice . in the present work",
    ", we will focus instead on the performance on a pc with a limited amount of memory .",
    "our test case is the same 3d cubic lattice .",
    "the test architecture we use is a dual - core apple macbook pro with a 2.53 ghz intel core i5 dual - core processor and 4 gb ram , a 256 kb l2-cache per core , a 3 mb l3-cache , and a 5400 rpm hard disk of size 500 gb , running the macos 10.6.8 operating system .",
    "we use the gcc compiler , version 4.2 , with flags ` -o3 -wall ` .",
    "sawdoubler first creates saws of length @xmath1 by algorithm  [ algo : go ] and then computes the correction terms @xmath186 by algorithm  [ algo : correct ] .",
    "the computation of values @xmath39 for sets @xmath38 has been organised such that all sets @xmath38 with the same terminal site @xmath187 are handled by a separate tree . a saw @xmath29 of length @xmath1 is then only stored if it contains @xmath187 , and only the sites @xmath188 of the walk are stored in the tree ; thus stored walks may have length less than @xmath1 . the main program",
    "then loops over @xmath187 up to the maximum reachable lattice site .",
    "this procedure saves much memory , and makes it possible to reach larger @xmath1 .",
    "we call this the _ split - tree _ approach .",
    "if desired , the single site @xmath187 could be replaced by a set of sites @xmath189 , to reduce memory requirements further .",
    "table  [ tbl : time ] presents the computation time needed for calculating @xmath2 , for @xmath190 .",
    "the time given is the total elapsed time of a single run as measured by the unix ` time ` utility .",
    "( for @xmath191 , the time needed is too short and our measurement becomes inaccurate ; therefore we omit those results . ) in almost all cases , the elapsed time is close to the used cpu time .",
    "comparing columns in the table without and with symmetry shows that exploiting symmetry considerably accelerates the computation , by up to a factor of 26.2 for @xmath192 .",
    "we use two different numberings in our experiments for table  [ tbl : time ] . changing the numbering from ordering by the euclidean norm to ordering by the manhattan norm ( @xmath193 ) ,",
    "saves up to a modest 5 per cent in time for @xmath194 but it takes about 10 per cent more memory .",
    "this becomes a disadvantage for @xmath192 , where the amount of memory required is close to the total amount available .",
    "both numberings order the lattice points by an increasing distance from the origin , given by the respective norm , and thus perform much better than other numberings ( that we used in our initial implementations of sawdoubler . )",
    "the last column of table  [ tbl : time ] represents an attempt to use the full computing capability of the dual - core architecture by employing both cores in parallel .",
    "this is done by running two instances of the program simultaneously , one executing the odd iterations of the main loop , and the other the even ones .",
    "this already gives a speedup of around 1.7 for @xmath195@xmath196 and the @xmath197 norm .",
    "the load imbalance here is reasonable , with the largest imbalance ( 3.5 per cent above the average time ) observed for @xmath198 , one core running 687 s and the other 736 s. both cores use the same shared memory , so they may hinder each other and both must store a complete tree in memory . for @xmath192 ,",
    "the trees become very large , and together they fill up about two thirds of the available ram memory . here , the cpu time was about 10 per cent less than the elapsed time , perhaps caused by cores interfering with each other when making use of shared resources such as the ram and the l3 cache .",
    "this difference between cpu time and elapsed time only occurred for the largest problem instance @xmath192 .",
    "the resulting speedup for @xmath192 is 1.56 out of 2 .",
    "the dual - core approach can be generalised to more cores by cyclic assignment : processor core @xmath199 from a set of @xmath200 cores will carry out iterations @xmath201 of the main loop . for larger @xmath1 and a larger number of cores @xmath200 , this static distribution of work by cyclic assignment may lead to larger imbalance than that observed for two cores , in particular since the amount of work may then vary considerably between loop iterations . in that case , a dynamic distribution of work based on a job queue would lead to better balance .    considering the growth of the computation time with increasing @xmath1",
    ", we note that moving from @xmath202 to @xmath198 increases the time by a factor of 7.1 ( using symmetry and the @xmath197 norm ) , and moving from @xmath198 to @xmath192 by a factor of 7.4 .",
    "asymptotically , the length - doubling method grows as @xmath203 , since every one of the @xmath204 walks of length @xmath1 has @xmath20 different subsets @xmath38 and incrementing a counter for each of these costs @xmath205 operations .",
    "the memory savings of the tree by eliminating repetition also pays off in computation time , as counters may now be incremented by larger numbers than one .",
    "this results in slower initial growth than the factor of 9.368 theoretically predicted .    for comparison",
    ", we also used our program to compute @xmath0 in a straighforward way , without length - doubling and without using symmetry , just by creating and counting all @xmath0 walks .",
    "the computation of @xmath206 in this manner already took 9258 s , about the same time as the computation of @xmath3 with length - doubling and symmetry .    examining the breakdown of the computation time",
    ", we observed that for large @xmath1 by far most of the time is spent in computing the correction terms by algorithm  [ algo : correct ] . a notable 25 per cent of that time is spent in finding the largest remaining site @xmath95 using the bin structure , and the remainder in traversing the tree .",
    "finding @xmath95 can possibly be optimised in the future , perhaps by using some form of hashing , as many bins will be empty .",
    ".time ( in s ) of the computation of the number of saws of length @xmath19 for the 3d cubic lattice . exploitation of 48-fold symmetry is either disabled or enabled ; the site numbering is based on either the @xmath197 ( euclidean ) norm or the @xmath207 ( manhattan ) norm ; and either one or two cores of the dual - core processor are used .",
    "[ cols= \" > , > , < , > , < , > , < , > , < \" , ]",
    "in this article , we have presented an algorithm for counting the number of self - avoiding walks of length @xmath19 by creating self - avoiding walks of length @xmath1 , based on the length - doubling method  @xcite .",
    "we have made available a program sawdoubler in c , which implements the method , exploits symmetry , and uses an efficient data structure .",
    "we have computed @xmath208 for the 3d cubic lattice on a dual - core laptop computer with 4 gb main memory in 1 hour and 40 minutes , and thereby demonstrated the efficiency of our program .",
    "we have verified the counting results up to @xmath209 of our previous work  @xcite , which was done by a completely different implementation .",
    "furthermore , we have shown that two processor cores of a dual - core processor can be used with a speedup of 1.7 , provided two copies of the problem tree fit into the shared memory .",
    "the design of the sawdoubler program makes it easy to extend the computation to other lattices .",
    "anyone can replace the file ` lattice.c ` ( aimed at the 3d cubic lattice ) by another file such as for the 2d square or honeycomb lattice , the 3d bcc or fcc lattice , or the 4d hypercubic lattice , which is straightforward to do , and no change in the tree structure functions of the file ` sawdoubler.c ` is needed , nor changes in the main file ` saw.c ` .    for future work",
    ", the software can be extended to compute @xmath210 as well as @xmath2 , and to compute squared end - to - end distances @xmath211 , as has been done in  @xcite .",
    "a limitation of the present software is the size of the tree for one terminal site @xmath187 .",
    "generalising to a terminal set @xmath189 to keep the tree within any amount of available memory would be the next step .",
    "future research could investigate variants of the present problem , such as self - avoiding polygons and lattices with forbidden regions .",
    "the present work should provide an efficient and extendible basis for such investigations ."
  ],
  "abstract_text": [
    "<S> this article presents sawdoubler , a package for counting the total number @xmath0 of self - avoiding walks ( saws ) on a regular lattice by the length - doubling method , of which the basic concept has been published previously by us . </S>",
    "<S> we discuss an algorithm for the creation of all saws of length @xmath1 , efficient storage of these saws in a tree data structure , and an algorithm for the computation of correction terms to the count @xmath2 for saws of double length , removing all combinations of two intersecting single - length saws .    </S>",
    "<S> we present an efficient numbering of the lattice sites that enables exploitation of symmetry and leads to a smaller tree data structure ; this numbering is by increasing euclidean distance from the origin of the lattice . </S>",
    "<S> furthermore , we show how the computation can be parallelised by distributing the iterations of the main loop of the algorithm over the cores of a multicore architecture . </S>",
    "<S> experimental results on the 3d cubic lattice demonstrate that @xmath3 can be computed on a dual - core pc in only 1 hour and 40 minutes , with a speedup of 1.56 compared to the single - core computation and with a gain by using symmetry of a factor of 26 . </S>",
    "<S> we present results for memory use and show how the computation is made to fit in 4 gbyte ram . </S>",
    "<S> it is easy to extend the sawdoubler software to other lattices ; it is publicly available under the gnu lgpl license .    </S>",
    "<S> self - avoiding walk , enumeration , simple cubic lattice    * program summary *    _ manuscript title : _ sawdoubler : a program for counting self - avoiding walks + _ authors : _ </S>",
    "<S> raoul d. schram , gerard t. barkema , rob h. bisseling + _ program title : _ sawdoubler + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ program obtainable from : _ cpc program library , queen s university , belfast , n.ireland ; also from http://www.staff.science.uu.nl/~bisse101/saw/ + _ number of lines of code of program : _ 1152 + _ licensing provisions : _ gnu lgpl + _ distribution format : _ tar.gz </S>",
    "<S> + _ programming language : _ c + _ computer : _ any computer with a unix - like operating system and a c compiler . for large problems </S>",
    "<S> , use is made of specific 128-bit integer arithmetic provided by the gcc compiler . </S>",
    "<S> + _ operating system : _ any unix - like system ; developed under linux and mac os 10 + _ ram : _ problem dependent ( 2 gbyte for counting saws of length 28 on the 3d cubic lattice ) + _ number of processors used : _ 1 . </S>",
    "<S> parallel version available in directory extras . </S>",
    "<S> + _ keywords : _ self - avoiding walk , enumeration , simple cubic lattice . </S>",
    "<S> + _ classification : _ 7 . </S>",
    "<S> condensed matter and surface science + _ nature of problem : _ computing the number of self - avoiding walks of a given length on a given lattice + _ solution method : _ length doubling + _ restrictions : _ the length of the walk must be even . lattice is 3d simple cubic . + _ </S>",
    "<S> additional comments : _ the lattice can be replaced by other lattices , such as bcc , fcc , or a 2d square lattice + _ running time : _ problem dependent ( 2.5 hours using one processor core for length 28 on the 3d cubic lattice ) + </S>"
  ]
}