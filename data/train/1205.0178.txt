{
  "article_text": [
    "this paper is a survey of the known results about the expressiveness , closure , and decidability properties of finite - state automata that read multiple input tapes .",
    "the theoretical study of these computing devices began within the classic work of rabin and scott  @xcite , elgot and mezei  @xcite , and rosenberg  @xcite . in recent years , multi - tape automata have found some applications such as automatic structures  @xcite , querying string databases  @xcite , and weighted automata for computational linguistic  @xcite .    section  [ sec : definitions ] gives a general definition of multi - tape automata that allows for nondeterministic , asynchronous , and two - way movements of the input heads .",
    "the following sections analyze the expressiveness , closure properties , and decidability for increasing levels of generality : section  [ sec : single - tape - automata ] briefly recalls the well - known properties of single - tape automata ; section  [ sec : synchr - multi - tape ] discusses synchronous automata , where different input heads are not allowed to be in arbitrary portions of their respective tapes ; and section  [ sec : asynchr - multi - tape ] considers the most general case of fully asynchronous heads . section  [ sec : summary - properties ] gives a synopsis of the fundamental properties surveyed .",
    "finally , section  [ sec : intersection ] presents an original algorithm for the intersection of asynchronous one - way multi - tape automata .",
    "since this class is not closed under intersection , the algorithm may not terminate in the general case .",
    "@xmath0 is the set of integer numbers , and @xmath1 is the set of natural numbers @xmath2 . for a ( finite )",
    "set @xmath3 , @xmath4 denotes its powerset . for a finite nonempty _ alphabet _",
    "@xmath5 , @xmath6 denotes the set of all finite sequences @xmath7 , with @xmath8 , of symbols from @xmath5 ( also called _ words _ over @xmath5 ) ; when @xmath9 , @xmath10 is the _ empty _ word .",
    "@xmath11 denotes the length @xmath12 of a word @xmath13 .",
    "@xmath12-word _ is an @xmath12-tuple @xmath14 of words over @xmath5 , where each @xmath15 .",
    "the _ convolution _ of @xmath12 words @xmath16 is a word over the padded alphabet @xmath17 : @xmath18 \\cdots \\left [ \\begin{array}{c } y_1^m \\\\ \\vdots \\\\",
    "y_n^m \\end{array } \\right]\\,,\\ ] ] where @xmath19 is the maximum length @xmath20 , and @xmath21    given two words @xmath22 and @xmath23 , @xmath24 denotes their _ concatenation _",
    "@xmath25 , and @xmath26 denotes the _ reversal _ @xmath27 of @xmath28 .",
    "these operations on words are naturally lifted to sets of words and to @xmath12-words ; for example , @xmath29 denotes the concatenation of the two sets of words @xmath30 and @xmath31 ; @xmath32 denotes the reversal of the @xmath12-word @xmath33 .",
    "also , @xmath34 denotes the _ kleene closure _ with respect to finite self - concatenation , that is @xmath35 , where @xmath36    given a set @xmath30 of @xmath12-words over @xmath5 , @xmath37 is the _ complement _ set @xmath38 ; @xmath39 is the _ projection _ set of @xmath40-words obtained by projecting out @xmath30 s @xmath41-th component , that is @xmath42 @xmath43 is the _ generalization _ set of @xmath40-words obtained for every value of @xmath30 s @xmath41-th component , that is @xmath44 and the convolution of @xmath30 is the set of words @xmath45      a two - way finite - state automaton with @xmath46 tapes scans @xmath12 read - only input tapes , each with an independent head . at every step , the transition function determines the possible next states and head movements , based on the current state and the symbols currently under each head .",
    "two special symbols @xmath47 respectively mark the left and right ends of each input tape ; @xmath48 denotes the extended alphabet @xmath49 .",
    "[ def : nda ] a _ two - way nondeterministic finite - state automaton with @xmath12 tapes _ is a tuple @xmath50 , where :    * @xmath5 is the input alphabet , such that @xmath51 ; * @xmath52 is the finite set of states ; * @xmath53 is the transition function that maps current state and input to a set of next states and head movement directions , with the restriction that the head does not move past the end markers ; * @xmath54 is the initial state ; * @xmath55 is the set of accepting states .",
    "the semantics of two - way nondeterministic finite - state automata relies on the notion of _ configuration_. given a two - way nondeterministic finite - state automaton @xmath56 as in definition  [ def : nda ] , a configuration of @xmath56 is a @xmath57-tuple @xmath58 where @xmath59 is the current state , and , for @xmath60 , @xmath61 is the content of the @xmath41-th tape and @xmath62 is the position of the @xmath41-th head ; when @xmath63 ( resp . ,",
    "@xmath64 ) the head is on the left marker @xmath65 ( resp .",
    ", right marker @xmath66 ) .",
    "the transition relation @xmath67 between configurations is defined as : @xmath68 if and only if , for each @xmath60 , @xmath69 is the symbol at position @xmath70 in input word @xmath61 , @xmath71 includes a tuple @xmath72 , and @xmath73 for each @xmath60 .",
    "@xmath74 of @xmath56 on input @xmath75 is a sequence of configurations @xmath76 such that @xmath77 and , for all @xmath78 , @xmath79 .",
    "a run @xmath74 of @xmath56 on input @xmath28 is _ accepting _ if @xmath80 for some @xmath81 and the @xmath70-th character of the @xmath41-th tape is @xmath66 ( that is , every head has reached the end of its tape ) .",
    "correspondingly , @xmath56 accepts an input word @xmath28 if there is an accepting run @xmath74 of @xmath56 on @xmath28 .",
    "the _ language _ accepted ( or recognized ) by @xmath56 is the set of @xmath12-words @xmath82    [ def : n - tape - automaton ] an @xmath12-tape automaton @xmath56 is :    * _ deterministic _ if @xmath83 for any @xmath84 ; * _ @xmath85-synchronized _ for @xmath86 if every run of @xmath56 , accepting or not , is such that any two heads that are not on the right - end marker @xmath66 are no more than @xmath85 positions apart ( as measured from the left - end marker @xmath65 ) ; * _ synchronized _ if it is @xmath85-synchronized for _ some _ @xmath87 ; * _ asynchronous _ if it is _ not _ synchronized ; * _ synchronous _ if it is @xmath88-synchronized ; * _ @xmath89-reversal bounded _ for @xmath90 if every run of @xmath56 , accepting or not , is such that any head never inverts its direction of motion more than @xmath89 times ; * _ reversal - bounded _ if it is @xmath89-reversal bounded for _ some _ @xmath91 ; * _ one - way _ if it is @xmath88-reversal bounded , that is @xmath92 never moves any head left ; * _ with rewind _ if it only makes a special type of reversals where , after all heads reach the right - end marker @xmath66 , they are simultenously rewinded to the left - end marker @xmath65 , where the computation continues ; * _ @xmath89-rewind bounded _ for @xmath90 if it is @xmath93-reversal bounded with rewind ; * _ rewind - bounded _ if it is @xmath89-rewind bounded for _ some _ @xmath91 .",
    "correspondingly , @xmath94 denotes the class of @xmath85-synchronized @xmath89-reversal bounded @xmath12-tape two - way nondeterministic finite - state automata , @xmath95 the corresponding deterministic class , and when @xmath96 ( resp .",
    "@xmath97 ) the class includes asynchronous ( resp .",
    "two - way reversal - unbounded ) automata as well .",
    "finally , for @xmath98 , @xmath99 and @xmath100 denote the classes of nondeterministic and deterministic @xmath85-synchronized @xmath101-rewind bounded ( or unbounded if @xmath102 ) @xmath12-tape two - way finite - state automata .    with a little abuse of notation",
    ", the notation for automata classes also denotes to the corresponding class of accepted languages ; for example , @xmath103 is also the class of languages recognized by nondeterministic 3-tape machines with at most 4 reversals and with no synchronization restrictions .",
    "a number of weak inclusions are a direct consequence of the definitions . in the following ,",
    "let @xmath46 be a number of tapes , @xmath104 be nonnegative integers , and @xmath105 be nonnegative integers or infinity .",
    "determinism is a syntactic restriction , thus : @xmath106 and similarly , bounding the number of reversals reduces generality : @xmath107 and so does limiting the degree of synchrony : @xmath108 rewinds are a restricted form of reversals , hence : @xmath109      given a class @xmath110 of languages , and @xmath12-tape automata @xmath111 , consider the following decision problems :    emptiness : : :    does @xmath112 ?",
    "universality : : :    does @xmath113 ?",
    "finiteness : : :    is @xmath114 finite ?",
    "disjointness : : :    does @xmath115 ?",
    "inclusion : : :    does @xmath116 ?",
    "equivalence : : :    does @xmath117 ?",
    "class membership : : :    does @xmath118 ?",
    "the languages accepted by variants of multi - tape automata ( definition  [ def : n - tape - automaton ] ) have also been studied by algebraic means : see for example ( * ? ? ?",
    "* chap .  3 ) and ( * ? ? ? * chap .  4 ) .",
    "it is convenient to be aware of the terminology used in those works :    * the class of languages accepted by nondeterministic one - way automata without synchronization requirements is called the _ rational languages_. * for @xmath85 a nonnegative integer , the class of languages accepted by nondeterministic one - way @xmath85-synchronized automata is called the rational languages _ with delay ( or lag ) @xmath85_. * the class of languages accepted by nondeterministic one - way synchronous automata is called the",
    "_ automatic languages_.",
    "this section recalls the well - known properties of single - tape automata ( that is , with @xmath119 tapes ) , which define the class of _ regular _ languages  @xcite .",
    "clearly , the notion of synchronization is immaterial with a single tape : @xmath120 also , languages defined by one - tape automata are closed under complement , intersection , union , concatenation , kleene closure , projection , generalization , and reversal .",
    "the emptiness , universality , finiteness , disjointness , inclusion , equivalence , and class membership problems are all decidable for regular languages .",
    "this section studies several properties of synchronized multi - tape automata @xmath121 and @xmath122 , where @xmath85 denotes a generic value in @xmath1 , and @xmath101 a generic value in @xmath123 .",
    "as we will see , synchronization essentially makes multi - tape automata defining regular languages over convolutions , hence synchronized multi - tape automata define a very robust class of languages .",
    "this section shows that : @xmath124 since rewinds are a special case of reversals , it also follows that : @xmath125      every synchronized @xmath12-tape automaton can be transformed to an equivalent synchronous @xmath12-tape automaton : @xmath126 the construction to translate an @xmath127 into an @xmath128 generalizes the one in @xcite ( @xcite proved the same result by algebraic means ) to two - way nondeterministic automata ; to our knowledge , it is original to the present survey .",
    "it works as follows : additional states in the synchronous automaton @xmath129 keep track of the `` neighbour '' @xmath85 symbols on each tape scanned during a synchronous reading of the tapes .",
    "precisely , the states @xmath130 of @xmath129 are of the form @xmath131 $ ] , where each @xmath132 is a word of at most @xmath133 characters over @xmath134 , with exactly one occurrence of the special symbol @xmath135 . for any such words",
    "@xmath136 , @xmath137 denotes the character immediately to the right of @xmath135 , or @xmath138 if @xmath135 is the right - most character in @xmath136 .",
    "then , a configuration of @xmath129 where the symbol currently under the @xmath41-th head is @xmath139 and the current state is @xmath140 $ ] , corresponds to a configuration of @xmath56 where the symbol currently under the @xmath41-th head is @xmath141that is the one immediately to the right of @xmath135 in @xmath142and the current state is @xmath143 .",
    "the initial state @xmath144 of @xmath129 is @xmath145 $ ] , where all heads are on the left marker . during any computation over a given input",
    ", the ( common ) position of the heads in @xmath129 corresponds to the position of the right - most head in @xmath56 ; more precisely , the states of @xmath129 plus the input describe a @xmath146 tape portion : @xmath147 where @xmath148 is the left - most stored portion of the @xmath41-th tape , @xmath149 is the character immediately to the left of the marker , @xmath150 is the character immediately to the right of the marker , @xmath151 is the right - most stored portion of the @xmath41-th tape , and @xmath152 is the charater currently under the @xmath41-th head .",
    "the hypothesis that @xmath129 is @xmath85-bounded entails that @xmath153 . finally , when a head is on the right marker @xmath66 , we call it `` inactive '' , and we do not update the corresponding portion of the state . write @xmath154 to denote the set of inactive heads in the current state ( that is , the set of heads @xmath155 such that @xmath156 and @xmath157 ) , and @xmath158 to denote the other active heads .",
    "let us now see how to construct the transitions of @xmath129 .",
    "for each of @xmath56 s transitions @xmath159 consider all states of @xmath129 of the form @xmath160 $ ] .",
    "@xmath129 should make a transition from such current state according to the characters currently marked by @xmath135 , corresponding to the @xmath161 , and then adjust the state to reflect the head movements in @xmath56 .",
    "if all _ active _ heads move left in @xmath56 ( that is , @xmath162 ) and there exist an active tape @xmath163 whose @xmath85-size buffer encoded in the state has the marker @xmath135 in the leftmost position ( @xmath164 ) , then it is not sufficient to rearrange the information in @xmath160 $ ] to determine the next state @xmath129 moves to , because the new character the head moves is to @xmath133 characters away from the current position of the head in @xmath129 .",
    "hence , in these situations , @xmath129 enters a sequence of _ lookup _ states @xmath165 while moving all its active heads left , until it reads the @xmath166-th character to the left , so that it can update the state accordingly .",
    "precisely , the following transitions in @xmath129 define a lookup , for any characters @xmath167 read while moving heads .",
    "* enter the lookup state @xmath168 and start moving left : @xmath169 , \\lambda_1^{-1/0 } , \\ldots , \\lambda_n^{-1/0 } \\rangle \\in \\delta'([q , a_1 , \\ldots , a_n ] , \\mu_1 , \\ldots , \\mu_n)\\,,\\ ] ] where @xmath170 hence inactive heads are not moved .",
    "* traverse all lookup states , for @xmath171 , while moving left : @xmath172 , \\lambda_1^{-1/0 } , \\ldots , \\lambda_n^{-1/0 } \\rangle \\in \\delta'([\\ell_h^- , a_1 , \\ldots , a_n ] , \\mu_1 , \\ldots , \\mu_n)\\ ] ] * include the current characters @xmath167 in the state and start moving right on the `` duplicate ''",
    "lookup state @xmath173 : @xmath174 , \\lambda_1^{1/0 } , \\ldots , \\lambda_n^{1/0 } \\rangle \\in \\delta'([\\ell_{s+1}^- , a_1 , \\ldots , a_n ] , \\mu_1 , \\ldots , \\mu_n)\\,,\\ ] ] where @xmath175 is @xmath176 , with the last character removed if @xmath177 .",
    "* move right , for @xmath178 , until you reach @xmath179 : @xmath180 , \\lambda_1^{1/0 } , \\ldots , \\lambda_n^{1/0 } \\rangle \\in \\delta'([\\ell_h^+ , \\nu_1 , \\ldots , \\nu_n ] , \\mu_1 , \\ldots , \\mu_n)\\ ] ] * move to the original position on @xmath143 : @xmath181 , \\lambda_1^{1/0 } , \\ldots , \\lambda_n^{1/0 } \\rangle \\in \\delta'([\\ell_1^+ , \\nu_1 , \\ldots , \\nu_n ] , \\mu_1 , \\ldots , \\mu_n)\\,.\\ ] ] notice that , after the lookup , the tuple @xmath182 is certainly different than the starting tuple @xmath183 , because we have added a left - most character to the left of the marker @xmath135 in at least one of @xmath183 .",
    "hence , the lookup does not introduce nondeterminism .    after setting up the lookup",
    "when necessary , let us now describe normal transitions of @xmath129 .",
    "let @xmath160 $ ] be the current state ; add to @xmath129 all transitions of the form @xmath184 , \\lambda_1^{d'/0 } , \\ldots , \\lambda_n^{d'/0 } \\rangle \\in \\delta'([q , a_1 , \\ldots , a_n ] , \\sigma_1 ' , \\ldots , \\sigma_n')\\ ] ] such that , for @xmath60 :    * @xmath185 ; * @xmath186 or , if @xmath135 does not appear in @xmath187 ( this may only happen after a lookup when the @xmath135 occurred at the last position in @xmath187 ) , @xmath188 ; * let @xmath189 be @xmath190 with @xmath135 moved right , left , or not moved , according to whether @xmath191 is @xmath192 , @xmath193 , or @xmath88 ; formally : @xmath194 then , @xmath195 is : @xmath196    [ [ remarks . ] ] remarks .",
    "+ + + + + + + +    * with this construction the number @xmath197 of states of @xmath129 is @xmath198 , because there are at most @xmath199 @xmath12-tuples of words of length at most @xmath85 for each state in @xmath52 , plus a multiplicative factor @xmath200 to account for the lookup states ( @xmath201 , for any possible left - most characters @xmath202 ) . * the lookups may introduce additional reversals , therefore the construction does not , in general , preserve the original value @xmath101 of reversals . *",
    "automaton @xmath129 is deterministic if and only if @xmath56 is .",
    "therefore , the same construction proves : @xmath203      the classic constructions to turn two - way automata into equivalent one - way automata ( such as shepherdson s  @xcite or vardi s  @xcite ) are applicable to multi - tape synchronous automata as well .",
    "the only minimal difference is that a multi - tape one - way automaton is not forced to always move its heads right , because the heads reaching the right - hand marker @xmath66 can not move right at all . in all",
    ", the following result holds : @xmath204      the usual construction to determinize nondeterministic finite - state automata works for multi - tape synchronous automata too : @xmath205      the computations of synchronous @xmath12-tape one - way automata can be regarded as computations of single - tape automata over @xmath12-track alphabets .",
    "more precisely , let @xmath114 be the language over alphabet @xmath5 accepted by some synchronous @xmath12-tape one - way automaton @xmath206 .",
    "then , there exists a single - tape one - way automaton @xmath207 that accepts the language @xmath208 .      since synchronized automata essentially define regular languages via convolution , they enjoy the same closure properties .",
    "thus , the usual constructions  @xcite show that @xmath209 is closed under under complement , intersection , union , concatenation , kleene closure , projection , generalization , and reversal .",
    "decidability of most decision problems considered in section  [ sec : decision - problems ] is also a straightforward consequence of the regular nature of synchronized automata : for example , _ emptiness _ is decidable : construct the automaton recognizing @xmath208 and determine if it accepts some word ; alternatively , directly test reachability of an accepting state .",
    "similarly , it is easy to see that universality , finiteness , disjointness , inclusion , and equivalence are decidable for synchronized automata .",
    "next , we consider some class membership problems .",
    "ibarra and tran  ( * ? ? ?",
    "15 ) show that , for generic two - way automaton @xmath210 and @xmath86 , it is decidable to determine whether @xmath211 , that is whether @xmath56 is @xmath85-synchronized .",
    "the idea is to build an automaton @xmath212 that simulates the computations of @xmath56 on a single tape that stores the convolution of the input ; whenever @xmath212 detects a computation where a pair of heads would `` separate '' more than @xmath85 cells apart , it accepts , and otherwise it rejects . since @xmath212 accepts the empty language if and only if @xmath56 is not @xmath85-synchronized , and emptiness for @xmath212 is decidable ( as @xmath212 is a single - tape automaton ) , it follows that we have an effective procedure to determine whether @xmath211 .",
    "the same procedure is applicable to automata with bounded reversals , hence it is also decidable whether @xmath127 for given @xmath87 and @xmath98 .",
    "ibarra and tran  ( * ? ? ?",
    "14 ) also show  via reduction from the halting problem of 2-counter machines  that , for a generic two - way automaton @xmath210 , it is undecidable to determine whether @xmath56 is synchronized ( for some @xmath87 ) .",
    "however , if @xmath213 is one - way deterministic , then the same problem is decidable , because @xmath56 is asynchronous unless it is @xmath214-synchronized , where @xmath143 is the number of @xmath56 s states . since we notice that the determinization construction of single - tape automata is applicable to deterministic one - way multi - tape automata as well , we have that the problem of deciding whether a generic @xmath215 is synchronized is also decidable .    on the other hand ,",
    "the following problem is undecidable ( for @xmath216 )  ( * ? ?",
    "11 ) : given @xmath217 , determine whether @xmath218 with @xmath85 given or not ( the two problems are both undecidable because of the result : every @xmath85-synchronous language is also @xmath88-synchronous ) , that is whether @xmath56 recognizes a synchronous language .",
    "undecidability immediately extends to the two - way case ( also with bounded reversals ) .",
    "the decidability of the corresponding problems for deterministic one - way automata is currently open .",
    "this section studies several properties of asynchronous multi - tape automata @xmath219 and @xmath220 , where @xmath101 denotes a generic value in @xmath123 , and @xmath221 .",
    "asynchrony significantly increases the expressiveness of multi - tape automata , but it also significantly restricts the decidability and closure properties .",
    "this section shows that : @xmath222 and , for @xmath223 , @xmath224      there exist asynchronous languages that no synchronous automaton recognizes , thus : @xmath225 in fact , consider the language over pairs of strings @xmath226 it is clear that @xmath227 , because the automaton in figure  [ fig : ln2n ] recognizes it ; notice that the automaton is indeed asynchronous , as the second head makes twice as many moves as the first one , and both scan the entire tape upon acceptance . on the contrary ,",
    "@xmath228^n \\left [ \\begin{array}{c } { \\box}\\\\ a \\end{array } \\right]^n \\mid n \\in \\naturals \\right\\}\\ ] ] is not regular , hence @xmath229 is not accepted by any synchronous @xmath230-tape automaton because of the results of section  [ sec : sync - convolution ] . since we can always extend @xmath229 to an @xmath12-word language with all components empty but the first two , the separation of synchronized and asynchronous holds for every @xmath221 .",
    "( init ) ; ( read2n ) [ right = of init ] ; ( readn ) [ right = of read2n ] ; ( done ) [ left = of init ] ;    ( init ) edge node [ above ] @xmath231 ( read2n ) ; ( read2n ) edge [ bend left ] node [ above ] @xmath232 ( readn ) ; ( readn ) edge [ bend left ] node [ below ] @xmath233 ( read2n ) ;    ( read2n ) edge [ bend left ] node [ below ] @xmath234 ( done ) ;      the power of asynchronous multi - tape automata increases with the number of rewinds : @xmath235 collectively , rewind - bounded automata are instead as expressive as rewind - unbounded ones : @xmath236    these results have been proved by chan  ( * ? ? ?",
    "* ch .  4 ) .",
    "consider first deterministic rewind - bounded automata .",
    "given any @xmath237 distinct positive integers @xmath238 consider the language @xmath239 it is not difficult to show that @xmath240 : each language @xmath241 is recognizable without rewinds , and the @xmath89 rewinds can implement a binary search among all @xmath237 different values of @xmath242 . the standard argument that binary search of @xmath237 elements requires , in the worst case , @xmath89 comparisons , carries over to this setting of @xmath89-rewind automata , hence allowing us to prove that @xmath89 rewinds are necessary to recognize @xmath243 .",
    "the argument clearly extends to an arbitrary number of tapes , thus separating @xmath244 from @xmath245 for all finite @xmath89 s .",
    "let us now consider nondeterministic rewind - bounded automata . the argument for deterministic ones breaks down , as we can use nondeterministic parallelism to try out all @xmath237 values of @xmath41 . more generally , every language over _ unary _ alphabet that is accepted by a reversal - bounded @xmath12-tape automaton is also accepted by some one - way @xmath12-tape nondeterministic automaton ( that can be constructed effectively , see chan  ( * ? ? ?",
    "however , inclusion is still strict for larger alphabets . for @xmath246 , consider the @xmath230-word language @xmath247 it is clear that @xmath248 is accepted by a deterministic @xmath249-rewind bounded automaton .",
    "chan proves , using yao and rivest s technique  @xcite , that no nondeterministic automaton with only @xmath250 rewinds can accept @xmath248 . since",
    "a deterministic automaton is a special case of a nondeterministic one , we have a separation of @xmath251 and @xmath252 ( which , as usual , extends to a generic number of tapes ) .    finally , rosenberg first observed  @xcite that bounding the number of rewinds is without loss of generality for deterministic automata : if , in some computation , an automaton re - enters the same state after two rewinds , it has entered an infinite loop ( and hence will not accept the input ) .",
    "the pigeonhole principle implies that an automaton must re - enter the same state after a number of rewinds equal to the number of its internal states .",
    "thus , a finite bound on the number of rewinds ( equal to the number of internal states ) does not limit the expressiveness of deterministic automata .",
    "a very similar argument works for nondeterministic automata too ( as observed by chan ) : an input can be accepted only if there exists some computation where a different state is entered after each rewind ; therefore , every accepting computation has bounded rewinds . these arguments",
    "prove and .",
    "it is currently unknown whether a hierarchy on to the number of reversals exists , similar to the hierarchy on the number of rewinds discussed in the previous section .",
    "in particular , it is unknown whether the inclusions @xmath253 and @xmath254 are strict for every @xmath89 .",
    "the standard conjecture is that they are , but the capabilities of reversals are quite difficult to capture exactly for asynchronous automata .",
    "in particular , chan  ( * ? ? ?",
    "4.3 ) showed that the hierarchy collapses for nondeterministic automata over unary alphabet , since these automata precisely define the set of unary encodings of presburger relations , regardless of the number of reversals ; thus , a separation in the general case requires languages over binary alphabets .",
    "nondeterminism is not replaceable by rewinds in general .",
    "consider the language @xmath243 introduced in section  [ sec : expr - incr - with - rewinds ] ; a deterministic automaton needs @xmath89 rewinds to recognize it , but it is clear that a nondeterministic automaton needs no rewinds , as it can just guess the right value of @xmath41 ( if it exists ) .",
    "this shows that @xmath255 is not empty , for each @xmath90 and @xmath221 .",
    "chan  ( * ? ? ?",
    "4.6 ) proves a stronger result : there exist languages accepted by one - way nondeterministic automata that no deterministic automaton with ( arbitrarily many ) rewinds accepts .",
    "the language @xmath256 is an example that belongs to the non - empty difference @xmath257    rosenberg  ( * ? ?",
    "9 ) shows a simpler language that belongs to the set difference .",
    "consider the two languages @xmath258 and their concatenation @xmath259 it is clear that both @xmath207 and @xmath260 are in @xmath261 .",
    "on the contrary , @xmath56 is not in @xmath262 for any @xmath90 because a deterministic automaton can not `` guess '' where the tail of @xmath136 s starts on the first tape ; rewinds do not help , because the tail can be arbitrarily long , while the number of rewinds is bounded by the finite number of states of the automaton ( as we observed in section  [ sec : expr - incr - with - rewinds ] ) . for the same reason ,",
    "@xmath56 is in @xmath263 , where a nondeterministic choice guesses where the tail starts .",
    "rewinds are not replaceable by nondeterminism in general , as first proved by rosenberg  ( * ? ? ?",
    "* th .  9 ) .",
    "we can easily show it using the language @xmath264 discussed later in section  [ sec : det - one - way - automata - closures ] .",
    "@xmath265 is in @xmath266 : a deterministic automaton can make a pass to check that the two input strings are identical and in the form @xmath267 ; then , it rewinds and makes another pass to check that the sequence of @xmath268 s before the @xmath136 on the first tape has the same length as the sequence of @xmath268 s after the @xmath136 on the second tape .",
    "however , @xmath265 is not in @xmath263 , because nondeterminism does not help here ( section  [ sec : det - one - way - automata - closures ] gives a more rigorous characterization of why this is the case ) .",
    "hence , the difference @xmath269 is not empty .",
    "reversals are not replaceable by rewinds in general , not even when combined with nondeterminism .",
    "the 2-word language @xmath270 is clearly recognizable with a 1-reversal bounded deterministic automaton .",
    "no automaton with rewinds and nondeterminism , however , can accept @xmath271 .",
    "otherwise , let @xmath212 be such an automaton , and let @xmath272 be the number of its rewinds ; we could then use @xmath212 to recognize a language similar to @xmath248 for @xmath273 , but where the word on the second tape is the reversal of the one on the first ; this is impossible with @xmath272 rewinds , as shown by same argument that showed that @xmath248 is not accepted with less than @xmath274 rewinds .",
    "the contradiction shows that the difference @xmath275 is not empty .",
    "whether reversals can replace nondeterminism is an open problem in general ; in particular , it is unknown whether the inclusion @xmath276 is strict or not . some related results for single - tape multi - head automata might suggest that it is . for example ,",
    "bebjk and tefnekov  @xcite show some functions @xmath277 ( where @xmath19 is the length of the input ) such that @xmath277-reversal bounded @xmath12-head nondeterministic automata are strictly more expressive than their deterministic counterparts .",
    "the general question for @xmath12-head automata is likely hard to settle , as it corresponds  @xcite to the open problem of whether deterministic logarithmic space ( l ) equals nondeterministic logarithmic space ( nl ) .",
    "this section presents the closure properties of multi - tape finite automata .",
    "we start with one - way automata , and then introduce rewinds and reversals .",
    "let us consider the closure properties of the class @xmath278 , for @xmath221 .",
    "rabin and scott observed  ( * ? ? ?",
    "17 ) that @xmath279 is closed under complement , with the usual construction that complements the accepting states ( with a transition function that is total ) .",
    "the same construction carries over to show that @xmath280 is closed under complement for any @xmath12 .",
    "@xmath280 is not closed under projection , but we have the weaker property that if @xmath281 then @xmath282 . rabin and scott proved this  ( * ? ? ?",
    "16 ) for @xmath283 , and other authors  @xcite generalized it .",
    "the idea of the proof is the following : given an @xmath12-tape automaton @xmath56 , build an @xmath40-tape automaton @xmath207 that replicates @xmath56 s behavior on all tapes except the @xmath41-th ( which is projected out ) , where it behaves nondeterministically ( that is , it performs any computation @xmath56 may perform on the @xmath41-th tape ) .",
    "since @xmath280 is closed under complement but not under projection , it is also not closed under generalization : the projection @xmath284 of a language @xmath281 is equivalently expressed as @xmath285 , hence if @xmath280 were closed under generalization , it would also be closed under projection  a contradiction .",
    "@xmath280 is not closed under intersection .",
    "for example , rabin and scott  ( * ? ? ?",
    "17 ) suggest the @xmath230-word language : @xmath286 clearly @xmath287 and @xmath288 ; however , their intersection @xmath265 is not in @xmath279 , because its projection @xmath289 is not regular ( i.e. , in @xmath290 ) , contradicting the closure under projection established above . obviously , the proof generalizes to any @xmath221 .",
    "notice that @xmath291 is synchronous , hence @xmath279 is not closed under intersection even with synchronous languages .    since @xmath280 is closed under complement but not under intersection ,",
    "it is also not closed under union by de morgan s laws : @xmath292 . however , if @xmath293 then @xmath294 , because a nondeterministic automaton can recognize @xmath295 and @xmath296 in parallel .",
    "fischer and rosenberg showed  ( * ? ? ? * sec .",
    "3 ) that @xmath280 is not closed under concatenation , kleene closure , or reversal .",
    "the proof uses the three simple @xmath230-word languages @xmath297 , @xmath298 , @xmath299 .",
    "clearly , @xmath300",
    "because recognizing @xmath301 amounts to comparing the words on the two tapes up to the character @xmath302 ; however , the concatenation @xmath303 is not in @xmath279 , intuitively because a deterministic automaton can not `` guess '' when @xmath304 ends and @xmath305 begins ( formally , a counting argument similar to the pumping lemma of regular languages shows that a deterministic automaton must misclassify some words ) .",
    "this implies that @xmath279 , and hence @xmath280 , is not closed under concatenation . a similar arguments that considers arbitrary concatenations of @xmath301 proves that @xmath279 is not closed under kleene closure , either .",
    "to show non - closure under reversal , take the language @xmath306 , which is accepted by a nondeterministic automaton in @xmath307 that guesses when @xmath28 ends in @xmath308 .",
    "a modification of the argument used for @xmath309 proves that @xmath310 is not recognizable with a deterministic automaton .",
    "however , @xmath311 clearly is in @xmath279 ; in all @xmath279 , and @xmath280 , is not closed under reversal .",
    "let us consider the closure properties of the class @xmath312 , for @xmath221 .",
    "@xmath313 is closed under projection , using the same construction discussed in section  [ sec : det - one - way - automata - closures ] for deterministic automata : given an @xmath12-tape automaton @xmath56 , build an @xmath40-tape automaton @xmath207 that replicates @xmath56 s behavior on all tapes except the @xmath41-th ( which is projected out ) , where it behaves nondeterministically ( that is , it performs any computation @xmath56 may perform on the @xmath41-th tape ) . hence if @xmath314 then @xmath282 .",
    "@xmath313 is closed under union ; elgot and mezei gave  @xcite the first proof of this fact ( using a different formalism , ultimately corresponding to one - way multi - tape automata ) , which generalizes the construction for 1-tape automata : a nondeterministic automaton checks all components of a finite union in parallel through nondeterministic choice , and accepts if and only if at least one parallel computation accepts .",
    "similarly , the classic constructions for 1-tape automata are applicable to @xmath12-tape automata to prove that @xmath313 is closed under concatenation , kleene closure , and reversal .",
    "like @xmath280 , @xmath313 is not closed under intersection .",
    "the proof is the very same as in the deterministic case : @xmath315 and @xmath291 ( section  [ sec : det - one - way - automata - closures ] ) are in @xmath307 ( even in @xmath279 ) , but their intersection @xmath265 is not in @xmath307 because its projection on either component is not regular , whereas @xmath313 is closed under projection .",
    "closure under union and non - closure under intersection imply , through de morgan s laws , that @xmath313 is not closed under complement .",
    "finally , @xmath313 is not closed under generalization .",
    "the proof uses the following lemma proved by monks  ( * ? ? ?",
    "4 ) : for every @xmath12-word language @xmath316 in @xmath313 there exists an @xmath317-word language @xmath318 in @xmath280 such that @xmath319 . the proof gives an effective construction that turns an automaton accepting @xmath316 into a deterministic automaton accepting @xmath318 over an extended alphabet , which can be projected out to obtain the original set @xmath316 of @xmath12-words .",
    "now , consider @xmath315 and @xmath291 again ; both are in @xmath279 and , since @xmath279 is closed under complement , their complements @xmath320 and @xmath321 also are in @xmath279 , hence in @xmath307 _ a fortiori_. @xmath307 is closed under union , thus the language @xmath322 is also in @xmath307 . therefore , the lemma we just stated ensures the existence of another language @xmath323 in @xmath324 such that @xmath325 equals @xmath326 ; since @xmath327 , its complement @xmath328 is in @xmath324 as well .",
    "now , notice that the complement @xmath329 of @xmath326 is equivalent to @xmath330 which we noted is not in @xmath307 .",
    "if @xmath313 were closed under generalization , @xmath331 would be in @xmath307 , which we noted is not the case . in all , @xmath313 is not closed under generalization .",
    "let us consider the closure properties of the class @xmath332 , for @xmath221 .",
    "@xmath333 is closed under complement , since each pass of a rewind automaton on the input tapes corresponds to a computation of an automaton in @xmath280 , which is closed under complement .",
    "hence , it is sufficient to adapt the usual construction for complementation in the following way : after every pass , accept if the original automaton rejects , reject if the original automaton accepts , and rewind if the original automaton rewinds .",
    "@xmath333 is closed under union : given an automaton @xmath334 accepting @xmath295 and another automaton @xmath335 accepting @xmath296 , an automaton @xmath56 accepting @xmath336 operates as follows : simulate @xmath337 ; if @xmath337 accepts @xmath56 also accepts ; otherwise , @xmath56 rewinds , simulates @xmath338 , and accepts iff @xmath338 does .",
    "notice that termination is not a problem because the final part of section [ sec : expr - incr - with - rewinds ] discussed why we can assume that the number of rewinds is always bounded .",
    "closure under union and complement imply closure under intersection for @xmath333 through de morgan s laws .",
    "alternatively , we can produce a direct construction similar to the one for union , where the simulation of two automata @xmath339 accepts iff both simulations accept .",
    "not only is @xmath333 closed under all boolean operations ; rosenberg proves  ( * ? ? ?",
    "8) that every language in @xmath333 is expressible as a finite boolean combination of languages in @xmath280 ( essentially , each of finitely many rewinds represents a one - way deterministic computation over the input ) , hence @xmath333 is the _",
    "boolean closure _ of @xmath280 .",
    "@xmath333 is not closed under concatenation , because we have already observed in section  [ sec : nond - not - repl - rewinds ] that the languages @xmath207 and @xmath260 are in @xmath279 ( hence in @xmath340 _ a fortiori _ ) , but their concatenation @xmath341 is not in @xmath340 because accepting it requires nondeterminism .",
    "( as usual , the result immediately carries over to @xmath333 ) .",
    "since , however , @xmath342 clearly is in @xmath340 , we conclude that @xmath333 is not closed under reversal either .",
    "@xmath333 is not closed under kleene closure ; rosenberg s proof  ( * ? ? ?",
    "8) works as follows .",
    "consider the language @xmath343 clearly @xmath344 ( actually , even @xmath345 ) .",
    "then , the same argument showing @xmath346 not in @xmath340 proves that @xmath347 .",
    "assume by contradiction that @xmath340 is closed under kleene closure ; then , since @xmath340 is closed under union and intersection , the language @xmath348 also is in @xmath340 .",
    "this is a contradiction , because @xmath129 equals @xmath349as the @xmath207 in the right - most argument of @xmath350 in forces @xmath207 to appear first , and the closing @xmath351 forces @xmath352 to appear second and last  but we know that @xmath353 .",
    "we can prove that @xmath333 is not closed under projection using the language @xmath354 defined in section  [ sec : det - one - way - automata - closures ] .",
    "we know that both @xmath315 and @xmath291 are in @xmath279 , hence their intersection @xmath265 is in @xmath340 ( it is easy to build an automaton in @xmath340 that accepts @xmath265 with one rewind ) .",
    "the projection @xmath355 is , however , not in @xmath356 because it is not regular and @xmath357 .",
    "finally , @xmath333 is not closed under generalization , because it is closed under complement but not under projection .",
    "let us consider the closure properties of the class @xmath358 , for @xmath221 .",
    "using rewinds , the same constructions that show @xmath333 closed under intersection and union are applicable to show @xmath359 is closed under intersection and union : use one rewind to execute the two computations for @xmath295 and @xmath296 in parallel ; accept if both accept , when recognizing @xmath360 ; accept if at least one accepts , when recognizing @xmath336 .",
    "@xmath359 is not closed under projection , with the same proof we have used in several other cases : @xmath265 is in @xmath361 , but @xmath362 is not in @xmath363 because it is not regular and @xmath364 .",
    "@xmath359 is not closed under complement either .",
    "the proof is a modification of chan  ( * ? ? ?",
    "4.6 ) : consider the language @xmath365 @xmath366 essentially is the complement of @xmath367 , but we can show that @xmath368 whereas @xmath369 . intuitively , rewinds do not help in recognizing @xmath367 or @xmath366 , as @xmath19 and @xmath12 can be arbitrarily large , whereas a finite - state automaton can only `` remember '' a finite number of position to jump to after any rewind ; nontdeterminism works to recognize @xmath367 but is still insufficient for @xmath366 where `` universal '' nondeterminism is needed . formally ,",
    "assume by contradiction that @xmath370 for some automaton @xmath56 with @xmath89 rewinds .",
    "then , modify @xmath56 into @xmath129 so that @xmath129 works on inputs of the form @xmath371 as @xmath56 would work on inputs of the form @xmath372 by having enough states to count @xmath268 s up to @xmath373 .",
    "therefore @xmath129 recognizes @xmath248 with @xmath89 rewinds , contradicting the fact that @xmath248 is not in @xmath374 .",
    "since @xmath19 is generic , the contradiction shows that @xmath368 , then @xmath359 is not closed under complement .",
    "@xmath359 is closed under concatenation , kleene closure , and reversal , through the usual constructions that exploit nondeterminism mentioned in section  [ sec : nondet - one - way - automata - closures ] .",
    "finally , whether @xmath359 is closed under generalization is an open problem .",
    "the proof that establishes the non - closure under projection of automata with rewinds ( by reduction to the 1-tape case ) entails the non - closure under projection of automata with generic reversals in @xmath219 and @xmath219 , for any @xmath221 and @xmath375 . since non - closure under projection of a class of automata is tantamount to undecidability of emptiness for automata of that class , we do not proceed further with the investigation of the closure properties of two - way automata ( which have not been studied in the literature either ) .",
    "this section discusses the decidability of various problems for multi - tape automata .",
    "let us consider a generic member @xmath56 of the class @xmath278 , for @xmath221 .",
    "emptiness is decidable , as a corollary of the fact that the projection of @xmath376 is in @xmath377 , which is closed under projection .",
    "thus , @xmath114 is empty if and only if @xmath378 is empty , where @xmath379 is any subset of @xmath380 with @xmath40 elements ; the latter problem is decidable because emptiness of regular languages is decidable .",
    "notice that the projection automaton is effectively constructible from @xmath56 .",
    "another proof of the same decidability results uses an analogue of the pumping lemma for multi - tape automata : rosenberg  @xcite shows that , given a partition @xmath381 of @xmath56 s set @xmath52 of states , @xmath382 if and only if @xmath56 accepts some input @xmath16 such that @xmath383 for all @xmath384 . since @xmath280 is closed under complement , universality is also decidable for @xmath376 .",
    "the property of projection also shows that finiteness is decidable for @xmath376 : @xmath114 is finite if and only if @xmath378 is finite for _ every _ subset @xmath379 of @xmath380 with @xmath40 elements ; the latter problem is decidable because finiteness of regular languages is decidable .",
    "the problem of whether equivalence is decidable for @xmath376 has been open for several years ; harju and karhumki  @xcite have finally shown it to be decidable .",
    "their proof is quite technical , and it is basically a corollary of the related problem of `` multiplicity equivalence '' for nondeterministic one - way multi - tape automata .",
    "two automata in @xmath313 are _ multiplicity equivalent _ if they accept the same @xmath12-words exactly the same number of times ( that is with the same number of distinct computations ) . using some group - theoretic techniques , harju and karhumki show that the multiplicity equivalence problem is decidable for automata in @xmath313 , hence also for automata in @xmath280 .",
    "the multiplicity equivalence problem reduces , however , to ( ordinary ) equivalence for deterministic automata in @xmath280 , which have at most one computation on each input .",
    "rabin and scott  ( * ? ? ?",
    "18 ) have shown that disjointness is undecidable for automata in @xmath279 ; as usual , the proof immediately generalizes to @xmath280 with @xmath221 .",
    "the proof is a simple reduction from post s correspondence problem : given a finite set of 2-words over @xmath5 ( with @xmath385 ) @xmath386 determine if there exists a sequence @xmath387 of indices from @xmath388 ( possibly with repetitions ) such that @xmath389 the reduction is as follows : consider the ( finite ) 2-word languages @xmath390 obviously , @xmath391 and @xmath392 are both in @xmath279 , but the given instance of post s correspondence problem has a solution if and only if @xmath393 .",
    "since post s correspondence problem is undecidable , disjointness for @xmath279 ( and @xmath280 ) is also undecidable .",
    "the undecidability of the inclusion problem for @xmath280 follows from the fact that @xmath280 is closed under complement but disjointness is undecidable for it ; in fact , @xmath394 if and only if @xmath395 .",
    "let us consider a generic member @xmath56 of the class @xmath312 , for @xmath221 .",
    "the proof of decidability of emptiness and finiteness for @xmath280 does not depend on the restriction on deterministic automata , and in fact establishes that the same problems are decidable for @xmath313 as well .",
    "conversely , undecidability results for @xmath280 immediately extend to its superclass @xmath313 ; thus disjointness and inclusion are undecidable for @xmath313 as well .",
    "universality is undecidable for @xmath313 ; fischer and rosenberg  ( * ? ? ?",
    "7 ) give another proof using reduction from post s correspondence problem ( introduced in section  [ sec : dec - determ - one - way ] : @xmath396 if and only if @xmath397 if and only if @xmath398 , which is the universality problem for a language in @xmath307 ( remember that @xmath313 is closed under union ) .",
    "now , notice that there exist an automaton @xmath399 in @xmath280 ( hence also in @xmath313 ) that accepts the universe language @xmath400 .",
    "since deciding the equivalence @xmath401 is equivalent to deciding the universality problem for a generic @xmath402 , it follows that equivalence is also undecidable for @xmath313 .",
    "finally , deciding whether a generic language @xmath314 is deterministically recognizable ( i.e. , @xmath281 ) is also undecidable , with a more complex reduction from post s correspondence problem  ( * ? ? ?",
    "all decision problems considered in this paper are undecidable for the class @xmath332 , for @xmath221 .",
    "this is a consequence of the non - decidability of some problems for the class @xmath280 , of which @xmath333 is a strict superset , combined with the closure of @xmath333 under all boolean operations .",
    "consider , for example , the emptiness problem for @xmath333 ; if it were decidable , then the disjointness problem for generic @xmath403 would be decidable by reducing it to testing the emptiness of @xmath404 .",
    "but section  [ sec : dec - determ - one - way ] showed that disjointness is undecidable for @xmath280 . since @xmath333 is closed under complement , universality is also undecidable for @xmath333 .",
    "emptiness is reducible to finiteness as follows .",
    "assume , _ a contrario _ that finiteness is decidable for @xmath333 ; then , we can decide whether @xmath112 for a generic @xmath405 .",
    "first , determine if @xmath56 accepts a finite or infinite language ; if it accepts an infinite language , we conclude that @xmath114 is not empty ; thus , let @xmath114 be finite . modify @xmath56 into @xmath129 by adding a loop on every accepting state of @xmath56 ; the loop reads some @xmath406 and moves the head right on every tape .",
    "it should be clear that , for every @xmath12-word @xmath16 accepted by @xmath56 , @xmath129 accepts all ( infinitely many ) words in @xmath407 we have that @xmath129 accepts a finite language if and only if @xmath114 is empty , but emptiness is undecidable for a generic @xmath405 .",
    "disjointness is undecidable for @xmath333 because the universe language @xmath400 is in @xmath333 , and deciding disjointness of @xmath114 and @xmath400 is equivalent to deciding emptiness of @xmath114 .",
    "similarly , @xmath408 if and only if @xmath112 , hence inclusion is also undecidable for @xmath333",
    ". finally , equivalence is a generalization of emptiness , thus it is undecidable for @xmath333 .",
    "the undecidability of all decision problems for @xmath333 propagates up the hierarchy : all decision problems are undecidable for @xmath359 , as well as for generic two - way automata .",
    "figure  [ fig : expr ] summarizes the known inclusion between classes of multi - tape automata .",
    "solid lines denote strict inclusions and dotted lines denote weak inclusions ; namely , it is unknown whether nondeterminism increases the expressive power of asynchronous multi - tape automata with unbounded reversals .",
    "( reg ) * synchronized * + ( deterministic , nondeterministic ) + ( one - way , two - way ) ; ( dao ) [ below = of reg ] * deterministic * + * asynchronous * + * one - way * ; ( nao ) [ right = of dao ] * nondeterministic * + * asynchronous * + * one - way * ;    ( dar ) [ below = of dao ] * deterministic * + * asynchronous * + * rewinds * ; ( darw ) [ below = of dar ] * deterministic * + * asynchronous * + * reversals * ;    ( nar ) [ below = of nao ] * nondeterministic * + * asynchronous * + * rewinds * ; ( narw ) [ below = of nar ] * nondeterministic * + * asynchronous * + * reversals * ;    ( reg ) edge ( dao ) ; ( dao ) edge ( dar ) ; ( dar ) edge ( darw ) ;    ( dao ) edge ( nao ) ; ( nao ) edge ( nar ) ; ( nar ) edge ( darw ) ;    ( darw ) edge [ dotted ] ( narw ) ;    table  [ tab : closure ] summarizes the known closure properties of synchronized multi - tape automata ( * syn * ) , deterministic asynchronous one - way ( * da1 * ) , nondeterministic asynchronous one - way ( * na1 * ) , deterministic asynchronous with reversals ( * dar * ) , and non deterministic asynchronous with reversals ( * nar * ) , with respect to complement @xmath409 , intersection @xmath350 , union @xmath410 , projection @xmath411 , generalization @xmath412 , concatenation @xmath413 , kleene star @xmath414 , and reversal @xmath415 .",
    "`` y '' means closure , `` n '' means non - closure , `` n '' denotes closure within the next class , and `` ? '' means open problem .",
    ".closure properties of multi - tape automata . [ cols=\"^,^,^,^,^,^,^,^\",options=\"header \" , ]",
    "this section describes an algorithm for the intersection of multi - tape nondeterministic asynchronous one - way finite - state automata .",
    "since these are not closed under intersection , the algorithm may not terminate ( or , equivalently , it may define an infinite - state automaton as result ) .",
    "we use a slightly different definition of multi - tape automaton , which is easily seen equivalent to definition  [ def : nda ] in the one - way case .",
    "[ def : n - tape - aut ] an _ @xmath12-tape finite - state automaton _",
    "@xmath56 is a tuple @xmath416 where : @xmath5 is the input alphabet , with @xmath417 ; @xmath418 is the set of tapes ; @xmath52 is the finite set of states ; @xmath419 assigns a tape to each state ; @xmath420 is the ( nondeterministic ) transition function ; @xmath421 are the initial states ; @xmath55 are the accepting ( final ) states .",
    "consider two asynchronous automata @xmath424 and @xmath425 , such that @xmath56 has @xmath19 tapes @xmath426 and @xmath207 has @xmath12 tapes @xmath427 .",
    "we now describe an algorithm that computes the intersection @xmath428 of @xmath56 and @xmath207 , where @xmath429 ; @xmath260 s tapes @xmath430 are the union of @xmath431 and @xmath432 . to describe the algorithm , we introduce repeated operations as separate routines .",
    "all components of the algorithm have access to the definitions of @xmath56 and @xmath207 and to a global stack ` s ` where new states of the composition are pushed ( when created ) and popped ( when processed ) .",
    "routine ` async_next ` takes a @xmath433-tape automaton @xmath352 ( i.e. , @xmath56 or @xmath207 ) and one of its states @xmath143 , and returns a set of tuples @xmath434 of all next states reachable from @xmath143 either directly or by accumulating delayed transitions @xmath435 in tape @xmath436 , for @xmath437 .",
    "we call _ delayed states _ such tuples of states with delayed transitions .",
    "the search for states reachable from @xmath143 stops at the first occurrences of states associated with a certain tape .",
    "figure  [ fig : asyncnext ] shows the pseudo - code for ` async_next ` .    ....",
    "async_next ( d , q ) : set [ $ \\langle q ' , h_1 , \\ldots , h_t \\rangle$ ]     -- $ q$ is always reachable from itself     result $ : = \\ { \\langle q , \\epsilon , \\ldots , \\epsilon\\rangle \\}$     -- for every tape other than $ q$ 's     for each $ t_i \\in \\{t_1^d , \\ldots , t_t^d\\ } \\setminus \\tau^d(q)$",
    "do        $ p : = \\text{all shortest paths } p \\text { from } q \\text { to some } \\overline{q }   \\text { such that : } $              $ \\tau^d(\\overline{q } ) = t_i \\text { and no state } \\widetilde{q } \\text { with } \\tau^d(\\widetilde{q } ) = t_i \\text { appears in } p \\text { before } \\overline{q}$        -- each element in $ p$ is a sequence of transitions        for each $ e_1\\,\\cdots\\,e_m \\in p$ do           $ h_1 , \\ldots , h_t : = \\epsilon$           -- each transition is a triple ( source , input , target )           for each $ ( q_1 , \\sigma , q_2 ) \\in e_1\\,\\cdots\\,e_m$ do              -- add the transition to the sequence corresponding              -- to its source 's tape              $ h_{\\tau^d(q_1 ) } : = h_{\\tau^d(q_1 ) } + ( q_1 , \\sigma , q_2)$           -- $ q_2(e_m)$ is the target state of the last transition $ e_m$           result $ : = $ result $ \\cup \\langle q_2(e_m ) , h_1 , \\ldots , h_t\\rangle$ ....    consider now a pair of delayed states @xmath438 and @xmath439 , respectively for automata @xmath56 and @xmath207 .",
    "the two delayed states can be composed only if the delays on the synchronized tapes are pairwise _ consistent _ , that is the sequence of input symbols of one is a prefix ( proper or not ) of the other s ; ` cons($h_i , k_i$ ) ` denotes that the sequences @xmath440 of delayed transitions are consistent .",
    "routine ` new_states ` ( in figure  [ fig : newstates ] ) takes two sets @xmath441 of delayed states and returns all consistent states obtained by composing them . `",
    "new_states ` also pushes onto the stack ` s ` all composite states that have not already been added to the composition . for convenience , ` new_state ` also embeds the tape @xmath433 of each new composite state within the state itself",
    ".    .... new_states ( p : set[$\\langle p , h_1 , \\ldots , h_m \\rangle$ ] , q : set[$\\langle q , k_1 , \\ldots , k_n \\rangle$ ] ) : s     s $ : = \\emptyset$     for each $ \\langle p , h_1 , \\ldots , h_m \\rangle \\in p$ , $ \\langle q , k_1 , \\ldots , k_n \\rangle \\in q$ do        -- if delays on synchronized tapes are consistent        if $ \\forall i \\in t^a \\cap t^b:$ cons($h_i , k_i$ ) then           for each $ t \\in t$ do $ s : = s \\cup \\{\\langle p , q , t , h_1 , \\ldots , h_m , k_1 , \\ldots , k_n \\rangle \\}$ end     -- here $ q$ denotes $ c$ 's set of states , not the input argument     for each $ r \\in s$ do if $ r \\not\\in q$ then s.push ( r ) end ....    it is often convenient to add arbitrary prefixes to the delays of delayed states generated by ` new_states ` . to this end , routine ` compose_transition ` ( in figure  [ fig : composetransition ] ) takes two sets @xmath441 of delayed states and an @xmath442-tuple of delays , and calls ` new_states ` on the modified states obtained by orderly adding the delays to the states in @xmath443 and @xmath52",
    ". it also adds all transitions to the newly generated states to the transition function @xmath92 of the composite @xmath260 .    .... compose_transition ( p : set[$(p , h_1 , \\ldots , h_m)$ ] , q : set[$(q , k_1 , \\ldots , k_n)$ ] ,                       d : ( $ h_1 , \\ldots , h_m , k_1 , \\ldots , k_n$ ) , $ \\sigma$ , r )     $ j_a : = \\ { ( p , h_1\\,h_1 ' , \\ldots , h_m\\,h_m ' ) \\mid ( p , h_1 ' , \\ldots , h_m ' ) \\in p \\}$     $ j_b : = \\ { ( q , k_1\\,k_1 ' , \\ldots , k_n\\,k_n ' ) \\mid ( q , k_1 ' , \\ldots , k_n ' ) \\in q \\}$     $ s : = $ new_states ( $ j_a , j_b$ )     for each $ r ' \\in s$ do $ \\delta : = \\delta \\cup \\{r , \\sigma , r'\\}$ end ....",
    "we are ready to show the main routine ` intersect ` which builds @xmath260 from @xmath56 and @xmath207 .",
    "since the intersection may have infinite states , ` intersect ` takes as arguments a bound on the maximum number of states and on the maximum delay ( measured in number of transitions ) accumulated in the states .    .... intersect",
    "( max_states , max_delay )    $ q : = \\emptyset$ ; $ s : = \\emptyset$    -- $ a$ 's initially reachable states    $ j_a : = \\bigcup_{i \\in i_a}$ async_next ( a , i )    -- $ b$ 's initially reachable states    $ j_b : = \\bigcup_{i \\in i_b}$ async_next ( b , i )    s $ : = $ new_states ( $ j_a$ , $ j_b$ )    -- mark these states as initial    $ i : = s$    until $ s = \\emptyset$ or $ |q| \\geq$ max_states loop      r $ : = $ ( $ q_a , q_b , t , h_1 , \\ldots , h_m , k_1 , \\ldots , k_n$ ) $ = $ s.pop      if $ \\forall d \\in \\ { h_1 , \\ldots , k_n \\ } : |d|",
    "\\leq $ max_delay then         $ q : = q \\cup \\ { r \\}$       else continue      $ q : =",
    "q \\cup \\ { r \\}$      if $ t \\in t^a \\cap t^b$ then        -- event on shared tape        if $ h_t = ( u_a , \\sigma , u_a ' ) \\overline{h_t}$ and $ k_t = ( u_b , \\sigma , u_b ' ) \\overline{k_t}$ then          -- delayed transition on both $ a$ and $ b$          $ p : = $ async_next $ ( a , q_a)$          $ q : = $ async_next $ ( b , q_b)$          $ d : = ( h_1 , \\ldots , \\overline{h_t } , \\ldots , h_m , k_1 , \\ldots , \\overline{k_t } , \\ldots , k_n)$          compose_transition ( $ p , q , d , \\sigma , r$ )        elseif $ h_t = ( u_a , \\sigma , u_a ' ) \\overline{h_t}$ and $ k_t = \\epsilon$ then          -- delayed transition on $ a$          $ p : = $ async_next $ ( a , q_a)$          -- normal transition on $ b$          $ q : = \\{$ async_next ( $ b , q_b'$ ) $ \\mid ( q_b , \\sigma_b , q_b ' ) \\in \\delta^b \\land \\sigma = \\sigma_b \\land \\tau^b(q_b ) = t \\}$          $ d : = ( h_1 , \\ldots , \\overline{h_t } , \\ldots , h_m , k_1 , \\ldots , k_n)$          compose_transition ( $ p , q , d , \\sigma , r$ )        elseif $ h_t = \\epsilon$ and $ k_t = ( u_b , \\sigma , u_b ' ) \\overline{k_t}$ then          -- delayed transition on $ b$          $ q : = $ async_next $ ( b , q_b)$          -- normal transition on $ a$          $ p : = \\{$ async_next ( $ a , q_a'$ ) $ \\mid ( q_a , \\sigma_a , q_a ' ) \\in \\delta^a \\land \\sigma = \\sigma_a \\land \\tau^a(q_a ) = t \\}$          $ d : = ( h_1 , \\ldots , h_m , k_1 , \\ldots , \\overline{k_t } , \\ldots , k_n)$          compose_transition ( $ p , q , d , \\sigma , r$ )        elseif $ h_t = k_t = \\epsilon$ then          for each $ \\sigma \\in \\sigma$ do            -- normal transition on both $ a$ and $ b$            $ p : = \\{$ async_next ( $ a , q_a'$ ) $ \\mid ( q_a , \\sigma_a , q_a ' )",
    "\\in \\delta^a \\land \\sigma_a = \\sigma \\land \\tau^a(q_a ) = t \\}$            $ q : = \\{$ async_next ( $ b , q_b'$ ) $ \\mid ( q_b , \\sigma_b , q_b ' ) \\in \\delta^b \\land",
    "\\sigma_b = \\sigma \\land \\tau^b(q_b ) = t \\}$            $ d : = ( h_1 , \\ldots , h_m , k_1 , \\ldots , \\ldots , k_n)$            compose_transition ( $ p , q , d , \\sigma , r$ )      elseif $ t \\in t^a \\setminus t^b$ then        -- event on $ a$ 's non - shared tape        if $ h_t = ( u_a , \\sigma , u_a ' ) \\overline{h_t}$ then          -- delayed transition on $ a$ , $ b$ stays          $ p : = $ async_next $ ( a , q_a)$          $ q : = \\ { ( q_b , \\epsilon , \\ldots , \\epsilon ) \\}$          $ d : = ( h_1 , \\ldots , \\overline{h_t } , \\ldots , h_m , k_1 , \\ldots , k_n)$          compose_transition ( $ p , q , d , \\sigma , r$ )        elseif $ h_t = \\epsilon$ then          -- normal transition on $ a$ , $ b$ stays            $ q : = \\ { ( q_b , \\epsilon , \\ldots , \\epsilon ) \\}$            for each $ \\sigma \\in \\sigma$",
    "do              $ p : = \\{$ async_next ( $ a , q_a'$ ) $ \\mid ( q_a , \\sigma_a , q_a ' ) \\in \\delta^a \\land \\sigma_a = \\sigma \\land \\tau^a(q_a ) = t \\}$              $ d : = ( h_1 , \\ldots , h_m , k_1 , \\ldots , k_n)$              compose_transition ( $ p , q , d , \\sigma , r$ )      elseif $ t \\in t^b \\setminus t^a$ then        -- event on $ b$ 's non - shared tape        if $ k_t = ( u_b , \\sigma , u_b ' ) \\overline{k_t}$ then          -- delayed transition on $ b$ , $ a$ stays          $ p : = \\ { ( q_a , \\epsilon , \\ldots , \\epsilon ) \\}$          $ q : = $ async_next $ ( b , q_b)$          $ d : = ( h_1 , \\ldots , h_m , k_1 , \\ldots , \\overline{k_t } , \\ldots , k_n)$          compose_transition ( $ p , q , d , \\sigma , r$ )        elseif $ k_t = \\epsilon$ then          -- normal transition on $ b$ , $ a$ stays            $ p : = \\ { ( q_a , \\epsilon , \\ldots , \\epsilon ) \\}$            for each $ \\sigma \\in \\sigma$ do              $ q : = \\{$ async_next ( $ b , q_b'$ ) $ \\mid ( q_b , \\sigma_b , q_b ' )",
    "\\in \\delta^b \\land \\sigma_b = \\sigma \\land \\tau^b(q_b ) = t \\}$              $ d : = ( h_1 , \\ldots , h_m , k_1 , \\ldots , k_n)$              compose_transition ( $ p , q , d , \\sigma , r$ ) ...."
  ],
  "abstract_text": [
    "<S> this paper summarizes the fundamental expressiveness , closure , and decidability properties of various finite - state automata classes with multiple input tapes . </S>",
    "<S> it also includes an original algorithm for the intersection of one - way nondeterministic finite - state automata . </S>"
  ]
}