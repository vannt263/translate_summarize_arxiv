{
  "article_text": [
    "several different approaches have been considered so far to enrich the sld resolution in order to improve the performance of top - down interpreters .",
    "the usual objective is to reduce the search space without loss of results of the refutation process , possibly obtaining a finite search space . among the proposed methods ,",
    "the loop check mechanisms @xcite , @xcite , @xcite , @xcite ,  and the tabulation technique @xcite , @xcite , @xcite , @xcite , @xcite , aim to eliminate redundant computations and to enforce the termination of a query over a logic program .",
    "loop check mechanisms provide the interpreter with the capability of pruning certain nodes of the sld tree .",
    "the pruning is based on excluding some kinds of structural repetitions for the goals in a derivation path .",
    "when suitable structure repetitions are found , further rewritings of the current node are ignored , because any solution possibly existing in the cut sub - tree is also present in other parts of the sld tree .",
    "different forms of loop checks are proposed in the literature .",
    "in particular , bol et al . have defined several _",
    "simple _ loop checks , i.e. loop checks whose pruning mechanisms do not depend on the considered logic program , and have analysed them against the basic property of soundness and completeness @xcite .",
    "the completeness property concerns with the capability of pruning every infinite derivation .",
    "in contrast , soundness concerns with the preservation of the computed answer substitutions .",
    "the main idea of tabulation originates from functional programming and consists in building a table during the search of answers in an sld tree .",
    "the table contains entries for atoms with the corresponding answers so far computed .",
    "these answers are to be used later , when instances of such atoms should be recomputed .",
    "such instantiated occurrences are named _ non - admissible atoms _ ( or _ consumer _ ) .",
    "in essence , non - admissible atoms are not resolved against clauses but against answers computed in other parts of the sld tree . the re - using approach exploited by the tabulation technique",
    "was already mentioned by kowalski @xcite and has been proposed several times under different names , such as memo - isation @xcite , and al - technique @xcite .",
    "the conceptual differences between loop checks and tabulation are reflected in several interesting aspects . in particular",
    ", tabulation requires a local selection rule to guarantee the answer preservation , while no missing of solution is possible with ( sound ) loop checks independently of the used selection rule . on the other hand ,",
    "the tabulation technique ensures termination for any function - free program and for any program with a finite herbrand model , while the completeness of loop checks takes place for specific classes of programs possibly with respect to given selection rules @xcite , @xcite , @xcite .",
    "finally , loop checks exploit no auxiliary data structure and the pruning decision usually depends on the current derivation only , while tabulation needs a table to store the answers of atoms solved in the previously traversed portion of the tree .",
    "proposals can be also found in literature for a synergistic use of different techniques aiming to optimise the query evaluation procedure .",
    "in particular , in @xcite a loop checking mechanism is combined with the tabulation technique in order to eliminate some redundant parts of the search space . in @xcite",
    "the simple loop check mechanisms proposed in @xcite are combined with another form of redundancy elimination which is named ( goal ) _",
    "reduction_. goal reduction is conceptually analogous to the _ condensing _ technique proposed by joyner for the proof of the unsatisfiability of first - order formulas @xcite . in both cases",
    "redundant atoms are eliminated from resolvents , in order to avoid useless computations and to contain the size of the resolvents at the same time .",
    "the main idea of reduction originates from the observation that if there exists a refutation for an atom , then a refutation exists also for any more general version of that atom . in this sense ,",
    "such more general versions can be seen as potentially redundant and we can imagine to remove them from the resolvent , though suitable cares are to be taken as discussed in @xcite . by goal reduction , a generalised form of sld resolution ( named rsld ) can be obtained , where a reduction of the resolvent is performed after each rewriting step .",
    "goal reduction technique has a modus operandi which shows evident affinity with the one of loop checking mechanisms .",
    "indeed , with reduction redundant atoms are definitively ignored , as it is done with loop checks for pruned nodes .",
    "this is not the case with tabulation , in the sense that non - admissible atoms , which are indeed solved against previously tabulated answers , are not redundant .",
    "such different philosophy between tabulation and rsld is highlighted also by the fact that the reduction technique eliminates atoms in their _ more general version _ , while non - admissible atoms are _ instances _ of previously solved goals .",
    "it is evident that rsld does not need any auxiliary data structure because it considers only the current goal ( not even the current derivation path ) .",
    "the soundness of rsld is shown in @xcite independently of the used selection rule .",
    "this means that rsld does not require particular selection rules in order to ensure answer preservation .",
    "it is intuitive that redundancy elimination may have positive effects on derivation process . in @xcite ,",
    "advantageous combinations are shown with respect to loop checking mechanisms .",
    "in particular , it is proven that a well known simple loop check mechanism , namely equality variant check of resultant as lists ( @xmath0 ) , becomes complete for several classes of programs , provided that rsld is exploited instead of usual sld .",
    "the specific reason is that the length of resolvents can be maintained within the limit of a finite value through systematic elimination of redundant atoms .",
    "in essence , there is clear evidence that the strength of equality loop checks can augment if rsld resolution is used .",
    "however , even though not completely intuitive , redundancy elimination can produce undesirable effects , too .",
    "in fact , as exemplified later , problems can arise with program termination , as well as with the completeness of loop checking mechanisms .",
    "the rationale behind this is that redundancy elimination can affect the actual sequence of atom rewriting with respect to given selection rules .",
    "this can ( infinitely ) delay the selection of failing atoms , so that termination is missed . on the other hand ,",
    "the structure of the obtained resolvents can be altered by redundancy elimination , so that loop checks may become unable to detect infinite derivations .    as shown in this paper , missing termination and",
    "loop detection depends critically on the used selection rule .",
    "we say in the sequel that a selection rule is _ redundancy elimination tolerant _ if no loss in termination and/or loop detection comes out , passing from sld to rsld .    in section [ s1.goalredu ]",
    ", we prove that termination and @xmath0 completeness are preserved if they hold in sld with respect to all possible selection rules .",
    "then , a more accurate analysis of redundancy elimination tolerance is performed . to this aim ,",
    "a careful reconsideration of selection rule basic concepts will be required , so that we will be led to a reformulation of selection rule ideas in terms of their operational counterparts , namely _ scheduling mechanisms _ , so that we will prefer to talk of tolerant scheduling rules . as a matter of fact ,",
    "in section [ s2.priosche ] we provide a highly expressive execution model based on priority mechanism for atom selection .",
    "a priority is assigned to each atom in a resolvent , and primary importance is given to the event of arrival of new atoms from the body of the applied clause at rewriting time .",
    "indeed , new atoms can be freely positioned with respect to the old ones in the resolvent , through the assignment of priority values according to a given scheduling rule . then , at any derivation step , the atom with optimum priority is simply selected .",
    "this new computational model proves able to address the study of redundancy elimination effects , giving at the same time interesting insights into general properties of selection rules . as a matter of fact , in section [ s3.specfree ] a class of scheduling rules , namely the _ specialisation independent _ ones , is defined by using not trivial semantic arguments .",
    "several properties of specialisation independent scheduling rules are also proven . as a quite surprising result , in section [ s4.stacqueu ]",
    "we show that specialisation independent scheduling rules coincide with _ stack - queue rules _",
    ", which have an immediate structural characterisation .",
    "indeed , the stack - queue scheduling technique is simply defined so that , in order to obtain the new resolvent at rewriting time , part of new atoms are stacked at the beginning of the old resolvent while the remaining ones are queued . then in section [ s5.reduelim ] we prove that such scheduling rules are tolerant to redundancy elimination , in the sense that neither program termination nor completeness of equality loop check is lost passing from sld to rsld . the proof is largely based on properties which we have established for specialisation independent ( and stack - queue ) scheduling rules .",
    "throughout the paper we assume familiarity with the basic concepts of logic programming @xcite , @xcite , @xcite .    here , only some notations are given about sld derivation procedure , which can be described as follows .",
    "let @xmath1 be a _ goal _",
    ", constituted by a conjunction of @xmath2 atoms , and @xmath3 a _ clause _ , where@xmath4is an atom and@xmath5is a goal .",
    "the goal @xmath6 is a _ resolvent _ of@xmath7and@xmath8by a renaming @xmath9 and a substitution @xmath10 , if an atom @xmath11 exists , with @xmath12 , such that @xmath13 , where @xmath14 is an idempotent and relevant mgu of @xmath15 and @xmath11 . in the sequel , given an expression @xmath16 ,",
    "the notation @xmath17 will indicate the set of variables in @xmath16 .",
    "moreover , we will denote by @xmath18 the fact that @xmath6 is a resolvent of@xmath19and@xmath8by @xmath9 and @xmath20 .",
    "initial goal _ @xmath21 and a logic program p , an _ sld derivation of _ @xmath21 _ _  in p _ _ is a possibly infinite sequence of the type :",
    "@xmath22    such that , for any @xmath23 , each clause @xmath24 belongs to p and each @xmath25 is _ standardised apart _ , i.e.    @xmath26    a _ selection rule _ is a function which chooses the atom to be rewritten in the last resolvent of any finite sld derivation . given a selection rule@xmath27 an sld derivation is _ _",
    "via__@xmath28if all the selections of atoms are performed in agreement with@xmath29 an sld _ refutation _ is a finite sld derivation such that the last resolvent is empty .",
    "now we can introduce the definitions of _ goal reduction _ and rsld derivation .",
    "the reduction technique aims to eliminate redundant atoms from the resolvents in order to contain their size .",
    "analogous issue was already been faced for the proof of the unsatisfiability of first - order formulas .",
    "indeed joyner @xcite noted that the increase in size of resolvents is a factor which prevents resolution strategies being decision procedures for solvable classes of first - order formulas ( i.e. classes of formulas for which the question of satisfiability or unsatisfiability can be effectively decided ) . to limit the growth of the number of literals",
    ", joyner introduced a technique for simplifying resolvents , called _ condensing_.",
    "the condensation of a clause is defined as the smallest subset of the clauses which is also an instance of it . in other words",
    ", the condensation of a clause can be obtained by applying a substitution @xmath30 and eliminating all the atom repetitions .    with reference to sld derivations ,",
    "the most evident form of redundancy corresponds to multiple occurrences of the same atom in a resolvent .",
    "it is obvious that this kind of atom repetition is essentially redundant .",
    "however , this is not the only possible case of redundancy .",
    "indeed , the reduction technique , which is introduced in @xcite as a variant of joyner s condensing technique , is able to perform quite general actions of redundancy elimination from resolvents while preserving the soundness and the completeness of rsld resolution . by condensation , joyner obtains a complete and sound resolution procedures , which work as decision procedures for several solvable classes of first order formulas @xcite . by reduction ,",
    "the well known sound @xmath0 loop check becomes complete for several classes of logic programs @xcite .",
    "intuitively , the basic idea of goal reduction technique can be explained as follows .",
    "suppose having to refute a resolvent which contains @xmath31 and @xmath32 , where @xmath33 is a variable and @xmath34 is a constant .",
    "obviously , any refutation for @xmath35 implies a refutation for the atom @xmath31 , as @xmath31 is more general than @xmath35 . in this sense ,",
    "the atom @xmath31 may appear as a redundant one .",
    "actually , in order to ensure the soundness of the derivation process , the elimination of redundant atoms ( such as @xmath31 above ) is conditioned in two aspects which can be sketched through the following simple examples :    1 .",
    "consider a resolvent like @xmath36 . in this case ,",
    "the atom @xmath31 can not be eliminated , because the connection between the atoms @xmath37 and @xmath38 , by the variable @xmath33 , is lost .",
    "2 .   suppose that @xmath33 is a variable in the initial goal of a derivation , and the actual resolvent is @xmath39 . in this case",
    "@xmath31 can not be dropped , because possible instantiations of @xmath33 in computed answers could be lost .",
    "so we would obtain computed answers which are too general with respect the correct answers , thus missing soundness .",
    "now we present a formal definition of goal reduction which takes into account the observations a ) and b ) and follows the line of definition 2.1 presented in @xcite .",
    "we will denote by @xmath40 the inclusion relation between goals , and @xmath41 will indicate the goal obtained from @xmath42 by eliminating the atoms which are present in @xmath43 . in both cases",
    "the goals are regarded as lists .",
    "[ d1.1 ] let @xmath44 be a set of variables , @xmath45 a substitution and@xmath7a goal .",
    "a goal@xmath46is a _ reduced goal _",
    "of@xmath47by @xmath45 up to @xmath44 , denoted by @xmath48 , if the following conditions hold :    \\i ) @xmath49    \\ii ) @xmath50    \\iii ) @xmath51it is @xmath52    in agreement with the above definition , a part @xmath53 of atoms of@xmath7can be eliminated if a substitution @xmath45 exists such that @xmath54 , for any atom @xmath55 , provided that @xmath45 does not affect neither the variables in@xmath46nor those in @xmath44 .",
    "the imposition that @xmath45 does not affect the variables in@xmath46prevents the kind of difficulties which are exemplified in a ) .",
    "[ e1.1 ] let :    @xmath56    @xmath57    the following goal@xmath46is a reduced goal of@xmath7by @xmath58 up to @xmath44 :    @xmath59  @xmath60    performing reductions in the resolvents of an sld derivation corresponds to an actual extension of the sld resolution process .",
    "then , a generalised version of sld resolution can be introduced , i.e. the _ reduced sld resolution _",
    "( rsld in the sequel ) , where at any resolution step a reduction of the resolvent is allowed .",
    "the following is the formal definition of rsld derivations .",
    "[ d1.2 ] let @xmath61 be a program and @xmath21 a goal .",
    "a _ reduced sld derivation _ of @xmath21 in @xmath61 ( rsld in the following ) is a possibly infinite sequence of the form :    @xmath62    where , for any",
    "@xmath63    \\i ) @xmath24 is a clause in @xmath61 ,    \\ii ) @xmath64",
    "\\iii ) @xmath65 up to @xmath66    it is evident that an sld derivation is a particular case of rsld derivation where @xmath67 , for any @xmath68 .",
    "each @xmath69 is called a _ reduced resolvent_. condition ii ) above is the usual standardisation apart requirement .",
    "condition iii ) prevents the kind of difficulties which are exemplified in b ) , guaranteeing the soundness of the mechanism .",
    "the soundness and completeness of rsld resolution are proven in theorems 2.1 and 2.2 of @xcite .",
    "the completeness of rsld resolution ensures that missing computed answers is impossible when we pass from sld to rsld .",
    "this is not the case with termination , as shown by the following example [ e1.1.1 ] . in the example",
    "a selection rule@xmath28and a program p are given , such that any sld derivation of p via@xmath28terminates independently of the initial goal .",
    "however , we show that termination is lost , if reduction of resolvents is performed .",
    "[ e1.1.1 ] let us consider a selection rule@xmath28such that , given a goal @xmath42 , the first atom is chosen for rewriting if the length of@xmath7is odd , and the last atom is chosen otherwise .",
    "let us consider the logic program p consisting of the following clause :    @xmath70    it can be easily seen that all sld derivations in p via@xmath28terminate , independently of the initial goal . indeed , suppose that the initial goal has an odd number of atoms .",
    "it is evident that either the derivation via@xmath28fails immediately or the initial goal has the form `` @xmath71 '' , so that the first step of the derivation produces a resolvent of an even length as follows :    @xmath72    now , either the derivation fails immediately or @xmath73 , so that a second derivation step is performed :    @xmath74 ,    and the process fails anyway , since the last resolvent has an odd length . then , suppose on the contrary that the initial goal has an even number of atoms .",
    "either the derivation fails immediately or the initial goal has the form `` @xmath75 '' . in the second case",
    ", the first derivation step gives place to a resolvent with an odd length , so that the derivation fails .",
    "now , let us verify that termination can be lost if reduction of resolvents is performed .",
    "indeed , let us consider the rsld derivation of the goal @xmath76 in p via @xmath77 given in figure [ f1 ] .",
    "it is evident that the number of atoms is even in any reduced resolvent .",
    "thus , the last atom is always selected and the derivation is infinite .  @xmath60     + @xmath78 + @xmath79@xmath80 + @xmath81 + @xmath82@xmath80 + @xmath83 + @xmath84 @xmath85 + ........................ .....................    as shown by the example in figure [ f1 ] , termination with respect to a given selection rule can be missed , if we pass from sld to rsld resolution . on the contrary ,",
    "we show in this section ( theorem [ t1.1.1 ] ) that termination is preserved , when any sld derivation of@xmath7 in p is finite independently of the used selection rule .",
    "theorem [ t1.1.1 ] will be proven as an immediate consequence of the following lemma [ l1.1.1 ]    [ l1.1.1 ] let p be a program and @xmath21 a goal . for any possibly infinite rsld derivation @xmath86 of @xmath21 in p , an sld derivation @xmath87 of @xmath21 in p exists , such that every reduced resolvent of @xmath86 is included in the corresponding resolvent of @xmath87 up to renamings .",
    "consider a possibly infinite rsld derivation @xmath86 of @xmath21 in p    @xmath88    @xmath89(1 )    intuitively , the sld derivation @xmath87 is obtained by choosing , step by step , the same clause and the same atom as in @xmath86 . this way ,",
    "redundant atoms are not eliminated from resolvents of @xmath87 , but they have no real influence on the derivation process . more formally ,",
    "suppose that an sld derivation of @xmath21 in p is already constructed like    @xmath90(2 )    such that , for any @xmath91 , a renaming @xmath92 exists with @xmath93 it is easy to show that derivation ( 2 ) can be extended of one step in agreement with the lemma .",
    "let @xmath34 be the atom which is rewritten in the step @xmath94 of derivation ( 1 ) .",
    "it is evident that the clause @xmath95 is applicable to the atom @xmath96 so that we have an sld derivation step of the form :    @xmath97(3 )    now let @xmath98 denote the sublist of atoms in @xmath99 which derives from @xmath100 .",
    "it is obvious that the subgoal @xmath101 has no active role in derivation step ( 3 ) .",
    "so , we have that @xmath98 is a variant of @xmath102 , i.e. a renaming @xmath103 exists with @xmath104 , which means that @xmath105 .",
    "but , by definition of goal reduction we have @xmath106 as a consequence    @xmath107  @xmath60    [ t1.1.1]let p be a program and@xmath7a goal .",
    "if every sld derivation of@xmath7 in p is finite independently of the used selection rule , then every rsld derivation of@xmath7 in p is finite too .",
    "suppose that an infinite rsld derivation of@xmath7 in p exists . by lemma [ l1.1.1 ] , an infinite sld derivation of@xmath7 in p also exists , which contradicts the hypothesis .",
    "the termination issue of a query to a logic program has attracted much attention over the past few years , both in the logic programming field , and in the deductive database field ( see @xcite for a survey ) .    a well known approach to the termination problem of a query in a logic program consists in modifying the computation mechanism by adding a capability of pruning , i.e. at some point the interpreter is forced to stop its search through a certain part of the sld tree @xcite ,  @xcite ,  @xcite ,  @xcite ,  @xcite ,  @xcite .",
    "these mechanisms are called _ loop checks _ , as they are based on discovering some kinds of repetitions in derivation paths .",
    "the purpose of a loop check is to reduce the search space for top - down interpreters in order to prune infinite derivations , without loss of results of the refutation process .",
    "thus , two basic properties are considered for loop checks .",
    "the _ completeness _ property of a loop check concerns the capability of pruning every infinite derivation .",
    "in contrast , the _ soundness _ property has to do with the preservation of computed answer substitutions .",
    "different forms of loop checking are considered in literature .",
    "a systematic analysis of loop checking for sld resolution is given in @xcite .",
    "_ simple loop checks _ have deserved special interest , because the decision of pruning does not depend on the logic program we are confronted with .",
    "the more immediate form of simple and sound loop check is the so called _ equality variant of resultant _ check , which requires the detection of equal ( up to renaming ) resultants in the derivation .",
    "such a loop check is formulated with respect to rsld derivations in the following definition [ d1.2.1 ] which recalls the essence of the analogous definition 3.19 in @xcite .",
    "the notation @xmath108 is used , which means that the goal @xmath98 is equal to @xmath42 , where the goals are regarded as lists .",
    "[ d1.2.1 ] an rsld derivation    @xmath109    is _ pruned _ by _ equality variant of resultant as lists _",
    "loop check ( @xmath0 in the following ) , if for some @xmath110 and @xmath68 , with @xmath111 , a renaming @xmath45 exists such that :    \\i ) @xmath112    \\ii ) @xmath113    given an rsld tree t , the application of @xmath0 yields a prefix tp of t which is obtained in this way .",
    "the descendants of a node are thrown away iff the derivation associated with the path from the root to the node is pruned .",
    "any couple @xmath114 $ ] is a _ reduced resultant_. given two resultants @xmath115 $ ] and @xmath116,$ ] for which requirements i ) and ii ) of definition [ d1.2.1 ] hold , we will write @xmath117 in other words , definition [ d1.2.1 ] expresses that @xmath0 check is based on detecting that a resultant is obtained which is related by @xmath118 to a preceding one in the same derivation . it is worth noting that the relationship @xmath118 is an equivalence relationship .",
    "it is evident that , if reduction of resolvents is always ineffective ( i.e. @xmath67 , for any @xmath68 ) , the usual @xmath0 loop check for sld derivations is found again .",
    "it is well known that @xmath119 is a sound loop check in the case of sld resolution .",
    "the soundness of @xmath0 is extended to the more general case of rsld by theorem 4.1 of @xcite .",
    "let us observe that if we do not consider condition i ) in definition [ d1.2.1 ] we obtain the @xmath120 loop check which is based on detecting that a resolvent is obtained which is a variant of a preceding one in the same derivation .",
    "it is worth noting that @xmath120 is a _ weakly sound _ loop check , in sense that it preserves at least a successful , but it does not ensure the preservation of the computed answer substitutions @xcite .    the completeness of a loop check is usually referred to given selection rules and classes of programs .",
    "a loop check is complete for a program p with respect to a selection rule@xmath28if all infinite derivations of p via@xmath28are pruned .",
    "a loop check is complete for a class c of programs , if it is complete for every program in c. several classes of logic programs are characterised in literature for which complete loop checks can be found . actually , most of them are classes of function free programs , i.e. programs whose clauses contain no function symbol @xcite , @xcite , @xcite , @xcite . in the following of this section , and",
    "later in section [ s5.reduelim ] , we consider the problem of preserving the completeness of @xmath0 check , passing from sld to rsld resolution , in the case of function free programs .",
    "let us first show how the completeness of equality loop checks , with respect to a given selection rule , can be lost passing from sld to rsld .",
    "indeed , it is sufficient reconsider example [ e1.1.1 ] . in that case",
    "@xmath0 loop check is obviously complete , since no infinite sld derivation exists . on the other hand ,",
    "it is obvious that @xmath0 loop check can not prune the infinite rsld derivation developed in the same example , because the length of resolvents increases at each derivation step .",
    "actually , it is immediate to verify that the infinite derivation in example [ e1.1.1 ] can not even be pruned by using more complex and powerful checks ( like @xmath121 ) which are based on _ subsumption _ relationships between resultants @xcite .",
    "now we prove that @xmath0 loop check completeness is preserved for function free programs , in the case that @xmath0 is complete with respect to all selection rules .",
    "precisely , theorem [ t1.2.1 ] states that , if @xmath122 prunes every infinite sld derivation of a goal@xmath7 in a function free program p , then @xmath0 prunes also every infinite rsld derivation of@xmath19 in p. in order to show this result , let us provide a condition which holds whenever @xmath0 prunes every infinite derivation of@xmath7 in p. lemma [ l1.2.1 ] states that , if @xmath0 check prunes all infinite derivations of@xmath7 in p , then the length of resolvents in all possible derivations is limited . in the proof of lemma [ l1.2.1 ]",
    "we exploit the notion of s - tree @xcite . given a program p and a goal @xmath42 , an s-_tree _ of@xmath7 in p is a tree where the descendants of a goal are its resolvents with respect to all selection rules and all input clauses . in other words ,",
    "an s - tree groups all sld derivations of@xmath7 in p. the notation @xmath123 represents the number of atoms in the goal @xmath124 .",
    "[ l1.2.1]let p be a program and@xmath7a goal .",
    "suppose that all infinite sld derivations of@xmath7 in p are pruned by @xmath0 .",
    "then , a finite bound @xmath125 exists such that , for each resolvent@xmath126 in any sld derivation of@xmath7 in p , it is @xmath127 .",
    "let t be an s - tree of@xmath7 in p. given a node@xmath128  in t , let @xmath129 denote the derivation associated to the path from the root of t to @xmath130 , and @xmath131 the final resolvent of @xmath129 .",
    "then , let tp be the prefix of t which is obtained by applying the @xmath0 check to t , i.e. the prefix where the descendants of any node@xmath128  of t are thrown away if and only the derivation @xmath129 is not pruned by @xmath0 . by hypothesis ,",
    "all infinite sld derivations of@xmath7 in p are pruned by @xmath0 , which means that tp has no infinite path . as a consequence , since t is a finitely branching tree , by konig s lemma ( see theorem k , in @xcite ) the prefix tp is finite .",
    "now , let @xmath132 be the depth of tp , and @xmath133 the maximum of the set @xmath134  is a node in tp@xmath135 .",
    "we prove that :    @xmath136 for any node@xmath128  in t.    the proof is by induction on the value of @xmath137 .",
    "for @xmath138 the thesis is trivial .",
    "then consider an integer @xmath139 , and suppose that @xmath140 , for any node @xmath141 with @xmath142 given a node@xmath128  of t such that @xmath143 , we show that also @xmath144 holds .",
    "since@xmath145tp , the derivation @xmath129 is pruned by @xmath0 , so that two nodes @xmath146 and @xmath147 exist in the path from the root of t to@xmath128  with :    - @xmath148(1 )    - @xmath149 is a variant of @xmath150.(2 )    now , consider the sequence of clauses which has determined the path from @xmath151 to@xmath128  in t. since t contains all sld derivations of@xmath19 in p , the same derivation steps can be repeated in t starting from @xmath152 . as a consequence , by ( 1 ) and ( 2 ) , a path from @xmath146 to a node @xmath153 exists such that :    - @xmath154 ,    - @xmath155 is a variant of @xmath131 .    by inductive hypothesis",
    "it is @xmath156 .",
    "but @xmath155 is a variant of @xmath131 , so that@xmath157 .    in conclusion",
    ", the thesis holds for every node@xmath128  in t.    [ t1.2.1]let p be a function free program and@xmath7a goal .",
    "if @xmath0 prunes every infinite sld derivation of@xmath7 in p independently of the used selection rule , then @xmath0 prunes every infinite rsld derivation of @xmath42 in p.    let @xmath86 be an infinite rsld derivation of@xmath7 in p. by lemma [ l1.1.1 ] , an sld derivation @xmath87 of@xmath7 in p also exists such that every reduced resolvent of @xmath86 is included in a resolvent of @xmath87 ( up to renamings ) . since @xmath0 prunes every infinite sld derivation of@xmath7 in p , by lemma [ l1.2.1 ] the length of resolvents of @xmath87 is limited .",
    "then , the length of reduced resolvents and resultants of @xmath86 is also limited .",
    "now , since the language of p is function free and has finite many predicate symbols and constants , the relationship denoted by @xmath118 has only finitely many equivalence classes on resultants of @xmath86 . as a consequence , for some @xmath158",
    "we have that the @xmath159 and the @xmath160 resultants of @xmath86 are in @xmath118 relationship .",
    "this implies that @xmath86 is pruned by @xmath0 .    in this section ,",
    "redundancy elimination tolerance has been proven on the basis of a rather strong hypothesis , i.e. termination and completeness of loop checking for all possible selection rules . in section [ s2.priosche ]",
    "we will introduce a new computational model which will allow us to characterise a class of selection rules which are shown to be redundancy elimination tolerant . as a matter of fact , in section [ s5.reduelim ] we will prove that program termination and @xmath0 loop check completeness are maintained for that class of rules , passing from sld to rsld .",
    "as shown in section [ s1.goalredu ] , redundancy elimination can determine missing termination and loop check detection .",
    "this fact depends critically on the used selection rule , because redundancy elimination can affect the actual sequence of atom rewriting . as a matter of fact",
    ", it is widely acknowledged that the analysis of interdependence between derivation processes and the used selection rules is a difficult task . in our study , the necessary insights have been provided by a computation model which is based on a novel mechanism of atom choice , which works in terms of _ scheduling rules _ rather than in terms of conventional selection rules . through this new computational model ,",
    "a class of scheduling rules is identified in section [ s3.specfree ] , which is _ redundancy elimination tolerant _ in the sense that no loss in termination and/or loop detection comes out , passing from sld to rsld .",
    "we start the analysis with an observation about selection rules , as they are normally conceived in literature and used in practice . in sld derivations ,",
    "resolvents are usually regarded as lists , nevertheless selection rules are given complete free choice ability of the atom to rewrite . in this sense ,",
    "two different philosophies are superimposed , because a scheduling ( i.e. an ordering ) must coexist with an atom choice which can actually overcome the scheduling .",
    "now , in the case that resolvents are viewed as unstructured multisets instead of lists , the obvious solution is that a free choice ability is provided at rewriting time .",
    "but , if scheduling policies ( i.e. an ordering or a priority assignment ) are exploited , it may appear natural that priorities are obeyed at rewriting time , so that the atom with optimum priority is always selected .",
    "indeed , if a scheduling policy is used , the moment of addition of new atoms in the resolvent may be recognised as the really important event , when suitable priority values must be established and assigned .    in the following of the paper we consider execution mechanisms for logic programs which are based on priority scheduling policies .",
    "in particular we characterise _ scheduling rules _ informally as follows :    * a priority value is assigned to each atom in the actual resolvent , * assigned priorities are not modified in the following of the derivation , * the atom with optimum priority is always taken for rewriting .    in essence a scheduling rule is a rule that defines a priority values for any new atom which enters the actual resolvent .",
    "it is crucial that atoms from the body of the applied clause can be freely scheduled with respect to the ones already present in the resolvent , which maintain their own priority values .",
    "it is intuitive that this can be easily done if a set of `` dense '' priority values is adopted . indeed , as formalised in section [ subs2.1 ] , we will use rational numbers as priority values .",
    "now , in analogy with lloyd s definition of selection rules @xcite , we consider the subclass of scheduling rules where the schedule of new atoms is determined only by the last resolvent in the derivation , i.e. by the _",
    "current state _ of the computation .",
    "such rules will be named state _ scheduling rules_. a state scheduling rule can be seen as a rule which , for any resolvent @xmath42 and clause @xmath161 ( that is applied to the optimum priority atom ) , determines the schedule positions of the new atoms in the resolvent , through the assignment of appropriate priority values .    in other words , a state scheduling rule determines new resolvents , starting from the old ones and from applied clauses .",
    "the rewritten atom is necessarily the one with the optimum priority value .",
    "it is evident that the transformation from a resolvent to a new one , which is obtained by the addition of new atoms from the applied clause , is nothing more than a step of an sld derivation . in this sense",
    ", we can say that a state scheduling rule characterises a set of derivation steps . indeed",
    ", as formalised in section [ subs2.5 ] , a state scheduling rule can be straight conceived as a _ set of derivation steps _ , that is : the set of derivation steps which are allowed according to the scheduling rule itself",
    ". formal definition of state scheduling rules is provided in section [ subs2.5 ] .",
    "in order to characterise _ state scheduling rules _ in a formal way , we introduce the notions of _ priority goal _ and _ priority clause_. a priority goal is a goal where each atom has an associated priority value .",
    "thus , a priority goal@xmath7can be thought as a set of couples , where any couple is named _",
    "priority atom_. in the following formal definition , priority atom will be denoted by @xmath162 $ ] , where @xmath34 is an usual atom and @xmath163 is a rational number which establishes the priority of @xmath34 in @xmath42 .",
    "the symbol @xmath164 will be frequently used in the rest of the paper to denote logical implication .",
    "[ d2.1.1 ]    1 .",
    "a _ _ priority goal__@xmath7(_p - goal _ in the sequel ) is defined by a set of _ priority atoms _ ( or simply _",
    "p - atoms _ ) of the form : + @xmath165, ... a_{k}[p_{k}]\\},$ ] with @xmath166 + where each @xmath167 is an usual atom and each @xmath168 is a rational number , @xmath169 .",
    "2 .   a _ priority clause _ ( or simply a _",
    "p - clause _ ) has the form @xmath170 , where@xmath4is an atom ( without priority ) and@xmath171is a priority goal .    in the sequel",
    ", priority clauses will be referred as clauses for the sake of simplicity .",
    "capital letters will be used in the following to represent p - goals . in order to denote p - atoms",
    ", we will use notations like @xmath162 $ ] , as well as simple small letters ( as @xmath172 , etc . ) when explicit reference to priority values is not important . as a slight abuse of notation , p - goals made of only one p - atom @xmath34",
    "will be often denoted by @xmath34 . given a p - goal @xmath42 , the notations @xmath173 will indicate the number of p - atoms in @xmath42 .    in the sequel",
    ", we will exploit very frequently a basic operation which corresponds to the union of two p - goals with no common priority values .",
    "this operation is denoted by `` + '' and is said p - goal _",
    "merging_. during merging operations , atoms retain their priority values .",
    "we introduce also the idea of _ concatenation _ , which is a particular case of merging .",
    "concatenations will be denoted by the symbol `` '' ( vertical bar ) .",
    "the following are the formal definitions of merging and concatenation .",
    "it is worth noting that both these operations are associative .",
    "[ d2.1.2 ]    1 .",
    "a p - goal@xmath174is the _ merging",
    "_ of@xmath175and@xmath7(denoted by @xmath176 ) if@xmath175and@xmath7have no common priority values and @xmath177 .",
    "given two p - goals@xmath175and @xmath42 , we write@xmath178to denote that all priorities in@xmath175are less than any priority in @xmath179 a p - goal@xmath46is the _ concatenation _ of@xmath175and@xmath7(denoted by @xmath180 ) , if @xmath181 and@xmath182 .",
    "the fact that equal priority values are not admitted in a p - goal has two principal effects .",
    "the first one is that a complete ordering ( i.e. a scheduling ) is imposed on the atoms of a p - goal .",
    "in particular we assume that atoms with less priorities precede atoms with greater ones .",
    "the second effect is that possible multiple occurrences of atoms are distinguished by different priority values . on the basis of the above observations ,",
    "the following evident properties of concatenation can be stated .",
    "[ py2.1.1]given the p - goals @xmath183 , and @xmath184 , the following propositions hold :    1 .   @xmath185 or @xmath186 2 .",
    "@xmath187      throughout the paper , we will exploit a basic operator for handling priority values .",
    "it will be said ( _ priority _ ) _ shifting _ , and corresponds to a modification of priority values which does not alter the scheduling of the atoms in a p - goal .",
    "the following is the formal definition of shifting . in the sequel",
    ", shiftings will be always denoted by underlined greek letters .",
    "[ d2.2.1 ] a _ shifting _",
    "@xmath188 is an increasing one - to - one application of the type :    @xmath188 : rational @xmath189 rational .",
    "given a _ shifting _",
    "@xmath188 , and two p - goals@xmath7and@xmath175such that :    @xmath165, ... a_{k}[p_{k}]\\}$ ] and @xmath190, ... a_{k}[\\underline{\\pi } ( p_{k})]\\}$ ] ,    we say that@xmath175is a _ shifting _",
    "of@xmath7and write@xmath191 .",
    "it is evident that the composition of two shiftings is a shifting , too , as well as the inverse of a shifting .",
    "shifting operations enjoy the following four basic properties .",
    "all properties are plain consequence of the definition .",
    "the first two properties will be used very often in the sequel without explicit reference .",
    "[ py2.2.1 ]    ax - i ) @xmath192    ax - ii ) @xmath193    ax - iii )",
    "@xmath194    @xmath195  @xmath196 @xmath197   _ such that _ @xmath198 ,    ax - iv ) @xmath199",
    "@xmath200    finally let us consider a combination of shifting and merging which provides the convenient tool to formalise our ideas about scheduling of atoms in resolvents .",
    "as outlined in previous section , at any step of derivation , atoms coming from the body of the applied clause are assigned new priority values , while priorities of old atoms are left unchanged .",
    "this way , new atoms are positioned ( i.e. scheduled ) with respect to the old ones . in general , the _ positioning _ of atoms from a p - goal @xmath201 , with respect to the atoms of another p - goal @xmath98 , can be described through a composition of shifting and merging .",
    "indeed , consider an expression like @xmath202 .",
    "the effect of the shifting @xmath188 is twofold .",
    "first of all , possible conflicts of priority values between@xmath175and@xmath5can be removed , so that the merging @xmath203 is correctly performed . at the same time , yet more important , @xmath188 allows us to establish the positions which atoms from@xmath5go to occupy .",
    "since priorities are represented by rational values , it is evident that all possible allocations of atoms from @xmath201 , with respect to those in @xmath98 , can be described through suitable choices of @xmath188 .",
    "now , we are ready to frame well known logic programming concepts , as the ones of resolvent and sld derivation , in terms of priority atoms , goals and scheduling .",
    "we start with the following definition [ d2.3.1 ] , which formalises the idea of _ priority derivation step_. given a p - goal @xmath204 , in agreement with our concept of scheduling the atom @xmath34 with minimum priority is always rewritten and atoms coming from the body of the applied clause are positioned with respect to old ones to form the new resolvent .",
    "the positioning is obtained through a combination of shifting and merging , as discussed at the end of the previous section [ subs2.2 ] . with reference to definition [ d2.3.1 ] , the body@xmath5of the applied clause is first shifted by and then merged with @xmath98 , i.e. with the initial p - goal @xmath204 minus the rewritten atom .",
    "[ d2.3.1 ] consider a p - goal@xmath205 and a clause @xmath3 .",
    "let :    - @xmath9 be a renaming such that @xmath206 ,    - @xmath20 be an idempotent and relevant mgu of @xmath34 and @xmath15 ,    -@xmath207 be a shifting such that@xmath175and @xmath208 have no common priority value .",
    "we say that@xmath126is a _ resolvent _",
    "of@xmath7and@xmath8by @xmath209 , @xmath20 and @xmath188 , if :    @xmath210 .    the transformation from @xmath204 to @xmath211",
    "will be called a _ priority derivation step_. it is denoted by :    @xmath212 .",
    "the notation@xmath213 will be used to represent a derivation step by @xmath20 and @xmath9 , where the shifting is not pointed out .",
    "analogously , we will write@xmath214 to represent a derivation step by the renaming @xmath9 without specifying the mgu @xmath20 .",
    "by@xmath215 we denote a derivation step which generically produces@xmath216as a resolvent of@xmath7and @xmath161 .",
    "iterating the process of computing resolvents , we obtain a priority sld derivation , that is a sequence of priority derivation steps as formalised by the following definition .    [ d2.3.2 ] let p be a program and @xmath217 a p - goal .",
    "priority sld derivation _ of @xmath21 in p is a possibly infinite sequence of priority derivation steps    @xmath218    where , for any @xmath23 ,    \\i ) @xmath24 is a clause in p ,",
    "\\ii ) @xmath26    given a finite priority sld derivation ( p - sld _ derivation _ in the following ) of the form :    @xmath219    the sequence @xmath220 of applied clauses will be called _",
    "template_. the whole derivation will be denoted by @xmath221 , where @xmath222 , or simply @xmath223 , if the substitution @xmath20 does not need to be pointed out .",
    "we use the notation @xmath224 , when there is not interest in specifying the final resolvent . given a template @xmath225 , the notation @xmath226 will indicate the number of clauses in @xmath225 .",
    "in many cases , we will consider concatenation of templates , which is denoted by a vertical bar `` '' .",
    "it is intuitive that , given a derivation , any subset of atoms in the current resolvent _ derives from _ other specific atoms in preceding resolvents . as it will be clear in the sequel , this idea plays an important role in the development of this paper .",
    "thus , it is convenient to give some formal definitions .",
    "precisely , let us consider a p - sld derivation of the form @xmath227 .",
    "the following two intuitive concepts will be characterised :    1 .",
    "the _ _ sub - resolvent of__@xmath228_in _ @xmath229 , i.e. the subset of p - atoms in @xmath230 which derive from the subgoal@xmath175(denoted by @xmath231 ) , 2 .",
    "the _ _ sub - template of__@xmath228_in _ @xmath229 , i.e. the sequence of clauses which are applied to p - atoms of@xmath175and p - atoms derived from @xmath98 , extracted in the order from the template @xmath232 ( denoted by @xmath233 ) .",
    "[ d2.3.4 ]    1 .   given a derivation step of the following form , where @xmath3 : + @xmath234,(1 ) + let us define _ sub - resolvents _ and _ sub - templates _ in ( 1 ) as follows : + @xmath235 + @xmath236 2 .",
    "given a derivation of the form : + @xmath237 ( 2 ) + let us recursively define _ sub - resolvents _ and _ sub - templates _ in ( 2 ) as follows : + @xmath238 , + @xmath239 .",
    "it is worth noting that the notation relative to sub - templates and sub - resolvents can be ambiguous .",
    "indeed consider :    @xmath240(3 )    @xmath241.(4 )    it is possible that @xmath242 with respect to ( 3 ) is different from @xmath243 with respect to ( 4 ) . in the following of the paper ,",
    "when such a kind of ambiguity will possibly arise , we exploit a refined notation of evident meaning , like @xmath244 and @xmath245 . as an example , let us consider @xmath246 , @xmath247 , @xmath248 and @xmath249 such that    @xmath250(3b )    @xmath251(4b )    then , @xmath252 and @xmath253 .",
    "this section introduces some important ideas . precisely , the concepts of _ specialisation _ , _ lowering _ , and finally _ congruent lowering _ are defined and analysed .",
    "congruent lowering is basic for the characterisation of the general concept of scheduling rule , as well as of the class of specialisation independent scheduling rules ( see section [ s3.specfree ] ) to which the results about redundancy elimination tolerance of section [ s5.reduelim ] refer .    substitutions and renamings are basic concepts in logic programming . in agreement with usual terminology , if a substitution is applied to a goal , an _ instance _ is obtained , while , if a renaming is used , a _ variant _ of the original goal is produced .",
    "goals which are equal up to renamings are in essence equivalent goals",
    ". practically all the results of logic programming are insensible to renamings .",
    "an instance may be considered as a specialised version of the original goal , while any goal is more general with respect to its instances .",
    "the above concepts are easily adjusted in the frame of priority goals .",
    "intuitively , the application of a renaming / substitution corresponds to the application of a renaming / substitution together with a shifting . actually , as it will be clear in the following , we are interested in an idea of _ specialisation _ of a given p - goal which extends the traditional concept of instantiation .",
    "in essence , we will consider couples of p - goals such that the second one is obtained from the first one by performing in the order :    - the application of a generic substitution @xmath254 and a shifting ,    - the embedding in a generic context @xmath44 of other p - atoms .",
    "[ d2.4.1 ] a p - goal@xmath175is a _ specialisation _ of a p - goal @xmath255 by @xmath44 , if a shifting and a substitution @xmath254 exist such that    @xmath256 .",
    "it is worth noting that our idea of specialisation is essentially symmetric to the concept of subsumption by an instance ( see @xcite ) . a goal@xmath19_subsumes _ ( as list ) a goal@xmath175_by an instance _",
    ", if a substitution @xmath254 exists such that @xmath257 . indeed , considering that any shifting preserves the order of the atoms , it is evident that , if@xmath175is a specialisation of @xmath255 by @xmath44 , i.e.@xmath258 , then @xmath259 subsumes ( as list)@xmath175by the instance @xmath260 .    the term `` lifting '' is used in logic programming to express that a derivation step ( or a whole derivation ) which is possible from a goal @xmath261 is repeated starting from the more general goal @xmath262 .",
    "analogously , we use the term lifting to mean that a derivation step ( or a whole derivation ) which is possible from a specialisation of @xmath255 , i.e. from a p - goal @xmath263 , is repeated starting from @xmath255 . in the sequel of the paper , we will use the dual concept of `` lowering '' . in other words",
    ", the term lowering will mean that a derivation step ( or a whole derivation ) from a p - goal @xmath255 is repeated , when possible , starting from a specialisation @xmath264 of @xmath255 .",
    "then , let us give the following definition which refers to single derivation steps .",
    "[ d2.4.2 ] let us consider two priority derivation steps of the type@xmath265 and @xmath266 .",
    "we will say that the second step is a _ lowering of _ the first one _ by _",
    "@xmath44 , if the p - goal@xmath175is a specialisation of@xmath7by @xmath44 .",
    "let us consider two derivation steps ( ds1 ) and ( ds2 ) , such that ( ds2 ) is a lowering of ( ds1 ) by @xmath44 , and let @xmath3 . by definition of derivation step",
    ", they have the following form :    @xmath267(ds1 )    @xmath268 ( ds2 )    the definition of lowering of derivation steps does not impose any similarity in the way priority values are handled in couples of derivation steps like ( ds1 ) and ( ds2 ) .",
    "in particular , no analogy is required about the positions new atoms go to occupy with respect to old ones in the resolvents produced by ( ds1 ) and ( ds2 ) .",
    "indeed the shifting @xmath269 and @xmath270 are completely independent , so that the positions of atoms of @xmath271 , with respect to atoms of @xmath272 , will be in general different from the positions occupied by atoms of @xmath273 with respect to atoms of @xmath274 .",
    "nevertheless , in the rest of the paper special importance will be given to derivation step lowering such that the positioning of new atoms , with respect to the old ones in @xmath274 and @xmath272 , is maintained passing from ( ds1 ) to ( ds2 ) .",
    "in such hypothesis , we will say that the lowering is a _",
    "congruent lowering_.    as an elementary example , let us consider a clause like @xmath275 and the following derivation steps , such that ( 2 ) is a lowering of ( 1 ) by @xmath276 :    @xmath277(1 )    @xmath278(2 )    in ( 1 ) and ( 2 ) the relative positions of atoms @xmath279 and @xmath280 with respect to @xmath281 and @xmath282 are the same , then ( 2 ) is a congruent lowering of ( 1 ) .",
    "now , let us consider the following other derivation step ( 3 ) :    @xmath283(3 )    also ( 3 ) is a lowering of ( 1 ) by @xmath276 .",
    "however , in this case the positioning of atoms @xmath279 and @xmath280 with respect to @xmath281 and @xmath282 is not maintained passing from ( 1 ) to ( 3 ) , so that ( 3 ) is not a congruent lowering of ( 1 ) .",
    "variable substitutions are not considered in the above examples . indeed ,",
    "in agreement with the following formal definition [ d2.4.3 ] , they are not really influent for a lowering to be congruent or not .",
    "[ d2.4.3 ] let us consider two derivation steps of the form ( ds1 ) and ( ds2 ) above , i.e. two derivation steps such that the second one is a lowering of the first one by @xmath44 .",
    "we will say that step ( ds2 ) is a _ congruent lowering _ of step ( ds1 ) _ by _",
    "@xmath44 if a shifting exists with :    @xmath284 and @xmath285 .",
    "( c1 )    it is apparent that the desired analogy , in positioning new atoms in the two derivation steps ( ds1 ) and ( ds2 ) , is imposed by means of condition ( c1 ) above in definition [ d2.4.3 ] . indeed ,",
    "condition ( c1 ) says that the shifting creates a correspondence between atoms of @xmath286 and atoms of @xmath287 , such that old atoms are mapped in old atoms ( see @xmath284 ) and new atoms in new ones ( see @xmath288 ) .",
    "since any shifting maintains atom precedence , it is intuitive that congruent allocation of new atoms is imposed .",
    "more specifically , let us consider the generic atom @xmath289 of@xmath5and assume :    @xmath290 ,    @xmath291 .",
    "it is immediate to verify that@xmath292 expresses that the formula ( c1 ) must be used to establish the equality .",
    "similar advising will be used frequently in the sequel.]@xmath293}$ ] :    @xmath294    @xmath295    now , by @xmath296 in ( c1 ) and ax - iv in property [ py2.2.1 ] , we have that @xmath297 . then , by property [ py2.1.1]-ii ) it is @xmath298 , and then also @xmath299 , for @xmath130 positive integer . in essence ,",
    "considered the generic atom @xmath289 of @xmath201 , it is found in the @xmath300 position in @xmath301 as well as in @xmath302 . in other words ,",
    "new atoms from@xmath5are positioned in ( ds1 ) with respect to old ones ( i.e. atoms of @xmath274 ) exactly as it happens in ( ds2 ) with respect to @xmath303 .",
    "it is evident that the presence of various substitutions in ( ds1 ) and ( ds2 ) does not interfere with the above positional considerations .",
    "[ e2.4.1 ]    let us consider a clause of the form@xmath304)$ ] and the two following derivation steps :    @xmath305|\\{b[\\mathbf{3}]\\}\\overset{c}{\\longrightarrow } \\{b[\\mathbf{3}],q[% \\underline{10}]\\}$],(1 )    @xmath306|\\{b[12],b[13],d[15]\\}\\overset{c}{\\longrightarrow } % \\{b[12],q[12.5],b[13],d[15]\\}$].(2 )    in step ( 1 ) , old atoms are pointed out in bold and new ones are underlined .    1 .   in agreement with definition [ d2.4.3 ] , step ( 2 ) is a lowering of ( 1 ) by @xmath307,d[15]\\}$ ] , with @xmath308\\}$ ] .",
    "pointing out old and new atoms , derivation step ( 2 ) can be written as follows : + @xmath306|\\{b[\\mathbf{12}],b[13],d[15]\\}\\overset{c}{\\longrightarrow } \\{b[\\mathbf{% 12}],q[\\underline{12.5}],b[13],d[15]\\}$ ] .",
    "+ it is evident that ( 2 ) is a congruent lowering of ( 1 ) by @xmath44 , with any shifting such that @xmath309 .",
    "2 .   step ( 2 ) is a lowering of ( 1 ) also by @xmath310,d[15]\\ } $ ] , with @xmath311\\}$ ] .",
    "however ( 2 ) is not a congruent lowering of ( 1 ) by @xmath312 .",
    "in fact , in agreement with this second viewpoint , derivation step ( 2 ) can be written as follows : + @xmath306|\\{b[12],b[\\mathbf{13}],d[15]\\}\\overset{c}{\\longrightarrow } \\{b[12],q[% \\underline{12.5}],b[\\mathbf{13}],d[15]\\}$ ] . + as a consequence , for step ( 2 ) being a congruent lowering of step ( 1 ) by @xmath313 , a shifting @xmath314 might exist such that @xmath315 , which is not an increasing function .",
    "@xmath316    we close this section considering a couple of p - goals@xmath175and@xmath7such that they are specialisations of each other , i.e.@xmath175is a specialisation of@xmath7by a subgoal @xmath44 and@xmath7is a specialisation of@xmath175by @xmath317 . in this case",
    "it must be@xmath318 and@xmath319 , which yields :    @xmath320 .    as a consequence @xmath254",
    "must be a renaming for@xmath7and @xmath321 must hold , which means that@xmath322 where @xmath254 is a renaming .",
    "it is evident that the relation `` @xmath323 , for a renaming @xmath254 and a shifting @xmath324 '' can be seen as the translation of the usual notion of `` @xmath98 being variant of @xmath42 '' in the frame of p - sld resolution . in this sense",
    ", we will usually say that@xmath175is a _ p - variant _ of a @xmath42 , to mean that@xmath175and@xmath7are specialisations of each other .",
    "analogously , two derivation steps may be _ lowerings of each other _ , as well as _",
    "congruent lowerings of each other_. two derivation steps @xmath325 and @xmath326 are lowerings of each other if the initial goals are p - variants and the same clause is applied , i.e. it is @xmath327 and @xmath328 , where @xmath254 is a renaming .",
    "two derivation steps are congruent lowerings of each other if they have the form :    @xmath329 and @xmath330 ,    where @xmath3 , @xmath254 is a renaming , and the equalities @xmath284 and @xmath331 hold for a shifting @xmath332 .",
    "it is worth noting that by the preceding argument if two derivation steps are lowerings of each other the contexts must be empty .",
    "now , we use the notion of being congruent lowerings of each other to define the ideas of _ determinism _ and _ completeness _ of a set of derivation steps .",
    "both concepts are basic for the definition of state priority scheduling rules .",
    "[ d2.5.1 ] a set@xmath28of priority derivation steps is _ deterministic _ if , for each couple of derivation steps @xmath333 and @xmath326 in@xmath334 the following implication holds :    @xmath333 and @xmath326 are lowerings of each other    @xmath335 @xmath333 and @xmath326 are congruent lowerings of each other .    in other words",
    ", the definition of determinism imposes that two derivation steps , which apply the same clause to p - variant initial goals , give place to congruent allocations of new atoms .",
    "now let us give the definition of completeness of a set of derivation steps .",
    "[ d2.5.2 ] a set s of priority derivation steps is _ complete _ , if the following assertions hold :    \\i ) @xmath196 @xmath336 derivation step of the type@xmath337    @xmath335 @xmath196 @xmath338 of the type@xmath339 with @xmath340 ,    \\ii ) @xmath341 derivation steps with @xmath342 ,    @xmath338 and @xmath336 are congruent lowerings of each other @xmath343 @xmath340 .",
    "assertion i ) of the above definition states that , if a clause@xmath8is applicable to a p - goal @xmath42 , i.e. a derivation step exists of the type@xmath344 , the application of the clause@xmath8to@xmath7is indeed possible in any complete set of derivation steps .",
    "assertion ii ) assures that@xmath28is closed with respect to being congruent lowerings of each other . in other words , let @xmath345 be a derivation step , then every other @xmath346 must belong to@xmath334 if@xmath175is a p - variant of@xmath7and new atoms are allocated in@xmath126as it is done in @xmath347 .",
    "now , the formal definition of state priority scheduling rules can be easily given , by combining the properties of determinism and completeness .",
    "[ d2.5.3 ] a _ state priority scheduling rule _ is a complete and deterministic set of priority derivation steps .",
    "it can be easily verified that the leftmost selection rule , adopted by the prolog execution mechanism , is a state priority scheduling rule .",
    "the very nature of a state scheduling rule is characterised by the following definition [ d2.5.4 ] .",
    "indeed , the definition simply says that a p - sld derivation _ is via _ a state scheduling rule@xmath28if all derivation steps are admitted in the rule@xmath334 i.e. they all belong to the set of derivation steps which@xmath28is constituted by .",
    "[ d2.5.4 ]    1 .   given a set@xmath28of derivation steps",
    ", the notation @xmath348 represents the whole of p - sld derivations which are composed of derivation steps in@xmath29 2 .",
    "given a state scheduling rule@xmath334 the set @xmath348 is the set of _ _ p - sld derivations via__@xmath29    in the sequel of the paper we only consider state priority scheduling rules , which therefore will be called just _ scheduling rules_. the following notations will be used frequently . given a set@xmath28of",
    "derivation steps , a clause@xmath8and a template @xmath225 , we will denote by    @xmath349and@xmath350    the fact that the derivation step @xmath351and the p - sld derivation @xmath352 , respectively . in the case",
    "that the exploited logic program must be pointed out , a notation like    @xmath353    will be used to specify that the derivation is via@xmath28 in the program p , i.e. every clause of the template @xmath225 belongs to p. the notion of p - sld tree via@xmath28could be characterised in complete analogy with the usual one of sld tree .",
    "let us close this section with a property , which can be easily shown on the basis of completeness and will be used several times in the sequel .",
    "property [ py2.5.1 ] asserts that if a clause@xmath8can be applied to a p - goal @xmath354 , every complete set of derivation steps allows@xmath8to be applied to any p - goal of the form @xmath204 .",
    "since the atom @xmath34 is more general than @xmath355 , the property may also be interpreted as a sort of lifting of derivation steps . however , the subgoals@xmath7and@xmath175are left unrelated at all .",
    "the evident explication is that they have no active role in rewriting operations .",
    "moreover , the property recalls that new variables can be always chosen so that conflicts are avoided with arbitrary pre - established sets of variables .",
    "the formal proof of this rather intuitive property can be found in appendix a.    in the statement of property [ py2.5.1 ] and in the sequel of the paper , given a p - sld derivation @xmath229 , the notation @xmath356 will represent the set of standardisation apart variables which are introduced during the derivation @xmath229 . in the case of a single derivation step @xmath357 , it is @xmath358 .",
    "[ py2.5.1]let@xmath28be a complete set of derivation steps . given two p - goals @xmath359 and @xmath204 ,",
    "let us fix arbitrarily a finite set @xmath360 of variables .",
    "the following implication holds :    @xmath361 derivation step of the type @xmath362    @xmath363  @xmath364 of the type @xmath365 with @xmath366and @xmath367 .",
    "now , we will exploit the notion of congruent lowering in order to introduce the concept of _ specialisation independence_. this concept will be used to characterise the class of scheduling rules that are the main object of the paper ( _ specialisation independent scheduling rules _ ) . in fact",
    ", all our results for termination and loop check completeness preserving will refer to such a class of scheduling rules . in section [ s4.stacqueu ] , a second characterisation of the same class",
    "is given which has an operational nature and is surprisingly different in appearance .",
    "the definition of _ specialisation independence _",
    "enforces the idea of determinism .",
    "indeed , in agreement with the definition [ d3.1 ] below , every lowering is required to be a congruent lowering . in other words ,",
    "the congruence in the allocation of new atoms must hold any time the initial goals of two derivation steps are related by specialisation and the same clause is used .",
    "this can be interpreted saying that the positioning of new atoms with respect to old ones is _ independent of goal specialisation _ , which means independent of goal instantiation as well as of the addition of a group @xmath44 of other atoms .",
    "[ d3.1 ] a set@xmath28of priority derivation steps is _ specialisation independent _ if , for every couple of steps @xmath333 and @xmath326 in@xmath334 the following implication holds :    @xmath326 is a lowering of @xmath333 by @xmath44    @xmath368 is a congruent lowering of @xmath333 by @xmath44 .",
    "[ d3.2 ] a _ specialisation independent scheduling rule _ is a complete and specialisation independent set of priority derivation steps .    in the next two sections ,",
    "we provide some results about p - sld derivations via specialisation independent scheduling rules .",
    "the results will be frequently exploited in the sequel .      in this section",
    "we give results which relate resolvents coming from a couple of derivation steps in the congruent lowering relationship .",
    "then , by lemma [ l3.1.1 ] , the analysis is extended to couples of whole derivations , developed via specialisation independent scheduling rules .",
    "we start by presenting a preliminary statement ( property [ py3.1.1 ] ) which holds for every couple of derivation steps that are in the lowering relationship . in reference to derivation steps ( 1 ) and ( 2 ) below",
    ", the preliminary property says that , if we abstract from atom positioning and ignore the additional subgoal @xmath44 , the resolvent of ( 2 ) is an instance of the resolvent of ( 1 ) .",
    "property [ py3.1.1 ] can be shown following the line exploited for proving the variant lemma ( see @xcite ) , which is done in appendix a for the sake of completeness of the paper .",
    "[ py3.1.1]let @xmath3 be a clause .",
    "let us consider two derivation steps like ( 1 ) and ( 2 ) , where ( 2 ) is a lowering of ( 1 ) by @xmath44 .",
    "the following implication holds :    @xmath369,(1 )    @xmath370 ( 2 )    @xmath371 such that @xmath372 and @xmath373 ,    where @xmath374 is a renaming , if @xmath45 is a renaming .",
    "property [ py3.1.2 ] completes property [ py3.1.1 ] , taking into account the preservation of atom scheduling in the case of congruent lowering .",
    "it states that , if we ignore the additional subgoal @xmath44 , resolvents are preserved up to a substitution and a shifting . in reference to derivation steps ( 1 ) and ( 2 ) below , this means that , apart from @xmath375 , the resolvent@xmath216 in ( 2 ) is an instance of @xmath230 such that also atom scheduling is maintained .",
    "[ py3.1.2]let @xmath3 be a clause .",
    "let us consider two derivation steps of the type ( 1 ) and ( 2 ) , such that the second one is a congruent lowering of the first one by @xmath44 :    @xmath376,(1 )    @xmath377.(2 )    the following assertion holds :    @xmath378 such that @xmath379 ,    where @xmath374 is a renaming if @xmath45 is a renaming .",
    "let @xmath3 , so that @xmath230 and@xmath126may be written as follows :    @xmath380 ,    @xmath381 .",
    "since step ( 2 ) is a congruent lowering of ( 1 ) by @xmath44 , a shifting exists such that :    @xmath382.(3 )    by definition of sub - resolvent and ( 3 ) , we have :    @xmath383(4 )    now , we apply property [ py3.1.1 ] to ( 1 ) and ( 2 ) , deriving that a substitution @xmath374 exists such that :    @xmath384  and  @xmath385(5 )    where @xmath374 is a renaming if @xmath45 is a renaming .    as a consequence",
    ", we have that :    @xmath386    where @xmath374 is a renaming if @xmath45 is a renaming .",
    "the following lemma [ l3.1.1 ] may be seen as the extension of property [ py3.1.2 ] to whole derivations , provided that the used scheduling rule is specialisation independent .",
    "note that , given a derivation like ( 1 ) in the statement below , if a derivation like ( 2 ) exists , it can be considered as a lowering of ( 1 ) .",
    "indeed , the initial p - goal @xmath387 is a specialisation of@xmath7by @xmath44 , and the sequence @xmath16 of clauses is applied in the same order to atoms deriving from @xmath388 in derivation ( 2 ) . in this sense",
    "we will regard lemma [ l3.1.1 ] as a `` specialisation independent lowering lemma '' .",
    "[ l3.1.1 ] let@xmath28be a specialisation independent scheduling rule and consider two p - sld derivations like ( 1 ) and ( 2 ) .",
    "the following implication holds :    @xmath389,(1 )    @xmath390 , with @xmath391(2 )    @xmath392 such that @xmath393 ,    where @xmath394 is a renaming if @xmath395 is a renaming and @xmath396.(p1 )    let us first prove the thesis , apart from the fact ( p1 ) .",
    "the proof is by induction on the length of @xmath86 .",
    "if @xmath397 is equal to zero , the thesis is trivially true .",
    "let us suppose that @xmath397 is greater than zero .",
    "two different cases must be considered , i.e. the first clause of @xmath398 ( say @xmath161 ) is applied either to an atom of @xmath44 or to an atom of @xmath399 .",
    "( _ _ the clause__@xmath8_is applied to an atom of _",
    "@xmath44 ) .    in this case",
    "derivation ( 2 ) may be rewritten as :    @xmath400,(3 )    with @xmath401 .    by inductive hypothesis ,",
    "applied to the tail of derivation ( 3 ) and derivation ( 1 ) , we have :    @xmath402 such that @xmath403    ( _ _ the clause__@xmath8_is applied to an atom of _",
    "@xmath388 ) .    in in this case",
    "derivations ( 1 ) and ( 2 ) may be rewritten as ( 4 ) and ( 5 ) , respectively :    @xmath404(4 )    @xmath405(5 )    with @xmath406 , @xmath407.(6 )    since@xmath28is specialisation independent , the first step of ( 5 ) is a congruent lowering of the first one of ( 4 ) by @xmath44 .",
    "then , by property [ py3.1.2 ] , we have :    @xmath408 such that @xmath409.(7 )    as a consequence , recalling the first fact in ( 6 ) , the inductive hypothesis can be applied to the tails of derivations ( 4 ) and ( 5 ) .",
    "then , we have :    @xmath402 such that @xmath410 . ( 8)    in conclusion , we have that :",
    "@xmath411 .    in order to show the fact ( p1 ) ,",
    "i.e. @xmath394 is a renaming if @xmath412 is a renaming and @xmath413 , it is sufficient to note that :    - the `` first case '' does not occur at all ,    - the substitutions @xmath414 and @xmath394 , mentioned in ( 7 ) and ( 8) , are renamings .",
    "the following example shows that the hypothesis of specialisation independence is crucial for the validity of lemma [ l3.1.1 ] .",
    "[ e3.1.1 ]     let us consider a scheduling rule@xmath28such that new atoms are positioned in the centre of the old resolvent .",
    "new atoms are positioned immediately before the centre if the length of the resolvent ( the rewritten atom excluded ) is odd .",
    "it is easy to recognise that lowering lemma [ l3.1.1 ] does not hold for such a rule .",
    "indeed , let p be the following program :    @xmath415 $ ]    @xmath416 $ ] .",
    "now , in reference to the statement of lemma [ l3.1.1 ] , let :    @xmath417,p(a)[2]$ ]    @xmath418,p(a)[1.5]$ ]  and  @xmath419.$ ]    the following are two derivations of@xmath7 in p and @xmath420 in p , respectively :    @xmath421,p(a)[2]\\}\\overset{s , c2}{\\longrightarrow } \\{p(b)[1],p(a)[2]\\}\\overset{% s , c1}{\\longrightarrow } ( \\{q(b)[1],p(a)[2]\\}=q)$ ]    @xmath421,p(a)[1.5],r[2]\\}\\overset{s , c2}{\\longrightarrow } % \\{p(a)[1.5],p(b)[1.7],r[2]\\}\\overset{s , c1}{\\longrightarrow } $ ]    @xmath422,q(a)[1.8],r[2]\\}=r).\\qquad $ ]    thus , no @xmath394 and @xmath332 can exist such that :    @xmath423,p(b)[1.7]\\}=\\{q(b)[1],p(a)[2]\\}% \\sigma \\underline{\\rho } = q\\sigma \\underline{\\rho } .$ ]    note that @xmath424 and @xmath230 are essentially different , even if they are considered as multisets abstracting from priority values .",
    "it is easy to check that the used scheduling rule is not specialisation independent , in agreement with definition [ d3.2].@xmath425      the following lemma [ l3.2.1 ] is a result about p - sld derivation lifting which is valid for specialisation independent scheduling rules . in reference to derivation",
    "( 1 ) below , the lemma asserts that the sub - template of clauses , applied to the part @xmath388 of the initial p - goal @xmath426 in ( 1 ) , can be applied again in the order starting from the more general goal @xmath42 , via the same scheduling rule .",
    "the lemma also recalls that standardisation apart variables can be chosen in order to avoid conflicts with any fixed finite set of variables",
    ". the lemma does not relate resolvents .",
    "indeed , lemma [ l3.1.1 ] can be exploited to this purpose .",
    "[ l3.2.1 ] let@xmath28be a specialisation independent scheduling rule .",
    "given any finite set @xmath360 of variables , the following implication holds :    @xmath427 ( 1 )    @xmath428 ,  with  @xmath429 .",
    "the proof is by induction on the length of the template @xmath86 .",
    "if @xmath397 is zero , the assert is evident .",
    "let us suppose that @xmath430 .",
    "two cases must be considered , i.e. either the first clause in @xmath86 ( say @xmath161 ) is applied to an atom of @xmath44 or the clause@xmath8is applied to an atom of @xmath388 .",
    "( _ _ the clause__@xmath8_is applied to an atom of _",
    "@xmath44 ) .",
    "derivation ( 1 ) may be rewritten as :    @xmath431(2 )    by inductive hypothesis applied to the tail of ( 2 ) , for any finite set @xmath360 of variables , a derivation @xmath229 exists such that :    @xmath432 ,  with  @xmath429 .",
    "but , by construction of ( 2 ) , it is @xmath433 , so that the thesis is verified .",
    "( _ _ the clause__@xmath8_is applied to an atom of _",
    "@xmath388 ) .    derivation ( 1 ) may be rewritten as follows :    @xmath434,(3 )    where @xmath435.(4 )    let@xmath436 , that is @xmath437 . by ( 3 ) and property [ py2.5.1 ]",
    ", we can assert that a derivation step exists like :    @xmath438(6a )    with @xmath439.(6b )    since , by hypothesis@xmath28is specialisation independent , the first step of derivation ( 3 ) is a congruent lowering of step ( 6a ) by @xmath44 . as a consequence , by property [ py3.1.2 ] , a substitution @xmath440 and",
    "a shifting @xmath332 exist with :    @xmath441(7 )    then , by inductive hypothesis applied to the tail of ( 3 ) , we may assert that , a derivation @xmath442 exists :    @xmath443(8a )    with @xmath444.(8b )    so , derivation ( 8a ) is standardised apart with respect to ( 6a ) .",
    "since@xmath28is a state scheduling rule , ( 6a ) and ( 8a ) can be combined in order to give place to an unique derivation @xmath229 such that :    @xmath445 ,    where , by ( 6b ) and ( 8b ) , we have also that :    @xmath446    by ( 4 ) , the thesis is proven .",
    "it is worth noting that lowering lemma [ l3.1.1 ] and lifting lemma [ l3.2.1 ] consider couples of p - goals in a specialisation relationship , i.e. p - goals of the form@xmath7and @xmath447 .",
    "the distinctive point is that a group @xmath44 of additional atoms may be present in the second p - goal , besides the instantiation of@xmath7by @xmath395 .",
    "the correspondence is obvious with the fact that definition [ d3.1 ] requires that positioning of new atoms is independent of goal specialisation .",
    "as it will be clear in the following , this kind of independence is basic in order to assure tolerance to redundancy elimination .    in @xcite",
    "a class of selection rules is introduced for which independence of atom choices from goal instantiation is assured .",
    "these rules are named _ skeleton selection rules_. indeed , they are sensible only to a specific structural extract ( the skeleton ) of the applied clauses and the initial goal in the story of a derivation .",
    "as shown in @xcite , instantiation independence is sufficient to proof a strong lifting lemma which asserts that , for any skeleton rule@xmath334 an sld derivation of a goal @xmath448 via@xmath28can be lifted to a derivation of@xmath7via the same rule@xmath27 relating in a quite strong sense the mgu s and the resolvents . on the other hand , instantiation independence seems not sufficient to assure redundancy elimination tolerance .",
    "for example , in agreement to the definition in @xcite , the selection rule of example [ e1.1.1 ] is a skeleton rule , because choices only depend on the length of the initial goal and the ones of applied clauses .",
    "really , choices are performed on the unique basis of the length of the actual resolvent , so that the rule of example [ e1.1.1 ] can be seen as a case of @xmath449 skeleton selection rule .",
    "anyhow , the rule is not tolerant to redundancy elimination .    in order to point out the role of the hypothesis of specialisation independence with respect to derivation lifting ,",
    "let us give the following example where lifting lemma [ l3.2.1 ] does not hold .",
    "note that the used scheduling rule is instantiation independent , but it is not specialisation independent .",
    "[ e3.2.1 ]    let us consider again the scheduling rule of example [ e3.1.1 ] .",
    "it is easy to recognise that lifting lemma [ l3.2.1 ] does not hold for such a rule .",
    "indeed , let p be the following program :    @xmath450,r[2],r[3]$ ]    @xmath451 .",
    "now , in reference to the statement of lemma [ l3.2.1 ] , let :    @xmath452,s[2],s[3]\\}$ ]    @xmath453,s[2],s[2.5]\\}$ ]  and @xmath454,r[1.6]\\}$ ] .    in figure [ f2 ] an infinite p - sld derivation of @xmath447 in p",
    "is shown .",
    "@xmath455,r[1.5],r[1.6 ] , s[2],s[2.5]\\ } \\overset{s , c1}{\\longrightarrow } $ ] + @xmath456,r[1.6],p[1.7 ] , r[1.8],r[1.9],s[2],s[2.5]\\ } \\overset{s,(c2,c2)}{\\longrightarrow } $ ] + @xmath457,r[1.8 ] , r[1.9],s[2],s[2.5]\\}$ ] + ....................................    on the contrary , the only p - sld derivation of @xmath42 in p is the following one    \\{@xmath458,s[2],s[3]\\}\\overset{s , c1}{\\longrightarrow } \\{s[2],p[2.5],r[2.6],r[2.7],s[3]\\}.$ ]    which fails at the second resolvent .",
    "@xmath60    from the proofs of lemmata [ l3.1.1 ] and [ l3.2.1 ] , the proof of two corresponding assertions can be easily drawn .",
    "they are given in lemma [ l3.2.2 ] below , and are valid for all scheduling rules in the case of two p - sld derivations which are lowerings of each other .",
    "part a ) of the lemma may be viewed as a form of variant lemma .",
    "[ l3.2.2 ] let@xmath28be any scheduling rule and @xmath360 any arbitrary finite set of variables .",
    "then let@xmath7and @xmath459 be two p - goals such that @xmath6 is a p - variant of @xmath42 .",
    "the following implications hold :    a)@xmath460  and  @xmath461    @xmath462is a p - variant of @xmath230 ,    b)@xmath463    @xmath335 @xmath464 ,  with  @xmath465    let us consider part a ) of the lemma . by definition of p - variant",
    "it is @xmath466 , for a renaming @xmath395 and a shifting @xmath467 .",
    "by fact ( p1 ) in lemma [ l3.1.1 ] , i.e. `` where @xmath394 is a renaming if @xmath395 is a renaming and @xmath413 '' , the result appears as an immediate consequence of the proof of lemma [ l3.1.1 ] itself .",
    "it is sufficient to note that , if @xmath44 is empty and @xmath395 is a renaming , the fact that the used scheduling rule is specialisation independent becomes useless . indeed , in reference to the proofs of lemma [ l3.1.1 ] , though the hypothesis of specialisation independence is dropped , the first steps of ( 5 ) and ( 4 ) are congruent lowerings of each other , because every scheduling rule is deterministic .",
    "similar considerations are possible for part b ) of the lemma , in reference to the proof of lemma [ l3.2.1 ] .",
    "now , let us give a property that is valid for all scheduling rules and derives easily from lemma [ l3.2.2 ] .",
    "it asserts that two p - sld derivations @xmath468 and @xmath469 , via the same scheduling rule@xmath334 can be composed giving place to a longer derivation via@xmath334 if the last resolvent of @xmath468 coincides with the first of @xmath469 .",
    "[ py3.2.1 ] let@xmath28be any ( state ) scheduling rule .",
    "the following implication holds :    @xmath470  with  @xmath471    @xmath472 ,  with  @xmath473 ,    where@xmath126is a p - variant of @xmath230 .    by lemma [ l3.2.2]-b )",
    "applied to @xmath469 , a p - sld derivation @xmath474 exists with @xmath475 .",
    "thus , @xmath476 is standardised apart with respect to @xmath468 .",
    "since@xmath28is a state scheduling rule , @xmath229 is obtained as the composition of @xmath468 and @xmath477 .",
    "the fact that@xmath126is a p - variant of @xmath230 follows from lemma [ l3.2.2]-a ) , applied to @xmath469 and @xmath477 .",
    "prolog interpreters adopt a leftmost scheduling policy such that the first atom in the goal is always selected for rewriting and is replaced in the resolvent by the body of the applied clause . in other words , the actual resolvent is maintained as a _ stack _ , the atom on the top of the stack is always selected for rewriting , while new atoms from the applied clause are pushed on the top of the stack . in analogy , a _ queue scheduling policy _ may be considered , which corresponds to a very simple case of _ fair _ selection rule ( see @xcite ) . as for the stack scheduling policy the first atom in the resolvent is always selected , but new atoms are positioned at the end of the old resolvent .",
    "thus , the resolvent is treated as a queue of atoms and any queued atom is eventually selected in the case of infinite derivations    in this section the class of _ stack - queue _ scheduling rules is defined , which is a generalisation of both stack and queue scheduling policies . according to stack - queue rules , for any clause@xmath478 , two p - goals @xmath479 and @xmath480 can be identified , with@xmath481 , such that the atoms in @xmath479 are always scheduled in _ stack mode _ while the atoms in @xmath480 are scheduled in _ queue mode_. more formally , we have the following definition .",
    "as shown in the sequel of this section [ s4.stacqueu ] , the stack - queue class turns out to be an operational characterisation of the class of specialisation independent scheduling rules    [ d4.1 ] a set @xmath482 of derivation steps is said to be of _ stack - queue _ type , if it verifies the following condition . given any clause@xmath478 , two p - goals @xmath479 and @xmath480 exist with @xmath483 , such that for any p - goal @xmath484 :    @xmath485    the following property states that any set of stack - queue derivation steps is specialisation independent .",
    "then , as stated in theorem [ t4.1 ] , any set of stack - queue derivation steps which satisfies the completeness property is a specialisation independent scheduling rule .    [ py4.1 ]",
    "let @xmath486 be a stack - queue set of derivation steps .",
    "then @xmath482 is specialisation independent .",
    "let us consider two derivation steps in @xmath482 and suppose that derivation step ( 2 ) is a lowering of ( 1 ) by @xmath98 .",
    "this means that ( 1 ) and ( 2 ) have the following form , where@xmath487 :    @xmath488(1 )    @xmath489(2 )    in order to show that @xmath482 is specialisation independent , we have to verify that derivation step ( 2 ) is a congruent lowering of ( 1 ) by @xmath98 , i.e. a shifting @xmath332 exists , such that :    @xmath490@xmath491.(3 )    by property [ py2.2.1 ] , a shifting @xmath332 exists such that :    @xmath492    since it is evident that @xmath493  and @xmath494 , by property [ py2.1.1]-i ) we have :    @xmath495 ,    which immediately implies assertion ( 3 ) .    [ t4.1 ]",
    "let @xmath482 be a complete set of stack - queue derivation steps .",
    "then @xmath482 is a specialisation independent scheduling rule .",
    "now , we prove ( theorem [ t4.1.1 ] ) that any specialisation independent scheduling rule is actually a stack - queue rule .",
    "thus , combining this fact with theorem [ t4.1 ] , we have that definition [ d3.2 ] and the operational characterisation of definition [ d4.1 ] identify the same family of scheduling rules .",
    "to this aim , let us show the following lemma .",
    "[ l4.1.1 ] let@xmath28be a specialisation independent scheduling rule .",
    "given any clause@xmath496 , for every derivation step of the form :    @xmath497(1 )    two subgoals @xmath479 and @xmath480 exist ,",
    "with@xmath481 , such that :    @xmath498    let us consider a p - goal like :    @xmath499 ,  with @xmath500 .    on the basis of ( 1 ) , by property [ py2.5.1 ]",
    "a derivation step also exists of the following form :    @xmath501.(2 )    since @xmath500 , an index @xmath68 must exist such that no atom of@xmath5has been positioned inside @xmath502 .",
    "a priori several @xmath68 s might exist . without loss of generality , we take any one of them .",
    "thus , two p - goals @xmath479 and @xmath480 must exist , with @xmath483 , such that :    @xmath503(3 )    now , by definition , derivation step ( 1 ) has the form :    @xmath504.(1a )    since@xmath28is a specialisation independent rule , step ( 2 ) is a congruent lowering of step ( 1a ) by the subgoal @xmath505 , so that a shifting @xmath332 exists with @xmath506 and @xmath507 . then , recalling that ( 3 ) implies @xmath508 , we obtain :    @xmath509 .    finally :",
    "@xmath510 .",
    "the following theorem [ t4.1.1 ] shows that , for any scheduling rule , specialisation independence implies that the rule is stack - queue .",
    "together with theorem [ t4.1 ] , this result proofs that stack - queue is an operational characterisation of the set of specialisation independent scheduling rules .",
    "[ t4.1.1 ] let@xmath511be a specialisation independent scheduling rule .",
    "given any clause@xmath512 two p - goals @xmath479 and @xmath480 exist , with @xmath513 , such that for every derivation step of the form :    @xmath514(1 )    it is :    @xmath515 .",
    "let @xmath163 be the predicate symbol of atom @xmath516 . consider a p - atom @xmath289 of the form @xmath517 $ ] , where @xmath518 are distinct variables .",
    "then , consider a ground p - atom @xmath519 such that @xmath520 .",
    "by construction of @xmath289 and completeness of@xmath334 a derivation step of the type @xmath521 exists , which necessarily has the following form because @xmath519 is a single atom :    latexmath:[$b|r\\overset{s , c}{\\longrightarrow } ( m_{s}\\lambda \\underline{\\varepsilon } %    with@xmath481.(2 )    now , let us prove that @xmath523 is the partition of@xmath5which is required by the thesis .",
    "consider derivation step ( 1 ) .",
    "two cases are possible , either @xmath524 or @xmath525 .    @xmath526    in this case we have :    @xmath527    @xmath528    on the basis of ( 1 )",
    ", we have that also p - atom @xmath34 has @xmath163 as a predicate symbol , so that a substitution @xmath45 and a shifting @xmath529 exist with @xmath530 . by ( 1 ) and property [ py2.5.1 ] , a derivation step exists like :    @xmath531,(4 )    where by lemma [ l4.1.1 ] we have that :    @xmath532 ,  with@xmath533.(5 )    the proof can be now completed by exploiting derivation step ( 4 ) as a sort of `` bridge '' between ( 1 ) and ( 2 ) . in fact , since@xmath28is specialisation independent rule , derivation step ( 4 ) is a congruent lowering of step ( 2 ) by @xmath274 , so that a shifting @xmath314 exists with @xmath534 and @xmath535 . as a consequence ( see ( 5 ) and ( 2 ) ) , we can write :    @xmath536 .",
    "then , by property [ py2.1.1]-ii we have that @xmath537 , which obviously implies :    @xmath538.(6 )    now , let us note that by lemma [ l4.1.1 ] it must be :    @xmath539  with@xmath540.(7 )    since@xmath28is a specialisation independent rule , derivation step ( 4 ) is a congruent lowering of step ( 1 ) by @xmath541 , so that a shifting @xmath542 exists with @xmath543 and @xmath544 . as a consequence ( see ( 5 ) and ( 7 ) )",
    "we can write :    @xmath545 ,    with @xmath546 .    then ,",
    "by property [ py2.1.1]-ii , we have that @xmath547 , which obviously implies :    @xmath548.(8 )    by ( 2 ) and ( 7 ) , it is @xmath549 . by ( 6 ) , ( 8) and property [ py2.1.1]-i )",
    ", we have that :    @xmath550 and @xmath551 .    substituting in ( 7 ) , the thesis is obtained .",
    "let us consider a stack - queue derivation like :    @xmath552 ,  where @xmath553 and @xmath554(1 )    by definition of stack - queue scheduling rules , only atoms in @xmath262 together with atoms deriving from @xmath262 and allocated in stack mode can be rewritten in derivation ( 1 ) .",
    "thus , derivation ( 1 ) has the form :    @xmath555    @xmath556,(1a )    where :    * each @xmath557 is formed by new atoms deriving from @xmath262 which are allocated in stack mode , * each @xmath558 is formed by atoms of @xmath262 which are not yet rewritten , * each @xmath559 is formed by new atoms deriving from @xmath262 which are allocated in queue mode .",
    "the above structural considerations suggest the following formal definition .",
    "[ d4.2.1 ] a p - sld derivation , of the form @xmath560 , is of _ _  pre - queued type w.r.t . _ _ the subgoal @xmath262 ( simply written @xmath262__-preq type _ _ in the following ) if the only rewritten atoms are :    - atoms from the subgoal @xmath262 ,    - atoms deriving from @xmath262 and allocated in stack mode .    note that definition [ d4.2.1 ] is significant even if @xmath561 .",
    "it is evident that any @xmath262-preq derivation has the form ( 1a ) . in the sequel we use the following shortened notation to represent @xmath262-preq type derivations :    @xmath562(ap )    where , with reference to ( 1a ) , @xmath563 stands for `` stacked subgoal derived from @xmath262 '' , and @xmath564 means `` queued subgoal derived from @xmath262 '' .",
    "it is evident that in any preq type derivation we have @xmath565 .",
    "the following definition characterises an @xmath262__-queued _ _ derivation as an @xmath262-preq derivation where all atoms of @xmath262 are rewritten together with all atoms deriving from @xmath262 and allocated in stack mode , i.e. @xmath566= @xmath567 .",
    "intuitively , an @xmath262-queued derivation is an @xmath262-preq derivation which can not be extended without loosing its @xmath262-preq nature .",
    "indeed , the acronym `` @xmath262-preq '' stands for `` @xmath262-pre - queued '' derivation .",
    "[ d4.2.2 ] let @xmath482 be a stack - queue scheduling rule .",
    "a derivation which is of @xmath262-preq type and has the form :    @xmath568__(aq ) _ _    is said to be _ queued w.r.t .",
    "_ @xmath262 ( simply written @xmath262__-queued _ _ in the following ) .    in the following section [ subs4.3 ]",
    ", we will exploit the notations introduced in ( ap ) and ( aq ) to represent @xmath262-preq type and @xmath262-queued derivations , respectively .",
    "it is worth noting that starting from a p - goal of the form @xmath569 , when the @xmath262-queued derivation is reached , the last resolvent presents a situation where the roles of @xmath262 and@xmath5are exchanged . in practice , restarting from @xmath570 , the derivation can attempt to proceed towards a @xmath571-queued derivation .",
    "the proof of an important result in section [ subs4.3 ] ( duplication theorem [ t4.3.1 ] ) is based on this cyclic behaviour of stack - queue derivations .      in this section an important property is shown for stack - queue scheduling rules .",
    "let us give an intuitive presentation of this result , which is stated in the _ full duplication theorem _",
    "( theorem [ t4.3.2 ] ) .",
    "suppose that a p - sld derivation @xmath229 of@xmath7 in p can be developed via a stack - queue scheduling rule @xmath482 . then consider a p - goal @xmath6 which is equal to@xmath19apart from the duplication of some atoms .",
    "furthermore , suppose that each copy is scheduled after the corresponding original atom . in this hypothesis , the full duplication theorem asserts that a p - sld derivation of @xmath572 in p exists via the same scheduling rule @xmath482 , where all derivation steps of @xmath229 are redone in the order .",
    "the full duplication theorem is basic for the proof of the final results of the paper , i.e. results about redundancy elimination tolerance which are given in section [ s5.reduelim ] .",
    "indeed , let us consider the problem of preserving program termination .",
    "intuitively , program termination is preserved if the introduction of redundancy elimination does not provoke any really different new derivations . reversing the viewpoint ,",
    "termination is retained if any derivation , developed in presence of redundancy elimination , can be traced again when redundancy is left in place .",
    "the full duplication theorem asserts this kind of fact in the simplest case , i.e. when redundancy has the form of a replica of atoms already present in the initial p - goal , provided that the scheduling rule is of stack - queue type .",
    "first we show a duplication theorem ( theorem [ t4.3.1 ] ) which is valid when only one atom or group of adjacent atoms is duplicated .",
    "then the result is easily extended to obtain the full theorem . though intuitive in appearance ,",
    "theorem [ t4.3.1 ] has a relatively complex proof . in this section",
    "we give only a sketch of the argument . in the sketch",
    ", we will make reference to the particular case of completely ground derivations , i.e. derivations such that all resolvents are ground .",
    "this simplification will allow us to highlight the essence of the argument , without having to do with technical problems deriving from variable instantiations .",
    "formal presentation of the proof of theorem [ t4.3.1 ] is given in appendix b. note that the hypothesis of ground resolvents is verified in the case that no new variable is present in clause bodies and initial goals are ground .",
    "[ t4.3.1 ] let p be a logic program and @xmath482 a stack - queue scheduling rule . given two p - goals of the form @xmath573 and @xmath574 , the following implication holds :    @xmath575(1 )    @xmath576 such that  @xmath577    with @xmath578  and  @xmath579    let @xmath580 denote the subset of @xmath581 such that , for any derivation @xmath229 in @xmath580 , it is @xmath582 , where @xmath583 denotes the length of @xmath229 .",
    "we show the thesis by induction on @xmath130 .",
    "in other words , we show that the thesis holds when derivation ( 1 ) belongs to @xmath580 , for any @xmath584 .",
    "the fact is obvious for @xmath585 . in order to justify the inductive step from @xmath586 to @xmath580 , for @xmath587 ,",
    "let us consider a derivation like :    @xmath588(1a )    and show that @xmath589 exists with @xmath578 and @xmath590 .",
    "the following three possible situations must be taken into account .",
    "then , we start with case 3 , which is the most significant one .    1 .   derivation ( 1a ) is of @xmath591-preq type , 2 .   derivation ( 1a ) is of @xmath592-preq type , and not of @xmath591 -preq type , 3 .",
    "derivation ( 1a ) is not of @xmath592-preq type .    .",
    "as already said , the simplified argument , which we use in this sketch , works in the hypothesis that all resolvents are ground , so that derivation ( 1a ) has the following form :    @xmath593    @xmath594 , where @xmath595.(2 )    then , it is intuitive that a derivation can be constructed like the following , where @xmath596 is a suitable shifting :    @xmath597    @xmath598(3 )    @xmath599    by construction of ( 2 ) , @xmath600 is a derivation belonging to @xmath601 , with @xmath602 . by inductive hypothesis ,",
    "a derivation exists such that :    @xmath603,(5 )    with @xmath604 and @xmath605.(5a )    by property [ py3.2.1 ] , derivations ( 3 ) and ( 5 ) can be combined to yield a derivation of the form :    @xmath606,(6 )    where@xmath126is a p - variant of @xmath607 , which implies @xmath608 .",
    "finally :    @xmath609 .    .",
    "derivation ( 1a ) has the form @xmath610 , where @xmath611 .",
    "analogously to case 3 ) , a derivation can be constructed like :    @xmath612 .    .",
    "derivation ( 1a ) has the form @xmath613 .",
    "a derivation exists like :    @xmath614    now we can state and prove the full duplication theorem , which extends the previous theorem [ t4.3.1 ] to the duplication of two or more not adjacent atoms in the initial goal of a p - sld derivation .",
    "[ t4.3.2 ] let p be a logic program and @xmath482 a stack - queue scheduling rule . given a p - goal @xmath615 such that :    @xmath616\\in f,\\;\\;\\;\\exists b[s^{\\prime } ] \\in n$ ]  with @xmath617 ,    the following implication holds :    @xmath618    @xmath335 @xmath619 such that @xmath620    with @xmath621 and @xmath590 .    by hypothesis , the subgoal@xmath175is made of duplicated atoms .",
    "then , the proof is by induction on the length of @xmath98 .",
    "indeed , if@xmath175is empty the thesis is true . now",
    ", suppose that the thesis is already proven for any@xmath175with @xmath622 .",
    "then let us consider any p - goal@xmath623 $ ] with @xmath624 .",
    "by inductive hypothesis a derivation exists such that :    @xmath625  with @xmath626  and @xmath627 .    by hypothesis , three p - goals @xmath628 and @xmath86 exist together with a p - atom @xmath629 $ ] , such that :    @xmath630)=a|b[s^{\\prime } ] |c|b[s]|d$ ]  and  @xmath631|c|d$ ] .    as a consequence ,",
    "theorem [ t4.3.1 ] can be applied to @xmath615 and @xmath630)$ ] yielding :    @xmath630)\\overset{sq , y.p}{\\longrightarrow } r$ ] ,  with @xmath632 and @xmath633 .",
    "now the induction step is completed , because :    @xmath634  and  @xmath635 .",
    "in this section , the tolerance of stack - queue scheduling rules to redundancy elimination is considered . the preservation of program termination in shown in section [ subs5.1 ] .",
    "the preservation of the completeness of @xmath0 loop check is shown in section [ subs5.2 ] for function free programs .",
    "first , the idea of goal reduction , which is originally given in @xcite and is recalled in definition [ d1.1 ] of this paper , is restated .",
    "indeed , in section [ s1.goalredu ] little attention is paid to the positions of atoms which are removed from a resolvent . however ,",
    "if the execution is based on atom priority values , it is intuitive that removing an atom without any convenient expedient may overthrow the essence of previous atom scheduling .",
    "thus , a refined definition of goal reduction is given below ( definition [ d5.1 ] ) which fits the frame of priority sld derivation mechanisms .",
    "the inspiring idea of _ priority reduction _ is quite simple . according to definition [ d1.1 ] , for any removed atom @xmath289 , an _ eliminating _ atom @xmath636 exists which remains in the reduced resolvent .",
    "several removed atoms may share the same eliminating one .",
    "in reference to definition [ d5.1 ] below , for any eliminating atom @xmath637 $ ] , the corresponding subset @xmath638 of eliminated atoms is pointed out . then , except for the case @xmath637\\dashv a_{j}$ ] , any @xmath637 $ ] is advanced to the least priority value in @xmath638 . in other words",
    ", _ each eliminating atom is advanced to replace the first scheduled atom among its eliminated ones_. intuitively , the aim is to restore the essence of the previous atom priorities .",
    "the notation @xmath639 will represent the merging @xmath640 , and the notation @xmath641 the set of priority values in @xmath638 .",
    "[ d5.1 ] let @xmath44 be a set of variables , @xmath642 a substitution and@xmath7a p - goal .",
    "a p - goal@xmath46is a _ reduced p - goal _",
    "of@xmath7by @xmath45 up to x , denoted by@xmath643 , if the following conditions hold :    i)@xmath644,\\;1\\preceq j\\preceq h\\}\\;+\\;\\{+a_{j},\\;1\\preceq j\\preceq h\\}$ ] ,    where @xmath616\\in a_{j},\\;\\;\\;b\\tau = a_{j},\\;\\;\\;1\\preceq j\\preceq h$ ] ,    ii)@xmath645,\\;1\\preceq j\\preceq h\\},$ ]    where @xmath646    \\iii ) @xmath647  it is  @xmath648 .    given the p - goal    @xmath649,q(w)[2],p(a)[3],p(y)[4],q(v)[5]$ ] ,    the following@xmath46is a reduced p - goal of@xmath7by the substitution @xmath650 :    @xmath651,q(w)[2]$ ] .",
    "note that @xmath652 $ ] has been advanced to replace the first of the atoms it eliminates , that is @xmath653 $ ] .",
    "@xmath60    now , the idea of _ priority reduced sld derivation _ can be defined as a generalisation of definition [ d2.3.2 ] .",
    "in essence a priority reduced sld derivation is a p - sld derivation where , at any step , a priority reduction of the resolvent according to definition [ d5.1 ] is allowed .",
    "[ d5.2 ] let p be a program and @xmath21 a p - goal .",
    "priority reduced sld derivation _ of @xmath21 in p ( _ p - rsld derivation _ for short ) is a possibly infinite sequence of priority reductions and derivation steps    @xmath654    where , for any @xmath23 ,    \\i ) @xmath24 is a clause in p ,",
    "\\ii ) @xmath655 ,    \\iii ) @xmath65  up to @xmath656 .    the notation    @xmath657    will be used to represent a p - rsld derivation which is developed in agreement with the scheduling rule@xmath28using the template @xmath86 .",
    "the last resolvent@xmath46is intended to be a reduced resolvent .      in this section , the redundancy elimination tolerance of stack - queue scheduling rules is shown , with reference to program termination ( theorem [ t5.1.1 ] ) .",
    "the following lemma is fundamental for proving the preservation of termination , as well as the preservation of @xmath0 loop check completeness .",
    "[ l5.1.1]let p be a program and @xmath482 a stack - queue scheduling rule .",
    "the following implication holds :    @xmath658(1 )    @xmath659  such that@xmath660 ,  with @xmath661 .",
    "the proof is by induction on the length of @xmath44 . if @xmath662 , the thesis is trivially verified with @xmath663 .",
    "then let us consider @xmath664 .",
    "derivation ( 1 ) may be rewritten as :    @xmath665(2 )    since @xmath666 , by inductive hypothesis , a p - sld derivation exists of the form :    @xmath667 ,  with @xmath668.(3 )    by property [ py3.2.1 ] , the first derivation step of ( 2 ) and derivation ( 3 ) can be combined to yield a derivation of the following form :    @xmath669  where@xmath28is a p - variant of @xmath670.(4 )    now , let us consider the p - goal @xmath671 . with reference to definition [ d5.1 ] , we have that :    @xmath672,\\;1\\preceq j\\preceq h\\})\\tau + \\{+a_{j}\\tau , \\;1\\preceq j\\preceq h\\}=^{(def.\\;\\ref{d5.1}-iii)}$ ]    @xmath673,\\;1\\preceq j\\preceq h\\}+\\{+a_{j}\\tau , \\;1\\preceq j\\preceq h\\}=^{(def.\\;\\ref{d5.1}-i - ii)}$ ]    @xmath674,\\;1\\preceq j\\preceq h\\}+\\{+a_{j}\\tau \\{r_{j}/p_{j}\\},\\;1\\preceq j\\preceq h\\}=$ ]    @xmath675 means that the priority value @xmath676 is replaced by @xmath677 in the p - goal @xmath678.]@xmath293}$ ] ,    where @xmath679\\dashv a_{j}\\tau \\{r_{j}/p_{j}\\}$ ] and any atom in @xmath680 is a duplicate of @xmath681 @xmath682 . then,@xmath46and",
    "@xmath671 verify the hypothesis of theorem [ t4.3.2 ] .",
    "as a consequence , by ( 4 ) a derivation also exists such that :    @xmath683  with @xmath684 and @xmath685(5 )    now , let us apply lifting lemma [ l3.2.1 ] to ( 5 ) .",
    "we obtain that a p - sld derivation exists like :    @xmath686.(6 )    where , applying lowering lemma [ l3.1.1 ] to ( 5 ) and ( 6 ) , we have that @xmath687 .",
    "finally , we conclude :    @xmath688    @xmath689    [ t5.1.1 ] let p be a program,@xmath7a p - goal and @xmath482 a stack - queue scheduling rule . if every p - sld derivation of@xmath19 in p via @xmath482 is finite , then any p - rsld derivation via @xmath482 is finite too .",
    "let @xmath670 be the p - sld tree of@xmath7 in p via @xmath482 .",
    "by hypothesis , every p - sld derivation of@xmath7 in p via @xmath482 is finite . as a consequence ,",
    "since @xmath670 is a finitely branching tree , by konig s lemma ( see theorem k , in @xcite ) @xmath670 is a finite tree .",
    "let @xmath690 be the depth of @xmath670 . given any p - rsld derivation of the form@xmath691 , by lemma [ l5.1.1 ] a p - sld derivation of the form@xmath692 exists in @xmath670 , with @xmath693 .",
    "but @xmath694 , so that we obtain @xmath695 in conclusion , the length of all p - rsld derivations of@xmath7 in p via @xmath482 is limited by @xmath690 .",
    "let us close this section with two examples which show that both stack - queue scheduling and eliminating atom advancement are essential for redundancy elimination tolerance .",
    "the first example shows the necessity of advancement of eliminating atoms .",
    "the second one is an example of state scheduling rule which is not tolerant to redundancy elimination , though goal reduction is performed in agreement with definition [ d5.1 ] . of course , the scheduling rule is not of stack - queue type . in the following sketches of p - sld and p - rsld derivations , explicit indication of priority values",
    "is omitted , for the sake of brevity .",
    "[ e5.1.1 ]    let us consider the stack scheduling rule ( i.e. the usual leftmost rule ) and the following single clause program p :    @xmath696 .",
    "it is evident that all p - sld derivations fail .",
    "however , if advancement of eliminating atoms is not performed , an infinite p - rsld derivation of p exists , as shown in figure [ f3 ] .",
    "@xmath60     + @xmath697 + @xmath698    @xmath699    ......................................    [ e5.1.2 ]    let@xmath28be a scheduling rule which behaves as a stack rule , with an exception when atoms having @xmath700 as a predicate symbol are rewritten . in this case",
    "new atoms are positioned immediately after the first old atom , if one exists .",
    "then , let us consider the logic program p consisting of the following clauses :    @xmath701    @xmath702    @xmath703 .",
    "it is easy to verify that all p - sld derivations of p terminate independently of the initial p - goal .",
    "in fact , given a p - sld derivation of@xmath19 in p , where@xmath7is any p - goal , two cases are possible : either an atom with predicate symbol @xmath704 is rewritten or not . if no atom with predicate symbol @xmath704 is rewritten , the derivation terminates evidently .",
    "otherwise the derivation fails , as described below :    @xmath705    @xmath706    now let us show that , if reduction of resolvents is allowed , an infinite p - rsld derivation of p exists .",
    "+ @xmath707 + @xmath708 + @xmath709 + @xmath710 + ......................................",
    "+    it is easy to verify that the infinite rsld derivation in figure [ f4 ] can not be pruned neither by @xmath0 loop check nor by more powerful checks ( like @xmath121 ) which are based on _ subsumption _ relationships between resultants @xcite .",
    "@xmath60      in this section we prove the preservation of @xmath0 loop check completeness , passing from p - sld to p - rsld .",
    "the result holds for function free programs , provided that stack - queue scheduling rules are used in combination with priority reduction of resolvents , as introduced in definition [ d5.1 ] .",
    "the section starts with a characterisation of @xmath119 loop check which exploits the concept of priority shifting and is equivalent to the one stated in definition [ d1.2.1 ] .",
    "in essence , passing from definition [ d1.2.1 ] to definition [ d5.2.1 ] below , only assertion ii ) is modified . on the other hand ,",
    "the requirement @xmath711 is plainly equivalent to @xmath712 , since any shifting @xmath467 implies that the order of atoms is preserved .    [ d5.2.1 ] a p - rsld derivation    @xmath713    is _ pruned _ by _ priority equality variant of resultant _ check ( called _ _",
    "p-__@xmath0 _",
    "check _ , in the following ) , if for some @xmath110 and @xmath68 , with @xmath714 , a renaming @xmath45 and a shifting @xmath715 exist such that :    \\i ) @xmath716 ,    \\ii ) @xmath717 .    with reference to the above definition ,",
    "any couple @xmath718 $ ] is a _ reduced resultant_. given two reduced resultants @xmath719 $ ] and @xmath720 $ ] , for which requirements i ) and ii ) of definition [ d5.2.1 ] hold , we will write @xmath721 .",
    "in other words , definition [ d5.2.1 ] expresses that p-@xmath0 loop check is based on detecting that a reduced resultant is obtained which is connected by the relationship @xmath722 to a preceding one in the same derivation .",
    "it is worth noting that @xmath722 is an equivalence relationship .",
    "now let us prove theorem [ t5.2.1 ] , which states that the completeness of p-@xmath0 loop check is preserved passing from p - sld to p - rsld , if stack - queue scheduling rules are used . to this aim",
    "we provide a necessary condition which holds whenever p-@xmath0 prunes every infinite p - sld derivation of a goal@xmath7 in a program p via a scheduling rule@xmath29 indeed , as shown in lemma [ l5.2.1 ] , in this hypothesis the length of resolvents of all possible derivations of@xmath7 in p via@xmath28is limited .",
    "the structure and the proof of lemma [ l5.2.1 ] are strictly analogous to the ones of lemma [ l1.2.1 ] .",
    "note also that lemma [ l5.2.1 ] holds for any scheduling rule . on the contrary ,",
    "the stack - queue hypothesis is necessary in theorem [ t5.2.1 ] , which concludes the section .",
    "[ l5.2.1]let p be a program and@xmath7a p - goal .",
    "suppose that all infinite p - sld derivations of@xmath7 in p via a scheduling rule@xmath28are pruned by p-@xmath0 .",
    "then , a finite bound @xmath133 exists such that , for each resolvent@xmath126 in any p - sld derivation of@xmath7 in p via@xmath334 it is @xmath723 .",
    "the proof of this lemma can be obtained from the one of lemma [ l1.2.1 ] , by means of the following replacements :    `` let @xmath670 be the p - sld tree of@xmath7 in p via @xmath77 '' for `` let @xmath670 be an s - tree of@xmath7 in p '' ,    `` by determinism lemma [ l3.2.2 ] '' for `` since @xmath670 contains all sld derivations of@xmath7 in p '' ,    `` p-@xmath0 '' and `` p - variant '' for `` @xmath0 '' and `` variant '' , respectively .",
    "[ t5.2.1 ] let p be a function free program , @xmath21 a p - goal and @xmath482 a stack - queue scheduling rule .",
    "suppose that all infinite p - sld derivations of @xmath21 in p via @xmath482 are pruned by p-@xmath0 , then all infinite p - rsld derivations of @xmath724 in p via @xmath482 are pruned by p-@xmath0 .",
    "let @xmath86 be an infinite p - rsld derivation of @xmath21 in p via @xmath482 .",
    "let @xmath725 be any finite prefix of @xmath86 .",
    "by lemma [ l5.1.1 ] , a p - sld derivation @xmath726 exists with @xmath590 . on the other hand , by lemma [ l5.2.1 ]",
    "a bound @xmath133 exists such that @xmath727 . but @xmath230 is the generic reduced resolvent in @xmath86 , so that the number of atoms in all reduced resolvents of @xmath86 is bounded by @xmath728 . as a consequence ,",
    "the number of atoms in all reduced resultants of @xmath86 is also limited . since the program p has finite many predicate symbols and constants and no function symbol",
    "is allowed , the relationship @xmath722 between reduced resultants of @xmath86 has only finitely many equivalence classes .",
    "then , for some @xmath158 in @xmath86 , we have that the @xmath159 reduced resultant is related by @xmath722 to the @xmath160 one .",
    "this implies that @xmath86 is pruned by p-@xmath0 .",
    "in the paper the problem of possible undesirable effects of redundancy elimination from resolvents is addressed .",
    "in particular we have shown that program termination and loop check completeness can be lost .",
    "conditions are characterised which ensure the redundancy elimination tolerance , in the sense that program termination and completeness of equality loop check are preserved when redundancy is eliminated .",
    "however , difficulties in analysing interdependence of redundancy elimination effects from the used selection rule have arisen , and the necessity of a framework to formalise suitable features of selection rules has been highlighted . to this aim , a highly expressive execution model based on priority mechanism for atom selection",
    "is developed in the paper .",
    "the distinctive aspect is that primary importance is given to the event of arrival of new atoms from the body of the applied clause at rewriting time , when new atoms can be freely positioned with respect to old ones in the resolvent .",
    "then , at any derivation step , the atom with optimum priority is simply selected .    the results presented in the paper show that the new computational model is able to give remarkable insights into general properties of selection rules .",
    "as a matter of fact , the priority model allows us to formalise the delicate concepts on which the axiomatic definition of specialisation independent scheduling rules is based . as a quite unexpected result , the specialisation independence turns out to be equivalent to stack - queue scheduling technique , which has a very simple operational characterisation . in other words ,",
    "the priority mechanism is necessary to formalise the real semantic features of specialisation independent scheduling rules . on the contrary",
    ", the full generality of the same mechanism can be abandoned if only operational aspects of specialisation independent rules are of interest , in the sense that all we need is a `` watershed '' between the stacked and the queued atoms .",
    "it is widely acknowledged that the study of selection rules is a difficult subject which deserves attention .",
    "we are confident that the computational model proposed in the paper can be usefully exploited in future work to get further insights into topics which are related to selection rule theory and application , such as loop check , termination and optimisation of derivation processes .",
    "this appendix contains the formal proofs of properties [ py2.5.1 ] and [ py3.1.1 ] .",
    "the very simple property a1 is considered before proving property [ py2.5.1 ] .",
    "let@xmath742 . on the basis of ( 1 ) , by definition of derivation step ,",
    "a standardisation apart renaming @xmath743 for@xmath8and an mgu @xmath744 exist , with @xmath745 .",
    "then , let us consider a renaming @xmath9 of @xmath746 , such that the following assertions hold for the range of @xmath9 :                in other words , @xmath34 and @xmath752 unify through the unifier @xmath753 .",
    "on the other hand , the fact ( 2a ) says that @xmath754 is a standardisation apart renaming for@xmath8with respect to @xmath204 .",
    "then , a derivation step exists of the form @xmath755 . by hypothesis",
    "the set@xmath28is complete , so that by property a1 we have also a derivation step such that :                                                now let us suppose that @xmath45 is a renaming . in this case , facts ( 3 ) and ( 4 ) become symmetric at all . as a consequence , by symmetry with respect to ( 8a ) and ( 8b ) , a substitution @xmath395 exists such that @xmath781 and @xmath782 .",
    "then we have :          in this appendix we provide a formal proof of the duplication theorem ( theorem [ t4.3.1 ] ) .",
    "such a proof exploits two lemmata which are given below .",
    "lemma b1 establishes a condition which allows us to repeat derivations via a specialisation independent scheduling rule , when we pass from a goal@xmath7to a suitable kind of instantiations of @xmath42 .",
    "lemma b1 is a correspondent , for p - sld derivations , of part ( ii ) of strong lifting lemma @xcite .",
    "indeed , both part ( ii ) of strong lifting lemma and lemma b1 can be seen as results about sufficient conditions for derivation lowering from a goal@xmath7to instantiations of@xmath7itself . here a direct proof of lemma b1 is given which takes into account technical aspects concerning our priority value mechanism .",
    "lemma b1 does not relate resolvents , because it is not important for the purposes of this appendix .",
    "then , let us consider the substitution @xmath792 where @xmath793 is such that @xmath794 is ground . since @xmath395 is an mgu of @xmath34 and @xmath15 , we have @xmath795 , which means @xmath796 but @xmath797 is ground , so that we obtain the equality @xmath798 .",
    "in other words , @xmath799 and @xmath15 unify through the unifier @xmath800 .",
    "moreover , the renamed clause @xmath801 is obviously standardised apart with respect to the ground p - goal @xmath802 , so that a derivation step like @xmath803 exists . thus , by completeness of@xmath28and property a1 , a derivation step also exists of the form :                      by inductive hypothesis applied to the tail of ( 2 ) , we have that @xmath814 which by lifting lemma [ l3.2.1 ] implies that@xmath815 .",
    "now , by property [ py3.2.1 ] , the last obtained derivation can be combined with ( 3 ) yielding :        the following lemma b2 is a special form of determinism lemma which holds for preq type stack - queue derivations . roughly speaking ,",
    "the lemma states that an @xmath262-preq type derivation , starting from a p - goal of the form @xmath818 , can be replicated from a p - goal like @xmath819 , where @xmath254 is a renaming .",
    "note that no hypothesis is made on @xmath44 and @xmath820 which can be completely unrelated .",
    "the intuitive explication is that only atoms deriving from @xmath262 are rewritten so that neither @xmath44 nor @xmath317 have any active role in the derivations .",
    "the formal statement and the proof of lemma b2 are preceded by the quite simple property b1 .                by lowering lemma [ l3.1.1 ] ,",
    "applied to ( 3 ) and ( 1 ) , a renaming @xmath30 and a shifting @xmath830 exist with @xmath831 . by lowering lemma [ l3.1.1 ]",
    "applied to ( 3 ) and ( 2 ) , a renaming @xmath744 and a shifting @xmath832 exist with @xmath833 .",
    "finally , we derive that :              let @xmath840 .",
    "we show lemma b2 by induction on the length of the template @xmath274 . if @xmath841 , the assert is evident .",
    "if @xmath842 , let @xmath843 with@xmath844 .",
    "derivation ( 1 ) can be rewritten as follows :                    now , by ( 1b ) it is @xmath852  so that the equality @xmath853  holds , by property [ py2.1.1]-i ) .",
    "thus , the inductive hypothesis can be applied to the tail of ( 1a ) . as a consequence , a p - sld derivation @xmath87 exists , which is of @xmath854-preq type and has the following form : _ _            where @xmath86 is of @xmath858-preq type .",
    "the thesis is now proven .",
    "indeed , by property b1 applied to derivations ( 1 ) and ( 4 ) , a renaming @xmath374 and a shifting @xmath859 exist with @xmath860 , so that by property [ py2.1.1]-i ) we have @xmath861 and @xmath862 . the fact that @xmath863 follows from ( 2 ) and ( 3a ) .",
    "let @xmath580 denote the subset of @xmath866 , such that for any derivation @xmath229 in @xmath580 it is @xmath867 , where @xmath583 denotes the length of @xmath229 .",
    "we show the thesis by induction on @xmath130 , i.e. we show that the thesis holds when derivation ( 1 ) belongs to @xmath580 , for any @xmath584 .",
    "the fact is obvious for @xmath868 . in order to prove the inductive step from @xmath586 to @xmath580 , for @xmath587 ,",
    "let us consider a derivation like :          let us recall that the sketch of section [ subs4.3 ] was given in the simplifying hypothesis that : every clause body introduces no new variable and initial p - goals are ground . in this sense",
    ", we may say that the first phase removes the first restriction , while the second one is retained . in the second phase , also the restriction on the groundness of initial goals",
    "is overcome .",
    "in fact , since @xmath573 is ground , in each of the four initial segments of ( 2 ) only standardisation apart variables , introduced in the same segment , can be instantiated .",
    "in particular , @xmath872 are not instantiated in the second segment , @xmath873 are not in the third segment , and @xmath874 are not in the fourth one .",
    "it is evident , as a consequence , that the p - goal @xmath875 consists of four subgoals without common variables .",
    "now , since also @xmath876 is ground , a derivation can be constructed through five successive applications of lemma b2 , as depicted below :              at each application of lemma b2 , a segment of derivation ( 3 ) is obtained on the basis of a corresponding segment of derivation ( 2 ) . moreover , lemma b2 assures that each new segment can be freely standardised apart , so that each segment can be readily added to the sequence of its predecessors in ( 3 ) .",
    "note that the second segment of ( 2 ) is considered twice , in order to generate both the second and the fourth segment of ( 3 ) .",
    "in analogy with derivation ( 2 ) , the final p - goal @xmath880 of derivation ( 3 ) consists of five subgoals without common variables . as a consequence , the five renamings @xmath881 , @xmath882 , @xmath883 , @xmath884 and @xmath885 have disjoint domains , so that they can be joined in order to form a unique substitution                                                    in the preceding first phase of this proof",
    ", the inductive step is verified in the hypothesis that the initial p - goal @xmath573 is ground .",
    "now consider a generic p - goal of the form @xmath573 .",
    "with reference to ( 1a ) , let @xmath903 be a grounding substitution for @xmath904 . by lemma b1 ,",
    "a derivation exists such that :"
  ],
  "abstract_text": [
    "<S> in @xcite an extended form of resolution , called reduced sld resolution ( rsld ) , is introduced . </S>",
    "<S> in essence , an rsld derivation is an sld derivation such that redundancy elimination from resolvents is performed after each rewriting step . </S>",
    "<S> it is intuitive that redundancy elimination may have positive effects on derivation process . </S>",
    "<S> however , undesiderable effects are also possible . </S>",
    "<S> in particular , as shown in this paper , program termination as well as completeness of loop checking mechanisms via a given selection rule may be lost . </S>",
    "<S> the study of such effects has led us to an analysis of selection rule basic concepts , so that we have found convenient to move the attention from rules of atom selection to rules of atom scheduling . a priority mechanism for atom scheduling </S>",
    "<S> is built , where a priority is assigned to each atom in a resolvent , and primary importance is given to the event of arrival of new atoms from the body of the applied clause at rewriting time . </S>",
    "<S> this new computational model proves able to address the study of redundancy elimination effects , giving at the same time interesting insights into general properties of selection rules . as a matter of fact </S>",
    "<S> , a class of scheduling rules , namely the specialisation independent ones , is defined in the paper by using not trivial semantic arguments . as a quite surprising result , </S>",
    "<S> specialisation independent scheduling rules turn out to coincide with a class of rules which have an immediate structural characterisation ( named stack - queue rules ) . </S>",
    "<S> then we prove that such scheduling rules are tolerant to redundancy elimination , in the sense that neither program termination nor completeness of equality loop check is lost passing from sld to rsld .    </S>",
    "<S> * keywords * : redundancy elimination , selection rules , scheduling rules , termination , loop check , stack - queue scheduling rules . </S>"
  ]
}