{
  "article_text": [
    "phylogenetic analysis of a family of related nucleic acid or protein sequences is to determine how the family could have been derived during evolution .",
    "assume that evolution follows a tree model with evolution acting independently at different sites of genome .",
    "let the transition matrices for this model be the general markov model which is more general than any other in the felsenstein hierarchy .",
    "how to reconstruct evolutionary trees is one of the main objects in phylogenetics .    since statistical models are algebraic varieties , we are interested in defining polynomials called phylogenetic invariants for varieties .",
    "many authors have studied phylogenetic invariants for different models ( @xcite , @xcite , @xcite , @xcite , @xcite ) .",
    "phylogenetic invariants have been used for phylogenetic tree reconstruction ( @xcite ) .",
    "procedures for phylogenetic analysis are linked to those for sequence alignment .",
    "we can easily organize a group of similar sequences with a small variation into a phylogenetic tree . on the other hand , as sequences become more different through evolutionary change , as they can be more difficult to be aligned .",
    "a phylogenetic analysis of very different sequences is also hard to do since there are many possible evolutionary paths that could have been followed to produce the observed sequence variation . to solve these difficulties and complexities",
    "many phylogenetic analysis programs have been invented .",
    "the main ones in use are phylip ( phylogenetic inference package , @xcite ) available from dr .",
    "j. felsestein and paup ( @xcite ) available from sinauer associates , sunderland , massachusetts .",
    "nowadays these programs provide three methods for phylogenetic analysis - parsimony , distance , and maximum likelihood methods - and also give many evolutionary models for sequence variation .    note that splits in a phylogenetic tree play an important role in reconstructing the phylogenetic tree ( @xcite ) .",
    "recall that erikkson suggested a phylogenetic tree building algorithm using svd of flattenings in chapter 19 ( @xcite ) of @xcite . in that article",
    ", he tried to build a phylogenetic tree without concerning the notion of distance by concentrating on the phylogenetic invariants which are given by rank conditions of flattenings . on the other hand , he had difficulty in dealing with the phylogenetic tree having a large number of leaves since he had to compute svd of flattenings of huge size . in this paper",
    ", we construct algorithms with svd of flattenings of fixed number of rows , i.e. , 16 .",
    "we will present tree building algorithms ( algorithm 1 and algorithm 2 ) in section 3,4 using svd to calculate how close a matrix is to be a certain rank . in section 5",
    ", we use the program * seq - gen * ( @xcite ) to simulate data of various lengths for the phylogenetic tree .",
    "after that we build a phylogenetic tree using algorithm 1 , algorithm 2 and neighbor joining algorithm ( nj ) .",
    "it turns out that our algorithms are efficient to construct the phylogenetic tree involving @xmath0 species for dna sequences with respect to the numerical stability .",
    "also we compare our algorithms to nj using simulated and real encode data .",
    "our algorithms are suitable to construct phylogenetic trees for general markov models , i.e. models coming from real data .",
    "+ acknowledgements    we would like to thank lior pachter , bernd sturmfels and seth sullivant for discussing tree building algorithm and encouraging us to write this paper . also first author thanks organizers and participants of summer school  algebraic statistics , tropical geometry , computational biology \" in norway for warm hospitality and helpful discussion about these areas during he attended in the school .",
    "in this section we explain known results by erikkson and basic concepts in the book : algebraic statistics for computational biology ( @xcite ) for the later use .",
    "we will present basic theorem which plays an important role in this paper .",
    "a phylogenetic @xmath1-tree @xmath2 is a tree with leaf set @xmath1 and no vertices of degree two .",
    "if every interior vertex of a @xmath1-tree has degree three , then @xmath2 is called a trivalent tree .",
    "a split @xmath3 of @xmath1 in a tree @xmath2 is a partition of the leaves into two non - empty blocks , @xmath4 and @xmath5 .",
    "removing an edge @xmath6 from a phylogenetic @xmath1-tree @xmath2 divides @xmath2 into two connected components , which induces a split of the leaf set @xmath1 .",
    "we will call this the split associated with @xmath6 .",
    "the collection of all the splits associated with the edges of @xmath2 is called the splits of @xmath2 denoted by @xmath7 .",
    "two splits @xmath8 and @xmath9 of @xmath1 are compatible if at least one of the four intersections @xmath10 and @xmath11 is empty .",
    "also note that a collection @xmath12 of splits of @xmath1 is compatible if it is contained in the splits of some tree @xmath2 ( @xcite ) .",
    "we adopt all of these notations in @xcite .    a collection @xmath12 of splits of @xmath1 is pairwise compatible if and only if there exists a tree @xmath2 such that @xmath13 .",
    "let @xmath14:=\\{1,\\cdots , n\\}$ ] and @xmath15 be the number of states in the alphabet , @xmath16 set @xmath17 is the joint probability that leaf @xmath18 is observed to be in state @xmath19 for all @xmath20 .",
    "write @xmath21 for the entire probability distribution .",
    "a flattening along a partition @xmath3 is the @xmath22 by @xmath23 matrix where the rows are indexed by the possible states for the leaves in @xmath4 and the columns are indexed by the possible states for the leaves in @xmath5 .",
    "the entries of this matrix are given by the joint probabilities of observing the given pattern at the leaves .",
    "we write @xmath24 or shortly @xmath25 for this matrix .",
    "next we define a measurement that a general partition of the leaves is close to a split .",
    "if @xmath4 is a subset of the leaves of @xmath2 , then let @xmath26 be the subtree induced by the leaves in @xmath4 .",
    "that is , @xmath26 is the minimal set of edges needed to connect the leaves in @xmath4 .",
    "suppose that @xmath3 is a partition of @xmath27 $ ] .",
    "the distance between the partition @xmath3 and the nearest split , written @xmath28 , is the number of edges that occur in @xmath29 .",
    "notice that @xmath30 exactly when @xmath3 is a split . consider @xmath31 as a subtree of @xmath26 .",
    "color the nodes in @xmath32 red , the nodes in @xmath33 blue .",
    "say that a node is monochromatic if it and all of its neighbors are of the same color .",
    "we let @xmath34 be the number of monochromatic red nodes .",
    "define @xmath34 as the number of nodes in @xmath35 that do not have a node in @xmath33 as a neighbor .",
    "the following theorem shows how close a partition is to being a split with the rank of the flattening associated to that partition .",
    "originally this theorem is proved for the case that @xmath2 is a trivalent tree .",
    "on the other hand , we have the same result for the non - trivalent tree @xmath2 whose proof is almost same as original one in @xcite .",
    "[ thm2.5 ] let @xmath3 be a partition of @xmath27 $ ] , @xmath2 be an unrooted tree which is not necessarily trivalent with leaves labeled by @xmath27 $ ] , and assume that the joint probability distribution @xmath21 comes from a markov model on @xmath2 with an alphabet with @xmath15 letters .",
    "then the generic rank of the flattening @xmath36 is given by @xmath37    refer to @xcite , theorem 19.5 .",
    "using theorem [ thm2.5 ] we have the following corollaries .    [ cor2.6 ] if @xmath3 is a split in the tree , the generic rank of @xmath25 is m.    [ cor2.7 ] if @xmath3 is not a split in a trivalent tree and we have @xmath38 then the generic rank of @xmath36 is at least @xmath39 .    for the non - trivalent tree case we have a different result comparing to corollary [ cor2.7 ] ,",
    "i.e. , generic rank of @xmath40 is at least @xmath15 .",
    "the reason for the different result comes from considering the following 4-valent tree with @xmath41 .",
    "actually , in this case we have @xmath42 , @xmath43 for non - split @xmath3 .",
    "hence we get @xmath44 .",
    "( 200,110 )    ( 10,110)@xmath45    ( 0,70)@xmath46    ( 10,30)@xmath47    ( 50,70)(-1,0)40    ( 50,70)(-1,-1)30    ( 50,70)(-1,1)30    ( 50,70)(1,0)30    ( 50,75)@xmath48    ( 70,75)@xmath49    ( 80,70)(1,1)60    ( 100,105)@xmath50    ( 110,100)(1,-1)30    ( 145,60)@xmath51    ( 145,130)@xmath52    ( 80,70)(1,-1)30    ( 110,45)@xmath53    ( 110,40)(-1,-1)30    ( 70,0)@xmath54    ( 110,40)(1,0)40    ( 140,30)@xmath55    ( 150,40)(1,1)30    ( 185,75)@xmath56    ( 150,40)(1,-1)30    ( 185,5)@xmath57    a singular value decomposition of a @xmath58 matrix @xmath4 ( with @xmath59 ) is a factorization @xmath60 where @xmath61 is @xmath62 and satisfies @xmath63 , @xmath64 is @xmath65 and satisfies @xmath66 and @xmath67 , where @xmath68 are called the singular values of @xmath4 .",
    "we need the following theorem to define svd distance in the next section .",
    "[ thm : svd - dis ] the distance from @xmath4 to the nearest rank @xmath69 matrix is @xmath70 in the frobenius norm .",
    "in this section , we have an algorithm for constructing a phylogenetic tree using svd of flattenings which improves erikkson s algorithm in view of numerical stability ( cf .",
    "first we define a function called svd - cherry as follows .",
    "[ svd - dis ] for each distinct pair @xmath71 in the @xmath69 species @xmath72 , svd distance @xmath73 between @xmath74 , and @xmath75 in @xmath76 is defined by the distance from the flattening @xmath77 to the nearest rank @xmath15 matrix in the frobenius norm .",
    "[ svd - cherry ] for given @xmath69 species @xmath72 , define @xmath78 so that the pair @xmath79 in @xmath76 and their svd distance @xmath80 in @xmath76 satisfies that @xmath81\\times [ k],~ i\\ne j\\}.\\ ] ]    using definition [ svd - cherry ] , we have the following algorithm . + * algorithm 1 ( building a phylogenetic tree using svd of flattenings ) *    * input * : a multiple alignment of genomic data from @xmath82 species from the alphabet @xmath83 with @xmath15 states .",
    "* output * : an unrooted phylogenetic tree @xmath2 with @xmath82 leaves labeled by the species .",
    "* initialization * : partition @xmath82 species @xmath84 into @xmath82 singletons as @xmath85 .",
    "* loop * : for @xmath69 from @xmath45 to @xmath86 , perform the following steps .",
    "* step 1 * : for each @xmath87 species @xmath88 where @xmath89 is a representative of @xmath90 , @xmath91 , find a distinct pair of clusters @xmath92 such that @xmath93 for @xmath94 .",
    "* step 2 * : choose the pair of clusters @xmath95 which occurs most frequently in step 1 .",
    "* step 3 * : join @xmath96 and @xmath97 together in the tree and consider this as a new cluster @xmath98 .",
    "after that rename the remaining @xmath90 s as @xmath99 .",
    "+    [ prop3.1 ] algorithm 1 needs to compute svd at most @xmath100{k\\choose 2}$ ] times . here",
    "$ ] is the maximum possible integer not greater than @xmath102 .",
    "if we have @xmath69 clusters @xmath103 , then the number of possible representatives for each clusters is @xmath104 . since @xmath105 @xmath104 has maximum @xmath102 where @xmath106 . here",
    "@xmath107 is the cardinality of @xmath108 .",
    "thus we manipulate svd at most @xmath100{k\\choose 2}$ ] times in total for the flattenings with fixed number of rows , i.e. , @xmath39 .",
    "each cluster @xmath109 in algorithm 1 means a split in the tree . in algorithm 1",
    "we have the following hierarchy of @xmath90 s . in the initialization , @xmath110 mean @xmath82 trivial splits , in other words , outer edges in tree @xmath2 . at the end of the first loop ,",
    "there is one new cluster among @xmath111 ) , which means one new split in @xmath2 . at the end of each @xmath69-th loop from @xmath112 up to @xmath113",
    ", we obtain one new edge in @xmath2 . in total",
    "we have the exact @xmath114 splits in @xmath2 .",
    "@xmath115    the matrix size @xmath116 of flattenings may be large where @xmath69 varies from @xmath82 to 4 , on the other hand flattenings are very sparse .",
    "thus , it is faster to compute the eigenvalues of @xmath117 of fixed size @xmath118 for every flattening @xmath4 than singular values of @xmath4 itself of size @xmath119 .",
    "erikkson computed singular values of flattenings of various huge size @xmath120 where @xmath3 is a partition of @xmath27 $ ] . that must cause numerical instability .",
    "we , however , avoid computational difficulties which come from numerical instability since we only deal with @xmath117 of fixed size @xmath118 for every flattening @xmath4 .",
    "although we also have difficulty in computing lots of svd of matrices of fixed size @xmath118 , if the number of species grows , algorithm 1 is fit for parallel computing , especially , grid computing which arranges lots of volunteer computing resources to do distributed computing .    [ thm3.2 ] algorithm 1 is statistically consistent .    by corollary [ cor2.6 ] , we can see that @xmath73 goes to 0 if @xmath121 is a true split of @xmath122 . while corollary [ cor2.7 ] shows that @xmath73 does not go to 0 if @xmath123 is a partition which is not a split of @xmath76 .",
    "hence , as the empirical distribution approaches the true one , the distance of a split from rank @xmath15 will go to zero while the distance from rank @xmath15 of a non - split will not .",
    "therefore algorithm 1 picks a correct split at each loop .",
    "( 300,110 )    ( 240,102)@xmath45    ( 240,82)@xmath46    ( 240,62)@xmath47    ( 240,42)@xmath52    ( 240,22)@xmath51    ( 240,2)@xmath56    ( 200,107)@xmath124    ( 200,87)@xmath124    ( 200,67)@xmath124    ( 200,47)@xmath124    ( 200,27)@xmath124    ( 200,7)@xmath124    ( 135,97)@xmath124    ( 135,57)@xmath124    ( 135,17)@xmath124    ( 170,105)(1,0)60    ( 170,105)(0,-1)20    ( 170,85)(1,0)60    ( 170,65)(1,0)60    ( 170,65)(0,-1)20    ( 170,45)(1,0)60    ( 170,25)(1,0)60    ( 170,25)(0,-1)20    ( 170,5)(1,0)60    ( 110,95)(1,0)60    ( 110,95)(0,-1)40    ( 110,55)(1,0)60    ( 110,75)(-1,0)10    ( 100,75)(0,-1)60    ( 100,15)(1,0)70    * example *    we begin with an alignment of dna data of length 1000 for 6 species , labeled @xmath125 simulated from the tree in figure [ ex1 ] with all branch lengths equal to 0.1 . for the loop ( @xmath112 ) , let @xmath126 and consider all pairs of the 6 species . in the following results , the svd - val(@xmath127 ) is the distance from the flattening @xmath128 to the nearest rank @xmath52 matrix in the frobenius norm as in theorem [ thm : svd - dis ] after first loop , since svd - cherry(@xmath129)=(5 ,  6 ,  0.0076 ) , we have a new cluster @xmath130 and rename @xmath131 . + for the loop ( @xmath132 ) , first take 5 as a representative of @xmath130 and get svd - cherry(@xmath133 ) = ( 3 ,  4 ,  0.0127 ) . next choose 6 as a representative of @xmath130 and get svd - cherry(@xmath134 ) = ( 3 ,  4 ,  0.0127 ) . most frequent pair of clusters in @xmath135 is @xmath136 .",
    "we obtain a new cluster @xmath137 and rename @xmath138 .",
    "+ for the loop ( @xmath139 ) , first take 3 as a representative of @xmath137 , 5 as a representative of @xmath140 , then we get svd - cherry(@xmath141)=(1 ,  5 ,  0.0208 ) .",
    "next choose 3 as a representative of @xmath137 , 6 as a representative of @xmath140 , get svd - cherry(@xmath142)=(1 ,  2 ,  0.0167 ) .",
    "by the same manner we have svd - cherry(@xmath143)=(1 ,  2 ,  0.0214 ) , svd - cherry(@xmath144)=(1 ,  2 ,  0.0168 )",
    ". most frequent pair of clusters in @xmath145 is @xmath146 .",
    "we obtain a new cluster @xmath147 and rename @xmath148 .",
    "we can join these three clusters @xmath149 to make an unrooted tree .",
    "in algorithm 1 , if we can reduce the number of feasible representative of each cluster @xmath90 using some available a priori information , then computational cost can be saved . in this section , for example",
    ", we choose the unique feasible representative of each cluster which has the smallest distance from species outside the cluster . + * algorithm 2 ( simplified tree constructing algorithm ) *    * input * : a multiple alignment of genomic data from @xmath82 species from the alphabet @xmath83 with @xmath15 states .",
    "* output * : an unrooted phylogenetic tree @xmath2 with @xmath82 leaves labeled by the species .    * initialization * : partition @xmath82 species @xmath84 into @xmath82 singletons as @xmath85 .    * loop * : for @xmath69 from @xmath45 to @xmath86 , perform the following steps .",
    "* step 1 * : for each cluster @xmath150 , choose the representative @xmath151 by the following ;    for all @xmath152 , calculate @xmath153\\backslash c_{k , j}}p(s , s')}$ ] where @xmath154 is the    proportion of different nucleotides between two species @xmath155 .",
    "choose @xmath151    which has the smallest value @xmath156 for all @xmath152 .",
    "* step 2 * : for @xmath157 where @xmath158 , find a distinct pair of clusters @xmath92 such that @xmath159 for @xmath94 .",
    "* step 3 * : join @xmath160 and @xmath161 together in the tree and consider this as a new cluster @xmath98 .",
    "after that rename the remaining @xmath90 s as @xmath99 .",
    "+ note that algorithm 2 is much faster to construct phylogenetic trees with many leaves since it uses only one representative for each cluster @xmath90 .",
    "we chose phylogenetic tree models as in figure [ model trees ] and simulated dna sequence data on these trees using the program seq - gen ( @xcite ) .",
    "figure [ model trees ] shows variables @xmath162 in the trees .",
    "these trees were chosen as difficult trees in @xcite .",
    "next , we built trees using algorithm 1,2 and neighbor joining algorithm with jukes - cantor distance from these data , respectively .",
    "for each algorithm , we plotted percent of tree reconstructed among 1000 dna data set for various sequence lengths .",
    "figure [ c=.07 ] shows the results for the case of @xmath163 for both model trees in figure [ model trees ] .",
    "the results for the case of @xmath164 are shown in figure [ c=.19 ] .",
    "algorithm 1 shows better performance than algorithm 2 , but , worse than the neighbor joining algorithm .",
    "it might be expected because the used dna data were simulated by distance based algorithm .",
    "we tested algorithm 1,2 to reconstruct a tree with many species , for example 32 species .",
    "we simulated 100 dna data sets of length 1000 for 32 species from the tree in figure [ 32taxa ] with all branch lengths equal to .1 .",
    "we got 94 % of reconstruction rate using algorithm 2 , whereas 99 % of reconstruction rate with neighbor joining algorithm . for the algorithm 1",
    ", we tested only 1 data set using parallel cluster machine with 10 athlon 2600 cpus .",
    "it took about 3 hours for 1 data set . the loop number which took longest time was 19 .",
    "algorithm 1 did @xmath175 svd computations in 19-th loop .",
    "the important point is that we change the type of difficulty in dealing with rebuilding tree of many species from time and numerical instability to time only .",
    "furthermore , the difficulty in time can be overcome in various ways .      for data ,",
    "we use the september 2005 freeze of the encode alignments .",
    "we restrict our attention to the problem of constructing phylogenetic tree for 8 species : human , chimp , galago , mouse , rat , cow , dog , and chicken , which is called rodent problem .",
    "we processed each of the 44 encode regions to obtain data sets which have ungapped columns greater than 100 bps in length .",
    "we obtain 75 data sets in manually chosen 14 enm regions and 301 data sets in all 44 encode regions .",
    "recall that the robinson - foulds metric which is also called the partition metric was proposed by @xcite is one of the simplest metrics on trees .",
    "the distance between two trees @xmath176 and @xmath177 is defined by latexmath:[\\[d_{rf}(t_1,t_2)=\\frac{1}{2}(|\\mathcal s(t_1)-\\mathcal s(t_2)|+      rodents have very different morphological features , although their molecular data is similar to that of the primates .",
    "thus , lots of biologists pay attention to rodents .",
    "tree construction algorithms using genomic data usually misplace the rodents , mouse and rat , on the tree , with respect to other mammals . according to fossil records and molecular data",
    ", we have the biologically correct tree that is not sure whether it is correct . in this tree",
    "we have the primate clade with human and chimpanzee and then the galago as an outgroup to these two .",
    "the rodent clade ( mouse and rat ) is a sister group to the clade ( human , chimpanzee and galago ) and the clade ( dog and cow ) is the outgroup to former 5 species .",
    "the chicken is an outgroup to all of these as a root of this phylogenetic tree . on the other hand , usual tree reconstruction algorithm mislocate the rodents and",
    "so locate them as an out group to the clade ( human , chimpanzee and galago ) ( see figure [ rodent problem ] ) .",
    "the reasons for this are not entirely known , but it could be since tree construction methods generally assume the existence of a global rate matrix for all the species .",
    "however , rat and mouse have mutated faster than the other species .",
    "our algorithms does not assume anything about the rate matrix ( @xcite , chapter 21 ) .",
    "in fact , table [ comparison ] shows that our algorithms performs quite well on the encode data sets comparing to nj(neighbor joining algorithm with jukes - cantor distance ) algorithm .",
    "algorithm 1 constructs the correct tree similar to nj ( cf .",
    "@xcite , p.357 ) , but , has shorter symmetric distance @xmath184 on average than nj algorithm .                    , phylip , _ phylogeny inference package version 3.6 distributed by the author : http://evolution.genetics.washington.edu/phylip .",
    "html _ , department of genomic sciences university of washington , seattle , 2004 ."
  ],
  "abstract_text": [
    "<S> erikkson showed that singular value decomposition(svd ) of flattenings determined a partition of a phylogenetic tree to be a split ( @xcite ) . in this paper , based on his work , </S>",
    "<S> we develop new statistically consistent algorithms fit for grid computing to construct a phylogenetic tree by computing svd of flattenings with the small fixed number of rows . </S>"
  ]
}