{
  "article_text": [
    "as acknowledged by , _",
    "software architectures _ have become accepted as one of the main artefacts of software development .",
    "they form an integral part of the specification of a wide variety of complex software - intensive systems . including architectural design in the early stages of the software system life - cycle can be decisive for the software s success .",
    "they provide a powerful abstraction mechanism that is critical to support the successful development and evolution of the software systems they describe    the growing importance of software architecture descriptions and the maturity of the research field led to the @xcite that defines a software architecture as _",
    "`` the fundamental organization of a system embodied in its components , their relationships [ ... ] and the * principles guiding its design and evolution*. '' _ research on such principles for guiding architectural evolution has received relatively little attention , despite the promise of controlling cost and other change - related challenges ( cf . ) .",
    "our main objective is to offer a disciplined way to reuse evolution knowledge within software architectures .",
    "we focus on a specific and recurring evolution need : introducing an architectural style by restructuring an existing software architecture .",
    "we propose to formalise and automate _ evolution patterns _ as a means to guide and support evolution of architectural descriptions .",
    "the overall approach follows three successive stages to specify a reusable evolution process : ( 1 ) _ reify architectural concepts _ that may evolve ; ( 2 ) specify a minimal set of _ recurring evolution operations _ on these concepts ; and ( 3 ) specify _ the evolution process _ through a specific workflow of evolution operations applied to identified architectural concepts .",
    "this article is structured as follows .",
    "section  [ sec : softarchevol ] introduces and explains the necessary architectural concepts .",
    "section  [ sec : casestudyspec ] presents a case study using the architectural description language .",
    "section  [ sec : graphtransspec ] formally presents and analyses the approach using graph transformations .",
    "section  [ sec : validation ] explains how we implemented and validated these ideas in , an eclipse plug - in for .",
    "section  [ sec : relatedwork ] discusses related work , section  [ sec : future ] highlights some avenues of future research and section  [ sec : conclusion ] concludes .",
    "the use of architectural descriptions has become well - established .",
    "they specify the various concerns of the system at a high level of abstraction .",
    "such descriptions are made possible thanks to primary notions and concepts of viewpoints and views , architectural description languages and architectural styles .    the architectural description of a software - intensive system is commonly organized in several representations , like the different types of architectural blueprints in building construction .",
    "the objective is to reduce complexity and to facilitate system understanding .",
    "we base our work on the @xcite , partly illustrated in figure  [ fig : conceptualmodel ] by the shaded dotted rectangle : a description of the _ architecture _ of a _ system _ is composed of _ views _ expressed along different _ viewpoints _ addressing _ concerns _ that are important to a particular set of _",
    "viewpoints are generic and can concern several architectures , while views are architecture - specific .",
    "viewpoints thus allow to organise an architectural description where each view conforms to a particular viewpoint . according to @xcite , one of the main viewpoints",
    "is the _ structural _ viewpoint .",
    "following @xcite , it structures the organization of an architectural description in terms of coarse - grained _ components _ with _ ports _ and their interactions through _ connectors _ with _ roles _ , ignoring technical and implementation details . as suggested in figure  [ fig : conceptualmodel ] , the current article focuses on structural viewpoint .",
    "we will use from now on the term _ architecture _ to refer to _ architectural description within the structural viewpoint_.    _ architectural description languages ( adls ) _ have been proposed as a formal means to describe software architectures following the structural viewpoint .",
    "many adls have been proposed over the years : _ acme _ by , _",
    "aesop _ by , _",
    "c2sadel _ by , _ darwin _ by , _ metah _ by , _",
    "rapide _ by , _ sadl _ by , _ unicon _ by , _",
    "wright _ by and _ aadl _ by @xcite .",
    "each of them has its own notation and features , often with their own supporting methods and tools .",
    "they generally propose the same concepts of _ component _ , _ port _ , _ connector _ and _",
    "role_.    as advised by @xcite and , an adl should also provide support to _ evolve _ architectural descriptions .",
    "however , many adls , generally domain - specific ones , do not support such architectural evolution .",
    "those that do , typically rely on mechanisms offered by the underlying programming language , such as subtyping and inheritance or refinement .",
    "the architectural concepts that are subject to evolution are typically _ components _ and _ connectors _ for those adls that support them as first - class entities .",
    "introduced the concept of _ architectural style _ as a disciplined mechanism to guide the design and use of architectures .",
    "refer to an _ architectural style _ as a family of architectures in terms of a _ pattern of structural organization _ through a coordinated set of architectural constraints .",
    "these architectural constraints define : a unified vocabulary of component and connector types ; constraints on relations between these types ; and a semantic interpretation for each instantiated element .",
    "rely on architectural styles to facilitate the _ construction _ of architectures , while use styles to constrain and evolve architectures .    among the best known structural architectural styles are the _ pipe - and - filter _ style of and the _ client - server _ style of .",
    "any of these architectural styles defines specific types of components , ports , connectors and roles in addition to a set of architectural constraints . in this article",
    "we focus on the _ client - server _ architectural style as a case study .",
    "figure  [ fig : conceptualmodel ] shows how to fit it into the iso / iec conceptual framework .",
    "evolution mechanisms proposed by adls are generally tied to supporting tools , and thus hardly reusable when a similar architectural evolution situation occurs .",
    "an explicit specification of _ evolution pattern _ would enable future reuse , thereby reducing the costs and risks of architectural evolution in the long run .",
    "a typical example of such a reoccurring pattern is the restructuring of a monolithic architecture of a legacy system into a distributed client - server architecture .    _",
    "evolution patterns _ can be specified in terms of more elementary predefined architectural _",
    "evolution operations_. while an elementary evolution operation can lead a given architecture to an inconsistent state , an evolution pattern allows to evolve an architecture from a consistent state to another consistent one . as an evolution pattern",
    "should be reusable , its well - formedness needs to be validated before being proposed for reuse in similar evolution situations on different architectures . upon application of the evolution pattern",
    ", automatic analyses can be performed to determine the conformity of the evolved architecture , and to report or resolve any conformance problems that may arise .",
    "in this article , we will illustrate our approach through the specification , analysis and execution of an evolution pattern to introduce the client - server architectural style on a monolithic e - shop architecture . to do so",
    ", we will rely on the adl developed by @xcite and its associated tool .",
    "we use for four main reasons : _",
    "( i ) _ it is generic and extensible , defined through a metamodel ; _ ( ii ) _ it manipulates architectural elements ( configuration , component , connector , port , role ,  ) as first - class entities ; _ ( iii ) _ it can be easily extended with new first - class concepts , which is very useful if we want to add evolution operations and evolution patterns ; _ ( iv ) _ the metamodel and source code of are available to us .    the notion of computation ( represented by _ components _ ) is separated from the notion of interaction and communication ( represented by _ connectors _ ) .",
    "a component has a set of ports ( provided or required ) .",
    "the topological structure of the architecture is represented within a _ configuration _ , a graph of interconnected components .",
    "each composite component has its own configuration that handles its internal architectural elements .",
    "connectors can either be user - defined or built - in . in the latter case , we distinguish between _ attachments _ ( to connect a port to a role ) and _ bindings _ ( to interconnect two ports or two roles , generally in case of delegation ) .",
    "figure  [ fig : eshoparchitecturesimplespecnodep ] presents the monolithic e - shop architecture in .",
    "it contains three main components : ` product ` , ` customer ` and ` order ` with their own ports in addition to a set of connectors .",
    "we only explain one component , ` customer ` , as the two other components follow the same spirit . `",
    "customer ` has four required ports ( ` userdetails ` , ` pwd ` , ` acceptbill ` and ` pay ` ) and three provided ports ( ` authenticate ` , ` createcustomer ` and ` bill ` ) . for aims of clarity ,",
    "the names of these provided ports are hidden since the connectors they are attached to have the same names .",
    "the e - shop architecture also specifies how its components interact together through four connectors : ` openorder ` , ` authenticate ` , ` createcustomer ` and ` bill ` .",
    "each of these connectors has two roles , to connect a provided port of one component to a required port of another component .",
    "some component s ports , such as ` userdetails ` are connection - free and represent the interaction points of e - shop with its environment .",
    "since we focus on the structural viewpoint in this article , we restrict ourselves to expressing _ structural dependencies_. ideally , architectural restructuring , expressed by evolution patterns , should preserve dependencies : if some provided port of a component ( transitively ) depends on a required port of a ( possibly different ) component , this should remain the case after the restructuring .    in order to address properly architectural restructuring ,",
    "we need to consider all structural dependencies between ports of components . these dependencies can be of two kinds .",
    "_ external dependencies _ between different components are expressed using connectors , attachments and bindings .",
    "_ internal dependencies _ between ports of the same component are generally not explicitly materialized .",
    "we enriched the metamodel and syntax with a new built - in connector type , named _ uses ( u ) _ , to represent these internal dependencies .",
    "the _ product _ component in figure  [ fig : splitcomp]*(a ) * has two such internal dependencies : port ` selectproduct ` _ uses _ port ` viewproduct ` ( a customer first needs to view products in order to select one ) , and port ` openorder ` _ uses _ port ` selectproduct ` ( a customer can only order selected products ) . although not explicitly shown in figure  [ fig : eshoparchitecturesimplespecnodep ] for aims of readability , the e - shop architecture is enriched with these internal structural dependencies .",
    "[ sec : structuredep ]    architectural restructurings , such as the migration to a client - server architecture typically need to preserve internal dependencies . generally used for network - based applications ,",
    "the client - server style proposes two additional types of component , _ server _ and _ client _ , that are connected together .",
    "a software architecture conforming to the client - server style is only allowed to have instances of the element types specified by the style .",
    "in addition , it must respect all constraints imposed by the style .",
    "a server component offers a set of services to its client(s ) . a client component , desiring for a service to be performed , may send a request to the server via a connector .",
    "the server either rejects or performs the request and sends a response back to the client . in this article",
    ", we will adopt the following variant : there must be exactly one server within a given architecture and at least one client , and each client must be connected to at least one server .",
    "in addition , any other type of component must be contained ( possibly indirectly ) in either a client or the server .",
    "our goal is now to specify an _ evolution pattern _ that evolves the e - shop architecture of figure  [ fig : eshoparchitecturesimplespecnodep ] into the architecture of figure  [ fig : clientserverarchitecturever2 ] that conforms to the client - server style .",
    "the evolution pattern represents an architectural restructuring that preserves all external ports and structural dependencies of the original architecture .",
    "figure  [ fig : activitydiag ] shows the evolution patterns as a uml activity diagram , with two swimlanes representing ( a ) the automated changes carried out by the _ framework _ ; and ( b ) the changes manually triggered by the _ architect _ and executed by the framework .",
    "the activity diagram is composed of five basic steps , indicated by dashed rounded rectangles :    1 .",
    "the _ framework _ creates one server and @xmath0 clients ( @xmath1 ) with the names of all new components specified by the architect . for our e - shop architecture , @xmath2 , so one ` server ` component and one ` client",
    "` component are created .",
    "2 .   as client(s ) and the server are the only top - level components allowed , the architect selects existing components to be moved into a client or into the server . to obtain figure  [ fig : clientserverarchitecturever2 ] ,",
    "the architect chooses to move the ` order ` component in ` server ` , and the ` product ` and ` customer ` components in ` client ` .",
    "the _ framework _ moves the selected components in the server and client(s ) and transforms automatically all connectors and dependencies consistently to remain conform to the adl and the client - server architectural style .",
    "the architect manually triggers further desired changes . in the example",
    ", she wishes to have a ` product ` component in both ` server ` and ` client ` with different ports .",
    "it is thus necessary to _ split _ the ` product ` component in two components , ` product ` ( that allows the user to view and select products ) and ` product_server ` ( that encapsulates product information in the server ) .",
    "the architect also wishes to provide the ` cancel ` service from the ` server ` .",
    "the _ framework _ executes the requested changes and checks whether the architecture still conforms to the client - server style and the adl . in the example , splitting ` product ` and moving the resulting component ` product_server ` in ` server ` requires to adapt existing dependencies and connectors , yielding the final architecture in figure  [ fig : clientserverarchitecturever2 ] .        in section  [ sec : graphtransspec ]",
    "we show how this evolution pattern can be formally specified and analysed , and section  [ sec : validation ] shows how it is implemented in the tool .      the _ evolution pattern _ of figure  [ fig : activitydiag ] is essentially defined as an application of elementary architectural evolution operations in a particular order .",
    "we have identified many such operations in , such as : _ move port _ from a component to another , _",
    "split component _ into two or more components , _ merge components _ into one component , _ move in component _ as a subcomponent of another and _ move out component _ from its containing component .",
    "to restructure the e - shop architecture into a client - server one , we applied several of these evolution operations . during step 3 of figure  [ fig : activitydiag ] , _ move in component _",
    "was used to move components into ` client ` or ` server ` , followed by transformation _",
    "delegate component port _ to create necessary bindings and connectors using more primitive transformations like _ move port _ coupled with the creation of corresponding ports and attachments on ` client ` and ` server ` . during step 5 , the _ split component _ operation was applied to achieve specific changes requested by the user : splitting the ` product ` component ( belonging to ` client ` ) in two components ` product ` and ` product_server ` .",
    "the latter one is subsequently _ moved out _ of the ` client ` to be _ moved in _ to the ` server ` .",
    "this interactive evolution operation is guided and restricted by structural constraints , as illustrated in figure  [ fig : splitcomp ] .",
    "_ split component _ starts by selecting a component ( here : _ product _ ) , creating one or more new components ( here : _",
    "_ product_2 _ _ ) , and moving some manually selected ports of _ product _ into _ product_2_. while moving ports , in order to preserve structural dependencies we need to take into account three different situations :    * if the port to be moved does not depend on any other port , it can be moved to the target component without any additional changes . *",
    "if two ports with a _ uses_-dependency between them are both moved to the same target component , the internal dependency is moved along .",
    "* if the port to be moved has a _",
    "uses_-dependency to or from another port , this dependency needs to be preserved by the evolution pattern .",
    "this is for example the case in figure  [ fig : splitcomp ] for _ open order _ port that uses _ select product_. to preserve the dependency , after moving _ openorder _ to _ product_2 _ , a provided port _ pro _ on _ product _ and a required port _ req _ on _ product_2 _ are created , and a connector is added to connect these two ports .",
    "in addition , _",
    "uses_-dependencies are respectively created between the new port _ pro _ and _ selectproduct _ and the new port _ req _ and _ open order_. as a result , the initial _ uses _ dependency from _ open order _ to _ select product _ is automatically replaced by a longer dependency path between both ports , via an intermediate connector and two newly created ports and two newly created _ uses_-dependencies .",
    "a prerequisite for providing automatic support for architectural evolution is the ability to formally specify the adl , architectural styles and evolution patterns .",
    "we use graph transformation theory for this purpose .",
    "the analogy between architectural evolution and graph transformation is quite natural : an architecture description can be expressed as a graph containing a set of interconnected components .",
    "graph transformations allow us to formally analyse and reason about architectural evolution operations .    in this section",
    "we explain how we use agg for this puropse , a java - based graph transformation engine conceived by @xcite .",
    "we exploit agg s built - in formal analysis mechanisms to reason about evolution patterns and their relation to the architectural styles .",
    "figure  [ fig : typegraph ] shows how the part of the metamodel that is of interest to us is expressed as a _",
    "type graph_. any well - formed architecture can be represented as a graph that conforms to this type graph .",
    "the type graph represents all architectural concepts we want to reason about ( e.g. , component , port , connector , role ) as a _",
    "node type_. the associations or relations between the architectural concepts ( e.g. , bindings , attachments , uses dependencies and containment relationships ) are represented by _ _",
    "edge type__s .",
    "the type graph imposes ( lower and upper ) multiplicity constraints on edge types .",
    "node and edge types may contain additional attributes , and inheritance can be used between node types , as explained by @xcite .",
    "this is the case between the abstract node type _ port _ ( resp .",
    "_ role _ ) and its two concrete subtypes _ provport _ ( resp .",
    "_ provrole _ ) and _ reqport _ ( resp .",
    "_ reqrole _ ) that represent provided and required ports ( resp .",
    "all node types contain an attribute ` n ` of type _ string _ to represent the name of the corresponding node .",
    "_ role _ ) should always be connected by an edge of type _ hasport _ ( resp .",
    "_ hasrole _ ) to exactly one _ component _ ( resp . _ connector _ ) , and a _ component _ ( resp . _ connector _ ) may have any number of _ ports _ ( resp .",
    "_ roles _ ) .",
    "the edge type _ contains _ relates a component to one of its subcomponents ( via an intermediate _ configuration _",
    "node type ) .",
    "the _ binding _ edge type represents the binding of a port of the component to a port ( of the same type ) belonging to its subcomponent .",
    "the _ uses _ edge type represents a structural internal dependency between ports .    in order to simplify the formal representation of architectures , the type graph also includes so - called  derived \" edge typess ( _ connectsto _ and _ connector_. figure  [ fig : graphinvariant0 ] shows how they are expressed in terms of a more complex path of other node types and edge types .",
    "in addition to the type graph , graph invariants are needed to specify well - formedness constraints that can not be expressed directly by the type graph .",
    "some of these are : ( i ) a component can not be connected to , or contained in , itself ; ( ii ) a _ binding _ is only allowed between ports of the same type belonging to a component and one of its subcomponents ; ( iii ) a _ uses _ dependency is only allowed between different ports belonging to the same component ; ( iv ) two components can not be at the same time connected to , and contained in , one another . constraint ( ii ) and ( iii )",
    "are formally expressed as graph invariant in figure [ fig : bindingcontainment ] .",
    "the others can be expressed in a similar way .",
    "a architecture can be represented as a _ graph _ conforming to the type graph together with all of its graph invariants .",
    "figure  [ fig : graph ] shows the graph corresponding to the e - shop architecture of figure  [ fig : eshoparchitecturesimplespecnodep ] .",
    "this time , we have explicitly shown the _",
    "uses_-dependencies that were kept hidden in figure  [ fig : eshoparchitecturesimplespecnodep ] . with agg",
    ", we can automatically verify that this graph conforms to its type graph and that all imposed graph invariants are satisfied .",
    "to formalise an architectural style , we proceed in a similar way as for formalising the adl : we extend the type graph and add graph invariants that express the additional constraints imposed by the architectural style .",
    "the left part of figure  [ fig : cstg ] shows how two new _ component _ subtypes need to be added to the type graph to represent the client - server architectural style : a _ client _ node type and a _ server _ node type .",
    "the node multiplicities state that there should always be one server and at least one client .",
    "the edge multiplicities state that each client must be connected to one server .",
    "in addition , we need to add two extra graph invariants that further constrain the type graph : ( i ) a _ client _ component must always connected to _ server _ via one of its ports ( see right part of figure  [ fig : cstg ] ) ; ( ii ) any component that is not a _ client _ or _",
    "server _ must be contained in another component ( i.e. , only _ client _ and _ server _ are allowed as top - level components ) .",
    "for the sake of simplicity , we have not modeled the use of a particular client - server protocol .",
    "how to specify and analyse such a protocol is a topic of future work .",
    "a distinct advantage of formalising architectural styles is the ability to verify whether a given architecture is well - formed ( i.e. , it conforms to its adl ) , and whether it conforms to an architectural style .",
    "this kind of verification is quite straightforward .",
    "we have defined the adl and the client - server architectural style as a type graph together with additional graph constraints , and agg provides direct support for checking whether a graph conforms to its type graph and its associated graph constraints .",
    "this checking was successfully done on our e - shop architecture , before and after introduction of the client - server style .",
    "[ sec : rulesequences ]    in order to specify architectural evolution patterns we rely on the notion of a _",
    "graph transformation_. essentially , a graph transformation takes a graph as input and produces another graph as output .",
    "it is specified by means of a _ graph transformation rule _ that must conform to the type graph and all graph constraints .",
    "figure  [ fig : movetoserver ] shows three examples of graph transformation rules that formalise activities of figure  [ fig : activitydiag ] : _ create server _ , _ move component to server _ and _ delegate provided port to server_. in general , the specification of a graph transformation rule is composed of three different parts ( displayed from left to right in the figure ) : a number of optional negative application conditions ( nac ) , a left - hand side ( lhs ) and a right - hand side ( rhs ) . applying",
    "the transformation proceeds as follows :",
    "1 .   an occurrence ( or `` match '' ) of the lhs needs to be found in the host graph .",
    "it is possible that multiple matches are found . in that case",
    ", the user selects the desired match or the tool chooses a match non - deterministically .",
    "if successful , the nac is used to verify that certain `` forbidden constructs '' do not appear in the match . in rule _",
    "createserver _ of figure  [ fig : movetoserver ] , nac _ noserver _ states that a server can not be created if there is already one .",
    "nocontainment _ of rule _ movecomponenttoserver _",
    "states that the component to be moved is not allowed to be contained in any other configuration .",
    "if the nac is satisfied , the transformation rule is applied by `` replacing '' the match corresponding to the lhs in the host graph by its rhs .",
    "identical numbers in lhs and rhs are used to identify nodes and edges that are to be preserved by the transformation .",
    "nodes or edges only appearing in the rhs are newly added ; nodes or edges only appearing in the lhs are removed by the transformation .",
    "_ evolution patterns _ can be formalised , in part , as sequences of graph transformation rules .",
    "the rule sequence below specifies the order in which to apply the transformation rules of figure  [ fig : movetoserver ] to move components into the server : + ` createserver ; ( movecomponenttoserver)^ * ; ( delegateprovporttoserver)^ * ; ( delegatereqporttoserver)^ * ` + the ` ; ` symbol specifies the order in which to apply the rules , whereas the ` * ` is used to specify a repetition of a rule ( or even a sequence of rules ) , by applying it as long as a new match can be found in the graph .",
    "rule sequences provide a way to formalise the _ evolution pattern _ of figure  [ fig : activitydiag ] that specifies the introduction of the client - server architectural style .",
    "an activity diagram represents a set of possible execution paths .",
    "each such path can be expressed by a rule sequence .",
    "as such , the set of rule sequences represents all possible execution scenarios specified by the evolution pattern .",
    "agg provides different ways to analyse whether an evolution pattern is well - defined , including _",
    "critical pair analysis ( cpa ) _ and _ rule sequence analysis_. cpa is used to detect parallel conflicts and sequential dependencies between pairs of transformation rules @xmath3 and @xmath4 . _",
    "parallel conflicts _",
    "represent situations in which two transformation rules are not jointly applicable to the same host graph : application of rule @xmath3 prohibits subsequent application of @xmath4 or vice versa .",
    "this is used , for example , to verify whether two rules are mutually exclusive .",
    "_ sequential dependencies _ represent situations where rule @xmath4 is causally dependent on @xmath3 : @xmath4 can not be applied directly to the host graph , but becomes applicable once @xmath3 has been applied .    as an example , consider the evolution pattern of figure  [ fig : activitydiag ] . starting from an initial software architecture",
    ", one can execute two parallel sequences of activities , denoted by a black horizontal bar with two outgoing transitions , represents the start of two parallel threads of execution . ] .",
    "the first sequence starts with _ create server _ followed by _ move component to server _ and _ delegate ( required or provided ) port to server _",
    "( step 3 ) .",
    "the second sequence is similar but for client instead of server .        to verify that the imposed order between the different activities actually makes sense , we specified each of them as a graph transformation rule , and ran the critical pair analysis to detect parallel conflicts and sequential dependencies between pairs of rules .",
    "the result of this analysis is shown in figure  [ fig : cpa - results ] .",
    "it corresponds to our intention : _ create client _ and _ create server _ are parallel independent ; they can be applied in parallel without any harm . _",
    "create server _ is in parallel conflict with itself because only one server can be introduced into the client - server architecture .",
    "_ move component to client _ and _ move component to server _ have a potential parallel conflict if one tries to move the same component in the client and in the server . _ move component to server ( resp .",
    "client ) _ is in conflict with itself because one can not move the same component twice .",
    "we also find all expected sequential dependencies : _ delegate ( provided or required ) port to server _ causally depends on _ move component to server _ that causally depends on _ create server_. this automated formal analysis makes us more confident that the evolution pattern specified in figure  [ fig : activitydiag ] for applying the client - server architectural style is well - defined .",
    "in fact , we used the formal analysis as a kind of debugging mechanism : it enabled us to fine - tune the graph transformation rules and the well - formedness constraints imposed by the architectural style .",
    "as explained by and , it is possible to analyse rule sequences and this analysis is supported by agg .",
    "we can specify any given path in an activity diagram as a rule sequence , verify whether this sequence is applicable and , if not , what are the potential applicability problems .",
    "for the example rule sequence defined earlier , figure  [ fig : ruleseq - anal ] shows the result of analysing applicability ( for details , see ) .",
    "it reveals that the analysed rule sequence does not have any particular inconsistency ( it would have been displayed in red otherwise ) . as a result",
    ", the application of the rules in the specified order will not provoke conflicts .",
    "this confirms the results concerning sequential dependencies observed in figure  [ fig : cpa - results ] .",
    "the rule sequence for moving components into a server thus is well - defined . analysing the rule sequence to move components into a client yields a similar result",
    "after this formal validation of our ideas , we present now the practical validation through the extension of _ cosabuilder _ , an eclipse plug - in that implements the adl to specify architectural descriptions .",
    "its extension with support for evolution patterns and architectural styles is shown in figure  [ fig : cosaevolframework ] .",
    "the right frame displays the initial palette of enriched with the concept of _ service use _ to represent uses dependencies between ports .",
    "the central frame displays the architecture description .",
    "evolution operations can be applied to it by selecting the appropriate architectural element and choosing the desired evolution operation from a context - sensitive menu .",
    "figure  [ fig : cosaevolframework ] shows the _ move in _ operation on the selected _ order _ component .",
    "figure  [ fig : cosaevolmovein ] shows a new menu that appears ( to select the target component into which _ order _ needs to be moved ) , as well as the architecture resulting from applying this evolution operation .",
    "the implemented evolution layer enables the definition of : _ ( i ) _ elementary architectural _ evolution operations _ , _ ( ii ) _ reified _ evolution patterns _ in terms of those elementary evolution operations and _ ( iii ) _ _ architectural styles _ that can be checked . evolution operations and evolution patterns",
    "are defined as first - class entities , by extending the meta - model with two new metaclasses : _ evolutionoperation _ and _",
    "evolutionpattern_.    each evolution operation is implemented as a java class using the _ singleton _ design pattern .",
    "it has a unique method _",
    "execute(parameters)_. the first parameter is the _ context _ : the architectural element to be modified .",
    "other parameters are specific to the evolution operation under consideration .",
    "we implemented the following elementary evolution operations , in such a way that they preserve internal _ uses _ dependencies :    * _ create _ or _ delete _ an architectural element ( component or connector ) or interface ( port or role ) .",
    "* _ move _ an architectural element to a new parent . * _ split _ an architectural element into two or more . * _ merge _ several architectural elements into one . *",
    "_ move out _ an element from its containing element , or _ move in _ an element inside another one ( shown in figures  [ fig : cosaevolframework ] and  [ fig : cosaevolmovein ] ) .",
    "* _ delegate _ : create a binding from a given port to another element in the architecture , generally its parent .",
    "evolution patterns can be implemented in terms of existing evolution operations .",
    "figure  [ fig : cosabuilder - style ] illustrates the execution of the evolution pattern of figure  [ fig : activitydiag ] to introduce the client - server style .",
    "figure  [ fig : cosacheckstyle ] illustrates how to check conformance of an architecture to the client - server architectural style .",
    "this is achieved in three steps : ( 1 ) open the evolution window ; ( 2 ) select the architectural style to be checked on the architecture ; and ( 3 ) display the result of applying the architectural style , together with a message window indicating success or failure of the conformance checking .",
    "figure  [ fig : cosacheckstyleresults ] shows an example of success on the left , and an example of failure on the right .",
    "a variety of related work focuses on the individual topics that form part of our architectural evolution framework .",
    "the novelty of our research is that we combine several topics together by introducing the use of evolution patterns , formally specifying and analysing them using graph transformation to introduce and check architectural styles , and implementing them in an architectural modeling tool for the adl .",
    "@xcite used graph transformation theory to describe software architecture and architectural style as graph grammars .",
    "he proposed to use a coordinator in terms of rules that must be statically checked , as opposed to our use of evolution patterns that introduce architectural styles .",
    "@xcite used graph transformation theory to present an algebraic foundation for software architecture reconfiguration .",
    "@xcite formalised architectural refactorings as hypergraph transformation rules that can be applied automatically .",
    "the idea of considering architectural styles as typical architectural `` evolution patterns '' was first introduced by who proposed the sem model that introduces the concept of _ evolution style_. @xcite defined an evolution style as a set of evolution paths among different kinds of systems .",
    "@xcite provide first - class operations that express and capture architectural changes .",
    "the main difference is the type of evolution operations that are provided and the adl for which they are supported .",
    "an additional difference is that we use these evolution operations as elementary building blocks to create more complex evolution patterns to introduce architectural styles .",
    "go beyond the evolution pattern by proposing a framework to tailor evolution processes according to some desired architectural traits by looking for them in a given architectural knowledge base .",
    "the current article only scratched the surface of how one should provide more disciplined support for architectural evolution .",
    "this section provides a roadmap of future work that is still required in this very important emerging research domain .",
    "our formalisation of the structural viewpoint and the client - server architectural style , only focused on the architectural elements , relations and structural constraints between them .",
    "as explained by , many adls enable the formal analysis and verification of important non - functional properties such as consistency , completeness , correctness , performance , reliability , security , availability and dependability .",
    "we need to integrate support for verifying such properties , and to preserve these properties during architectural evolution .",
    "we also need support for documenting the rationale behind an architecture and its imposed architectural styles .    because offers 4 layers of modeling ( similar to the omg mda architecture ) , the tool support can accommodate other adls as well by considering as a pivot adl .",
    "@xcite proposed strategies to transform an architectural description specified in to a description in another adl such as uml 2 .",
    "this would allow us to benefit from a wide range of tools that have been implemented for the uml language .",
    "our case study presented only one viewpoint and architectural style . applying it to other viewpoints and styles",
    "opens up the possibility to evolve an architectural description that involves multiple viewpoints , and to deal with architectural styles that span multiple viewpoints .",
    "other interesting scenarios are the replacement of an architectural style by another one on an existing architecture .",
    "another future research topic is the study of _ co - evolution _ between adls , architectural styles , their conforming architectures , and their implementation .",
    "changes to any of these entities may require changes to the others .",
    "we thus need to analyse this change impact and manage co - evolution while limiting the number of constraint violations .",
    "this becomes very challenging when multiple architectural styles co - exist that may interfere when applied to the same software architecture .",
    "in this article , we introduced architectural evolution patterns as a disciplined mechanism to introduce architectural styles to an architectural description .",
    "we provided a case study using the structural viewpoint and the client - server architectural style expressed in the adl . using graph transformation , we formally analysed evolution patterns by relying on the notions of critical pair analysis and rule sequence analysis .",
    "this allowed us to ensure that the evolution patterns we specified are well - formed and preserve the consistency constraints imposed by the adl and the architectural style .",
    "we implemented and practically validated our ideas by extending , the tool that accompanies the adl , with explicit and first class support for defining and applying evolution patterns and architectural styles ."
  ],
  "abstract_text": [
    "<S> software architectures are critical in the successful development and evolution of software - intensive systems . </S>",
    "<S> while formal and automated support for architectural descriptions has been widely addressed , their evolution is equally crucial , but significantly less well - understood and supported . in order to face a recurring evolution </S>",
    "<S> need , we introduce the concept of _ evolution pattern_. it formalises an architectural evolution through both a set of concepts and a reusable evolution process . </S>",
    "<S> we propose it through the recurring need of introducing an architectural style on existing software architectures . </S>",
    "<S> we formally describe and analyse the feasibility of architectural evolution patterns , and provide a practical validation by implementing them in , an eclipse plug - in for the architectural description language .    software evolution , reuse of evolution knowledge , pattern , software architecture , architectural style , graph transformation , architecture description language . </S>"
  ]
}