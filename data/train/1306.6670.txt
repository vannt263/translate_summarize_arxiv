{
  "article_text": [
    "the generally encountered use of ontologies consists in performing data inferences and validation using a semantic web compliant reasoner .",
    "the corresponding reasoning mechanism can be used to generate a set of queries executed over the appropriate data sets .",
    "for example , this approach was designed in a medical application @xcite where inferences on chemical molecules were needed to highlight contra indications , side effects of pharmaceutical products .",
    "as mentioned in @xcite , results of queries with both inference on property ( _ i.e. _ ` rdf : property ` ) and concept ( _ i.e. _ ` rdf : class ` ) hierarchies are required by the application as well as by data quality or data exchange external tools .    in regards to large ontologies",
    "( e.g. ` opengalen ` or ` snomed ` in the medical domain ) and data sets ( e.g. linked data ) , providing efficient performances to reasoning dependent queries is an important issue .",
    "we believe that to enable efficient response time to such queries , one has to give a special attention to the storage system associated to the triples .",
    "in fact , ` rdf ` is basically a data model and its recommendation does not guide to a preferred storage solution .",
    "the related work about ` rdf ` data management systems can be subdivided into two categories : the ones involving a mapping to a relational database management system ( rdbms ) and the ones that do not . in this paper , we do not focus on the latter one .",
    "a set of techniques have been proposed for storing ` rdf ` data in relational databases .",
    "several research groups think that this is likely the best performing approach for their persistent data store , since a great amount of work has been done on making relational systems efficient , extremely scalable and robust .",
    "efficient storage of ` rdf ` data has already been discussed in the literature with different physical organization techniques based on partitioning ( cf .",
    "figure [ phys_org ] ) .",
    "on one hand , there exists tools such as sesame @xcite , jena @xcite , oracle @xcite and 3store @xcite which rely on a straightforward mapping of ` rdf ` into an rdbms  called _ triple table _ approach .",
    "each ` rdf ` statement of the form @xmath0",
    "@xmath1 @xmath2 is stored as an entry of one large table with a three - columns schema ( _ i.e. _ a column for each the _ subject _ , _ predicate _ and _ object _ ) .",
    "indexes are then added for each of the columns in order to make joins less expensive . however , since the collection of triples are stored in one single table , the queries may be very slow to execute . indeed",
    "when the number of triples scales , the table may exceed memory size ( inducing costly disk - ram transfers )",
    ". nevertheless , simple _ statement - based _ queries can be satisfactorily processed by such systems , although they do not represent the most important way of querying ` rdf ` data . still , this storage system scales poorly since complex queries with multiple triple patterns require many self - joins over this single large table as pointed out in @xcite .",
    "whereas this specific approach does not use partitioning at all , on the other hand , some recent research highlighted two efficient main trends depending on the information one uses to guide the partitioning : guided by ( 1 ) the underlying ontology or ( 2 ) the data itself .",
    "intuitively , one would expect that a well suited data partitioning will induce a better response time to queries ( at least select ones ) .",
    "indeed , data partitioning will allow queries to be made on smaller sets of entries which , given an adapted ` rdf ` data clustering , should be faster",
    ". the counterpart of this storage system will be some possible worst performance for data updates .",
    "as a first step to an efficient ` rdf ` storage road map , we propose an intermediate ontology - guided approach ",
    "namely ` rostore `  which lies between the two extremes : triple and vertically partitioned tables .",
    "the aim of this approach is to try to analyse the efficiency of a compromise approach where less partitions are used .",
    "intuitively , such physical organization will take benefits of requiring less joins in practical queries and with less risk of unmappable table in memory .",
    "as already mentioned , we believe that there should not be a unique generic solution to ` rdf ` storage and that depending on the data itself , the underlying ontology , application queries , better performance may be obtained by considering alternative and several dedicated approaches .",
    "the major aim of ` rostore ` is to provide some clue of this belief .",
    "we will demonstrate that ` rostore ` is one of them and may , in specific cases , induce better efficiency . in this context , we consider ` rostore ` as * one among other * interesting physical organizations based on property hierarchy that should be present in the ` rdf ` storage road map .",
    "our storage approach derives from the vertically partitioned one and extends this last by putting back together into a single table data related to a _ top - property _ of a property hierarchy . given a hierarchy",
    ", we say that a _ predicate _ is a top - property if it is only an ` rdf : subpropertyof ` of itself . for each such top - property @xmath3",
    ", a three - columns table is created by ( 1 ) merging all the two - columns tables corresponding to _ predicates _ being ` rdf : subpropertyof ` @xmath4 and ( 2 ) adding a third column indicating from which _ predicate _ the entry _",
    "( subject , object ) _ was retrieved ( cf .",
    "figure [ storagecomp ] ) .",
    "let us first notice that , providing with this definition , any _ predicate _ that is not an ` rdf : subpropertyof ` of a top - property will still be stored in a two - columns table .",
    "this induces an insignificant expense of the space complexity of this novel approach .",
    "moreover , in case of a cyclic _ property _ hierarchy , all _ predicates _ are necessarily all semantically equivalent . hence selecting a single canonical _",
    "predicate _ and rewriting triples accordingly is sufficient . despite the fact that considering top - property seems to be the most natural , one may , depending on the topology of the hierarchy , define other physical organizations inducing better performance too for specific cases .",
    "our preliminiary results demonstrate that an evolutive physical organizations guided by the queries may be efficient .",
    "the main impact of merging some tables is obtaining better performance of queries requiring joins over _ predicates _ belonging to the same  sub - hierarchy  of the property hierarchy .",
    "this is typically the case when one wants to retrieve all the information concerning a family of _ predicates _ of the property hierarchy ; since they will be quite related . in the following",
    ", we will denote by ` vpstore ` ( resp . `",
    "rostore ` ) the vertically partitioned ( resp",
    ". our ) approach .",
    "* example 1 : * let us consider a small data set ( figure [ storagecomp]b ) defined over a given property hierarchy ( figure [ storagecomp]a ) . with ` vpstore ` , the triples would be distributed over six different tables as displayed in figure [ storagecomp]c .",
    "comparatively , in ` rostore ` , one obtains only two different tables ( figure [ storagecomp]d ) : a single relation named after the top - property ` pa ` and a relation named after the property ` pf ` .",
    "\\(a ) property hierarchy : pf    \\(b ) rdf triples +    [ cols=\"^,^,^\",options=\"header \" , ]     the ` rdf ` data sets are later translated into the different physical organization models we would like to evaluate .",
    "they are decomposed into the two main approaches ` vpstore ` and ` rostore ` . in order to emphasize the efficiency of our solution on queries needing reasoning",
    ", we had to test these settings in a context similar to @xcite .",
    "more precisely , we evaluated each approach on a row store and a column store rdbms .",
    "this yields the four following approaches : ` vpstore ` resp . on a row ( * vprstore * ) and column ( * vpcstore * ) store and ` rostore ` resp . on a row ( * rorstore * ) and column ( * rocstore * ) store .",
    "hence a total of sixteen databases are generated ( each data set is implemented on each physical approach ) .",
    "we have selected postgresql and monetdb as the rdbms resp . for the row - oriented and the column - oriented databases .",
    "we retained monetdb instead of c - store ( the column store used for evaluation in @xcite ) essentially due to ( 1 ) the lack of maintenance of the latter one , ( 2 ) the open - source licence of monetdb and ( 3 ) the fact that monetdb is considered state of the art in column - oriented databases .",
    "the tests were run on monetdb server version 5 and postgresql version 8.3.1 .",
    "the benchmarking system is an intel pentium 4 ( 2.8 ghz ) operated by a linux ubuntu 9.10 , with 512 mbytes of memory , 1 mb l2 cache and one disk of 60 gbyte spinning at 7200rpm .",
    "the disk can read cold data at a rate of approximatively 55mb / sec .",
    "for the ` vprstore ` , there is a clustered b+ tree index on the _ subject _ and an unclustered b+ tree on the _",
    "object_. similarly , for the ` rorstore ` , a clustered b+ tree index is created on the _ property _ column and unclustered b+ trees on the _ subject _ and _ object_. as noted in @xcite , monetdb does not include user defined indices .",
    "hence , we relied on the ordering of the data on _ property _ , _ subject _ and _ object _ values .",
    "more precisely , any two columns table of ` rocstore ` and ` vpcstore ` is ordered on _ subject _ and _ object _ ; while any three columns table ( of ` rocstore ` ) is ordered on _ property _ , _ subject _ and _",
    "object_.    our evaluation contains fifteen queries out of which eleven are coming from the lubm benchmark and four tackling the lubm ontology to evaluate some particular aspects of ` rostore ` . an interesting aspect using lubm benchmark queries",
    "is that do not aim to emphasize on the performances of a given storage model .",
    "moreover , these queries tackle a wide range of possibilities on volume of input ( number of tuples retrieved ) and selectivity rate ( _ i.e. _ number of conditions in the ` where ` clause of a query ) . among the eleven evaluated queries ,",
    "three do not require any form of reasoning ( # 1 , # 2 and # 14 ) and the eight remaining queries can be divided in two groups whether they are involving reasoning on the concept hierarchy ( # 3,#4,#6,#7,#9,#10 ) or both concept / property hierarchies ( # 5,#8 ) .",
    "we now present the purpose of each of these queries :    * q1 : * retrieves instances of the ` graduatestudent ` class who have taken the course ` http://www.department0.university0.edu/graduatecourse0 ` .    * q2 : * retrieves three instances of respectively the ` graduatestudent ` , ` university ` and ` department ` concepts for those students that are member of a department , this department is a sub - organization of a university and this student has an undergraduate degree from this university .",
    "* q3 : * selects all kinds of publications which have been authored by a given assistant professor .",
    "* q4 : * retrieves all kinds of professors , their name , email address and telephone number for those professors working for a given department .    * q5 : * the result contains instances of the ` person ` concept hierarchy for those persons that are related to a given department by either the ` memberof ` , ` workingfor ` or ` headof ` properties .",
    "* q6 : * displays uris of instances of the ` student ` concept hierarchy .",
    "* q7 : * retrieves instances of all kind of students and all kinds of courses for courses that are related by the ` takescourse ` property for those courses that are taught by a given professor .",
    "* q8 : * displays instances of all kinds of students with their email addresses and department instances of a given university these students are member of .",
    "* q9 : * the retrieved dataset contains instances of the ` student ` , ` faculty ` and ` course ` concept hierarchies for those students that are advised by faculties , have taken some courses taught by those faculties .",
    "* q10 : * selects instances of all the ` student ` class hierarchy who have taken a given course .",
    "* q14 : * selects all undergraduate students .",
    "we have introduced * q15 * to emphasize ` rostore ` performances when values are needed for a property hierarchy .",
    "in fact , it retrieves all _ subjects _ involved in triples where the _ predicate _ is one of the properties of the ` memberof ` property hierarchy , i.e. ` memberof ` , ` headof ` and ` worksfor ` .",
    "this query is similar to q5 but does not refer to any concepts .    finally , the following three queries aim to highlight the efficiency of our sqr approach .",
    "* q16 : * selects the _ subject _ and _ object _ in triples where the _ predicate _ is ` teacherof ` and _ subject _ is of ` rdf : type ` administrativestaff .",
    "this query returns an empty answer set since the ` rdfs : domain ` of ` teacherof ` is the ` faculty ` concept which is disjoint with ` administrativestaff ` . in the next section ,",
    "we confront the performances of this query to the simple detection of unsatisfiability of our sqr solution .",
    "* q17 : * selects the _ subject _ and the _ object _ in triples where the _ predicate _ is ` teacherof ` and _ subject _ is of ` rdf : type ` ` faculty ` .",
    "this query requires a join .",
    "* q18 : * has the same purpose as q17 but exploits one of our rewriting rules to improve its performances .",
    "in fact , the join in q17 is not necessary if one knows that the ` rdfs : domain ` of ` teacherof ` is the concept ` faculty ` .    in the experiments , we will store the lubm ontology in main - memory and perform reasoning using the jena framework .",
    "we provide more details concerning the experimental settings and results on the following web site : + ` http://sites.google.com/site/wwwrostore ` .",
    "the results presented in this section correspond to the average of 5 hot runs ( i.e. repeated runs of the same query without stopping the dbms ) of real time ( i.e. execution time of a query defined as the wall clock passed between the server receiving the query and before returning the results to the client ) executions .",
    "all performance times , except for query q16 and q17 , include the time needed to perform the inferences . finally , in order to highlight the differences in terms of performances between the various approaches , we either present the results in bar or line diagrams",
    ".    * analysis of q1 . *",
    "not surprisingly , column stores outperform row stores .",
    "indeed , the results will only contain a unique column which will clearly benefit column store advantage .",
    "moreover , since the query does not involve sub - properties , the performances of ` vpstore ` and ` rostore ` are quite similar .",
    "* analysis of q2 . *",
    "this time , the row stores are more efficient than the column ones .",
    "the results require , in this case , to retrieve two columns of three tables , hence in a row store both columns will be transfered from the hard drive to main memory in a single step while two transfers will be needed for column stores",
    ". moreover , two out of these three tables corresponds to _ predicates _ being part of a group of related predicates in the property hierarchies , namely ` memberof ` and ` undergraduatedegreefrom ` . since we voluntarily decided to perform no inferences on these two _ _ predicates _ _ ( _ i.e. _ not including sub - properties in the query ) , it is not surprising that ` vpstore ` outperforms ` rostore ` since each _ predicate _ corresponds in the ` vpstore ` to a table .",
    "* analysis of q3 . *",
    "despite the fact that this query has a similar structure as q1 ( _ i.e. _ only two triples are present in the ` where ` clause ) , it requires to retrieve all concepts of a wide hierarchy . due to the ordered organization of tuples , column stores outperform row ones which rely on indices and on a less effective i / o transfers . in a similar manner to q1 , the difference between ` vpstore ` and ` rostore ` is not significant .",
    "* analysis of q4 .",
    "* once again , in this query , we do not use inference on the ` worksfor ` _ predicate _ to include results on sub - properties of this last .",
    "this is motivated by the will to emphasize on the weaknesses of the ` rostore ` approach . as expected , ` vpstore ` is , in this context , outperforming ` rostore ` .",
    "in fact , even ` vprstore ` is outperforming ` rocstore ` ; which can be induced by the high selectivity nature of the query ( four attributes in result set ) .",
    "* analysis of q5 . * due to the exploitation of the sub - properties of the _ predicate _ ` memberof ` in this query , it is not surprising that ` rostore ` outperforms ` vpstore ` . indeed in ` vpstore ` , the results of the query comes from the union of three distinct queries ( one for each _ predicates _ involved ) while ` rostore ` only requires a single query .    * analysis of q6 .",
    "* this query retrieves the subjects from a two columns table ( i.e. type ) . because the column stores primarily order these relations on the subject , they are more efficient than their row store counterparts .",
    "this is due to better i / o efficiency . similarly to q3 , the ` rostore ` approach outperforms ` vpstore ` .    *",
    "analysis of q7 .",
    "* again query processes in ` rostore ` ( resp . column store ) is more efficient than ` vpstore ` ( resp . row store ) .",
    "the reasons are similar to the ones for q3 .",
    "* analysis of q8 . * the analysis of the results for this query confirm the ones of q5 .",
    "* analysis of q9 .",
    "* this query does not require inferences on property hierarchies but some on several concept ones . as seen previously , in this situation column stores",
    "is more efficient than row stores . on column stores , ` vpstore ` and ` rostore ` have close performance results , with ` rostore ` slighty better than ` vpstore ` .",
    "* analysis of q10 .",
    "* the results are similar to q9 .",
    "* analysis of q14 .",
    "* this query has large input and low selectivity with no inferences . as expected , ` rocstore ` is faster than ` vpcstore ` which is more efficient than ` rorstore ` ; the less effective being ` vprstore ` .",
    "note that this is due to distinguished variable being placed at the _ subject _ position of the only triple of the ` where ` clause . a similar query pattern with the distinguished variable mapped to the _ object _ position of a triple would emphasize the superiority of the ` vpstore ` approach .",
    "* analysis of q15 .",
    "* this query clearly demonstrates the efficiency of ` rostore ` over ` vpstore ` .",
    "even the row oriented ` rostore ` outperforms the column oriented ` vpstore ` .",
    "this is due to the presence of ` union sql ` operators in the queries executed on the ` vpstore ` while ` rostore ` only requires a complete scan of the tuples of one table .",
    "* analysis of q16 , q17 and q18 . *",
    "finally , queries q16 , q17 and q18 emphasize the importance of reasoning over the ontology before executing queries over any of the store solutions .",
    "figure [ q16 ] displays the duration times for all databases , ranging from approximately 42ms ( column store with 1 university ) to 1450ms ( row store with 10 universities ) .",
    "this can be considered rather long to propose an empty answer set since , according to the ontology , the query is incoherent .",
    "comparatively , the ` propertycheck ` method we have implemented needs an average time of 1ms to reply that the query is coherent or not .",
    "hence , a system implemented on top of an ` owl ` compliant reasoner is able to determine almost instantly if the answer set is empty .    moreover",
    ", it could also provide some explanations concerning the inconsistency of the query .",
    "we believe that such optimization are quite useful especially when end - users are not confident with all the details of a given ontology .",
    "the performance results of q17 and q18 are provided together in figure [ q17q18 ] in order to highlight their comparisons .",
    "the purpose of q17 and q18 is to emphasize the importance of analyzing _ predicate _ ` rdfs : domain ` and ` rdfs : range ` in a property table approach .",
    "the execution of q17 does not perform any optimization while q18 checks that the concept ` faculty ` is the ` rdfs : domain ` of the ` teacherof ` _ predicate _ and hence a join to the ` rdf : type ` relation is not necessary .",
    "* summary : * several conclusions can be drawn from our evaluation .",
    "considering the adoption of a database solution , we confirm the evaluations of @xcite and @xcite stating that column stores outperform row stores for ` rdf ` triple storage .",
    "the only exception in our experiments consists in q2 which is rather due to the partitioning approach .    concerning the partitioning approach , all our intuitions",
    "were confirmed by this evaluation .",
    "that is ` rostore ` outperforms ` vpstore ` whenever queries retrieve information from triples where properties belong a given property hierarchy ( e.g. q5 and q15 ) . on the contrary , ` vpstore ` is more efficient than ` rostore ` where only a subset of the properties of a property hierarchy are necessary to reply to a query ( e.g. q2 ) .",
    "this result was expected since the ` rostore ` approach then requires to add additional conditions on the properties one wants to retrieve from a top property relation .",
    "finally , the sqr approach seems to be quite useful since it does not slow down the processing of satisfiable queries and enables to detect unsatisfiable queries efficiently ( e.g. q17 and q18 ) .",
    "anyhow , we consider that more evaluations need to be conducted on larger ontologies to confirm these results .",
    "the first contribution of this paper is to show that depending on the type of applications and queries asked to the rdf triple stores , different partitioning approaches can be considered . between the two extremes of triple and vertical partitioning",
    ", we introduced the ` rostore ` approach which is particularly advantageous for a certain class of queries , _",
    "i.e. _ those relying on deep property hierarchies ( e.g. the opengalen ontology contains a property hierarchy of depth 6 ) . moreover , this novel approach is a simple extension to the existing rdf column store work and can thus be easily adopted by other rdf stores .",
    "a second contribution of this work is to propose a semantic query rewritting solution that can be adopted by most of the rdf triples we have presented in this paper ( triples tables , vertical partitioning , ` rostore ` , property - class tables ) .",
    "this approach seems promising since it can be quite useful to detect unsatisfiable queries and optimizing other queries by analyzing property domains and ranges .",
    "our list of future works is large since we consider that several investigations need to be performed to complete the road map on efficient and persistent rdf triple storage .",
    "the first directions we would like to follow are ontology schema evolution in ` rostore ` ( e.g. a new property hierarchy emerges or is removed from the ontology ) and the consideration of concept hierarchies at the storage and querying levels .",
    "j.  broekstra , a.  kampman , and f.  v. harmelen .",
    "sesame : a generic architecture for storing and querying rdf and rdf schema . in _ proceedings of the first international semantic web conference on the semantic web",
    "_ , iswc 02 , pages 5468 , london , uk , uk , 2002 .",
    "springer - verlag .",
    "e.  i. chong , s.  das , g.  eadon , and j.  srinivasan . an efficient sql - based rdf querying scheme . in _ proceedings of the 31st international conference on very large data bases",
    "_ , vldb 05 , pages 12161227 .",
    "vldb endowment , 2005 .",
    "o.  cur .",
    "semi - automatic data migration in a self - medication knowledge - based system . in _ proceedings of the third biennial conference on professional knowledge management _ , wm05 , pages 373383 , berlin , heidelberg , 2005 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> the vision of the semantic web is becoming a reality with billions of ` rdf ` triples being distributed over multiple queryable endpoints ( e.g. linked data ) . </S>",
    "<S> although there has been a body of work on ` rdf ` triples persistent storage , it seems that , considering reasoning dependent queries , the problem of providing an efficient , in terms of performance , scalability and data redundancy , partitioning of the data is still open . in regards to recent data partitioning studies </S>",
    "<S> , it seems reasonable to think that data partitioning should be guided considering several directions ( e.g. ontology , data , application queries ) . </S>",
    "<S> this paper proposes several contributions : describe an overview of what a roadmap for data partitioning for ` rdf ` data efficient and persistent storage should contain , present some preliminary results and analysis on the particular case of ontology - guided ( property hierarchy ) partitioning and finally introduce a set of semantic query rewriting rules to support querying ` rdf ` data needing ` owl ` inferences . </S>"
  ]
}