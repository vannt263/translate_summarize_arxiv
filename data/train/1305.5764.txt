{
  "article_text": [
    "large scale data storage systems that are employed in social networks , video streaming websites and cloud storage are becoming increasingly popular . in these systems the integrity of the stored data and the speed of the data access needs to be maintained even in the presence of unreliable storage nodes . this issue is typically handled by introducing redundancy in the storage system , through the usage of replication and/or erasure coding .",
    "however , the large scale , distributed nature of the systems under consideration introduces another issue .",
    "namely , if a given storage node fails , it need to be regenerated so that the new system continues to have the properties of the original system .",
    "it is of course desirable to perform this regeneration in a distributed manner and optimize performance metrics associated with the regeneration process .    in recent years",
    ", regenerating codes have been the subject of much investigation ( see @xcite and its references ) .",
    "the principal idea of regenerating codes is to use subpacketization @xcite . in particular",
    ", one treats a given physical block as consisting of multiple packets ( unlike the mds code that stores exactly one packet in each node ) .",
    "coding is now performed across the packets such that the file can be recovered by contacting a certain minimum number of nodes . in addition",
    ", one can regenerate a failed node by downloading appropriately coded data from the surviving nodes . a distributed storage system ( henceforth abbreviated to dss )",
    "consists of @xmath0 storage nodes , each of which stores @xmath1 packets . in our discussion",
    ", we will treat these packets as elements from a finite field .",
    "thus , we will equivalently say that each storage node contains @xmath1 symbols ( we use symbols and packets interchangeably throughout our discussion ) .",
    "a given user , also referred to as the data collector needs to have the ability to reconstruct the stored file by contacting any @xmath2 nodes ; this is referred to as the maximum distance separability ( mds ) property of the system .",
    "suppose that a given node fails .",
    "the dss needs to be repaired by introducing a new node .",
    "this node should be able to contact any @xmath3 surviving nodes and download @xmath4 packets from each of them for a total repair bandwidth of @xmath5 packets .",
    "thus , the system has a repair degree of @xmath6 , normalized repair bandwidth @xmath4 and total repair bandwidth @xmath7 .",
    "the new dss should continue to have the mds property .",
    "a large body of prior work ( see for instance @xcite for a representative set ) has considered constructions for functional and exact repair at both the minimum bandwidth regenerating ( mbr ) point where the repair bandwidth @xmath7 is minimum and the minimum storage regenerating ( msr ) point where the storage capacity @xmath1 is minimum .    however , repair bandwidth is not the only metric for evaluating the repair process .",
    "it has been observed that the number of nodes that the new node needs to contact for the purposes of repair is also an important metric that needs to be considered . for either functional or exact repair ( discussed above )",
    "the repair degree @xmath6 needs to be at least @xmath2 .",
    "the notion of local repair introduced by @xcite , considers the design of dss where the repair degree is strictly smaller than @xmath2 .",
    "this is reasonable since contacting @xmath2 nodes allows the new node to reconstruct the entire file , assuming that the amount of data downloaded does not matter .",
    "much of the existing work in this broad area considers _ coded _ repair where the surviving nodes and the new node need to compute linear combinations for regeneration .",
    "it is well recognized that the read / write bandwidth of machines is comparable to the network bandwidth @xcite .",
    "thus , this process induces additional undesirable delays @xcite in the repair process",
    ". the process can also be potentially memory intensive since the packets comprising the file are often very large ( of the order of gb ) . in this work we consider the design of dss that can be repaired in a local manner by simply downloading packets from the surviving nodes , i.e. , dss that have the exact and uncoded repair property .",
    "the problem of local repair was first considered in references @xcite .",
    "tradeoffs between locality and minimum distance , and corresponding code constructions were proposed in @xcite for the case of scalar codes ( @xmath8 ) and extended to the case of vector codes ( @xmath9 ) in @xcite .",
    "the design of dss that have exact and uncoded repair and operate at the mbr point was first considered in the work of @xcite and further constructions appeared in @xcite .",
    "codes for these systems are a concatenation of an outer mds code and an inner fractional repetition code that specifies the placement of the encoded symbols on the storage nodes . in this work",
    "we consider the design of such codes that allow for local repair in the presence of one of more failures .",
    "the work of @xcite , considers vector codes that allow local recovery in the presence of more than one failure . in their setting each storage node participates in a local code that has minimum distance greater than two .",
    "they present minimum distance bounds and corresponding code constructions that meet these bounds .",
    "the work of @xcite on the design of mbr repair - by - transfer codes is most closely related to our work . however , as we shall see our constructions in section [ sec : code_cons_bounds ] are quite different from those that appear in @xcite and allow for a larger range of code parameters .",
    "moreover , as we focus on fractional repetition codes , our minimum distance bound is much tighter than the general case treated in @xcite .",
    "the dss is specified by parameters @xmath10 where @xmath0 - number of storage nodes , @xmath2 - number of nodes to be contacted for recovering the entire file and @xmath11 is the local repair degree , i.e. , the number of nodes that an incoming node connects to for regenerating a failed node .",
    "the repair is performed by simply downloading packets from the existing nodes and is symmetric , i.e , the same number of packets are downloaded from each surviving node that is contacted .",
    "it follows that we download @xmath12 packets from the surviving nodes . the proposed architecture for the system consists of an outer mds code followed by an inner fractional repetition code .",
    "specifically , let the file that needs to be stored consist of @xmath13 symbols @xmath14 .",
    "suppose that these symbols are encoded using a @xmath15-mds code to obtain encoded symbols @xmath16 .",
    "the symbols @xmath16 are placed on the @xmath0 storage nodes , such that each symbol appears exactly @xmath17 times in the dss .",
    "an example is illustrated in fig .",
    "[ dss-(15,4,4,2 ) ] .",
    "a node can be repaired locally by contacting the other two nodes in the same column .",
    "the system is resilient upto @xmath18 node failures . on the other hand ,",
    "local fr codes are resilient only a single node failure .",
    "hence @xmath19 and @xmath20 .",
    "moreover , contacting any four nodes recovers at least @xmath21 distinct symbols so that the file size is @xmath22 .",
    "therefore , the minimum distance of the code is @xmath23 for the filesize @xmath24 .",
    ", title=\"fig : \" ]    let @xmath25 = \\{1 , 2 , \\dots , \\theta \\}$ ] and @xmath26 be subsets of @xmath27 .",
    "let @xmath28 and consider @xmath29 with @xmath30 .",
    "we say that @xmath31 is @xmath4-recoverable from @xmath32 if there exists @xmath33 for each @xmath34 such that @xmath35 and @xmath36 .",
    "[ defn : fr_code ] a fractional repetition ( fr ) code @xmath37 for a @xmath38 dss with repetition degree @xmath17 and normalized repair bandwidth @xmath39 ( @xmath1 and @xmath4 are positive integers ) is a set of @xmath0 subsets @xmath40 of a symbol set @xmath25 $ ] with the following properties .    *",
    "the cardinality of each @xmath41 is @xmath1 . *",
    "each element of @xmath27 belongs to @xmath17 sets in @xmath32 .",
    "* let @xmath42 denote any @xmath43 sized subset of @xmath32 and @xmath44 .",
    "each @xmath45 is @xmath4-recoverable from some @xmath6-sized subset of @xmath42 .",
    "note that we only consider fr codes without repeated storage nodes to avoid trivialities .",
    "it can be observed that @xmath46 is a measure of the resilience of the system to node failures , while still allowing exact and uncoded repair .",
    "we define the code rate of the system as @xmath47 . for a fr code",
    "we define @xmath48 , where @xmath49 is the set of all @xmath50-sized subsets of @xmath32 , i.e. , @xmath51 is the minimum number of symbols accumulated when union of @xmath50 storage nodes from @xmath32 is considered .",
    "we say that nodes @xmath52 cover at least @xmath53 symbols if @xmath54 .",
    "a fr code is in one - to - one correspondence with a 0 - 1 matrix of dimension @xmath55 ( called the incidence matrix ) , where the @xmath56-th entry of the matrix is 1 if the @xmath57-th storage node contains the @xmath58-th symbol .",
    "note that in an fr code we do not have any restriction on the repair degree @xmath6 .",
    "_ locally recoverable fractional repetition code .",
    "_ let @xmath59 be a fr code for a @xmath38 dss , with repetition degree @xmath17 and normalized repair bandwidth @xmath60 .",
    "let @xmath61 denote the local repair degree where @xmath11 and @xmath62 .",
    "a node @xmath41 of @xmath63 is said to be locally recoverable if there exists a set @xmath64 such that @xmath65 and @xmath41 is @xmath66-recoverable from @xmath67 .",
    "we call @xmath68 the local structure associated with node @xmath41 .",
    "the fr code @xmath63 is locally recoverable if all nodes in @xmath32 belong to at least one local structure .",
    "let @xmath69 denote the maximum number of node failures such that each failed node has at least one local structure in the set of surviving nodes .",
    "we call @xmath69 the local failure resilience of the dss .",
    "we note that it is possible that the local structures themselves are fr codes ; in this case we call them local fr codes",
    ".    _ minimum distance . _",
    "the minimum distance of a dss denoted @xmath70 is defined to be the size of the smallest subset of storage whose failure guarantees that the file is not recoverable from the surviving nodes .",
    "it is evident that @xmath71 . in our constructions in section",
    "[ sec : code_cons_bounds ] , we will evaluate the different code designs on these parameters .",
    "bounds on the minimum distance of locally recoverable codes have been investigated in prior work .",
    "specifically , @xcite considers the case of scalar ( @xmath72 ) storage nodes and @xcite considers vector ( @xmath9 ) storage nodes .",
    "[ local bound ] consider a locally recoverable dss with parameters @xmath73 with file size @xmath13 with minimum distance @xmath70 .",
    "then , @xmath74    note that if a code is optimal with respect to lemma @xmath75 , then the file can be recovered from @xmath76 node erasures .",
    "this implies that @xmath77 .",
    "therefore , a code is equivalently optimal if @xmath78 and every set of @xmath2 nodes can reconstruct the file .",
    "the minimum distance bound was tightened by @xcite when each storage node participates in a local code with minimum distance at least two ; this allows for local recovery when there is more than one failure .",
    "however , for the class of codes that we consider , our bound ( see section [ sec : code_cons_bounds ] ) is tighter .",
    "in this section , we present several code constructions and a minimum distance bound for a specific system architecture where the local structures are also fr codes .",
    "our first construction is a class of codes which is optimal with respect to the bound provided in lemma [ local bound ] and allow local recovery in the presence of a single failure .",
    "our construction leverages the properties of graphs with large girth .",
    "an undirected graph @xmath80 is called an @xmath81-graph if each vertex has degree @xmath82 , and the length of the shortest cycle in @xmath80 is @xmath83 .",
    "[ grcons1 ] let @xmath84 be a @xmath81-graph with @xmath85 .",
    "* arbitrarily index the edges of @xmath80 from 1 to @xmath86 . *",
    "each vertex of @xmath80 corresponds to a storage node and stores the symbols incident on it .",
    "it can be observed that the above procedure yields an fr code @xmath59 with @xmath0 storage nodes , parameters @xmath87 , @xmath88 and @xmath89 . upon single failure ,",
    "the failed node can be regenerated by downloading one symbol each from the storage nodes corresponding to the vertices adjacent to it in @xmath80 ( i.e. , @xmath90 ) ; thus , @xmath91 .",
    "we note that the work of @xcite also used the above construction for mbr codes where the file size was guaranteed to be at least @xmath92 ; however , they did not have the restriction that @xmath80 is a @xmath81-graph . as we discuss next , @xmath81-graphs",
    "allow us to construct locally recoverable codes and provide a better bound on the file size when @xmath93 .",
    "we allow the system parameter @xmath2 to be greater than @xmath6 , however in the work of @xcite , they consider only the case @xmath94 .",
    "[ lemma : grcons1_coverage ] let @xmath59 be a fr code constructed by construction [ grcons1 ] .",
    "if @xmath95 , and @xmath93 , we have @xmath96 for any @xmath97    let @xmath98 and @xmath99 be any @xmath2 nodes in our dss , where @xmath93 .",
    "we argue inductively .",
    "note that @xmath100 .",
    "suppose that @xmath101 for @xmath102 , where @xmath103 is the number of connected components formed by the nodes @xmath104 in @xmath80 .",
    "now consider @xmath105 where @xmath106 .",
    "note that since @xmath107 there can be no cycle in @xmath108 .",
    "thus , @xmath109 is connected at most once to each connected component in @xmath110 .",
    "suppose that @xmath109 is connected to @xmath111 existing connected components in @xmath110 , where @xmath112 .",
    "then , the number of connected components in @xmath108 is @xmath113 and the number of new symbols that it introduces is @xmath114 .",
    "therefore @xmath115 .",
    "this proves the induction step .",
    "thus , @xmath116 , where @xmath117 is the number of connected components formed by @xmath118 . now consider @xmath119 .",
    "note that there can be a cycle introduced at this step if @xmath120 .",
    "now , if @xmath121 , it can be seen that @xmath122 can only connect to each of the @xmath117 connected components once , otherwise it would imply the existence of a cycle of length strictly less than @xmath83 in @xmath80 .",
    "thus , in this case @xmath123 . on the other hand",
    "if @xmath124 , then @xmath122 can connect at most twice to this connected component . in this case again we can observe that @xmath123 .",
    "let @xmath125 be a @xmath81-graph with @xmath126 and @xmath127 . if @xmath128 such that @xmath129 , then @xmath63 obtained from @xmath80 by construction [ grcons1 ] is optimal with respect to bound in lemma [ local bound ] when the file size @xmath130 .    from lemma [ lemma : grcons1_coverage ] ,",
    "any @xmath2 nodes cover at least @xmath131 symbols .",
    "thus , the code is optimal when the following holds .",
    "@xmath132 we have @xmath133 since , @xmath134 the following holds .",
    "@xmath135 and @xmath136    [ corollary_constr_1 ] let @xmath125 be a @xmath81-graph with @xmath126 and @xmath127 . if @xmath137 , then @xmath63 obtained from @xmath80 by construction [ grcons1 ] is optimal with respect to the bound in lemma [ local bound ] for file size @xmath138 .    it can be observed that in the specific case of @xmath139 , applying construction [ grcons1 ] results in a dss where the union of any @xmath2 nodes has at least @xmath140 symbols .",
    "we now discuss some examples of codes that can be obtained from our constructions .",
    "sachs @xcite provided a construction which shows that for all @xmath141 , there exists a @xmath82-regular graph of girth @xmath83 . also , explicit constructions of graphs with arbitrarily large girth are known @xcite . using these",
    "we can construct infinite families of optimal locally recoverable codes .",
    "the petersen graph on 10 vertices and 15 edges can be shown to be @xmath142-graph .",
    "we label the edges @xmath143 and @xmath144 in fig .",
    "[ ptrgraph ] .",
    "let the filesize @xmath145 ; we use a @xmath146 outer mds code . applying construction [ grcons1 ]",
    ", we obtain a dss with parameters @xmath147 . from corollary [ corollary_constr_1 ]",
    ", we observe that the dss meets the minimum distance bound .",
    "each vertex acts as a storage node and stores the symbols incident on it.,title=\"fig : \" ]    an @xmath81-graph with the fewest possible number of vertices , among all @xmath81-graphs is called an @xmath81-cage and will result in the maximum code rate for our construction .",
    "for instance , the @xmath142-cage is the petersen graph .",
    "we note here that bipartite cages of girth 6 were used to construct fr codes in @xcite though these were not in the context of locally recoverable codes .",
    "it can be seen that construction [ grcons1 ] can be extended in a straightforward way to larger filesizes .",
    "our second class of codes are such that the local structures are also fr codes .",
    "the primary motivation for considering this class of codes is that they naturally allow for local recovery in the presence of more than one failure as long as the local fr code has a repetition degree greater than two .",
    "thus , in these codes , each storage node participates in one or more local fr codes that allow local recovery in the presence of failures . for these classes of codes",
    ", we can derive the following tighter upper bound on the minimum distance ( the proof appears in the appendix ) when the file size is larger than the number of symbols in one local structure .",
    "[ minimum distance ] let @xmath63 be a locally recoverable fr code with parameters @xmath149 where each node belongs to a local fr code with parameters @xmath150 .",
    "suppose that the file size @xmath151 .",
    "then , @xmath152    the following corollary can be also be established ( see appendix ) .",
    "[ mincor ] let @xmath63 be a locally recoverable fr code with parameters @xmath149 where each node belongs to a local fr code with parameters @xmath150 . furthermore",
    ", suppose that @xmath63 can be partitioned as the union of @xmath111 disjoint local fr codes .",
    "if the file size @xmath153 for some integer @xmath154 and @xmath155 , we have @xmath156    [ design ] let @xmath59 be a fr code with parameters @xmath149 such that any @xmath157 + 1 nodes in @xmath32 cover @xmath158 symbols and for @xmath159 , we have @xmath160 when @xmath161 . we construct a locally recoverable fr code @xmath162 by considering the disjoint union of @xmath163 copies of @xmath63 .",
    "thus , @xmath162 has parameters @xmath164 .",
    "we call @xmath63 the local fr code of @xmath162 .",
    "[ lemma : cond_kron_opt ] let @xmath165 be a code constructed by construction [ design ] for some @xmath166 such that the parameters of the local fr code satisfy @xmath167 .",
    "let the file size be @xmath168 for some @xmath169 .",
    "then @xmath162 is optimal with respect to corollary [ mincor ] .",
    "it is evident that @xmath162 is the disjoint union of @xmath170 local fr codes .",
    "thus , the minimum distance bound here is @xmath171 the code is optimal when any @xmath172 nodes in @xmath162 cover at least @xmath168 symbols .",
    "we show that this is the case below .",
    "let @xmath173 be the number of nodes that are chosen from the @xmath57-th local fr code and @xmath174 be the symbols covered by these @xmath173 nodes .",
    "note that for any @xmath175 if @xmath176 , then @xmath177 ( the maximum possible ) .",
    "suppose there are @xmath178 local fr codes that cover @xmath158 symbols .",
    "it can be seen that in this case it suffices to show that @xmath179 nodes cover at least @xmath180 symbols . here",
    "we can omit case of @xmath181 , since our claim clearly holds in this situation .",
    "suppose that these nodes belong to @xmath82 local fr codes , where @xmath182 . by applying corradi s lemma",
    "@xcite we obtain @xmath183 this implies that @xmath184    the above lemma can be used to generate several examples of locally recoverable codes with @xmath185 .",
    "we discuss two examples below .",
    "[ affine resolvable ] in our previous work @xcite we used affine resolvable designs for the construction of fr codes that operate at the mbr point . let @xmath186 be a prime power .",
    "these codes have parameters @xmath187 and @xmath188 .",
    "moreover the code is resolvable , i.e. , we can vary the repetition degree by choosing an appropriate number of parallel classes .",
    "suppose we choose the local fr code by including @xmath189 parallel classes .",
    "thus , the parameters of the local fr code are @xmath190 . for this code",
    "it can be shown that @xmath191 and that @xmath192 .",
    "it can be observed that this local fr code satisfies the conditions of lemma [ lemma : cond_kron_opt ] when @xmath193 .",
    "we construct a locally recoverable fr code @xmath162 by taking the disjoint union of @xmath166 of the above local fr codes .",
    "thus , @xmath162 has parameters @xmath194 .",
    "it can be seen that the code allows for local recovery in the presence of at most @xmath195 failures , i.e. , @xmath196 . let the file size be @xmath197 for some @xmath198 .",
    "then @xmath165 is optimal with respect to corollary [ mincor ] .",
    "[ projective plane ] a projective plane of order @xmath186 also forms a fr code @xmath59 , where @xmath199 and @xmath200 .",
    "furthermore , @xmath201 if @xmath161 and each pair of symbols appears in exactly one node ; this further implies that @xmath202 .",
    "a simple counting argument shows that @xmath203 and @xmath204 .",
    "it can be shown that @xmath63 satisfies the conditions of lemma [ lemma : cond_kron_opt ] with @xmath205 since any @xmath206 nodes cover @xmath207 symbols .",
    "we construct a locally recoverable fr code @xmath162 by taking @xmath166 copies of the code @xmath63 . so the code @xmath162 has parameters @xmath208 .",
    "let the file size be @xmath209 for some @xmath198 .",
    "then , @xmath162 is optimal with respect to lemma [ minimum distance ] and has @xmath210 .",
    "an example is illustrated in fig .",
    "[ fano ] .",
    "it is worth noting that one can also obtain codes using the technique presented above by choosing the local fr code from several other structures including complete graphs and cycle graphs . owing to space limitations",
    ", we can not discuss all these examples here .",
    "[ t ]   and each local fr code ( the rows in the figure ) is a projective plane of order @xmath211 which is also known as a fano plane . here",
    "any set of @xmath213 nodes cover at least @xmath214 symbols .",
    "thus , the minimum distance of the code is @xmath215 for the filesize @xmath214.,title=\"fig : \" ]    10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    a.  dimakis , k.  ramchandran , y.  wu , and c.  suh , `` a survey on network codes for distributed storage , '' _ proceedings of the ieee _",
    "99 , no .  3 , pp . 476 489 , 2011 .",
    "a.  dimakis , p.  godfrey , y.  wu , m.  wainwright , and k.  ramchandran , `` network coding for distributed storage systems , '' _ ieee trans . on info .",
    "_ , vol .",
    "56 , no .  9 , pp . 4539 4551 , sept .",
    "k.  rashmi , n.  shah , p.  kumar , and k.  ramchandran , `` explicit construction of optimal exact regenerating codes for distributed storage , '' in _",
    "47th annual allerton conference on communication , control , and computing _ , 2009 , pp .",
    "1243 1249 .    c.  suh and k.  ramchandran , `` exact - repair mds code construction using interference alignment , '' _ ieee trans . on info .",
    "_ , vol .",
    "57 , no .  3 ,",
    "1425 1442 , 2011 .",
    "p.  gopalan , c.  huang , h.  simitci , and s.  yekhanin , `` on the locality of codeword symbols , '' _ ieee trans . on info .",
    "_ , vol .",
    "58 , no .",
    "11 , pp . 6925 6934 , 2012 .",
    "d.  papailiopoulos and a.  dimakis , `` locally repairable codes , '' in _ ieee intl .",
    "symposium on info .",
    "th . _ , 2012 ,",
    "2771 2775 .",
    "f.  oggier and a.  datta , `` self - repairing homomorphic codes for distributed storage systems , '' in _ infocom , 2011 proceedings ieee _ , april 2011 , pp .",
    "1215 1223 .",
    "`` wikipedia : list of device bit rates , available at http://en.wikipedia.org/wiki/listof device bandwidths . ''",
    "s.  jiekak , a .- m .",
    "kermarrec , n.  l. scouarnec , g.  straub , and a.  v. kempen , `` regenerating codes : a system perspective , '' 2012 [ online ] available : http://arxiv.org/abs/1204.5028 .",
    "g.  m. kamath , n.  prakash , v.  lalitha , and p.  v. kumar , `` codes with local regeneration , '' 2012 [ online ] available : http://arxiv.org/abs/1211.1932 .",
    "a.  k. rawat , o.  o. koyluoglu , n.  silberstein , and s.  vishwanath , `` optimal locally repairable and secure codes for distributed storage systems , '' 2012 [ online ] available : http://arxiv.org/abs/1210.6954 .",
    "s.  e. rouayheb and k.  ramchandran , `` fractional repetition codes for repair in distributed storage systems , '' in _ 48th annual allerton conference on communication , control , and computing _ , 2010 ,",
    "1510 1517 .",
    "j.  koo and j.  gill , `` scalable constructions of fractional repetition codes in distributed storage systems , '' in _",
    "49th annual allerton conference on communication , control , and computing _ , 2011 , pp .",
    "1366 1373 .",
    "o.  olmez and a.  ramamoorthy , `` repairable replication - based storage systems using resolvable designs , '' in _",
    "50th annual allerton conference on communication , control , and computing _ , 2012 .",
    "h.  sachs , `` regular graphs with given girth and restricted circuits , '' _ journal of the london mathematical society - second series _",
    "s1 - 38 , no .  1 ,",
    "pp . 423429 , 1963 .",
    "f.  lazebnik and v.  a. ustimenko , `` explicit construction of graphs with an arbitrary large girth and of large size , '' _",
    "discrete applied mathematics _",
    "60 , no .  1 ,",
    "pp . 275284 , 1995 .",
    "s.  jukna , _ extremal combinatorics : with applications in computer science_.1em plus 0.5em minus 0.4emspringer , 2011 .",
    "@xmath216 , @xmath217 for each node @xmath218 , identify an fr code @xmath219 ( if it exists ) such that @xmath220 . if no such fr code exists , find an fr code that has no intersection with @xmath221 and set @xmath222 equal to it",
    ".        we will apply an algorithmic approach here ( inspired by the one used in @xcite ) .",
    "namely , we iteratively construct a set @xmath228 so that @xmath229 .",
    "the minimum distance bound is then given by @xmath230 .",
    "our algorithm is presented in fig .",
    "[ min_dist_algorithm ] . towards this end , let @xmath231 and @xmath232 represent the number of nodes and the number of symbols included at the end of the @xmath57-th iteration . furthermore , let @xmath233 and @xmath234 , represent the corresponding increments between the @xmath235-th and the @xmath57-the iteration .",
    "we divide the analysis into two cases .",
    "* case 1 : [ the algorithm exits without ever entering line 8 . ] note that we have @xmath236 and @xmath237 where @xmath238 is the minimum number of symbols covered by @xmath239 nodes in the local fr code and hence the minimum size of @xmath240 . by considering the bipartite graph representing the local fr code",
    "it can be seen that @xmath241 .",
    "thus , we have @xmath242 suppose that the algorithm runs for @xmath170 iterations and exits on the @xmath243 iteration .",
    "then @xmath244 since the algorithm exits without ever entering line @xmath245 , it is unable to accumulate even one additional node .",
    "hence @xmath246 thus , the bound on the minimum distance becomes @xmath247 * case 2 : [ the algorithm exits after entering line 8 .",
    "] note that by assumption , @xmath151 .",
    "suppose that the algorithm enters line @xmath18 , @xmath248 times .",
    "now we have @xmath249 , otherwise we could include another local structure . hence we need to add nodes so that strictly less than @xmath250 symbols are covered . it can be seen that we can include at least @xmath251 more nodes .",
    "therefore , the total number of nodes @xmath252 therefore , we have the following minimum distance bound @xmath253 the final bound is obtained by taking the maximum of the two bounds obtained above .",
    "the proof of corollary [ mincor ] follows by observing that when the code consists of @xmath170 disjoint local fr codes and the file size @xmath254 , where @xmath255 , the algorithm in fig .",
    "[ min_dist_algorithm ] never enters line 8 ."
  ],
  "abstract_text": [
    "<S> we consider the design of regenerating codes for distributed storage systems that enjoy the property of local , exact and uncoded repair , i.e. , ( a ) upon failure , a node can be regenerated by simply downloading packets from the surviving nodes and ( b ) the number of surviving nodes contacted is strictly smaller than the number of nodes that need to be contacted for reconstructing the stored file .    </S>",
    "<S> our codes consist of an outer mds code and an inner fractional repetition code that specifies the placement of the encoded symbols on the storage nodes . for our class of codes , </S>",
    "<S> we identify the tradeoff between the local repair property and the minimum distance . </S>",
    "<S> we present codes based on graphs of high girth , affine resolvable designs and projective planes that meet the minimum distance bound for specific choices of file sizes . </S>"
  ]
}