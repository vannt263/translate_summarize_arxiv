{
  "article_text": [
    "the most famous algorithmic problem dealing with online assignment is arguably online bin packing . in this problem ,",
    "known since the 1970s , items of size between @xmath3 and @xmath4 arrive in a sequence and the goal is to pack these items into the least number of unit - sized bins , packing each item as soon as it arrives .",
    "online bin stretching , which was introduced by azar and regev in 1998  @xcite , deals with a similar online scenario .",
    "again , items of size between @xmath3 and @xmath4 arrive in a sequence , and the algorithm needs to pack them as soon as each item arrives , but it has two advantages : ( i ) the packing algorithm knows @xmath5 , the number of bins that an optimal offline algorithm would use , and must also use only at most @xmath5 bins , and ( ii ) the packing algorithm can use bins of capacity @xmath6 for some @xmath7 .",
    "the goal is to minimize the stretching factor @xmath6 .",
    "while formulated as a bin packing variant , online bin stretchingcan also be thought of as a semi - online scheduling problem , in which we schedule jobs in an online manner on exactly @xmath5 machines , before any execution starts .",
    "we have a guarantee that the optimum offline algorithm could schedule all jobs with makespan @xmath4 .",
    "our task is to present an online algorithm with makespan of the schedule being at most @xmath6 .",
    "* motivation .",
    "* we give two of applications of online bin stretching .    _ server upgrade .",
    "_ this application has first appeared in  @xcite . in this",
    "setting , an older server ( or a server cluster ) is streaming a large number of files to the newer server without any guarantee on file order .",
    "the files can not be split between drives .",
    "both servers have @xmath5 disk drives , but the newer server has a larger capacity of each drive .",
    "the goal is to present an algorithm that stores all incoming files from the old server as they arrive .    _",
    "shipment checking .",
    "_ a number @xmath5 of containers arrive at a shipping center .",
    "it is noted that all containers are at most @xmath8 percent full .",
    "the items in the containers are too numerous to be individually labeled , yet all items must be unpacked and scanned for illicit and dangerous material . after the scanning , the items must be speedily repackaged into the containers for further shipping . in this scenario ,",
    "an algorithm with stretching factor @xmath9 can be used to repack the objects into containers in an online manner .",
    "* history . * online bin stretchingwas proposed by azar and regev  @xcite . already before this , a matching upper and lower bound of @xmath10 for two bins had appeared  @xcite .",
    "azar and regev extended this lower bound to any number of bins and gave an online algorithm with a stretching factor @xmath11 .",
    "the problem has been revisited recently , with both lower bound improvements and new efficient algorithms . on the algorithmic side , kellerer and kotov  @xcite",
    "have achieved a stretching factor @xmath12 and gabay et al .",
    "@xcite have achieved @xmath13 .",
    "the best known general algorithm with stretching factor @xmath14 was presented by the authors of this paper in @xcite .    in the case with only three bins , the previously best algorithm was due to azar and regev  @xcite , with a stretching factor of @xmath15 .    on the lower bound side , the lower bound @xmath10 of  @xcite",
    "was surpassed only for the case of three bins by gabay et al .",
    "@xcite , who show a lower bound of @xmath16 , using an extensive computer search .",
    "the preprint @xcite was updated in 2015 @xcite to include a lower bound of @xmath2 for four bins .    * our contributions . * in section  [ sec : three118 ] we present an algorithm for three bins of capacity @xmath0 .",
    "this is the first improvement of the stretching factor @xmath15 of azar and regev  @xcite . in section  [ sec :",
    "lowerbound ] , we present a new lower bound of @xmath1 for online bin stretchingon three bins , along with a lower bound of @xmath2 on four and five bins which is the first non - trivial lower bound for four and five bins .",
    "we build on the paper of gabay et al .",
    "@xcite but significantly change the implementation , both technically and conceptually .",
    "the lower bound of @xmath2 for four bins is independently shown in @xcite .",
    "a preliminary version of this work appeared in waoa 2014 @xcite and sofsem 2016  @xcite .",
    "* related work . * the np - hard problem bin packingwas originally proposed by ullman  @xcite and johnson  @xcite in the 1970s .",
    "since then it has seen major interest and progress , see the survey of coffman et al .",
    "@xcite for many results on classical bin packing and its variants . while our problem can be seen as a variant of bin packing , note that the algorithms can not open more bins than the optimum and thus general results for bin packingdo not translate to our setting .",
    "as noted , online bin stretchingcan be formulated as the online scheduling on @xmath5 identical machines with known optimal makespan .",
    "such algorithms were studied and are important in designing constant - competitive algorithms without the additional knowledge , e.g. , for scheduling in the more general model of uniformly related machines  @xcite .    for scheduling , also other types of semi - online algorithms are studied .",
    "historically first is the study of ordered sequences with non - decreasing processing times  @xcite .",
    "most closely related is the variant with known sum of all processing times studied in  @xcite and the currently best results are a lower bound of @xmath17 and an algorithm with ratio @xmath18 , both from  @xcite .",
    "note that this shows , somewhat surprisingly , that knowing the actual optimum gives a significantly bigger advantage to the online algorithm over knowing just the sum of the processing times ( which , divided by @xmath5 , is a lower bound on the optimum ) .",
    "* definitions and notation . * our main problem , online bin stretching , can be described as follows :    * input : * an integer @xmath5 and a sequence of items @xmath19 given online one by one .",
    "each item has a _ size _",
    "@xmath20 $ ] and must be packed immediately and irrevocably .",
    "it is guaranteed that there exists a packing of all items in @xmath21 into @xmath5 bins of capacity @xmath4 .    * parameter : * the _ stretching factor _ @xmath7 .    *",
    "output : * partitioning ( packing ) of @xmath21 into bins @xmath22 so that @xmath23 for all @xmath24 .",
    "* goal : * design an online algorithm with the stretching factor @xmath6 as small as possible which packs all input sequences satisfying the guarantee .    for a bin @xmath25 , we define the _ size of the bin _ @xmath26 . unlike @xmath27 , @xmath28 can change during the course of the algorithm , as we pack more and more items into the bin . to easily differentiate between items , bins and lists of bins ,",
    "we use lowercase letters for items ( @xmath29 , @xmath30 , @xmath31 ) , uppercase letters for bins and other sets of items ( @xmath32 , @xmath25 , @xmath33 ) , and calligraphic letters for lists of bins ( @xmath34 , @xmath35 , @xmath36 ) .",
    "we rescale the item sizes and bin capacities for simplicity .",
    "therefore , in our setting , each item has an associated size @xmath37 $ ] , where @xmath38 is also the capacity of the bins which the optimal offline algorithm uses . the online algorithm for online bin stretchinguses bins of capacity @xmath39 , @xmath40 .",
    "the resulting stretching factor is thus @xmath41 .",
    "we scale the input sizes by @xmath42 .",
    "the stretched bins in our setting therefore have capacity @xmath43 and the optimal offline algorithm can pack all items into three bins of capacity @xmath42 each .",
    "we prove the following theorem .",
    "[ thm:3binsalgo ] there exists an algorithm that solves online bin stretchingfor three bins with stretching factor @xmath44 .",
    "the three bins of our setting are named @xmath32 , @xmath25 , and @xmath45 .",
    "we exchange the names of bins sometimes during the course of the algorithm .",
    "a natural idea is to try to pack first all items in a single bin , as long as possible . in general , this is the strategy that we follow .",
    "however , somewhat surprisingly , it turns out that from the very beginning we need to put items in two bins even if the items as well as their total size are relatively small .",
    "it is clear that we have to be very cautious about exceeding a load of 6 .",
    "for instance , if we put 7 items of size 1 in bin @xmath32 , and 7 such items in @xmath25 , then if two items of size 16 arrive , the algorithm will have a load of at least 23 in some bin .",
    "similarly , we can not assign too much to a single bin : putting 20 items of size 0.5 all in bin @xmath32 gives a load of 22.5 somewhere if three items of size 12.5 arrive next .",
    "( starting with items of size 0.5 guarantees that there is a solution with bins of size 16 at the end . )    on the other hand , it is useful to keep one bin empty for some time ; many problematic instances end with three large items such that one of them has to be placed in a bin that already has high load . keeping one bin free ensures that such items must have size more than 11 ( on average ) , which limits the adversary s options , since all items must still fit into bins of size 16 .",
    "deciding when exactly to start using the third bin and when to cross the threshold of 6 for the first time was the biggest challenge in designing this algorithm : both of these events should preferably be postponed as long as possible , but obviously they come into conflict at some point .      before stating the algorithm itself , we list a number of _ good situations _ ( gs )",
    ". these are configurations of the three bins which allow us to complete the packing regardless of the following input .",
    "it is clear that the identities of the bins are not important here ; for instance , in the first good situation , all that we need is that _ any _ two bins together have items of size at least 26 .",
    "we have used names only for clarity of presentation and of the proofs .",
    "a _ partial packing _ of an input sequence @xmath46 is a function @xmath47 that assigns a bin to each item from a prefix @xmath48 of the input sequence @xmath46 .",
    "[ lem : gs1 ] given a partial packing such that @xmath49 and @xmath50 is arbitrary , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "since the optimum can pack into three bins of size @xmath42 , the total size of items in the instance is at most @xmath51 .",
    "if two bins have size @xmath49 , all the remaining items ( including the ones already placed on @xmath45 ) have size at most @xmath43 .",
    "thus we can pack them all into bin @xmath45 .",
    "[ lem : gs2 ] given a partial packing such that @xmath52 $ ] and @xmath28 and @xmath50 are arbitrary , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "let @xmath32 be the bin with size between @xmath53 and @xmath54 and @xmath25 be one of the other bins ( choose arbitrarily )",
    ". put all the items greedily into @xmath25 .",
    "when an item does not fit , put it into @xmath32 , where it fits , as originally @xmath55 is at most @xmath54 . now",
    "the size of all items in @xmath25 plus the last item is at least @xmath43 .",
    "in addition , @xmath32 has items of size at least @xmath53 before the last item by the assumption .",
    "together we have @xmath49 , allowing us to apply 1 .",
    "from now on , we assume that each bin @xmath56 satisfies @xmath57 $ ] , otherwise we reach 2 .",
    "[ lem : gs3 ] given a partial packing such that @xmath58 and either ( i ) @xmath59 or ( ii ) @xmath60 and @xmath28 is arbitrary , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "\\(i ) we have @xmath61 , so we are in 1 on bins @xmath32 and @xmath25 or on bins @xmath32 and @xmath45 .",
    "( ii ) we pack arriving items into @xmath25 .",
    "if @xmath62 at any time , we apply 1 on bins @xmath32 and @xmath25 .",
    "thus we can assume @xmath63 and we can not continue packing into @xmath25 any further .",
    "this implies that an item @xmath29 arrives such that @xmath64 . as @xmath60",
    ", we pack @xmath29 into it and apply 1 on bins @xmath32 and @xmath45 .",
    "[ lem : gs4 ] given a partial packing such that @xmath65 , @xmath66 , and @xmath67 , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "let @xmath68 be the value of @xmath50 when the conditions of this good situation hold for the first time .",
    "we run the following algorithm until we reach 1 or 3 :    if at any time an item @xmath29 is packed into @xmath25 ( where it always fits ) , then @xmath69 and we reach 1 . in the event that no item @xmath29 is packed into @xmath25",
    ", we reach 3 ( with @xmath25 in the role of @xmath45 ) whenever the algorithm brings the size of @xmath32 to or above 15 .",
    "the only remaining case is when @xmath70 throughout the algorithm and several items with size in the interval @xmath71 arrive .",
    "these items are packed into @xmath45 .",
    "note that @xmath72 and that the lower bound of @xmath21 may decrease during the course of the algorithm .",
    "the first two items with size in @xmath21 will fit together , since @xmath73 .",
    "with two such items packed into @xmath45 , we know that the load @xmath74 is at least @xmath75 and we have reached 1 , finishing the analysis .",
    "[ lem : gs5 ] given a partial packing such that an item @xmath76 with @xmath77 is packed into bin @xmath32 , @xmath78 , and @xmath45 is empty , there exists an algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "pack all incoming items into @xmath32 as long as it possible . if @xmath79 , we have 4 , and so we assume the contrary",
    ". therefore , @xmath80 and an item @xmath29 arrives which can not be packed into @xmath32 .",
    "place @xmath29 into @xmath25 .",
    "if @xmath81 , we apply 3 .",
    "we thus have @xmath82 and @xmath83 .",
    "continue with on bins @xmath25 , @xmath32 , and @xmath45 in this order .",
    "we claim that 1 is reached at the latest after has packed two items , @xmath31 and @xmath84 , on bins other than @xmath25 .",
    "if one of them ( say @xmath31 ) is packed into bin @xmath32 , this holds because @xmath85 and @xmath86 already before this assignment ",
    "enough for 1 .",
    "if both items do not fit in @xmath32 , they are both larger than 10 , since @xmath87 .",
    "we will show by contradiction that this can not happen .",
    "as @xmath80 from our previous analysis , we note that @xmath88 .",
    "we therefore have three items @xmath89 with @xmath90 and an item @xmath91 from our initial conditions .",
    "these four items can not be packed together by any offline algorithm into three bins of capacity 16 , and so we have a contradiction with @xmath88 .",
    "[ lem : gs6 ] if @xmath60 , @xmath92 and @xmath93 , there exists an algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "pack all items into @xmath32 , until an item @xmath31 does not fit . at this point @xmath94 .",
    "if @xmath31 fits on @xmath25 , we put it there and reach 1 because @xmath92 . otherwise , @xmath31 definitely fits on @xmath45 because @xmath60 . by the condition on @xmath55 , we have @xmath95 , and we are in 1 again .    [",
    "lem : gs7 ] suppose @xmath96 , @xmath60 .",
    "if @xmath97 and for a new item @xmath31 we have @xmath98 , then there exists an online algorithm that packs all remaining items into three bins of capacity @xmath43 .",
    "we have @xmath99 and @xmath100 . placing @xmath31 on @xmath32 we increase the size of @xmath32 to at least @xmath101 and we reach 6 .      throughout our algorithm",
    ", we often use a special variant of which tries to reach good situations as early as possible .",
    "this variant can be described as follows :    [ dfn : gsff ] let @xmath102 be a list of bins @xmath103 where each bin @xmath33 has an associated capacity @xmath104 satisfying @xmath105 .",
    "( good situation first fit ) is an online algorithm for bin stretching that works as follows :    for example , checks whether either @xmath106 , @xmath107 or @xmath108 is a partial packing of any good situation .",
    "if this is not the case , the algorithm packs @xmath109 into bin @xmath32 provided that @xmath110 . if @xmath111 , the algorithm packs @xmath109 into bin @xmath25 with capacity @xmath43 .",
    "if @xmath109 can not be placed into @xmath25 , halts and another online algorithm must be applied to pack @xmath109 and subsequent items .      in a way ,",
    "any algorithm for online bin stretching for three bins must be designed so as to avoid several _ bad situations : _ the two most prominent ones being either two items of size @xmath112 or three items of size @xmath113 , where @xmath6 is the volume of the remaining items .",
    "our algorithm  especially steps and  are designed to primarily evade such bad situations , while making sure that no good situation is missed .",
    "this evasive nature gives it its name .",
    "let us start the analysis of the algorithm in step , where the algorithm branches on the size of the item @xmath109 .    throughout the proof , we will need to argue about loads of the bins @xmath32 , @xmath25 , @xmath45 before various items arrived .",
    "the following notation will help us in this endeavour :    * notation .",
    "* suppose that @xmath32 is a bin and @xmath31 is an item that gets packed at some point of the algorithm ( not necessarily into @xmath32 ) .",
    "then @xmath114 will indicate the set of items that are packed into @xmath32 just before @xmath31 arrived .",
    "we first observe that our algorithm can be in two very different states , based on whether @xmath115 or @xmath116 .",
    "note that the case @xmath117 $ ] is immediately settled using 2 .",
    "[ obs:1a ] assume that @xmath118 .",
    "we have @xmath119 and @xmath120 where @xmath32 and @xmath25 are bins after renaming in step  .",
    "thus both @xmath32 and @xmath25 received some items during step  .",
    "moreover , there is at most one item either in @xmath121 , or in @xmath122 .    since @xmath118 and @xmath123 , the item @xmath109 is assigned to @xmath25 in step  , which by step   is the least loaded bin among @xmath32 and @xmath25 after step  . for this bin , we have @xmath124",
    ", else we reach 2 .",
    "this implies that both @xmath32 and @xmath25 received items in step  , so @xmath125 , else a good situation would have been reached before @xmath109 arrived .",
    "it follows that @xmath126 and @xmath127 .",
    "since any item that is put into @xmath25 during step   must have size of more than two ( otherwise it fits into @xmath128 ) , only one such item can be packed into @xmath25 which proves the last statement .",
    "contrast the previous observation with the next one , which considers @xmath115 :    [ obs:1b ] assume that @xmath115 .",
    "then , @xmath129 , @xmath130 .",
    "if @xmath131 we reach 5 by packing @xmath109 into @xmath25 . however , if @xmath129 then @xmath132 which can be true ( without reaching a good situation ) only if @xmath130 .    both the analysis and the algorithm",
    "differ quite a lot based on the size of @xmath109 .",
    "if it holds that @xmath115 , we enter the _ large case _ of the analysis , while @xmath116 will be analyzed as the _",
    "standard case_. intuitively , if @xmath115 , the offline optimum is now constrained as well ; for instance , no three items of size @xmath133 can arrive in the future .",
    "this makes the analysis of the large case comparatively simpler .",
    "we now assume that @xmath115 .",
    "our goal in both the large case and the standard case will be to show that in the near future either a good situation is reached or several large items arrive , but is able to pack them nonetheless .",
    "let us start by recalling the relevant steps of the algorithm :    by choosing the limit @xmath134 to be @xmath135 in step , we make enough room for @xmath109 to be packed into @xmath32 .",
    "we also ensure that any item @xmath29 larger than @xmath54 that can not be placed into @xmath32 with capacity 22 must satisfy @xmath136 and so @xmath29 can not be with @xmath109 in the same bin in the offline optimum packing .",
    "let us define @xmath137 as the set of items on @xmath32 of size less than @xmath54 ( packed before or after @xmath109 ) .",
    "we note the following :    [ obs : nothingonc ]    1 .   during step , if @xmath25 contains any item , it is true that @xmath138 .",
    "if no good situation is reached , the item @xmath139 ending step satisfies @xmath140 .",
    "the first point follows immediately from our choice of @xmath134 and .",
    "for the second part of the observation , consider the item @xmath139 that ends step   and assume @xmath141 .",
    "the possibility that @xmath142 $ ] is excluded due to 2 .",
    "the case @xmath143 is also excluded , as this would imply 5 with @xmath109 in @xmath32 .",
    "since @xmath144 , the only remaining possibility is @xmath145 .",
    "even though @xmath139 does not fit into @xmath146 , if we were to pack @xmath139 into @xmath147 , we can use the first point of this observation and get @xmath148 , enough for 4 . the algorithm in step",
    "will notice this possibility and will pack @xmath139 into @xmath32 , where it will always fit , as @xmath149 by 4 .",
    "we now split the analysis based on which branch is entered in step :    * case 1 : * item @xmath139 fits into bin @xmath32 ; we enter step .",
    "we first note that @xmath150 , else we are in 4 since @xmath45 is still empty .",
    "this inequality also implies that @xmath151 , otherwise we have @xmath152 via observation  [ obs : nothingonc ] .",
    "we continue with step   until we reach a good situation or the end of input .",
    "suppose three items @xmath153 arrive such that none of them can be packed into @xmath32 and we do not reach a good situation .",
    "we will prove that this can not happen .",
    "we make several quick observations about those items :    1 .",
    "we have @xmath154 because @xmath155 or we reach 4 . the item @xmath31 is packed into @xmath25 .",
    "2 .   at any point",
    ", @xmath25 contains at most one item , otherwise @xmath156 , reaching 1 .",
    "we have @xmath157 because @xmath158 by 1 . the item @xmath84 is packed into @xmath45 .",
    "4 .   the bin @xmath45 contains also at most one item , similarly to @xmath25 .",
    "again , we have @xmath159 similarly to @xmath84 .",
    "the item @xmath160 does not fit into any bin .    from our observations",
    "above , we get @xmath161 , @xmath162 , @xmath163 . therefore ,",
    "at least two of the items @xmath164 are of size at least @xmath165",
    ". however , both items @xmath109 and @xmath139 have size at least @xmath54 , and there is no way to pack @xmath166 and the two items larger than @xmath165 into three bins of capacity @xmath42 , a contradiction .",
    "* case 2 : * item @xmath139 does not fit into bin @xmath147 .",
    "the choice of @xmath134 gives us @xmath167 .",
    "item @xmath139 is placed on @xmath25 .",
    "the limit @xmath134 gives us an upper bound on the volume of small items @xmath137 in @xmath32 , namely @xmath168 .",
    "an easy argument gives us a similar bound on @xmath25 , namely if @xmath169 , then @xmath170 .",
    "indeed , we have @xmath171 , the first inequality implied by not reaching 1 .    in case 2 ,",
    "it is sufficient to consider two items @xmath172 that do not fit into @xmath173 or @xmath174 .",
    "we have :    1 .   using @xmath175 , we have @xmath176 and @xmath177 .",
    "2 .   none of the items @xmath172 fits into @xmath147 .",
    "if say @xmath31 did fit , then we use the fact that @xmath31 does not fit into @xmath174 and get @xmath178 and we reach 1 .",
    "the choice of the limit @xmath134 on @xmath55 implies @xmath179 and @xmath180 .",
    "4 .   since @xmath181 at all times by 1",
    ", we have @xmath182 and @xmath157 .",
    "5 .   the items @xmath31 and @xmath84",
    "do not fit together into @xmath45 , or we would have @xmath183 .",
    "this implies @xmath161 .",
    "from the previous list of inequalities and using @xmath184 , we learn that no two items from the set @xmath185 can be together in a bin of size @xmath42 .",
    "again , this is a contradiction with the assumptions of online bin stretching .      from now on",
    ", we can assume that @xmath116 , @xmath109 is packed into @xmath25 and step of is reached .",
    "recall that by observation  [ obs:1a ] @xmath119 , @xmath120 , and there is exactly one item either in @xmath32 , or in @xmath25 ; we denote this item by @xmath186 .",
    "we repeat the steps done by in the standard case :    recall that @xmath187 by observation  [ obs:1a ] . assuming that no good situation is reached before step , we observe the following :    [ obs:6-b ] in step , as long as @xmath45 is empty , packing any item of size at least @xmath53 leads to a good situation .",
    "thus while @xmath45 is empty , all items that arrive in step and are not put on @xmath32 have size in @xmath188 .    any item with size in @xmath189\\cup[4,6]$ ]",
    "leads to 2 .",
    "any item with size more than 6 is assigned to @xmath25 if it fits there , reaching 5 , and else to @xmath32 or @xmath45 , reaching 7 since @xmath190 .",
    "the only remaining possible sizes of items that are not packed into @xmath32 are @xmath188 .",
    "[ obs : c ] after step , @xmath45 contains exactly one item @xmath191 and @xmath192 .    from the previous observation it is clear that @xmath45 receives at least one item @xmath191 in step .",
    "no second item @xmath193 can be packed into @xmath194 in step   as @xmath195 would be at least @xmath196 .",
    "step terminates with a new item @xmath31 which fits into @xmath174 ( otherwise we would reach 7 ) , but not below the limit @xmath197 .",
    "we pack @xmath31 into @xmath25 in step  , getting @xmath198 .",
    "a possible bad situation for our current packing is when three items @xmath199 arrive , where the items are such that no two items of this type fit together into any bin , and no single item of this type fits on the largest bin , which is @xmath25 in our case .",
    "in fact , we will prove later that this is the only possible bad situation .",
    "we claim that this potential bad situation can not occur :    [ clm : nobigitems ] suppose that algorithm reaches no good situation in the standard case .",
    "then , @xmath200 and after placing @xmath31 into b in step   it holds that @xmath201 .    furthermore",
    ", suppose that among items that arrive after @xmath31 , there are three items @xmath202 such that @xmath203 .",
    "then , it holds that @xmath204    we now show how claim [ clm : nobigitems ] finishes the analysis of .",
    "after step , assuming no good situation was reached , the algorithm places @xmath31 into @xmath174 and continues with step  , which is .",
    "claim [ clm : nobigitems ] gives us that @xmath205 after placing @xmath31 , while the fact that we exited step means that @xmath206 .",
    "consider the first item @xmath207 that does not fit into @xmath208 .",
    "we have that @xmath209 , otherwise 2 is reached . however , any item that fits into @xmath25 ( as long as @xmath210 ) triggers 4 , because @xmath211 .",
    "we now know that the first item @xmath207 does not fit into both @xmath212 and @xmath174 .",
    "we place it into @xmath45 , noting that @xmath213 .",
    "we keep packing items into @xmath212 , waiting for the second item @xmath214 that does not fit into @xmath208 in step  .",
    "again , @xmath215 .",
    "suppose that @xmath214 fits into @xmath174 or @xmath216 .",
    "claim [ clm : nobigitems ] gives us @xmath217 ; we thus sum up bins @xmath25 and @xmath45 and get @xmath218 , which is enough for 1 .",
    "our assumption was false , the item @xmath214 does fit into neither @xmath174 nor @xmath216 , in particular @xmath219 .",
    "we move to step  , pack @xmath214 into @xmath147 and continue with .",
    "if at any time @xmath220 , we enter 1 on @xmath32 and @xmath25 . otherwise ,",
    "if an item @xmath221 does not fit into @xmath147 , it must satisfy @xmath222 .",
    "we now apply the full strength of claim [ clm : nobigitems ] .",
    "the smallest item of @xmath207 , @xmath214 , @xmath221 must have size less than @xmath223 , and because of our argument , it must be @xmath221  but this means it fits into @xmath25 , as @xmath201 . 1 on bins @xmath32 and @xmath25 finishes the packing , since @xmath224 .      our current goal is to prove claim [ clm : nobigitems ] . as in the large case , we would now like to appeal to the offline layout of the larger items currently packed . unlike the large case , none of the items we have packed before step   is guaranteed to be over @xmath54 .    sidestepping this obstacle , we will argue about the offline layout of the smaller items .",
    "we now list several items that are packed before step   and will be important in our analysis :    [ dfn : fouritems ] the four items @xmath225 are defined as follows :    1 .   the item @xmath226 : the only item packed into @xmath25 in step   by observation  [ obs:1a ] .",
    "( note that @xmath186 might end up on @xmath32 after renaming the bins . ) 2 .   the item @xmath227 , defined in step  .",
    "the item @xmath228 , which is placed into @xmath45 in step   by observation  [ obs : c ] ; @xmath191 is the only item in @xmath45 until step  .",
    "4 .   the item @xmath31 which terminated step",
    ".    there are four such items and only three bins , meaning that in the offline optimum layout with capacity @xmath42 , two of them are packed in the same bin .",
    "we will therefore argue about every possible pair , proving that each pair is of size more than @xmath229 .    our main tool in proving the mentioned lower bounds are the inequalities that must be true during various stages of algorithm , since a good situation was not reached .",
    "we now list all the major inequalities that we will use :    * at the beginning of step  , packing @xmath109 makes the bin @xmath25 go over @xmath54 : @xmath230 * in step  , we know that any item @xmath29 that gets packed into @xmath25 ( and does not fit into @xmath208 ) also does not fit into @xmath231 or else we reach 2 : @xmath232 * the item @xmath191 does not fit into @xmath233 : @xmath234 * the item @xmath191 can not cause 4 if it is packed into @xmath25 ( with @xmath45 still empty ) : + @xmath235 * when @xmath31 got packed into @xmath174 in step  , it did not cause 4 when summing @xmath25 with @xmath45 : + @xmath236 * the item @xmath31 also did not cause 4 when summing @xmath25 with @xmath32 : + @xmath237 * packing @xmath31 into @xmath174 in step   causes @xmath25 to go over the limit @xmath238 : @xmath239 * the item @xmath31 can not start 6 when packed into @xmath32 . comparing bin @xmath32 to @xmath25",
    ", we get : @xmath240 + we get a similar but slightly different inequality when comparing @xmath25 to @xmath32 instead : @xmath241 * 6 could not be reached when the algorithm considered packing @xmath31 into bin @xmath45 , comparing the bin @xmath45 to @xmath25 : @xmath242 + again as in inequality we can compare bin @xmath25 to @xmath45 and get : @xmath243    note that one can prove claim  [ clm : nobigitems ] by showing that the converse of the claim and the above inequalities form an infeasible linear programming instance .",
    "this was our approach as well .",
    "nonetheless , we provide an explicit proof for completeness .",
    "our first lemma establishes that @xmath109 is actually the only item that is packed into @xmath25 during step  , which intuitively means that @xmath109 is not too small :    [ lem : onej ] assume that no good situation is reached until step  .",
    "then it holds that during step  , only @xmath109 is packed into @xmath25 .",
    "we first prove that no two additional items @xmath244 can be packed into @xmath25 during step  . assuming the contrary , we get @xmath245 . with that load on @xmath25",
    ", we consider the packing at the end of step  , when the item @xmath31 arrived .",
    "if @xmath246 , we get 6 by placing @xmath31 into @xmath45 since @xmath247 , so it must be true that @xmath248 , which means @xmath249 .",
    "this is enough for us to place @xmath31 into @xmath174 ( where it fits , otherwise we are in 7 ) and reach 3 .",
    "this contradiction gives us that at most one additional item @xmath250 can be packed into @xmath25 during step .",
    "we will now prove that even @xmath250 does not exist .",
    "we split the analysis into two cases depending on which of @xmath250 and @xmath191 arrives first .",
    "* case 1 . * the item @xmath191 is packed before @xmath250 , meaning @xmath251 .",
    "we start with inequalities , and in the following form :    @xmath252    we sum twice with and :    @xmath253    @xmath254    using @xmath255 ( since @xmath191 arrives after @xmath109 ) along with @xmath256 from observation [ obs:1a ] and @xmath257 gives us :    @xmath258    which is a contradiction , since @xmath259 and @xmath250 did not fit into @xmath231 .",
    "* case 2 . * in the remaining case , @xmath250 arrives before @xmath191 , which means @xmath260 .",
    "we start by summing and .",
    "we get : @xmath261    keeping in mind for later use , we continue by considering , and in the following form :    @xmath262    summing the three inequalities gives us : @xmath263 @xmath264 @xmath265    summing two times , two times and once gives us :    @xmath266    using @xmath267 ( which is only true here in case 2 , where @xmath191 arrived later ) and recalling along with , we get @xmath268 and @xmath269 , which is a contradiction with @xmath191 fitting into @xmath194",
    ".    having established that only one item @xmath109 is packed into @xmath25 during step , we can start deriving lower bounds on pairs of items from the set @xmath270 .",
    "we will prove these bounds similarly to lemma [ lem : onej ] , mostly by summing bounds that arise from evading various good situations .",
    "[ lem : eplusr ] suppose that @xmath186 and @xmath191 are items as described in definition [ dfn : fouritems ] and suppose also that no good situation was reached during step   of the algorithm .",
    "then , @xmath271 .",
    "first of all , it is important to note that the item @xmath186 may be packed on @xmath32 or on @xmath25 . since either @xmath122 , or @xmath121 contains solely @xmath186 by observation  [ obs:1a ]",
    ", we get that either @xmath272 , or @xmath273 .",
    "thus it is sufficient to prove @xmath274 .",
    "we start the proof of @xmath274 by restating , , and in the following form :    @xmath275    before summing up the inequalities , we multiply the first one by 8 , the second by 2 and the third by 2 . in total , we have : @xmath276    we know that @xmath277 and @xmath278 , allowing us to cancel out the terms :    @xmath279    finally , using the bound @xmath116 and noting that @xmath280 , we get    @xmath281    [ lem : eplusj ] suppose that @xmath186 and @xmath109 are items as described in definition [ dfn : fouritems ] and suppose also that no good situation was reached by the algorithm .",
    "then , @xmath282 .",
    "the same argument as in lemma [ lem : eplusr ] gives us @xmath283 .",
    "we therefore aim to prove @xmath284 . summing up and and using @xmath285 , we get    @xmath286 @xmath287    we now apply the bound @xmath288 , the second inequality being lemma [ lem : eplusr ] .",
    "we get :    @xmath289 and finally @xmath284 , completing the proof .",
    "[ lem : rplusj ] suppose that @xmath109 and @xmath191 are items as described in definition [ dfn : fouritems ] and suppose also that no good situation was reached by the algorithm .",
    "then , @xmath290 .    starting with :    @xmath291 and using @xmath292 together with @xmath293",
    ", we have : @xmath294    [ lem : xplus ] suppose that @xmath295 are items as described in definition [ dfn : fouritems ] .",
    "suppose also that no good situation was reached by the algorithm .",
    "then , @xmath296 and @xmath297 .    with all the previous lemmas in place ,",
    "the proof is simple enough .",
    "we first observe that @xmath296 ; this is true because @xmath298 and @xmath299 .",
    "since the remaining three items @xmath300 are bounded from above by @xmath53 but their pairwise sums are always at least @xmath229 , we have that @xmath301 , which along with @xmath296 gives us the required bound .    from lemmata [ lem : eplusr ] ,",
    "[ lem : eplusj ] , [ lem : rplusj ] and [ lem : xplus ] we get a portion of claim [ clm : nobigitems ] : if three big items @xmath202 exist in the offline layout , then one of these items needs to be packed together with at least two items from the set @xmath270 , and therefore @xmath302 .",
    "the second bound @xmath303 follows from lemma [ lem : eplusr ] and the fact that @xmath304 .",
    "all that remains is to prove the bound on @xmath28 , which we do in the following lemma :    [ lem : boundonb ] suppose that no good situation was reached in the algorithm during step  .",
    "then , after placing @xmath31 into @xmath25 in step  , it holds that @xmath205 .",
    "as before , we will use our inequalities to derive the desired bound . as we have argued above , lemma [ lem : eplusr ]",
    "gives us that @xmath303 .",
    "we sum up inequalities and , getting :    @xmath305    to finish the bound we need @xmath306 ( this is true because we reorder the bins @xmath25 , @xmath32 in step  ) , @xmath303 and @xmath116 . plugging them in",
    ", we get :    @xmath307 @xmath308    with lemma [ lem : boundonb ] proven , we have finished the proof of claim [ clm : nobigitems ] and completed the analysis of the algorithm .",
    "in this section , we describe our lower bound technique for a small number of bins .",
    "we build on the paper of gabay , brauner and kotov @xcite but significantly change the algorithm , both conceptually and technically .    on the conceptual side ,",
    "we propose a different algorithm for computing the offline optimum packing , suggest new ways of pruning the game tree and show how the alpha - beta pruning of @xcite can be skipped entirely .    on the technical side",
    ", we reimplement the algorithm of @xcite , gaining significant speedup from the reimplementation alone . while the lower bound search program of @xcite was written in python , employed csp solvers and had unrestricted caching , our program is written in c , is purely combinatorial and it sets limits on the cache size , making time the only exponentially - increasing factor .    with these improvements",
    ", we were able to find an improved lower bound for online bin stretchingfor three bins , namely @xmath1 .",
    "we also present the lower bound of @xmath309 for @xmath310 and @xmath311 .",
    "note that this is the first non - trivial lower bound for @xmath311 and that our result is independent from the lower bound of @xmath2 for @xmath310 by gabay et al .",
    "@xcite .    to see the strength of our improvements ,",
    "consider the scaling factor @xmath312 and items of integer size .",
    "it is easy to see that a general game tree search requires exponential running time with respect to @xmath312 .",
    "the algorithm of @xcite is able to check all @xmath313 ( for @xmath314 ) before claiming that `` even with many efficient cuts , we can not tackle much larger problems . ''",
    "in contrast , our proposed algorithm is able to check all @xmath315 and is fast enough to produce results for @xmath310 and @xmath311 .",
    "we now describe our lower bound technique .",
    "to simplify our arguments , we describe the technique only for @xmath316 .",
    "we discuss the pecularities of the generalization to any fixed @xmath5 in section  [ sec : generalization ] .    as with many other online algorithms",
    ", we can think of online bin stretchingas a two player game .",
    "the first player ( algorithm ) is presented with an item @xmath29 .",
    "algorithm s goal is to pack it into @xmath5 bins of capacity @xmath46 .",
    "this mimics the task of any algorithm for online bin stretching .",
    "the other player ( adversary ) decides which item to present to the algorithmin the next step .",
    "the goal of the adversaryis to force algorithmto overpack at least one bin .",
    "it is clear that knowing the game tree for a parameter @xmath46 of the aforementioned game is equal to knowing whether there is an algorithm for online bin stretchingwith stretching factor @xmath46 .",
    "we are interested primarily in the lower bound .",
    "therefore , it makes sense to slightly reformulate the previous game :    * the player algorithmwins if it can pack all items into bins with capacity strictly less than @xmath46 . *",
    "the player adversarywins if it can force algorithmto pack a bin with load @xmath317 while making sure that the online bin stretchingguarantee is satisfied .    this way",
    ", a winning strategy for the player adversaryimmediately implies that no online algorithm for online bin stretchingwith stretching factor less than @xmath46 exists .",
    "the two main obstacles to implementing a search of the described two player game are the following :    1 .",
    "adversarycan send an item of arbitrarily small size ; 2 .",
    "adversaryneeds to make sure that at any time of the game , an offline optimum can pack the items arrived so far into three bins of size @xmath318 .",
    "to overcome the first problem , it makes sense to create a sequence of games based on the granularity of the items that can be packed .",
    "a natural granularity for the scaled game are integral items , which correspond to multiples of @xmath319 in the non - scaled problem .",
    "the second problem increases the complexity of every game turn of the adversary , as it needs to run a subroutine to verify the guarantee for the next item it wishes to place .",
    "note that the ideas described above have been described previously in @xcite .    to precisely formulate our setting , we first define one state of a game :    [ dfn : binconf ] for given parameters @xmath320 , a * bin configuration * is a tuple @xmath321 , where    @xmath322 denote the current sorted loads of the bins , i.e. , @xmath323 ,    @xmath324 is a multiset with ground set @xmath325 which lists the items used in the bins .",
    "additionally , in a bin configuration , it must hold :    that there exists a packing of items from @xmath324 into three bins with loads exactly @xmath326 ,    that there exists a packing of items from @xmath324 into three bins that does not exceed @xmath318 in any bin .",
    "it is clear that every bin configuration is a valid state of the game with adversaryas the next player .",
    "we may also observe that the existence of an online algorithm for online bin stretchingimplies an existence of an oblivious algorithm with the same stretching factor that has access only to the current bin configuration @xmath25 and the incoming item @xmath29 .",
    "using the concept of bin configuration and the previous two facts , we may formally define the game we investigate :    for a given @xmath327 , the * bin stretching game * @xmath328 is the following two player game :    * there are two players named adversaryand algorithm",
    ". the player adversarystarts .",
    "* each turn of the player adversaryis associated with a bin configuration @xmath329 .",
    "the start of the game is associated with the bin configuration @xmath330 . *",
    "the player adversaryreceives a bin configuration @xmath25 .",
    "then , adversaryselects a number @xmath29 such that the multiset @xmath331 can be packed by an offline optimum into three bins of capacity @xmath318 .",
    "the pair @xmath332 is then sent to the player algorithm . *",
    "the player algorithmreceives a pair @xmath332 .",
    "the player algorithmhas to pack the item @xmath29 into the three bins as described in @xmath25 so that each bin has load strictly less than @xmath46 .",
    "algorithmthen updates the configuration @xmath25 into a new bin configuration , denoted @xmath333 .",
    "algorithmthen sends @xmath333 to the player adversary .    for a bin configuration @xmath25",
    "we define recursively whether it is won or lost for player adversary :    * if the player algorithmreceives a pair @xmath332 such that it can not pack the item according to the rules , the bin configuration @xmath25 is won for player adversary . *",
    "if the player adversaryhas no more items @xmath29 that it can send from a configuration @xmath25 , the bin configuration @xmath25 is lost for player adversary . * for any bin configuration @xmath25 where the player adversaryhas a possible move , the configuration is won for player adversaryif and only if the game ends in a bin configuration @xmath45 that is won for the player adversaryno matter which decision is made by the player algorithmat any point .",
    "we say that a game @xmath328 is a * lower bound * if and only if the bin configuration @xmath330 is won for the player adversary .",
    "our implemented algorithm is a fairly standard implementation of the minimax game search algorithm .",
    "the pecularities of our algorithm ( caching , pruning , and other details ) are described in the following sections .",
    "one of the differences between our algorithm and the algorithm of gabay et al .",
    "@xcite is that our algorithm makes no use of alpha - beta pruning  indeed , as every bin configuration is either won for algorithmor won for adversary , there is no need to use this type of pruning .",
    "the following procedures return 0 if the bin configuration is won for the player adversary ; otherwise they return 1 ( player algorithmwins ) .",
    "when we evaluate a turn of the adversary , we need to create the list @xmath334 of items that adversarycan actually send while satifying the online bin stretchingguarantee .",
    "we employ the following steps :    1 .",
    "first , we calculate a lower and upper bound @xmath335 on the maximal value @xmath84 of @xmath336 .",
    "2 .   then , we do a linear search on the interval @xmath337 using a procedure @xmath338 that checks a single multiset @xmath339 , where @xmath339 is @xmath324 plus the item in question and @xmath324 is the current multiset of items .",
    "the first feasible item size is the desired value of @xmath84 .",
    "note that in the second step we could also implement a binary search over the interval , but in our experiments the difference between @xmath340 and @xmath341 was very small ( usually at most 4 ) , thus a linear search is quicker .",
    "* upper and lower bounds . *",
    "the running time of procedure @xmath338 will be cubic in terms of @xmath318 in the worst case .",
    "we therefore reduce the number of calls to @xmath338 by creating good lower and upper bounds on the maximal item @xmath84 which adversarycan send .",
    "to find a good lower bound , we employ a standard bin packing algorithm called best fit decreasing .",
    "best fit decreasingpacks items from @xmath324 into three bins of capacity @xmath318 with items in decreasing order , packing an item into a bin where it `` fits best ''  where it minimizes the empty space of a bin .",
    "best fit decreasingis a linear - time algorithm ( it does not need to sort items in @xmath324 , as the implementation of @xmath324 stores them in a sorted order ) .",
    "our desired lower bound @xmath341 will be the maximum empty space over all three bins , after best fit decreasinghas ended packing .",
    "such an item can always be sent without invalidating the online bin stretchingguarantee .",
    "our upper bound @xmath340 is comparatively simpler ; for a bin configuration @xmath321 , it will be set to @xmath342 .",
    "clearly , no larger item can be sent without raising the total size of all items above @xmath343",
    ".    * procedure @xmath338 . *",
    "procedure @xmath338 is a sparse modification of the standard dynamic programming algorithm for knapsack .",
    "given a multiset @xmath344 , on input , our task is to check whether it can be packed into three bins ( knapsacks ) of capacity @xmath318 each .",
    "we use a queue - based algorithm that generates a queue @xmath345 of all valid triples @xmath346 that can arise by packing the first @xmath29 items .    to generate a queue @xmath347 , we traverse the old queue @xmath345 and add the new item @xmath348 $ ] to the first , second and third bin , creating up to three triples that need to be added to @xmath347 .",
    "we make sure that we do not add a triple several times during one step , we mark its addition into a auxilliary @xmath349 array @xmath350 .",
    "note that the queue @xmath347 needs only @xmath351 and the item @xmath348 $ ] for its construction , and so we can save space by switching between queues @xmath352 and @xmath353 , where @xmath354 and @xmath355 .",
    "the time complexity of the procedure @xmath338 is @xmath356 in the worst case .",
    "however , when a bin configuration contains large items , the size of the queue is substantially limited and the actual running time is much better .    * notes : * we employ two small optimizations that were not yet mentioned .",
    "first , we sort the numbers @xmath346 in each triple to ensure @xmath357 , saving a small amount of space and time .",
    "second , we use one global array @xmath350 in order to avoid initializing it with every call of the procedure @xmath338 .",
    "it is also worth noting that we could alternatively implement the procedure @xmath338 using integer linear programming or using a csp solver ( which has been done in @xcite ) .",
    "however , we believe our sparse dynamic programming solution carries little overhead and for large instances it is much faster than the csp / ilp solvers .",
    "our minimax algorithm employs extensive use of caching .",
    "we cache any solved instance of procedure @xmath338 as well as any evaluated bin configuration @xmath25 with its value .",
    "note that we do not cache results of procedure @xmath358",
    ".    * hash table limitation .",
    "* we store a large hash table of fixed size , with each entry being a separate chain . with each node in a chain we store the number of accesses .",
    "when a chain is to be filled over a fixed limit , we eliminate a node with the least number of accesses .    to allow hash tables of variable size , our hash function returns a @xmath359-bit number , which we trim to the desired size of our hash table .",
    "in our definition of a bin configuration @xmath321 , we do not require the loads @xmath326 to be sorted .",
    "however , configurations which differ only by a permutation of the values @xmath326 are equivalent , and so we sort these numbers when inserting a bin configuration into the hash table",
    ".    * hash function .",
    "* our hash function is based on zobrist hashing @xcite , which we now describe .    for each bin configuration , we count occurences of items , creating pairs @xmath360 , where @xmath29 is the item type and @xmath361 its frequency . as an example , a bin configuration @xmath362 forms pairs @xmath363 and so on .    at the start of our program",
    ", we associate a random @xmath359-bit number with each pair @xmath364 .",
    "we also associate a @xmath359-bit number for each possible load of bin @xmath32 , bin @xmath25 and bin @xmath45 .",
    "the zobrist hash function is then simply a xor of all associated numbers for a particular bin configuration .",
    "the main advantage of this approach is fast computation of new hash values .",
    "suppose that we have a bin configuration @xmath25 with hash @xmath365 .",
    "after one round of the player adversaryand one round of the player algorithm , a new bin configuration @xmath333 is formed , with one new item placed . calculating the hash @xmath366 of @xmath333 can be done in time @xmath367 , provided we remember the hash @xmath365  the new hash is calculated by applying xor to @xmath365 , the new associated values , and the previous associated values which have changed .",
    "* caching of the procedure @xmath338*. so far , we have described caching of the bin configurations .",
    "we also use the same approach for caching the values of the procedure @xmath338 . to see the usefulness ,",
    "note that the procedure @xmath338 does not use the entire bin configuration @xmath368 as input , but only the multiset @xmath324 .",
    "therefore , we aim to eliminate overhead that is caused by calling @xmath338 on a different bin configuration , but with the same multiset @xmath324 .",
    "our hash function and hash table approaches are the same in both cases .      alongside the extensive caching described in subsection [ subsec : caching ] , we also prune some bin configurations where it is possible to prove that a simple online algorithm is able to finalize the packing . such a bin configuration is then clearly won for player algorithm , as it can follow the output of the online algorithm",
    ".    such situation are called _ good situations _ , same as in section  [ sec : gs ] .",
    "we will make use of the first five good situations from section [ sec : gs ] . recall that in the bin stretching game @xmath328 , the player algorithmis trying to pack all three bins with capacity strictly below @xmath46 , which we can think of as capacity @xmath369 .",
    "therefore , we set @xmath370 and use @xmath371 in our definitions .",
    "we restate the good situations 1 to 5 for an instance of @xmath372 for general @xmath373 with @xmath374 satisfying @xmath375 , while in section [ sec : gs ] we formulate the good situations only for @xmath376 .",
    "the proofs are however equivalent and we omit them .",
    "[ lem : newgs1 ] given a bin configuration @xmath321 such that @xmath377 and @xmath68 is arbitrary , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath371 .",
    "[ lem : newgs2 ] given a bin configuration @xmath321 such that @xmath378 $ ] and @xmath30 and @xmath68 are arbitrary , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath371 .",
    "[ lem : newgs3 ] given a bin configuration @xmath321 such that @xmath379 $ ] and either ( i ) @xmath380 and @xmath30 is arbitrary or ( ii ) @xmath381 , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath371 .",
    "[ lem : newgs4 ] given a bin configuration @xmath321 such that @xmath382 , @xmath383 , and @xmath384 , there exists an online algorithm that packs all remaining items into three bins of capacity @xmath371 .",
    "[ lem : newgs5 ] suppose that we are given a bin configuration @xmath321 such that an item @xmath29 with @xmath385 is present in the multiset @xmath324 and the following holds : @xmath386 .",
    "then there exists an algorithm that packs all remaining items into three bins of capacity @xmath371 .",
    "table [ table : results ] summarizes our results .",
    "the paper of gabay , brauner and kotov @xcite contains results up to the denominator 20 ; we include them in the table for completeness .",
    "results after the denominator 20 are new .",
    "note that there may be a lower bound of size @xmath387 even though none was found with this denominator ; for instance , some lower bound may reach @xmath387 using item sizes that are not multiples of @xmath388 .",
    ".results produced by our minimax algorithm , along with elapsed time . the column _",
    "l. b. found _ indicates whether a lower bound was found when starting with the given granularity .",
    "fractions lower than @xmath2 and higher than @xmath389 are omitted .",
    "results were computed on a server with an amd opteron 6134 cpu and 64496 mb ram .",
    "the size of the hash table was set to @xmath390 with chain length @xmath53 . in order to normalize the speed of the program , the algorithm only checked for a lower bound and did not generate the entire tree in the * yes * cases . [ cols=\"^,<,<,<\",options=\"header \" , ]      we give a compact representation of our game tree for the lower bound of @xmath391 for @xmath314 , which can be found in appendix [ sec : appendix ] .",
    "the fully expanded representation , as given by our algorithm , is a tree on 11053 vertices .    for our lower bounds of @xmath2 for @xmath392 and @xmath393 , the sheer size of the tree ( e.g. 4665 vertices for @xmath311 )",
    "prevents us from presenting the game tree in its entirety .",
    "we therefore include the lower bound along with the implementations , publishing it online at http://github.com / bohm / binstretch/.    we have implemented a simple independent c++ program which verifies that a given game tree is valid and accurate . while verifying our lower bound manually may be laborious , verifying the correctness of the c++ program should be manageable .",
    "the verifier is available along with the rest of the programs and data .",
    "with our algorithm for @xmath314 , the remaining gap is small . for arbitrary @xmath5 ,",
    "we have seen at the beginning of section  [ sec : bigm ] that a significantly new approach would be needed for an algorithm with a better stretching factor than @xmath14 .",
    "thus , after the previous incremental results , our algorithm is the final step of this line of study .",
    "it is quite surprising that there are no lower bounds for @xmath394 larger than the easy bound of @xmath10 .",
    "* acknowledgment . *",
    "the authors thank emese bittner for useful discussions during her visit to charles university .",
    "10    s.  albers and m.  hellwig .",
    "semi - online scheduling revisited .",
    ", 443:19 , 2012 .",
    "j.  aspnes , y.  azar , a.  fiat , s.  plotkin , and o.  waarts . on - line load balancing with applications to machine scheduling and virtual circuit routing . , 44:486504 , 1997 .",
    "y.  azar and o.  regev . on - line",
    "bin - stretching . in _",
    "randomization and approximation techniques in computer science _ , pages 7181 .",
    "springer , 1998 .",
    "y.  azar and o.  regev . on - line",
    "bin - stretching . 268(1):1741 , 2001 .",
    "p.  berman , m.  charikar , and m.  karpinski .",
    "on - line load balancing for related machines .",
    ", 35:108121 , 2000 .",
    "lower bounds for online bin stretching with several bins .",
    "student research forum papers and posters at sofsem 2016 , ceur wp vol-1548 , 2016 .",
    "m. bhm , j. sgall , r. van stee , and p. vesel .",
    "better algorithms for online bin stretching . in approximation and online algorithms ( pp .",
    "23 - 34 ) .",
    "springer international publishing , 2014 .",
    "m. bhm , j. sgall , r. van stee , and p. vesel .",
    "the best two - phase algorithm for bin stretching .",
    "arxiv preprint arxiv:1601.08111 , 2016 .",
    "e.  coffman  jr . , j.  csirik , g.  galambos , s.  martello , and d.  vigo .",
    "bin packing approximation algorithms : survey and classification , in p.  m. pardalos , d .- z .",
    "du , and r.  l. graham , editors , _ handbook of combinatorial optimization _ , pages 455531 .",
    "springer new york , 2013 .",
    "t.  ebenlendr , w.  jawor , and j.  sgall .",
    "preemptive online scheduling : optimal algorithms for all speeds .",
    ", 53:504522 , 2009 .",
    "m.  gabay , n.  brauner , v.  kotov . computing lower bounds for semi - online optimization problems : application to the bin stretching problem .",
    "hal preprint hal-00921663 , version 2 , 2013 .",
    "m.  gabay , n.  brauner , v.  kotov . improved lower bounds for the online bin stretching problem .",
    "hal preprint hal-00921663 , version 3 , 2015 .",
    "m.  gabay , v.  kotov , n.  brauner .",
    "semi - online bin stretching with bunch techniques .",
    "hal preprint hal-00869858 , 2013 .    r.  l. graham .",
    "bounds on multiprocessing timing anomalies .",
    ", 17:263269 , 1969 .",
    "d.  johnson . .",
    "massachusetts institute of technology , project mac .",
    "massachusetts institute of technology , 1973 .",
    "h.  kellerer and v.  kotov .",
    "an efficient algorithm for bin stretching . , 41(4):343346 , 2013 .",
    "h.  kellerer , v.  kotov , m.  g. speranza , and z.  tuza .",
    "semi on - line algorithms for the partition problem . , 21:235242 , 1997 .    j.  ullman . . , 1971",
    "zobrist , albert l. a new hashing method with application for game playing .",
    "icca journal 13.2 : 69 - 73 .",
    "lower bound , scaled so that @xmath395 and @xmath396 .",
    "the vertices contain the current loads of all three bins , and a string ` n : i ` with @xmath29 being the next item presented by the adversary .",
    "if there are several numbers after ` n : ` , the items are presented in the given order , regardless of packing by the player algorithm .",
    "the coloured vertices are expanded in later figures . ]"
  ],
  "abstract_text": [
    "<S> online bin stretchingis a semi - online variant of bin packing in which the algorithm has to use the same number of bins as an optimal packing , but is allowed to slightly overpack the bins . </S>",
    "<S> the goal is to minimize the amount of overpacking , i.e. , the maximum size packed into any bin .    </S>",
    "<S> we give an algorithm for online bin stretchingwith a stretching factor of @xmath0 for three bins . </S>",
    "<S> additionally , we present a lower bound of @xmath1 for online bin stretchingon three bins and a lower bound of @xmath2 for four and five bins that were discovered using a computer search . </S>"
  ]
}