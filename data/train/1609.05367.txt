{
  "article_text": [
    "most state - of - the - art satisfiability checkers for propositional logic , also known as sat solvers , are based on variations of the davis - putnam - logemann - loveland ( dpll ) procedure  @xcite . during the last ten years , sat solvers have spectacularly progressed in performance thanks to better implementation techniques and conceptual enhancements , such as non - chronological backtracking and conflict - driven lemma learning , which in many instances of real problems are able to reduce the size of the search space significantly .",
    "thanks to those advances , nowadays best sat solvers can tackle problems with hundreds of thousands of variables and millions of clauses .",
    "these techniques have been adapted for more expressive ( yet decidable ) logics .",
    "for instance , in hardware and software verification applications , decision procedures for checking the satisfiability of quantifier - free first - order formulas with respect to background theories ( such as the integer or real numbers , arrays , bit vectors , etc ) have been developed .",
    "this is known as the sat modulo theories ( smt ) problem for a theory @xmath0 : given a formula @xmath1 , determine whether there is a model of @xmath2 .",
    "hence , an smt instance is a generalization of a boolean sat instance in which some propositional variables have been replaced by predicates from the underlying theories , and can contain clauses like , e.g. , @xmath3 , providing a much richer modeling language than is possible with sat formulas .",
    "although an smt instance can be solved by encoding it into an equisatisfiable sat instance and feeding it to a sat solver , currently most successful smt solvers are based on the integration of a sat solver and a @xmath0-solver , that is , a decision procedure for the given theory @xmath0 . in this so - called lazy approach , while the sat solver is in charge of the boolean component of reasoning , the @xmath0-solver deals with sets of atomic constraints in @xmath0 .",
    "the main idea is that the @xmath0-solver analyzes the partial model that the sat solver is building , and warns it about conflicts with theory @xmath0 ( @xmath0-inconsistency ) .",
    "see  @xcite for a survey on this approach .",
    "leveraging the advances made in sat solvers in the last decade , smt solvers have proved to be competitive with classical decision methods in many areas .",
    "see , e.g. , @xcite for an application of an smt solver on an optimization problem , being competitive with the best weighted csp solver with its best heuristic on that problem . in the spirit of bringing smt technology to other communities , in this paper",
    "we show how a non - trivial scheduling problem can be efficiently solved by using state - of - the - art smt solvers , and compare their performance to other approaches .",
    "the problem we deal with is a real - world cumulative scheduling problem , namely , the wastewater treatment plant problem ( wwtpp ) .",
    "this problem turns out to be a generalization of the preemptive cusp .",
    "the rest of the paper is organized as follows . in section  [ cusp ]",
    "we give some preliminaries on cumulative scheduling . in section  [ wwtpp ]",
    "we define the wwtpp and , in section  [ modeling ] we encode it by translation into sat modulo linear integer arithmetic and also into integer programming ( ip ) . in section  [ benchmarking ]",
    "we give computational results comparing the performance of different tools on the problem , both for real and random instances , which suggest that state - of - the - art smt solvers are competitive with best ip tools , and even better on difficult instances of this problem .",
    "for the sake of completeness , in section  [ cp ] the problem is encoded into many constraint programming ( cp ) dialects , preserving as much as possible the encoding given for smt .",
    "we give computational results showing that smt tools have far much better performance than cp tools on this problem .",
    "after this , in section  [ cum ] , a different encoding of the problem is discussed for the cp tools supporting the global cumulative constraint .",
    "overall conclusions and ideas for future work are given in section  [ conclusion ] .",
    "scheduling problems are prototypical np - complete real - world problems . roughly speaking",
    ", scheduling is the process of assigning scarce resources to tasks over time .",
    "it is not surprising , hence , that those problems have been addressed in a wide variety of research areas , and that they have been divided into different subclasses .",
    "many real - world scheduling problems fall into the cumulative scheduling class , where each resource may be shared between a bounded number of tasks  @xcite , in contrast with the disjunctive scheduling class , where each resource can execute at most one task at a time .",
    "another frequent differentiation is between preemptive and non - preemptive scheduling , depending on whether a task can be interrupted ( i.e. , subdivided ) or not .",
    "a very general problem in the cumulative scheduling class is the resource - constrained project scheduling problem ( rcpsp ) . in its non - preemptive version ,",
    "we have ( 1 ) a set of resources of given capacities , ( 2 ) a set of tasks of given durations , ( 3 ) an acyclic graph of precedence constraints between the tasks , and ( 4 ) for each task and each resource the amount of the resource required by the task over its execution .",
    "the objective is to find a start time assignment to the tasks that satisfies the precedences and resource capacity constraints , and minimizes the makespan ( i.e. , the time at which all tasks are completed ) . as a generalization of the job - shop scheduling problem , the decision variant of the rcpsp ( where what is required is to find an assignment whose makespan does not exceed a given deadline ) is np - complete in the strong sense and , hence , the rcpsp is np - hard in the strong sense  @xcite .",
    "see  @xcite for surveys .    due to the generality of the rcpsp ,",
    "many problems in the cumulative scheduling class are particular cases of it .",
    "this is the case for the so - called cumulative scheduling problem ( cusp ) , where we have ( 1 ) a single resource of given capacity and ( 2 ) a set of tasks , each one with a given duration , release time , deadline and resource capacity requirement , and we are asked to find an schedule satisfying all timing constraints and the resource capacity constraint  @xcite . as an extension of the parallel machine problem  @xcite ,",
    "this problem is also np - hard in the strong sense .",
    "most of the work on the rcpsp and the cusp has been devoted to the non - preemptive case ( note that the introduction of preemption increases the number of possible solutions ) .",
    "some relaxations of the cusp involving elastic tasks ( where , roughly , each task is only given a global amount of processing , and its duration and consumption is not fixed ) have been considered in  @xcite , but little work on the preemptive case can be found in the literature .",
    "see , e.g. , @xcite for the preemptive rcpsp and  @xcite for the preemptive cusp",
    ".    in this paper we deal with the wastewater treatment plant problem ( wwtpp ) , a real - world cumulative scheduling problem which is a generalization of the preemptive cusp .",
    "the treatment of the wastewater discharged by industries into the rivers is vital for environmental quality . for this purpose ,",
    "the wastewater is treated in wastewater treatment plants ( wwtp ) .",
    "a wwtp receives the polluted wastewater discharges coming from the city and different industries .",
    "nowadays the most common wastewater treatment is the activated sludge process .",
    "the system consists in an aeration tank in which the microorganisms responsible for treatment ( i.e. removal of carbon , nitrogen and phosphorous ) are kept in suspension and aerated followed by a liquid - solids separation , usually called secondary settler .",
    "finally a recycle system is responsible for returning a fraction of solids removed from the liquid - solids separation unit back to the reactor , whereas the other fraction is wasted from the system  @xcite .",
    "the treatment capacity of the plant is limited , and therefore all pollutants arriving at the wwtp should be under certain limits ; otherwise , the wastewater could not be fully treated and the river would be polluted . the hydraulic and contaminants capacity constraints that are defined according to its expected use ( industries and cities in the surroundings that generate the waste ) .",
    "currently , there exist regulations intended to achieve this goal by assigning a fixed amount of authorized discharges to each industry . however , they are not sufficient to guarantee the proper treatment of the wastewater .",
    "the problem is that , although these regulations enforce industries to respect the wwtp capacity thresholds , they do not take into account that simultaneous discharges by different industries may exceed the wwtp s thresholds . in such a case , no industry would be breaking the rules , but the effect would be to exceed the wwtp capacity .",
    "the scheduling problem faced in this domain is to distribute the industrial discharges over time so that all the water entering the wwtp can be treated .",
    "if the discharges are done without any coordination , the amount of water arriving at the wwtp can exceed its incoming water flow threshold , and cause the overflow to go directly to the river without being treated .",
    "moreover , if the contamination level of the water is too high , the microorganisms used in the cleaning process die , and the process has to stop until they are regenerated .",
    "thus , in order to prevent such dangerous situations , the industrial discharges should be temporally distributed so that all of them can be fully treated .    in this paper",
    "we address this problem , but taking into account only the water flow ( i.e. , without taking into account the contaminants ) .",
    "therefore we assume having a single resource of given capacity ( the wwtp ) and a set of tasks , each one with a given duration , release time , deadline and resource capacity requirement ( the discharges ) .",
    "note that we are asked to find a start time of each discharge between its release time and its deadline , such that , at any time , the sum of resource requirements of the discharges scheduled at that time does not exceed the wwtp capacity .",
    "one must assume , however , that there is some precedence relation ( presumably , a chain ) between the tasks of each single industry .",
    "hence , this problem is a generalization of the cusp , and a particular case of the rcpsp .",
    "we will focus on the decision variant of the problem , i.e. , in finding a feasible solution not exceeding an overall deadline , instead of in minimizing the makespan .",
    "this is because , in the real problem we address , it is sufficient that all discharges are rescheduled within the same day for which they were originally scheduled ( and , in fact , the minimization of the makespan may not be good for the wwtp , as it is preferably , for the microorganisms functioning , that the discharges are homogeneously distributed along the time )",
    ". then we have that the problem is np - complete , as it is in np ( as a particular case of the decision variant of the rcpsp ) and it is np - hard ( as a generalization of the decision variant of the cusp ) .",
    "let us mention that a relaxed version of the wwtpp , where there is no deadline and conflicts are solved by a recurrent auction mechanism , has been addressed in  @xcite .    since the delays introduced in the discharges ( in order to find a feasible schedule ) should not stop or delay the production processes of the industries , the idea is to keep those discharges temporarily in a retention tank in the industry itself , and to throw them to the river later on .",
    "this approach , however , brings us to a preemptive framework , since one can reasonably assume that a discharge coming from a tank can be interrupted ( i.e. , the tank can be emptied at disjoint intervals ) .",
    "hence , that problem has the preemptive cusp as a particular case ( where , in the cusp , each task corresponds to a discharge from a different industry , having a retention tank of sufficient capacity to hold the discharge and an output rate equivalent to the one of the discharge ) , and is np - hard as well .",
    "therefore , we define the wastewater treatment plant problem as follows .      an instance of the wastewater treatment plant problem ( wwtpp ) is given by ( 1 ) a single resource of given capacity , ( 2 ) a set of tasks , each one with a given duration , release time and resource capacity requirement , ( 3 ) a chain - like precedence relation between the tasks , ( 4 ) for any such chain of tasks , a buffer ( or retention tank ) of given capacity and output rate ( we assume that the input rate is flexible ) and ( 5 ) an overall deadline ( greater than all release times ) .    the question is to find an schedule where ( 1 ) each task is either scheduled at its release time ( and does not exceed the deadline ) , or else it is redirected to its corresponding buffer with a volume equal to its resource capacity requirement multiplied by its duration , ( 2 ) the capacity of each buffer is not exceeded at any time , ( 3 ) each buffer is emptied , preemptively , at its corresponding rate , ( 4 ) each buffer is empty at the deadline , and ( 5 ) at any time , the sum of required capacities of the tasks scheduled at that time , together with the required capacities of the emptying of the buffers at that time , does not exceed the capacity of the single resource .",
    "notice that nothing prevents a buffer from being emptied and filled at the same time , and also from being emptied at the same time at which one of the tasks is scheduled .",
    "in this section we give an encoding of a wwtpp instance into a sat modulo unquantified linear integer arithmetic ( lia ) instance .",
    "as we will see , sat modulo lia nicely captures all constraints .",
    "afterwards we translate this encoding into an integer programming problem , with the aim of comparing the performance of state - of - the - art solvers on both approaches .",
    "a wwtpp instance can be easily codified as a sat modulo unquantified linear integer arithmetic instance as follows .",
    "we have the following non - negative integer constants :    * @xmath4 denotes the capacity of the wastewater treatment plant at each time period . *",
    "given a set of @xmath5 industries , @xmath6 and @xmath7 denote respectively the capacity and the emptying rate of the buffer associated to industry  @xmath8 , @xmath9 .",
    "* given a set of discharges from @xmath5 industries to be scheduled within @xmath10 time periods , @xmath11 denotes the scheduled flow of discharge for industry @xmath8 during time period @xmath12 , @xmath13 .",
    "given a set of discharges from @xmath5 industries to be scheduled within @xmath10 time periods , we have the following integer variables @xmath14 :    * for every @xmath15 , @xmath16 denotes the actual `` capacity requirement '' of industry @xmath8 during time period @xmath12 , corresponding to a scheduled discharge .",
    "that is , for every @xmath15 , either @xmath17 , or @xmath18 and the discharge is redirected to that industry s buffer .",
    "* @xmath19 denotes the flow discharged from buffer ( of industry ) @xmath8 during time period @xmath12 . *",
    "@xmath20 denotes the flow stored in buffer @xmath8 at the end of time period @xmath12 .",
    "@xmath21    @xmath22    in constraints  [ 2 ] and  [ 3 ] , the difference @xmath23 is replaced by @xmath24 if @xmath25 ( recall that variables @xmath16 have been defined only for corresponding constants @xmath15 ) .",
    "@xmath26    for every discharge from an industry @xmath8 , spanning from time period @xmath27 to time period @xmath28 , we state : @xmath29    finally , the following ( obvious ) redundant constraints can be added in order to help orienting the search :    @xmath30    constraints  [ 1 ] state that the capacity of the wwtp is not exceeded at any time .",
    "constraints  [ 2 ] and  [ 3 ] define the amount of water inside every buffer at every time interval , taking into account the amount of water inside each buffer at the previous time interval , and the current output and input flows for this buffer",
    ". constraints  [ 4 ] require the capacity of each buffer not being exceeded at any time , and constraints  [ 5 ] impose all buffers being empty at the deadline . constraints from  [ 6 ] to  [ 9 ] are restrictions on the output flow from the buffers ( or retention tanks ) : the output flow at the first time interval must be zero ( as the buffer is empty ) and , at subsequent time intervals , it can be either zero , or it can be equal to the tank flow ( provided that there is enough water inside the buffer ) or it can be equal to the remaining water inside the buffer if this is less or equal than the tank flow",
    ". constraints  [ 10 ] express the dichotomy of throwing each discharge to the river or redirecting it to a buffer .    constraints  [ 11 ] and  [ 12 ] are unnecessary , but have proved to be helpful in our experiments . notice that , although the value of the @xmath31 variables is perfectly defined by constraints  [ 6 ] to  [ 9 ] , restricting the domain of the @xmath31 variables can help in the search for solutions .      in order to obtain an ip instance from the previous smt instance , we need to convert logical combinations of linear constraints into conjunctions of linear constraints .",
    "we use standard transformations like the ones of  @xcite .",
    "we define , @xmath32 , zero - one variables @xmath33 denoting whether discharge from industry @xmath8 at time period @xmath12 is actually scheduled or else redirected to a buffer .",
    "then we replace @xmath16 with @xmath34 inside constraints  [ 1 ] ,  [ 2 ] and  [ 3 ] .",
    "constraints  [ 4 ] , [ 5 ] and [ 6 ] remain the same .",
    "the zero - one variables @xmath33 allow constraint  [ 10 ] to be translated into @xmath35 this can then be encoded as a conjunction of linear constraints by defining additional zero - one variables @xmath36 for every discharge from an industry @xmath8 spanning from time period @xmath27 to time period @xmath28 , and stating : @xmath37    the disjunction of constraints  [ 7 ] , [ 8 ] and  [ 9 ] can be expressed as @xmath38 where @xmath39 , @xmath40 and @xmath41 are again zero - one variables , and @xmath42 then constraints  [ 15 ] , [ 16 ] and  [ 17 ] can be transformed into a conjunction of linear constraints by using @xmath43 like constraints .",
    "constraints is the following : a disjunction like , e.g. , @xmath44 , where @xmath28 is a propositional variable , can be converted into @xmath45 , where @xmath46 denotes an upper bound of @xmath47 . ] this way , constraint  [ 15 ] becomes @xmath48 and constraint  [ 16 ] becomes @xmath49 notice that these constraints work in conjunction with constraints  [ 11 ] , which are mandatory here : on the one hand , from  [ 19 ] we get @xmath50 whenever @xmath51 , which together with @xmath52 ( from  [ 11 ] ) gives us @xmath53 as we need ; on the other hand , from  [ 20 ] we get @xmath54 whenever @xmath55 , which together with @xmath56 ( from  [ 11 ] ) gives us @xmath57 as we need .    finally , constraint  [ 17 ] becomes @xmath58 constraints  [ 12 ] are mandatory for similar reasons as before , since they work in conjunction with  [ 22 ] .",
    "here we comment on some benchmarking we did , showing that state - of - the - art smt solvers outperform best ip solvers with the previous modeling of the wwtpp .",
    "we worked with two sets of benchmarks , one coming from real data and another coming from randomly generated data .    in the real set of benchmarks we used data coming from 8 industries ( each one having its own retention tank ) , with a total of 94 discharges planned within a period of 24 hours .",
    "we took a time discretization of one hour and an overall deadline of 24 hours for the schedule .",
    "different problem instances were generated with different capacities of the wastewater treatment plant , ranging from 2000 units to 10000 , at increments of 20 .",
    "this way , an easy - hard - easy transition was observed ( as already noted by  @xcite for similar scheduling problems ) with a transition from unsatisfiability to satisfiability taking place at 5000 units of capacity .    for the random set of benchmarks we considered a total of 114 discharges from 10 industries ( having again each one an associated retention tank ) , all of them being planned within a period of 24 hours .",
    "although randomly generated , both the magnitude and duration of the discharges and the size of the retention tanks was restricted to be within reasonable limits .",
    "we took a time discretization of one hour and an overall deadline of 26 hours for the schedule . from this",
    "data different problem instances were generated , with a capacity of the wastewater treatment plant ranging from 5000 to 30000 units , at increments of 100 , resulting into a transition from unsatisfiability to satisfiability at 14500 units .",
    "all the benchmarks , written according to the modeling of subsection  [ smtmodeling ] in the smt - lib standard language , were submitted the last year to the smt library , and some of them were chosen for the annual smt competition in the corresponding category .",
    "table  [ naive_ip ] shows the percentage of solved benchmarks and the total time spent by ibm ilog cplex 11 , z3.2@xmath59 ( smt - comp08 qf_lia division winner ) and yices 2 ( smt - comp09 qf_lia division winner ) , with a time out of 1800 seconds for each instance in the real set , and of 300 seconds in the random set .",
    "all benchmarks were executed on a 3.80  ghz intel xeon machine with 3.5 gb of ram running under gnu / linux 2.6 . the modeling given in subsection  [ ipmodeling ]",
    "was used for cplex .",
    "as it can be seen , state - of - the - art smt solvers clearly outperform cplex on this benchmarks .",
    "it is specially remarkable that yices solves all the benchmarks , and z3 only fails in solving one from the real set around the phase transition .",
    "moreover , yices is able to solve all the 251 benchmarks from the random set in only 5.15 seconds , being almost insensitive to the phase transition .",
    "cplex , although it has very good performance in many instances , it fails to solve some of them around the phase transition . since smt solvers ,",
    "like it does cplex , use a simplex procedure for handling atomic linear constraints , other elements of smt technology such as conflict - driven lemma learning , backjumping or restarts can be playing a central role in this problem .",
    "it is worth noting that worse results are obtained by cplex if no objective function is used . after trying with several objective functions",
    ", we obtained the best results by minimizing the sum of buffer contents .",
    "this somehow corresponds to an eager strategy consisting in avoiding the use of buffers if possible ( and hence prioritizing discharges of wastewater at their preliminarily scheduled times ) and emptying the buffers as soon as possible .",
    "notice however that no objective function or user - given search strategy is possible with smt solvers , which are completely black - box for the user and , still , better results are obtained .",
    "for the sake of completeness , in this section we detail the results obtained with several constraint programming ( cp ) tools on our benchmarks .    in order to do the benchmarking",
    ", our modeling needs to be translated into several cp dialects . for the comparison to be fair ,",
    "in all cases we must choose an encoding as similar as possible to the one described in subsection  [ smtmodeling ] .",
    "this implies avoiding the use of global constraints and sophisticated search strategies that can be available in cp tools .",
    "for this reason , we have only used labeling strategies .",
    "results on a different encoding , using the cumulative global constraint , are given in the next section .",
    "since the translation of the encoding described in subsection  [ smtmodeling ] into a cp program over finite domains is almost direct , the encodings obtained for each cp tool are very similar and hence we do not detail them here . moreover , for solvers providing a flatzinc front - end , we have used the same minizinc model : minizinc  @xcite proposes to be a standard cp modeling language that can be translated into an intermediate language called flatzinc .",
    "flatzinc instances can be obtained from minizinc instances by using the minizinc - to - flatzinc translator mzn2fzn , and then can be plugged into any solver providing an specialized front - end for flatzinc .",
    "table  [ naive_cp ] shows the results obtained by several cp solvers on the benchmarks described in section  [ benchmarking ] , except for the last two entries , which show the results obtained by the same smt solvers used in section  [ benchmarking ] , but where smt instances have been obtained from flatzinc instances through an experimental compiler fzn2smt .",
    "the table refers only to the solving time ( we do not include translation times since we are interested in comparing solving times , regardless of the input language ) .",
    "all benchmarks were executed on a 3  ghz intel core 2 duo machine with 1 gb of ram running under gnu / linux 2.6 .    at a first glance we can observe that smt solvers are far better than other tools on these benchmarks .",
    "it is remarkable that , after the two step translation from minizinc - to - flatzinc - to - smt , we obtain similar ( and in some case even better ) results to the ones in section  [ benchmarking ] .",
    "we tried different labeling strategies with cp solvers , but almost identical results were obtained . hence , unless contrarily indicated , the results in table  [ naive_cp ] are for the default strategy , which is usually first - fail : selecting the leftmost variable with smallest domain next , in order to detect infeasibility early .",
    "this is often a good strategy .",
    "however , with sicstus prolog we obtained significantly better results when using the max and down options : selecting the leftmost variable with the greatest upper bound next , and exploring its domain in descending order . in our program , this translates to a strategy consisting in giving priority to the biggest discharges , and keeping them in buffers as least as possible .",
    "notice that this roughly coincides with the objective function giving best results in the ip approach of section  [ benchmarking ] .",
    "the concrete versions of the cp solvers we used are : sicstus prolog 4.0.1 ( for the first entry in the table ) , sicstus prolog 4.1.1 ( with flatzinc support , for the minizinc case ) , comet 2.0 , minion 0.9 , g12 minizinc 1.0.3 , gecode 3.2.2 , and ecl@xmath60ps@xmath61 6.0 . for the case of minion , we used tailor as a translator from the essence  @xcite high - level language to the minion language , in the same spirit of using the minizinc - to - flatzinc translator mzn2fzn .",
    "this allowed us to use an almost identical model .",
    "comet already supports a high - level language which allowed us to express the constraints in a very similar way .",
    "moreover , for the case of comet we tried both the cp engine and the lp engine , with no clear winner .",
    "we want to remark that we are aware of ibm ilog cp optimizer , which uses constraint programming to solve detailed scheduling problems and combinatorial problems not easily solved using mathematical programming methods .",
    "unfortunately we were not able to test this tool on our benchmarks , since the trial version has severe limitations in the number of variables and in the number of allowed constraints .",
    "an alternative approach is to solve the wwtpp by exploiting the use of the cumulative constraint within a cp system , since this constraint is closely related to our problem .",
    "many cp systems , such as chip v5 , ecl@xmath60ps@xmath61 , b - prolog and sicstus prolog , include the ` cumulative ` global constraint in their finite domain library .",
    "this constraint was originally introduced into the chip programming system to describe and solve complex scheduling problems @xcite .",
    "its habitual syntax is ` cumulative(starts , durations , resources , limit ) ` , where ` starts ` , ` durations ` , and ` resources ` are lists of integer domain variables or integers of the same length , and ` limit ` is an integer .",
    "the declarative meaning is : if the lists denote respectively the start times , durations and resource capacity requirements of a set of tasks , then the sum of resource usage of all the tasks does not exceed ` limit ` at any time .",
    "one should expect that , by using this constraint adequately , the performance of a cp system on the previous problem will be better ( or , at least , not worse ) than if not using it .",
    "our modeling using the cumulative constraint goes as follows .",
    "given a discharge @xmath8 of duration @xmath62 and resource capacity requirement @xmath63 , since it can either go directly to the river or be redirected to a retention tank of certain output rate @xmath64 , we create a set of new @xmath65 discharges of duration @xmath66 and capacity requirement @xmath64 , and one discharge of duration @xmath66 and non - negative requirement capacity @xmath67 ( the remainder ) , such that @xmath68 .",
    "observe that by dividing the discharges into a number of discharges of duration @xmath66 we get rid of preemption .",
    "then , by using reified constraints , we state that the capacity requirements of those @xmath69 new discharges is actually @xmath24 if and only if the associated original discharge @xmath8 goes to the river .",
    "notice that a set of remainders ( each of them coming from a different original discharge of the same industry ) could eventually be redistributed , forming a new set of discharges of resource capacity @xmath64 plus one single remainder .",
    "however , such redistribution should be made for the remainders being available at each time , i.e. , dynamically , and this does not go in the direction of an encoding using the cumulative constraint , which requires a fixed set of resources . therefore , here we do not consider the possibility of redistributing the remainders .",
    "although this is a inexact formulation of the problem , in practice it results a very few times in a smaller set of solutions than with the encoding used in the previous sections . and , in any case , since this simplification results in a smaller search space , it is likely to favour this approach",
    "then , apart from stating the obvious release time , precedence and finishing time constraints , we use the cumulative constraint two - fold . on the one hand",
    ", we use it in order to assure that the wwtp capacity is not exceeded . on the other hand ,",
    "we use it in order to assure that the output rate and capacity of every retention tank is not exceeded .",
    "this second use implies stating two cumulative constraints for each industry , in the following way :    let ` [ i1,  ,in ] ` be a list with the initial times of the discharges kept in the retention tank of a industry , let ` [ h1,  ,hn ] ` be the times at which they are respectively flushed out from the tank , let ` [ c1,  ,cn ] ` be their resource capacity requirements , let ` r ` be the output rate of the tank , and let ` c ` be the capacity of the tank",
    ". then we state    cumulative([h1, ",
    ",hn],[1,  ,1],[c1,  ,cn],r )    in order that the output rate of the tank is not exceeded , and    cumulative([i1 ,  , in],[h1-i1,  ,hn - in],[c1, ",
    ",cn],c )    in order that the capacity of the tank is not exceeded .",
    "finally , for symmetry breaking , we state ordering constraints between ( indistinguishable ) discharges from each retention tank .",
    "since all these discharges are of duration @xmath66 , this improvement dramatically reduces the search space .",
    "table  [ cumulative ] shows the results obtained by the cp solvers supporting the cumulative global constraint on the same benchmarks as in the previous sections .",
    "again , we used the possibility of sharing a unique minizinc model , except for the first entry , where we directly built a prolog program . we can observe that , in general , the results are better than with the previous encoding for the same cp solvers ( with the only exception of g12 in the random set ) .",
    "however , these results are still far from the ones obtained by smt solvers .",
    "this can be due to the fact that we are using two cumulative constraints for each industry ( for assuring , respectively , that the output rate and the capacity of each retention tank is not exceeded ) , plus one cumulative global constraint ( for assuring that the wwtp capacity is not exceeded ) and , moreover , we are using many reified constraints ( for the dichotomy of sending the discharges either to the river or to a retention tank ) , making thus difficult for the cp solvers to take profit of their algorithms for the cumulative constraint .",
    "in this paper we have presented the wastewater treatment plant problem ( wwtpp ) , a real problem in the cumulative scheduling class , and have compared several techniques for solving it .",
    "the encoding of the wwtpp into sat modulo linear integer arithmetic , and using a high - performance smt solver as a black - box for solving it , has turned out to be one of the best approaches .",
    "specifically , we have seen that state - of - the - art smt solvers are competitive with current best ip solvers , en even better on difficult instances of this problem ( i.e. , the ones around the phase transition ) .",
    "we think that this is a new result in the direction of showing that current smt solvers are ready to solve real problems outside the verification area , and that they provide a nice compromise between expressivity and efficiency for scheduling problems .",
    "let us recall that smt solvers , like ip tools , use a simplex procedure for handling atomic linear constraints .",
    "however , the particular treatment of bound constraints of the form @xmath70 or @xmath71 inside a simplex procedure like the one of yices , must be a key ingredient for the good results obtained in this problem by this solver ( notice that many constraints in this problem are of this form ) . also , we think that usual smt techniques such as backjumping , restarts , and conflict - driven lemma learning must be a key ingredient for the good results obtained around the phase transition",
    ".    moreover , in our point of view , the encoding of the wwtpp as an smt problem is simpler than as an ip problem ( where logical combinations of linear constraints must be translated into conjunctions of linear constraints , with the addition of zero - one variables ) . compared to cp , the smt approach is not that simple ( since most cp tools provide a high - level language front - end ) , but far more efficient .",
    "the performance of smt solvers on this problem is still more significant if we take into account that they are completely black - box , and one can not provide neither labeling strategies nor local search algorithms for guiding the search .",
    "it was not our aim to find specialized algorithms for this problem , but to solve it from a non - expert perspective . in this sense , from our result it follows that compilers translating from a high - level language to smt would be desirable , especially for people having no experience with constraint satisfaction problems .",
    "let us recall , that , after a two step translation from minizinc - to - flatzinc - to - smt , we obtained similar ( and in some case even better ) results to the ones with a direct smt encoding .",
    "hence , we think that user - friendly and at the same time competitive cp tools could arise from such or similar combinations .",
    "in fact , some research has already been done in this direction .",
    "for instance , in  @xcite , excellent results have been obtained on benchmarks from the csplib  @xcite , after modeling them in a high - level language and automatically translating them into sat modulo unquantified linear integer arithmetic .",
    "the fzn2smt compiler is a new tool in the same direction .    on the other hand , as pointed out in  @xcite , for dense difference logic problems such as the ones coming from scheduling , there is still room for improvement in the context of smt .",
    "although such an improvement could be done in the solvers for the usual smt theories , an alternative interesting thing to do would be to implement , e.g. , a solver for the theory of cumulative , to be used with a modular smt solver like the ones based on the dpll(x ) approach  @xcite .",
    "notice that this combination would give us a framework similar to the one of constraint programming , but with backjumping and learning .",
    "in fact , excellent results have been recently obtained in  @xcite by modeling the cumulative constraint by descomposition , and by exploiting the autonomous search and learning capabilities of a sat solver in a way which resembles what is done in smt .",
    "this makes us expect good performance results for smt solvers in constraint satisfaction problems if backtrackable and incremental solvers for theories like cumulative , alldifferent , etc , are developed . in this sense , we totally agree with challenge  12 in  @xcite : to develop an smt system with the advantages of one of cp s sophisticated global constraint propagation algorithms and the robustness and efficiency of sat s backjumping , lemmas and heuristics , by expressing the global constraints as a theory .",
    "ian  p. gent and toby walsh .",
    "@xmath72 : a benchmark library for constraints . in _",
    "5th international conference on principles and practice of constraint programming , cp99 _ , volume 1713 of _ lncs _ , pages 480481 .",
    "springer , 1999 .",
    "v.  muoz , j.  murillo , d.  busquets , and b.  lpez .",
    "improving water quality by coordinating industries schedules and treatment plants . in _",
    "aamas workshop on coordinating agents plans and schedules ( caps ) _ , 2007 .",
    "robert nieuwenhuis , albert oliveras , enric rodrguez - carbonell , and albert rubio . .",
    "in _ 18th international conference on rewriting techniques and applications , rta07 _ , volume 4533 of _ lncs _ , pages 218 .",
    "springer , 2007 .",
    "nicholas nethercote , peter  j. stuckey , ralph becket , sebastian brand , gregory  j. duck , and guido tack .",
    "minizinc : towards a standard cp modelling language . in _",
    "13th international conference on principles and practice of constraint programming , cp07 _ , volume 4741 of _ lncs _ , pages 529543 .",
    "springer , 2007 .",
    "andreas schutt , thibaut feydy , peter  j. stuckey , and mark wallace . why cumulative decomposition is not as bad as it sounds . in _",
    "15th international conference on principles and practice of constraint programming , cp09 _ , volume 5732 of _ lncs _ , pages 746761 .",
    "springer , 2009 ."
  ],
  "abstract_text": [
    "<S> in this paper we introduce the wastewater treatment plant problem , a real - world scheduling problem , and compare the performance of several tools on it . </S>",
    "<S> we show that , for a naive modeling , state - of - the - art smt solvers outperform other tools ranging from mathematical programming to constraint programming . </S>",
    "<S> we use both real and randomly generated benchmarks .    from this and similar results , </S>",
    "<S> we claim for the convenience of developing compiler front - ends being able to translate from constraint programming languages to the smt - lib standard language . </S>"
  ]
}