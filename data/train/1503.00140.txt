{
  "article_text": [
    "[ [ byzantine - processes - and - self - stabilization ] ] byzantine processes and self - stabilization + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    algorithms that tolerate byzantine faults are of extreme interest , as they can tolerate malicious takeovers of portions of the system , and still achieve the desired goal .",
    "moreover , as the program executed by several of the participants may include programming mistakes , it is possible that these participants will ( unintentionally ) behave in a malicious way .",
    "obviously , when all participants exhibit byzantine arbitrary behavior , the system output will be arbitrary too .",
    "usually , lower bounds on the number of byzantine participants are used as part of the algorithm design assumptions .",
    "the cases in which the lower bound is not respected are not considered , as the system can reach an arbitrary configuration due to the possibly overwhelming malicious actions .",
    "assume that some of the byzantine participants regain consistency ( possibly by rebooting , running anti - virus software , environment change ) so that the assumed threshold on the number of byzantine participants is now respected .",
    "will the system regain consistency , from this arbitrary configuration ? or in other words will the system stabilize to a correct behavior ?",
    "[ [ related - work - and - aim - of - the - paper ] ] related work and aim of the paper + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    an active research area concerns the construction of a byzantine - tolerant disk storage ( e.g.,@xcite to cite a few ) .",
    "many of these papers consider registers built on top of duplicated disks ( servers ) , which are accessed by clients , and where disks and clients may exhibit different type of failures .",
    "the construction of a reliable shared memory on top of a byzantine message - passing system is addressed in  @xcite .",
    "recently , several works investigated stabilizing byzantine algorithms e.g. ,  @xcite .",
    "the first of these papers is the most related to our research , as it constructs a stabilizing byzantine multi - writer multi - reader regular register , where @xmath3 out of @xmath0 servers ( with @xmath4 ) can be byzantine .",
    "such a construction relies on the _ write operation quiescence _ assumption , i.e. , it is assumed that , after a burst of write operations executed by the writer , there exists a sufficiently long period during which the writer does not invoke the write operation .",
    "differently , we construct a _ practically stabilizing byzantine multi - writer multi - reader atomic _",
    "register in a client / server system which is able to tolerate transient failures and up to @xmath3 byzantine servers . given @xmath3 ,",
    "our solutions require @xmath5 servers when client / server communication is asynchronous , and only @xmath6 servers when it is synchronous .",
    "this gap comes from the fact that , as they provide bounds on message transfer delays , synchronous settings allows readers and writers to use timers . as far as we known , our construction is the first that builds a distributed atomic read / write memory on top of asynchronous servers , which communicate by message - passing , can suffer transient failures , and where some of them can exhibit a byzantine behavior .",
    "[ [ roadmap ] ] roadmap + + + + + + +    the paper is made up of  [ sec : conclusion ] sections . the computing model and",
    "the problem which is addressed are presented in section  [ sec : model - and - pb ] .",
    "then , section  [ sec : regular - algorithm ] presents and proves correct an algorithm that builds a stabilizing single - writer single - reader ( swsr ) regular register .",
    "this algorithm is extended in section  [ sec : practically - atomic ] to obtain an swsr atomic register , and section  [ sec : single - to - multi ] shows how to go from `` single - reader '' to `` multi - reader '' and from `` single - writer '' to `` multi - writer '' .",
    "finally section  [ sec : conclusion ] concludes the paper . due to page limitation",
    ", the synchronous communication case and proofs can be found in appendices .",
    "[ [ basic - system - model ] ] basic system model + + + + + + + + + + + + + + + + + +    the basic system model we consider consists of @xmath7 asynchronous sequential processes .",
    "one of them is called `` writer '' ( denoted @xmath8 ) , another is called `` reader '' ( denoted @xmath9 ) , while the @xmath0 others are called `` servers '' ( denoted @xmath10 , ... , @xmath11 ) .    from a communication point of view , there are @xmath12 directed asynchronous communication links , connecting each server to @xmath8 and @xmath9 ( one in each direction ) .",
    "each link is fifo and reliable ( neither loss , corruption , duplication , nor creation of messages ) .",
    "it is assumed that processing times are negligible , and are consequently assumed to take zero time .",
    "only message transfers takes time .",
    "this basic model will be later enriched in two directions : one concerning client processes to have @xmath13 reader / writer processes , and a second concerning the synchrony of the communication links .",
    "[ [ failure - model ] ] failure model + + + + + + + + + + + + +    at most @xmath1 servers can commit byzantine failures or @xmath9 .",
    "in fact , in any case , the system is guaranteed to converge to exhibit the desired behavior once the assumptions concerning the system hold again for a `` long enough '' period of time . ] .",
    "let us remember that a server commits a byzantine failure when it behaves arbitrarily  @xcite .",
    "classical examples of a byzantine behavior consists in sending erroneous values , not sending a message when this should be done , stopping its execution , etc .",
    "in addition to the possibility of byzantine servers , the local variables of any process ( writer , reader , servers ) can suffer transient failures .",
    "this means that their values can be arbitrarily modified  @xcite .",
    "it is nevertheless assumed that there is a finite time @xmath14 ( which remains always unknown to the processes ) after which there are no more transient failures .    from a terminology point of view , a server is _ correct _ if it does not commit byzantine failures .",
    "hence , as the reader and the writer , any correct server can suffer transient failures .",
    "[ [ configurations - and - executions ] ] configurations and executions + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each process ( writer , reader , or server ) is a state machine , enriched with the operations send and receive .",
    "its state ( called `` local state '' ) is defined by the current values of its local variables .",
    "the state of a directed link consists of the messages that have been sent on this link , and are not yet received .    a configuration ( or global state )",
    "is composed of the local state of each process and the state of each link . due to the `` transient failures '' behavioral assumption",
    ", the initial configuration can be arbitrary .",
    "[ [ underlying - ss - broadcast - abstraction ] ] underlying ss - broadcast abstraction + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    it is assumed that the system has a built - in communication abstraction , denoted ss - broadcast , that provides the reader and the writer with an operation denoted @xmath15 , and each server with a matching operation denoted @xmath16 .",
    "when the reader or the writer ( resp . , server ) uses this broadcast abstraction , we consequently say that it `` ss - broadcasts '' ( resp .",
    ", `` ss - delivers '' ) a message .",
    "this communication abstraction is defined by the following properties .    * _ termination_. if the reader or the writer invoke @xmath17 then such invocation terminates . *",
    "_ eventual delivery_. if the reader or the writer invokes @xmath17 then every correct server eventually ss - delivers @xmath13 . * _ synchronized delivery_. if a process @xmath18 ( reader or writer ) invokes @xmath17 at time @xmath19 and returns from this invocation at time @xmath20 , then there exists a set @xmath21 of @xmath22 correct servers , such that , for each @xmath23 , there exists a time @xmath24 such that @xmath25 at which @xmath26 executed @xmath27 .",
    "* _ no duplication_. an invocation of @xmath17 by a process @xmath28 ( reader or writer ) results in at most one @xmath29 at any correct server @xmath26 . *",
    "_ validity_. if a correct server @xmath26 ss - delivers a message @xmath13 from @xmath28 ( reader or writer ) , then either @xmath28 ss - broadcasts @xmath13 , or @xmath13 belongs to the initial state of the corresponding link . * _ order delivery_. any correct server ss - delivers the messages ss - broadcast by a process @xmath18 ( reader or writer ) in the order in which they have been ss - broadcast .",
    "implementations of such a broadcast abstraction are presented in section 4.2 of  @xcite , ( see also  @xcite ) .",
    "they rely on bounded capacity communication links send operation is invoked by a correct process @xmath30 to a correct process @xmath31 , @xmath30 repeatedly send the packet @xmath32 to @xmath31 until receiving @xmath33 packets from @xmath31 ( where @xmath34 is the maximal number of packets in transit from @xmath30 to @xmath31 and back ) .",
    "then @xmath30 repeatedly sends the packets @xmath35 to @xmath31 until receiving @xmath33 packets from @xmath31 . process",
    "@xmath31 sends @xmath36 only when receiving @xmath37 , and executes @xmath29 when receiving the packet @xmath35 immediately after receiving the packet @xmath32 . ] .",
    "[ [ construction - of - a - readwrite - register - and - assumptions ] ] construction of a read / write register and assumptions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the problem in which we are interested is the construction of a stabilizing server - based atomic register @xmath38 , that can be written by the writer @xmath8 , and read by the reader @xmath9 . from an abstraction point of view",
    ", the register provides the writer with an operation @xmath39 , where the input parameter @xmath40 is the new value of the register , and the reader with an operation @xmath41 , which returns the value of the register .",
    "the construction is done incrementally .",
    "a regular register is first built .",
    "then this construction is enriched to obtain an atomic register .",
    "both constructions assume that ( a ) there is a time after which there is no more transient failures ( instant @xmath14 ) , and ( b ) the writer invokes at least once the @xmath42 operation after @xmath14 . according to case ( b ) , let @xmath43 be the time at which the first write invoked after @xmath14 terminates .",
    "[ [ concurrent - operations - read - and - write - sequences ] ] concurrent operations , read and write sequences + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let @xmath44 and @xmath45 be the executions of a @xmath46 operation by the writer and @xmath47 operation by the reader , respectively . if @xmath44 and @xmath45 overlap in time , they are said to be _",
    "concurrent_. if they do not overlap , they are said to be _",
    "sequential_.    let us observe that , as the writer @xmath8 ( resp .",
    ", reader @xmath9 ) is sequential , the set of invocations of the operation @xmath42 ( resp . , @xmath41 )",
    "defines a sequence @xmath48 ( resp . , @xmath49 ) .",
    "[ [ stabilizing - regular - register ] ] stabilizing regular register + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a _ regular _ read / write register is defined by the following properties .    * _ liveness_. any invocation of @xmath46 or @xmath47 terminates . * _ eventual regularity_. there is a finite time @xmath50 after which each @xmath47 @xmath45 returns a value @xmath40 that was written by a @xmath46 operation @xmath44 that is ( a ) the last write operation executed before @xmath45 , or ( b ) a write operation concurrent with @xmath45 .",
    "let us observe that , as there is at least one invocation of @xmath46 ( assumption ) , and any invocation of @xmath46 terminates ( liveness ) , @xmath51 exists .",
    "let us also observe that , before @xmath52 , read operations can return arbitrary values .",
    "if a read / write register is regular , we say that the value returned by each of its read operations is regular .",
    "the duration @xmath53 is the time needed for the system to stabilize .",
    "after @xmath52 , no invocation of @xmath47 returns an arbitrary value .",
    "but , while after @xmath52 regularity prevents @xmath38 from returning too `` old '' values , it still allows @xmath38 to return values in an order different from their writing order , as described in figure  [ fig : new - old - inversion ] . the first read returns the value @xmath54 ( whose write is concurrent with it ) , while the second read returns the value @xmath55 ( which was the last value written before it starts ) .",
    "this phenomenon is known under the name `` new / old inversion '' .",
    "[ [ stabilizing - atomic - register ] ] stabilizing atomic register + + + + + + + + + + + + + + + + + + + + + + + + + + +    such a register is a stabilizing regular register that , after some time , does not allow new / old inversion .",
    "it is defined by the following properties .",
    "* _ liveness_. any invocation of @xmath46 or @xmath47 terminates . * _ eventual atomicity_. there is a finite time @xmath50 after which any invocation of @xmath47 returns a regular value , and there are no two invocations of @xmath47 that return new / old inverted values .",
    "informally , this means that it is possible to merge sequences @xmath48 and @xmath49 to obtain a sequence @xmath21 where , after time @xmath52 , each read operation returns the last value written by the closest write operation that precedes it .    [ [ notation - and - other - readwrite - registers ] ] notation and other read / write registers + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the previous registers are called stabilizing regular ( or atomic ) single - writer single - reader ( swsr ) registers . the swsr atomic register will be used in section  [ sec : single - to - multi ] as a building block to construct stabilizing atomic single - writer multi - reader ( swmr ) registers , and stabilizing atomic multi - writer multi - reader ( mwmr ) registers .",
    "this section presents a stabilizing algorithm that implements a single - writer single - reader regular register in the system model introduced in section  [ sec : model ] .",
    "the algorithms implementing the operations @xmath46 , @xmath47 , and the behavior of the servers @xmath26 , is described in figure  [ algo : swsr - regular ] .",
    "the writer and the reader terminate their operations when they execute the statement @xmath56 ( line  [ ns - byz-06 ] for the writer , and lines  [ ns - byz-13 ] or  [ ns - byz-15 ] for the reader ) .",
    "[ [ local - variables - and - update - messages ] ] local variables and update messages + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each server @xmath26 , @xmath57 , manages two local variables , which locally define its internal representation of the constructed regular register @xmath38 .    *",
    "the aim of the variable @xmath58 is to store the last value written by the writer , as known by @xmath26 . to that end , when it invokes @xmath59 , the writer ss - broadcasts the message write @xmath60 to inform the servers of the new value @xmath40 . *",
    "the aim of the variable @xmath61 is to contain the last value ss - broadcast by the writer to each server @xmath26 , when identifying that the reader requests assistance as write operations are too frequent .",
    "this variable is reset to @xmath62 at the beginning of every new read",
    ".    there is no specific local variable managed by the writer . as far as the reader is concerned , it has to manage a single local variable .",
    "* @xmath63 is a boolean flag , that , when true , demands each server to reset to @xmath62 its helping variable @xmath61 . to this end ,",
    "the reader ss - broadcasts the message read@xmath64 , where @xmath65 , each time it starts a new read operation .",
    "* operation * @xmath66 ( @xmath40 ) * is *  % issued by the writer @xmath8",
    "% + [ ns - byz-01 ] @xmath67 write @xmath60 @xmath68 all servers ; + [ ns - byz-02 ] @xmath69 ( messages ack_write @xmath70 received from @xmath71 different servers ) ; + [ ns - byz-03 ]  = @xmath72(@xmath73 @xmath74 such that @xmath75 for @xmath76 of the previous messages ) + [ ns - byz-04 ] @xmath67 new_help_val@xmath60 @xmath68 all servers + [ ns - byz-05 ] ; + [ ns - byz-06 ] @xmath56 .",
    "+   + * operation * @xmath77 ( ) * is *  % issued by the reader @xmath9 % + [ ns - byz-07 ] @xmath78 ; + [ ns - byz-08 ] * ile * ( @xmath79 ) * do * + [ ns - byz-09 ] @xmath67 read @xmath64 @xmath68 all servers ; + [ ns - byz-10 ] @xmath80 ; + [ ns - byz-11 ] @xmath69 ( messages ack_read @xmath81 +   received from @xmath71 different servers ) ; + [ ns - byz-12 ] = ( @xmath82 of the previous messages have the same @xmath83 ) + [ ns - byz-13 ] * let * @xmath84 be this value ; @xmath85     % the value returned is regular or atomic % + [ ns - byz-14 ] = ( @xmath82 of the previous messages have the same @xmath86 ) + [ ns - byz-15 ] * let * @xmath87 be this value ; @xmath88   % the value returned is atomic % + [ ns - byz-16 ] + [ ns - byz-17 ] + [ ns - byz-18 ] .",
    "+  + * when * write @xmath60 * is * @xmath89 * from * @xmath8 * do * + [ ns - byz-19 ] @xmath90 ; + [ ns - byz-20 ] @xmath91 ack_write @xmath92",
    "@xmath68 @xmath8 .",
    "+   + * when * new_help_val @xmath60 * is * @xmath89 * from * @xmath8 * do * + [ ns - byz-21 ] @xmath93 . +   + * when * read @xmath94 * is * @xmath89 * from * @xmath9 * do * + [ ns - byz-22 ] @xmath94 * then * @xmath95 * end if * ; + [ ns - byz-23 ] @xmath91 ack_read @xmath96 @xmath68 @xmath9 .",
    "[ [ algorithm-implementing-mathitreg.sf-write ] ] algorithm implementing @xmath46 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as already said , when the writer invokes @xmath59 , it first ss - broadcasts the message write@xmath60 ( line  [ ns - byz-01 ] ) , and waits until it received an acknowledgment message ack _",
    "write@xmath70 from @xmath71 servers , ( i.e. , from at least @xmath22 correct servers ) ( line  [ ns - byz-02 ] ) .",
    "when a server @xmath26 ss - delivers the message write@xmath60 , it updates @xmath58 ( line  [ ns - byz-19 ] ) , and sends by return ( line  [ ns - byz-20 ] ) the acknowledgment ack _ write@xmath92 to give the writer information on the state of the reader ( namely , @xmath97 means that the reader started a new read operation , and accordingly @xmath61 needs to be refreshed ) .",
    "when the writer stops waiting , it checks if it has received the same value @xmath86 from at least @xmath76 different servers ( line  [ ns - byz-03 ] ) .",
    "if this predicate is false , the local variables @xmath61 of the servers @xmath26 needs to be refreshed . to this end , the writer ss - broadcasts the message new_help_val@xmath60 to inform them that , from now on , they must consider @xmath40 as the new helping value ( lines  [ ns - byz-04 ] and  [ ns - byz-21 ] ) .",
    "[ [ algorithm-implementing-mathitreg.sf-read ] ] algorithm implementing @xmath47 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when the reader invokes @xmath47 , it sets @xmath98 to @xmath99 ( line  [ ns - byz-07 ] ) and enters a while loop ( lines  [ ns - byz-08 ] and  [ ns - byz-18 ] ) , that it will exit at line  [ ns - byz-13 ] or  [ ns - byz-15 ] . once in the loop body , the reader starts a new inquiry by ss - broadcasting the message read@xmath100 to the servers .",
    "if @xmath101 , the message is related to a new read operation ( line  [ ns - byz-07 ] ) ; if @xmath102 , it is from the same read operation as before ( line  [ ns - byz-10 ] ) .",
    "then , the reader waits until it has received an acknowledgment message ack _",
    "read@xmath81 from @xmath71 servers ( line  [ ns - byz-11 ] ) .    when a server @xmath26 receives the message read@xmath100 , it resets @xmath61 to @xmath62 if this message indicates a new read operation started ( line  [ ns - byz-22 ] ) . in all cases",
    "( i.e. , whatever the value of @xmath98 ) , it sends by return its current local state in the message ack _",
    "read@xmath103 ( line  [ ns - byz-23 ] ) .    when the reader stops waiting , it returns the value @xmath40 if the field @xmath83 of @xmath82 messages ack _",
    "read@xmath104 is equal to @xmath40 ( lines  [ ns - byz-12]-[ns - byz-13 ] ) .",
    "otherwise it returns the value @xmath87 if the field @xmath105 of @xmath82 messages ack _",
    "read@xmath104 is equal to @xmath106 ( lines  [ ns - byz-14]-[ns - byz-15 ] ) .",
    "if none of these predicates is satisfied , the reader re - enters the loop body .",
    "[ [ remark - on - the - reception - order - of - the - messages - ack_write - and - ack_read ] ] remark on the reception order of the messages ack_write@xmath104 and ack_read@xmath104 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    it is important to notice that , thanks to the properties of the ss - broadcast abstraction , and the fact that the links are fifo , we have the following . when the writer invokes @xmath15 , and later waits for associated acknowledgments ack_write@xmath104 from @xmath71 servers ( lines  [ ns - byz-01]-[ns - byz-02 ] ) , the sequence of acknowledgments received from each correct server matches the sequence of @xmath15 it issued ( the same holds for the reader and the acknowledgments ack_read@xmath104 , lines  [ ns - byz-09]-[ns - byz-11 ] ) .",
    "this means that @xmath15 and the associated acknowledgments do not need to carry sequence numbers .",
    "all the poofs assume @xmath5 .",
    "[ write - termination ] any invocation of @xmath107 terminates .    due to the ss - broadcast termination property ,",
    "the writer can not block forever when it invokes @xmath15 at line  [ ns - byz-01 ] or line  [ ns - byz-04 ] .",
    "as far the wait statement of line  [ ns - byz-02 ] is concerned , we have the following : due to the ss - broadcast eventual delivery property , eventually at least @xmath71 non - byzantine servers ss - deliver the message write@xmath104 ss - broadcast by the writer , and then they will eventually answer by returning the acknowledgment message ack_write@xmath104 , which concludes the proof of the lemma .",
    "[ read - termination ] any invocation of @xmath108 terminates .",
    "using the same reasoning as in lemma  [ write - termination ] , it follows that the reader can not block forever in the wait statement of line  [ ns - byz-11 ] .",
    "so , the proof consists in showing that the predicate of line  [ ns - byz-12 ] , or the one of  [ ns - byz-14 ] , becomes eventually true . the rest of the proof is by contradiction .",
    "let @xmath45 be the first invocation of @xmath108 that does not terminate and let us consider an execution of the loop body after time @xmath52 .",
    "_ claim _ c. at the time at which a write that started after @xmath14 terminates , there are ( a ) at least @xmath22 correct servers @xmath26 such that @xmath109 , and ( b ) at least @xmath110 correct servers @xmath111 such that @xmath112 .",
    "+ _ proof of the claim_. let us consider a write started after @xmath14 and let @xmath113 be the time at which such write terminates . considering that after @xmath14 there are no more transient failures and due to the synchronized delivery property of the ss - broadcast we have that at time @xmath113 there are at least @xmath22 correct servers @xmath26 such that @xmath109 .",
    "moreover , if the predicate of line  [ ns - byz-03 ] is true , it follows from ( a ) the synchronized delivery property of the ss - broadcast of the message new_help_val@xmath104 ( line  [ ns - byz-04 ] ) , and ( b ) the fact that @xmath114 , that at least @xmath110 correct servers @xmath111 are such that @xmath112 .",
    "if predicate of line  [ ns - byz-03 ] is false , there are @xmath76 servers that sent ack_write@xmath115 where @xmath74 ( line  [ ns - byz-20 ] ) , from which we conclude that at least @xmath110 of them are correct and are such that @xmath112 .",
    "_ end of the proof of the claim _ c.",
    "let us consider the last write that terminated before @xmath45 started , and let us assume it wrote @xmath116 .",
    "due to part ( a ) of claim c , just after this write terminated , at least @xmath22 correct servers @xmath26 are such that @xmath117 .",
    "if no write is concurrent with @xmath45 , as @xmath45 receives messages ack_read@xmath118 from @xmath71 servers at line  [ ns - byz-11 ] ( i.e. , from at least @xmath22 correct servers ) , it follows from the fact that the intersection of any two sets @xmath119 and @xmath120 of @xmath22 correct servers ( the set @xmath119 of correct servers @xmath26 such that @xmath117 , and the set @xmath120 of correct servers from which @xmath45 receives ack_read  @xmath118 ) contains at least @xmath82 correct servers , that @xmath45 terminates at lines  [ ns - byz-12]-[ns - byz-13 ] .",
    "let us now assume that there is exactly one write that is concurrent with @xmath45 , and let @xmath121 be the value it writes .",
    "due to the synchronized delivery property of ss - broadcast , @xmath45 first resets to @xmath62 the variables @xmath61 of at least @xmath122 correct servers @xmath26 ( lines  [ ns - byz-07 ] ,  [ ns - byz-09 ] , and  [ ns - byz-22 ] ) , and then receives ( line  [ ns - byz-11 ] ) messages ack_read@xmath118 from at least @xmath122 correct servers .",
    "we show that at least @xmath82 of these messages carry either @xmath116 or @xmath121 , from which @xmath45 terminates at lines  [ ns - byz-12]-[ns - byz-13 ] . due to part ( a ) of claim c",
    ", there were at least @xmath122 correct servers @xmath26 such that @xmath117 when the write of @xmath116 finished .",
    "let @xmath123 be this set of servers .",
    "@xmath45 receives messages ack_read@xmath118 from at least @xmath76 servers in @xmath123 . due to the operation @xmath124 ( concurrent with @xmath45 )",
    ", variables @xmath58 of some of these servers may have been updated to the value @xmath121 .",
    "hence , some of the previous @xmath76 messages ack_read@xmath118 received by @xmath45 carry @xmath116 , while others carry @xmath121 . hence ,",
    "at least @xmath82 of them carry either @xmath116 or @xmath121 , and @xmath45 terminates at lines  [ ns - byz-12]-[ns - byz-13 ] .",
    "let us finally consider the case where there are more than one write concurrent with @xmath45 .",
    "when @xmath45 terminates its invocation of @xmath67 read@xmath125 ( there is only one such invocation per read operation , line  [ ns - byz-09 ] ) , the local variables @xmath61 of @xmath22 correct servers are equal to @xmath62 .",
    "let @xmath126 be this set of servers .",
    "( the proof of this statement is the same as the proof appearing in the first part of claim c. ) hence , when this ss - broadcast terminated , the messages ack_read@xmath127 sent by each server @xmath128 ( line  [ ns - byz-23 ] ) , is such that @xmath97 .",
    "let us consider the first write ( e.g. , @xmath129 ) that occurs after the servers @xmath128 have set @xmath61 to @xmath62 .",
    "this write receives @xmath71 messages ack_write @xmath70 , and at least @xmath76 of them are from servers in @xmath126 and carry @xmath130 .",
    "hence the predicate of line  [ ns - byz-03 ] is satisfied , and the writer issues @xmath67",
    "if later ( i.e. , after the invocation of @xmath129 terminated ) , there are other invocations of @xmath42 concurrent with @xmath45 , none of them will execute line  [ ns - byz-04 ] .",
    "this is due to the fact that @xmath45 does not reset the variables @xmath61 to @xmath62 , and the @xmath71 messages ack_write  @xmath70 sent by the servers at line  [ ns - byz-20 ] are such that at most @xmath3 are from byzantine servers , and at least @xmath76 carry @xmath132 , from which follows that there is a finite time @xmath133 after which the variables @xmath61 of the correct servers are no longer modified .",
    "let us finally consider the first invocation of @xmath134 issued by @xmath45 after @xmath133 , such that @xmath135 .",
    "it follows from the previous discussion that , among the @xmath71 messages ack_read@xmath136 received by @xmath45 , at most @xmath3 ( the ones from byzantine servers ) carry arbitrary values , and at least @xmath137 carry the value @xmath132 .",
    "when this occurs , @xmath45 terminates at lines  [ ns - byz-14]-[ns - byz-15 ] .",
    "[ label : eventual - regularity ] let @xmath1 .",
    "there is a finite time @xmath50 after which each read invocation @xmath45 returns a value @xmath40 that was written by a write operation @xmath44 , which is ( a ) the last write operation executed before @xmath45 , or ( b ) a write operation concurrent with @xmath45 .",
    "let us assume that a read operation @xmath45 returns @xmath132 , a value different from the value @xmath40 of the last completed write prior to @xmath45 , and from any value @xmath138 of a concurrent write .",
    "let us consider the first write concurrent with @xmath45 .",
    "for @xmath45 to return @xmath132 , the reader must receive @xmath82 messages ack_read@xmath139 or @xmath82 messages ack_read@xmath140 .",
    "however , immediately following the termination of the write of @xmath40 there were @xmath22 correct servers @xmath26 with @xmath109 .",
    "thus , following the termination of the write of @xmath40 , and until the termination of the next write of some value @xmath138 , the reader can not receive @xmath82 values for a value @xmath132 different from @xmath40 and @xmath138 .",
    "the above argument holds for the second concurrent write , where we start with @xmath22 values of @xmath138 , and so on and so forth .",
    "[ theorem : regular - register ] let @xmath1 .",
    "the algorithm described in figure  _ [ algo : swsr - regular ] _ implements a stabilizing regular register in the presence of at most @xmath3 byzantine servers . _ ( the proof follows from lemmas  [ write - termination ] , [ read - termination ] , and  [ label : eventual - regularity ] . ) _",
    "let us consider a communication model where the links are synchronous .",
    "_ synchronous _ means here that each link , connecting the reader or the writer and a correct server , is timely i.e. , there is an upper bound on message transfer delays and this bound is known by the processes .",
    "when considering the construction of an swsr regular register , this allows the reader or the writer to know how long it has to wait for a round trip delay with respect to the correct servers , and consequently use a timer with an appropriate timeout value .",
    "it appears that the previous algorithm can be adapted , with very a simple modification , to this synchronous communication model to build a stabilizing swsr regular register .",
    "due to page limitation , this algorithm is described and proved correct in appendix  [ swsrss ] . the important result is the following theorem , which states that , in such a synchrony setting , up to @xmath141 servers can commit byzantine failures .",
    "[ theorem : regular - register - ss-2 ] let @xmath141 .",
    "the algorithm described in figure  _ [ algo : swsrss - regular - ss ] _ implements a stabilizing regular register in the presence of at most @xmath3 byzantine servers . _",
    "( proof in appendix  [ swsrss ] . ) _",
    "[ [ practically - stabilizing - swsr - atomic - register ] ] practically stabilizing swsr atomic register + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a stabilizing swsr _ practically _ atomic register is a stabilizing swsr regular register with no new / old inversions as long as the number of writes between two successive reads ( that are not executed concurrently with any write ) is less than a given constant called _ system - life - span _ ( e.g. ,",
    "@xmath142 )  @xcite .",
    "this section presents a practically stabilizing swsr atomic register that stabilizes after a read that ( a ) is not concurrent with a write , and ( b ) follows the first write that follows the last transient failure .",
    "its operations are denoted @xmath143 ( ) and @xmath144 ( ) .",
    "[ [ algorithm-1 ] ] algorithm + + + + + + + + +    the stabilizing swsr _ practically _ atomic register algorithm is described in figure  [ algo : swsr - atomic ] .",
    "it is an extension of the algorithm implementing a stabilizing regular register presented figure  [ algo : swsr - regular ] .",
    "the lines with the same number @xmath145 are exactly the same in both algorithms .",
    "a line numbered n@xmath116 is a new line , while a line numbered @xmath145m@xmath132 corresponds to a modification of the line @xmath145 of figure  [ algo : swsr - regular ] .",
    "[ [ underlying - principle ] ] underlying principle + + + + + + + + + + + + + + + + + + + +    to obtain an algorithm implementing such a register , the main idea is to count the invocations of @xmath143 ( ) so that no new / old inversion can occur if the reader traces the sequence number attached to each written value , and exchange an older value with a newer that is already known .",
    "this is the role of the write sequence number denoted @xmath146 .",
    "hence , the data value @xmath40 appearing in figure  [ algo : swsr - regular ] in now replaced by the pair @xmath147 in figure  [ algo : swsr - atomic ] .",
    "therefore , @xmath58 contains now such a pair , and @xmath61 contains now either such a pair , or the default value @xmath62 .",
    "special care must be taken to bound @xmath146 so that there is no ambiguity on its current value .",
    "hence , a relation @xmath148 on sequence numbers has to be defined , such that it always reflects the write order of the values they are associated with .",
    "this relation is defined as follows : given two integer @xmath116 and @xmath121 ( e.g. , in range @xmath149 $ ] ) , @xmath150 iff the clockwise distance ( hence the subscript @xmath151 ) from @xmath121 to @xmath116 is smaller than their anti - clock distance ; moreover , @xmath152 if @xmath150 and @xmath153 .",
    "such precedence relation is used at lines  n6 and [ ns - byz-13]m2 to compare the highest previously received sequence number @xmath154 with the current one and to update it ( lines n6 , [ ns - byz-13]m2 , and [ ns - byz-15]m ) . as",
    "transient failures may corrupt counter values , those must be automatically corrected .",
    "this is done as follows .",
    "after the first read , which follows a write invocation and does not overlap a write , it holds that the local pair @xmath155 stored by the reader reflects the last read correct value .",
    "thus , the bookkeeping of @xmath154 , @xmath156 , and the values of @xmath146 and @xmath40 , which are read , reflects the right value ordering which allow their correct reordering , thereby providing the writer and the reader with an atomic register .    the aim of the lines n2-n7 is to do a sanity check for the the local pair @xmath155 managed by the reader . to that end ,",
    "the reader ss - broadcasts the message read @xmath157 , and wait for @xmath71 associated acknowledgments ack_read @xmath136 ( lines  n2-n3 ) . if @xmath82 of these messages carry the same pair @xmath158 , and @xmath146 is smaller than @xmath159 , then the reader adopts this pair as current value of @xmath160 .",
    "this is because , if @xmath82 of these messages carry the same pair , they reflect the last value written , and therefore carry the correct @xmath161 .",
    "hence , the `` if '' statement in line  n6 , whose aim is to refresh the pair @xmath160 .",
    "this preliminary sanity check , which relies on values provided by the servers , helps the rest of the read algorithm ( lines  [ ns - byz-07]-[ns - byz-18 ] which are nearly the same as the ones of figure  [ algo : swsr - regular ] ) prevent new / old inversions from occurring .",
    "[ [ remark ] ] remark + + + + + +    due to page limitation , the proof of the previous construction is given in appendix  [ annex - proof - practically - atomic - swsr ] .",
    "let us notice that the `` synchronous link '' algorithm designed for @xmath162 processes , has a similar extension , which builds an swsr atomic register version .",
    "* operation * @xmath163 ( @xmath40 ) * is *  % issued by the writer @xmath8",
    "% + ( n1 )  @xmath164 ; + ( [ ns - byz-01]m )   @xmath67 write @xmath147 @xmath68 all servers ; + ( [ ns - byz-02 ] )  @xmath69 ( messages ack_write @xmath70 received from @xmath71 different servers ) ; + ( [ ns - byz-03 ] )  * if *  = @xmath72(@xmath73 @xmath74 such that @xmath75 for @xmath76 of the previous messages ) + ( [ ns - byz-04]m )  * then * @xmath67 new_help_val@xmath147 @xmath68 all servers + ( [ ns - byz-05 ] )  * end if * + ( [ ns - byz-06 ] )  @xmath56",
    ". +   + * operation * @xmath144 ( ) * is *  % issued by the reader @xmath165 where @xmath166 % + ( n2 )  @xmath67 read @xmath157 @xmath68 all servers ; + ( n3 )   @xmath69 ( messages ack_read @xmath81 received from @xmath71 different servers ) ; + ( n4 )  * if * = ( @xmath82 of the previous messages have the same @xmath86 ) + ( n5 )  * then * * let * @xmath167 be this value ; + ( n6 )   @xmath168 * then * @xmath169 ; @xmath170 * end if *  % sanity check for @xmath154 and @xmath156 % + ( n7 )  * end if * ; + ( [ ns - byz-07 ] )   @xmath78 ; + ( [ ns - byz-08 ] )  * wh***ile * * ( @xmath79 ) * do * + ( [ ns - byz-09 ] )  @xmath67 read @xmath64 @xmath68 all servers ; + ( [ ns - byz-10 ] )  @xmath80 ; + ( [ ns - byz-11 ] )   @xmath69 ( messages ack_read",
    "@xmath81 +   received from @xmath71 different servers ) ; + ( [ ns - byz-12 ] )  * if * = ( @xmath82 = of the = previous = messages have the same @xmath83 ) + ( [ ns - byz-13]m1 )  * then * * let * @xmath167 be this value ; + ( [ ns - byz-13]m2 ) @xmath171 * then * = @xmath169 ; @xmath172 ; @xmath85 + ( [ ns - byz-13]m3 )  @xmath173   % prevention of new / old inversion % + ( [ ns - byz-13]m4 )  * end if * + ( [ ns - byz-14 ] ) = ( @xmath82 of the previous messages have the same @xmath86 ) + ( [ ns - byz-15]m )  * then * * let * @xmath174 be this value ; @xmath169 ; @xmath175 ; @xmath88   % already atomic % + ( [ ns - byz-16 ] )  * end if * + ( [ ns - byz-17 ] )  * end if * + ( [ ns - byz-18 ] )  * end while*. +  + * when * write @xmath176 * is * @xmath89 * from * @xmath8 * do * % @xmath40 is now a pair @xmath177 % + ( [ ns - byz-19 ] )  @xmath90 ; + ( [ ns - byz-20 ] ) @xmath91 ack_write  @xmath92 @xmath68 @xmath8 . +   + * when * new_help_val @xmath60 * is * @xmath89 * from * @xmath8 * do * % @xmath40 is now a pair @xmath177 % + ( [ ns - byz-21 ] )  @xmath93 .",
    "+   + * when * read @xmath94 * is * @xmath89 * from * @xmath9 * do * + ( [ ns - byz-22 ] )  * if * @xmath94 * then * @xmath95 * end if * ; + ( [ ns - byz-23 ] ) @xmath91 ack_read @xmath96 @xmath68 @xmath9 .",
    "the technique to obtain a swmr atomic register from swsr atomic registers is a classical one  @xcite .",
    "the writer interacts with each reader , writing the same value to all readers , the servers maintaining variables for each reader .",
    "since the result is atomic register for each reader , and any write is executed to all , then the result is a single - writer multi - reader register .",
    "let @xmath178 ( ) and @xmath179 ( ) denote the operations associated with such a swmr atomic register .",
    "this section presents a stabilizing algorithm that implements a multi - writer multi - reader atomic register in the system model introduced in section  [ sec : model ] .",
    "[ [ underlying - swmr - atomic - registers ] ] underlying swmr atomic registers + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    it is assumed that each process is both a reader and a writer .",
    "hence , in the following we use the term `` process '' .",
    "let @xmath13 be the number of processes .",
    "a process is denoted @xmath30 , @xmath180",
    ". the construction uses one stabilizing swmr register per process .",
    "let @xmath181 $ ] be the swmr register associated with @xmath30 , which means that any process can read it but only @xmath30 can write it .",
    "to write @xmath181 $ ] , @xmath30 invokes @xmath181.\\mathsf{swmr\\_write}\\big(v , epoch , seq\\big)$ ] , where @xmath182 is a bounded label ( see below ) , and @xmath183 is a sequence number bounded by some large constant @xmath142 .",
    "any process @xmath31 reads @xmath181 $ ] by invoking @xmath181.\\mathsf{swmr\\_read}()$ ] .",
    "such an invocation returns a triple @xmath184 , where @xmath40 is a data value , whose associated timestamp is the pair @xmath185 .",
    "* operation * @xmath186 ( @xmath40 ) * is *    % issued by process @xmath30 %   + [ mwmr - byz-01 ] @xmath187 * do * @xmath188\\leftarrow { \\mathit{reg}}[j].\\mathsf{swmr\\_read}()$ ] * end for * ; % obtains @xmath13 triples @xmath189 % + [ mwmr - byz-02 ] @xmath190))$ ] @xmath191 @xmath192.epoch = { \\sf max\\_epoch}(reg_i[1 .. m ] ) )                 \\wedge ( reg_i[j].seq \\geq2^{64})])\\big)$ ] + [ mwmr - byz-03 ] = @xmath193 \\leftarrow \\big(v,{\\sf next\\_epoch}(reg_i[1 .. m]),0\\big)$ ] + [ mwmr - byz-04 ] ; + [ mwmr - byz-05 ] let @xmath194 be the set of indexes @xmath195 such that @xmath196)=reg_i[j].epoch$ ] ; + [ mwmr - byz-06 ] @xmath197.seq , j \\in m)$ ] ; + [ mwmr - byz-07 ] @xmath181.{\\sf swmr\\_write }            \\big(v,{\\sf max\\_epoch}(reg_i[1 .. m]),seq_{max}+1\\big)$ ] ; + [ mwmr - byz-08 ] @xmath56 .",
    "+   + * operation * @xmath198 ( ) * is *    % issued by process @xmath30 % + [ mwmr - byz-09 ] @xmath187 * do * @xmath188 \\leftarrow { \\mathit{reg}}[j].\\mathsf{swmr\\_read}()$ ] * end for * ; % obtains @xmath13 triples @xmath189 % + [ mwmr - byz-10 ] @xmath199))$ ] @xmath191 @xmath200.epoch =        { \\sf max\\_epoch}(reg_i[1 .. m ] ) ) \\wedge ( reg_i[j].seq \\geq2^{64})])\\big)$ ] + [ mwmr - byz-11 ] = @xmath193 \\leftarrow ( reg_i[i].v,{\\sf next\\_epoch}(reg_i[1 .. m]),0\\big)$ ] ; @xmath181.{\\sf swmr\\_write }            \\big(reg_i[i].v , reg_i[i].epoch , 0\\big)$ ] + [ mwmr - byz-12 ] ; + [ mwmr - byz-13 ] let @xmath194 be the set of indexes @xmath195 such that @xmath196)=reg_i[j].epoch$ ] ; + [ mwmr - byz-14 ] @xmath197.seq , j \\in m)$ ] ; + [ mwmr - byz-15 ] let @xmath201 be the minimal index such that @xmath202.seq = seq_{max}$ ] ; + [ mwmr - byz-16 ] @xmath203.v)$ ] .",
    "[ [ the - notion - of - an - epoch ] ] the notion of an epoch + + + + + + + + + + + + + + + + + + + + + +    this notion was introduced in  @xcite where a bounded labeling scheme is proposed with uninitialized values .",
    "let @xmath204 be an integer , and let @xmath205 .",
    "we consider the set @xmath206 and let @xmath207 ( the set of epochs ) be the set of all ordered pairs @xmath208 where @xmath209 and @xmath210 has size @xmath211 .",
    "the comparison operator @xmath212 among two epochs is defined as follows : @xmath213 note that this operator is antisymmetric by definition , yet may not be defined for every pair @xmath214 and @xmath215 in @xmath207 ( e.g. , @xmath216 and @xmath217 ) .",
    "given a subset @xmath21 of epochs of @xmath207 , a function is defined in  @xcite which compute a new epoch which is greater ( with respect to @xmath212 ) than every label in @xmath21 .",
    "this function , called @xmath218 , is as follows .",
    "given a subset of @xmath211 epochs @xmath219 , @xmath220 is the epoch @xmath208 that satisfies :    * @xmath221 is an element of @xmath222 that is not in the union @xmath223 ( as the size of each @xmath224 is @xmath211 , the size of the union is at most @xmath225 , and since @xmath222 is of size @xmath226 such an @xmath221 always exists ) . * @xmath227 is a subset of size @xmath211 of @xmath222 containing all values @xmath228 ( if they are not pairwise distinct , add arbitrary elements of @xmath222 to get a set of size exactly @xmath211 ) .",
    "the relation @xmath212 is extended to @xmath148 as follows : @xmath229    the predicate @xmath230 applied to a set of epochs returns true if there is an epoch in the set such that is equal to or greater ( in the sense of the relation @xmath148 ) than any other epoch in the set .    [ [ algorithm - implementing - mathsfmwmr_write ] ] algorithm implementing @xmath231 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath30 invokes @xmath186 ( @xmath40 ) , it first checks if it has to start a new epoch ( lines  [ mwmr - byz-01]-[mwmr - byz-04 ] ) , in which it first reads all the underlying swmr registers @xmath232 $ ] , and saves their values in its local array @xmath233 $ ] ( line  [ mwmr - byz-01 ] ) .",
    "this constitutes its view of the global state .",
    "hence , for any @xmath187 , @xmath188 $ ] contains a triple @xmath234 , namely , @xmath188.v$ ] is the data value of @xmath235 , @xmath188.epoch$ ] is the epoch of the timestamp of @xmath40 , and @xmath188.seq$ ] is the sequence number of the timestamp of @xmath40 .",
    "then , if there is no greatest epoch in @xmath233 $ ] , or there is one ( @xmath188.epoch$ ] ) , but the associated sequence number ( @xmath188.seq$ ] ) is equal to or greater than the bound @xmath142 , @xmath30 must start the next epoch ( @xmath236 $ ] ) with starts with the sequence number @xmath55 , and informs the other processes . to this end",
    "@xmath30 writes the value @xmath40 and its timestamp @xmath237 in @xmath238 $ ] .",
    "then @xmath30 writes the value @xmath40 with its epoch and sequence number ( line  [ mwmr - byz-07 ] ) .",
    "the pair ( epoch , sequence number ) is computed at lines  [ mwmr - byz-05]-[mwmr - byz-07 ] so that it is greater than all the previous pairs known by @xmath30 .",
    "[ [ algorithm - implementing - mathsfmwmr_read ] ] algorithm implementing @xmath239 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the algorithm implementing the operation @xmath240 ( ) is nearly the same as the one implementing the operation @xmath186 ( ) . the lines  [ mwmr - byz-09]-[mwmr - byz-12 ] are the same as the lines  [ mwmr - byz-01]-[mwmr - byz-04 ] , except line  [ mwmr - byz-11 ] where @xmath30 writes into the timestamp of @xmath193 $ ] a new epoch .",
    "the second difference is at lines  [ mwmr - byz-14]-[mwmr - byz-16 ] , where the value returned by the read operation is computed .",
    "this value is the one associated with the greatest epoch known by @xmath30 and the greatest sequence number , and where process identities are used to do tie - breaking ( if needed ) .",
    "[ [ proof ] ] proof + + + + +    due to page limitation , the proof of the previous construction is given in appendix  [ annex - proof - atomic - mwmr ] .",
    "this paper was on the implementation of stabilizing server - based storage on top of an asynchronous message - passing system where up to @xmath3 servers can exhibit a byzantine behavior .",
    "a first basic algorithm was represented , which implements a single - writer single - reader _ regular _ register stabilizing after the first write invocation .",
    "this algorithm tolerates @xmath1 if communication is asynchronous , and @xmath141 if it is synchronous .",
    "this algorithm was then extended to obtain a _ practically stabilizing atomic _ single - writer single - reader register .",
    "finally , the paper presented a generalization allowing any number of processes to read and write the practically stabilizing atomic register .",
    "this paper , together with  @xcite , is one of the very first to address the construction of a read / write register in an asynchronous system where all servers can experience transient failures , and some of them can behave arbitrarily . while the algorithms presented in  @xcite , require the `` operation quiescence '' assumption , and build only regular registers , ( as already noticed in the introduction ) our constructions are the first that build a distributed atomic read / write memory on top of asynchronous servers , which communicate by message - passing with the readers and writers processes , can suffer transient failures , and where some of them can exhibit a byzantine behavior .",
    "this section presents and proves correct an algorithm , which builds a stabilizing swsr regular register , in a synchronous system where up to @xmath141 servers can commit byzantine failures .    as aleady indicated in section  [ sec : synchronous - swsr ] , _ synchronous _ means here that there is an upper bound on message transfer delays on each link connecting a process ( reader or writer ) and a correct server .",
    "moreover , this bound is known by the processes . hence ,",
    "both the reader and the writer know how long they have to wait for messages from all correct servers , and can consequently use timers with appropriate timeout values .",
    "the corresponding algorithm is described in figure  [ algo : swsrss - regular - ss ] , which is a simple adaptation of the basic algorithm of figure  [ algo : swsr - regular ] .",
    "the modified lines are suffixed with the letter m.    due to the link synchrony property , we have the following .",
    "when the writer writes a value @xmath116 to the correct servers ( which are at least @xmath82 ) , and then starts another write of a value @xmath121 , as it obtains values from all correct servers , a concurrent read obtains at least @xmath241 messages carrying @xmath116 , or at least @xmath241 messages carrying @xmath121 .",
    "more generally , if the writer is faster than the reader , it assists the reader to find @xmath82 identical non-@xmath62 values , writing the same value at all correct servers .",
    "the reader can then read at least @xmath241 identical non-@xmath62 values in the @xmath105 field of the messages it receives from all correct servers , and is able to return a correct value .",
    "* operation * @xmath66 ( @xmath40 ) * is *  % issued by the writer @xmath8",
    "% + ( [ ns - byz-01 ] )   @xmath67 write @xmath60 @xmath68 all servers ; + ( [ ns - byz-02].m )   @xmath69 ( messages ack_write @xmath70 received from @xmath0 different servers or time - out ) ; + ( [ ns - byz-03].m )   * if *  = @xmath72(@xmath73 @xmath74 such that @xmath75 for @xmath241 of the previous messages ) + ( [ ns - byz-04 ] )   @xmath67 new_help_val@xmath60 @xmath68 all servers + ( [ ns - byz-05 ] )   * end if * ; + ( [ ns - byz-06 ] )   @xmath56 .",
    "+   + * operation * @xmath77 ( ) * is *  % issued by the reader @xmath9 % + ( [ ns - byz-07 ] ) @xmath78 ; + ( [ ns - byz-08 ] ) * ile * ( @xmath79 ) * do * + ( [ ns - byz-09 ] ) @xmath67 read @xmath64 @xmath68 all servers ; + ( [ ns - byz-10 ] ) @xmath80 ; + ( [ ns - byz-11].m ) @xmath69 ( messages ack_read @xmath81 +   received from @xmath0 different servers or time - out ) ; + ( [ ns - byz-12].m ) = ( @xmath241 of the previous messages have the same @xmath83 ) + ( [ ns - byz-13 ] ) * let * @xmath84 be this value ; @xmath85     % the value returned is regular or atomic % + ( [ ns - byz-14].m ) = ( @xmath241 of the previous messages have the same @xmath86 ) + ( [ ns - byz-15 ] ) * let * @xmath87 be this value ; @xmath88   % the value returned is atomic % + ( [ ns - byz-16 ] ) + ( [ ns - byz-17 ] ) + ( [ ns - byz-18 ] ) .",
    "+  + * when * write @xmath60 * is * @xmath89 * from * @xmath8 * do * + ( [ ns - byz-19 ] ) @xmath90 ; + ( [ ns - byz-20 ] ) @xmath91 ack_write @xmath92 @xmath68 @xmath8 . +   + * when * new_help_val @xmath60 * is * @xmath89 * from * @xmath8 * do * + ( [ ns - byz-21 ] ) @xmath93 .",
    "+   + * when * read @xmath94 * is * @xmath89 * from * @xmath9 * do * + ( [ ns - byz-22 ] ) @xmath94 * then * @xmath95 * end if * ; + ( [ ns - byz-23 ] ) @xmath91 ack_read @xmath96 @xmath68 @xmath9 .",
    "the proof is a straightforward adaptation of the proof of section  [ sec : basic - algo - proof ] , which takes into account the synchrony assumption .",
    "it assumes @xmath141 .",
    "[ write - termination - ss-2 ] any invocation of @xmath107 terminates .    due to the ss - broadcast termination property",
    ", the writer can not block forever when it invokes @xmath15 at line  [ ns - byz-01 ] or line  [ ns - byz-04 ] .",
    "as far the wait statement of line  [ ns - byz-02 ] is concerned , we have the following . due to the ss - broadcast eventual delivery property , at least @xmath71 non - byzantine servers ss -",
    "deliver the message write@xmath104 ss - broadcast by the writer , and send it by return the acknowledgment message ack_write@xmath104 , which concludes the proof of the lemma .",
    "[ read - termination - ss-2 ] any invocation of @xmath108 terminates .",
    "using the same reasoning as in lemma  [ write - termination ] , it follows that the reader can not block forever in the wait statement of line  [ ns - byz-11 ] .",
    "so , the proof consists in showing that the predicate of line  [ ns - byz-12 ] , or the one of  [ ns - byz-14 ] , becomes eventually true .",
    "the rest of the proof is by contradiction .",
    "@xmath45 being the first invocation of @xmath108 that does not terminate , let us consider an execution of the loop body after time @xmath52 .",
    "_ claim _ c. at the time at which a write that started after @xmath14 terminates , there are ( a ) at least @xmath242 correct servers @xmath26 such that @xmath109 , and ( b ) at least @xmath241 correct servers @xmath111 such that @xmath112 .",
    "+ _ proof of the claim_. it follows from the synchronized delivery property of the ss - broadcast of the message write@xmath104 , and the fact that no correct server suffers transient failures after @xmath14 , that , when a write that started after @xmath14 terminates , there are at least @xmath71 correct servers @xmath26 such that @xmath109 .",
    "moreover , if the predicate of line  [ ns - byz-03 ] is true , it follows from ( a ) the synchronized delivery property of the ss - broadcast of the message new_help_val@xmath104 ( line  [ ns - byz-04 ] ) , and ( b ) the fact that @xmath243 , that at least @xmath241 correct servers @xmath111 are such that @xmath112",
    ". if predicate of line  [ ns - byz-03 ] is false , there are @xmath244 servers that sent ack_write@xmath115 where @xmath74 ( line  [ ns - byz-20 ] ) , from which we conclude that there are at least @xmath241 with @xmath112 .",
    "_ end of the proof of the claim _ c.",
    "let us consider the last write that terminated before @xmath45 started , and let us assume it wrote @xmath116 .",
    "due to part ( a ) of claim c , just after this write terminated , all the @xmath71 correct servers @xmath26 are such that @xmath117 .",
    "if no write is concurrent with @xmath45 , as @xmath45 receives messages ack_read@xmath118 from @xmath71 correct servers at line  [ ns - byz-11 ] , it follows that @xmath45 terminates at lines[ns - byz-12]-[ns - byz-13 ] .",
    "let us now assume that there is exactly one write that is concurrent with @xmath45 , and let @xmath121 be the value it writes .",
    "due to the synchronized delivery property of ss - broadcast , @xmath45 first resets to @xmath62 the variables @xmath61 of all @xmath245 correct servers @xmath26 ( lines  [ ns - byz-07 ] ,  [ ns - byz-09 ] , and  [ ns - byz-22 ] ) , and then receives ( line  [ ns - byz-11 ] ) messages ack_read@xmath118 from all the correct servers .",
    "we show that at least @xmath241 of these messages carry either @xmath116 or @xmath121 , from which @xmath45 terminates at lines  [ ns - byz-12]-[ns - byz-13 ] .",
    "due to part ( a ) of claim c , there were at least @xmath246 correct servers @xmath26 such that @xmath117 when the write of @xmath116 finished .",
    "let @xmath123 be this set of servers .",
    "@xmath45 receives messages ack_read@xmath118 from all the @xmath244 correct servers in @xmath123 . due to the operation @xmath124 ( concurrent with @xmath45 ) , variables @xmath58 of some of these servers",
    "may have been updated to the value @xmath121 .",
    "hence , some of the previous @xmath244 messages ack_read@xmath118 received by @xmath45 carry @xmath116 , while others carry @xmath121 . hence ,",
    "at least @xmath241 of them carry either @xmath116 or @xmath121 , and @xmath45 terminates at lines  [ ns - byz-12]-[ns - byz-13 ] .",
    "let us finally consider the case where there are more than one write concurrent with @xmath45 .",
    "when @xmath45 terminates its invocation of @xmath67 read@xmath125 ( there is only one such invocation per read , line  [ ns - byz-09 ] ) , the local variables @xmath61 of @xmath71 correct servers are equal to @xmath62 .",
    "let @xmath126 be this set of servers .",
    "( the proof of this statement is the same as the proof appearing in the first part of claim c. ) hence , when this ss - broadcast terminated , the messages ack_read@xmath127 sent by each server @xmath128 ( line  [ ns - byz-23 ] ) , is such that @xmath97 .",
    "let us consider the first write ( e.g. , @xmath129 ) that occurs after the servers @xmath128 have set @xmath61 to @xmath62 .",
    "this write receives @xmath71 messages ack_write @xmath70 , and at least @xmath244 of them are from servers in @xmath126 , and carry consequently @xmath130 .",
    "hence the predicate of line  [ ns - byz-03 ] is satisfied , and the writer issues @xmath67",
    "if later ( i.e. , after the invocation of @xmath129 terminated ) , there are other invocations of @xmath42 concurrent with @xmath45 , none of them will execute line  [ ns - byz-04 ] .",
    "this is due to the fact that @xmath45 does not reset the variables @xmath61 to @xmath62 , and the @xmath71 messages ack_write  @xmath70 sent by the servers at line  [ ns - byz-20 ] are such that at most @xmath3 are from byzantine servers , and at least @xmath244 carry @xmath132 , from which follows that there is a finite time @xmath133 after which the variables @xmath61 of the correct servers are no longer modified .",
    "let us finally consider the first invocation of @xmath134 issued by @xmath45 after @xmath133 , such that @xmath135 .",
    "it follows from the previous discussion that , among the @xmath71 messages ack_read@xmath136 received by @xmath45 , at most @xmath3 ( the ones from byzantine servers ) carry arbitrary values , and at least @xmath71 carry the value @xmath132 .",
    "when this occurs , @xmath45 terminates at lines  [ ns - byz-14]-[ns - byz-15 ] .",
    "[ label : eventual - regularity - ss-2 ] let @xmath141 .",
    "there is a finite time @xmath50 after which each read invocation @xmath45 returns a value @xmath40 that was written by a write operation @xmath44 , which is ( a ) the last write operation executed before @xmath45 , or ( b ) a write operation concurrent with @xmath45 .",
    "let us assume that a read operation @xmath45 returns @xmath132 , a value different from the value @xmath40 of the last completed write prior to @xmath45 , and from any value @xmath138 of a concurrent write .",
    "let us consider the first write concurrent with @xmath45 .",
    "for @xmath45 to return @xmath132 , the reader must receive @xmath241 messages ack_read@xmath139 or @xmath241 messages ack_read@xmath140 .",
    "however , immediately following the termination of the write of @xmath40 there were @xmath71 correct servers @xmath26 with @xmath109 .",
    "thus , following the termination of the write of @xmath40 , and until the termination of the next write of some value @xmath138 , the reader can not receive @xmath241 values for a value @xmath132 different from @xmath40 and @xmath138 .",
    "the above argument holds for the second concurrent write , where we start with @xmath71 values of @xmath138 , and so on and so forth .",
    "theorem : regular - register - ss-2 let @xmath141 .",
    "the algorithm described in figure  [ algo : swsrss - regular - ss ] implements a stabilizing regular register in the presence of at most @xmath3 byzantine servers .",
    "the proof follows from lemma  [ write - termination - ss-2 ] , lemma  [ read - termination - ss-2 ] , and lemma  [ label : eventual - regularity - ss-2 ] .",
    "[ lem : swsrawterm ] any invocation of a @xmath247 operation terminates .",
    "let us suppose by contradiction that there exists a @xmath247 operation @xmath248 invoked by the writer @xmath8 and that @xmath248 does not terminate .",
    "if such operation does not terminate , it means that @xmath8 never executes line [ ns - byz-06 ] in figure [ algo : swsr - atomic ] .",
    "let us note that , due to the ss - broadcast termination property , @xmath8 can not be blocked while sending messages .",
    "thus , the only point where @xmath8 can be blocked is executing line [ ns - byz-02 ] in figure [ algo : swsr - atomic ] while waiting for the delivery of ack_write@xmath104 messages .",
    "an ack_write@xmath104 message is sent by a server when it delivers a write@xmath249 message ( line [ ns - byz-20 ] , figure [ algo : swsr - atomic ] ) that is in turn sent by @xmath8 at the beginning of the @xmath247 operation ( line [ ns - byz-01]m , figure [ algo : swsr - atomic ] ) . due to the eventual delivery property of ss - broadcast",
    ", we have that eventually @xmath245 correct servers will deliver the write@xmath104 message sent by @xmath8 and will send back an ack_write@xmath104 message .",
    "thus , considering that links connecting each server to the writer is fifo reliable , we have that @xmath8 will eventually deliver at least @xmath245 ack_write@xmath104 messages .",
    "therefore , we have a contradiction and the claim follows .    [ lem : stateafterwrite ] let @xmath248 be a @xmath250 operation invoked by the writer @xmath8 at some time @xmath251 , let @xmath252 be the sequence number associated to the operation and let @xmath253 be the time at which @xmath248 terminates . at time @xmath253 there exist at least @xmath22 correct servers that store locally in their @xmath58 variable the pair @xmath254 .",
    "due to lemma [ lem : swsrawterm ] , we have that time @xmath253 exists .",
    "let us now show that at that time , at least @xmath22 correct servers store the pair @xmath254 .",
    "the writer @xmath8 returns from the @xmath250 operation only after it is unlocked from the @xmath69 statement in line [ ns - byz-02 ] .",
    "if @xmath8 is unblocked , it means that it delivered at least @xmath71 ack_write@xmath104 messages from @xmath245 different servers .",
    "an ack_write@xmath104 message is sent by a server @xmath26 when it delivers a write@xmath60 message and just after it updated its local copy of the register with the value and the sequence number contained in the write@xmath60 message ( line [ ns - byz-19 ] , figure [ algo : swsr - atomic ] ) .",
    "let us denote as @xmath255 such a time .",
    "considering that ( i ) both ss - broadcast and the fifo link involved in such a message pattern do not create messages , ( ii ) the value and the sequence number are communicated to @xmath26 directly from the writer , ( iii ) among the @xmath71messages ack_write@xmath104 received by @xmath8 , at most @xmath3 are from byzantine servers , and ( iv ) @xmath256 , the claim follows .",
    "[ lem : statehvafterwrite ] let @xmath248 be a @xmath250 operation invoked by the writer @xmath8 at some time @xmath251 , let @xmath252 be the sequence number associated to @xmath248 and let @xmath253 be the time at which @xmath248 terminates",
    ". at time @xmath253 there exist at least @xmath76 correct servers that store locally in their @xmath61 variable the same pair @xmath257 .    due to lemma",
    "[ lem : swsrawterm ] , we have that time @xmath253 exists .",
    "let us now show that at that time , at least @xmath22 correct servers store the same pair @xmath258 .",
    "the writer @xmath8 returns from the @xmath250 operation only after it is unblocked from the @xmath69 statement in line [ ns - byz-02 ] .",
    "if @xmath8 is unblocked , it means that it delivered at least @xmath71 ack_write@xmath259 messages from @xmath71 different servers .",
    "thus , @xmath8 received at least @xmath71 helping values , stored locally at the servers , from @xmath71 different servers .",
    "let @xmath260 be the time at which @xmath8 is unblocked from the @xmath69 statement in line [ ns - byz-02 ] and evaluates the condition in line [ ns - byz-03 ] .",
    "two cases can happen : the condition at line  [ ns - byz-03 ] is ( i ) @xmath99 . or ( ii ) @xmath261 .    *",
    "_ case 1 : the condition in line [ ns - byz-03 ] is @xmath262_. in this case , it means that among the @xmath71 received helping values , there not exists a value @xmath263 occurring a majority of time .",
    "this means that helping values stored at each server @xmath26 during the current @xmath247 operation are corrupted values and need to be cleaned .",
    "thus , at time @xmath260 , the writer @xmath8 broadcasts a new_help_val@xmath264 message that will trigger the update of the @xmath61 variable ( line [ ns - byz-21 ] ) .",
    "considering that ss - broadcast ( i ) does not modify the content of messages , ( ii ) guarantees that at least @xmath22 correct servers deliver the message before the end of its invocation , and ( iii ) @xmath8 returns form the @xmath250 operation only after the termination of the ss - broadcast , it follows that at least @xmath22 correct servers stored the same pair @xmath254 in their @xmath61 local variable before the end of the operation . as @xmath265",
    ", the claim follows . * _ case 2 : the condition in line [ ns - byz-03 ] is @xmath266_. in this case , the claim directly follows as the writer found @xmath76 same values .",
    "[ lem : swsrarterm ] any invocation of a @xmath267 operation terminates .",
    "let us suppose by contradiction that there exists a @xmath267 operation @xmath268 invoked by the reader @xmath9 and that @xmath268 does not terminate .",
    "if such operation does not terminate , it means that @xmath9 never executes line [ ns - byz-13]m2 or line [ ns - byz-13]m3 or line  [ ns - byz-15]m in figure [ algo : swsr - atomic ] .",
    "let us note that , due to the ss - broadcast termination property , @xmath9 can not be blocked while sending messages .",
    "thus , the only points where @xmath9 can be blocked is ( i ) while executing line [ ns - byz-11 ] in figure [ algo : swsr - atomic ] keep waiting for the delivery of ack_read@xmath104 messages or ( ii ) cycling for ever as the set of ack_read@xmath104 messages received by clients never contains two values @xmath116 and @xmath121 such that @xmath116 is the last value reported by at least @xmath82 servers or @xmath121 is the helping value reported by at least @xmath82 servers .",
    "+ _ case 1 : the reader remains blocked while executing line [ ns - byz-11 ] in figure [ algo : swsr - atomic ] .",
    "_ if the reader is blocked while executing line [ ns - byz-11 ] in figure [ algo : swsr - atomic ] , it means that it never delivers at least @xmath71 ack_read@xmath104 messages from servers .",
    "an ack_read@xmath104 message is sent by a server when it delivers a read@xmath104 message ( line [ ns - byz-23 ] , figure [ algo : swsr - atomic ] ) that is in turn sent by @xmath9 at the beginning of the @xmath41 operation ( line [ ns - byz-09 ] , figure [ algo : swsr - atomic ] ) .",
    "due to the eventual delivery property of ss - broadcast , we have that eventually @xmath71 correct servers will deliver the read@xmath104 message sent by @xmath9 and will eventually send back a ack_read@xmath104 message . thus , considering that links connecting each server to the writer is fifo reliable , we have that @xmath9 will eventually deliver at least @xmath71 ack_read@xmath104 messages .",
    "therefore , we have a contradiction and this case can never happen .",
    "+ _ case 2 : the reader never collects @xmath82 copies of the same last value or it never collects @xmath82 copies of of the same helping value .",
    "_ let us note that last values and helping values are sent from a server @xmath26 trough an ack_read@xmath104 message when it delivers a read@xmath104 message ( line [ ns - byz-23 ] , figure [ algo : swsr - atomic ] ) .",
    "+ thus , if the servers is not able to find @xmath82 same last values or @xmath82 same helping values it means that there always exists @xmath71 servers answering with different values .",
    "note that each server @xmath26 updates its @xmath58 variable while delivering a write@xmath104 message sent by the writer and it updates its @xmath61 variable either during a write using values provided by the writer or during a read resetting such value to @xmath62 . considering that , by assumption , there exists a @xmath247 operation issued after time @xmath14 we have that , due to lemma [ lem : stateafterwrite ] and lemma [ lem : statehvafterwrite ] there exists a time @xmath269 at which the write terminates and such that at least @xmath22 correct servers store the same last value and such that at least @xmath76 correct server stores the same helping value .",
    "let us show now that the @xmath267 operation @xmath268 eventually terminates after time @xmath270 .",
    "let us consider the first read@xmath104 message @xmath13 broadcast by @xmath9 after time @xmath270 .",
    "two further cases may happen : ( 2.1 ) @xmath13 is the first message sent by @xmath9 in the while loop ( i.e. , @xmath13 is a read@xmath271 message ( line [ ns - byz-09 ] ) , or ( 2.2 ) @xmath13 is the @xmath272-th message sent by @xmath9 in the while loop , with @xmath273 ( i.e. , @xmath13 is a read@xmath274 message ( line  [ ns - byz-09 ] ) .    * _ case 2.1 . _",
    "if @xmath13 is a read@xmath271 message , it will trigger the update of the @xmath61 variable to @xmath62 at any correct server @xmath26 that will deliver it . due to the synchronized delivery property of the @xmath275 primitive",
    ", we have that at least @xmath22 correct servers will update their @xmath61 variable .",
    "considering that , at time @xmath270 , we have @xmath22 correct servers storing the same last value and considering that we have only one reader @xmath9 , it follows that such values can be modified concurrently with the broadcast only by the writer .",
    "so , if the writer is not going to modify such values , servers will answer to the broadcast by sending back last values stored at time @xmath270 and the helping values just updated . considering that messages are not altered by the network ,",
    "the reader will receive at least @xmath276 same last values and at least @xmath276 same helping values .",
    "thus , evaluating the condition in line [ ns - byz-12 ] , the reader will find it true and it will terminate the operation either executing line  [ ns - byz-13]m2 or line  [ ns - byz-13]m3 .",
    "+ contrarily , if the writer is going to update the @xmath58 variables due to a concurrent write , the reader will find the condition in line [ ns - byz-12 ] false as well as the condition in line [ ns - byz-14 ] .",
    "note that such concurrent write will be acknowledged by servers with at least @xmath276 helping values equal to @xmath62 .",
    "this will entail the update of the @xmath61 variables with the value concurrently written . as a consequence , in the next iteration of the while loop , due to lemma [ lem : statehvafterwrite ]",
    ", there will exist at least @xmath76 correct servers with the same helping value different from @xmath62 .",
    "thus , at least @xmath82 will acknowledge the next read@xmath104 message making the condition in line [ ns - byz-14 ] true and letting the operation terminate .",
    "* _ case 2.2 . _",
    "if @xmath13 is a read@xmath277 message , it will just be acknowledge by servers with the current values stored locally in their @xmath58 variable and in their @xmath61 variable .",
    "considering that , at time @xmath3 , we have @xmath22 correct servers storing the same last value , we have at least @xmath76 correct servers storing the same helping values and considering that we have only one reader @xmath9 , it follows that such values can be modified concurrently with the broadcast only by the writer .",
    "depending on the value stored by the @xmath76 correct servers ( i.e. , @xmath62 or a different one ) we fall down in the previous case or we have that the reader will find the condition in line [ ns - byz-14 ] immediately true .",
    "however , in both case we have the termination of the operation and the claim follows .    [",
    "lem : toafterstab ] let @xmath14 be the time after which no more transient failures happen .",
    "let @xmath278 be the first @xmath247 operation issued after @xmath14 and let @xmath279 be the time at which @xmath278 terminates .",
    "let @xmath48 be the sequence of @xmath247 operations issued by @xmath8 and let @xmath280 be the sub - sequence of @xmath48 starting with @xmath278 . for each @xmath281 ,",
    "let @xmath282 be the sequence number associated to the operation .",
    "for each pair @xmath283 , @xmath284 of adjacent write in @xmath280 we have that @xmath285 .",
    "the claim simply follows by the definition of the precedence relation @xmath286 considering that after time @xmath14 the sequence number is generated only by the unique writer by incrementing the previous one .",
    "[ lem : evvalidityatomic ] let @xmath1 .",
    "there is a finite time @xmath50 after which each @xmath267 operation @xmath268 returns a value @xmath40 that was written by a write operation @xmath248 , which is ( a ) the last @xmath247 operation executed before @xmath268 , or ( b ) a @xmath247 operation concurrent with @xmath268 .",
    "due to lemma [ lem : swsrarterm ] , we have that eventually each @xmath267 operation terminates .",
    "let us show in the following that there exists a time @xmath52 after which , each @xmath267 operation terminates returning a valid value ( i.e. , the last value written or a value concurrently written ) . without loss of generality ,",
    "let us consider only @xmath267 operations starting after time @xmath51 ( i.e. , considering only @xmath267 operations following the end of the first completed write in the stability period ) .",
    "let @xmath248 be the first @xmath250 operation terminated after @xmath52 and let @xmath116 be the sequence number associated to such operation and terminated at time @xmath51 .",
    "let us consider a @xmath267 operation @xmath268 issued at some time after @xmath51 .",
    "when executing @xmath268 , the reader @xmath9 sends a read@xmath104 message to all servers that will answer by sending back their pair @xmath287 ( line [ ns - byz-23 ] , figure [ algo : swsr - atomic ] ) .",
    "note that , due to lemma [ lem : stateafterwrite ] , at time @xmath51 , there exist at least @xmath22 correct servers storing the same pair @xmath288 in their @xmath58 variable and , due to lemma [ lem : statehvafterwrite ] , at time @xmath51 , there exist at least @xmath76 correct servers storing the same pair @xmath289 in their @xmath61 local variable .",
    "if there is no concurrent @xmath247 operation , it means that servers will answer by sending back the value @xmath288 and the pair @xmath289 . in order to select a value to return",
    ", the reader waits for @xmath71 messages , that @xmath3 answers may arrive from byzantine servers and @xmath3 may arrive from servers that are not yet updated , we have that only @xmath276 values are guaranteed to arrive from correct and updated servers . considering that @xmath265 we hate that at least @xmath290 messages arrives from correct and updates servers .",
    "thus , evaluating the condition in line [ ns - byz-12 ] , figure [ algo : swsr - atomic ] , @xmath9 will find it true and will check whether @xmath116 is smaller or greater than its current local sequence number .",
    "two cases may happen : ( 1 ) @xmath291 or ( 2 ) @xmath292 .",
    "* _ case 1 : @xmath291 .",
    "_ in this case the reader executes line [ ns - byz-13]m3 returning the value locally stored that can be a corrupted one .",
    "let us remark that since @xmath268 is the first read executed after the stabilization , we may have that executing lines n2 -n7 , @xmath9 collects helping values that are still corrupted and set the its local sequence number to a value that is corrupted .",
    "however , this happen only this time as from this time on , the only process that will generate sequence number for write operation is the writer . considering that the such sequence number is generated by incrementing each time the old one ( see lemma  [ lem : toafterstab ] )",
    ", we have that such a scenario may happen a finite number of time .",
    "thus , eventually the writer will use a sequence number that is greater equal than the current one and we will have that eventually a read returns a valid value . * _ case 2 : @xmath292 . _ in this case the reader executes line [ ns - byz-13]m2 returning the last written value and the claim follows .",
    "let us note that , due to the enforcement of the helping value by the writer , we obtain , in case of concurrent writes , the scenario described so far , and the claim follows .",
    "[ lem : evatomocity ] let @xmath1 .",
    "there is a finite time @xmath50 after which any @xmath267 having less than @xmath293 @xmath247 concurrent operations returns a regular value and no two invocations of @xmath294 return new / old inverted values .",
    "eventual validity follows from [ lem : evvalidityatomic ] thus , in the following , we just need to prove that there exists a time @xmath50 after which no new / old inversion happens .",
    "let us suppose by contradiction that there exists two @xmath267 operations @xmath295 and @xmath296 such that @xmath295 happens before @xmath296 @xmath295 returns a value @xmath297 and @xmath296 returns a value @xmath298 and @xmath299 happens before @xmath300 .",
    "if @xmath299 happens before @xmath300 it means that @xmath301 .",
    "note that , if @xmath295 returned value @xmath297 , it means that @xmath9 executed line [ ns - byz-13]m3 ore line [ ns - byz-15]m .",
    "however , in both cases , before returning @xmath297 , @xmath9 updated its current local sequence number to @xmath302 .",
    "thus , executing @xmath296 , evaluating the condition in line [ ns - byz-13]m2 , @xmath9 will find it false and will execute line [ ns - byz-13]m3 returning @xmath297 and we have a contradiction .    note that , the local sequence number can be reset to a value smaller than @xmath302 only if , executing line n6 , @xmath9 found the condition true . however , this happen if and only if the writer sequence number wrapped around as there are more than @xmath293 concurrent operations and the claim follows .",
    "[ theo : evatomocity ] let @xmath1 .",
    "the algorithm described in figure  _ [ algo : swsr - atomic ] _ implements a byzantine - tolerant practically stabilizing swsr atomic register .",
    "the proof follows from lemmas  [ lem : swsrawterm]-[lem : evatomocity ] .",
    "the synchronous link version has an analogous proof for @xmath141 .",
    "the proof of both the next lemmas is straightforward , as the code of @xmath303 and @xmath304 is sequential .",
    "let @xmath305 , timestamped @xmath306 , be any write issued any process @xmath30 , and @xmath307 timestamped @xmath308 be any write issued by any process @xmath31 .",
    "iff @xmath310 @xmath191 @xmath311 @xmath191 @xmath312 .",
    "moreover , @xmath313 @xmath314 @xmath315 .",
    "first notice that non concurrent write or read enforces the existence of a greatest epoch which all subsequent read and write identify .",
    "let @xmath21 be the set of writes on the register happened after @xmath270 .",
    "we will prove in the following that @xmath316 is a total order on s :    * @xmath316 reflexivity , @xmath305 @xmath316 @xmath305 , follows directly from the definition .",
    "* @xmath316 antisymmetry , @xmath317 implies @xmath318 .",
    "since @xmath305 and @xmath307 happen after @xmath270 it follows that the above relations reduce to @xmath319",
    ". hence @xmath320 and @xmath321 .",
    "* @xmath316 transitivity , @xmath322 implies @xmath323 .",
    "this follows directly from the definition and the fact the invocation time is after @xmath270 .",
    "* @xmath316 comparability , for any @xmath305 and @xmath307 in @xmath21 , @xmath324 or @xmath325 .",
    "this follows directly from the definition and the fact that the writes happen after the @xmath270 .      in the following",
    "we prove that value @xmath40 returned by @xmath45 is the value that was written by a write operation @xmath44 , which is ( a ) the last write operation executed before @xmath45 , or ( b ) a write operation concurrent with @xmath45 .",
    "following lemma [ label : eventual - tow ] there is a time @xmath270 such that all writes invoked after @xmath270 are totally ordered .",
    "let @xmath45 be a read operation that happens after @xmath270 .",
    "let @xmath44 be the last writer in that order that modified the register after @xmath270 before @xmath45 started .",
    "@xmath44 either happened before @xmath45 or is concurrent with @xmath45 .",
    "the reader @xmath45 reads first all the swmr registers and stores their values in the vector @xmath326 .",
    "let @xmath211 be the index of the swmr register corresponding to @xmath44 .",
    "since , @xmath44 is the last writer on the register according to @xmath316 it follows that @xmath327.epoch={\\sf   max\\_epoch}(reg_i[1 .. m])$ ] and @xmath327.seq \\geq reg[j].seq ,                      \\forall j , reg[j].epoch={\\sf   max\\_epoch}(reg_i[1 .. m])$ ] ( lines  [ mwmr - byz-09]-[mwmr - byz-10 ] , figure [ algo : mwmr - atomic ] ) and @xmath211 is the minimal with this property .",
    "it follows that @xmath45 returns @xmath327.v$ ] which is the value written by @xmath44 .",
    "following lemma [ label : eventual - tow ] there is a time @xmath270 such that all writes invoked after @xmath270 are totally ordered .",
    "let @xmath328 and @xmath329 be two read operations that happen after @xmath270 and let @xmath330 and @xmath331 that also happen after @xmath270",
    ". assume also that @xmath328 happens before @xmath329 , @xmath330 happens before @xmath331 ( and no other write happens after @xmath330 and before @xmath331 ) , @xmath328 is concurrent with @xmath330 and @xmath331 and @xmath329 is concurrent with @xmath331 . assume a new / old inversion on @xmath328 and @xmath329 .",
    "that is , @xmath328 returns the value written by @xmath331 and @xmath329 returns the value written by @xmath330 .",
    "let @xmath332 be the index in @xmath333 that stores the state of the register modified by @xmath331 .",
    "let @xmath334 be the index in @xmath335 that stores the state of the register modified by @xmath330 .",
    "since @xmath330 happens before @xmath331 then @xmath336.epoch \\succ reg_{r_2}[m2].epoch$ ] or @xmath336.epoch       = reg_{r_2}[m2].epoch$ ] and @xmath336.seq > reg_{r_2}[m2].seq$ ] .",
    "it follows that we have @xmath337.epoch \\succ reg_{r_2}[m2].epoch$ ] , or @xmath337.epoch",
    "= reg_{r_2}[m2].epoch$ ] and @xmath337.seq > reg_{r_2}[m2].seq$ ] .",
    "hence , @xmath329 has to return the value stored at the index @xmath332 which corresponds to the value written by @xmath331 .",
    "this contradicts the new / old inversion assumption .",
    "[ theorem : evatomocity ] let @xmath1 for the asynchronous version and @xmath141 for the link synchronous version .",
    "the algorithm described in figure  _ [ algo : mwmr - atomic ] _ implements a byzantine - tolerant stabilizing mwmr atomic register ."
  ],
  "abstract_text": [
    "<S> a stabilizing byzantine single - writer single - reader ( swsr ) regular register , which stabilizes after the first invoked write operation , is first presented . </S>",
    "<S> then , new / old ordering inversions are eliminated by the use of a ( bounded ) sequence number for writes , obtaining a practically stabilizing swsr atomic register . a practically stabilizing byzantine single - writer multi - reader ( swmr ) atomic register </S>",
    "<S> is then obtained by using several copies of swsr atomic registers . </S>",
    "<S> finally , bounded time - stamps , with a time - stamp per writer , together with swmr atomic registers , are used to construct a practically stabilizing byzantine multi - writer multi - reader ( mwmr ) atomic register . in a system of @xmath0 servers implementing an atomic register , and in addition to transient failures , the constructions tolerate @xmath1 byzantine servers if communication is asynchronous , and @xmath2 byzantine servers if it is synchronous . </S>",
    "<S> the noteworthy feature of the proposed algorithms is that ( to our knowledge ) these are the first that build an atomic read / write storage on top of asynchronous servers prone to transient failures , and where up to @xmath3 of them can be byzantine </S>",
    "<S> .     +   + * keywords * asynchronous message - passing system , atomic read / write register , byzantine server , clients / servers architecture , distributed algorithm , fault - tolerance , regular read / write register , self - stabilization , transient failures . </S>"
  ]
}