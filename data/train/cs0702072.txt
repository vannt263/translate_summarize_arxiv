{
  "article_text": [
    "the use of sat solvers in a wide range of applications is a great success of recent years and quickly growing more popular . contributing to this success are two main factors : ( a ) sat solvers are continuously becoming more powerful , and ( b ) encoding techniques are emerging to represent a wide range of search problems as propositional formulae such that each satisfying assignment of the encoding represents a solution of the problem .",
    "this paper presents a prolog interface to the minisat sat solver @xcite .",
    "minisat is a small ( @xmath0 lines of c - code ) and efficient open - source sat solver which is designed to enable easy integration with other tools and languages .",
    "application of this interface facilitates the best of both worlds : prolog programming for encoding a search problem into a propositional formula on the one hand , and application of powerful sat solving tools on the other .    in recent",
    "work @xcite we apply sat encodings to decide lpo termination @xcite of a given term rewrite system @xmath1 . here",
    "lpo termination of @xmath1 is encoded as a propositional formula @xmath2 and any assignment satisfying @xmath2 indicates a precedence on the symbols in @xmath1 such that its corresponding lexicographic path order orients the rules of @xmath1 .",
    "namely for each rule @xmath3 in @xmath1 , @xmath4 holds .",
    "prolog is well suited for the tasks of parsing the given system @xmath1 and constructing the encoding @xmath2 .",
    "searching for an assignment which satisfies @xmath2 is conveniently delegated to the sat solver .",
    "in other recent works codish  apply sat encodings to determine termination of rewrite systems using dependency pairs @xcite and using recursive path orders ( rpo ) @xcite .",
    "a contribution of those works is the propositional encodings for so called _ argument filterings _ and _ usable rules _ , in @xcite , and the encodings for multi - set orders and lexicographic path orders modulo permutation of arguments , in @xcite .",
    "all of the above mentioned results have been developed on top of the described prolog minisat interface .",
    "we have also had positive experience in using the interface as an educational tool for teaching logic programming concepts as well as the basics of sat encodings and sat solving .",
    "most sat solvers assume as input a propositional formula in conjunctive normal form ( cnf ) . that is a conjunction of disjunctions of literals , or equivalently a conjunction of clauses .",
    "each literal is a propositional variable @xmath5 or its negation @xmath6 .",
    "a truth assignment is a mapping from propositional variables into @xmath7 .",
    "[ [ syntax ] ] * syntax :  * + + + + + + + + + +    in the logic programming setting we represent : literals as terms of the form ` x ` or ` -x ` where ` x ` is a logic variable ; clauses as lists of literals ; and conjunctions of clauses as lists of clauses . for propositional formulae we use terms involving the symbols ` 0/0 ` , ` 1/0 ` , ` -/1 ` , ` * /2 ` , ` + /2 ` , ` = = /2 ` , ` xor/2 ` for : false , true , negation , conjunction , disjunction , bi - implication and xor .",
    "the syntax supports also : ` ( x->y;z ) ` which is equivalent to ` x*y+(-x)*z ` . in the logic programming",
    "setting a truth assignment is a substitution of the variables to the constants @xmath7 .",
    "we also use a list of propositions to represent non - negative integers , in two different ways .",
    "the unary representation is given by the sum of the bits .",
    "for example [ 0,1,0,1 ] represents 2 .",
    "the binary representation is as usual , but giving the least significant bit first . for example [",
    "0,1,0,1 ] represents @xmath8 .",
    "we now recall the satisfiability and maximum satisfiability problems .",
    "partial maxsat is a generalization of sat and maxsat introduced by miyazaki and iwama @xcite .",
    "see also @xcite .",
    "[ [ sat ] ] * sat :  * + + + + + + +    given a propositional logic formula @xmath9 in conjunctive normal form , is there an assignment of truth values to the propositional variables that makes @xmath9 true .",
    "[ [ maxsat ] ] * maxsat :  * + + + + + + + + + +    given a propositional logic formula @xmath9 in conjunctive normal form , find an assignment of the logical variables that maximizes the number of clauses in @xmath9 that are true .",
    "[ [ partial - maxsat ] ] * partial maxsat :  * + + + + + + + + + + + + + + + + + +    given propositional logic formulae @xmath9 and @xmath10 in conjunctive normal form , the problem is to find an assignment that satisfies all clauses in @xmath9 and maximizes the number of clauses in @xmath10 that are true .",
    "the library implementation is written primarily in swi - prolog @xcite and interfaces the minisat solver @xcite for solving sat instances .",
    "we have integrated minisat and swi - prolog through @xmath11190 lines of c - code and @xmath11140 lines of prolog code .",
    "the c - code handles the low - level interface and conversion between the internal data representations of swi - prolog and of minisat .",
    "the prolog code provides a high - level interface for using the sat solver in prolog applications .",
    "the sat solver is deterministic .",
    "it does not , and is not intended to , provide alternative satisfying assignments over backtracking .",
    "the minisat library for prolog can be downloaded from @xcite .",
    "it includes three modules for the user : ` cnf.pl ` , ` adder.pl ` and ` minisat.pl ` .    the module ` cnf.pl ` exports the predicate ` cnf/2 ` . a call to ` cnf(f , cnf ) ` transforms a propositional formula ` f ` to a conjunctive normal form ` cnf ` .",
    "the implementation of ` cnf(f , cnf ) ` applies a tseitin transformation  @xcite to ensure that the size of the conjunctive normal form ` cnf ` is linear in that of the input formula ` f ` .",
    "the basic idea is to associate fresh variables with the sub - formulae of ` f ` .",
    "so , for example , if ` f ` is of the form ` g+h ` and variables ` a , b , c ` are associated respectively with sub - formulae ` f , g , h ` , then the clauses for the bi - implication ` a \\leftrightarrow ( b \\lor c ) ` are introduced to the ` cnf ` together with the clauses for the transformations of ` b \\leftrightarrow g ` and ` c \\leftrightarrow h ` .",
    "this process establishes the conjunctive normal form of ` a \\leftrightarrow f ` . adding the singleton clause ` [ a ] ` then provides a cnf equisatisfiable to @xmath12 .",
    "the variables ` a , b , c ` are sometimes referred to as `` tseitin variables '' .    a technique proposed by plaisted and greenbaum @xcite is applied to reduce the size of the transformation .",
    "if it can be determined that we are only interested in the truth of a tseitin variable , we can simplify the transformation only including the implication . in the above example , since we are only interested in the truth of tseitin variable ` a ` ( for ` f ` ) , the cnf created for ` a \\leftrightarrow ( b \\lor c ) ` , will be ` [ [ -a , b , c ] ] ` rather than ` [ [ -a , b , c],[a ,- b],[a ,-",
    "similarly when we are only interested in falsity of a tseitin variable .    to demonstrate the use of the module consider the following queries where ` t ` , ` t1 ` and ` t2 ` are the tseitin variables .",
    "figure  [ fig : adder ] illustrates the module ` adder.pl ` which includes a textbook @xcite ripple - carry circuit for binary addition .",
    "the module exports the predicate ` sum/3 ` .",
    "a call to ` sum(unary , binary , psi ) ` constructs a boolean circuit ` psi ` .",
    "the arguments ` unary ` and ` binary ` are lists of boolean formulae , the truth values of which encode unary and binary numbers respectively .",
    "these are the inputs and outputs of the circuit which can be seen as computing the binary sum of its unary inputs .",
    "the formula , ` psi ` is a propositional statement capturing the correspondence between unary and binary representations of non - negative integers .",
    "the formula ` psi ` is satisfiable exactly when ` unary ` and ` binary ` encode the same number . in the recursive call of the code ,",
    "the formula ` psi = f1*f2*f3 ` is constructed by splitting the inputs into two equal halves ( padding with a zero if necessary ) . from the recursive calls , the subformulae ` f1 ` and ` f2 ` relate the two halves of the inputs ( unary ) to the ( binary ) numbers ` s1 ` and ` s2 ` .",
    "the call to ` add(s1,s2,sum , f3 ) ` constructs the formula ` f3 ` for the binary ` sum ` of ` s1 ` and ` s2 ` .",
    "observe that the length of ` binary ` is @xmath13 ) .",
    "sum([b],[s],(s==b ) ) .",
    "sum([b1,b2|bs],sum , f1*f2*f3 ) : - split([b1,b2|bs],xs , ys ) , sum(xs , s1,f1 ) , sum(ys , s2,f2 ) , add(s1,s2,sum , f3 ) .    split ( [ ] , [ ] , [ ] ) .",
    "split([x],[x],[0 ] ) .",
    "split([x , y|xys],[x|xs],[y|ys ] ) : - split(xys , xs , ys ) .",
    "add([x|xs],[y|ys],[z|zs],(cxy==carryxy)*(z==sumxy)*sum ) : - halfadder(x , y , sumxy , carryxy ) , adder(xs , ys , cxy , zs , sum ) .",
    "adder([],[],carry,[z],z==carry ) .",
    "adder([x|xs],[y|ys],carry,[z|zs],(cxy==carryxy)*(z==sumxy)*rest ) : - fulladder(x , y , carry , sumxy , carryxy ) , adder(xs , ys , cxy , zs , rest ) .",
    "fulladder(x , y , c , ( x xor y xor c ) , ( c - > x+y ; x*y ) ) .",
    "halfadder(x , y , ( x xor y ) , x*y ) .    to demonstrate the use of the module consider the following query constructing the circuit `",
    "psi ` for the inputs ` unary = [ x+y , x*y , x==y , x xor y ] ` and outputs ` binary ` .    ?",
    "- sum([x+y , x*y , x==y , x xor y],binary , psi ) .",
    "binary = [ s1 , s2 , s3 ] psi = ( t1==x+y)*(t2==(x==y))*(t3==t1 xor t2)*(t4==t1*t2)*(t5==x*y ) * ( t6==x xor y)*(t7==t5 xor t6 ) * ( t8==t5*t6)*(s1==t3 xor t7 ) * ( s2==t4 xor t8 xor ( t3*t7 ) ) * ( s3==(t3*t7->t4+t8;t4*t8 ) )    table  [ table : sum ] illustrates the declarative meaning of the predicate depicting the truth values for ` unary ` and ` binary ` determined by ` psi ` for the 4 truth assignments of ` x ` and ` y ` .",
    "0 & 0 & [ 0 , 0 , 1 , 0 ] & [ 1 , 0 , 0 ] + 0 & 1 & [ 1 , 0 , 0 , 1 ] & [ 0 , 1 , 0 ] + 1 & 0 & [ 1 , 0 , 0 , 1 ] & [ 0 , 1 , 0 ] + 1 & 1 & [ 1 , 1 , 1 , 0 ] & [ 1 , 1 , 0 ] +    the module ` minisat.pl ` exports four predicates :    * ` solve(cnf ) ` succeeds if and only if the formula ` cnf ` in conjunctive normal form is satisfiable , binding its variables to truth values 0 ( false ) and 1 ( true ) that satisfy ` cnf ` . * ` sat(cnf ) ` succeeds if and only if the formula ` cnf ` in conjunctive normal form is satisfiable .",
    "it is similar to ` solve(cnf ) ` but does not bind any variables .",
    "* ` minimize(vec , cnf ) ` is similar to ` sat(cnf ) ` .",
    "the additional argument ` vec ` is a list of variables ( e.g. , occurring in ` cnf ` ) .",
    "the variables of ` vec ` are assigned the truth value that minimizes the binary number represented by ` vec ` for all solutions of ` cnf ` . if ` cnf ` has no solutions ( i.e. is unsatisfiable ) it fails . *",
    "` maximize(vec , cnf ) ` is similar to ` minimize(vec , cnf ) ` but the assignment returned maximizes the value of the non - negative integer represented by ` vec ` .",
    "the predicates ` minimize/2 ` and ` maximize/2 ` are illustrated in figure  [ fig : minmax ] .",
    "consider the query ` ?",
    "- maximize(xs , cnf ) ` where ` xs ` is a list of @xmath14 variables and ` cnf ` a formula in conjunctive normal form . to solve the query ,",
    "the basic idea is to pose @xmath14 questions , one for each variable of ` xs ` , to the sat solver to determine the maximum value of ` xs ` .",
    "each question determines the satisfiability of ` cnf ` when setting the next bit in ` xs ` to its maximal value .",
    "observe , in the code , that these questions are posed using ` sat ` so as not to bind variables in the formula .",
    "note also that each of these questions is of size @xmath15 .",
    "minimize([],cnf ) : - sat(cnf ) .",
    "minimize([b|bs],cnf ) : - minimize(bs , cnf ) , ( ( b=0 , sat(cnf ) ) - > true ; b=1 ) .",
    "maximize([],cnf ) : - sat(cnf ) .",
    "maximize([b|bs],cnf ) : - maximize(bs , cnf ) , ( ( b=1 , sat(cnf ) ) - > true ; b=0 ) .    to demonstrate the use of the module consider the following queries :    * ` solve/1 ` .",
    "the call succeeds binding ` x ` and ` y ` to truth values .",
    "- cnf(x==y , cnf ) , solve(cnf ) .",
    "x=0 , y=0 * ` sat/1 ` .",
    "the call succeeds without binding ` x ` and ` y ` .",
    "- cnf(x==y , cnf ) , sat(cnf ) . yes * `",
    "sum/3 ` with ` solve/1 ` .",
    "the first call succeeds binding ` x=0 ` and ` y=0 ` . in this case",
    "the circuit output is 1 ( only one of the inputs is true under this assignment ) . the second call indicates that it is possible to satisfy 2 of the inputs under the assignment ` x=0 ` and ` y=1 ` .",
    "- sum([x+y , x*y , x==y , x xor y],sum , f ) , cnf(f , cnf ) , solve(cnf ) .",
    "x = 0 , y = 0 sum = [ 1 , 0 , 0 ] ?",
    "- sum([x+y , x*y , x==y , x xor y],[0,1,0],f ) , cnf(f , cnf ) , solve(cnf ) .",
    "x = 0 , y = 1 * ` sum/3 ` with ` maximize/2 ` .",
    "the answer ` sum=[1,1,0 ] ` indicates that it is possible to satisfy at most three of the four formulae .",
    "the call ` maximize(sum , cnf ) ` binds only the elements of ` sum ` . to obtain the maximizing assignment ,",
    "` x=1 , y=1 ` , the call to ` maximize ` must be followed by a call to ` solve(cnf ) ` . + ?",
    "- sum([x+y , x*y , x==y , x xor y],sum , f ) , cnf(f , cnf ) , maximize(sum , cnf ) , solve(cnf ) .",
    "sum=[1,1,0 ] x=1 , y=1",
    "to solve a partial maxsat problem for cnf formula @xmath9 and @xmath10 we seek an assignment that satisfies @xmath9 and maximizes the number of clauses of @xmath10 which are satisfied .",
    "we solve the more general problem with @xmath9 an arbitrary propositional formula and @xmath10 a list of @xmath16 propositional formulae .",
    "the solution is illustrated in figure  [ fig : pmaxsat ] .",
    "the arguments ` phi ` and ` psi ` correspond to @xmath9 and @xmath10 respectively .",
    "the key idea is to construct the formula ` sumpsi ` representing the sum of the @xmath16 formulae in ` psi ` .",
    "this results in a vector ` max ` with @xmath17 bits .",
    "we then aim to satisfy the conjunction ` phi*sumpsi ` while maximizing the number represented by ` max ` .",
    "solving the query ` maximize(max , cnf ) ` involves @xmath18 calls to the sat solver .",
    "partialmaxsat(phi , psi ) : - sum(psi , max , sumpsi ) , cnf(phi*sumpsi , cnf ) , maximize(max , cnf ) , solve(cnf ) .",
    "for example the following query provides an assignment which satisfies @xmath19 and 4 of the 7 formula in the second argument .    ?",
    "- partialmaxsat(x+y,[x*y , x==y , x xor y ,- x+y , -x , -y , x ] ) .",
    "x = 1 , y = 1",
    "we define a prolog library for solving sat instances through an interface to the minisat solver . the combination of prolog for manipulating boolean formulae , and powerful sat tools for solving them is compelling",
    ". we can straightforwardly build solutions to difficult problems , with small and clean , pearlish code .",
    "we illustrate this in the paper by encoding a reduction from partial maxsat to sat .",
    "we have successfully used the library to solve many such problems  @xcite .              , schneider - kamp , p. , lagoon , v. , thiemann , r. , and giesl , j. 2006 .",
    "sat solving for argument filterings . in _",
    "logic for programming , artificial intelligence and reasoning ( lpar)_. vol .",
    "springer , 3044 .",
    "an extensible sat - solver . in _ theory and applications of satisfiability testing , 6th international conference , sat 2003 ( selected revised papers ) _ , e.  giunchiglia and a.  tacchella , eds .",
    "lecture notes in computer science , vol . 2919 .",
    "springer , 502518 .",
    "\\1968 . on the complexity of derivation in propositional calculus . in _ studies in constructive mathematics and mathematical logic_. 115125 . reprinted in j. siekmann and g. wrightson ( editors ) , automation of reasoning , vol .",
    "466 - 483 , springer - verlag berlin , 1983 .",
    "an overview of the swi - prolog programming environment . in _ proceedings of the 13th international workshop on logic programming environments _ , f.  mesnard and a.  serebenik , eds .",
    "katholieke universiteit leuven , heverlee , belgium , 116 ."
  ],
  "abstract_text": [
    "<S> this paper presents a prolog interface to the minisat satisfiability solver . </S>",
    "<S> logic programming with satisfiability combines the strengths of the two paradigms : logic programming for encoding search problems into satisfiability on the one hand and efficient sat solving on the other . </S>",
    "<S> this synergy between these two exposes a programming paradigm which we propose here as a logic programming pearl . to illustrate logic programming with sat solving we give an example prolog program which solves instances of partial maxsat .    to appear in theory and practice of logic programming ( tplp ) </S>"
  ]
}