{
  "article_text": [
    "wavelets are versatile functions with a wide range of applications including time - frequency analysis , data compression , and numerical analysis .",
    "the objective of these notes is to provide an introduction to the properties of wavelets which are useful for solving integral and differential equations by using the wavelets to represent the solution of the equations .    while there are many types of wavelets , we concentrate primarily on orthogonal wavelets of compact support , with particular emphasis on the wavelets introduced by daubechies .",
    "the daubechies wavelets have the additional property that finite linear combinations of the daubechies wavelets provide local pointwise representations of low - degree polynomials .",
    "we also have a short discussion of continuous wavelets in the appendix i and spline wavelets in appendix ii .",
    "there notes are not intended to provide a complete discussion of the subject which can be found in the references given at the end of this section .",
    "rather , we concentrate on the specific properties which are useful for numerical solutions of integral and differential equations .",
    "our approach is to develop the wavelets as orthonormal basis functions rather than in terms of low- and high - pass filters , which is more common for time - frequency analysis applications .",
    "the daubechies wavelets have some properties that make them natural candidates for basis functions to represent solutions of integral equations . like splines , they are functions of compact support that can locally pointwise represent low degree polynomials . unlike splines , they are orthonormal .",
    "more significantly , only a relatively small number of wavelets are needed to represent smooth functions .",
    "one of the interesting features of wavelets is that they can be generated from a single scaling function , which is the solution of a liner renormalization - group equation , by combinations of translations and scaling .",
    "this equation , called the scaling equation , expresses the scaling function on one scale as a finite linear combination of discrete translations of the same function on a smaller scale .",
    "the resulting scaling functions and wavelets have a fractal - like structure .",
    "this means that they have structure on all scales .",
    "this requires a different approach to the numerical analysis , which is provided by the scaling equation .",
    "these notes make extensive use of the scaling function .",
    "some of the references that we have found useful are :    [ 1 ] i. daubechies , orthonormal bases of compactly supported wavelets , comm .",
    "pure appl . math . *",
    "41*(1988)909 .",
    "[ 2 ] g. strang , `` wavelets and dilation equations : a brief introduction , '' siam review , 31:4 , pp .",
    "614627 , ( dec 1989 ) .",
    "[ 3 ] i. daubechies , _ ten lectures on wavelets _ , siam , philadelphia , 1992 .",
    "[ 4 ] c. k. chui _ wavelets - a tutorial in theory and applications _ , academic press , 1992 .    [ 5 ] w .- c .",
    "shann , `` quadrature rules needed in galerkin - wavelets methods '' , proceedings for the 1993 annual meeting of chinese mathematics association , chiao - tung univ , ( dec 1993 ) .    [",
    "6 ] w .- c .",
    "shann and j .- c .",
    "yan , `` quadratures involving polynomials and daubechies wavelets '' , technical report 9301 , department of mathematics , national central university , ( 1993 ) .",
    "[ 7 ] g. kaiser , _ a friendly guide to wavelets _ , birkhauser 1994 .",
    "[ 8 ] w. sweldens and r. piessens , `` quadrature formulae and asymptotic error expansions for wavelet approximations of smooth functions '' , siam j. numer .",
    ", 31 , pp . 12401264 , ( 1994 ) .",
    "[ 9 ] h. l. resnikoff and r. o. wells , _ wavelet analysis , the scalable structure of information _ , springer verlag , ny .    [ 10 ] o. bratelli and p. jorgensen , _ wavelets through a looking glass _ , birkhauser , 2002 .",
    "in addition , some of the material in these notes is in our paper    [ 11 ] b. m. kessler , g. l. payne , and w. n. polyzou , scattering calculations with wavelets , few body systems , 33,1 - 26(2003 ) .",
    "scaling functions play a central role in the construction of orthonormal bases of compactly supported wavelets .",
    "the scaling functions and wavelets are distinct bases related by an orthogonal transformation called the wavelet transform .",
    "the concept of scaling functions is most easily understood using haar wavelets ( these are made out of simple box functions ) .",
    "the haar functions are the simplest compactly supported scaling functions and wavelets .",
    "the * haar scaling function * is defined by ( x ) : = \\ {    ll 0 & x 0 + 1 & 0<x1 + 0 & x>1    . .",
    "it satisfies the normalization conditions : ( , ) : = ^_- ^ * ( x ) ( x ) dx = _",
    "0 ^ 1 ( x ) dx = 1 .",
    "the operations of discrete translation and dilatation are used extensively in the study of compactly supported wavelets .",
    "the * unit translation operator @xmath0 * is defined by ( t ) ( x ) = ( x-1 ) .",
    "this operator translates the function @xmath1 to the right by one unit .",
    "the unit translation operator has the property : ( t , t ) = ^_- ^ * ( x-1 ) ( x-1 ) dx= ^_- ^ * ( y ) ( y ) dy= ( , ) where @xmath2 .",
    "this means that the unit translation operator preserves the scalar product : ( t , t ) = ( , ) .",
    "if @xmath3 is a linear operator its * adjoint * @xmath4 is defined by the relation ( , a^ ) = ( a , ) .",
    "it follows that ( , t^ ) = ( t , ) = ^_- ^ * ( x-1 ) ( x ) dx . changing variables to @xmath2 gives ( , t^ ) = ^_- ^ * ( y ) ( y+1 ) dy or ( t^ ) ( x ) = ( x+1 ) which is a left shift by one unit . since ( , ) = ( t , t)= ( , t^ t ) it follows that @xmath5 .",
    "an operator whose adjoint is its inverse is called unitary .",
    "unitary operators preserve inner products .",
    "it follows from the definition of the haar scaling function , @xmath6 , that @xmath7 ^1_0 ( x - n+m ) dx = _ nm this means the functions _",
    "n ( x ) : = ( t^n ) ( x ) = ( x - n ) are orthonormal .",
    "there are an infinite number of these functions for integers @xmath8 satisfying @xmath9 .",
    "the integer translates of the scaling function span a space , @xmath10 , which is a subspace of the space of square integrable functions .",
    "the elements of @xmath10 are functions of the form f(x ) = _",
    "n=-^ f_n _ n ( x ) = _ n=-^ f_n ( t^n ) ( x ) = _ n=-^ f_n ( x - n ) , where the square integrability requires that the coefficients satisfy _",
    "n=-^ f_n ^2 < . for the haar scaling function @xmath10 is the space of square integrable functions that are piecewise constant on each unit - width interval .",
    "note that while there are an infinite number of functions in @xmath10 , it is a small subspace of the space of square integrable functions .",
    "in addition to translations @xmath0 , the linear operator @xmath11 , corresponding to * discrete scale transformations * , is defined by : ( d ) ( x ) = 1 ( x/2 ) .",
    "when this is applied to the haar scaling function it gives    \\(d ) ( x ) = \\ {    ll 0 & x 0 + 1 & 0<x2 + 0 & x>2    . .",
    "this function has the same box structure as the original haar scaling function , except it is twice as wide as the original scaling function and shorter by a factor of @xmath12 .",
    "note that the normalization ensures ( d , d ) = ^_- 1 2^ * ( x/2 ) ( x/2 ) dx = ^_- ^ * ( y ) ( y ) dy = ( , ) where the variable in the integrand has been changed to @xmath13 .",
    "the adjoint of @xmath11 is determined by the definition ( , d^ ) = ( d , ) = ^_- 1 ^ * ( x/2 ) ( x ) dx . setting @xmath13 gives ^_-^ * ( y ) ( 2y ) dy which gives ( d^)(x)= ( 2x ) .",
    "this shows that @xmath14 or @xmath11 is also unitary .",
    "define the functions constructed by @xmath8 translations followed by @xmath15 scale transformations _ mn ( x ) = ( d^m t^n ) ( x ) = ( d^m _ n ) ( x ) = 2 ^ -m/2 ( 2 ^ -mx -n ) = 2 ^ -m/2 ( 2 ^ -m(x - 2^m n ) ) .",
    "it follows that for a fixed scale @xmath15 ( _ mn , _ mk ) = ( d^m _ n , d^m _ k ) = ( _ n , d^m - m _ k)= ( _ n , _",
    "k ) = _ nk .",
    "this shows that the functions @xmath16 for any fixed scale @xmath15 are orthonormal .",
    "we define the subspace @xmath17 of the square integrable functions to be those functions of the form : f(x ) = _ n=-^ f_n _ mn ( x ) = _ n=-^ f_n ( d^mt^n ) ( x ) where the square integrability requires that the coefficients satisfy _ n=-^ f_n ^2 < .",
    "these elements of @xmath17 are square summable functions that are piecewise constant on intervals of width @xmath18 .",
    "the spaces @xmath17 and @xmath10 are related by @xmath15 scale transformations @xmath19 .    in general",
    "the scaling function @xmath6 is defined as the solution of a scaling equation subject to a normalization condition .",
    "the scaling equation relates the scaled scaling function , @xmath20 , to translates of the original scaling function .",
    "the general form of the * scaling equation * is ( d ) ( x ) = _ l h_l t^l ( x ) [ eq : aaxx ] where @xmath21 are fixed constants , and the sum may be finite or infinite .",
    "this equation can be expressed as ( x2 ) = _ l h_l ( x - l ) which is sometimes written as ( x ) = _ l h_l ( 2 x - l ) = _ l c_l ( 2 x - l ) where @xmath22 . equation ( [ eq : aaxx ] ) is the most important equation in these notes .    in general",
    "the scaling equation can not be solved analytically . in the special case of the haar scaling function the solution",
    "is obtained by observing that the scaled box is stretched over two adjacent boxes with a suitable reduction in height .",
    "it follows that : @xmath23 = 1 ( x ) + 1 ( x-1 ) . here",
    "these coefficients are special to the haar scaling function . the best way to think about",
    "the scaling function @xmath6 is to note that the scaling function @xmath6 is the solution of the scaling equation up to normalization .",
    "the normalization is fixed by @xmath25    an additional relation involving the translation @xmath0 and dilatation operator @xmath11 is useful for future computations .",
    "first note that    dt ( x ) = d ( x-1 ) = 1 ( x/2 - 1 ) = 1 ( x-2 2 ) = t^2 d ( x ) , which leads to the operator relation dt = t^2 d .",
    "it follows from this equation that d_n(x ) = d t^n ( x)= t^2nd ( x ) = t^2n ( h_0 ( x ) + h_1 t ( x ) ) .",
    "this shows that all of the basis elements in @xmath26 can be expressed in terms of basis elements in @xmath10 . for the case of the haar scaling function",
    "this is obvious , but the argument above is more general .    specifically if @xmath27 then ( x ) = _ n=-^ d_n _",
    "1n(x ) = _ n= -^ d_n d _",
    "n= -^ [ d_n h_0 _ 2n(x ) + d_n h_1 _",
    "2n+1(x ) ] = _ -^ e_n _ n(x ) where e_2n = d_n h_0 e_2n+1 = d_n h_1 .",
    "it is easy to show that _",
    "n=-^ e_n ^2 = _",
    "n=-^ d_n ^2 .    what we have shown , as a consequence of the scaling equation , is the inclusion property _ 0 _ 1 . similarly , using the same method ,",
    "it is possible to show the chain of inclusions _ -k _ -k+1 _ 0 _ k _ k+1 these properties hold for the solution of any scaling equation . in the haar example",
    "the spaces @xmath17 are spaces of piecewise constant , square integrable functions that are constant on intervals of the real line of width @xmath18 .",
    "the subspaces @xmath17 are used as approximation spaces in applications . to understand how they are used as approximation spaces note that as @xmath28 the approximation to @xmath29 given by f_m ( x ) = _",
    "n=-^ f_mn _",
    "mn(x ) with f_mn = _ -^ _ mn(x ) f(x ) dx is bounded by the upper and lower riemann sums for steps of width @xmath30 .",
    "this is because , up to a scale factor , the coefficients @xmath31 are just average values of the function on the appropriate sub - interval ( to deal with the infinite interval it is best to first consider functions that vanish outside of finite intervals and take limits ) . since the upper and lower riemann sums converge to the same integral ( when the function is integrable ) it follows that    _",
    "-^ f_m(x)-f(x)dx < for sufficiently large @xmath32 . a similar argument",
    "can be extended to get @xmath33 convergence .    similarly , as @xmath34",
    ", the width of @xmath16 grows like @xmath18 while the height falls off like @xmath35 .",
    "again , if the function vanishes outside of a bounded interval then for sufficiently large @xmath15 there is only one ( or two ) @xmath16 that are non - vanishing where the function is non - vanishing . in the case that only one @xmath36 overlaps the support of @xmath29 f_m ( x ) ~2 ^ -m/2 _ mn_0 ( x ) _",
    "-^ f(x ) dx .",
    "the integral of the square of this function @xmath37 as @xmath38 .",
    "note that _",
    "-^ f_m(x ) dx _",
    "-^ f(x)dx as @xmath38 .",
    "this shows that the limit of the integral of @xmath39 as @xmath40 is finite in @xmath41 but @xmath42 in @xmath33 .",
    "it is useful to express some of these results in a more useful form .",
    "define the projection operators p_m f(x ) = _",
    "n=-^ f_mn _ mn ( x ) where f_mn = _ - ^ _ mn^ * ( x ) f(x ) dx .",
    "the above conditions can be stated in terms of these projectors : _",
    "m - p_m = i [ eq : comp ] _",
    "m + p_m = 0 .",
    "[ eq : null ] these results mean that the approximation space @xmath17 approaches the space of square integrable functions as @xmath43 .",
    "we have shown that ( [ eq : comp ] ) and ( [ eq : null ] ) are valid for the haar scaling function , but they are also valid for a large class of scaling functions ,    we are now ready to construct * wavelets*. first recall the condition _ 0 _ 1 .",
    "let @xmath44 be the subspace of vectors in the space @xmath10 that are orthogonal to the vectors in @xmath26",
    ". we can write _ 0 = v_1 _ 1 .",
    "this notation means that any vector in @xmath10 can be expressed as a sum of two vectors - one that is in @xmath26 and one that is orthogonal to every vector in @xmath26 .",
    "note that the scaling equation implies that every vector in @xmath26 can be expressed as a linear combination of vectors in @xmath10 using d_n ( x ) = h_0 _ 2n ( x ) + h_1 _ 2n+1 ( x ) .",
    "clearly the functions that are orthogonal to these in @xmath26 on the same interval can be expressed in terms of the difference functions _",
    "1n ( x ) : = d_n ( x ) = h_1 _ 2n ( x ) - h_0 _ 2n+1 ( x ) = 1 ( _ 2n ( x ) - _ 2n+1 ( x ) ) .",
    "direct computation shows that the @xmath45 are elements of @xmath10 that satisfy ( d_1n , d_l ) = 0 . and ( _ 1n , _",
    "1k ) = _ nk .",
    "thus we conclude that @xmath44 is the space of square integrable functions of the form f(x ) = _ n=-^ f_n _",
    "1n ( x ) with f(x ) = _ n=-^",
    "f_n ^2 .",
    "similarly , we can decompose @xmath46 for each value of @xmath47 .",
    "for the special case of @xmath48 we define the haar * mother wavelet * as ( x ) : = d^-1 ( h_1 ( x ) - h_0 t ( x ) ) = h_1 ( 2 t ) - h_0 ( 2(t-1))= ( ( 2 t ) - ( 2(t-1 ) ) ) which is manifestly orthogonal to the scaling function .",
    "translates of the mother wavelet define a basis for @xmath48 _ n ( x ) = t^n ( x ) = t^n d^-1 ( h_1 ( x ) - h_0 t ( x ) ) = d^-1 ( h_1 _ 2n ( x ) - h_0 _ 2n+1 ( x ) ) .",
    "if we decompose @xmath17 we have : @xmath49 @xmath50 = w_-m+1 _ -m+2 _ l _ l. [ eq : mres ] note that unlike the @xmath17 spaces , the @xmath51 spaces are all mutually orthogonal , since if @xmath52 which is orthogonal to @xmath53 by definition .    if @xmath29 is any square integrable function the conditions _ m - p_m = i [ eq : lima ] _",
    "m + p_m = 0 [ eq : limb ] mean that for sufficiently large @xmath15 and any @xmath47 that @xmath29 can be well approximated by a function in _",
    "-m+1 _ -m+2 _ l .",
    "this means that the function can be approximated by a linear combination of basis functions ( wavelets ) from each of the spaces @xmath54 .",
    "a * multiresolution analysis * is a set of subspaces @xmath17 and @xmath51 satisfying ( [ eq : mres ] ) , ( [ eq : lima ] ) , and ( [ eq : limb ] ) .",
    "the condition ( [ eq : lima ] ) allows one to interpret the space @xmath55 , for sufficiently large @xmath32 , as an approximation space for numerical applications .",
    "basis functions for @xmath51 are given by _",
    "mn(x ) = d^m t^n ( x ) = d^m-1 ( h_1 _ 2n ( x ) - h_0 _ 2n+1 ( x ) ) .",
    "[ eq : mom ] that these are a basis with the required properties is easily shown by showing that these functions are orthogonal to @xmath55 and can be used to recover the remaining vectors in @xmath56 .",
    "the functions @xmath57 , are called haar wavelets .",
    "they satisfy the orthonormality conditions : ( _ nl , _",
    "nl ) = _ nn _ ll where the @xmath58 follows from the orthogonality of the spaces @xmath53 and @xmath59 for @xmath60 .",
    "the @xmath61 follows from the unitarity of @xmath11 and ( , t^n ) = _ n0 .",
    "the important steps discussed above generalize to the case of a general scaling equation of the form : d(x ) = h_l t^l ( x ) .",
    "this equation is solved to find the scaling function @xmath6 .",
    "this , along with translations and dilatations is used to construct the spaces @xmath62 .",
    "the scaling equation ensures the existence of spaces @xmath51 , satisfying @xmath63 that can be used to build discrete orthonormal bases .",
    "the mother wavelet function is expressed in terms of the scaling function and the coefficients @xmath21 as ( x ) = d^-1 _ l g_l t^l ( x ) where we will see later that g_l = ( -)^kh_k - l where @xmath64 is any odd integer . in general",
    "the coefficients @xmath21 must satisfy constraints for the solution to the scaling equation to exist .",
    "general wavelets can be expressed in terms of the mother wavelet using ( [ eq : mom ] ) . in the next section the coefficients @xmath65",
    "will be expressed in terms of the scaling function .",
    "this section extends the treatment of scaling equation to a more general class of scaling functions than the haar functions . in general",
    ", a scaling function satisfies the following three conditions .",
    "first , the * scaling function * is the solution of the * scaling equation * d ( x ) = _ l h_l t^l ( x ) [ eq : iaa ] where @xmath21 are numerical coefficients that define the scaling equation .",
    "second , in addition to satisfying the scaling equations , * integer translates * of the scaling functions are required to be * orthonormal * ( _",
    "m ) = ( t^n , t^m ) = ( , t^m - n ) = _ mn . [ eq : norma ] third , the initial scale is fixed by the * normalization condition * ( x ) dx = 1 .",
    "[ eq : normb ] it might seem like the normalization conditions in ( [ eq : norma ] ) and ( [ eq : normb ] ) are not compatible . to see that this is not true note that condition ( [ eq : norma ] ) is invariant under unitary changes of scale of the form @xmath66 while condition ( [ eq : normb ] )",
    "it follows that condition ( [ eq : normb ] ) can be interpreted as setting a starting scale , @xmath67 .",
    "the condition ( [ eq : norma ] ) is preserved independent of the starting scale .",
    "we now investigate the consequences of these three conditions . using the definitions of the operators @xmath11 and @xmath0",
    "the scaling equation becomes : ( x 2 ) = h_l ( x - l ) .",
    "[ eq : iab ] as shown in section 1 , it can be put in the useful form ( x ) = _ l h_l ( 2x - l ) .",
    "[ eq : iac ] in general the sums may be from @xmath68 .",
    "finite sums are treated by assuming that only a finite number of the @xmath21 s are non zero .",
    "all of the compactly supported scaling functions are solutions of scaling equations with a finite number of non - zero coefficients .",
    "if the scaling equation has a solution , it is unique up to an overall normalization factor . to see this",
    "take the fourier transform of both sides of equation ( [ eq : iac ] ) to get ( k)= 1 _",
    "-^ e^-i k x ( x ) dx = _",
    "-^ e^-i k x ( 2x - l ) dx . [ eq : iad ]    changing variables @xmath69 on the right - hand side gives _",
    "e^-i k x ( x )",
    "dx = _ l 1 h_l 1 _",
    "-^ e^-i ( k/2 ) ( x+l ) ( x ) dx [ eq : iae ] or ( k ) = ( k 2 ) ( k 2 ) [ eq : iaf ] where ( k ) = _",
    "l h_l e^-i k l .",
    "[ eq : iag ]    this form of the scaling equation can be iterated @xmath8 times to get : ( k ) = ( k 2^n ) _",
    "m=1^n ( k 2^m ) [ eq : iah ]    this equation holds for any @xmath8 provided the fourier transforms exist . for a finite @xmath8",
    ", an approximation can be made by a finite number of iterations of the form _",
    "n ( k ) = _ n-1(k 2 ) ( k 2 ) [ eq : iai ] for any starting function @xmath70 . in the limit of large @xmath8",
    "the function @xmath71 should converge to a solution to the scaling equation .",
    "the result of formally taking this limit is @xmath72 = ( 0 ) _ l=1^ ( k 2^l ) .",
    "[ eq : iaj ] if the limit exists as @xmath73 , and the scaling function is continuous in a neighborhood of zero , then the solution of the scaling equation is uniquely determined by the scaling coefficients @xmath21 up to the overall normalization @xmath74 .",
    "the condition @xmath75 is equivalent to the standard normalization condition @xmath76 the resulting solution of the scaling equation is independent of the choice of starting function provided it is normalized so @xmath77 .",
    "once the normalization is fixed , the limit only depends on the coefficients @xmath21 .    thus , if the infinite product converges , then we have an expression for the scaling function , up to normalization , which is fixed by assigning a value to @xmath78 . to show how this works we compute this limit for the haar scaling equation .    for the haar scaling equation the expression for the scaling function",
    "is @xmath79 @xmath80 expanding this out in powers of @xmath81 gives @xmath82 @xmath83 = 1 e^-ik/2(k/2 ) ( k/2 ) .",
    "[ eq : iaja ] a direct calculation of the fourier transform of the haar scaling function gives @xmath84 = 1 e^-ik/2(k/2 ) ( k/2 ) which agrees with ( [ eq : iaja ] ) .",
    "the above analysis shows that the solution of the scaling equation depends on the choice of scaling coefficients @xmath21 .",
    "the scaling coefficients @xmath21 are not arbitrary .",
    "first note that setting @xmath85 in ( [ eq : iaj ] ) gives 1 = _",
    "[ eq : iak ] now using ( [ eq : iag ] ) gives ( 0 ) = 1 = _",
    "l h_l or _ l h_l = .",
    "[ eq : ial ] this condition is satisfied by the haar wavelets .",
    "this is a necessary condition on the scaling coefficients in order to have a solution to the scaling equation .",
    "another condition which constrains the scaling coefficients is the orthogonality of the unit translates , @xmath86 .",
    "this requires , using ( [ eq : iac ] ) , @xmath87 @xmath88 @xmath89 = _",
    "l h_l h_l-2(m - n ) = _ mn [ eq : iam ] or equivalently _",
    "l h_l-2 m h_l = _ m0 .",
    "[ eq : ian ] this is trivially satisfied for the haar wavelets .",
    "here and in all that follows we restrict our considerations to the case that the scaling coefficients and scaling functions are real .",
    "the orthogonality condition also requires that the number of non - scaling coefficients must be even . to see this assume by contradiction that there are @xmath90 non - zero scaling coefficients , @xmath91 .",
    "then setting @xmath92 in ( [ eq : ian ] ) gives _",
    "l h_l+2n h_l = h_2n h_0 = _",
    "n0 = 0 . which means that either @xmath93 or @xmath94 , which contradicts the assumption that there are @xmath90 non - zero scaling coefficients .",
    "this shows that if the number of non - zero scaling coefficients are finite , then there must be an _ even number _ , @xmath95 , with @xmath96 .",
    "note that if there are only two non - vanishing scaling coefficients , @xmath97 and @xmath98 , then the conditions ( [ eq : ial ] ) and ( [ eq : ian ] ) have a unique solution , which is the haar scaling coefficients . in this case",
    "these equations become h_0 + h_1= h_0 h_0 + h_1 h_1 = 1 .",
    "these equations have the unique solution @xmath99 .    conditions ( [ eq : ial ] ) and ( [ eq : ian ] ) are important constraints on the scaling coefficients .    for scaling equations with more than two non - zero scaling coefficients ,",
    "additional conditions are needed to determine the scaling coefficients .",
    "the number of non - zero scaling coefficients determines the support of the scaling function .",
    "the important property is that scaling functions that are solutions of a scaling equation with a finite number of non - zero scaling coefficients have compact support .",
    "the support is determined by the number of non - zero scaling coefficients .    to determine the support of the scaling function ,",
    "consider a scaling equation with @xmath100 non - zero scaling coefficients .",
    "the scaling function is given by @xmath101 @xmath102 @xmath103    this defines the scaling function as a distribution .",
    "this is not a useful representation for computation , however it indicates that if a scaling function has @xmath104 non - zero coefficients @xmath21 then the scaling function has support on @xmath105 = [ 0,n-1]\\ ] ] where @xmath104 is the number of non - zero scaling coefficients .    while the support condition depends only on the number of non - zero coefficients ,",
    "there are many scaling functions with @xmath104 non - zero scaling coefficients . except for the constraints dictated by the scaling equation , orthonormality , and normalization",
    ", there is considerable freedom in choosing the coefficients @xmath21 .",
    "the scaling coefficients also determine the mother wavelet function .",
    "in the general case the spaces @xmath17 are the spaces of square integrable functions spanned by the orthogonal basis functions @xmath106 for integer @xmath8 satisfying @xmath9 . as in the haar case , the scaling equation implies that @xmath107 for @xmath108 .",
    "wavelet spaces are defined by @xmath109 it they also satisfy ( [ eq : lima ] ) and ( [ eq : limb ] ) they define a * multiresolution analysis*. the * mother wavelet function * lives in the space @xmath48 which means that it has an expansion in @xmath110 : ( x ) = _ n g_n ( 2x - n ) = _ n g_n d^-1 t^n ( x ) .",
    "[ eq : iau ] this equation can be expressed in a form similar to the scaling equation : d ( x ) = _ n g_n t^n ( x ) .",
    "[ eq : iav ]    the mother wavelet and all of its integer translates should be orthogonal to the scaling function , which is in @xmath10 . in terms of the coefficients",
    "this requirements is : @xmath111 @xmath112 = _",
    "n h_n+2 m g_n = 0 [ eq : iava ] for all @xmath15 .",
    "orthonormality of the translated mother function requires @xmath113 _ k g_k+2(n - m ) g_k = _ mn [ eq : iaw ] or equivalently ( _ m , ) = _ k g_k+2 m g_k = _ m0 .",
    "[ eq : iax ] the choice @xmath114 where @xmath47 is any odd integer it satisfies ( [ eq : iav ] ) and ( [ eq : iax ] ) : @xmath115 = _ k h_k+2(n - m ) h_k",
    "= _ mn [ eq : iay ] where we have let @xmath116 in the last term .",
    "it also follows that @xmath117 @xmath118 = ( -1)^l_n g_n h_n+2 m .",
    "[ eq : iaz ] since @xmath47 is odd , the sum is equal to its negative which shows that it vanishes .",
    "the choice of @xmath47 is arbitrary - changing @xmath47 shifts the origin of the mother by an even number of steps .",
    "since the mother is orthogonal to all integer translates of the scaling function , it does not matter where the origin is placed .",
    "this shows that the coefficients @xmath21 , satisfying _",
    "[ eq : iba ] _",
    "l h_l-2 m h_l = _ m0 [ eq : ibb ] with @xmath119 defined by g_k : = ( -1)^k h_l - k l [ eq : ibc ] give a multi - resolution analysis , scaling function , and a mother function .",
    "the daubechies order-@xmath120 wavelets are defined by the conditions x^n ( x ) dx = 0 , n=0,1 , , k-1 .",
    "[ eq : daubcon ] these equations ensure that polynomials of degree @xmath121 can be locally represented by finite linear combinations of scaling functions on a fixed scale .",
    "this is a useful property for numerical approximations .",
    "the order @xmath120-daubechies scaling function has @xmath95 scaling coefficients , with @xmath122 corresponding to the haar wavelets , and each additional value of @xmath120 adds one more orthogonality condition .",
    "the scaling equation ( [ eq : iav ] ) and the moment conditions ( [ eq : daubcon ] ) for the mother wavelet function gives the additional equations necessary to find the daubechies scaling coefficients , @xmath21 : @xmath123 @xmath124 this gives @xmath125 for @xmath126 this gives ( using the @xmath126 equation ) @xmath127 for @xmath128 this gives @xmath129 for @xmath130 this gives @xmath131 @xmath132 @xmath133 when coupled with @xmath134 and the orthonormality constraints , @xmath135 we get a system of equations that can be solved for the daubechies-@xmath120 scaling coefficients .",
    "the cases @xmath136 have analytic solutions .",
    "these solutions are given in table 1 .",
    "* table 1 : scaling coefficients *   +    [ cols=\"<,<,<,<\",options=\"header \" , ]",
    "the scaling equation can also be used as a tool to solve differential equations . consider the following approximation of the function @xmath29 given by f(x ) ~_n f_n _ mn ( x ) [ eq : expa ] where @xmath137 is the scaling function basis on the approximation space @xmath17 . as @xmath28 this representation becomes exact .    for the purpose solving differential equation",
    "we want to calculate approximate derivatives of @xmath29 on the same approximation space @xmath138 @xmath139 the orthonormality of the scaling basis functions can be used to find the expansion coefficients @xmath140 and @xmath141 : d_n : = _ mn ( x ) f ( x ) dx = - _mn ( x ) f(x ) dx . [ eq : expb ] d_n : = _ mn ( x ) f  ( x ) dx =  _ mn ( x ) f(x ) dx . [ eq : expbb ] using the expansion ( [ eq : expa ] ) in ( [ eq : expb ] ) gives @xmath142 and @xmath143 the coefficients @xmath144 and @xmath145 are needed to compute the expansion coefficients @xmath140 and @xmath141 for the derivatives in terms of the expansion coefficients @xmath146 of the function .    given these linear relations between the coefficients @xmath147 and @xmath141 , the solution of a linear differential equation can be reduced to solving a linear algebraic system for the coefficients @xmath148 .",
    "the size of this system can be reduced by employing the wavelet transformation .",
    "the method of solution depends on the type of problem .",
    "standard methods can be used to enforce boundary conditions ; the only trick is that all of the basis functions with support that overlaps the boundary should be retained .",
    "the goal of this section is to show that the scaling equation can be used to compute the needed overlap integrals .    to proceed we first consider the simplest case where the scale @xmath149 .",
    "using unitarity of the translation operator gives the following relations @xmath150 @xmath151 in addition these coefficients have the following symmetry relations @xmath152 @xmath153 and @xmath154 which follow by integration by parts .    the overlap coefficients can be computed using the scaling equation and the derivatives of the scaling equation : @xmath155 @xmath156 @xmath157    we first consider the computation of the coefficients @xmath158 .    for @xmath159 defined by @xmath160",
    "this leads to the following linear relations among the overlap coefficients @xmath161 = 2 _ l ,",
    "l=0 ^ 2k-1 h_l h_l ( y - 2n -l+l )  ( y ) dy = 2 _ l , l=0 ^ 2k-1 h_l h_l a_2n + l - l .",
    "[ eq : hom ] since both @xmath6 and @xmath162 have support for @xmath163 , the non - zero terms in the sum are constrained by @xmath164 for the second derivative these equations are replaced by a_n : = (  ( x ) , _",
    "n ) = 8 _ l ,",
    "l=0 ^ 2k-1 h_l h_l a_2n + l - l [ eq : homa ] these linear equation are homogeneous and must be supplemented by a normalization condition . for the daubechies",
    "wavelets of order @xmath165 we have the expansion @xmath166 where the expansion coefficients are @xmath167 and @xmath168 @xmath169 thus @xmath170 these equations can be differentiated to get @xmath171 multiplying by @xmath6 and integrating gives the desired inhomogeneous equation @xmath172 -_n n ( _ n ,  ) = - _ n n a_n [ eq : inho ] and 2= _",
    "n n^2 a_n  [ eq : inhoa ] equations ( [ eq : hom ] ) and ( [ eq : inho ] ) or ( [ eq : hom ] ) and ( [ eq : inhoa ] ) are linear systems that can be used to solve for the coefficients @xmath173 and @xmath174 .    in general",
    ", it is desirable to expand a function using a scaling basis associated with a sufficiently small scale @xmath15 , in addition , for efficiency it also useful to use the basis on the approximation space @xmath17 consisting or the scaling functions on the scale @xmath175 and wavelet basis functions on scales between @xmath176 and @xmath175 .",
    "finally , one needs to be able to treat higher derivatives .",
    "generalizations of the methods can be used to find exact expression for all of these quantities expressed a solutions of linear equations involving the scaling coefficients . for the higher derivatives it is necessary to use a daubechies wavelet of sufficiently high order . the number of derivative of the wavelet and scaling function basis increases with order .",
    "a necessary condition for the solution of the scaling equation to have @xmath64 derivatives can be obtained by differentiating the scaling equation @xmath64 times , which gives @xmath177 letting @xmath178 and @xmath179 gives the equation @xmath180 where the non - zero values of @xmath181 satisfy @xmath182 . for this equation of",
    "have a solution the matrix @xmath183 must have eigenvalue @xmath184 .",
    "this is a necessary condition for the basis to have @xmath64 derivatives . when the @xmath64-th derivative exists , it can be computed up to normalization by iterating the fourier transform of equation ( [ eq : der ] ) .",
    "the method used to compute wavelets at dyadic points can also be used with the above equation to compute the @xmath64-th derivatives of scaling functions and wavelets at dyadic points .",
    "the scaling equation can be used to exactly compute all of the expansion coefficients . in order to exhibit the key relations it is useful to use operators : df(x ) = 1 f ( x 2 ) tf(x ) = f ( x -1 ) f(x ) = df dx(x ) .",
    "direct computation shows the following intertwining relations d = 1 2 d d",
    "t = t ^ = - t^ = t^-1 d^ = d^-1 .",
    "we also have the scaling equations : d= _",
    "l g_l t^l .    using",
    "the operator relations above give d ^r = 2^r _ l h_l t^l ^r d ^r = 2^r _ l g_l t^l ^r .",
    "the different expansion coefficients can be expressed in terms of these operators as ( _ mn , ^r _ mn ) = ( d^m t^n , ^r d^m t^n ) ( _ mn , ^r _ mn ) = ( d^m t^n , ^r d^m t^n ) ( _ kn , ^r _ mn ) = ( d^k t^n , ^rd^m t^n ) ( _ kn , ^r _ mn ) = ( d^k t^n , ^r d^m t^n ) . the following steps are used to evaluate these coefficients :    \\1 .",
    "move all of the factors of @xmath11 to a single side of the equation .",
    "choose the side where the power of @xmath11 is positive .",
    "move the @xmath11 s through all derivatives .",
    "use the scaling equations to eliminate all of the @xmath11 s .",
    "move all of the @xmath0 s to the left side of the scalar product .    using these steps",
    "all of the overlap coefficients can be expressed in terms of ( _",
    "n , ^r ) ( _ n , ^r ) ( _ n , ^r , ) ( _ n , ^r ) the scaling equation can be used to express all of the @xmath185 terms in terms of the @xmath186 terms .",
    "the result is at all of the coefficients can be expressed in terms of the coefficients ( _ n , ^r ) we have shown how to compute these for @xmath187 and @xmath188 .",
    "the coefficients for larger values of @xmath189 can be obtained by solving the system : @xmath190 a^(r)_n : = (  ( x ) , _",
    "n ) = 2 ^ 2r-1 _ l , l=0 ^ 2k-1 h_l h_l a^(r)_2n + l - l [ eq : homc ]",
    "we want to find the solution to the s - wave schrdinger equation @xmath191+v(r)\\,\\psi(r )        = e\\,\\psi(r ) \\label{scheqn}\\ ] ] for a particle with mass @xmath15 and energy @xmath192 , where @xmath193 has the asymptotic form @xmath194 and @xmath195 is zero at the origin . equation ( [ scheqn ] ) can be rewritten in the form @xmath196+u(r)\\,\\psi(r )        = k^2 \\psi(r ) \\ , , \\label{ueqn}\\ ] ] where @xmath197 to solve equation ( [ ueqn ] ) we choose a complete set of basis functions @xmath198 and write @xmath199 to solve for the expansion coefficients @xmath159 we first multiply equation ( [ ueqn ] ) by @xmath200 and integrate from @xmath42 to @xmath201 .",
    "this gives @xmath202\\,dr + \\int_0^r \\phi_m(r)\\,u(r)\\,\\psi(r ) r^2dr       = k^2 \\int_0^r \\phi_m(r)\\,\\psi(r ) \\,r^2dr \\label{mproj } \\,.\\ ] ] using integration by parts , the first term in equation ( [ mproj ] ) can be written as @xmath203\\,dr      = -r\\,\\phi_m(r ) \\frac{d}{dr}[r\\,\\psi(r)]\\bigg\\vert_0^r        + \\int_0^r \\frac{d}{dr}[r\\,\\phi_m(r ) ] \\frac{d}{dr}[r\\,\\psi(r)]\\,dr \\,.\\ ] ] now we set @xmath204\\bigg\\vert_{r = r } = 1 \\label{newbc } \\,,\\ ] ] which corresponds to a change in the normalization of @xmath193 , and use @xmath205 is zero at @xmath206 to write @xmath203\\,dr      = -r\\,\\phi_m(r ) + \\int_0^r \\frac{d}{dr}[r\\,\\phi_m(r ) ]         \\frac{d}{dr}[r\\,\\psi(r)]\\,dr   \\label{intp } \\,.\\ ] ] thus , equation ( [ mproj ] ) can be written in the form    _ 0^r [ r_m(r ) ] [ r(r)]dr & + & _ 0^r _ m(r)u(r)(r ) r^2dr + & & -  k^2 _ 0^r _ m(r)(r ) r^2dr = r_m(r ) [ eneqn ] .    substituting the expansion for @xmath193 in equation ( [ psiexp ] ) into equation ( [ eneqn ] )",
    "n=1^n a_n \\ { _ 0^r . & [ r_m(r ) ] [ r_n(r)]dr + .",
    "_ 0^r _ m(r)u(r)_n(r ) r^2dr .",
    "+ & -  . k^2 _",
    "0^r _ m(r)_n(r ) r^2dr } = r_m(r ) [ mateqn ] ,    which can be written as the matrix equation @xmath207    given the solution to equation ( [ mateqn2 ] ) we need to determine the normalization and the phase shift . for the new boundary condition given in equation ( [ newbc ] ) @xmath208 thus , we need an additional equation to use with equation ( [ newbc ] ) .",
    "we use the integral    i & = & _ 0^r ( kr)u(r)(r)r dr + & = & _ 0^r ( kr)\\{[r(r ) ] + k^2(r)}r dr + & = & ( kr)[r(r)]_0^r -k(kr)[r(r)]_0^r [ tmat ] + & & +  _ 0^r r(r ) dr + & = & ka + & = & - ka .    from equations ( [ newbc ] ) and ( [ asym ] ) we get @xmath209 which using equation ( [ tmat ] ) can be written as @xmath210 finally , from equations ( [ tmat ] ) and ( [ acos ] ) we find @xmath211 given @xmath212 the value of @xmath3 can be found using equation ( [ tmat ] ) .    eckart wave function    to test the method we use the eckart potential @xmath213 which has the analytic solution @xmath214\\sin(kr+\\delta)-4k\\lambda\\beta e^{-\\lambda r }               \\cos(kr+\\delta)}{(4k^2+\\lambda^2)\\left(\\beta e^{-\\lambda r}+1               \\right ) } \\ , , \\label{scfun}\\ ] ] where the phase shift is given by @xmath215 if @xmath216 is chosen to have the value @xmath217 the potential will have a bound state with the energy @xmath218 the boundstate wave function is given by @xmath219",
    "the wavelet transform is the orthogonal mapping between the scaling function basis on a fine scale and the equivalent basis consisting of scaling functions on a coarser scale and wavelets at all intermediate scales .",
    "the wavelet transform can be implemented by treating the scaling equation and the equation defining the wavelets as linear combinations of scaling functions for a finer scale , as low and high pass filters .",
    "this has the advantage when most of the high - frequency information is unimportant .",
    "the wavelet filter is defined using the scaling relations @xmath220 and @xmath221 where @xmath222 . using equations ( [ sc - phi ] ) and ( [ sc - psi ] )",
    "we can write    _ j , m(x ) & = & d^jt^m ( x ) + & = & _ l=0",
    "^ 2k-1 h_l d^j t^m d^-1 t^l ( x ) + & = & _ l=0 ^ 2k-1 h_l d^j-1 t^2 m t^l(x ) [ sc - phij ] + & = & _ l=0 ^ 2k-1 h_l _",
    "j-1,2m+l(x )    and    _ j , m(x ) & = & d^jt^m ( x ) + & = & _ l=0",
    "^ 2k-1 g_l d^j t^m d^-1 t^l ( x ) + & = & _ l=0 ^ 2k-1 g_l d^j-1 t^2 m t^l(x ) [ sc - psij ] + & = & _ l=0 ^ 2k-1 g_l _",
    "j-1,2m+l(x ) ,    where we have used    td^-1(x ) & = & t(2x ) + & = & ( 2x-2 ) + & = & d^-1 t^2(x )    to write @xmath223 .",
    "we use the orthonormality of the functions @xmath224 and @xmath225 to obtain the inverse relation .",
    "since @xmath226 , we can write @xmath227 using the scaling relations , we find    a_n & = & _ j , n(x)_j-1,m(x)dx + & = & _ l h_l _ j-1,2n+l(x)_j-1,m(x)dx + & = & _ l h_l _ 2n+l , m + & = & h_m-2n + b_n & = & _ j , n(x)_j-1,m(x)dx + & = & _ l g_l _",
    "j-1,2n+l(x)_j-1,m(x)dx + & = & _ l g_l _ 2n+l , m + & = & g_m-2n .",
    "thus , we find @xmath228    an alternate derivation is to use the orthonormality relations    _",
    "l h_l h_l+2 m & = & _ m0 [ orth - a ] + _ l g_l g_l+2 m & = & _ m0 [ orth - b ] + _ l h_l g_l+2 m & = & 0 , [ orth - c ]    derived in the _ wavelet notes_. now using the scaling relations in equation ( [ inv - ab ] ) gives @xmath229 taking the inner product with @xmath230 gives    _ km & = & _ n _",
    "l a_n h_l _ 2n+l , k + _ n _",
    "l b_n g_l _ 2n+l , k + & = & _ n",
    "a_n h_k-2n + _",
    "n b_n g_k-2n . [ inveqn ]    multiplying equation ( [ inveqn ] ) by @xmath231 and summing over @xmath15 gives    h_k-2n^ & = & _ n a_n _ k",
    "h_k-2n^ h_k-2n + _",
    "n b_n _ k h_k-2n^ g_k-2n + & = & _ n a_n _",
    "n n^ + & = & a_n^ ,    where we have used the relations ( [ orth - a ] ) and ( [ orth - c ] ) .",
    "multiplying equation ( [ inveqn ] ) by @xmath232 and summing over @xmath64 gives    g_k-2n^ & = & _ n a_n _ k",
    "g_k-2n^ h_k-2n + _",
    "n b_n _ k g_k-2n^ g_k-2n + & = & _ n b_n _",
    "n n^ + & = & b_n^ ,    where we have used the relations ( [ orth - b ] ) and ( [ orth - c ] ) .    given the expansion of @xmath29 in terms of the scaling functions @xmath233 we can use equation ( [ inv - rel ] ) to write the expansion in the form    f(x ) & = & _ n=0 ^ 2^j-1 c_j , n _",
    "m h_n-2 m _",
    "j+1,m(x ) + _",
    "n=0 ^ 2^j-1 c_j , n _",
    "m g_n-2 m _",
    "j+1,m(x ) + & = & _ m=0 ^ 2^j-1 - 1 c_j+1,m _",
    "j+1,m(x ) + _",
    "m=0 ^ 2^j-1 - 1 d_j+1,m _",
    "j+1,m(x ) , [ fexp-2 ]    where    c_j+1,m & = & _ n=2m^2m+2p-1 h_n-2 m c_j , n [ c - trans ] + d_j+1,m & = & _ n=2m^2m+2p-1",
    "g_n-2 m c_j , n , [ d - trans ]    where we use the periodic wrap - around condition @xmath234 . equations ( [ c - trans ] ) and ( [ d - trans ] ) can be written as a matrix equation , which for @xmath235 has the form @xmath236 for the daubechies @xmath237 wavelets .",
    "repeated application of the filter transform to the remaining @xmath238 gives @xmath239    the reverse transform can be obtained by substituting equations ( [ sc - phij ] ) and ( [ sc - psij ] ) into equation ( [ fexp-2 ] ) .",
    "this gives    f(x ) & = & _ m=0 ^ 2^j-1 - 1 c_j+1,m _",
    "l=0 ^ 2k-1 h_l _",
    "j,2m+l(x ) + _ m=0 ^ 2^j-1 - 1 d_j+1,m _",
    "l=0 ^ 2k-1 g_l _",
    "j,2m+l(x ) + & = & _",
    "n _ m h_n-2mc_j+1,m_j , n(x ) + _ n _ m g_n-2md_j+1,m_j ,",
    "n(x ) + & = & _ n c_j , n_j , n(x ) ,    where @xmath240 for the example used in equation ( [ mateqn-1 ] ) , this gives @xmath241 which is the transpose of the matrix in equation ( [ mateqn-1 ] ) .",
    "the wavelet transform is by its nature local at each level and therefore admits an implementation in which the data to be transformed can be placed in a buffer instead of storing the entire data set at once .",
    "this significantly reduces the amount of storage space required for applications involving compression .    in the one - dimensional case ,",
    "the @xmath242-level wavelet transform can be computed by buffering @xmath243 nonessential elements or the full transform can be computed buffering @xmath244 elements .",
    "the standard form for the two - dimensional transform of an @xmath245 matrix can be performed by buffering only @xmath246 elements . in general , a @xmath11-dimensional wavelet transform can be computed by only storing @xmath247 elements .",
    "this buffered wavelet transform can be applied to any type of data that can be input or computed in series .",
    "some notable examples include the compression of time - series data and applications to solutions of integral equations .",
    "below , we will explain the exact implementation of the transform including the buffer and the extension of the method to two dimensions .",
    "the extension to arbitrary dimension is straightforward from the two dimensional case .",
    "first , we will layout the terminology that will be used throughout .",
    "we adopt the filter viewpoint since it makes the explanation of the buffering procedure more clear . but",
    "this is equivalent to the linear algebra viewpoint and we will attempt to explain the procedure in this language as well .    from the filter viewpoint ,",
    "the wavelet transform is a convolution of the data set and two vectors @xmath248 and @xmath249 followed by a decimation .",
    "this is equivalent to a convolution that proceeds by steps of two instead of one . for the daubechies family of wavelets ,",
    "both of these filters have a length @xmath250 .",
    "the convolution with @xmath248 produces what is called the father set and the convolution with @xmath249 produces the mother set .",
    "we denote the data set to be transformed as a and use brackets to denote subscripts . in all contexts below ,",
    "the one - dimensional length of the data set will be @xmath251 where @xmath8 is an integer .",
    "that is the data runs from @xmath252 $ ] to @xmath253 $ ] .",
    "the typical procedure to deal with a finite data set is to periodize the data over the boundary such that @xmath254 = a[0 ] , a[n+1]=a[1 ] , \\cdots a[n+l-3]=a[l-3]$ ] .",
    "now , if we write out the first level of the transform as a matrix we can see that it is banded with a bandwidth l corresponding to the convolution operation .",
    "the second level of the transform is identical to the first except that it only acts on the father set of data , i.e. the transform on the mothers is the identity .",
    "this corresponds to the fact that all of the information about coarser levels is contained in the father functions .",
    "the mother functions form an orthogonal subspace to the fathers and mothers on all higher levels . using this knowledge",
    "we can immediately perform a thresholding procedure on the mother set without affecting the rest of the data in any way .",
    "the father set can simultaneously be transformed and the resulting mothers thresholded as well .",
    "iterating this procedure on all the relevant levels forms the basis for the buffered wavelet transform .",
    "of course , one must have an a priori thresholding scheme to accomplish this .",
    "the simplest such example is an absolute threshold . in this scheme",
    ", one chooses an epsilon and all elements with a magnitude less than this epsilon .",
    "other more sophisticated thresholding procedures exist as well , such as procedures based on the level on the transform .",
    "the important fact is that one can not have a procedure that depends in any way on the final transformed data set .",
    "examples of such procedures would be based on the relative size of the transformed elements or a threshold that keeps a certain number / percentage of the final coefficients . in many applications ,",
    "the absolute thresholding is an acceptable method .",
    "now , we will explain the detailed implementation of the one - dimensional transform .",
    "one begins by computing the elements @xmath252 $ ] to @xmath255 $ ] of the data set . as noted above",
    ", these elements are necessary for the periodic boundary conditions and form a boundary buffer that must be saved until the end of the calculation .",
    "now , elements can be added to a moving buffer of length @xmath256 that constitutes the heart of the procedure .",
    "after the elements @xmath257 $ ] and @xmath258 $ ] are computed and placed in the moving buffer , one can begin transforming the data set .",
    "convolving this data set , including the boundary terms , with h produces the first member of the father set @xmath259 $ ] and convolving with g produces the first member of the mother set @xmath260 $ ] . as described previously , this mother element can be immediately thresholded and placed in the final output vector . the father element is considered the beginning of a new data set to be transformed and is placed in the boundary buffer corresponding to the next level of the transform .",
    "one then proceeds to compute two more elements and convolve @xmath261 $ ] to @xmath262 $ ] with @xmath248 and @xmath249 .",
    "this produces @xmath263 $ ] and @xmath264 $ ] , which are treated the same way as before .",
    "we continue in this manner , calculating more elements and convolving , until we have computed the element @xmath265 $ ] .",
    "the moving buffer is now full and we have reached the interior of the data set . when we compute the next element of the data set we can discard the last element of the moving buffer and shift all the elements of the buffer one place . the new element is then appended to the moving buffer . discarding the last element",
    "is justified by the fact that all the information in that element is represented by the corresponding father and mother data sets due to the equivalence of the subspaces .",
    "the name moving buffer is clear since this buffer can be viewed as scanning the interior of the data set by moving over it .",
    "this process continues , the shifting and convolving , until the end of the data set is reached .",
    "when the end of the data set is reached we simply make the data set periodic using the boundary buffer .",
    "this process is simultaneously carried out at each level .",
    "now counting the elements in each buffer we see that in each level we must store @xmath266 elements in the boundary buffer and @xmath256 elements in the moving buffer .",
    "so , for @xmath242 levels we must store @xmath267 elements .",
    "this gives us our size of @xmath243 where the coefficient depends on the length @xmath256 of the wavelet filter as is common with most wavelet algorithms .",
    "in many wavelet applications , the data vector to be transformed will be of length @xmath268 and a wavelet transform of level @xmath269 will be computed . in this case",
    ", the number of elements stored in the buffers will be of @xmath244 . a minor point to note",
    "is that for wavelet filters of length @xmath270 the last few levels will not be filled completely . as a programming point",
    "one can either fill the buffers periodically or just periodize the convolution .",
    "both procedures are equivalent and consistent with the periodic wavelet transform .",
    "also note that the number of operations has been increased by the shift operation , but is still of @xmath271 which is the case for the standard wavelet transform .",
    "the standard procedure to perform the wavelet transform on a two dimensional data set is to first transform the rows of the matrix and then transform the columns .",
    "alternatively , one could transform the columns and then the rows .",
    "both are equivalent as can be seen by writing out the transform as a matrix multiply and noting the associativity of matrix multiplication .    to perform the buffered wavelet transform on a two - dimensional data set we calculate the data column by column .",
    "each row has a separate set of buffers associated with it .",
    "we can view this as a strip that scans the matrix in much the same way as the moving buffer did in the one - dimensional case .",
    "each of these buffers behaves in exactly the same way as the one - dimensional case , except the output is handled differently . the first output from the buffer associated with row one",
    "is placed in two vertical buffers .",
    "$ ] and @xmath273 $ ] the @xmath274 stands for blank since these are internal buffers that have no outside significance . both of these outputs must be saved because they contain information about the columns of the matrix .",
    "row two then produces @xmath275 $ ] and @xmath276 $ ] , and so on continuing down the rows .",
    "the transform procedure is applied to the vertical buffers , which produce output @xmath277 , @xmath278 , @xmath279 , and @xmath280 .",
    "the output @xmath280 can be thresholded immediately .",
    "the output @xmath278 is placed in an array of row buffers of height @xmath281 that transform the rows and filter immediately the @xmath282 s produced .",
    "the @xmath279 output is placed in another vertical buffer where the traditional one - dimensional transform procedure is enacted .",
    "the @xmath277 output is placed in an array of row buffers identical to the original configuration , except that it is only @xmath281 tall .",
    "the same procedure is enacted on this data set that is half as small .",
    "now this proceeds across the matrix in a similar manner as the one - dimensional case , except that the vertical buffers can be completely purged as the next column is reached . to count the number of elements that are necessary we can ignore the vertical buffers , which are subdominant . at the first level we note that there are @xmath283 elements in the row buffer and @xmath284 in the @xmath277 output and @xmath278 output .",
    "hereafter we will drop the @xmath285 to simplify the counting since we are just looking for order .",
    "so we have @xmath104 and @xmath281 and @xmath281",
    ". the @xmath278 output will proceed like the one - dimensional case .",
    "therefore it will produce @xmath286 elements .",
    "the @xmath277 out put will produce @xmath287 and @xmath288 .",
    "so we can see that the total number of elements will be @xmath289 .",
    "the sum is a simple geometric sum that in the limit that @xmath242 goes to infinity is bounded by @xmath188 .",
    "so the final tally of the necessary elements is @xmath290 .",
    "the generalization to @xmath11 dimensions is straightforward .",
    "one begins with a data structure of dimensions @xmath291 .",
    "one then performs a transform to produce two @xmath292 data structures .",
    "one performs a transform on these two structures to produce four @xmath293 structures .",
    "this process continues until the final transform where one has a single dimension .",
    "this transform is enacted and the @xmath294 elements are filtered .",
    "appropriate lower dimensional transforms are applied to the mixed output , @xmath295 etc .",
    "the process is repeated for the @xmath296 data set . in higher dimensions",
    "the algorithm becomes more complicated , but the idea is the same .",
    "and the leading order number of elements that need to be saved is @xmath297 .",
    "we begin by considering the continuous wavelet transform .",
    "the continuous wavelet transform is an alternate representation of a function , like a fourier transform .",
    "both continuous and discrete wavelets are built from a single function called a * mother function*. the notation , @xmath298 , is used to denote the mother function of a wavelet .",
    "wavelets are built from translations and scale transformations of the mother function .",
    "translations and scale transformations of @xmath298 are defined by : _",
    "t , s ( x ) : = s ^-p(x - t s ) .",
    "the factor @xmath299 is a parameter .",
    "the functions @xmath300 are the wavelets associated with the mother function @xmath298 .",
    "the wavelet @xmath300 has two continuous parameters .",
    "we investigate conditions on the mother function that allow one to expand any function in terms of wavelets .    to choose the parameter @xmath299 note that @xmath301 s ^1 - qp _ -^ ( u ) ^q du .",
    "it follows that if @xmath302 the @xmath303-norm of @xmath185 _ q : = ( _ -^ ( u ) ^q du ) ^1/q is preserved under scale transformations .",
    "thus for @xmath302 :    _ q = _ s , t _",
    "q s , t .",
    "the * continuous wavelet transform * of @xmath304 is defined by taking the scalar product of @xmath304 with the wavelet @xmath305 : ( s , t ) : = _",
    "^*_s , t(x ) f(x ) dx = ( _ s , t , f ) where asterik @xmath306 indicates the complex conjugate for a complex mother function . in what follows a @xmath307",
    "is used to indicate the wavelet transform of the function @xmath304 .",
    "parseval s identity for the fourier transform implies that the wavelet transform can be expressed in terms of the original function and the mother function or alternatively in terms of their fourier transforms : ( s , t)= ( _ s , t , f ) = ( _ s , t , ) [ eq : aa ] where the @xmath308 indicates the fourier transform defined by : _ s ,",
    "t(k ) = 1 _ -^ e^-ikx _ s , t ( x ) dx ( k ) = 1 _ -^ e^-ikx f(x ) dx .",
    "note that parseval s identity states @xmath309 . using this with @xmath310 and @xmath311 gives ( g , g ) + ( h , h ) + ( g , h ) + ( h , g ) = ( , ) + ( , ) + ( , ) + ( , ) [ eq : ab ] and ( g , g ) + ( h , h ) + i(g , h ) -i(h , g ) = ( , ) + ( , ) + i ( , ) -i ( , ) [ eq : ac ] which , using the identities @xmath312 and @xmath313 , gives the solution to ( [ eq : ab ] ) and ( [ eq : ac ] ) : ( g , h)= ( , ) which is the form of parseval s identity used in ( [ eq : aa ] ) .",
    "the fourier transform of the wavelet @xmath314 can be expressed in terms of the fourier transform of the mother function :    @xmath315 @xmath316 s ^1-p e^- i kt ( sk ) .",
    "the inner product of the fourier transforms gives @xmath317 @xmath318 _",
    "-^ s^1-p e^ i kt ^ * ( sk ) ( k ) dk . [ eq : fa ] multiplying both sides of ( [ eq : fa ] ) by @xmath319 and integrating over @xmath320 gives @xmath321 s ^1-p ^ * ( sk ) ( k ) , [ eq : fb ] where the representation of the delta function : _",
    "-^ e^- i ( k-k)tdt = ( k-k ) . was used to get ( [ eq : fb ] ) .",
    "the right - hand side of ( [ eq : fb ] ) is a product of the fourier transform of the original function with another function .",
    "we ca nt divide by the function @xmath322 because it might be zero for some values of @xmath323 .",
    "instead , the trick is to eliminate it using the variable @xmath67 .",
    "multiply both sides of this equation by @xmath324 and a yet to be determined weight function @xmath325 and integrate over @xmath67 .",
    "this gives    @xmath326 ( k ) _",
    "-^w(s ) ds s ^1-p ^ * ( sk ) ( sk ) = ( k ) y(k ) [ eq : fc ] where y(k)= _",
    "-^ds w(s ) s ^1-p ( sk)^2 .",
    "in order to be able to extract the fourier transform of the original function , it is sufficient that @xmath327 satisfies @xmath328 for some numbers @xmath3 and @xmath274 . in this case",
    "\\(k ) = 1 2 y(k ) _",
    "0^w(s ) ds _ -^ dt e^- i kt ( sk ) ( s , t ) .    it is convenient to rewrite this in terms of the wavelet basis : ( k ) = 1 2 y(k ) _ - ^w(s ) s ^p-1 ds _",
    "-^ dt _ s , t(k ) ( s , t ) .    we define the * dual wavelet * by ^s , t(k ) = 1 2 y(k)_s , t(k ) .",
    "[ eq : ad ] the dual wavelet is distinguished from the ordinary wavelet by having the parameters @xmath329 appearing as superscripts rather than subscripts .",
    "the inversion formula can be expressed in terms of the dual wavelet by ( k ) = _ -^w(s ) s ^p-1 ds _",
    "-^ dt ^s , t(k ) ( s , t ) .    in order to recover the original function , take the inverse fourier transform of this expressions : @xmath330 _ -^w(s ) s^p-1 ds _",
    "-^ dt ^s , t(x ) ( s , t ) where ^s , t(x ) = 1 ^_- dk e^ikx ^s , t(k ) .",
    "[ eq : ae ] in general this is a tedious procedure because the dual wavelet @xmath331 must be computed using ( [ eq : ad ] ) and ( [ eq : ae ] ) for each value of @xmath67 and @xmath320 .",
    "if the dual wavelet also had a mother function , then it would only be necessary to fourier transform the `` dual mother '' and then all of the other fourier transforms could be expressed in terms of the transform of the `` dual mother '' .",
    "the first step in constructing a `` dual mother '' is to investigate the structure of the dual wavelets in @xmath332-space :    @xmath333 @xmath334 @xmath335 where @xmath336 this shows for a single scale the dual wavelet and its translation can be expressed in terms of a single function .",
    "this is not necessarily true for the dual wavelet and the scaled quantity .",
    "@xmath337 @xmath338 this fails to be a rescaling of a single function because of the @xmath67 dependence in the quantity @xmath339 .",
    "it follows that if _ a weight function @xmath325 _ is chosen so @xmath340 is constant , the dual wavelet will satisfy ^s,0(x ) = 1 ^_- du e^iu x s 1 2 y s^-p ( u ) = s^-p ^1,0(x / s ) . in this case",
    "@xmath339 is a constant which we denote by @xmath341 .",
    "the function @xmath342 serves as the dual mother wavelet .    to determine @xmath325 note that @xmath343 let @xmath344 to get @xmath345 @xmath346 this will equal @xmath347 provided @xmath348    with this choice @xmath349 assuming this choice of weight the admissibility condition becomes @xmath350    having computed the constant @xmath341 it is now possible to write down an explicit expression for the dual mother wavelet : @xmath351 @xmath352 letting @xmath353 @xmath354 @xmath355 this has the form ^s , t(x ) = 1 2 1 y_s , t(x ) .",
    "thus the inversion procedure can be summarized by the formulas : f(x ) = _ -^s^2p-3 ds _",
    "-^ dt ^s , t(x ) ( s , t ) y = _ -^ dt t",
    "( t)^2 ^s , t(x ) = _ s , t(x ) 2 y _ s , t = s ^-p ( x - t s ) .    the mother function must satisfy @xmath356 .",
    "this requires that the fourier transform of the mother function vanishes at the origin .",
    "this is equivalent to saying that the integral of the mother function is zero .",
    "using the representation for the wavelet transform gives a representation of a delta function :    @xmath357 @xmath358 @xmath359 we can also use this representation of the delta function to formulate a parseval s identity for continuous wavelets ( f , f ) = 1 2 y _",
    "-^ s^2p-3 ds _",
    "-^ dt ( s , t ) ^2 .",
    "consider the example of the * mexican hat * wavelet .",
    "the mother function is @xmath360    to work with the mexican hat mother function it is useful to use properties of gaussian integrals : @xmath361 @xmath362 change variables to @xmath363 to obtain : @xmath364 @xmath365    this can be used to compute the fourier transform of the mexican hat mother function : @xmath366 @xmath367 to do the integral insert a parameter @xmath368 which will be set to 1 at the end of the calculation : @xmath369 @xmath370 @xmath371 in the limit that @xmath372 this becomes @xmath373    using this expression it is possible to calculate the coefficient @xmath341",
    "@xmath374 @xmath375 @xmath376 @xmath377 inserting a parameter @xmath368 which will eventually be set to 1 gives @xmath378 @xmath379 @xmath380 this satisfies the essential inequality @xmath381 which ensures the admissibility of the mexican hat mother function .    the expression for the wavelet transform and its inverse can be written as :    @xmath382 @xmath383 where @xmath384    the inverse is formally given by    @xmath385 @xmath386 @xmath387 @xmath388 where @xmath389 .",
    "initially we were concerned because we were representing an arbitrary function by a linear superposition of functions that all have zero integral .",
    "we could not understand how wavelets could be used to represent a function with non - zero integral .",
    "we tested this by computing the wavelet transform and its inverse for a gaussian function with the mexican hat wavelet .",
    "the original gaussian function was recovered .",
    "the resolution of this paradox has to do with the difference between @xmath41 and @xmath33 convergence .",
    "the wavelet transform has a vanishing @xmath41 norm , but the @xmath33 norm is non - zero .",
    "we use the convention which defines the fourier transform of a function @xmath29 as @xmath390 and the inverse transform by @xmath391 for this convention , parseval relation is @xmath392    the cardinal b - splines , @xmath393 , are defined by first defining @xmath394 then for @xmath395 , @xmath393 is defined recursively by the convolution integral @xmath396 since @xmath393 is defined by a convolution integral , the fourier transform will be defined by a product . to show this , we evaluate the fourier transform @xmath397 now setting @xmath398 in the second integral , we find @xmath399^m \\,,\\end{aligned}\\ ] ] where @xmath400    for this example we use the quadratic spline shifted to the left by one unit @xmath401 ^ 3 \\ , .",
    "\\label{qbk}\\end{aligned}\\ ] ] now evaluating the inverse transform using maple , we get @xmath402 the splines are not orthogonal ; however , we can use them to construct a scaling function @xmath403 which has the orthonormality property @xmath404 to do this we follow the procedure given in the books by chui and daubechies . note",
    "that this a general procedure ; we are using the spline as a convenient example .",
    "the method gives an expression for the fourier transform , @xmath405 , of @xmath403 .",
    "the fourier transform of @xmath406 is given by @xmath407 now we show that if @xmath408 then the functions are orthogonal .",
    "to show this , we use the parseval relation @xmath409    finally , we show that if we can find a @xmath405 such that @xmath410 then the functions are orthonormal .",
    "the infinite sum in equation ( [ grel ] ) is periodic in @xmath64 with a period of @xmath411 ; thus it has the fourier series expansion @xmath412 where the expansion coefficients are give by @xmath413 since the sum in equation ( [ grel ] ) is equal to one , @xmath414 , and one finds @xmath415 thus , the functions are orthonormal .",
    "now given a function , @xmath416 , we construct a scaling function by taking its fourier transform and defining @xmath417^\\frac{1}{2 } } \\ , .",
    "\\label{scfuna}\\ ] ] this function satisfies equation ( [ grel ] ) , and the @xmath403 will have the orthonormality property given in equation ( [ ortho ] ) . to evaluate the infinite sum in equation ( [ scfuna ] ) , we use the finite fourier series expansion of the function @xmath418 this function has period @xmath411 , and the fourier expansion has the form @xmath419 following the derivation in equation ( [ coef ] ) , the expansion coefficients are given by @xmath420 where the parseval relation was used for the last step . the integral in equation ( [ bcoef ] ) is easy to evaluate for the b - splines , and we find @xmath421 using these coefficients for the expansion given in equation ( [ gfour ] ) , we find @xmath422    to find @xmath403 the inverse fourier transform of @xmath405 must be done numerically ; however , there is a nice method which gives an efficient algorithm .",
    "since the function @xmath423 has period @xmath411 , we can use the expansion @xmath424 where the coefficients @xmath425 must be computed numerically . for the b - spline",
    ", the @xmath423 is an even function of @xmath64 , and one finds @xmath426 in addition , from equation ( [ cn ] ) we see that @xmath427 .",
    "now , using equation ( [ rtexp ] ) we get @xmath428\\,e^{ikx}\\,dk               \\nonumber\\\\          & = & \\sum_{n=-\\infty}^\\infty c_n \\left[\\frac{1}{2\\pi }                \\int_{-\\infty}^\\infty \\tilde{b}(k ) e^{ik(x - n)}\\,dk \\right ]               \\nonumber\\\\          & = & \\sum_{n=-\\infty}^\\infty c_n b(x - n ) \\ , . \\label{phi_b}\\end{aligned}\\ ] ]    now we need to find the wavelet @xmath298 with the properties @xmath429 and @xmath430 to do this we introduce the functions @xmath431 the fourier transform of these functions is given by @xmath432 and setting @xmath433 yields @xmath434    using the @xmath435 as an orthonormal basis set , we can write @xmath436 where @xmath437 this is the scaling equation for this system . in this case",
    "there are an infinite number of non - zero scaling coefficients .",
    "since the @xmath438 are orthonormal , the @xmath439 must have the property @xmath440 taking the fourier transform of equation ( [ phiexp ] ) gives @xmath441 which can be written as @xmath442 where @xmath443 using equations ( [ grel ] ) and ( [ prod ] ) we see that @xmath444 where we have used the periodicity of @xmath445 .",
    "the sum on the left - hand side of equation ( [ msum ] ) is equal to unity ; thus , we have shown that @xmath446    now we use a similar procedure to find @xmath298 . using the @xmath435 as an orthonormal basis set , we write @xmath447 with @xmath448 taking the fourier transform of equation ( [ psiexpb ] ) gives @xmath449 where @xmath450    if @xmath451 has the same property as that given in equation ( [ m0rel ] ) for @xmath445 , then the functions @xmath452 will be orthonormal .",
    "in addition , we want @xmath453 to be orthogonal to @xmath454 .",
    "thus , we want to find a @xmath451 such that @xmath455 this condition is satisfied if @xmath456 substituting equations ( [ prod ] ) and ( [ psiprod ] ) into equation ( [ psiorth ] ) and replacing @xmath64 by @xmath457 gives @xmath458 regrouping the sums for odd and even @xmath47 , and following the procedure used in equation ( [ msum ] ) gives @xmath459 this condition will be satisfied if we choose @xmath460 note this choice for @xmath451 is not unique ; we can multiply @xmath451 by any function @xmath461 which has period @xmath462 and @xmath463 , and still satisfy the constraints on @xmath451 . substituting this result into equation ( [ psiprod ] ) gives @xmath464 replacing @xmath8 by @xmath465 in equation ( [ psi1 ] )",
    "gives @xmath466 for convenience , we drop the minus sign in front of the sum , and write @xmath467 where @xmath468 for @xmath439 a real number . taking the fourier transform of equation ( [ psi2 ] )",
    "gives the result @xmath469    to evaluate @xmath298 we use the expansion given in equation ( [ phi_b ] ) in equation ( [ pseries ] ) .",
    "this gives @xmath470 now replace @xmath15 by @xmath471 , this gives @xmath472 b(2x - l ) \\nonumber\\\\          & = & \\sum_{l=-\\infty}^\\infty d_l b(2x - l ) \\,.\\end{aligned}\\ ] ]      to determine the @xmath439 we need to evaluate the overlap integral given in equation ( [ hint ] ) . from equations ( [ phim ] ) and ( [ phi_b ] )",
    ", we find @xmath473 then using @xmath474 where , the @xmath475 for the quadratic b - splines are given by @xmath476 we can write @xmath477 b(2x - l ) \\nonumber\\\\          & = & \\sum_{l=-\\infty}^\\infty s_l b(2x - l ) \\,.\\end{aligned}\\ ] ] using these expansions , the overlap integral is given by @xmath478 where , we have set @xmath479 in the second summation .",
    "the values for the integrals of the quadratic b - splines are given in equation ( [ bcoef ] ) .",
    "to derive equation ( [ bscale ] ) , we use @xmath480 to write equation ( [ qbk ] ) as @xmath481 ^ 3                     \\nonumber\\\\               & = & e^{-ik/4}\\left(\\frac{e^{ik/4}+e^{-ik/4}}{2}\\right)^3 e^{-ik/2 }                    \\left[\\frac{\\sin(k/4)}{k/4}\\right]^3 \\nonumber\\\\               & = & e^{-ik/4}\\left(\\frac{e^{ik/4}+e^{-ik/4}}{2}\\right)^3                     \\tilde{b}(k/2 ) \\nonumber\\\\               & = & \\left(\\frac{e^{ik/2 } + 3 + 3\\,e^{-ik/2 } + e^{-ik}}{8}\\right )                      \\tilde{b}(k/2 ) \\ , .",
    "\\label{b3exp}\\end{aligned}\\ ] ] now taking the fourier transform of ( [ b3exp ] ) and using @xmath482 we find @xmath483"
  ],
  "abstract_text": [
    "<S> wavelets are a useful basis for constructing solutions of the integral and differential equations of scattering theory . </S>",
    "<S> wavelet bases efficiently represent functions with smooth structures on different scales , and the matrix representation of operators in a wavelet basis are well - approximated by sparse matrices . </S>",
    "<S> the basis functions are related to solutions of a linear renormalization group equation , and the basis functions have structure on all scales . </S>",
    "<S> numerical methods based on this renormalization group equation are discussed . </S>",
    "<S> these methods lead to accurate and efficient numerical approximations to the scattering equations . </S>",
    "<S> these notes provide a detailed introduction to the subject that focuses on numerical methods . </S>",
    "<S> we plan to provide periodic updates to these notes .    </S>",
    "<S> * file : usr / wavelets / revised - notes.tex * </S>"
  ]
}