{
  "article_text": [
    "informally , a promise problem is the problem to decide whether an object or process has a property @xmath4 or @xmath5 , provided it is promised ( known ) to have a property @xmath6 .",
    "the concept of a promise problem was introduced explicitly in @xcite and it has been argued there that promise problems are actually more fundamental for the study of computational theory issues than decision problems or , more formally , formal language versions / encodings of the decision problems .",
    "such a view on the fundamental importance of promise problems has been even more emphasized in the survey paper @xcite , where also the following basic version of the promise problems has been introduced .",
    "a promise problem over an alphabet @xmath7 is a pair @xmath8 of disjoint subsets of @xmath9 .",
    "the union @xmath10 is then called the _ promise _ and @xmath11 as well @xmath12 are called promise s components .    the goal is then to decide whether @xmath13 or @xmath14 for a given string @xmath15 from the promise set . in a special ( trivial ) case",
    "the promise is the the whole set @xmath9 .",
    "however , in general it may be very nontrivial to decided whether an input string is in a given promise set .    in spite of the fact that both papers @xcite have brought interesting problems and outcomes ,",
    "the study of promise problems did not get a proper momentum yet .    on the other side ,",
    "the results concerning several promise problems in quantum information processing have had very large impact .",
    "they demonstrated that using quantum phenomena and processes one can solve several interesting promise problems with much less quantum queries ( to quantum black boxes ) than in the case only classical tools and queries ( to classical black boxes ) are available .",
    "the initial development in this area was culminated by the result of simon @xcite that the promise problem he introduced can be solved with the polynomial number of quantum and classical queries but not with polynomial number of classical queries only even if probabilistic tools are used .",
    "the second promise problem is the hidden subgroup problem for non - commutative groups , which took very large attention , especially its special cases , for example integer factorization , due to shor @xcite , and can be now seen as one of the most fundamental , and still open , problems .",
    "almost all papers so far , especially papers @xcite , dealt with promise problems in the context of such high level complexity classes as * p * , * np * , * bpp * , * szk * and so on .    in this paper",
    "we start to explore promise problems on another level , namely , using classical and quantum or even semiquantum finite automata to attack some promise problems working in various ( especially two special ) modes .",
    "the remainder of the paper is organized as follows . in section 2 ,",
    "we recall the definitions of classical and quantum finite automata that will be used in the paper , and define two acceptance modes of promise problems , _ recognizability _ and _ solvability _ of promise problems by automata .",
    "then , in section 3 , we deal with the closure and ordering properties of promise problems .",
    "afterwards , in section 4 , lower and upper bounds are derived concerning the state complexity in a promise problem between the promise and its two components .    in particular , we study some promise problems in terms of classical and quantum finite automata in section 5 , and obtain the following results : that there is a promise problem that can be recognized exactly by _ measure - once one - way quantum finite automata _ ( mo-1qfa ) , but no _ deterministic finite automata _ ( dfa ) can recognize it ( theorem [ thmoq - dfa ] ) ; there is a promise problem that can be solved with any error probability by _ one - way finite automaton with quantum and classical states _",
    "( 1qcfa ) , but no _ one - way probability finite automaton _ ( pfa ) can solve it with error probability @xmath0 ( theorem [ thqcfa - pfa ] ) .",
    "especially , in section 5 we prove a hierarchic result concerning qfa .",
    "more exactly , we show that there are promise problems @xmath1 with size @xmath2 that can be solved _ with any error probability _ by mo-1qfa with only two quantum basis states , but they can not be solved _",
    "exactly _ by any mo-1qfa with two quantum basis states ( theorem [ thmoq - moq ] ) , and in contrast , the minimal pfa solving @xmath1 with any error probability ( usually smaller than @xmath3 ) has @xmath2 states ( theorem [ thmoq - pfa ] ) . however , we do not know whether there is an mo-1qfa with more than _ two _ quantum basis states being able to solve exactly this promise problems @xmath1 .",
    "in addition , the above result may give rise to a hierarchic problem for the classes solved by mo-1qfa in terms of different quantum basis states .",
    "more precisely , let @xmath16 denote the class of promise problems solved exactly by an mo-1qfa with @xmath17 quantum basis states . then , whether does @xmath18 hold for @xmath19 ?",
    "therefore , in section 6 we mention a number of problems related for further study .",
    "we introduce in this section some basic concepts and notations concerning classical and quantum finite automata . for more on quantum information processing and ( quantum and semi - quantum ) finite automata",
    "we refer the reader to @xcite .",
    "in this subsection we recall the definition of _ deterministic finite automata _ ( dfa ) and give the definition of so - called _ promise version deterministic finite automata _ ( pvdfa ) .",
    "[ dfa ] a deterministic finite automaton ( dfa ) @xmath20 is specified by a 5-tuple    @xmath21    where :    * @xmath22 is a finite set of classical states ; * @xmath7 is a finite set of input symbols ; * @xmath23 is the initial state of the automaton ; * @xmath24 is a set of accepting states ; * @xmath25 is a transition function : @xmath26    for any @xmath27 and @xmath28 , we define @xmath29 and if @xmath30 is the empty string , then @xmath31    to every dfa @xmath32 we assign a language @xmath33 defined as following @xmath34    a language @xmath35 over an alphabet @xmath7 is _ recognized _ by a dfa @xmath20 if for every @xmath27    * @xmath36 if and only if @xmath37 .",
    "* @xmath38 if and only if @xmath39 .",
    "it is well known that a language @xmath35 is recognized by a dfa if and only if @xmath35 is regular . to every dfa @xmath20",
    "we assign also the ( maximal ) promise problem @xmath40 defined as follows @xmath41    a promise problem @xmath42 is _ solved _ by a dfa @xmath20 if for every @xmath43    * @xmath44 implies that @xmath37 . *",
    "@xmath45 implies that @xmath39 .    a _ promise version deterministic finite automaton _ ( pvdfa )",
    "@xmath20 is specified by a 6-tuple @xmath46 where @xmath47 is a set of accepting states and @xmath48 is a set of rejecting states , respectively , and @xmath22 , @xmath7 , @xmath25 , @xmath49 are defined as in definition [ dfa ] .",
    "a dfa can be see as a special pvdfa with @xmath50 . if a pvdfa @xmath20 is such that @xmath50 , then it is equivalent to a dfa . in such a case , we say that @xmath20 is a dfa . to every pvdfa",
    "we assign a promise problem @xmath40 defined as following @xmath51    a promise problem @xmath42 is _ recognized _ by a pvdfa @xmath20 if for every @xmath27    * @xmath52 if and only if @xmath37 .",
    "* @xmath45 if and only if @xmath53 .    a promise problem @xmath42 is _ solved _ by a pvdfa @xmath20 if for every @xmath54    * @xmath44 implies that @xmath37 . *",
    "@xmath55 implies that @xmath53 .",
    "if a language @xmath35 is recognized by a dfa , then we can find efficiently the minimal dfa @xmath20 such that @xmath56 .",
    "if a promise problem @xmath57 is recognized by a pvdfa , then we can also find efficiently the minimal pvdfa @xmath20 such that @xmath58 .",
    "more about that will be in section [ s - propeties ] .",
    "we will see that for pvdfa recognizability and solvability modes can be seen as much different .",
    "quantum finite automata were introduced by kondacs and watrous @xcite and also by moore and crutchfields @xcite .",
    "it has been proved that one - way quantum finite automata ( 1qfa ) with unitary operations and projective measurements are less powerful than one - way classical finite automata ( 1fa ) @xcite .",
    "however , 1qfa can be more succinct in recognizing languages or solving promise problems @xcite .",
    "a measure - once quantum finite automaton ( mo-1qfa ) @xmath59 is specified by a 5-tuple @xmath60 where :    * @xmath61 is a finite set of orthonormal quantum ( basis ) states , denoted as @xmath62 ; * @xmath7 is a finite alphabet of input symbols and @xmath63 ( where @xmath64 will be used as the left end - marker and @xmath65 as the right end - marker ) ; * @xmath66 is the initial quantum state ; * @xmath67 denotes the set of accepting basis states ; * @xmath68 s ( @xmath69 ) are unitary operators",
    ".    the quantum state space of this model will be the @xmath70-dimensional hilbert space denoted @xmath71 .",
    "each quantum basis state @xmath72 in @xmath71 can be represented by a column vector with the @xmath73th entry being @xmath74 and other entries being @xmath75 . with this notational convenience",
    "we can describe the above model as follows :    1 .",
    "the initial state @xmath76 is represented as @xmath77 .",
    "the accepting set @xmath78 corresponds to the projective operator @xmath79 .",
    "the computation of an mo-1qfa @xmath59 on an input string @xmath80 goes as follows : @xmath59  reads \" the input string from the left end - marker to the right end - marker , symbol by symbol , and the unitary matrices @xmath81 are applied , one by one , always on the current state , starting with @xmath76 as the initial state .",
    "finally , the projective measurement @xmath82 is performed on the final state , in order to accept or reject the input .",
    "therefore , for an input string @xmath83 , @xmath59 has the accepting probability @xmath84 = \\|p_{acc}u_{\\$}u_{\\sigma_n}\\cdots u_{\\sigma_2}u_{\\sigma_1}u_{|\\hspace{-1mm}c}|0\\rangle\\|^2\\ ] ] and the rejecting probability @xmath85=1- pr[{\\cal m}\\ \\mbox{accepts}\\   w].\\ ] ]    a promise version of a measure - once quantum finite automaton ( pvmo-1qfa ) @xmath59 is specified by a 6-tuple @xmath86 where : @xmath61 , @xmath7 , @xmath87 , @xmath76 , @xmath78 , @xmath68 are as defined in an mo-1qfa , @xmath88 ( @xmath89 ) denotes the set of rejecting basis states",
    ". the set @xmath90 corresponds to the projective operator @xmath91 .    for an input string @xmath83 ,",
    "@xmath59 has the accepting probability @xmath84 = \\|p_{acc}u_{\\$}u_{\\sigma_n}\\cdots u_{\\sigma_2}u_{\\sigma_1}u_{|\\hspace{-1mm}c}|0\\rangle\\|^2\\ ] ] and the rejecting probability @xmath85=\\|p_{rej}u_{\\$}u_{\\sigma_n}\\cdots u_{\\sigma_2}u_{\\sigma_1}u_{|\\hspace{-1mm}c}|0\\rangle\\|^2.\\ ] ]    another interesting ( important ) model of _ two - way finite automata with quantum and classical states _ ( 2qcfa)was introduced by ambainis and watrous @xcite and explored in @xcite .",
    "if restricting the read - head in a 2qcfa to be _ one - way _ , then it is natural to get _ one - way finite automata with quantum and classical states _ ( 1qcfa ) .",
    "that is , 1qcfa are one - way versions of 2qcfa , studied by zheng and qiu _ et al _ @xcite .",
    "it is worth mentioning that more previously a different but more practical model called as _",
    "one - way quantum finite automata together with classical states _ ( 1qfac ) was proposed and studied by qiu _",
    "et al _ @xcite .",
    "informally , a 1qcfa can be seen as a dfa which has an access to a quantum memory of a constant size ( dimension ) , upon which the automaton performs quantum transformations and projective measurements . given a finite set of quantum basis states @xmath61 , we denote by @xmath92 the hilbert space spanned by @xmath61 .",
    "let @xmath93 and @xmath94 denote the sets of unitary operators and projective measurements over @xmath92 , respectively .",
    "a _ one - way finite automaton with quantum and classical states _ ( 1qcfa ) @xmath20 is specified by a 10-tuple @xmath95 where :    1 .",
    "@xmath61 is a finite set of orthonormal quantum states , a basis of a hilbert space @xmath96 spanned by states from @xmath61 .",
    "2 .   @xmath22 is a finite set of classical states .",
    "@xmath7 is a finite alphabet of input symbols and @xmath97 , where @xmath98 will be used as the left end - marker and @xmath65 as the right end - marker .",
    "@xmath99 is the initial quantum state .",
    "@xmath49 is the initial classical state .",
    "@xmath100 and @xmath101 , where @xmath102 , are sets of the classical accepting and rejecting states , respectively . 7 .",
    "@xmath103 is a quantum transition function @xmath104 assigning to each pair @xmath105 a unitary transformation .",
    "@xmath106 is a mapping @xmath107 where each @xmath108 corresponds to a projective measurement ( a projective measurement will be taken each time a unitary transformation is applied ; if we do not need a measurement , we denote that @xmath109 , and we assume the result of the measurement to be a fixed @xmath110 ) .",
    "@xmath25 is a special transition function of classical states .",
    "let the results set of the measurement be @xmath111 , @xmath112 , then @xmath113 where @xmath114 means that if a tape symbol @xmath115 is being scanned and the projective measurement result is @xmath116 , then the state @xmath117 is changed to @xmath118 .",
    "given an input @xmath119 , the word on the tape will be seen as @xmath120 ( for convenience , we denote @xmath121 and @xmath122 ) .",
    "now , we define the behavior of 1qcfa @xmath59 on any input word @xmath30 .",
    "the computation starts in the classical state @xmath49 and the quantum state @xmath123 .",
    "after that transformations associated with symbols in the word @xmath124 are applied in succession . a transformation associated with a state @xmath125 and a symbol @xmath69 consists of three steps :    1 .   the unitary transformation @xmath126 is applied to the current quantum state @xmath127 , yielding the new state @xmath128 .",
    "the observable @xmath129 is measured on @xmath130 .",
    "the set of possible results is @xmath131 . according to quantum mechanics principles , such a measurement yields the classical outcome @xmath132 with probability @xmath133 , and the quantum state of @xmath59 collapses to @xmath134 .",
    "the current classical state @xmath117 is changed to @xmath135    an input word @xmath30 is assumed to be accepted ( rejected ) if and only if the automaton enters at the end an accepting ( rejecting ) state .",
    "it is assumed that @xmath25 is well defined so that 1qcfa @xmath59 always accepts or rejects at the end of the computation .",
    "an mo-1qfa , 1qcfa @xmath59 recognizes a language @xmath35 with bounded error @xmath136 if for every @xmath27    * @xmath137 if and only if @xmath138\\geq 1-\\varepsilon$ ] .",
    "* @xmath139 if and only if @xmath140\\geq 1-\\varepsilon$ ] .",
    "a pvmo-1qfa @xmath59 recognizes a promise problem @xmath141 with an error probability @xmath136 if for every @xmath27    * @xmath52 if and only if @xmath138\\geq 1-\\varepsilon$ ] .",
    "* @xmath55 if and only if @xmath140\\geq 1-\\varepsilon$ ] .",
    "a promise problem @xmath42 is solved by a pvmo-1qfa @xmath59 with an error probability @xmath136 if for every @xmath54    * @xmath52 implies that @xmath138\\geq 1-\\varepsilon$ ] , and * @xmath142 implies that @xmath140\\geq 1-\\varepsilon$ ] .",
    "if @xmath143 , we say that the automaton @xmath59 solves ( recognizes ) the promise problem @xmath57 exactly .",
    "we will now study closure properties of promise problems recognized or solved by pvdfa .",
    "[ th - rec ] a promise problem @xmath42 can be recognized by a pvdfa @xmath20 iff both @xmath11 and @xmath12 are regular .",
    "( @xmath144 ) suppose that a promise problem @xmath57 can be recognized by a pvdfa @xmath145 .",
    "in such a case , for all @xmath27 , @xmath44 if and only if @xmath37 .",
    "let dfa @xmath146 .",
    "obviously , @xmath11 is recognized by @xmath147 and therefore @xmath11 is regular . using similar argument , one can show that @xmath12 is regular .",
    "( @xmath148 ) let us assume that the set @xmath11 can be recognized by a dfa @xmath149 and @xmath12 can be recognized by a dfa @xmath150 .",
    "we now consider the following pvdfa @xmath151 where    * @xmath152 ; * @xmath153 ; * @xmath154 ; * @xmath155 and @xmath156 .    for any @xmath157 , we prove first that @xmath158 .",
    "let us assume that @xmath159 .",
    "we have @xmath160 . therefore , @xmath161 and @xmath162 .",
    "this implies that @xmath44 and @xmath55 , which is a contradiction .    if @xmath44 , then @xmath163 and @xmath164 .",
    "therefore , @xmath165 .    if @xmath157 is such that @xmath37 , then @xmath166 .",
    "we have therefore @xmath167 and @xmath44 .    with a similar argument as above , we can show that for any @xmath157 , @xmath55 if and only if @xmath53 .    therefore the promise problem @xmath42 can be recognized by the pvdfa @xmath20 .    if a promise problem @xmath57 is recognized by a pvdfa @xmath20 , then @xmath57 is solved by the same pvdfa @xmath20 .",
    "however , if a promise problem @xmath57 is solved by a pvdfa @xmath20 , it does not necessarily mean that @xmath57 can be recognized by a pvdfa .",
    "for example , let us consider the promise problems @xmath168 with @xmath169 and @xmath170 , where @xmath171 is a fix positive integer .",
    "the promise problem @xmath172 can be solved by a dfa @xcite .",
    "therefore it can be solved by a pvdfa .",
    "however , both @xmath173 and @xmath174 are _ nonregular languages_. therefore @xmath172 can not be recognized by a pvdfa .",
    "the pumping lemma for pvdfa concerning recognition is similar to the classical one @xcite .",
    "let a promise problem @xmath42 can be recognized by a pvdfa @xmath20 .",
    "then there exists an integer @xmath175 , depending only on @xmath20 , such that every string @xmath30 in @xmath11 ( @xmath12 ) , of length at least @xmath2 , can be written as @xmath176 ( i.e. , w can be divided into three substrings ) , satisfying the following conditions :    * @xmath177 ; * @xmath178 ; * @xmath179 for all integers @xmath180 .",
    "the pumping lemma for pvdfa concerning solvability has quite a different form than the above pumping lemma .",
    "[ pumpinglemmai ] let a promise problem @xmath42 can be solved by a pvdfa @xmath20",
    ". then there exists an integer @xmath181 , depending only on @xmath20 , such that every string @xmath30 in @xmath11 ( @xmath12 ) , of length at least @xmath2 , can be written as @xmath176 ( i.e. , w can be divided into three substrings ) , satisfying the following conditions :    * @xmath177 ; * @xmath178 ; * @xmath182 for all integers @xmath180 .",
    "let pvdfa @xmath145 and @xmath183 be the number of the of states of @xmath20 . for a word @xmath184 , we denote the computation of @xmath20 on @xmath30 by the following sequence of transitions : @xmath185 where @xmath186 .",
    "if @xmath187 , then there exist @xmath188 such that @xmath189 . let @xmath190 , @xmath191 and @xmath192 .",
    "we have , @xmath193 , @xmath194 and @xmath195 . therefore @xmath196 .",
    "if there exists an integer @xmath180 such that @xmath197 , then @xmath198 , which is a contradiction . therefore , we have @xmath182 for all @xmath180 .    in the following example it will be shown how pumping lemma ii can be used to prove that a promise problem can not be solved by pvdfa .",
    "[ eample-1 ] let us consider the promise problem @xmath199 with @xmath200 and @xmath201 .",
    "assume that @xmath202 can be solved by a pvdfa @xmath20 and @xmath2 is the constant for the pumping lemma .",
    "choose @xmath203 . clearly , @xmath204 . by the pumping lemma ii , @xmath205 for some @xmath206 such that ( 1 ) @xmath207 , ( 2 ) @xmath208 , and ( 3 ) @xmath209 for all @xmath180 . by ( 1 ) and ( 2 )",
    ", we have @xmath210 , @xmath211 . however , @xmath212",
    ". therefore , ( 3 ) does not hold .",
    "the promise problem @xmath202 therefore does not satisfy the pumping property of the pumping lemma ii .",
    "hence , the promise problem @xmath202 can not be solved by any pvdfa .",
    "let us have promise problems @xmath42 and @xmath213 over the same alphabet is a promise problem over alphabet @xmath7 , then we can also think of @xmath214 over any finite alphabet that is a superset of @xmath7 . see @xcite for more details . ] .",
    "the complement , intersection and union operations on such promise problems will be defined as follows .",
    "* complement : @xmath215 , where @xmath216 and @xmath217 .",
    "* intersection : @xmath218 , where @xmath219 and @xmath220 .",
    "* union : if @xmath221 , then the union of @xmath57 and @xmath222 will be undefined ; otherwise the union @xmath223 , where @xmath224 and @xmath225 .",
    "there seems to be several other ways one could try to define intersection and union of @xmath57 and @xmath222 .",
    "we will now try to argue that our definitions are reasonable .",
    "let us assume that alice has two subsets @xmath11 and @xmath12 over @xmath9 .",
    "if alice would be asked for an @xmath226 whether @xmath13 or @xmath14 , then she should be able to answer ",
    "yes \" or  no \" ( by checking whether @xmath13 or @xmath14 ) .",
    "let us assume also that bob has two subsets @xmath227 and @xmath228 over @xmath9 .",
    "if bob would be asked for an @xmath229 whether @xmath230 or @xmath231 , then he should be able to give correct answer .",
    "the intersection of two promise problems should be therefore such that for a given input , both alice and bob are able to tell whether a given input is in the yes  set or no  set .",
    "the union of two promise problems should be therefore such that for a given input , at least one of alice and bob are able to tell whether it is in the yes  set or no  set , that is why union was defined in the way it was .",
    "let us now give several results concerning how promise problems are closed on some operations in the case of recognizability and solvability modes .",
    "if a promise problems @xmath57 can be recognized ( solved ) by a pvdfa , then @xmath232 can be recognized ( solved ) by a pvdfa .",
    "suppose that a promise problem @xmath57 can be recognized ( solved ) by a pvdfa @xmath145 .",
    "exchanging the sets of accepting states and rejecting states of the pvdfa @xmath20 , we get a new pvdfa @xmath233 .",
    "it is easy to see that @xmath232 is recognized ( solved ) by the pvdfa @xmath234 .",
    "if promise problems @xmath57 and @xmath222 can be recognized by pvdfa , then their intersection can be also recognized by a pvdfa .",
    "suppose that a promise problem @xmath57 can be recognized by a pvdfa @xmath235 and a promise problem @xmath222 can be recognized by a pvdfa @xmath236 .",
    "we consider a pvdfa @xmath145 , where    * @xmath237 ; * @xmath153 ; * @xmath154 ; * @xmath238 and @xmath239 .",
    "let the promise problem @xmath240 be the intersection of the promise problems @xmath42 and @xmath213 .    if @xmath241 , then @xmath242 . we have @xmath243 and @xmath244 .",
    "therefore , we have @xmath245 .",
    "if @xmath157 is such that @xmath37 , we have @xmath246 . therefore , @xmath247 and @xmath244 , i.e. @xmath44 and @xmath248 .",
    "hence , @xmath249 .",
    "therefore , we have @xmath241 if and only if @xmath37 . by a similar argument",
    ", we can show that @xmath250 if and only if @xmath53 . hence , the promise problem @xmath251 can be recognized by the pvdfa @xmath20 .",
    "if promise problems @xmath57 and @xmath222 can be solved by pvdfa , then their intersection can be solved also by a pvdfa .",
    "let a promise problem @xmath240 be the intersection of the two promise problems @xmath42 and @xmath213 .",
    "suppose that the promise problem @xmath42 can be solved by a pvdfa @xmath20 .",
    "since @xmath252 and @xmath253 , the promise problem @xmath202 can be solved by @xmath20 .",
    "let promise problems a and b over an alphabet @xmath7 can be recognized by pvdfa and their union @xmath202 exists , then @xmath202 can be recognized also by a pvdfa .",
    "suppose that the promise problem @xmath57 with the alphabet @xmath7 can be recognized by a pvdfa @xmath235 and the promise problem @xmath222 with alphabet @xmath7 can be recognized by a pvdfa @xmath236 .",
    "we consider the pvdfa @xmath145 , where    * @xmath254 ; * @xmath153 ; * @xmath154 ; * @xmath255 and @xmath256 .",
    "let the promise problem @xmath240 be the union of promise problems @xmath42 and @xmath213 . since the union @xmath257 exists , we have @xmath258 .",
    "we prove now for any @xmath157 that @xmath259 .",
    "let us assume that @xmath260 .",
    "we have @xmath160 .",
    "therefore , @xmath161 and @xmath261 . from",
    "that it follows that @xmath44 and @xmath262 .",
    "therefore , @xmath263 , which is a contradiction . by a similar argument we can prove that @xmath264 . hence @xmath265 .",
    "if @xmath241 , then @xmath266 . we have @xmath243 or @xmath244 . therefore , @xmath267 .",
    "if @xmath157 is such that @xmath37 , we have @xmath267 . therefore , @xmath247 and @xmath244 , i.e. @xmath44 or @xmath248 .",
    "hence , @xmath268",
    ".    therefore , @xmath241 if and only if @xmath37 . by a similar argument",
    ", we can show that @xmath250 if and only if @xmath53 .",
    "hence , the promise problem @xmath257 can be recognized by the pvdfa @xmath20 .",
    "if promise problems @xmath57 and @xmath222 can be solved by pvdfa and their union @xmath202 exists , then @xmath202 may not be solved by a pvdfa .",
    "indeed , let @xmath42 , where @xmath269 and @xmath270n \\mbox { is even}\\}$ ] .",
    "if @xmath44 , then @xmath271 and @xmath272 are odd . if @xmath55 , at least one of @xmath271 and @xmath272 is even",
    "obviously , we can design a pvdfa to solve the promise problem @xmath57 .",
    "let @xmath213 , where @xmath273 and @xmath274\\mbox{of } m , n \\mbox { is odd}\\}$ ]",
    ". similarly , we can design another pvdfa to solve the promise problem @xmath222 .",
    "now we consider their union @xmath275 , where @xmath276 and @xmath277 .",
    "according to example [ eample-1 ] , @xmath202 can not be solved by any pvdfa .",
    "let us start with some basic definitions concerning ordering of promise problems .",
    "let @xmath141 and @xmath278 be two promise problems over an alphabet @xmath7 .",
    "we say that @xmath57 is a _ subproblem _ of @xmath222 , denoted by @xmath279 , if @xmath280 and @xmath281 .",
    "we say also that a pvdfa @xmath20 is _ equivalent _ to a pvdfa @xmath282 ( denoted by @xmath20=@xmath282 ) if @xmath283 .",
    "we say that a pvdfa @xmath282 is _ more powerful than or equivalent to _ a pvdfa @xmath20 ( denoted by @xmath284 or @xmath285 ) if @xmath286 .",
    "it is clear that the set of all pvdfa is a partially ordered set with the partial order ` @xmath287 ' .",
    "we say that a pvdfa @xmath282 is _ more powerful _ than a pvdfa @xmath20 ( denoted by @xmath288 or @xmath289 ) if @xmath286 and @xmath290 .    the first outcome concering the impact of ordering on solvability of promise problems follows in a straightforward way from basic definitions .",
    "if a promise problem @xmath57 can be solved by a pvdfa @xmath20 and @xmath285 , then the promise problem @xmath57 can be solved by the pvdfa @xmath282 .",
    "we say a pvdfa @xmath20 is maximally powerful if there does not exist a pvdfa @xmath282 such that @xmath291 .",
    "a pvdfa @xmath20 is maximally powerful if and only if it is ( essentially ) a dfa .    if @xmath20 is a dfa , then @xmath292",
    "therefore , there does not exist a promise problem @xmath222 such that @xmath293 .",
    "therefore , there does exist a pvdfa @xmath282 such that @xmath291 , i.e. @xmath20 is maximally powerful .",
    "assume that a pvdfa @xmath20 is maximally powerful and @xmath20 is not a dfa .",
    "suppose that the pvdfa @xmath294 and it is state minimal .",
    "we have that @xmath295 and @xmath48 is a proper subset of @xmath296 .",
    "let us now consider a new pvdfa @xmath297 .",
    "suppose that @xmath298 . therefore , there must exist some @xmath262 such that @xmath299 and @xmath300 .",
    "therefore , @xmath301 is a proper subset of @xmath228 . since @xmath302 .",
    "we have @xmath303 , which is a contradiction .",
    "hence , @xmath20 must be a dfa .",
    "we say that two pvdfa @xmath20 and @xmath282 are comparable if @xmath304 or @xmath289 or @xmath305 .",
    "two dfa are either equivalent or not comparable . if a pvdfa @xmath20 is a dfa , then there does not exist a pvdfa @xmath282 such that @xmath291 .",
    "equivalence of two dfa can be seen as a special case of the equivalence of two pvdfa .",
    "if pvdfa @xmath304 , then @xmath20 is a potential substitute for @xmath282 in recognizing promise problems ( languages ) .",
    "if pvdfa @xmath306 , then @xmath20 is a potential substitute for @xmath282 in solving promise problems .",
    "therefore , it is important to determine the order of pvdfa .",
    "in order to study determination of equivalence and ordering of two given pvdfa , we now introduce the concept of a _ bilinear machine _ ( blm ) .    by @xcite ,",
    "a blm over an alphabet @xmath7 is a four - tuple @xmath307 , where @xmath22 is a finite set of states with @xmath308 , @xmath309 , @xmath310 and @xmath311 for @xmath28 .",
    "the _ word function _",
    "@xmath312 associated to @xmath20 is then defined as follows : @xmath313 where @xmath314 .",
    "two blms @xmath315 and @xmath316 are said to be equivalent if @xmath317 for all @xmath318 . for this problem ,",
    "we recall a result from @xcite .",
    "[ lemm : blm ] there exists a polynomial - time algorithm _ ( _ running in time @xmath319 _ ) _ that takes two blms @xmath315 and @xmath316 as inputs and determines whether @xmath315 and @xmath320 are equivalent , where @xmath321 and @xmath322 are the numbers of states of @xmath315 and @xmath316 , respectively .    using this lemma",
    "we will obtain the following result .",
    "it is decidable whether two pvdfa are comparable .    given two pvdfa @xmath20 and @xmath282 , it is sufficient to prove that it is decidable whether @xmath304 , and whether @xmath291 .    at first",
    "we prove that it is decidable whether @xmath304 . indeed , suppose that a pvdfa @xmath323 recognizes a promise problem @xmath240 .",
    "we construct now a blm : @xmath324 , where @xmath325 is an @xmath326-dimensional row vector with @xmath327=1 $ ] and @xmath328=1 $ ] for @xmath329 , @xmath330 is an @xmath331 matrix with @xmath332=1 $ ] if @xmath333 and @xmath75 otherwise , and @xmath334 is an @xmath326-dimensional column vector such that @xmath335=\\left\\ {            \\begin{array}{ll }              1 , & \\hbox{if $ s\\in s_a$ ; } \\\\              2 , & \\hbox{if $ s\\in s_r$ ; } \\\\              0 , & \\hbox{otherwise . }",
    "\\end{array }          \\right.\\end{aligned}\\ ] ] to such a blm @xmath336 we can associate a function @xmath337 defined as follows : @xmath338 iff @xmath339 , @xmath340 iff @xmath341 , and @xmath342 iff @xmath343",
    ".    therefore , two pvdfa @xmath20 and @xmath282 are equivalent iff their associated blms @xmath234 and @xmath344 are equivalent , i.e. , @xmath345 for all @xmath346 .",
    "the latter problem is decidable by lemma [ lemm : blm ] .    as the next",
    "we show that it is decidable whether @xmath291 .",
    "suppose that a pvdfa @xmath323 is such that @xmath347 .",
    "let us now consider dfa @xmath348 and @xmath349 .",
    "clearly @xmath350 and @xmath351 .",
    "these observations can now be used as follows .",
    "given two pvdfa @xmath20 and @xmath282 , we have @xmath291 iff @xmath352 and @xmath353 .",
    "it is clear that @xmath354 is equivalent to @xmath355 .",
    "the later problem is decidable , since it is easy to construct a dfa @xmath356 recognizing @xmath357 and the equivalence between dfa @xmath356 and @xmath20 is decidable .",
    "therefore , given two dfa @xmath20 and @xmath282 , it is decidable whether @xmath354 .",
    "note that for any given pvdfa , there exist algorithms to find an equivalent pvdfa which has the smallest number of states among all pvdfa equivalent to the given one , since a pvdfa can be considered as a special moore automaton whose minimization problem is known to be solvable , see @xcite for more details .",
    "if one of the following cases @xmath304 , @xmath291 or @xmath358 holds , then we know that two pvdfa are comparable . otherwise , they are not comparable .",
    "suppose that pvdfa @xmath20 has @xmath321 states and pvdfa @xmath282 has @xmath322 states , it takes polynomial time ( @xmath319 ) to determine whether @xmath304 .",
    "given two dfa @xmath356 and dfa @xmath359 , it takes also polynomial time to find out @xmath360 . according to the above theorem",
    ", therefore , it takes polynomial time to determine whether two pvdfa are comparable or not .",
    "consideration of state complexity is another way to get a deepen insight in to the power of various types of automata @xcite . in this section",
    "we will deal with the state complexity of pvdfa for promise problems with respect to recognizability and solvability .    for a regular language @xmath35 ,",
    "we denote by @xmath361 the number of states of the minimal dfa to recognize the language @xmath35 . for a promise problem @xmath141 that can be recognized by a pvdfa ,",
    "we denote by @xmath362 the number of states of the minimal pvdfa recognizing @xmath57 . for a promise problem @xmath141 that can be solved by a pvdfa ,",
    "we denote by @xmath363 the number of states of the minimal pvdfa solving @xmath57 .    in a dfa @xmath32",
    ", a state @xmath117 is said to be _",
    "distinguishable _ from a state @xmath364 if there is @xmath27 such that one of the states @xmath365 and @xmath366 is accepting , and the other is not .",
    "if every two states in dfa @xmath20 are distinguishable from each other , then @xmath20 is minimal @xcite .",
    "[ th9 ] if a promise problem @xmath141 with @xmath367 and @xmath368 can be recognized by a pvdfa , then @xmath369    since @xmath57 can be recognized by a pvdfa , according to theorem [ th - rec ] , @xmath11 and @xmath12 are regular languages .",
    "suppose that @xmath57 is recognized by a minimal pvdfa @xmath145 , we have that the regular language @xmath11 can be recognized by the dfa @xmath370 and the regular language @xmath12 can be recognized by the dfa @xmath371 .",
    "therefore , @xmath372 and @xmath373 .",
    "hence @xmath374 .",
    "let us assume that @xmath11 is recognized by a minimal dfa @xmath149 and @xmath12 is recognized by a minimal dfa @xmath150 . according to theorem [ th - rec ] ,",
    "the promise problem can be recognized by the pvdfa @xmath151 where @xmath152 , @xmath153 , @xmath154 , @xmath155 and @xmath156 .",
    "therefore , we have @xmath375 .",
    "a natural problem is whether inequalities ( [ eq - com ] ) are tight .",
    "next we try to answer them partially .",
    "first , we consider the left side .",
    "the left side of inequalities ( [ eq - com ] ) is tight .",
    "we prove that @xmath376 in some cases .",
    "let us consider the promise problem @xmath377 with @xmath378 and @xmath379 , where @xmath380 is a fix prime and @xmath171 is a fix positive integer such that @xmath381 .",
    "it is easy to see that @xmath382 and @xmath383 .",
    "let us consider now an @xmath380-state pvdfa @xmath384 , where @xmath385 , @xmath386 , @xmath387 and @xmath388 .",
    "it is easy to check that the promise problem @xmath389 can be recognized by the pvdfa @xmath282 .",
    "let us assume now that the promise problem @xmath389 can be recognized by an @xmath390-state pvdfa @xmath391 and @xmath392 .",
    "it is easy to see that the dfa @xmath393 can solve the promise problem @xmath389 .",
    "therefore , the minimal dfa to solve the promise problem @xmath389 has less than @xmath380 states , contradicting the fact that the minimal dfa to solve @xmath389 has @xmath380 states @xcite",
    ".    therefore , @xmath394 .    for the right side , we only know the following relation .",
    "[ bound ] there is a promise problem @xmath57 satisfying @xmath395 .    in the interest of readability , we put the proof in appendix .    if a promise problem @xmath141 can be recognized by a pvdfa , then @xmath396s(a_{no})\\}$ ] .",
    "according to theorem [ th - rec ] , @xmath11 and @xmath12 are regular languages .",
    "suppose @xmath11 can be recognized by a minimal dfa @xmath397 .",
    "this implies that the promise problem @xmath57 can be solved by the dfa @xmath398 and therefore @xmath399 .",
    "suppose @xmath12 can be recognized by a minimal dfa @xmath400 .",
    "we get that the promise problem @xmath57 can be solved by the dfa @xmath401 and therefore @xmath402 .",
    "hence @xmath403 .",
    "we prove that @xmath404 in same cases .",
    "let us consider the promise problem @xmath377 with @xmath378 and @xmath379 , where @xmath380 is a fix prime and @xmath171 is a positive integer such that @xmath381 .",
    "it is easy to see that @xmath382 and @xmath383 .",
    "it has been proved in @xcite that @xmath405",
    ". therefore @xmath406 .",
    "@xmath363 can be very small with respect to @xmath407 and @xmath408 .",
    "for example , let us consider the promise problem @xmath377 with @xmath378 and @xmath379 , where @xmath380 is a fix even integer and @xmath171 is fix odd integer such that @xmath381 . obviously , we have @xmath382 and @xmath383",
    ". however @xmath409 , since the length of the input @xmath410 is even if @xmath411 and the length of the input @xmath410 is odd if @xmath412 .",
    "it has been proved that two - way quantum finite automata ( 2qfa ) @xcite and also 2qcfas @xcite are more powerful than two - way probabilistic finite automata ( 2pfa ) in recognizing languages .",
    "2qcfa are also more powerful than 2pfa in solving promise problems @xcite . in the case of one - wayness",
    ", it has been proved that one - way quantum finite automata ( 1qfa ) are not more powerful than one - way classical finite automata ( 1fa ) @xcite in recognizing languages .",
    "however , we will prove that 1qfa can be more powerful than their classical counterparts when recognizing promise problems .",
    "we prove now that the exact 1qfa have advantages in recognizing promise problems comparing to their classical counterparts ( dfa ) . some of the proof techniques can be found in @xcite .",
    "let us consider a family of promise problems @xmath413 with @xmath414 and @xmath415 , where @xmath171 is a fix positive integer such that @xmath416 for some integer @xmath417 .",
    "[ thmoq - dfa ] the promise problems @xmath418 can be recognized exactly by a pvmo-1qfa and can not be recognized by any pvdfa .",
    "let @xmath419 we will now construct a pvmo-1qfa @xmath420 to recognize @xmath418 exactly , where    * @xmath421 , @xmath422 , @xmath423 .",
    "* @xmath68 are defined as follows : @xmath424    see @xcite for more intuitions why we choose @xmath425 and @xmath426 in the way as above .",
    "since @xmath427 , for @xmath428 , we have @xmath429    let @xmath430 and @xmath431 . if @xmath432 , then the quantum state before the measurement is @xmath433 and if the input @xmath434 , then the quantum state before the measurement is @xmath435 where @xmath436 and @xmath437 are amplitudes that we do not need to specify more exactly .    since the amplitude at @xmath76 in the above quantum state @xmath438 is 0 , we get the exact result after the measurement of @xmath439 in the standard basis @xmath440 . therefore , we have    * if @xmath432 , then @xmath441=1 $ ] ; * if @xmath434 , then @xmath442= 1 $ ] .",
    "we now give the proof for the other direction .",
    "namely , we show that @xmath441=1 $ ] implies that @xmath432 .",
    "assume that @xmath443 , that is @xmath444 .",
    "the quantum state before the measurement is @xmath445 since @xmath446 , there are no integers @xmath447 such that @xmath448 . therefore @xmath449 and @xmath441\\neq 1 $ ] .",
    "we now prove the following : if @xmath450=1 $ ] , then the input @xmath434 .",
    "assume that @xmath451 , that is @xmath452 .",
    "the quantum state before the measurement is @xmath453 let @xmath454 .",
    "since @xmath446 and @xmath455 , we have    @xmath456    therefore , @xmath441\\neq 1 $ ] .",
    "hence , we have proved that the promise problem @xmath418 can be recognized exactly by the pvmo-1qfa @xmath457 .",
    "obviously , @xmath458 and @xmath459 are not regular languages .",
    "according to theorem [ th - rec ] , the promise problem @xmath418 can not be recognized by any pvdfa .    from theorem",
    "[ thmoq - dfa ] it implies that there are three subsets ( non - regular languages ) that can be distinguished precisely by a pvmo-1qfa , but any pvdfa can not do it , and this result further shows a stronger aspect of 1qfa than dfa .",
    "we will now consider solvability mode .",
    "geffert and yakaryilmaz @xcite proved that the promise problem ( @xmath110 ) where @xmath460 is an integer .",
    "] can be solved by a _",
    "one - way probability finite automaton _ ( pfa ) @xmath461 , but there is no dfa solving ( @xmath110 ) .",
    "rashid and yakaryilmaz @xcite proved that a promise problem can be solved by a las vegas realtime rtqcfa or by an exact rational restarting rtqcfa in linear expected time , where there is no bounded - error pfa that solves the promise problem . in order to prove that 1qcfa have advantages in solving promise problems comparing to their classical counterparts ( pfa ) , we define a new promise problem @xmath462 where @xmath463 is a polynomial of @xmath464 which will be specified later .",
    "[ thqcfa - pfa ] for any @xmath465 , the promise problem @xmath466 can be solved by a 1qcfa with the error probability @xmath136 , but there is no pfa solving @xmath466 with the error probability @xmath136 .",
    "let @xmath446 .",
    "we design a 1qcfa @xmath467 to solve the promise problem @xmath466 , where @xmath468 .",
    "the automaton @xmath59 proceeds as shown in figure [ f3 ] , where @xmath469    [ cols=\"<\",options=\"header \" , ]     let us choose @xmath470 . if the input @xmath471 , then the quantum state before the measurement in the step 2.2 is always @xmath76 .",
    "therefore , the input will be accepted with certainty .",
    "if the input @xmath472 , the quantum state before the @xmath417-th measurement in the step 2.2 is @xmath473    according to @xcite , the rejecting probability after the @xmath417-th measurement is @xmath474 and the overall probability that @xmath59 rejects the input @xmath30 is @xmath475&=     \\sum_{i\\geq 1}^{t}\\left(p_{ir}\\prod^{i-1}_{i=1 }   ( 1-p_{r(i-1)})\\right ) > \\sum_{i\\geq 1}^{t}\\left(\\frac{1}{2l^2}\\prod^{i-1}_{i=1 }   ( 1-\\frac{1}{2l^2})\\right)\\\\ & = \\sum_{i\\geq 1}^{t}\\frac{1}{2l^2 } ( 1-\\frac{1}{2l^2})^{i-1}=\\frac{1}{2l^2 } \\frac{1-(1-\\frac{1}{2l^2})^t}{\\frac{1}{2l^2}}=1-(1-\\frac{1}{2l^2})^t.\\end{aligned}\\ ] ]    since @xmath476 , we have @xmath475>1-(1-\\frac{1}{2l^2})^t>1-e^{-\\frac{1}{2l^2}t}\\geq 1-e^{-\\frac{1}{2l^2 } 2l^2\\log_{e}\\frac{1}{\\varepsilon}}=1-e^{-\\log_{e}\\frac{1}{\\varepsilon}}=1-\\varepsilon.\\end{aligned}\\ ] ]    therefore , the promise problem @xmath466 can be solved by a 1qcfa @xmath59 with the error probability @xmath136 .",
    "assume now that there is a pfa @xmath20 solving @xmath466 with the error probability @xmath136 .",
    "let us consider a 2pfa @xmath59 running as follows :    1 .",
    "@xmath59 reads the input @xmath30 from the left to the right ",
    "symbol by symbol ; 2 .   after reading each @xmath477",
    ", @xmath59 simulates the transformation of the pfa @xmath20 reading @xmath478 ; 3 .",
    "when @xmath59 reaches the right - end marker , @xmath59 moves its tape head to the left most symbol of the input @xmath30 and reads the input @xmath30 again .",
    "if @xmath59 reads the input @xmath30 @xmath463 times , then we have , according to the above assumption , @xmath479=pr[{\\cal a}\\ \\mbox{accepts}\\   a^nb^n\\#]\\geq 1-\\epsilon\\ ] ] and @xmath480=pr[{\\cal a}\\ \\mbox{accepts}\\   a^nb^m\\#]\\leq 1-pr[{\\cal a}\\ \\mbox{rejects}\\   a^nb^m\\ # ] \\leq \\epsilon\\ ] ] where @xmath481 .    therefore , for any integers @xmath17 and @xmath482",
    ", it holds @xmath483-pr[{\\cal m}\\ \\mbox{accepts}\\   a^nb^{n+d}\\ # ] \\right|\\geq 1 - 2\\epsilon\\geq \\epsilon.\\ ] ]    since @xmath463 is a polynomial of the length of the input @xmath30 , the following lemma holds ( as in @xcite ) :    [ lm - gw86 ] let @xmath484 .",
    "suppose that @xmath59 is a two - way probabilistic finite automaton ( 2pfa ) with @xmath485 expected running time , where @xmath410 is the length of the input .",
    "then there exists , for all sufficiently large @xmath17 , an integer @xmath486 such that @xmath487-pr[{\\cal m}\\ \\mbox{accepts}\\   a^nb^{n+d}\\ # ] \\right| < \\epsilon.\\ ] ]    obviously , equality ( [ eq - c ] ) contradicts equality([eq - gw86 ] ) .",
    "therefore , there is no pfa solving @xmath466 with the error probability @xmath136 .",
    "we now study state complexity .",
    "we consider the following promise problem @xmath488 where @xmath489 .",
    "[ thmoq - moq ] for integer @xmath490 , the promise problems @xmath1 can be solved with error probability @xmath0 by an mo-1qfa with two quantum basis states , but can not be solved exactly by any mo-1qfa with two quantum basis states .",
    "we will now construct an mo-1qfa @xmath491 to solve @xmath1 , where    * @xmath468 , @xmath422 .",
    "* @xmath68 are defined as follows : @xmath492    if input @xmath493 , then the quantum state before the measurement is @xmath494 the automaton @xmath59 has the accepting probability @xmath84 = \\cos^2 l_1\\theta\\geq 2/3.\\ ] ] if input @xmath495 , then the quantum state before the measurement is @xmath496 the automaton @xmath59 has the rejecting probability @xmath85=1- pr[{\\cal m}\\ \\mbox{accepts}\\   w]=1-\\cos^2 l_2\\theta\\geq 1 - 1/3=2/3.\\ ] ] therefore , @xmath1 can be solved by the automaton @xmath59 with error probability @xmath497 .",
    "suppose that the promise problems @xmath1 can be solved exactly by an mo-1qfa @xmath498 with two basis states .",
    "without loss of generality , we assume that @xmath499 , where @xmath500 and @xmath501 .    since @xmath490 , we have @xmath502 and @xmath503 .",
    "since the probability that @xmath498 accepts @xmath504 is 1 , we have @xmath505 where @xmath506 and @xmath507 .",
    "therefore , @xmath508 , where @xmath509 is conjugate and transpose of @xmath510 .",
    "since the probability that @xmath498 accepts @xmath511 is also 1 , we have also @xmath512 where @xmath513 and @xmath514 .",
    "therefore , we have @xmath515 it is easy to find out that @xmath516 where @xmath517 and @xmath518 with @xmath519 .",
    "it is easy to see that @xmath520 .",
    "therefore , we have @xmath521 .",
    "now for any integer @xmath522 , we have @xmath523 obviously , @xmath524 .",
    "therefore , for any @xmath522 , the automaton accepts the input @xmath525 with probability 1 .",
    "if @xmath526 , it is easy to check that @xmath527 and @xmath528 .",
    "thus , we get a contradiction .",
    "therefore , the promise problems @xmath1 can not be solved exactly by any mo-1qfa with two quantum basis states .    in the previous theorem , the error probability @xmath529 . for @xmath530 , using the same method as the previous theorem , we can prove that the following promise problem @xmath531 where @xmath532 , can be solved with error probability @xmath136 by an mo-1qfa with two quantum basis states , but can not be solved exactly by any mo-1qfa with two quantum basis states .",
    "we consider now the minimal pfa to solve the promise problem @xmath1 with @xmath2 is prime .",
    "[ thmoq - pfa ] for any prime @xmath533 , the minimal pfa solving the promise problem @xmath1 with error probability ( smaller than @xmath3 ) has @xmath2 states .",
    "we consider now a @xmath2-state dfa @xmath534 , with the set of states @xmath535 , the set of accepting states @xmath536 , and the transition function @xmath537 .",
    "obviously , the promise problem @xmath1 can be solved by the automaton @xmath20 .",
    "a dfa is also a pfa .",
    "therefore , there is a pfa with @xmath2 states solving the promise problem @xmath1 .",
    "the minimal pfa that solving the promise problem @xmath1 has not more than @xmath2 states .    since @xmath533",
    ", there must be fix integers @xmath538 such that @xmath539 and @xmath540 .",
    "we consider the following promise problem @xcite .",
    "namely , @xmath541 with @xmath542 and @xmath543 , where @xmath380 , @xmath544 and @xmath545 are fixed positive integers such that @xmath546 .",
    "let @xmath547 and @xmath548 .",
    "according to subsection 3.3 , we have @xmath549 .",
    "any pfa that solving the promise problem @xmath1 can also solve the promise problem @xmath550 . according to @xcite",
    "( see theorem 4 ) , the minimal pfa solving the promise @xmath550 with error probability has @xmath486 states , where @xmath486 is the smallest positive integer such that @xmath551 and @xmath552 .",
    "since @xmath2 is prime , we have @xmath553 .",
    "therefore , the minimal pfa that solving the promise problem @xmath1 has at least @xmath2 states .",
    "thus , the theorem has been proved .",
    "in order to make clear the difference between recognizability and solvability of quantum and classical finite automata , we have introduced several promise versions finite automata and discussed their properties . we have explored some basic properties of promise problems recognized and solved by pvdfa , and we have showed the state complexity for several promise problems concerning recognizability and solvability .",
    "in particular , we have proved that one - way quantum finite automata can be more powerful than their classical counterparts when recognizing and solving some promise problems .",
    "more specifically , we have proved :    * there is a promise problem that can be recognized exactly by _ measure - once one - way quantum finite automata _ ( mo-1qfa ) , but no _ deterministic finite automata _ ( dfa ) can recognize it .",
    "indeed , this result implies that there are three subsets ( non - regular languages ) that can be distinguished precisely by a pvmo-1qfa , but any pvdfa can not do it .",
    "* there is a promise problem that can be solved with error probability @xmath0 by _ one - way finite automaton with quantum and classical states _ ( 1qcfa ) , but no _ one - way probability finite automaton _ ( pfa ) can solve it with error probability @xmath0 . * especially , there are promise problems @xmath1 with size @xmath2 that can be solved _ with any error probability _ by mo-1qfa with only two quantum basis states , but they can not be solved _",
    "exactly _ by any mo-1qfa with two quantum basis states ; in contrast , the minimal _ one - way probability finite automaton _ ( pfa ) solving @xmath1 _ with any error probability _",
    "( usually smaller than @xmath3 ) has @xmath2 states .    however , there are still some problems to be considered for future research , and we list them in the following .    1",
    ".   first we concern a problem related to _ recognizability _ : suppose that a promise problem @xmath57 can be recognized by a quantum ( or probabilistic ) finite automaton with error probability @xmath554 .",
    "then , for any @xmath555 , whether is there a quantum ( or probabilistic ) finite automaton recognizing @xmath57 with error probability @xmath556 ? for solvability , this problem can be verified positively by using the idea of the languages accepted by pfa with _ bounded error _",
    "( e.g. , @xcite ) .",
    "2 .   second is a hierarchic problem for the classes solved by quantum finite automata mentioned in section 1 .",
    "namely , let @xmath16 denote the class of promise problems solved exactly by an mo-1qfa with @xmath17 quantum basis states . then , whether does @xmath18 hold for @xmath19 ?",
    "3 .   for any given regular language @xmath35",
    ", there is , according to the myhill - nerode theorem , a method to find out a minimal dfa @xmath20 to recognize @xmath35 @xcite .",
    "for some specific promise problems , it is possible to find out minimal dfa ( pvdfa ) to solve the promise problems @xcite .",
    "however it is not clear yet whether there is a general way to find out a minimal pvdfa to solve a given promise problem that can be solved by a pvdfa ? 4 .",
    "we have proved that for any @xmath465 , the promise problem @xmath466 can be solved by a 1qcfa with the error probability @xmath136 , but there is no pfa solving @xmath466 with the error probability @xmath136 ( theorem [ thqcfa - pfa ] ) . however , whether is there no pfa solving @xmath466 with the error probability @xmath557 ?",
    "another challenge is to find out some simpler promise problems to demonstrate the advantage of 1qfa in solving promise problems , since the promise problem @xmath466 is quite complex ? 5 .",
    "we have proved that the left side in inequality ( [ eq - com ] ) is tight .",
    "nevertheless , can we prove that the right side is tight ?",
    "this work was partly supported by the national natural science foundation of china ( nos .",
    "61272058 , 61472452 , 61572532 ) .",
    "let @xmath558 and @xmath559 , where @xmath560 are integers such that @xmath561 .",
    "we first prove that @xmath562 .",
    "since @xmath561 , there exist integers @xmath563 and @xmath564 such that @xmath565 and @xmath566 .",
    "assume that @xmath567 .",
    "there must exist integers @xmath417 and @xmath568 such that @xmath569 , i.e. @xmath570 .",
    "we have @xmath571 , which is a contradiction",
    ". therefore , @xmath562 .",
    "let us consider now the promise problem @xmath141 . since @xmath11 and @xmath12 are regular languages , the promise problem @xmath57 can be recognized by a pvdfa .",
    "let us consider the following pvdfa @xmath572 , where      at first , we prove that @xmath577 .",
    "let us assume that there exist @xmath578 such that @xmath579 .",
    "this implies @xmath580 and @xmath581 .",
    "therefore , @xmath582 and @xmath583 .",
    "since @xmath561 , we have @xmath584 , which is a contradiction .",
    "hence , @xmath585 . for any @xmath586 , let @xmath587 where @xmath588 .",
    "since @xmath589 and @xmath590 , we have @xmath591 . therefore @xmath577 .    secondly , we prove that @xmath265 . since @xmath561 , we have @xmath592 and @xmath593 .",
    "assume that @xmath594 .",
    "in such a case , there must exist integers @xmath417 and @xmath568 such that @xmath595 and @xmath596 .",
    "therefore , we have @xmath570 and @xmath597 , which is a contradiction .      finally , we prove that the pvdfa @xmath572 is minimal .",
    "let us consider dfa @xmath599 .",
    "obviously , the dfa @xmath234 recognizes the language @xmath10 .",
    "we prove now that the dfa @xmath234 is minimal .",
    "let @xmath600 and @xmath601 .",
    "for any @xmath602 , we prove that the states @xmath603 and @xmath604 are distinguishable . since @xmath605 , at most one of the following two conditions ( 1 ) @xmath606 and ( 2 ) @xmath607 holds .",
    "we have therefore the following three cases to consider :    1 .",
    "the condition ( 1 ) holds and ( 2 ) does not hold .",
    "in such a case we have @xmath608s^2_{n+1\\ { \\it mod}\\ q}\\rangle=\\langle s^1_{1 } , s^2_{1}\\rangle\\in f$ ] and @xmath609 .",
    "since @xmath610 , we have @xmath611 . therefore , @xmath612 .",
    "hence @xmath613 and @xmath614 are distinguishable .",
    "2 .   the condition ( 2 ) holds and ( 1 ) does not hold .",
    "the proof is similar to the one in the case 1 .",
    "neither the condition ( 1 ) nor ( 2 ) holds .",
    "in such a case we have @xmath615 and @xmath616 . if @xmath617 , then @xmath613 and @xmath614 are distinguishable",
    "otherwise , we have @xmath618 since @xmath619 .",
    "there are now two subcases to consider",
    "we have @xmath621 and @xmath622 .",
    "since @xmath561 and @xmath623 , we have @xmath624 that is @xmath625 . therefore , @xmath626 and @xmath627 .",
    "hence , @xmath613 and @xmath614 are distinguishable .",
    "2 .   @xmath628 .",
    "we have @xmath629 and @xmath630 .",
    "since @xmath628 , we have @xmath631 . since @xmath632 , we have @xmath633 . therefore , @xmath634 .",
    "we have again that @xmath613 and @xmath614 are distinguishable .",
    "we have therefore shown that the dfa @xmath234 is minimal and has @xmath635 states .",
    "let us assume that there is a pvdfa @xmath282 with less than @xmath635 states recognizing the promise problem @xmath57 .",
    "we can then get a dfa with less than @xmath635 states recognizing the language @xmath10 .",
    "this would implies that the dfa @xmath234 is not minimal . a contradiction .",
    "f.  bonchi , m.m .",
    "bonsangue , h.h .",
    "hansen , p.  panangaden , j.j.m.m .",
    "rutten , a.  silva , algebra - coalgebra duality in brzozowski s minimization algorithm , acm transactions on computational logic * 15 * ( 2014 ) , article no .",
    "3 .",
    "j.  gruska , d.w .",
    "qiu , s.g .",
    "zheng , generalizations of the distributed deutsch - jozsa promise problem , mathematical structures in computer science , doi : http://dx.doi.org/10.1017/s0960129515000158 , 21 pages ( 2015 ) .",
    "also arxiv:1402.7254 ."
  ],
  "abstract_text": [
    "<S> the concept of _ promise problems _ was introduced and started to be systematically explored by even , selman , yacobi , goldreich , and other scholars . </S>",
    "<S> it has been argued that promise problems should be seen as partial _ decision problems _ and as such that they are more fundamental than decision problems and formal languages that used to be considered as the basic ones for complexity theory . </S>",
    "<S> the main purpose of this paper is to explore the promise problems accepted by classical , quantum and also semi - quantum finite automata . </S>",
    "<S> more specifically , we first introduce two acceptance modes of promise problems , _ recognizability _ and _ solvability _ , and explore their basic properties . afterwards , we show several results concerning descriptional complexity on promise problems . </S>",
    "<S> in particular , we prove : ( 1 ) there is a promise problem that can be recognized exactly by _ measure - once one - way quantum finite automata _ ( mo-1qfa ) , but no _ deterministic finite automata _ ( dfa ) can recognize it ; ( 2 ) there is a promise problem that can be solved with error probability @xmath0 by _ one - way finite automaton with quantum and classical states _ ( 1qcfa ) , but no _ one - way probability finite automaton _ ( pfa ) can solve it with error probability @xmath0 ; and especially , ( 3 ) there are promise problems @xmath1 with prime @xmath2 that can be solved _ with any error probability _ by mo-1qfa with only two quantum basis states , but they can not be solved _ </S>",
    "<S> exactly _ by any mo-1qfa with two quantum basis states ; in contrast , the minimal pfa solving @xmath1 _ with any error probability _ </S>",
    "<S> ( usually smaller than @xmath3 ) has @xmath2 states . </S>",
    "<S> finally , we mention a number of problems related to promise for further study .    </S>",
    "<S> promise problems , quantum computing , finite automata , quantum finite automata , recognizability , solvability </S>"
  ]
}