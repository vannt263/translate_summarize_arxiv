{
  "article_text": [
    "there has recently been an increased interest in the physics literature in methods that allow to automatically compute the numerical values of the derivatives of a function along with the function itself @xcite .",
    "since the need to do this arises in different contexts , different methods have been proposed and implemented . in many cases , such as in differential equation solvers ,",
    "only the first and possibly second derivatives are needed , a task for which a number of tools exist @xcite .",
    "there are , however , some cases , such as the expansion of feynman diagrams in external momenta or particle masses and other series expansions in quantum field theory , where at least some of the higher - order derivatives up to some relatively large order are needed , and few tools to deal with this situation were available so far .",
    "it is thus the purpose of this paper to present taylur , a fortran  95 module that addresses this need by providing a mechanism to compute the values of the higher derivatives of a function along with the function itself .    in the field of automatic differentiation @xcite ,",
    "two different approaches are generally distinguished : source transformation methods , which take an existing code for the computation of a function as their input and produce a code that computes its derivatives as output , and operator overloading methods , which make use of operator overloading and other object - oriented features of a language to encapsulate the task of computing derivatives within an object that has the same `` user interface '' as a real or complex number .",
    "while source transformation has the advantage of producing faster code , since it can take full advantage of a compiler s optimising features , operator overloading provides for an easier and more convenient user interface , in particular since no additional step is inserted into the compile - link - run cycle .",
    "taylur uses an operator overloading strategy to provide a new type taylor that acts like a complex ( or real ) number while containing the values of the derivatives of the function it represents along with that function s value .    in order to emulate the behaviour of intrinsic numerical data types as closely as possible",
    ", taylur makes significant use of the fortran  95 features for pure and elemental functions .",
    "thus very few , if any , changes to existing user code ( apart from declaring objects to be of type taylor ) will be necessary .",
    "the intended area of application of taylur is fairly orthogonal to that of other , existing systems like adf95 @xcite or auto_deriv @xcite : where the latter are aimed primarily at use in implicit differential equation solvers , where only first and possibly second order derivatives are needed , but efficient handling of large numbers of variables with potentially sparse jacobian and hessian matrices is a primary goal , taylur aims at cases such as feynman diagram differentiation , where the number of variables is usually limited , but an expansion to higher orders is needed .",
    "taylur performs well with large numbers of variables , but does not exploit any existing sparsity structure of the derivatives .",
    "there are some areas of application , such as optimization problems or higher - dimensional interpolation , which require mixed higher - order derivatives , something which neither taylur nor adf95 or auto_deriv provide .    where it is acceptable to link a fortran  95 program against code written in c++ , the c++ package adol - c @xcite is available .",
    "adol - c uses a very different approach internally than taylur , employing a sophisticated storage allocation system to maintain a data structure that allows the computation of higher derivative tensors , including mixed derivatives , for functions written in c / c++ .",
    "the advantage of computing mixed higher - order derivatives which adol - c has over taylur is bought at the expense of numerous memory accesses , which significantly slow down the code at runtime , although on the other hand it allows for better scaling behaviour in the taylor expansion order .",
    "the beam dynamics simulation and analysis code cosy infinity @xcite and the general - purpose numerical harwell subroutine library @xcite also contain arbitrary - order automatic differentiation code that computes mixed higher - order derivatives and can be linked against fortran  95 programs .",
    "we believe that the straightforward interface and relatively small code size ( about a quarter the size of adol - c ) of taylur , as well as the fact that it is coded entirely in fortran  95 , offer a fair balance for the lack of mixed higher - order derivatives , and make it very competitive with these larger libraries for those applications where mixed higher - order derivatives are not required .    it should also be noted that the existing packages for automatic differentiation using operator overloading have so far been restricted to use real - valued functions only .",
    "taylur overcomes this limitation and provides a complex - valued function type , which is commonly needed e.g. in the evaluation of feynman diagrams in high - energy physics .",
    "in order to employ the taylur module , the user must include a use statement for taylur at the beginning of his program .",
    "in addition to this , any variable for which the computation of derivatives is desired , as well as all variables and user functions which feed into its computation over the course of the user program , must be declared to be of type(taylor ) .",
    "independent variables are created by the function independent , which takes the index of the independent variable and its value as arguments , as in the following example :    ....     type(taylor ) : : x , y , f       x = independent(1,0.3 )     y = independent(2,2 )     f = y**2 -3*x ....    which declares x and y to be the independent variables with index 1 and 2 , respectively , and assigns them the values 0.3 and 2 , before computing the function f from them .",
    "the function value of f will be 3.1 , its first derivative with respect to ( w.r.t . )",
    "the first independent variable will be -3 . with all higher derivatives w.r.t .",
    "this variable vanishing , and its first derivative w.r.t .",
    "the second independent variable will be 4 .",
    ", the second derivative 2 . , all higher derivatives w.r.t .",
    "this variable vanish again , as do any derivatives w.r.t .",
    "other variables .    as a slightly more realistic example",
    "let us look at the computation of the wavefunction renormalisation constant in euclidean scalar @xmath0 theory .",
    "at the one - loop level , we need to compute @xmath1 , where @xmath2 is given by the bubble diagram .",
    "a way to code this might be given by    ....",
    "function bubble_diagram(k , p_,m _ )      use taylur      complex : : p_(4),bubble_diagram    real : : k(4),m _      type(taylor ) : : p(4),m , feynman    integer : : mu      do mu=1,4      p(mu ) = independent(mu , p_(mu ) )    enddo    m = independent(5,m",
    "_ )      k(4 ) = k(4 ) - 0.5*p(4 )   ! shift k_4",
    "countour    feynman = 1/(sum(k**2)+m**2)/(sum((k+p)**2)+m**2 )      bubble_diagram = derivative(feynman,4,2)/(2*pi)**4      end function bubble_diagram ....    this routine might then be passed to an integration routine which expects a function with the given interface and performs an appropriately regularised integration .",
    "while in this case the derivative can be easily computed analytically , this is no longer the case in e.g. lattice perturbation theory , where ( especially for improved actions @xcite ) the feynman rules quickly become too complex to allow analytical calculations to be performed easily .",
    "it should also be noted that changing just the two last arguments of the derivative function call will allow to compute the mass dependence of the mass renormalisation . with an appropriately implemented integration method ,",
    "it is even possible to numerically integrate a taylor object - valued function for a taylor object - valued result .",
    "the taylor type is defined internally as    .... type taylor   complex(kind = dc_kind ) : : drv(1:n_taylor_vars,0:max_taylor_order ) end type taylor ....    where dc_kind is defined as the kind parameter of a double precision complex .",
    "the field drv(i , n ) holds the n - th derivative w.r.t .",
    "the i - th independent variable , where any zeroth derivative is defined as equal to the function value .",
    "the maximal order of the taylor expansion is determined by the module parameter max_taylor_order , the total number of variables by the module parameter n_taylor_vars . where needed ,",
    "these parameters can be changed to provide for higher orders or more variables , or to speed up code by reducing the numbers .    where a specific portion of a program does not need the full taylor expansion up to order max_taylor_order , it is possible to set the module variable taylor_order to a lower value in order to compute only derivatives up to that order .",
    "independent variables are created by the function independent , which takes the index of the independent variable and its value as arguments .",
    "it is the user s responsibility to make sure that no two taylor objects are declared to share the same independent variable index , since it is not possible for the taylur module to keep track of this .",
    "there are a number of user - defined functions for accessing the value and derivatives of the function encoded by a taylor object .",
    "value(t ) returns the value of the taylor object t , whereas derivative(t , i , n ) gives the n - th partial derivative of the taylor object t w.r.t . the i - th independent variable .",
    "the expansion @xmath3 w.r.t . can be obtained as an array by using expansion(t , i ) .",
    "it is also possible to obtain the vector of first partial derivatives as an array by using the function gradient(t ) , and the laplacian as laplacian(t ) .",
    "the assignment operator = has been overloaded to allow assignment of intrinsic types to taylor objects and vice versa .",
    "it should be noted that , in accordance with the standard behaviour of fortran  95 intrinsic types , assignment to a real will result in the real part of the right - hand side being taken implictly .",
    "all standard fortran  95 arithmetic operators ( + , - , , / , * ) have been overloaded to act on taylor objects .",
    "numbers of both double and default precision real and complex type as well as integers can be combined with taylor objects by addition , subtraction , multiplication and division in any order , and taylor objects can be raised to integer powers .",
    "all these operations are defined with the elemental attribute and therefore can be used with arrays of taylor objects using the usual fortran  95 array syntax .",
    "all comparison operators have been overloaded to allow comparison of taylor objects with both double and default precision reals and integers as well as with complex numbers , where this makes sense .",
    "the comparison operators compare the value of the taylor objects only , neglecting their derivatives .",
    "in addition to these intrinsic operations , two user - defined comparison operators .ident . and .nident .",
    "exist , which check for identity and non - identity of the complete taylor series , as opposed to the comparison of values only carried out by the intrinsic operators = = and /=. all comparison operators are elemental .",
    "all fortran  95 intrinsics which make sense on a taylor - expanded quantity and which can be fully implemented as user - defined functions , have been overloaded to work correctly on taylor objects .",
    "specifically , the functions abs , acos , aimag , asin , atan , atan2 , conjg , cos , cosh , dim , exp , log , log10 , mod , modulo , sign , sin , sinh , sqrt , tan , tanh accept taylor objects as their arguments , and matmul and dot_product accept arrays of taylor objects as their arguments .    in the case of the functions",
    "real and aimag , a conscious decision was made to have them behave differently from their intrinsic counterparts in that they do _ not _ convert to real type , but return an result of type taylor ( with the real / imaginary part of each derivative taken ) instead .",
    "this was done so that the mathematical functions @xmath4 ( real part ) and @xmath5 ( imaginary part ) are available on taylor objects , and since assignment of a taylor object to a real variable will convert it to a real anyway , no functionality is lost . in the case where it is necessary to assign the value of one taylor object to another taylor object as a constant , or where the value of a taylor object has to be passed to an external function that accepts only a complex or real argument , the user - defined value function may be used instead .",
    "a pair of user - defined functions realvalue and imagvalue , which return the real and imaginary part of the value of a taylor object , respectively , are also provided .",
    "the following fortran  95 intrinsics can not be fully emulated by user - defined functions , since they return results of different kinds depending on the value of an argument , which is impossible to achieve with a function written in fortran  95 : ai nt , anint , ceiling , floor , int , nint , real .",
    "these functions accept taylor objects as their arguments only when the optional kind argument is absent .",
    "the fortran  95 intrinsics max and min that accept arbitrary variable numbers of arguments ( which a function written in fortran  95 can not emulate ) accept taylor objects as their arguments in their two - argument form only .",
    "the fortran  95 array reduction intrinsics maxloc , maxval , minloc , minval , product and sum accept arguments of variable rank along with an optional argument dim to denote the dimension along which reduction is to be performed .",
    "this behaviour , too , can not be emulated by a fortran  95 function ; these functions accept taylor object arrays of rank one only .",
    "otherwise they act as their intrinsic counterparts , including the existence of the optional mask argument .",
    "the taylor functions are elemental where their intrinsic counterparts are .",
    "those functions whose intrinsic counterparts are restricted to real or integer arguments ( acos , ai nt , anint , asin , atan , atan2 , ceiling , dim , floor , int , log10 , max , maxloc , maxval , min , minloc , minval , mod , modulo , nint , sign ) will take the real part of a taylor object first and should be applied to real - valued taylor objects only , just like their intrinsic counterparts would be applied to real numbers only . depending on the value of the variable real_args_warn , which defaults to .true . , these functions will warn about a complex argument ( with imaginary part greater than real_args_tol ) being passed by returning a nan ( not a number ) value , or @xmath6huge in the case of integer functions ; this behaviour can be turned off where desired by setting real_args_warn to .false . in the user s code .",
    "on the other hand , cosh , sinh , tan and tanh work correctly with complex - valued taylor objects , although their intrinsic counterparts are ( somewhat arbitrarily ) restricted to real arguments .",
    "it should be noted that , while taylur accepts complex - valued independent variables , the conjg function assumes that all independent variables are real .",
    "in particular , no attempt is made to implement any features of wirtinger calculus .    in those cases where the derivative of a function becomes undefined at certain points ( as for abs , ai nt , anint , max , min , mod , modulo and sqrt ) , while the value is well defined , the derivative fields will be filled with nan ( not a number ) values by assigning them to be 0./0 .",
    "depending on the compiler and system settings , this may cause the program to stop .",
    "examples of the usage of all routines can be found in the test program distributed with taylur .",
    "the derivatives of products of taylor objects are computed using leibniz s rule @xmath7 leibniz s rule is also employed to compute derivatives of quotients and square roots by using the equalities @xmath8 @xmath9 and solving for the @xmath10-the derivative of @xmath11 or @xmath12 , respectively .",
    "taylur differs significantly from similar tools such as auto_deriv @xcite or adf95 @xcite that use hard - coded chain rule expressions for the derivatives of intrinsics .",
    "such an approach is obviously unsuitable for the arbitrary - order case .",
    "taylur instead uses fa di bruno s formula @xcite for the @xmath10-th derivative of a composite function : @xmath13 where @xmath14 , and the sum runs over all integer vectors @xmath15 that satisfy the conditions @xmath16 and @xmath17 .",
    "a subroutine fdb_generate that generates and stores the needed vectors @xmath15 along with the precomputed weight of each term @xmath18 is called from within the independent function .",
    "those functions requiring the computation of derivatives via fa di bruno s formula call another function fdb which returns these precomputed values . this separation allows to compute the vectors only once and store them for better performance , while maintaining the elemental status of the overloaded intrinsics ( which requires them to be pure , prohibiting any side - effects such as manipulating external data or save variables )",
    ".      the runtime memory and cpu requirements of the taylur package are determined by the n_taylor_vars , max_taylor_order parameters and , to some extent , the taylor_order variable .",
    "a taylor object requires n_taylor_vars@xmath19 max_taylor_order times the memory that a complex variable of kind dc_kind requires , and this size is fixed at compilation time .",
    "the time taken to perform operations on taylor objects depends on the operation , the compiled value of n_taylor_vars and the run - time value of taylor_order .",
    "all operations scale approximately linearly in the number of variables , although this partially depends on the cpu and compiler , since the dependence on n_taylor_vars is through array assignments alone .",
    "the run - time of linear operations , such as assignment , addition , multiplication with a constant or comparison for identity , as well as some of the simpler mathematical functions like mod , will scale approximately linearly with max_taylor_order ( again through array assignment ) , while being independent of taylor_order .",
    "multiplication and division of taylor objects , as well as the sqrt function , will have a run - time scaling quadratically with taylor_order , while the run - time of the exp function , logarithms , trigonometric , hyperbolic and inverse trigonometric functions will scale approximately exponentially with taylor_order , due to the increase in the number of terms combining different lower - order derivatives of their arguments that need to be combined .",
    "besides the limits on the number of variables and maximal expansion order that memory and cpu time constraints may impose , there are limits on the expansion order that may be achieved due to the finite precision of floating - point operations taken in conjunction with the large number of potentially large terms that need to be added to obtain the value of high - order derivatives .",
    "this becomes a problem in particular when functions whose @xmath10-th derivatives are large are combined to form a function with a small @xmath10-th derivative , or when contributions from different orders combine in a product of quotient to yield a small result for some higher - order derivative of the result . in these cases , the resulting value for the derivative can be many orders of magnitude less accurate than the value obtained for the function value or lower - order derivatives .    in order to avoid a potential total loss of precision",
    ", users interested in high - order derivatives should monitor the derivatives of intermediate results and compare them to the derivatives of the final answer . if the derivatives of the final result become insignificant when compared to those of the intermediate steps that entered its computation , the final result is likely to be dominated by numerical noise .",
    "apart from any language - imposed limitations in the emulation of the behaviour of certain fortran  95 intrinsics mentioned in section [ subs : usage ] , taylur is limited in that it does not attempt to compute any mixed second or higher - order derivatives .",
    "this limitation is imposed for a number of reasons : firstly , the memory and time needed for the storage and computation of mixed higher - order derivatives gets out of hand very quickly as one goes up to higher orders .",
    "secondly , the computation of mixed derivatives of arbitrary order involves a programming effort that is rather disproportionate to the use that is likely to be made of them in most applications .",
    "we would also like to repeat that taylur allows for complex - valued functions and variables , while those functions that are only defined for real arguments ( in particular those that refer to ordering relations ) will silently take the real parts of their arguments .",
    "it also bears repeating that the conjg function assumes that all independent variables are real - valued , and that no attempt is made to implement wirtinger calculus .",
    "the taylur package has been tested on a range of computer systems ( linux/ intel , linux / alpha and sunos / sparc ) with a number of different compilers ( intel , compaq and sun ) .",
    "the test suite used to test taylur for potential bugs and errors consists of both testing the derivatives computed for a number of functions with known derivative expansions against their analytically determined values and of various sanity checks such as that f / f is equal to one with all derivatives vanishing to within a reasonable accuracy .",
    "taylur has evolved out of similar , more restricted codes used by the author in the automatic differentiation of feynman diagrams in perturbative lattice qcd @xcite and chiral perturbation theory on the lattice .",
    "these codes had been tested and used in practice and have been found to work correctly , giving results in agreement with analytical results whenever those were available .",
    "while taylur contains some significant extensions compared to these codes , in particular the intrinsic functions whose derivative expansion is based of fa di bruno s formula , these extensions have been well tested and found to be stable .",
    "+   +   +   +    as an example , let us consider the function @xmath20 whose derivative expansion involves recourse to fa di bruno s formula twice at each order , as well as usage of the expansion of the square root , power and multiplicative inverse functions .",
    "[ fig : one ] shows plots of the analytical form ( as given by a computer algebra program ) and numerical evaluations using taylur of @xmath21 and it first three derivatives .",
    "excellent agreement can be seen , with the largest relative errors of order @xmath22 .    as a further test",
    ", a comparison was run between taylur and adol - c .",
    "the example powexam included with adol - c , which computes the taylor series coefficients for the monomial @xmath23 , was used as a test case .",
    "complete agreement between taylur and adol - c was found .",
    "for low orders of @xmath24 , taylur was about 2 - 3 times faster than adol - c , whereas for larger orders , adol - c began to take over quickly . as a further comparison point ,",
    "the speelpenning example program , which computes the function value and gradient of the product @xmath25 , was used .",
    "again , agreement ( to within floating point accuracy ) was found between taylur and adol - c . in this case ,",
    "taylur was about 5 - 10 times faster than adol - c for all dimensions in the range 2@xmath26100 tested .",
    "these timings suggest that taylur is very competitive for relatively low taylor expansion orders ( less than about 10 ) , but falls behind for higher orders .",
    "the taylur versions were the most direct possible translations of the adol - c examples , and the timing tests were run on a @xmath27 ghz intel pentium 4 using the intel fortran compiler and gcc to compile the taylur and adol - c versions , respectively .",
    "taylur provides a much needed high - order automatic differentiation package for fortran  95 that is particularly useful for expansion of feynman diagrams in external momenta or particle masses , but is expected to be applicable to other fields of computational physics as well .",
    "the author acknowledges helpful discussions with a.g .",
    "hart and r.k .",
    "this work was supported in part by the natural sciences and engineering research council of canada and by the government of saskatchewan .",
    "to verify that the taylur package has been installed and compiled correctly , the user should build the included verification program by performing a make verify in the installation directory .",
    "when run , ./verify should produce the following output :    ....      taylor eval .       analytic eval .",
    "error      0.333333333333     0.333333333333       0.000000000000e+00     -0.888888888889    -0.888888888889       0.000000000000e+00      1.185185185185     1.185185185185       0.000000000000e+00     -2.370370370370    -2.370370370370       0.000000000000e+00      6.320987654321     6.320987654321       0.000000000000e+00    -21.069958847737   -21.069958847737       0.355271367880e-14",
    "84.279835390946    84.279835390947       0.142108547152e-13 ....    the less significant digits and errors may depend on the specific floating - point implementation of the system used , but the two columns headed taylor eval . and analytic eval .",
    "should agree to the accuracy shown ( in double precision arithmetic ) .",
    "any other output , in particular complaints about failed tests , is indicative of a compilation error or a problem with the floating - point system used , such as a lack of precision in the results of some of the intrinsic functions ."
  ],
  "abstract_text": [
    "<S> we present taylur , a fortran  95 module to automatically compute the numerical values of a complex - valued function s derivatives with respect to several variables up to an arbitrary order in each variable , but excluding mixed derivatives . </S>",
    "<S> arithmetic operators and fortran intrinsics are overloaded to act correctly on objects of a defined type taylor , which encodes a function along with its first few derivatives with respect to the user - defined independent variables . </S>",
    "<S> derivatives of products and composite functions are computed using leibniz s rule and fa di bruno s formula . </S>",
    "<S> taylur makes heavy use of operator overloading and other fortran  95 features such as elemental functions .    </S>",
    "<S> automatic differentiation , higher derivatives , fortran  95 02.60.jh , 02.30.mv 41 - 04 , 41a58 , 65d25    * program summary *    _ manuscript title : _ taylur , an arbitrary - order diagonal automatic differentiation package for fortran 95 </S>",
    "<S> + _ authors : _ g.m . </S>",
    "<S> von hippel + _ program title : _ taylur + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ </S>",
    "<S> none + _ programming language : _ fortran 95 + _ computer : _ any computer with a conforming fortran 95 compiler + _ operating system : _ any system with a conforming fortran 95 compiler + _ keywords : _ automatic differentiation , higher derivatives , fortran 95 + _ pacs : _ 02.60.jh , 02.30.mv + _ classification : _ 4.12 other numerical methods , 4.14 utility + _ nature of problem : _ </S>",
    "<S> + problems that require potentially high orders of derivatives with respect to some variables , such as e.g. expansions of feynman diagrams in particle masses in perturbative quantum field theory , and which can not be treated using existing fortran modules for automatic differentiation [ 1 - 2 ] . </S>",
    "<S> +   + _ solution method : _ </S>",
    "<S> + arithmetic operators and fortran intrinsics are overloaded to act correctly on objects of a defined type taylor , which encodes a function along with its first few derivatives with respect to the user - defined independent variables . </S>",
    "<S> derivatives of products and composite functions are computed using leibniz s rule and fa di bruno s formula . </S>",
    "<S> +   + _ restrictions : _ + memory and cpu time constraints may restrict the number of variables and taylor expansion order that can be achieved . </S>",
    "<S> loss of numerical accuracy due to cancellation may become an issue at very high orders . </S>",
    "<S> +   + _ unusual features : _ + no mixed higher - order derivatives are computed . </S>",
    "<S> the complex conjugation operation assumes all independent variables to be real . +   + _ running time : _ + the running time of taylur operations depends linearly on the number of variables . </S>",
    "<S> its dependence on the taylor expansion order varies from linear ( for linear operations ) through quadratic ( for multiplication ) to exponential ( for elementary function calls ) . </S>",
    "<S> +   + _ references : _    c.  w. straka , adf95 : tool for automatic differentiation of a fortran code designed for large numbers of independent variables , comput .  </S>",
    "<S> phys .  </S>",
    "<S> commun . </S>",
    "<S> * 168 * ( 2005 ) 123 - 139 [ arxiv : cs.ms/0503014 ] .    </S>",
    "<S> s. stamatiadis , r. prosmiti , s.  c. farantos , auto_deriv : tool for automatic differentiation of a fortran code , comput .  </S>",
    "<S> .  commun . </S>",
    "<S> * 127 * ( 2000 ) 343 - 355 . </S>"
  ]
}