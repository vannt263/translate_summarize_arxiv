{
  "article_text": [
    "detecting loops in data networks usually involves counting down a hop limit or caching data at each hop to detect a cycle . using",
    "a hop limit means that the origin of a packet must know the maximum distance a packet could travel without loops .",
    "it also means a loop is not detected until it travels that maximum distance , even if that is many loops . caching a packet signature at each hop , such as a hash or nonce ,",
    "could require large amounts of memory at every hop because that cached information must persist for as long as a loop could forward packets .",
    "this paper presents a new distributed loop detection mechanism based on a tortoise and hare algorithm that can quickly detect loops without caching per - packet data at each hop with a modest amount of additional state in each packet .",
    "one class of algorithms for detecting loops in a series are based on the tortoise and hare construction , attributed to floyd by knuth  @xcite .",
    "the core idea is that the tortoise moves one - by - one through a series , denoted as @xmath0 , and the hare moves twice as fast , denoted as @xmath1 . if there is a cycle , eventually @xmath2 , where hop @xmath3 , modulo the cycle length , is the same item as @xmath4 . at each step of the algorithm , @xmath5 and @xmath6 .",
    "brent s algorithm  @xcite finds cycles like floyd s algorithm , however it requires less memory than floyd s algorithm to compute the `` next '' operation .",
    "brent s algorithm compares @xmath7 with all @xmath8 in the open interval @xmath9 .",
    "therefore , the same @xmath7 is used at each iteration until there s a single update .",
    "@xmath10 , @xmath11 , until the next power of two when @xmath12 .",
    "this formation keeps the state update using `` next '' proceeding in - step with the algorithm iteration , so a packet does not need to carry any memory with it beyond @xmath13 .",
    "section  [ sec : brent ] reviews brent s centralized algorithm .",
    "section  [ sec : distributed ] presents our distributed version of the algorithm for use in a packet network .",
    "algorithm  [ alg : brent ] shows brent s algorithm for the case where @xmath14 and @xmath15 , which he calls the common case , based on  @xcite .",
    "we have used more descriptive names than @xmath16 .",
    "mapping brent s variables to more descriptive names , we use @xmath17 , @xmath18 , @xmath19 , and @xmath20 .    in this formulation ,",
    "the algorithm tracks four variables : @xmath21 , @xmath13 , @xmath22 , and @xmath23 . for a centralized algorithm , tracking",
    "this information is not a burden , but in a distributed algorithm we wish to minimize the message sizes to reduce overhead . in our distributed version of the algorithm , in section  [ sec : distributed ]",
    ", we reduce the necessary message size to only @xmath21 and @xmath23 .",
    "@xmath24 @xmath25 @xmath26 @xmath27 @xmath28 @xmath29 @xmath30 @xmath31 @xmath32 @xmath33 @xmath31 @xmath33 true false",
    "our use of brent s algorithm is shown in alg  [ alg : init ] and alg .",
    "[ alg : receive ] . when a node creates a new packet , it initializes the @xmath21 variable to its node identifier ( nodeid ) .",
    "the node identifier could be the hash a a system s public key or an administratively assigned unique identifier .",
    "when a node receives a packet , it first increments the hop count .",
    "if the packet s @xmath21 is equal to the current node s @xmath34 , then there is a loop ( the algorithm returns true ) .",
    "otherwise , if the hop count is equal to the @xmath22 , then the packet has traveled a power of 2 hops , so the algorithm updates the @xmath21 value .",
    "the size of @xmath21 must be large enough that there is a very low probability of duplicates along a given path .",
    "either the size must be so large that there s a vanishingly small probability that there are no duplicates or we should ensure that a retransmission will not have the same failure mode .",
    "[ fig : object ] uses the birthday paradox to calculate the probability that two or more routers on a path of path length have the same nodeid assuming the ids are picked randomly .",
    "for example , for a 32-bit nodeid , there s about a 1% chance of collision for a path of 8192 hops . for paths of practical maximum lengths , such as at most 256 to 512 hops , node ids of 48 to 64 bits",
    "should be sufficient .",
    "if we wish to make sure that a retransmission breaks a path with duplicate node ids , we can need to use a virtual node i d .",
    "one could calculate the virtual node i d as @xmath40 , where the @xmath41 is a large number , such as the sha-256 hash of a system s public key , and the hash of the packet includes a short nonce per retransmission and does not include the loop - prevention fields ( tortoise , power , hops ) .",
    "this method also better preservers anonymity because the @xmath21 identity is scrambled , potentially with a cryptographic - grade hash ."
  ],
  "abstract_text": [
    "<S> detecting loops in data networks usually involves counting down a hop limit or caching data at each hop to detect a cycle . using </S>",
    "<S> a hop limit means that the origin of a packet must know the maximum distance a packet could travel without loops . </S>",
    "<S> it also means a loop is not detected until it travels that maximum distance , even if that is many loops . caching a packet signature at each hop , such as a hash or nonce , </S>",
    "<S> could require large amounts of memory at every hop because that cached information must persist for as long as a loop could forward packets . </S>",
    "<S> this paper presents a new distributed loop detection mechanism based on a tortoise and hare algorithm that can quickly detect loops without caching per - packet data at each hop with a modest amount of additional state in each packet .    </S>",
    "<S> mosko : aesop fable of network loops </S>"
  ]
}