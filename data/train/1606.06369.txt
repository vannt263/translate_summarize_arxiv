{
  "article_text": [
    "malware detection has evolved as one of the challenging problems in the field of cyber - security as the attackers continuously enhance the sophistication of malware to evade novel detection techniques .",
    "malware for various platforms such as desktop and mobile devices is growing at an alarming rate .",
    "for instance , kaspersky reports @xcite detecting 4 million malware infections in 2015 which is a 216% increase over 2014 .",
    "this volume and growth rate clearly highlights an imperative need for automated malware detection solutions .",
    "+ to perform automated malware detection , security analysts resort to program analysis and machine learning ( ml ) techniques . typically , this process involves extracting semantic features from suitable representations of programs ( e.g. , assembly code , call graphs ) and detecting malicious code or behavior patterns using ml classifiers @xcite .",
    "+ a major reason for such tremendous growth rate in malware is the production of _ malware variants_. typically , the attackers produce large number of _ variants _ of the same malware by resorting to techniques such as variable renaming and junk code insertion .",
    "these variants perform same malicious functionality , with apparently different syntax , thus evading syntax - based detectors",
    ". however , higher level semantic representations such as call graphs , control- and data - flow graphs , control- , data- and program - dependency graphs mostly stay similar even when the code is considerably altered . in this work ,",
    "we use a common term , _ program representation graph _",
    "( prg ) to refer to any of these aforementioned graphs .",
    "as prgs are resilient against variants , many works in the past have used them to perform malware detection .",
    "in essence , such works cast malware detection as a _ graph classification problem _ and apply existing graph mining and classification techniques . some methods such as @xcite note that ml classifiers are readily applicable on data represented as vectors and attempt to encode prgs as feature vectors .",
    "typically , these techniques face two challenges :    * * ( c1 ) expressiveness . * prgs are complex and expressive data structures that characterize topological relationships among program entities . representing them as vectors",
    "is a non - trivial task . in many cases vectorial representations of prgs",
    "fail to capture all the vital information .",
    "for instance , appcontext @xcite , a well - known android malware detection approach represents apps as prgs and ends up capturing features from individual nodes without their topological neighbourhood information . with such loss of expressiveness , attacks that span across multiple prg nodes could not be effectively detected . * * ( c2 ) efficiency . *",
    "the scale of malware detection problem is such that we have millions of samples already and thousands streaming in every day .",
    "many classic graph mining based approaches ( e.g. , ) are np hard and have severe scalability issues , making them impractical for real - world malware detection @xcite .        * graph kernels .",
    "* one of the increasingly popular approaches in ml for graph - structured data is the use of graph kernels .",
    "recently , efficient and expressive graph kernels such as @xcite have been proposed and widely adopted in many application areas ( e.g , bio- and chemo - informatics @xcite ) .",
    "some of them support explicit feature vector representations of graphs ( e.g , @xcite ) .",
    "thus both the aforementioned challenges c1 and c2 are effectively addressed by these graph kernels .",
    "therefore , it just suffices to use a graph kernel together with a kernelized ml classifier ( e.g. , svm ) and we have a scalable , effective and ready - to - use malware detector .",
    "recently , three approaches @xcite , @xcite and @xcite ,  have successfully demonstrated using these general purpose graph kernels for malware detection .",
    "+ * research gap .",
    "* however , a major problem in using these general purpose graph kernels on prgs is that , they are not designed to take domain - specific observations into account .",
    "for instance , recent research on malware analysis has revealed that besides capturing neighbourhood ( i.e. , structural ) information from prgs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods @xcite ( explained in detail in  [",
    "sec : bgm ] ) .",
    "many existing graph kernels such as @xcite and @xcite can capture and compare structural information from prgs effectively .",
    "however , they are not designed to capture the reachability context , as it is a strong domain - specific requirement and hence fail to do so . to address this",
    ", we develop a novel graph kernel which is capable of capturing both the aforementioned types of information . + for similar domain - specific reasons , researchers from other fields such as computer vision @xcite , bio- and chemo - informatics @xcite have developed a number of kernels that specifically suit their applications . despite graphs being natural representations of programs and amenable for various activities ,",
    "the program analysis research community has not devoted significant attention to development of domain - specific graph kernels .",
    "we take the first step towards this , by developing a kernel on prgs which specifically suits our task of malware detection . +",
    "* our approach . * to improve the accuracy of malware detection process",
    ", we propose a method to enrich the feature space of a graph kernel that inherently captures structural information with contextual information .",
    "we apply this feature - enrichment idea on a state - of - the - art graph kernel , namely , weisfeiler - lehman kernel ( wlk ) @xcite to obtain the contextual weisfeiler - lehman kernel ( cwlk ) . specifically , cwlk associates to each sub - structure feature of wlk a piece of information about the context under which the sub - structure is reachable in the course of execution of the program . a sub - structure appearing in two different prgs",
    "will match only if it is reachable under the same context in both prgs .",
    "we show that for the malware detection problem , cwlk is more expressive and hence more accurate than wlk and other state - of - the - art kernels while maintaining comparable efficiency .",
    "+ * experiments . * through our large - scale experiments with more than 50,000 android apps",
    ", we demonstrate that cwlk outperforms two state - of - the - art graph kernels ( including wlk ) and three malware detection techniques by more than 5.27% and 4.87% f - measure , respectively , while maintaining high efficiency .",
    "this , in essence shows the significance of incorporating the contextual information along with structural information in the graph kernel while performing malware detection . +",
    "* contributions . *",
    "the paper makes the following contributions : + ( 1 ) we develop a graph kernel that captures both structural and contextual information from prgs to perform accurate and scalable malware detection (  [ sec : cwlk ] ) . to the best of our knowledge ,",
    "this is the first graph kernel specifically addressing a problem from the field of program analysis .",
    "+ ( 2 ) through large - scale experiments and comparative analysis , we show that the proposed kernel outperforms two state - of - the - art graph kernels and three malware detection solutions in terms of accuracy , while maintaining high efficiency (  [ sec : eval ] ) .",
    "+ ( 3 ) we make an efficient implementation of the proposed kernel ( along with the dataset information ) publicly available .",
    "in this section , we motivate the design of our kernel by describing why considering just the structural information from prgs is insufficient to determine the maliciousness of a sample and how supplementing it with contextual information helps to increase detection accuracy . to this end",
    "we use a real - world android malware from the _ geinimi _ family which steals users private information .",
    "we contrast its behavior with that of a well - known benign app , _ yahoo weather_. + * _ geinimi _ s execution . *",
    "the app is launched through a background event such as receiving a sms or call .",
    "once launched , it reads the user s personal information such as geographic location and contacts and leaks the same to a remote server .",
    "the ( simplified ) malicious code portion pertaining to the location information leak is shown in fig .",
    "[ fig : me ] ( a ) .",
    "the method _",
    "leak_location _ reads the geographic location through getlatitude and getlongitude application programming interfaces ( apis ) .",
    "subsequently , it calls _",
    "leak_info_to_url _ method to leak the location details ( through dataoutputstream.writebytes ) to a specific server .",
    "the data dependency graph ( ddg ) corresponding to the code snippet is shown in fig .",
    "[ fig : me ] ( b ) .",
    "the nodes in ddg are labeled with the sensitive apis that they invoke .",
    "+ * _ yahoo weather _ s execution .",
    "* on the other hand , _ yahoo weather _ could be launched only by user s interaction with the device ( e.g. , by clicking the app s icon on the dash board ) .",
    "the app then reads the user s location and sends the same to its weather server to retrieve location - specific weather predictions .",
    "hence , ddg portions of _ yahoo weather _ is same as that of _",
    "geinimi_. + * contextual information .",
    "* from the explanations above , it is clear that both the apps leak the same information in the same fashion .",
    "however , what makes _ geinimi _ malicious is the fact that its leak happens without the user s consent . in other words , unlike _ yahoo weather _ , _ geinimi _ leaks private information through an event which is not triggered by user s interaction .",
    "we refer to this as a leak happening in _ user - unaware _ context . on the same lines",
    ", we refer to _ yahoo weather s _ leak as happening in _ user - aware _ context . + as explained in @xcite and @xcite , in the case of android apps , one could determine whether a prg node is reachable under _ user - aware _ or _ user - unaware _",
    "context by examining its entry point nodes . following this procedure",
    "we add the context as an attribute to every ddg node .",
    "this context annotated ddg of _ geinimi _ and _ yahoo weather _ are shown in fig .",
    "[ fig : me ] ( c ) and ( d ) , respectively . +",
    "* requirements for effective detection . * from the aforementioned example the two key requirements that makes a malware detection process effective can be identified : + * ( r1 ) _ capturing structural information . _ * since malicious behaviors often span across multiple nodes in prgs , just considering individual nodes ( and their attributes ) in isolation is not enough . capturing the structural ( i.e. , neighborhood ) information from prgs is of paramount importance . + * ( r2 ) _ capturing contextual information . _ * considering just the structural information without the context is not enough to determine whether a sensitive behavior is triggered with or without user s knowledge .",
    "for instance , if structural information alone is considered , the features of both _ geinimi _ and _ yahoo weather _ apps become identical , thus making the latter a false positive . hence , it is important for the detection process to capture the contextual information as well to make the detection process more accurate .",
    "+ many existing graph kernels could address the first requirement well .",
    "however , the second requirement which is more domain - specific makes the problem particularly challenging . to the best of our knowledge ,",
    "none of the existing graph kernels support capturing this reachability context information along with structural information .",
    "hence , this gives us a clear motivation to develop a new kernel that specifically addresses our two - fold requirement .",
    "the formal definitions and notations that will be used throughout the paper are presented in this section . +",
    "* definition 1 ( program representation graph ) . * @xmath0 is a directed graph where @xmath1 is a set of nodes and each node @xmath2 denotes program entity such as a function or instruction .",
    "@xmath3 is a set of edges and each edge @xmath4 denotes either control- or data - flow or dependency from @xmath5 to @xmath6 .",
    "@xmath7 is the set of labels that characterize the ( security - sensitive ) operations of a node and @xmath8 , is a labeling function which assigns a label to each node .",
    "@xmath9 is a set of events that denote the context of a node and @xmath10 , is a function which assigns the context to each node . + * definition 2 ( context ) . *",
    "the context of a node @xmath11 in the prg of a program @xmath12 is a set of attributes @xmath13 that govern the reachability of @xmath14 in the course of execution of @xmath12 .",
    "+ * examples of contexts . * in the case of windows executables , the _ guard conditions _ that govern the execution of a node could be considered as its context . unlike windows ( and other desktop os ) binaries , android and ios mobile apps",
    "typically have multiple entry points @xcite .",
    "hence , in the case of such mobile apps , besides guard conditions , the categories of entry points through which a node is reachable could also be considered as its context .",
    "similar platform - specific constraints and observations could be considered while defining the contexts for executables of other platforms .",
    "in this section , we begin by explaining how the regular wlk can be applied to perform malware detection using prgs and how it falls short .",
    "subsequently , we introduce our cwlk and discuss how it addresses the shortcomings of wlk . finally , we prove cwlk s semi - definitiveness and analyze its time complexity .",
    "wlk computes the similarities between graphs based on the 1-dimensional wl test of graph isomorphism @xcite . + * wl test of isomorphism . *",
    "suppose we are to determine whether a given a pair of graphs @xmath15 and @xmath16 are isomorphic . the wl test of isomorphism works by augmenting the node labels by the sorted set of labels of neighboring nodes .",
    "this process is referred to as _ label - enrichment _ and new labels are referred as _",
    "neighborhood labels_. thus , in each iteration _ i _ of the wl algorithm , for each node @xmath2 , we get a new neighborhood label , @xmath17 that encompass the @xmath18 degree neighborhood around @xmath14 .",
    "@xmath17 could be optionally compressed using a hash function @xmath19 such that @xmath20 , iff @xmath21 . to test graph isomorphism",
    ", the re - labeling process is repeated until the neighborhood label sets of @xmath15 and @xmath16 differ , or the number of iterations reaches a specific threshold .",
    "therefore , one iteration of wl relabeling is equivalent to a function @xmath22 that transforms all graphs in the same manner . + * definition 3 ( wl sequence ) . *",
    "define the wl graph at height @xmath23 of the graph @xmath24 as the graph @xmath25 .",
    "the sequence of graphs @xmath26 is called the wl sequence up to height @xmath27 of @xmath15 , where @xmath28 ( i.e. , @xmath29 ) is the original graph and @xmath30 is the graph resulting from the first relabeling , and so on . + * definition 4 ( wl kernel ) . * given a valid kernel @xmath31 and the wl sequence of graph of a pair of graphs @xmath15 and @xmath16 , the wl graph kernel with @xmath27 iterations is defined as @xmath32 where @xmath27 is the number of wl iterations and @xmath33 and @xmath34 are the wl sequences of @xmath15 and @xmath16 , respectively .",
    "@xmath35 is referred as _ height of the kernel_. + intuitively , wlk counts the common neighborhood labels in two graphs .",
    "hence we have @xmath36 , iff @xmath37 for @xmath38 , where @xmath39 is injective and the sets @xmath40 and @xmath41 are disjoint for all @xmath42 .",
    "+ * example & wlk s shortcoming .",
    "* we now apply wlk on the real - world examples discussed in  [ sec : bgm ] to see if it distinguishes malicious and benign neighborhoods clearly , facilitating accurate detection . for the ease of illustration ,",
    "the label compression step is avoided . applying wlk on the ddg for both _",
    "geinimi _ and _ yahoo weather _ apps , shown in fig .",
    "[ fig : me ] ( b ) , for the node getlatitude , for heights @xmath43 , we get the neighborhood labels getlatitude and getlatitude , writebytes , respectively .",
    "clearly , wlk captures the neighborhood around the node getlatitude , incrementally in every iteration of @xmath27 .",
    "in fact , neighborhood label for @xmath44 captures that another sensitive node , writebytes lies in the neighborhood of getlatitude , which highlights a possible privacy leak .",
    "however , wlk does not capture whether the neighborhood involved in this leak is reached in _ user - aware _ or _ unaware _ context .",
    "this is precisely what we address through our cwlk .      * input * : + @xmath45 | _ prg _ with set of nodes ( @xmath1 ) , set of edges ( @xmath46 ) and set of node labels ( @xmath47 ) and context for each node ( @xmath9 ) + @xmath27 | number of iterations + * output * : + @xmath48 - contextual wl sequence of height @xmath27    @xmath49 @xmath50 @xmath51 @xmath52 @xmath53 @xmath54    @xmath55 @xmath56 @xmath57 * return * \\{@xmath58 }    [ algo : cr ]    the goal of cwlk is to capture not only neighborhoods around the node , but also to include the contexts in which each of the neighborhoods is reachable in the prg . to this end",
    ", we modify the re - labeling step of wlk so as to accommodate the context of every neighborhood .",
    "we refer to this process as _ contextual - relabeling _ and the sequence of graphs thus obtained as _",
    "contextual wl sequence_. + * contextual re - labeling . * specifically , cwlk performs one additional step in the re - labeling process which is to attach the contexts of every node to its neighborhood label in every iteration .",
    "this in effect , indicates the contexts under which a particular neighborhood is reachable .",
    "the label thus obtained is referred to as _ contextual neighborhood label_. the contextual relabeling process is presented in detail in algorithm [ algo : cr ] .",
    "+ the inputs to the algorithm are prg , @xmath15 and the degree of neighbourhoods to be considered for re - labeling , @xmath27 .",
    "the output is the sequence of contextual wl graphs , @xmath59 , where @xmath60 are constructed using the contextual relabeling procedure .",
    "+ for the initial iteration @xmath61 , no neighborhood information needs to be considered .",
    "hence the contextual neighborhood label @xmath62 for all nodes @xmath11 is obtained by justing prefixing the contexts to the original node labels and compressing the same ( lines 6 - 8,17 - 18 ) . for @xmath63 ,",
    "the following procedure is used for contextual re - labeling .",
    "firstly , for a node @xmath2 , all of its neighboring nodes are obtained and stored in @xmath64 ( line 10 ) . for each node",
    "@xmath65 the neighborhood label up to degree @xmath66 is obtained and stored in multiset @xmath67 ( line 11 ) .",
    "@xmath68 , neighborhood label of @xmath14 till degree @xmath69 is concatenated to the sorted value of @xmath67 to obtain the current neighborhood label , @xmath70 ( line 12 ) .",
    "finally the current neighborhood label is prefixed with the contexts of node @xmath14 to obtain the string @xmath71 which is then compressed using the function @xmath72 to obtain the contextual neighborhood label , @xmath73 ( lines 13 - 15,17 - 18 ) . +",
    "* definition 5 ( cwl kernel ) . * given a valid kernel @xmath31 and the cwl sequence of graph of a pair of graphs @xmath15 and @xmath16 , the contextual wl graph kernel with @xmath27 iterations is defined as @xmath74 where @xmath27 is the number of cwl iterations and @xmath75 and @xmath76 are the cwl sequences of @xmath15 and @xmath16 , respectively .",
    "+ intuitively , cwlk counts the common contextual neighborhood labels in two graphs .",
    "hence we have @xmath77 , iff @xmath78 for @xmath38 .",
    "+ * example .",
    "* we now apply cwlk on the apps in our example to show how it overcomes wlk s shortcomings .",
    "the contextual neighborhood labels @xmath79 ( without compression ) of the node getlatitude in _ geinimi _ app for heights @xmath80 are , * user - unaware*@xmath81getlatitude and * user - unaware*@xmath81getlatitude , witebytes , respectively . for the same node in _ yahoo weather",
    "_ the contextual neighborhood labels are * user - aware*@xmath81getlatitude and * user - aware*@xmath81getlatitude , witebytes .",
    "hence , it is evident that the cwlk s contextual relabeling provides a means to clearly distinguish malicious prg neighborhoods from the benign ones .",
    "this is achieved by complementing the structural information with contextual information .",
    "therefore , unlike wlk , cwlk based classification does not detect _ yahoo weather _ as a false positive .",
    "this example clearly establishes the suitability of cwlk for the malware detection task .",
    "+ we now prove cwlk s positive definiteness and also analyze its time complexity . + * theorem 1 .",
    "* cwlk is positive definite . + * proof .",
    "* let us define a mapping @xmath82 that counts the occurrences of a particular contextual neighborhood label sequence @xmath83 in @xmath15 ( generated in @xmath27 iterations of algorithm [ algo : cr ] ) .",
    "let @xmath84 denote the number of occurrences of @xmath83 in @xmath15 , and analogously @xmath85 for @xmath16 .",
    "then , @xmath86 summing over all @xmath79 from the vocabulary @xmath87 , we get latexmath:[\\[\\begin{gathered } k^{(h)}_{cwl}(g , g ' ) = \\sum_{\\sigma \\in \\sigma^*}^ { } k^{(h)}_{\\sigma}(g , g ' ) = \\sum_{\\sigma \\in \\sigma^ * } \\phi^{(h)}_\\sigma(g)\\phi^{(h)}_\\sigma(g')\\\\ = |\\{(\\sigma_i(n),\\sigma_i(n'))|\\sigma_i(n ) = \\sigma_i(n ' ) , i \\in \\{1, ...",
    ",h\\ } , n \\in n , n ' \\in n'\\}|\\\\ =     where the last equality follows from the fact that @xmath72 is injective .",
    "+ as @xmath89 if @xmath90 , the string @xmath79 corresponds to exactly one contextual neighborhood label and @xmath91 defines a kernel with corresponding feature map @xmath92 , such that @xmath93 * complexity . *",
    "the runtime complexity of cwlk with @xmath27 iterations on a graph with @xmath14 nodes and @xmath94 edges is @xmath95 ( assuming that @xmath96 ) which is same as that of wlk .",
    "more specifically , the neighborhood label computation with sorting operations ( lines 10 - 12 of algorithm [ algo : cr ] ) take @xmath97 time for one iteration and the same for @xmath35 iterations take @xmath98",
    ". the inclusion of context ( lines 6 - 8,13 - 15 ) , does not incur additional overhead as @xmath99 .",
    "hence the final time complexity remains as @xmath95 .",
    "for a detailed derivation and analysis of the time complexity of wlk , we refer the reader to @xcite . +",
    "* efficient computation of cwlk on k graphs .",
    "* when computing cwlk on @xmath100 graphs to obtain @xmath101 kernel matrix , a nave approach would involve @xmath102 comparisons , resulting a time complexity of @xmath103",
    ". however , as mentioned in @xcite , a bag - of - features ( bof ) model based optimization could be performed to arrive the kernel matrix in @xmath104 time .",
    "this optimized computation involves the following steps : ( 1 ) a vocabulary @xmath105 of all the contextual neighbourhood labels of nodes across the @xmath100 graphs is obtained in @xmath106 time .",
    "this facilitates representing each of the @xmath100 graphs as feature vectors of @xmath107 dimensions .",
    "( 2 ) subsequently , @xmath101 kernel matrix can be computed by multiplying these vectors in @xmath108 time .",
    "+ in summary , cwlk has the same efficiency as that of wlk and supports explicit feature vector representations of prgs . +",
    "* relation to other spatial contextual kernels .",
    "* two recently proposed graph kernels @xcite and @xcite , consider incorporating the spatial context information to neighborhood subgraph features .",
    "they define _ context of a subgraph feature as another subgraph appearing in its vicinity_. as mentioned earlier , in our malware detection problem we refer to _ attributes of a node which determine its reachability as its context_. this _ reachability context _ is different from _ spatial context _ discussed in @xcite and @xcite .",
    "hence cwlk is consummately different from these two kernels .",
    "[ tab : ds ]    .composition of dataset [ cols=\"^,^,^\",options=\"header \" , ]      we now compare cwlk based detection with the state - of - the - art android malware detection solutions to study whether contextual prg neighborhoods makes good features for malware detection , through experiment e2 . for cwlk based detection , icfg",
    "representation with @xmath109 is used as it offers the best performance .",
    "the precision , recall and f - measures of each of these methods are reported in table [ tab : maldetect ] .",
    "the following observations are made from the table :    * clearly , cwlk based malware detection outperforms all the compared solutions in terms of f - measure .",
    "in particular , our approach outperforms the best performing technique ( i.e. , drebin ) by 4.87% f - measure . in terms of precision ,",
    "our approach outperforms adagio and allix _ et al .",
    "_ s methods and is comparable to drebin . in terms of recall ,",
    "ours outperforms other methods . * out of the methods compared , drebin does not use both structural and contextual features .",
    "adagio and allix _ et al . _",
    "s approaches use structural information but not contextual information .",
    "this reveals that capturing both these types of information is the reason for our approach s superior performance , reinforcing our findings from experiment e1 .",
    ", width=340,height=136 ]    we now compare the efficiency of cwlk based detection against that of state - of - the - art malware detectors .",
    "it is noted that these techniques use different features and classifiers and hence a wide variation in training and testing durations is expected .",
    "the results of this comparison is presented in fig .",
    "[ fig : soaeff ] , from which the following observations are made :    * drebin being a light - weight non prg based approach it has significantly higher efficiency than all other methods , including ours .",
    "* allix _ et al . _",
    "s method is similar to ours in terms of using prg based features .",
    "hence our efficiency is comparable to this method . *",
    "adagio uses nhgk and hi kernel svm in the primal formulation .",
    "hence it takes a prohibitively long time for training and testing .",
    "our method is far more efficient than adagio .    in conclusion ,",
    "our method s efficiency is comparable to that of other prg based methods , far better than heavy - weight approaches and inferior to non prg based light - weight methods .",
    "* summary . * from experiment e2 , we conclude that when compared to state - of - the - art malware detectors , cwlk produces considerably higher accuracy with a practically tractable efficiency , making it suitable for large - scale real - world malware detection .",
    "in this paper , we present cwlk , a novel graph kernel that facilitates detecting malware using prgs . unlike the existing kernels which capture only the security - sensitive neighborhoods in prgs , cwlk captures these neighborhoods along with the context under which they are reachable .",
    "this makes cwlk more expressive and in turn more accurate than existing kernels . besides expressiveness , cwlk has two specific advantages : ( 1 ) shows high efficiency , ( 2 ) supports building explicit feature vector representations of prgs .",
    "cwlk is evaluated on a large - scale experiment with more than 50,000 android apps , and is found to outperform two state - of - the - art graph kernels and three malware detection techniques in terms of f - measure , while maintaining comparable efficiency . +",
    "* future work . * in our future work ,",
    "we plan to investigate incorporating contextual information in other sub - structure based graph kernels such as @xcite and @xcite and subsequently , study their suitability for performing malware detection",
    ". + * implementation & dataset .",
    "* we provide an efficient implementation of cwlk and information on the datasets used within this work at : https://sites.google.com/site/cwlkernel",
    "we thank the authors of @xcite and @xcite , for their suggestions that helped us re - implement their methods .",
    "zhang , mu , et al .",
    "`` semantics - aware android malware classification using weighted contextual api dependency graphs . ''",
    "proceedings of the 2014 acm sigsac conference on computer and communications security .",
    "acm , 2014 .",
    "navarin , n. , sperduti , a. , & tesselli , r. ( 2015 , november ) . extending local features with contextual information in graph kernels . in neural information processing ( pp .",
    "271 - 279 ) .",
    "springer international publishing .",
    "frhlich , holger , jrg k. wegner , and andreas zell .",
    "`` assignment kernels for chemical compounds . '' neural networks , 2005 . ijcnn05 . proceedings .",
    "2005 ieee international joint conference on .",
    "2 . ieee , 2005 ."
  ],
  "abstract_text": [
    "<S> in this paper , we propose a novel graph kernel specifically to address a challenging problem in the field of cyber - security , namely , malware detection . </S>",
    "<S> previous research has revealed the following : ( 1 ) graph representations of programs are ideally suited for malware detection as they are robust against several attacks , ( 2 ) besides capturing topological neighbourhoods ( i.e. , structural information ) from these graphs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods .    </S>",
    "<S> we observe that state - of - the - art graph kernels , such as weisfeiler - lehman kernel ( wlk ) capture the structural information well but fail to capture contextual information . to address this , we develop the contextual weisfeiler - lehman kernel ( cwlk ) which is capable of capturing both these types of information . we show that for the malware detection problem , cwlk is more expressive and hence more accurate than wlk while maintaining comparable efficiency . through our large - scale experiments with more than 50,000 real - world android apps , we demonstrate that cwlk outperforms two state - of - the - art graph kernels ( including wlk ) and three malware detection techniques by more than 5.27% and 4.87% f - measure , respectively , while maintaining high efficiency . </S>",
    "<S> this high accuracy and efficiency make cwlk suitable for large - scale real - world malware detection </S>",
    "<S> .    keywords | graph kernels , malware detection , program analysis </S>"
  ]
}