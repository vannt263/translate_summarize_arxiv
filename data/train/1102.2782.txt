{
  "article_text": [
    "isomorphism problems for infinite but finitely presented structures are an active research topic in algorithmic model theory @xcite .",
    "it is a folklore result in computable model theory that the isomorphism problem for computable structures ( i.e. , structures , where the domain is a computable set of natural numbers and all relations are computable too ) is highly undecidable  more precisely , it is @xmath3-complete , i.e. , complete for the first existential level of the analytical hierarchy .",
    "khoussainov et al .",
    "proved in @xcite that even for automatic structures ( i.e. , structures , where the domain is a regular set of words and all relations can be recognized by synchronous multitape automata ) , the isomorphism problem is @xmath3-complete . in @xcite , this result",
    "was further improved to automatic order trees and automatic linear orders . on the decidability side",
    ", courcelle proved that the isomorphism problem for equational graphs is decidable @xcite . recall that a graph is equational if it is the least solution of a system of equations over the hr graph operations .",
    "we remark that courcelle s algorithm for the isomorphism problem for equational graphs has very high complexity ( it is not elementary ) , since it uses the decidability of monadic second - order logic on equational graphs .    in this paper",
    ", we continue the investigation of isomorphism problems for infinite but finitely presented structures at the lower end of the spectra .",
    "we focus on two very simple classes of infinite structures : _ regular trees _ and _ regular words_. both are particular automatic structures . recall that a countable tree is regular if it has only finitely many subtrees up to isomorphism .",
    "this definition works for ordered trees ( where the children of a node are linearly ordered ) and unordered trees .",
    "an equivalent characterization in the unordered case uses regular languages : an unordered ( countable ) tree @xmath4 is regular if and only if there is a regular language @xmath5 which contains the empty word and such that @xmath4 is isomorphic to the tree obtained by taking the prefix order on @xmath6 ( the empty word word is the root of the tree ) .",
    "hence , a regular tree can be represented by a finite deterministic or nondeterministic automaton ( dfa or nfa ) , and the isomorphism problem for regular trees becomes the following computational problem : given two dfas ( resp .",
    ", nfas ) accepting both the empty word , are the corresponding regular trees isomorphic ?",
    "it is is not difficult to prove that this problem can be solved in polynomial time if the two input automata are assumed to be dfas ; the algorithm is very similar to the well - known partition refinement algorithm for checking bisimilarity of finite state systems @xcite , see section  [ sec : upper - bounds - trees ] .",
    "hence , the isomorphism problem for regular trees that are represented by nfas can be solved in exponential time .",
    "our first main result states that this problem is in fact @xmath0-complete , see section  [ sec : lower - bound - exptime - tree ] .",
    "the proof of the @xmath0 lower bound uses three main ingredients : ( i ) @xmath0 coincides with alternating polynomial space @xcite , ( ii ) a construction from @xcite , which reduces the evaluation problem for boolean expressions to the isomorphism problem for ( finite ) trees , and ( iii ) a small nfa accepting all words that do _ not _ represent an accepting computation of a polynomial space machine @xcite .- complete . ] .",
    "our proof technique yields another result too : it is @xmath2-complete to check for two given _ acyclic _ nfas @xmath7 , @xmath8 ( both accepting the empty word ) , whether the trees that result from the prefix orders on @xmath9 and @xmath10 , respectively , are isomorphic .",
    "note that these two trees are clearly finite ( since the automata are acyclic ) , but the size of @xmath11 can be exponential in the number of states of @xmath12 . in this sense ,",
    "acyclic nfas can be seen as a succinct representation of finite trees .",
    "the @xmath2-upper bound for acyclic nfas follows easily from lindell s result @xcite that isomorphism of explicitly given trees can be checked in logarithmic space .    the second part of this paper studies the isomorphism problem for _ regular words _ , which were introduced in @xcite .",
    "a _ generalized word _ over an alphabet @xmath13 is a countable linear order together with a @xmath13-coloring of the elements .",
    "a generalized word is regular if it can be obtained as the least solution ( in a certain sense made precise in @xcite ) of a system @xmath14 . here",
    ", every @xmath15 is a finite word over the alphabet @xmath16 .",
    "for instance , the system @xmath17 defines the regular word @xmath18 .",
    "courcelle @xcite gave an alternative characterization of regular words : a generalized word is regular if and only if it is equal to the frontier word of a finitely - branching ordered regular tree , where the leaves are colored by symbols from @xmath13 .",
    "here , the frontier word is obtained by ordering the leaves in the usual left - to - right order ( note that the tree is ordered ) . alternatively",
    ", a regular word can be represented by a dfa @xmath19 , where the set of final states is partitioned into sets @xmath20 ( @xmath21 ) ; we call such a dfa a _ partitioned dfa_. the corresponding regular word is obtained by ordering the language of @xmath19 lexicographical and coloring a word @xmath22 with @xmath23 if @xmath24 leads from the initial state to a state from @xmath20",
    ". a third characterization of regular words was provided by heilbrunner @xcite : a generalized word is regular if it can be obtained from singleton words ( i.e. , symbols from @xmath13 ) using the operations of concatenation , @xmath25-power , @xmath26-power and dense shuffle . for a generalized word @xmath27 , its @xmath25-power ( resp .",
    "@xmath26-power ) is the generalized word @xmath28 ( resp .",
    "@xmath29 ) .",
    "moreover , the shuffle of generalized words @xmath30 is obtained by choosing a dense coloring of the rationals with colors @xmath31 ( up to isomorphism , there is only a single such coloring @xcite ) and then replacing every @xmath32-colored rational by @xmath33 .",
    "in fact , heilbrunner presents an algorithm which computes from a given system of equations ( or , alternatively , a partitioned dfa ) an expression over the above set of operations ( called a _ regular expression _ in the following ) which defines the least solution of the system of equations . a simple analysis of heilbrunner s algorithm shows that the computed regular expression in general has exponential size with respect to the input system of equations and it is easy to see that this can not be avoided .",
    "( @xmath34 ) , @xmath35 , which defines the finite word @xmath36 . ]",
    "the next step was taken by thomas in @xcite , where he proved that the isomorphism problem for regular words is decidable . for his proof",
    ", he uses the decidability of the monadic second - order theory of linear orders ; hence his proof does not yield an elementary upper bound for the isomorphism problem for regular words .",
    "such an algorithm was presented later by bloom and sik in @xcite , where the authors present a polynomial time algorithm for checking whether two given regular expressions define isomorphic regular words .",
    "together with heilbrunner s algorithm , this yields an exponential time algorithm for checking whether the least solutions of two given systems of equations ( or , alternatively , the regular words defined by two partitioned dfas ) are isomorphic . it was asked in @xcite , whether a polynomial time algorithm for this problem exists .",
    "our second main result answers this question affirmatively .",
    "in fact , we prove that the problem , whether two given partitioned dfas define isomorphic regular words , is @xmath1-complete . a large part of this paper deals with the polynomial time upper bound .",
    "the first step is simple . by reanalyzing heilbrunner s algorithm ,",
    "it is easily seen that from a given partitioned dfa ( defining a regular word @xmath27 ) one can compute in _ polynomial time _ a _ succinct representation _ of a regular expression for @xmath27 .",
    "this succinct representation consists of a dag ( directed acyclic graph ) , whose unfolding is a regular expression for @xmath27 .",
    "the second and main step of the proof shows that the polynomial time algorithm of bloom and sik for regular expressions can be refined in such a way that it works ( in polynomial time ) for succinct regular expressions too .",
    "the main tool in our proof is ( besides the machinery from @xcite ) algorithmics on compressed strings ( see @xcite for a survey ) , in particular plandowski s result that equality of strings that are represented by _ straight - line programs _",
    "( i.e. , context free grammars that only generate a single word ) can be checked in polynomial time @xcite .",
    "it is a simple observation that an _ acyclic _ partitioned",
    "dfa is basically a straight - line program .",
    "hence , we show how to extend plandowski s polynomial time algorithm from acyclic partitioned dfas to general partitioned dfas .",
    "an immediate corollary of our result is that it can be checked in polynomial time whether the lexicographic orderings on the languages defined by two given dfas ( so called regular linear orderings ) are isomorphic .",
    "for the special case that the two input dfas accept well - ordered languages , this was shown in @xcite .",
    "let us mention that it is highly undecidable ( @xmath3-complete ) to check , whether the lexicographic orderings on the languages defined by two given deterministic pushdown automata ( these are the algebraic linear orderings @xcite ) are isomorphic @xcite .",
    "for an equivalence relation @xmath37 on a set @xmath38 and @xmath39 we denote with @xmath40_r$ ] the equivalence class containing @xmath37 . moreover , @xmath41_r = \\ { [ a]_r \\mid a \\in a \\}$ ] .",
    "let us take a finite alphabet @xmath13 .",
    "the length of a finite words @xmath42 is denoted by @xmath43 .",
    "let @xmath44 , @xmath45 , @xmath46 , and @xmath47 . for @xmath48 , we write @xmath49 if there exists @xmath50 with @xmath51 , i.e.",
    ", @xmath27 is a _ prefix _ of @xmath52 .",
    "we write @xmath53 if @xmath49 and @xmath54 . for a language @xmath5",
    "let @xmath55 .",
    "for a fixed linear order @xmath56 on the alphabet @xmath13 we define the _ lexicographic order _",
    "@xmath57 on @xmath58 as follows : @xmath59 if @xmath49 or there exist words @xmath60 and @xmath61 such that @xmath62 , @xmath63 , and @xmath64 .",
    "we assume that the reader has some basic background in complexity theory , in particular concerning the complexity classes @xmath65 , @xmath1 , @xmath2 , and @xmath0 , see e.g.  @xcite .",
    "all completeness results in this paper refer to logspace reductions .",
    "a @xmath2-transducer is a deterministic turing machine with a read - only input tape , a write - only output tape and a work tape , whose length is bounded by @xmath66 , where @xmath67 is the input length .",
    "the output is written from left to right on the output tape , i.e. , in each step the transducer either outputs a new symbol on the output tape , in which case the output head moves one cell to the right , or the transducer does not output a new symbol in which case the output head does not move .",
    "moreover , we assume that the transducer terminates for every input .",
    "this implies that a @xmath2-transducer computes a mapping @xmath68 , where @xmath69 is bounded by @xmath70 .",
    "we need the following simple lemma :    [ pspace ] assume that the mapping @xmath68 can be computed by a @xmath2-transducer and let @xmath71 be a language in @xmath72 for some constant @xmath73 .",
    "then @xmath74 belongs to @xmath2 .",
    "the proof uses the same idea that shows that the composition of two logspace computable mappings is again logspace computable .",
    "let @xmath50 be an input .",
    "basically , we run the @xmath72-algorithm for @xmath6 on the input @xmath75 .",
    "but since @xmath76 can be computed by a @xmath2-transducer ( which can generate an exponentially long output ) the length of @xmath75 can be only bounded by @xmath70 .",
    "hence , we can not construct @xmath75 explicitly .",
    "but this is not necessary .",
    "we only store a pointer to some position @xmath75 ( this pointer needs space @xmath77 ) while running the @xmath72-algorithm for @xmath6 .",
    "each time , this algorithm needs the @xmath78 letter of @xmath75 , we run the pspace - transducer for @xmath6 until the @xmath78 output symbol is generated .",
    "the first @xmath79 symbols of @xmath75 are not written on the output tape .",
    "note that the @xmath72-algorithm for @xmath6 needs space @xmath80 while running on @xmath75 .",
    "hence , the total space requirement is bounded by @xmath77 .",
    "an _ alternating turing machine _ is an ordinary nondeterministic turing machine , where in addition the set of states @xmath81 is partitioned into existential states ( @xmath82 ) and universal states ( @xmath83 ) .",
    "a configuration , where the current state is existential ( resp . , universal ) is called an existential ( resp . , universal ) configuration .",
    "let us assume that @xmath84 is an alternating turing machine without infinite computation paths .",
    "then , we define inductively the notion of an _ accepting configuration _ as follows : if @xmath85 is an existential configuration , then @xmath85 is accepting if and only if @xmath85 has an accepting successor configuration . if @xmath85 is a universal configuration , then @xmath85 is accepting if and only if all successor configurations of @xmath85 are accepting .",
    "note that a universal configuration without successor configurations is accepting , whereas an existential configuration without successor configurations is not accepting .",
    "an input @xmath86 is accepted by @xmath84 ( briefly , @xmath87 ) if and only if the initial configuration with input @xmath86 is accepting .",
    "the complexity class @xmath88 consists of all languages @xmath5 such that there exist nondeterministic polynomial time turing machines @xmath89 and @xmath90 with input alphabet @xmath13 such that for every input @xmath50 : @xmath91 if and only if the number of accepting computations of @xmath89 on input @xmath24 equals the number of accepting computations of @xmath90 on input @xmath24 .",
    "if we replace in this definition nondeterministic polynomial time turing machines by nondeterministic logspace turing machines , we obtain the class @xmath92 .",
    "let @xmath93 be a nondeterministic finite automaton , briefly _ nfa _ , where @xmath81 is the set of states , @xmath13 is the input alphabet , @xmath94 is the transition relation , @xmath95 is the initial state , and @xmath96 is the set of final states .",
    "a state @xmath97 is _ accessible _ ( resp .",
    "_ coaccessible _ ) , if @xmath98 can be reached from the initial state @xmath99 ( resp .",
    ", if a final state from @xmath100 can be reached from @xmath98 ) .",
    "we say that @xmath19 is accessible ( resp . ,",
    "coaccessible ) , if every state of @xmath19 is accessible ( resp , coaccessible ) .",
    "an nfa @xmath19 is called _ prefix - closed _ if every state of @xmath19 is a final state . in that case , the language @xmath101 is prefix - closed .",
    "moreover , if @xmath19 is coaccessible and the prefix - closed nfa @xmath102 results from @xmath19 by making every state final , then clearly @xmath103 . for a dfa ( deterministic finite automaton )",
    ", @xmath104 is a partial map from @xmath105 to @xmath81 .",
    "sometimes , we will also deal with nfas ( dfas ) without an initial state .",
    "if @xmath19 is an nfa without an initial state and @xmath98 is a state of @xmath19 , then @xmath106 is the language accepted by @xmath19 , when @xmath98 is declared to be the initial state",
    ". we will need the following simple lemma , which is probably folklore :    [ lemma : counting ] for a given a dfa @xmath93 , we can compute the cardinality @xmath107 in polynomial time .",
    "w.l.o.g we can assume that @xmath19 is accessible and coaccessible .",
    "then @xmath101 is finite if and only if @xmath19 is acyclic .",
    "so assume that @xmath19 is acyclic .",
    "since @xmath19 is deterministic , the size of @xmath101 equals the number of paths from @xmath99 to @xmath100 .",
    "now , in a directed acyclic graph , the number of paths from a source node to all other nodes can be easily computed by dynamic programming in polynomial time .",
    "a _ partitioned dfa _ is a tuple @xmath108 , where @xmath109 is a finite alphabet , @xmath110 is an ordinary dfa and @xmath111 for @xmath112 .",
    "since @xmath102 is a dfa , it follows that the language @xmath113 is partitioned by the languages @xmath114 , where @xmath115 ( @xmath116 ) .",
    "we use partitioned dfas to label elements of a structure with symbols from @xmath109 .",
    "the language @xmath114 will be the set of @xmath23-labelled elements .",
    "we do not introduce partitioned nfas , since for nfas the languages @xmath114 ( @xmath116 ) would not partition @xmath113 ( thus , a point could get several labels ) .    a ( @xmath117-free ) _ rational transducer _ is a tuple @xmath118 , where @xmath81 ( the set of states ) , @xmath13 ( the input alphabet ) , and @xmath109 ( the output alphabet ) are finite sets , @xmath95 is the initial state , @xmath96 is the set of final states , and @xmath119 is the transition relation . a transition @xmath120 is also written as @xmath121 .",
    "the rational transducer @xmath122 defines a binary relation @xmath123\\ ! ]",
    "\\sigma^ * \\times \\gamma^*$ ] in the usual way . for a language @xmath5",
    "let @xmath124\\!]\\}$ ] .",
    "a _ tree _ is a partial order @xmath125 , where @xmath56 has a smallest element ( the root of the tree ; in particular @xmath126 ) and for every @xmath39 , the set @xmath127 is finite and linearly ordered by @xmath56 . we write @xmath128 if @xmath62 and there does not exist @xmath129 with @xmath130 . for @xmath39 ,",
    "let @xmath131 ( the set of children of @xmath23 ) be the set of all @xmath132 such that @xmath128 .",
    "the set of leaves of @xmath4 is @xmath133 .",
    "for @xmath39 let @xmath134 be the subtree of @xmath4 rooted at @xmath23 , i.e. , the set of nodes of @xmath134 is @xmath135 .",
    "the tree @xmath4 is _ finitely branching _ if @xmath131 is finite for all @xmath39 .",
    "an _ infinite path _ of @xmath4 is an infinite chain @xmath136 ; _ finite paths _ are defined analogously . if @xmath4 is finite and @xmath39 , then the _ height _ of @xmath23 in @xmath4 is the maximal length of a path that starts in @xmath23 . for trees @xmath137 and @xmath138 we write @xmath139 in case @xmath137 and @xmath138 are isomorphic .    a _ tree over the finite alphabet _",
    "@xmath13 is a pair @xmath140 , where @xmath5 is a language with @xmath141 .",
    "note that @xmath4 is indeed a tree in the above sense .",
    "most of the time , we will identify the language @xmath6 with the tree @xmath142 .",
    "moreover , if @xmath143 ( i.e. , @xmath6 is prefix - closed ) , then @xmath4 is a finitely branching tree .",
    "a countable tree @xmath4 is called _ regular _ if @xmath4 has only finitely many subtrees up to isomorphism .",
    "equivalently , a countable tree is regular if it is isomorphic to a tree of the form @xmath144 , where @xmath6 is a regular language with @xmath141 .",
    "we require that the empty word @xmath117 belongs to @xmath6 in order to ensure the existence of a root ( otherwiese @xmath144 would be only a forest ) .",
    "if @xmath6 is accepted by the accessible dfa @xmath19 , then the subtrees of @xmath144 correspond to the final states of @xmath19 .",
    "note that by our definition , a regular tree need not be finitely branching .",
    "our definition of a regular tree ( having only finitely many subtrees up to isomorphism ) makes sense for other types of trees as well , e.g. for node - labeled trees or ordered trees ( where the children of a node are linearly ordered ) .",
    "these variants of regular trees can be generated by finite automata as well .",
    "for instance , a node - labeled regular tree @xmath145 , where @xmath109 is the finite labeling alphabet and @xmath146 is the set of @xmath23-labeled nodes can be specified by a partitioned dfa @xmath147 with @xmath148 and @xmath149 .",
    "we do not consider node labels in this paper , since it makes no difference for the isomorphism problem ( node labels can be eliminated by adding additional children to nodes ) .",
    "ordered regular trees will be briefly considered in section  [ sec : order - trees ] .",
    "see @xcite for a thorough introduction into linear orders .",
    "let @xmath150 be the order type of the rational numbers , @xmath25 the order type of the natural number , and @xmath151 be the order type of the negative integers . with @xmath152",
    "we denote a finite linear order with @xmath67 elements .",
    "let @xmath153 be a linear order .",
    "@xmath154 is _ dense _ if @xmath6 consists of at least two elements , and for all @xmath155 there exists @xmath156 with @xmath157 . by cantor",
    "s theorem , every countable dense linear order , which neither has a smallest nor largest element is isomorphic to @xmath150 . hence ,",
    "if we take symbols @xmath158 and @xmath159 with @xmath160 , then @xmath161 .",
    "the linear order @xmath154 is _ scattered _ if there does not exist an injective order morphism @xmath162 .",
    "clearly , @xmath25 , @xmath151 , as well as every finite linear order are scattered .",
    "a linear order is _ regular _ if it is isomorphic to a linear order @xmath163 for a regular language @xmath6 .",
    "hence , for instance , @xmath150 , @xmath25 , @xmath151 , and every finite linear order are regular linear orders .    for two linear orders @xmath164 and @xmath165 with @xmath166",
    "we define the sum @xmath167 , where @xmath168 if and only if either @xmath169 and @xmath170 , or @xmath171 and @xmath172 , or @xmath173 and @xmath174 .",
    "we define the product @xmath175 where @xmath176 if and only if either @xmath177 or ( @xmath178 and @xmath179 ) .    an _ interval _ of @xmath154 is a subset @xmath180 such that @xmath157 and @xmath181 implies @xmath182 .",
    "an interval is _ right - closed _",
    "_ left - closed _ ) if it has a greatest ( resp .",
    "smallest ) element and it is _ closed _ if it is both right - closed and left - closed .",
    "an interval @xmath183 is _ dense _",
    ", _ scattered _ ) if the linear order @xmath56 restricted to @xmath183 is dense ( resp .",
    ", _ scattered _ ) . a predecessor ( resp . ,",
    "successor ) of @xmath184 is a largest ( resp . ,",
    "smallest ) element of @xmath185 ( resp . , @xmath186 ) .",
    "of course , a _ predecessor _ ( resp . , _ successor _ ) of @xmath86 need not exist , but if it exists then it is unique .",
    "generalized words are countable colored linear orders .",
    "let @xmath13 be a ( possibly infinite ) alphabet .",
    "a _ generalized word _",
    "( or simply word ) @xmath27 over @xmath13 is a triple @xmath187 such that @xmath6 is a finite or countably infinite set , @xmath56 is a linear order on @xmath6 and @xmath188 is a coloring of @xmath6 .",
    "the alphabet @xmath189 equals the image of @xmath190 . if @xmath6 is finite , we obtain a finite word in the usual sense . as for trees",
    ", we write @xmath191 for generalized words @xmath27 and @xmath52 in case @xmath27 and @xmath52 are isomorphic .",
    "let @xmath192 be a generalized word over @xmath13 with @xmath193 .",
    "let @xmath194 be a generalized word for each @xmath195 .",
    "we define the generalized word @xmath196=(l';\\leq,\\tau')$ ] as follows :    * @xmath197 , * @xmath198 if and only if either @xmath199 or ( @xmath200 and @xmath201 ) , and * @xmath202 .",
    "thus , @xmath196 $ ] is obtained from @xmath27 by replacing every @xmath23-labelled point by @xmath203 ( for all @xmath21 ) .",
    "now we can define the regular operations on words . in order to do",
    "so we need the following words .",
    "the words @xmath204 and @xmath205 for @xmath206 are as usual .",
    "the generalized word @xmath207 has @xmath151 as underlying order and every element is colored with @xmath23 .",
    "finally , we let @xmath208^\\eta$ ] be the generalized word with underlying order @xmath150 where the coloring is such that any point is labeled by some @xmath209 @xmath210 and , moreover , for any two points @xmath211 and any @xmath212 we find a point @xmath156 with @xmath213 colored by @xmath209 .",
    "it can be shown that this describes a unique word up to isomorphism @xcite .",
    "let @xmath214 be words over @xmath13 .",
    "we let : @xmath215    &   \\qquad     u^\\omega&=a^\\omega[a / u]\\\\      [ u_1,\\ldots , u_n]^\\eta&=[a_1,\\ldots , a_n]^\\eta[a_1/u_1,\\ldots , a_n / u_n ]      & u^{{\\overline{\\omega}}}&=a^{{\\overline{\\omega}}}[a / u ] .    \\end{aligned}\\ ] ]    thus , the underlying linear order of @xmath216 is the sum of the underlying linear orders of @xmath27 and @xmath52 .",
    "intuitively , we have @xmath217 and @xmath218 .",
    "note that since @xmath219^\\eta$ ] is invariant under permutations of the @xmath33 we also sometimes use the notation @xmath220 for a finite set @xmath221 .",
    "the least set of words which is closed under the regular operations and contains the singleton words @xmath23 for @xmath222 is called the set of _ regular words _ over @xmath13 , denoted @xmath223 .",
    "note that this implies that every regular word is non - empty , i.e. , its domain is a non - empty set .",
    "moreover , although we allow @xmath13 to be infinite ( this will be useful later ) , the alphabet @xmath189 of a regular word @xmath27 must be finite .",
    "clearly , every regular word can be described by a _ regular expression _ over the above operations , but this regular expression is in general not unique .",
    "here are some typical identities between regular words , where @xmath221 is a finite set of regular words , @xmath224 , @xmath225 , @xmath226 , every @xmath227 ( @xmath228 ) has one of the forms @xmath220 , @xmath229 , @xmath230 , @xmath231 with @xmath232 , and @xmath233 are regular words : @xmath234^\\eta \\cong x^\\eta , \\\\   ( vw)^\\omega = v ( wv)^\\omega , \\quad ( vw)^{{\\overline{\\omega } } } = ( wv)^{{\\overline{\\omega } } } w .\\end{gathered}\\ ] ] see @xcite for a complete axiomatization of the equational theory of regular words .    by a result of heilbrunner @xcite ,",
    "regular words can be characterized by partitioned dfas as follows : let @xmath235 be a partitioned dfa , and let @xmath236 .",
    "let us fix a linear order on the alphabet @xmath109 , so that the lexicographic order @xmath57 is defined on @xmath237 .",
    "then we denote with @xmath238 the generalized word @xmath239 where @xmath240 ( @xmath21 , @xmath241 ) if and only if @xmath242 .",
    "it is easy to construct from a given regular expression ( describing the regular word @xmath27 ) a partitioned dfa @xmath19 with @xmath243 , see e.g. ( * ? ? ?",
    "* proof of proposition  2 ) for a simple construction .",
    "the other direction is more difficult .",
    "heilbrunner has shown in @xcite how to compute from a given partitioned dfa @xmath19 ( such that @xmath238 is non - empty ) a regular expression for the word @xmath238 , which is therefore regular .",
    "unfortunately , the size of the regular expression produced by heilbrunner s algorithm is exponential in the size of @xmath19 . in section  [ sec : heilbrunner ]",
    ", we will see that a succinct representation of a regular expression for @xmath238 can be produced in polynomial time .",
    "one can show that the isomorphism problem for regular words ( given by partitioned dfas ) can be reduced ( in logspace ) to the isomorphism problem for regular linear orders ( given by dfas ) .",
    "in other words , node labels can be eliminated as for regular trees ( as remarked at the end of section  [ sec : trees ] ) .",
    "so , the reader might ask , why we consider the isomorphism problem for regular words and do not restrict to regular linear orders .",
    "the point is that even if we start with regular linear orders , in the course of our polynomial isomorphism check regular words will naturally arise .",
    "in this section , we investigate the isomorphism problem for ( unordered ) regular trees .",
    "we consider two input representations for regular trees : dfas and nfas .",
    "it turns out that while the isomorphism problem for dfa - represented regular trees is @xmath1-complete , the same problem becomes @xmath0-complete for nfa - represented regular trees .",
    "moreover , we show that for _ finite _ trees that are succinctly represented by _ acyclic _",
    "nfas , isomorphism is @xmath2-complete .",
    "[ thm : upper - bound - p ] the following problem can be solved in polynomial time :    input : two dfas @xmath7 and @xmath8 such that @xmath244 .",
    "question : @xmath245 ?    by taking the disjoint union of @xmath7 and @xmath8 , it suffices to solve the following problem in polynomial time :    input : a dfa @xmath19 without initial state and two final states @xmath246 of @xmath19 .",
    "question : @xmath247 ?",
    "note that @xmath248 since @xmath249 and @xmath98 are final .",
    "let @xmath250 .",
    "in fact , we will compute in polynomial time the equivalence relation @xmath251 this will be done similarly to the classical partition refinement algorithm for checking bisimilarity of finite state systems @xcite .    for @xmath252 and @xmath253",
    "let @xmath254 be the set of all words accepted by the dfa @xmath255 .",
    "hence , the sets @xmath256 ( @xmath257 ) partition @xmath258 .",
    "let us say that a node @xmath259 is of type @xmath98 if @xmath260",
    ". for @xmath252 and @xmath261 let us define the subset @xmath262 as the set of all words over @xmath13 labeling a path from @xmath249 to a state from @xmath263 without intermediate final states ; this is clearly a regular language and a dfa for @xmath264 can be easily computed in polynomial time from @xmath19 , @xmath249 , and @xmath263 : we take the dfa @xmath19 and remove every transition leaving a final state from @xmath100 .",
    "moreover , we introduce a copy @xmath265 of @xmath249 , which will be the new initial state and there is an @xmath23-labeled transition from @xmath265 to @xmath98 if and only if there is an @xmath23-labeled transition from @xmath249 to @xmath98 in @xmath19 .",
    "finally , @xmath263 is the set of final states .",
    "note that if @xmath259 is of type @xmath98 , then the nodes @xmath266 with @xmath267 are exactly the children of @xmath27 in the tree @xmath268 .",
    "let @xmath269 be the cardinality of the language @xmath270 .",
    "by lemma  [ lemma : counting ] , each of these numbers @xmath271 can be computed in polynomial time . for @xmath253",
    "let @xmath272 .",
    "thus @xmath273 is the cardinality of the language @xmath274 .",
    "let us now compute the equivalence relation @xmath275 .",
    "as already remarked , this will be done by a partition refinement algorithm .",
    "assume that @xmath37 is an equivalence relation on @xmath100 .",
    "we define the new equivalence relation @xmath276 on @xmath100 as follows : @xmath277 thus , @xmath276 is a refinement of @xmath37 which can be computed in polynomial time from @xmath37 .",
    "let us define a sequence of equivalence relations @xmath278 on @xmath100 as follows : @xmath279 , @xmath280 .",
    "then , there exists @xmath281 such that @xmath282 .",
    "we claim that @xmath283 .",
    "a simple argument shows that for every equivalence relation @xmath37 on @xmath100 with @xmath284 , one has @xmath285 as well .",
    "hence , by induction over @xmath286 , one gets @xmath287 for all @xmath286 .    for the other direction",
    ", we show that if @xmath37 is an equivalence relation on @xmath100 such that @xmath288 ( this holds for @xmath289 ) , then @xmath290 . so , assume that @xmath291 .",
    "we will define an isomorphism @xmath292 as the limit of isomorphisms @xmath293 , @xmath294 . here",
    ", @xmath293 is an isomorphism between the trees that result from @xmath295 and @xmath296 by cutting off all nodes below level @xmath67 ( the roots are one level 1 ) .",
    "let us call these trees @xmath297 ( @xmath298 ) .",
    "moreover , @xmath293 has the additional property that if @xmath293 maps a node @xmath299 of type @xmath300 to a node @xmath301 of type @xmath302 , then we will have @xmath303 .",
    "assume that @xmath293 is already constructed and let @xmath299 of type @xmath300 be a leaf of @xmath304 .",
    "let @xmath305 be of type @xmath302 ; it is a leaf of @xmath306 .",
    "then we have @xmath307 and hence for every equivalence class @xmath263 of @xmath37 we have @xmath308 .",
    "we can therefore find a bijection @xmath309 between the languages @xmath310 and @xmath311 such that @xmath312 for all @xmath313 .",
    "note that the nodes @xmath314 with @xmath315 are the children of @xmath33 in the tree @xmath295 .",
    "we now extend the isomorphism @xmath293 by @xmath309 and do this for all leaves @xmath299 of @xmath304 .",
    "this gives us the isomorphism @xmath316 .",
    "[ coro - nfa - prefix ] the following problem belongs to @xmath0 :    input : two nfas @xmath7 and @xmath8 such that @xmath244 .",
    "question : @xmath245 ?    in exponential time , we can transform @xmath7 and @xmath8 into dfas using the powerset construction",
    ". then we can apply theorem  [ thm : upper - bound - p ] .",
    "[ thm : pspace - acyclic ] the following problem belongs to @xmath2 :    input : two acyclic nfas @xmath7 and @xmath8 such that @xmath244 .",
    "question : @xmath245 ?",
    "by @xcite , isomorphism for finite trees , given explicitly by adjacency lists , can be decided in deterministic logspace .",
    "hence , by lemma  [ pspace ] it suffices to show that for a given acyclic nfa , the adjacency list representation for the tree @xmath317 can be computed by a @xmath2-transducer .",
    "this is straightforward .",
    "assume that @xmath13 is the alphabet of @xmath19 and that @xmath67 is the number of states of @xmath19 .",
    "let us fix an arbitrary order on @xmath13 and let @xmath156 be the largest symbol in @xmath13 .",
    "the language @xmath101 only contains words of length at most @xmath318 . in an outer loop",
    "we generate the language @xmath101 . for this",
    ", we enumerate all words ( e.g. in lexicographic order ) of length at most @xmath318 and test whether the current word is accepted by @xmath19 .",
    "for each enumerated word @xmath319 , we have to output a list of all children of @xmath27 in the tree @xmath317 .",
    "in an inner loop , we enumerate ( again in lexicographic order ) all words @xmath216 ( @xmath320 ) of length at most @xmath318 and check whether @xmath321 . in case ,",
    "we find such a word @xmath321 , we output @xmath216 and do the following : if @xmath322 , then the inner loop terminates . on the other hand , if @xmath323 , where @xmath324 , then we jump in the inner loop to the word @xmath325 , where @xmath326 is the symbol following @xmath23 in our order",
    "the main result of this section states that the isomorphism problem for regular trees that are represented by nfas is @xmath0-hard , which matches the upper bound from the previous section .",
    "it is straightforward to prove @xmath2-hardness .",
    "if @xmath13 is the underlying alphabet of a given nfa @xmath19 , then @xmath317 is a full @xmath327-ary tree if and only if @xmath328 .",
    "but universality for nfas is @xmath2-complete @xcite .",
    "the proof for the @xmath0 lower bound is more involved .",
    "here is a rough outline : @xmath0 coincides with alternating polynomial space @xcite .",
    "checking whether a given input is accepted by a polynomial space bounded alternating turing machine @xmath84 amounts to evaluate a boolean expression whose gates correspond to configurations of @xmath84 . using a construction from @xcite , the evaluation problem for ( finite )",
    "boolean expressions can be reduced to the isomorphism problem for ( finite ) trees . in our case",
    ", the boolean expression will be infinite .",
    "nevertheless , the infinite boolean expressions we have to deal with can be evaluated because on every infinite path that starts in the root ( the output gate ) there will be either an @xmath329-gate , where one of the inputs is a @xmath330-gate , or an @xmath331-gate , where one of the inputs is a @xmath332-gate . applying the construction from @xcite to an infinite boolean expression ( that arises from our construction )",
    "will yield two infinite trees , which are isomorphic if and only if our boolean expression evaluates to @xmath332 .",
    "luckily , these two trees turn out to be regular , and they can be represented by small nfas .",
    "let us fix the alphabet @xmath333 in the following , we will only consider _ prefix - closed _ trees over the alphabet @xmath334 ( we will not mention this explicitly all the time ) .",
    "moreover , we will identify the tree @xmath144 with the language @xmath6 .",
    "now , consider such a tree @xmath335 .",
    "then , @xmath4 is _ well - formed _",
    ", if the following conditions hold :    a.   if @xmath336 or @xmath337 ends with @xmath338 , @xmath339 , @xmath340 , or @xmath341 , then @xmath342 is one of the following sets , where @xmath343 : @xmath344 , @xmath345 , @xmath346 . b.   if @xmath337 ends with @xmath23 , @xmath347 , or @xmath348 , then @xmath27 is a leaf of @xmath4 . c.   for every infinite path @xmath349 in @xmath4 , there exists @xmath350 with @xmath351",
    "note that a well - formed tree @xmath4 is always infinite ; it contains an infinite path of the form @xmath352 , where @xmath353 for all @xmath354 .",
    "let us define the set @xmath355 hence , on every infinite path in @xmath4 there is a unique node from @xmath356 .    with a well - formed tree",
    "@xmath4 we associate an infinite boolean expression @xmath357 as follows : the gates of @xmath357 are the nodes of @xmath4 that do not end with @xmath23 .",
    "* the set of input gates for @xmath337 is @xmath358 . *",
    "if @xmath359 ( resp .",
    "@xmath360 ) , then @xmath27 is an @xmath331-gate ( resp .",
    "@xmath329-gate ) . * if @xmath361 and @xmath362 , then @xmath363 is a @xmath332-gate . * if @xmath361 and @xmath364 , then @xmath363 is a @xmath330-gate . * if @xmath365 and @xmath362 , then @xmath366 is a @xmath330-gate . * if @xmath365 and @xmath364 , then @xmath366 is a @xmath332-gate .",
    "although @xmath357 is an infinite boolean formula , the fact that @xmath4 is well - formed ensures that the root of @xmath357 can be evaluated : we simply remove from @xmath4 all nodes that have a proper prefix from @xmath356 .",
    "the resulting tree has no infinite path and since it is finitely branching it is finite by knig s lemma . if @xmath367 is such that @xmath361 ( resp .",
    ", @xmath365 ) , then @xmath27 can be transformed into a @xmath330-gate ( resp . , @xmath332-gate ) .",
    "then , one has to evaluate the resulting finite boolean expression .",
    "we next transform a tree @xmath335 into trees @xmath368_1 , [ t]_2 \\subseteq \\{\\ell , r\\}^*$ ] using two rational transducers .",
    "these two transducers only differ in their initial state . for @xmath298 ,",
    "let @xmath369 be the transducer from figure  [ fig : trans ] , where the initial state is @xmath370 and all states are final .",
    "then , for a tree @xmath335 and @xmath298 let @xmath368_i = { \\mathsf{pref}}({\\mathcal{t}}_i(t))$ ] . we will show that for every well - formed tree @xmath335 : @xmath357 evaluates to true if and only if @xmath368_1 \\cong [ t]_2 $ ] .",
    "( lemma  [ lemma_inf : toran ] ) for this , we first have to show a few lemmas .",
    "( 100,65)(0,-20 ) ( 1)(35,25)@xmath300 ( 2)(65,25)@xmath302 ( s)(50,-15)@xmath371 ( 1)@xmath372 r_\\wedge| &          \\!r\\ell \\\\[1 mm ] \\ell_\\vee| & \\!\\ell^2 \\\\[1 mm ]   r_\\vee| & \\!r^2\\ell \\end{array}$ ] ( 2)@xmath372 r_\\wedge| &          \\!r\\ell \\\\[1 mm ] \\ell_\\vee| & \\!r\\ell \\\\[1 mm ]   r_\\vee| &          \\!r^2\\ell \\end{array}$ ] ( 1,2)@xmath373   r_\\vee| & \\!\\ell r\\ell \\end{array}$ ] ( 2,1)@xmath374   r_\\vee| & \\!\\ell r\\ell \\end{array}$ ] ( 1,s)@xmath375   \\ell'_\\vee | & \\ ! r\\ell^2 \\\\[1 mm ]   \\ell'_\\wedge | & \\ ! \\ell \\\\[1 mm ]   a | & \\ ! \\ell^3 \\end{array}$ ] ( 2,s)@xmath375   \\ell'_\\vee | & \\ ! r\\ell^2 \\\\[1 mm ]   \\ell'_\\wedge | & \\ ! \\ell \\\\[1 mm ]   a | & \\ ! \\ell^3 \\\\[1 mm ]   a | & \\ ! \\ell r \\end{array}$ ]    [ lemma_inf:1 ] let @xmath376 or @xmath377 for a tree @xmath378 ( hence , also @xmath4 is a tree ) .",
    "then @xmath368_1 \\cong [ t]_2 $ ] if and only if @xmath379_1 \\cong [ u]_2 $ ] .",
    "we only prove the lemma for @xmath376 ; the statement for @xmath380 can be shown analogously .",
    "let us compute compute @xmath381 and @xmath382 .",
    "we have @xmath383 next , we have to compute @xmath384 .",
    "there are two transitions starting in @xmath300 , where @xmath340 can be read , namely @xmath385 hence , we get @xmath386 similarly , we get @xmath387 from , , and it follows that the trees @xmath368_i = { \\mathsf{pref}}({\\mathcal{t}}_i(\\{\\varepsilon , \\ell'_\\vee\\ } \\cup r_\\vee u))$ ] ( @xmath298 ) are the ones shown in figure  [ fig : lemma_inf:1 ] . the equivalence of @xmath368_1 \\cong [ t]_2 $ ] and @xmath379_1 \\cong [ u]_2 $ ] is obvious from these diagrams .",
    "( 111,40)(0,15 ) ( root)(22,50 ) ( l)(8,36 ) ( r)(36,36 ) ( root , l)@xmath388 ( root , r)@xmath389 ( ll)(0,28 ) ( lr)(16,28 ) ( rl)(28,28 ) ( rr)(44,28 ) ( l , ll)@xmath388 ( l , lr)@xmath389 ( r , rl)@xmath388 ( r , rr)@xmath389 ( lrl)(16,22)@xmath379_2 $ ] ( rrl)(44,22)@xmath379_1 $ ] ( lr , lrl)@xmath388 ( rr , rrl)@xmath388 ( 16,22)(9,12)(23,12 ) ( 44,22)(37,12)(51,12 ) ( rll)(28,22 ) ( rl , rll)@xmath388 ( root)(82,50 ) ( l)(68,36 ) ( r)(96,36 ) ( root,l)@xmath388 ( root,r)@xmath389 ( ll)(60,28 ) ( lr)(76,28 ) ( rl)(88,28 ) ( rr)(104,28 ) ( l,ll)@xmath388 ( l,lr)@xmath389 ( r,rl)@xmath388 ( r,rr)@xmath389 ( lrl)(76,22)@xmath379_1 $ ] ( rrl)(104,22)@xmath379_2 $ ] ( lr,lrl)@xmath388 ( rr,rrl)@xmath388 ( 76,22)(69,12)(83,12 ) ( 104,22)(97,12)(111,12 ) ( rll)(88,22 ) ( rl,rll)@xmath388    the following three lemmas can be shown with the same kinds of arguments as for lemma  [ lemma_inf:1 ] .",
    "we therefore only sketch the proofs .",
    "[ lemma_inf:2 ] let @xmath390 for a tree @xmath378 ( hence , also @xmath4 is a tree ) .",
    "then @xmath368_1 \\cong [ t]_2 $ ] .",
    "we have @xmath391 and @xmath392 .",
    "it follows , that the trees @xmath368_1 $ ] and @xmath368_2 $ ] are as shown in figure  [ fig : lemma_inf:2 ] . clearly , we have @xmath368_1 \\cong [ t]_2 $ ] .",
    "( 111,40)(0,15 ) ( root)(22,50 ) ( l)(8,36 ) ( r)(36,36 ) ( root , l)@xmath388 ( root , r)@xmath389 ( ll)(0,28 ) ( lr)(16,28 ) ( rl)(28,28 ) ( rr)(44,28 ) ( l , ll)@xmath388 ( l , lr)@xmath389 ( r , rl)@xmath388 ( r , rr)@xmath389 ( lll)(0,22 ) ( lrl)(16,22)@xmath379_2 $ ] ( rrl)(44,22)@xmath379_1 $ ] ( ll , lll)@xmath388 ( lr , lrl)@xmath388 ( rr , rrl)@xmath388 ( 16,22)(9,12)(23,12 ) ( 44,22)(37,12)(51,12 ) ( rll)(28,22 ) ( rl , rll)@xmath388 ( root)(82,50 ) ( l)(68,36 ) ( r)(96,36 ) ( root,l)@xmath388 ( root,r)@xmath389 ( ll)(60,28 ) ( lr)(76,28 ) ( rl)(88,28 ) ( rr)(104,28 ) ( l,ll)@xmath388 ( l,lr)@xmath389 ( r,rl)@xmath388 ( r,rr)@xmath389 ( lll)(60,22 ) ( lrl)(76,22)@xmath379_1 $ ] ( rrl)(104,22)@xmath379_2 $ ] ( ll,lll)@xmath388 ( lr,lrl)@xmath388 ( rr,rrl)@xmath388 ( 76,22)(69,12)(83,12 ) ( 104,22)(97,12)(111,12 ) ( rll)(88,22 ) ( rl,rll)@xmath388    [ lemma_inf:3 ] let @xmath393 for a tree @xmath378 ( hence , also @xmath4 is a tree ) . then @xmath368_1 \\not\\cong [ t]_2 $ ] .    the trees @xmath368_1 $ ] and @xmath368_2 $ ] are shown in figure  [ fig : lemma_inf:3 ] . clearly , we have @xmath368_1 \\not\\cong [ t]_2 $ ] .",
    "( 115,26)(-5,15 ) ( root)(22,36 ) ( l)(14,28 ) ( ll)(14,22 ) ( lll)(14,16 ) ( r)(30,28 ) ( root , l)@xmath388 ( l , ll)@xmath388 ( ll , lll)@xmath388 ( root , r)@xmath389 ( rl)(30,22)@xmath379_1 $ ] ( r , rl)@xmath388 ( 30,22)(25,12)(35,12 ) ( root)(82,36 ) ( l)(74,28 ) ( r)(90,28 ) ( ll)(68,22 ) ( lr)(80,22 ) ( lll)(68,16 ) ( root,l)@xmath388 ( l,ll)@xmath388 ( l,lr)@xmath389 ( ll,lll)@xmath388 ( root,r)@xmath389 ( rl)(90,22)@xmath379_2 $ ] ( r,rl)@xmath388 ( 90,22)(85,12)(95,12 )    [ lemma_inf:4 ] let @xmath394 for well - formed trees @xmath395 ( hence , also @xmath4 is well - formed ) . then @xmath368_1 \\cong [ t]_2 $ ] if and only if @xmath396_1 \\cong [ u]_2 $ ] or @xmath397_1 \\cong [ v]_2)$ ] .    the trees @xmath368_1 $ ] and @xmath368_2 $ ] are shown in figure  [ fig : lemma_inf:4 ] . since @xmath378 and @xmath398 are well - formed , in each of the trees @xmath379_1 $ ] , @xmath379_2 $ ] , @xmath397_1 $ ] , and @xmath397_2 $ ] , the root has two children .",
    "it follows easily that @xmath368_1 \\cong [ t]_2 $ ] if and only if ( @xmath379_1 \\cong [ u]_2 $ ] or @xmath397_1 \\cong [ v]_2 $ ] ) .",
    "( 115,40)(-5,15 ) ( root)(22,50 ) ( l)(8,36 ) ( r)(36,36 ) ( root , l)@xmath388 ( root , r)@xmath389 ( ll)(0,28)@xmath379_1 $ ] ( lr)(16,28 ) ( rl)(28,28)@xmath379_2 $ ] ( rr)(44,28 ) ( l , ll)@xmath388 ( l , lr)@xmath389 ( r , rl)@xmath388 ( r , rr)@xmath389 ( lrl)(16,22)@xmath397_2 $ ] ( rrl)(44,22)@xmath397_1 $ ] ( lr , lrl)@xmath388 ( rr , rrl)@xmath388 ( 0,28)(-5,18)(5,18 ) ( 28,28)(23,18)(33,18 ) ( 16,22)(11,12)(21,12 ) ( 44,22)(39,12)(49,12 ) ( root)(82,50 ) ( l)(68,36 ) ( r)(96,36 ) ( root,l)@xmath388 ( root,r)@xmath389 ( ll)(60,28)@xmath379_1 $ ] ( lr)(76,28 ) ( rl)(88,28)@xmath379_2 $ ] ( rr)(104,28 ) ( l,ll)@xmath388 ( l,lr)@xmath389 ( r,rl)@xmath388 ( r,rr)@xmath389 ( lrl)(76,22)@xmath397_1 $ ] ( rrl)(104,22)@xmath397_2 $ ] ( lr,lrl)@xmath388 ( rr,rrl)@xmath388 ( 60,28)(55,18)(65,18 ) ( 88,28)(83,18)(93,18 ) ( 76,22)(71,12)(81,12 ) ( 104,22)(99,12)(109,12 )    [ lemma_inf:5 ] let @xmath399 for well - formed trees @xmath395 ( hence , also @xmath4 is well - formed ) .",
    "then @xmath368_1 \\cong [ t]_2 $ ] if and only if @xmath396_1 \\cong [ u]_2 $ ] and @xmath397_1 \\cong [ v]_2)$ ] .    the trees @xmath368_1 $ ] and @xmath368_2 $ ] are as shown in figure  [ fig : lemma_inf:5 ] .",
    "since @xmath378 and @xmath398 are well - formed , in each of the trees @xmath379_1 $ ] , @xmath379_2 $ ] , @xmath397_1 $ ] , and @xmath397_2 $ ] , the root has two children .",
    "it follows easily that @xmath368_1 \\cong [ t]_2 $ ] if and only if ( @xmath379_1 \\cong [ u]_2 $ ] and @xmath397_1 \\cong [ v]_2 $ ] ) .    ( 115,26)(-5,15 ) ( l)(22,36 ) ( ll)(14,28)@xmath379_1 $ ] ( lr)(30,28 ) ( l , ll)@xmath388 ( l , lr)@xmath389 ( lrl)(30,22)@xmath397_1 $ ] ( lr , lrl)@xmath388 ( 14,28)(9,18)(19,18 ) ( 30,22)(25,12)(35,12 ) ( l)(82,36 ) ( ll)(74,28)@xmath379_2 $ ] ( lr)(90,28 ) ( l,ll)@xmath388 ( l,lr)@xmath389 ( lrl)(90,22)@xmath397_2 $ ] ( lr,lrl)@xmath388 ( 74,28)(69,18)(79,18 ) ( 90,22)(85,12)(95,12 )    [ lemma_inf : toran ] for every well - formed tree @xmath335 , we have : @xmath357 evaluates to true if and only if @xmath368_1 \\cong [ t]_2 $ ] .    recall the definition of the set @xmath356 from . from the definition it follows that @xmath400 is a finitely branching tree without infinite paths .",
    "hence , by knig s lemma it is finite .",
    "moreover , for every @xmath401 , the subtree @xmath402 is well - formed as well ( since @xmath403 ) .",
    "inductively over the height of @xmath401 in the finite tree @xmath400 , we will prove for every @xmath401 : @xmath404_1 \\cong [ t{\\mathord\\restriction}_u]_2 $ ] if and only if @xmath405 evaluates to @xmath332 .    for the induction base , let @xmath367 be a leaf of @xmath400 .",
    "hence , we have @xmath351 .",
    "if @xmath361 , then in @xmath405 , the root is an @xmath329-gate for which one of the inputs ( namely @xmath406 ) is a @xmath330-gate .",
    "hence , @xmath405 evaluates to @xmath330 .",
    "moreover , lemma  [ lemma_inf:3 ] implies that @xmath404_1 \\not\\cong [ t{\\mathord\\restriction}_u]_2 $ ] . on the other hand ,",
    "if @xmath365 , then in @xmath405 , the root is an @xmath331-gate for which one of the inputs ( namely @xmath407 ) is a @xmath332-gate .",
    "hence , @xmath405 evaluates to @xmath332 .",
    "moreover , lemma  [ lemma_inf:2 ] implies that @xmath404_1 \\cong [ t{\\mathord\\restriction}_u]_2 $ ] .",
    "this concludes the induction base .",
    "next , let @xmath401 be a proper prefix of a node from @xmath356 . in particular @xmath408 .",
    "we can distinguish 4 different cases :    _ case 1 .",
    "_ @xmath409 .",
    "we must have @xmath410 .",
    "hence , the induction hypothesis ( ih ) holds for @xmath411 and @xmath412 .",
    "we get : @xmath413_1 \\cong [ t{\\mathord\\restriction}_{u\\ell_\\wedge}]_2         \\text { and } \\\\ & &   [ t{\\mathord\\restriction}_{ur_\\wedge}]_1 \\cong [ t{\\mathord\\restriction}_{ur_\\wedge}]_2 \\\\ & \\stackrel{\\text{lemma~\\ref{lemma_inf:5}}}{\\longleftrightarrow } &         [ t{\\mathord\\restriction}_u]_1 \\cong [ t{\\mathord\\restriction}_u]_2\\end{aligned}\\ ] ] _ case 2 . _ @xmath414 .",
    "this case is analogous to case 1 , using lemma  [ lemma_inf:4 ] .",
    "_ @xmath415 . since @xmath408 , we have @xmath362",
    ". we must have @xmath416 .",
    "moreover , in @xmath405 , the root is an @xmath329-gate , where one of the inputs is a @xmath332-gate and the other input is the root for the boolean expression @xmath417 .",
    "hence , we get : @xmath418_1 \\cong [ t{\\mathord\\restriction}_{ur_\\wedge}]_2 \\\\ & \\stackrel{\\text{lemma~\\ref{lemma_inf:1}}}{\\longleftrightarrow } &         [ t{\\mathord\\restriction}_u]_1 \\cong [ t{\\mathord\\restriction}_u]_2\\end{aligned}\\ ] ] _ case 4 . _ @xmath419 .",
    "this case is analogous to case 3 .",
    "our last auxiliary lemma states that an nfa for the tree @xmath420_i$ ] can be easily computed from an nfa for @xmath6 .",
    "[ prop : transducer ] there is a logspace machine that computes from a given prefix - closed nfa @xmath19 with terminal alphabet @xmath334 a prefix - closed nfa @xmath102 such that @xmath421_i$ ] for @xmath298 .",
    "let @xmath422 .",
    "recall that all states of @xmath369 and @xmath19 are final .",
    "the prefix - closed nfa @xmath102 is obtained from the direct product of @xmath19 and @xmath369 by adding further states so that every transition is labeled with a single symbol .",
    "thus , the set of states of @xmath102 contains @xmath423 and the initial state of @xmath102 is @xmath424 .",
    "if @xmath425 in @xmath19 and @xmath426 in @xmath369 for @xmath427 , then we add @xmath428 many new states to @xmath102 , which built up a @xmath24-labeled path from from @xmath429 to @xmath430 .",
    "we are now in the position to prove the main result of this section .",
    "[ thm : exptime - hard ] the following problem is @xmath0-hard ( and hence @xmath0-complete ) :    input : two prefix - closed nfas @xmath7 and @xmath8 .",
    "question : @xmath245 ?",
    "the upper bound is stated in corollary  [ coro - nfa - prefix ] . for the lower",
    "bound we use the fact that @xmath0 equals the class of all sets that can be accepted in polynomial space on an alternating turing machine @xcite .",
    "hence , let @xmath84 be a polynomial space bounded alternating turing machine such that the accepted language @xmath431 is @xmath0-complete .",
    "we can assume that @xmath84 has no infinite computation paths . by padding inputs",
    ", we can moreover assume that @xmath84 works in space @xmath67 for an input of length @xmath67 .",
    "let @xmath432 be the set of states of @xmath84 and let @xmath433 be the tape alphabet .",
    "we can assume that in every computation step , @xmath84 moves from an existential state to a universal state or vice versa , and that the initial state @xmath99 is universal .",
    "let us now fix an input @xmath434 of length @xmath67 .",
    "we will construct two prefix - closed nfas @xmath7 and @xmath8 such that @xmath435 if and only if @xmath436 .",
    "let @xmath437 . as usual , a configuration of @xmath84",
    "can be represented by a string from the language @xmath438 ( more precisely , from @xmath439 ) .",
    "a word @xmath440 is a _ valid computation of @xmath84 on input @xmath24 _ if @xmath27 is of the form @xmath441 for some @xmath442 such that the following holds :    * @xmath443 for all @xmath228 * @xmath444 ( i.e. , @xmath445 is a successor configuration of @xmath446 ) for all @xmath447 * @xmath448    note that @xmath117 is a valid computation in this sense . it is well known that from @xmath24 one can construct in logspace a coaccessible nfa @xmath449 such that @xmath449 accepts all words over @xmath450 that are _ not _ a valid computation of @xmath84 on @xmath24 @xcite .",
    "next , we will define a regular well - formed tree @xmath451 ( depending only on @xmath24 ) such that @xmath452 evaluates to @xmath332 if and only if @xmath435 . in the following ,",
    "we identify the symbols in @xmath450 with the integers @xmath453 in an arbitrary way .",
    "we can assume that @xmath454 .",
    "we define two morphisms @xmath455 as follows ( @xmath456 ) : @xmath457 for @xmath458 , let @xmath459 be the mapping @xmath460 ( resp .",
    "@xmath461 ) if @xmath32 is odd ( resp . , even ) . similarly , for @xmath462 , let @xmath463 be @xmath464 ( resp .",
    "@xmath465 ) if @xmath32 is odd ( resp . , even ) . then , the tree @xmath451 is @xmath466 , where @xmath467 clearly , @xmath468 is regular , and a prefix - closed nfa for @xmath468 can be computed in logspace from @xmath24 ( using the logspace computable coaccessible nfa @xmath449 ) .    _ claim 1 : _ @xmath468 is well - formed .",
    "_ proof of claim  1 : _ the first three conditions for well - formed trees are easy to check . for the last condition",
    ", we have to consider an arbitrary infinite path @xmath349 of @xmath468 and show that there exists @xmath469 such that @xmath364 . but this means that @xmath27 is of the form @xmath470 with @xmath442 , @xmath471 , and @xmath472 .",
    "the latter condition means that @xmath441 is not a valid computation of @xmath84 on input @xmath24 .",
    "claim  1 now follows from the fact that for every infinite sequence @xmath473 with @xmath474 for @xmath354 there exists @xmath225 such that @xmath441 is not a valid computation of @xmath84 on input @xmath24 ( since @xmath84 does not have infinite computation paths ) .",
    "_ claim 2 : _ @xmath435 if and only if @xmath452 evaluates to @xmath332 .",
    "_ proof of claim  2 : _ let us consider the _",
    "tree @xmath475 . for every node @xmath476 with @xmath442 and @xmath471 we will prove ( by induction on the height of @xmath309 ) the following :",
    "if @xmath441 is a valid computation of @xmath84 on input @xmath24 , then @xmath477 is an accepting configuration if and only if @xmath309 evaluates to true in @xmath452 . here , for @xmath478",
    ", we define @xmath479 as the initial configuration @xmath480 .",
    "so , assume that @xmath481 is of the above form and that @xmath441 is a valid computation of @xmath84 on input @xmath24 .",
    "assume that @xmath482 is odd ( the case that @xmath482 is even can be dealt analogously ) .",
    "thus , @xmath483 then , in @xmath452 , the input gates for the @xmath331-gate @xmath309 are @xmath484 and @xmath485 . since @xmath441 is a valid computation of @xmath84 on input @xmath24 , @xmath486 does not belong to the tree @xmath468 .",
    "hence , in @xmath452 , @xmath484 is a @xmath330-gate .",
    "thus , @xmath309 evaluates to @xmath332 if and only if @xmath485 evaluates to @xmath332 . from the structure of",
    "@xmath468 we see that the latter holds if and only if there exists @xmath487 such that @xmath488 evaluates to @xmath332 .",
    "first assume that @xmath489 is such that @xmath490 is not a valid computation .",
    "the inputs for the @xmath329-gate @xmath488 are @xmath491 and @xmath492 .",
    "since @xmath490 is not a valid computation , @xmath493 belongs to the tree @xmath468 .",
    "thus , in @xmath452 , @xmath491 is a @xmath330-gate and @xmath488 evaluates to @xmath330 .",
    "this holds for all @xmath489 such that @xmath490 is not a valid computation .",
    "hence , @xmath485 evaluates to @xmath332 if and only if there exists a configuration @xmath487 such that @xmath490 is a valid computation ( which means that @xmath489 is a successor configuration of @xmath477 ) and @xmath488 evaluates to @xmath332 in @xmath452 .",
    "now , if @xmath490 is a valid computation , then by induction , @xmath488 ( which belongs to @xmath475 as well ) evaluates to @xmath332 in @xmath452 if and only if @xmath489 is an accepting configuration of @xmath84 .",
    "we have shown that @xmath309 evaluates to @xmath332 if and only if @xmath477 has an accepting successor configuration .",
    "finally , since @xmath482 is odd , @xmath477 is an existential configuration ( recall that the initial configuration @xmath494 is universal ) .",
    "thus , indeed , @xmath309 evaluates to @xmath332 if and only if @xmath477 is accepting .",
    "this proves claim  2 .",
    "let @xmath495 and @xmath496 be the rational transducers from section  [ sec : inf - formulas ] .",
    "using lemma  [ prop : transducer ] we can compute in logspace from a prefix - closed nfa for @xmath468 two prefix - closed nfas @xmath7 and @xmath8 such that @xmath497_i$ ] for @xmath298 . by lemma  [ lemma_inf : toran ] and",
    "claim  2 , we have @xmath498 this concludes the proof of the @xmath0 lower bound .",
    "[ thm : pspace - hard ] the following problem is @xmath2-hard ( and therefore @xmath2-complete ) :    input : two prefix - closed acyclic nfas @xmath7 and @xmath8 .",
    "question : @xmath245 ?",
    "the upper bound is stated in theorem  [ thm : pspace - acyclic ] . for the lower bound",
    ", we use the same idea as in the proof of theorem  [ thm : exptime - hard ] .",
    "in fact , we will use most of the notations from that proof ; some of them will be slightly modified .",
    "this time , we use the fact that @xmath2 equals the class of all sets that can be accepted in polynomial time on an alternating turing machine . hence , let @xmath84 be a polynomial time bounded alternating turing machine such that the accepted language @xmath431 is @xmath2-complete .",
    "let @xmath499 ( a polynomial ) be the time bound and let @xmath500 .",
    "we can assume that @xmath501 is odd for all @xmath224 .",
    "we can assume again that @xmath84 works in space @xmath67 for an input of length @xmath67 .",
    "let @xmath434 be an input for @xmath84 of length @xmath67 .",
    "let us add to the alphabet @xmath334 in an additional symbol @xmath502 .",
    "the notions from section  [ sec : inf - formulas ] have to be extended to this new alphabet @xmath334 . in condition ( a ) for the definition of a well - formed tree @xmath4",
    ", we also allow the set @xmath503 for @xmath342 .",
    "moreover , every node @xmath504 is a leaf of @xmath4 .",
    "the new definition for the set @xmath356 can be overtaken from .",
    "also the boolean expression @xmath357 can be defined as in section  [ sec : inf - formulas ] ; the truth value of a leaf ending with @xmath502 is set arbitrarily ( say @xmath332 ) .",
    "finally , let us extend the two transducers @xmath495 and @xmath496 such that , from @xmath300 and @xmath302 they can read the new symbol @xmath502 and output @xmath388 and then terminate in a sink state @xmath371 .",
    "we now define the well - formed tree @xmath505 as @xmath506 , where : @xmath507 note that @xmath508 is finite .",
    "an acyclic prefix - closed nfa for @xmath508 can be produced in logspace from @xmath24 . moreover , since every word from @xmath509 is not a valid computation ( since @xmath84 terminates after @xmath510 steps ) , the boolean expression @xmath511 and @xmath452 ( where @xmath468 was defined in the proof of theorem  [ thm : exptime - hard ] ) evaluate to the same truth value .",
    "hence , using claim  2 from the proof of theorem  [ thm : exptime - hard ] , it follows that @xmath435 if and only if @xmath511 evaluates to @xmath332 . using an analogon of lemma  [ lemma_inf : toran ] , this holds if and only if @xmath512_1 \\cong [ u_w]_2 $ ] .",
    "acyclic nfas for @xmath512_1 $ ] and @xmath512_2 $ ] can be easily constructed in logspace from @xmath24 ( using an acyclic nfa for @xmath508 ) .",
    "this concludes the proof of the theorem .",
    "[ thm : p - hard ] the following problem is @xmath1-hard ( and hence @xmath1-complete ) :    input : two prefix - closed acyclic dfas @xmath7 and @xmath8 .",
    "question : @xmath245 ?",
    "the upper bound is stated in theorem  [ thm : upper - bound - p ] . for the lower bound",
    ", we reduce the @xmath1-complete monotone circuit value problem @xcite to the problem from the theorem . note that the tree @xmath317 , where @xmath19 is a prefix - closed acyclic dfa , is just the unfolding of the underlying dag ( directed acyclic graph ) in the initial of @xmath19 .",
    "vice versa , from a dag @xmath513 with a root node @xmath389 one can construct a prefix - closed acyclic dfa @xmath19 such that @xmath317 is isomorphic to the unfolding of @xmath513 in @xmath389 ( let us denote the latter tree by @xmath514 ) .",
    "one only has to associate labels to the edges of @xmath513 .",
    "hence , it suffices to construct from a given monotone circuit @xmath263 a dag @xmath513 which contains for every gate @xmath309 of @xmath263 two nodes @xmath515 such that @xmath309 evaluates to @xmath332 if and only if @xmath516 .",
    "this is straightforward for the input gates of @xmath263 . for @xmath329- and @xmath331-gates of @xmath263",
    ", we can use again the construction of @xcite .",
    "take the constructions from figure  [ fig : lemma_inf:4 ] and [ fig : lemma_inf:5 ] , where in figure  [ fig : lemma_inf:4 ] each of the subtrees @xmath379_1 $ ] , @xmath379_2 $ ] , @xmath397_1 $ ] , and @xmath397_2 $ ] is represented only once .",
    "the construction for @xmath331-gates is shown in figure  [ fig : p - hard ] .",
    "assume that the dag @xmath513 below the nodes @xmath299 , @xmath301 , @xmath517 , and @xmath518 is already constructed . here",
    "@xmath299 and @xmath301 correspond to a gate @xmath27 and @xmath517 and @xmath518 correspond to a gate @xmath52 .",
    "hence , @xmath27 ( resp . , @xmath52 ) evaluates to @xmath332 if and only if @xmath519 ( resp . , @xmath519 ) .",
    "let @xmath520 be an @xmath331-gate with inputs @xmath27 and @xmath52 .",
    "we add the nodes and edges as shown in figure  [ fig : p - hard ] .",
    "then the arguments from the proof of lemma  [ lemma_inf:4 ] show that @xmath27 or @xmath52 evaluates to @xmath332 if and only if @xmath521 .    ( 115,40)(-5,15 ) ( root)(22,50)@xmath522 ( l)(8,36 ) ( r)(36,36 ) ( root , l ) ( root , r ) ( ll)(0,28)@xmath299 ( lr)(16,28 ) ( rl)(28,28)@xmath301 ( rr)(44,28 ) ( l , ll ) ( l , lr ) ( r , rl ) ( r , rr ) ( root)(82,50)@xmath523 ( l)(68,36 ) ( r)(96,36 ) ( root,l ) ( root,r ) ( lr)(76,28 ) ( rr)(104,28 ) ( l,ll ) ( l,lr ) ( r,rl ) ( r,rr ) ( lrl)(76,22)@xmath517 ( rrl)(104,22)@xmath518 ( lr,lrl ) ( rr,rrl ) ( lr , rrl ) ( rr , lrl )",
    "in this section we study the isomorphism problem for regular words that are represented by partitioned dfas . we prove that this problem as well as the isomorphism problem for regular linear orders that are represented by dfas are @xmath1-complete .",
    "it follows that the isomorphism problem for regular linear orders that are represented by nfas can be solved in exponential time .",
    "we show that this problem is @xmath2-hard . for the case of acyclic dfas and nfas , respectively",
    ", we obtain completeness results for counting classes ( @xmath92-completeness for acyclic dfas and @xmath88-completeness for acyclic nfas ) .",
    "the main result of this section is :    [ thm : ptime - reg - words ] the following problem can be solved in polynomial time :    input : two partitioned dfas @xmath7 and @xmath8 .",
    "question : @xmath524 ?    in section  [ sec : blocks][sec : main - alg ] we prove theorem  [ thm : poly_st ] .",
    "section  [ sec : blocks ] will introduce some of the machinery from @xcite concerning blocks .",
    "blocks allow to condensate a generalized word to a coarser word ( whose elements are the blocks of the original word ) . in section  [ sec : expressions ] we will formally introduce succinct regular expressions ( expressions in form of dags ) and in section  [ sec : heilbrunner ] we will argue that heilbrunner s algorithm from @xcite allows to transform a given partitioned dfa in polynomial time into an equivalent succinct ( regular ) expression .",
    "hence , the remaining goal is to develop a polynomial time algorithm for checking whether two given succinct expressions represent isomorphic regular words .",
    "for the special case that these regular words consist of only one block ( so called primitive regular words ) , this will be accomplished in section  [ sec : equiv - primitive ] . in this step",
    ", we will make use of algorithms for straight - line programs ( succinctly represented finite words ) @xcite .",
    "finally , in section  [ sec : main - alg ] we will present a polynomial time algorithm or checking whether two given succinct expressions represent isomorphic regular words .      in this section",
    ", we will introduce the crucial notion of a block , and we recall some of the results from @xcite that we are using later .",
    "let @xmath525 be a generalized word .",
    "an _ interval _ of @xmath27 is an interval of the underlying linear order @xmath526 .",
    "a _ subword _ of @xmath27 is an interval @xmath183 of @xmath27 together with the coloring @xmath190 restricted to @xmath183 .",
    "let @xmath527 be finite .",
    "@xmath109-uniform _ subword of @xmath27 is a subword that is isomorphic to @xmath528 .",
    "a subword is _ uniform _ if it is @xmath109-uniform for some @xmath527 .",
    "a uniform subword is a _ maximal uniform subword _ if it is not properly contained in another uniform subword .",
    "now let @xmath52 be a subword such that no point of @xmath52 is contained in a uniform subword of @xmath27",
    ". then @xmath52 is _ successor - closed _",
    "if for each point @xmath249 of @xmath52 , whenever the successor and the predecessor of @xmath249 exist , they are contained in @xmath52 as well .",
    "a successor - closed subword is _ minimal _ if it does not strictly contain another successor - closed subword .",
    "following @xcite we define :    let @xmath27 be a regular word .",
    "block _ of @xmath27 is either a maximal uniform subword of @xmath27 or a minimal successor - closed subword of @xmath27 .    a regular word which consists of a single block is called _ _ primitive . _",
    "_ by @xcite a word @xmath27 is primitive if and only if it is of one of the following forms ( where @xmath529 , @xmath530 ) : a finite non - empty word , a scattered word of the form @xmath531 , a scattered word of the form @xmath532 , a scattered word of the form @xmath533 , or a uniform word ( @xmath528 for some @xmath534 ) .",
    "let @xmath535 be the set of all primitive words over @xmath13 .",
    "let @xmath27 be a regular word .",
    "each point @xmath249 of @xmath27 belongs to some unique block @xmath536 , which induces a regular ( and hence primitive ) word .",
    "moreover we can order the blocks of @xmath27 linearly by setting @xmath537 if and only if @xmath538 . the order obtained that way is denoted @xmath539 .",
    "then we extend the order @xmath539 to a generalized word @xmath540 over @xmath535 ( here it is useful to allow infinite alphabets , since @xmath535 is infinite ) , called the _ skeleton _ of @xmath27 , by labeling each block with the corresponding isomorphic word in @xmath535 .",
    "implicitly , it is shown in @xcite that for every regular word @xmath27 there exists a _ finite _ subset of @xmath535 such that every block of @xmath27 is isomorphic to a primitive word from that finite subset .",
    "moreover , @xmath540 is again a regular word .",
    "later it will be convenient to have the following renaming notion available .",
    "let @xmath398 be a finite alphabet , let @xmath541 be an injective mapping and suppose that all blocks of a regular word @xmath27 belong to the image of @xmath542 .",
    "the word @xmath52 that has @xmath543 as underlying order and each block @xmath544 of @xmath27 labeled with @xmath545 is called the @xmath542-skeleton of @xmath27 .",
    "we will need the following result from @xcite :    [ prop : skel ] let @xmath546 .",
    "let @xmath398 be a finite alphabet and let @xmath541 be injective such that all blocks of @xmath27 and @xmath52 are in the image of @xmath542",
    ". then @xmath27 and @xmath52 are isomorphic if and only if the @xmath542-skeletons of @xmath27 and @xmath52 are isomorphic .",
    "we will consider finite and infinite sequences , whose symbols are regular words and where the underlying order type is either finite , @xmath25 or @xmath151 . in the following ,",
    "when writing @xmath547 , we assume that either @xmath548 ( i.e. , @xmath547 is the finite sequence @xmath549 ) or @xmath550 ( i.e. , @xmath547 is the infinite sequence @xmath551 ) or @xmath552 ( i.e. , @xmath547 is the infinite sequence @xmath553 ) .",
    "the corresponding generalized word is @xmath554 ( either @xmath555 , or @xmath556 or @xmath557 ) .",
    "we say that two sequences @xmath547 and @xmath558 are _ equivalent _ , if the generalized words @xmath554 and @xmath559 are isomorphic",
    ". we use commas to separate the successive @xmath33 in the sequence @xmath547 in order to avoid misinterpretations .",
    "for instance @xmath560 viewed as a sequence over regular words has length two whereas @xmath561 has length 1 .",
    "of course , @xmath560 and @xmath561 are equivalent sequences .",
    "let @xmath562 be a sequence of regular words .",
    "we say that @xmath563 does not merge if the set of blocks of @xmath554 is the union of the set of blocks of the @xmath33 .",
    "if this is not the case , then we say that @xmath563 _ merges .",
    "_    in other words , @xmath563 merges if there exists a block that contains elements from two different @xmath33 . in (",
    "* corollary 32 ) it is shown that a sequence @xmath563 merges , if and only if there exists a factor @xmath564 or @xmath565 that merges .",
    "clearly if @xmath27 and @xmath52 are finite words , then @xmath566 merges . also ,",
    "@xmath567 and @xmath568 merge for every @xmath534 and @xmath569 ( in both cases , the sequence is equivalent to @xmath528 ) . on the other hand",
    ", @xmath570^\\eta , [ ab]^\\eta ) $ ] does not merge .",
    "the reason is that the blocks of @xmath571^\\eta$ ] are the copies of @xmath204 .",
    "more generally , if @xmath27 is not primitive and @xmath221 is a finite subset of regular words , then @xmath572 does not merge .    for the case of a sequence of primitive words , a complete description of merging sequences",
    "was given in @xcite . moreover ,",
    "if a sequence of primitive words merges , then it can be simplified to a non - merging sequence of primitive words . to make this more precise ,",
    "let @xmath573 be primitive words .",
    "if @xmath566 merges , then by ( * ? ? ?",
    "* lemma 24 ) either @xmath27 and @xmath52 are @xmath109-uniform for some @xmath534 or @xmath27 is right - closed and @xmath52 is left - closed . then , the regular word @xmath216 has a single block .",
    "if @xmath574 merges , then by ( * ? ? ?",
    "* lemma 24 ) either @xmath566 merges , or @xmath575 merges , or @xmath576 are @xmath109-uniform and @xmath52 is a singleton from @xmath109 .",
    "this motivates the definition of the following rewriting system @xmath37 over finite sequences over @xmath535 .",
    "[ def : systemr ] the rewriting system @xmath37 over the set @xmath535 consists of the following rules :    * @xmath577 if @xmath578 for some @xmath527 and @xmath579 * @xmath580 if one of the following holds : * * @xmath299 is right - closed , @xmath301 is left - closed and @xmath581 * * @xmath582 for some @xmath527 .    in the following",
    ", we will use some basic facts from rewriting theory , see e.g. @xcite for further details .",
    "for sequences @xmath583 and @xmath584 over @xmath223 , we write @xmath585 if there exist a rewrite rule @xmath586 and an occurrence of the sequence @xmath563 in @xmath583 such that replacing that occurrence by @xmath27 gives the sequence @xmath584 . here , @xmath583 and @xmath584 may be infinite sequences .",
    "moreover , those @xmath463 of @xmath587 that are not primitive are left untouched in the rewrite step @xmath585 .",
    "clearly , @xmath585 implies that the sequences @xmath583 and @xmath584 are equivalent .",
    "a ( possibly infinite ) sequence @xmath563 is irreducible w.r.t .",
    "@xmath37 if there does not exist a sequence @xmath588 with @xmath589 .",
    "clearly , on infinite sequences , @xmath37 can not be _ terminating _",
    "( e.g. , @xmath590 is a loop ) . on the other hand",
    ", @xmath37 is trivially terminating on finite sequences , since it is length - reducing .",
    "moreover , by analyzing overlapping left - hand sides of @xmath37 , one can easily show :    the rewriting system @xmath37 is strongly confluent ( on finite and infinite sequences ) , i.e. , for all @xmath563 , @xmath588 , @xmath591 such that @xmath589 and @xmath592 there exists @xmath583 such that ( @xmath593 or @xmath594 ) and ( @xmath595 or @xmath596 ) .    by a simple",
    "fact from rewriting theory , it follows that @xmath37 is also _ confluent _ , i.e. , for all @xmath563 , @xmath588 , @xmath591 such that @xmath597 and @xmath598 there exists @xmath583 such that @xmath599 and @xmath600 .",
    "termination ( on finite sequences ) and confluence imply that @xmath37 produces unique normal forms for finite sequences , i.e. , for every finite sequence @xmath563 there exists a unique finite sequence @xmath588 such that @xmath597 and @xmath588 is irreducible w.r.t .",
    "this @xmath588 is called the _",
    "irreducible normal form _ of @xmath563 .",
    "the following is a direct consequence of ( * ? ? ? * lemma 24 & corollary 32 ) .",
    "[ lem : merge ] let @xmath563 be a sequence of primitive words",
    ". then @xmath563 does not merge if and only if @xmath563 is irreducible w.r.t .",
    ".    we also have to verify that a sequence @xmath563 over @xmath223 containing non - primitive words does not merge .",
    "we use the definition below . note that a regular word need not have a first or last block . for instance",
    ", @xmath601 has a first block but no last block , whereas @xmath602 and @xmath603^\\eta$ ] neither have a first block nor a last block .",
    "[ def : good ] the sequence @xmath604 is _ good _ if the following conditions hold :    1 .",
    "@xmath563 is irreducible with respect to @xmath37 .",
    "2 .   for all",
    "@xmath605 we have : a.   if @xmath33 is not primitive and has a first block , then either ( @xmath606 , @xmath607 is uniform , and @xmath608 does not merge ) or ( @xmath609 , @xmath607 and @xmath610 are primitive , and @xmath611 does not merge )",
    ". b.   if @xmath33 is not primitive and has a last block , then either ( @xmath612 , @xmath613 is uniform , and @xmath614 does not merge ) or ( @xmath615 , @xmath613 and @xmath616 are primitive , and @xmath617 does not merge ) .",
    "if only ( 2 ) holds , then @xmath563 is said to be _ semi - good_.    [ lem : goodtorporper ] if @xmath563 is good , then @xmath563 does not merge .",
    "assume that @xmath563 is good but merges . by ( * ?",
    "* corollary 32 ) , one of the following cases holds :    _ case 1 . _ @xmath563 contains a factor @xmath564 that merges .",
    "if @xmath33 and @xmath613 would be both primitive , then @xmath563 would be not irreducible , which is a contradiction ( @xmath563 is good ) .",
    "hence , @xmath33 or @xmath613 must be not primitive .",
    "assume that @xmath33 is not primitive ( the other case is symmetric ) .",
    "if @xmath33 has no last block , then ( * ? ?",
    "* corollary 30(1 ) ) implies that @xmath564 does not merge , which is a contradiction .",
    "hence , we can assume that @xmath33 has a last block .",
    "but then , since @xmath563 is good , @xmath564 does not merge , which is again a contradiction .",
    "_ @xmath563 contains a factor @xmath618 that merges but neither @xmath619 nor @xmath620 merges . since @xmath563 is irreducible w.r.t .",
    "@xmath37 , it follows that @xmath621 , or @xmath616 is not primitive .",
    "the case that @xmath616 is not primitive is symmetric to the case that @xmath33 is not primitive .",
    "hence , it suffices to consider the following two subcases :    _ case 2a .",
    "_ @xmath33 is not primitive .",
    "if @xmath33 has no last block , then ( * ? ?",
    "* corollary 31(1 ) ) implies that @xmath565 does not merge , which is a contradiction .",
    "hence , we can assume that @xmath33 has a last block , call it @xmath622 .",
    "since @xmath563 is good and @xmath618 merges , @xmath613 must be uniform .",
    "if @xmath616 has no first block , then again ( * ? ? ?",
    "* corollary 31(1 ) ) implies that @xmath565 does not merge , which is a contradiction .",
    "let @xmath623 be the first block of @xmath616 .",
    "moreover , ( * ? ? ?",
    "* corollary 31(2 ) ) implies that @xmath624 merges .",
    "since @xmath564 and @xmath625 do not merge , also @xmath626 and @xmath627 do not merge .",
    "it follows ( from the form of our rewriting system @xmath37 ) that @xmath628 is uniform and @xmath613 is a singleton word .",
    "but we have already shown that @xmath613 is uniform , which is a contradiction .",
    "_ case 2b .",
    "_ @xmath613 is not primitive . then @xmath613 has more than one block and ( * ? ? ? * corollary  31(1 ) ) directly implies that @xmath618 does not merge , which is again a contradiction .",
    "[ lemma : semi - good - preserved ] if @xmath563 is semi - good and @xmath629 , then @xmath588 is semi - good as well .",
    "assume that @xmath630 is semi - good and @xmath629 .",
    "we have to show that @xmath631 is semi - good . for this , consider an @xmath632 such that @xmath633 is not primitive . since the system @xmath37 does not introduce non - primitive words , @xmath633 must have been already present in @xmath563 .",
    "let @xmath634 be the position in @xmath563 that corresponds to position @xmath635 in @xmath588 .",
    "hence , @xmath636 . by symmetry",
    "it suffices to show that condition ( 2a ) from definition  [ def : good ] holds for @xmath632 .",
    "the case that @xmath636 has no first block is clear .",
    "so , assume that @xmath33 has a first block .",
    "since @xmath563 is semi - good , we can distinguish the following two cases .",
    "_ case 1 . _",
    "@xmath606 , @xmath607 is uniform , and @xmath608 does not merge . from the form of the rewrite rules , it follows that @xmath637 .",
    "hence , @xmath638 is uniform , and @xmath639 does not merge .",
    "thus , we have shown condition ( 2a ) from definition  [ def : good ] for @xmath635 .",
    "_ case 2 . _",
    "@xmath609 , @xmath640 are primitive , and @xmath641 does not merge .",
    "we make a case distinction on the position , where the rewrite rule is applied .",
    "_ case 2a .",
    "_ @xmath642 and in the rewrite step @xmath629 , @xmath643 is replaced by @xmath644 .",
    "thus , @xmath645 is uniform .",
    "hence , @xmath646 is uniform .",
    "moreover , @xmath647 does not merge .",
    "_ case 2b .",
    "_ @xmath648 and in the rewrite step @xmath629 , @xmath649 is replaced by @xmath644 .",
    "thus , @xmath650 is uniform , @xmath651 , and @xmath652 .",
    "it follows that @xmath653 and @xmath638 are primitive , and that @xmath654 does not merge .",
    "_ case 2c .",
    "_ in the rewrite step @xmath629 , @xmath655 is replaced by @xmath644 .",
    "then , @xmath655 merges . but",
    "this contradicts the assumption that @xmath641 does not merge .    _",
    "_ @xmath642 and in the rewrite step @xmath629 , @xmath656 is replaced by @xmath644 .",
    "if @xmath657 is uniform , then @xmath658 and @xmath637 are primitive and @xmath654 does not merge . finally , assume that @xmath659 is right - closed , @xmath610 is left - closed and @xmath660 .",
    "we have @xmath637 .",
    "thus @xmath638 and @xmath653 are primitive .",
    "it remains to show that @xmath661 does not merge .",
    "we know that @xmath662 does not merge ( since @xmath663 does not merge ) .",
    "assume that @xmath664 merges .",
    "then ( since @xmath665 is primitive and scattered and @xmath607 is primitive ) @xmath665 must be right - closed and @xmath607 must be left - closed .",
    "but then , @xmath666 is right - closed as well and @xmath655 merges .",
    "this is a contradiction .",
    "hence , @xmath664 does not merge .",
    "let @xmath622 be the first block of @xmath33 .",
    "if @xmath667 merges , then by ( * ? ? ?",
    "* corollary  31(2 ) ) , @xmath668 merges .",
    "since neither @xmath664 nor @xmath669 merges , @xmath665 and @xmath622 must be uniform .",
    "but we know that @xmath665 is scattered , which leads again to a contradiction .",
    "thus , indeed @xmath667 does not merge .",
    "if the rewrite rule is applied at a position different from those considered in case 2a2d , then @xmath654 . since @xmath663 fulfills condition ( 2a ) from definition  [ def : good ] , so does @xmath670 .",
    "this concludes the proof of the lemma .",
    "lemma  [ lemma : semi - good - preserved ] implies that from a given finite semi - good sequence @xmath563 we can compute an equivalent good sequence , by computing the ( unique ) irreducible normal form of @xmath563 .",
    "regular words can be naturally described by expressions using the operations of concatenation , @xmath25-power , @xmath151-power , and shuffle .",
    "formally , the set @xmath671 of _ expressions _ over @xmath398 and @xmath13 is inductively defined as follows :    a.   @xmath672 b.   if @xmath673 ( @xmath294 ) , then @xmath674 . c.   if @xmath675 , then @xmath676 and @xmath677",
    "d.   if @xmath678 ( @xmath294 ) , then @xmath679^\\eta\\in t(v,\\sigma)$ ] .",
    "a mapping @xmath680 will be extended homomorphically to a mapping @xmath681 inductively as follows , where @xmath682 :    * @xmath683 for @xmath21 * @xmath684 * @xmath685 * @xmath686 * @xmath687^\\eta)=([f(\\alpha_1),\\ldots , f(\\alpha_n)]^\\eta$ ]    for @xmath675 we define the size @xmath688 inductively as follows :    * @xmath689 for @xmath690 * @xmath691 * @xmath692 * @xmath693^\\eta|=|\\alpha_1|+\\cdots+|\\alpha_n|+1 $ ]    a _ succinct expression system ( ses ) _ is a tuple @xmath694 such that :    * @xmath398 ( the set of variables ) and @xmath13 ( the terminal alphabet ) are disjoint finite alphabets . * @xmath695 ( for right - hand side ) is a mapping from @xmath398 to @xmath671 such that the relation @xmath696 is acyclic .",
    "the reflex transitive closure of this relation is called the _ hierarchical order _ of @xmath697 and denoted by @xmath698 .",
    "the property for @xmath695 ensures that there exists a unique mapping @xmath699 such that @xmath700 for all @xmath701 .",
    "if @xmath697 is clear from the context , we will simply write @xmath702 .    in the following a quadruple @xmath703 where @xmath704 is as above and @xmath705 ( i.e. , an ses with a distinguished start variable @xmath706 ) we will be called a _",
    "succinct expression_. in this case let us set @xmath707 .",
    "a succinct expression may be also seen as a dag ( directed acyclic graph ) , whose unfolding is an expression in the above sense .",
    "consider the succinct expression @xmath708 with @xmath709^\\eta \\qquad &    { \\mathsf{rhs}}(x_2 ) & = x_3 x_3 \\qquad &    { \\mathsf{rhs}}(x_3 ) & = x_4 x_4 \\\\ { \\mathsf{rhs}}(x_4 ) & = x_5 x_6 &   { \\mathsf{rhs}}(x_5 ) & = ab &   { \\mathsf{rhs}}(x_6 ) & = ba . \\end{aligned}\\ ] ] we have @xmath710^\\eta$ ] .",
    "the corresponding dag looks as follows :    ( 75,20 ) ( x1)(0,10)@xmath150 ( x2)(15,5)@xmath711 ( x3)(30,15)@xmath711 ( x4)(45,10)@xmath711 ( x5)(60,5)@xmath711 ( x6)(60,15)@xmath711 ( a)(75,5)@xmath23 ( b)(75,15)@xmath326 ( x1,x2 ) ( x1,x3 ) ( x2,x3 ) ( x2,x3 ) ( x3,x4 ) ( x3,x4 ) ( x4,x5)@xmath159 ( x4,x6)@xmath712 ( x5,a)@xmath159 ( x5,b)@xmath712 ( x6,a)@xmath712 ( x6,b)@xmath159    nodes labelled with @xmath711 compute the concatenation of their successor nodes . in case",
    "the order of the successor nodes matters , we specify it by edge labels .    for an ses",
    "@xmath697 we define @xmath713 an ses @xmath694 is in _ normal form _ if all right - hand sides are in @xmath714 or of the form @xmath715^\\eta$ ] for some @xmath716 .",
    "for such an ses @xmath697 , we define @xmath717 and @xmath718 for @xmath719 inductively as follows ( below , we set @xmath720 for @xmath21 ) :    * if @xmath721 ( @xmath294 , @xmath722 ) , then @xmath723 * if @xmath724 or @xmath725 , then @xmath726 * if @xmath727^\\eta$ ] , then @xmath728    [ [ straight - line - programs . ] ] * straight - line programs . *",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    a succinct expression , where all right - hand sides belong to @xmath729 is called a _ straight - line program ( slp ) _ @xcite . in this case",
    ", @xmath730 is a finite non - empty word .",
    "an slp @xmath697 can be viewed as a succinct representation of the word @xmath730 .",
    "more precisely , the length of @xmath730 may be exponential in @xmath731 .",
    "we will make heavy use of the fact that certain algorithmic problems on slp - encoded finite words can be solved in polynomial time .",
    "more precisely , we use the following results :    [ remark : slp - alg ] there exist polynomial time algorithms for the following problems :    a.   given an slp @xmath697 , calculate @xmath732 . b.   given an slp @xmath697 and a number @xmath733 ( coded in binary ) we can produce an slp @xmath734 of size @xmath735 such that @xmath736 . c.   given an slp @xmath697 and numbers @xmath737 , compute an slp @xmath734 with @xmath738 $ ] . here",
    "@xmath739 = a_i\\ldots",
    "a_j$ ] for a finite word @xmath740 .",
    "d.   given slps @xmath697 and @xmath734 decide whether @xmath741 @xcite .",
    "e.   given slps @xmath697 and @xmath734 decide whether @xmath730 is a factor of @xmath742 @xcite .    the proofs for ( a ) , ( b ) , and ( c ) are straightforward .",
    "[ [ level - systems . ] ] * 2-level systems . * + + + + + + + + + + + + + + + + + +    a _",
    "2-level system _ is a tuple @xmath743 such that the following holds ( @xmath744 denotes the restriction of a function @xmath76 to the set @xmath38 ) :    * the tuple @xmath745 is an ses ( w.l.o.g . in normal form ) over the terminal alphabet @xmath746 . *",
    "the tuple @xmath747 is an ses over the terminal alphabet @xmath13 .",
    "the set @xmath748 ( resp .",
    "@xmath746 ) is called the set of _ upper level variables _ ( _ lower level variables _ ) of @xmath697 .",
    "moreover , we set @xmath749 and call it the set of variables of @xmath697 .",
    "the ses @xmath745 is called the _ upper part of @xmath697 _ , briefly @xmath750 , and the ses @xmath747 is the _ lower part of @xmath697 _ , briefly , @xmath751 .",
    "the upper level evaluation mapping @xmath752 of @xmath697 is defined as @xmath753 .",
    "the evaluation mapping @xmath754 is defined by @xmath755 for @xmath756 and @xmath757 for @xmath758 .",
    "[ thm : heilb ] from a given partitioned dfa @xmath19 , we can compute in polynomial time a succinct expression @xmath697 such that @xmath759 .",
    "there is nothing new about the proof .",
    "we just have to follow algorithm carefully .",
    "let @xmath235 be a partitioned dfa and let @xmath760 .",
    "we can assume that every state in @xmath100 is a dead end , i.e. , does not have outgoing transitions .",
    "for this , take a new symbol @xmath761 , as well as a copy @xmath762 together with the transition @xmath763 for every final state @xmath257 .",
    "we set @xmath764 and let @xmath761 be the smallest symbol in @xmath765 .",
    "the resulting partitioned dfa produces the same generalized word as @xmath19 .",
    "so , assume that every state in @xmath100 is a dead end .",
    "we can also assume that @xmath19 is coaccessible .",
    "the variables of the succinct expression @xmath697 will be the states of @xmath19 .",
    "consider a state @xmath766 and let @xmath767 ( @xmath768 ) be all outgoing transitions for @xmath249 , where @xmath769 .",
    "let us define @xmath770 .",
    "next , consider the graph with node set @xmath81 and an edge from @xmath766 to @xmath771 if there is a transition from @xmath249 to @xmath98 .",
    "we partition this graph into its strongly connected components ( sccs ) .",
    "an scc @xmath263 is smaller than an scc @xmath513 if there exists a path from a state in @xmath263 to a state in @xmath513 ; this defines a partial order on the set of sccs .",
    "we eliminate all sccs starting with the maximal ones .",
    "when eliminating an scc @xmath263 , we define @xmath772 for each state @xmath773 .",
    "if the scc @xmath263 is a singleton set @xmath774 with @xmath775 , then we set @xmath776 .",
    "if the scc @xmath777 is a singleton set with @xmath778 , then we set @xmath779 .",
    "note that @xmath780 , since @xmath778 and @xmath19 is coaccessible .",
    "now , consider an scc @xmath263 of size @xmath781 .",
    "then every word @xmath782 ( @xmath773 ) contains at least one occurrence of a state from @xmath263 .",
    "hence @xmath782 can be factored as @xmath783 , where @xmath784 and @xmath785 do not contain occurrences of states from the scc @xmath263 ( i.e. , all states occurring in @xmath784 and @xmath785 belong to larger sccs ) , and @xmath786 starts and ends with a state from @xmath263 ( @xmath786 might consist of a single state from @xmath263 ) .",
    "define functions @xmath787 and @xmath788 as follows : @xmath789 ( resp .",
    "@xmath790 ) is the first ( resp .",
    "last ) state of the word @xmath786 .",
    "then , for every @xmath773 , the sequences @xmath791 and @xmath792 become periodic after at most @xmath793 steps .",
    "we now define regular expressions @xmath794 and @xmath795 as follows : let @xmath796 and @xmath797 be shortest sequences such that @xmath798 , @xmath799 , @xmath800 , and @xmath801 , @xmath802 .",
    "assume that @xmath803 and @xmath804 for @xmath805 , @xmath806 .",
    "then , we define @xmath807 next , let @xmath4 be the set of all regular expressions of the form @xmath808 ( @xmath809 ) such that some word @xmath782 ( @xmath773 ) contains a factor @xmath810 , where the word @xmath811 does not contain a state from @xmath263",
    ". then we finally set @xmath812^\\eta r_p$ ] for all @xmath773 .",
    "this concludes the elimination step for the scc @xmath263 . by @xcite , for every state @xmath766 we have @xmath813 .    by theorem  [ thm : heilb ] , it suffices to prove the following result in order to prove theorem  [ thm : ptime - reg - words ] .",
    "[ thm : poly_st ] the following problem can be solved in polynomial time :    input : two succinct expressions @xmath814 and @xmath815 .",
    "question : @xmath816 ?    in the next section , we will prove this result for the special case that both @xmath817 and @xmath818 are primitive .      by theorem  [ thm : heilb ] , the remaining goal is to test in polynomial time , whether two succinct expressions represent isomorphic regular words . in a first step",
    ", we accomplish this for succinct expressions that represent primitive words . in the following",
    ", @xmath13 will always refer to a _",
    "finite _ alphabet .",
    "let us first show that we can decide in polynomial time whether a succinct expression represents a primitive word .",
    "[ lem : oneblock ] given a succinct expression @xmath697 , we can decide in polynomial time whether @xmath730 is a primitive word , and in case it is we can compute in polynomial time a representation , which has one of the following forms , where @xmath819 are slps and @xmath534 ( here , we should allow also the empty word for @xmath820 ) : @xmath742 , @xmath821 , @xmath822 , @xmath823 , @xmath528 .",
    "we proceed along the hierarchical order of @xmath697 and compute for each variable @xmath38 of @xmath697 whether @xmath824 is of one of the following forms ( @xmath825 , @xmath534 , @xmath826 ) : @xmath52 , @xmath827 , @xmath828 , @xmath829 , @xmath528 , @xmath830 , @xmath831 , @xmath832 . moreover , slps for the finite words @xmath27 , @xmath52 , and @xmath24 can computed simultaneously .",
    "observe that from @xmath833 and the information already computed we can easily obtain whether @xmath824 is of such a form and in this case of which form .",
    "the following identities have to be used for shuffles ( @xmath534 , @xmath224 , @xmath225 , @xmath834 , and every @xmath33 ( @xmath228 ) has one of the forms @xmath528 , @xmath835 , @xmath836 , @xmath837 with @xmath838 ) @xmath839^\\eta \\cong \\gamma^\\eta",
    "\\\\    \\gamma^\\eta \\gamma^\\eta \\cong \\gamma^\\eta a \\gamma^\\eta \\cong ( \\gamma^\\eta)^\\omega \\cong ( \\gamma^\\eta)^{{\\overline{\\omega } } } \\cong ( \\gamma^\\eta a)^\\omega \\cong ( a \\gamma^\\eta)^{{\\overline{\\omega } } } \\cong \\gamma^\\eta \\\\    ( a \\gamma^\\eta)^\\omega   \\cong   a \\gamma^\\eta \\\\    ( \\gamma^\\eta a)^{{\\overline{\\omega } } }   \\cong   \\gamma^\\eta a \\end{gathered}\\ ] ] all these identities can be deduced from the axioms for regular expressions in @xcite . now @xmath730 is primitive if and only if @xmath840 is of one of the following forms ( @xmath825 , @xmath534 ) : @xmath52 , @xmath827 , @xmath828 , @xmath829 , @xmath528 .    for our polynomial time equivalence test for succinct expressions that represent primitive words , we need the following technical lemma .    [",
    "lem : factor ] let @xmath841 @xmath842 ) be finite words such that @xmath843 .",
    "then @xmath844 if and only if one of the following conditions hold :    * @xmath845 is a factor of @xmath846 .",
    "* @xmath847 is a factor of @xmath848 .",
    "* @xmath849 , @xmath850 , and @xmath851 is a factor of @xmath852 .",
    "* @xmath853 , @xmath854 , and @xmath855 is a factor of @xmath856 .",
    "( 110,10 ) ( 5,0)(10,5)@xmath301 ( 15,0)(10,5)@xmath518 ( 25,0)(10,5)@xmath857 ( 35,0)(10,5)@xmath857 ( 0,5)(10,5)@xmath299 ( 10,5)(10,5)@xmath299 ( 20,5)(10,5)@xmath517 ( 30,5)(10,5)@xmath858 ( 40,5)(10,5)@xmath858 ( 65,0)(10,5)@xmath299 ( 75,0)(10,5)@xmath517 ( 85,0)(10,5)@xmath858 ( 95,0)(10,5)@xmath858 ( 60,5)(10,5)@xmath301 ( 70,5)(10,5)@xmath301 ( 80,5)(10,5)@xmath518 ( 90,5)(10,5)@xmath857 ( 100,5)(10,5)@xmath857    ( 90,10 ) ( 5,0)(10,5)@xmath301 ( 15,0)(10,5)@xmath857 ( 25,0)(10,5)@xmath857 ( 0,5)(10,5)@xmath299 ( 10,5)(10,5)@xmath299 ( 20,5)(10,5)@xmath858 ( 30,5)(10,5)@xmath858 ( 50,0)(10,5)@xmath301 ( 60,0)(10,5)@xmath301 ( 70,0)(10,5)@xmath857 ( 80,0)(10,5)@xmath857 ( 55,5)(10,5)@xmath299 ( 65,5)(10,5)@xmath858 ( 75,5)(10,5)@xmath858    the four conditions from the lemma are shown in figure  [ fig : overlap1 ] and figure  [ fig : overlap2 ] .",
    "it is straightforward to show that any of these four situations implies @xmath859 .",
    "for instance , if the left situation in figure  [ fig : overlap1 ] occurs , then there exist words @xmath860 such that @xmath861 , @xmath862 , @xmath863 , @xmath864 and @xmath865 .",
    "hence , @xmath866 let us now assume that @xmath867 .",
    "we distinguish the following cases :    _ case 1 . _",
    "the occurrence of @xmath517 in @xmath868 overlaps the occurrence of @xmath518 in @xmath869 .",
    "then , either @xmath845 is a factor of @xmath846 ( if @xmath518 starts before @xmath517 ) or @xmath847 is a factor of @xmath848 ( if @xmath517 starts before @xmath518 ) , see figure  [ fig : overlap1 ] .",
    "_ case 2 . _",
    "the occurrence of @xmath517 in @xmath868 does not overlap the occurrence of @xmath518 in @xmath870 .",
    "_ case 2.1 . _",
    "the occurrence of @xmath871 in @xmath872 overlaps the occurrence of @xmath518 in @xmath873 .",
    "then , one of the following two situations occurs :    ( 60,10 ) ( -6,5)@xmath874 ( 5,0)(10,5)@xmath301 ( 15,0)(10,5)@xmath518 ( 25,0)(10,5)@xmath857 ( 35,0)(10,5)@xmath857 ( 45,0)(10,5)@xmath857 ( 0,5)(10,5)@xmath299 ( 10,5)(10,5)@xmath299 ( 20,5)(10,5)@xmath299 ( 30,5)(10,5)@xmath517 ( 40,5)(10,5)@xmath858 ( 57,5)@xmath874    ( 60,10 ) ( -6,5)@xmath874 ( 0,0)(10,5)@xmath301 ( 10,0)(10,5)@xmath301 ( 20,0)(10,5)@xmath301 ( 30,0)(10,5)@xmath518 ( 40,0)(10,5)@xmath857 ( 5,5)(10,5)@xmath299 ( 15,5)(10,5)@xmath517 ( 25,5)(10,5)@xmath858 ( 35,5)(10,5)@xmath858 ( 45,5)(10,5)@xmath858 ( 57,5)@xmath874    in the first situation , we obtain @xmath849 ( since @xmath875 is a factor of @xmath876 ) and @xmath850 ( since @xmath877 is a factor of @xmath878 ) .",
    "hence , we get the left situation shown in figure  [ fig : overlap2 ] , i.e. , @xmath879 is a factor of @xmath880 . in the second situation",
    ", we obtain @xmath853 ( since @xmath881 is a factor of @xmath882 ) and @xmath883 ( since @xmath884 is a factor of @xmath885 ) .",
    "hence , we get the right situation shown in figure  [ fig : overlap2 ] , i.e. , @xmath886 is a factor of @xmath887 .",
    "_ case 2.2 . _",
    "the occurrence of @xmath871 in @xmath868 does not overlap the occurrence of @xmath518 in @xmath869 .",
    "then @xmath871 either occurs in @xmath888 or @xmath889 .",
    "hence , @xmath890 and similarly @xmath891 . but",
    "@xmath892 implies that @xmath882 is a factor of @xmath893 .",
    "hence , the third condition from the lemma holds .",
    "[ lem : equalitytest ] given two succinct expressions @xmath894 over @xmath13 such that @xmath817 and @xmath818 are primitive words , we can decide in polynomial time whether @xmath895 .",
    "we have to distinguish the following cases :    _ case 1 .",
    "_ @xmath896 ( @xmath298 ) is finite .",
    "then @xmath895 can be checked in polynomial time by remark  [ remark : slp - alg](d ) .",
    "_ @xmath896 is @xmath897-uniform ( @xmath298 ) .",
    "then @xmath895 if and only if @xmath898 which can be checked in polynomial time .",
    "_ @xmath899 ( @xmath298 ) . by lemma  [ lem : oneblock ]",
    "we can produce slps for @xmath33 and @xmath227 ( @xmath298 ) from @xmath814 and @xmath815 , respectively , in polynomial time .",
    "let @xmath900 and @xmath901 .",
    "let @xmath902 denote the greatest common multiple of @xmath903 and @xmath904 . by replacing @xmath227 by @xmath905 ( for which we can compute an slp in polynomial time by remark  [ remark : slp - alg](b ) )",
    ", we can assume that @xmath906 . let @xmath907 .",
    "w.l.o.g assume that @xmath908 and let @xmath909",
    ". then , we can replace @xmath299 and @xmath517 by @xmath910 $ ] and @xmath911 v_1[1:k]$ ] , respectively ( we can compute slps for these words in polynomial time by remark  [ remark : slp - alg](c ) ) .",
    "hence , we can also assume that @xmath912 .",
    "but then , @xmath913 if and only if @xmath914 and @xmath915 , which can be checked in polynomial time by remark  [ remark : slp - alg](d ) .    _ case 4 .",
    "_ @xmath916 ( @xmath298 ) .",
    "this case can be dealt with analogously to case  3 .",
    "_ @xmath917 ( @xmath918 ) . by lemma  [ lem : oneblock ]",
    "we can produce slps for @xmath33 , @xmath227 , and @xmath919 in polynomial time .",
    "as in case  3 , by replacing the words @xmath920 by appropriate powers , we can enforce the condition @xmath921 .",
    "in addition , we can enforce the condition @xmath922 as follows : let @xmath923 .",
    "then we can replace @xmath227 and @xmath919 by @xmath924 $ ] and @xmath925w_i[1:\\ell - k_i]$ ] , respectively .",
    "now , that we have @xmath926 , we can check @xmath927 in polynomial time using lemma  [ lem : factor ] and remark  [ remark : slp - alg](e ) .      in this section",
    ", we will finally prove theorem  [ thm : poly_st ] .",
    "the general strategy is very similar to @xcite .",
    "we will incrementally reduce the @xmath928 of the two given succinct expressions , until one of them ( or both ) describe primitive words .",
    "this allows to use the results from the previous section .",
    "we have to analyze carefully the size of the intermediate succinct expressions . in the following",
    ", @xmath13 will always refer to a _",
    "finite _ alphabet .",
    "we will need certain nice properties of sess .",
    "a primitive ses is an ses @xmath694 such that @xmath929 is primitive for all @xmath719 .",
    "a 2-level system @xmath734 is primitive if @xmath930 is primitive .",
    "an irredundant ses is an ses @xmath694 such that @xmath931 for all @xmath932 with @xmath933 .",
    "again we say that a 2-level system @xmath734 is irredundant if @xmath930 is irredundant .",
    "one can think of a primitive and irredundant ses as a succinct representation of a finite subset of @xmath535 where @xmath934 defines an injective mapping from @xmath398 to this finite subset .",
    "hence , for a regular word @xmath27 such that all blocks belong to the image of @xmath754 , we can define the @xmath754-skeleton of @xmath27 . in the following",
    ", we will simply call it the @xmath697-skeleton of @xmath27 .",
    "a primitive and irredundant 2-level system intuitively is a system , where the terminal alphabet is a finite subset of @xmath535 ( namely the valuations of the variables of the lower part @xmath930 ) .    [",
    "remark : making - irredundant ] if a primitive 2-level system @xmath734 is not irredundant then , using lemma  [ lem : equalitytest ] , one can produce in polynomial time an irredundant 2-level system @xmath935 such that @xmath936 .",
    "indeed , if there are two different variables @xmath937 such that @xmath938 , then one has to replace @xmath221 in all right - hand sides by @xmath939 . thereafter @xmath221 can be removed from @xmath746 .",
    "note that this process does not change the set of upper level variables of @xmath734 .",
    "assume that @xmath734 is an ses or 2-level system and let @xmath940 be a ( possibly infinite ) sequence of variables of @xmath734 .",
    "we say that @xmath27 does not merge ( is good , semi - good , irreducible ) , if the sequence @xmath941 does not merge ( is good , semi - good , irreducible ) .",
    "moreover , two sequences @xmath940 and @xmath942 of variables ( possibly from two different sess or 2-level systems ) are equivalent if the sequences @xmath941 and @xmath943 are equivalent ( i.e. , @xmath944 and @xmath945 are isomorphic generalized words ) .",
    "the following definition is an adaption of the definition of a proper expression in @xcite .",
    "[ def : proper ] let @xmath946 be a primitive 2-level system . a variable @xmath947 is proper if one of the following cases holds :    1 .",
    "@xmath948 2 .",
    "@xmath949 , where @xmath950 does not merge and @xmath951 are proper .",
    "3 .   @xmath952 or @xmath725 , where @xmath939 is proper and @xmath953 does not merge .",
    "4 .   @xmath727^\\eta$ ] where @xmath951 are proper and @xmath702 is not primitive .",
    "the 2-level system @xmath734 is proper if @xmath734 is irredundant , primitive , and all variables are proper .",
    "note that the condition that @xmath953 does not merge in definition  [ def : proper](3 ) implies that @xmath954 and @xmath955 both do not merge by  ( * ? ? ?",
    "* corollary 32 ) . moreover , condition ( 4 ) from definition  [ def : proper ] means that @xmath951 are proper and at least on @xmath956 is not a single symbol .",
    "[ lem : skel ] let @xmath734 be a proper 2-level system and @xmath221 an upper level variable . then @xmath957 is the @xmath930-skeleton of @xmath702 .    the next two lemmas will be used to make a given 2-level system proper .",
    "[ cor : makegood ] given a primitive 2-level system @xmath734 and a finite semi - good sequence @xmath958 of variables of @xmath734 , we can produce in polynomial time a primitive 2-level system @xmath935 and a sequence @xmath959 of variables of @xmath935 such that the following holds :    * the upper parts of @xmath734 and @xmath935 are the same , and the lower part of @xmath935 extends the lower part of @xmath734 by at most @xmath960 many new lower level variables , whose right - hand sides have length 2 . *",
    "the sequence @xmath959 is good . *",
    "@xmath958 and @xmath959 are equivalent sequences . *",
    "the subsequence of upper level variables in @xmath958 is the same as the subsequence of upper level variables in @xmath959 .",
    "* @xmath961 .",
    "as long as the sequence @xmath958 contains a factor @xmath962 or @xmath963 , whose evaluation is a left - hand side of our rewriting system @xmath37 , we do the following :    if @xmath964 is right - closed and @xmath965 is left - closed , then we introduce a new lower level variable @xmath38 , set @xmath966 , and replace the sequence @xmath958 by the sequence @xmath967 . if @xmath968 for some @xmath534 , we continue with the sequence @xmath969 . finally ,",
    "if @xmath970 for some @xmath534 and @xmath971 , we continue with the sequence @xmath972 .",
    "we iterate this process as long as possible .",
    "[ cor : makegood2 ] given a primitive 2-level system @xmath734 and a finite irreducible sequence @xmath973 ( @xmath974 ) , where every @xmath975 is a lower level variable of @xmath734 , we can produce in polynomial time a primitive 2-level ses @xmath935 and sequences @xmath976 , @xmath977 ( @xmath442 , @xmath294 ) of lower level variables of @xmath935 such that the following holds :    * the upper parts of @xmath734 and @xmath935 are the same , and the lower part of @xmath935 extends the lower part of @xmath734 by at most one new lower level variable , whose right - hand side has length 2 . * the infinite sequence @xmath978 is irreducible .",
    "* @xmath979 and @xmath980 are equivalent sequences .",
    "* @xmath981 .",
    "assume that @xmath979 is not irreducible .",
    "since @xmath973 is irreducible , an @xmath37-reduction in the infinite sequence @xmath982 can only occur at a border between @xmath983 and @xmath984 .",
    "there are the following cases , according to the left - hand sides of the system @xmath37 .",
    "_ case 1 . _",
    "@xmath985 for some @xmath986 .",
    "then , the infinite sequence @xmath987 is irreducible and equivalent to our original sequence ( recall that @xmath974 ) .",
    "_ @xmath988 is scattered and right - closed , @xmath989 is scattered and left - closed . then , we introduce a new lower level variable @xmath38 with @xmath990 .",
    "it follows that the infinite sequence @xmath991 is irreducible and equivalent to our original sequence .",
    "_ @xmath992 , @xmath993 , @xmath994 for some @xmath534 and @xmath995 .",
    "if @xmath996 , then @xmath997 would not be irreducible ( since @xmath998 ) , which contradicts our assumptions .",
    "hence , assume that @xmath999 .",
    "then , the sequence @xmath1000 is again irreducible and equivalent to our original sequence .",
    "_ @xmath1001 , @xmath1002 , @xmath1003 for some @xmath534 and @xmath995 .",
    "this case is similar to case  3 .",
    "let @xmath734 be an ses and @xmath221 a variable with @xmath1004 .",
    "then there is a sequence of variables @xmath1005 such that @xmath1006 , @xmath1007 , and @xmath1008 .",
    "note that @xmath1009 is either primitive or a shuffle of finite words .",
    "if @xmath1010^\\eta$ ] where at least one of the @xmath33 is in @xmath1011 ( thus , @xmath1009 is not primitive ) , then this sequence is called a _ bad sequence_. if a variable @xmath221 has a bad sequence , then we say it is of _ bad shape_. otherwise it is of _ good shape_. for instance , if @xmath1012^\\eta$ ] and @xmath1013 , then @xmath221 is of bad shape .",
    "[ prop : mainsstep ] let @xmath1014 be an ses such that for every variable @xmath701 , either @xmath1015 or @xmath1016 is of the form @xmath1017 , @xmath1018 , or @xmath1019^\\eta$ ] for @xmath1020 . given @xmath734 we can produce in polynomial time a proper 2-level system @xmath1021 such that every variable @xmath719 , where @xmath1022 is not primitive , belongs to @xmath748 and for each of these variables @xmath221 we have :    a.   @xmath1023 b.   if @xmath221 is of good shape in @xmath734 , then @xmath1024 .",
    "c.   if @xmath221 is of bad shape in @xmath734 , then @xmath1025 and @xmath221 is of good shape in @xmath1026 .",
    "we can assume that @xmath742 is not primitive .",
    "we start with some preprocessing .    [ [ preprocessing . ] ] * preprocessing . * + + + + + + + + + + + + + + + +    first we transform our succinct expression @xmath734 into a 2-level system @xmath935 by collecting in @xmath746 all variables @xmath221 such that @xmath702 is primitive .",
    "this can be done in polynomial time using lemma  [ lem : oneblock ] .",
    "note that if @xmath702 is primitive and scattered , then for every @xmath939 in @xmath1016 , @xmath1027 is primitive too .",
    "but if @xmath702 is primitive and dense ( i.e. , of the form @xmath528 for some @xmath534 ) , then this is not necessarily true.^\\eta$ ] with @xmath1028^\\eta$ ] . then @xmath1029^\\eta$ ] is primitive but @xmath1027 is not primitive . ] hence , in this case we have to redefine @xmath1030 . after this process",
    "the 2-level system @xmath935 is already primitive , satisfies conditions ( a ) , ( b ) , and ( c ) in our proposition , and for all @xmath1031 the word @xmath702 is not primitive .",
    "all these properties will stay invariant throughout the remaining proof where we manipulate the system @xmath935 in order to make it proper .    before we come to the actual algorithm we transform @xmath935 for technical convenience such that for all @xmath1031 one of the following holds :    1 .",
    "@xmath1032 , 2 .",
    "@xmath1033^\\eta$ ] for some @xmath1034 , 3 .",
    "@xmath1035 , 4 .",
    "@xmath952 for @xmath1036 , 5 .",
    "@xmath725 for @xmath1036 .    in order to achieve this form",
    "we simply introduce for each upper level variable @xmath221 with @xmath1037 where @xmath1038 and @xmath1039 two variables @xmath1040 and set @xmath1041 , @xmath1042 , and @xmath1043 ( if e.g. @xmath336 , then @xmath1044 is not present ) .",
    "moreover , if a symbol @xmath21 occurs in a right - hand side of the form @xmath1017 , @xmath1018 , or @xmath1019^\\eta$ ] , then we replace that occurrence by a new @xmath746-variable with right - hand side @xmath23 .",
    "in fact , by this preprocessing all right - hand sides of the form ( 1 ) have length at most @xmath1045 .",
    "this fact will be important when we estimate the size of the final system . from now on variables in @xmath748 that have a right - hand side of form ( 1 ) or ( 2 ) are said to be of type ( 1 , 2 ) , all other variables are said to be of type ( 3 - 5 ) .    following ( * ? ? ? * proof of theorem 65 & 66 ) we will now give an algorithm that produces a proper 2-level system .",
    "we will proceed along the hierarchical order of the variables in @xmath748 where in each step we possibly add a constant number of new variables and change the right - hand sides of the old variables such that all variables are proper and of the form ( 1)(5 ) and , moreover , all old variables @xmath221 are of type ( 1 , 2 ) and fulfill the following technical condition ( tec ) :    a.   if @xmath702 has a first block , then @xmath1046 and the first variable of @xmath1016 evaluates to the first block of @xmath702 . b.   if @xmath702 has a second block and the first block is scattered , then @xmath1047 and the second variable of @xmath1016 evaluates to the second block of @xmath702 . c.   if @xmath702 has a last block then @xmath1048 and the last variable of @xmath1016 evaluates to the last block of @xmath702 .",
    "d.   if @xmath702 has a second last block and the last block is scattered , then @xmath1049 and the second last variable of @xmath1016 evaluates to the second last block of @xmath702 .",
    "we need the following claim about this property ( tec ) :    [ claim ] if @xmath1050 and @xmath1016 is good , then @xmath221 satisfies ( tec ) .    by symmetry let us only consider conditions ( a ) and ( b ) of ( tec ) .",
    "assume that @xmath1016 is a good sequence .",
    "if @xmath1051 , then lemma  [ lem : goodtorporper ] implies that the variables in @xmath1016 evaluate to the blocks of @xmath702 ( recall that @xmath1016 is good ) . hence ( a ) and ( b ) hold .",
    "next , assume that @xmath1052 .",
    "again , since @xmath1016 is good , lemma  [ lem : goodtorporper ] implies that the first two variables in @xmath1016 evaluate to the first two blocks of @xmath702 .",
    "thus , ( a ) and ( b ) hold again . if @xmath1053 , then the first variable of @xmath1016 evaluates to a non - primitive word . since @xmath1016 is good , it follows that @xmath702 does not have a first block and ( a ) and ( b ) hold .",
    "finally assume that @xmath1054 and the first two variables of @xmath1016 are @xmath1055 and @xmath1056 .",
    "then , @xmath824 is the first block of @xmath702 .",
    "since @xmath1016 is good either @xmath1057 does not have a first block or @xmath1057 has a first block , @xmath824 is uniform , and @xmath1058 does not merge . in both cases ( a ) and ( b ) are obviously satisfied .",
    "this proves the claim .",
    "[ [ actual - algorithm . ] ] * actual algorithm . * + + + + + + + + + + + + + + + + + + +    we can now outline our procedure . consider a variable @xmath756 such that every variables in @xmath1016 is either in @xmath746 or was already processed and is therefore now proper , satisfies ( tec ) , and is of type ( 1 , 2 ) .",
    "we need to distinguish on the form of the right - hand side of @xmath221 . in all of the following cases , we reset @xmath1016 either    a.   to a shuffle of variables that are already proper or b.   to a good sequence from @xmath1059 ( and all variables in that sequence are already proper ) .    in ( i ) ,",
    "@xmath221 is proper by definition  [ def : proper](4 ) ( note that @xmath702 is not primitive since @xmath756 ) . in ( ii ) it follows from lemma  [ lem : goodtorporper ] and claim  [ claim ] , that @xmath221 is proper and satisfies ( tec ) . for every other new upper level variables",
    "@xmath939 that is introduced , the right - hand side is either    a.   a non - merging sequence of ( already proper ) variables or b.   @xmath1060 or @xmath1061 , where @xmath1062 is already proper and @xmath1063 does not merge .    in both cases it follows from definition  [ def : proper ] that @xmath939 is proper too .",
    "_ @xmath1064 ( hence @xmath1016 is semi - good ) . by applying lemma  [ cor : makegood ] to @xmath1016",
    ", we can compute in polynomial time an equivalent good sequence of at most three possibly new @xmath746-variables ( and their corresponding right - hand sides ) .",
    "this sequence becomes the new right - hand side of @xmath221 .",
    "_ case 2 . _",
    "let @xmath1062 be the unique @xmath748-variable in @xmath1016 .",
    "note that @xmath1062 is one of the old variables , which has already been processed and hence is proper , of type ( 1 , 2 ) , and satisfies ( tec ) . if @xmath1066 , then we replace @xmath1062 in @xmath1016 by @xmath1067 ( if @xmath1067 is a shuffle , then we leave @xmath1062 in @xmath1016 ) . recall that @xmath1062 is proper and satisfies ( tec ) .",
    "it follows easily that the resulting new right - hand side of @xmath221 is semi - good and in @xmath1068 .",
    "thus , we can apply lemma  [ cor : makegood ] and obtain an equivalent good sequence in @xmath1069 ( as in case  1 , we will introduce new @xmath746-variables thereby ) .",
    "this good sequence will be the new right - hand side of @xmath221 .",
    "_ @xmath1070^\\eta$ ]",
    ". then there is nothing to do .",
    "recall that we assumed that @xmath702 is not primitive and hence @xmath221 is proper and satisfies the technical condition ( tec ) as @xmath702 neither has a first nor a last block .",
    "_ case 4 . _",
    "@xmath1071 for some @xmath1072 . here",
    "@xmath939 and @xmath1062 are old variables , which have already been processed and therefore are proper , of type ( 1 , 2 ) , and satisfy ( tec ) . if @xmath1073 then we replace @xmath939 in @xmath1074 by @xmath1075 ( if @xmath1075 is a shuffle , we leave @xmath939 in @xmath1074 )",
    ". we proceed analogously with @xmath1062 in @xmath1074 .",
    "since @xmath939 and @xmath1062 are proper and satisfy ( tec ) , it follows ( as in case 2 ) that the resulting new right - hand side of @xmath221 is semi - good and contains at most two variables from @xmath748 .",
    "thus we can apply lemma  [ cor : makegood ] and obtain an equivalent good sequence @xmath27 of variables with at most two variables from @xmath748 ( again , we introduce new @xmath746-variables thereby ) .",
    "now , we replace parts in the sequence @xmath27 in order to get @xmath1016 .",
    "first , assume that @xmath1076 .",
    "if @xmath1077 , then @xmath1016 simply becomes @xmath27 ( which is good ) . if @xmath1078 , then we introduce a new @xmath748-variable @xmath378 and set @xmath1079 since @xmath27 is good , both right - hand sides are good as well .",
    "second , assume that @xmath1080 with @xmath1081 . if @xmath1082 and @xmath1083 then we we simply set @xmath1084 . on the other hand , if @xmath1085 or @xmath1086 , then we introduce a new @xmath748-variable @xmath398 and set @xmath1087 ( if e.g. @xmath1085 but @xmath1088 , then @xmath1089 and @xmath1090 disappear ) . since @xmath27 is good , @xmath1016 will be good too .",
    "moreover , since @xmath27 does not merge ( by lemma  [ lem : goodtorporper ] ) , @xmath1091 does not merge as well ( @xmath1091 is not necessarily good ) .",
    "third , assume that @xmath1092 with @xmath1093 .",
    "in this case we introduce two new @xmath748-variables @xmath1094 and @xmath1095 and set @xmath1096 again , since @xmath27 is good , @xmath1016 is good as well .",
    "moreover , since @xmath27 does not merge , neither @xmath1097 nor @xmath1098 merges . note that the number @xmath67 in the right - hand side of @xmath221 above is bounded by @xmath1099 .",
    "this will be important for estimating the length of right - hands .",
    "_ @xmath952 .",
    "note that @xmath939 is either a @xmath746-variable , or it is an old @xmath748-variable , which has already been processed and hence is proper , of type ( 1 , 2 ) , and satisfies ( tec ) .",
    "we can therefore distinguish the following subcases .",
    "_ case 5(a ) .",
    "_ @xmath1100^\\eta$ ] for some @xmath1101 . then by the general identity @xmath1102 ( which follows from cantor s theorem ) , we have @xmath1103 and we set @xmath1104 .",
    "then @xmath221 is obviously proper . since we assumed that @xmath702 is not primitive @xmath702 does not have a first or a last block and ( tec ) is satisfied .",
    "_ case 5(b ) .",
    "_ @xmath1105 . let @xmath1106 with @xmath1107 and @xmath1108 .",
    "since @xmath939 is proper and satisfies ( tec ) , the infinite sequence @xmath1109 is semi - good . by applying lemma  [ cor : makegood ] to the sequence @xmath1110 of @xmath746-variables",
    ", we obtain an equivalent good sequence @xmath1111 . here",
    "@xmath24 is a sequence of ( possibly new ) @xmath746-variables such that @xmath24 represents the irreducible normal form w.r.t .",
    "@xmath37 of the sequence represented by @xmath1110 .",
    "note that @xmath1112 .",
    "we set @xmath1113 since the sequence @xmath1114 is good , also the sequence @xmath1115 is good .",
    "moreover , since @xmath1114 does not merge ( by lemma  [ lem : goodtorporper ] ) , the same holds for @xmath1116 and @xmath1117 ( so @xmath378 and @xmath398 are proper by definition ) .    _",
    "case 5(c ) .",
    "_ @xmath1118 and hence @xmath1027 is primitive . then the infinite sequence @xmath954 must be irreducible , because otherwise @xmath1027 would be either finite or uniform and @xmath1119 would be primitive . we introduce a new @xmath748-variable @xmath1062 and set @xmath1120 then @xmath1016 is good and @xmath953 does not merge .    _ case 5(d ) . _",
    "let @xmath1122 for @xmath1123 .",
    "since @xmath939 is already proper , we know that @xmath1124 is irreducible . if the infinite sequence @xmath1125 is irreducible too , then we introduce a new @xmath748-variables @xmath1062 and set @xmath1126 clearly , @xmath1016 is good and @xmath953 does not merge . on the other hand ,",
    "if @xmath1125 is not irreducible , then ( since @xmath1124 is irreducible ) , an @xmath37-reduction can only occur at a border between @xmath1127 and @xmath984 .",
    "the case that @xmath1128 for some @xmath534 can not occur ( since @xmath1124 is irreducible ) .",
    "if @xmath1129 is scattered and right - closed and @xmath989 is scattered and left - closed , then we introduce a new @xmath746-variable @xmath544 and a new @xmath748-variable @xmath1062 and set @xmath1130 it is straightforward to show that the infinite sequence @xmath1131 is irreducible .",
    "hence @xmath1016 is good and @xmath1132 does not merge .",
    "next , if @xmath1003 and @xmath1133 for some @xmath534 and @xmath569 , then @xmath1125 evaluates to @xmath528 .",
    "hence , @xmath702 is primitive , which is a contradiction . finally , if @xmath994 and @xmath1134 , then @xmath1125 evaluates to @xmath1135 and we set @xmath1136 .",
    "_ case 5(d ) .",
    "_ @xmath1137 .",
    "we apply lemma  [ cor : makegood2 ] to the irreducible sequence @xmath1075 and compute sequences @xmath27 , @xmath52 of ( possibly new ) @xmath746-variables with their corresponding right - hand sides .",
    "the infinite sequence @xmath1138 of @xmath746-variables is irreducible and evaluates to @xmath1027 .",
    "we can assume @xmath1139 ( otherwise , we can replace @xmath27 by @xmath1140 ) .",
    "we introduce new @xmath748-variables @xmath378 and @xmath398 and set @xmath1141 ( if @xmath1142 , i.e. , @xmath52 consists of a single @xmath746-variable , then we do not need @xmath378 ) .",
    "_ @xmath725 .",
    "this case is symmetric to case 4 .",
    "the resulting system @xmath935 is primitive and all @xmath748-variables are proper . on the other hand , @xmath935 is not necessarily irredundant . but this can be easily achieved as described in remark  [ remark : making - irredundant ] .",
    "we are now in the position to prove theorem  [ thm : poly_st ] .",
    "_ proof of theorem  [ thm : poly_st ] . _",
    "it suffices to show that the following problem can be solved in polynomial time :    input : an ses @xmath697 and two variables @xmath1143 of @xmath697 .",
    "question : @xmath1144 ?",
    "if both variables @xmath221 and @xmath939 evaluate to primitive words , then we just need to apply lemma  [ lem : equalitytest ] . if only one of the two evaluates to a primitive word , then @xmath1145 .",
    "hence , we may assume that both @xmath702 and @xmath1027 are not primitive .",
    "in particular , we have @xmath1146 .",
    "it is easy to bring @xmath697 into the normal form required in proposition  [ prop : mainsstep ] .",
    "applying proposition  [ prop : mainsstep ] to @xmath697 gives a proper 2-level system @xmath1147 .",
    "the variables @xmath221 and @xmath939 belong to the upper level part of @xmath1147 . starting with @xmath1147",
    "we construct a sequence of proper 2-level systems @xmath1148 ( with @xmath1149 ) . in order to obtain @xmath1150",
    "we apply the procedure of proposition  [ prop : mainsstep ] to @xmath1151 .",
    "let @xmath73 be maximal such that @xmath221 and @xmath939 belong to the upper level part of @xmath1152 .",
    "since by proposition  [ prop : mainsstep ] in every second step the @xmath928 of @xmath221 and @xmath939 strictly decreases we have @xmath1153 .",
    "let @xmath1154 .",
    "by lemma  [ lem : skel ] @xmath1155 is the @xmath1156-skeleton of @xmath1157 and similarly for @xmath939 .",
    "hence @xmath1158 if and only if @xmath1159 by proposition  [ prop : skel ] .",
    "recall that @xmath1160 is obtained by applying the procedure of proposition  [ prop : mainsstep ] to @xmath1161 .",
    "we obtain @xmath1158 if and only if @xmath1162 for all @xmath1163 . hence , @xmath1144 if and only if @xmath1164 if and only if @xmath1165 . now , by the maximality of @xmath73 , @xmath1166 or @xmath1167 must be primitive . hence , using lemma  [ lem : equalitytest ] , we can check in polynomial time whether @xmath1165 .",
    "[ [ runtime . ] ] * runtime . *",
    "+ + + + + + + + + +    let us analyze the system @xmath1168 for @xmath1169 .",
    "the 2-level system @xmath1150 is obtained by applying proposition  [ prop : mainsstep ] to @xmath1151 .",
    "observe that by the construction in the proof , the system @xmath1168 already has the normal form that we require in proposition  [ prop : mainsstep ] .",
    "let @xmath1170 be the set of variables in @xmath1171 that are of type ( 3 - 5 ) .",
    "now let us estimate the number @xmath1172 for @xmath1173 .",
    "observe that in the proof of proposition  [ prop : mainsstep ] in each of the cases ( 1)(3 ) only new lower level variables are introduced . in each of the cases ( 4)(6 )",
    "the old variable is turned into a variable of type ( 1 , 2 ) and at most one new variable of type ( 3 - 5 ) is added to @xmath1171 . moreover ,",
    "additionally at most one new variables of type ( 1 , 2 ) is added to @xmath1171 .",
    "we conclude that @xmath1174 and the total number of variables in @xmath1171 is bounded by @xmath1175 .",
    "recall that @xmath1176 .",
    "hence @xmath1177 for all @xmath1178 .",
    "let us now estimate the maximal length of a right - hand side in @xmath1150 .",
    "let us first bound the length of the right - hand side of a variable @xmath1179 ( i.e. , an old variable ) . by reanalyzing all cases from the proof of proposition  [ prop : mainsstep ]",
    ", we see that for such a variable @xmath221 , @xmath1180 is either at most 5 or it is bounded by @xmath1181 , where @xmath1182 is an old variable , which was processed before .",
    "we therefore obtain @xmath1183 .",
    "hence , @xmath1184 . for the newly added variables , @xmath1185 the size of the right - hand side is bounded by twice the maximal size of a right - hand side of an old variable in @xmath1186 ( the factor 2 comes from case  4 ) .",
    "hence @xmath1187 for all @xmath1188 .",
    "finally , note that @xmath1189 is bounded polynomially bounded in @xmath731 .    concerning lower level variables of @xmath1150 , note that the length @xmath1190 for a lower level variable of @xmath1150 is bounded by 2 ( if @xmath38 is introduced in one of the cases  16 ) or by the maximal length of the right - hand side of a variable from @xmath1191 ( if @xmath38 is introduced in the preprocessing step ) .",
    "moreover , in each of the cases  16 , the number of new lower level variables that are introduced is bounded by twice the maximal size of a right - hand side of an old variable in @xmath1186 ( the factor 2 comes again from case  4 ) .",
    "hence the number of lower level variables is also bounded polynomially in @xmath731 .",
    "we have shown that the total size of very 2-level system @xmath1150 ( @xmath1192 ) is bounded polynomially in @xmath731 . as the time needed to construct @xmath1160 from @xmath1150",
    "is polynomially bounded by proposition  [ prop : mainsstep ] , we conclude that the overall running time of our algorithm is polynomially bounded as well .      in this section",
    "we prove lower bounds for the isomorphism problem for regular words .",
    "in fact , all these lower bounds only need a unary alphabet , i.e. , they hold for regular linear orders .",
    "the results in this section nicely contrast the results from section  [ sec : reg - trees ] , where we studied the isomorphism problem for the prefix order trees on regular languages . in this section ,",
    "we replace the prefix order by the lexicographical order .",
    "[ thm : ptime - complete - st ] the following problem is @xmath1-hard ( and hence @xmath1-complete ) for every finite alphabet @xmath13 :    input : two succinct expressions @xmath814 and @xmath815 over the alphabet @xmath13 .",
    "question : @xmath816 ?",
    "note that the problem can be solved in polynomial time by theorem  [ thm : poly_st ] .",
    "@xmath1-hardness will be shown by a reduction from the monotone circuit value problem .",
    "so , let @xmath263 be a monotone boolean circuit .",
    "we can assume that the gates of @xmath263 are partitioned into layers @xmath1193 , where @xmath1194 contains all input gates , @xmath1195 only contains the output gate , and all inputs for a gate from @xmath1196 belong to @xmath1197 .",
    "moreover , @xmath1197 ( @xmath1198 ) either contains only @xmath329-gates or @xmath331-gates .",
    "we construct an ses @xmath697 ( over a unary terminal alphabet @xmath1199 ) , which contains for each gate @xmath52 of @xmath263 a variable @xmath1200 and for each layer @xmath1201 two variables @xmath1202 , and @xmath1203 such that the following holds for all gates @xmath1204 :    a.   either @xmath1205 or @xmath1206 .",
    "b.   @xmath1206 if and only if gate @xmath52 evaluates to @xmath332 .",
    "c.   the linear orders @xmath1207 and @xmath1208 do not contain an interval isomorphic to @xmath1209 ( recall that @xmath1209 denotes the linear order @xmath1210 ) .    the base case for the first layer is trivial . set @xmath1211 and @xmath1212 .",
    "in other words , @xmath1213 and @xmath1214 . moreover , @xmath1215 if @xmath1216 is a @xmath332-gate and @xmath1217 if @xmath1216 is a @xmath330-gate .    now assume that @xmath1218 is a gate with inputs @xmath1219 .",
    "for @xmath1220 we use the abbreviation @xmath1221 moreover , we write @xmath1222 for the concatenation @xmath1223 of the regular expression @xmath1224 and @xmath1225 ( which denote regular linear orders since the alphabet is unary ) .",
    "there are two cases :    _ case 1 .",
    "_ @xmath1226 consists of @xmath329-gates",
    ". then we set @xmath1227^\\eta \\\\ { \\mathsf{rhs}}_{{\\mathbb{a}}}({\\mathsf{good}}_{d+1 } ) & = &   [ \\omega\\cdot d + { \\mathsf{good}}_d]^\\eta \\\\ { \\mathsf{rhs}}_{{\\mathbb{a}}}({\\mathsf{bad}}_{d+1 } ) & = &    [ \\omega\\cdot d + { \\mathsf{good}}_d , \\omega\\cdot d + { \\mathsf{bad}}_d]^\\eta .\\end{aligned}\\ ] ]    _ case 2 .",
    "_ @xmath1226 consists of @xmath331-gates . @xmath1228^\\eta \\\\ { \\mathsf{rhs}}_{{\\mathbb{a}}}({\\mathsf{good}}_{d+1 } ) & = &   [ \\omega\\cdot d + { \\mathsf{good}}_d , \\omega\\cdot d + { \\mathsf{bad}}_d]^\\eta\\\\ { \\mathsf{rhs}}_{{\\mathbb{a}}}({\\mathsf{bad}}_{d+1 } ) & = &   [ \\omega\\cdot d + { \\mathsf{bad}}_d]^\\eta .\\end{aligned}\\ ] ] the above three properties ( a ) , ( b ) , and ( c ) can be shown by induction on the layer . for layer @xmath1194",
    "all three properties are trivially true .",
    "now , consider layer @xmath1226 .",
    "property ( a ) follows directly from the induction hypothesis for layer @xmath1229 .",
    "since the linear orders @xmath1207 and @xmath1208 are shuffles , ( c ) holds for layer @xmath1226 too .",
    "finally , for ( b ) we consider two cases :    _ case 1 .",
    "_ @xmath1218 is an @xmath329-gate .",
    "let @xmath1219 be the inputs for @xmath52 .",
    "first , assume that @xmath52 evaluates to @xmath332 .",
    "then , @xmath517 and @xmath518 both evaluate to @xmath332 .",
    "hence , by induction , we get @xmath1230 .",
    "thus , @xmath1231^\\eta \\\\ & \\cong & [ \\omega\\cdot d + { \\mathsf{val}}_{{\\mathbb{a}}}({\\mathsf{good}}_d)]^\\eta \\\\ & = & { \\mathsf{val}}_{{\\mathbb{a}}}({\\mathsf{good}}_{d+1 } ) .\\end{aligned}\\ ] ] for the other direction assume that @xmath1231^\\eta \\\\ & \\cong & [ \\omega\\cdot d + { \\mathsf{val}}_{{\\mathbb{a}}}({\\mathsf{good}}_d)]^\\eta .\\end{aligned}\\ ] ] since neither @xmath1232 nor @xmath1233 nor @xmath1207 contains an interval isomorphic to @xmath1209 , ( * ? ? ?",
    "* lemma  23 ) implies that @xmath1234 this implies @xmath1235 finally , the induction hypothesis yields that both @xmath517 and @xmath518 , and hence also @xmath52 evaluate to @xmath332 .    _ case 2 .",
    "_ @xmath1218 is an @xmath331-gate .",
    "we can use similar arguments as for case  1 .",
    "we do not know , whether the lower bound from theorem  [ thm : ptime - complete - st ] holds for ordinary expressions too ( instead of succinct expressions ) .",
    "[ thm : lower - bound - dfa - lex ] the following problem is @xmath1-hard ( and hence @xmath1-complete ) :    input : two dfas @xmath7 and @xmath8 .",
    "question : @xmath1236 ?",
    "note that by theorem  [ thm : ptime - reg - words ] the problem belongs to @xmath1 .",
    "for @xmath1-hardness , it suffices by theorem  [ thm : ptime - complete - st ] to construct in logspace from a given succinct expression @xmath697 ( over a unary terminal alphabet ) a dfa @xmath19 such that the linear order @xmath730 is isomorphic to @xmath1237 .",
    "but this is accomplished by the construction in the proof of ( * ? ? ?",
    "* proposition  2 ) .",
    "theorem  [ thm : ptime - reg - words ] implies that it can be checked in @xmath0 whether the lexicographical orderings on two regular languages , given by nfas , are isomorphic .",
    "we do not know whether this upper bound is sharp .",
    "currently , we can only prove a lower bound of @xmath2 :    [ thm : pspace - nfa - lex ] the following problem is @xmath2-hard :    input : two nfas @xmath7 and @xmath8 .",
    "question : @xmath1236 ?",
    "we prove @xmath2-hardness by a reduction from the @xmath2-complete problem whether a given nfa @xmath19 ( over the terminal alphabet @xmath1238 ) accepts @xmath1239 @xcite .",
    "so let @xmath19 be an nfa over the terminal alphabet @xmath1238 and let @xmath1240 .",
    "let @xmath1241 and fix the following order on @xmath13 : @xmath1242 under this order , @xmath1243 .",
    "it is straightforward to construct from @xmath19 in logspace nfas for the following languages : @xmath1244 it follows that @xmath1245 ( the sum is taken over all words from @xmath1246 in lexicographic order ) , where @xmath1247 hence , if @xmath1248 , then @xmath163 contains an interval isomorphic to @xmath1249 and therefore is not dense .",
    "hence @xmath1250 . on the other hand , if @xmath1251 , then @xmath1252 .",
    "this proves the theorem .",
    "the proof of theorem  [ thm : pspace - nfa - lex ] shows that it is @xmath2-hard to check for a given nfa @xmath19 , whether @xmath1253 .",
    "in fact , this problem is @xmath2-complete , since we can check in polynomial space whether @xmath1253 : in polynomial time , we can construct an nfa @xmath102 that accepts a convolution of two words and @xmath1254 is the word @xmath1255 , where @xmath1256 , @xmath1257 ( a dummy symbol ) for @xmath1258 and @xmath1259 for @xmath1260 . ]",
    "@xmath1261 if and only if @xmath1262 and there exist words @xmath1263 such that @xmath1264 and ( @xmath1265 or @xmath1266 ) . then , @xmath1253 if and only if @xmath102 accepts the set of all convolutions @xmath1261 with @xmath1262 .",
    "the latter can be checked in polynomial space .",
    "in @xcite it is shown that the problem , whether for a given context - free language @xmath6 the linear order @xmath163 is isomorphic to @xmath150 , is undecidable .",
    "this result is shown by a reduction from post s correspondence problem .",
    "note that this result can be also easily deduced using the technique from the above proof : if we start with a pushdown automaton for @xmath19 instead of an nfa , then the language @xmath6 from is context - free .",
    "hence , @xmath1267 if and only if @xmath1268 .",
    "the latter property is a well - known undecidable problem .    in section  [ sec : reg - trees ]",
    "we also studied the isomorphism problem for finite trees that are succinctly given by the prefix order on the finite language accepted by a dfa ( resp .",
    ", nfa ) . to complete the picture",
    ", we will finally consider the isomorphism problem for linear orders that consist of a lexicographically ordered finite language , where the latter is represented by a dfa ( resp .",
    ", nfa ) . of course",
    ", this problem is somehow trivial , since two finite linear orders are isomorphic if and only if they have the same cardinality .",
    "hence , we have to consider the problem whether two given acyclic dfas ( resp .",
    "nfas ) accept languages of the same cardinality .",
    "it is @xmath92-complete ( resp .",
    "@xmath88-complete ) to check whether two given acyclic dfas ( resp . , acyclic nfas ) accept languages of the same size .",
    "the upper bounds are easy : there exists a nondeterministic polynomial time ( resp .",
    ", logspace ) machine , which gets an nfa ( resp .",
    "a dfa ) @xmath19 over an alphabet @xmath13 as input , and has precisely @xmath1269 many accepting paths .",
    "let @xmath67 be the number of states of @xmath67 .",
    "the machine first branches nondeterministically for at most @xmath1270 steps and thereby produces a word @xmath1271 .",
    "then it checks whether @xmath22 and only accepts it this holds .",
    "the checking step can be done in deterministic polynomial time for an nfa and in deterministic logspace for a dfa .    for the lower bound",
    ", we first consider the dfa - case . given two nondeterministic logspace machines @xmath1272 ( over the same input alphabet ) together with an input @xmath24 we can produce in logspace the configuration graphs @xmath1273 and @xmath1274 of @xmath89 and @xmath90 , respectively , on input @xmath24 .",
    "we can assume that @xmath1273 and @xmath1274 are acyclic ( one can add a step counter to @xmath1275 ) .",
    "now , from @xmath1276 it is straightforward to construct an acyclic dfa @xmath12 such that @xmath1277 is the number of paths in @xmath1276 from the initial configuration to the ( w.l.o.g .",
    "unique ) accepting configuration .",
    "the latter number is the number of accepting computations of @xmath1275 on input @xmath24 .",
    "finally , @xmath88-hardness for nfas follows from ( * ? ? ?",
    "* theorem  2.1 ) , where it was shown that counting the number of words accepted by an nfa is @xmath1278-complete .",
    "let us briefly discuss the isomorphism problem for ordered regular trees , i.e. , regular trees , where the children of a node are linearly ordered .",
    "an ordered tree can be viewed as a triple @xmath1279 , where @xmath1280 is a tree as defined in section  [ sec : trees ] and the binary relation @xmath37 is the disjoint union of relations @xmath1281 ( @xmath39 ) , where @xmath1281 is a linear order on the children of @xmath23 .",
    "now , assume that @xmath19 is a ( deterministic or nondeterministic ) finite automaton with input alphabet @xmath13 and let @xmath1282 be a linear order on @xmath13 .",
    "assume that @xmath1283 .",
    "then , we can define a finitely branching ordered regular tree @xmath1284 with @xmath19 as follows : @xmath1285 where @xmath1286 is the relation @xmath1287 this means that we order the children of a node @xmath319 lexicographically . in the following , we will omit the order @xmath1282 on the alphabet .",
    "the proof of the following result combines ideas from the proof of theorem  [ thm : upper - bound - p ] with theorem  [ thm : ptime - reg - words ] .",
    "[ prop : ordered - trees - p ] the following problem is @xmath1-complete :    input : two dfas @xmath7 and @xmath8 with @xmath244 .",
    "question : @xmath1288 ?    similarly to the proof of theorem  [ thm : upper - bound - p ] , it suffices to take a dfa @xmath1289 without initial state and two states @xmath1290 , and to check in polynomial time , whether @xmath1291 , where @xmath1292 for @xmath1293 .",
    "define the following equivalence relation on @xmath100 : @xmath1294 we show that @xmath275 can be computed in polynomial time . as in the proof of theorem  [ thm : upper - bound - p",
    "] , this will be done with a partition refinement algorithm .",
    "we need a few definitions .",
    "recall from the proof of theorem  [ thm : upper - bound - p ] the definition of the languages @xmath1295 and @xmath262 for @xmath252 and @xmath261 .",
    "assume that @xmath37 is an equivalence relation on @xmath100 and let @xmath482 be the number of equivalence classes of @xmath37 .",
    "fix an arbitrary bijection @xmath76 between the the alphabet @xmath1296 and the set of equivalence classes of @xmath37 . with @xmath37 and @xmath252",
    "we associate a partitioned dfa @xmath1297 as follows : take the dfa for the language @xmath1298 as defined in the proof of theorem  [ thm : upper - bound - p ] and set @xmath1299 ( @xmath228 ) , which is the set of final states associated with symbol @xmath32 .",
    "finally , define the regular word @xmath1300 over the alphabet @xmath1296 .",
    "we define the new equivalence relation @xmath276 on @xmath100 as follows : @xmath1301 thus , @xmath276 is a refinement of @xmath37 which , by theorem  [ thm : ptime - reg - words ] , can be computed in polynomial time from @xmath37 .",
    "let us define a sequence of equivalence relations @xmath278 on @xmath100 as follows : @xmath279 , @xmath280 .",
    "then , there exists @xmath281 such that @xmath282 .",
    "we claim that @xmath283 .    for the inclusion @xmath1302 , one shows , by induction on @xmath32 , that @xmath287 for all @xmath1303 .",
    "the point is that for every equivalence relation @xmath37 on @xmath100 with @xmath284 , we also have @xmath1304 . to see this ,",
    "assume that @xmath284 but there is @xmath1305 , which does not belong to @xmath276 . since @xmath1306 belongs to @xmath37 , we must have @xmath1307 . on the other hand , since @xmath1305 , it follows that the regular words @xmath1308 and @xmath1309 are isomorphic .",
    "but since @xmath284 , @xmath1310 is a homomorphic image of @xmath1308 and similarly for @xmath1311 .",
    "thus , also @xmath1310 and @xmath1311 are isomorphic , which is a contradiction .    for the inclusion @xmath1312",
    ", we show that if @xmath37 is an equivalence relation on @xmath100 such that @xmath288 ( this holds for @xmath289 ) , then @xmath290 . for this , take a pair @xmath1313 .",
    "take the tree @xmath1314 .",
    "we assign types in form of final states to the nodes of @xmath1314 in the same way as in the proof of theorem  [ thm : upper - bound - p ] .",
    "we now construct an isomorphism @xmath1315 as the limit of isomorphisms @xmath293 , @xmath294 . here",
    ", @xmath293 is an isomorphism between the trees that result from @xmath1316 and @xmath1317 by cutting off all nodes below level @xmath67 .",
    "let us call these trees @xmath1318 ( @xmath298 ) .",
    "moreover , if an @xmath293 maps a node @xmath299 of type @xmath300 to a node @xmath301 of type @xmath302 , then we will have @xmath303 .",
    "assume that @xmath293 is already constructed and let @xmath299 of type @xmath300 be a leaf of @xmath1319 .",
    "let @xmath305 be of type @xmath302 .",
    "then we have @xmath303 and hence the regular words @xmath1320 and @xmath1321 are isomorphic .",
    "let @xmath309 be an isomorphism .",
    "the elements of these regular words correspond to the children of @xmath299 and @xmath301 , respectively .",
    "more precisely , if @xmath227 belongs to the domain of @xmath1322 , then @xmath1323 is a child of @xmath33 and vice versa .",
    "clearly , @xmath309 can be also viewed as an isomorphism between the lexicographical orderings on the children of @xmath299 and @xmath301 , respectively . moreover , by definition of the regular words @xmath1320 and @xmath1321 , if @xmath309 maps some @xmath1324 of type @xmath1325 to @xmath1326 of type @xmath1327 , then @xmath1328 . by choosing such an isomorphism @xmath309 for every pair @xmath1329 of leaves in @xmath1319 and @xmath1330 , respectively , we can extend @xmath293 to @xmath316 .",
    "let us now consider prefix - closed automata . here",
    ", we can improve the upper bound from theorem  [ prop : ordered - trees - p ] to nl .",
    "[ prop : nl ] the following problem is nl - complete :    input : two prefix - closed dfas @xmath7 and @xmath8 .",
    "question : @xmath1288 ?",
    "again , it suffices to take a prefix - closed dfa @xmath1331 without initial state , and two states @xmath1332 , and two check in nl , whether @xmath1333 . by the complement closure of nl",
    ", it suffices to check nondeterministically in logarithmic space , whether @xmath1334 this can be done as follows : let @xmath1335 and @xmath1336 the transition labels of the outgoing transitions of @xmath249 and @xmath98 , respectively . if @xmath1337 then clearly @xmath1338 and the algorithm can accept . if @xmath1339 , then @xmath1340 if and only if there exists @xmath228 such that @xmath1341 .",
    "hence , the algorithm will simply guess @xmath228 and replace the state pair @xmath1306 by @xmath1342 . in this way",
    ", the algorithm only has to store two states of @xmath19 , which is possible in logspace .",
    "nl - hardness can be shown by a reduction from the complement of the graph accessibility problem .",
    "take a directed graph @xmath1343 and two nodes @xmath1344 .",
    "add to each node of @xmath398 loops , so that every node @xmath1345 has outdegree @xmath67 ( where @xmath67 can be taken as the maximal outdegree of a node of @xmath1346 ) and @xmath520 has outdegree @xmath1347 .",
    "then label the edges of the resulting multigraph arbitrarily by symbols so that we obtain a dfa @xmath19 ( the initial state is @xmath371 and all states are final ) .",
    "then there is no path from @xmath371 to @xmath520 in @xmath1346 if and only if the tree @xmath1348 is a full @xmath67-ary tree .",
    "the following problem is pspace - complete :    input : two prefix - closed nfas @xmath7 and @xmath8 .",
    "question : @xmath1288 ?",
    "the pspace upper bound follows from proposition  [ prop : nl ] , using lemma  [ pspace ] and the obvious fact that the power set automaton of a given nfa can be produced by a pspace - transducer . for the pspace lower bound , note that for an nfa @xmath19 over an alphabet @xmath13 we have @xmath328 if and only if @xmath1348 is a full @xmath327-ary tree .",
    "but universality for nfas is pspace - complete @xcite .",
    "table  [ tab - pref ] ( table  [ tab - lex ] ) summarizes our complexity results for the isomorphism problem for regular trees ( regular linear orders ) .",
    "let us conclude with some open problems . as can be seen from table  [ tab - lex ]",
    ", there is a complexity gap for the isomorphism problem for regular linear orders that are represented by nfas .",
    "this problem belongs to @xmath0 and is @xmath2-hard .",
    "another interesting problem concerns the equivalence problem for straight - line programs ( i.e. , succinct expressions that generate finite words , or equivalently , acyclic partitioned dfas , or equivalently , context - free grammars that generate a single word ) .",
    "plandowski has shown that this problem can be solved in polynomial time .",
    "recall that this result is fundamental for our polynomial time algorithm for succinct expressions ( theorem  [ thm : poly_st ] ) . in @xcite , it was conjectured that the equivalence problem for straight - line programs is @xmath1-complete , but this is still open .",
    "v.  brny , e.  grdel , and s.rubin .",
    "automata - based presentations of infinite structures . in _ finite and algorithmic model theory _ , number 379 in london mathematical society lecture notes series .",
    "cambridge university press , 2011 . to appear .",
    "bruno courcelle .",
    "the definability of equational graphs in monadic second - order logic . in _ proceedings of the 16th international colloquium on automata , languages and programming ( icalp 1989 ) _ , number 372 in lecture notes in computer science , pages 207221 .",
    "springer , 1989 .",
    "zoltn sik .",
    "representing small ordinals by finite automata . in _",
    "proceedings ofthe twelfth annual workshop on descriptional complexity of formal systems , dcfs 2010 _ , volume  31 of _ eptcs _ , pages 7887 , 2010 .",
    "leszek gasieniec , alan gibbons , and wojciech rytter . efficiency of fast parallel pattern searching in highly compressed texts . in m.  kutylowski , l.  pacholski , and t.  wierzbicki , editors , _ proceedings of the 24th international symposium on mathematical foundations of computer science ( mfcs99 ) , szklarska poreba ( poland ) _ , number 1672 in lecture notes in computer science , pages 4858 .",
    "springer , 1999 .",
    "leszek gasieniec , marek karpinski , wojciech plandowski , and wojciech rytter .",
    "efficient algorithms for lempel - ziv encoding ( extended abstract ) . in rolf  g. karlsson and andrzej lingas , editors , _ proceedings of the 5th scandinavian workshop on algorithm theory ( swat 1996 ) , reykjavk ( iceland ) _ , number 1097 in lecture notes in computer science , pages 392403 .",
    "springer , 1996 .",
    "dietrich kuske , jiamou liu , and markus lohrey .",
    "the isomorphism problem on classes of automatic structures with transitive relations . submitted for publication ,",
    "extended version of a paper presented at lics 2010 , 2011 .",
    "yury lifshits .",
    "processing compressed texts : a tractability border . in bin ma and kaizhong zhang , editors , _ proceedings of the 18th annual symposium on combinatorial pattern matching ( cpm 2007 ) , london ( canada ) _ , number 4580 in lecture notes in computer science , pages 228240 .",
    "springer , 2007 .",
    "masamichi miyazaki , ayumi shinohara , and masayuki takeda .",
    "an improved pattern matching algorithm for strings in terms of straight - line programs . in alberto",
    "apostolico and jotun hein , editors , _ proceedings of the 8th annual symposium on combinatorial pattern matching ( cpm 97 ) , aarhus ( denmark ) _ , number 1264 in lecture notes in computer science , pages 111 .",
    "springer , 1997 .",
    "wojciech plandowski . testing equivalence of morphisms on context - free languages . in jan van leeuwen , editor , _ second annual european symposium on algorithms ( esa94 ) , utrecht ( the netherlands ) _ , number 855 in lecture notes in computer science , pages 460470 .",
    "springer , 1994 .",
    "wojciech plandowski and wojciech rytter .",
    "complexity of language recognition problems for compressed words . in juhani",
    "karhumki , hermann  a. maurer , gheorghe paun , and grzegorz rozenberg , editors , _ jewels are forever , contributions on theoretical computer science in honor of arto salomaa _ , pages 262272 .",
    "springer , 1999 .",
    "wojciech rytter .",
    "grammar compression , lz - encodings , and string algorithms with implicit input . in j.",
    "diaz , j.  karhumki , a.  lepist , and d.  sannella , editors , _ proceedings of the 31st international colloquium on automata , languages and programming ( icalp 2004 ) , turku ( finland ) _ , number 3142 in lecture notes in computer science , pages 1527 .",
    "springer , 2004 .",
    "larry  j. stockmeyer and a.  r. meyer .",
    "word problems requiring exponential time ( preliminary report ) . in _ proceedings of the 5th annual acm symposium on theory of computing ( stocs 73 )",
    "_ , pages 19 .",
    "acm press , 1973 ."
  ],
  "abstract_text": [
    "<S> the computational complexity of the isomorphism problem for regular trees , regular linear orders , and regular words is analyzed . </S>",
    "<S> a tree is regular if it is isomorphic to the prefix order on a regular language . in case regular languages </S>",
    "<S> are represented by nfas ( dfas ) , the isomorphism problem for regular trees turns out to be @xmath0-complete ( resp . </S>",
    "<S> @xmath1-complete ) . in case </S>",
    "<S> the input automata are acyclic nfas ( acyclic dfas ) , the corresponding trees are ( succinctly represented ) finite trees , and the isomorphism problem turns out to be @xmath2-complete ( resp . </S>",
    "<S> @xmath1-complete ) . </S>",
    "<S> a linear order is regular if it is isomorphic to the lexicographic order on a regular language . </S>",
    "<S> a polynomial time algorithm for the isomorphism problem for regular linear orders ( and even regular words , which generalize the latter ) given by dfas is presented . </S>",
    "<S> this solves an open problem by sik and bloom . </S>"
  ]
}