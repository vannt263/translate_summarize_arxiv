{
  "article_text": [
    "most computer programs are _ concurrent _ programs , which need to perform several tasks at the same time . for example , a network server needs to serve multiple clients at a time ; a gui needs to handle multiple keyboard and mouse inputs ; and a network program with a graphical interface ( e.g.  a virtual machine with an emulated network card ) needs to do both simultaneously .    [ [ threads - and - events ] ] threads and events + + + + + + + + + + + + + + + + + +    there are many different techniques to implement concurrent programs .",
    "a very common abstraction is provided by _",
    "threads_. in a threaded program , concurrent tasks are executed by a number of independent threads which communicate through a shared memory heap .",
    "threads are generally either _ native threads _ , preemptively scheduled by the operating system ( os ) , or _",
    "user - space threads _ , cooperatively scheduled by a library .",
    "an alternative to threads is _ event - driven _ programming .",
    "an event - driven program interacts with its environment by reacting to a set of stimuli called _ events_. at any given point in time , to every event is associated a piece of code known as the _ handler _ for this event . a global scheduler , known as the _ event loop _ , repeatedly waits for an event to occur and invokes the associated handler .",
    "performing a complex task requires to coordinate several event handlers by exchanging appropriate events .    unlike threads ,",
    "event handlers do not have an associated stack ; event - driven programs are therefore more lightweight and often faster than their threaded counterparts  @xcite .",
    "they are also more portable than native threads , because they do not require os support for task switching . however , because it splits the flow of control into multiple tiny event handlers , event - driven programming is generally deemed more difficult and error - prone  @xcite , in particular in imperative languages such as c with no support for closures and first - class functions . additionally ,",
    "because of its cooperative nature , event - driven programming alone is often not powerful enough , in particular when accessing blocking apis or using multiple processor cores ; it is then necessary to write _ hybrid _ code , that uses both native threads and event handlers , which is even more difficult .",
    "[ [ continuation - passing - c ] ] continuation - passing c + + + + + + + + + + + + + + + + + + + + + +    since event - driven programming is more difficult but more efficient than threaded programming , it is natural to want to at least partially automate it .",
    "_ continuation - passing c _",
    "( cpc  @xcite ) is an extension of the c programming language for writing concurrent systems , built on top of the c intermediate language ( cil ) framework  @xcite .",
    "the cpc programmer manipulates very lightweight threads , annotating cooperative functions and choosing whether they should be cooperatively or preemptively scheduled at any given point .",
    "the cpc program is then compiled in two steps : it is first processed by the _ cpc translator _ , which produces highly - efficient sequentialized event - driven code , and then linked with the _ cpc runtime _ , a small optimised c library scheduling the continuations introduced by the cpc translator .",
    "the translation from annotated cooperative functions into events is performed by a series of classical source - to - source program transformations : splitting of the control flow into mutually recursive nested functions , lambda lifting of these functions , and cps conversion .",
    "this approach retains the best of both worlds : the relative convenience of programming with threads , and the low memory usage of event - loop code .",
    "[ [ the - qemu - emulator ] ] the qemu emulator + + + + + + + + + + + + + + + + +    _ quick emulator _ ( qemu  @xcite ) is an open - source machine emulator and virtualizer that supports 16  cpu architectures and many individual devices including network cards , storage controllers , and graphics cards .",
    "code execution is done either through dynamic translation , or through hardware virtualization support available in modern x86 cpus .",
    "it is a large and complex project : 750000 lines of code written by 645  contributors over more than 10  years .    running a guest system with qemu involves executing guest code , handling timers , processing i / o , and responding to the management console . performing all these tasks at once requires an architecture capable of mediating resources in a safe way without pausing guest execution if a disk i / o or a command from the management console takes a long time to complete .",
    "qemu uses a hybrid architecture that combines event - driven programming with threads .    to simplify the event - driven part",
    ", qemu uses _",
    "coroutines_. coroutines are an old control abstraction , commonly characterised by the ability to resume and suspend execution , as well to preserve the values of local data between successive calls . among the many existing styles of coroutines",
    "@xcite , qemu implements first - class , stackful , asymmetric coroutines , with no value passing upon suspension and resumption . as a result ,",
    "programming with qemu coroutines feels a lot like programming with threads , with the exception that cooperating passes control back to the parent coroutine instead of some global scheduler .",
    "each coroutine is responsible for registering itself with the main event loop before yielding .    similarly to cpc ,",
    "qemu functions that should be executed within coroutines are annotated .",
    "these annotations are not intended to drive a source - to - source transformation with static checking , but they are an essential piece of documentation for developers to write correct coroutine code . however , they are never statically checked .",
    "coroutines in qemu are implemented in a platform - dependent manner .",
    "there are currently two classes of coroutine implementations : _ stack - switching backends _ , which allocate a new stack for each coroutine and perform a context switch when entering and yielding ; and _ thread - based backends _ , which create a new thread for each coroutine and use synchronization primitives to ensure that only one coroutine runs at a given time and that control is transferred in the correct order .",
    "the former use non - portable functions , such as ` sigaltstack ` and ` swapcontext ` on unix , and ` switchtofiber ` on windows : the context switch is triggered from user - space , and in most cases involves only a cheap function call to set the current stack pointer .",
    "the latter is built on top of glib s threads , a more portable but slower approach .",
    "these approaches can be made to work well but require maintenance and a relatively high porting effort when targeting new platforms .",
    "consequently , new qemu ports sometimes only use the slower thread - based backends .",
    "the stack - switching backends require in - depth knowledge of the cpu architecture and low - level support for switching the runtime stack and process context such as signal masks .",
    "the maintenance cost of coroutine backends , and the lack of static verification of coroutine annotations , create a need for a new approach that offers safety guarantees , and good portability with no performance degradation .",
    "our approach in this paper is to process the whole qemu source code with the cpc translator in order to convert it to continuation - passing style , and then link the resulting code with a new , portable coroutine backend for qemu based on continuations .",
    "therefore , we reuse the cpc translator , but not the original cpc runtime : the point of our work is indeed not to rewrite qemu in the cpc language , but to use the cpc compilation technique to implement the coroutine api defined by qemu .",
    "this article is a case study in applying cps conversion and static analysis on a large c program , to implement safe , portable and efficient coroutines .    [",
    "[ contributions ] ] contributions + + + + + + + + + + + + +    we make the following contributions :    1 .   a new type of annotations to mark blocking functions ; 2 .",
    "corocheck , a tool for the static analysis and inference of cooperation and blocking annotations , used to rectify hundreds of annotations in qemu , a real - world open - source project of over 750000 lines of c code ; 3 .   a performance comparison of continuation - based coroutines to several other existing implementations of coroutines for qemu .",
    "our work shows the importance of static annotation checking to prevent actual concurrency bugs , and demonstrates that cps conversion  as implemented by the cpc translator  is a flexible , portable , and efficient compilation technique , even for very large programs written in an imperative language .",
    "[ [ outline ] ] outline + + + + + + +    we first give an overview of related work ( section  [ sec : related - work ] ) , and qemu coroutines ( section  [ sec : qemu - api ] ) .",
    "then , we introduce corocheck , our tool for the static analysis and inference of coroutine annotations ( section  [ sec : corocheck ] ) .",
    "next , we present the cpc transformation technique ( section  [ sec : cpc ] ) , and dive into the challenges associated with applying cps conversion to qemu ( section  [ sec : cpc - qemu ] ) . finally , we evaluate performance results ( section  [ sec : eval ] ) , and conclude ( section  [ sec : conclusion ] ) .    [ [ timeline ] ] timeline + + + + + + + +    the work described has been carried out over the course of three months , in the context of a google summer of code project . the second author , who had no prior knowledge of either qemu or cpc , is the sponsored student .",
    "the first and third authors co - mentored his work , respectively for the cpc and qemu sides of the project .",
    "the timeline went roughly as follows :    before the begining of the project : :    the first author spent two weeks improving cil    ( section  [ sec : cil - bugs ] ) and cpc    ( section  [ sec : cps - calling - convention ] ) .",
    "first month : :    the second author studied the implementation of the cpc translator and    runtime , qemu coroutines , and implemented a prototype of the    ` coroutine - cpc ` backend ( section  [ sec : cpc - backend ] ) .",
    "second month : :    the second author started adding missing coroutine annotations in the    block layer ( section  [ sec : missing - annot ] ) , to compile two small ,    stand - alone utilities provided by qemu ( ` qemu - img ` and ` qemu - io ` ) . to    support his refactoring effort",
    ", the first author spent a few days    writing a first prototype of corocheck , a tool for the static analysis    of coroutine annotations ( section  [ sec : coro - features ] ) , and two more    weeks adding a plug - in mechanism to cil and rewriting corocheck as a    cil plug - in . third month : :    the second author published two series of patches adding coroutine    annotations to qemu , and improved them with the help of the third    author and other qemu developers .",
    "after some minor clean - up and    optimisations , the first author was able to run a virtual machine    using qemu with a ` coroutine - cpc ` backend , and perform micro- and    macro - benchmarks ( section  [ sec : eval ] ) .",
    "[ [ software - availability ] ] software availability + + + + + + + + + + + + + + + + + + + + +    the code developed as part of this work is available as free software . whenever possible , the changes have been integrated directly in the original projects that we had to adapt ( cil  @xcite , cpc  @xcite , qemu  @xcite ) .",
    "our new tool corocheck is also available in its own repository  @xcite .",
    "some patches for the cpc backend of qemu are still pending review by the qemu team at the time of writing .",
    "[ [ continuations - and - concurrency ] ] continuations and concurrency + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    delimited continuations are the general abstraction to think of threads , events and coroutines .",
    "a delimited continuation can be realized in many ways : as a stack implicitly associated with a thread , as an explicitly copied part of the stack , as a sequence of activation frames stored on heap or in a data structure ( as happens in continuation - passing style ) , or as a closure ( an event handler ) . in functional languages ,",
    "thread - like primitives are commonly built either on top of first - class ( delimited ) continuations , or encapsulated within a continuation monad .",
    "the former approach is best illustrated by concurrent ml constructs  @xcite , implemented on top of sml / nj s first - class continuations , or by the way coroutines are typically implemented in scheme using the ` call / cc ` operator  @xcite .",
    "more recently , scala uses first - class delimited continuations to implement concurrency primitives  @xcite .",
    "anton and thiemann build pure ocaml coroutines  @xcite on top of kiselyov s delimcc library for delimited continuations  @xcite .",
    "explicit translation into continuation - passing style , often encapsulated within a monad , is used in languages lacking first - class continuations . in haskell",
    ", claessen proposes a monad transformer yielding a concurrent version of existing monads  @xcite .",
    "li and zdancewic also use a monadic approach to build event - driven network servers  @xcite . in ocaml",
    ", vouillon s lwt  @xcite provides a lightweight alternative to native threads . the asynchronous model in f #",
    "is implemented with a localized continuation - passing translation of control - flow and a heap - based allocation of the closures , using three continuations for success , exceptions and cancellation  @xcite .",
    "[ [ from - threaded - to - event - driven - style ] ] from threaded to event - driven style + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in imperative languages , first - class continuations are generally not available and monadic style extremely inconvenient .",
    "this makes program transformation techniques more widespread , with two main approaches : translating loops and gotos into state machines  @xcite , or converting functions into continuation - passing style  @xcite .",
    "deriving state - machines from a threaded - style code is as old as _ duff s device _  @xcite .",
    "implementations have then been improved in multiple directions : as c preprocessor macros  @xcite , as source - to - source transformations on c++  @xcite or java  @xcite programs , as a transformation on jvm bytecode  @xcite , or as llvm code blocks and macros based on gcc s nested functions  @xcite .",
    "cps conversion for imperative languages is less common , probably because it is harder to implement and prove correct .",
    "cps conversion has been applied at least to c  @xcite , c++  @xcite , and javascript  @xcite . to the best of our knowledge",
    ", cpc is the only public implementation for the c language , as well as the only one using lambda - lifting to avoid the runtime overhead of environments  @xcite .",
    "the main downside of these program transformation techniques is that cps conversion changes function signatures , which makes it harder to mix concurrent functions with external libraries expecting callbacks .",
    "unsurprisingly , similar issues arise when using events and threads simultaneously ; adya et al .",
    "show how to use adaptors to connect both styles  @xcite .",
    "[ [ static - verification - of - real - world - programs ] ] static verification of real - world programs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the constraint that only cooperative functions can call cooperative functions is a very natural and common one in concurrent systems . in functional languages with a static type - checking ,",
    "it is generally enforced by the monadic structure or the type system itself  @xcite .",
    "interestingly enough , authors of similar systems for imperative languages commonly acknowledge that static checking would be preferable , but do not implement it  @xcite .",
    "it seems that kilim statically checks ` @pausable ` annotations , although the authors do not mention it explicitly  @xcite .",
    "there is a long history of static analysis to enforce safety properties , in particular for real - world programs written in languages lacking a strong type system  @xcite .",
    "however , most of them require to add explicit annotations in ad - hoc domain - specific languages .",
    "a noteworthy exception is dialyzer , a static analyser reusing the annotation format already found in the documentation of many erlang programs  @xcite .",
    "as described in section  [ sec : intro ] , qemu is an open source machine emulator and virtualizer using a hybrid architecture that combines event - driven programming with threads .",
    "the use of threads mitigates two well - known limitations of event - driven architectures : an event loop can not take advantage of multiple cores because it only has a single thread of execution ; and long - running computations or blocking system calls freeze every task in the event loop , not only the current one .",
    "nevertheless , the core of qemu is event - driven and most code executes in that environment .",
    "the main event loop is executed by a dedicated thread , called _",
    "iothread_. when a file descriptor becomes ready , or when a timer expires , it invokes a callback that responds to the event . on the other hand ,",
    "guest code is executed by a number of _ vcpu _ threads , one per virtual ( emulated ) cpu .",
    "in addition , _ worker _ threads are also used to offload blocking operations outside of the main loop .    in 2011 , in response to an increase of complexity in asynchronous code , qemu developers began to use coroutines to run concurrent tasks in the iothread without splitting them into individual callback functions  @xcite .",
    "a coroutine has its own stack and is therefore able to preserve state across blocking operations , which traditionally require callback functions and manual marshalling of parameters .",
    "coroutines are now used heavily in the _ block layer _ , the subsystem that provides access to disk image files and supports background operations like live storage migration .",
    "coroutines allow tasks requiring multiple disk updates to be expressed as sequential code rather than breaking them ( in event - driven style ) into many functions and explicitly passing on local variables .",
    "qemu is written in c. since the c programming language does not include support for coroutines , qemu uses its own implementation that is based on two annotations , two type definitions and five functions ( figure  [ fig : qemu - api ] ) .",
    ".... # define coroutine_fn   / * implementation - dependent * / # define blocking_fn    / * implementation - dependent * / typedef struct coroutine coroutine ; typedef void coroutine_fn coroutineentry(void * ) ; coroutine * qemu_coroutine_create(coroutineentry * ) ; void qemu_coroutine_enter ( coroutine * , void * ) ; void coroutine_fn qemu_coroutine_yield(void ) ; bool qemu_in_coroutine(void ) ; coroutine * coroutine_fn qemu_coroutine_self(void ) ; ....    creating and starting a coroutine is very straightforward :    .... coroutine = qemu_coroutine_create(my_coroutine ) ; qemu_coroutine_enter(coroutine , my_data ) ; ....    the function ` qemu_coroutine_create ` takes an entry function that will be run inside a new coroutine , and returns a pointer to an opaque structure ` coroutine ` , or _",
    "coroutine handler_. the entry function must be of type ` coroutineentry ` , i.e.  taking an opaque ` void * ` pointer and returning nothing .",
    "the function ` qemu_coroutine_enter ` transfers control to the coroutine .",
    "the coroutine then executes until it returns , in which case it is automatically freed , or yields :    .... void coroutine_fn my_coroutine(void * opaque ) {    mydata * my_data = opaque ;    / * ... do some work ... * /    qemu_coroutine_yield ( ) ;    / * ... do some more work ... * / } ....    yielding is done either directly by calling ` qemu_coroutine_yield ` , or indirectly by calling a function that yields ( itself directly or indirectly ) . yielding switches control back to the caller of ` qemu_coroutine_enter ` .",
    "this is typically used to switch back to the main thread s event loop after issuing an asynchronous i / o request .",
    "the request callback will then invoke the function ` qemu_coroutine_enter ` once more to switch back to the coroutine .",
    "finally , the qemu coroutine interface provides a simple introspection mechanism based on two functions : ` qemu_in_coroutine ` can be used to check if the current function is executed in coroutine context , and ` qemu_coroutine_self ` to get a pointer to the current coroutine if this is the case .",
    "functions that are run inside a coroutine and may yield are called _ coroutine functions _ , and annotated with ` coroutine_fn ` .",
    "note that any function that calls a coroutine function is prone to yielding itself .",
    "therefore , a coroutine function may only be called by another coroutine function ; in other words , it is forbidden to call a coroutine function from a non - coroutine , _ native _ function .",
    "coroutine functions , on the other hand , are allowed to call native functions .",
    "coroutine annotations are used twice in the coroutine api ( figure  [ sec : qemu - api ] ) : coroutine entry points ( ` coroutineentry ` ) must be coroutine functions , since they are executed in a coroutine , and ` qemu_coroutine_yield ` is of course annotated as a coroutine function .",
    "_ blocking functions _ , on the other hand , are native functions that must not be called from a coroutine ; they are annotated with ` blocking_fn ` .",
    "we introduce this new annotation , which did not exist in qemu before this work , to identify native functions that could block the main event loop for a long time and have a coroutine equivalent that should be used instead .",
    "note that in principle , it would be even safer to consider every native function as potentially blocking , and annotate explicitly those that we wish to allow in coroutine context ; however , such a white - list mechanism would be intractable in practice on a project of the size of qemu , and we opted for a black list of blocking functions instead .    one important limitation of qemu before our work was that these global constraints on the function call graph were not enforced in any way : as shown in figure  [ fig : qemu - api ] , ` coroutine_fn ` and ` blocking_fn ` are simply defined as empty macros by default , hence discarded from the final source - code by the c preprocessor .",
    "we discuss in sections  [ sec : cps - calling - convention ] and  [ sec : corocheck ] how to give them a rigorous semantics , and how to check that annotated functions are used correctly .",
    "qemu uses indirect coroutine calls and function pointers to coroutine functions intensively .",
    "we have seen in figure  [ fig : qemu - api ] that every call to ` qemu_coroutine_create ` involves a pointer to a coroutine function , but this is far from the only place where they are used .    as explained above ,",
    "coroutines are mainly used to provide non - blocking accesses to emulated disk images in the iothread . to support multiple disk image formats in an extensible way",
    ", the block layer of qemu defines a generic block driver interface ( figure  [ fig : blockdriver ] ) .",
    "this interface consists in a set of more than 40 callback functions that each driver needs to implement ; among them , 17 are coroutine functions .",
    ".... struct blockdriver {    const char * format_name ;    int ( * bdrv_probe_device)(const char * filename ) ;    int coroutine_fn ( * bdrv_co_flush_to_os )                            ( blockdriverstate * bs ) ;    / * ... * / } ; ....    the block layer then uses this abstract interface to implement i / o operations , performing many indirect calls to coroutine functions provided by each driver . for instance , the coroutine function ` brdv_co_flush ` calls the coroutine callback ` brdv_co_flush_to_os ` .    .... int coroutine_fn bdrv_co_flush(blockdriverstate * bs ) {    / * write back cached data to the os * /    if ( bs->drv->bdrv_co_flush_to_os ) {     int ret = bs->drv->bdrv_co_flush_to_os(bs ) ;     if ( ret < 0 ) {       return ret ;     }    }    / * ... * / } ....    to preserve the coroutine constraint on the call graph , it is essential that function pointers be explicitly annotated .",
    "coroutine annotations on function declarations and definitions alone are not enough to ensure the correctness of coroutine calls .",
    "coroutine annotations are not only useful to document which functions might block the event loop , and which ones can safely be used in a non - blocking way . in an event - driven program , as well as in a concurrent system with cooperative threads or coroutines , the main loop acts as a global lock , and it is common for programmers to rely on it to synchronise access to shared resources or preserve global invariants . even in a stack - switching approach to coroutines ,",
    "calling a coroutine function outside of coroutine context can then lead to serious bugs .",
    "ironically , such a bug occurred in qemu during the course of our study .",
    "the code responsible for throttling disk i / o was causing a segmentation fault because a function to reschedule coroutines , ` qemu_co_queue_next ` , was missing a coroutine annotation and was called from native functions .",
    "it remained broken for two months before canet identified the bug and fixed it  @xcite .",
    "however , as we discovered later when checking statically the impacted file , the fix itself still misses some coroutine annotations : getting all of them correct without some form of automated verification is a daunting task ( see section  [ sec : coro - example ] for more details ) .",
    "the cpc translator enforces this rule statically , because it needs correct annotations to drive its transformation .",
    "however , it only performs limited checking and is not convenient to analyse and infer coroutine annotations on a large scale ( section  [ sec : missing - annot ] ) . the fact that it interleaves the analysis of coroutine annotations with source - to - source transformations increases the opportunities for bugs , and makes it harder to add new features . in order to fix a large number of annotations in an efficient and reliable way",
    ", we decided to write corocheck , a generic tool for the static analysis and inference of coroutine annotations , designed to be usable for cpc , qemu , or any c other library with coroutine annotations ( section  [ sec : coro - features ] ) .",
    "we illustrate the use of corocheck on a small example from qemu in section  [ sec : coro - example ] , and evaluate the number of annotations that corocheck enabled us to fix in qemu in section  [ sec : coro - eval ] .",
    "in theory , it should have been enough to change a single line in the header file ` coroutine.h ` to make the cpc translator recognize and convert coroutine functions in qemu : for an explanation of ` _ _",
    "attribute__((cps ) ) ` . ]",
    ".... # define coroutine_fn _ _",
    "attribute__((cps ) ) ....    in practice , however , this early attempt failed because many coroutine annotations in qemu were missing , and cpc produced hundreds of errors caused by inconsistent annotations .",
    "as shown in table  [ tab : annot - stats ] ( section  [ sec : coro - eval ] , more than 70% of the coroutine annotations required to compile qemu were missing . in hindsight",
    ", this should have come as no surprise .",
    "as explained in section  [ sec : qemu - api ] , coroutine annotations are used exclusively for documentation purposes .",
    "qemu is a very large project , and not every contributor understands how the coroutine mechanism works . even fewer keep in mind the rules about coroutine annotations , and mistakes easily go unnoticed since there is no automated check to detect them .",
    "a naive approach to fix coroutine annotations is to blindly follow the error messages reported by the cpc translator : adding missing annotations where errors are reported , which will produce more errors at the call points of these newly annotated functions , and iterating until one reaches a fixed - point . apart from being extremely tedious , there are two reasons why this naive approach does not work well , or even at all in the case of qemu : spurious annotations and hybrid functions .",
    "[ [ spurious - annotations ] ] spurious annotations + + + + + + + + + + + + + + + + + + + +    there is a risk of introducing too many annotations .",
    "each illegal call to a coroutine function from a native function can be fixed either by annotating the caller , or by wrapping the callee in a native function allocating a dedicated coroutine for this call .",
    "this is a design choice that only the programmer can make , based on the concurrent structure of the program : it would be unreasonable to systematically add annotations all the way to the ` main ` function at the root of the call graph because of a single annotation at one of the leaves .",
    "conversely , it is sometimes a deliberate choice to spuriously annotate functions which do not call any other coroutine functions , e.g.  for documenting the intention and further plans to add cooperation in some place of the code . hence spurious annotations should not be removed automatically .",
    "[ [ hybrid - functions ] ] hybrid functions + + + + + + + + + + + + + + + +    hybrid functions use ` qemu_in_coroutine ` to check dynamically whether they are called in coroutine context , and execute a different code path in each case . such functions do not work with cpc , and need to be rewritten to split the coroutine and native code paths .    the need for blocking functions ( section  [ sec : coro - annot ] ) arose mainly when splitting hybrid functions into a native and a cooperative version . annotating",
    "the native one as a blocking function would make sure that it is not called by mistake from a coroutine , which would block the whole event loop .",
    "both the splitting of hybrid functions and the introduction of the ` blocking_fn ` annotation were discussed with and approved by qemu developers  several of them considered hybrid functions as a temporary work - around , used to ease the transition when coroutines were first introduced in qemu .",
    "corocheck is a generic tool for the static analysis and inference of coroutine annotations , written in ocaml . to make corocheck easily available and usable by as many qemu developers as possible",
    ", we extended cil with a modular plug - in system , and wrote corocheck as a cil plug - in .",
    "this improves the previous cumbersome cil architecture , which required users to recompile their own version to add new features , and should make it easier for every programmer to distribute analysis and program transformation tools based on cil in the future .",
    "corocheck analyses one c file at a time .",
    "it assumes that coroutine functions and function pointers are marked with an attribute , as detailed in section  [ sec : cps - calling - convention ] , and that the prototypes of functions implemented outside of the analysed file are correctly annotated .",
    "this is a necessary assumption , since corocheck has no means to determine whether extern functions are actually cooperative or not .    assuming the correctness of external annotations implies that the programmer is responsible for analysing the files in a topological order based on their dependencies , or to iterate the analysis over the whole project until reaching a fixed - point .",
    "this proved not to be a problem in practice .    for each file that it analyses , corocheck performs a coroutine annotation inference , prints warnings for missing and spurious annotations , outputs an annotated call graph to help the programmer analyse and fix those errors , and checks that type casts and assignments respect coroutine annotations .",
    "we detail each of these steps in the rest of this section .",
    "[ [ coroutine - annotation - inference ] ] coroutine annotation inference + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    corocheck builds a directed graph of the functions calls in the analysed file , with a node for each function ( either defined in the file , or simply declared ) , and edges from caller to callee .",
    "it then uses the ` fixpoint ` module of the ocamlgraph library  @xcite to propagate coroutine annotations . as explained above , we start with the coroutine functions implemented outside of the current file as a trusted root , and propagate the annotations backwards to their callers until we reach a fixed - point .",
    "there is in fact another class of functions that we add to the roots of the algorithm : coroutine functions which have their address retained in a function pointer .",
    "this turned out to be necessary to avoid generating too many warnings about spurious annotations : when a function is used to implement an interface such as ` blockdriver ` ( figure  [ fig : blockdriver ] ) , it is essential to obey the annotation constraints mandated by the interface . for further safety , corocheck also verifies automatically that these function pointers are used consistently .",
    "corocheck then iterates over every function defined in the file and prints warnings when the inferred coroutine annotation does not match the original one",
    ". it also warns if a blocking function is inferred as cooperative , or called from a coroutine function ( either inferred or annotated in the original file ) .",
    "[ [ annotated - call - graph ] ] annotated call graph + + + + + + + + + + + + + + + + + + + +    as explained in section  [ sec : missing - annot ] , blindly following corocheck suggestions for annotating coroutine functions is not necessarily enough : one might need to refactor an interface or split a hybrid function for example . having a per - file graphical view of the function call graph proves very helpful in understanding the reasons for the suggested fixes and analysing the root causes of erroneous annotations .",
    "corocheck uses ocamlgraph facilities to output a file that can be processed with the ` dot ` utility ( from the graphviz project ) to generate an image representing the annotated function call graph .",
    "consider for example the input program in figure  [ fig : inference ] ; it yields the output shown in figure  [ fig : corocheck ] .    .... extern void coroutine_fn coro ( ) ; extern void blocking_fn block ( ) ;    void native ( ) { } ; void coroutine_fn ( * coro_fun_ptr)(void ) = & coro ;    void coroutine_fn spurious ( )      { } void coroutine_fn good ( )          { coro ( ) ; native ( ) ; } void               missing ( )       { coro ( ) ; } void coroutine_fn call_missing ( ) { missing ( ) ; } void blocking_fn   wrong ( )         { good ( ) ; } void               call_block ( )    { block ( ) ; } void coroutine_fn wrong_call ( )    { coro ( ) ; block ( ) ; } void               ptr_call ( )      { coro_fun_ptr ( ) ; } ....        functions _ inferred _ as coroutine functions are represented in rectangles ; native functions in ovals .",
    "annotations _ provided by the programmer _",
    ", on the other hand , are printed within the boxes ( ` coroutine_fn ` or ` blocking_fn ` in figure  [ fig : corocheck ] ) . for indirect calls ,",
    "since the name of the called function is unknown , we print the expression used to perform the call instead ( eg .  ` coroutine * coro_fun_ptr ` ) .",
    "mismatching nodes , corresponding to either spurious or missing annotations , are ouput with dashed , red lines . for example , from top - left to bottom - right in figure  [ fig : corocheck ] , the function ` wrong ` should be annotated with ` coroutine_fn ` instead of ` blocking_fn ` because it calls the coroutine function ` good ` ; the function ` spurious ` does not call any coroutine function , so it does not need a ` coroutine_fn ` annotation ; the function ` ptr_call ` should be a coroutine functions because it performs an indirect call to a coroutine function through the function pointer ` coro_fun_ptr ` ; and the function ` missing ` should be annotated as well since it calls the coroutine function ` coro ` .",
    "note that the function ` call_missing ` is not flagged as spurious , since it calls ` missing ` which should be a coroutine function ( even though it lacks the proper annotation ) .",
    "finally , dashed , red lines are also used for forbidden edges from coroutine functions to blocking functions , such as ` wrong_call ` calling ` block ` .",
    "files from a real - world program can contain a huge number of functions , making the call graph cluttered and challenging to decipher . to focus on the relevant information",
    ", corocheck removes every native function defined outside of the current file from the graph .",
    "this strategy removes many leaves , in particular all functions from the ` libc ` standard c library .",
    "for example , when applied to ` block.c ` , it removes more than half of the nodes and edges ( from 657  nodes and 781  edges down to 316  nodes and 302  edges ) .",
    "[ [ type - cast - and - assignment - verification ] ] type cast and assignment verification + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as an additional safety check , unrelated to call graph analysis , corocheck ensures that coroutine annotations are not lost when function pointers are typecast or assigned to a variable .",
    "this is relatively straightforward thanks to cil making every type cast explicit in its intermediary ast .      in this section ,",
    "we show that annotations are significant even in the original qemu , and that a missing annotation can cause ( and has in fact caused ) a serious and hard - to - find bug .",
    "coroutine locks ( ` comutex ` ) are built on top a coroutine queues ( ` coqueue ` ) .",
    "the basic operations are to enqueue the current coroutine , which transfers control to its caller ( ` qemu_co_queue_wait ` ) , and to restart the next coroutine in a queue ( ` qemu_co_queue_next ` ) .",
    "locking operations are thin wrappers around these functions which check if the ` comutex ` is already locked before proceeding ( ` qemu_co_mutex_lock ` and ` qemu_co_mutex_unlock ` ) .",
    "figure  [ fig : lock]a gives an overview of the file implementing coroutine queues and locks .",
    "corocheck detects no less than six functions missing a coroutine annotation , and one ( ` qemu_co_queue_run_restart ` ) spuriously annotated .",
    "these missing annotations caused a serious bug : the code responsible for throttling disk i / o trusted them , and called ` qemu_co_next ` in native context .",
    "this ultimately led to calling ` qemu_coroutine_self ` in native context , which returned an invalid coroutine pointer and caused a segmentation fault in ` qemu_co_queue_do_restart ` .",
    "+ ( a ) before canet s patch     + ( b ) after canet s patch    note : the graph has been slightly simplified , and we use ` coro ` instead of ` coroutine_fn ` to keep it readable .",
    "canet  @xcite fixed the segmentation fault two months later by introducing ` qemu_co_enter_next ` , a native - mode counterpart to ` qemu_co_queue_next ` . however , as shown on figure  [ fig : lock]b , quite a few annotations are still missing or incorrectly placed after the patch . without an automated verification tool such as corocheck , it is probably only a matter of time before the wrong function is used again by mistake in another part of qemu .",
    "we have no doubt that it would have been much less likely to obtain fully correct annotations in the short time - frame of our study without using corocheck . although this is but a subjective impression , the figures shown in table  [ tab : annot - stats ] give a better idea of the amount of work required .",
    "compared to the correctly annotated ` cpc ` branch , the original ` master ` branch lacks more than 70% of annotations .",
    "we firmly believe that bug - free annotations can not be reached in a project of this scale without automated , static verification tools .",
    ".coroutine annotations in qemu [ cols=\"<,<,>,>\",options=\"header \" , ]     all speeds are in nanoseconds , averaged over 10 runs ( except _ gthread - nesting _ , over 5 runs ) of millions of iterations , on an 8-core intel xeon e5 - 1620 at 3.6  ghz . for _ nesting",
    "_ , the time is per nested coroutine , hence comparable to _ lifecycle _ directly .",
    "the ` cpc ` backend is consistently faster than every other backend .",
    "allocation is faster because continuations are resized dynamically when needed , whereas other backends need to allocate a large chunk of memory at once . as a result ,",
    "the coroutine pool is extremely effective for other backends , but turns out to slow down ` cpc ` in the _ nesting _ benchmark : when the number of coroutines is one order of magnitude larger than the size of the pool , the cost of managing the pool becomes higher than its benefits .",
    "as expected , the pool has almost no impact for _ yield _ , since only one coroutine is used in this test .",
    "we are not sure exactly why the gap is so large between the _ lifecycle _ and _ nesting _ benchmarks for most backends : both tests perform exactly the same task , except that the latter uses more coroutines simultaneously and maintains a shared counter between coroutines .",
    "the memory pressure is certainly higher , but it is not clear why it slows down the creation of each coroutine so much , especially when the pool is disabled anyway .",
    "we believe that cache effects are involved here , which would explain why ` cpc ` performs much better with its small memory footprint .",
    "the result of the _ yield _ benchmark is not surprising .",
    "coroutine switching is a mere function return in the case of ` cpc ` , hence faster than the signals , stack - switching mechanisms or locks used by the other backends .",
    "the main downside of cps conversion is that it adds an overhead to each call to a cps - converted function .",
    "it is hard to predict the global overhead on a large program because the splitting pass introduces a number of calls to cps - converted functions which varies with the complexity of the control - flow and the position of cooperation points .",
    "while the cpc translator tries to limit the number of inserted calls by performing incremental transformations , we need to perform macro - benchmarks to evaluate the overall effectiveness of our approach .",
    "since coroutines are mainly used in the block layer implementation , we need to generate a lot of disk i / o from the virtual machine .",
    "we use a virtualized guest os with debian `` squeeze '' , ran on a debian `` squeeze '' host on an 8-core intel xeon 3.6  ghz , and ` fio ` to generate various intensive disk accesses patterns , with up to 500  simultaneous readers or writers .",
    "the guest is installed in a disk image using qemu s ` qcow2 ` disk format .",
    "we take particular care to disable disk caches in both the guest os and qemu s disk layer , to make sure each access in the guest translates to an actual read or write of the image file on the host ; disk cache is kept enabled on the host .",
    "we compare the mean and median access time for each access pattern and coroutine backend .",
    "unfortunately , none of the coroutine backend performs significantly faster or slower than the others in these macro - benchmarks . to get a finer - grained understanding of the results , we profile each qemu instance with the linux ` perf ` utility , which uses hardware performance counters provided by the cpu",
    ". as it turns out , coroutines are not at all on the critical path when emulating or virtualizing a whole system : slightly less than 1% of the execution time is spent in coroutine - related functions , and the differences between backends end up being smaller than the variability of disk - access times .    however , ` perf ` allows for a fine - grained analysis of the time spent in each function , with some measurement uncertainty due to its event - sampling approach .",
    "therefore , it is possible to isolate the most time - consuming coroutine function in ` perf ` results ( for instance ` qcow2_co_writev ` for a write benchmark ) , and compare its ranking for the various coroutine backends .",
    "this is a tedious process that we did not manage to automate : since the splitting pass of the cpc translator creates new coroutine functions , one needs to sum those to recover the global time spent in the original function .",
    "in the few runs that we analysed , the coroutine functions split by the cpc translator did not take significantly more time to execute .",
    "a likely explanation is that coroutine functions frequently yield in practice ; the time wasted in the trampoline loop is negligible compared to the overhead of entering and switching coroutines for other backends .    despite our efforts ,",
    "these macro - benchmarks are frustratingly inconclusive .",
    "profiling at least seems to indicate that cps conversion does not generate a significant overhead in the case of qemu .",
    "this is in line with the conclusions of our previous experiments on smaller programs  @xcite .",
    "we have applied a conversion to continuation - passing style to qemu , a large open - source project written in c with heavy use of function pointers .",
    "then , we have used these continuations to implement an alternative coroutine backend , both more portable and much faster than the existing ones .",
    "we have also developed corocheck , a tool for the static analysis of coroutine annotations , and used it to correct several hundreds of missing annotations in qemu .",
    "our work demonstrates that static analysis of coroutines helps ruling out some actual bugs .",
    "it also shows that cpc is flexible and mature enough to scale efficiently to very large programs , and to a model ( coroutines ) that it was not initially designed to handle .    beyond the scientific results ,",
    "this is the story of a successful collaboration between an open - source project and academic research .",
    "over the course of a few months , we have started a fruitful relationship , improving the state of coroutines in qemu , developing a tool that they can use as part of their test suite , and fixing many bugs in cil and cpc .",
    "we were certainly not the first , but we hope that many others will come after us , and discover the mutual benefits of scaling - up their techniques to real - world projects .",
    "the authors wish to thank alan mycroft and gabriel scherer for their thoughtful suggestions on the structure of this article , as well as matthieu boutier , marc lasson , raphal proust , and peter sewell for their comments .",
    "they are also beholden to the anonymous reviewers for their extremely detailed and valuable suggestions .",
    "this work has been supported by google ( google summer of code 2013 ) and epsrc ( grants ep / h005633 and ep / k008528 ) .",
    "a.  adya , j.  howell , m.  theimer , w.  j. bolosky , and j.  r. douceur .",
    "cooperative task management without manual stack management .",
    "in c.  s. ellis , editor , _ usenix annual technical conference , general track _ , pages 289302 .",
    "usenix , 2002 .",
    "k.  anton and p.  thiemann . towards deriving type systems and implementations for coroutines . in k.",
    "ueda , editor , _ aplas _ , volume 6461 of _ lecture notes in computer science _ ,",
    "pages 6379 .",
    "springer , 2010 .",
    "s.  conchon , j .- c .",
    "fillitre , and j.  signoles . designing a generic graph library using ml functors . in m.",
    "t. morazn , editor , _ trends in functional programming _ , volume  8 of _ trends in functional programming _ , pages 124140 .",
    "intellect , 2007 .",
    "p.  cuoq , f.  kirchner , n.  kosmatov , v.  prevosto , j.  signoles , and b.  yakobowski .",
    "- a software analysis perspective . in g.  eleftherakis , m.  hinchey , and m.  holcombe , editors ,",
    "_ sefm _ , volume 7504 of _ lecture notes in computer science _ , pages 233247 .",
    "springer , 2012 .",
    "a.  dunkels , o.  schmidt , t.  voigt , and m.  ali .",
    "protothreads : simplifying event - driven programming of memory - constrained embedded systems . in a.",
    "t. campbell , p.  bonnet , and j.  s. heidemann , editors , _ sensys _ , pages 2942 .",
    "acm , 2006 .",
    "g.  kerneis and j.  chroboczek . : programming with a massive number of lightweight threads . in _ proceedings of the workshop on",
    "programming language approaches to concurrency and communication - centric software _ , pages 3034 , 2011 .",
    "p.  li and s.  zdancewic .",
    "combining events and threads for scalable network services implementation and evaluation of monadic , application - level concurrency primitives . in j.",
    "ferrante and k.  s. mckinley , editors , _ pldi _ , pages 189199 .",
    "acm , 2007 .",
    "g.  c. necula , s.  mcpeak , s.  p. rahul , and w.  weimer . : intermediate language and tools for analysis and transformation of c programs . in r.",
    "n. horspool , editor , _ cc _ , volume 2304 of _ lecture notes in computer science _ ,",
    "pages 213228 .",
    "springer , 2002 .",
    "j.  h. reppy .",
    "concurrent ml : design , application and semantics . in p.",
    "e. lauer , editor , _ functional programming , concurrency , simulation and automated reasoning _",
    ", volume 693 of _ lecture notes in computer science _ , pages 165198 .",
    "springer , 1993 .",
    "t.  rompf , i.  maier , and m.  odersky . implementing first - class polymorphic delimited continuations by a type - directed selective cps - transform . in g.",
    "hutton and a.  p. tolmach , editors , _ icfp _ , pages 317328 .",
    "acm , 2009 .          c.  strachey and c.  p. wadsworth .",
    "continuations : a mathematical semantics for handling full jumps .",
    "technical monograph prg-11 , oxford university computing laboratory , programming research group , oxford , england , 1974 .",
    "d.  syme , t.  petricek , and d.  lomov .",
    "the f # asynchronous programming model .",
    "in r.  rocha and j.  launchbury , editors , _ padl _ , volume 6539 of _ lecture notes in computer science _ , pages 175189 .",
    "springer , 2011 .",
    "a.  van wijngaarden .",
    "recursive definition of syntax and semantics . in _",
    "formal language description languages for computer programming _ , pages 1324 ,",
    "amsterdam , netherlands , 1966 .",
    "north - holland publishing company ."
  ],
  "abstract_text": [
    "<S> coroutines and events are two common abstractions for writing concurrent programs . </S>",
    "<S> because coroutines are often more convenient , but events more portable and efficient , it is natural to want to translate the former into the latter . </S>",
    "<S> cpc is such a source - to - source translator for c programs , based on a partial conversion into continuation - passing style ( cps conversion ) of functions annotated as cooperative .    in this article </S>",
    "<S> , we study the application of the cpc translator to qemu , an open - source machine emulator which also uses annotated coroutine functions for concurrency . </S>",
    "<S> we first propose a new type of annotations to identify functions which never cooperate , and we introduce corocheck , a tool for the static analysis and inference of cooperation annotations . </S>",
    "<S> then , we improve the cpc translator , defining cps conversion as a calling convention for the c language , with support for indirect calls to cps - converted function through function pointers . finally , we apply corocheck and cpc to qemu ( 750000 lines of c code ) , fixing hundreds of missing annotations and comparing performance of the translated code with existing implementations of coroutines in qemu .    </S>",
    "<S> our work shows the importance of static annotation checking to prevent actual concurrency bugs , and demonstrates that cps conversion is a flexible , portable , and efficient compilation technique , even for very large programs written in an imperative language .    </S>",
    "<S> coroutines ; cps conversion ; static analysis . </S>"
  ]
}