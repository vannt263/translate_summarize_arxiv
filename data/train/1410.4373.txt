{
  "article_text": [
    "the current development of mobile and wireless technologies enables direct _ ad hoc _ communication between various kinds of mobile entities , such as vehicles , smartphones , terrestrian robots , flying robots , or satellites . in all these contexts ,",
    "the set of communication links depends on distances between entities , thus the network topology changes continuously as the entities move .",
    "not only changes are frequent , but in general they even make the network partitionned . clearly , the usual assumption of connectivity does not hold here , although another form of connectivity is often available over time and space ( temporal connectivity ) . also , the classical view of a network whose dynamics corresponds to _ failures _ is no longer suitable in these scenarios , where dynamics is the norm rather than the exception .",
    "this induces a shift in paradigm that strongly impacts algorithms .",
    "in fact , it even impacts the problems themselves .",
    "what does it mean , for instance , to elect a leader in such a network ? is the objective to distinguish a unique global leader , whose leadership then takes place over time and space , or is it to _ maintain _ a leader in each connected component , so that the decisions concerning each component are taken quickly and locally .",
    "the same remark holds for spanning trees .",
    "should an algorithm construct a unique , global tree whose logical edges survive intermittence , or should it build and maintain a _ forest _ of trees that strive to cover collectively all components in each instant ? both viewpoints make sense , and so far , were little studied in distributed computing ( see e.g.  @xcite for temporal trees , @xcite for maintained trees ) .",
    "we focus on the second interpretation , which reflects a variety of scenarios where the expected output of the algorithm should relate to the _ immediate _ configuration ( _ e.g. _ direct social networking , swarming of flying robots , vehicles platooning on the road ) .",
    "a particular feature of this type of algorithms is that they never terminate .",
    "more significantly , in highly dynamic networks , they are not even expected to stabilize to an optimal state ( here , a single tree per component ) , unless the changes stop , which never happens .",
    "this precludes , in particular , all approaches whereby the computation of a new solution requires the previous computation to have completed .",
    "this paper is an attempt to understand what can still be computed ( and guaranteed ) when no assumptions are made on the network dynamics : neither on the rate of change , nor on their simultaneity , nor on global connectivity .",
    "in other words , the topology is controlled by an almighty adversary . in this seemingly chaotic context , we present an algorithm that strives to maintain as few trees per components as possible , while always guaranteeing some properties .",
    "several works have addressed the spanning tree problem in dynamic networks , with different goals and assumptions .",
    "burman and kutten  @xcite and kravchik and kutten  @xcite consider a self - stabilizing approach where the legal state corresponds to having a ( single ) minimum spanning tree and the faults are topological changes .",
    "the strategy consists in recomputing the entire tree whenever changes occur .",
    "this general approach , sometimes called the `` blast away '' approach , is meaningful if stable periods of time exist , which is not assumed here .",
    "many spanning tree algorithms rely on random walks for their elegance and simplicity , as well as for the inherent localized paradigm they offer . in particular",
    ", approaches that involve multiple coalescing random walks allow for uniform initialization ( each node starts with the same state ) and topology independence ( same strategy whatever the graph ) .",
    "pionneering studies involving such processes include bar - ilan and zernik  @xcite ( for the problem of election and spanning tree ) , israeli and jalfon  @xcite ( mutual exclusion ) , and chapter 14 of aldous and fill  @xcite ( for general analysis ) .",
    "the principle of using coalescing random walks to build spanning trees in mildly dynamic networks was used by baala et al .",
    "@xcite and abbas et al .",
    "@xcite , where tokens are annexing territories gradually by capturing each other . regarding dynamicity , both algorithms require the nodes to know an upper bound on the cover time of the random walk , in order to regenerate a token if they are not visited during a long - enough period of time . besides the strength of this assumption ( akin to knowing the number of nodes @xmath0 , or the size of components in our case ) , the efficiency of the timeout approach decreases dramatically with the rate of topological changes .",
    "in particular , if they are more frequent than the cover time ( itself in @xmath1 ) , then the tree is constantly fragmented into `` dead '' pieces that lack a root , and thus a leader .",
    "another algorithm based on random walks is proposed by bernard et al .",
    "@xcite . here",
    ", the tree is constantly redefined as the token moves ( in a way that reminds the snake game ) . since the token moves only over present edges , those edges that have disappeared are naturally cleaned out of the tree as the walk proceeds .",
    "hence , the algorithm can tolerate failure of the tree edges .",
    "however it still suffers from detecting the disappearance of tokens using timeouts based on the cover time , which as we have seen , suits only slow dynamics .    a recent work by awerbuch et al .",
    "@xcite addresses the maintenance of _ minimum _ spanning trees in dynamic networks .",
    "the paper shows that a solution to the problem can be updated after a topological change using @xmath2 messages ( and same time ) , while the @xmath3 messages of the `` blast away '' approach was thought to be optimal .",
    "( this demonstrates , incidentally , the revelance of _ updating _ a solution rather than recomputing it from scratch in the case of minimum spanning trees . )",
    "the algorithm has good properties for highly dynamic networks .",
    "for instance , it considers as natural the fact that components may split or merge perpetually .",
    "furthermore , it tolerates new topological events while an ongoing update operation is executing . in this case",
    ", update operations are enqueued and consistently executed one after the other .",
    "while this mechanism allows for an arbitrary number of topological events _ at times _ , it still requires that such burst of changes are only episodical and that the network remains eventually stable for ( at least ) a linear amount of time in the number of nodes , in order for the update operations to complete and thus the logical tree to be consistent with physical reality .",
    "all the aforementioned algorithms either assume that _ global update _ operations ( e.g. wave mechanisms ) can be performed contemporaneously , or at least eventually , or that some node can collect _ global information _ about the tree structure .",
    "as far as dynamics is concerned , this forbids arbitrary and ever going changes to occur in the network .",
    "a purely localized scheme was proposed by casteigts et al .",
    "@xcite for the maintenance of a ( non - minimum ) spanning forest in unrestricted dynamic networks , using a coarse grain interaction model inspired from graph relabeling systems  @xcite .",
    "it can be described informally as follows .",
    "initially every node hosts a token and is the _ root _ of its own individual tree .",
    "whenever two roots arrive at the endpoints of a same edge ( see merging rule on figure  [ fig : scheme ] ) , one of them destroys its tokens and selects the other as parent ( _ i.e. _ the trees are merged ) .",
    "the rest of the time , each token executes a random walk within its own tree in the search for other merging opportunities ( circulation rule ) .",
    "tree relations are flipped accordingly .",
    "the fact that the random walk is _ confined _ to the underlying tree is crucial and different from all algorithms discussed above , in which they were free to roam everywhere without restriction .",
    "this simple feature induces very attractive properties for highly dynamic networks .",
    "in particular , whenever an edge of the tree disappears , the child side of that edge knows instantly that no token remains on its whole subtree .",
    "it can thus regenerate a token ( _ i.e. _ become root ) _ instantly _ , without global concertation nor further information collection . as a result , both merging and splitting of trees are managed in a purely localized fashion .    at an abstract graph level ,",
    "this very simple scheme guarantees that the network remains covered by a spanning forest at any time , in which 1 ) no cycle can ever appear , 2 ) maximal subtrees are always directed rooted trees ( with a token at the root ) , and 3 ) every node always belongs to such a tree , whatever the chaos of topological changes . on the other hand",
    ", it is not expected to reach an optimal state where a single tree covers each connected component . even if the network were to stabilize , convergence to the optimum ( though easy to be made certain ) would not be expected to occur fast . whether this general principle could be implemented in a message passing model remained an open question .",
    "this paper provides an implementation of the spanning forest principle in the synchronous message - passing model . due to the loss of atomicity and exclusivity in the interaction , the algorithm turns out to be much more sophisticated than its original counterpart .",
    "while still reflecting the very same high - level principle , it faces new problems that require conceptual differences .",
    "in particular , the original model prevented a node from both selecting a parent and being selected as parent simultaneously , making it easier to avoid cycle creations .",
    "one of the ingredients in the new algorithm to circumvent this problem is an original technique ( which we refer to as the _ unique score _ technique ) that consists of maintaining , network - wide , a set of score variables that always remain a permutation of the set of nodes ids .",
    "this mechanism allows us to break symmetry and avoid the formation of cycles in a context where ids alone could not .",
    "the paper is organized as follows . in section",
    "[ sec : model ] , we present the model and notations that we use throughout the paper .",
    "then section  [ sec : algorithm ] presents the algorithm , whose correctness analysis is outlined in section  [ sec : correctness ] and detailed in section  [ sec : detailed - proofs ] .",
    "section  [ sec : simulation ] presents experimental results that validate our algorithm .",
    "the network is represented by an untimed evolving graph  @xcite @xmath4 , such that @xmath5 , where @xmath6 is a static set of vertices and @xmath7 is a dynamically changing set of undirected edges . following kuhn et al .",
    "@xcite , we consider a synchronous ( thus rounded ) computational model , where in each round @xmath8 , the adversary chooses the set of edges @xmath7 that are present . in our case , this set is arbitrary ( _ i.e. _ the adversary is unrestricted ) . at the beginning of each round , each node sends a message that it has prepared at the end of the previous round .",
    "this message is sent to all its neighbors in @xmath7 , although the list of these neighbors is not know by the node .",
    "then it receives all messages sent by its neighbors ( in the same round ) , and finally computes its new state and the next message .",
    "hence , each round corresponds to three phases ( send , receive , compute ) , which corresponds to a rotation of the original model of  @xcite where the phases are ( compute , send , receive ) .",
    "this adaptation is not necessary , but it allows us to formulate correctness of our algorithm in terms of the state of the nodes _ after _ each round rather than in the middle of rounds .",
    "we assume that the nodes have a unique identifier taken from a totally ordered set , that is , for any two nodes @xmath9 and @xmath10 , it either holds that @xmath11 or @xmath12 .",
    "a node can specify what neighbor its message is intended to ( although all neighbors will receive it ) by setting the target field of that message .",
    "symmetrically , the @xmath13 of the emitter of a message can be read in the sender field of that message .",
    "since the edges are undirected , if @xmath9 receives a message from @xmath10 at round @xmath8 , then @xmath10 also receives a message from @xmath9 at that round .",
    "we call this property the _ reciprocity principle _ and it is an important ingredient for the correctness of our algorithm .",
    "using synchronous rounds allows us to represent the progress of the execution as a sequence of _ configurations _",
    "@xmath14 , where each @xmath15 corresponds to the state of the system _ after _ round @xmath8 ( except for @xmath16 , the initial state ) .",
    "each _ configuration _ consists of the union of all nodes variables , defined next .",
    "besides the i d variable , which we assume is externally initialized , each node has a set of variable that reflects its situation in the tree : ` status ` accounts for the possession of a token ( t",
    "if it has a token , n if it does not ) ; ` parent ` contains the i d of this node s parent ( @xmath17 if it has none ) ; ` children ` contains the set of this node s children ( @xmath18 if it has none ) .",
    "observe that both variables status and parent are somewhat redundant , since in the spanning forest principle ( see section  [ sec : principle ] ) the possession of a token is equivalent to being a root .",
    "our algorithm enforces this equivalence , yet , keeping both variables separated simplifies the description of the algorithm and our ability to think of it intuitively .",
    "variable neighbors contains the set of nodes from which a message was received in the last reception .",
    "these neighbors may or may not belong to the same tree as the current node .",
    "variable contender contains the i d of a neighbor that the current node considers selecting as parent in the next round ( or @xmath17 if there is no such node ) .",
    "finally , the variable score is the main ingredient of our cycle - avoidance mechanism , whose role is described below .",
    "all the nodes are uniformly initialized .",
    "they are initially the root of their own individual tree ( _ i.e. _ @xmath19 , @xmath20 , and @xmath21 ) . they know",
    "none of their neighbors ( @xmath22 ) , have no contenders ( @xmath23 ) , and their score is set to their own i d .",
    "messages are composed of a number of fields : sender is the i d of the sending node ; senderstatus its status ( either t or n ) ; and score its score when the message was prepared .",
    "the field action is one of @xmath24 .",
    "informally , @xmath25 messages are sent by a root node to another root node to signify that it `` adopts '' it as a parent ( merging operation ) ; @xmath26 messages are sent by a root node to circulate the token to one of its children ( circulation operation ) ; @xmath27 messages are sent by a node by default , when none of the other messages are sent , to make its presence and status known by its neighbors .",
    "finally , target is the i d of the neighbor to which a flip or a select message are intended ( @xmath17 for hello messages ) .    received messages are stored in a variable ` mailbox ` , which is a map collection whose _ keys _ are the senders i d ( _ i.e. , _ a message whose sender i d is @xmath9 can be accessed as mailbox[@xmath9 ] ) . in each round",
    ", the algorithm makes use of a receive ( ) function that clears the mailbox and fill it with all the messages received in that round ( one for each physical neighbor ) .",
    "a node can thus update the set of its neighbors by fetching the _ keys _ of its mailbox .",
    "similarly , it can eliminate from its list of children those nodes which are no more neighbor .    as mentioned above",
    ", every node prepares at the end of a round the message to be sent at the beginning of the next round .",
    "this message is stored in a variable ` outmessage ` .",
    "we allow the short hand @xmath29 to define a new message @xmath30 whose emitter is node @xmath31 ( with status @xmath32 and score @xmath33 ) ; target is node @xmath34 ; and action is @xmath35 .",
    "the mailbox is initially empty ( mailbox @xmath36 ) and ` outmessage ` is initialized to @xmath37 .",
    "the algorithm implements the general scheme presented in section  [ sec : principle ] . in this section",
    "we explain how each of the three core operations ( _ merging _ , _ circulation _ , _ regeneration _ ) is implemented .",
    "then we discuss the specificities of the merging operation in more detail and the problems that arise due to its entanglement with the circulation operation , a fact due to the loss of atomicity in the message passing model .",
    "the resulting solution is substantially more sophisticated than its original scheme , and yet it faithfully reflects the same high - level principle . let us start with some generalities . in each round , each node broadcasts to its neighbors a message containing , among others , its status ( t or n ) and an action ( select , flip , or hello ) . whether or not the message is intended to a specific @xmath38 ( which is the case for select and flip messages ) , all the nodes who receive it can possibly use this information for their own decisions .",
    "more generally , based on the received information and the local state , each node computes at the end of the round its new status and the local structure of its tree ( variables ` children ` and ` parent ` ) , then it prepares the next message to be sent .",
    "we now describe the three operations . throughout the explanations ,",
    "the reader is invited to refer to figure  [ fig : example ] , where an example of execution involving all of them is shown . all details are also given in the listings of algorithm  [ algo : main ] and  [ algo : functions ] .",
    "if a root ( _ i.e. _ a node having a token ) , say @xmath10 , detects the existence of a neighbor root with higher score than its own , then it considers that node as a possible ` contender ` , _",
    "i.e. _ as a node that it might select as a parent in the next round .",
    "if several such roots exist , then the one with highest score , say @xmath9 , is chosen . at the beginning of the next round",
    ", @xmath10 sends a @xmath25 message to @xmath9 to inform it that it is its new parent .",
    "two cases are possible : either the considered edge is still present in that round , or it disappeared in - between both rounds . if it is still present , then @xmath9 receives the message and adds @xmath10 to its children list , among others ( line  [ line : addchild ] ) . as for @xmath10 , it sets its parent variable to @xmath9 and its status to n ( lines  [ line : testadoptparent ] and  [ line : becomeordinary ] ) . if the edge disappeared , then @xmath9 does not receive the message , which is lost . however",
    ", due to the reciprocity of message exchange , @xmath10 does not receive a message from @xmath9 either and thus simply does not executes the corresponding changes . by the end of the round",
    ", either the trees are properly merged , or they are properly separated .",
    "if a root @xmath10 does not detect another root with higher score , then it selects one of its children at random , if it has any ( see line  [ line : prepareflip ] ) , otherwise it simply remains root .",
    "randomness is not a strict requirement of our algorithm and replacing it with any deterministic strategy would not affect correctness of the algorithm .",
    "once the child is chosen , say @xmath9 , the root prepares a flip message intended to @xmath9 , and sends it at the beginning of the next round .",
    "two cases are again possible , whether or not the edge @xmath39 is still present in that round .",
    "if it is still present , then @xmath9 receives the message , it updates its status and adds @xmath10 to its children list , among others ( lines  [ line : becomeroot ] and line  [ line : addchild ] ) . as for @xmath10 , it sets its parent variable to @xmath9 and its status to n ( lines  [ line : testadoptparent ] and  [ line : becomeordinary ] ) . if the edge disappeared , then @xmath10 can detect it as before simply does not executes the corresponding changes .",
    "node @xmath9 , on the other hand , detects that the edge leading to its current parent disappeared , thus it regenerates a token ( discussed next ) .",
    "notice that in the absence of a merging opportunity , a node receiving the token in round @xmath8 will immediately prepare a flip message to circulate the token in the next round .",
    "unless the tree is composed of a single node , the tokens are thus moved in each round . in order for them to remain detectable in this case , the status announced in @xmath26 messages is t ( whereas it is n for @xmath25 messages ) .",
    "the first thing a non - root node does after receiving the messages of the current round is to check whether the edge leading to its current parent is still present . if the edge disappeared , then the node regenerates a root directly ( line  [ line : become ] ) .",
    "a nice property of the spanning forest principle is that this can not happen twice in the same tree . and",
    "if a tree is broken into several pieces simultaneously , then each of the resulting subtree will have exactly one node performing this operation .",
    "unlike the high - level graph model from  @xcite , in which the merging operation involved two nodes in an _ exclusive _ way , the non - atomic nature of message passing allows for a _ chain _ of selection that may involve an arbitrary long sequence of nodes ( e.g. @xmath31 selects @xmath32 , @xmath32 selects @xmath35 , and so on ) .",
    "this has both advantages and drawbacks . on the good side",
    ", it makes the initial merging process very fast ( see rounds @xmath40 and @xmath41 in figure  [ fig : example ] to get an example ) . on the bad side , it is the reason why scores need to be introduced to avoid cycles . indeed , relying only on a mere comparison of i d to avoid cycles is not sufficient .",
    "consider a chain of selection in round @xmath8 that ends up at some root node @xmath9 .",
    "nothing prevents @xmath9 to have passed the token to a lower - id child , say @xmath10 , in the previous round @xmath42 ( that same round when @xmath9 s status @xmath43 was overheard by the next - to - last root in the chain ) .",
    "now , nothing again prevents @xmath10 to have selected one of the nodes in the selection chain in round @xmath8 , thereby creating a cycle .",
    "the score mechanism prevents such a situation by enforcing that after each flip , the new root has a larger score than its predecessor ( see lines  [ line : min - score ] and  [ line : max - score ] in algorithm  [ algo : functions ] ) .",
    "the score mechanism also guarantees that the current set of scores ( network - wide ) is always a permutation of the initial set of scores .",
    "hence , scores are always unique .",
    "all of these elements are crucial ingredients in the proofs of correctness of section  [ sec : correctness ] .",
    "each token performs a random walk in its underlying tree . hence , unless some of the trees are bipartite , the configuration will eventually ( and with high probability ) stabilize into a single tree per connected component if the network stops changing .",
    "although convergence is not the main focus here , we believe that pathetic scenarios where some trees are bipartite can easily be avoided , by making the tokens stop for a random additional round at the nodes ( _ lazy _ walk ) .",
    "this way , the symmetry of bipartiteness is eventually broken _ w.h.p .",
    "_    ` procedure become_root `    ` procedure adopt_parent(outmessage ) `    ` procedure adopt_child(message ) `    ` procedure prepare_message(action , target ) `",
    "this section summarizes the correctness analysis of our algorithm , whose detail ( proofs of all lemmas and theorems ) can be found in section  [ sec : detailed - proofs ] .",
    "we first define a handful of instrumental concepts that help minimize the number of properties to be proven . then , as we start formulating the key properties to be proved , we adopt concise notations regarding the state of the system .",
    "precisely , we denote by @xmath44 ( resp .",
    "@xmath45 ) the value of variable @xmath46 at node @xmath9 before ( resp . after )",
    "round @xmath8 .",
    "notice that for any node @xmath9 , round @xmath8 , and variable @xmath46 , we have @xmath47 .",
    "we use whichever notation is the most convenient in the given context .      these definitions are not specific to our algorithm , they are general graph concepts that simplify the subsequent proofs .",
    "[ def : pseudoforest ] a directed graph whose vertices have outdegree at most 1 is a _ pseudoforest_. a vertex whose outdegree is 0 is called a _",
    "root_. the weakly connected components of a pseudoforest are called",
    "_ pseudotrees_.",
    "[ lem : one_root ] a pseudotree has at most one root .    by definition ,",
    "a pseudotree @xmath48 is connected , thus @xmath49 .",
    "if @xmath50 has several roots , then at least two nodes in @xmath51 have no outgoing edge . since the others have at most one , we must have @xmath52 , which is a contradiction .    [",
    "lem : pseudotree_tree ] if a pseudotree @xmath50 contains a root @xmath53 , then it has no cycle .",
    "let @xmath54 be the set of nodes at distance @xmath40 from @xmath55 .",
    "since @xmath53 has outdegree @xmath56 , there is an edge from each node in @xmath57 to @xmath53 .",
    "since @xmath50 is a pseudotree , these nodes have no other outgoing edge than those ending up in @xmath58 .",
    "the same argument can be applied inductively , all nodes at distance @xmath8 having no other outgoing edges than those ending up in @xmath59 .",
    "[ def : forest ] at the light of lemma  [ lem : one_root ] and  [ lem : pseudotree_tree ] , we define a _",
    "correct tree _ ( or simply a _ tree _ ) as a pseudotree in which a root can be found .",
    "we naturally define a _",
    "correct forest _",
    "( or simply a _ forest _ ) as a pseudoforest whose pseudotrees are trees .    finally ,",
    "because forests are considered in a spanning context , we say that a pseudoforest @xmath60 is a correct forest _ on graph _",
    "@xmath61 iff @xmath60 is a correct forest _ and _ @xmath60 is a subgraph of @xmath61 .",
    "defining correct trees as pseudotrees in which a root can be found is the key .",
    "when the moment arrives , this will allow us to reduce the correctness of our algorithm to the presence of a root in each pseudotree .        at the end of a round",
    ", the state of an edge ( whether it belongs to a tree , and if so , in what direction ) must be consistently decided at both endpoints :    the configuration @xmath15 is forest consistent if and only if for all nodes @xmath9 , @xmath62 .",
    "the proof of forest consistency is inductively established by theorem  [ th : consistency]lala , based on consistency of the initial configuration ( lemma [ lem : c0-forestconsistency ] ) and the maintenance the consistency over the rounds ( lemma [ lem : consistency ] ) .",
    "forest consistency allows us to reduce the output of interest of the algorithm after each round @xmath8 to the mere ` parent ` variable .      at the end of round @xmath8 , the values of all ` parent ` variables should be consistent with the underlying graph @xmath63 .",
    "the configuration @xmath15 is graph consistent if and only if for all nodes @xmath9 , @xmath64 .",
    "this property is established by corollary [ co : consistency ] .",
    "graph consistency allows us to say that the output of the algorithm forms a pseudoforest on @xmath63 .",
    "[ def : f_i ] given a round @xmath65 , occurring on graph @xmath63 , the graph @xmath66 such that @xmath67 is called the _ pseudoforest _ resulting from round  @xmath8 .      as explained in section  [ sec : variables ] , the variables parent and status are somewhat redundant , since the possession of a token is synonymous with being a root .",
    "the equivalence between both variables after each round is established in lemma  [ lem : l5 ] .",
    "the main advantage of this equivalence is that it allows us to formulate and prove a large number of lemmas based on whichever of the two variables is the most convenient ( and intuitive ) for the considered property .      in this section",
    ", we prove that the resulting forest is always correct ( definition [ def : forest ] ) . to achieve that goal",
    ", we first define a validity criterion at the node level , which recursively ensures the correctness of the pseudotree this node belongs to thanks to definition  [ def : forest ] ( _ i.e. _ the existence of a root implies correctness ) .",
    "a node @xmath9 is said to be valid at the beginning of round @xmath8 if either @xmath68 or @xmath69 is valid .",
    "the correctness of the whole forest can thus be established through showing that , first , it is initially correct ( lemma  [ lem : initial_forest ] ) and , second , if it is correct after round @xmath8 , then it is correct after round @xmath70 ( theorem  [ lem : nodes_validity ] ) .",
    "the latter is difficult to prove , and it involves a number of intermediate steps that correspond to a case analysis based on every action a node can perform ( sending flip messages , select messages , etc . ) .",
    "we first prove that a node @xmath9 that sends a successful flip to @xmath10 in a round , is valid at the end of that round ( lemma [ lem : flip - valid ] ) because at the end of that round @xmath10 is a root .",
    "the proof relies on the fact that during a given round , a node can not receive a flip and send a select or a flip ( lemma [ lem:2flips ] ) .",
    "we then prove some necessary properties on the score variable at each node .",
    "for instance , a node changes its score at most once during a round ( lemma [ lem : no - flip - score ] and [ lem : change_score - once ] ) . also , the set of all scores are a permutation of the node identifiers after each round ( lemma [ lem : permutation ] )",
    ".    then we prove that a node that sends a successful select in a round @xmath8 , is valid at the end of that round ( lemma  [ lem : select_valid ] ) .",
    "this part is the most technical and is the one that proves that chains of selection can not create cycles thanks to the property that score variables remain a permutation of all nodes ids .    finally , we prove that all roots at the beginning of a round are still valid at the end of the round ( lemma [ lem : t - vald ] ) . therefore ,",
    "if all nodes are valid at the beginning of round , then they are also valid at the end of the round ( theorem [ lem : nodes_validity ] ) . since they are initially valid ( lemma  [ lem : initial_forest ] ) , we conclude by induction on the number of rounds .",
    "[ lem : c0-forestconsistency ] [ lem : initial_forest ] the configuration @xmath16 is forest consistent and graph consistent . in @xmath16 ,",
    "the resulting pseudoforest is correct .",
    "the parent variable is initialized to @xmath17 .",
    "so , the configuration @xmath16 is forest consistent and graph consistent .",
    "any node @xmath9 belonging to the pseudotree @xmath71 .",
    "each of these pseudotrees contains a root ( @xmath9 itself ) and is therefore a correct tree .",
    "we say that @xmath9 _ sends a flip _",
    "_ select _ ) in round @xmath8 if and only if @xmath72 ( resp . _ select _ ) .",
    "we say that it sends it _ to node _",
    "@xmath10 if and only if @xmath73 . finally the flip or select is said to be _ successful _",
    "_ failed _ ) if @xmath74 ( resp .",
    "@xmath75 ) .",
    "[ lem : l5 ] for all round @xmath76 , and for all node @xmath9 , @xmath77    initially , at any node @xmath9 , @xmath78 and @xmath79 .",
    "the change of @xmath80 to @xmath81 always comes with the assignment of a non - null @xmath82 ( @xmath83 ) to @xmath84 ( procedure ` adopt_parent ( ) ` ) , and assigning the value @xmath43 to @xmath80 is always followed by the change of @xmath84 to @xmath17 ( procedure ` become_root ( ) ` ) .",
    "so at any configuration , @xmath85 if and only if @xmath86 .",
    "[ lem : flip - procedure ] if @xmath9 does not send a flip or select in round @xmath8 , then @xmath9 does not execute the procedure ` adopt_parent ( ) ` during round @xmath8 .",
    "the execution of the procedure ` adopt_parent ( ) ` by @xmath9 is conditioned by the sending of a select or a flip by @xmath9 during the current round ( line [ line : testadoptparent ] ) .",
    "[ obs : message_pepared ] at time where a node @xmath9 prepares its message to be sent during the round @xmath8 , we have @xmath87 ( resp .",
    "@xmath88 ) .",
    "[ lem : flip - select - t ] if @xmath9 sends a flip or select in round @xmath8 , then @xmath89 .",
    "@xmath9 sends in round @xmath8 the message prepared in round @xmath42 . if @xmath9 sends a flip or a select in round @xmath8 then in round @xmath42 ` prepare_message ( ) ` is called with flip or select as action ( lines [ line : prepareselect ] or [ line : prepareflip ] ) .",
    "both instructions are conditioned by @xmath90 .",
    "[ lem : t - if - t ] if @xmath10 sends a message containing @xmath43 in round @xmath8 , then @xmath91 .",
    "the procedure ` prepare_message ( ) ` is executed by a node @xmath9 in round @xmath42 to construct the message @xmath30 to be sent in round @xmath8 . in all cases ` prepare_message ( ) ` sets @xmath92 to @xmath43 only if @xmath78 .",
    "[ lem : select - score ] if @xmath9 sends a select to @xmath10 in round @xmath8 , then @xmath93 .",
    "the value of the @xmath94 field in the message sent by a node @xmath10 in round @xmath42 is @xmath95 . assumes that the node @xmath9 sends a select to @xmath10 in a round @xmath8 .",
    "so , during the round @xmath42 , @xmath9 sets its @xmath96 variable to @xmath10 and its @xmath97 variable to @xmath98 @xmath99 being the message sent by @xmath10 at the begining of round @xmath42 . from that time to the end of round @xmath42 , @xmath100 is not modified .",
    "so @xmath93 , if @xmath9 sends a select to @xmath10 in a round @xmath8 .",
    "[ lem : cond - single - flip ] if at the beginning of round @xmath8 , the configuration is forest consistent then only @xmath69 can send a flip at destination of @xmath9 during the round @xmath8 .    a node @xmath10 can prepare a flip message to the node @xmath9 at then end of round @xmath42 only if @xmath101 .",
    "we have @xmath102 according to the hypothesis ( forest consistency at the beginning of round ) . therefore ,",
    "only the node @xmath69 can prepare a flip message at destination of @xmath9 , at the end of round @xmath42 .",
    "[ lem : add_parent ] let @xmath9 be a node such that @xmath103",
    ". then @xmath9 sends a successful flip or select to @xmath10 during the round @xmath8 .",
    "the only change of @xmath104 by @xmath9 to a non - null identifier @xmath10 in a round @xmath8 is at the execution of the procedure ` adopt_parent ( ) ` which is conditioned by the reception of a message from @xmath10 ( line [ line : becomeordinary ] ) .",
    "if @xmath9 receives the message of @xmath10 during round @xmath8 then @xmath10 effectively receives the message sent by @xmath10 ( _ reciprocal reception property _ ) .",
    "[ lem : keep_parent ] let @xmath9 be a node such that @xmath105 .",
    "we have @xmath106 .    by lemma [ lem : l5 ]",
    ", we have @xmath107 .",
    "so , @xmath9 does not send a flip or select during the round @xmath8 ( lemma [ lem : flip - select - t ] ) .",
    "then , @xmath9 does not execute ` adopt_parent ( ) ` during the round @xmath8 according to lemma [ lem : flip - procedure ] .",
    "since @xmath108 we conclude that @xmath9 does not execute the procedure ` become_root ( ) ` during the round @xmath8 .",
    "so @xmath9 did receive a message from @xmath69 in round @xmath8 .",
    "we have @xmath106 .",
    "[ co : consistency ] every configuration is graph consistent .",
    "the configuration reached after any round is graph consistent ( lemmas [ lem : add_parent ] and [ lem : keep_parent ] ) .",
    "[ lem : n - parent ] if @xmath102 then @xmath109 or @xmath110 .",
    "according to lemma [ lem : l5 ] , we have @xmath107 , so u can not send a flip or a select in round @xmath8 ( by lemma [ lem : flip - select - t ] ) .",
    "therefore , @xmath9 does not execute ` adopt_parent ( ) ` in round @xmath8 ( lemma [ lem : flip - procedure ] ) .",
    "we conclude that @xmath109 or @xmath110 .",
    "[ lem : cond-2flips ] assume that at the beginning of round @xmath8 , the configuration is forest consistent . if @xmath9 receives a flip in round @xmath8 , then it does not send a flip nor a select in round @xmath8 .",
    "we will establish the contraposition of the lemma statement : if @xmath9 sends a flip or a select in round @xmath8 , then it does not receive a flip in round @xmath8 . by lemma [ lem",
    ": flip - select - t ] , we have @xmath68 . according to lemma [",
    "lem : l5 ] , @xmath111 . thus according to the hypothesis ( forest consistency at the beginning of round ) , for any node @xmath10 , @xmath112 .",
    "therefore no node has prepared a flip message at destination of @xmath9 , in round @xmath42 .",
    "so @xmath9 can not receive a flip in round @xmath8 .",
    "[ lem : add_parent_add_child ] assume that at the beginning of round @xmath8 , the configuration is forest consistent .",
    "if in round @xmath8 , @xmath9 changes @xmath84 to @xmath10 then @xmath113 : @xmath114 .",
    "@xmath9 sets @xmath84 to @xmath10 only if the flip or select was successful ( lemma [ lem : add_parent ] ) .",
    "therefore @xmath10 has received the flip or select message sent by @xmath9 .",
    "the addition of a node @xmath9 to @xmath115 by @xmath10 is done during the excution of the procedure ` adopt_child ( ) ` which is conditioned by the reception of a flip or a select message @xmath116 from @xmath9 ( @xmath117 , line [ line : addchild ] ) .",
    "the procedure ` adopt_child ( ) ` is executed after line [ line : intersection ] which is the only instruction that could remove @xmath9 from @xmath115 .",
    "so , @xmath113 . we have @xmath118 .",
    "[ lem : add_child_add_parent ] assume that at the beginning of round @xmath8 , the configuration is forest consistent . if in round @xmath8 , @xmath10 adds @xmath9 to @xmath115 then @xmath108 : @xmath119 .",
    "@xmath10 adds @xmath9 to @xmath115 only if it excutes the procedure ` adopt_child ( ) ` which is conditioned by the reception of a flip or a select sent by @xmath9 .",
    "as the reception of messages is reciprocal , @xmath9 also receives in round @xmath8 a message from @xmath10 .",
    "this satisfies the condition for @xmath9 to execute the procedure ` adopt_parent ( ) ` which sets @xmath84 to @xmath10 .",
    "only the execution of ` become_root ( ) ` ( at line [ line : becomeroot ] ) could modify the value of @xmath84 .",
    "this procedure would be executed only if @xmath9 has received a flip during round @xmath8 which can not be the case .",
    "notice that @xmath9 does not receive a flip during the round @xmath8 ( lemma [ lem : cond-2flips ] ) .",
    "[ lem : rem_parent_rem_child ] assume that at the beginning of round @xmath8 , the configuration is forest consistent .",
    "if in round @xmath8 , @xmath9 changes @xmath84 from @xmath10 to another value then @xmath120 : @xmath121 .",
    "if @xmath9 changes @xmath122 then we have @xmath123 ( lemma [ lem : n - parent ] ) .",
    "only the execution of ` become_root ( ) ` by @xmath9 sets @xmath84 to @xmath124 .",
    "the procedure ` become_root ( ) ` is executed in two cases : at the detection of a disconnection ( line [ line : become ] ) , and at the reception of a flip message ( line [ line : becomeroot ] ) .",
    "in the first case , the _ reciprocal reception property _ ensures that @xmath10 does not receive the message sent by @xmath9 .",
    "so , @xmath10 removes @xmath9 from @xmath125 ( line [ line : intersection ] ) .    in the second case",
    ", @xmath9 receives a flip from @xmath69 ( lemma [ lem : cond - single - flip ] ) . according to the _ reciprocal reception property _",
    ", @xmath10 receives the message sent by @xmath9 during the round @xmath8 .",
    "so , @xmath10 executes ` adopt_parent((i^-)v.outmessage ) ` which removes @xmath9 ( i.e. @xmath126 ) from @xmath115 ( line [ line : becomeordinary ] ) .",
    "[ lem : rem_child_rem_parent ] assume that at the beginning of round @xmath8 , the configuration is forest consistent .",
    "if in round @xmath8 , @xmath10 removes @xmath9 from @xmath115 then @xmath127 : @xmath128 .",
    "@xmath10 removes @xmath9 from @xmath115 in two cases : at the detection of a disconnection ( @xmath10 does not receive a message from @xmath9 , line [ line : intersection ] ) , and when @xmath10 executes ( ` adopt_parent((i).v.outmessage ) ` , line [ line : becomeordinary ] )    in the first case , the _ reciprocal reception property _ ensures that @xmath9 does not receive the message sent by @xmath10 during the round @xmath8 .",
    "so , @xmath9 becomes a root : it executes the procedure ` become_root ( ) ` ( line [ line : become ] ) .    in the second case",
    ", @xmath10 executes ` adopt_parent((i).v.outmessage ) ` .",
    "so @xmath10 did send a successful flip or select ( lemma [ lem : flip - procedure ] ) . as @xmath10 removes @xmath9 from @xmath115 during the execution of ` adopt_parent((i).v.outmessage ) ` , we have @xmath129 and @xmath130 ( see the procedure ` adopt_parent(outmessage ) ` ) .",
    "so @xmath10 sends a successful flip to @xmath9 during round @xmath8 .",
    "therefore , in round @xmath8 , @xmath9 executes the procedure ` become_root ( ) ` ( line [ line : becomeroot ] ) : @xmath9 sets @xmath84 to @xmath124 .",
    "[ lem : consistency ] let @xmath8 be a round starting from a forest consistent configuration .",
    "the configuration reached at the end of round @xmath8 is forest consistent    the configuration after the round @xmath8 is forest consistent according to lemmas [ lem : add_parent_add_child ] , [ lem : add_child_add_parent ] , [ lem : rem_parent_rem_child ] , [ lem : rem_child_rem_parent ] .",
    "notice that in the case where @xmath9 does not change the value of its parent variable ( _ resp_. @xmath9 stays in @xmath115 ) during round @xmath8 , at the end of round @xmath8 the forest consistency property is preserved according to the contraposition of lemma [ lem : rem_child_rem_parent ] ( _ resp_. contraposition of lemma [ lem : rem_parent_rem_child ] ) and the hypothesis .",
    "[ th : consistency ] every configuration is forest consistent .",
    "@xmath16 is forest consistent ( lemma [ lem : c0-forestconsistency ] ) .",
    "the configuration reached after any round is forest consistent ( lemma [ lem : consistency ] ) .",
    "[ lem : single - flip ] let @xmath10 be a node .",
    "only @xmath131 can send a flip at destination of @xmath10 during the round @xmath8 .    at the beginning of round @xmath8 ,",
    "the configuration is forest consistent ( theorem [ th : consistency ] ) .",
    "therefore , only the node @xmath131 can prepare a flip message at destination of @xmath10 , at the end of round @xmath42 ( lemma [ lem : cond - single - flip ] ) .",
    "[ lem:2flips ] if @xmath9 receives a flip in round @xmath8 , then it does not send a flip nor a select in round @xmath8 .    at the beginning of round @xmath8 ,",
    "the configuration is forest consistent ( theorem [ th : consistency ] ) .",
    "therefore no node has prepared a flip message at destination of @xmath9 , in round @xmath42 ( lemma [ lem : cond-2flips ] ) .",
    "[ lem : adoption ] if @xmath9 sends a successful flip or select to @xmath10 in round @xmath8 , then @xmath132 and @xmath109 .    in round @xmath8 , @xmath133 or select and @xmath134 .",
    "during the round @xmath8 , @xmath9 executes the procedure ` adopt_parent ( ) ` ( line [ line : becomeordinary ] ) which sets @xmath122 to @xmath10 . according to lemma [ lem:2flips ]",
    ", @xmath9 did not receive any flip message during the round @xmath8 .",
    "only an execution of ` become_root ( ) ` by @xmath9 at line [ line : becomeroot ] can change the value of @xmath84 during the round @xmath8 .",
    "this line is not executed during round @xmath8 .",
    "[ lem : received - flip ] if @xmath9 sends a successful flip to @xmath10 , then @xmath135 .",
    "@xmath10 received @xmath136 in round @xmath8 , so @xmath74 .",
    "@xmath10 executes the procedure ` become_root ( ) ` that changes @xmath137 to @xmath43 .",
    "after the execution of line [ line : becomeordinary ] , no instruction can set @xmath137 to @xmath81 until the end of round @xmath8 .",
    "so @xmath135 .",
    "[ lem : flip - valid ] if @xmath9 sends a successful flip in round @xmath8 , then @xmath9 is valid after round @xmath8 .",
    "by lemmas [ lem : adoption ] and [ lem : received - flip ] @xmath9 s parent has a status @xmath43 after round @xmath8 .",
    "[ lem : received - flip - score ] if @xmath9 sends a successful flip to @xmath10 , then @xmath138 .",
    "@xmath9 sent a message @xmath136 to @xmath10 at the beginning of round @xmath8 such that @xmath139 flip , @xmath140 and @xmath141 .",
    "@xmath10 received @xmath136 in round @xmath8 , so @xmath74 .",
    "@xmath10 executes the procedure `",
    "adopt_child(mu ) ` at line [ line : addchild ] in round @xmath8 .",
    "this procedure sets the current score of @xmath10 to @xmath142 , as @xmath143 .",
    "after the execution of this instruction , we have @xmath144 .",
    "we notice that after this operation , no instruction can change the value of @xmath145 ( lemma [ lem : single - flip ] .",
    "[ lem : no - flip - score ] @xmath146 unless @xmath9 sends or receives a successful flip in round @xmath8 .",
    "@xmath9 changes its @xmath94 value only by executing ` adopt_parent(m_u ) ` or ` adopt_child(m_u ) ` .",
    "both instructions that changes @xmath100 value in these procedures ( algorithm [ algo : functions ] , line [ line : becomeordinary ] , [ line : addchild ] ) are conditioned by @xmath147 .",
    "[ lem : change_score - once ] a node @xmath9 changes @xmath100 at most once during a round .",
    "a node sends at most one flip message during a round .",
    "a node receives at most one flip message during a round ( lemma [ lem : single - flip ] ) .",
    "either a node receives a flip , sends one , or it does not receive and does not send a flip during a given round ( lemma [ lem:2flips ] ) .",
    "so , according to lemma [ lem : no - flip - score ] , a node changes @xmath100 at most once during a round .",
    "[ lem : permutation ] before each round , the set of scores is a permutation of the set of identifiers .",
    "after the initialization in each node @xmath9 , @xmath148 .",
    "a node @xmath9 changes its score only by executing ` adopt_parent ( ) ` or ` adopt_child ( ) ` .",
    "we will do a proof by induction .",
    "we assume at the beginning of round @xmath8 , the set of scores is a a permutation of the set of indentifiers .",
    "we have for any node @xmath9 , @xmath143 .    according to lemma [ lem : no - flip - score ] ,",
    "only a node sending or receiving a successful flip may change its @xmath94 value .",
    "assume that the node @xmath9 changes its @xmath94 value during round @xmath8 .",
    "without lost of generality , we assume @xmath9 sends the successful flip to a node @xmath10 in round @xmath8 .    by hypothesis ,",
    "@xmath9 changes its @xmath94 to @xmath149 during the execution of ` adopt_parent ( ) ` in round @xmath8 .",
    "we have @xmath150 .",
    "@xmath10 executes the procedure ` adopt_child(mu ) ` at line [ line : addchild ] in round @xmath8 .",
    "this procedure sets the current score of @xmath10 to @xmath142 , as @xmath143 . after the execution of this instruction",
    ", we have @xmath151 .    according lemma [ lem : change_score - once ] , we have @xmath152 and @xmath153 .      in lemmas [",
    "lem : selected - t ] and [ lem : selected - n ] , we establish that if @xmath9 sends a successful select to @xmath10 in round @xmath8 either @xmath154 or @xmath155 . in the first case , we have @xmath156 , and in the second case , we have @xmath157 .",
    "let @xmath158 be a series of nodes @xmath159 such that @xmath160 and such that @xmath161 sends a successful select to @xmath162 during the round @xmath8 .",
    "as a @xmath158 s subchain of nodes having strictly increasing scores at the beginning of round @xmath8 may be built : @xmath158 has not loop .",
    "so @xmath158 ends by a node having a token : all nodes on that chain are valid .    [",
    "lem : send - t - become - n - parent - t ] if @xmath10 sends a message containing @xmath43 in round @xmath8 and @xmath163 , let @xmath164 , then @xmath165 .",
    "if @xmath10 sends a message containing @xmath43 in round @xmath8 , then @xmath166 . if @xmath163 , then @xmath10 has executed ` adopt_parent ( ) ` in round @xmath8 , because it is the only procedure that sets @xmath137 to @xmath81 .",
    "@xmath10 executes ` adopt_parent ( ) ` only if it has sent a flip message @xmath167 to a node @xmath168 ( @xmath169 select because @xmath170 ) , and if @xmath168 has received the message @xmath167 ( _ reciprocal reception property _ ) . at the reception of @xmath167 by @xmath168",
    ", @xmath168 executes ` become_root ( ) ` ( line 16 ) which sets @xmath171 to @xmath43 and from this line until the end of the round no instruction can change @xmath171 to @xmath81 .",
    "so @xmath165 .",
    "at the execution of ` adopt_parent ( ) ` by @xmath10 , @xmath10 sets @xmath172 to @xmath168 . after this instruction",
    "there is only ` becomes_root ( ) ` that can modifie the value of @xmath172 , and which is conditioned by the reception of a flip message .",
    "according to lemma [ lem:2flips ] @xmath10 can not call ` becomes_root ( ) ` because it can not receive a flip message .",
    "so @xmath164 .",
    "so , if @xmath10 sends a message containing @xmath43 in round @xmath8 and @xmath163 , and @xmath164 , then @xmath165 .",
    "[ lem : sendt ] if @xmath10 sends a message containing @xmath43 in round @xmath8 and @xmath163 , let @xmath164 , then @xmath173 .",
    "we have @xmath91 because in round @xmath42 , @xmath137 can not be modified after the execution of ` prepare_message ( ) ` . if @xmath174 then @xmath10 sends a flip message to one of its children , named @xmath9 , in round @xmath8 .",
    "either @xmath74 , then @xmath109 , @xmath135 and @xmath175 ( see lemmas [ lem : received - flip ] and [ lem : received - flip - score ] ) .",
    "otherwise @xmath166 .",
    "[ lem : selected - was - t ] if @xmath9 sends a successful select to @xmath10 in round @xmath8 then @xmath176 .",
    "node @xmath9 prepared a select message to @xmath10 in round @xmath42 , thus it had @xmath177 , which implies it received from @xmath10 a message containing @xmath43 .",
    "we have then @xmath176 because after the execution of ` prepere_message ( ) ` by @xmath10 in round @xmath178 , @xmath137 can not be changed .",
    "[ lem : selected - t ] if @xmath9 sends a successful select to @xmath10 in round @xmath8 and @xmath154 , then @xmath156 .    by lemma  [ lem : selected - was - t ] @xmath179 .",
    "then lemmas  [ lem : select - score ] and  [ lem : no - flip - score ] respectively imply that @xmath93 and @xmath180 .",
    "[ lem : selected - n ] if @xmath9 sends a successful select to @xmath10 in round @xmath8 and @xmath181 , then let @xmath182 .",
    "it holds that @xmath183 and @xmath184 .    by lemma  [ lem : selected - was - t ]",
    "we have @xmath179",
    ". then lemmas  [ lem : select - score ] and  [ lem : sendt ] respectively imply that @xmath93 and @xmath185 .",
    "lemma [ lem : send - t - become - n - parent - t ] implies that @xmath183 .",
    "[ lem : cancel ] if @xmath9 sends a failed flip or select in round @xmath8 , then @xmath186 .    by lemma [ lem :",
    "flip - select - t ] , we have @xmath89 .",
    "@xmath10 did not receive the message from @xmath9 implies that @xmath75 .",
    "so , in round @xmath8 , @xmath187 ( @xmath9 did not receive the message from @xmath10 ) .",
    "only during the execution of ` adopt_parent ( ) ` , called in line [ line : becomeordinary ] , @xmath9 can change its @xmath188 to @xmath81 .",
    "this procedure is not executed during the round @xmath8 .",
    "[ lem : conservation ] if @xmath68 and @xmath9 does not send a flip or select in round @xmath8 , then @xmath189 .    by lemma [ lem : flip - procedure ]",
    ", @xmath9 does not execute the procedure ` adopt_parent ( ) ` during the round @xmath8 .",
    "@xmath9 can set ` status ` variable to @xmath81 only if it executes ` adopt_parent ( ) ` .",
    "[ lem : all - but - select - valid ] if @xmath68 and @xmath9 does not send a successful select in round @xmath8 , then @xmath9 is valid after the round @xmath8 .",
    "according to lemma [ lem : flip - valid ] , after the successful sending of a flip message in round @xmath8 , @xmath9 is valid at the end of round @xmath8 .",
    "if @xmath9 sends a failed select or a failed flip then @xmath9 is valid after the round @xmath8 by lemma  [ lem : cancel ] .",
    "otherwise , @xmath9 did not send a select or a flip during the round : it is also valid at the end of the round by lemma  [ lem : conservation ] .",
    "[ lem : select_valid ] if a node sends a successful select in round @xmath8 , then it is valid at the end of round @xmath8 .",
    "let @xmath190 be the set of nodes that send a successful select in round @xmath8 and are not valid at the end of round @xmath8 .",
    "we will prove , by contradiction , that @xmath190 is empty .",
    "assume @xmath190 is non - empty and consider the node in @xmath190 that had the largest score at the beginning of round ( say , node @xmath9 ) .",
    "such a node exists by lemma  [ lem : permutation ]",
    ". we will prove that @xmath9 is valid after the round , which is a contradiction .",
    "let @xmath10 be the recipient of @xmath9 s successful select .",
    "by lemma  [ lem : adoption ] @xmath109 , thus is enough to show that @xmath10 is valid after round @xmath8 to get our contradiction .",
    "let us examine both cases whether @xmath191 or @xmath81 .",
    "if @xmath154 , then either @xmath10 also sends a successful select in round @xmath8 , or it does not . if it does not , then it is valid after round @xmath8 ( lemma  [ lem : all - but - select - valid ] ) .",
    "if it does , then it must be valid otherwise @xmath9 is not maximal in @xmath190 ( lemma  [ lem : selected - t ] ) .    if @xmath181 , then let @xmath182 .",
    "two cases are considered , whether @xmath192 or not .",
    "if @xmath193 then @xmath166 because the condition forces @xmath9 to call the procedure ` become_root ( ) ` in line  [ line : become ] which makes it take the status @xmath43 .",
    "after , @xmath9 can takes the status @xmath81 , only during the execution of the procedure ` adopt_parent ( ) ` in line  [ line : becomeordinary ] .",
    "this procedure is called by @xmath9 only if @xmath9 did send a flip or a select at the beginning of round @xmath8 by lemma [ lem : flip - procedure ] . by lemma  [ lem :",
    "flip - select - t ] , this can not happen .",
    "thus @xmath10 is valid after round  @xmath8 . if @xmath192 , we use the fact that @xmath183 ( lemma  [ lem : send - t - become - n - parent - t ] ) to apply the same idea as we did above : either @xmath168 also sends a successful select in round  @xmath8 , or it does not .",
    "if it does not , then it is valid after round  @xmath8 ( lemma  [ lem : all - but - select - valid ] ) .",
    "if it does , then it must be valid otherwise @xmath9 is not maximal in @xmath190 ( lemma  [ lem : selected - n ] ) .",
    "[ lem : t - vald ] if @xmath68 then @xmath9 is valid after round @xmath8 .    according to lemma [",
    "lem : select_valid ] , after the successful sending of a select message in round @xmath8 , @xmath9 is valid at the end of round @xmath8 . according to lemma [ lem : flip - valid ] , after the successful sending of a flip message in round @xmath8 , @xmath9 is valid at the end of round @xmath8 .",
    "if @xmath9 sends a failed select or a failed flip then @xmath9 is valid after the round by lemma  [ lem : cancel ] . in otherwise , @xmath9 is also valid the round by lemma  [ lem : conservation ] .",
    "[ lem : nodes_validity ] if all nodes are valid at the beginning of the the round @xmath8 , then all nodes are valid after round @xmath8 .",
    "assume that a node @xmath10 is invalid after round @xmath8 . according to lemma [ lem : t - vald ] , @xmath194 .",
    "let @xmath195 be the finite series of nodes such that for @xmath196 $ ] , @xmath197 , @xmath198 , and @xmath199 .",
    "this series exists because @xmath9 is valid at the beginning of round @xmath8 .",
    "let @xmath200 be the infinite series of nodes such that for all @xmath201 @xmath202 , and @xmath203 .",
    "this series exists because @xmath10 is invalid ( by hypothesis ) .    according to lemma [ lem : n - parent ] ,",
    "@xmath204 $ ] , @xmath205 . according to lemma [ lem : t - vald ]",
    ", @xmath206 is valid .",
    "so all nodes of the series @xmath195 are valid .",
    "there is a contradiction .",
    "we verified the applicability of our algorithm to real world situations .",
    "the algorithm was implemented in the jbotsim simulator  @xcite and tested upon the infocomm06 dataset  @xcite .",
    "this dataset is a record of the possible interactions between people during the infocomm06 conference .",
    "the resulting graph has the following characteristics : the number of nodes is 78 and the average node degree is @xmath207 .",
    "it should also be noted that an edge can appear at any time but the fact that it is still present is thereafter only tested every 120 seconds ; this means that the presence time of an edge is a multiple of 120 seconds .",
    "two cases were considered , based on the number of rounds one can assume to occur per second .",
    "the results show the average number of trees per connected component , averaged over 100 runs . in the first case ( figure  [ fig : infocomm10 ] ) , we assume that 10 rounds can be performed per second , which seems reasonable , yet optimistic .        in the second case , we lower our expectations by assuming that only one round can be performed per second ( figure  [ fig : infocomm1 ] ) .",
    "these results show that the number of trees per connected component , averaged over time , is very close to @xmath40 ( about @xmath208 in the first case , and @xmath209 in the second case ) .",
    "furthermore , the algorithm achieves an optimal configuration of a single spanning tree per connected component about @xmath210 of the time in the first case ( @xmath211 in the second case ) , which is encouraging .",
    "these results also validate the relevance of our algorithm in real - world scenarios .",
    "this work was partially supported by anr projects displexity and astrid - maturation , as well as dga scholarship no 2013600074 .",
    "sheila abbas , mohamed mosbah , and akka zemmari . distributed computation of a spanning tree in a dynamic graph by mobile agents . in _ proc .",
    "of ieee int .",
    "conference on engineering of intelligent systems ( iceis ) _ , pages 16 , 2006 .",
    "baruch awerbuch and shimon even .",
    "efficient and reliable broadcast is achievable in an eventually connected network . in _ proceedings of the third annual acm symposium on principles of distributed computing _ , pages 278281 .",
    "acm , 1984 .",
    "janna burman and shay kutten .",
    "time optimal asynchronous self - stabilizing spanning tree . in andrzej pelc , editor , _ distributed computing _ ,",
    "volume 4731 of _ lecture notes in computer science _ , pages 92107 .",
    "springer berlin heidelberg , 2007 .",
    "arnaud casteigts , serge chaumette , frdric guinand , and yoann pign .",
    "distributed maintenance of anytime available spanning trees in dynamic networks . in _ proceedings of 12th conf .",
    "on adhoc , mobile , and wireless networks ( adhoc - now ) _ , volume 7960 of _ lecture notes in computer science _ , 2013 .",
    "amos israeli and marc jalfon .",
    "token management schemes and random walks yield self - stabilizing mutual exclusion . in _ proceedings of the ninth annual acm symposium on principles of distributed computing _ , pages 119131 .",
    "acm , 1990 .",
    "alex kravchik and shay kutten .",
    "time optimal synchronous self stabilizing spanning tree . in yehuda afek , editor , _ distributed computing _ , volume 8205 of _ lecture notes in computer science _ ,",
    "pages 91105 .",
    "springer berlin heidelberg , 2013 ."
  ],
  "abstract_text": [
    "<S> highly dynamic networks are characterized by frequent changes in the availability of communication links . </S>",
    "<S> many of these networks are in general partitioned into several components that keep splitting and merging continuously and unpredictably . </S>",
    "<S> we present an algorithm that strives to maintain a forest of spanning trees in such networks , without any kind of assumption on the rate of changes . </S>",
    "<S> our algorithm is the adaptation of a coarse - grain interaction algorithm ( casteigts et al . , 2013 ) to the synchronous message passing model ( for dynamic networks ) . </S>",
    "<S> while the high - level principles of the coarse - grain variant are preserved , the new algorithm turns out to be significantly more complex . </S>",
    "<S> in particular , it involves a new technique that consists of maintaining a distributed permutation of the set of all nodes ids throughout the execution . </S>",
    "<S> the algorithm also inherits the properties of its original variant : it relies on purely localized decisions , for which no global information is ever collected at the nodes , and yet it maintains a number of critical properties whatever the frequency and scale of the changes . in particular , the network remains always covered by a spanning forest in which 1 ) no cycle can ever appear , 2 ) every node belongs to a tree , and 3 ) after an arbitrary number of edge disappearance , all maximal subtrees immediately restore exactly one token ( at their root ) . </S>",
    "<S> these properties are ensured whatever the dynamics , even if it keeps going for an arbitrary long period of time . </S>",
    "<S> optimality is not the focus here , however the number of tree per components  the metric of interest here  eventually converges to one if the network stops changing ( which is never expected to happen , though ) . </S>",
    "<S> the algorithm correctness is proven and its behavior is tested through experimentation . </S>"
  ]
}