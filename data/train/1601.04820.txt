{
  "article_text": [
    "since sumer time  @xcite , and much later turing s machine tape  @xcite , read / write objects are certainly the most basic memory - based communication objects .",
    "such an object , usually called a _ register _ , provides its users ( processes ) with a write operation which defines the new value of the register , and a read operation which returns the value of the register . when considering sequential computing , registers are universal in the sense that they allow to solve any problem that can be solved  @xcite .",
    "[ [ register - in - message - passing - systems ] ] register in message - passing systems + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in a message - passing system , the computing entities communicate only by sending and receiving messages transmitted through a communication network . hence ,",
    "in such a system , a register is not a communication object given for free , but constitutes a communication abstraction which must be built with the help of the communication network and the local memories of the processes .",
    "several types of registers can be defined according to which processes are allowed to read or write it , and the quality ( semantics ) of the value returned by each read operation .",
    "we consider here registers which are single - writer multi - reader ( swmr ) , and atomic .",
    "atomicity means that ( a ) each read or write operation appears as if it had been executed instantaneously at a single point of the time line , between is start event and its end event , ( b ) no two operations appear at the same point of the time line , and ( c ) a read returns the value written by the closest preceding write operation ( or the initial value of the register if there is no preceding write )  @xcite .",
    "algorithms building multi - writer multi - reader ( mwmr ) atomic registers from single - writer single - reader ( swsr ) registers with a weaker semantics ( safe or regular registers ) are described in several textbooks ( e.g. ,  @xcite ) .",
    "many distributed algorithms have been proposed , which build a register on top of a message - passing system , be it failure - free or failure - prone . in the failure - prone case ,",
    "the addressed failure models are the process crash failure model , or the byzantine process failure model ( see , the textbooks  @xcite ) .",
    "the most famous of these algorithms was proposed by h. attiya , a. bar - noy , and d. dolev in  @xcite .",
    "this algorithm , which is usually called abd according to the names its authors , considers an @xmath0-process asynchronous system in which up to @xmath1 processes may crash ( it is also shown in  @xcite that @xmath1 is an upper bound of the number of process crashes which can be tolerated ) .",
    "this simple and elegant algorithm , relies on ( a ) quorums  @xcite , and ( b ) a simple broadcast / reply communication pattern .",
    "abd uses this pattern once in a write operation , and twice in a read operation implementing an swmr register .",
    "[ [ fast - operation ] ] fast operation + + + + + + + + + + + + + +    to our knowledge , the notion of a _ fast implementation _ of an atomic register operation , in failure - prone asynchronous message - passing systems , was introduced in  @xcite for process crash failures , and in  @xcite for byzantine process failures .",
    "these papers consider a three - component model , namely there are three different types of processes : a set of writers @xmath3 , a set of readers @xmath4 , and a set of servers @xmath5 which implements the register .",
    "moreover , a client ( a writer or a reader ) can communicate only with the servers , and the servers do not communicate among themselves .    in these papers , _ fast _ means that a read or write operation must entail exactly one communication round - trip delay between a client ( the writer or a reader ) and the servers . when considering the process crash failure model ( the one we are interested in in this paper ) , it is shown in  @xcite that , when @xmath6 , the condition @xmath7 is necessary and sufficient to have fast read and write operations ( as defined above ) , which implement an atomic register .",
    "it is also shown in  @xcite that there is no fast implementation of an mwmr atomic register if @xmath8 .",
    "[ [ content - of - the - paper ] ] content of the paper + + + + + + + + + + + + + + + + + + + +    the work described in  @xcite is mainly on the limits of the three - component model ( writers , readers , and servers constitute three independent sets of processes ) in the presence of process crash failures , or byzantine process failures .",
    "these limits are captured by predicates involving the set of writers ( @xmath3 ) , the set of readers ( @xmath4 ) , the set of servers ( @xmath9 , and the maximal number of servers that can be faulty ( @xmath2 ) .",
    "both the underlying model used in this paper and its aim are different from this previous work .    while keeping the spirit ( basic principles and simplicity ) of abd , our aim is to design a _ time - efficient _ implementation of an atomic register in the classical model used in many articles and textbooks ( see , e.g. ,  @xcite ) .",
    "this model , where any process can communicate with any process , can be seen as a peer - to - peer model in which each process is both a client ( it can invoke operations ) and a server ( it manages a local copy of the register that is built ) . ) , we obtain a two - component model with one writer and reader - server processes . in this model , the necessary and sufficient condition @xmath7 can never be satisfied , which means that , it is impossible to design a fast implementation of a swmr atomic register in such a two - component model . ]    adopting the usual distributed computing assumption that ( a ) local processing times are negligible and assumed consequently to have zero duration , and ( b ) only communication takes time , this paper focuses on the communication time needed to complete a read or write operation .",
    "for this reason the term _ time - efficiency _ is defined here in terms on message transfer delays , namely , the cost of a read or write operation is measured by the number of `` consecutive '' message transfer delays they require to terminate .",
    "let us notice that this includes transfer delays due to causally related messages ( for example round trip delays generated by request / acknowledgment messages ) , but also ( as we will see in the proposed algorithm ) message transfer delays which occur sequentially without being necessarily causally related .",
    "let us notice that this notion of a time - efficient operation does not involve the model parameter @xmath2 .    in order to give a precise meaning to the notion of a `` time - efficient implementation '' of a register operation ,",
    "this paper considers two distinct ways to measure the duration of read and write operations , each based on a specific additional synchrony assumption .",
    "one is the `` bounded delay '' assumption , the other one the `` round - based synchrony '' assumption .",
    "more precisely , these assumptions and the associated time - efficiency of the proposed algorithm are the following .    *",
    "_ bounded delay _ assumption .",
    "+ let us assume that every message takes at most @xmath10 time units to be transmitted from its sender to any of its receivers .",
    "in such a context , the algorithm presented in the paper has the following time - efficiency properties . * * a write operation takes at most @xmath11 time units . *",
    "* a read operation which is write - latency - free takes at most @xmath11 time units . (",
    "the notion of write - latency - freedom is defined in section  [ sec : fast - definition ] .",
    "intuitively , it captures the fact that the behavior of the read does not depend on a concurrent or faulty write operation , which is the usual case in read - dominated applications . ) otherwise , it takes at most @xmath12 time units , except in the case where the read operation is concurrent with a write operation and the writer crashes during this write , where it can take up to @xmath13 time units .",
    "( let us remark that a process can experience at most once the @xmath13 read operation scenario . ) * _ round - based synchrony _ assumption .",
    "+ here , the underlying communication system is assumed to be round - based synchronous  @xcite .",
    "in such a system , the processes progress by executing consecutive synchronous rounds . in every round , according to its code , a process possibly sends a message to a subset of processes , then receives all the messages sent to it during the current round , and finally executes local computation . at the end of a round ,",
    "all processes are directed to simultaneously progress to the next round .",
    "in such a synchronous system , everything appears as if all messages take the very same time to go from their sender to theirs receivers , namely the duration @xmath14 associated with a round .",
    "when executed in such a context , the proposed algorithm has the following time - efficiency properties . * * the duration of a write operation is @xmath15 time units .",
    "* * the duration of a read operation is @xmath15 time units , except possibly in the specific scenario where the writer crashes while executing the write operation concurrently with the read , in which case the duration of the read can be @xmath16 time units ( as previously , let us remark that a process can experience at most once the @xmath16 read operation scenario . )    hence , while it remains correct in the presence of any asynchronous message pattern ( e.g. , when each message takes one more time unit than any previous message ) , the proposed algorithm is particularly time - efficient when `` good '' scenarios occur .",
    "those are the ones defined by the previous synchrony patterns where the duration of a read or a write operation corresponds to a single round - trip delay . moreover , in the other synchronous scenarios , where a read operation is concurrent with a write , the maximal duration of the read operation is precisely quantified .",
    "a concurrent write adds uncertainty whose resolution by a read operation requires one more message transfer delay ( two in the case of the @xmath10 synchrony assumption , if the concurrent write crashes ) .    [",
    "[ roadmap ] ] roadmap + + + + + + +    the paper consists of  [ sec : conclusion ] sections .",
    "section  [ sec : model - definitions ] presents the system model .",
    "section  [ sec : fast - definition ] defines the atomic register abstraction , and the notion of a time - efficient implementation .",
    "then , section  [ sec : algorithm ] presents an asynchronous algorithm providing an implementation of an atomic register with time - efficient operations , as previously defined .",
    "section  [ sec : proof ] proves its properties .",
    "finally , section  [ sec : conclusion ] concludes the paper .",
    "[ [ processes ] ] processes + + + + + + + + +    the computing model is composed of a set of @xmath0 sequential processes denoted @xmath17 , ... , @xmath18 .",
    "each process is asynchronous which means that it proceeds at its own speed , which can be arbitrary and remains always unknown to the other processes .",
    "a process may halt prematurely ( crash failure ) , but executes correctly its local algorithm until it possibly crashes .",
    "the model parameter @xmath2 denotes the maximal number of processes that may crash in a run . a process that crashes in a run",
    "is said to be _",
    "faulty_. otherwise , it is _ correct _ or _ non - faulty_.    [ [ communication ] ] communication + + + + + + + + + + + + +    the processes cooperate by sending and receiving messages through bi - directional channels .",
    "the communication network is a complete network , which means that any process @xmath19 can directly send a message to any process @xmath20 ( including itself ) .",
    "each channel is reliable ( no loss , corruption , nor creation of messages ) , not necessarily first - in / first - out , and asynchronous ( while the transit time of each message is finite , there is no upper bound on message transit times ) .",
    "a process @xmath19 invokes the operation `` @xmath21 tag(@xmath22 ) to @xmath20 '' to send @xmath20 the message tagged tag and carrying the value @xmath22 .",
    "it receives a message tagged tag by invoking the operation `` @xmath23 tag ( ) '' .",
    "the macro - operation `` @xmath24 tag(@xmath22 ) '' is a shortcut for `` * for each * @xmath25 @xmath21 tag(@xmath22 ) to @xmath20 * end for * '' .",
    "( the sending order is arbitrary , which means that , if the sender crashes while executing this statement , an arbitrary  possibly empty subset of processes will receive the message . )",
    "let us notice that , due to process and message asynchrony , no process can know if an other process crashed or is only very slow .",
    "[ [ notation ] ] notation + + + + + + + +    in the following , the previous computation model , restricted to the case where @xmath1 , is denoted @xmath26 $ ] ( crash asynchronous message - passing ) .",
    "it is important to notice that , in this model , all processes are a priori `` equal '' .",
    "as we will see , this allows each process to be at the same time a `` client '' and a `` server '' . in this sense , and as noticed in the introduction , this model is the `` fully connected peer - to - peer '' model ( whose structure is different from other computing models such as the client / server model , where processes are partitioned into clients and servers , playing different roles ) .",
    "a _ concurrent object _ is an object that can be accessed by several processes ( possibly simultaneously ) .",
    "an swmr _ atomic _ register ( say @xmath27 ) is a concurrent object which provides exactly one process ( called the writer ) with an operation denoted @xmath28 , and all processes with an operation denoted @xmath29 . when the writer invokes @xmath30 it defines @xmath31 as being the new value of @xmath27 .",
    "an swmr atomic register ( we also say the register is _ linearizable _",
    "@xcite ) is defined by the following set of properties  @xcite .",
    "* liveness .",
    "an invocation of an operation by a correct process terminates .",
    "* consistency ( safety ) .",
    "all the operations invoked by the processes , except possibly for each faulty process the last operation it invoked , appear as if they have been executed sequentially and this sequence of operations is such that : * * each read returns the value written by the closest write that precedes it ( or the initial value of @xmath27 if there is no preceding write ) , * * if an operation @xmath32 terminated before an operation @xmath33 started , then @xmath32 appears before @xmath33 in the sequence .",
    "this set of properties states that , from an external observer point of view , the object appears as if it was accessed sequentially by the processes , this sequence ( a ) respecting the real time access order , and ( ii ) belonging to the sequential specification of a read / write register .",
    "the notion of a time - efficient operation is not related to its correctness , but is a property of its implementation .",
    "it is sometimes called _ non - functional _ property . in the present case",
    ", it captures the time efficiency of operations .",
    "as indicated in the introduction , we consider here two synchrony assumptions to define what we mean by time - efficient operation implementation .",
    "as we have seen , both are based on the duration of read and write operations , in terms of message transfer delays .",
    "let us remember that , in both cases , it is assumed that the local processing times needed to implement these high level read and write operations are negligible .",
    "let us assume an underlying communication system where message transfer delays are upper bounded by @xmath10 .",
    "[ [ write - latency - free - read - operation - and - interfering - write ] ] write - latency - free read operation and interfering write + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    intuitively , a read operation is _ write - latency - free _ if its execution does `` not interleave '' with the execution of a write operation .",
    "more precisely , let @xmath34 be the starting time of a read operation .",
    "this read operation is _ write - latency - free _ if ( a ) it is not concurrent with a write operation , and ( b ) the closest preceding write did not crash and started at a time @xmath35 .",
    "let @xmath36 be a read operation , which started at time @xmath34 .",
    "let @xmath37 be the closest write preceding @xmath36 .",
    "if @xmath37 started at time @xmath38 , it is said to be _ interfering _ with @xmath36 .",
    "[ [ bounded - delay - based - definition ] ] _ bounded delay_-based definition + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    an implementation of a read / write register is _ time - efficient _ ( from a bounded delay point of view ) if it satisfies the following properties .    * a write operation takes at most @xmath11 time units . * a read operation which is write - latency - free takes at most @xmath11 time units .",
    "* a read operation which is not write - latency - free takes at most * * @xmath12 time units if the writer does not crash while executing the interfering write , * * @xmath13 time units if the writer crashes while executing the interfering write ( this scenario can appear at most once for each process ) .",
    "let us assume that the underlying communication system is round - based synchronous , where each message transfer delay is equal to @xmath14 .",
    "when considering this underlying synchrony assumption , it is assumed that a process sends or broadcasts at most one message per round , and this is done at the beginning of a round .",
    "an implementation of a read / write register is _ time - efficient _ ( from the round - based synchrony point of view ) if it satisfies the following properties .",
    "* the duration of a write operation is @xmath15 time units . *",
    "the duration of a read operation is @xmath15 time units , except possibly in the `` at most once '' scenario where the writer crashes while executing the write operation concurrently with the read , in which case the duration of the read can be @xmath16 time units .",
    "[ [ what - does - the - proposed - algorithm ] ] what does the proposed algorithm + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as we will see , the proposed algorithm , designed for the asynchronous system model @xmath39 $ ] , provides an swmr atomic register implementation which is time - efficient for both its `` bounded delay''-based definition , and its `` round synchrony''-based definition .",
    "the design of the algorithm , described in figure  [ algo : fast - basic - version ] , is voluntarily formulated to be as close as possible to abd . for the reader aware of abd ,",
    "this will help its understanding .",
    "[ [ local - variables ] ] local variables + + + + + + + + + + + + + + +    each process @xmath19 manages the following local variables .    * @xmath40 contains the value of the constructed register @xmath27 , as currently known by @xmath19 .",
    "it is initialized to the initial value of @xmath27 ( e.g. , the default value @xmath41 ) .",
    "* @xmath42 is the sequence number associated with the value in @xmath40 .",
    "* @xmath43 is the sequence number of the last read operation invoked by @xmath19 .",
    "* @xmath44 is a synchronization local variable .",
    "it contains the sequence number of the most recent value of @xmath27 that , to @xmath19 s knowledge , is known by at least @xmath45 processes .",
    "this variable ( which is new with respect to other algorithms ) is at the heart of the time - efficient implementation of the read operation .",
    "* @xmath46 is the value of @xmath27 whose sequence number is @xmath44 .    [",
    "[ client - side - operation - sf - write - invoked - by - the - writer ] ] client side : operation @xmath47 invoked by the writer + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when the writer @xmath19 invokes @xmath30 , it increases @xmath42 , updates @xmath40 , and broadcasts the message write@xmath48 ( line  [ f - swmr-01 ] ) .",
    "then , it waits until it has received an acknowledgment message from @xmath45 processes ( line  [ f - swmr-02 ] ) .",
    "when this occurs , the operation terminates ( line  [ f - swmr-03 ] ) .",
    "let us notice that the acknowledgment message is a copy of the very same message as the one it broadcast .",
    "[ [ server - side - reception - of - a - message - sc - writewsnv ] ] server side : reception of a message @xmath49 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath19 receives such a message , and this message carries a more recent value than the one currently stored in @xmath40 , @xmath19 updates accordingly @xmath42 and @xmath40 ( line  [ f - swmr-07 ] ) .",
    "moreover , if this message is the first message carrying the sequence number @xmath50 , @xmath19 forwards to all the processes the message write@xmath51 it has received ( line  [ f - swmr-08 ] ) .",
    "this broadcast has two aims : to be an acknowledgment for the writer , and to inform the other processes that @xmath19 `` knows '' this value . when @xmath19 receives a message write@xmath51 for the first time . ]    moreover , when @xmath19 has received the message write@xmath51 from @xmath45 different processes , and @xmath44 is smaller than @xmath50 , it updates its local synchronization variable @xmath44 and accordingly assigns @xmath31 to @xmath46 ( lines  [ f - swmr-09]-[f - swmr-11 ] ) .",
    "[ [ server - side - reception - of - a - message - readrsn ] ] server side : reception of a message read@xmath52 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath19 receives such a message from a process @xmath20 , it sends by return to @xmath20 the message state@xmath53 , thereby informing it on the freshness of the last value of @xmath27 it knows ( line  [ f - swmr-12 ] ) .",
    "the parameter @xmath54 allows the sender @xmath20 to associate the messages state@xmath55 it will receive with the corresponding request identified by @xmath54 .    [ [ client - side - operation - sf - read - invoked - by - a - process - p_i ] ] client side : operation @xmath56 invoked by a process @xmath19 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process invokes @xmath29 , it first broadcasts the message read@xmath57 with a new sequence number .",
    "then , it waits until `` some '' predicate is satisfied ( line  [ f - swmr-05 ] ) , and finally returns the current value of @xmath46 .",
    "let us notice that the value @xmath46 that is returned is the one whose sequence number is @xmath44 .",
    "the waiting predicate is the heart of the algorithm .",
    "its first part states that @xmath19 must have received a message state@xmath55 from @xmath45 processes .",
    "its second part , namely @xmath58 , states that the value in @xmath19 s local variable @xmath46 is as recent or more recent than the value associated with the greatest write sequence number @xmath50 received by @xmath19 in a message state@xmath55 .",
    "combined with the broadcast of messages write@xmath59 issued by each process at line  [ f - swmr-08 ] , this waiting predicate ensures both the correctness of the returned value ( atomicity ) , and the fact that the read implementation is time - efficient .",
    "the properties proved in this section are independent of the message transfer delays ( provided they are finite ) .",
    "[ lemma : termination ] if the writer is correct , all its write invocations terminate .",
    "if a reader is correct , all its read invocations terminate .",
    "let us first consider the writer process . as by assumption",
    "it is correct , it broadcasts the message write@xmath60 ( line  [ f - swmr-01 ] ) .",
    "each correct process broadcasts write@xmath60 when it receives it for the first time ( line  [ f - swmr-08 ] )",
    ". as there are at least @xmath45 correct processes , the writer eventually receives write@xmath60 from these processes , and stops waiting at line  [ f - swmr-02 ] .",
    "let us now consider a correct reader process @xmath19 .",
    "it follows from the same reasoning as before that the reader receives the message state@xmath55 from at least @xmath45 processes ( lines  [ f - swmr-05 ] and  [ f - swmr-12 ] ) .",
    "hence , it remains to prove that the second part of the waiting predicate , namely @xmath61 ( line  [ f - swmr-05 ] ) becomes eventually true , where @xmath62 is the greatest write sequence number received by @xmath19 in a message state@xmath55 .",
    "let @xmath20 be the sender of this message .",
    "the following list of items is such that item @xmath63 @xmath64 item @xmath65 , from which follows that @xmath61 ( line  [ f - swmr-05 ] ) is eventually satisfied .    1 .",
    "@xmath20 updated @xmath66 to @xmath62 ( line  [ f - swmr-07 ] ) before sending state@xmath67 ( line  [ f - swmr-12 ] ) .",
    "hence , @xmath20 received previously the message write@xmath68 , and broadcast it the first time it received it ( line  [ f - swmr-08 ] ) .",
    "it follows that any correct process receives the message write@xmath68 ( at least from @xmath20 ) , and broadcasts it the first time it receives it ( line  [ f - swmr-08 ] ) .",
    "4 .   consequently , @xmath19 eventually receives the message write@xmath68 from @xmath45 processes .",
    "when this occurs , it updates @xmath44 ( line  [ f - swmr-10 ] ) , which is then @xmath69 , which concludes the proof of the termination of a read operation .",
    "[ lemma : atomicity ] the register @xmath27 is atomic .",
    "let @xmath70 $ ] be a read operation issued by a process @xmath19 which returns the value with sequence number @xmath63 , and @xmath71 $ ] be the write operation which writes the value with sequence number @xmath72 .",
    "the proof of the lemma is the consequence of the three following claims .",
    "* claim 1 .",
    "if @xmath70 $ ] terminates before @xmath71 $ ] starts , then @xmath73 . *",
    "if @xmath74 $ ] terminates before @xmath75 $ ] starts , then @xmath76 . *",
    "if @xmath70 $ ] terminates before @xmath77 $ ] starts , then @xmath76 .",
    "claim 1 states that no process can read from the future .",
    "claim 2 states that no process can read overwritten values .",
    "claim 3 states that there is no new / old read inversions  @xcite .",
    "+ proof of claim 1 .",
    "+ this claim follows from the following simple observation .",
    "when the writer executes @xmath71 $ ] , it first increases its local variable @xmath50 which becomes greater than any sequence number associated with its previous write operations ( line  [ f - swmr-01 ] ) .",
    "hence if @xmath70 $ ] terminates before @xmath71 $ ] starts , we necessarily have @xmath73 .",
    "+ proof of claim 2 .",
    "+ it follows from line  [ f - swmr-02 ] and lines  [ f - swmr-07]-[f - swmr-08 ] that , when @xmath74 $ ] terminates , there is a set @xmath78 of at least @xmath45 processes @xmath79 such that @xmath80 . on another side , due to lines  [ f - swmr-04]-[f - swmr-05 ] and line  [ f - swmr-12 ] , @xmath75 $ ] obtains a message state@xmath81 from a set @xmath82 of at least @xmath45 processes .",
    "as @xmath83 , @xmath84 , and @xmath85 , it follows that @xmath86 is not empty .",
    "there is consequently a process @xmath87 , such that that @xmath80 .",
    "hence , @xmath79 sent to @xmath19 the message state@xmath88 , where @xmath89 .",
    "due to ( a ) the definition of @xmath90 , ( b ) the predicate @xmath91 ( line  [ f - swmr-05 ] ) , and ( c ) the value of @xmath92 , it follows that @xmath93 when @xmath75 $ ] stops waiting at line  [ f - swmr-05 ] .",
    "as , @xmath89 , it follows @xmath94 , which proves the claim .",
    "+ proof of claim 3 .",
    "+ when @xmath70 $ ] stops waiting at line  [ f - swmr-05 ] , it returns the value @xmath46 associated with the sequence number @xmath95 .",
    "process @xmath19 previously received the message write@xmath96 from a set @xmath97 of at least @xmath45 processes . the same occurs for @xmath20 , which , before returning , received the message write@xmath98 from a set @xmath99 of at least @xmath45 processes .",
    "as @xmath100 , @xmath101 , and @xmath85 , it follows that @xmath102 is not empty .",
    "hence , there is a process @xmath79 which sent state@xmath103 to @xmath19 , and later sent state@xmath104 to @xmath20 .",
    "as @xmath105 never decreases , it follows that @xmath76 , which completes the proof of the lemma .",
    "[ theo : main-1 ] algorithm _ [ algo : fast - basic - version ] _ implements an _ swmr _ atomic register in @xmath39 $ ] .",
    "the proof follows from lemma  [ lemma : termination ] ( termination ) and lemma  [ lemma : atomicity ] ( atomicity ) .",
    "as already indicated , this underlying synchrony assumption considers that every message takes at most @xmath10 time units .",
    "moreover , let us remind that a read ( which started at time @xmath34 ) is write - latency - free if it is not concurrent with a write , and the last preceding write did not crash and started at time @xmath106 .",
    "[ lemma : fast - writer ] a write operation takes at most @xmath11 time units .",
    "the case of the writer is trivial .",
    "the message write@xmath81 broadcast by the writer takes at most @xmath10 time units , as do the acknowledgment messageswrite@xmath81 sent by each process to the writer . in this case",
    "@xmath11 correspond to a causality - related maximal round - trip delay ( the reception of a message triggers the sending of an associated acknowledgment ) .",
    "[ [ when - the - writer - does - not - crash - while - executing - a - write - operation ] ] when the writer does not crash while executing a write operation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the cases where the writer does not crash while executing a write operation are captured by the next two lemmas .",
    "[ lemma : fast - read - write - correct - writer-2 ] a write - latency - free read operation takes at most @xmath11 time units .    let @xmath19 be a process that issues a write - latency - free read operation , and @xmath34 be its starting time .",
    "moreover , let @xmath107 the starting time of the last preceding write .",
    "as the read is write latency - free , we have @xmath108 .",
    "moreover , as messages take at most @xmath10 time units , and the writer did not crash when executing the write , each non - crashed process @xmath79 received the message write@xmath96 ( sent by the preceding write at time @xmath109 ) , broadcast it ( line  [ f - swmr-08 ] ) , and updated its local variables such that we have @xmath110 ( lines  [ f - swmr-07]-[f - swmr-11 ] ) at ime @xmath109 .",
    "hence , all the messages state@xmath81 received by the reader @xmath19 carry the write sequence number @xmath63",
    ". moreover , due to the broadcast of line  [ f - swmr-08 ] executed by each correct process , we have @xmath95 at some time @xmath111 .",
    "it follows that the predicate of line  [ f - swmr-05 ] is satisfied at @xmath19 within @xmath11 time units after it invoked the read operation .",
    "[ lemma : fast - read - write - correct - writer-3 ] a read operation which is not write - latency - free , and during which the writer does not crash during the interfering write operation , takes at most @xmath12 .",
    "let us consider a read operation that starts at time @xmath34 , concurrent with a write operation that starts at time @xmath107 and during which the writer does not crash . from the read operation point of view ,",
    "the worst case occurs when the read operation is invoked just after time @xmath112 , let us say at time @xmath113 . as a message state@xmath55",
    "is sent by return when a message read@xmath52 is received , the messages state@xmath55 received by @xmath19 by time @xmath114 can be such that some carry the sequence number @xmath63 ( due to last previous write ) while others carry the sequence number @xmath115 ( due to the concurrent write ) are sent by the processes that received read@xmath52 before @xmath107 , while the messages state@xmath116 are sent by the processes that received read@xmath52 between @xmath107 and @xmath117 . ] .",
    "hence , @xmath118 or @xmath119 ( predicate of line  [ f - swmr-05 ] ) . if @xmath118 , we also have @xmath95 and @xmath19 terminates its read .",
    "if @xmath119 , @xmath19 must wait until @xmath120 , which occurs at the latest at @xmath121 ( when @xmath19 receives the last message of the @xmath45 messages write@xmath98 which makes true the predicates of lines  [ f - swmr-09]-[f - swmr-10 ] , thereby allowing the predicate of line  [ f - swmr-05 ] to be satisfied ) .",
    "when this occurs , @xmath19 terminates its read operation . as @xmath122",
    ", @xmath19 returns at the latest @xmath123 time units after it invoked the read operation .",
    "[ [ when - the - writer - crashes - while - executing - a - write - operation ] ] when the writer crashes while executing a write operation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the problem raised by the crash of the writer while executing the write operation is when it crashes while broadcasting the message write@xmath96 ( line  [ f - swmr-01 ] ) : some processes receive this message by @xmath10 time units , while other processes do not .",
    "this issue is solved by the propagation of the message write@xmath96 by the non - crashed processes that receive it ( line  [ f - swmr-08 ] ) .",
    "this means that , in the worst case ( as in synchronous systems ) , the message write@xmath96 must be forwarded by @xmath124 processes before being received by all correct processes .",
    "this worst scenario may entail a cost of @xmath125 time units .",
    "figure  [ algo - modified ] presents a simple modification of algorithm  [ algo : fast - basic - version ] , which allows a fast implementation of read operations whose executions are concurrent with a write operation during which the writer crashes . the modifications are underlined .",
    "when a process @xmath19 receives a message read@xmath81 , it now returns a message state@xmath81 containing an additional field , namely the current value of @xmath40 , its local copy of @xmath27 ( line  [ f - swmr-12 ] ) .",
    "when a process @xmath19 receives from a process @xmath20 a message state@xmath126 , it uses it in the waiting predicate of line  [ f - swmr-05 ] , but executes before the lines  [ f - swmr-07]-[f - swmr-11 ] , as if this message was write@xmath51 . according to the values of the predicates of lines",
    "[ f - swmr-07 ] ,  [ f - swmr-09 ] , and  [ f - swmr-10 ] , this allows @xmath19 to expedite the update of its local variables @xmath42 , @xmath40 , @xmath44 , and @xmath46 , thereby favoring fast termination .",
    "the reader can check that these modifications do not alter the proofs of lemma  [ lemma : termination ] ( termination ) and lemma  [ lemma : atomicity ] ( atomicity ) . hence , the proof of theorem  [ theo : main-1 ] is still correct .",
    "[ lemma : faulty - writer ] a read operation which is not write - latency - free , and during which the writer crashes during the interfering write operation , takes at most @xmath13 time units .",
    "let @xmath34 be the time at which the read operation starts .",
    "as in the proof of lemma  [ lemma : fast - read - write - correct - writer-2 ] , the messages state@xmath127 received @xmath19 by time @xmath114 can be such that some carry the sequence number @xmath128 ( due to last previous write ) while some others carry the sequence number @xmath129 ( due to the concurrent write during which the writer crashes ) . if all these messages carry @xmath128 , the read terminates by time @xmath114 .",
    "if at least one of these messages is state@xmath130 , we have @xmath131 , and @xmath19 waits until the predicate @xmath132 becomes true ( line  [ f - swmr-05 ] ) .",
    "when it received state@xmath130 , if not yet done , @xmath19 broadcast the message write@xmath130 , ( line  [ f - swmr-08 ] of figure  [ algo - modified ] ) , which is received by the other processes within @xmath10 time units . if not yet done , this entails the broadcast by each correct process of the same message write@xmath130 .",
    "hence , at most @xmath10 time units later , @xmath19 has received the message write@xmath116 from @xmath45 processes , which entails the update of @xmath44 to @xmath65 .",
    "consequently the predicate of line  [ f - swmr-05 ] becomes satisfied , and @xmath19 terminates its read operation .",
    "when counting the number of consecutive communication steps , we have : the message read@xmath52 by @xmath19 , followed by a message state@xmath130 sent by some process and received by @xmath19 , followed by the message write@xmath116 broadcast by @xmath19 , followed by the message write@xmath116 broadcast by each non - crashed process ( if not yet done ) . hence , when the writer crashes during a concurrent read , the read returns within at most @xmath133 time units .",
    "[ theo : main-2 ] algorithm _ [ algo : fast - basic - version ] _ modified as indicated in figure  _ [ algo - modified ] _ implements in @xmath39 $ ] an _ swmr _ atomic register with time - efficient operations ( where the time - efficiency notion is based on the _ bounded delay _ assumption ) .",
    "the proof follows from theorem  [ theo : main-1 ] ( termination and atomicity ) , lemma  [ lemma : fast - writer ] , lemma  [ lemma : fast - read - write - correct - writer-2 ] , lemma  [ lemma : fast - read - write - correct - writer-3 ] , and lemma  [ lemma : faulty - writer ] ( time - efficiency ) .",
    "as already indicated , this notion of a time - efficient implementation assumes an underlying round - based synchronous communication system , where the duration of a round ( duration of all message transfer delays ) is @xmath14 .",
    "[ lemma : writer ] the duration of write operation is @xmath15 .    the proof follows directly from the observation that the write operation terminates after a round - trip delay , whose duration is @xmath15 .",
    "[ lemma : reader ] the duration of a read operation is @xmath15 time units if the writer does not crash while executing a write operation concurrent with the read .",
    "otherwise , it can be @xmath16 .    considering a read operation that starts at time @xmath34 ,",
    "let us assume that the writer does not crash while concurrently executing a write operation .",
    "at time @xmath134 all processes receives the message read@xmath52 sent by the reader ( line  [ f - swmr-04 ] ) , and answer with a message state@xmath55 ( line  [ f - swmr-12 ] ) . due the round - based synchrony assumption",
    ", all these messages carry the same sequence number @xmath63 , which is equal to both their local variable @xmath42 and @xmath44 .",
    "it follows that at time @xmath135 , the predicate of line  [ f - swmr-05 ] is satisfied at the reader , which consequently returns from the read operation .    if the writer crashes while concurrently executing a write operation , it is possible that during some time ( a round duration ) , some processes know the sequence number @xmath63 , while other processes know only @xmath136 . but this synchrony break in the knowledge of the last sequence number is mended during the next round thanks to the message write@xmath137 sent by the processes which are aware of @xmath63 ( see figure  [ algo - modified ] ) . after this additional round ,",
    "the read terminates ( as previously ) in two rounds .",
    "hence , the read returns at the latest at time @xmath138 .",
    "[ theo : main-3 ] algorithm _ [ algo : fast - basic - version ] _ modified as indicated in figure  _ [ algo - modified ] _ implements in @xmath39 $ ] an _ swmr _ atomic register with time - efficient operations ( where the time - efficiency notion is based on the _ round - based synchrony _ assumption ) .",
    "the proof follows from theorem  [ theo : main-1 ] ( termination and atomicity ) , lemma  [ lemma : writer ] , and lemma  [ lemma : reader ] ( time - efficiency ) .",
    "this work has presented a new distributed algorithm implementing an atomic read / write register on top of an asynchronous @xmath0-process message - passing system in which up to @xmath1 processes may crash . when designing it ,",
    "the constraints we imposed on this algorithm were ( a ) from an efficiency point of view : provide time - efficient implementations for read and write operations , ( b ) and from a design principle point of view : remain `` as close as possible '' to the flagship abd algorithm introduced by attiya , bar - noy and dolev  @xcite .",
    "+ the `` time - efficiency '' property of the proposed algorithm has been analyzed according to two synchrony assumptions on the underlying system .",
    "* the first assumption considers an upper bound @xmath10 on message transfer delays .",
    "under such an assumption , any write operation takes then at most @xmath11 time units , and a read operation takes at most @xmath11 time units when executed in good circumstances ( i.e. , when there is no write operation concurrent with the read operation ) .",
    "hence , the inherent cost of an operation is a round - trip delay , always for a write and in favorable circumstances for a read .",
    "a read operation concurrent with a write operation during which the writer does not crash , may require an additional cost of @xmath10 , which means that it takes at most @xmath12 time units .",
    "finally , if the writer crashes during a write concurrent with a read , the read may take at most @xmath13 time units .",
    "this shows clearly the incremental cost imposed by the adversaries ( concurrency of write operations , and failure of the writer ) .",
    "* the second assumption investigated for a `` time - efficient implementation '' is the one provided by a round - based synchronous system , where message transfer delays ( denoted @xmath14 ) are assumed to be the same for all messages .",
    "it has been shown that , under this assumption , the duration of a write is @xmath15 , and the duration of a read is @xmath15 , or exceptionally @xmath16 when the writer crashes while concurrently executing a write operation .",
    "it is important to remind that the proposed algorithm remains correct in the presence of any asynchrony pattern .",
    "its time - efficiency features are particularly interesting when the system has long synchrony periods . differently from the proposed algorithm",
    ", the abd algorithm does not display different behaviors in different concurrency and failure patterns . in abd ,",
    "the duration of all write operations is upper bounded by @xmath11 time units ( or equal to @xmath15 ) , and the duration of all read operations is upper bounded by @xmath13 time units ( or equal to @xmath139 ) .",
    "the trade - off between abd and our algorithm lies the message complexity , which is @xmath140 in abd for both read and write operations , while it is @xmath141 for a write operation and @xmath140 for a read operation in the proposed algorithm .",
    "hence our algorithm is particularly interesting for registers used in read - dominated applications .",
    "moreover , it helps us better understand the impact of the adversary pair `` writer concurrency + writer failure '' on the efficiency of the read operations .",
    "this work has been partially supported by the franco - german dfg - anr project 40300781 discmat devoted to connections between mathematics and distributed computing , and the french anr project displexity devoted to the study of computability and complexity in distributed computing .",
    "guerraoui r. , levy r. , and chakraborty a. , how fast can a distributed atomic read be ?",
    "23rd acm symposium on principles of distributed computing ( podc04 ) _ , acm press , pp .",
    "236 - 245 , 2004 ."
  ],
  "abstract_text": [
    "<S> the atomic register is certainly the most basic object of computing science . </S>",
    "<S> its implementation on top of an @xmath0-process asynchronous message - passing system has received a lot of attention . </S>",
    "<S> it has been shown that @xmath1 ( where @xmath2 is the maximal number of processes that may crash ) is a necessary and sufficient requirement to build an atomic register on top of a crash - prone asynchronous message - passing system . </S>",
    "<S> considering such a context , this paper visits the notion of a fast implementation of an atomic register , and presents a new time - efficient asynchronous algorithm . </S>",
    "<S> its time - efficiency is measured according to two different underlying synchrony assumptions . </S>",
    "<S> whatever this assumption , a write operation always costs a round - trip delay , while a read operation costs always a round - trip delay in favorable circumstances ( intuitively , when it is not concurrent with a write ) . when designing this algorithm , the design spirit was to be as close as possible to the one of the famous abd algorithm ( proposed by attiya , bar - noy , and dolev ) .   +   + * </S>",
    "<S> keywords * : asynchronous message - passing system , atomic read / write register , concurrency , fast operation , process crash failure , synchronous behavior , time - efficient operation . </S>"
  ]
}