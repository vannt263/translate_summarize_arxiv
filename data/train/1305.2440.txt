{
  "article_text": [
    "dimakis _ et al . _",
    "@xcite proposed the framework of regenerating codes to address the tradeoff between the storage and repair bandwidth in erasure - coded distributed storage systems . in this framework , the overall system consists of @xmath1 storage nodes situated in different network locations , each with @xmath2 units of data , and the content is coded in such a way that by accessing any @xmath3 of these @xmath1 storage nodes , the full data content of @xmath4 units can be completely recovered .",
    "when a node fails , a new node may access any @xmath5 remaining nodes for @xmath6 units of data each , in order to regenerate a new data node .",
    "the main result in @xcite is for the so - called functional - repair case , where the regenerating process only needs to guarantee that the regenerated node can serve the same purpose as the lost node , _",
    "i.e. _ , data reconstruction using any @xmath3 nodes , and being able to help regenerate new data nodes to replace subsequently failed nodes .",
    "it was shown that this problem can be cleverly converted to a network multicast problem , and the celebrated result on network coding @xcite can be applied directly to provide a complete characterization of the optimal bandwidth - storage tradeoff .",
    "furthermore , linear network codes @xcite are sufficient to achieve this optimal performance .    the decoding and repair rules for functional - repair regenerating codes may evolve as nodes are repaired , which increases the overhead of the system .",
    "moreover , functional - repair does not guarantee systematic format storage , which is an important requirement in practice .",
    "for this reason , exact - repair regenerating codes have received considerable attention recently @xcite , where the regenerated data need to be exactly the same as that stored in the failed node .    the optimal bandwith - storage tradeoff for the functional - repair case can clearly serve as an outer bound for the exact - repair case .",
    "there also exist code constructions for the two extreme cases , _",
    "i.e. _ , the minimum storage regenerating ( msr ) point @xcite , or the minimum bandwidth regenerating ( mbr ) point @xcite , and the aforementioned outer bound is in fact achievable at these two extreme points . also relevant",
    "is the fact that symbol extensions are necessary for linear codes to achieve the msr point for some parameter range @xcite , however the msr point can indeed be asymptotically ( in @xmath4 ) achieved by linear codes for all the parameter range @xcite .",
    "it was also shown in @xcite that other than the two extreme points and a segment close to the msr point , the majority the functional repair outer bound is in fact not strictly achievable by exact - repair regenerating codes .",
    "the non - achievability result reported in @xcite was proved by contradiction , _",
    "i.e. _ , a contradiction will occur if one supposes that an exact - repair code operates _ strictly _ on the optimal functional - repair tradeoff curve .",
    "however , it is not clear whether this contradiction is caused by the functional - repair outer bound being only asymptotically achievable , or caused by the existence of a non - vanishing gap between the optimal tradeoff of exact - repair codes and the functional - repair outer bound .",
    "in fact , the necessity of symbol extension proved in @xcite and the asymptotically optimal construction given in @xcite may be interpreted as suggesting that the former is true .    in this work ,",
    "we focus on the simplest case of exact - repair regenerating codes , _",
    "i.e. _ , when @xmath0 , for which the rate region has not been completely characterized previously . a complete characterization of the rate region is provided for this case , which shows that indeed there exists a non - vanishing gap between the optimal tradeoff of the exact - repair codes and that of the functional - repair codes . as in many open information theoretical problems ,",
    "the difficulty lies in finding good outer bounds , particularly in this problem with a large number of regenerating and reconstruction requirements .",
    "we rely on a computer - aided proof ( cap ) approach and take advantage of the symmetry in the problem to reduce the computation complexity .",
    "this approach builds upon yeungs linear programming ( lp ) framework @xcite , but instead of only machine - proving whether an information theoretic bound is true or not as in @xcite , we further use a secondary optimization procedure to find an _ explicit information theoretic proof _ , which , after some amount of machine - to - human translation , is presented here . as of our knowledge",
    ", this is the first time that the lp framework is meaningfully applied to a non - trivial information theoretic problem , which leads to a complete solution .",
    "although this cap approach may be of independent interest by itself , due to space constraint we focus in this paper on establishing the rate region , and only briefly discuss the cap approach and leave the details to another work .",
    "the rest of the paper is organized as follows . in section [ sec : definition ] , we provide a formal definition of the problem and review briefly the functional - repair outer bound .",
    "the main result of this paper is given in section [ sec : main ] .",
    "the code construction for the achievability part is given in section [ sec : achievability ] , and the converse is proved in section [ sec : converse ] .",
    "section [ sec : conclusion ] concludes the paper .",
    "a @xmath7 exact - repair regenerating code is formally defined as follows , where the notation @xmath8 is used to denote the set @xmath9 , and @xmath10 is used for the cardinality of a set @xmath11 .",
    "an @xmath12 exact - repair regenerating code for the @xmath7 case consists of @xmath13 encoding function @xmath14 , @xmath13 decoding functions @xmath15 , @xmath16 repair encoding functions @xmath17 , and @xmath13 repair decoding functions @xmath18 , where @xmath19 each of which maps the message @xmath20 to one piece of coded information , @xmath21 each of which maps @xmath22 pieces of coded information stored on a set @xmath11 of nodes to the original message , @xmath23 each of which maps a piece of coded information at node @xmath24 to an index that will be made available to reconstruct the data at node @xmath25 , and @xmath26 each of which maps 3 such indices from the helper nodes to reconstruct the information stored at the failed node .",
    "the functions must satisfy the data reconstruction conditions@xmath27 and the repair conditions @xmath28    a normalized bandwidth - storage pair @xmath29 is said to be @xmath7 exact - repair achievable if for any @xmath30 there exists an @xmath12 exact - repair regenerating code such that @xmath31 the collection of all the achievable @xmath29 pairs is the achievable region @xmath32 of the @xmath7 exact - repair regenerating codes .    the quantity @xmath33 in the definition is introduced to include the case when the storage - bandwidth tradeoff may be approached asymptotically , _",
    "e.g. _ , the case considered in @xcite .      in order to derive the outer bound ,",
    "it is convenient to write the reconstruction and regenerating conditions in the form of entropy constraints . for this purpose ,",
    "some further notation is introduced here , which is largely borrowed from @xcite .",
    "let us denote the message random variable as @xmath34 , which is uniformly distributed in the set @xmath35 .",
    "define @xmath36 thus we have the following random variables in the set @xmath37 @xmath38 the reconstruction requirement thus implies that @xmath39 the regenerating requirement implies that @xmath40 and @xmath41 because the message @xmath34 has a uniform distribution , we also have that @xmath42 which is strictly larger than zero .",
    "note that together with ( [ eqn : reconstruction ] ) , this implies that @xmath43 the symmetric storage requirement can be written as @xmath44 and the regenerating bandwidth constraint can be written as @xmath45 the above constraints ( [ eqn : reconstruction])-([eqn : beta ] ) are the constraints that need to be satisfied by any exact - repair regenerating codes .",
    ".[fig : bound433 ] ]      the optimal tradeoff for functional - repair regenerating codes was given by dimakis _",
    "@xcite , which provides an outer bound for the exact - repair case .",
    "the bound has the following form in our notation for the @xmath7 case ( see fig .",
    "[ fig : bound433 ] ) @xmath46 it is not difficult to show that it can be rewritten as the following four simultaneous linear bounds @xmath47 the msr point for this case is @xmath48 , and the mbr point is @xmath49 .",
    "the main result in this paper is the following theorem .",
    "the rate region @xmath32 of the @xmath0 exact - repair regenerating codes is given by @xmath50    this rate region is also depicted in fig .",
    "[ fig : bound433 ] .",
    "the rate region @xmath32 has three corner points , and thus we only need to show that these three points are all achievable .",
    "the msr point @xmath48 is simply achieved by any @xmath51 mds code , such as the binary systematic code with a single parity check bit .",
    "the mbr point @xmath49 is also easily obtained by using the repair - by - transfer code construction in @xcite , which in this case reduces to a simple replication coding .",
    "it thus only remains to show that the point @xmath52 is also achievable .",
    "next we shall give a construction for a binary @xmath7 code with @xmath53 , @xmath54 and @xmath55 , which indeed achieves this operating point .",
    "the code is illustrated in table [ table : code ] , where ( and in the remainder of this section ) the addition @xmath56 is in the binary field .",
    "here @xmath57 are the systematic bits , @xmath58 , and the remaining bits are the parity bits .",
    "first note that the construction is circularly symmetric , and thus without loss of generality , we only need to consider the case when node 1 fails . if it can be shown that when node 2 , 3 , 4 each contribute two bits , node 1 can be reconstructed , which also implies that the complete data can be recovered using only node 2 , 3 and 4 , then the proof is complete .",
    "this can indeed be done using the combination shown in table [ table : repair ] .    upon receiving these six bits in table [ table :",
    "repair ] , the new node can form the following combinations @xmath59 where the first combination is formed by using the second bit from node 2 and the first bit from node 3 ( shown in bold ) , and the other combinations can be formed similarly . in the binary field , this is equivalent to having @xmath60 and it is seen that @xmath61 can be recovered by simply taking the difference between ( [ eqn : first ] ) and ( [ eqn : second ] ) , and similarly @xmath62 can be recovered by taking the difference between ( [ eqn : first ] ) and ( [ eqn : third ] ) .",
    "note further that the third bit stored in node 1 is simply the summation of the first bits contributed from node 2 , 3 , and 4 in table [ table : repair ] .",
    "the proof is thus complete .    .a",
    "@xmath7 code for @xmath52 .",
    "[ cols=\"^,^,^,^\",options=\"header \" , ]",
    "it is clear that we only need to prove the following bound @xmath63 because the other bounds in the main theorem can be obtained from the outer bound ( [ eqn : frouterbound ] ) .",
    "we first give an instrumental result regarding the symmetry of the optimal solution .      a permutation @xmath64 on",
    "the set @xmath65 is a one - to - one mapping @xmath66 .",
    "the collections of all permutations is denoted as @xmath67 .",
    "any given permutation @xmath64 correspondingly maps a random variable @xmath68 to @xmath69 .",
    "any subset of @xmath70 , e.g. , @xmath71 , is thus mapped to another set of random variables , denoted as @xmath72 .",
    "for example , the permutation @xmath73 , @xmath74 , @xmath75 and @xmath76 will map the set of random variables @xmath77 to @xmath78 .",
    "similarly a random variable @xmath79 will be mapped to @xmath80 , and for any subset of @xmath81 , we use a similar notation as for the case of @xmath70 .",
    "an @xmath12 exact - repair regenerating code is said to induce a symmetric entropic vector if for any sets @xmath82 and @xmath83 and any permutation @xmath84 , @xmath85    a normalized bandwidth - storage pair @xmath29 is said to be entropy - symmetrically @xmath7 exact - repair achievable if for any @xmath30 there exists an @xmath12 exact - repair regenerating code which induces a symmetric entropic vector such that @xmath31 the collection of all such @xmath29 pairs is the symmetrically achievable region @xmath86 of the @xmath7 exact - repair regenerating codes .    with the above definition , it is not difficult to see the following proposition is true .",
    "[ prop : symmetry ] for @xmath0 exact - repair regenerating codes @xmath87 .",
    "clearly the inclusion @xmath88 is true . for the other direction",
    ", we can simply invoke a time - sharing ( or more precisely here , space - sharing ) argument among all possible permutations ; the proof details are thus omitted .      because of the equivalence in proposition [ prop : symmetry ] , without loss of generality we can limit ourselves to only codes that induce symmetrical entropy vectors .",
    "we first write @xmath89 where the first inequality is by ( [ eqn : alpha ] ) and ( [ eqn : beta ] ) , the first equality is by expanding the mutual information terms and using @xmath90 implied by ( [ eqn : regeneratingencoding ] ) and then the symmetry @xmath91 and the second equality is by ( [ eqn : regeneratingencoding ] ) , ( [ eqn : regenerating ] ) and ( [ eqn : totalinfo2 ] ) on the third term @xmath92 and ( [ eqn : regeneratingencoding ] ) on the sixth term . for notational simplicity , we shall write from here on ( s ) , ( [ eqn : reconstruction ] ) , ( [ eqn : regeneratingencoding ] ) , ( [ eqn : regenerating ] ) and ( [ eqn : totalinfo2 ] ) on top of the equalities in the derivation to signal the reasons for the equalities , _",
    "i.e. , _ by the symmetry , or by equations ( [ eqn : reconstruction ] ) , ( [ eqn : regeneratingencoding ] ) , ( [ eqn : regenerating ] ) and ( [ eqn : totalinfo2 ] ) , respectively .    note that @xmath93 where , to be more precise , the last but one equality is because @xmath94 it follows that @xmath95 notice that @xmath96 then we can further write @xmath97 however @xmath98 which leads to @xmath99 where in the above step labeled ( [ eqn : regenerating ] ) we have first used the fact that @xmath100 . because @xmath101 we can now write @xmath102 by writing @xmath103 and @xmath104 we can arrive at @xmath105 the proof can be completed by combining ( [ eqn : lastbutone ] ) and ( [ eqn : lastone ] ) .      it should be clear at this point that the converse proof is rather difficult to find manually , and this difficulty motivated the investigation of the computer - aided proof ( cap ) approach .    using the linear programming ( lp ) bound in @xcite as an outer bound to the entropy space",
    ", one can potentially find an outer bound for the problem .",
    "a direct application is however infeasible , because the number of variables in the lp is exponential in the number of random variables , with an even larger number of constraints .",
    "there are at least 16 random variables , resulting in an lp too large for most solvers . to circumvent this difficulty ,",
    "the symmetry and other techniques are used to reduce the problem size . moreover , even when certain @xmath106 can be shown to be on the outer bound using this approach , it does not lead to an explicit proof as given above . to achieve this , we further extended the lp approach by embedding a secondary linear optimization problem to yield explicitly the converse proof .",
    "the details of this approach , unfortunately , can not be included here due to space constraint .",
    "a complete characterization is provided for the rate region of the @xmath7 exact - repair regenerating codes , which shows that the cut - set - based outer bound @xcite is in general not ( even asymptotically ) tight for exact - repair .",
    "an explicit binary code construction is provided to show that the given rate region is achievable .",
    "it should be noted that the rate region given here remains the same if the codes are required only to have asymptotic zero error probability , instead of zero - error .    as an ongoing work",
    ", we are currently investigating the generalization of the results presented here for other @xmath107 parameters , and have obtained partial results on several more cases , which will be presented in a follow - up work .",
    "n. b. shah , k. v. rashmi , p. v. kumar and k. ramchandran , distributed storage codes with repair - by - transfer and non - achievability of interior points on the storage - bandwidth tradeoff , , vol .",
    "1837 - 1852 , mar .",
    "n. b. shah , k. v. rashmi , p. v. kumar and k. ramchandran , interference alignment in regenerating codes for distributed storage : necessity and code constructions , , vol .",
    "2134 - 2158 , apr . 2012 .",
    "k. v. rashmi , n. b. shah , and p. v. kumar , optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , , vol .",
    "57 , no . 8 , pp . 5227 - 5239 , aug . 2011 ."
  ],
  "abstract_text": [
    "<S> exact - repair regenerating codes are considered for the case @xmath0 , for which a complete characterization of the rate region is provided . </S>",
    "<S> this characterization answers in the affirmative the open question whether there exists a non - vanishing gap between the optimal bandwidth - storage tradeoff of the functional - repair regenerating codes ( _ i.e. , _ the cut - set bound ) and that of the exact - repair regenerating codes . </S>",
    "<S> the converse proof relies on the existence of symmetric optimal solutions . for the achievability , </S>",
    "<S> only one non - trivial corner point of the rate region needs to be addressed , for which an explicit binary code construction is given .    </S>",
    "<S> = 0.21 cm = 0.21 cm = -0.0 cm = -0.0 cm    = 0.15 cm = 0.15 cm </S>"
  ]
}