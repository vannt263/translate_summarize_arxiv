{
  "article_text": [
    "* _ title of program : _ slam * _ available from : _ +   http://www.ttp.kit.edu/progdata/ttp13/ttp13-024/ * _ computer for which the program is designed and others on which it is operable : _ any computer where mathematica version  6 or higher is running providing bash and sed .",
    "* _ operating system or monitor under which the program has been tested : _ linux * _ no . of bytes in distributed program including test data etc . :",
    "_ @xmath1 bytes . * _ distribution format : _ source code * _ keywords : _ susy , mssm , slha , sql , database , mathematica , particle spectrum generation . * _ nature of physical problem : _ interfacing published spectrum generators for automated creation , saving and loading of susy particle spectra . *",
    "_ method of solution : _ slam automatically writes / reads slha spectrum generator input / output and is able to save / load generated data in / from a data base .",
    "* _ restrictions : _ no general restrictions , specific restrictions are given in the manuscript .",
    "* _ typical running time : _ a single spectrum calculation takes much less than one second on a modern pc .",
    "although there has been no experimental evidence for the realization of supersymmetry ( susy ) yet , the minimal supersymmetric standard model ( mssm ) became very popular among particle physicists .",
    "many calculations of elementary particle processes include the effects of susy particles .",
    "this applies to cosmological predictions like relic density of dark matter from early universe , predictions of cross sections for the direct production of susy particles at colliders like the lhc and ilc , the calculation of radiative corrections due to the presence of susy particles for standard model ( sm ) processes , for example in flavour physics , and many more .",
    "compared to the sm a supersymmetric model is more predictive because supersymmetry imposes many relations between different parameters .",
    "however , due to the fact that we do not live in a supersymmetric world susy must be softly broken in a realistic model describing our world .",
    "since the breaking mechanism is still unknown many new unknown parameters arise in the broken model .",
    "once one makes an assumption for those unknown parameters or assumes a certain breaking mechanism of susy , many parameters can be determined directly from the knowledge of the measured sm parameters .",
    "for example , the higgs mass is an independent parameter in the sm . in the mssm",
    "this is no longer true , because after assuming a certain susy breaking model it can be calculated from the knowledge of a few parameters . on the one hand",
    "this is a nice feature , but on the other hand it leads to the problem of a consistent determination of all relevant parameters like masses , mixing angles , and couplings in such a model .",
    "a collection of such a set of parameters will be called spectrum in the following .    fortunately this problem has already been solved and spectra can be calculated automatically using spectrum generators like spheno  @xcite , softsusy  @xcite , suseflav  @xcite or",
    "suspect  @xcite .",
    "in order to manage the identification of particle parameters and couplings as well as option settings for programs in a common way , the supersymmetry les houches accord ( slha ) has been proposed  @xcite and is used by many programs including the mentioned ones . within the slha",
    "the generation of a consistent spectrum can be specified by providing a single input file ( leshouches.in ) . providing this file",
    "leads , after a run of the generator , to an output file ( leshouches.out ) containing the complete spectrum in the slha notation .",
    "if one is interested in only a few parameters of a single spectrum one can easily extract them via copy and paste by hand . however , this procedure is certainly not feasible if one needs to extract many parameters of more than one spectrum for further numerical evaluation .",
    "in fact this is the situation one is facing immediately when trying to create a plot in dependence of high or low scale scenario parameters like @xmath2 .",
    "that means in order to be able to use the output of spectrum generators or any other program using slha , one needs an interface providing an automatic extraction of the relevant parameters from the output file leshouches.out .",
    "there already exist public interfaces written for c++  @xcite , fortran  @xcite , and python  @xcite .",
    "due to its vast amount of implemented functions and with increasing computer power and increasing computation speed , mathematica became an attractive alternative for numerical evaluation of analytic expressions obtained in susy models .",
    "however , to the authors knowledge there is up to now no public implementation of an interface to spectrum generators , automatically writing and reading slha files with the goal to provide simple data sets containing all needed parameters in mathematica for general purpose .",
    "this task is accomplished by slam ( * s*upersymmetry * l*es houches * a*ccord with athematica ) which will be presented in detail throughout this publication .",
    "a preliminary version of this package with name lhsqldb was already used in refs .",
    "@xcite and  @xcite .",
    "this paper is organized as follows : for the impatient reader we present in section  2 typical usage examples which should give a compact overview of what slam is capable to do . in section",
    "3 we give detailed information about how to install and configure the package properly before we give a full usage instruction in section  4 .",
    "section  5 is dedicated to the internal structure of slam and may help interested users to go beyond the `` black box '' model of this package .",
    "to demonstrate , how the package should be used , we present some of the implemented scenarios in this section . the full list of predefined scenarios can be found in tab .",
    "[ tab : preimplementedmodels ] .",
    "once a spectrum generator is installed on the system and slam is configured properly it is very easy to obtain a slha spectrum within mathematica .",
    "install the package into the mathematica kernel by loading the main file :     +   +    afterwards , one can generate spectra , e.g. in the predefined @xmath3-scenario  @xcite by using the central function ` obtainleshouchesspectrum ` :     +   +    with the displayed command we have requested a @xmath3-spectrum using the spectrum generator spheno .",
    "such a spectrum depends on @xmath4 and @xmath2 .",
    "because we did not switch off the usage of a currently empty data base , slam creates a new table in it .",
    "since there is no matching spectrum in the data base the spectrum generator spheno is run with the given parameters and the spectrum stored in the data base .",
    "finally it returns a part of the spectrum in a list of replacement rules .",
    "since no parameters have been requested explicitly , slam just returned a list of selected parameters , which are defined in a default request list .",
    "assuming we are only interested in the mass of the lightest higgs boson @xmath5 within the same scenario we can use :     +   +    [ mb : mhmaxrun2 ]    where we have used the slha identification for the on - shell higgs mass , settled in the block ` \" mass \" ` with key entry @xmath6 .",
    "the choice of the symbol ` mh0 ` is completely arbitrary , up to the restriction that it has to be an undefined symbol .",
    "this allows the user to use his own notation in mathematica .",
    "the ` real ` statement tells slam that it should treat the parameter during the internal processing as a real valued number .",
    "note that slam did not rerun spheno to obtain the higgs mass , but just retrieved the value directly from the data base , where it has been stored during the previous call of the function ` obtainleshouchesspectrum ` .    in order to see the default value of the option ` inputrequest ` one can use :     +   +    [ mb : defaultinputrequest ]    with the given output it is straightforward to customize the ` inputrequest ` option values for the user s needs .    beside the @xmath3 scenario the no - mixing , gluophobic and small @xmath7 scenarios , which were proposed together with the @xmath3 scenario in ref .",
    "@xcite , are already implemented and have the same input variables @xmath4 and @xmath2 .",
    "they are used when setting the ` model ` option to ` \" nomix \" ` , ` \" smallalpha \" ` , or ` \" gluophob \" ` .",
    "the msugra - scenario exists as a predefined model and can be called as follows :     +   +    the shown values for the five input parameters represent their default values .",
    "one should be aware that those values are already excluded experimentally and their allowed values are much higher .",
    "since more and more space of the msugra scenario has been excluded at the lhc , there has been a proposal of many scenarios in ref .",
    "@xcite taking into account exclusions by this non - observation of susy particles .",
    "if there is no interest in a susy breaking mechanism motivated by some high scale physics , one can just define all the susy breaking parameters at a low scale . with certain assumptions one can reduce the number of these parameters to 19 .",
    "two different planes have been defined in such a phenomenological 19 parameter mssm  @xcite :    * p19mssm plane i ( ` \" p19mssm1 \" ` ) in dependence of @xmath8(`m1 ` ) and @xmath9(`m3 ` ) .",
    "* p19mssm plane ii ( ` \" p19mssm2 \" ` ) depends on @xmath8(`m1 ` ) and a common soft slepton mass breaking parameter @xmath10(`mslepton ` ) of the first two generations .",
    "both scenarios are implemented in slam .",
    "we just show an example for the first one :     +   +    to provide a reasonable light higgs mass , we show the spheno result for the scenario point p19mssm1.13 .",
    "the very first points in the sequence ( p19mssm1.1 , p19mssm1.2 ,  ) seem to be already excluded if one assumes that the new particle discovered at the lhc is the lightest higgs boson .      on the one hand predefined scenarios are quite useful , because the user does not need to worry about all the required input parameters , on the other hand they are very restrictive . to remove this disadvantage ,",
    "slam can be used to generate spectra for any user - defined scenario one can think of .",
    "this is done by handing all relevant input parameters to slam directly via the option ` model ` of the function ` obtainleshouchesspectrum ` . in the example below we generate the same msugra spectrum like two sections ago but this time using direct model input for the underlying scenario :     +   +    in the first line we defined our own model in variable ` mymodel ` . in this example",
    ", we use a minimal definition of the model , only giving the definition of needed entry values which are indicated by the ` ev ` symbols .",
    "in addition , it is possible to define comments for every entry , which can improve the readability of the slha files .",
    "as can be seen from the output , the requested spectrum was already stored in the data base , which is the case since it corresponds to the predefined msugra scenario used before .",
    "we have to add the warning that when using user - defined scenarios , the user has to make sure that the input provided is sufficient for the spectrum generators to run correctly .",
    "slam will not check the provided input for its consistency .",
    "to be able to use slam one needs :    * mathematica of version @xmath11 or higher . * a unix operating system providing bash and sed .    and at least one of the spectrum generators listed in the following table . +    [ cols=\"^,^,^\",options=\"header \" , ]     the options and their descriptions are :    * ` adoptentryformats ` * * ` false ` + will keep the string format of all entry values read in . * * ` true ` + will convert the entry format according to either inputrequest or datastructure , depending on the value of inputrequest .",
    "* ` datastructure `   + gives the default declaration of all entry values .",
    "its default value is given by ` leshouchesoutputsqlformats ` in the slam.config.m file .",
    "note , that this can be changed to what is required for the content of the slha file getting loaded . * ` input ` * * ` file ` + tells readleshouchesspectrumfile to read in the file according to the path and file name provided in ` outputfilepath ` . * * direct string input + will be read like stemming from a file . * ` inputrequest ` * *   ` all ` + returns everything without touching the data format , that means everything stays a string . * * ` allformated ` + returns only blocks of entry values which are declared in the ` datastructure ` option .",
    "further , all values are converted to their declaration formats , if ` adoptentryformats ` is set to ` true ` .",
    "use this option value in order to generate direct input useable as ` model ` option value of obtainleshouchesspectrum . *",
    "* direct input + only the selected input values will be returned in a replacement rule , working like for obtainleshouchesspectrum ( see page  [ itm : inputrequest ] ) . *",
    "` removetemporaryfiles ` * * ` true ` + tells readleshouchesspectrumfile to delete the file after reading it . * * ` false ` + will keep the file unchanged after reading it . * ` outputfilepath `   + provides a string holding the path and the name of the file that should be read .",
    "because we already have written out an example slha file in the previous section , we can give an usage example of the function readleshouchesspectrumfile by just loading in , what we have written out :     +   +    [ mb : readleshouchesspectrumfile1 ]    in the code above we set the default value of removetemporaryfiles to ` false ` to be sure that we can load in the input file again .",
    "further we specify the file which should be loaded .",
    "after that we call the readleshouchesspectrumfile function , requesting everything that can be found in the slha file by setting the option inputrequest - > all .",
    "we show the output in the inputform to be able to distinguish strings from regular symbol names .",
    "the output shows everything that is contained in the file , but the entry values ( ` ev ` ) are kept as strings .    in order to adopt their original format",
    ", we can load the file with the option inputrequest - > allformated . because the default option of datastructure , which is given by leshouchesoutputsqlformats , does not contain any suitable declaration information for our little toy example",
    ", we have to provide the proper declaration through the datastructure option on our own .",
    "this is done in the following :     +   +    [ mb : readleshouchesspectrumfile2 ]    compared to the output of mbx .",
    "( m[mb : readleshouchesspectrumfile1 ] ) , we see that all entry values which have been declared got converted from string to the declared format . since we did not declare anything for the block ` \" holidays \" `",
    ", this block is completely missing .    in the last example",
    "we directly request just the number of advents in block ` \" xmas \" ` :     +   +    [ mb : readleshouchesspectrumfile3 ]    this results in a list containing a replacement rule , where our choice of symbol for the number of advents has been taken over and the number was properly converted to an integer .",
    "in this section we provide information , which enables the user to extend or adjust slam to very special needs . before going into details , some words about the general layout of the package and the spirit in which it has been programmed are in order .    the package is purely written in mathematica . only very little bash code is used to manage the spectrum generators and the slha files . throughout the package the code was written in a modular way , heavily relying on the built - in options system of mathematica . a comprehensive introduction to the options interface can be found in the mathematica help centre .",
    "it is easy to write argument insensitive code for the call of a sub function inside a normal function , if one uses the options interface .",
    "one does not need to worry about which argument has to be put at which position and it is no problem to add further parameters later , without changing the code for the function call itself . with this feature one can conveniently write modular code , grouping different tasks into different , topic oriented functions .",
    "this helps to keep the code local and modular , which is very convenient while debugging .",
    "if something is not working properly , one can just check the data exchanged between modules . finding the place where wrong data appears leads directly to the faulty module .",
    "moreover , since every module serves a very special purpose only , it is simpler to ensure that each module fulfils its task properly than just writing a single code which has to achieve many goals properly at the same time . thus following the old maxim `` divide et impera '' , one can write complicated code achieving multiple goals properly by just writing small modules doing their job properly and finally connecting all of them .    in the following subsection we are going to give a `` map '' of all relevant main modules which work inside the obtainleshouchesspectrum function",
    ". we will walk on this map through the steps which are performed automatically by mathematica in order to carry out commands given by the user . during this subsection",
    "the reader should get a basic orientation , needed for any modification of the code .",
    "the second subsection clarifies the mathematica internal representation of the slha used in this package .    in the third subsection",
    "we explain the used layout of the data base table in more detail .",
    "the fourth subsection should enable the reader to implement new predefined scenarios in the existing code of slam .",
    "internal structure of the function obtainleshouchesspectrum .",
    "the named white rectangular boxes correspond to sub functions used by obtainleshouchesspectrum .",
    "arrows indicate the data flow .",
    "rounded boxes stand for data in certain format , depending on their colour .",
    "the red lines follow the order of function calls .",
    "yellow diamonds show possible branchings into different function calls in dependence of certain conditions . ]    in fig .",
    "[ fig : obtainleshouchesspectrum ] a simplified `` blueprint '' of the function obtainleshouchesspectrum is shown .",
    "the function connects a spectrum generator on the left and a sql data base on the right with the output of the function at the bottom right , in dependence of input provided by the user , shown at the top left . inside the function obtainleshouchesspectrum , which is indicated by the light grey background",
    ", sub functions are displayed in white rectangular boxes .",
    "they are connected by red lines indicating the order of sub - function calls .",
    "the yellow diamonds represent branchings of function calls in dependence of certain conditions .",
    "the rounded boxes stand for data prepared in a certain format indicated by the colour of the background .",
    "in fact all names inside are actual function and data names used in the mathematica code .",
    "black arrows show the flow of data .    in the following the flowchart is described step by step .",
    "the starting point of this description is the place where the user input enters obtainleshouchesspectrum :    1 .   in dependence of the option ` cleardatabase `",
    "the sql data base table will be removed by the sub function dropsqlleshouchestable when ` true ` or ` only ` .",
    "2 .   in case of ` only ` the evaluation ends after that .",
    "when ` true ` or ` false ` was selected it generates the data generatorinputsqldefinitions with either the tosqlleshouchesdata or the generateinputsqlchecklist function .",
    "the first one is used in case a direct input model is used , the second function will do the job when a predefined model is considered .",
    "when the option usedatabase is ` true ` , the next step is to check if there is already any data consistent with the defined generatorinputsqldefinitions in the data base .",
    "this is done by calling the sub function selectsqlleshouchestable . 1 .   if there is any spectrum ready , it is stored in sqldatabaseoutput which gets filtered by the sub function filterleshouchesblocktoinputrequest in order to provide the final output and end the evaluation .",
    "2 .   in case",
    "no proper data base table could be found it is created by the sub function createsqlleshouchesdatabase .",
    "further steps coincide with the case below .",
    "if no match was found , the spectrum needs to be obtained from the spectrum generator .",
    "5 .   in order to obtain a spectrum from the generator , the proper slha input file has to be created .",
    "this is either done with the sub function writeleshouchesfile , when a direct input model is considered , or with the sub function writespectrumgeneratorinput , when a predefined model is in use .",
    ".   then the spectrum generator is run by the sub function runspectrumgenerator .",
    "if there was no problem in the previous step , the sub function readleshouchesspectrumfile is used to read in the slha output file and store the data in the expression newspectrumblockrule .",
    "8 .   in case",
    "the options extenddatabase and usedatabase were set to ` true ` : 1 .",
    "readleshouchesspectrumfile is used to read in the slha input file and store the data in the expressions generatorinputblockrule .",
    "2 .   tosqlleshouchesdata transforms the data in generatorinputblockrule and newspectrumblockrule to the data base writable expressions generatorinputsqldefinitions and generatoroutputsqldefinitions .",
    "then both sets of data are saved together in the sql data base through the sub function writesqlleshouchesdata .",
    "the final step is done by the sub function filterleshouchesblocktoinputrequest filtering the requested output from the data of newspectrumblockrule in order to return it as output .",
    "we did not discuss any option relevant for the sub functions .",
    "for example , the spectrumgenerator option , telling obtainleshouchesspectrum which spectrum generator should be used , does not appear in the code of the function at all .",
    "this is because obtainleshouchesspectrum just trades these options to its sub function via a generic interface .",
    "this keeps the structure of the code very simple and generic .      in the following subsection",
    "we explain the mathematica internal format of slha data , which is in use for the expressions generatorinputblockrule , newspectrumblockrule and sqldatabaseoutput ( see fig .",
    "[ fig : obtainleshouchesspectrum ] ) .",
    "the easiest way of explaining a certain format is to give just a data example .",
    "a slha output like :    .... block minpar   # input parameters   3    2.00000000e+01   # tanb at m_z   4    1.00000000e+00   #",
    "sign(mu ) block alpha   # effective higgs mixing angle      -1.05379330e-01   # alpha block yu q=",
    "1.01490536e+03   # ( susy scale )   1 1   8.59529004e-06   # y_u(q)^drbar ....    looks like the following in the mathematica internal notation :    ....   exampleslhadata= {   \" minpar \" - > {        bc - > \" input parameters \" ,         bi - > { ev - > none , ec - > none } ,         3 - > { ev - > \" 2.00000000e+01 \" , ec - > \" tanb at m_z \" } ,         4 - > { ev - > \" 1.00000000e+00 \" , ec - > \" sign(mu ) \" } } ,    \" alpha \" - > {        bc - > \" effective higgs mixing angle \" ,         bi - > { ev - > none , ec - > none } ,         none - > { ev - > \" -1.05379330e-01 \" , ec - > \" alpha \" } } ,   \" yu \" - > {        bc - > \" ( susy scale ) \" ,         bi - > { ev - > \" q=   1.01490536e+03 \" , ec - > none } ,         { 1 , 1 } - > { ev - > \" 8.59529004e-06 \" , ec - > \" y_u(q)^drbar \" } } } ; ....    as one can see , the slha data is ordered with respect to blocks , where each block is just a replacement rule giving the block name in capital letters as string on the left hand side of the rule and the content of the block in a list on the right hand side .",
    "each of those lists contains a replacement rule for the block comment ( ` bc ` ) .",
    "further it contains a replacement rule for the block information ( ` bi ` ) , which has a list of two replacements on its right hand side .",
    "the latter contains a replacement for its entry value ( ` ev ` ) and entry comment ( ` ec ` ) , where in case of the block information the last one is always ` none ` .    in case the entry value is given by a matrix element depending on two entry values , instead of a single integer as entry key , a list of two integers is used , as can be seen in the last line .    in case where",
    "there is no entry key for a value , like for the mixing angle @xmath12 , the variable ` none ` is used as entry key .",
    "note that in the example above all entry values are kept as strings .",
    "this only happens when slha files are loaded from a generator using the option inputrequest->all .    in case of inputrequest->allformated  slam tries to return converted entry values ( e.g. real numbers ) using the declarations made in the file slam.config.m .",
    "however , blocks which were not declared at all will not be displayed in the output .",
    "entry values are returned in their declared format when loading spectra from the data base .      because one can use the automatically created and built - up data base independently from slam , the layout of the table should be clarified .",
    "the default option value for ` tablename ` leads to the creation of a table with name ` \" spectratable \" ` .",
    "any table is declared and initialized with the information provided in the variables leshouchesinputsqlformats and leshouchesoutputsqlformats defined in the file slam.config.m .",
    "these variables are read in and the contained information is processed once , when the slam package gets loaded , to give the full declaration list of the table .",
    "the full list of declarations can be printed using the command :    ....   ( tabledeclarationlist /.",
    "options[obtainleshouchesspectrum ] )",
    "// tableform ....    we do not give the full default output here because it is quite lengthy , but pick only a selection for demonstration :     +   +    [ mb : tabledeclarations ]    note that all terms appearing in this output are in fact strings , because ` tableform ` does not display the ` \" ` character .",
    "the output shows pairs of strings where the first string gives the name of the corresponding column and encodes mainly the place where the data is located in the slha file .",
    "the second string defines the type of data which will be stored in the corresponding column .",
    "so far there are only three different data types in use : ` \" integer \" ` , ` \" double \" ` and ` \" varchar \" ` .    in the selection shown in mbx .",
    "( m[mb : tabledeclarations ] ) one can distinguish two different kinds of column names :    * column names starting with a `` ` i ` '' reserve space for data stemming from slha input files . * column names starting with a `` ` o ` '' reserve space for data generated by the spectrum generators , so stemming from the slha output files .",
    "further the column names ending with ` comment ` lead to columns , which do only save comments in the ` \" varchar \" ` format .",
    "this is because one can optionally place comments behind the hash symbol ( ` # ` ) in a slha file in each line .",
    "after the initial `` ` i ` '' or `` ` o ` '' comes a block name in capital letters separated by an underscore .    * for columns which do not save a string one of the following holds then : 1 .",
    "at least one further underscore separated integer value is required .",
    "this value corresponds to the key value defined in the slha .",
    "see lines seven and nine in the displayed output above for example .",
    "2 .   if the value represents a matrix element there may be two underscore separated integers .",
    "those integers correspond to two valued key entries defined in the slha .",
    "if the corresponding slha quantity has no key value , that means it comes alone in its own data block , like it is the case for the mixing angle @xmath12 , the string ` none ` has to follow the block name after one underscore .",
    "* every data value entry can have its own comment .",
    "the name of the comment column is obtained by simply appending the string ` _ comment ` to the name of the corresponding data value column .",
    "see lines ten and eight in the output above for example .",
    "* every block can have its own comment which is saved in the column name given by the block location appending the string ` _ comment ` .",
    "lines one , three and five of the displayed output above give examples for this case .",
    "* every block can have an additional information entry which is mainly used to hold the scale information . for example a block definition in a slha file might look like the following : + ....   block gauge q=   1.01490536e+03   # ( susy scale ) .... + everything after the space behind ` gauge ` and before the hash symbol ( ` # ` ) gets stored in the block information ( ` bi ` ) .",
    "the information is automatically saved in the ` \" varchar \" ` format , as can be seen e.g. from lines two , four and six in the printout above where the name of the column is ending with the string ` _ info ` . note that requesting this data in the output as ` \" real \" ` will force slam to return just the real number without the ` q= ` .    with the given information it is easy to search directly in the data base for certain parameter limits .",
    "an example is to search for higgs boson masses between @xmath13 gev and @xmath14 gev :    .... select i_extpar_26 as ma ,         i_minpar_3 as tanbeta ,         o_mass_25 as mh           from spectratable          where ( o_mass_25 > 123 & & o_mass_25 < 129 )          order by mh ; ....      adding a new predefined scenario requires 6 steps but may help to speed up the generation of spectra , because less calculation steps have to be done for predefined scenarios in mathematica .    1 .",
    "if the new predefined scenario requires new option values because it depends on parameters which have not been used yet , one should add a new usage instruction before the private section in the file slam.m for every symbol which will become an option .",
    "for example , the usage instruction for the ` nmess ` parameter used in the mgmsb - scenario looks like : + .... nmess::usage=\"number of minimal copies of the messenger   sector in the gauge mediated symmetry breaking model . \" ;   .... + this enables the user to get information for that option via a question mark operation like : ` ?",
    "2 .   add the option name and description of the new scenario to the usage instruction of the model variable : + .... model::usage= \" ... \" ....",
    "+ for example the additional line should look like : + .... \\\"mgmsb\\ \" ( gauge mediated symmetry breaking ) . .... 3 .",
    "add the definitions for the default option value symbols related to the new option value in the slam.config.m file .",
    "the names of the default option value symbols are just obtained from the option name itself by appending value .",
    "see for example the ` nmessvalue ` in tab .",
    "[ tab : defaultvalues ] .",
    "that way , the file slam.m will stay clean of any default numerical value definition and any user has a nice collection of the default numerical values in the config file .",
    "4 .   add the new options to the options of writespectrumgeneratorinput .",
    "for our ` nmess ` example the corresponding line , which would have to be added , looks like : + ....   nmess - > global`nmessvalue , .... 5 .   the most difficult part is to add the new scenario consistently to the subfunction writespectrumgeneratorinput .",
    "there are multiple ` switch ` instructions where the new code for the new scenario has to be added .",
    "this can be done by just following the given examples in the code itself .",
    "once having finished the modification of this function , one should check , after reloading the package , that the string written to the input slha file is correct when calling the new scenario . an easy way to do that is to call the modified function directly via : + .... slam`private`writespectrumgeneratorinput[model - > \" mgmsb \" , inputfilepath - > string ] .... + where one of course has to replace ` \" mgmsb \" ` by the option value of the new scenario . 6 .   in the final step",
    "the new scenario has to be added to the body of the sub function generateinputsqlchecklist .",
    "note that this works pretty much the same as in the previous step .",
    "+ in fact all numerical values entered directly _ have _ to be equal to those entered in the previous step !",
    "if this is not the case slam may not find anything in the data base although it already saved a requested spectrum .",
    "please note that one should apply the function ` stablenumber ` to real numbers in order to make them stable under the conversion from and to their ` fortran ` form .",
    "if a number is not stable under these conversions , very small rounding errors occur , which spoil the detection of matching spectra in the data base . +",
    "each numerical value follows an identification string in a list .",
    "this string can be built up from the position of the numerical value in a slha file as follows : conventionally the first letter is a `` ` i ` '' which indicates that the value is entering the input value part of the sql data base .",
    "since white spaces are not allowed in sql to be part of a column name , the separation to the following block name in capital letters is done by an underscore .",
    "after the block name the underscore separated key value follows as an integer .",
    "if it is a double key value , like used for matrix elements , there may be two integer numbers separated by one underscore .",
    "if there is no entry key at all , like it is the case for the output value of the mixing angle @xmath12 , which somehow got its own block , ` none ` replaces the usual integer number .",
    "one can check the adjustments by directly calling the function via : + ....   slam`private`generateinputsqlchecklist[model - > \" mgmsb \" ] .... + where ` \" mgmsb \" ` has to be replaced by the option value of the new scenario . the output should be just a list of pairs , where each pair is a list with an identification string as the first element and a numerical value as the second element .",
    "once the given steps have been completed , the new predefined scenario should work without any problems .",
    "we presented and published the package slam , which provides a convenient interface for slha spectrum generators in mathematica .",
    "the package enables the user to obtain spectrum data from generators in a fully automatic way .",
    "results of different spectrum generators can be compared without any effort and it allows the user to use his own notation in mathematica .",
    "slam comes with a large number of built - in benchmark scenarios .",
    "furthermore , it allows the user to freely define any desired scenario following the slha standard .",
    "moreover , it can store and recall all acquired data to and from a data base in order to avoid a recalculation of known spectra .",
    "storing spectra in a data base allows the examination of parameter spaces by simply using powerful data base functionalities .",
    "a parallel use of slam is possible and helps to reduce the time needed for possible parameter scans and builds of data bases .    besides the pure usage documentation including examples",
    ", we provided more details about the internal structure of the package which may help in case a modification of the program code is needed due to special user requirements .",
    "we would like to thank m.  iskrzynski and a.  kurz for beta testing the application , and j.  hoff , a.  kurz and m.  steinhauser for reading the manuscript .",
    "moreover we appreciate the fruitful time at the institut fr theoretische teilchenphysik at kit , where the core routines of slam have been implemented and runtime benchmarks could be performed on the local pc cluster . this work has been supported in part by the eu network lhcphenonet pitn - ga-2010 - 264564 , and by dfg sonderforschungsbereich transregio 9 , computergesttzte theoretische teilchenphysik .",
    "w.  porod , comput .",
    "commun .",
    "* 153 * ( 2003 ) 275 [ hep - ph/0301101 ] .",
    "b.  c.  allanach , comput .",
    "commun .",
    "* 143 * ( 2002 ) 305 [ arxiv : hep - ph/0104145 ] .",
    "d.  chowdhury , r.  garani and s.  kvempati , comput .",
    "commun .   * 184 * ( 2013 ) 899 [ arxiv:1109.3551 [ hep - ph ] ] .",
    "a.  djouadi , j.  -l .",
    "kneur and g.  moultaka , comput .",
    "commun .",
    "* 176 * ( 2007 ) 426 [ hep - ph/0211331 ] .",
    "z.  skands , b.  c.  allanach , h.  baer , c.  balazs , g.  belanger , f.  boudjema , a.  djouadi and r.  godbole _ et al .",
    "_ , jhep * 0407 * ( 2004 ) 036 [ hep - ph/0311123 ] . b.  c.  allanach , c.  balazs , g.  belanger , m.  bernhardt , f.  boudjema , d.  choudhury , k.  desch and u.  ellwanger _",
    "et al . _ ,",
    "commun .   * 180 * ( 2009 ) 8 [ arxiv:0801.0045 [ hep - ph ] ] . http://home.fnal.gov/@xmath15skands/slha/",
    "g.  belanger , n.  d.  christensen , a.  pukhov and a.  semenov , comput .",
    "commun .   * 182 * ( 2011 ) 763 [ arxiv:1008.0181 [ hep - ph ] ] . t.  hahn , hep - ph/0408283 .",
    "t.  hahn , comput .",
    "commun .",
    "* 180 * ( 2009 ) 1681 [ hep - ph/0605049 ] .",
    "p.  kant , r.  v.  harlander , l.  mihaila and m.  steinhauser , jhep * 1008 * ( 2010 ) 104 [ arxiv:1005.5709 [ hep - ph ] ] .",
    "a.  pak , m.  steinhauser and n.  zerf , arxiv:1208.1588 [ hep - ph ] .",
    "a.  kurz , m.  steinhauser and n.  zerf , arxiv:1206.6675 [ hep - ph ] .",
    "m.  s.  carena , s.  heinemeyer , c.  e.  m.  wagner and g.  weiglein , eur .",
    "j.  c * 26 * ( 2003 ) 601 [ hep - ph/0202167 ] .",
    "s.  s.  abdussalam , b.  c.  allanach , h.  k.  dreiner , j.  ellis , u.  ellwanger , j.  gunion , s.  heinemeyer and m.  kraemer _ et al .",
    "_ , eur .",
    "j.  c * 71 * ( 2011 ) 1835 [ arxiv:1109.3859 [ hep - ph ] ] ."
  ],
  "abstract_text": [
    "<S> we present and publish a mathematica package , which can be used to automatically obtain any numerical mssm input parameter from susy spectrum generators , which follow the slha standard , like spheno , softsusy , suseflav or suspect . </S>",
    "<S> the package enables a very comfortable way of numerical evaluations within the mssm using mathematica . </S>",
    "<S> it implements easy to use predefined high scale and low scale scenarios like msugra or @xmath0 and if needed enables the user to directly specify the input required by the spectrum generators . </S>",
    "<S> in addition it supports an automatic saving and loading of susy spectra to and from a sql data base , avoiding the rerun of a spectrum generator for a known spectrum . </S>"
  ]
}