{
  "article_text": [
    "graphical models have played a very important role in the recent history of error - correction coding ( ecc ) schemes for conventional channel and storage setups  @xcite . in particular ,",
    "some of the most powerful ecc schemes known today , like message - passing iterative ( mpi ) decoding of low - density parity - check ( ldpc ) and turbo codes , can be represented by graphical models .",
    "it is therefore highly desirable to extend the design and analysis lessons that have been learned from these ecc systems to quantum error - correction code ( qecc ) systems , in particular to stabilizer qecc systems .",
    "for background material and a history of stabilizer qeccs in particular , and quantum information processing ( qip ) in general , we refer to the excellent textbook by nielsen and chuang  @xcite .",
    "alternatively , one can consult some early papers on stabilizer qeccs , e.g.  @xcite , or more recent accounts , e.g.  @xcite .",
    "the aim of the present paper is to introduce a forney - style factor graph ( ffg ) framework that allows one to construct ffgs that represent interesting classes of stabilizer qeccs , more precisely , that represent interesting classes of stabilizer label codes and normalizer label codes .",
    "anyone familiar with the basics of stabilizer qeccs can then easily formulate the corresponding stabilizer qeccs .",
    "( note that due to space constraints this paper does not motivate stabilizer qeccs and does not define them .",
    "however , the paper does not use any qip jargon and should therefore be accessible to anyone familiar with the basics of coding theory . )",
    "this paper is structured as follows . in section  [ sec : ffgs:1 ] we introduce the basics on ffgs and in section  [ sec : dualizing : ffgs:1 ] we extend a well - known duality result for ffgs . in section  [ sec : stabilizer : and : normalizer : label : codes:1 ] we then show how this duality result can be used to construct stabilizer and normalizer label codes . afterwards , in section  [ sec : examples:1 ] we discuss several examples of such codes , in particular we show that our ffg framework unifies earlier proposed code constructions .",
    "we conclude by briefly commenting on message - passing iterative decoding and linear programming decoding in section  [ sec : mpi : and : lp : decoding:1 ] .",
    "because of space limitations we decided to formulate many of the concepts and results in terms of examples ; most of them can be suitably generalized .",
    "our notation is quite standard . in particular ,",
    "the field of real numbers will be denoted by @xmath0 and the ring of integers modulo @xmath1 by @xmath2 .",
    "( if @xmath1 is a prime , then @xmath2 is a field . ) the galois field @xmath3 will be based on the set @xmath4 , where @xmath5 satisfies @xmath6 ( and therefore also @xmath7 ) , and where conjugation is defined by @xmath8 .",
    "moreover , for any statement @xmath9 we will use iverson s convention which says that @xmath10 = 1 $ ] if @xmath9 is true and @xmath10 = 0 $ ] otherwise .",
    "ffgs  @xcite , also known as normal factor graphs , are graphs that represent multivariate functions .",
    "for example , let @xmath11 and @xmath12 , let @xmath13 , @xmath14 and @xmath15 , @xmath16 be some arbitrary alphabets , and consider the function @xmath17 that represents the mapping @xmath18 here , @xmath19 is called the global function and is the product of @xmath20 functions @xmath21 , @xmath22 ( here @xmath23 ) , which are called local functions .",
    "whereas the argument set of the function @xmath19 encompasses @xmath24 , @xmath25 , @xmath26 , @xmath27 , @xmath28 , @xmath29 , and @xmath30 , the function @xmath31 has only @xmath24 , @xmath28 , and @xmath30 as arguments , @xmath32 has only @xmath25 , @xmath28 , and @xmath29 as arguments , and @xmath33 has only @xmath26 , @xmath27 , @xmath29 , and @xmath30 as arguments .",
    "graphically , we represent this function decomposition as follows , cf .",
    "[ fig : simple : ffg:1 ]  ( left ) :    * for each local function we draw a function node ( vertex ) .",
    "* for each variable we draw an half - edge or an edge . *",
    "if a variable appears as an argument in only one local function then we draw an half - edge that is connected to that local function .",
    "if a variable appears as an argument in two local functions then we draw an edge that connects these two local functions .",
    "can be replaced by the essentially equivalent @xmath34 $ ] . with this , @xmath19 being `` essentially equivalent '' to @xmath35 means that whenever @xmath36 is nonzero then @xmath37 with @xmath38 . ]    in our example the variables that are associated with half - edges are labeled @xmath39 , @xmath14 , whereas the variables that are associated with edges are labeled @xmath40 , @xmath41 .",
    "this distinction of variable labels will be very helpful later on when we will dualize the global function .",
    "interesting are global functions where the local function argument sets are strict subsets of the global function argument set : the fewer arguments appear in the local functions , the sparser the corresponding ffg will be .",
    "consider again the ffg in figure  [ fig : simple : ffg:1 ]  ( left ) and let the local functions represent indicator functions , i.e. , @xmath42 , \\\\",
    "f_2(t_2 , m_1 , m_2 )      & { \\triangleq}\\big [           ( t_2 , m_1 , m_2 ) \\in { \\mathcal{c}}_2         \\big ] , \\\\    f_3(t_3 , t_4 , m_2 , m_3 )      & { \\triangleq}\\big [           ( t_3 , t_4 , m_2 , m_3 ) \\in { \\mathcal{c}}_3         \\big],\\end{aligned}\\ ] ] for some codes @xmath43 , @xmath44 , and @xmath45 . the restriction of the resulting global function to the variables @xmath46 , i.e. , to the variables that are associated with the half - edges , yields the function @xmath47 $ ] with @xmath48 clearly , if the sets @xmath13 , @xmath14 , and @xmath15 , @xmath41 , are groups and the codes @xmath49 , @xmath50 are group codes then @xmath51 is a group code .",
    "in the context of stabilizer qeccs , dual codes ( under the symplectic inner product ) play a very important role .",
    "the aim of this section is to start with an ffg that represents the indicator function of some code and to construct an ffg that represents the indicator function of the dual of that code . to that end",
    "we will heavily use insights from  ( * ? ? ?",
    "* section  vii ) on pontryagin duality theory in the context of ffgs , notably one of relatively few results that hold for graphical models _ without _ and _ with _ cycles .    for the rest of the paper",
    ", we make the following definitions .",
    "[ def : qsc : ring : def:1 ]    let @xmath1 be some prime .    for @xmath14 :",
    "* we define @xmath13 to be the group @xmath52 with vector addition modulo @xmath1 and we denote elements of @xmath13 by @xmath53 . * we let @xmath54 be the character group of @xmath13 . because @xmath54 turns out to be isomorphic to @xmath13",
    ", we identify @xmath54 with @xmath13 .",
    "elements of @xmath54 will be denoted by @xmath55 .",
    "* we define the inner product @xmath56 to be the symplectic inner product , i.e. , @xmath57 where @xmath58 represents vector transposition and where addition and multiplication are modulo @xmath1 .",
    "( note that we are using angular brackets to denote inner products .",
    "this is in contrast to  @xcite that used angular brackets to denote pairings , which are exponential functions of inner products . )    for @xmath41 :    * we let @xmath59 be some positive integer , we define @xmath15 to be the group @xmath60 with vector addition modulo @xmath1 , and we denote elements of @xmath15 by @xmath61 . * we let @xmath62 denote the character group of @xmath15 . again , because @xmath62 turns out to be isomorphic to @xmath15 , we identify @xmath62 with @xmath15 .",
    "elements of @xmath62 will be denoted by @xmath63 .",
    "* we define the inner product @xmath64 to be the symplectic inner product , i.e. , @xmath65    the above inner products induce inner products on vectors , e.g. , @xmath66 is the inner product defined by @xmath67 , etc ..    moreover , all codes are assumed to be group codes .    in the following , because of the natural isomorphism of the groups @xmath68 and @xmath69 , a vector @xmath70 will not only be written as @xmath71 but also as @xmath72 with this convention , the symplectic inner product of @xmath46 and @xmath73 can be written as @xmath74 or as @xmath75 where @xmath76 is the @xmath77 identity matrix .",
    "similar expressions will also be used for the vector @xmath78 and combinations of @xmath46 and @xmath78 .",
    "[ def : dual : code:1 ]    the dual code @xmath79 ( under the symplectic inner product ) of some group code @xmath80 is defined to be @xmath81    note that @xmath79 is also a group code and that @xmath82 .",
    "similarly , for any @xmath83 , because @xmath49 was assumed to be a group code , we can define its dual @xmath84 .    in the following ,",
    "we want to show that there is an ffg representing @xmath79 that is tightly related to the ffg that represents @xmath51 .",
    "continuing our example from section  [ sec : ffgs:1 ] , let @xmath85 for @xmath41 , and let @xmath86 be the function that represents the mapping @xmath87 \\ ,         \\big [ m'_2 { = } - m''_2 \\big ] \\ ,         \\big [ m'_3 { = } - m''_3 \\big]\\end{aligned}\\ ] ] with @xmath88 \\ ; , \\\\",
    "f^\\perp_2(t'_2 , m''_1 , m'_2 )      & { \\triangleq}\\big [           ( t'_2 , m''_1 , m'_2 ) \\in { \\mathcal{c}}^{{\\perp}}_2         \\big ] \\ ; , \\\\    f^\\perp_3(t'_3 , t'_4 , m''_2 , m'_3 )      & { \\triangleq}\\big [           ( t'_3 , t'_4 , m''_2 , m'_3 ) \\in { \\mathcal{c}}^{{\\perp}}_3         \\big ] \\ ; .\\end{aligned}\\ ] ] the function @xmath89 is depicted by the ffg in figure  [ fig : simple : ffg:1 ]  ( middle ) where the function nodes with a tilde in them represent the indicator functions @xmath90 $ ] , @xmath91 $ ] , and @xmath92 $ ] , respectively . with this",
    ", we can follow  @xcite and establish the next theorem .    [ th : code : duality:1 ]    with the above definitions , @xmath93    ( the proof is for the example code in figure  [ fig : simple : ffg:1 ] , but the proof can easily be generalized . )",
    "let @xmath94 be such that there exist @xmath95 and @xmath96 such that @xmath97 .",
    "moreover , let @xmath98 and let @xmath78 be such that @xmath99 .",
    "then , @xmath100 here , step @xmath101 follows from the fact that @xmath102 and @xmath103 imply that @xmath104 , with similar expressions for the other subcodes .",
    "we see that @xmath73 is orthogonal to @xmath46 , and because @xmath98 was arbitrary , @xmath73 must be in @xmath79 .    [",
    "ass : characteristic : two:1 ]    for the rest of the paper we will assume that @xmath105 , which implies that the groups @xmath13 , @xmath54 , @xmath14 , and the groups @xmath15 , @xmath62 , @xmath106 , @xmath41 , have characteristic @xmath107 . therefore , @xmath108 for all @xmath109 , @xmath41 , etc ..    so , given that we are only interested in arguments of @xmath89 that lead to non - zero function values , any valid configuration @xmath110 of the ffg in figure  [ fig : simple : ffg:1 ]  ( middle ) fulfills @xmath111 .",
    "this observation allows us to simplify the function @xmath89 to @xmath112 that represents the mapping @xmath113 with @xmath114 \\ ; , \\\\",
    "f^\\perp_2(t'_2 , m'_1 , m'_2 )      & { \\triangleq}\\big [           ( t'_2 , m'_1 , m'_2 ) \\in { \\mathcal{c}}^{{\\perp}}_2         \\big ] \\ ; , \\\\    f^\\perp_3(t'_3 , t'_4 , m'_2 , m'_3 )      & { \\triangleq}\\big [           ( t'_3 , t'_4 , m'_2 , m'_3 ) \\in { \\mathcal{c}}^{{\\perp}}_3         \\big ] \\ ; .\\end{aligned}\\ ] ] the new function @xmath89 is depicted by the ffg in figure  [ fig : simple : ffg:1 ]  ( right ) .",
    "it is clear that theorem  [ th : code : duality:1 ] simplifies to the following corollary .",
    "[ cor : code : duality:2 ]    with the above definitions and assumption  [ ass : characteristic : two:1 ] we have @xmath115    follows easily from theorem  [ th : code : duality:1 ] .",
    "we conclude this section with a definition that will be crucial for the remainder of this paper , namely self - orthogonality and self - duality ( under the symplectic inner product ) of a code .",
    "[ def : self : orthogonal : code:1 ]    let @xmath51 be a group code with dual code @xmath116 .",
    "then ,    * @xmath51 is called self - orthogonal if @xmath117 and * @xmath51 is called self - dual if @xmath118 .",
    "( note that a code @xmath51 is self - orthogonal if @xmath119 for all @xmath120 . )",
    "let @xmath51 be a code over @xmath121 that is self - orthogonal under the symplectic inner product . without going into the details of the stabilizer qecc framework",
    ", such a code @xmath51 can be used to construct a stabilizer qecc . in that context , the codes @xmath51 and @xmath116 are called , respectively , the stabilizer label code and the normalizer label code associated with that stabilizer qecc .    [ prop : ffg : self : orthogonal : code:1 ]    using the notation that has been introduced so far , in particular definition  [ def : qsc : ring : def:1 ] and assumption  [ ass : characteristic : two:1 ] , let @xmath122 be a group code whose indicator function is defined by an ffg containing half - edges @xmath39 , @xmath14 , full edges @xmath40 , @xmath41 , and function nodes @xmath21 , @xmath123 , where the latter are indicator functions of group codes @xmath49 , @xmath22 . then ,    * @xmath51 is self - orthogonal if all @xmath49 are self - orthogonal , and * @xmath51 is self - dual if all @xmath49 are self - dual .",
    "first we consider the case where all @xmath49 are self - orthogonal .",
    "the code @xmath51 can be represented by an ffg like the ffg in figure  [ fig : simple : ffg:1 ]  ( left ) .",
    "let @xmath46 be a codeword in @xmath51 and let @xmath78 be such that @xmath99 . because of definition  [ def : qsc : ring : def:1 ] , assumption  [ ass : characteristic : two:1 ] , and corollary  [ cor : code : duality:2 ] , its dual code @xmath79 can be represented by an ffg like the ffg in figure  [ fig : simple : ffg:1 ]  ( right ) .",
    "then , because the ffg in figure  [ fig : simple : ffg:1 ]  ( left ) is topologically equivalent to the ffg in figure  [ fig : simple : ffg:1 ]  ( right ) and because all @xmath49 are self - orthogonal , it follows that @xmath124 , which in turn yields @xmath125 .",
    "finally , because @xmath98 was arbitrary , we see that @xmath126 , i.e. , that @xmath51 is self - orthogonal .",
    "secondly , we consider the case where all @xmath49 are self - dual .",
    "similarly to the above argument , we can show that @xmath127 . reversing the roles of @xmath51 and @xmath79",
    ", we can also show that @xmath128 .",
    "this proves that @xmath118 , i.e. , that @xmath51 is self - dual .",
    "obviously , proposition  [ prop : ffg : self : orthogonal : code:1 ] gives us a simple tool to construct stabilizer label codes and normalizer label codes .",
    "it does not seem that duality results for ffgs , which are at the heart of proposition  [ prop : ffg : self : orthogonal : code:1 ] , have been leveraged before to construct stabilizer qeccs .",
    "css codes are a family of stabilizer qeccs named after calderbank , shor , and steane ( see e.g.  @xcite ) . for these codes",
    "we will not use our formalism , however , later on css codes can be used as component codes for longer codes .",
    "let @xmath129 and @xmath130 be two binary codes of length @xmath131 such that @xmath132 for all @xmath133 and @xmath134 . based on these two binary codes",
    ", we define the stabilizer label code @xmath135 it can easily be seen that the code @xmath51 is self - orthogonal .",
    "namely , for any @xmath136 we have @xmath137 , where @xmath138 follows from @xmath139 and @xmath140 , and where @xmath141 follows from @xmath142 and @xmath143 .",
    "[ ex : steane : code:1 ]    the so - called seven qubit steane stabilizer qecc ( see e.g.  @xcite ) is a css code where both @xmath144 and @xmath145 equal the @xmath146 $ ] binary simplex code , i.e. , the code given by the rowspan of the matrix @xmath147      let us associate with any vector @xmath148 the vector @xmath149 through the mapping was given at the end of section  [ sec : introduction:1 ] . ]",
    "@xmath150 clearly , the mapping @xmath151 is injective and surjective and therefore bijective , and so there is a bijective mapping between @xmath51 and @xmath152 , the latter being the image of @xmath51 under the mapping @xmath151 . because @xmath51 was assumed to be a group / additive code , @xmath153 is also a group / additive code .",
    "moreover , if for any codeword @xmath154 it holds that @xmath155 , then the code @xmath153 is a linear code , i.e. , not only is the sum of two codewords again a codeword , but any @xmath3-multiple of a codewords is also a codeword .",
    "if @xmath153 is a linear code then also @xmath156 is a linear code . with this",
    ", proposition  [ prop : ffg : self : orthogonal : code:1 ] can be suitably reformulated for sub - codes @xmath157 that are linear codes over @xmath3 , whereby one can show that the symplectic inner product can be replaced by the hermitian inner product  @xcite ; we leave the details to the reader .",
    "note that a necessary condition for the code @xmath153 to be linear is that @xmath158 is a power of @xmath159 , i.e. , that also @xmath160 is a power of @xmath159 .",
    "[ ex : steane : code:2 ]    the so - called five qubit stabilizer qecc ( see e.g. @xcite ) has a stabilizer label code @xmath153 that is the @xmath161-rowspan of @xmath162 it can easily be checked that @xmath153 is a linear code , which allows one to represent it as the @xmath3-rowspan of @xmath163",
    "in this section we show how proposition  [ prop : ffg : self : orthogonal : code:1 ] can be leveraged to construct stabilizer label codes , in particular how that proposition unifies several earlier proposed stabilizer label code constructions .",
    "( for more details about the discussed codes we refer to the corresponding papers . )",
    "[ ex : conv : stab : qecc:1 ]    * ( convolutional stab .",
    "qecc  ( * ? ? ?",
    "* example  1 ) ) * with the help of our ffg framework , the stabilizer label code of  ( * ? ? ?",
    "* example  1 ) can be seen to be given by the ffg in figure  [ fig : ffg : example : forney : grassl : guha:1 ] , where , using the notation from definition  [ def : qsc : ring : def:1 ] , @xmath164 for all @xmath165 . for all @xmath165 , the local function @xmath21 is given by @xmath166    \\end{aligned}\\ ] ] with @xmath49 such that @xmath157 is a linear code that is the @xmath3-rowspan of the matrix @xmath167 \\ ; .",
    "\\end{aligned}\\ ] ] ( in order to obtain a block code one needs to terminate the ffg in figure  [ fig : ffg : example : forney : grassl : guha:1 ] on both sides ; we omit the discussion of this issue .",
    "alternatively , tail - biting can be used . )",
    "[ ex : conv : stab : qecc:2 ]    * ( convolutional stab .",
    "qecc  ( * ? ? ?",
    "* example  3 ) ) * similarly , we can represent the stabilizer label code of  ( * ? ? ?",
    "* example  3 ) by the ffg in figure  [ fig : ffg : example : forney : grassl : guha:1 ] . here",
    ", however , we have @xmath168 for all @xmath165 , and @xmath49 is such that @xmath169 is a linear code given by the @xmath3-rowspan of @xmath170 \\ ; .",
    "\\end{aligned}\\ ] ] note that a `` more common '' choice for a matrix whose @xmath3-rowspan is the trellis section code of a non - recursive convolutional code would have been a matrix like @xmath171 \\ ; .",
    "\\end{aligned}\\ ] ] here the rows are such that the last @xmath172 components of @xmath173 equal the first @xmath172 components of @xmath174 . however , the @xmath3-span of such a matrix does not result in a self - orthogonal @xmath49 .    [",
    "ex : serial : turbo : stab : qecc:1 ]    * ( serial turbo stab .",
    "qecc  ( * ? ? ?",
    "* figure  10 ) ) * the paper  @xcite discusses constructions of serial turbo stabilizer label codes . in particular , figure  10 in  @xcite presents a code that corresponds to the ffg shown in figure  [ fig : ffg : example : poulin : tillich : ollivier:1 ]  ( left ) . here ,",
    "@xmath175 , @xmath176 , and @xmath177 represent , respectively , the indicator functions of the first convolutional code , of the quantum interleaver , and of the second convolutional code .",
    "if the indicator functions correspond to self - orthogonal codes then we can apply our ffg framework and guarantee that the overall code is self - orthogonal .",
    "this is indeed the case for the codes presented in  @xcite .",
    "a particular example of a stabilizer label code that can be used for the function node @xmath177 is given in  ( * ? ? ?",
    "* figures  8 and  9 ) and shown as an ffg in figure  [ fig : ffg : example : poulin : tillich : ollivier:1 ]  ( right ) .",
    "( in contrast to  ( * ? ?",
    "? * figures  8 and  9 ) , that uses the variable names @xmath178 and @xmath179 , we are using the variable names @xmath180 and @xmath181 , respectively . ) here , for all @xmath165 the indicator function @xmath21 corresponds to a code @xmath49 that is the rowspan of @xmath182 \\ ; ,    \\end{aligned}\\ ] ] where the columns correspond to @xmath183 , @xmath184 , @xmath185 , @xmath186 , @xmath187 , @xmath188 , @xmath189 , @xmath190 , @xmath191 , @xmath192 , respectively . note that @xmath49 is self - dual under the symplectic inner product and that the corresponding @xmath3-code @xmath157 is additive but not linear .",
    "( it can not be linear since the number of codewords is @xmath193 , which is not a power of @xmath159 . )",
    "[ ex : stab : state:1 ]    * ( stabilizer state  ( * ? ? ?",
    "* example  1 ) ) * roughly speaking , a stabilizer state corresponds to a stabilizer qecc whose stabilizer label code is self - dual , see @xcite .",
    "let @xmath194 be the @xmath77 adjacency matrix of any graph with @xmath131 vertices and let @xmath51 be the rowspan of @xmath195 $ ] , where the columns correspond to @xmath196 , @xmath197 , and where @xmath76 is the @xmath77 identity matrix .",
    "it can easily be checked that @xmath51 is self - dual under the symplectic inner product .",
    "( note that @xmath198 because @xmath194 is the adjacency matrix of a graph . )    for example , the graph in figure  [ fig : ffg : example : vandennest : dehaene : demoor:1 ]  ( left ) results in a stabilizer label code @xmath51 which is the rowspan of @xmath199 \\ ; .",
    "\\end{aligned}\\ ] ]    it turns out that any such stabilizer label code can also be represented by an ffg that is topographically closely related to the graph that defined the code .",
    "e.g. , figure  [ fig : ffg : example : vandennest : dehaene : demoor:1 ]  ( right ) shows the ffg that corresponds to the example graph in figure  [ fig : ffg : example : vandennest : dehaene : demoor:1 ]  ( left ) . here ,",
    "@xmath31 is the indicator function of the self - dual code @xmath200 which is defined to be the rowspan of @xmath201 \\ ; ,    \\end{aligned}\\ ] ] where the columns correspond to @xmath202 , @xmath203 , @xmath204 , @xmath205 , @xmath206 , @xmath207 , @xmath208 , @xmath209 , @xmath210 , @xmath211 , respectively .",
    "moreover , @xmath212 is the indicator function of the self - dual code @xmath213 which is defined to be the rowspan of @xmath214 $ ] , where the columns correspond to @xmath203 , @xmath215 , @xmath208 , @xmath216 , respectively .",
    "the other indicator functions @xmath21 and @xmath217 and self - dual codes @xmath49 and @xmath218 are defined analogously .",
    "note that the code @xmath49 depends on the number of vertices that are adjacent to vertex @xmath165 .",
    "however , the code @xmath218 is always the same for any pair @xmath219 of adjacent vertices .    [ ex : pg : code:1 ]    * ( ldpc codes ) *",
    "any ldpc code whose parity - check matrix contains orthogonal rows can be used to construct a normalizer label code @xmath116 , see e.g.  @xcite and references therein . in terms of ffgs ,",
    "such ldpc codes are expressed with the help of equal and single - parity - check function nodes .",
    "the ffg of the corresponding stabilizer label code @xmath51 can also be expressed in terms of equal and single - parity - check function nodes . because single - parity - checks of length not equal to @xmath107 do _ not _ represent self - orthogonal codes ,",
    "our ffg framework is not directly applicable to construct ffgs of such ldpc codes .",
    "however , with the help of some auxiliary code constructions , our framework can also be used to construct ldpc stabilizer / normalizer label codes ; because of space constraints we do not give the details here .",
    "we leave it as an open problem to use our ffg framework to construct other classes of stabilizer label codes that have interesting properties .",
    "one of the main interests in studying ffgs for stabilizer label codes and their duals is that one would like to have ffgs that are suitable for mpi decoding .",
    "( note that the code that is relevant for decoding in the stabilizer qecc framework is the code @xmath116 , or the coset code @xmath220 , see e.g.  the comments in  @xcite . )",
    "the well - known trade - offs from classical ldpc and turbo codes apply also here : good codes with low ffg variable and function node complexity must have cycles , yet cycles lead to sub - optimal performance of message - passing iterative decoders .",
    "we leave it as an open problem to study stopping sets , trapping sets , absorbing sets , near - codewords , pseudo - codewords , the fundamental polytope , etc .",
    "( see e.g.the refs .  at @xcite ) for the codes that were discussed in this paper .",
    "moreover , one can formulate alternative decoders to mpi decoders like linear programming ( lp ) decoding .",
    "it would be interesting to see if the self - orthogonality property of stabilizer label codes leads to further insights in the context of mpi and lp decoders , in particular by also leveraging other duality results for ffgs like fourier duality  @xcite and lagrange duality  @xcite .",
    "o. vontobel and h .- a .",
    "loeliger , `` on factor graphs and electrical networks , '' in _ mathematical systems theory in biology , communication , computation , and finance , i m a volumes in math .  & appl .",
    "_ , d.  gilliam and j.  rosenthal , eds.1em plus 0.5em minus 0.4emspringer verlag , 2003 ."
  ],
  "abstract_text": [
    "<S> quantum error - correction codes ( qeccs ) are a vital ingredient of quantum computation and communication systems . in that context </S>",
    "<S> it is highly desirable to design qeccs that can be represented by graphical models which possess a structure that enables efficient and close - to - optimal iterative decoding .    in this paper </S>",
    "<S> we focus on stabilizer qeccs , a class of qeccs whose construction is rendered non - trivial by the fact that the stabilizer label code , a code that is associated with a stabilizer qecc , has to satisfy a certain self - orthogonality condition . in order to design graphical models of stabilizer label codes that satisfy this condition , we extend a duality result for forney - style factor graphs ( ffgs ) to the stabilizer label code framework . </S>",
    "<S> this allows us to formulate a simple ffg design rule for constructing stabilizer label codes , a design rule that unifies several earlier stabilizer label code constructions . </S>"
  ]
}