{
  "article_text": [
    "programming autonomous agents that behave intelligently is one of the key challenges of artificial intelligence . because of its declarative nature , and high level of abstraction , logic programming is a natural choice for this task",
    "this is witnessed by e.g.  the two major exponents of agent programming languages that are based on classical logic programming , namely golog @xcite and flux @xcite .",
    "both these languages combine a language for specifying the agent s behaviour with an axiomatic theory that describes the agent s environment . in the case of golog",
    "the strategy language is procedural in nature ( though implemented in prolog ) , and the action theory is the classical situation calculus @xcite in reiter s version @xcite . for flux the strategy language is full classical logic programming , and the action theory is the more recent fluent calculus @xcite .    in a recent work",
    "@xcite we have developed agent logic programs ( alps ) , a new declarative strategy language that is based upon a proof calculus in the style of classical sld - resolution .",
    "contrary to golog and flux the alp framework is parametric in the action theory : any background theory that allows to infer when an action is applicable , and what the effects of the action are , can be used . exploiting this generality",
    "we have recently @xcite been able to give a semantics for the bdi - style language agentspeak @xcite .",
    "another distinctive feature of the theoretical framework is the elegant handling of incomplete information for offline planning via _ disjunctive substitutions_. by default , alps are combined with our new unifying action calculus ( uac ) @xcite that encompasses the major logical action calculi , including both the situation calculus and the fluent calculus , as well as many planning domain description languages .",
    "the alp formalism stays entirely within classical logic .",
    "the implementation of any fragment of the alpprolog framework consists of ( 1 ) an implementation of the proof calculus , and ( 2 ) an action theory reasoner .",
    "existing mature prolog technology can be used out of the box for ( 1 ) unless disjunctive substitutions enter the picture . for ( 2 )",
    "we can also exploit existing technology : e.g.  golog implements a fragment of the situation calculus , and flux handles a fragment of the fluent calculus . in @xcite",
    "the implementation of a description logic - based fragment of the fluent calculus is described .    in this work we present alpprolog , where the underlying action theory is an essentially propositional version of the fluent calculus in the uac that includes a simple , yet powerful model of sensing .",
    "alpprolog is intended for the online control of agents , where actions are immediately executed .",
    "this starkly contrasts with offline reasoning , where agents may make assumptions to see where these are leading .",
    "alpprolog was developed specifically for the efficient handling of large ground state representations , something that we consider to be practically useful . to this end alpprolog",
    "combines strong - points of golog and flux :    * from golog it takes the representation of the agent s state knowledge in full propositional logic via prime implicates ; and * from flux it takes the principle of progression : the agent s state knowledge is updated upon the execution of an action . in standard golog the agent s initial state knowledge is never updated .",
    "instead , queries referring to later time - points are rewritten until they can be evaluated against the initial state knowledge , something which becomes a hindrance to good performance as the sequence of executed actions grows .",
    "we emphasise that alpprolog is an agent programming language in the spirit of classical logic programming in prolog : the straightforward operational semantics provides the programmer with a powerful means to actively determine the sequence of actions that an agent executes .",
    "alpprolog can be obtained at alpprolog.sourceforge.net .",
    "the remainder of this paper is organised as follows : in section  [ sec : alp ] we recall the basics of the alp framework , and in section  [ sec : alpprolog ] we introduce alpprolog .",
    "we evaluate the performance of alpprolog in section  [ sec : eval ] , and conclude in section  [ sec : conc ] .",
    "the purpose of agent logic programs is to provide high - level control programs for agents using a combination of declarative programming with reasoning about actions .",
    "the syntax of these programs is kept very simple : standard ( definite ) logic programs ( see e.g.  @xcite ) are augmented with just two special predicates , one  written ` do(`@xmath0 ` ) `  to denote the execution of an action by the agent , and one  written ` ? ( ` @xmath1 ` ) `  to verify properties against ( the agent s model of ) the state of its environment .",
    "this model , and how it is affected by actions , is defined in a separate action theory .",
    "this allows for a clear separation between the agent s strategic behaviour ( given by the agent logic program itself ) and the underlying theory about the agent s actions and their effects .",
    "prior to giving the formal definition , let us illustrate the idea by an example agent logic program .",
    "[ ex : alp ] consider an agent whose task is to find gold in a maze .",
    "for the sake of simplicity , the states of the environment shall be described by a single _ fluent _",
    "( i.e. , state property ) : @xmath2 to denote that  @xmath3 is at location  @xmath4",
    ". the agent can perform the action @xmath5 of going to location  @xmath6 , which is possible if  @xmath6 is adjacent to the current location of the agent .",
    "the following alp describes a simple search strategy via a given list of locations ( choice points ) that the agent may visit , and an ordered collection of backtracking points .",
    "we follow the prolog convention of writing variables with a leading uppercase letter .    ....",
    "explore(choicepoints , backtrack ) : -          % finished , if      ?",
    "( at(agent , x ) ) , ?",
    "( at(gold , x ) ) .",
    "% gold is found     explore(choicepoints , backtrack ) : -                 ?",
    "( at(agent , x ) ) ,      select(y , choicepoints , newchoicepoints ) , % choose a direction      do(go(y ) ) ,                               % go in this direction      explore(newchoicepoints,[x|backtrack ] ) .",
    "% store the choice     explore(choicepoints,[x|backtrack ] ) : -      % go back one step      do(go(x ) ) ,      explore(choicepoints , backtrack ) .",
    "select(x,[x|xs],xs ) .",
    "select(x,[y|xs],[y|ys ] ) : - select(x , xs , ys ) .",
    "....    suppose we are given a list of choice points ` c ` , then the query ` : - explore(c , [ ] ) ` lets the agent systematically search for gold from its current location : the first clause describes the base case where the agent is successful ; the second clause lets the agent select a new location from the list of choice points and go to this location ( the declarative semantics and proof theory for ` do(`@xmath0 ` ) ` will require that the action is possible at the time of execution ) ; and the third clause sends the agent back using the latest backtracking point .",
    "the example illustrates two distinct features of alps : ( 1 ) the agent strategy is defined by a logic program that may use arbitrary function and predicate symbols in addition to the signature of the underlying action theory .",
    "( 2 ) the update of the agent s belief according to the effects of its actions is not part of the strategy .",
    "formally , alps are defined as follows .",
    "consider an action theory signature @xmath7 that includes the pre - defined sorts and , along with a logic program signature  @xmath8 .",
    "_ terms _ are from @xmath9 .",
    "if ` p ` is an @xmath10-ary relation symbol from @xmath11 and t@xmath12t@xmath13 are terms , then p(t@xmath12t@xmath14 is a _",
    "program atom_.    ` do(`@xmath0 ` ) ` is a _ program atom _ if @xmath15 is an term in  @xmath16 .    ` ? ( ` @xmath1 ` ) ` is a _ program atom _ if @xmath17 is a _ state property _ in  @xmath16 , that is , a formula ( represented as a term ) based on the s in  @xmath16 .",
    "clauses , programs , and queries are then defined as usual for definite logic programs , with the restriction that the two special atoms can not occur in the head of a clause .",
    "the semantics of an alp is given in two steps .",
    "first , the program needs to be `` temporalised , '' making explicit the state change that is implicit in the use of the two special predicates , ` do(`@xmath0 ` ) ` and ` ? ( ` @xmath1 ` ) ` .",
    "second , the resulting program is combined with an action theory as the basis for evaluating these two special predicates .",
    "the semantics is then the classical logical semantics of the expanded program together with the action theory .",
    "time is incorporated into a program through macro - expansion : two arguments of sort are added to every regular program atom  @xmath18 , and then @xmath19 is understood as restricting the truth of the atom to the temporal interval between ( and including ) @xmath20 and @xmath21 .",
    "the two special atoms receive special treatment : ` ? ( ` @xmath1 ` ) ` is re - written to @xmath22 , with the intended meaning that  @xmath17 is true at  @xmath23 ; and ` do(`@xmath0 ` ) ` is mapped onto @xmath24 , meaning that action  @xmath15 can be executed at  @xmath20 and that its execution ends in  @xmath21 .",
    "the formal definition is as follows .",
    "[ d : expansion ] for a clause h :-",
    ",b@xmath13 ( @xmath26 ) , let @xmath27 be variables of sort .    for @xmath28 , if b@xmath29 is of the form    p(t@xmath25, ...",
    ",t@xmath30 ) , expand to @xmath31 .",
    "do(@xmath0 ) , expand to @xmath32 .    ?",
    "( @xmath1 ) , expand to @xmath33 .",
    "the head atom h = p(t@xmath25, ... ,t@xmath30 ) is expanded to @xmath34 .",
    "the resulting clauses are understood as universally quantified implications .",
    "queries are expanded exactly like clause bodies , except that    a special constant @xmath35  denoting the earliest time - point in the underlying action theory  takes the place of @xmath20 ;    the resulting conjunction is existentially quantified .",
    "the example program of the preceding section is understood as the following axioms , which for notational convenience we have simplified in that all equations between time variables have been applied and then omitted .",
    "@xmath36,s_3,s_4 ) \\\\    ( \\forall){\\mbox{\\em explore\\/}}(c,[x|b],s_1,s_3 ) & { \\subset } & { \\ensuremath{\\text{\\em poss}}}({\\mbox{\\em go\\/}}(x),s_1,s_2)\\wedge { \\mbox{\\em explore\\/}}(c , b , s_2,s_3 ) \\\\    \\multicolumn{3}{l}{(\\forall){\\mbox{\\em select\\/}}(x,[x|x'],x',s_1,s_1){\\subset}{\\mbox{\\em true\\/ } } } \\\\    \\multicolumn{3}{l}{(\\forall){\\mbox{\\em select\\/}}(x,[y|x'],[y|y'],s_1,s_2){\\subset}{\\mbox{\\em select\\/}}(x , x',y',s_1,s_2 ) } \\end{array}\\ ] ] the resulting theory constitutes a purely logical axiomatisation of the agent s strategy , which provides the basis for logical entailment .",
    "for instance , macro - expanding the query ` : - explore(c , [ ] ) ` from the above example results in the temporalised logical formula @xmath37,s_0,s)$ ] .",
    "if this formula follows from the axioms above , then that means that the strategy can be successfully executed , starting at  @xmath35 , for the given list of choice points  @xmath38 .",
    "whether this is actually the case of course depends on the additional action theory that is needed to evaluate the special atoms @xmath39 and @xmath40 in a macro - expanded program .",
    "macro - expansion provides the first part of the declarative semantics of an agent logic program ; the second part is given by an action theory in form of a logical axiomatisation of actions and their effects .",
    "the overall declarative semantics of agent logic programs is given by the axiomatisation consisting of the action theory and the expanded program .",
    "let us next introduce the fragment of the uac corresponding to the fluent calculus .",
    "the uac that is used to axiomatise the action theory is based on many - sorted first order logic with equality and the four sorts , , , and . by convention variable symbols",
    "@xmath23 , @xmath41 , @xmath42 , and @xmath43 are used for terms of sort , , , and , respectively .",
    "fluents are reified , and the standard predicate @xmath44 indicates whether a fluent is true at a particular time .",
    "the predicate @xmath45 means that action  @xmath15 can be executed at  @xmath20 and that its execution ends in  @xmath46 .",
    "the number of function symbols into sorts and is finite .",
    "[ def : uac ] we stipulate that the following formula types are used by action theories :    * state formulas express what is true at particular times : a _ state formula @xmath47 $ ] in  @xmath48 _ is a first - order formula with free variables @xmath48 where * * for each occurrence of @xmath49 we have @xmath50 ; * * predicate @xmath40 does not occur .",
    "+ a state formula is _ pure _ if it does not mention predicates other than @xmath39 .",
    "* a _ state property _",
    "@xmath51 is an expression built from the standard logical connectives and terms @xmath52 of sort . with a slight abuse of notation , by @xmath53",
    "we denote the state formula obtained from state property @xmath51 by replacing every occurrence of a fluent @xmath54 by @xmath49 . in an expanded program @xmath55 we always treat @xmath53 as atomic .",
    "state properties are used by agent logic programs in ` ? ( phi ) ` atoms . *",
    "the _ initial state axiom _ is a state formula @xmath56 in @xmath35 , where @xmath35 denotes the initial situation . *",
    "an _ action precondition axiom _ is of the form @xmath57 \\land s_2 = { \\ensuremath{\\text{\\em do}}}(a({\\bar{x}}),s_1),\\ ] ] where @xmath58 $ ] is a state formula in  @xmath20 with free variables among @xmath59 .",
    "this axiom illustrates how different actions lead to different situation terms @xmath60 .",
    "situations constitute the sort time in the fluent calculus and provide a branching time structure . * _ effect axioms _ are of the form + & @xmath61(a(x),s_1,s_2 ) + & _ k ( y_k)(_k[s_1](f)[(_i f = f_ki(@xmath62(f , s_1)_j fg_kj ) ) + & @xmath62(f , s_2 ) ] ) .",
    "+ such an effect axiom has @xmath63 different cases that can apply  these are identified by the case selection formulas @xmath64 $ ] which are state formulas in  @xmath20 with free variables among @xmath65 . the @xmath66 ( and @xmath67 ,",
    "respectively ) are fluent terms with variables among @xmath68 and describe the positive ( or , respectively , negative ) effects of the action , given that case @xmath63 applies . *",
    "_ domain constraints _ are universally quantified state formulas @xmath69 $ ] in  @xmath70 . *",
    "_ auxiliary axioms _ are domain - dependent , but time - independent , additional axioms such as e.g.  an axiomatisation of finite domain constraints .",
    "an action theory @xmath71  is given by an initial state axiom @xmath72 , finite sets @xmath73 and @xmath74 of precondition and effect axioms .",
    "moreover domain constraints @xmath75 and auxiliary axioms @xmath76 may be included . for illustration ,",
    "the following is a background axiomatisation for our example scenario as a basic fluent calculus theory in the uac .",
    "our example program can be supported by the following domain theory .",
    "initial state axiom @xmath77    precondition axiom @xmath78    effect axiom    & @xmath61((y),s_1,s_2 ) + & ( x ) ( @xmath62((,x),s_1 )   + & ) .    given this ( admittedly very simple , for the sake of illustration ) specification of the background action theory , the axiomatisation of the agent s strategy from above entails , for example , @xmath79,[\\,],s_0,s)$ ] .",
    "this can be shown as follows .",
    "first , observe that the background theory entails @xmath80 where @xmath81 denotes the situation term @xmath82 .",
    "it follows that @xmath83,[3,2,1],s , s)$ ] according to the first clause of our example alp .",
    "consider , now , the situation @xmath84 , then action theory and strategy together imply @xmath85,[5],s',s')\\wedge { \\ensuremath{\\text{\\em poss}}}({\\mbox{\\em go\\/}}(4),s',s)\\ ] ] by using this in turn , along with @xmath83,[3,2,1],s , s)$ ] from above , according to the second program clause we obtain @xmath86,[2,1],s',s)$ ] .",
    "continuing this line of reasoning , it can be shown that @xmath87,[1],{\\ensuremath{\\text{\\em do}}}({\\mbox{\\em go\\/}}(2),s_0),s ) \\\\",
    "\\mbox{and hence , } & { \\mbox{\\em explore\\/}}([2,3,4,5],[\\,],s_0,s ) \\end{array}\\ ] ] this proves the claim that @xmath79,[\\,],s_0,s)$ ] . on the other hand e.g.  the query @xmath88,[\\,],s_0,s)$ ] is _ not _ entailed under the given background theory : without location  @xmath89 among the choice points , the strategy does not allow the agent to reach the only location that is known to house gold .",
    "we have developed two sound and complete proof calculi for alps that both assume the existence of a suitable reasoner for the underlying action theory @xcite .",
    "the first proof calculus is plain sld - resolution , only that @xmath62- and @xmath61-atoms are evaluated against the action theory .",
    "this calculus is sound and complete if the underlying action theory has the witness property : that is , whenever @xmath90 then there is a substitution @xmath91 such that @xmath92 . note that in general action theories may violate the witness property , as they may include disjunctive or purely existential information ; consider e.g.  the case @xmath93 , where the exact location of the gold is unknown .",
    "hence the second proof calculus , intended for the general case , resorts to constraint logic programming , and the notion of a disjunctive substitution : still assuming that the gold is located at one of two locations the query @xmath94 can now be answered positively via the disjunctive substitution @xmath95 .",
    "disjunctive substitution together with the respective principle of reasoning by cases are a powerful means for inferring conditional plans .    for the online control of agents , however , assuming a particular case is unsafe .",
    "but if we use the plain sld - resolution - based alp proof calculus on top of action theories that lack the witness property we obtain a nice characterisation of cautious behaviour in a world of unknowns ( albeit at the cost of sacrificing logical completeness ) . for alpprolog",
    "this is the setting that we use .    in both proof calculi",
    "we adopt the `` leftmost '' computation rule familiar from prolog .",
    "this has many advantages : first , it simplifies the implementation , as this can be based on existing mature prolog technology .",
    "second , state properties can always be evaluated against a description of the `` current '' state .",
    "last , but not least , this ensures that actions are executed in the order intended by the programmer  this is of no small importance for the online control of agents .",
    "we next present alpprolog  an implementation of the alp framework atop of action theories in a version of the fluent calculus that    * uses ( a notational variant of ) propositional logic for describing state properties ; * is restricted to actions with ground deterministic effects ; and * includes sensing actions .",
    "the intended application domain for alpprolog is the online control of agents in dynamic domains with incomplete information .",
    "an alpprolog program is an alp that respects the following restrictions on the ` ? ( phi ) ` atoms in the program :    * all occurrences of non - fluent expressions in @xmath51 are positive .",
    "* so called sense fluents @xmath96 that represent the interface to a sensor may only occur in the form ` ? ( s(x ) ) ` .",
    "sense fluents are formally introduced below .",
    "because alpprolog programs are meant for online execution the programmer must ensure that no backtracking over action executions occurs , by inserting cuts after all action occurrences .",
    "observe that this applies to sensing actions , too .",
    "it is readily checked that  after the insertion of cuts  the alp from example  [ ex : alp ] satisfies all of the above conditions .      in this section",
    "we introduce the announced propositional fragment of the fluent calculus .",
    "the discussion of sensing is deferred until section  [ ssec : sens ] .",
    "for ease of modelling we admit finitely many ground terms for fluents and objects , instead of working directly with propositional letters .",
    "an action domain @xmath71  is then made propositional by including the respective domain closure axioms .",
    "for actions , objects , and fluents unique name axioms are included  hence we can avoid equality reasoning .",
    "the basic building block of both the propositional fluent calculus and alpprolog are the so - called prime implicates of a state formula @xmath97 :    a clause @xmath98 is a _ prime implicate _ of @xmath51 iff it is entailed by @xmath99 , is not a tautology , and is not entailed by another prime implicate .",
    "the prime implicates of a formula are free from redundancy  all tautologies and implied clauses have been deleted . for any state formula",
    "an equivalent _ prime state formula _ can be obtained by first transforming the state formula into a set of clauses , and by then closing this set under resolution , and the deletion of subsumed clauses and tautologies .",
    "prime state formulas have the following nice property : let @xmath51 be a prime state formula , and let @xmath98 be some clause ( not mentioning auxiliary predicates ) ; then @xmath98 is entailed by @xmath51 if and only if it is subsumed by some prime implicate in @xmath51 , a fact that has already been exploited for golog @xcite .",
    "this property will allow us to reduce reasoning about state knowledge in alpprolog to simple list look - up operations .",
    "formally the propositional version of the fluent calculus is defined as follows .",
    "we stipulate that the following properties hold in propositional fluent calculus domains :    * the initial state @xmath100  is specified by a ground prime state formula .",
    "* the state formulas @xmath101 in action preconditions @xmath102 are prime state formulas . *",
    "the effect axioms are of the form + & @xmath61(a(x),s_1,s_2 ) + & _ k ( _ k[s_1](f)[(_i f = f_ki(@xmath62(f , s_1)_j fg_kj ) ) + & @xmath62(f , s_2 ) ] ) , + where each @xmath64 $ ] is a prime state formula .",
    "this implies that existentially quantified variables that may occur in case selection formulas ( cf .  definition  [ def : uac ] ) have been eliminated by introducing additional cases .",
    "* only so - called _ modular _ domain constraints @xcite may be included . very roughly",
    ", domain constraints are modular if they can be compiled into the agent s initial state knowledge , and the effect axioms ensure that updated states also respect the domain constraints . in the fluent calculus this holds if the following two conditions are met @xcite : condition  ( [ e : i1 ] ) , says that for a state that is consistent with the domain constraints and in which an action  @xmath103 is applicable , the condition  @xmath104 $ ] for at least one case  @xmath105 in the effect axiom for  @xmath106 holds",
    ". condition ( [ e : i2 ] ) requires that any possible update leads to a state that satisfies the domain constraints .",
    "formally , let @xmath107 be constants of sort  .",
    "@xmath75 the domain constraints , @xmath73 the precondition axioms , and @xmath74 the effect axioms . the following must hold for every action @xmath103 : there exists @xmath108 such that @xmath109\\wedge\\pi_a[s]\\wedge(\\exists\\vec y_i)\\phi_i[s],\\ ] ] and for every such @xmath105 , @xmath110\\wedge\\pi_a[s]\\wedge{\\ensuremath{\\upsilon}}_i[s , t]{\\supset}{\\ensuremath{{\\ensuremath{{\\cal d}}}_{\\text{dc}}}}[t].\\ ] ] non - modular , fully general domain constraints greatly complicate reasoning . *",
    "auxiliary time - independent axioms may be included if they can faithfully be represented in the prolog dialect underlying the implementation .",
    "this deliberately sloppy condition is intended to allow the programmer to use her favourite prolog library .",
    "however , we stipulate that auxiliary predicates occur only positively outside of @xmath111  in the action domain @xmath71 in order to ensure that they can safely be evaluated by prolog",
    ". they also must not occur in the initial state formula at all .",
    "the update mechanism underlying alpprolog can handle only ground effects .",
    "hence , if auxiliary atoms are used in action preconditions , case selection formulas of effect axioms , then it is the burden of the programmer to ensure that these predicates always evaluate to ground terms on those variables that also occur in the action s effects .    on the one hand clearly",
    "every propositional fluent calculus domain can be transformed to this form . on the other hand",
    "it is well known that in general compiling away the quantifiers in a state formula can result in an exponential blow - up , as can the conversion to conjunctive normal form .",
    "we believe that the simplicity of reasoning with prime implicates outweighs this drawback .",
    "propositional action domains can still be non - deterministic .",
    "for example , for an applicable action two different cases may be applicable at the same time .",
    "the resulting state would then be determined only by the disjunction of the cases effects .",
    "what is more , it would be logically unsound to consider only the effects of one of the cases .",
    "for the online control of agents in alpprolog we stipulate that for an applicable action at most a single case applies , greatly simplifying the update of the agent s state knowledge .",
    "[ def : fcp ] a propositional fluent calculus domain is deterministic if the following holds : let @xmath43 be an applicable ground action",
    ". then there is at most one case of the action that is applicable in the given state .",
    "for example , an action theory is deterministic if for each effect axiom all the cases are mutually exclusive .",
    "next assume we have an applicable deterministic action with e.g.  two case selection formulas @xmath97 and @xmath112 , where neither case is implied by the current state . here , instead of updating the current state with the disjunction of the respective effects",
    ", alpprolog will employ incomplete reasoning .",
    "we make the following assumptions concerning sensing : at any one time , a sensor may only return a single value from a fixed set @xmath113 of ground terms , the _ sensing results_. however , the meaning of such a sensing result may depend upon the concrete situation of the agent .",
    "assume that now one of the cells in the maze contains a deadly threat to our gold - hunting agent .",
    "if the agent is next to a cell containing the threat she perceives a certain smell , otherwise she does nt : she can sense whether one of the neighbouring cells is unsafe ; but the actual neighbouring cells are only determined by the agent s current location .",
    "[ def : sens ] a sense fluent @xmath114 is a unary fluent that serves as interface to the sensor .",
    "we assume the sort to be a subsort of sort .",
    "a sensor axiom then is of the form @xmath115 for a ground set of sensing results @xmath113 . here",
    "@xmath116 is a prime state formula that selects a meaning of the sensing result @xmath117 , whereas the pure prime state formula @xmath118 describes the selected meaning .",
    "we stipulate that sensor axioms ( which are a form of domain constraint ) may only be included if they are modular .",
    "clearly @xmath116 should be chosen so as to be uniquely determined in each state . if auxiliary axioms are used in @xmath116 then again the programmer must ensure that these evaluate to ground terms in order that a ground state representation can be maintained .",
    "the following is the sensor axiom for our gold - hunter : @xmath119    theoretically , the combination of sensing with the online control of an agent is quite challenging : it is logically sound to to consider the disjunction of all possible sensing results for offline reasoning . in the online setting ,",
    "however , upon the observation of a sensing result we henceforth have to accept this result as being true ; that is , at runtime we _ add _ the result to the action theory , something which is logically unsound .",
    "on the other hand , it also does not make sense to stipulate that the sensing result be known beforehand .",
    "we continue by describing how the underlying action theory is represented in alpprolog . as basic building block",
    "we need a representation for prime state formulas . for notational convenience",
    "we will represent @xmath120 literals by the ( possibly negated ) fluent terms only , and , by an abuse of terminology , we will call such a term @xmath121 a fluent literal .",
    "a convenient prolog representation for such a state formula is a list , where each element is either a literal ( i.e.  a unit clause ) or a list of at least two literals ( a non - unit clause ) . in the following we call such a list a pi - list .",
    "action theories as defined in definition  [ def : fcp ] are represented in alpprolog as follows :    * the initial state is specified by a prolog fact `",
    "initial_state(pi - list ) . ` , where ` pi - list ` mentions only ground fluent literals .",
    "domain constraints other than sensor axioms have to be compiled into ` pi - list ` . * a prolog fact ` action(a , precond , effax ) . ` , for each action @xmath43 , has to be included , where * * ` a ` is an action function symbol , possibly with object terms as arguments ; * * ` precond ` is a pi - list , the action s precondition ; * * ` effax ` is a list of cases for the action s effects with each case being a pair ` cond - eff ` , where the effect s condition ` cond ` is a pi - list , and the effects ` eff ` are a list of fluent literals ; and * * all variables in ` effax ` also occur in ` precond ` . *",
    "if present , auxiliary axioms @xmath111  are represented by a set of prolog clauses .",
    "the predicates defined in the auxiliary axioms must be declared explicitly by a fact ` aux(aux ) . ` , where ` aux ` denotes the listing of the respective predicate symbols .",
    "the sensor axioms are represented as prolog facts ` sensor_axiom(s(x),vals ) . ` , where    * ` s ` is a sense fluent with object argument ` x ` ; and * ` vals ` is a list of ` val - index - meaning ` triples , where * * ` val ` is a pair ` x - result_i ` , where ` result_i ` is the observed sensing result ; * * ` index ` is a pi - list consisting of unit clauses ; and * * ` meaning ` is a pi - list , mentioning only fluent literals and only variables from ` val ` and ` index ` .",
    "the sense fluents have to be declared explicitly by a fact ` sensors(sensors ) . ` , where ` sensors ` is a listing of the respective function symbols .",
    "this is necessary in order to distinguish sense fluents , ordinary fluents , and auxiliary predicates in pi - lists .",
    "reasoning in alpprolog works as follows : for evaluating the program atoms we readily resort to prolog .",
    "the reasoner for the action theory is based on the principle of progression .",
    "setting out from the initial state , upon each successful evaluation of an action s precondition against the current state description , we update the current state description by the action s effects .",
    "reasoning about the action comes in the following forms :    * given a ground applicable action @xmath43 , from the current state description @xmath101 and the action s positive and negative effects compute the description of the next state @xmath122 ( the update problem ) .",
    "* given a description @xmath97 of the current state , check whether @xmath123 , where @xmath124 is some state formula in @xmath70 , but not a sense fluent ( the entailment problem ) .",
    "* for a sensing action , i.e.  a query @xmath125 , integrate the sensing results observed into the agent s state knowledge ( the sensing problem ) .    in the following we consider each of these reasoning problems in turn .",
    "it turns out that solving the update problem is very simple .",
    "let ` state ` be a ground pi - list , and let ` update ` be a list of ground fluents .",
    "the representation of the next state is then computed in two steps :    * first , all prime implicates in ` state ` that contain either an effect from ` update ` , or its negation , are deleted , resulting in ` state1 ` . * the next state",
    "` nextstate ` is given by the union of ` state1 ` and ` update ` .",
    "starting from a ground initial state only ground states are computed .",
    "the correctness of this procedure can be seen e.g.  as follows : in @xcite algorithms for computing updates in a fluent calculus based upon description logics have been developed .",
    "the above update algorithm constitutes a special case of these algorithms .",
    "when evaluating a clause @xmath98 against a ground prime state formula @xmath51 , @xmath98 is first split into the fluent part @xmath126 , and the non - fluent part @xmath127 .",
    "it then holds that @xmath98 is entailed by @xmath51 if there is a ground substitution @xmath91 such that    * @xmath128 is subsumed by some prime implicate in @xmath51 ; or * some auxiliary atom @xmath129 from @xmath127 can be derived from its defining prolog clauses .",
    "computing that the clause @xmath126 is subsumed by @xmath51 can be done as follows :    * if @xmath126 is a singleton , then it must be a prime implicate of @xmath51 ( modulo unification ) .",
    "* otherwise there must be a prime implicate in @xmath51 that contains @xmath126 ( modulo unification ) .",
    "hence the entailment problem for alpprolog can be solved by ` member ` , ` memberchk ` , and ` subset ` operations on sorted , duplicate - free lists .",
    "the following example illustrates how reasoning in alpprolog can be reduced to simple operation on lists .",
    "it also illustrates the limited form of reasoning about disjunctive information available in alpprolog :    assume that the current state is given by ` [ [ at(gold,4),at(gold,5 ) ] ] ` .",
    "then the query ` ? ( [ at(gold , x ) ] ) ` fails , because we do nt consider disjunctive substitutions .",
    "however , on the same current state the query ` ? ( [ [ at(gold , x),at(gold , y ) ] ] ) ` succeeds with ` x=4 ` and ` y=5 ` .",
    "sensing results have to be included into the agent s state knowledge every time a sensing action is performed , i.e.  a literal ` ?",
    "( s(x ) ) ` is evaluated .",
    "this works as follows :    * first we identify the appropriate sensor axiom ` sensor_axiom(s(x),vals ) ` .",
    "* next we identify all the ` [ x - result_i]-index - meaning ` triples in ` vals ` such that ` result_i ` matches the observed sensing result , and unify ` x ` with ` result_i ` .",
    "* we then locate the unique ` index - meaning ` s.t .",
    "the current state entails ` index ` . *",
    "finally , we adjoin ` meaning ` to the current state and transform this union to a pi - list .",
    "at the end of section  [ ssec : sens ] we have already mentioned that adding sensing results to the action theory at runtime makes the subsequent reasoning logically unsound wrt .  the original program plus action theory .",
    "if we add the set of sensing results observed throughout a run of an alpprolog program , however , then we can obtain the following soundness result :    [ prop : sound ] let @xmath11  be a alpprolog program on top of an action domain @xmath71 .",
    "let @xmath7 be the union of the sensor results observed during a successful derivation of the alpprolog query @xmath130  with computed answer substitution @xmath91 .",
    "then @xmath131 .",
    "it is well - known that sld - resolution is sound for any ordinary program atom .",
    "a query @xmath132 , where @xmath51 is not a sense fluent , is only evaluated successfully if there is a substitution @xmath91 such that @xmath133 .",
    "assume we observe the sensing result @xmath134 for a sense fluent @xmath135 .",
    "in general we have ( cf .  definition  [ def : sens ] ) : @xmath136 for soundness , we have to add the observed sensing result as an additional assumption to the theory : @xmath137 .",
    "we have evaluated the performance of alpprolog via the so - called wumpus world @xcite that is a well - known challenge problem in the reasoning about action community .",
    "essentially , the wumpus world is an extended version of the gold - hunter domain from example  [ ex : alp ] . the main features that make it a good challenge problem are incomplete information in the form of disjunctions and unknown propositions , and reasoning about sensing results .",
    "we have used both flux and alpprolog to solve wumpus worlds of size up to @xmath138 .",
    "we have done this using three different modellings :    * in @xcite a flux model is described that uses quantification over variables  this is beyond alpprolog .",
    "* we have evaluated both languages on a ground model .",
    "* we have artificially increased the size of the ground model by making the connections between cells part of the state knowledge .",
    "a first observation is that both languages roughly scale equally well in all models .",
    "using ( 1 ) flux is slightly faster than alpprolog using ( 2 ) .",
    "let us then point out that on ground models flux and alpprolog maintain the same state representation : flux also computes the prime implicates . on the encoding ( 2 )",
    "alpprolog is roughly one order of magnitude faster than flux , whereas on ( 3 ) the difference is already two orders of magnitude .",
    "the key to the good performance of alpprolog then is that it handles large state representations well : by encoding states as _ sorted _ lists ( of lists ) some of the search effort necessary in flux can be avoided .",
    "if , however , we use flux capability of handling quantified variables in the state knowledge for a more concise encoding , then alpprolog and flux are again on par , with flux even having slightly the edge . in general , we expect alpprolog to excel on problem domains that feature large state representations that are not easily compressed using quantification .",
    "it has already been established that flux gains continuously over standard golog the more actions have to be performed @xcite . as",
    "alpprolog scales as well as flux the same holds for alpprolog and golog .",
    "the version of golog with periodically progressed state knowledge is slightly slower than flux @xcite .",
    "let us also compare alpprolog , flux , and golog from a knowledge representation perspective : both alpprolog and flux allow the programmer to define new auxiliary predicates for the agent strategy that are not present in the action theory , a practically very useful feature that is missing from golog .",
    "also , the propositional variables used in golog instead of the finitely many ground terms used in alpprolog make it hard for the programmer to fully exploit the power of prolog s unification mechanism . in this regard flux , on the other hand , excels in that the programmer can include fluents containing ( possibly quantified ) variables in the agent s state knowledge .",
    "contrary to alpprolog and golog , however , flux does not support arbitrary disjunctions .",
    "in this work we have presented alpprolog , an efficient logic programming language for the online control of autonomous agents in domains that feature incomplete information and sensing . on the one hand , it can be argued that the state - of - the - art languages golog and flux already successfully address this application domain . on the other hand",
    ", we have shown that alpprolog excels because of its efficient reasoning with large ground state representations , something that we expect to be quite useful in practice .    for future work",
    ", there are two interesting directions : on the one hand it would be nice to extend alpprolog to offline planning .",
    "the disjunctive substitutions in the general alp proof calculus provide a powerful form of reasoning about conditional plans , or planning in the presence of sensing in the sense of @xcite .",
    "on the other hand we plan to fruitfully apply alpprolog in the domain of general game playing .",
    "general game playing @xcite is a new exciting ai research challenge aiming at the integration of manifold ai techniques : a program ( also called a player ) is given an axiomatisation of the rules of a game .",
    "the player then computes a strategy / heuristic that it uses to play and hopefully win the game . the main challenge of general game playing consists of constructing suitable heuristics .",
    "however , at its base the player also needs a means to represent , and reason about , the state of the game .",
    "up to now the games played in general game playing have been restricted to complete information @xcite  but clearly games with incomplete information constitute a bigger challenge  @xcite . we intend to include techniques from alpprolog into the successful flux - based fluxplayer @xcite .      we appreciate the helpful comments by the reviewers .",
    "this work was partially supported by dfg grant th 541/14 .",
    "c.  drescher wishes to acknowledge support by epsrc grant ep / g055114/1 .",
    "m.  thielscher is the recipient of an australian research council future fellowship ( project number  ft0991348 ) .",
    "he is also affiliated with the university of western sydney .      ,",
    "liu , h. , baader , f. , guhlemann , s. , petersohn , u. , steinke , p. , and thielscher , m. 2009 .",
    "putting abox updates into action . in _ proceedings of the seventh international symposion on frontiers of combining systems ( frocos  2009)_. trento , italy .    ,",
    "schiffel , s. , and thielscher , m. 2009 . a declarative agent programming language based on action theories . in _ proceedings of the seventh international symposion on frontiers of combining systems ( frocos  2009)_. trento , italy .              ,",
    "lutz , c. , milicic , m. , and wolter , f. 2006 .",
    "updating description logic aboxes . in _ proceedings of the tenth international conference on principles of knowledge representation and reasoning ( kr  06)_. lake district of the uk .",
    "2010a . a general game description language for incomplete information games .",
    "in _ proceedings of the twenty - fourth national conference on artificial intelligence ( aaai  2010)_. aaai press , atlanta , 994999 ."
  ],
  "abstract_text": [
    "<S> logic programming is a powerful paradigm for programming autonomous agents in dynamic domains , as witnessed by languages such as golog and flux . in this work we present alpprolog , an expressive , yet efficient , logic programming language for the online control of agents that have to reason about incomplete information and sensing actions .    </S>",
    "<S> * note : * this article has been published in _ theory and practice of logic programming_,volume 11 , issue 4 - 5 , pp . 451 - 468 , cambridge university press .    </S>",
    "<S> reasoning about actions , agent logic programs </S>"
  ]
}