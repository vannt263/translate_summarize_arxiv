{
  "article_text": [
    "consider a scenario wherein a centralized receiver is interested in evaluating a multi - variate function , the arguments of which are available to spatially distributed transmitters .",
    "traditionally , the technique of computing functions at a centralized receiver is based on it s decoding of the arguments in it s entirety .",
    "solutions based on this technique have been proven optimal for particular instances of distributed source coding . moreover",
    ", this technique lends itself naturally for communication based on separation . buoyed by this partial success and ease of implementation ,",
    "the de facto framework for computing at a centralized receiver is by enabling the decoder decode the arguments of the function in it s entirety .",
    "the problem of computing mod-@xmath0 sum of distributed binary sources has proved to be an exception .",
    "studied in the context of a source coding problem , krner and marton @xcite propose an ingenious technique based on linear codes , that circumvent the need to communicate sources to the decoder , and thereby perform strictly better for a class of source distributions .",
    "in fact , as proposed in @xcite , the decoder needs only sum of message indices put out by the source encoder .",
    "this fact has been further exploited by nazer and gastpar @xcite in developing a channel coding technique for a _ linear _ mac , henceforth referred to as linear computation coding ( lcc ) , that enables the decoder reconstruct the sum of the message indices input to the channel encoder .",
    "since the decoder does not need to disambiguate individual message indices , this technique , when applicable , outperforms earlier known techniques .",
    "lcc @xcite is built around employing the same linear code as a channel code at both encoders .",
    "the message indices output by the krner - marton ( km ) source code is linearly mapped into channel codewords .",
    "since a linear mac first computes a sum of the transmitted codewords , it is as if the codeword corresponding to the sum of messages was input to the ensuing channel .",
    "the first question that comes to mind is the following . if the mac is not linear , would it be possible to decode sum of message indices without having to decode the individual codewords ?",
    "in other words , what would be the generalization of lcc for an arbitrary mac ? if there exist such a generalization , how efficient would it be ?    in this article , we answer the above question in the affirmative .",
    "firstly , we recognize that in order to decode the sum of transmitted codewords , it is most efficient to employ channel codes that are closed under addition , of which a linear code employed in lcc is the simplest example .",
    "closure under addition contains the range of the sum of transmitted codewords and thereby support a larger range for individual messages .",
    "secondly , typical set decoding circumvents need for the mac to be linear .",
    "since nested coset codes have been proven to achieve capacity of arbitrary point - to - point channels @xcite and are closed under addition , we employ this ensemble for generalizing the technique of lcc . as illustrated by examples [ ex : pentaadditivemacwithtwonoisyandthreenoiselesssymbols],[ex : pentaadditivemacwithtwouselessandthreenoisysymbols ] in section [ sec : nestedcosetcodesforcomputingthesumofsourcesoveramac ] , the generalization we propose ( i ) outperforms separation based technique for an arbitrary mac and moreover ( ii ) outperforms lcc even for examples with a structural match .",
    "we remark that analysis of typical set decoding of a function of transmitted codewords with nested coset codes that contain statistically dependent codewords contains new elements and are detailed in proof of theorem [ thm : achievabilityusingnestedcosetcodes ] .    even in the case of a structural match , separation based schemes might outperform lcc ( * ? ? ?",
    "* example 4 ) .",
    "this raises the following question . what then would be a unified scheme for computing over an arbitrary mac",
    "is there such a scheme that reduces to ( i ) separation when the desired function and mac are not matched and ( ii ) lcc when appropriately matched ?",
    "we recognize that km technique is indeed suboptimal for a class of source distributions . for such sources , it is more efficient to communicate sources as is .",
    "we therefore take the approach of ahlswede and han ( * ? ? ?",
    "* section vi ) , where in a two layer source code accomplishes distributed compression .",
    "the first layer generates message indices of those parts that are best reconstructed as is , and the second employs a km technique . in section [ sec : generaltechnique ] , we propose a two layer channel code for mac that is compatible with the above two layer source code .",
    "the first layer of the mac channel code communicates the message indices as is , while the second enables the decoder decode the sum of second layer message indices , and thereby develop a unifying strategy that subsumes separation and lcc .",
    "we highlight the significance of our contribution .",
    "firstly , we propose a strategy based on nested coset codes and derive a set of sufficient conditions for the problem of computing sum of sources over an _",
    "arbitrary _ mac .",
    "the proposed strategy subsumes all current known strategies and performs strictly better for certain examples ( section [ sec : nestedcosetcodesforcomputingthesumofsourcesoveramac ] ) . secondly , our findings highlight the utility of nested coset codes @xcite as a generic ensemble of structured codes for communicating over arbitrary multi - terminal communication problems .",
    "thirdly , and perhaps more importantly , our findings hint at a general theory of structured codes .",
    "linear and nested linear codes have been employed to derive communication strategies for particular symmetric additive source and channel coding problems that outperform all classical unstructured - code based techniques .",
    "however the question remains whether these structured code based techniques can be generalized to arbitrary multi - terminal communication problems .",
    "our findings indicate that strategies based on structured codes can be employed to analyze more intelligent encoding and decoding techniques for an arbitrary multi - terminal communication problem .",
    "following remarks on notation ( [ subsec : notation ] ) and problem statement ( [ subsec : problemstatement ] ) , we briefly describe lcc for a linear mac ( [ subsec : linearcomputationcoding ] ) and set the stage for it s generalization .",
    "we employ notation that is now widely adopted in the information theory literature supplemented by the following .",
    "we let @xmath1 denote a finite field of cardinality @xmath2 .",
    "when the finite field is clear from context , we let @xmath3 denote addition in the same . when ambiguous , or to enhance clarity , we specify addition in @xmath1 using @xmath4 .    in this article , we repeatedly refer to pairs of objects of similar type . to reduce clutter in notation",
    ", we use an to refer to aggregates of similar type .",
    "for example , ( i ) @xmath5 abbreviates @xmath6 , ( ii ) if @xmath7 are finite alphabet sets , we let @xmath8 either denote the cartesian product @xmath9 or abbreviate the pair @xmath7 of sets .",
    "more non trivially , if @xmath10 are a pair of maps , we let @xmath11 abbreviate @xmath12 .",
    "consider a pair @xmath6 of information sources each taking values over a finite field @xmath13 of cardinality @xmath2 .",
    "we assume outcome @xmath14 of the sources at time @xmath15 , is independent and identically distributed across time , with distribution @xmath16 .",
    "we let @xmath17 denote this pair of sources .",
    "@xmath18 is observed by encoder @xmath19 that has access to input @xmath19 of a two user discrete memoryless multiple access channel ( mac ) that is used without feedback .",
    "let @xmath20 , @xmath21 be the finite input alphabet sets and @xmath22 the finite output alphabet set of mac .",
    "let @xmath23 denote mac transition probabilities .",
    "we refer to this as mac @xmath24 .",
    "the objective of the decoder is to compute @xmath25 . in this article",
    ", we provide a characterization of a sufficient condition for computing @xmath25 with arbitrary small probability of error .",
    "the relevant notions are made precise in the following definitions .",
    "[ defn : computationcode ] a computation code @xmath26 for computing sum of sources @xmath27 over the mac @xmath28 consists of ( i ) two encoder maps @xmath29 and ( ii ) a decoder map @xmath30 .    [ defn : averageerrorprobability ] the average error probability @xmath31 of a computation code @xmath26 is @xmath32    the sum of sources @xmath33 is computable over mac @xmath28 if for all @xmath34 , there exists an @xmath35 such that for all @xmath36 , there exists an @xmath37 computation code such that @xmath38 .",
    "the main objective in this article is to provide a sufficient condition for computability of sum of sources over a mac .",
    "we describe the technique of lcc in a simple setting and highlight the key aspects .",
    "consider binary sources and a binary additive mac , i.e. , @xmath39 and @xmath40 , where @xmath41 is independent of the inputs and @xmath42 .",
    "furthermore assume sources are symmetric , uniform , i.e. , @xmath43 and @xmath44 such that @xmath45 .    by employing a km source code ,",
    "the two message indices at rate @xmath46 can be employed to decode @xmath25 .",
    "let @xmath47 denote a parity check matrix for the km source code , with @xmath48 arbitrarily close to @xmath49 . nazer and gastpar observe that the decoder only requires the sum @xmath50 of message indices .",
    "if the map from message indices to channel code is linear , then the decoder can infer @xmath51 by decoding the codeword corresponding to sum of transmitted codewords . since sum of transmitted codewords passes through a bsc(@xmath2 ) , they employ a capacity achieving linear code of rate arbitrarily close to @xmath52 with generator matrix @xmath53 .",
    "each encoder employs the same linear code and transmits @xmath54 .",
    "the decoder receives @xmath55 and decodes as if the channel is a bsc(@xmath2 ) .",
    "it ends up decoding message corresponding to @xmath56 which was precisely what it was looking for .",
    "we note that a separation based scheme will require the sum capacity of the mac to be greater than @xmath57 and hence lcc is more efficient .",
    "what are key aspects of lcc ?",
    "note that ( i ) the channel code is designed for the @xmath58 to @xmath59 channel , i.e. , the bsc(@xmath2 ) and ( ii ) both encoders employ the same linear channel code , thereby ensuring their codes are closed under addition .",
    "this contains range of the sum of transmitted codewords to a rate @xmath52 .",
    "it is instructive to analyze the case when the two users are provided two linear codes of rates @xmath60 and @xmath61 spanning disjoint subspaces .",
    "since the range of sum of transmitted codewords is @xmath62 , the same decoding rule will impose the constraint @xmath63 resulting in the constraint @xmath64 which is strictly suboptimal .",
    "_ we conclude that the two users channel codes being closed under addition is crucial to the optimality of lcc for this problem . _ furthermore , the coupling of ( i ) a linear map of km message indices to the channel code at the encoder and ( ii ) decoding of the sum of transmitted codewords , is central to lcc .    in the following section",
    ", we make use of the above observations to propose a generalization of lcc for computing sum of sources over an arbitrary mac .",
    "in this section , we propose a technique for computing @xmath25 over an _",
    "arbitrary _ mac using the ensemble of nested coset codes @xcite , and derive a set of sufficient conditions under which , sum of sources @xmath33 can be computed over a mac @xmath65 .",
    "definitions [ defn : characterizationoftestchannelsforcomputingsumoverfields ] and theorem [ thm : achievabilityusingnestedcosetcodes ] state these sufficient conditions .",
    "this is followed by examples that illustrate significance of theorem [ thm : achievabilityusingnestedcosetcodes ] .",
    "[ defn : characterizationoftestchannelsforcomputingsumoverfields ] let @xmath66 be collection of distributions @xmath67 defined over @xmath68 such that ( i ) @xmath69 , ( ii ) @xmath70 . for @xmath71 , let @xmath72 be defined as @xmath73    [ thm : achievabilityusingnestedcosetcodes ] the sum of sources @xmath33is computable over a mac @xmath74 if @xmath75 .",
    "before we provide a proof , we briefly state the coding strategy and indicate how we attain the rates promised above .",
    "we begin with a description of the encoding rule .",
    "encoder @xmath19 employs a km source code to compress the observed source .",
    "let @xmath76 denote corresponding message index , where @xmath77 is a km parity check matrix of rate @xmath78 .",
    "each encoder is provided with a common nested linear code taking values over @xmath13 .",
    "the nested linear code is described through a pair of generator matrices @xmath79 and @xmath80 , where @xmath81 and @xmath82^{t}$ ] are the generator matrices of the inner ( sparser ) code and complete ( finer ) codes respectively , where @xmath83 encoder @xmath19 picks a codeword in coset @xmath84 indexed by @xmath85 that is typical with respect to @xmath86 .",
    "based on this chosen codeword @xmath87 is generated according to @xmath88 and transmitted .",
    "the decoder is provided with the same nested linear code .",
    "having received @xmath55 it lists all codewords that are jointly typical with @xmath55 with respect to distribution @xmath89 .",
    "if it finds all such codewords in a unique coset , say @xmath90 , then it declares @xmath91 to be the sum of km message indices and employs km decoder to decode the sum of sources .",
    "otherwise , it declares an error .",
    "we derive an upper bound on probability of error by averaging the error probability over the ensemble of nested linear codes . for the purpose of proof",
    ", we consider user codebooks to be cosets of nested linear codes .",
    "we average uniformly over the entire ensemble of nested _ coset _ codes .",
    "lower bound ( [ eqn : binningrate](a ) ) ensures the encoders find a typical codeword in the particular coset .",
    "upper bound ( [ eqn : binningrate](b ) ) enables us derive an upper bound on the probability of decoding error . from ( [ eqn : binningrate ] ) , it can be verified that if @xmath92 then the decoder can reconstruct the sum of sources with arbitrarily small probability of error .",
    "how does nesting of linear codes enable attain non - uniform distributions ? as against to a linear code , nesting of linear codes provides the encoder with a coset to choose the codeword from .",
    "the vectors in the coset being uniformly distributed , it contains at least one vector typical with respect to @xmath86 with high probability , if the coset is of rate at least @xmath93 . by choosing such a vector",
    ", the encoder induces a non - uniform distribution on the input space .",
    "therefore , constraint ( [ eqn : binningrate](a ) ) enables achieve non - uniform input distributions .",
    "since the codebooks employed by the encoders are uniformly and independently distributed cosets of a common random linear code , the sum of transmitted codewords also lies in a codebook that is a uniformly distributed coset of the same linear code . any vector in this codebook is uniformly distributed over it s entire range .",
    "therefore , a vector in this codebook other than the legitimate sum of transmitted codewords is jointly typical with the received vector with probability at most @xmath94 .. ] employing a union bound , it can be argued that the probability of decoding error decays exponentially if ( [ eqn : binningrate](b ) ) holds .",
    "since the ensemble of codebooks contain statistically dependent codewords and moreover user codebooks are closely related , deriving an upper bound on the probability of error involves new elements .",
    "the informed reader will recognize that in particular , deriving an upper bound on the probability of decoding error will involve proving statistical independence of the pair of cosets indexed by km indices @xmath95 and any codeword in a coset corresponding to @xmath96 .",
    "the statistical dependence of the codebooks results in new elements to the proof .",
    "the reader is encouraged to peruse the same in the following .    given @xmath34 ,",
    "our goal is to identify a computation code @xmath26 such that @xmath97 for all sufficiently large @xmath98 .",
    "the source sequences are mapped to channel input codewords in two stages . in the first stage ,",
    "a distributed source code proposed by krner and marton @xcite is employed to map @xmath99-length source sequences to message indices that takes values over @xmath100 .",
    "the second stage maps these indices to channel input codewords .",
    "we begin by stating the main findings of @xcite on which our first stage relies .",
    "[ lem : kornermartonresult ] given a pair of @xmath33 of information sources and @xmath101 , there exists an @xmath102 such that for every @xmath98 , there exists a parity check matrix @xmath103 and a map @xmath104 such that ( i ) @xmath105 , and ( ii ) @xmath106 .    given @xmath107 , let @xmath77 be a parity check matrix that satisfies ( i ) and ( ii ) in lemma [ lem : kornermartonresult ] .",
    "let @xmath108 be the message indices output by the source encoder .",
    "in the second stage , we identify maps @xmath109 that maps these message indices to channel input codewords .",
    "the encoder @xmath110 of the computation code is therefore defined as @xmath111 .",
    "the second stage of the encoding is based on nested coset codes .",
    "we begin with a brief review of nested coset codes .",
    "an @xmath112 coset is a collection of vectors in @xmath113 obtained by adding a constant bias vector to a @xmath114dimensional subspace of @xmath113 . if @xmath115 and @xmath116 are @xmath117 and @xmath112 coset codes respectively , then @xmath118 cosets @xmath119 that partition @xmath120 is a nested coset code .",
    "a couple of remarks are in order .",
    "an @xmath112 coset code is specified by a bias vector @xmath121 and generator matrices @xmath122 .",
    "if @xmath123 and @xmath124 are @xmath117 and @xmath112 coset codes respectively , then there exists a bias vector @xmath125 and generator matrices @xmath126 and @xmath127 \\in \\fieldq^{(k+l)\\times n}$ ] , such that @xmath128 , @xmath81 specify @xmath129 and @xmath128 , @xmath130 specify @xmath120 .",
    "therefore , a nested coset code is specified by a bias vector @xmath128 and any two of the three generator matrices @xmath81 , @xmath131 and @xmath130",
    ". we refer to this as nested coset code @xmath132 .",
    "we now specify the encoding rule .",
    "encoder @xmath19 is provided a nested coset code @xmath133 denoted @xmath134 taking values over the finite field @xmath13 .",
    "let @xmath135 denote a generic codeword in @xmath134 and @xmath136 denote coset corresponding to message @xmath137 .",
    "the message index @xmath138 put out by the source encoder is used to index coset @xmath139 .",
    "encoder @xmath19 looks for a codeword in coset @xmath140 that is typical according to @xmath86 .",
    "if it finds at least one such codeword , one of them , say @xmath141 is chosen uniformly at random .",
    "@xmath142 is generated according @xmath143 and @xmath142 is transmitted .",
    "otherwise , an error is declared .",
    "we now specify the decoding rule .",
    "the decoder is provided with the nested coset code @xmath132 denoted @xmath119 , where @xmath144 .",
    "we employ notation similar to that specified for the encoder . in particular ,",
    "let @xmath145 denote a generic codeword and @xmath146 denote a generic coset in @xmath119 respectively .",
    "decoder receives @xmath55 and declares error if @xmath147 .",
    "else , it lists all codewords @xmath148 such that @xmath149 .",
    "if it finds all such codewords in a unique coset say @xmath150 of @xmath119 , then it declares @xmath151 to be the decoded sum of sources , where @xmath152 is as specified in lemma [ lem : kornermartonresult ] .",
    "otherwise , it declares an error .    as is typical in information theory , we derive an upper bound on probability of error by averaging the error probability over the ensemble of nested coset codes .",
    "we average over the ensemble of nested coset codes by letting the bias vectors @xmath153 and generator matrices @xmath154 mutually independent and uniformly distributed over their respective range spaces .",
    "let @xmath155 and @xmath156 denote the random nested coset codes @xmath157 and @xmath158 respectively , where @xmath159 .",
    "for @xmath160 , @xmath161 , let @xmath162 , @xmath163 denote corresponding random codewords in @xmath155 and @xmath156 respectively .",
    "let @xmath164 and @xmath165 denote random cosets in @xmath155 and @xmath156 corresponding to message @xmath166 and @xmath91 respectively .",
    "we now analyze error events and upper bound probability of error .",
    "we begin by characterizing error events at encoder . if @xmath167 and @xmath168 , then @xmath169 is the error event at encoder @xmath19 .",
    "an upper bound on @xmath170 can be derived by following the arguments in [ proof of theorem1]@xcite .",
    "findings in @xcite imply existence of @xmath171 such that @xmath172 , @xmath173 if @xmath174 .",
    "the error event at the decoder is @xmath175 , where @xmath176 and @xmath177 in order to upper bound @xmath178 by conditional frequency typicality , it suffices to upper bound @xmath179 .",
    "note that ( i ) independence of @xmath180 implies the markov chain @xmath181 , and ( ii ) the chosen codeword @xmath182 and the transmitted vector @xmath183 are jointly typical with high probability as a consequence of conditional generation of the latter . by the markov lemma @xcite",
    ", it suffices to prove @xmath184 are jointly typical .",
    "if the codewords were chosen independently at random according to @xmath185 , this would fall out as a consequence of uniformly sampling from the typical set @xcite .",
    "however , the generation of nested coset code is different , and the proof of this involves an alternate route .",
    "an analogous proof of the markov lemma is provided in @xcite and omitted here in the interest of brevity .",
    "it remains to upper bound @xmath186 . in appendix",
    "[ sec : anupperboundonprobabilityofepsilon3 ] , we prove that if @xmath187 , there exists @xmath188 such that @xmath189 , @xmath190 . combining the bounds @xmath191 and @xmath187",
    ", we note that @xmath192 , then the sum of message indices @xmath193 can be reconstructed at the decoder .",
    "this concludes proof of achievability .",
    "the informed reader will recognize that deriving an upper bound on @xmath194 will involve proving statistical independence of the pair @xmath195 of cosets and any codeword @xmath196 corresponding to a competing sum of messages @xmath197 .",
    "this is considerably simple for a coding technique based on classical unstructured codes wherein codebooks and codewords in every codebook are independent .",
    "the coding technique proposed herein involves correlated codebooks and codewords resulting in new elements to the proof .",
    "the reader is encouraged to peruse details of this element presented in appendix [ sec : anupperboundonprobabilityofepsilon3 ] .",
    "it can be verified that the rate region presented in theorem [ thm : achievabilityusingnestedcosetcodes ] subsumes that presented in ( * ? ? ?",
    "* theorem1 , corollary 2 ) .",
    "this follows by substituting a uniform distribution for @xmath198 .",
    "therefore examples presented in @xcite carry over as examples of rates achievable using nested coset codes .",
    "one might visualize a generalization of lcc for arbitrary mac through the modulo - lattice transformation ( mlt ) ( * ? ? ?",
    "* section iv ) .",
    "since the map for km source code message indices to the channel code has to be linear , the virtual input alphabets of the transformed channel are restricted to be source alphabets as in definition [ defn : characterizationoftestchannelsforcomputingsumoverfields ] .",
    "it can now be verified that any virtual channel , specified through maps from ( i ) virtual to actual inputs , ( ii ) output to the estimate of the linear combination , identifies a corresponding test channel in @xmath199 .",
    "hence , the technique proposed herein subsumes mlt . moreover , while mlt is restricted to employing uniform distributions over the auxiliary inputs , nested coset codes can induce arbitrary distributions .",
    "we now present a sample of examples to illustrate significance of theorem [ thm : achievabilityusingnestedcosetcodes ] . as was noted in (",
    "* example 4 ) a uniform distribution induced by a linear code maybe suboptimal even for computing functions over a mac with a structural match .",
    "the following example , closely related to the former , demonstrates the ability of nested coset codes to achieve a nonuniform distribution and thus exploit the structural match better .",
    "[ ex : pentaadditivemacwithtwonoisyandthreenoiselesssymbols ] let @xmath200 and @xmath201 be a pair of independent and uniformly distributed sources taking values over the field @xmath202 of five elements .",
    "the decoder wishes to reconstruct @xmath203 .",
    "the two user mac channel input alphabets @xmath204 and output alphabet @xmath205 .",
    "the output @xmath59 is obtained by passing @xmath206 through an asymmetric channel whose transition probabilities are given by @xmath207 for each @xmath208 and @xmath209 .",
    "let the number of source digits output per channel use be @xmath210 .",
    "we wish to compute the range of values of @xmath210 for which the decoder can reconstruct the sum of sources .",
    "this is termed as computation rate in @xcite .",
    "it can be verified that the decoder can reconstruct @xmath203 using the technique of lcc if @xmath211 .",
    "a separation based scheme enables the decoder reconstruct the sum if @xmath212 .",
    "we now explore the use of nested coset codes .",
    "it maybe verified that pmf @xmath213 defined on @xmath214 satisfies ( i),(ii ) of definition [ defn : characterizationoftestchannelsforcomputingsumoverfields ] and moreover @xmath215.thus nested coset codes enable reconstructing @xmath203 at the decoder if @xmath216 .",
    "the above example illustrates the need for nesting codes in order to achieve nonuniform distributions .",
    "however , for the above example , a suitable modification of lcc is optimal . instead of building codes over @xmath202 ,",
    "let each user employ the linear code of rate @xmath217length vectors ] built on @xmath218 .",
    "the map @xmath219 defined as @xmath220 and @xmath221 induces a code over @xmath202 and it can be verified that lcc achieves the rate achievable using nested coset codes .",
    "however , the following example precludes such a modification of lcc .",
    "[ ex : pentaadditivemacwithtwouselessandthreenoisysymbols ] the source is assumed to be the same as in example [ ex : pentaadditivemacwithtwonoisyandthreenoiselesssymbols ] .",
    "the two user mac input and output alphabets are also assumed the same , i.e. , @xmath204 and output alphabet @xmath205 .",
    "the output @xmath59 is obtained by passing @xmath206 through an asymmetric channel whose transition probabilities are given by @xmath207 for each @xmath208 and @xmath222 .",
    "the technique of lcc builds a linear code over @xmath202 .",
    "it can be verified that the symmetric capacity for the @xmath223 channel is @xmath224 and therefore lcc enables decoder reconstruct the sum if @xmath225 .",
    "a separation based scheme necessitates communicating each of the sources to the decoder and this can be done only if @xmath226 .",
    "the achievable rate region of the test channel in ( [ eqn : pmffornestedcosetcodes ] ) is @xmath227 and therefore nested coset codes enable decoder reconstruct the sum if @xmath228 .",
    "[ ex : ternarysourcesanddecoderintersetedinparityofthepair ] let @xmath200 and @xmath201 be independent sources distributed uniformly over @xmath229 .",
    "the input alphabets @xmath230 is the ternary field and the output alphabet @xmath231 is the binary field .",
    "let @xmath232 and output @xmath59 is obtained by passing @xmath233 through a bsc with crossover probability @xmath234 .",
    "the decoder is interested in reconstructing @xmath233 . as noted in (",
    "* example 8) , @xmath233 is @xmath235 if an only if @xmath236 .",
    "therefore , it suffices for the decoder to reconstruct @xmath237 .",
    "following the arguments in proof of theorem [ thm : achievabilityusingnestedcosetcodes ] it can be proved that @xmath237 can be reconstructed using nested coset codes if there exists a pmf @xmath238 such that @xmath239 .",
    "it can be verified that for pmf @xmath240 wherein @xmath198 are independently and uniformly distributed over @xmath241 , @xmath242 , @xmath243 , the achievable rate region is @xmath244 .",
    "the computation rate achievable using scc and separation technique are @xmath245 and @xmath246 respectively .",
    "the computation rate achievable using nested coset codes is @xmath247 .",
    "[ example : additivetweakedtomakenonadditive ] let @xmath200 and @xmath201 be independent and uniformly distributed binary sources and the decoder is interested in reconstructing the binary sum .",
    "the mac is binary , i.e. @xmath248 with transition probabilities @xmath249 if @xmath250 , @xmath251 and @xmath252 .",
    "it can be easily verified that the channel is not linear , i.e. , @xmath253 is _ not _ a markov chain .",
    "this restricts current known techniques to either separation based coding or scc ( * ? ? ?",
    "* section v ) .",
    "scc yields a computation rate of @xmath254 .",
    "the achievable rate region for the test channel @xmath240 where in @xmath255 and @xmath256 are independent and uniformly distributed binary sources , @xmath257 is given by @xmath258 .",
    "we conclude by recognizing that example [ example : additivetweakedtomakenonadditive ] is indeed a family of examples . as long as the mac is close to additive",
    "we can expect nested coset codes to outperform separation and scc .",
    "in this section , we propose a general technique for computing sum of sources over a mac that subsumes separation and computation .",
    "the architecture of the code we propose is built on the principle that techniques based on structured coding are not in lieu of their counterparts based on unstructured coding .",
    "indeed , the km technique is outperformed by the berger - tung @xcite strategy for a class of source distributions .",
    "a general strategy must therefore incorporate both .",
    "we take the approach of ahlswede and han ( * ? ? ?",
    "* section vi ) , where in a two layer source code is proposed .",
    "each source encoder @xmath19 generates two message indices @xmath259 .",
    "@xmath260 is an index to a berger - tung source code and @xmath261 is an index to a km source code .",
    "the source decoder therefore needs @xmath262 and @xmath263 to reconstruct the quantizations and thus the sum of sources .",
    "we propose a two layer mac channel code that is compatible with the above source code .",
    "the first layer of this code is a standard mac channel code based on unstructured codes .",
    "the messages input to this layer are communicated as is to the decoder .",
    "the second layer employs nested coset codes and is identical to the one proposed in theorem [ thm : achievabilityusingnestedcosetcodes ] .",
    "a function of the codewords selected from each layer is input to the channel .",
    "the decoder decodes a triple - the pair of codewords selected from the first layer and a sum of codewords selected from the second layer - and thus reconstructs the required messages .",
    "the following characterization specifies rates of layers 1 and 2 separately and therefore differs slightly from ( * ? ? ?",
    "* theorem 10 ) .",
    "[ defn : testchannelsahlswedehancharacterization ] let @xmath264 be collection of distributions @xmath265 defined over @xmath266 such that ( a ) @xmath267 are finite sets , ( b ) @xmath268 , ( c ) @xmath269 is a markov chain . for @xmath270 , let @xmath271 let @xmath272 denote convex closure of the union @xmath273 over @xmath274    we now characterize achievable rate region for communicating these indices over a mac . we begin with a definition of test channels and the corresponding rate region .",
    "[ defn : channelcodingtestchannelsforahlswedehancharacterization ] let @xmath275 be collection of distributions @xmath276 defined on @xmath277 such that ( i ) @xmath278 , ( ii ) @xmath279 . for @xmath280 , let @xmath281 be defined as @xmath282 where @xmath283 and define @xmath284 as the convex closure of the union @xmath285 over @xmath286 .",
    "[ thm : jointseparationcomputationtechniquebasedonahlswedehan ] the sum of sources @xmath287 is computable over mac @xmath74 if @xmath288 .",
    "[ rem : universaltechniquesubsumesseparationandcomputation ] it is immediate that the general strategy subsumes separation and computation based techniques . indeed , substituting @xmath289 to be degenerate yields the conditions provided in theorem [ thm : achievabilityusingnestedcosetcodes ] . substituting @xmath290 to be degenerate yields separation based technique .",
    "in this appendix , we derive an upper bound on @xmath194 . as is typical in proofs of channel coding theorems , this step involves establishing statistical independence of @xmath291 and any codeword @xmath292 in a competing coset @xmath293 .",
    "we establish this in lemma [ lem : statisticalindependenceoftransmittedcosetandcompetingcodeword ] .",
    "we begin with the necessary spadework .",
    "the following lemmas holds for any @xmath1 and we state it in this generality .",
    "[ lem : uniformdistributionandpairwiseindependenceofcodewordsinarandomcoset ] let @xmath1 be a finite field .",
    "let @xmath294 , @xmath295 , @xmath296 be mutually independent and uniformly distributed on their respective range spaces . then the following hold .",
    "1 .   @xmath297 for any @xmath298 , @xmath299 and @xmath300 , 2 .",
    "@xmath301 for any @xmath302 , @xmath303 and @xmath304 , and 3 .",
    "@xmath305 for any @xmath306 and @xmath307 and @xmath308 .",
    "the proof follows from a counting argument similar to that employed in ( * ? ? ?",
    "* remarks 1,2 ) .",
    "+ ( a ) for any @xmath309 , @xmath310 , @xmath300 , there exists a unique @xmath311 such that @xmath312 . since @xmath313 , @xmath314 and @xmath315 are mutually independent and uniformly distributed @xmath316 .",
    "+ ( b ) we first note @xmath317 . for any choice of @xmath81 and @xmath131 , there exists unique @xmath318 such that @xmath319 . since @xmath313 , @xmath314 and",
    "@xmath315 are mutually independent and uniformly distributed , the probability in question is therefore @xmath320 .",
    "+ ( c ) note that @xmath321 since @xmath322 , there exists an index @xmath323 such that @xmath324 . therefore , given any set of rows @xmath325",
    ", there exists a unique selection for row @xmath326 such that @xmath327 .",
    "having chosen this , choose @xmath328 . since @xmath313 , @xmath314 and @xmath153 are mutually independent and uniformly distributed , the probability in question is therefore @xmath329 .",
    "[ lem : statisticalindependenceoftransmittedcosetandcompetingcodeword ] if generator matrices @xmath330 ,",
    "@xmath331 and @xmath296 are mutually independent and uniformly distributed over their respective range spaces , then the pair of cosets @xmath332 is independent of @xmath196 whenever @xmath333 .",
    "let @xmath334 for each @xmath335 , @xmath336 and @xmath337 .",
    "we need to prove @xmath338 for every choice of @xmath339 and @xmath340 .    if ( i ) for some @xmath341 or @xmath342 , @xmath343 for any pair @xmath344 , @xmath345 , or ( ii ) @xmath346 for some @xmath335 , then lhs and first term of rhs are zero and equality holds .",
    "otherwise , lhs of ( [ eqn : identitytobeestablishedinindependencestep ] ) is @xmath347 where we have used independence of @xmath313 and @xmath348 in arriving at ( [ eqn : lhsofidentitytobeestablishedinindependencestep ] ) .",
    "similarly rhs of ( [ eqn : identitytobeestablishedinindependencestep ] ) is @xmath349 where ( [ eqn : substitutingforprobabilityofacodeword ] ) , ( [ eqn : rhsofidentitytobeestablishedinindependencestep ] ) follows from lemma [ lem : uniformdistributionandpairwiseindependenceofcodewordsinarandomcoset](a ) and ( b ) respectively . comparing simplified forms of lhs in ( [ eqn : lhsofidentitytobeestablishedinindependencestep ] ) and rhs in ( [ eqn : rhsofidentitytobeestablishedinindependencestep ] ) , it suffices to prove @xmath350 this follows from lemma [ lem : uniformdistributionandpairwiseindependenceofcodewordsinarandomcoset](c )    we emphasize consequence of lemma [ lem : statisticalindependenceoftransmittedcosetandcompetingcodeword ] in the following .",
    "[ rem : keyindependencestep ] if @xmath351 , then conditioned on the event @xmath352 , received vector @xmath55 is statistically independent of @xmath353 for any @xmath354 .",
    "we establish truth of this statement in the sequel .",
    "let @xmath355 denote the set of all ordered @xmath356-tuples of vectors in @xmath357 .",
    "observe that , @xmath358 we have used ( a ) independence of @xmath359 and random objects that characterize the codebook , ( b ) independence of @xmath196 and @xmath360 ( lemma [ lem : statisticalindependenceoftransmittedcosetandcompetingcodeword ] ) , ( c ) @xmath361 being a function of @xmath362 , is conditionally independent of @xmath196 given @xmath362 in arriving at ( [ eqn : usingstatisticalindependenceofcosetscorrtomessageandcompetingcodeword ] ) .",
    "moreover , since @xmath363 , we have @xmath364 .",
    "we are now equipped to derive an upper bound on @xmath194 .",
    "observe that @xmath365 where ( [ eqn : upperboundondecodingerrorprobability ] ) follows from the uniform bound of @xmath366 on @xmath367 for any @xmath368 , @xmath369 ( conditional frequency typicality ) for @xmath370 .",
    "having decoded the sum of sources , we ask whether it would be possible to decode an arbitrary function of the sources using the above techniques ?",
    "the answer is yes and the technique involves ` embedding ' .",
    "example [ ex : ternarysourcesanddecoderintersetedinparityofthepair ] illustrates embedding and a framework is proposed in a subsequent version of this article .",
    "this leads us to the following fundamental question .",
    "the central element of the technique presented above was to decode the _ sum _ of transmitted codewords and use that to decode sum of km message indices .",
    "if the mac is ` far from additive ' , is it possible to decode a different bivariate function of transmitted codewords and use that to decode the desired function of the sources ?",
    "the answer to the first question is yes .",
    "indeed , the elegance of joint typical encoding and decoding enables us reconstruct other ` well behaved ' functions of transmitted codewords .",
    "we recognize that if codebooks take values over a finite field and were closed under addition , it was natural and more efficient to decode the sum . on the other hand ,",
    "if the codebooks were taking values over an algebraic object , for example a group , and were closed with respect to group multiplication , it would be natural and efficient to decode the product of transmitted codewords .",
    "since , we did not require the mac to be linear in order to compute the sum of transmitted codewords , we will not require it to multiply in order for us to decode the product of transmitted codewords .",
    "we elaborate on this in a subsequent version of this article .",
    "this work was supported by nsf grant ccf-1111061 ."
  ],
  "abstract_text": [
    "<S> the problem of computing sum of sources over a multiple access channel ( mac ) is considered . </S>",
    "<S> building on the technique of linear computation coding ( lcc ) proposed by nazer and gastpar @xcite , we employ the ensemble of nested coset codes to derive a new set of sufficient conditions for computing sum of sources over an _ arbitrary _ mac . </S>",
    "<S> the optimality of nested coset codes @xcite enables this technique outperform lcc even for linear mac with a structural match . </S>",
    "<S> examples of non - additive mac for which the technique proposed herein outperforms separation and systematic based computation are also presented . </S>",
    "<S> finally , this technique is enhanced by incorporating separation based strategy , leading to a new set of sufficient conditions for computing sum over a mac . </S>"
  ]
}