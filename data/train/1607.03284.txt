{
  "article_text": [
    "several researchers are working to solve the shape from shading(sfs ) problem @xcite , but there are no solutions that give good results on real images . even with complex synthetic images , several constraints must be defined@xcite .",
    "the methods of sfs can be classified into three categories : the first category concerns the local resolution methods ( pontland@xcite@xcite , lee and ronselfd@xcite , tsai and shah@xcite ) , in which , the computing of the surface orientation of each pixel is principally given by the gray level information of its neighbors .",
    "the second category is the global resolution methods in which the resolution is calculated using all the pixels of the image@xcite , by passing over each pixel several times",
    ". the third category is mixed methods .",
    "in this paper we are interested to the needle map integration methods @xcite , in which the resolution is given by two steps : the generation and then the integration of the needle map for the surface reconstruction ( each step can be local global or mixed .",
    "the needle map represents the set of normals corresponding to all the pixels of image .",
    "we propose a method for generating the needle map by using a machine learning method .",
    "this method is composed of three phases : the first phase is the generation of the 3d object .",
    "the second phase is the preparation of the database examples ( offline).in the third phase we use the database examples to generate the needle map of each pixel ( online ) , it is belong to the local resolution methods .    among the methods dealing with shape from shading ,",
    "we mention the puntlands method @xcite , he proposed the first method to solve sfs problem using a local method .",
    "he chooses to direct all points of the image using the angles slant and tilt .",
    "there is also the method of lee and ronselfd that follows the puntlands method @xcite , but using a perspective camera and light source at the infinity .",
    "a.sethian@xcite is the first who applied the level set method to solve the sfs problem .",
    "his method uses the depth function ( z(x , y ) ) to generate the levels curves , and also jean denis @xcite used this category where he suggested a perspective camera and light source at the infinity .    like most methods proposed in sfs problem ,",
    "we suppose that : the surface is smooth , the image taken by a parallel projection camera , light source at the infinity and regular surface ( lambertian ) .    the paper is structured as follows : after the introduction section that offers a range of methods for solving the sfs problem with their classification .",
    "section two summarizes the basic concepts for the image formation and explains the mathematical equations used .",
    "the third section details the proposed technique based on the machine learning method .",
    "the last experimenting section gives the obtained results after applying our approach on synthetic and real images .",
    "sfs is the process of generating a three - dimensional shape using a single two - dimensional image , which is the reverse process of the image formation .      in this section",
    "we will define some basic notion and notations ( see fig.[fig : def ] ) :    * normal vector @xmath0 : is the perpendicular vector to the surface in a point ( x , y ) .",
    "* light source vector @xmath1 : is the vector which represents the direction of the light source and its intensity , the direction of s is towards the light source .",
    "* needle map : represents the set of the normals corresponding to all the pixels of image . *",
    "slant ( @xmath2 ) : is the angle between the origin ( the x - axis ) and the projection of the normal on the plane ( x , y ) . *",
    "tilt ( @xmath3 ) : is the angle between the normal vector and z - axis ( see figure [ fig : def ] ) . *",
    "boundary condition : the characteristic ( solution ) of the pixels located at the boundaries of the object is known . *",
    "neumann boundary condition : the solution in neumann boundary condition is the gradient ( in our case the gradient of the depth z ) . * albedo : reflectance factor ( ratio of light emitted and light received ) . *",
    "lambert surface : surface that reflects radiation uniformly in all directions .",
    "* gradient of depth ( z):depth variation ( the derivative of z with respect x and y ) .",
    "* singular point : pixel has a maximum illuminance .     [",
    "fig : def ]      the image formation consist to study the generation of images from objects ( see fig.[fig : defmodel ] ) .",
    "this process is used in cameras .",
    "we can generate an image form a 3d object by using the basic equation of the images formation for more details see @xcite .",
    "the illumination e is : @xmath4     [ fig : defmodel ]    the luminance ( brightness ) of a lambert surface can be expressed as follows :    @xmath5    the illumination ( e ) can expressed using the angle @xmath6 between the two vectors(n and s ) @xcite :    @xmath7    k is a constant @xmath8 , @xmath9 is the albedo of the surface . in a singular point",
    "both vector n and s are equal , @xmath10 , the illumination in this point is maximum @xmath11 .",
    "the equation (  [ eq : eq_8 ] ) can be written as @xcite :    @xmath12      our method belongs to the category of integration methods which consists of reconstructing the scene in two steps .",
    "generate the needle map then construct the scene from it .",
    "the following diagram in figure  [ fig : schema1 ] shows the different steps for the reconstruction .",
    "[ fig : schema1 ]      in our approach , we propose the generation of the needle map using the slant and tilt angles . we can compute the normal vector from the two angles ( tilt and slant ) using the formula : @xmath13    as explained previously , the tilt angle is equal to the angle between the normal n and the light source .",
    "s , @xmath14 .",
    "we propose a method to compute the slant ( the angle between the project vector of n on image plane and the vector n ) using machine learning under some constraints .",
    "we assume that the surface is lambertian , differentiable , continuous with a punctual light source located at infinity , taken by a camera with a parallel projection .",
    "our method is divided into three phases : the first phase is the generation of the 3d shape from mathematic functions .",
    "the second phase is the preparation of the examples database ( offline ) .",
    "third phase uses the database examples to generate the needle map of the test images ( online ) .      in this phase",
    "we will generate the training data , these data contain the inputs ( gray levels ) and outputs ( slant ) . in order to generate the data we need the 3d objects and their gray level images .    in this work",
    "we will create 3d objects by two methods : the first method is based on the generation of 3d surface from mathematic functions .",
    "figures [ fig : app1 ] , [ fig : app2 ] and [ fig : app4 ] show three 3d objects generated by the functions @xmath15 and @xmath16 respectively .",
    "the second method uses 3d surfaces defined by their depth ( z ) for example the silt ( figure.[fig : app5 ] ) mozart ( figure[fig : app6 ] ) and penny ( figure[fig : app7 ] ) . after the generation of the depths ( z of each pixels ) we will calculate the tilt and slant angles , and then we will generate the image corresponding to each 3d object",
    ". we will finally get results as a set of pixels and corresponding angles .",
    "the purpose of the offline phase is to create a database containing several examples .",
    "each example contains :    * input : * * the gray level of the pixel ( i , j ) * * the gray level and the slant of three adjacent neighbors of pixel ( i , j ) * output : the slant of pixel ( i , j )    for example in figure [ fig : db ] , we have a pixel ( i , j ) and three adjacent neighbors , the database contains eight fields , seven input and one output , the inputs are the gray level of@xmath17 and the slant of@xmath18 .",
    "the slant of(i , j ) is the output .",
    "[ fig : db ]      in our approach we will use the neumann boundary condition , so it is assumed that the normal of edge around the treated area in the image is known ( figure [ fig : bc ] ) .",
    "all pixels with three adjacent neighbors known slant are ready to find its slant .",
    "the search is done by the euclidean distance between the ready pixels and each element of examples database , and choose the minimum distances .",
    "@xmath19    such as :    * @xmath20 : is a ready pixel .",
    "* @xmath21 : is a database example .",
    "* @xmath22 : is the gray level of @xmath23 neighbor of p(i , j ) * @xmath24 : is the gray level of @xmath23 neighbor of e(i , j ) * @xmath25 : is the slant of @xmath23 neighbor of p(i , j ) * @xmath26 : is the slant of @xmath23 neighbor of e(i , j ) * @xmath27 is the gray level of p(i , j )     [ fig : bc ]      there are several methods to integrate the normal field , j.denis@xcite shows some iterative and no - iterative methods of the normal field integration .",
    "iterative methods are slow but give better results .",
    "we use in the following the method of horn and brooks@xcite , it is simple , easy to implement and gives a good results .",
    "the equation of integration is follows : + @xmath28    p and q are calculated using slant(@xmath2 ) and tilt(@xmath3 ) .",
    "the results of our approach is depend to the learning phase ( offline ) , we will test on many examples database generated from different functions .",
    "figures [ fig : app1 ] , [ fig : app2 ] and [ fig : app4 ] show four objects and corresponding images , these objects are generated using mathematics functions , @xmath15 and @xmath16 .",
    "figures [ fig : app5 ] , [ fig : app6 ] and [ fig : app7 ] shows three objects generated from the depths matrix and corresponding images . in all this cases the images are generated from objects using equation [ eq : eq_8 ] .",
    "[ fig : app1 ]     [ fig : app2 ]     [ fig : app4 ]     [ fig : app5 ]     [ fig : app6 ]     [ fig : app7 ]    we study six different cases of database , for each case we apply different function for the off - line and the on - line process :      first we will generate examples of function f1 , knowing that the examples are disjoint , function f1 can be generate 4625 examples .",
    "the test result on the image generated by the function f2 is shown in figure [ fig : res1 ] .",
    "the average of the distance of all pixels equals 0.07     [ fig : res1 ]      now we use the functions f1 and f2 to generate the examples database and f3 for the test . f1 and f2 generate 9249 example .",
    "the result is show in figure [ fig : res2 ] the average of distance is 0.064 .",
    "so there are pixels that do not have examples nearest .",
    "[ fig : res2 ]      in this case we will use f1 , f2 and f3 in the database and the silt image [ fig : app5 ] for the test , the result is shown in figure [ fig : res3 ] .",
    "the value of the average of distance is 0.1 .",
    "note that whenever the image is becoming more complicated the average distance increases .",
    "[ fig : res3 ]      the mozart and penny images contain more detail than the others , so there are several pixels that do not have a nearest example .",
    "figure [ fig : res4 ] shows the test result on the two images .",
    "the average distance is higher 0.19 for the image of mozart and 0.21 for the image of penny .",
    "the distance interval is between 0 and 1 , it represents the difference between the gray level and the azimuth of a pixel in the test image and the nearest example in database .",
    "the distance is equal is to 1 if the difference equals @xmath30 .",
    "the distance of penny s image equal 0.21 and equal also 0.66 rad @xmath31 .",
    "[ fig : res4 ]      the advantage of our approach is that we can add the examples to the database according to the use case .",
    "the result is depend on the the examples in the database .",
    "now we take the best case , a database contain all possible examples , we will put all functions ( f1,f2,f3,vase , mozart and penny ) in the database , they generate 23004 examples .",
    "we test to the three images vase , mozart and penny , the average of the distance equal ( 0.0000554 , 0.0004 , 0.027 ) , the results are shown in figures [ fig : res21 ] [ fig : res22 ] [ fig : res23 ] .",
    "[ fig : res21 ]     [ fig : res22 ]     [ fig : res23 ]      in the above results we tested our approach on synthetic images , in which the boundary conditions are known . to test our approach on images without boundary condition , we will use the edge of the object ( there are several methods for detecting the edge ) .",
    "we assume that the projection is perpendicular to the tangent toward the outside .",
    "the results shown in figures [ fig : res31 ] and [ fig : res32 ] are obtained with any additional information .",
    "[ fig : res31 ]      [ fig : res32 ]",
    "most of the local resolution methods does not give a good results , because it is difficult to determine the depth variation from the gray level variation .",
    "the solutions of the local resolution are generally complex . in this work we proposed a simple local resolution method using machine learning .",
    "it gives very acceptable results compared with other local resolution methods .",
    "the advantage of our approach is in the `` learning phase '' .",
    "the examples database can be specialized ( using same object types ) , i.e. we can create a database according to the use case . in the future work we will improve this approach , so that we can test it on more complex images , and minimize the number of constraints .",
    "j. ma p. zhao ; b. gong , a shape - from - shading method based on surface reflectance component estimation .",
    "fuzzy systems and knowledge discovery ( fskd ) , 2012 9th international conference page(s ) : 1690 - 1693 , may 2012    b. kunsberg and s.w .",
    "zucker the differential geometry of shape from shading : biology reveals curvature structure . computer vision and pattern recognition workshops ( cvprw ) , 2012 ieee computer society conference , pages : 39 - 46 , june 2012    w. fan and k. wang and f. cayre and x. zhang 3d lighting - based image forgery detection using shape - from - shading .",
    "signal processing conference ( eusipco ) , 2012 proceedings of the 20th european , page(s ) : 1777 - 1781 , august 2012                      j.d , durou and j.f , aujol integration of a normal field in the case of discontinuities.emmcvpr 09 proceedings of the 7th international conference on energy minimization methods in computer vision and pattern recognition , 2010"
  ],
  "abstract_text": [
    "<S> the aim of shape from shading ( sfs ) problem is to reconstruct the relief of an object from a single gray level image . in this paper </S>",
    "<S> we present a new method to solve the problem of sfs using machine learning method . </S>",
    "<S> our approach belongs to local resolution category . </S>",
    "<S> the orientation of each part of the object is represented by the perpendicular vector to the surface ( normal vector ) , this vector is defined by two angles slant and tilt , such as the tilt is the angle between the normal vector and z - axis , and the slant is the angle between the the x - axis and the projection of the normal to the plane . </S>",
    "<S> the tilt can be determined from the gray level , the unknown is the slant . to calculate the normal of each part of the surface ( pixel ) </S>",
    "<S> a supervised machine learning method has been proposed . </S>",
    "<S> this method divided into three steps : the first step is the preparation of the training data from 3d mathematical functions and synthetic objects . </S>",
    "<S> the second step is the creation of database of examples from 3d objects ( off - line process ) . </S>",
    "<S> the third step is the application of test images ( on - line process ) . </S>",
    "<S> the idea is to find for each pixel of the test image the most similar element in the examples database using a similarity value .     </S>",
    "<S> 0= 0=    integration method , machine learning , needle map , shape from shading . </S>"
  ]
}