{
  "article_text": [
    "binary programs  programs consisting of clauses with at most one atom in the body  appear quite naturally when simulating computations of turing machines by logic programs .",
    "@xcite introduced the concept of binary clauses . since then various binarizing transformations have been defined by @xcite , @xcite , @xcite and by @xcite .",
    "it is not difficult to show that the last three transformations produce programs with identical computational behaviour .    while in the beginning",
    ", binarization was a rather theoretical issue , later , with the advent of prolog compilers for programs consisting of binary clauses , it found important applications .",
    "@xcite built a prolog system called binprolog that makes use of binarization . in a preprocessing phase ,",
    "the prolog program is binarized ( see @xcite ) and the binary program is compiled using binwam , a specialized version of the warren abstract machine for binary programs .",
    "binwam is simpler than wam and the size of the code of the binary program is reduced .",
    "hence , it is of practical use to investigate transformations changing a logic program to an equivalent binary logic program .",
    "it turned out that on some programs , binarization and partial deduction produce programs with a better performance whereas on others , programs with a worse performance are produced .",
    "the goal of this paper is to describe a class of programs for which binarization followed by partial deduction produces programs with a better computational behaviour .",
    "the paper is organized as follows .",
    "section 2 presents the above mentioned transformation of logic programs to binary logic programs .",
    "section 3 deals with the problem of computational efficiency of binarized programs . in section 4 , b - stratifiable programs are introduced and it is proved that the transformation consisting of binarization and partial deduction succeeds on these programs .",
    "this transformation usually leads to a computationally more efficient program .",
    "section 5 gives results and conclusions .",
    "we shall adopt the terminology and notation of @xcite .",
    "let @xmath0 be an atom ,    @xmath1    be ( possibly empty ) sequences of atoms .",
    "we restrict our attention to definite logic programs , that is programs consisting of clauses @xmath2 with the atom @xmath0 in the head and a sequence @xmath3 of atoms in the body .",
    "if @xmath3 is empty , we write simply @xmath4 . a clause is called _ binary _ if it has at most one atom in the body . a program consisting of binary clauses",
    "is called _ binary_.    a _ query _ is a sequence of atoms .",
    "queries are denoted by @xmath5 with possible subscripts .",
    "the _ empty query _ is denoted by @xmath6 .",
    "a computation of a logic program starts from a non - empty query and generates a possibly infinite sequence of queries by sld - resolution steps .",
    "maximal sequences of queries generated by this way are called _ sld - derivations_. finite sld - derivations are _ successful _ if they end with the empty query , otherwise they are _ failed .",
    "_    in what follows , by an _",
    "ld - resolvent _ we mean an sld - resolvent with respect to the leftmost selection rule and by an _ ld - derivation _ we mean an sld - derivation w.r.t .",
    "the leftmost selection rule .",
    "similarly , an _ ld - tree _ is an sld - tree w.r.t . the leftmost selection rule . by _ continuation _",
    "we mean a ( possibly empty ) list of terms representing goals @xcite .",
    "we shall describe the transformation @xcite of definite logic programs to programs consisting of binary clauses .",
    "we define the operator @xmath7 transforming the queries and the clauses of the input program . the resulting binary program is completed by an additional clause @xmath8 .",
    "* definition 2.1 * given a logic program @xmath9 , let @xmath10 be a new unary predicate symbol ,    \\(i ) for a query    @xmath11    to @xmath9 , let    @xmath12)$ ]    in particular , for the empty query , we put @xmath13)$ ] .",
    "\\(ii ) for a clause    @xmath14    let    @xmath15)\\ ; \\leftarrow \\ ; q([b_{1 } , b_{2 } , \\ldots , b_{n}|cont])$ ]    where @xmath16 is a _ continuation variable_. in particular , if @xmath17 is a unit clause , then @xmath15 ) \\leftarrow q(cont)$ ] .",
    "\\(iii ) the clause @xmath8 is @xmath18)\\leftarrow$ ]    \\(iv ) for a program @xmath9 , we put    @xmath19    note that @xmath8 is the only unit clause of the binarized program that provides the step @xmath20 in successful sld - derivations .    * 2.2 example * transformation of a program to its binary form    .... a : - b , c .",
    "q([a|cont ] ) : -   q([b , c|cont ] ) .",
    "b : - d.                 q([b|cont ] ) : -   q([d|cont ] ) . c.                      q([c|cont ] ) : -   q(cont ) .",
    "d.                      q([d|cont ] ) : -   q(cont ) .",
    "q ( [ ] ) . ....    note that    \\(i ) we use a different syntax for prolog programs and for the theory of logic programs , and    \\(ii ) continuation variables have been introduced for binarized programs . in what follows , we will use the term _ continuation variable _ also for variables in binary programs obtained by partial deduction of binarized programs containing clauses such as    .... q_b([a(x,1)|cont ] ) : -   q_e([b(x),c(1)|cont ] ) . ....    let @xmath9 be a program and @xmath5 a query .",
    "then @xmath21 has a successful ld ",
    "derivation with computed answer @xmath22 iff @xmath23 does .",
    "@xmath6    this follows from the fact that for every step of any ld  derivation of @xmath23 , there is a corresponding step of a corresponding ld ",
    "derivation of @xmath21 .",
    "contrary to a natural expectation  that binarization can only slow down the computations of a program because extra arguments and extra computation steps are involved in the transformed program , binarization followed by partial deduction can in some cases speed the computation of a program up significantly .",
    "@xcite was the first to present a case study of such behaviour .    * transformation steps * ( 1 )    we consider the following steps of transformation :    \\1 .",
    "binarization    \\2 . partial deduction with the empty continuation [ ] ( i.e , the empty list ) in the top  level call ( see section 4 )    \\3 . further partial deduction with final optimization steps such as removing duplicate variables @xcite",
    ".    we will show in example 3.1 how the above transformation steps are applied to the ` sameleaves ` program from @xcite .",
    "we are going to investigate programs for which this transformation gives more efficient programs when applied to programs with certain syntactical features and why it leads to programs with identical or worse performance if applied to other programs .",
    "first , we shall recall the ` sameleaves ` program .    *",
    "3.1 example * the program ` sameleaves ` tests whether two binary trees have the same sequence of leaves .",
    "the trees with the same sequence of leaves need not be isomorphic .    * program * ` sameleaves `    ....",
    "sameleaves(leaf(l),leaf(l ) ) .",
    "sameleaves(tree(t1,t2),tree(s1,s2)):-                     getleaf(t1,t2,l , t ) ,                     getleaf(s1,s2,l , s ) ,                     sameleaves(s , t ) .",
    "getleaf(leaf(a),c , a , c ) .",
    "getleaf(tree(a , b),c , l , o):-getleaf(a , tree(b , c),l , o ) . ....    as the first step of transformation ,",
    "we apply the binarizing operator @xmath7 from section [ b_s ] and obtain the following program :    ....          q([sameleaves(leaf(l),leaf(l))|cont]):-q(cont ) .",
    "q([sameleaves(tree(t1,t2),tree(s1,s2))|cont]):-                     q([getleaf(t1,t2,l , t ) ,                     getleaf(s1,s2,l , s ) ,                     sameleaves(s , t)|cont ] )",
    ".          q([getleaf(leaf(a),c , a , c)|cont]):-q(cont ) .          q([getleaf(tree(a , b),c , l , o)|cont]):-                 q([getleaf(a , tree(b , c),l , o)|cont ] ) .          q ( [ ] ) . ....",
    "* * then we perform the steps 2 and 3 . using an automated partial deduction system mixtus @xcite",
    ", we partially deduce the binarized program with the goal    ` q([sameleaves(tree1,tree2 ) ] ) `    where the continuation is empty ( i.e. [ ] ) .    *",
    "* applying steps 1 and 2 , we obtain the following program    ....",
    "sameleaves1(leaf(a ) , leaf(a ) ) .",
    "sameleaves1(tree(a , b ) , tree(c , d ) ) : -                     getleaf1(a , b , c , d ) .",
    "getleaf1(leaf(c),d , a , b ) : -                     getleaf2(a , b , c , d ) .",
    "getleaf1(tree(a , d),e , b , c ) : -                     getleaf1(a , tree(d , e),b , c ) .",
    "getleaf2(leaf(c),a , c , b ) : -                     sameleaves1(a , b ) .",
    "getleaf2(tree(a , d),e , b , c ) : -                     getleaf2(a , tree(d , e),b , c ) . ....",
    "the resulting program is binary and has two specialized predicates for the two calls of ` getleaf ` .",
    "demoen showed that it is faster by approximately 40% .",
    "* * the ` sameleaves ` example is interesting for yet another reason . if we skip binarization and perform only partial deduction on the original non - binary program , we get only an identical copy of the logic program . on the other hand , by binarization and partial deduction w.r.t .",
    "continuation [ ] , that is by adding no information , we get a computationally more efficient binary program by partial deduction .    the program ` frontier ` below computes the frontier , i.e. list of leaves of a binary tree .",
    "it serves as an example where the above described steps of binarization and partial deduction do not give any significant improvement .",
    "* 3.2 example * ` frontier `    ....          frontier(leaf(x),[x ] ) .",
    "frontier(tree(left , right),res):-                     frontier(left , l1 ) ,                     frontier(right , r1 ) ,                     append(l1,r1,res ) . ....",
    "if we perform the above steps on this program , we do not get a computationally more efficient program .",
    "its performance is worse in terms of time and space .",
    "the length of the program obtained by binarization and partial deduction is significantly larger .",
    "it is so due to the fact that the partial deduction system can not remove calls with a free continuation variable such as    ....    q1([append([],b , b)|",
    "cont]):- q(cont ) . ....",
    "* 3.3 definition * we say that the binarization and partial deduction transformation consisting of steps 1 , 2 and 3 _ succeeds _ if it terminates and eliminates all continuation variables in steps 1 and 2 .",
    "in this section , we will define the class of b - stratifiable programs , prove that for this class of programs the transformation consisting of steps 1 and 2 succeeds ( i.e. it eliminates continuation variables . )    * 4.1 definition * we say that a program @xmath9 is _ b - stratifiable _ if there is a partition of the set of all predicates of @xmath9 into disjoint sets    @xmath24 ( 2 )    called _ strata _ , such that    \\(i ) if there is a clause @xmath17 such that a predicate symbol @xmath25 , @xmath26 occurs in the head of @xmath17 and a predicate @xmath27 occurs in the body of the same same clause @xmath17 , then @xmath28 , i.e. , @xmath10 belongs to a lower or the same stratum , and    \\(ii ) in any clause @xmath29 of @xmath9 where the predicate symbol @xmath25 belongs to @xmath30 from the head @xmath0 there is at most one predicate symbol @xmath10 from the same stratum @xmath31 in the body . in this case",
    ", @xmath10 is the predicate symbol of the rightmost atom in .",
    "then the set of strata ( 2 ) is called a _",
    "b  stratification _ of @xmath9 .",
    "@xmath6    * 4.2 example * program    `          p : - q , p . `    `          q : - r , r . ` ( 3 )    `          r. `    `          r : - q. ` ( 4 )    is not @xmath32-stratifiable because ` q`,`r ` are mutually dependent and hence in the same stratum , but in the body of ( 3 ) there are two calls to ` r ` .",
    "if we remove the clause ( 4 ) , the program becomes @xmath32-stratifiable .",
    "it suffices to take the b ",
    "stratification @xmath33 .",
    "it is easy to check that the program ` sameleaves ` is @xmath32-stratifiable while the program ` frontier ` is not .",
    "note that the notion of b ",
    "stratifiable programs includes several classes of programs .",
    "it can be proved that e.g. _ non  recursive _ and _ binary _ programs are b  stratifiable . as for _ tail",
    " recursive _ programs , in the literature we found no mathematical definition but the notions tail  recursive and b  stratifiable are similar .",
    "we will show that on @xmath32-stratifiable programs , the transformation consisting of binarization and partial deduction succeeds .",
    "@xmath32-stratifiable programs can be transformed with binarization and partial deduction into binary programs that are free of continuation variables  and usually more efficient .",
    "this is due to the fact that the number of terms representing goals in continuations is bounded .",
    "we shall show that for every b ",
    "stratifiable program @xmath9 and a query @xmath5 , a there is partial deduction of @xmath34 w.r.t .",
    "@xmath35 such that the resulting program does not contain any continuation variables .",
    "in order to do this we shall introduce a simple partial deduction alogorithm and prove that it terminates on b ",
    "stratifiable programs , giving a new program without continuation variables .",
    "intuitively , we shall compute a partial deduction of @xmath34 w.r.t . a set @xmath36 .",
    "as the program @xmath37 is binary , we can use an instance of the general partial deduction @xcite to remove the continuation variables . to this purpose , it is sufficient to compute ( incomplete ) ld - trees to the depth one .",
    "( a similar technique has been used in @xcite ) .    to make sure that the conditions of so called @xmath38closedness and independence of @xmath36 hold to guarantee termination and that the partially deduced program computes the same set of answer substitutions , we use the following generalization operator .    * 4.3 definition",
    "* we define _ generalization operator @xmath39_. let    @xmath40    be a general ( non - binary ) query and    @xmath41)$ ] the respective binarized query .",
    "we put    @xmath42)$ ] where @xmath43 are new variables .",
    "in particular , @xmath44 ) ) \\equiv q([\\,])$ ] .",
    "note that @xmath45 is an instance of @xmath46 .",
    "furthermore , we will extend @xmath39 so that it will be applied to sets of binarized queries and atoms .",
    "if @xmath36 is a set of binarized queries , we put @xmath47 .    * 4.4 algorithm 1 *    * input : * binarized program @xmath37 and the set @xmath48 , where @xmath9 is a program and @xmath5 a query .",
    "* output : * a program @xmath49 with no continuation variables , a set @xmath36 , a new query @xmath50 .",
    "i. @xmath51 ,    @xmath52 ,    @xmath53    \\ii .",
    "* while * @xmath54 * do *    \\a ) take an atom @xmath55 ;    @xmath56 ;    \\b ) compute partial deduction of @xmath57 obtaining an incomplete ld - tree of depth 1 ( i. e. perform one unfolding step )    @xmath58 the set of resultants .",
    "@xmath59 the set of bodies of resultants from @xmath60 .",
    "it follows from the fact that the program @xmath37 is binary , that all elements of @xmath32 are atoms .",
    "\\c ) @xmath61 ;    @xmath62 ;    \\iii . *",
    "renaming * we shall define an operator @xmath63 which renames each atom    @xmath64)$ ]    in @xmath65 to    @xmath66    obtaining the program @xmath49 and the new query @xmath67 .",
    "@xmath6    we can see that the continuation variables have been eliminated by algorithm  1 . to show that",
    ", we can verify that the following invariant holds during the computation of algorithm  1 and that algorithm  1 will terminate .    * 4.5 invariant * no clause in @xmath65 contains a free continuation variable .",
    "now we come to the main result of this section :    * 4.6 theorem * let @xmath9 be a @xmath32-stratifiable program and @xmath5 a query . then    \\1 .",
    "algorithm  1 terminates on the input @xmath34 , @xmath48 .",
    "let @xmath49 be the output program of algorithm 1 .",
    "then @xmath68 has an ld - derivation with a computed answer @xmath22 iff @xmath23 does .",
    "_ proof _ we will need a definition and two lemmas that will enable us to prove termination of the algorithm .    * 4.7 definition",
    "* let @xmath9 be a logic program , @xmath69 an atom and let    @xmath70    be a sequence of atoms .",
    "let    @xmath71    be an ld - resolution step of @xmath72 where @xmath3 denotes a ( possibly empty ) conjunction .",
    "we say that each atom @xmath73 is an _ immediate successor _ of @xmath69 and write @xmath74 .",
    "let @xmath75 be the reflexive and transitive closure of the immediate successor relation @xmath76 .",
    "if @xmath77 , we say that @xmath32 is a _",
    "successor _ of @xmath69 .    * 4.8 lemma * let @xmath9 be a @xmath32-stratifiable logic program , let    @xmath78 ( 5 )    be a b  stratification of @xmath9 and let @xmath79 be the maximum number of atoms in the body of a clause from @xmath9 and let @xmath80 be a query and @xmath81 be an arbitrary ld - derivation of @xmath23 .",
    "then    \\(i ) each atom @xmath82 , has at most @xmath83 successors in every ld - resolvent of @xmath81 .",
    "\\(ii ) for each query @xmath50 of at most @xmath84 atoms , the number of atoms in any ld  resolvent of @xmath85is at most @xmath86 . hence there is a bound on the number of atoms in ld  resolvents of @xmath23 .",
    "( i ) in general , if @xmath69 is an atom with a predicate symbol from a stratum @xmath87 ,    @xmath88 then @xmath69 has at most @xmath89 successors in every ld - resolvent in @xmath81 .",
    "hence @xmath83 is a bound on the number of successors of an arbitrary atom in every ld - resolvent in @xmath81 .",
    "\\(ii ) follows from ( i).@xmath6    note that the number of elements of a continuation in any ld - resolvent of the binarized program @xmath90 is equal to the number of atoms of the corresponding ld - resolvent of @xmath91 minus 1 because for any ld - resolvent @xmath92 of @xmath23 , the corresponding continuation in the binarized program is @xmath93 $ ] .",
    "* 4.9 lemma * let @xmath94 be a program and let @xmath95 be a query .",
    "assume that there is a bound on the number of atoms in all continuations in computations of @xmath96 .",
    "then there is a bound on the number of sequences of predicate symbols in continuations that occur in computations of @xmath96 , too .",
    "@xmath6    _ proof of termination of algorithm 1 _    algorithm 1 terminates if the set @xmath97 of goals for partial deduction is empty .",
    "the elements of this set are atoms obtained by application of the generalization operator @xmath39 .",
    "to guarantee the so called @xmath38closedness condition of partial deduction ( see @xcite ) , each goal evaluated by partial deduction is removed from @xmath97 and is put to @xmath36 .",
    "the goals from the set @xmath98 are added to @xmath97 , where @xmath32 is the set of goals from the bodies of resultants obtained by partial deduction .",
    "it follows from the definition of @xmath39 that it maps any two goals with the same sequence of predicate symbols to the same atom .",
    "it follows also that s is independent .",
    "we assumed that @xmath9 is a @xmath99stratifiable program , hence it follows from lemma 4.8 and 4.9 that there is a bound on the number of sequences of predicate symbols in continuations that occur in any resultant obtained by partial deduction of @xmath100 , where @xmath101 is a goal from @xmath97 .",
    "it turns out that after a finite number of steps , @xmath97 is empty and the computation of the algorithm terminates .",
    "_ equivalence of computed answer substitutions .",
    "_    first , by lemma 2.3 we can see that @xmath21 has a successful ld ",
    "derivation with computed answer @xmath22 iff @xmath23 does .",
    "second , since @xmath102 is @xmath36closed and @xmath36 is independent , it follows from theorem 4.2 of @xcite that the resulting program @xmath103 has the same computed  answer substitutions as the binarized program @xmath104 .",
    "third , it is easy to see that the same holds for the renamed    @xmath105 .",
    "@xmath6    once we have obtained a binary program without the continuation variables , further partial deduction can be performed without a limitation on the depth of ld trees . that partial deduction can improve performance of the program .",
    "further improvement may be obtained by the raf procedure @xcite , @xcite .",
    "now we discuss the question whether b  stratifiable programs are exactly those on which this transformation succeeds , i.e. whether for every non b ",
    "stratifiable program , the binarization and partial deduction fail to eliminate continuation variables .    due to the fact that algorithm 1 abstracts w.r.t .",
    "predicate symbols only and disregards terms , there are non  b  stratifiable programs for which the transformation still succeeds . for example , if we add the following clause to the ` sameleaves ` program , we obtain a program which is not b - stratifiable but the transformation described in example 3.1 still may succeed when applied to it :    .... getleaf(1,2,3,4 ) : - getleaf(5,6,7,8 ) , getleaf(9,10,11,12 ) .",
    "....    this clause which caused that the program became non ",
    "b  stratifiable is in fact never used in ld ",
    "resolution for the query ` sameleaves(x , y ) ` .",
    "on the other hand , we will give a sufficient condition for programs for which the transformation does not succeed .",
    "we can show that for non ",
    "b  stratifiable programs for which the continuation can grow arbitrarily , algorithm  1 does not terminate .",
    "this class of programs is large enough to include most of reasonable non ",
    "b  stratifiable programs .",
    "the idea of this proposition is analogous to the idea of theorem 4.6 .    *",
    "4.10 proposition * suppose that a program @xmath9 is not b  stratifiable , @xmath17 is a clause of @xmath9 containing a recursive call not in the last position in the body , and let there be an atomic query @xmath5 such that there is a successful ld ",
    "derivation for @xmath23 in which @xmath17 is used at least once .    then algorithm  1 does not terminate with inputs @xmath106 and @xmath46 .    _ proof _    let @xmath107 be the recursive clause from the assumptions of the proposition and let @xmath108 and @xmath3 be sequences of atoms such that @xmath3 is not empty . assume that the conditions of proposition 4.10 hold .",
    "we shall proceed by contradiction .",
    "assume that algoritm 1 with inputs @xmath106 and @xmath46 terminates .    as there is a successful ld  derivation which uses the clause @xmath17 , algorithm 1",
    "will also use the binarized clause @xmath109 and add the atom    @xmath110)$ ]    to the set @xmath111 note that due to the generalization operator , @xmath3 is an instance of @xmath112 and @xmath108 is an instance of @xmath113 .",
    "it follows from the assumption that algorithm 1 with the given inputs terminates , that it will make empty the set @xmath114 .",
    "hence , after a finite number of steps of the algorithm 1 , an atom    @xmath115)$ ]    will be added to the set @xmath114 .",
    "this atom will later be selected for unfolding and using the clause @xmath109 , an atom    @xmath116)$ ]    will be added to the set @xmath114 .",
    "this process is repeated infinitely many times and algoritm 1 does not terminate , a contradiction .",
    "this completes the proof of proposition 4.10 .",
    "@xmath117    * 4.11 example * for the program ` frontier ` , its only recursive clause and the query ` front(x , y ) ` which meet the assumptions of this proposition , the following atoms are added to the set @xmath97 :    .... q([front(x1,x2 ) ] ) , q([front(x1,x2),front(x3,x4),append(x5,x6,x7 ) ] ) , q([front(x1,x2),front(x3,x4),append(x5,x6,x7),front(x8,x9 ) ,      append(x10,x11,x12 ) ] ) , q([front(x1,x2),front(x3,x4),append(x5,x6,x7),front(x8,x9 ) ,      append(x10,x11,x12),front(x13,x14),append(x15,x16,x17 ) ] ) ........ ....    hence the size of atoms that are added to the set @xmath97 grows indefinitely and algorithm  1 does not terminate .",
    "we will present results of our experiments with binarization and partial deduction and give some comparison .",
    "it may seem that the class of b  stratifiable programs is relatively small .",
    "nonetheless , some transformations transform programs into b ",
    "stratifiable programs , improve the efficiency of the program significantly and allow for further binarization and partial deduction .",
    "we have experimented with a set of programs taken from @xcite , @xcite , @xcite and @xcite .",
    "we used sicstus prolog 3.8 running on a linux workstation and test data of reasonable size .",
    "the first column of the table gives the name of the program , the second through the fourth columns give the respective speedups induced by binarization , partial deduction ( algorithm 1 ) and final optimization .",
    "( speedup greater than 1 means the transformed program was faster . )",
    "the first column of the table gives the name of program , the second one gives ratio of run ",
    "time for the output of conjunctive partial deduction system ecce and binarization with partial deduction ( greater than 1 means that binarization with partial deduction was faster . )",
    "the output programs are similar yet not always identical ( for the ` sameleaves ` profram ecce produced the same progragram as binarization with partial deduction . ) for most programs , ecce produced faster output . in some cases this is owed to its flexible computation rule ( e.g. double - append . )      while classical partial deduction can not handle conjunctions ( as needed e.g. for the ` sameleaves ` program ) , binarization followed by partial deduction can not use flexible selection rule ( as in the ` doubleappend ` program ) or split a conjunction in more parts , conjunctive partial deduction is the strongest of these transformation techniques .",
    "demoen , b. ( 1992 ) on the transformation of a prolog program to a more efficient binary program . in kung - kiu lau and tim clement ( eds . ) , _ proceedings of lopstr 92 , international workshop on logic program synthesis and transformation , university of manchester ,",
    "_ workshops in computing series , springer 1993 , pp",
    ". 242252 .",
    "de schreye , d. , glck , r. , jrgensen , j. , leuschel , m. , martens , b. , srensen , m. h. ( 1999 ) conjunctive partial deduction : foundations , control , algorithms and experiments . _ journal of logic programming _ * 41 * , 231277 .",
    "gallagher , j. p. and bruynooghe , m. ( 1990 ) some low  level source transformations for logic programs . in _ proceedings of meta90 workshop on meta programming in logic _ , katholieke universiteit leuven , belgium , 1990 .",
    "hr23uza , j. and tpnek , p. ( 2000 ) binary speed up for logic programs . in john w. lloyd ,",
    "vernica dahl , ulrich furbach , manfred kerber , kung - kiu lau , catuscia palamidessi , lus moniz pereira , yehoshua sagiv , peter j. stuckey ( eds . ) , _ computational logic - cl 2000 , first international conference , london 2000 , proceedings , _ lncs 1861 , springer , pp .",
    "116130 .",
    "leuschel , m. and srensen , m. h. ( 1996 ) redundant arguments filtering of logic programs . in john",
    "gallagher ( ed . ) , _ logic program synthesis and transformation , proceedings of the 6th international workshop , lopstr96 , stockholm _ , lncs 1207 , springer , pp .",
    "83103 .",
    "pettorossi , a. and proietti , m. ( 1997 ) flexible continuations in logic programs via unfold / fold transformatios and goal generalization . in o.",
    "danvy ( ed . ) _ proceedings of the acm sigplan workshop on continuations , 1997 _ , brics notes n69313 .",
    "sagonas , k. f. and warren , d. s. ( 1995 ) efficient execution of hilog in wam  based prolog implentations . in leon sterling ( ed . ) , _ proceedings if the twelfth international conference on logic programming , _ mit press , 1995 , pp .",
    "349363 .",
    "tpnkov , o. and tpnek , p. ( 1989 ) stratification of definite clause programs and of general logic programs , _ proc .",
    "csl 89 , third workshop on computer science logic , kaiserslautern , germany , 1989 _ , lncs 440 , springer - verlag , berlin , pp ."
  ],
  "abstract_text": [
    "<S> binary logic programs can be obtained from ordinary logic programs by a binarizing transformation . in most cases , </S>",
    "<S> binary programs obtained this way are less efficient than the original programs . </S>",
    "<S> ( demoen , 1992 ) showed an interesting example of a logic program whose computational behaviour was improved when it was transformed to a binary program and then specialized by partial deduction .    the class of b - stratifiable logic programs is defined . </S>",
    "<S> it is shown that for every b - stratifiable logic program , binarization and subsequent partial deduction produce a binary program which does not contain variables for continuations introduced by binarization . </S>",
    "<S> such programs usually have a better computational behaviour than the original ones </S>",
    "<S> . both binarization and partial deduction can be easily automated . </S>",
    "<S> a comparison with other related approaches to program transformation is given . </S>"
  ]
}