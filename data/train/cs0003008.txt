{
  "article_text": [
    "knowledge base is always subject to change since an environment around the knowledge base is not guaranteed to be stable forever and even some error might be included at the initial stage .",
    "therefore , study of revision of knowledge base is very important@xcite . @xcite and",
    "@xcite consider a revision of monotonic theories and there are a lot of researches in this direction ( see  @xcite for a survey ) .",
    "@xcite and @xcite consider an update of nonmonotonic theories to derive a given goal or a given observation . @xcite and",
    "@xcite consider a revision of nonmonotonic theories which is more related to a revision of monotonic theories studies  @xcite ; they consider a revision when inconsistency arises at addition of rules   in this paper , we follow the latter approach .    revision of nonmonotonic theories is especially important for ai , since it is very rare that commonsense reasoning can be represented as a monotonic theory .",
    "however , revision of nonmonotonic theories is more complicated than revision of monotonic theory . in monotonic theory ,",
    "if some addition of knowledge or observation leads to inconsistency , then we can avoid inconsistency by deleting a part of knowledge base . on the other hand",
    ", we might add a piece of assumptions since deletion leads to inconsistency .",
    "consider the following program .",
    "@xmath0    @xmath1    @xmath2    @xmath3 means `` negation as failure '' .",
    "the first rule says that if @xmath4 is a car and @xmath4 is not known to be broken , @xmath4 should run . since there is no information about @xmath5 and @xmath6 in the current program , @xmath7 and @xmath8 are derived .",
    "suppose , however , that we add a rule `` @xmath9 '' meaning that car @xmath10 does not run   means contradiction . ] .",
    "then , we have no stable model , that is , we are in an inconsistent situation . to fix this inconsistency , we have ( at least ) two possible ways .    1 .",
    "we simply discard the default rule of car @xmath10 : @xmath11 2 .",
    "we derive @xmath5 since if we assumed @xmath12 , then contradiction would occur and thus , we have a reason to assume @xmath5 .    the first revision is contraction widely used in belief revision of monotonic theories  @xcite but the second is special for nonmonotonic theories such as normal logic programs . in monotonic theories ,",
    "addition of formula can not help to restore consistency , but in nonmonotonic theories addition can help .",
    "this phenomena were firstly observed in doyle s justification tms and he introduced _",
    "dependency - directed backtracking_. moreover , in monotonic theories , contraction or deletion of formula can not produce any inconsistency , whereas in nonmonotonic theories , deletion can cause inconsistency .    therefore , we need more functions for revision in nonmonotonic theories than monotonic ones . in this paper",
    ", we propose a top - down procedure using abduction to compute revision for a normal logic program when there exists no stable model .",
    "our idea of using abduction for revision is as follows .",
    "we introduce two kinds of abducibles one of which represents a deletion of each retractable rule and the other of which represents an addition of each addable rule . for a retractable rule , we add negation of a corresponding abducible in the body of the rule so that if an instance of abducible is assumed then an instance of rule corresponding with the instance of abducible is no longer applicable . for an addable rule ,",
    "we add a corresponding abducible in the body of the rule so that if an instance of abducible is assumed then an instance of rule corresponding with the instance of abducible becomes applicable .",
    "then , in order to compute such abducibles to specify revision , we show that we can use a modification of satoh and iwayama s query evaluation procedure on stable models  @xcite which is a combination of integrity constraint checking  @xcite and abductive procedure  @xcite . in stead of starting with a subprocedure which show a derivation of positive literals , we start with a subprocedure for rule consistency checking to derive abducibles to specify revision",
    ". this procedure traverses rules of a program which is related with addition or deletion of a rule and we guarantee that a minimal revision can be found by selecting a minimal set of abducibles among all the sets of abducibles computed by the rule consistency checking procedure .",
    "firstly , we define a revision framework as follows . in this paper , we consider a function - free normal logic program .",
    "we use domain closure axiom and unique name axiom so that constants in the language for a program are finite and denote distinct objects .",
    "we can easily extend our results to function - free extended logic programs by translating an extended logic program into a normal logic program proposed by  @xcite .    a _ rule _ @xmath13 is of the form : @xmath14 where @xmath15 , @xmath16 are atoms .",
    "we call @xmath15 the _ head _ of the rule @xmath13 denoted as @xmath17 and @xmath18 the _ body _ of the rule denoted as @xmath19 . if @xmath20 , we sometimes call the rule an _ integrity constraint_.    let @xmath21 and @xmath22 be sets of rules . a _ revision framework _ @xmath23 is a pair , @xmath24 where @xmath21 can be divided into two sets of rules @xmath25 and @xmath26 .",
    "we call @xmath25 a _ persistent part _ of @xmath23 and @xmath26 a _ temporal part _ of @xmath23 and @xmath22 a _ backup part _ of @xmath23 .",
    "@xmath21 expresses the current logic program which consists of @xmath25 and @xmath26 .",
    "@xmath25 is an unchanged part which should always be satisfied such as integrity constraints whereas any part of @xmath26 can be retracted and any part of @xmath22 can be added to restore consistency .",
    "usage of @xmath22 is inspired by back - up semantics proposed by  @xcite .",
    "we use stable model semantics for the above program .",
    "let @xmath27 be sets of rules .",
    "we denote a set of ground rules obtained by replacing all the variables in every rule of @xmath27 by every element in the language as @xmath28 .",
    "let @xmath29 be a set of ground atoms and @xmath30 be the following program .",
    "@xmath31 @xmath32    @xmath33 and @xmath34 for each @xmath35 let @xmath36 be the least model of @xmath30 .",
    "a _ stable model _ for a logic program @xmath27 is @xmath29 iff @xmath37 and @xmath38 .",
    "we say that @xmath27 is consistent if @xmath27 has a stable model .",
    "now , we define a revised program in a revision framework .",
    "[ revisedprogram ] let @xmath23 be a revision framework , @xmath39 .",
    "let @xmath40 be a rule .",
    "then , a _ revised program _ w.r.t . @xmath23 and @xmath40 is @xmath41 such that    * @xmath42 * @xmath43 * @xmath41 is consistent .",
    "we say for such @xmath44 and @xmath45 that a pair _",
    "@xmath46 accomplishes revision of @xmath40 to @xmath23_.    a _ minimally revised program _",
    "w.r.t . @xmath23 and @xmath40 is @xmath41 such that there is no revised program @xmath47 such that @xmath48 and @xmath49 where @xmath50 is a strict inclusion .",
    "[ revision ] let + @xmath25 be @xmath51 and + @xmath26 be @xmath52 and + @xmath22 be @xmath53 and + @xmath40 be `` @xmath54 '' .",
    "+ then , @xmath55 @xmath56 , + and @xmath57 @xmath58 .    for the above revision",
    ", we have the following two minimally revised programs :    1 .   a program accomplished by @xmath59 where @xmath60 and @xmath61 : + @xmath62 and @xmath63 2 .   a program accomplished by @xmath64 where",
    "@xmath65 and @xmath66 + @xmath62 and @xmath26 and @xmath67    there are other non - minimally revised programs , for example , one accomplished by @xmath68 or by @xmath69 .    in the above example",
    ", we follow giordano s approach  @xcite where contrapositives of default rules are in the back - up part , but we can actually assume any rules which we think are appropriate for back - up rules when inconsistency occurs .    to compute a revised program , we use a translation from a specification to an abductive logic program and compute a consistent generalized stable model for the translated program which denotes deletion and addition of rules .",
    "an _ abductive framework _ is a pair @xmath70 where @xmath71 is a set of predicate symbols , called _ abducible predicates _ and @xmath27 is a set of rules each of whose head is not in @xmath71 .",
    "we call a ground atom for a predicate in @xmath71 _ an abducible_.    the semantics of abductive framework is based on a generalized stable model  @xcite .",
    "the following is a definition of a generalized stable model which can manipulate abducibles in abductive logic programming .",
    "let @xmath70 be an abductive framework and @xmath72 be a set of abducibles .",
    "a _ generalized stable model _",
    "@xmath73 is a stable model of @xmath74 .",
    "we say that a model @xmath73 is a _ generalized stable model with a minimal set of abducibles _",
    "@xmath72 if there is no generalized stable model @xmath75 such that @xmath76 is a proper subset of @xmath72 .",
    "now , we define a translation of a revision framework into an abductive framework as follows .",
    "let @xmath23 be a revision framework @xmath39 .",
    "we firstly give a name to every rule in @xmath26 and @xmath22 such as @xmath77 where @xmath78 is a name for the rule .    a _ translation for a consistency management of @xmath23 _ ( denoted as @xmath79 )",
    "is a set of the following translation from @xmath23 to an abductive framework @xmath70 where    * @xmath80 is a name of a rule in @xmath81 @xmath82 is a name of a rule in @xmath83 * we add every rule in @xmath25 into @xmath27 .",
    "* we translate every rule in @xmath26 with a name @xmath78 @xmath84 into the following rule in @xmath27 : @xmath85 where @xmath86 is a tuple of variables in the clause .",
    "* we translate every rule in @xmath22 with a name @xmath78 @xmath84 into the following rule in @xmath27 : @xmath87    the following shows that an revised program corresponds with a generalized stable model .",
    "[ deltheorem ] let @xmath23 be a revision framework @xmath39 and @xmath40 be an added clause .",
    "@xmath88 is a ( minimally , resp . )",
    "revised program if and only if there is a generalized stable model of @xmath89 with a ( minimal , resp . )",
    "set of abducibles @xmath72 s.t .    * @xmath90 + where @xmath78 is a name of @xmath91 . * @xmath92 + @xmath93 + where @xmath78 is a name of @xmath94 @xmath95 + @xmath96 + @xmath97 where @xmath78 is a name of @xmath98 + and @xmath99 + and @xmath100    we say that _ @xmath72 ( minimally , resp . ) realizes revision of @xmath40 to @xmath23 .",
    "_    note that in the above theorem , we delete whole rules related to inconsistency and then add modified rules with negation of conjunctions of disequality in the body of the deleted rules .",
    "the modified rules are logically equivalent to rules in definition  [ revisedprogram ] since we assume domain closure axiom and unique name axiom .",
    "[ translation ] consider the revision framework in example  [ revision ] .",
    "let us give names to the rules in @xmath26 and @xmath22 as follows :    @xmath101    @xmath102 +    then @xmath103 is :    * @xmath104 .",
    "* @xmath27 becomes as follows : + @xmath105 + @xmath106 + @xmath54 .",
    "+ @xmath107 + @xmath108 +    then , we have two generalized models with minimal abducibles :    1 .   @xmath109 .",
    "then , a minimally revised program is : + @xmath62 and @xmath110 2 .",
    "then , a minimally revised program is : + @xmath62 and @xmath26 and @xmath67",
    "to compute a revision , it is sufficient to compute a generalized stable model of @xmath112 .",
    "but , if we concern a minimal revision , we need to compute all the generalized stable models and then compare sets of abducibles in these models to choose minimal sets of abducibles . for this purpose",
    ", it is desirable to restrict sets of abducibles to be compared as small as possible .",
    "this can be done if we compute only revision related to @xmath40 .",
    "for example , suppose that some of temporary rules are not relevant to inconsistency of addition of @xmath40 .",
    "if we naively compute all the generalized stable models , then we have to compare all the combination of in / out of abducibles for these irrelevant rules .    in order to avoid this kind of redundancy",
    ", we modify satoh and iwayama s query evaluation procedure on stable models  @xcite .",
    "basically , we change the order of application of subprocedures so that we can use the procedure for consistency checking .",
    "we impose rules in a revision framework must be _ range - restricted _ , that is , any variable in a rule @xmath13 must occur in @xmath113 .",
    "however , any rule can be translated into range - restricted form by inserting a new predicate `` @xmath114 '' describing herbrand universe for every non - range - restricted variable in the rule .    before showing our procedure to compute revision",
    ", we need the following definitions .",
    "let @xmath115 be a literal .",
    "then , @xmath116 denotes the complement of @xmath115 .",
    "let @xmath27 be a logic program .",
    "a set of resolvents w.r.t . a ground literal @xmath115 and @xmath21",
    ", @xmath117 is the following set of rules : @xmath118    @xmath119 @xmath115 is negative and    @xmath120 and @xmath121 by a ground substitution @xmath122    @xmath123    @xmath120 and @xmath124 by a ground substitution @xmath125    let @xmath27 be a logic program .",
    "a set of deleted rules w.r.t .",
    "a ground literal @xmath115 and @xmath27 , @xmath126 , is the following set of rules : @xmath127 @xmath128 and @xmath129 by a ground substitution @xmath125    let @xmath27 be a logic program and @xmath130 be an abducible - and - negation - removed program obtained by removing all integrity constraints in @xmath27 and all the negative literals and abducibles in the body of remaining rule and @xmath131 be the least minimal model of @xmath130.we define a _",
    "relevant ground program _",
    "@xmath132 for @xmath27 as follows : @xmath133 @xmath134    we briefly explain our procedure .",
    "our procedure consists of 4 subprocedures , @xmath135 , @xmath136 , @xmath137 , and @xmath138 where @xmath139 is a non - abducible atom and @xmath140 is a set of ground literals already assumed and @xmath115 is a ground literal and @xmath13 is a rule .",
    "@xmath135 , @xmath137 , and @xmath138 return union of @xmath140 and a set of ground literals which are assumed during the execution of the subprocedures .",
    "@xmath136 return the above union and a substitution for @xmath139 which are made during the execution of @xmath136 .    in the procedure , we have a * select * operation and a * fail * operation .",
    "the * select * operation expresses a nondeterministic choice among alternatives .",
    "the * fail * operation expresses immediate termination of an execution with failure .",
    "therefore , a procedure succeeds when its inner calls of subprocedures do not encounter * fail*. we say _ a subprocedure succeeds with ( a substitution @xmath141 and ) a set of assumptions @xmath140 _ when the subprocedure successfully returns ( @xmath141 and ) @xmath140 .",
    "our procedure firstly starts from @xmath142 .",
    "@xmath142 checks the consistency of a rule @xmath40 with a program @xmath143 .",
    "we can show the consistency of addition of @xmath40 by showing one of the following .    1 .",
    "a literal @xmath115 in @xmath144 can be falsified .",
    "to do so , we invoke subprocedure @xmath145 for @xmath116 .",
    "every positive literal @xmath139 in @xmath144 can be made true and every negative and every abducible literal @xmath115 can be consistently assumed and @xmath146 consistent .",
    "to do so , we invoke subprocedure @xmath147 for @xmath139 and @xmath145 for @xmath115 and @xmath146 .",
    "the informal specification of the other 3 subprocedures is as follows .",
    "1 .   [ literalcon ] @xmath137 checks the consistency of a ground literal @xmath115 with @xmath143 and @xmath140 . to show the consistency for assuming @xmath115",
    ", we add @xmath115 to @xmath140 ; then , we check the consistency of resolvents and deleted rules w.r.t . @xmath115 and @xmath143 .",
    "2 .   @xmath136 searches a rule @xmath13 of @xmath139 in a program @xmath143 whose body can be made true with a ground substitution @xmath141 under a set of assumptions @xmath140 . to show that every literal in the body can be made true , we call @xmath147 for non - abducible positive literals in the body",
    ". then , we check the consistency of other literals in the body with @xmath143 and @xmath140 .",
    "note that because of the range - restrictedness , other literals in @xmath13 become ground after all the calls of @xmath147 for non - abducible positive literals .",
    "@xmath138 checks if a deletion of @xmath13 does not cause any contradictions with @xmath143 and @xmath140 . to show the consistency of the implicit deletion of @xmath13 , it is sufficient to prove that the head of every ground instance @xmath148 in @xmath149 can be made either true or false .",
    "@xmath135 @xmath13 : a rule ; @xmath140 : a set of literals    * begin *    @xmath150 , @xmath151    ground rule @xmath152 * do *    case ( a ) or case ( b )    \\(a ) * select * @xmath153    @xmath154 and    @xmath155 succeeds with @xmath156    @xmath157 and * continue *    @xmath158 and    @xmath159 succeeds with @xmath160    @xmath157 and * continue *    \\(b ) @xmath161 , @xmath162    @xmath153 * do *    @xmath163    and @xmath164 succeeds with ( @xmath165 )    @xmath166 and * continue *    @xmath167    and @xmath168 succeeds with @xmath169    @xmath166 and * continue *    @xmath170 succeeds with @xmath156    @xmath157 and * continue *    @xmath171    * end * ( @xmath172 )    @xmath137 @xmath115 : a ground literal ; @xmath140 : a set of literals    * begin *    @xmath173 * then * * return * @xmath140    @xmath174 or @xmath175 * then * * fail *    @xmath176 , @xmath151    @xmath177 * do *    @xmath178 succeeds with @xmath156    @xmath157 and * continue *    @xmath179 * do *    @xmath180 succeeds with @xmath156    @xmath157 and * continue *    @xmath181    * end * ( @xmath145 )    @xmath136 @xmath139 : a non - abducible atom ; @xmath140 : a set of literals    * begin *    @xmath139 is ground and @xmath182 * then * * return * @xmath183    @xmath139 is ground and @xmath184 * then * * fail *    @xmath185    s.t . @xmath17 and @xmath139 are unifiable with an mgu @xmath141    such a rule is not found * then * * fail *    @xmath186 , @xmath187 , @xmath188 , @xmath151    @xmath189 * do *    take a literal @xmath115 in @xmath190    @xmath191 succeeds with ( @xmath192 )    @xmath193 , @xmath194 ,    @xmath157 and * continue *    @xmath195    @xmath196 * do *    @xmath197 succeeds with @xmath156    @xmath157 and * continue *    @xmath198 succeeds with @xmath199    @xmath200    * end * ( @xmath147 )    @xmath138 @xmath13 : a rule ; @xmath140 : a set of literals    * begin *    @xmath173 * then * * return * @xmath140    @xmath150 , @xmath151    ground rule @xmath201 * do *    case ( a ) or case ( b )    \\(a ) * if * @xmath202 succeeds with @xmath160    @xmath157 and * continue *    \\(b ) * if * @xmath203 succeeds with    @xmath156    @xmath157 and * continue *    @xmath171    * end * ( @xmath204 )    now , we describe a complete specification of the subprocedures in figure  [ ruleconandliteralcon ] and figure  [ deriveanddeletedcon ] . in figures ,",
    "we denote a set of non - abducible positive literals , non - abducible negative literals , and abducibles ( either negative or positive ) in a rule @xmath13 as @xmath113 , @xmath205 and @xmath206 respectively , and we denotes empty substitution as @xmath207 , and @xmath208 expresses a composition of two substitutions @xmath209 and @xmath210 .    the following theorem on correctness for rule checking can be derived from correctness on query evaluation procedure of  @xcite .",
    "[ rulecheck ] let @xmath70 be a consistent abductive framework .",
    "suppose @xmath142 succeeds for @xmath27 with @xmath140 , then there is a generalized stable model @xmath73 for @xmath211 such that @xmath72 includes positive abducibles in @xmath140 .",
    "par the above theorem only guarantees that @xmath13 is consistent with @xmath27 and the procedure produces _ some _ abducibles included in a generalized stable model . to compute revision , however , we must have the stronger result that @xmath140 includes all the necessary @xmath212 s and @xmath213 s .",
    "actually , we can guarantee this by the following theorem .",
    "let @xmath23 be a revision framework @xmath214 such that @xmath215 is consistent and @xmath40 be an added rule .",
    "suppose @xmath142 succeeds for @xmath79 with @xmath140 , then , a set of positive abducibles in @xmath140 realizes revision of @xmath40 to @xmath23 .",
    "the following theorem means that if we can search exhaustively in selecting the rules or cases and there is a generalized stable model whose abducibles minimally realizes a revision for addition of rule @xmath40 , then we can find such a set of abducibles by our procedure .",
    "note that this property is always guaranteed if a program is a finite propositional program or has finite constant symbols and no function symbols .",
    "[ complete ] let @xmath23 be a revision framework @xmath214 and @xmath40 be an added rule .",
    "suppose that every selection of rules or cases terminates for @xmath142 with either success or failure for @xmath79 .",
    "if @xmath72 minimally realizes revision of @xmath40 to @xmath21 , then there is a selection of rules and cases such that @xmath142 succeeds with @xmath140 where a set of abducibles in @xmath140 is equivalent to @xmath72 .",
    "note that we can not guarantee that positive abducibles of every @xmath140 always corresponds with a minimal revision .",
    "this problem is inherited from satoh s procedure in that it is not guaranteed for the procedure to produce a minimal abducibles . however , using the procedure , we can restrict sets of abducibles related with inconsistency and , thus , considered sets of abducibles to choosing minimal sets are smaller than sets of abducibles from a naive calculation of all the generalized stable models .",
    "consider the revision framework in example  [ revision ] .",
    "the following are two sequences of main calls of subprocedures for @xmath142 to @xmath216 shown in example  [ translation ] . in the following",
    ", @xmath217 , @xmath218 , @xmath219 and @xmath220 corresponds with @xmath172 , @xmath145 , @xmath147 and @xmath204 respectively , and indexes in the front express a nesting structure of the calls .",
    "note that existence of `` @xmath221 . '' in @xmath25 does not influence these derivations .",
    "* sequence 1 * ( for @xmath222 in example  [ revision ] )    @xmath223    1 @xmath224    1.1 @xmath225    1.1.1 @xmath226    @xmath227 * select * @xmath228    1.1.1.2 @xmath229    1.1.1.2.1 @xmath230    1.1.1.2.1.1 @xmath231    1.1.1.2.1.1.1 @xmath232    @xmath233    1.1.1.2.1.1.1.1 @xmath234    1.1.1.2.1.1.1.1.1 @xmath235    1.1.1.2.1.1.1.1.1.1 @xmath236    @xmath237    1.1.1.2.1.1.2 @xmath238    @xmath237    1.1.1.2.1.1.2.1 @xmath239    @xmath237    1.1.1.2.1.1.2.1.1 @xmath240    @xmath241    1.1.1.2.2 @xmath242    @xmath241    1.2 @xmath243    @xmath241    1.3 @xmath244    @xmath245    * sequence 2 * ( for @xmath246 in example  [ revision ] )    @xmath223    1 @xmath224    1.1 @xmath225    1.1.1 @xmath226    @xmath227 * select * @xmath228    1.1.1.2 @xmath229    1.1.1.2.1 @xmath230    1.1.1.2.1.1 @xmath247    @xmath227 * select * @xmath248    1.1.1.2.1.1.2 @xmath249    1.1.1.2.1.1.3 @xmath250    1.1.1.2.1.1.3.1 @xmath251    @xmath252    1.1.1.2.1.1.3.1.1 @xmath253    1.1.1.2.1.1.3.1.1.1 @xmath236    @xmath254    1.1.1.2.1.1.4 @xmath255    1.1.1.2.1.1.5 @xmath256    1.1.1.2.2 @xmath242    @xmath254    1.2 @xmath257    @xmath258    1.3 @xmath259",
    "there are works on calculation method of updates  @xcite .",
    "@xcite propose a top - down procedure to compute view updates in a database for proving a given goal , but it is not applicable to updating a normal logic program in general .",
    "@xcite give a bottom - up procedure for an update of an acyclic program to explain given observations in the perfect model of an acyclic program and therefore , can not apply to a normal logic program which has multiple stable models .",
    "moreover , using bottom - up computation would lead to an irrelevant derivation to an added rule .    in  @xcite ,",
    "translation from an update framework  @xcite to an extended logic program is provided  .",
    "differences between our translation and their translation are as follows .",
    "* they give a translation to compute an update to explain a goal whereas we consider a revision to avoid inconsistency of addition of a rule .",
    "* they introduce a new predicate symbol in stead of abducibles .",
    "this makes their translation rather complex .",
    "if we translate our translated abductive logic program to a new normal logic program by a method proposed in  @xcite , the new normal logic program would be the same as their program .",
    "* they consider addition / deletion of the whole rules to derive a given observation . that is , instead of considering deletion / addition of parts of @xmath260/@xmath261 in definition  [ revisedprogram ] , they propose deletion / addition of parts of @xmath26/@xmath22 .",
    "at least , however , to handle exception of integrity constraints in software engineering  @xcite , we believe that our fine - grained approach is better since we would like to keep consistent part of integrity constraints for further checking of other data when some instances cause inconsistency .",
    "see the detailed discussion in  @xcite .",
    "there are many procedures to compute stable models , generalized stable models or abduction .",
    "if we use a bottom - up procedure for our translated abductive logic program to compute all the generalized stable models naively , then sets of abducibles to be compared would be larger since abducibles of irrelevant temporary rules and addable rules with inconsistency will be considered .",
    "therefore , it is better to compute abducibles related with inconsistency . to our knowledge ,",
    "top - down procedure which can be used for this purpose is only satoh and iwayama s procedure since we need a bottom - up consistency checking of addition / deletion of literals during computing abducibles for revision .",
    "this task is similar to integrity constraint checking in  @xcite and satoh and iwayama s procedure includes this task .",
    "in this paper , we propose an abductive top - down procedure to compute a minimal revised program which traverses only relevant parts of the program to the added rule .",
    "it is done by translating a revision framework of a normal logic program into an abductive logic program .    as a future work",
    ", we would like to find an efficient method of computing a minimal revision directly by combining our top - down procedure and atms - like method of memorizing justifications of revisions .",
    "this research is partly supported by grant - in - aid for scientific research on priority areas , `` principles for constructing evolutionary software '' , the ministry of education , japan .",
    "we also thank the anonymous referees for valuable comments on this paper ."
  ],
  "abstract_text": [
    "<S> this paper presents a method of computing a revision of a function - free normal logic program . </S>",
    "<S> if an added rule is inconsistent with a program , that is , if it leads to a situation such that no stable model exists for a new program , then deletion and addition of rules are performed to avoid inconsistency . </S>",
    "<S> we specify a revision by translating a normal logic program into an abductive logic program with abducibles to represent deletion and addition of rules . </S>",
    "<S> to compute such deletion and addition , we propose an adaptation of our top - down abductive proof procedure to compute a relevant abducibles to an added rule . </S>",
    "<S> we compute a minimally revised program , by choosing a minimal set of abducibles among all the sets of abducibles computed by a top - down proof procedure . </S>"
  ]
}