{
  "article_text": [
    "we are slowly reaching the classical limit of current technology in decreasing the size of computer chips . hence to avoid quantum effect and also to reduce heat generation parallel computing has become the dominant paradigm in computer architecture . on the other hand in the quantum domain",
    "reducing the depth would be essential for keeping the computation coherent to avoid classical effect . in both scenarios designing parallel circuit",
    "remains a challenging task .",
    "hence one attempts to rewrite locally a given circuit to reduce the depth of the computation .",
    "usually such an approach will add ancilla registers to achieve the parallelisation , this being an undesired effect in the quantum setting as addition of ancilla qubits could increase the decoherence , breaching the initial purpose of parallelisaiton . in this paper",
    "we present a general optimisation techniques for quantum circuit that exploits the global structure of a given computation to achieve parallelisation with no ancilla addition .",
    "our technique is based on the translation of a given quantum circuit @xcite into a measurement - based quantum computation ( mbqc ) @xcite .",
    "these two models utilise remarkably different information processing tools : while the former is based on unitary evolution of an initially non - entangled set of qubits , the latter needs an initial highly - entangled multi - qubit state , where the information processing is driven by measurements only .",
    "naturally since the two aforementioned models use different information processing tools , hence each model has its own optimisation techniques . in the mbqc model , for instance ,",
    "most of the optimization techniques are based on the identification of a more efficient correction structure that is directly linked to the geometry of the underlying global entanglement structure .",
    "examples of these techniques are the _ signal shifting _ @xcite and the _ generalised flow _",
    "@xcite , both discussed in following sections .",
    "the so - called _ standardisation _ procedure @xcite can also reduce the number of computational steps by rearranging the mbqc operations into a normal form .",
    "moreover , _ all _ pauli measurements in this model can be performed in the beginning of the computation @xcite , which is a surprising difference from the quantum circuit model .    on the other hand ,",
    "most optimization techniques for quantum circuits are based on template identification and substitution .",
    "for instance in @xcite , some circuit identities are used to modify the teleportation and dense coding protocols , with the purpose of giving a more intuitive understanding of those protocols . similarly in @xcite and @xcite a set of circuit identities for reducing the number of gates in the circuit for size optimization was given .",
    "in contrast to that , in @xcite a useful set of techniques for circuit parallelisation was provided , where the number of computational steps is reduced by using additional resources . however , as noted in @xcite , all the aforementioned circuit optimization techniques are basically exchanging a sequence of gates for a different one without any consideration on the structure of the complete circuit being optimised .",
    "the translation into mbqc would allow us to explore the global structure of a given circuit .",
    "the first such a scheme by back and forth translation between the two models was presented in @xcite .",
    "however the backward translation into the circuit required the addition of many ancilla qubits . on the other hand several recent works presented an optimised translation scheme from mbqc into the circuit where all the non - input qubits are removed , referred hereinafter as compact translation @xcite .",
    "the price for doing that happened to be the loss of the optimal depth of the original mbqc .",
    "the key result of our paper is a new scheme for the parallelisation where the obtained mbqc pattern could be translated compactly .",
    "our scheme is based on a new theoretical connection between two mbqc depth optimisation procedures , known as the _ maximally delayed generalised flow _",
    "@xcite and _ signal shifting _ , which could lead to other interesting observation about mbqc , beyond the purpose of this paper as we discuss later .",
    "also our result highlights the fundamental role of the mbqc pauli optimisation in obtaining mbqc parallel structure beyond anything obtainable in the quantum circuit model , described later .",
    "we prove how our proposed scheme is more optimal in both depth and space compare to the scheme in @xcite .",
    "we conclude with a new algorithm for finding the maximally delayed generalised flow for graphs with flow with @xmath0 steps compared to the exciting algorithm in @xcite , where @xmath1 is the number of the nodes in the graph .",
    "we review the basic ideas behind the measurement - based quantum computation , with special attention to its description in terms of the formal language known as measurement calculus @xcite , and the flow theorems @xcite .    in 1999",
    "chuang and gottesman described how one could apply arbitrary quantum gates using an adaptation of the quantum teleportation model @xcite .",
    "this approach was further developed by other researchers @xcite , enabling one in principle to perform arbitrary computations given a few primitives : preparation of maximally entangled systems of fixed , small dimension ; multi - qubit measurements on arbitrary set of qubits ; and the possibility of adapting the measurement bases depending on earlier measurement outcomes .",
    "these models of computation draw on measurements to implement the dynamics , and as such named collectively the measurement - based model of quantum computation ( mbqc ) , for an overview see the paper by jozsa @xcite .",
    "an mbqc model using only single qubit measurements was proposed by raussendorf and briegel in 2001 , which became known as the one - way model @xcite .",
    "the one - way model achieves universality through the preparation of a special type of entangled states , the so - called cluster states @xcite .",
    "these states are created with the cz gate acting on qubits prepared in the state @xmath2 arranged in a regular lattice , usually the two - dimensional ones .",
    "this can be relaxed to create more general states with the same interaction over general graphs , creating the so - called graph states @xcite .",
    "both cluster and graph states can be represented graphically , using vertices denoting the qubits and edges for the two - qubit entangling gate cz .",
    "therefore , the entangled resource for the one - way model can be fully represented as graphs .",
    "although two - dimensional cluster states can be used as resource for universal quantum computation in the one - way model , arbitrary graph states may , or may not , serve for the same purpose ; investigating which kinds of entangled states are useful resources for mbqc is an active area of research @xcite .    a formal language to describe in a compact way the operations needed for the one - way model was proposed in @xcite . the language could be easily adapted to any other type of measurement - based model hence in the rest of this paper we refer to the general mbqc term instead of the specific one - way model as our scheme could be applicable to any mbqc models . in this framework",
    "every mbqc algorithm ( usually referred to as an mbqc pattern ) involves a sequence of operations such as entangling gates , measurements and feed - forwarding of outcome results to determine further measurement bases .",
    "a _ measurement pattern _ , or simply a pattern , is defined by a choice of a set of working qubits @xmath3 , a subset of input qubits ( @xmath4 ) , another subset of output qubits ( @xmath5 ) , and a finite sequence of commands acting on qubits in @xmath3 .",
    "therefore , we consider patterns associated to the so - called _ open graphs _ :    [ def_opengraph ] an open graph is a triplet @xmath6 , where @xmath7 is a undirected graph , and @xmath8 are respectively called input and output vertices .",
    "an example of an open graph is shown in figure [ def_gflow ] .",
    "there are four types of commands , the first is the qubit initialisation command @xmath9 that prepares qubit @xmath10 in the state @xmath11 .",
    "the input qubits are already given as a prepared state .",
    "the entangling command @xmath12 corresponds to the @xmath13 gate between qubits @xmath10 and @xmath14 , where @xmath15 the single - qubit measurement command @xmath16 corresponds to a measurement of qubit @xmath10 in the basis @xmath17 , with outcome @xmath18 associated with @xmath19 , and outcome @xmath20 with @xmath21 .",
    "the measurement outcomes are usually referred as _",
    "signals_. finally , the corrections may be of two types , either pauli @xmath22 or pauli @xmath23 , and they may depend on any prior measurement results , denoted by @xmath24 ( @xmath25 or @xmath20 and the summation is done modulo two ) .",
    "this dependency can be summarised as correction commands : @xmath26 and @xmath27 denoting a pauli @xmath22 and @xmath23 corrections on qubit @xmath10 which must be applied only when the parity of the measurement outcomes on qubits @xmath28 equals one ( as @xmath29 ) .",
    "a characteristic of the mbqc model is that the choice of measurement bases may depend on earlier measurement outcomes .",
    "these dependent measurements can be conveniently written as @xmath30^s$ ] , where @xmath31^s \\equiv m_i^{\\theta}x_i^s z_i^t = m_i^{(-1)^s\\theta+t\\pi},\\ ] ] where it is understood that the operations are performed in the order from right to left in the sequence .",
    "the left ( @xmath32 ) and right ( @xmath33 ) dependencies of the measurement @xmath34 are called its @xmath23 and @xmath22 _ dependencies _ , respectively .",
    "a pattern is runnable , that is , corresponds to a physically sound sequence of operations , if it satisfies the following requirements : ( r0 ) no command depends on outcomes not yet measured ; ( r1 ) no command acts on a qubit already measured or not yet prepared , with the obvious exception of the preparation commands ; ( r2 ) a qubit undergoes measurement ( preparation ) iff it is not an output ( input ) qubit .    as an example , take the pattern consisting of the choices @xmath35 and the sequence of commands : @xmath36 this sequence of operations does the following : first it initialises the output qubit 2 in the state @xmath11 ; then it applies @xmath37 on qubits 1 and 2 ; followed by a measurement of input qubit 1 onto the basis @xmath38 .",
    "if the result is the latter vector then the one - bit outcome is @xmath39 and there is a correction on the second qubit ( @xmath40 ) , otherwise no correction is necessary .",
    "a simple calculation shows that this pattern implements the unitary @xmath41 on the state prepared in qubit 1 , outputting the result on qubit 2 , where @xmath42 the simple sequence above is a convenient building block of more complicated computations in the mbqc model .",
    "this is because the set of single qubit @xmath41 ( @xmath43 ) together with cz on arbitrary pairs of qubits can be shown to be a universal set of gates for quantum computation @xcite .",
    "the following rewrite rules ( @xcite ) put the command sequence in the _ standard _ form , where preparation is done first followed by the entanglement , measurements and corrections : @xmath44^sx_i^r & \\rightarrow & _ t[m_i^{\\theta}]^{s+r } \\label{rw3}\\\\ _ t[m_i^{\\theta}]^sz_i^r & \\rightarrow & _ { r+t}[m_i^{\\theta}]^s \\label{rw4}\\end{aligned}\\ ] ] this procedure is called _ standardisation _ and can directly change the dependencies structure commands , possibly reducing the computational depth , without breaking the causality ordering @xcite .      due to the probabilistic nature of quantum measurement ,",
    "not every measurement pattern implements a _",
    "deterministic _ computation  a completely positive , trace - preserving ( cptp ) map that sends pure states to pure states .",
    "we will refer to the collection of possible measurement outcomes as a _ branch _ of the computation . in this paper ,",
    "we consider deterministic patterns which satisfies three conditions : ( 1 ) the probability of obtaining each branch is the same , called _ strong determinism _ ; ( 2 ) for any measurement angle we have determinism , called _ uniform determinism _ ; and ( 3 ) which are deterministic after each single measurement , called _",
    "stepwise determinism_. we will call those patterns simply _ deterministic patterns_. here since we are only working with quantum circuits we do nt need to be concerned with other stronger notions of determinism defined for mbqc pattern such as in @xcite .    in @xcite conditions over a graph ( knows as _ flow _ ) are presented in order to identify a dependency structure for the measurement sequence associated to open graph to obtain determinism . in what follows ,",
    "we call non - input vertices as @xmath45 ( complement of @xmath4 in the graph ) and non - output vertices as @xmath46 ( complement of @xmath5 in the graph )",
    ".    [ def_flow ] we say that an open graph @xmath47 has _ flow _ iff there exists a map @xmath48 and a strict partial order @xmath49 over all vertices in the graph such that for all @xmath50    * ( f1 ) @xmath51 ; * ( f2 ) if @xmath52 , then @xmath53 or @xmath54 , where @xmath55 is the neighbourhood of @xmath56 ; * ( f3 ) @xmath57 ;    efficient algorithms for finding flow ( if it exist ) can be found in @xcite .",
    "the flow function @xmath58 is a one - to - one function .",
    "the proof is trivial , but as this property is extensively used in this work we will present the proof in this paper .",
    "let @xmath59 be a flow on an open graph @xmath6 .",
    "the function @xmath58 is an injective function , _",
    "i.e. _ for every @xmath60 , @xmath61 is unique .",
    "let us assume that for some @xmath60 , @xmath61 is not unique , _ i.e. _ there exists @xmath62 such that @xmath63 but @xmath64 . then according to the flow definition : @xmath65 and we arrive to a contradiction because @xmath54 and @xmath66 can not be true at the same time .",
    "hence @xmath61 has to be unique .    in the case where @xmath67",
    ", the flow function induces a circuit - like structure in a graph , in the sense that for each input qubit @xmath68 , there exists a number @xmath1 such that @xmath69 and the vertex sequence @xmath70 , f [ f[f(i)]]\\ } , ... , f^n(i)\\},\\ ] ] can be translated to a single wire in the circuit model .",
    "a simple example can be seen in figure [ fig_flowgflow ] .",
    "this circuit - like structure is an interesting feature of the flow function , since it allows a very simple translation procedure called star decomposition introduced in @xcite .",
    "flow provides only a sufficient condition for determinism but one can generalise the above definition to obtain a condition that is both necessary and sufficient .",
    "this generalisation allows correcting sets with more than one element . in those cases ,",
    "we say that the graph has _",
    "generalised flow _",
    "( or simply _ gflow _ ) . in what follows we define @xmath71 to be the set of vertices where each element is connected with the set @xmath72 by an odd number of edges .",
    "[ * generalised flow * @xcite ] [ def_gflow ]",
    "we say @xmath47 has generalised flow if there exists a map @xmath73 ( the set of all subsets of non - input qubits ) and a partial order @xmath74 over all vertices in the graph such that for all @xmath50 ,    * ( g1 ) if @xmath75 then @xmath76 ; * ( g2 ) if @xmath77 then @xmath53 or @xmath76 ; * ( g3 ) @xmath78 ;    the set @xmath79 is often referred to as the _ correcting set _ for qubit @xmath10 .",
    "it is important to note that flow is a special case of gflow , where @xmath79 contains only one element .",
    "this is a key difference regarding the translation of measurement patterns to quantum circuits .",
    "an example of a graph with gflow ( but no flow ) is shown in figure [ fig_flowgflow ] .",
    "[ fig_flowgflow ]     the gflow partial oder leads to an arrangement of the vertices into layers ( see below ) , in which all the corresponding measurements can be performed simultaneously .",
    "the number of layers corresponds to the number of parallel steps in which a computation could be finished , known as the _ depth _ of the pattern .",
    "[ def_gflow_depth ] for a given open graph @xmath6 and a gflow @xmath80 of @xmath6 , let @xmath81 where @xmath82 is the set of maximal elements of @xmath22 according to @xmath74 .",
    "the _ depth _ @xmath83 of the gflow is the smallest @xmath84 such that @xmath85 , @xmath86 is a partition of @xmath87 into @xmath88 layers .",
    "we define the _ layering function _ of a gflow based on the above distribution of vertices into layers .",
    "given a gflow @xmath80 on an open graph @xmath6 we define its _ layering function _ @xmath89 to be the natural number @xmath90 such that @xmath91 .",
    "there is another useful way to understand the depth of a gflow .",
    "a gflow can be represented as a directed graph on top of an open graph as shown in figure [ fig_flowgflow ] .",
    "the longest path from inputs to outputs over those directed edges corresponds to the depth of the gflow . in @xcite",
    "it was shown , that a special type of gflow , called a _ maximally delayed gflow _ , has minimal depth .",
    "[ def_delayed_gflow ] for a given open graph @xmath6 and two given gflows @xmath80 and @xmath92 of @xmath6 , @xmath80 is more delayed than @xmath92 if @xmath93 , @xmath94 and there exists a @xmath90 such that the inequality is strict .",
    "a gflow @xmath80 is _ maximally delayed _ if there exists no gflow of the same graph that is more delayed .",
    "we will simply refer to the maximally delayed gflow as the _ optimal gflow_. note that in @xcite it was proven that the layering of the vertices imposed by an optimal gflow @xmath80 is always unique , however the gflow itself might not be unique .",
    "this is an important property together with the following lemmas that we will exploit later for our main result on linking gflow to other known structures for mbqc .",
    "[ lem_last_layer ] if @xmath95 is a maximally delayed gflow of @xmath6 then @xmath96 .",
    "[ lem_penultimate_layer ] if @xmath95 is a maximally delayed gflow of @xmath6 then @xmath97 is a maximally delayed gflow of @xmath98 where @xmath99 is the restriction of @xmath100 to @xmath101 and @xmath102 .",
    "th parallel power of mbqc is proven to be equivalent to quantum circuit augmented with free unbounded fanout @xcite .",
    "this motivates to use mbqc as an automated tool for circuit parallelisation as it was first presented in @xcite .",
    "another way to obtain parallel mbqc structure is to extract the entanglement graph of the pattern and obtain the optimal gflow of the graph @xcite .",
    "then one performs the required corrections according to this structure .",
    "our first main result is to show the equivalence between these two seemingly very different technique for the patterns obtained from a quantum circuit , that is those with flow .",
    "more precisely we show how the effect of performing signal shifting optimisation ( that is the core idea in @xcite ) result in a maximally delayed gflow .",
    "this structural link shed further lights on the complicated structure of maximally delayed gflow and permit us to find a new efficient algorithm for finding it for the large class of patterns obtained form a circuit .",
    "we proceed with reviewing the rules for signal shifting defined in @xcite : @xmath103^s & \\rightarrow s_i^t \\ ; [ m_i^{\\alpha}]^s \\label{eq_ss1 } \\\\",
    "x_j^s \\ ; s_i^t & \\rightarrow s_i^t \\ ; x_j^{s[(t+s_i)/s_i ] } \\label{eq_ss2 } \\\\",
    "z_j^s \\ ; s_i^t & \\rightarrow s_i^t \\ ; z_j^{s[(t+s_i)/s_i ] } \\label{eq_ss3}\\end{aligned}\\ ] ] where @xmath104 is the signal shifting command ( adding @xmath32 to @xmath105 ) and @xmath106 $ ] denotes the substitution of @xmath105 with @xmath32 in @xmath33 .",
    "signal shifting , can be utilised to parallelise mbqc patterns and quantum circuits @xcite .",
    "the rest of this section is focused on various structural properties of the signal shifting .",
    "as can be seen from the above rules , signal shifting rewrites the @xmath22- and @xmath23-corrections of a measurement pattern in a well defined manner .",
    "in particular , it will move all the @xmath23-corrections to the end of the pattern , thereby introducing new @xmath22-corrections when rule [ eq_ss2 ] is applied .",
    "it is proven in @xcite that signal shifting will never increase the depth of an mbqc pattern , although it can decrease it .",
    "in the case when the depth decreases , it is the consequence of the removal of the @xmath23-corrections on the measured qubits by applying rule [ eq_ss1 ] .",
    "the rules [ eq_ss1 ] - [ eq_ss3 ] can be interpreted in the following way .",
    "signal shifting takes a signal from a @xmath23-correction on a measured qubit @xmath10 ( rule [ eq_ss1 ] ) and adds it to the corrections that depend on the outcome of the measurement of @xmath10 ( rules [ eq_ss2 ] - [ eq_ss3 ] ) . when the signal moves to an @xmath22-correction command , then it wo nt propagate any further .",
    "if the signal was added to another @xmath23-correction of a measured vertex , then signal shifting can be applied again until no @xmath23-corrections are left on non - output vertices .",
    "therefore signals move along a path created by the @xmath23-corrections .",
    "the propagation of signals in an mbqc pattern can be described by a _",
    "@xmath23-path _ as defined below .",
    "[ def_zpath ] let @xmath107 be a measurement pattern on an open graph @xmath6 .",
    "then we define a directed acyclic graph , called @xmath108 , on the vertices of @xmath109 such that there exists a directed edge from @xmath10 to @xmath14 iff there exists a correction command @xmath110 in @xmath107 .",
    "a path in @xmath108 between two vertices @xmath56 and @xmath111 is called a _",
    "@xmath23-path_.    the above definition allows us to state a simple observation about connectivity of a graph with flow .",
    "[ lem_zpath_conn ] if @xmath59 is a flow on an open graph @xmath6 , and there exists a @xmath23-path from vertex @xmath10 to vertex @xmath14 , then the vertices @xmath10 and @xmath112 can not be connected .",
    "the existence of a @xmath23-path from @xmath10 to @xmath14 implies that @xmath54 .",
    "the z dependency graph is an acyclic graph , thus @xmath63 .",
    "if @xmath10 would be connected to @xmath112 , then according to the flow property ( f2 ) : @xmath113 now we have two contradicting strict partial order relations @xmath54 and @xmath66 .",
    "therefore @xmath10 can not be connected to @xmath112 .",
    "recall that the addition of signals is done modulo 2 , therefore , if an even number of signals from a measured vertex @xmath10 is added to a correction command on vertex @xmath14 , the signals will cancel out ( since @xmath114 ) .",
    "furthermore , it is evident from the rewrite rules of [ eq_ss1 ] - [ eq_ss3 ] that after signal shifting , the measurement result of vertex @xmath10 will create a new @xmath22-correction over vertex @xmath14 if there exist an odd number of @xmath23-paths from @xmath10 to a vertex @xmath90 that @xmath14 is @xmath22-dependent on directly before signal shifting .",
    "similarly a new @xmath23-correction from @xmath10 to @xmath14 will be created if there exists an odd number of @xmath23-paths from @xmath10 to @xmath14 .",
    "either way , _ the number of @xmath23-paths from a vertex @xmath10 to another vertex @xmath14 _ , denoted as @xmath115 , can be used to determine if the signal from @xmath10 should be added to a correction .",
    "we define @xmath116 to be 1 to simplify further calculations and definitions in this paper .",
    "the importance of the number of @xmath23-paths will manifest itself in the next subsection , when the relation between signal shifting and gflows is studied .",
    "we define a new structure called the _ signal shifted flow _ ( ssf ) , and show that it satisfies the three gflow properties in definition [ def_gflow ] . before constructing the ssf ,",
    "some definitions and lemmas are needed to justify our definition .",
    "note that if an open graph @xmath6 has a flow @xmath59 , then we can write the mbqc pattern of a deterministic computations on this open graph as @xcite :    @xmath117    where the product follows the strict partial order @xmath49 of the flow @xmath59 . from equation [ eq_flow_pattern ]",
    "we see that a @xmath23-correction on a vertex @xmath14 depending on the measurement outcome of another vertex @xmath10 appears only if @xmath14 is a neighbour of @xmath61 .",
    "this is formally stated in the next corollary as we will refer to it several times .",
    "[ cor_zcorr ] if @xmath6 is an open graph with a flow @xmath59 , then there exists a @xmath23-correction from vertex @xmath10 to another vertex @xmath14 iff @xmath118 .",
    "we define _ @xmath23-dependency neighbourhood _ of a vertex @xmath14 to be the set of vertices from which @xmath14 is receiving a @xmath23-correction from .",
    "this set has an explicit form given as @xmath119 , this is due to the following facts : for all vertices @xmath120 , from flow definition @xmath121 exists also since @xmath122 hence @xmath90 can not be equal to @xmath14 and moreover since @xmath123 therefore according to corollary [ cor_zcorr ] there exists a @xmath23-correction from @xmath90 to @xmath14 .",
    "it is easy to see , that @xmath115 can be written as : @xmath124 there exists a @xmath23-correction from every @xmath125 to @xmath14 .",
    "these @xmath23-corrections can be used to extend every such @xmath23-path to @xmath90 to reach @xmath14 . if @xmath10 is in the sum , then because @xmath126 the correct number of @xmath23-paths is obtained with equation [ eq_paths ] .",
    "we now present the complete algorithm ( algorithm [ alg_ss ] ) for signal shifting a flow pattern shown in equation [ eq_flow_pattern ] .",
    "we keep in mind that the order in which we apply the signal shifting rules does not matter @xcite .",
    "[ lem_alg_ss ] given the measurement pattern @xmath127 of a flow @xmath59 as defined in equation [ eq_flow_pattern ] as input to algorithm [ alg_ss ] , the output will be the signal shifted measurement pattern of @xmath127 .",
    "we will prove this proposition by showing that :    * algorithm [ alg_ss ] terminates . *",
    "every step in algorithm [ alg_ss ] that modifies the pattern @xmath128 is a valid application of a signal shifting rewrite rule . *",
    "the output of algorithm [ alg_ss ] , the pattern @xmath128 , is signal shifted .",
    "we begin by showing that algorithm [ alg_ss ] will terminate .",
    "the first `` while '' loop will obviously terminate , as we decrease the number of elements on each loop iteration and never add anything to the set @xmath129 .",
    "the second `` while '' loop will not terminate only if some @xmath130 command will be added to the pattern an infinite number of times . as",
    "the underlying graph is finite and a @xmath130 command represents a directed edge in the @xmath23-correction graph , this implies the existence of a cycle in the graph , however this is impossible according to the flow definition .",
    "the `` for '' loop in the algorithm terminates because the graph itself is finite , hence algorithm [ alg_ss ] has to terminate .    for algorithm [ alg_ss ] to actually perform the signal shifting , its operations have to be either trivial commuting rules or the three signal shifting rules [ eq_ss1 ] - [ eq_ss2 ] .",
    "as can be easily seen from the algorithm , the operations done are indeed the signal shifting rewrite rules [ eq_ss1 ] - [ eq_ss2 ] . we still need to prove , that these rules can be applied in the order shown in the algorithm .",
    "obviously we can use rule [ eq_ss1 ] on line 8 to create the signal command due to the fact that @xmath131 and that every non - output qubit is measured .",
    "hence we have the measurement required for the creation of the signal command in the pattern .",
    "we know that @xmath132 has to be in the pattern after the command @xmath133 and before @xmath134 .",
    "the entanglement and creation commands are the first commands in the pattern and we do not need to move the @xmath130 command past them .",
    "hence we only need to move @xmath130 past measurement commands on qubits that are not @xmath10 and @xmath90 and other correction commands . these can be done trivially and hence we can always move the @xmath130 command next to @xmath134 to apply rule [ eq_ss1 ] .",
    "next we want to move the newly created @xmath135 command to the end of the measurement pattern . to do that we need to commute it past the commands that appear after it .",
    "the only commands @xmath135 commutes non - trivially with are the ones that depend on the measurement of qubit @xmath90 as can be seen from rules [ eq_ss1 ] - [ eq_ss3 ] .",
    "those are the @xmath22- and @xmath23-corrections depending on the measurement outcome of qubit @xmath90 .",
    "according to equation [ eq_flow_pattern ] there is exactly one such @xmath22-correction in the pattern @xmath127 , namely @xmath136 .",
    "also the previous steps of the algorithm could not have created any dependencies from qubit @xmath90 .",
    "the @xmath23-correction commands have only been created depending on vertices that we already moved from @xmath129 .",
    "therefore we need to create exactly one new @xmath22-correction command using rule [ eq_ss2 ] .",
    "we also look at the @xmath23-corrections depending on @xmath90 and from equation [ eq_flow_pattern ] we see that in the original pattern these are on vertices from the set @xmath137 . as for the @xmath22-corrections",
    "we also have not created any new @xmath23-corrections from @xmath90 in the previous steps of the algorithm .",
    "hence this is exactly the set of corrections we need to commute with and apply rule [ eq_ss3 ] .",
    "we are only left with commands after @xmath135 in the pattern that commute trivially with @xmath135 .",
    "we can move the command at the end of the pattern .",
    "the signal command at the end of the pattern does not influence the computation and we will not add any new commands to the end of the pattern . hence we can remove the @xmath138 command from the pattern .",
    "finally we show that no more signal shifting rules can be applied after the completion of algorithm [ alg_ss ] , _ i.e. _ the pattern @xmath128 is signal shifted .",
    "we eliminate all @xmath23-corrections acting on a non - output qubit depending on a vertex @xmath10 after removing it from the set @xmath129 and will afterwards never create any new @xmath23-corrections depending on that vertex . at the end of the algorithm",
    "the set @xmath129 is empty , hence there can not exist any non - output qubit that has a @xmath23-correction acting on it and rule [ eq_ss1 ] can not be applied anymore .",
    "moreover , since every signal command is at the end of the pattern , we can not apply the rules [ eq_ss2 ] and [ eq_ss3 ] neither , that completes the proof .",
    "we consider any trivial commutation of a pattern commands resulting to an equivalent pattern .",
    "therefore the above algorithm defines the unique pattern obtained after signal shifting .",
    "note that algorithm [ alg_ss ] works almost like a directed graph traversal , where there is a directed edge from vertex @xmath10 to @xmath90 iff there exists the command @xmath130 in the measurement pattern .",
    "the only difference from a classical directed graph traversal is that we allow visiting of a vertex more than only once .",
    "hence we will traverse through every different path in the graph however we do that exactly once .    as mentioned before",
    ", the evenness of the number of @xmath23-paths can be used to determine if a signal is added to a correction command .",
    "let @xmath139 be the function that determines the oddness or evenness of the integer @xmath1 , _",
    "i.e. _ @xmath140 .",
    "then if an open graph has a flow , the oddness of @xmath115 can be found as described in the following lemma .",
    "[ lem_oddness ] for every two vertices @xmath10 and @xmath14 in an open graph @xmath6 with flow @xmath59 @xmath141 _ i.e. _ @xmath142 depends only on the number of vertices in the @xmath23-dependency neighbourhood which have odd number of @xmath23-paths from @xmath10 .",
    "the oddness of @xmath115 can be written as @xmath143    all these notions will allow us to define the structure of the pattern after signal shifting is being performed .",
    "[ prop_ssf ] given a flow @xmath59 on an open graph @xmath6 , let @xmath33 be a function from @xmath144 such that @xmath145 iff @xmath146 .",
    "also define @xmath147 to be a layering function from @xmath87 into a natural number : @xmath148 define the strict partial order @xmath149 with : @xmath150 then , the application of signal shifting rules [ eq_ss1 ] - [ eq_ss3 ] over an mbqc pattern with flow @xmath59 will lead to the following pattern : @xmath151    the proof is divided into three parts . first we will show that signal shifting creates exactly the pattern commands shown in equation [ eq_ssf_pattern ] .",
    "we proceed by showing , that the layering function @xmath147 is defined for every @xmath152 .",
    "lastly , we need to prove that using the partial order @xmath149 derived from @xmath147 for ordering the commands as in equation [ eq_ssf_pattern ] gives a valid measurement pattern .",
    "note that the preparation commands ( @xmath153 ) , entanglement commands ( @xmath154 ) and measurement commands ( @xmath133 ) are the same for equations [ eq_flow_pattern ] and [ eq_ssf_pattern ] . because signal shifting would not change these commands ( rules [ eq_ss1 ] - [ eq_ss3 ] ) these are as required for a signal shifted pattern .",
    "hence we need only to consider the correction commands .",
    "we will look at the correction commands that would appear in a signal shifted pattern .",
    "we do this by examining the signal shifting algorithm ( algorithm [ alg_ss ] ) . as mentioned before",
    ", the algorithm works as a directed graph traversal , in a way that every distinct path is traversed o. as seen in the algorithm every @xmath130 correction acting on a non - output qubit is removed from the pattern .",
    "this is in accordance with the proposed pattern in equation [ eq_ssf_pattern ] .",
    "let us examine which new corrections are created .    the number of newly created @xmath155 depends on the number of times we enter the first loop with command @xmath156 .",
    "as the algorithm is a directed graph traversal algorithm , this happens as many times as there are different paths over the @xmath23-dependency graph from @xmath10 to @xmath157 .",
    "because the same two @xmath158 corrections cancel each other , hence a new @xmath22-correction appears in a signal shifted pattern only if @xmath146 .",
    "we also note that no new @xmath159 correction is created since there exist no @xmath23-path between @xmath10 and @xmath160 . on the other hand algorithm [ alg_ss ]",
    "leaves the already existed @xmath22 corrections unchanged and moreover since we have defined @xmath126 therefore @xmath161 .",
    "this implies that the set @xmath162 does indeed contain all the vertices that have an @xmath22-correction depending on @xmath105 after signal shifting is performed .",
    "the number of newly created @xmath23-corrections on an output vertex @xmath14 depending on a vertex @xmath10 appearing in the signal shifted pattern is equal to the number of different paths from @xmath10 to @xmath14 .",
    "the difference with non - output qubits is that these will not be removed through the process of signal shifting . as with @xmath22-corrections ,",
    "two @xmath23-correction commands on the same qubit will cancel each other out and hence the existence of a @xmath110 in the final pattern depends on the parity of the number of paths from @xmath10 to @xmath14 .",
    "this can be written in short as : @xmath163 hence the measurement pattern in equation [ eq_ssf_pattern ] has exactly the same commands as the signal shifted pattern in equation [ eq_flow_pattern ] .",
    "another thing we need to proof is that the layering function @xmath147 is defined for every @xmath152 .",
    "as proven above , the @xmath22-corrections depending on the measurement of qubit @xmath56 correspond to the set @xmath164 .",
    "hence we can interpret the definition of @xmath165 as finding the maximum value of @xmath147 for every vertex that has an @xmath22-correction from @xmath56 and adding @xmath20 to it .",
    "the recursive definition of @xmath165 is well defined , if for every non - output qubit we can find a path over @xmath22-corrections ending at an output qubit .",
    "we know that signal shifting of a valid pattern creates another valid pattern .",
    "this implies that the @xmath22-corrections can not create a cyclic dependency structure and hence every path over the @xmath22-corrections has an endpoint .",
    "moreover such a path can not end on a non - output qubit @xmath90 since @xmath166 and one could always extend that path with @xmath121 .",
    "therefore @xmath165 is well defined .    finally , it is easy to show that the partial order @xmath149 as used in equation [ eq_ssf_pattern ] gives a valid ordering of the commands .",
    "every vertex @xmath14 that has an @xmath22-correction depending on the measurement of qubit @xmath10 has a smaller @xmath147 number and hence @xmath167 . this way no @xmath22-correction command acts on an already measured qubit and",
    "because the @xmath23-corrections are applied only on output qubits , the correction ordering is valid .",
    "every other command is applied before the measurement command and hence the pattern in equation [ eq_ssf_pattern ] is a valid measurement pattern .    given an open graph with a flow , we refer to the construction of the above proposition as its corresponding _ signal shifted flow _ ( ssf ) .",
    "the main theorem of this section states that every ssf is actually a special case of a gflow .",
    "[ cor_neighbour ] if @xmath6 is an open graph with flow @xmath59 and ssf @xmath168 then for every vertex @xmath10 and @xmath14 such that @xmath169 , we can find another vertex @xmath90 , such that @xmath170 .",
    "if @xmath171 , then from the proposition [ prop_ssf ] of ssf we can conclude that @xmath172 .",
    "we know that @xmath173 from the assumptions .",
    "lemma [ lem_oddness ] says , that there must exist at least one other vertex @xmath90 from which @xmath14 has a @xmath23-correction , such that @xmath174 .",
    "the flow definition says that @xmath14 must therefore be a neighbour of @xmath121 .",
    "definition [ prop_ssf ] of ssf states that @xmath121 must therefore be in @xmath162 , hence @xmath170 .",
    "[ theorem_ssfisgflow ] given any open graph @xmath6 with flow @xmath59 , the corresponding signal shifted flow @xmath168 is a gflow .    the proof is based on the following lemmas , demonstrating that @xmath33 is a gflow by satisfying all the properties of definition [ def_gflow ] .",
    "the first property of gflow ( property g1 ) is satisfied by sff implicitly from definition [ prop_ssf ] , _ i.e. _ for every @xmath152 it holds that @xmath167 if @xmath145 .",
    "consider the second gflow property ( g2 ) , _ i.e. _ if @xmath175 then @xmath53 or @xmath167 .",
    "we will show that every vertex with odd many connections to @xmath162 has to be either @xmath10 itself or an output qubit .",
    "this is a stronger condition than is needed to show g2 , but as shown in section [ sec_compactification ] , necessary for creating compact circuits from ssf .",
    "[ lem_evenconnections ] if @xmath176 is an ssf then every non - output vertex @xmath177 connected to @xmath162 has an even number of connections to @xmath162 , _",
    "i.e. _ , @xmath178    let @xmath177 be a vertex connected to @xmath162 , we show the following two sets have the same number of elements .",
    "@xmath179 for every @xmath180 , we prove @xmath157 is the unique element in @xmath181{lllllllllllllll } \\lbrace k \\in n_z(v ) \\ ; | \\ ; parity(\\zeta_i(k ) ) = 1 \\rbrace \\end{array}\\ ] ] because @xmath145 from proposition [ prop_ssf ] there must exist @xmath157 .",
    "also since @xmath182 therefore @xmath183 .",
    "moreover since @xmath184 , corollary [ cor_zcorr ] implies the existence of a @xmath23-correction from @xmath157 to @xmath56 , _",
    "i.e. _ @xmath185 .",
    "proposition [ prop_ssf ] says that because @xmath145 , it must hold that @xmath146 .",
    "therefore @xmath186 .",
    "on the other hand , for every vertex @xmath187 , as @xmath188 then from proposition [ prop_ssf ] we have@xmath189 . also @xmath190 because of corollary [ cor_zcorr ] and finally , @xmath191 because @xmath56 can not have a @xmath23-correction from itself , _",
    "i.e. _ @xmath192 .",
    "hence it holds that @xmath193 .",
    "therefore @xmath194 according to lemma [ lem_oddness ] @xmath195 .",
    "if @xmath196 then @xmath197 must have an even number of elements .",
    "proposition [ prop_ssf ] says that @xmath198 can not be in @xmath162 and therefore @xmath56 can have only even number of connections to @xmath162 . if @xmath199 then we know that @xmath197 must have an odd number of elements .",
    "if @xmath198 exists it must be in @xmath162 because of proposition [ prop_ssf ] . in the case of @xmath200",
    ", we can conclude that @xmath201 and @xmath56 has even many connections to @xmath162 . on the other hand",
    "if @xmath198 does not exist , @xmath56 has to be an output qubit because the flow function @xmath58 is defined for every non - output vertex .",
    "the only possibility of @xmath90 having odd many connections to @xmath162 is therefore if @xmath90 is an output vertex , which proves the lemma .",
    "the next lemma directly proves that an ssf also satisfies the last gflow property ( g3 ) which states that @xmath202 .",
    "[ lem_oddi ] if @xmath168 is an ssf , then for every @xmath60 it holds that @xmath202 .",
    "first we show that , performing signal shifting creates new @xmath22-corrections only between unconnected vertices .",
    "recall that signal shifting creates a new @xmath22-correction between vertices @xmath10 and @xmath14 iff there exists a @xmath23-path from @xmath10 to @xmath157 and an @xmath22 correction from @xmath157 to @xmath14 therefore from the flow definition we have : @xmath203 let us assume that there exists an edge between @xmath10 and @xmath14 . according to the flow definition",
    "we have that @xmath204 this contradicts the partial order @xmath205 of the flow @xmath59 and therefore there can not be an edge between vertices @xmath10 and @xmath14 .",
    "next we claim that there is exactly one edge between @xmath10 and @xmath162 . according to definition [ prop_ssf ] of ssf ,",
    "the set @xmath162 consists only of the vertex @xmath61 and the vertices to which signal shifting created a new x dependency from @xmath10 .",
    "we showed that signal shifting does not create @xmath22 dependencies between connected edges .",
    "hence , @xmath61 is the only vertex in @xmath162 that can be connected to @xmath10 , and there must be an edge between @xmath10 and @xmath61 because of the flow property ( f3 ) ( @xmath57 ) .    now to obtain the proof of theorem [ theorem_ssfisgflow ] , we note that the definition of ssf implies the gflow property _",
    "( 1.)_. lemma [ lem_evenconnections ] implies that every ssf satisfies the gflow condition _",
    "( 2.)_. as the third and last gflow condition is satisfied by ssf according to lemma [ lem_oddi ] , ssf is indeed a gflow and theorem [ theorem_ssfisgflow ] holds .",
    "the above theorem for the first time presents an structural link between two seemingly different approach for parallelisation , gflow and signal shifting , for those patterns having already flow .",
    "as mentioned in the introduction this is the key step in obtaining our simultaneous depth and space optimisation .",
    "the next section explores further the link with gflow , showing optimality of ssf in parallelisation .",
    "the notions of _ influencing walks _ and _ partial influencing walks _ on open graphs with flow was introduced in @xcite to describe the set of all vertices that a measurement depends on .",
    "an influencing walk starts with an input and ends with an output vertex , a partial influencing walk starts with an input vertex but can end with a non - output vertex .",
    "we will use a modified definition of influencing walks that can start from any non - output vertex @xmath10 and end at any vertex @xmath145 and call it a _ stepwise influencing path_. this will allow us to conveniently explore the dependency structure of a pattern with ssf .",
    "[ def_path ] let @xmath176 be an ssf that is obtained from a flow @xmath206 of an open graph @xmath47 and vertices @xmath10 and @xmath14 in @xmath87 such that @xmath145 .",
    "we say that a path between vertices @xmath10 and @xmath14 is an _ stepwise influencing path _ , noted as @xmath207 , iff    * the path is over the edges of @xmath109 .",
    "* the first two elements on the path are @xmath10 and @xmath61 . *",
    "every even - placed vertex @xmath90 on the path @xmath207 , starting from @xmath61 , is in @xmath162 . * every odd - placed vertex on the path @xmath207 is the unique vertex @xmath208 of some @xmath209 such that @xmath90 is the next vertex on the path @xmath207 .",
    "it is easy to see that every second edge , in particular the edges between @xmath208 and @xmath209 , in the stepwise influencing path is a flow edge .",
    "hence the path contains no consecutive non - flow edges .",
    "if we restrict the first vertices of the stepwise influencing path to be input vertices , the stepwise influencing path would be a partial influencing path , but not _",
    "vice versa_. stepwise influencing paths are useful because of their appearance in the ssf as proven by the following lemma .",
    "[ lem_path ] let @xmath176 be an ssf obtained from a flow @xmath206 of an open graph @xmath47 and vertices @xmath10 and @xmath14 in @xmath87 such that @xmath145 .",
    "then there always exists a stepwise influencing path @xmath207 .",
    "we start by constructing such a path backward from @xmath14 to @xmath10 .",
    "we select @xmath14 and @xmath157 as the last two vertices on the path and apply corollary [ cor_neighbour ] to find the vertices on the path , until we reach @xmath10 .",
    "the formation of cycles is impossible , as this would imply a cyclic dependency structure , impossible for a flow .",
    "we have to reach @xmath10 as the set of vertices we choose from is finite .",
    "the above lemma will be used in section [ sec_compactification ] to obtain compact circuits from ssf .",
    "note that there might be more than one stepwise influencing path from @xmath10 to @xmath14 .",
    "we conclude the section about influencing paths with the following two lemmas which will be used to prove the optimality of ssf .",
    "first , the structure of stepwise influencing paths imposes a strict restriction on the way a vertex on the stepwise influencing path can be connected .",
    "[ lem_past_conn ] let @xmath207 be a stepwise influencing path from @xmath10 to @xmath14 in an open graph @xmath6 with flow @xmath59 and corresponding ssf @xmath168 .",
    "then @xmath157 is the only odd - placed vertex in @xmath207 that @xmath14 is connected to .    according to the definition of stepwise influencing path , for every three consecutive vertices @xmath210 ,",
    "@xmath211 , @xmath212 in @xmath207 such that @xmath210 and @xmath212 are odd - placed we have that @xmath213 and @xmath214 . according to corollary [ cor_zcorr ] there must exist a @xmath23-correction from @xmath210 to @xmath212 .",
    "therefore the odd - placed vertices in @xmath207 are on a @xmath23-path from @xmath10 to @xmath157 and obviously from every odd - placed vertex in @xmath207 there exists a @xmath23-path to @xmath157 .",
    "lemma [ lem_zpath_conn ] says that @xmath14 can not be connected to any of the odd - placed vertices in @xmath207 .",
    "the previous lemma shows , that the stepwise influencing paths can be used to describe some properties of the connectivity in open graphs with ssf .",
    "the next lemma ( illustrated in figure [ fig_ext_path ] ) will explain how a stepwise influencing path can be extended .",
    "[ lem_ext_path ] let @xmath6 be an open graph with flow @xmath59 and corresponding ssf @xmath168 and let @xmath10 and @xmath14 be two non - output vertices of the open graph such that @xmath171 . if @xmath215 then every stepwise influencing path @xmath216 can be extended by the vertices @xmath14 and @xmath112 to create another stepwise influencing path @xmath217 .",
    "adding @xmath14 and @xmath112 to @xmath216 satisfies the conditions for stepwise influencing paths .",
    "there exists an edge between vertices @xmath14 and @xmath56 and vertices @xmath14 and @xmath112 , hence it is a valid path .",
    "moreover , @xmath171 would be an even - placed vertex on the extended path , and @xmath14 would be the unique oddly - placed vertex with @xmath171 .     of @xmath162 containing @xmath61",
    "we can find a vertex @xmath56 in the odd neighbourhood of @xmath218 such that @xmath198 is not contained in @xmath218 .",
    "this is proven in lemma [ lem_strict_subset ] . ]     of @xmath162 containing @xmath61 we can find a vertex @xmath56 in the odd neighbourhood of @xmath218 such that @xmath198 is not contained in @xmath218 .",
    "this is proven in lemma [ lem_strict_subset ] . ]",
    "given an mbqc pattern with gflow , finding the maximally delayed gflow of its underlying graph could potentially further reduce the depth of the computation @xcite . a natural question that arises",
    "is how ssf is linked with the optimal gflow . in this section",
    ", we prove that if the input and output sizes of the pattern are equal , then ssf is indeed the optimal gflow .",
    "hence we can conclude the most optimal parallelisation that one could obtain via translation of a quantum circuit into an mbqc pattern is achieved by the simple rewriting rules of ssf .",
    "this will also lead to a more efficient algorithm than the one presented in @xcite for finding the maximally delayed gflow of a graph as we discuss later .",
    "[ thm_optimality ] let @xmath6 be an open graph with flow @xmath59 such that @xmath67 .",
    "let @xmath168 be the ssf obtained from @xmath59 .",
    "then @xmath168 is the optimal gflow of @xmath6 .",
    "the proof of the theorem is rather long , an outline is presented below .",
    "a general reader could omit the next subsections , however various novel constructions has been introduced in the proof that could be explored for other mbqc results and hence could be valuable for an mbqc expert . in section [ sec_optimality_pen_layers ] we show that the penultimate layers of an optimal gflow and an ssf of an open graph where @xmath219 , are equal . next we introduce the concept of a _ reduced open graph _ in section [ sec_optimality_reduced_og ] .",
    "we prove two key properties of the optimal gflow and ssf of the reduced open graph .",
    "this highlights the recursive structures of the gflow and ssf leading to the possibility of extending these notions to new domains . in section [ sec_optimality_induction ]",
    "we put the pieces together , by showing that the previous properties imply that reduced gflow ( implicitly also optimal gflow and ssf ) layers are equal to the original gflow layers from layer 1 onward .",
    "this allows us to construct a recursive proof for theorem [ thm_optimality ] , which we present in section [ sec_optimality_proof ] .      the equality of the last layers of an ssf and optimal gflow follows from lemma [ lem_last_layer ] and proposition [ prop_ssf ]  the last layer of an optimal gflow and an ssf is always the set of output vertices .",
    "what is left to prove is that the penultimate layers are also equal , for doing so we need the following properties of open graphs with ssf .",
    "an illustration of the property proven in the first of the two lemmas is shown in figure [ fig_strict_subset ] .",
    "[ lem_strict_subset ] let @xmath220 ) be an open graph with flow @xmath59 and corresponding ssf @xmath168 . if @xmath60 then for every strict subset @xmath218 of @xmath162 containing @xmath61 there must exist a non - output vertex @xmath56 that is oddly connected to @xmath218 such that @xmath221 , _",
    "i.e. _ @xmath222    if @xmath223 the lemma holds trivially , as there does not exist any nonempty strict subsets of @xmath162 .",
    "consider the case where @xmath162 contains more than one element and @xmath218 is a strict subset of @xmath162 .",
    "then we select any vertex @xmath224 from @xmath162 and look at the stepwise influencing paths from @xmath10 to @xmath14 .",
    "note that there might be more than one such path .",
    "we move backwards from @xmath14 towards @xmath10 over the stepwise influencing paths in the following way :    1 .",
    "move by two vertices if possible , choose any stepwise influencing path where the previous even - placed element is not in @xmath218 and move to that element .",
    "if the previous even - placed elements in all the stepwise influencing paths from @xmath10 to @xmath14 are in @xmath218 , then stop .",
    "repeat step 1 .",
    "let @xmath111 be the vertex to where we moved using the above process , @xmath111 has to exist because of the way we initially selected @xmath14 .",
    "there are a couple of other observations that we can make about @xmath111 .",
    "first , @xmath225 , because of the selection of @xmath14 and the way we moved on the paths .",
    "second , @xmath111 can not be the first even placed vertex on a stepwise influencing path from @xmath10 to @xmath111 because the first element is @xmath226 ( according to definition [ def_path ] ) .",
    "third , for every stepwise influencing path ending in @xmath111 , the previous even - placed vertex has to be in @xmath218 as otherwise we could have moved one more step towards @xmath10 .",
    "considering the previous three observations we can show that the vertex @xmath227 must be oddly connected to @xmath218 .",
    "we begin by noting that @xmath56 can not be connected to any vertex @xmath228 .",
    "otherwise , according to lemma [ lem_ext_path ] , we could extend any stepwise influencing path ending at @xmath90 with @xmath56 and @xmath198 .",
    "hence @xmath229 would then be an even - placed vertex on a stepwise influencing path from @xmath10 to @xmath198 .",
    "in particular , @xmath90 would be the second to last even - placed vertex on a stepwise influencing path from @xmath10 to @xmath230 every such vertex , except @xmath198 itself , is in @xmath218 as mentioned before .",
    "because , according to lemma [ lem_evenconnections ] , @xmath56 has to be evenly connected to @xmath162 , it has to be oddly connected to @xmath218 and lemma [ lem_strict_subset ] holds .",
    "next we need to show that every non - input vertex @xmath10 has a corresponding unique vertex @xmath231 , this is only true for those graphs with @xmath67 .",
    "[ lem_io_size ] if @xmath206 is a flow on an open graph ( g , i , o ) , then @xmath219 iff for every @xmath232 there exists @xmath157 .    first , if @xmath219 then also @xmath233 .",
    "the flow definition uniquely defines @xmath61 for every @xmath60 and therefore @xmath157 is uniquely defined for some , but not necessarily for all , vertices @xmath232 .",
    "the number of vertices for which @xmath58 is defined must equal the number of vertices for which @xmath234 is defined and because @xmath233 , @xmath234 must be defined for every element in @xmath45 .",
    "second , let us consider the case when for every @xmath232 there exists @xmath157 .",
    "the number of elements for which @xmath234 is defined equals the number of elements @xmath58 is defined for .",
    "@xmath58 is by definition [ def_flow ] defined for every element in @xmath46 .",
    "hence @xmath233 which implies that @xmath219 .",
    "note that the above requirement , _",
    "i.e. _ the existence of @xmath231 , is the only reason why our proof of theorem [ thm_optimality ] fails if @xmath235 .",
    "we conjecture that by padding the input with necessary ancilla qubits without changing the underlying computation we could extend the above theorem to the general graphs .",
    "however the proof of such result is outside of the scope of this paper and not relevant for the optimisation of quantum circuit .",
    "note that because of definition [ def_delayed_gflow ] if a gflow is not optimal , its penultimate layer has to either be equal to the penultimate layer of the optimal gflow or there exists a vertex in the penultimate layer of optimal gflow that is not included in the penultimate layer of the other gflow . in the proof of the main result",
    "we assume that the penultimate layers are not equal , hence we could choose a vertex with particular properties ( described in the next two lemmas ) to derive a contradiction .    . ]    . ]    [ lem_max_base ] let @xmath6 be an open graph where @xmath219 with flow @xmath59 , corresponding ssf @xmath168 and a gflow @xmath80 such that @xmath236 .",
    "assume there exists a vertex @xmath237 , then    * @xmath238 * @xmath239 * @xmath240    and there exists a vertex @xmath241 such that    * @xmath242 * @xmath243    because @xmath10 is in @xmath244 the set @xmath79 must be a subset of @xmath236 according to definition [ def_gflow_depth ] . proposition [ prop_ssf ]",
    "implies that @xmath245 .",
    "this and the fact that @xmath246 implies that @xmath162 is not a subset of the output vertices @xmath247 . therefore there must exist a non - output vertex in @xmath162 and , because @xmath238 , this vertex can not be contained in @xmath79 .",
    "thus the intersection of @xmath162 and @xmath79 can not be equal to @xmath162 and @xmath239 .",
    "we now show that @xmath240 .",
    "let us assume that @xmath248 , and choose a vertex @xmath249 connected to @xmath10 , such a vertex has to exist because the gflow definition says that @xmath10 is oddly connected to @xmath79 .",
    "as @xmath249 then by the gflow definition @xmath250 can not be an input qubit . according to lemma [ lem_io_size ]",
    ", there must exist a vertex @xmath251 to which @xmath250 is connected to . by the definition of flow ,",
    "@xmath251 can not be an output vertex and thus is not in layer @xmath252 . as @xmath238 this also means @xmath253 .",
    "on the other hand @xmath251 is connected to @xmath249 . because @xmath254 and @xmath255 we know from definition [ def_gflow_depth ] that @xmath256 .",
    "as @xmath251 is connected to @xmath79 we can conclude from the gflow definition that @xmath251 has to be evenly connected to @xmath79 and therefore has at least one more connection to a vertex @xmath257 .    using the same argument for @xmath258 as for @xmath250",
    "we can say that there must exist @xmath259 to which @xmath258 is connected to .",
    "let us assume that @xmath260 is not connected to @xmath250 .",
    "this means it has only one connection to the set @xmath261 and is therefore oddly connected to it .",
    "we can continue this procedure of selecting vertices from @xmath79 until we select a vertex @xmath262 such that @xmath263 is connected to at least one vertex @xmath264 in @xmath265 .",
    "if this happens we can no longer say with certainty that @xmath263 is oddly connected to @xmath266 , which means we can not select any more elements from @xmath79 using this method . because @xmath6 is a finite open graph we must find this @xmath262 in finite number of steps .",
    "we created the set @xmath267 in such a way that : @xmath268 hence we have a @xmath23-correction from every @xmath269 to @xmath270 and thus there exists a @xmath23-path from @xmath263 to every @xmath270 such that @xmath271 and , because of lemma [ lem_path ] , @xmath263 can not be connected to any vertex in @xmath272 .",
    "this leads to a contradiction with the assumption that it is connected to at least one vertex in @xmath272 .",
    "therefore our initial assumption that @xmath248 must be false and @xmath79 must contain @xmath61 .    from the definition of ssf we have that @xmath161 and therefore also @xmath273 .",
    "now we know that @xmath274 is a strict subset of @xmath162 containing @xmath61 ; the existence of @xmath241 follows from lemma [ lem_strict_subset ] .",
    "now we prove that if we have a vertex with the same properties as @xmath241 in lemma [ lem_max_base ] and a ( possibly empty ) subset @xmath275 of vertices with particular properties ( which will be defined in the next lemma ) we can always increase the size of @xmath275 and find another vertex with properties of @xmath241 .",
    "this would imply the possibility of increasing the size of @xmath275 to infinity and will give us the contradiction we need .",
    "[ lem_max_step ] let @xmath6 be an open graph where @xmath219 with flow @xmath59 , corresponding ssf @xmath168 and a gflow @xmath80 .",
    "if we have a vertex @xmath10 in the open graph such that    * @xmath238 * @xmath239 * @xmath240    and if we have a subset @xmath276 and another vertex @xmath241 such that    * @xmath242 * @xmath243 * @xmath277    then there exists another vertex @xmath278 and a non empty set @xmath279 such that    * @xmath280 * @xmath281 * @xmath282 * @xmath283 * @xmath284    the proof consists of three steps : we start by constructing the set @xmath129 ; we proceed with finding the vertex @xmath285 ; and finally we prove that @xmath285 has the required properties .",
    "define @xmath286 , since @xmath287 exists hence @xmath241 can not be an output vertex . also since @xmath238 therefore @xmath241 is not in @xmath79 . as @xmath288 and @xmath238",
    "we can conclude from definition [ def_gflow_depth ] that @xmath254 and @xmath289 . therefore according to the gflow definition",
    ", @xmath241 must be in the even neighbourhood of @xmath79 .",
    "we also know from the initial conditions of this lemma that @xmath241 is in the odd neighbourhood of @xmath274 .",
    "thus there has to exist a vertex @xmath210 in @xmath79 to which @xmath241 is connected to , but which is not included in @xmath274 , _",
    "i.e. _ @xmath290 . as @xmath291",
    ", @xmath292 can not be an input qubit and because @xmath234 exists for every non - input qubit according to lemma [ lem_io_size ] , there must exist a vertex @xmath293 .",
    "it is also important for the later part of the proof to note that @xmath294 .",
    "this is due to lemma [ lem_zpath_conn ] , which implies that @xmath241 can not be connected to any vertex in @xmath275 .",
    "define @xmath295 and consider the case when @xmath296 is evenly connected to @xmath297 .",
    "remember that the flow property ( f3 ) says that there is always an edge between @xmath296 and @xmath298 .",
    "this means that @xmath296 is oddly connected to @xmath299 which is a subset of @xmath79 . but",
    "again because of the gflow property ( g2 ) we have that @xmath296 must be evenly connected to @xmath79 . thus there must exist another vertex @xmath300 such that @xmath296 is connected to @xmath301 , otherwise @xmath296 could not be in the even neighbourhood of @xmath79 .",
    "if @xmath300 is evenly connected to @xmath302 , it must be oddly connected to @xmath303 which is again a subset of @xmath79 .",
    "if @xmath300 is oddly connected to @xmath304 there must exist a vertex @xmath305 such that @xmath305 is connected to @xmath306 , otherwise @xmath300 could not be in the even neighbourhood of @xmath79 .",
    "we can continue this scheme until we get to vertex @xmath307 that is oddly connected to @xmath308 .",
    "as @xmath309 and there exists an edge between @xmath307 and @xmath310 we get that @xmath307 must be evenly connected to @xmath311 .",
    "such vertex @xmath307 must exist , otherwise we could continue selecting elements from @xmath79 infinitely , but @xmath6 is a finite open graph .",
    "we select @xmath312 . recall that @xmath298 must exist ,",
    "therefore @xmath129 must have at least on element .",
    "next we show @xmath307 is oddly connected to @xmath218 .",
    "we note that we have the following : @xmath313 corollary [ cor_zcorr ] implies that for every @xmath314 there exists a @xmath23-correction from @xmath315 to @xmath316 .",
    "thus we have a @xmath23-path from @xmath307 to every other @xmath315 where @xmath317 , hence from lemma [ lem_zpath_conn ] we conclude @xmath307 can not be connected to any vertex @xmath318 where @xmath317 .",
    "the number of edges that connect the vertices in @xmath308 to vertex @xmath307 has to be the same as the number of edges between vertices of @xmath218 and @xmath307 , because @xmath319 .",
    "as @xmath307 was oddly connected to @xmath308 , it must also be oddly connected to @xmath218 .",
    "note that however @xmath307 does not have the required properties for @xmath285 , but will be used to find such a vertex .",
    "the gflow definition says that @xmath307 must be evenly connected to @xmath162 .",
    "it is also oddly connected to @xmath320 hence there must exist a vertex @xmath321 to which @xmath307 is connected to . according to lemma [ lem_path ] there",
    "exists a stepwise influencing path @xmath322 and due to definition [ def_path ] , @xmath61 has to be on on this path .",
    "therefore there exists at least one element in @xmath322 that is in @xmath218 .",
    "let @xmath323 be the last element of the path @xmath322 in @xmath218 .",
    "define @xmath250 to be the vertex in @xmath322 that comes after @xmath323 .",
    "we know that @xmath250 has odd many @xmath23-paths from @xmath10 because definition [ def_path ] implies that @xmath324 .",
    "if @xmath250 is already oddly connected to @xmath218 , then we are done and @xmath325 .",
    "if @xmath250 is evenly connected to @xmath326 , then we know that it must be oddly connected to @xmath327 .",
    "there must exist another vertex @xmath328 to which @xmath250 is connected to for it to be evenly connected to @xmath162 as is required by lemma [ lem_evenconnections ] . because @xmath329 we know there exists a stepwise influencing path @xmath330 ( lemma [ lem_path ] ) and we can extend that path by @xmath250 and @xmath331 as was proven in lemma [ lem_ext_path ]",
    ". we move backward on this path and find the element @xmath258 . if @xmath258 is oddly connected to @xmath218 , we are done and set @xmath332 .",
    "otherwise we can continue as was the case for @xmath250 until we find an element @xmath333 that is oddly connected to @xmath218 .",
    "this element must exist since graph is finite and the @xmath23 corrections do not create any loops .",
    "we select @xmath334 .",
    "note that @xmath333 can not be @xmath10 because @xmath335 but @xmath336 .",
    "there is a @xmath23-path from @xmath337 to @xmath250 ( we moved backwards along this path to find @xmath333 ) and from @xmath250 to @xmath307 because of the way we selected @xmath250 .",
    "there also exists a @xmath23-path from @xmath307 to every other @xmath315 such that @xmath338 , thus @xmath333 will also have a @xmath23-path to every @xmath315 in @xmath339 . even more , because : @xmath340 this completes the proof .",
    "finally we could put together lemmas [ lem_max_base ] and [ lem_max_step ] .",
    "[ lem_equal_layer ] let @xmath6 be an open graph with flow @xmath59 , corresponding ssf @xmath168 and optimal gflow @xmath80 such that @xmath219",
    ". then @xmath341 .",
    "assume @xmath342 we show how we can choose infinitely many different vertices from @xmath87 .",
    "due to definition [ def_delayed_gflow ] we have @xmath343 and since @xmath342 hence trivially @xmath344 and there must exist a vertex @xmath10 in @xmath345 .",
    "then from lemma [ lem_last_layer ] we have @xmath346 and using lemma [ lem_max_base ] we obtain the following :    * @xmath238 * @xmath240 * @xmath239    and that there exists another vertex @xmath241 such that    * @xmath242 * @xmath243    these constraints together with an empty set @xmath275 allow us to apply lemma [ lem_max_step ] .",
    "lemma [ lem_max_step ] is constructed in such a way that whenever we can apply it to a ( possibly empty ) set @xmath275 , it proves the existence of another set @xmath129 such that that @xmath347 and lemma [ lem_max_step ] is applicable to the new set @xmath348 .",
    "thus it is possible to apply lemma [ lem_max_step ] infinitely many times and construct a subset of @xmath87 containing infinitely many vertices .",
    "this leads to a contradiction as @xmath109 is a finite graph .",
    "the equality of penultimate layers of ssf and gflow might suggest that one could prove the equality of other layers simply by removing the last layer from the open graph and reapply the lemmas from the last section .",
    "however this would fail as the vertices in any layers can also use the output vertices in their correcting sets .",
    "therefore we need to be careful which vertices we remove such that the reduced graph still have a gflow .",
    "[ def_reduced_og ] if @xmath6 is an open graph with flow @xmath59 and corresponding ssf @xmath168 then we call the open graph @xmath349 a _ reduced open graph according to _ @xmath168 , where    * @xmath350 is the set of removed vertices .",
    "* @xmath351 where @xmath352 @xmath353 * @xmath354    we will omit `` according to ... '' and call @xmath349 just reduced open graph when it is clear from the text which ssf is used for constructing it .",
    "an example of a reduced open graph is shown in figure [ fig_reduced_og ]    as we saw in the previous section , we needed the fact that @xmath67 to be able to prove that the penultimate layers of ssf and optimal gflow are equal .",
    "if we want to apply the same lemmas to the new reduced open graph , we need to guarantee that if we start with a graph where input size equals output size , the same holds for the reduced open graph .",
    "[ lem_reduced_og_output ] let @xmath349 be a reduced open graph of the open graph @xmath6 , then @xmath355 .",
    "let @xmath356 be the set of vertices removed from @xmath109 , then for every vertex @xmath357 we have a corresponding unique vertex @xmath61 in @xmath356 since proposition [ prop_ssf ] implies that @xmath358 and @xmath161 .",
    "on the other hand , for every vertex in @xmath356 there exists a corresponding vertex in @xmath359 from the definition of @xmath356 .",
    "therefore for every vertex @xmath360 that we remove from @xmath5 when constructing @xmath354 we add another vertex @xmath361 and it must hold that @xmath355 .    the next lemma is used later to construct a gflow of the reduced open graph from the gflow of the original open graph .",
    "[ lem_set_property ] let @xmath6 be an open graph and @xmath275 and @xmath129 two sets in @xmath5 such that @xmath362",
    ". then @xmath363 .",
    "there are altogether four different possibilities for a vertex @xmath364 to be connected to the sets @xmath275 and @xmath129 satisfying @xmath362 as shown in figure [ fig_set_property ] : @xmath365 we see that every time @xmath56 is evenly connected to @xmath275 it is also evenly connected to @xmath366 and every time @xmath56 is oddly connected to @xmath275 it is also oddly connected to @xmath366 . because @xmath367 ans @xmath56 is in @xmath46 it must hold that @xmath363 .",
    "we start by creating a function that will be proven to have the required properties of the gflow .",
    "[ lem_reduced_gflow_existance ] let @xmath6 be an open graph with flow @xmath59 , ssf @xmath168 and optimal gflow @xmath80 such that @xmath219 .",
    "let @xmath349 be the ssf reduced open graph of @xmath6 with the removed vertices set @xmath356 , then there exists a function @xmath368 such that :    1 .",
    "@xmath369 2 .",
    "@xmath370    we start by noting that according to lemma [ lem_penultimate_layer ] we can create an optimal gflow @xmath97 of the open graph @xmath371 by restricting @xmath100 to @xmath372 and setting @xmath373 .",
    "we construct our desired @xmath374 function from @xmath99 .",
    "we consider @xmath375 , if there exists a vertex @xmath376 then from the reduced open graph definition we have @xmath377 . also from lemma [ lem_equal_layer ] we have @xmath378 and thus @xmath379 .",
    "according to proposition [ prop_ssf ] this means that @xmath380 .",
    "we have @xmath381 since the only odd neighbours of @xmath382 are either output vertices or the vertex @xmath383 .",
    "now we define @xmath384 , hence @xmath385 .",
    "moreover lemma [ lem_set_property ] implies that @xmath386 .",
    "also @xmath387 since @xmath388 .",
    "note that , since the new set will be constructed via a union of two sets we might add another vertex @xmath389 to the set @xmath390 .",
    "however , we can remove any such vertex @xmath90 added to @xmath390 by applying the same procedure recursively . for every such vertex @xmath90",
    ", it must hold that @xmath391 since @xmath392 and proposition [ prop_ssf ] implies the existence of a @xmath23-path from @xmath157 to @xmath208 .",
    "now we remove @xmath90 via the above procedure _ i.e. _ defining @xmath393 .",
    "if this would add vertex @xmath14 again to @xmath390 , hence there exists a @xmath23-path from @xmath208 to @xmath157 and @xmath394 which contradicts the previous relation .",
    "this procedure will eventually terminate and remove all undesired vertices @xmath389 since in the above procedure we never create any @xmath23-path loops .",
    "we call a function which satisfies properties ( 1 ) and ( 2 ) of lemma [ lem_reduced_gflow_existance ] the _ reduced gflow function _ of @xmath100",
    ". we can interpret these properties as saying that the gflow function @xmath374 differs from the gflow function @xmath100 only by the vertices in @xmath395 , _",
    "i.e. _ the other elements in the correcting set are left unchanged .",
    "as a gflow consists of a function and a partial order , we still need to define a valid partial order .",
    "the one that is most useful to us is such that it preserves as much relations as possible from the original gflow , hence the layering structures remain similar .    [ lem_ordering ]",
    "let @xmath6 be an open graph with ssf @xmath168 , gflow @xmath80 and @xmath349 a reduced open graph of @xmath349 . if @xmath374 is a reduced gflow function of @xmath80 , then @xmath92 is a gflow of @xmath349 , where @xmath396    we will show that @xmath92 satisfies the three gflow properties ( g1 ) - ( g3 ) in definition [ def_gflow ] .",
    "first property requires that if @xmath397 , then @xmath398 .",
    "this is obviously true if @xmath399 .",
    "if @xmath400 , from lemma [ lem_reduced_gflow_existance ] we have @xmath401 which implies that @xmath76 because @xmath80 is a gflow .",
    "now according the definition of @xmath402 it must also hold , that @xmath398 .",
    "now we consider the gflow property ( g2 ) .",
    "for every @xmath403 it must be that @xmath53 or @xmath398 .",
    "if @xmath399 , then again this is obviously true because of the definition of @xmath402 . if @xmath404 then we know that @xmath175 and @xmath53 or @xmath76",
    "according to the definition of @xmath402 , @xmath76 implies that @xmath398 and we have that if @xmath403 then either @xmath405 or @xmath398 .",
    "thus the gflow property ( g2 ) is satisfied .",
    "finally , we require for gflow property ( g3 ) that @xmath406 and as @xmath375 this is true because of the properties of @xmath374 .",
    "we call the gflow @xmath92 from lemma [ lem_ordering ] the _ reduced gflow _ of @xmath80",
    ". similarly we can construct the ssf of the reduced open graph .",
    "note that an ssf can only exist if the reduced open graph has flow . thus arises the need to prove the existence of a flow on the reduced open graph , as is done in the next lemma .",
    "[ lem_restricted_flow ] if @xmath6 is an open graph with flow @xmath59 and if @xmath349 is the reduced open graph described in definition [ def_reduced_og ] , then @xmath407 , where    * @xmath408 * @xmath409 $ ]    is a flow of @xmath349 .",
    "it is sufficient to show that @xmath407 satisfies the flow properties ( f1 ) - ( f3 ) in definition [ def_flow ] and that @xmath410 is a function from @xmath411 to @xmath45 .",
    "it is easy to see that @xmath412 .",
    "@xmath410 acts by definition on @xmath411 and @xmath413 the graph @xmath414 has fewer vertices than @xmath109 , therefore we need to show that all the vertices required according to the flow function @xmath410 are included in @xmath414 , _",
    "i.e. _ @xmath415 it must hold that @xmath416 . according to definition [ def_reduced_og ]",
    "every vertex @xmath56 removed from the initial open graph @xmath6 is chosen such that @xmath417 .",
    "therefore it must be that every vertex @xmath418 such that @xmath419 must be an output vertex in @xmath420 . because @xmath421 is not defined for outputs the vertices removed from the original graph @xmath109 are not needed for @xmath410 and @xmath412 .",
    "hence we have that @xmath422 for every vertex @xmath375 and @xmath423 .",
    "let @xmath356 be the set of removed vertices as defined in definition [ def_reduced_og ] .",
    "the flow property ( f1 ) states that @xmath424 and holds because : @xmath425    to prove that @xmath407 satisfied flow property ( f2 ) we need to show that for every @xmath418 if @xmath426 then either @xmath53 or @xmath427 .",
    "@xmath428    finally the flow property ( f3 ) @xmath429 holds almost trivially : @xmath430    next we prove that the reduced gflow of an ssf is also an sff .",
    "[ lem_restricted_ssf ] let @xmath6 be an open graph with flow @xmath59 and ssf @xmath168 .",
    "if @xmath349 is the reduced open graph , according to @xmath168 , then there exists an ssf @xmath431 of @xmath349 such that @xmath431 is the reduced gflow of @xmath168 .",
    "let @xmath356 be the set of vertices removed from @xmath6 to get @xmath349 .",
    "the reduced flow @xmath407 exists because of lemma [ lem_restricted_flow ] . define @xmath431 to be the the ssf derived from this reduced flow .",
    "assume @xmath431 is not a reduced gflow of @xmath168 , then one of the properties of lemma [ lem_reduced_gflow_existance ] should not hold , we show a contradiction in both cases .    if the first property does not hold then @xmath432 \\rightarrow \\\\           & & ( parity(\\zeta_i^{s}(f^{-1}(j ) ) ) = 1 \\land parity(\\zeta_i^{s'}(f^{-1}(j ) ) ) = 0 ) \\lor \\\\           & & ( parity(\\zeta_i^{s'}(f^{-1}(j ) ) ) = 1 \\land parity(\\zeta_i^{g}(f^{-1}(j ) ) ) = 0 ) \\rightarrow \\\\ & & parity(\\zeta_i^{s}(j ) ) \\neq parity(\\zeta_i^{s'}(j ) )      \\end{aligned}\\ ] ] hence by removing vertices and edges from the open graph @xmath6 we must have changed @xmath433 by an odd number to get @xmath434 .",
    "we look at how removing the vertices in @xmath356 from the open graph @xmath6 changes @xmath433 . removing a vertex @xmath56 changes the number of @xmath23-paths from @xmath10 to @xmath157 if by removing it we also remove an edge in the @xmath23-correction graph @xmath108 .",
    "let this removed edge be @xmath435 , then corollary [ cor_zcorr ] implies that @xmath436 and @xmath56 has to be either @xmath90 , @xmath437 or @xmath121 .",
    "corollary [ cor_zcorr ] also implies that for @xmath56 to have an outgoing edge in @xmath108 , @xmath198 has to be defined .",
    "since @xmath58 is not defined for output vertices and @xmath438 , there can not be any outgoing edges from @xmath56 .",
    "therefore @xmath56 can not be @xmath90 as there is an edge from @xmath90 to @xmath437 in @xmath108 .",
    "also @xmath56 can not be @xmath437 since again @xmath56 can not have an outgoing edge in @xmath108 , hence @xmath56 would have to be the last element on the @xmath23-path from @xmath10 to @xmath157 , which is @xmath157 .",
    "this is impossible , as @xmath157 can not be an output vertex .",
    "therefore the only possibility is that @xmath439 .",
    "let @xmath56 be the first vertex removed from @xmath109 , such that @xmath433 changes by an odd number .",
    "hence all the paths from @xmath10 to @xmath157 that disappear due to removal of @xmath56 have to go through @xmath440 .",
    "therefore there must also exist an odd number of paths from @xmath440 to @xmath157 .",
    "we know that because of proposition [ prop_ssf ] , @xmath441 and @xmath442 . on the other hand",
    "because of definition [ def_reduced_og ] it must also hold that @xmath361 , which together with definition [ def_gflow_depth ] implies that @xmath443 .",
    "this leads to a contradiction , because @xmath14 has to be in @xmath444 and can not be in @xmath5 . therefore",
    "property @xmath445 must be true for @xmath431 .",
    "now we show that property @xmath446 has to hold . according to lemma [ lem_evenconnections ] : @xmath447 because @xmath448 , it must also hold that @xmath449 and property @xmath446 has to be true for @xmath431 .    in the specific case",
    "where @xmath67 , it will follow from lemma [ lem_restricted_ssf ] that the unique ssf of a reduced open graph is the reduced gflow of the original ssf .",
    "[ cor_restricted_ssf ] let @xmath6 be an open graph with an ssf @xmath168 such that @xmath67 . if @xmath349 is the reduced open graph , according to @xmath168 , of @xmath6 , then the unique ssf @xmath431 of @xmath349 has the following properties :    1 .",
    "@xmath450 2 .",
    "@xmath451    because of lemma [ lem_restricted_flow ] @xmath349 has a flow . since @xmath219 ,",
    "then according to lemma [ lem_reduced_og_output ] @xmath452 and hence @xmath453 has a unique flow @xcite .",
    "flow is required for the existence of an ssf according to proposition [ prop_ssf ] , therefore there can exist only one ssf and because of lemma [ lem_strict_subset ] this ssf has to satisfy properties ( 1 ) and ( 2 ) .",
    "we have proven that the penultimate layers of ssf and optimal gflow are equal if @xmath67 .",
    "then we showed how to remove some vertices from the open graph and construct an ssf and optimal gflow on the new reduced graph . both of them are reduced gflows , a property which we will use in this section to show that they preserve the layering of the gflows they were derived from .",
    "[ lem_layering ] let @xmath6 be an open graph with ssf @xmath168 and gflow @xmath80 such that @xmath349 is the reduced open graph of @xmath6 with the removed vertices set @xmath356 .",
    "for every reduced gflow @xmath92 of @xmath349 such that @xmath454 and @xmath455 it must hold that @xmath456    we prove lemma [ lem_layering ] by induction and showing first that equation [ eq_layering ] holds if @xmath457 , _ i.e. _ we need to prove that @xmath458 lemma [ lem_last_layer ] tells that @xmath459 and @xmath236 . because the penultimate layers of ssf @xmath168 and gflow @xmath80 are equal we also have that @xmath455 .",
    "now we take the definition of @xmath395 from definition [ def_reduced_og ] of the reduced open graph and substitute the appropriate sets : @xmath460 thus equation [ eq_layering ] holds for @xmath457 . for the induction step",
    "we assume that equation [ eq_layering ] holds for @xmath461 , _",
    "i.e _ @xmath462 and show that it holds for @xmath463 .",
    "we use contradiction and assume that @xmath464 there are two possibilities : either @xmath465 or @xmath466 .",
    "we note that according to lemma [ lem_ordering ] @xmath467 if @xmath375 and @xmath468 . because @xmath469 for every @xmath470 we have that @xmath471 as can be seen above , both of the possible cases lead to a contradiction and",
    "hence it must hold that @xmath472 this completes the induction step and the proof itself .",
    "from the previous lemma we can construct a proof saying that every layer of a reduced gflow starting from the second to last one is equal to a layer of the original gflow .",
    "[ cor_layering ] let @xmath6 be an open graph with ssf @xmath168 and gflow @xmath80 such that @xmath349 is the reduced open graph of @xmath6 with the removed vertices set @xmath356 .",
    "for every reduced gflow @xmath92 of @xmath349 such that @xmath454 and @xmath455 it must hold that @xmath473    this follows trivially from lemma [ lem_layering ] .",
    "we have that if @xmath474 : @xmath475 we can now subtract the elements of the second set from the first .",
    "@xmath476 because definition [ def_reduced_og ] of ssf reduced open graph we know that @xmath477 .",
    "lemma [ lem_last_layer ] says that @xmath478 , hence we know that no element in @xmath356 can be included in @xmath479 for @xmath480 and @xmath481 .",
    "it turns out , that if the gflow we have for the original open graph is the optimal one , then the reduced gflow will be optimal for the reduced open graph .",
    "[ lem_reduced_optimal_gflow ] let @xmath6 be an open graph with ssf @xmath168 and optimal gflow @xmath80 .",
    "if @xmath349 is the reduced open graph of @xmath6 then the reduced gflow @xmath92 of @xmath80 is the optimal gflow of @xmath349 .",
    "first , because of lemma [ lem_ordering ] @xmath482 has to be a gflow of @xmath349 .",
    "let us assume that @xmath92 is not the optimal gflow of @xmath349 and let @xmath483 be the optimal one . then according to definition [ def_delayed_gflow ] @xmath484 and since @xmath485 from lemma [ lem_layering ] we obtain @xmath486 , where the @xmath356 is the set of vertices removed from the original graph .",
    "now we know from definition [ def_delayed_gflow ] that @xmath10 is in @xmath479 which according to corollary [ cor_layering ] must be equal to @xmath487 .",
    "this leads to a contradiction because @xmath488 and thus @xmath92 has to be the optimal gflow of @xmath349",
    ".      we can now prove theorem [ thm_optimality ] by showing that the vertex layering of any ssf and an optimal gflow is exactly the same .",
    "let @xmath6 be an open graph with flow @xmath59 such that @xmath219 .",
    "let @xmath168 be the ssf obtained from @xmath59 according to proposition [ prop_ssf ] and @xmath80 the optimal gflow of @xmath6 . according to proposition [ prop_ssf ] the last layer of any ssf is the set of output vertices .",
    "lemma [ lem_last_layer ] says that this is also true for the last layer of an optimal gflow , therefore @xmath489 .",
    "the layers @xmath490 and @xmath491 are equal because of lemma [ lem_equal_layer ] .",
    "now we need to show that layers @xmath492 and @xmath493 are equal for @xmath494 .",
    "we can construct a reduced open graph ( definition [ def_reduced_og ] ) @xmath349 from @xmath6 .",
    "we now consider the unique ssf @xmath431 and reduced gflow @xmath92 of @xmath349 , which according to lemma [ lem_reduced_optimal_gflow ] is optimal .",
    "according to lemma [ lem_layering ] , @xmath495 for every @xmath474 and because ssf is by theorem [ theorem_ssfisgflow ] a gflow the same lemma also implies that @xmath496 .",
    "because of the way a reduced open graph is defined , we know that @xmath452 ( lemma [ lem_reduced_og_output ] )",
    ". thus we can again use lemma [ lem_equal_layer ] to say that @xmath497 .",
    "we can now take @xmath349 and find its reduced open graph to show using the same technique that @xmath498 .",
    "this can be continued until we reach the empty layers , in which case we have considered all the layers according to @xmath168 and @xmath80 .",
    "as every layer of @xmath168 and @xmath80 will be equal and @xmath80 is the optimal gflow , the ssf of a flow of an open graph @xmath6 is an optimal gflow if @xmath67 , which proves theorem [ thm_optimality ] .",
    "in the last section we presented an automated parallelisation technique for measurement patterns .",
    "however , when we translate those parallel measurement patterns back to the circuit model using the method described in @xcite , we end up with quantum circuits with many ancilla qubits .",
    "more specifically , the new circuits will have the same number of qubits as there are vertices in the associated mbqc graph .",
    "our next main result of the paper is a new scheme that explore the notion of circuit compactification introduced in @xcite to remove all ancilla qubits introduced by the back - and - forth translation between the two models .",
    "we start by reviewing the notion of extended circuits , which is basically a re - interpretation of measurement patterns using circuit notation .",
    "then we derive a set of rewrite procedures that combine the rewrite rules introduced in @xcite in such a way that the ssf layering function ( and , consequently , the optimised depth ) does not change in the process of removing ancilla qubits from an ssf extended circuit .",
    "finally , we introduce the algorithm that make use of rewrite procedures to completely rewrite an extended circuit until all ancilla qubits are removed .",
    "a straightforward translation method for measurement patterns , which we refer to as _ extended translation _ , was introduced in @xcite .",
    "this translation is inefficient , in the sense that it gives as many circuit wires as vertices in the original pattern ( instead of inputs only ) .",
    "however its importance comes from the fact that its very easy to implement since the procedure to obtain an extended circuit is just a re - interpretation of the measurement pattern using the quantum circuit notation .",
    "moreover , it will serve as a starting point to obtain more compact circuits for patterns with signal - shifted flow .     and",
    "the corresponding extended circuit . ]    [ def_ext ] given a signal shifted measurement pattern with computational space  @xmath499 and underlying geometry  @xmath47 with ssf @xmath168 . the corresponding _ extended circuit _",
    "@xmath500 with  @xmath501 input qubits and  @xmath502 ancilla qubits , is constructed in the following steps :    1 .",
    "each vertex on the graph is translated as a circuit wire .",
    "the wires corresponding to @xmath45 are prepared in the sate @xmath11 .",
    "each edge linking vertices @xmath10 and @xmath14 on the graph ( command @xmath503 ) is translated as a @xmath504 in the beginning of the circuit .",
    "each dependent measurement @xmath505^{s(i)}$ ] is translated as a gate @xmath506 in wire @xmath10 followed by controlled-@xmath22 operator with qubit @xmath10 as control and @xmath507 as the target .",
    "the layering respects the @xmath149 by replacing the control just after the @xmath508-gate and the target just before the @xmath508-gate of the next measurement command .",
    "each correction on the output qubits @xmath509 ( @xmath510 pauli -x or -z ) is translated as a controlled-@xmath500 gates at with qubit @xmath10 as control and @xmath14 as target .",
    "the layering again respects @xmath149 by putting the control right after the @xmath508-gate and all the corresponding @xmath511 ( introduced in step 4 ) acting on qubit @xmath10 .",
    "all the qubits in @xmath46 will be measured in the computational basis .",
    "the obtained layering structure is referred to as @xmath512 , @xmath513 , and @xmath514 , each containing only entangling gates , @xmath508-gates , and correction gates , respectively .",
    "we also divide slices @xmath514 into @xmath515 many smaller slices @xmath516 , where @xmath515 is the total number of @xmath508-gates in slice @xmath513 .",
    "each slice @xmath516 contains all correction gates with control on qubit @xmath10 s.t .",
    "@xmath517 is in @xmath513 .",
    "it is easy to verify that the above circuit implements the same operator as the measurement pattern ( see also @xcite ) . for clarity , in what follows",
    "we will refer to a @xmath504 created in step 3 above as @xmath503 while keeping the notation @xmath504 for those created in step 5 . later on we will use the fact that , for a signal shifted pattern ( equation [ eq_ssf_pattern ] ) , a @xmath518 or @xmath519 will be created in the corresponding extended circuit if and only if @xmath145 or @xmath520 , respectively .",
    "note that by construction , all gates associated to operators @xmath503 are initially in slice @xmath521 ( step 3 in definition [ def_ext ] ) , with @xmath522 all empty .",
    "however during the compactification procedure while we rewrite the circuit new gates will be added to these empty slices .",
    "figure [ fig_examplessf]-b shows the extended circuit of the following signal shifted measurement pattern with associated graph given in figure [ fig_examplessf]-a .",
    "@xmath523      compactification procedures can be described as a way of globally rewriting extended circuits in order to remove ancilla ( non - input ) wires .",
    "one way to achieve this is to rewrite the circuit to create _",
    "@xmath508-blocks _ , defined as follows .",
    "[ def_jblock ] consider a measurement pattern with computational space  @xmath499 and underlying geometry  @xmath47 with flow @xmath59 and corresponding extended circuit @xmath500 .",
    "we say there is a _",
    "@xmath508-block _ in wires @xmath10 and @xmath61 if the following set of conditions are satisfied ( see figure [ fig_jgate]-a ) :    1 .",
    "the initial state of wire @xmath61 is @xmath524 .",
    "2 .   the gates sequence ( @xmath525 , @xmath526 , @xmath527 ) appears in @xmath500 .",
    "the only gate acting on the wire @xmath61 before @xmath527 is @xmath525 .",
    "4 .   the only gates acting on wire @xmath10 after @xmath525 are @xmath526 and @xmath527 .",
    "5 .   after @xmath527 gate",
    ", the qubit @xmath10 is measured in the @xmath23 basis .    once a @xmath508-block is created ( via circuit rewriting )",
    ", one can use the identity in figure [ fig_jgate ] ( @xmath508-gate identity ) to remove one wire from the circuit . in general , extended circuits",
    "are not prepared for direct applications of the @xmath508-gate identity . in definition",
    "[ def_ext ] , all corrections @xmath509 are translated as controlled - gates with control placed after @xmath517 gate .",
    "hence condition 4 in definition [ def_jblock ] is not satisfied in general .",
    "moreover , since all @xmath528 gates are initially placed in slice @xmath521 , condition 3 is not satisfied either for any open graph with more than two non - output qubits ( see example in figure [ fig_examplessf]-b ) . in order to create @xmath508-blocks in ssf",
    "extended circuits , we explore the relation between the @xmath528 gates and the correcting gates @xmath500 , since the latter are defined accordingly to the former through the stabilizer formalism . in other words",
    ", there is a direct relation between the gates in slice @xmath521 and all other two - qubit gates in the rest of the extended circuit . in the case where we succeed in removing as many wires as there are non - output qubits in the graph",
    ", we say that the resulting circuit is in a _",
    "compact form_. we will refer to circuits in the compact form as _ compact circuits_.    -gate identity _ will be used repeatedly to simplify generic extended circuits .",
    "note that the @xmath508-gate angles differ from each other by a minus sign . ]",
    "[ def_compactform ] let  @xmath500 be the extended circuit of a measurement pattern with computational space @xmath499 .",
    "we say that @xmath500 can be put into a compact form if there exists a sequence of circuit rewriting equations such that the @xmath508-gate identity ( figure [ fig_jgate ] ) can be applied @xmath529 times .",
    "is in the @xmath524 state ) .",
    "the circuit identity in figure ( d ) ( figure ( e ) ) is obtained by multiplying @xmath519 ( @xmath530 ) in both sides of the identity in figure ( a ) ( figure ( c ) ) . ]    a collection of circuit identities with the purpose of exploring the aforementioned relation between gates in extended circuits to create @xmath508-blocks was introduced in @xcite ( figure [ fig_rules ] ) .",
    "a compactification procedure for graphs with flow was provided and some simple examples of graphs with gflow explored . in this section",
    "we present a novel algorithm able to rewrite ssf extended circuits to put it into a compact form . in what follows",
    "we present the circuit identities that will be used in the algorithm , which we will refer to as rewrite procedures ( rps ) .",
    "we refer to the @xmath10 wire of each rp as the _ target wire _ , @xmath531 as the _ correcting wires _ and finally @xmath90 as the _ neighbour wire_. moreover , when we need to emphasize which rp we are referring to we also add a superscript to the wire label ; for instance @xmath532 indicates the neighbour wire of rp2 .",
    "* * rewrite procedure 1 . *",
    "the circuit identity in figure [ fig_rp1 ] moves gates @xmath533 past gates @xmath534 , adding @xmath535 many gates @xmath519 to slice @xmath536 in the process . using the rewrite rule in figure [ fig_rules]-d each of those @xmath528 gates",
    "can be moved past gates @xmath534 in @xmath536 , creating a new @xmath519 each time the rule is applied ( figure [ fig_rp1]-c ) .",
    "although all @xmath528 gates are drawn in the @xmath537 slice , it is sufficient that those @xmath528 gates are placed just before the corresponding @xmath511 gates ( that is , with no gate in between ) ) . ] * * rewrite procedure 2 .",
    "* the circuit identity in figure [ fig_rp2 ] replaces gates @xmath538 in slice @xmath537 with @xmath539 @xmath540 in slice @xmath536 , removing gate @xmath541 in the process .",
    "we use the rewrite rule in figure [ fig_rules]-b for each pair @xmath542 transforming gates @xmath543 into @xmath544 , as depicted in figure [ fig_rp2]-b .",
    "the new @xmath511 gates can be pushed forward to the beginning of slice @xmath536 , since it commutes trivially with @xmath545 . using the rewrite rule in figure [ fig_rules]-e we can commute @xmath544 past @xmath546 creating @xmath547 many new @xmath541 in the process , which together with the pre - existing @xmath541 in @xmath536 will cancel out , resulting in the circuit depicted in figure [ fig_rp2]-c .",
    "+ + , slices @xmath548 and @xmath549 become the same ; the rewrite procedure remains exactly the same .",
    "] * * rewrite procedure 3 . *",
    "the circuit identity in figure [ fig_rp3 ] replaces gates @xmath550 in slice @xmath551 with @xmath552 @xmath553 in slice @xmath536 .",
    "we use the rewrite rule in figure [ fig_rules]-b for each pair @xmath554 @xmath555 transforming gates @xmath556 into @xmath557 ( figure [ fig_rp3]-b ) .",
    "the new @xmath511 gates can be pushed forward to the beginning of slice @xmath536 , since it commutes trivially with @xmath558 . using the rewrite rule in figure [ fig_rules]-e we can commute @xmath557 past @xmath559 , creating @xmath1 many @xmath560 in the process .",
    "since @xmath1 is even , all those @xmath511 gates will cancel , resulting in the circuit depicted in figure [ fig_rp3]-c .",
    ", slices @xmath548 and @xmath549 become the same ; the rewrite procedure remains exactly the same . ]    in order to apply the @xmath508-gate identity for the pair of wires @xmath561 of a ssf extended circuit , we need to rewrite it until all conditions in definition [ def_jblock ] are satisfied . in a ssf extended circuit ,",
    "the first two conditions are trivially satisfied for any pair of wires @xmath561 and , therefore , we need to rewrite the circuit to satisfy the other conditions . to do so we analyse each qubit @xmath90 in the neighbourhood of @xmath162 , classifying it according to three different cases : ( i ) @xmath562 , ( ii ) @xmath563 and @xmath564 and ( iii ) @xmath563 and @xmath565 .",
    "this separation into cases is necessary for two reasons : first , the distinction between @xmath562 and @xmath563 is necessary because we are interested in keeping the @xmath508-gate parallelization introduced by signal shifting and hence we need a different procedure to deal with each case .",
    "secondly , in the case where @xmath563 , we use the rewrite rule in figure [ fig_rules]-b which deletes @xmath528 gates .",
    "since condition 2 in definition [ def_jblock ] requires the existence of gates of form @xmath566 , we will treat differently cases where @xmath564 and @xmath565 to guarantee those @xmath528 gates will not be removed from the circuit . as we show next , for each case one of the rps can be applied if a set of prior conditions are satisfied .",
    "[ prop_rp1 ] let @xmath10 be a wire in a ssf extended circuit s.t .",
    "@xmath517 is in some slice @xmath513 . if there exists a wire @xmath90 s.t .",
    "( i ) @xmath562 and ( ii ) the set of gates @xmath567 ( with @xmath568 ) can be pushed to slice @xmath513 , then rp1 ( figure [ fig_rp1 ] ) can be applied .    since @xmath562",
    ", the gate @xmath569 belongs to a future slice @xmath570 ( @xmath571 ) .",
    "also , @xmath568 implies @xmath572 and hence the gates @xmath573 are in slices after @xmath513 as well .",
    "moreover , @xmath568 implies there exist operators @xmath574 in the measurement pattern , which are translated to the extended circuit as a @xmath575 in slice @xmath516 ( according to definition [ def_ext ] ) .",
    "thus , if every gate @xmath576 , @xmath145 , can be trivially pushed to slice @xmath513 , we have exactly the scenario depicted in figure [ fig_rp1]-a .",
    "therefore , the circuit identity in figure [ fig_rp1 ] can be applied .    for reasons",
    "that will become clear in the section [ sec_alg ] , where the algorithm to obtain compact circuits from ssf extended circuits is introduced , we need to consider a case which is slightly different from the scenario described in proposition [ prop_rp1 ] . in this case ,",
    "condition ( ii ) in proposition [ prop_rp1 ] is not satisfied because some of the @xmath528 gates are in slice @xmath516 but can not be pushed trivially back to @xmath513 .",
    "the only scenario where that could happen is if there exists @xmath577 in slice @xmath516 and some of the @xmath576 gates are placed past it ( and hence can not be pushed trivially to @xmath513 ) . in this scenario ,",
    "as we show next , rp1 can also be applied .",
    "[ prop_rp1b ] let @xmath10 be a wire in a ssf extended circuit s.t .",
    "@xmath517 is in some slice @xmath513 . if there exists a wire @xmath90 s.t .",
    "( i ) @xmath209 and ( ii ) gates @xmath567 ( with @xmath568 ) can either be all pushed to slice @xmath513 or just some can be pushed to slice @xmath513 and the other @xmath528 gates are placed in @xmath516 just after @xmath530 , then rp1 ( figure [ fig_rp1 ] ) can be applied .",
    "the proof of this proposition is trivial due to its similarity to proposition [ prop_rp1 ] .",
    "first , note that @xmath209 implies @xmath562 and hence condition ( i ) in this proposition is equivalent to the one in proposition [ prop_rp1 ] .",
    "therefore , if all gates in the set @xmath567 can be pushed to slice @xmath513 we have exactly the conditions in proposition [ prop_rp1 ] and there is nothing to prove . the other possibility is when a subset of the set @xmath567 can be pushed to slice @xmath513 but gates in the complementary subset are placed in slice @xmath516 , after gate @xmath530 ( which exists since @xmath209 ) .",
    "it is easy to note that it will not prevent the application of rp1 , since the only gate in @xmath516 that could be placed in between the @xmath528 and @xmath511 gates used in rp1 , namely @xmath530 , is assumed in condition ( ii ) to be placed before the gates of the form @xmath576 .    in the next lemma",
    "we show the interesting effect of applying rp1 to ssf extended circuits .",
    "[ lem_rp1 ] the application of rp1 to a pair of target and neighbour wires @xmath578 of a ssf extended circuit removes all @xmath519 from the circuit .    according to definition [ def_ext ] , all @xmath13 gates with control in wire @xmath10 are placed in slice @xmath516 and hence we only need to show that all @xmath519 in that slice are removed .",
    "let us divide the analysis into two cases : ( i ) @xmath520 and ( ii ) @xmath579 .",
    "consider the first case .",
    "since @xmath520 , there exists a @xmath130 in the measurement pattern and hence there exists a gate @xmath519 in slice @xmath516 . for this case ,",
    "the index @xmath535 in rp1 is an odd number and therefore the application of rp1 creates odd many @xmath519 gates in slice @xmath516 .",
    "note that those @xmath519 gates can be created in different parts of @xmath516 ( depending whether proposition [ prop_rp1 ] or [ prop_rp1b ] is satisfied ) such that they can not be grouped together trivially ( like in figure [ fig_lemczcx]-a ) .",
    "it is easy to verify that the only possible scenario for that to happen is when there exists @xmath530 in @xmath516 in between the created @xmath519 gates .",
    "however , those @xmath519 gates can be grouped together by moving all @xmath519 to one side of the troublesome @xmath530 using the identity    @xmath580    where @xmath581 and @xmath582 are arbitrary quantum sates and @xmath23 is the pauli operator ( see figure [ fig_lemczcx]-b ) .",
    "this way , since there exist even many @xmath519 in sequence and even many @xmath13 gates equal the identity , all @xmath519 can be simply removed from the circuit .",
    "the created single - qubit gate @xmath583 can be pushed forward to the end of the @xmath10 wire , since it commutes with all gates in @xmath516 . moreover , since the final measurement is onto the @xmath23-basis , the operator @xmath583 has no effect in the measurement statistics and therefore can be removed from the circuit without changing the computation being implemented by the circuit ( figure [ fig_lemczcx]-c ) .",
    "an equivalent analysis applies for the second case , where @xmath579 . for this case",
    "rp1 create even many @xmath519 in slice @xmath516 and there is no pre - existing @xmath519 in that slice .",
    "the same identity can be used to group together all created @xmath519 , which cancel out since there are even many of those . since both created and pre - existing @xmath519 are removed from the circuit by the application of rp1 , the lemma holds .     from a ssf extended circuit .",
    "see lemma [ lem_rp1 ] for more information . ]",
    "now we analyze the cases where @xmath563 , that is , with @xmath569 gate blocking all gates of form @xmath576 to be pushed past the correction gates ( necessary to satisfy condition 3 in definition [ def_jblock ] ) .",
    "since in those cases the corresponding rp will delete @xmath528 gates and we do not want to delete e gates of the form @xmath584 ( see definition [ def_jblock ] ) , we analyze separately the case where @xmath564 ( proposition [ prop_rp2 ] ) and the case where @xmath565 ( proposition [ prop_rp3 ] ) .",
    "[ prop_rp2 ] let @xmath10 be a wire in a ssf extended circuit s.t .",
    "@xmath517 is in slice @xmath513 . if there exists a wire @xmath90 such that the following conditions are satisfied : ( i ) @xmath563 ; ( ii ) @xmath564 ; ( iii ) gates @xmath585 ( with @xmath586 ) can be trivially pushed to some slice @xmath587 ( containing @xmath569 ) ; and ( iv ) the @xmath566 gate is the first gate acting on wire @xmath121 , then rp2 ( figure [ fig_rp2 ] ) can be applied .    since @xmath563 , @xmath588 . in slice @xmath589",
    "there is a @xmath558 ; since @xmath564 , we define @xmath590 .",
    "also , @xmath586 implies that @xmath591 and hence the gates @xmath592 are in some future slices ( compared to @xmath1 ) .",
    "moreover , it also implies the existence of the operators @xmath593 in the measurement pattern , which are translated to the extended circuit as @xmath594 in slice @xmath516 ( containing all the @xmath511 and @xmath13 with control on qubit @xmath10 ) . on the other hand",
    ", @xmath563 implies both @xmath579 and @xmath595 and therefore there is no @xmath519 or @xmath530 in the circuit .",
    "thus , if every gate @xmath585 can be trivially pushed to slice @xmath587 and @xmath566 is the first gate acting on wire @xmath596 , we have exactly the scenario depicted in figure [ fig_rp2]-a .",
    "therefore , the circuit identity in figure [ fig_rp2 ] can be applied .",
    "[ prop_rp3 ] let @xmath10 be a wire in a ssf extended circuit s.t .",
    "@xmath517 is in slice @xmath513 . if there exists a wire @xmath90 such that the following conditions are satisfied : ( i ) @xmath563 ; ( ii ) @xmath565 ; ( iii ) gates @xmath585 ( with @xmath586 )",
    "can be trivially pushed to slice @xmath587 ( containing @xmath569 ) ; and ( iv ) the @xmath566 gate is the first gate acting on wire @xmath121 , then rp3 ( figure [ fig_rp3 ] ) can be applied .    since @xmath563 , then @xmath588 . in slice @xmath589",
    "there is a @xmath558 , with @xmath565 .",
    "also , @xmath586 implies that @xmath591 and hence the gates @xmath592 are also in some future slices ( compared to @xmath1 ) .",
    "moreover , it also implies the existence of the operators @xmath593 in the measurement pattern , which are translated to the extended circuit as @xmath594 in slice @xmath516 ( containing all the @xmath511 and @xmath13 with control on qubit @xmath10 ) . on the other hand",
    ", @xmath563 implies both @xmath579 and @xmath595 and therefore there is no @xmath519 or @xmath530 in the circuit .",
    "thus , if every gate @xmath585 and @xmath566 can be trivially pushed to slice @xmath587 and @xmath566 is the first gate acting on wire @xmath121 , we have exactly the scenario depicted in figure [ fig_rp3]-a .",
    "therefore , the circuit identity in figure [ fig_rp3 ] can be applied .    in what follows we analyse some properties regarding the interplay between the rps that will be crucial for the compactification algorithm for ssf extended circuits .",
    "[ lem_czdeleted ] let @xmath500 be an extended circuit obtained from a signal shifted measurement pattern . then",
    ", if a rewrite procedure removes a gate @xmath597 from the circuit , it will not be required for the application of any other rewrite procedure .",
    "note that only rp2 and rp3 can delete a @xmath597 gate from the circuit .",
    "the proof is divided into three parts : ( i ) we show that the @xmath597 is never a flow edge and , therefore , it will not be required for the application of a @xmath508-gate identity ; ( ii ) it will not be needed for the application of rp1 and ( iii ) it will not be needed to create a @xmath511 ( by using rp2 or rp3 ) in the next layers .",
    "suppose @xmath597 is a flow edge such that @xmath598 , with @xmath14 being any of qubits @xmath599 in rp2 or @xmath600 in rp3 . the other way around , that is , @xmath601 , is not possible since @xmath121 is separately identified in both rp2 and rp3 . since @xmath602 for all @xmath62",
    ", we have @xmath603 . by construction , rp2 and rp3",
    "are applied if and only if @xmath604 . moreover , since @xmath145 in both rp2 and rp3 , it holds that @xmath167 . putting everything together we have @xmath605 , which is a contradiction .",
    "therefore , @xmath597 is never a flow edge .",
    "in this second part of the proof , we show that if @xmath597 is deleted by rp2 or rp3 , it will not be required for the application of rp1 in any future step . using the notation defined earlier , the fact that rp1 is applied after rp2 or rp3 can be written as @xmath606 or @xmath607 , where @xmath10 is the target wire of the corresponding rp .",
    "this relation will be used in the rest of the proof .",
    "we show that @xmath532 and @xmath608 can not be any of wires @xmath609 ( denoted simply by @xmath610 in the rest of this proof ) or @xmath611 and hence the gates @xmath612 or @xmath613 can not be the same as @xmath614 , which is what we want to prove .",
    "let us show for @xmath532 . since @xmath615 and @xmath616 ( true for both propositions [ prop_rp1 ] and [ prop_rp1b ] , which state the scenarios where rp1 is applied ) we have @xmath617 and therefore @xmath532 can not be the same wire as @xmath611",
    ". now assume wire @xmath610 is @xmath532 .",
    "in rp2 we have @xmath615 ( by construction ) and in rp1 it holds that @xmath618 , since the target of a correcting gate is always placed before the @xmath508-gate acting on that same wire ( definition [ def_ext ] ) . putting everything together gives @xmath619 .",
    "but since by assumption @xmath610 is @xmath532 , it gives @xmath620 which is a contradiction .",
    "the proof is the same for @xmath608 .",
    "therefore , if @xmath597 is `` consumed '' by rp2 or rp3 , it will not be required for the application of rp1 in any future step .    finally for the third part note that an @xmath528 gate will be removed to create a @xmath511 gate only through identity in figure [ fig_rules]-b .",
    "the pair of such @xmath528 gates is always associated with a flow and a non - flow edge when used in rp2 or rp3 .",
    "therefore , there are two possible pairs of @xmath528 gates using the non - flow edge @xmath597 : @xmath621 ( which would create @xmath622 ) and @xmath623 ( which would create @xmath624 ) .",
    "we want to show that whenever we `` consume '' @xmath597 , it will not be required to create a different @xmath511 than the one already created .",
    "suppose we use @xmath625 to create @xmath626 .",
    "this is the case when @xmath627 and @xmath628 , if @xmath629 is a correcting wire and @xmath630 is a neighbour wire in either rp2 or rp3 .",
    "similarly , if @xmath629 is the neighbour wire and @xmath630 is the correcting one then @xmath631 and @xmath632 ( easily obtained by relabelling the wires in rp2 and rp3 ) . since the first pair of conditions is inconsistent with the last pair of conditions ( @xmath633 and @xmath634 ) , we conclude that once a given @xmath528 is used to create a @xmath511 , that @xmath528 would not be required to create a different @xmath511 in any further step of the algorithm since the partial order @xmath149 is not changed by the application of any rp .",
    "[ cor_czcx ] let @xmath518 be a gate in an extended circuit created by the application of a rewrite procedure .",
    "the @xmath528 gate `` consumed '' to create this @xmath518 can be univocally determined .",
    "it follows from the third part of the proof of lemma [ lem_czdeleted ] that if a gate of the form @xmath597 is deleted in rp2 or rp3 we will have one of the following cases : the gates @xmath621 are used to create @xmath622 or the pair @xmath623 are used to create @xmath624 .",
    "the @xmath511 that is created by `` consuming '' the @xmath597 depends exclusively on the relation between vertices @xmath14 , @xmath90 and @xmath112 in respect to the partial order @xmath149 . since the partial order @xmath149 is not changed by the application of any rp , there is a one - to - one correspondence between the deleted @xmath528 gate and the newly created @xmath511 gate .",
    "the process of choosing the correct rp to be applied is summarised in algorithm [ alg_chooserp ] , which will be used as a subroutine in the compactification algorithm for ssf extended circuits ( algorithm [ alg_full ] ) .",
    "the modified conditions in lines 5 and 7 are based on the fact that if a @xmath13 required for the application of rp2 or rp3 is not in the circuit , the @xmath511 that it would create will be ( see lemma [ lem_czdeleted ] ) , allowing the application of future rps . in all rps",
    "we assumed that some @xmath528 gates could be moved to the beginning of a given slice @xmath635 in a trivial way .",
    "it will not be true in general for ssf extended circuits , since there might exist several other gates in the extended circuit such that the aforementioned @xmath528 gates could not be moved trivially to @xmath635 .",
    "in other words , the conditions in propositions [ prop_rp1 ] to [ prop_rp3 ] would not be satisfied . the algorithm in the next section address exactly this problem",
    ": it provides an ordering where algorithm [ alg_chooserp ] never aborts .",
    "this ordering is the _ global _ structure coming into play , since it is related to ssf and flow of the graph .      in this section",
    "we explain how the compactification algorithm for ssf extended circuits ( algorithm [ alg_full ] ) works and show some examples .",
    "the goal of algorithm [ alg_full ] is to create @xmath529 many @xmath508-blocks ( see definition [ def_jblock ] ) in a ssf extended circuit and then apply the @xmath508-gate identity for all @xmath508-block , removing @xmath529 many wires from the extended circuit .",
    "therefore , the output of algorithm [ alg_full ] is the compact form of the inputed ssf extended circuit .",
    "one of the main differences between ssf and other gflows is the notions of stepwise influencing path , introduced in section [ sec_ip ] .",
    "the next lemma use some properties of stepwise influencing path to relate the ssf correcting set to the partial order of flow .",
    "this relation will play an important role in algorithm [ alg_full ] since it gives an appropriate ordering for the application of the rps .",
    "[ lem_flowssf ] let @xmath47 be an open graph with flow @xmath206 and ssf @xmath176 .",
    "then , for all @xmath636 , where @xmath145 , it holds that @xmath637 .",
    "first suppose @xmath638 .",
    "then , by flow definition ( definition [ def_flow ] ) , @xmath637 .",
    "now suppose @xmath639 then from definition [ def_flow ] , @xmath640 . by lemma [ lem_path",
    "] , there exists a step - wise influencing path passing through @xmath61 and @xmath157 , namely @xmath207 .",
    "it follows from corollary [ cor_neighbour ] , that there exists @xmath208 such that @xmath209 and @xmath641 and , consequently , @xmath642 .",
    "lemma 2.14 allows us to repeat this process to find the previous vertices in the path @xmath207 until we reach vertex @xmath10 .",
    "hence we conclude that @xmath643 and therefore @xmath644 .    before running algorithm [ alg_full ]",
    ", the slices @xmath516 must be arranged in the extended circuit from right to left respecting the order imposed by @xmath49 ( see for instance figure [ fig_examplessf ] ) .",
    "this can always be done since the set of gates in a given slice @xmath516 commutes with the gates in an other slice @xmath645 , for any valid @xmath14 .",
    "the algorithm starts with a @xmath646 loop that runs for one ssf layer at a time , starting with the input layer and moving onwards until the last layer of non - output qubit is considered . at each iteration @xmath1 of the @xmath646 loop ,",
    "a rewrite procedure is applied to each pair of qubits @xmath578 s.t .",
    "@xmath517 is in @xmath513 and @xmath647 .",
    "the two @xmath648 loops and the two @xmath649 loops define the order in which algorithm [ alg_chooserp ] will be called .",
    "this ordering , which is the inverse of the order given by @xmath49 , assures that algorithm [ alg_chooserp ] will never abort when it is called by algorithm [ alg_full ] .",
    "[ ht ]    [ lem_algneveraborts ] algorithm [ alg_chooserp ] never aborts when called by algorithm [ alg_full ] .",
    "let us start by showing that the algorithm works for the first iteration of the @xmath646 loop ( _ i.e. _ , @xmath650 ) and then we explain why it will work for all other layers . in what follows we use the notation @xmath651 to represent a target wire @xmath10 in layer @xmath1",
    "; note that there might exist more than one such wire in the same layer .",
    "let @xmath652 ( @xmath653 ) be the maximum ( minimum ) value of @xmath654 for @xmath655 ( as defined in lines 5 and 6 in the algorithm ) , where @xmath656 is the set of the @xmath657 wires with @xmath508-gate in slice @xmath513 . according to lemma [ lem_flowssf ] , for any @xmath658 such that @xmath659 , and any qubit @xmath90 connected to a qubit in @xmath660 it holds that @xmath661 . in this case , condition ( i ) in proposition [ prop_rp1 ] is satisfied .",
    "since we are in the first ssf layer , all @xmath528 gates required for the application of any of those rps can be trivially pushed forward to slice @xmath662 , hence all conditions in proposition [ prop_rp1 ] are initially satisfied .",
    "after the application of one or more rp1 , it might happen that some @xmath528 gates get stuck in between two @xmath511 gates in slice @xmath663 ( which happens when a neighbour wire @xmath90 is itself in both @xmath664 and @xmath660 sets ) . in this case",
    "the conditions in proposition [ prop_rp1b ] are the ones satisfied . in both cases ,",
    "only rp1 can be selected by algorithm [ alg_chooserp ] .",
    "therefore , algorithm [ alg_chooserp ] would not abort for all target qubits @xmath658 such that @xmath665 . as a consequence , since only rp1 is applied , all gate @xmath666 , such that @xmath667 , are moved past the correction slice @xmath663 , for all @xmath658 such that @xmath665 .",
    "now consider qubits @xmath658 such that @xmath668 , that is , the second iteration of the first @xmath649 loop . for @xmath669 ,",
    "lemma [ lem_flowssf ] implies that either @xmath661 or @xmath670\\}$ ] is true . for @xmath661 , the procedure to be applied",
    "is rp1 , similarly and by the same reasons as in the previous iteration . for the other case the applicable rewrite procedures are either rp2 or rp3 , since @xmath569 in @xmath662 implies @xmath671 .",
    "note that in the previous iteration ( qubits @xmath658 s.t .",
    "@xmath672 , like the wire @xmath90 being analysed now ) , all @xmath673 , for any @xmath674 were moved past the corresponding correction slice and hence @xmath675 is the first gate acting on the @xmath121 wire ( as required by both propositions [ prop_rp2 ] and [ prop_rp3 ] ) . moreover ,",
    "when the circuit identity in figure [ fig_rules]-b creates the new @xmath511 gates ( first step in both rp2 and rp3 ) , it can be pushed forward to @xmath663 because the only gate in between is @xmath558 , which commutes with the @xmath511 gates we want to push forward .",
    "therefore , since all conditions in either proposition [ prop_rp2 ] or proposition [ prop_rp3 ] would be satisfied for all qubits @xmath658 such that @xmath668 , the corresponding @xmath676 can be successfully applied .    to complete the proof by induction for the first iteration of the @xmath646 loop , assume algorithm [ alg_chooserp ] has not aborted in the first @xmath677 iteration of the first @xmath649 loop . then in the @xmath678 iteration , qubits @xmath658 such that @xmath679 , where @xmath680 , are considered .",
    "if a given qubit @xmath90 is neighbour of a qubit in @xmath660 , then lemma [ lem_flowssf ] implies that either @xmath661 or @xmath681 is true . here the same analysis as before applies ; first , if @xmath682 , algorithm [ alg_chooserp ] will apply rp1 , moving the corresponding @xmath528 gates past slice @xmath663 . on the other hand , if @xmath681 , either the conditions in proposition [ prop_rp2 ] or proposition [ prop_rp3 ] will be satisfied , since all @xmath528 gates acting on qubits in the sets @xmath683 , for all @xmath684 s.t .",
    "@xmath685 , were moved past slice @xmath686 in previous iterations ( with the obvious exception of gates of the form @xmath687 ) .",
    "the procedure continues until there is no qubit left in @xmath688 to be considered .",
    "therefore , algorithm [ alg_chooserp ] never aborts when called during the first iteration ( @xmath650 ) .",
    "now let us analyse how the @xmath528 gates placement changed in the circuit after the @xmath689 iteration of the @xmath646 loop where algorithm [ alg_chooserp ] applied a rp each time it was called by algorithm [ alg_full ] .",
    "first , note that all @xmath528 gates acting on qubits in @xmath162 , for @xmath690 , were moved to @xmath691 ( via rp1 ) or transformed into a @xmath511 ( via rp2 or rp3 ) and then moved to the same slice , with the exception of gates of the form @xmath525 which remains in @xmath512 and will later be used for the application of the @xmath508-gate identity .",
    "moreover , lemma [ lem_czdeleted ] guarantees that if an @xmath528 gate is deleted in a given iteration of the algorithm , it will not be required in any future step of the algorithm .",
    "note also that those @xmath528 and @xmath511 gates were moved to the @xmath691 slice in a specific order , namely the inverse of the order induced by @xmath49 .",
    "since this ordering is a property of the associated graph , it does not change during the run of the algorithm .",
    "it means that for any given iteration @xmath1 of the @xmath646 loop , the ordering of the two - qubit gates required for the application of a rp will be in agreement with the order algorithm [ alg_chooserp ] will be called by algorithm [ alg_full ] .",
    "hence the condition ( required for the application of any rp ) that the required two - qubit gates can be pushed trivially to a given slice is always satisfied .",
    "therefore , at each iteration of the @xmath646 loop , it arranges all two - qubit gates necessary for the next iteration in the same order it will be called .    to complete the proof by induction ,",
    "let us assume that in the first @xmath692 iterations of the @xmath646 loop algorithm [ alg_chooserp ] has not aborted , and then we show that it will not abort in the @xmath693 iteration .",
    "let us analyse the first iteration of the first @xmath649 loop for @xmath694 . according to lemma [ lem_flowssf ] , for any @xmath695 such that @xmath696 , if a given qubit @xmath697 then either @xmath698 ( if there exists @xmath699 s.t .",
    "@xmath700 ) or the @xmath569 gate belongs to a layer @xmath701 s.t .",
    "if the latter condition is the case , then by definition only rp1 is applied to @xmath695 . on the other hand , if @xmath698 , rp2 or rp3 must be applied . since by assumption algorithm [ alg_chooserp ]",
    "has not aborted in any previous iteration , the conditions for the application of the aforementioned rps are satisfied and algorithm 2 will not abort in the current iteration .    now assume algorithm [ alg_chooserp ] has not aborted in the first @xmath677 iteration of the first @xmath649 loop for @xmath694 . in the @xmath678 iteration of this loop , qubits @xmath695 such that @xmath703 , where @xmath704 , are considered . for a given @xmath90 neighbour of a qubit in @xmath705 ,",
    "lemma [ lem_flowssf ] implies that one of the following statement holds : ( i ) @xmath706 $ ] for some @xmath699 , ( ii ) @xmath707 $ ] or ( iii ) @xmath708 , for @xmath709 . here the same analysis as before applies ; for cases ( i ) and ( ii ) rp2 or rp3 is applied and for ( iii ) rp1 will move the corresponding @xmath528 gates past slice @xmath710 .",
    "since the same order is respected throughout the algorithm ( the inverse of the order defined by flow ) , the conditions for the application of the aforementioned rps are satisfied and algorithm 2 will not abort in the current iteration .",
    "this procedure is repeated until there is no more elements in the set @xmath711 , which concludes our proof by induction and proves the lemma .",
    "[ the_compact ] algorithm [ alg_full ] outputs a compact circuit .",
    "we show that algorithm [ alg_full ] creates @xmath529 many @xmath508-gate blocks ( definition [ def_compactform ] ) and then removes @xmath529 many wires from the circuit ( using the @xmath508-gate identity ) , yielding a compact circuit .",
    "the first two conditions in definition [ def_jblock ] are trivially satisfied for all ssf extended circuit . in lemma [ lem_algneveraborts ] we proved that algorithm [ alg_full ] moves to a future slice ( or removes ) all gates @xmath528 acting on qubits @xmath145 ( @xmath712 ) except gate @xmath525 and hence condition 3 in definition [ def_jblock ] is also satisfied .",
    "now we prove that condition 4 is satisfied .",
    "note that all non - input qubit are initialised in state @xmath713 . according to ssf construction ( proposition [ prop_ssf ] ) , for all qubit @xmath145",
    ", there exists @xmath157 . by definition @xmath714 and therefore every qubits in @xmath162 , for all @xmath60",
    ", starts in the @xmath524 state .",
    "therefore , all remaining @xmath518 such that @xmath639 can me removed from the circuit without changing the computation , since @xmath715 ( remember that the only gate @xmath528 acting on wires @xmath145 left behind by the algorithm is @xmath525 ) . therefore , after the step in line 17 , condition 4 in definition [ def_compactform ] is also satisfied . since all non - output wires in an extended circuit are measured in the z basis by construction , condition 5",
    "is also satisfied and hence algorithm [ alg_full ] has created @xmath529 many @xmath508-blocks after the step in line 17 . finally , in line 18 the @xmath508-gate identity is applied to all @xmath508-blocks , resulting in a compact circuit .",
    "we complete this section with two examples using the above algorithm . in the first one",
    "we start with a generic quantum circuit , translate it to the mbqc model , find the ssf extended circuit of it and then apply algorithm [ alg_full ] to put the circuit in the compact form . in the second example , we analyse an example with pauli measurements and show that if we want to keep the parallelization introduced by it we can no longer find the compact form of the extended circuit .      ]    in this first example we apply our method to optimise the circuit in figure [ fig_example1]-a . using the method from @xcite , we translate the circuit in figure [ fig_example1]-a to the following measurement pattern , resulting in the graph in figure [ fig_examplegraphs]-a .",
    "the difference in depth between the flow and ssf is shown in table [ table_ex1 ] .",
    "[ table_ex1 ]    [ cols=\"<,<,<\",options=\"header \" , ]     @xmath716     for more information . ) ]    the extended translation ( definition [ def_ext ] ) of the measurement pattern in equation [ eq_ex1ssf ] gives the circuit in figure [ fig_example1]-b .",
    "let us apply algorithm [ alg_full ] to find the compact form of that extended circuit .",
    "we start with the first ssf layer of circuit in figure [ fig_example1]-a .",
    "for @xmath650 we have @xmath717 , @xmath718 and @xmath719 .",
    "thus , we start with qubit 7 with @xmath720 and therefore no rewrite procedure is applied .",
    "the value of @xmath721 is decreased to 2 ( there is no qubit @xmath10 s.t . @xmath722 or @xmath723 ) .",
    "now we analyse qubit 4 because @xmath724 with @xmath725 . for qubits in this set",
    "it holds that @xmath726 .",
    "the maximal value of @xmath727 is stored in @xmath728 . for both qubits @xmath729 and @xmath730 , algorithm [ alg_full ] applies rp1 , moving @xmath731 and @xmath732 past @xmath733 .",
    "now @xmath734 and the qubit considered is qubit @xmath735 . for qubit @xmath735",
    "the algorithm applies rp2 , transforming @xmath736 , @xmath737 and @xmath738 into @xmath739 , @xmath740 and @xmath741 respectively and moving those new @xmath742 past the correction structure , removing @xmath743 from the circuit .",
    "now consider qubit @xmath744 and move @xmath745 and @xmath746 past the correction structure , using rp2 .",
    "the same rewrite procedure is applied for qubit @xmath747 , moving @xmath748 and @xmath749 past the correction structure .",
    "the rewritten circuit is depicted in figure [ fig_example1]-c .    in the next step ,",
    "the value of @xmath750 is decreased to 1 , where the qubit to be considered is qubit @xmath20 .",
    "@xmath751 . for qubits in this set",
    "it holds that @xmath752 . for @xmath730 , proposition [ prop_rp1 ]",
    "is satisfied and hence algorithm [ alg_full ] applies rp1 , moving @xmath731 past @xmath753 .",
    "then for @xmath754 , algorithm [ alg_full ] applies rp1 ( proposition [ prop_rp1 ] ) , moving @xmath755 and @xmath756 past @xmath757 and @xmath753 .",
    "next , rp2 is applied to @xmath758 , moving @xmath741 and @xmath740 past @xmath759 and @xmath753 .",
    "for @xmath760 , we have that @xmath209 ( condition ( i ) in proposition [ prop_rp1b ] ) and @xmath755 in slice @xmath761 after @xmath753 gate ( ( condition ( ii ) in proposition [ prop_rp1b ] ) .",
    "therefore , for this case rp1 moves @xmath755 and",
    "@xmath762 past @xmath757 and @xmath759 , creating two @xmath763 separated by @xmath753 . by lemma [ lem_rp1 ] ,",
    "we know those two @xmath763 can simply be removed from the circuit without changing the computation being implemented . for @xmath764 , proposition [ prop_rp1 ] is satisfied and hence rp1 moves @xmath762 and @xmath756 past @xmath759 and @xmath753 .",
    "finally , for qubit @xmath723 , rp3 transforms @xmath765 into @xmath766 and move it past @xmath757 and @xmath753 , removing the latter in the process , resulting in figure [ fig_example1]-d .    in the second ssf layer we have @xmath767 , @xmath768 , @xmath769 and @xmath770 .",
    "thus , we start with qubit 5 . since @xmath771 , algorithm [ alg_full ] applies rp2 , moving @xmath739 past @xmath772 and @xmath740 while removing @xmath740 in the process . after that , the value of @xmath728 decreases and qubit @xmath747 is considered .",
    "@xmath773 and since @xmath774 , qubit @xmath735 is considered first . in this case algorithm [ alg_full ]",
    "applies rp3 moving gates @xmath741 and @xmath739 past the correction structure .",
    "now for qubit @xmath744 , rp2 is applied transforming @xmath746 into @xmath775 .",
    "the created @xmath511 is moved forward past the correction structure , removing @xmath776 from the circuit .",
    "the resulting circuit is shown in figure [ fig_example1]-f . the command in line 17 of algorithm [ alg_full ] removes the remanning undesired gates using the identity trivial @xmath777 .",
    "the resulting circuit is depicted in figure [ fig_example1]-g .",
    "finally , the @xmath508-gate identity is applied for every qubit @xmath60 resulting in the optimised compact circuit shown in figure [ fig_example1]-h .      in this example",
    "we explore what is the role of pauli measurements in the context of compactification procedures .",
    "let us start by reviewing how the correction operators are modified when applied to a qubit measured with @xmath778 and @xmath779 angles ( corresponding to pauli measurements ) : @xmath780 note that in the mbqc context , both substitutions clearly might reduce the depth of the computation : equation [ eq_pauliy ] substitute @xmath781 for @xmath782 , which can then be removed using signal - shifting , and equation [ eq_paulix ] simply deletes the existing @xmath782 dependency .",
    "however , in the associated extended circuit , these optimisations can not be implemented alongside the compactification procedure developed in this section ( algorithm [ alg_full ] ) , forcing one to choose between optimization in time or memory . to see why , note that both equations [ eq_pauliy ] and [ eq_paulix ] change the correcting structure for every qubit encoded in the index @xmath33 . as a consequence",
    ", the step - wise influencing path @xmath783 ( definition [ def_path ] ) , which is the backbone of the compactification protocol , can not be defined anymore for these qubits .    in summary ,",
    "if one wants to save memory in the circuit model , the substitutions in equations [ eq_pauliy ] and [ eq_paulix ] must be avoided , allowing the identification of all step - wise influencing paths and , consequently , the removal of auxiliary qubits .",
    "conversely , if @xmath508-gate parallelization is the goal , algorithm [ alg_full ] can be easily adapted to create just @xmath784 many @xmath508-blocks in the extended circuit ( instead of @xmath529 many ) , where @xmath785 is the number of pauli measurements in the associated measurement pattern .",
    "consider the circuit shown in figure [ fig_pauliopt]-a .",
    "it has two @xmath508 gates with arbitrary angles ( arbitrary angles are omitted in the figure ) and two pauli angles , namely @xmath778 and @xmath786 . using the method in @xcite",
    ", we can translate this circuit to the mbqc model ; the associated graph is shown in figure [ fig_pauliopt]-b and the flow measurement pattern is given by :    @xmath787    where , @xmath788 .",
    "using the signal shifting technique explored in this paper , we obtain the following ssf measurement pattern : @xmath789 now let us see what happens when we use the fact that some measurements are pauli measurements . using equation [ eq_pauliy ] , we can optimise it by removing the dependency between measurements @xmath20 and @xmath747 , obtaining the following measurement pattern:@xmath790 alternatively , the measurement on qubit @xmath744 can also be parallelised with the ones in @xmath20 and @xmath723 , using equation [ eq_paulix ] .",
    "the optimized measurement pattern is the following : @xmath791 finally , both optimisations can be considered together . in this case , all measurements can be performed at once : @xmath792    -gate parallelization for circuits with pauli angles .",
    "see example 2 for more information . ]    with few adaptations and [ eq_paulix ] , it is not possible to create @xmath508-blocks for @xmath785 many wires , where @xmath785 is the number of times equations [ eq_pauliy ] or [ eq_paulix ] were used in the original measurement pattern .",
    "] , algorithm [ alg_full ] can be applied to the extended circuits associated to the measurement patterns in equations [ eq_ex2ssf ] to [ eq_ex2allpauli ] .",
    "the obtained circuits are shown in figures [ fig_pauliopt]-c to [ fig_pauliopt]-f , respectively .",
    "note that the optimization given by equations [ eq_pauliy ] and [ eq_paulix ] in the mbqc model becomes @xmath508-gate parallelization in the circuit model .",
    "however , it is not clear in which cases the @xmath508-gate parallelization implies time optimization .",
    "an in - depth analysis of the time - memory tradeoff for extended circuits with pauli angles remains as an interesting open question .",
    "in this section we analyse the space , _ i.e. _ the number of wires , and depth complexity of our proposed optimization scheme .",
    "we show that our procedure can give a more optimal circuit in terms of both space and depth compared with the general method obtained in @xcite .",
    "an overview of this analysis is shown in figure [ fig_complexity ] .",
    "let @xmath500 be our initial quantum circuit with @xmath1 wires , @xmath793 j gates and depth @xmath794 .",
    "we can translate the computation implemented by @xmath500 to an mbqc pattern @xmath127 with @xmath795 qubits , out of which @xmath535 are measured qubits , and depth @xmath796 @xcite .",
    "this pattern can be further optimised to depth @xmath797 by performing signal shifting @xcite and obtaining a new pattern @xmath798 . the extended quantum circuit @xmath799 , corresponding to the signal shifted pattern @xmath798 can be created via the method given in definition [ def_ext ] .",
    "this new circuit @xmath800 performs exactly the same computation as the initial circuit @xmath500 and has the same number of @xmath508-gates , @xmath795 wires and depth @xmath801 .",
    "one could apply the parallelisation method of @xcite to create a parallelised circuit @xmath802 with depth @xmath803 and size @xmath804 @xcite . depending on the value of @xmath805",
    ", the depth of @xmath802 can be smaller than that of the original circuit @xmath500 , but this could increase the space used , which can increase considerably , _",
    "i.e _ from @xmath1 to @xmath804 .    to resolve this problem , instead of parallelising the circuit @xmath800 we apply our compactification method . this will give us the compact circuit @xmath806 with @xmath1 wires and @xmath807 where @xmath808 is the degree of the open graph @xmath6 of @xmath798 .",
    "let @xmath800 be the quantum circuit obtained through extended translation from a signal shifted measurement pattern @xmath809 on an open graph @xmath6 with depth @xmath805 .",
    "the application of the compactification algorithm [ alg_full ] to @xmath800 results in a circuit with depth @xmath807 .",
    "algorithm [ alg_full ] is the application of rewrite procedures ( 1 ) - ( 5 ) as defined in section [ sec_rps ] to the extended circuit of @xmath809 .",
    "note that the number of @xmath508-gate layers in @xmath810 is equal to the depth of @xmath809 @xcite .",
    "since the rewrite procedures do not change the @xmath508-gate layers , the compactified circuit @xmath811 will also have @xmath805 @xmath508-gate layers .",
    "now we will count the number of gates in - between the @xmath508-gates .",
    "we do not need to be concerned with gates in the @xmath536 layers , since algorithm [ alg_full ] removes all of them .",
    "it is possible that the rewrite procedures leave some @xmath812 gates in front of qubit @xmath10 .",
    "as all of these gates correspond to an edge in the graph @xmath109 , the maximum number of such gates has to be @xmath813 . according to the rewrite procedures",
    ", none of the @xmath814 gates created will be moved past the @xmath508-gates . as can be seen from the rewrite procedures and algorithm [ alg_full ] ,",
    "these will be created because of the existence of some @xmath815 gates in @xmath800 . since these correspond to the edges connected to the vertex @xmath231 there can only exist @xmath813 many @xmath511 gates between any two @xmath508-gates .",
    "now we know that there can be a total of @xmath813 two qubit gates in - between any two @xmath508-gates and hence also between the @xmath508-gate layers .",
    "therefore the total depth of the circuit @xmath811 will be @xmath807    already we can see , that if @xmath816 the @xmath811 will have smaller depth than @xmath800 while the corresponding space will be considerably smaller .",
    "we can further decreased the depth of @xmath811 by applying the parallelisation method from @xcite .",
    "the depth of the new circuit @xmath817 will be @xmath818 and size @xmath819 . note that because of the way @xmath500 is translated into @xmath127 , the maximum number of edges connected to a vertex in @xmath109 will be @xmath820 , where @xmath821 .",
    "therefore the depth of @xmath817 can be written as @xmath803 .",
    "hence the compactification procedure together with the parallelisation method from @xcite will in the worst case give us the same depth as the method from @xcite , without pauli simplifications , but uses considerably less qubits ( @xmath822 vs @xmath823 , where @xmath824 ) .",
    "initially mbqc was proposed as an alternative architecture for the implementation of quantum computing . however from early on the distinct parallel power of the model attracted researchers to explore further this unique feature of the model . in a series of results",
    "the key concepts of flow , signal shifted flow , gflow , maximally delayed gflow , focused gflow and information preserving flow were introduced @xcite .",
    "they address the general question of determinism in mbqc while shedding light on the parallelism as well .",
    "although it is now known that the mbqc parallel power is equivalent to the quantum circuit with unbounded fanout @xcite , further investigation is required to fully take advantage of this extra power . in this paper",
    "we continue this line of research by first presenting a surprising link between signal shifted flow and maximally delayed gflow .",
    "the surprise comes from the fact that the former is obtained via a simple rewrite rules of pushing the @xmath23 dependencies of a pattern to the end of the computation , while the latter is constructed directly from the stabilisers of the underlying graph .",
    "this leads to a new efficient procedure for finding the optimal gflow of graphs with flow as we discussed in the last section .",
    "moreover the link between signal shifted flow and optimal gflow opens a new direction to unify further the `` flow '' structure and fully characterise the constructions behind the parallel power of mbqc . to begin with , we succeeded in extending the applicability of the compactification method from @xcite by proving that it can also be used for the signal shifted flow .",
    "this will allow us to translate back the obtained parallel structure of the mbqc into the circuit model without increasing the size , leading to an automated optimisation procedure for quantum circuits .",
    "the automated scheme explore the global structure of circuit to parallelise several @xmath508-gates and to group together several @xmath511 gates , which allow further optimisations to take place using specific method for clifford gate parallelisation .",
    "interestingly the scheme fails to compact the parallel pattern obtained via pauli simplification rules @xcite . in other words",
    "one needs to keep the extra space to keep the parallel depth obtained due to the pauli measurements .",
    "this further indicates the crucial role that clifford computation ( corresponding to pauli measurements ) play in obtaining the superior parallel power of mbqc over quantum circuit .",
    "the above trade - off naturally suggests the consideration of a hybrid model for quantum computing , where part of the computation is processed using the quantum circuit model and the other part using mbqc .",
    "such a computation can be obtained by a _ partial _",
    "compactification of the extended circuits .",
    "first a quantum circuit acting on @xmath1 qubits is translated to the mbqc model , where it requires @xmath571 qubits .",
    "then , we use an automated compactification procedure to obtain many different circuits implementing the same computation but with different depth and number of qubits ( ranging from @xmath1 to @xmath535 many qubits ) . in those circuits ,",
    "part of the computation is implemented using mbqc to obtain the parallel depth due to pauli measurement while the rest are performed in the circuit model as one would not achieve any parallel advantage .",
    "we believe that this can be of great value for experimental implementation of quantum computation , since one can design algorithms more adapted to the available experimental resources .",
    "the application of the different techniques introduced in this paper to known quantum algorithms , as well as a full comparison with other known optimization methods beyond mbqc , constitute an interesting subject to be explored in the future .",
    "we are grateful to ernesto f. galvo for many helpful discussions .",
    "we acknowledge financial support by the instituto nacional de cincia e tecnologia de informaco quntica ( inct- iq / cnpq - brazil ) that sponsored r. dias da silva visit to scotland where this work was completed .",
    "e. kashefi also acknowledges support from uk engineering and physical sciences research council ( ep / e059600/1 ) .",
    "m.  hein , w.  dr , j.  eisert , r.  raussendorf , m.  van den nest , and h.  j. briegel . in _ proceedings of the international school of physics `` enrico fermi '' on `` quantum computers , algorithms and chaos '' _ * 162 * ( 2006 ) ."
  ],
  "abstract_text": [
    "<S> one of the main goals in quantum circuit optimisation is to reduce the number of ancillary qubits and the depth of computation , to obtain robust computation . </S>",
    "<S> however , most of known techniques , based on local rewriting rules , for parallelising quantum circuits will require the addition of ancilla qubits , leading to an undesired space - time tradeoff . </S>",
    "<S> recently several novel approaches based on measurement - based quantum computation ( mbqc ) techniques attempted to resolve this problem . </S>",
    "<S> the key element is to explore the global structure of a given circuit , defined via translation into a corresponding mbqc pattern . </S>",
    "<S> it is known that the parallel power of mbqc is superior to the quantum circuit model , and hence in these approaches one could apply the mbqc depth optimisation techniques to achieve a lower depth . </S>",
    "<S> however , currently , once the obtained parallel pattern is translated back to a quantum circuit , one should either increase the depth or add ancilla qubits . </S>",
    "<S> in this paper we characterise those computations where both optimisation could be achieved together . in doing </S>",
    "<S> so we present a new connection between two mbqc depth optimisation procedures , known as the _ maximally delayed generalised flow _ and _ signal shifting_. this structural link will allow us to apply an mbqc qubit optimisation procedure known as _ </S>",
    "<S> compactification _ to a large class of pattern including all those obtained from any arbitrary quantum circuit . </S>",
    "<S> we also present a more efficient algorithm ( compared to the existing one ) for finding the maximally delayed generalised flow for graph states with flow . </S>"
  ]
}