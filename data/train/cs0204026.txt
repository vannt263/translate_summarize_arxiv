{
  "article_text": [
    "we are grateful to peter buneman , mark liberman and gary simons for helpful discussions concerning the research reported here .        s.  bird and m.  liberman .",
    "annotation graphs as a framework for multidimensional linguistic data analysis . in _ towards standards and tools for discourse tagging  proceedings of the workshop _ , pages 110 .",
    "somerset , nj : association for computational linguistics , 1999 . .",
    "s.  bird and m.  liberman . a formal framework for linguistic annotation .",
    "technical report ms - cis-99 - 01 , department of computer and information science , university of pennsylvania , 1999 . ,",
    "expanded from version presented at icslp-98 , sydney , revised version to appear in _",
    "speech communication_.    s.  cassidy . compiling multi - tiered speech databases into the relational model",
    ": experiments with the emu system . in _ proceedings of the 6th european conference on speech communication and technology _ , 1999 .",
    "http://www.shlrc.mq.edu.au/emu/eurospeech99.shtml .",
    "s.  cassidy and j.  harrington .",
    "emu : an enhanced hierarchical speech data management system . in _ proceedings of the sixth australian international conference on speech science and technology _ , pages 361366 , 1996 .",
    "http://www.shlrc.mq.edu.au / emu/."
  ],
  "abstract_text": [
    "<S> annotated speech corpora are databases consisting of signal data along with time - aligned symbolic ` transcriptions ' </S>",
    "<S> . such databases are typically multidimensional , heterogeneous and dynamic . </S>",
    "<S> these properties present a number of tough challenges for representation and query . </S>",
    "<S> the temporal nature of the data adds an additional layer of complexity . </S>",
    "<S> this paper presents and harmonises two independent efforts to model annotated speech databases , one at macquarie university and one at the university of pennsylvania . </S>",
    "<S> various query languages are described , along with illustrative applications to a variety of analytical problems . </S>",
    "<S> the research reported here forms a part of several ongoing projects to develop platform - independent open - source tools for creating , browsing , searching , querying and transforming linguistic databases , and to disseminate large linguistic databases over the internet .    </S>",
    "<S> annotated corpora have been an essential component of research and development in language - related technologies for some years . </S>",
    "<S> text corpora have been used for developing information retrieval and summarisation software ( e.g. muc @xcite , trec @xcite ) , automatic taggers and parsers and machine translation systems @xcite . in a similar way , annotated speech corpora have proliferated and have found uses across a rapidly expanding set of languages , disciplines and technologies . over the last 7 years , the linguistic data consortium ( ldc ) has published over 150 text and speech databases .    </S>",
    "<S> typically , such databases are specified at the level of file formats . </S>",
    "<S> linguistic content is annotated with a variety of tags , attributes and values , with a specified syntax and semantics . </S>",
    "<S> tools are developed for each new format and linguistic domain on an ad hoc basis . </S>",
    "<S> these systems are akin to the databases of the 1960s . </S>",
    "<S> there is a physical representation along with a hand - crafted program offering a single view on the data . </S>",
    "<S> recently , the authors have shown how the three - level architecture and the relational model can be applied to annotated speech databases @xcite . </S>",
    "<S> the goal of this paper is to illustrate our two approaches and to describe ongoing research on query algebras .    before presenting the models we give an example of a collection of speech annotations </S>",
    "<S> this illustrates the diversity of the physical formats and gives an idea of the challenge involved in providing a general - purpose logical characterisation of the data . </S>",
    "<S> the boston university radio speech corpus consists of 7 hours of radio news stories . </S>",
    "<S> the annotations include four types of information : orthographic transcripts , broad phonetic transcripts ( including main word stress ) , and two kinds of prosodic annotation , all time - aligned to the digital audio files . </S>",
    "<S> the two kinds of prosodic annotation implement the system known as tobi  tones and break indices . </S>",
    "<S> we have added three further annotations : coreference annotation and named entity annotation in the style of muc-7 , and syntactic structures in the style of the penn treebank @xcite . </S>",
    "<S> fragments of the physical data are shown in figure  [ fig : bu - speech ] .    [ cols= \" < </S>",
    "<S> , < , < \" , ]     ' '' ''    we form the transitive closure of the ( unlabeled ) graph relation to define a structural ( graph - wise ) precedence relation using a datalog program :    s_prec(x , x ) : - s_prec(x , y ) : - arc(_,x , y , _ , _ , _ ) s_prec(x , y ) : - s_prec(x , z ) , arc(_,z , y , _ , _ , _ )    now we further define a temporal precedence relation , where leq is the @xmath0 relation ( minimally defined on the times used by the graph ) :    t_prec0(x , y ) : - time(x , t1 ) , time(y , t2 ) , leq(x , y )    t_prec(x , y ) : - t_prec0(x , y ) t_prec(x , y ) : - t_prec(x , z ) , t_prec0(z , y )    in our experience with the analysis of linguistic databases , we have found a recurrent pattern of use having three components which we will call query , report generation , and analysis .    the query system proper can be viewed as a function from annotation graphs to sets of subgraphs , i.e. those meeting some ( perhaps complex ) condition . </S>",
    "<S> the report generation phase is able to access these query results , but also the signals underlying the annotations . </S>",
    "<S> for example , the report generation phase can calculate such things as ` mean f@xmath1 in signal s during time interval @xmath2 . ' </S>",
    "<S> each hit constitutes an ` observation ' in the statistician s sense , and we extract a vector of specified values for each observation , to be passed along to the analysis system . </S>",
    "<S> the analysis phase is then some general - purpose data crunching system such as splus or matlab .    </S>",
    "<S> this architecture saves us from having to incorporate all possible calculations over annotated signals into the query language . </S>",
    "<S> the report generation phase can perform such calculations , as well as compute properties of the annotation data itself . </S>",
    "<S> this seems to simplify the query system a good deal ; now things like ` count the number of syllables to the end of the current phrase ' ( which we do need to be able to do ) are tasks for the report generator , not the query system proper .    in general </S>",
    "<S> , the result of a query is a set of sub - graphs , each of which forms one matching instance . </S>",
    "<S> if we use the relational model proposed above , these would be returned as a result table having the same structure as the arc relation of figure  [ fig : graph - table ] , but containing just the tuples which took part in each matching instance . </S>",
    "<S> we are then faced with the problem of how to differentiate the matching instances , for example , if we wished to collect together the word labels for the query ` find all words dominated by noun phrases ' we need some way of treating each sub - graph separately . </S>",
    "<S> hence , we would prefer the result to be a set of tables rather than a single table containing all matching tuples .    in a sense , then , the only role of the query is to define an iterator for the report generator over a set of sub - graphs of the overall annotation graph .      </S>",
    "<S> the emu query language uses simple conditions on token labels which match only tokens at a specified level , for example : ` phonetic = a|i|o|u|e|v ` . </S>",
    "<S> these conditions can be combined by sequence , domination or association operators to constrain the relational structure of the tokens of interest . </S>",
    "<S> examples of each are :    find a sequence of ` vowel ` followed by ` stop ` at the phoneme level : + ` [ phoneme = vowel - >  phoneme = stop ] `    find words not labelled ` x ` dominating ` vowel ` phonemes : + ` [ word!=x ^  phoneme = vowel ] `    find words associated with ` h * ` tones : + ` [ word!=x = >  tone = h * ] `    the ` word!=x ` query is intended to match any word in lieu of a query language construct which allows matching any label string .    </S>",
    "<S> each query matches either a token or , in the case of the sequence query , a sequence of tokens . </S>",
    "<S> the result of a domination or association query is the result of the left hand side of the bracketed term ; this can be changed by marking the right hand side term with a hash ( ` # ` ) . </S>",
    "<S> compound queries can be arbitrarily nested to specify complex constraints on tokens . as </S>",
    "<S> an example the following query finds sequences of stop and vowels dominated by strong syllables where the vowel is associated with an ` h * ` tone target , the result is a list of the vowel labels with associated start and end times .    </S>",
    "<S> [ syllable = s ^ [ phoneme = stop - > [ phoneme = vowel = > tone = h * ] ] ]    the result of an emu query is a table with one entry per matching token :    database : timit query : phoneme!=x type : segment # h # 0 147.5 fjsp0:sa1 sh 147.5 232.5 fjsp0:sa1 iy 232.5 325 fjsp0:sa1 hv 325 385 fjsp0:sa1 ...    this table is used to extract any of the associated time - series data associated with the database , an operation usually carried out from an analysis environment such as splus or xlispstat . </S>",
    "<S> emu provides libraries of analysis functions for these environments which facilitate , for example , mapping signal processing operations over each token in a query result or overlaying plots of the time series data for each token .    </S>",
    "<S> although this query system has proved useful and useable in the environment of acoustic phonetics research , it is now evident that there are a number of shortcomings which prevent it s wider use . </S>",
    "<S> the query syntax is unable to express some queries , such as those involving disjunction or optional elements , and the query result is only really useful for data extraction . </S>",
    "<S> it is for these reasons that we are now looking more formally at the requirements for a query language for annotation data .    </S>",
    "<S> a high - level query language for annotation graphs , founded on an interval - based tense logic , is currently being developed and will be reported in a later version of this paper .    </S>",
    "<S> here we describe a variety of useful queries on annotation graphs and formulate them as datalog programs . as we shall see , it turns out that datalog is insufficiently expressive for the range of queries we have in mind . finding a more expressive yet tractable query language </S>",
    "<S> is the focus of ongoing research .    </S>",
    "<S> a number of simple operations , extending our two relations and , will be necessary for succinct queries . </S>",
    "<S> the first and most obvious is for hierarchy . </S>",
    "<S> observe in figure  [ fig : ag - timit ] that there is a notion of structural inclusion defined by the arcs . </S>",
    "<S> we formulate this as follows :    s_incl(i , j ) : - arc(i , w , z , _ </S>",
    "<S> , _ , _ ) , arc(j , x , y , _ , _ , _ ) , s_prec(w , x ) , s_prec(y , z )    now , since is reflexive , so is . observe that nodes 3 and 6 in figure  [ fig : ag - timit ] are connected by both an arc and a arc . </S>",
    "<S> the syntactic verb arc should dominate the word arc , but not vice versa . </S>",
    "<S> therefore we need to have a hierarchy defined over the types . </S>",
    "<S> we achieve this with a ( domain - specific ) ordering on the type names :    type_hierarchy(word , syl ) type_hierarchy(syl , seg )    now dominance is expressed by the predicate :    dom(i , j ) : - arc(i,_,_,l1 , _ , _ ) , arc(j,_,_,l2 , _ , _ ) , type_hierarchy(l1,l2 ) , s_incl(i , j )    in some cases it is necessary to have an intransitive dominance relation that is sensitive to phrase structure rules . for simplicity of presentation , we assume binary branching structures . </S>",
    "<S> the first of the rules below states that a sentence arc will immediately and exhaustively dominate an arc followed by a arc .    </S>",
    "<S> ps_rule(s , np , vp ) ps_rule(np , det , n ) ps_rule(vp , v , np )    now we define immediate dominance over the syntax arcs as follows :    i_dom(i , j ) : - arc(i , x , z , syn , p , _ ) , ps_rule(p , </S>",
    "<S> c1,c2 ) , arc(j , x , y , syn , c1 , _ ) , arc(_,y , z , syn , c2 , _ )    i_dom(i , j ) : - arc(i , x , z , syn , p , _ ) , ps_rule(p , c1,c2 ) , arc(_,x , y , syn , c1 , _ ) , arc(j , y , z , syn , c2 , _ )    another widely used relation between arcs is association . in the instance of the ag model in figure  [ fig : graph - table ] , </S>",
    "<S> association amounts to sharing the value of @xmath3 , as we saw in the tuples for and in figure  [ fig : graph - table ] . </S>",
    "<S> the predicate simply does a join on the third label field :    assoc(i , j ) : - arc(i,_,_,_,_,a ) , arc(j,_,_,_,_,a )    finally , it is convenient to have a kleene star relation . </S>",
    "<S> unfortunately in datalog we are unable to collect up the arbitrary length sequence it matches . </S>",
    "<S> here we have it returning the two nodes which bound the sequence , which is often enough to uniquely identify the sequence in practice .    </S>",
    "<S> node(n ) : - arc(_,n , _ , _ , _ , _ ) </S>",
    "<S> node(n ) : - arc(_,_,n , _ , _ , _ )    kleene1(x , x , _ ) : - node(x ) kleene1(x , y , l ) : - arc(_,x , z , l , _ , _ ) , kleene1(z , y , l )    kleene2(x , x , _ ) : - node(x ) kleene2(x , y , l ) : - arc(_,x , z,_,l , _ ) , kleene2(z , y , l )    kleene3(x , x , _ ) : - node(x ) kleene3(x , y , l ) : - arc(_,x , z,_,_,l ) , kleene3(z , y , l )    with this simple machinery we can start defining some annotation queries .    </S>",
    "<S> find a sequence of vowel followed by stop at the phoneme level ( assumes suitably defined vowel and stop unary relations ) :    vowel_stop(i , j ) : - arc(i,_,y , phoneme , v , _ ) , arc(j , y,_,phoneme , s , _ ) , vowel(v ) , stop(s )    if we do not want both the vowel and the stop , but just the vowel , we could write :    vowel_stop(i ) : - arc(i,_,y , phoneme , v , _ ) , arc(_,y,_,phoneme , s , _ ) , vowel(v ) , stop(s )    find words dominating vowel phonemes :    strongwrddomvowels(i ) : - arc(i,_,_,word , s , _ ) , arc(j,_,_,phoneme , v , _ ) , vowel(v ) , dom(i , j )    find words associated with h * tones :    sylhtone(i ) : - arc(i,_,_,word,_,a ) , arc(_,_,_,tone , h*,a )    find stop - vowel sequences dominated by words in noun phrases where the word is associated with an h * tone target .    </S>",
    "<S> stop_vowel_seq(i , j ) : - arc(i,_,y , phoneme , s , _ ) , stop(s ) , arc(j , y,_,phoneme , v , _ ) , vowel(v ) , arc(w,_,_,word , _ , _ ) , arc(n,_,_,syn , np , _ ) , dom(n , w ) , dom(w , </S>",
    "<S> i ) , dom(w , j ) , arc(t,_,tone , h * , _ ) , assoc(w , t )    find the intermediate phrase containing the main verb of a sentence :    imt_phrase(p ) : - arc(k , _ , _ , syn , s , _ ) , arc(j , _ , _ , syn , vp , _ ) , arc(i , _ , _ , syn , v , _ ) , i_dom(k , j ) , i_dom(j , i ) , dom(p , i ) , arc(p , _ , _ , imt , _ , _ )    return the set of syllables between an h * and an l% tone ( inclusive ) .    </S>",
    "<S> syls(k ) : - arc ( _ , _ , n , tone , h * , a1 ) , arc ( _ , n , _ , </S>",
    "<S> tone , l arc(i , _ , </S>",
    "<S> n1 , syl , _ , a1 ) , arc(j , n2 , _ , syl , _ , a2 ) , kleene1(n1 , n2 , syl ) , arc(k , n2 , n3 , syl , _ , _ ) , kleene1(n3 , n4 , syl )    the above query shows how the datalog model breaks down . </S>",
    "<S> we would like it to return sets of sets of syllable arcs . instead it returns a flat set structure . </S>",
    "<S> in many cases we will know that some arc participating in the query expression can be used to recover the nested structure . </S>",
    "<S> for example , if the head of the above clause was changed from to , then will aggregate in just the right way .    </S>",
    "<S> it is worth briefly considering the suitability of existing xml query languages such as xml - ql @xcite and xql @xcite for the domain of annotated speech . at first glance the problems we face querying annotated speech data are similar to those present with xml queries in that both present a hierarchical data model . </S>",
    "<S> a number of formulations of annotation data as xml are possible , indeed some projects make use of xml / sgml based formats entirely ( e.g.  mate , lacito ) . </S>",
    "<S> xml can represent trees using properly nested tags , in the obvious way . in order to represent multiple independent hierarchies built on top of the same material </S>",
    "<S> one must construct trees using idref pointers . </S>",
    "<S> this idea was proposed by the text encoding initiative @xcite and recently adopted by the mate project . </S>",
    "<S> we believe this approach is vastly more expressive than necessary for representing speech annotations , and we prefer a more constrained approach having desirable computational properties with respect to creation , validation and query .    </S>",
    "<S> the xql proposal @xcite describes a query language which is intended to select elements from within xml documents according to various criteria ; for example , the query ` text / author ` returns all author elements that are children of text elements . </S>",
    "<S> the xql data model ignores the order of elements within a parent element and has no obvious way to query for sequences of tokens .    </S>",
    "<S> the xml - ql proposal @xcite provides for a data model where the order of elements is respected . </S>",
    "<S> a query for a word - internal vowel - stop sequence could be expressed as follows ( assuming suitably tagged annotation data for timit ) :    < word > < phoneme label=&vowel;/ > < phoneme label=&stop;/ > < /word >    the result of this query would have the following form :    < word label = had > </S>",
    "<S> < phoneme label = ae/ > < phoneme label = dcl/ > < /word > < word label = dark > < phoneme label = ar/ > </S>",
    "<S> < phoneme label = k/ > < </S>",
    "<S> /word >    queries which refer to two independent hierarchies , such as syntactic and intonational phrase structure , need to use joins . for example , to find words that are simultaneously at the end of both clauses and intermediate phrases , we could have the following query :    < intermediate > < word id=$i></>[end ( ) ] < /intermediate >    < clause > < word id=$i></>[end ( ) ] < /clause >    we assume the existence of some mechanism to pick out the last child element . </S>",
    "<S> the i d attribute ensures that the words are the same in each part of the join .    </S>",
    "<S> perhaps either of these approaches could be made to work for a useful range of query needs . </S>",
    "<S> however they do not appear to be sufficiently general . </S>",
    "<S> for example , it is often useful to have query expressions involving kleene star : ` select all pairs of consonants , ignoring any intervening vowels ' ( cv*c ) . </S>",
    "<S> such queries may ignore hierarchical structure , finding sequences across ( say ) word boundaries . </S>",
    "<S> using regular expressions over paths , xml - ql could provide access to strings of terminal symbols ignoring intervening levels of hierarchy . </S>",
    "<S> yet it does not provide regular - expression matching over those sequences . </S>",
    "<S> alternatively , sequences at each level of a hierarchy could be chained together using idref pointers , but it is unclear how we would manage closures over such pointer structures .    </S>",
    "<S> annotated speech corpora are an essential component of speech research , and the variety of formats in which they are distributed has become a barrier to their wider adoption . to address this issue , </S>",
    "<S> we have developed two data models for speech annotations which seem to be sufficiently expressive to encompass the full range of practice in this area . </S>",
    "<S> we have shown how the models can be stored in a simple relational format , and how many useful queries in this domain are first - order . however </S>",
    "<S> , existing query languages lack sufficient expressive power for the full range of queries we would like to be able to express , and we hope stimulate new research into the design of general purpose query languages for databases of annotated speech recordings . </S>"
  ]
}