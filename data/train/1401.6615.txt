{
  "article_text": [
    "approximate consensus can be related to many distributed computations in networked systems , such as data aggregation @xcite , decentralized estimation @xcite , and flocking @xcite .",
    "extensive work has addressed the problem in the presence of _ byzantine nodes _ @xcite in either complete networks @xcite or arbitrary directed networks @xcite .",
    "as observed in @xcite , link failures become more and more prevalent . thus",
    ", it is of interest to consider the problem of approximate consensus in the presence of byzantine _ link _ failures .",
    "this paper explores such problem in synchronous point - to - point networks , where each directed link of the underlying communication graph represents a communication channel between a pair of nodes .",
    "the link failures are modeled using a _ transient byzantine link _ failure model ( formal definition in section [ s_models ] ) @xcite , in which different sets of link failures may occur at different time .",
    "we consider the problem in arbitrary directed graphs using a _ restricted class _ of iterative algorithms that maintain only a small amount of memory across iterations , e.g. , the algorithms do not require the knowledge of the network topology .",
    "such iterative algorithms are of interest in networked systems , since they have low complexity and do not rely on global knowledge @xcite .",
    "in particular , the iterative algorithms have the following properties , which we will state more formally later :    * * initial state * of each node is equal to a real - valued _ input _ provided to that node .",
    "* * termination * : the algorithm terminates in finite number of iterations . * * validity * : after each iteration of the algorithm , the state of each node must stay in the _ convex hull _ of the states of all the nodes at the end of the _ previous _ iteration . * * @xmath0-agreement * : for any @xmath1 , when the algorithm terminates , the difference between any pair of nodes is guaranteed to be within @xmath0 .    [ [ main - contribution ] ] main contribution + + + + + + + + + + + + + + + + +    this paper extends our recent work on approximate consensus under node failures @xcite .",
    "the main contribution is identifying a _ tight _ necessary and sufficient condition for the graphs to be able to reach approximate consensus under _ transient byzantine link _ failure models @xcite using restricted iterative algorithms ; our proof of correctness follows a structure previously used in our work to prove correctness of other consensus algorithms in incomplete networks @xcite .",
    "the use of matrix analysis is inspired by the prior work on non - fault - tolerant consensus ( e.g. , @xcite ) .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    approximate consensus has been studied extensively in synchronous as well as asynchronous systems .",
    "bertsekas and tsitsiklis explored reaching approximate consensus without failures in synchronous dynamic network , where the underlying communication graph is time - varying @xcite .",
    "dolev et al .",
    "considered approximate consensus in the presence of _ byzantine nodes _ in both synchronous and asynchronous systems @xcite , where the network is assumed to be a clique , i.e. , a complete network .",
    "subsequently , for complete graphs , abraham et al . proposed an algorithm to achieve approximate consensus with _",
    "byzantine nodes _ in asynchronous systems using optimal number of nodes @xcite .",
    "recent work has addressed approximate consensus in incomplete graphs with faulty _ nodes _ @xcite . @xcite and @xcite showed exact characterizations of graphs in which the approximate consensus problem is solvable in the presence of byzantine nodes and malicious nodes , respectively .",
    "malicious node is a restricted type of byzantine node in which every node is forced to send the identical message to all of its neighbors .",
    "much effort has also been devoted to the problem of achieving consensus in the presence of link failures @xcite .",
    "charron - bost and schiper proposed a ho ( heard - of ) model that captures both the link and node failures at the same time @xcite .",
    "however , the failures are assumed to be benign in the sense that no corrupted message will ever be received in the network .",
    "santoro and widmayer proposed the _ transient _ byzantine link failure model : a different set of links can be faulty at different time @xcite .",
    "they characterized a necessary condition and a sufficient condition for undirected networks to achieve consensus in the transient link failure model ; however , the conditions are _ not _ tight ( i.e. , do not match ) : necessary and sufficient conditions are specified in terms of node degree and edge - connectivity , is said to be @xmath2-edge connected , if @xmath3 is connected for all @xmath4 such that @xmath5 .",
    "] respectively .",
    "subsequently , biely et al . proposed another link failure model that imposes an upper bound on the number of faulty links incident to each node @xcite . as a result , it is possible to tolerate @xmath6 link failures with @xmath7 nodes in the new model . under this model , schmid et al .",
    "proved lower bounds on number of nodes , and number of rounds for achieving consensus @xcite .",
    "however , incomplete graphs were not considered in @xcite .    for consensus problem , it has been shown in @xcite and @xcite , respectively , that an undirected graph of @xmath8 node - connectivity is said to be @xmath2-node connected , if @xmath9 is connected for all @xmath10 such that @xmath5 . ] and edge - connectivity is able to tolerate @xmath11 byzantine nodes and @xmath11 byzantine links .",
    "independently , researchers showed that @xmath8 node - connectivity is both necessary and sufficient for the problem of information dissemination in the presence of either @xmath11 faulty nodes @xcite or @xmath11 _ fixed _ faulty links @xcite .",
    "however , both node - connectivity and edge - connectivity are not adequate for our problem as illustrated in section [ sec : iacbl ] .",
    "link failures have also been addressed under other contexts , such as distributed method for wireless control network @xcite , reliable transmission over packet network @xcite , or estimation over noisy links @xcite .",
    "_ communication model : _ the system is assumed to be _ synchronous_.",
    "the communication network is modeled as a simple _ directed _ graph @xmath12 , where @xmath13 is the set of @xmath7 nodes , and @xmath14 is the set of directed edges between the nodes in @xmath15 . with a slight abuse of terminology",
    ", we will use the terms _ edge _ and _ link _ interchangeably in our presentation . in simple graph",
    ", there is at most one directed edge from any node @xmath16 to some other node @xmath17 ( but our results can be extended to multi - graph ) .",
    "we assume that @xmath18 , since the consensus problem for @xmath19 is trivial .",
    "node @xmath16 can reliably transmit messages to node @xmath17 if and only if the directed edge @xmath20 is in @xmath14 .",
    "each node can send messages to itself as well ; however , for convenience , we exclude _ self - loops _ from set @xmath14 .",
    "that is , @xmath21 for @xmath22 .    for each node @xmath16 ,",
    "let @xmath23 be the set of nodes from which @xmath16 has incoming edges .",
    "that is , @xmath24 .",
    "similarly , define @xmath25 as the set of nodes to which node @xmath16 has outgoing edges .",
    "that is , @xmath26 . since we exclude self - loops from @xmath14 , @xmath27 and @xmath28",
    "however , we note again that each node can indeed send messages to itself .",
    "similarly , let @xmath29 be the set of incoming links incident to node @xmath16 .",
    "that is , @xmath29 contains all the links from nodes in @xmath23 to node @xmath16 , i.e. , @xmath30 . + _ failure model : _ we consider the transient byzantine _ link _ failure model @xcite for iterative algorithms in directed network .",
    "all nodes are assumed to be _ fault - free _ , and only send a single message once in each iteration .",
    "a link @xmath20 is said to be faulty if the message sent by node @xmath16 is different from the message received by node @xmath17 in some iteration .",
    "note that in our model , it is possible that link @xmath20 is faulty while link @xmath31 is fault-free.s transmitter is broken while node @xmath16 s receiver and node @xmath17 s transmitter and receiver all function correctly . ] in every iteration , up to @xmath11 links may be faulty , at most @xmath11 links may deliver incorrect message or drop message .",
    "note that different sets of link failures may occur in different iterations .",
    "a faulty link may tamper or drop messages .",
    "also , the faulty links may be controlled by a single omniscient adversary .",
    "that is , the adversary is assumed to have a complete knowledge of the execution of the algorithm , including the states of all the nodes , contents of messages the other nodes send to each other , the algorithm specification , and the network topology .",
    "in this section , we describe the structure of the _ iterative approximate byzantine consensus _ ( iabc ) algorithms of interest , and state conditions that they must satisfy .",
    "the iabc structure is identical to the one in our prior work on node failures @xcite .",
    "each node @xmath16 maintains state @xmath32 , with @xmath33 $ ] denoting the state of node @xmath16 at the _ end _ of the @xmath34-th iteration of the algorithm ( @xmath35 ) .",
    "initial state of node @xmath16 , @xmath36 $ ] , is equal to the initial _ input _ provided to node @xmath16 . at the _ start _ of the @xmath34-th iteration ( @xmath37 )",
    ", the state of node @xmath16 is @xmath38 $ ] .",
    "we assume that the input at each node is lower bounded by a constant @xmath39 and upper bounded by a constant @xmath40 .",
    "the iterative algorithm may terminate after a number of iterations that is a function of @xmath41 and @xmath40 .",
    "@xmath39 and @xmath40 are assumed to be known a priori .",
    "the iabc algorithms of interest will require each node @xmath16 to perform the following three steps in iteration @xmath34 , where @xmath37 .",
    "note that the message sent via faulty links may deviate from this specification .    1 .",
    "_ transmit step : _ transmit current state , namely @xmath38 $ ] , on all outgoing edges ( to nodes in @xmath25 ) .",
    "2 .   _ receive step : _ receive values on all incoming edges ( from nodes in @xmath23 )",
    ". denote by @xmath42 $ ] the vector of values received by node @xmath16 from its neighbors .",
    "the size of vector @xmath42 $ ] is @xmath43 .",
    "the values sent in iteration @xmath34 are received in the same iteration ( unless dropped by the faulty links ) .",
    "3 .   _ update step : _",
    "node @xmath16 updates its state using a transition function @xmath44 as follows .",
    "@xmath44 is a part of the specification of the algorithm , and takes as input the vector @xmath42 $ ] and state @xmath38 $ ] .",
    "@xmath45 & = &   t_i ~ ( ~r_i[t]\\,,\\,v_i[t-1 ] ~ ) \\label{eq : t_i}\\end{aligned}\\ ] ]       the following properties must be satisfied by an iabc algorithm in the presence of up to @xmath11 byzantine faulty links :    * * termination * : the algorithm terminates in finite number of iterations . + * * validity : * @xmath46 \\ge \\min_{i \\in { \\mathcal{v } } } v_i[t-1]$ ] and + @xmath47 \\ge \\max_{i \\in { \\mathcal{v } } } v_i[t-1]$ ] . + * * @xmath0-agreement : * if the algorithm terminates after @xmath48 iterations , then @xmath49 - v_j[t_{end}]| < \\epsilon$ ] .",
    "the objective in this paper is to identify the necessary and sufficient conditions for the existence of a _ correct _ iabc algorithm ( i.e. , an algorithm satisfying the above properties ) for a given @xmath12 .",
    "[ [ example - network ] ] example network + + + + + + + + + + + + + + +    we give an example showing that node- and edge - connectivity are not adequate for specifying the _ tight _ condition in directed graphs .",
    "consider the case when @xmath50 in the network in figure [ f : eg ] . in the network ,",
    "nodes @xmath51 form a clique , while node @xmath52 has only incoming edges from nodes @xmath53 .",
    "it is obvious that the node- and edge - connectivity of the network are less than @xmath54 , since node @xmath52 does not have any outgoing links to any other node .",
    "however , the approximate consensus is solvable using iabc algorithms under one ( directed ) faulty link , since the network satisfies the sufficient condition proved later . the proof is presented in [ a : example ] .",
    "therefore , @xmath8 node- and edge - connectivity are not necessary for the existence of iabc algorithms .",
    "for a correct iterative approximate consensus algorithm to exists in the presence of byzantine link failures , the graph @xmath55 must satisfy the necessary condition proved in this section .",
    "we now define relations @xmath56 and @xmath57 that are used frequently in our proofs .",
    "[ def : absorb ] for non - empty disjoint sets of nodes @xmath58 and @xmath59 in @xmath55 , @xmath60 iff there exists a node @xmath61 that has at least @xmath62 incoming links from nodes in @xmath58 , i.e. , @xmath63 ; @xmath64 iff @xmath65 is _ not _ true .",
    "_ condition p _  : consider graph @xmath55 .",
    "denote by @xmath66 a subset of @xmath14 such that @xmath67 .",
    "let sets @xmath68 form a partition of @xmath15 , such that both @xmath69 and @xmath70 are non - empty .",
    "then , in @xmath71 , at least one of the two conditions below must be true : ( i ) @xmath72 ; ( ii ) @xmath73 .",
    "[ thm : nc ] suppose that a correct iabc algorithm exists for @xmath55",
    ". then @xmath74 satisfies _",
    "condition p_.    the proof is by contradiction .",
    "let us assume that a correct iabc algorithm exists , and for some node partition @xmath75 and a subset @xmath76 such that @xmath67 , @xmath77 and @xmath78 in @xmath79 .",
    "thus , for any @xmath80 , @xmath81 .",
    "similarly , for any @xmath82 , @xmath83 .    also assume that the links in @xmath66 ( if @xmath66 is non - empty ) all behave faulty , and the rest of the links are all fault - free in every iteration .",
    "note that the nodes are not aware of the identity of the faulty links .",
    "consider the case when ( i ) each node in @xmath69 has initial input @xmath84 , ( ii ) each node in @xmath70 has initial input @xmath85 , such that @xmath86 , and ( iii ) each node in @xmath87 , if @xmath87 is non - empty , has an input in the interval @xmath88 $ ] .",
    "define @xmath89 and @xmath90 such that @xmath91 .    in the _ transmit step _ of iteration 1 ,",
    "each node @xmath2 , sends to nodes in @xmath92 value @xmath93 $ ] ; however , some values sent via faulty links may be tampered .",
    "suppose that the faulty links in @xmath66 ( if non - empty ) tamper the messages sent via them in the following way ( i ) if the link is an incoming link to a node in @xmath69 , then @xmath94 is deliver to that node ; ( ii ) if the link is an incoming link to a node in @xmath70 , then @xmath95 is deliver to that node ; and ( iii ) if the link is an incoming link to a node in @xmath87 , then some arbitrary value in interval @xmath88 $ ] is deliver to that node .",
    "this behavior is possible since links in @xmath66 are byzantine faulty by assumption .",
    "note that @xmath96 .",
    "consider any node @xmath97 . recall that @xmath29 the set of all the node @xmath16 s incoming links",
    "let @xmath98 be the subset of @xmath29 that are incident to nodes in @xmath99 , i.e. ,    @xmath100    since @xmath101 , @xmath102 .",
    "moreover , by assumption @xmath77 ; thus , @xmath103 .",
    "node @xmath16 will then receive @xmath89 via the links in @xmath104 ( if non - empty ) and values in @xmath88 $ ] via the links in @xmath105 , and @xmath84 via the rest of the links , i.e. , links in @xmath106 .",
    "consider the following two cases :    * both @xmath104 and @xmath105 are non - empty : + in this case , recall that @xmath102 and @xmath107 . from node @xmath16 s perspective , consider two possible scenarios : ( a ) links in @xmath104 are faulty , and the other links are fault - free , and ( b ) links in @xmath105 are faulty , and the other links are fault - free .",
    "+ in scenario ( a ) , from node @xmath16 s perspective , all the nodes may have sent values in interval @xmath88 $ ] , but the faulty links have delivered @xmath89 to node @xmath16 . according to the validity property , @xmath108 \\geq m$ ] . on the other hand , in scenario ( b ) , all the nodes may have sent values @xmath89 or @xmath84 , where @xmath109 ; so @xmath108 \\leq m$ ] , according to the validity property . since node @xmath16 does not know whether the correct scenario is ( a ) or ( b )",
    ", it must update its state to satisfy the validity property in both cases .",
    "thus , it follows that @xmath108 = m$ ] .",
    "* at most one of @xmath104 and @xmath105 is non - empty : + recall that by assumption , @xmath102 and @xmath107 .",
    "since at most one of the set is non - empty , @xmath110 . from node @xmath16",
    "s perspective , it is possible that the links in @xmath111 are all faulty , and the rest of the links are fault - free . in this situation ,",
    "the values sent to node @xmath16 via all the fault - free links are all @xmath84 , and therefore , @xmath108 $ ] must be set to @xmath84 as per the validity property .",
    "thus , @xmath108=m$ ] for each node @xmath80 .",
    "similarly , we can show that @xmath112 = m$ ] for each node @xmath113 .",
    "now consider the nodes in set @xmath87 , if @xmath87 is non - empty .",
    "all the values received by the nodes in @xmath87 are in @xmath88 $ ] , therefore , their new state must also remain in @xmath88 $ ] , as per the _ validity _ property .",
    "the above discussion implies that , at the end of iteration 1 , the following conditions hold true : ( i ) state of each node in @xmath69 is @xmath84 , ( ii ) state of each node in @xmath70 is @xmath85 , and ( iii ) state of each node in @xmath87 is in the interval @xmath88 $ ] .",
    "these conditions are identical to the initial conditions listed previously .",
    "then , by a repeated application of the above argument ( proof by induction ) , it follows that for any @xmath35 , @xmath33 = m$ ] for all @xmath114 , @xmath115 = m$ ] for all @xmath113 and @xmath116\\in[m , m]$ ] for all @xmath117 .    since both @xmath69 and @xmath70 are non - empty , the _",
    "@xmath0-agreement _ property is not satisfied . a contradiction .",
    "@xmath118    theorem [ thm : nc ] shows that _ condition p _ is necessary .",
    "however , _",
    "condition p _ is not intuitive .",
    "below , we state an equivalent condition _",
    "condition s _ that is easier to interpret . to facilitate the statement",
    ", we introduce the notions of `` source component '' and `` link - reduced graph '' using the following three definitions .",
    "the link - reduced graph is analogous to the similar concept introduced in our prior work on node failures @xcite .",
    "[ def : decompose ] * graph decomposition : * let @xmath119 be a directed graph .",
    "partition graph @xmath119 into non - empty strongly connected components , @xmath120 , where @xmath121 is a non - zero integer dependent on graph @xmath119 , such that    * every pair of nodes within the same strongly connected component has directed paths in @xmath119 to each other , and * for each pair of nodes , say @xmath16 and @xmath17 , that belong to two _ different _ strongly connected components , either @xmath16 does not have a directed path to @xmath17 in @xmath119 , or @xmath17 does not have a directed path to @xmath16 in @xmath119 .    construct a graph @xmath122 wherein each strongly connected component @xmath123 above is represented by vertex @xmath124 , and there is an edge from vertex @xmath124 to vertex @xmath125 if and only if the nodes in @xmath123 have directed paths in @xmath119 to the nodes in @xmath126 .",
    "it is known that the decomposition graph @xmath122 is a directed _ acyclic _ graph @xcite .",
    "* source component * : let @xmath119 be a directed graph , and let @xmath122 be its decomposition as per definition  [ def : decompose ] .",
    "strongly connected component @xmath123 of @xmath119 is said to be a _ source component _ if the corresponding vertex @xmath124 in @xmath122 is reachable from any other vertex in @xmath122 .",
    "[ def : reduced ] * link - reduced graph : * for a given graph @xmath12 and @xmath127 , a graph @xmath128 is said to be a _",
    "link - reduced graph _",
    ", if @xmath129 is obtained by first removing from @xmath14 all the links in @xmath66 , and _ then _ removing up to @xmath11 other incoming links at each node in @xmath130 .",
    "note that for a given @xmath12 and a given @xmath66 , multiple link - reduced graphs @xmath131 may exist .",
    "+ now , we state _",
    "condition s _",
    ":       _ condition s _ : consider graph @xmath12 .",
    "for any @xmath76 such that @xmath67 , every link - reduced graph @xmath131 obtained as per definition [ def : reduced ] must contain exactly one _ source component_.    then , we show that _ condition s _ and _ condition p _ specify the equivalent property of the graph .",
    "[ lemma : p - to - s ] suppose that _",
    "condition p _ holds for graph @xmath12 .",
    "then @xmath74 satisfies _",
    "condition s_.    by assumption , @xmath74 contains at least two node , and so does @xmath131 ; therefore , at least one source component must exist in @xmath131 .",
    "we now prove that @xmath131 can not contain more than one source component .",
    "the proof is by contradiction .",
    "suppose that there exists a subset @xmath132 with @xmath101 , and the link - reduced graph @xmath128 corresponding to @xmath66 such that the decomposition of @xmath131 includes at least two source components .",
    "let the sets of nodes in two such source components of @xmath131 be denoted @xmath69 and @xmath70 , respectively .",
    "let @xmath133 .",
    "observe that @xmath68 form a partition of the nodes in @xmath15 . since @xmath69 is a source component in @xmath131",
    ", it follows that there are no directed links in @xmath129 from any node in @xmath99 to the nodes in @xmath69 .",
    "similarly , since @xmath70 is a source component in @xmath131 , it follows that there are no directed links in @xmath129 from any node in @xmath134 to the nodes in @xmath70 .",
    "these observations , together with the manner in which @xmath129 is defined , imply that ( i ) there are at most @xmath11 links in @xmath130 from the nodes in @xmath99 to each node in @xmath69 , and ( ii ) there are at most @xmath11 links in @xmath130 from the nodes in @xmath134 to each node in @xmath70 .",
    "therefore , in graph @xmath135 , @xmath77 and @xmath78 .",
    "thus , @xmath136 does not satisfies _ condition p _ , since @xmath76 and @xmath67 , a contradiction .",
    "@xmath118    [ lemma : s - to - p ] suppose that _ condition s _ holds for graph @xmath12 .",
    "then , @xmath74 satisfies _",
    "condition p_.    the proof is by contradiction .",
    "suppose that _",
    "condition p _ does not hold for graph @xmath137 .",
    "thus , there exist a subset @xmath138 , where @xmath67 , and a node partition @xmath68 , where @xmath69 and @xmath70 are both non - empty , such that @xmath77 and @xmath78 in @xmath71 .",
    "we now constructed a link - reduced graph @xmath139 corresponding to set @xmath66 .",
    "first , remove all links in @xmath66 from @xmath14 . then since @xmath77 , the number of links at each node in @xmath69 from nodes in @xmath140 is at most @xmath11 ; remove all these links .",
    "similarly , for every node @xmath113 , remove all links from nodes in @xmath141 to @xmath17 ( recall that by assumption , there are at most @xmath11 such links ) .",
    "the remaining links form the set @xmath129",
    ". it should be obvious that @xmath139 satisfies definition [ def : reduced ] ; hence , @xmath131 is a valid link - reduced graph .",
    "now , observe that by construction , in the link - reduced graph @xmath139 , there are no incoming links to nodes in @xmath70 from nodes in @xmath134 ; similarly , in @xmath131 , there are no incoming links to nodes in @xmath69 from nodes in @xmath99 .",
    "it follows that for each @xmath97 , there is no path using links in @xmath129 from @xmath16 to nodes in @xmath70 ; similarly , for each @xmath113 , there is no path using links in @xmath129 from @xmath17 to nodes in @xmath69 .",
    "thus , @xmath131 must contain at least two source components .",
    "therefore , the existence of @xmath131 implies that @xmath74 violates _ condition s _ , a contradiction .",
    "lemmas [ lemma : p - to - s ] and [ lemma : s - to - p ] imply that _ condition p _ is equivalent to _",
    "condition s_. an alternate interpretation of _ condition s _ is that in every link - reduced graph @xmath131 , non - fault - tolerant iterative consensus must be possible .",
    "suppose @xmath55 satisfies _ condition p _ and _ condition s_. we provide two lemmas below to state some properties of @xmath55 that are useful for analyzing the iterative algorithm presented later .",
    "lemma [ lemma : path ] intuitively states that at least one node can propagate its value to all the other nodes ( over enough number of iterations ) .",
    "lemma [ lemma:2f+1 ] states that each node needs to have enough incoming neighbors for achieving approximate consensus .",
    "[ lemma : path ] suppose that graph @xmath55 satisfies _",
    "condition s_. then , in any link - reduced graph @xmath139 , there exists a node that has a directed path to all the other nodes in @xmath15 .",
    "recall that _",
    "condition s _ states that any link - reduced graph @xmath139 has a single source component . by the definition of source component , any node in the source component ( say node @xmath142 )",
    "has directed paths using edges in @xmath129 to all the other nodes in the source component , since the source component is a strongly connected component . also , by the uniqueness of the source component , all other strongly connected components in @xmath131 ( if any exist ) are not source components , and hence reachable from the source component using the edges in @xmath129 . therefore , node @xmath142 also has directed paths to all the nodes in @xmath15 that are not in the source component as well . therefore , node @xmath142 has directed paths to all the other nodes in @xmath15 .",
    "this proves the lemma .",
    "@xmath118    [ lemma:2f+1 ] for @xmath143 , if graph @xmath144 satisfies _ condition p _ , then each node in @xmath15 has in - degree at least @xmath8 , i.e. , for each @xmath145 .",
    "the proof is by contradiction . by assumption in the lemma , @xmath143 , and graph @xmath136 satisfies _",
    "condition p_.    suppose that there exists a node @xmath146 such that @xmath147 .",
    "define @xmath148 , and @xmath149 .",
    "note that sets @xmath68 form a partition of @xmath15 .",
    "now , define an edge set @xmath66 such that @xmath150 , and @xmath66 contains @xmath151 incoming links from nodes in @xmath70 to node @xmath16 .",
    "observe that @xmath143 , and @xmath152 .",
    "thus , there can be at most @xmath153 link from @xmath141 to any node in @xmath70 in @xmath135 .",
    "therefore , @xmath154 in @xmath135 . then , recall that @xmath29 is the set of all the node @xmath16 s incoming links . since @xmath155 and @xmath156 , @xmath157 . also , since @xmath158 , and @xmath66 contains @xmath151 links in @xmath29 , @xmath159 .",
    "therefore , @xmath160 in @xmath161 .",
    "thus , @xmath162 does not satisfy _ condition p _ , a contradiction . @xmath118",
    "we will prove that there exists a correct iabc algorithm  particularly algorithm 1 below  that satisfies the termination , validity and @xmath0-agreement properties provided that the graph @xmath55 satisfies _",
    "condition s_. this implies that _ condition p _ and _ condition s _ ares also sufficient . algorithm 1 has the iterative structure described in section [ sec : iacbl ] , and it is similar to algorithms that were analyzed in prior work as well @xcite ( although correctness of the algorithm under the necessary condition ( _ conditions p _ and _ s _ ) has not been proved previously ) .       ' '' ''    * algorithm 1 *    ' '' ''    1 .   _ transmit step : _ transmit current state @xmath38 $ ] on all outgoing edges and self - loop .",
    "2 .   _ receive step : _ receive values on all incoming edges and self - loop .",
    "these values form vector @xmath42 $ ] of size @xmath163 ( including the value from node @xmath16 itself ) . when a node expects to receive a message from an incoming neighbor but",
    "does not receive the message , the message value is assumed to be equal to its own state , i.e. , @xmath38 $ ] .",
    "3 .   _ update step : _ sort the values in @xmath42 $ ] in an increasing order ( breaking ties arbitrarily ) , and eliminate the smallest and largest @xmath11 values .",
    "let @xmath164 $ ] denote the set of nodes from whom the remaining @xmath165 values in @xmath42 $ ] were received .",
    "note that as proved in lemma [ lemma:2f+1 ] , each node has at least @xmath8 incoming neighbors .",
    "thus , when @xmath143 , @xmath166| \\geq 2 $ ] .",
    "let @xmath167 denote the value received from node @xmath168 $ ] .",
    "note that @xmath169 $ ] .",
    "hence , for convenience , define @xmath170 $ ] to be the value node @xmath16 receives from itself .",
    "observe that if the link from @xmath171 $ ] is fault - free , then @xmath172 $ ] .",
    "+ define @xmath45 ~ = ~ t_i(r_i[t ] ) ~ = ~\\sum_{j\\in n_i^*[t ] } a_i \\ , w_j \\label{e_t}\\end{aligned}\\ ] ] where @xmath173| } = \\frac{1}{|n_i^-|+1 - 2f}\\ ] ] + the `` weight '' of each term on the right - hand side of ( [ e_t ] ) is @xmath174 .",
    "note that @xmath166| = |n_i^-|+1 - 2f$ ] , and @xmath175 $ ] because @xmath21 .",
    "thus , the weights on the right - hand side add to 1 . also , @xmath176 . and",
    "@xmath174 may be different for each iteration @xmath34 , for simplicity , we do not explicitly represent this dependence on @xmath34 in the notations . ]    * termination * : each node terminates after completing iteration @xmath48 , where @xmath48 is a constant defined later in equation ( [ eq : tend ] ) .",
    "the value of @xmath48 depends on graph @xmath55 , constants @xmath40 and @xmath39 defined earlier in section [ sec : iacbl ] and parameter @xmath0 in @xmath0-agreement property .    ' '' ''",
    "we will prove that given a graph @xmath55 satisfying _ condition s _ , algorithm 1 is correct , i.e. , algorithm 1 satisfies _ termination , validity , @xmath0-agreement _ properties .",
    "therefore , _ condition s _ and _ condition p _ are proved to be sufficient .",
    "we borrow the matrix analysis from the work on non - fault - tolerant consensus @xcite .",
    "the proof below follows the same structure in our prior work on node failures @xcite ; however , such analysis has not been applied in the case of link failures .    in the rest of the section ,",
    "we assume that @xmath12 satisfies _ condition s _ and _ condition p_. we introduce standard matrix tools to facilitate our proof .",
    "then , we use transition matrix to represent the _ update _ step in algorithm 1 , and show how to use these tools to prove the correctness of algorithm 1 in @xmath12 .      in the discussion",
    "below , we use boldface upper case letters to denote matrices , rows of matrices , and their elements . for instance",
    ", @xmath177 denotes a matrix , @xmath178 denotes the @xmath16-th row of matrix @xmath177 , and @xmath179 denotes the element at the intersection of the @xmath16-th row and the @xmath17-th column of matrix @xmath177 .    [ d_stochastic ] a vector is said to be",
    "_ stochastic _ if all the elements of the vector are non - negative , and the elements add up to 1 .",
    "a matrix is said to be _ row stochastic _ if each row of the matrix is a stochastic vector .    when presenting matrix products , for convenience of presentation , we adopt the `` backward '' product convention below , where @xmath180 ,    @xmath181 = { { \\bf a}}[b]{{\\bf a}}[b-1]\\cdots{{\\bf a}}[a]\\ ] ]    for a row stochastic matrix @xmath177 , coefficients of ergodicity @xmath182 and @xmath183 are defined as follows @xcite : @xmath184    [ lemma : ergodicity ] for any @xmath185 square row stochastic matrices @xmath186 ,    @xmath187    lemma [ lemma : ergodicity ] is proved in @xcite .",
    "lemma [ lemma : ergodicity2 ] below follows from the definition of @xmath188 .",
    "[ lemma : ergodicity2 ] if all the elements in any one column of matrix * a*are lower bounded by a constant @xmath189 , then @xmath190 .",
    "that is , if @xmath191 , such that @xmath192 , then @xmath190 .",
    "it is easy to show that @xmath193 and @xmath194 , and that the rows of @xmath177 are all identical iff @xmath195 .",
    "also , @xmath196 iff @xmath197 .",
    "denote by @xmath198 $ ] the column vector consisting of the initial states at all nodes .",
    "the @xmath16-th element of @xmath198 $ ] , @xmath36 $ ] , is the initial state of node @xmath16 .",
    "denote by @xmath199 $ ] , for @xmath200 , the column vector consisting of the states of all nodes at the end of the @xmath34-th iteration .",
    "the @xmath16-th element of vector @xmath199 $ ] is state @xmath33 $ ] .",
    "for @xmath200 , define @xmath201 $ ] to be the set of all links behaving faulty in iteration @xmath34 .",
    "recall that link @xmath31 is said to be faulty in iteration @xmath34 if the value received by node @xmath16 is different from what node @xmath17 sends in iteration @xmath34 .",
    "then , define @xmath202 as the set of all nodes whose outgoing links to node @xmath16 is faulty in iteration @xmath34 , i.e. , @xmath203\\}$ ] .",
    "may be different for each iteration @xmath34 .",
    "for simplicity , the notation does not explicitly represent this dependence . ]",
    "define @xmath204 as a subset of incoming neighbors at node @xmath16 of size at most @xmath11 , i.e. , corresponds to the links removed in some link - reduced graph .",
    "thus , the superscript @xmath205 in the notation stands for  removed . \"",
    "@xmath204 may be different for each @xmath34 .",
    "for simplicity , the notation does not explicitly represent this dependence . ]",
    "@xmath206    now , we state the key lemma that helps prove the correctness of algorithm 1 .",
    "in particular , lemma [ lemma : tm2 cm ] allows us to use results for non - homogeneous markov chains to prove the correctness of algorithm 1 . the proof is presented in appendix [ a : tm2 cm ] .",
    "[ lemma : tm2 cm ] the _ update _ step in iteration @xmath207 of algorithm 1 at the nodes can be expressed as    @xmath208 = { \\textbf{m}}[t ] v[t-1]\\ ] ]    where @xmath209 $ ] is an @xmath210 row stochastic transition matrix with the following property : there exist a constant @xmath211 that depends only on graph @xmath55 , and @xmath204 such that for each @xmath146 , and for all @xmath212 ,    @xmath213 \\geq \\beta\\ ] ]       matrix @xmath209 $ ] is said to be a for iteration @xmath34 .",
    "aa the lemmas states , @xmath209 $ ] is a row stochastic matrix .",
    "the proof of lemma [ lemma : tm2 cm ] shows how to construct a suitable row stochastic matrix @xmath209 $ ] for each iteration @xmath34 .",
    "@xmath209 $ ] depends not only on @xmath34 but also on the behavior of the faulty links in iteration @xmath34 .",
    "[ thm : correctness ] algorithm 1 satisfies the _ termination , validity _ , and _",
    "@xmath0-agreement _ properties .",
    "sections [ s : validity ] , [ s : termination ] and [ s : agreement ] provide the proof that algorithm 1 satisfies the three properties for iterative approximate consensus in the presence of byzantine links .",
    "this proof follows a structure used to prove correctness of other consensus algorithms in our prior work @xcite .",
    "@xmath118      observe that @xmath214({\\textbf{m}}[t ] v[t-1 ] ) = ( { \\textbf{m}}[t+1]{\\textbf{m}}[t ] ) v[t-1]$ ] .",
    "therefore , by repeated application of ( [ matrix : e_t ] ) , we obtain for @xmath200 ,    @xmath215 = ( \\pi_{u = 1}^t { \\textbf{m}}[u ] ) v[0]\\ ] ]    since each @xmath216 $ ] is row stochastic as shown in lemma [ lemma : tm2 cm ] , the matrix product @xmath217 $ ] is also a row stochastic matrix .",
    "thus , ( [ eq : matrixt ] ) implies that the state of each node @xmath16 at the end of iteration @xmath34 can be expressed as a convex combination of the initial states at all the nodes .",
    "therefore , the validity property is satisfied .",
    "algorithm 1 terminates after @xmath48 iterations , where @xmath48 is a finite constant depending only on @xmath218 , and @xmath0 .",
    "recall that @xmath40 and @xmath39 are defined as upper and lower bounds of the initial inputs at all nodes , respectively .",
    "therefore , trivially , the algorithm satisfies the termination property .",
    "later , using ( [ eq : tend ] ) , we define a suitable value for @xmath48 .",
    "the proof below follows the same structure in our prior works on node failures @xcite for proving correctness of other consensus algorithms with byzantine nodes .",
    "denote by @xmath219 the set of all the link - reduced graph of @xmath55 corresponding to some faulty link set @xmath66 .",
    "let    @xmath220    note that @xmath205 only depends on @xmath55 and @xmath11 , and is a finite integer .",
    "consider iteration @xmath221 . recall that @xmath201 $ ] denote the set of faulty links in iteration @xmath34 .",
    "then for each link - reduced graph @xmath222 \\in r_{f[t]}$ ] , define connectivity matrix @xmath223 $ ] as follows , where @xmath224 :    * @xmath225 = 1 $ ] , if either @xmath226 , or edge @xmath31 exists in link - reduced graph @xmath227 ; * @xmath225 = 0 $ ] , otherwise .",
    "thus , the non - zero elements of row @xmath228 $ ] correspond to the incoming links at node @xmath16 in the link - reduced graph @xmath222 $ ] , or the self - loop at @xmath16 .",
    "observe that @xmath223 $ ] has a non - zero diagonal .",
    "condition s _ and lemma [ lemma : tm2 cm ] , we can show the following key lemmas .",
    "[ lemma : non - zero ] for any @xmath222 \\in r_{f[t]}$ ] , and @xmath229 $ ] has at least one non - zero column , i.e. , a column with all elements non - zero .",
    "@xmath12 satisfies the _",
    "condition s_. therefore , by lemma [ lemma : path ] , there exists at least one node @xmath185 in the link - reduced graph @xmath222 $ ] that has directed paths to all the nodes in @xmath222 $ ] ( consisting of the edges in @xmath222 $ ] ) .",
    "@xmath230 $ ] of product @xmath231 $ ] is @xmath153 if and only if node @xmath185 has a directed path to node @xmath17 consisting of at most @xmath2 edges in @xmath222 $ ] . since the length of the path from @xmath185 to any other node in @xmath222 $ ] is at most @xmath7 , and @xmath185 has directed paths to all the nodes , for @xmath232 the @xmath185-th column of matrix @xmath233 $ ] will be non - zero.$ ] , too .",
    "we use the loose bound of @xmath7 to simplify the presentation . ]",
    "@xmath118    for matrices @xmath234 and @xmath235 of identical dimension , we say that @xmath236 iff @xmath237 for all @xmath238 .",
    "lemma below relates the transition matrices with the connectivity matrices .",
    "constant @xmath239 used in the lemma below was introduced in lemma [ lemma : tm2 cm ] .",
    "[ lemma : cm ] for any @xmath200 , there exists a link - reduced graph @xmath222 \\in r_{f[t]}$ ] such that @xmath240 \\leq { \\textbf{m}}}[t]$ ] , where @xmath223 $ ] is the connectivity matrix for @xmath222 $ ] .",
    "first , let us construct a link - reduced graph @xmath222 $ ] by first removing @xmath201 $ ] from @xmath55 . recall that @xmath201 $ ] is the set of faulty links in iteration @xmath34 .",
    "then for each @xmath16 , remove a set of at most @xmath11 node @xmath16 s incoming links as defined in lemma [ lemma : tm2 cm ] ( @xmath204 ) . as a result , we have obtained a link - reduced graph @xmath222 $ ] such that @xmath241 \\geq \\beta$ ] , if @xmath226 or edge @xmath242 is in the link - reduced graph @xmath222 $ ] .",
    "denote by @xmath223 $ ] the connectivity matrix for the link - reduced graph @xmath222 $ ] .",
    "then , @xmath225 $ ] denotes the element in @xmath16-th row and @xmath17-th column of @xmath223 $ ] . by definition of the connectivity matrix ,",
    "we know that @xmath225 = 1 $ ] , if @xmath226 or edge @xmath242 is in the link - reduced graph ; otherwise , @xmath225 = 0 $ ] .",
    "the statement in the lemma then follows from the above two observations .",
    "@xmath118    [ l_product_h ] for any @xmath243 , at least one column in the matrix product",
    "@xmath244 $ ] is non - zero .",
    "since @xmath244 $ ] consists of @xmath245 connectivity matrices corresponding to link - reduced graphs , and the number of all link - reduced graphs for @xmath66 ( @xmath67 ) is @xmath205 , connectivity matrices corresponding to at least one link - reduced graph , say matrix @xmath246 , will appear in the above product at least @xmath7 times .",
    "now observe that : ( i ) by lemma [ lemma : non - zero ] , @xmath247 contains a non - zero column , say the @xmath2-th column is non - zero , and ( ii ) by definition , all the @xmath248 $ ] matrices in the product contain a non - zero diagonal . these two observations together imply that the @xmath2-th column in the above product is non - zero.$ ] can be viewed as the product of @xmath7 instances of @xmath249  interspersed \" with matrices with non - zero diagonals . ]",
    "@xmath118    let us now define a sequence of matrices @xmath250 , @xmath251 , such that each of these matrices is a product of @xmath245 of the @xmath252 $ ] matrices . specifically , @xmath253 \\label{e_q_i}\\end{aligned}\\ ] ] from ( [ eq : matrixt ] ) and ( [ e_q_i ] ) observe that @xmath254 & = & \\left(\\ , \\pi_{i=1}^k ~ { { \\bf q}}(i ) \\,\\right)~{v}[0]\\end{aligned}\\ ] ]    [ l_q ] for @xmath251 , @xmath250 is a scrambling row stochastic matrix , and @xmath255    @xmath250 is a product of row stochastic matrices ( @xmath252 $ ] ) ; therefore , @xmath250 is row stochastic . from lemma [ lemma :",
    "cm ] , for each @xmath256 , @xmath257 ~ \\leq ~ { { \\bf m}}[t]\\ ] ] therefore , @xmath258 ~ \\leq   ~ \\pi_{t=(i-1 ) r n+1}^{i",
    "r n } ~ { { \\bf m}}[t ] ~ = ~ { { \\bf q}}(i)\\ ] ] by using @xmath259 in lemma [ l_product_h ] , we conclude that the matrix product on the left side of the above inequality contains a non - zero column .",
    "therefore , since @xmath260 , @xmath250 on the right side of the inequality also contains a non - zero column .",
    "observe that @xmath245 is finite , and hence , @xmath261 is non - zero . since the non - zero terms in @xmath248 $ ]",
    "matrices are all 1 , the non - zero elements in @xmath262 $ ] must each be @xmath263 1 . therefore , there exists a non - zero column in @xmath250 with all the elements in the column being @xmath264 .",
    "therefore , by lemma [ lemma : ergodicity2 ] , @xmath265 , and @xmath250 is a scrambling matrix .",
    "@xmath118    let us now continue with the proof of @xmath0-agreement .",
    "consider the coefficient of ergodicity @xmath266)$ ] .",
    "observe that the upper bound on right side of ( [ eq : t ] ) depends only on graph @xmath55 and @xmath34 , and is independent of the input states , and the behavior of the faulty links .",
    "moreover , the upper bound on the right side of ( [ eq : t ] ) is a non - increasing function of @xmath34 .",
    "define @xmath48 as the smallest positive integer such that the right hand side of ( [ eq : t ] ) is smaller than @xmath268 . recall that @xmath40 and @xmath39 are defined as the upper and lower bound of the inputs at all nodes .",
    "thus ,    @xmath269 ) \\leq \\left ( 1-\\beta^{rn}\\right)^{\\lfloor\\frac{t_{end}}{r n}\\rfloor } < \\frac{\\epsilon}{n \\max(|u| , |\\mu|)}\\ ] ]    recall that @xmath239 and @xmath205 depend only on @xmath55 .",
    "thus , @xmath48 depends only on graph @xmath55 , and constants @xmath270 and @xmath0 .",
    "recall that @xmath217 $ ] is an @xmath210 row stochastic matrix .",
    "let @xmath271 $ ] . from [ eq : matrixt",
    "] , we have @xmath115 = { \\textbf{m}}^*_j v[0]$ ] .",
    "that is , the state of any node @xmath17 can be obtained as the product of the @xmath17-th row of @xmath272 and @xmath198 $ ] .",
    "now , consider any two nodes @xmath273 , we have    @xmath274 - \\sigma_{i=1}^n { \\textbf{m}}^*_{ki } v_i[0]| \\nonumber\\\\ & = |\\sigma_{i=1}^n \\left({\\textbf{m}}^*_{ji } - { \\textbf{m}}^*_{ki } \\right ) v_i[0]| \\nonumber\\\\ & \\leq \\sigma_{i=1}^n | { \\textbf{m}}^*_{ji } - { \\textbf{m}}^*_{ki } | |v_i[0]| \\nonumber\\\\ & \\leq \\sigma_{i=1}^n \\delta({\\textbf{m}}^ * ) |v_i[0]| \\nonumber\\\\ & \\leq n \\delta({\\textbf{m}}^ * ) \\max(|u| , |\\mu| ) \\nonumber\\\\ & \\leq n \\delta(\\pi_{u=1}^t { \\textbf{m}}[u ] ) \\max(|u| , |\\mu| ) \\label{eq : delta}\\end{aligned}\\ ] ]    therefore , by ( [ eq : tend ] ) and ( [ eq : delta ] ) , we have    latexmath:[\\[\\label{eq : final }     since the output of the nodes equal its state at termination ( after @xmath48 iterations ) .",
    "thus , ( [ eq : final ] ) implies that algorithm 1 satisfies the @xmath0-agreement property .",
    "this paper explores approximate consensus problem under transient byzantine link failure model .",
    "we address a particular class of iterative algorithms in arbitrary directed graphs , and prove a necessary and sufficient condition for the graphs to be able to solve the approximate consensus problem iteratively .",
    "10 i. abraham ,  y. amit ,  and  d. dolev . optimal resilience asynchronous approximate agreement . in opodis , 2004 .",
    "m.  biely , u.  schmid , and b.  weiss . .",
    "theoretical computer science , 412(40):5602  5630 , 2011 .",
    "d.  p. bertsekas and j.  n. tsitsiklis . .",
    "optimization and neural computation series .",
    "athena scientific , 1997 .",
    "b. charron - bost and a. schiper .",
    "the heard - of model : computing in distributed systems with benign faults .",
    "distributed computing , 22(1):4971 , april 2009 .",
    "s.  dasgupta , c.  papadimitriou , and u.  vazirani . .",
    "mcgraw - hill higher education , 2006 .",
    "d.  dolev , n.  a. lynch , s.  s. pinter , e.  w. stark , and w.  e. weihl .",
    "reaching approximate agreement in the presence of faults .",
    ", may 1986 .",
    "m. j. fischer , n. a. lynch , and m. merritt .",
    "easy impossibility proofs for distributed consensus problems .",
    "podc 85 , 1985 .",
    "j.  hajnal .",
    "weak ergodicity in non - homogeneous markov chains . in _ proceedings of the cambridge philosophical society _ , volume  54 , pages 233246 , 1958 .",
    "a.  jadbabaie , j. lin , and a. morse .",
    "coordination of groups of mobile autonomous agents using nearest neighbor rules .",
    "automatic control , ieee transactions on , 48(6):9881001 , june 2003 .",
    "d.  kempe ,  a.  dobra ,  and j. gehrke .",
    "gossip - based computation of aggregate information .",
    "ieee symposium on foundations of computer science , oct .",
    "l.  lamport , r.  shostak , and m.  pease .",
    "the byzantine generals problem . , 1982 .",
    "h. j. leblanc , h. zhang , x. koutsoukos , s. sundaram .",
    "resilient asymptotic consensus in robust networks . selected areas in communications , ieee journal on , vol.31 , no.4 , pp.766,781 , april 2013 .",
    "d. s. lun , m. mdard , r. koetter , and m. effros . on coding for reliable communication over packet networks . physical communication , 2008",
    "m. pajic , s. sundaram , j. le ny , g. j. pappas , and r. mangharam . closing the loop : a simple distributed method for control over wireless networks .",
    "international conference on information processing in sensor networks , 2012 .",
    "n. santoro , and p. widmayer .",
    "time is not a healer . in : proc .",
    "symposium on theoretical aspects of computer science , stacs 89 , 1989 .    n. santoro and p. widmayer .",
    "agreement in synchronous networks with ubiquitous faults .",
    "384 ( 2 - 3 ) ( 2007 ) 232249 .",
    "i. d. schizas , a. ribeiro , and g. b. giannakis .",
    "consensus in ad hoc wsns with noisy links- part i : distributed estimation of deterministic signals .",
    "ieee transactions on signal processing , 2008 .",
    "u. schmid , b. weiss , i. keidar . impossibility results and lower bounds for consensus under link failures .",
    "siam journal on computing 38 ( 5 ) 19121951 , 2009 ..    s. sundaram , s. revzen , and g. pappas",
    ". a control - theoretic approach to disseminating values and overcoming malicious links in wireless networks automatica , 2012 .",
    "s. sundaram and c. n. hadjicostis .",
    "distributed function calculation via linear iterative strategies in the presence of malicious agent .",
    "ieee transactions on automatic control , 2011 .",
    "l. tseng and n. h. vaidya .",
    "iterative approximate byzantine consensus under a generalized fault model . in international conference on distributed computing and networking ( icdcn ) , january 2013 .",
    "n.  h. vaidya , l.  tseng , and g.  liang .",
    "iterative approximate byzantine consensus in arbitrary directed graphs .",
    "podc 12 , 2012 .",
    "n.  h. vaidya .",
    "iterative byzantine vector consensus in incomplete graphs . in international conference on distributed computing and networking ( icdcn ) , january 2014 .",
    "j.  wolfowitz .",
    "products of indecomposable , aperiodic , stochastic matrices . in _ proceedings of the american mathematical society _ , volume  14 , pages 733737 , 1963 .",
    "the graph in figure [ f : eg ] satisfies _ condition p _ when @xmath276 .",
    "denote by @xmath74 the graph in figure [ f : eg ] .",
    "first observe that a clique of @xmath277 nodes satisfies _ condition p _ when @xmath50 .",
    "thus , for @xmath74 , we only need to consider the case when node @xmath52 is in either @xmath69 or @xmath70 ; otherwise , some node in @xmath69 ( or @xmath70 ) from the clique ( formed by nodes @xmath51 ) will have at least @xmath278 incoming links from @xmath70 ( or @xmath69 ) excluding link in @xmath66 .    without loss of generality ,",
    "consider the case when @xmath52 is in @xmath69 .",
    "consider the following cases :    * one of the nodes @xmath51 is in @xmath69 : say node @xmath279 is in @xmath69 besides @xmath52 .",
    "then node @xmath279 has at least @xmath62 incoming links from @xmath70 excluding link in @xmath66 .",
    "* two of the nodes @xmath51 are in @xmath69 : say nodes @xmath280 are in @xmath69 besides @xmath52 .",
    "then either node @xmath281 or @xmath282 has at least @xmath62 incoming links from @xmath70 excluding link in @xmath66 . *",
    "three of the nodes @xmath51 are in @xmath69 : say node @xmath283 is the only node in @xmath70 , since all the other nodes are in @xmath69 .",
    "then node @xmath283 has at least @xmath62 incoming links from @xmath69 excluding link in @xmath66 .    in every case , either @xmath284 or @xmath285 .",
    "thus , @xmath74 satisfies _ condition p_.    @xmath118",
    "we prove the following lemma in section [ s : sufficiency ] .            where @xmath209 $ ] is an @xmath210 row stochastic transition matrix with the following property :",
    "there exist a constant @xmath211 that depends only on graph @xmath55 , and @xmath204 such that for each @xmath146 , and for all @xmath212 ,      we prove the correctness of lemma [ lemma : tm2 cm ] by constructing @xmath287 $ ] for @xmath288 that satisfies the conditions in lemma [ lemma : tm2 cm ] .",
    "recall that @xmath201 $ ] denotes the set of faulty links in the @xmath34-th iteration .",
    "consider a node @xmath16 in iteration @xmath207 . in the _ update _",
    "step of algorithm 1 , recall that the smallest and the largest @xmath11 values are removed from @xmath42 $ ] by node @xmath16 .",
    "denote by @xmath289 and @xmath290 , respectively , the set of nodes and @xmath290 may be different for each iteration @xmath34 , for simplicity , we do not explicitly represent this dependence on @xmath34 in the notations @xmath289 and @xmath290 . ] from whom the smallest and the largest @xmath11 values",
    "were received by node @xmath16 in iteration @xmath34 .",
    "define sets @xmath291 and @xmath292 to be subsets of @xmath289 and @xmath290 that contain all the nodes from whom node @xmath16 receives the correct value in @xmath289 and @xmath290 , respectively .",
    "that is , @xmath293\\}$ ] and @xmath294\\}$ ] .",
    "observe that if @xmath291 ( @xmath292 ) is empty , then @xmath298 and @xmath299 ( @xmath300 ) , since there are at most @xmath11 faulty links and @xmath301 .",
    "therefore , the 3 cases above cover all the possible scenarios .",
    "* case i *     in case i , @xmath296 , and @xmath297 .",
    "let @xmath302 and @xmath303 be defined as shown below .",
    "recall that the incoming links from the nodes in @xmath291 and @xmath292 to node @xmath16 are all fault - free , and therefore , for any node @xmath304 , @xmath172 $ ] ( in the notation of algorithm 1 ) .",
    "that is , the value received by node @xmath16 from node @xmath17 is exactly the state at node @xmath17 in iteration @xmath305 .              * for @xmath168 - n_i^f$ ] : in this case , either the edge @xmath31 is fault - free , or @xmath226 . for each such @xmath17 , define @xmath241 = a_i$ ] . this is obtained by observing in ( [ e_t ] ) that the contribution of such a node @xmath17 to the new state @xmath33 $ ] is @xmath316 $ ] .",
    "+ the elements of @xmath287 $ ] defined here add up to @xmath317 - n_i^f|~a_i\\ ] ] * for @xmath318 : in this case , the edge @xmath31 is a fault - free . + for each @xmath319 , @xmath213 ~=~ a_i \\ , \\sum_{k \\in n_i^f } \\frac{s_k}{|{\\mathcal{s}}_g|}\\ ] ] and for each node @xmath320 , @xmath213 ~=~ a_i \\ , \\sum_{k \\in n_i^f } \\frac{l_k}{|{\\mathcal{l}}_g|}\\ ] ] to obtain these two expressions , we represent value @xmath321 sent via faulty link @xmath322 for each @xmath307 using ( [ eq : casei ] ) . recall that this node @xmath2 contributes @xmath323 to ( [ e_t ] ) .",
    "the above two expressions are then obtained by summing ( [ eq : casei ] ) over all the nodes in @xmath202 , and replacing this sum by equivalent contributions by nodes in @xmath291 and @xmath292 .",
    "+ the elements of @xmath287 $ ] defined here add up to @xmath324 * for @xmath325 : these nodes have not yet been considered above . for each such node @xmath17 , define @xmath241 = 0 $ ] .    with the above definition of @xmath287 $ ]",
    ", it should be easy to see that @xmath287\\,v[t-1]$ ] is , in fact , identical to @xmath33 $ ] obtained using ( [ e_t ] ) .",
    "thus , the above construction of @xmath287 $ ] results in the values sent via faulty links to ( [ e_t ] ) being replaced by an equivalent contribution from the nodes in @xmath292 and @xmath291 .",
    "first , we show that @xmath209 $ ] is row stochastic .",
    "observe that all the elements of @xmath287 $ ] are non - negative .",
    "also , all the elements of @xmath287 $ ] above add up to @xmath317 - n_i^f|~a_i + |n_i^f|~a_i = |n_i^*[t]|~a_i = 1\\ ] ] because @xmath326|$ ] as defined in algorithm 1 .",
    "thus , @xmath287 $ ] is a stochastic row vector .",
    "recall that from the above discussion , for @xmath327 , one of @xmath313 and @xmath314 must be @xmath315 . without loss of generality , assume that @xmath328 for all nodes @xmath329 . consequently , for each node @xmath319 , @xmath241 \\geq \\frac{a_i}{|{\\mathcal{s}}_g| } s_s \\geq \\frac{a_i}{2|{\\mathcal{s}}_g|}$ ] .",
    "also , for each node @xmath17 in @xmath164 - n_i^f$ ] , @xmath241 = a_i$ ] .",
    "thus , if @xmath239 is chosen such that @xmath330 and @xmath204 is defined to be @xmath292 , then the condition in the lemma holds for node @xmath16 .",
    "that is , for all @xmath212 ,            now , we consider the case when @xmath296 , and @xmath298 .",
    "that is , when each of @xmath289 and @xmath290 contains at least one node from which the node @xmath16 receives correct value , and node @xmath16 receives correct value(s ) from all the node(s ) in @xmath164 $ ] .",
    "in fact , the analysis of case ii is very similar to the analysis presented above in case i. we now discuss how the analysis of case i can be applied to case ii . rewrite ( [ e_t ] ) as follows :      in the above equation , @xmath331 is to be viewed as a `` virtual '' incoming neighbor of node @xmath16 , which has sent value @xmath332}{2}$ ] to node @xmath16 in iteration @xmath34 . with the above rewriting of state update",
    ", the value received by node @xmath16 from itself should be viewed as @xmath333}{2}$ ] instead of @xmath38 $ ] . with this transformation , case",
    "ii now becomes identical to case i , with virtual node @xmath331 being treated as an incoming neighbor of node @xmath16 .",
    "in essence , a part of node @xmath16 s contribution ( half , to be precise ) is now replaced by equivalent contribution by nodes in @xmath292 and @xmath291 .",
    "we now define elements @xmath241 $ ] of row @xmath287 $ ] :    * for @xmath226 : @xmath241 = \\frac{a_i}{2}$ ] .",
    "this is obtained by observing in ( [ e_t ] ) that node @xmath16 s contribution to the new state @xmath33 $ ] is @xmath334}{2}$ ] . * for @xmath168 - \\{i\\}$ ] : in this case , @xmath17 is a node from which node @xmath16 receives correct value . for each such @xmath17 ,",
    "define @xmath241 = a_i$ ] .",
    "this is obtained by observing in ( [ e_t ] ) that the contribution of node @xmath17 to the new state @xmath33 $ ] is @xmath335 $ ] . * for @xmath304 : in this case , @xmath17 is a node in @xmath289 or @xmath290 from which node @xmath16 receives correct value .",
    "+ for each @xmath319 , @xmath213 ~=~ \\frac{a_i}{2 } \\ , \\frac{s_z}{|{\\mathcal{s}}_g|}\\ ] ] and for each node @xmath320 ,",
    "@xmath213 ~=~ \\frac{a_i}{2 } \\ , \\frac{l_z}{|{\\mathcal{l}}_g|}\\ ] ] + where @xmath336 and @xmath337 are chosen such that @xmath338 and @xmath339}{2 } = \\frac{s_z}{2 } m_{{\\mathcal{s } } } + \\frac{l_z}{2 } m_{{\\mathcal{l}}}$ ] .",
    "note that such @xmath336 and @xmath337 exist because by definition of @xmath291 and @xmath292 , @xmath38 \\geq w_j,~\\forall j \\in s_g$ ] and @xmath38 \\leq w_j,~\\forall j \\in l_g$ ] .",
    "then the two expressions above are obtained by replacing the contribution of the virtual node @xmath331 by an equivalent contribution by the nodes in @xmath291 and @xmath292 , respectively . * for @xmath340 \\cup { \\mathcal{s}}_g \\cup { \\mathcal{l}}_g)$ ] : these nodes have not yet been considered above . for each such node @xmath17 , define @xmath241 = 0 $ ] .        by argument",
    "similar to that in _ case i _ , @xmath287 $ ] is row stochastic . without loss of generality , suppose that @xmath341 .",
    "then for each node @xmath319 , @xmath241 = \\frac{a_i}{2|{\\mathcal{s}}_g|}s_z \\geq \\frac{a_i}{4|{\\mathcal{s}}_g|}$ ] . also , for node @xmath17 in @xmath164-\\{i\\}$ ] , @xmath241 = a_i$ ] , and @xmath342 = \\frac{a_i}{2}$ ] .",
    "recall that by definition , @xmath343 .",
    "if @xmath239 is chosen such that            here , we consider the case when at most one of @xmath291 and @xmath292 is empty , and @xmath298 . without loss of generality ,",
    "suppose that @xmath289 contains only nodes whose outgoing links to node @xmath16 is faulty in iteration @xmath34 , i.e. , @xmath346\\}$ ] .",
    "since there are at most @xmath11 faulty links and @xmath347 , @xmath299 .",
    "that is , the value received from each node in @xmath290 by node @xmath16 is correct .          in case iii , recall that for any node @xmath17 in @xmath164 $ ] , @xmath241 = a_i$ ] .",
    "thus , if @xmath239 is chosen such that @xmath349 and @xmath204 is defined to be equal to @xmath290 , then the condition in the lemma [ lemma : tm2 cm ] holds for node @xmath16 .",
    "now , let us consider cases i - iii together . from the definition of @xmath174 in algorithm 1 , observe that @xmath350 ( because @xmath351 ) .",
    "let us define @xmath352 moreover , observe that @xmath353 and @xmath354 . then define @xmath239 as @xmath355 this definition satisfies constraints on @xmath239 in cases i through iii ( conditions ( [ eq : beta_casei ] ) , ( [ eq : beta - caseii ] ) and ( [ eq : beta - caseiii ] ) ) .",
    "thus , lemma [ lemma : tm2 cm ] holds for all three cases with this choice in ( [ eq : beta ] ) ."
  ],
  "abstract_text": [
    "<S> this paper explores the problem of reaching approximate consensus in synchronous point - to - point networks , where each directed link of the underlying communication graph represents a communication channel between a pair of nodes . </S>",
    "<S> we adopt the _ transient byzantine link _ failure model @xcite , where an omniscient adversary controls a subset of the _ directed _ communication links , but the nodes are assumed to be _ fault - free_.       recent work has addressed the problem of reaching approximate consensus in incomplete graphs with byzantine _ </S>",
    "<S> nodes _ using a _ restricted class _ of iterative algorithms that maintain only a small amount of memory across iterations @xcite . </S>",
    "<S> however , to the best of our knowledge , we are the first to consider approximate consensus in the presence of byzantine _ links_. we extend our past work that provided exact characterization of graphs in which the iterative approximate consensus problem in the presence of byzantine _ node _ failures is solvable @xcite . </S>",
    "<S> in particular , we prove a _ tight _ necessary and sufficient condition on the underlying communication graph for the existence of iterative approximate consensus algorithms under _ transient byzantine link _ model . the condition answers ( part of ) the open problem stated in @xcite . </S>"
  ]
}