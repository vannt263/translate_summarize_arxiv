{
  "article_text": [
    "the `` quantum fast fourier transformation '' ( qfft ) plays an important role in quantum algorithms .",
    "it is a unitary transformation that applies the discrete fourier transform to the amplitudes of a quantum register .",
    "the standard version has order @xmath0 and is applied to a quantum register consisting of @xmath1 qubits .",
    "it was found by coppersmith @xcite ( see also shor @xcite ) .",
    "the construction is essentially identical to the standard classical fast fourier transform ( fft ) . like the fft it generalises to orders which are a power of a small prime and more generally to smooth numbers , thus integers who have only small prime factors ( see cleve @xcite ) .",
    "these constructions implement the desired unitary transformation exactly .",
    "in contrast , so far no exact ( and efficient ) constructions for arbitrary orders have been known . for his `` abelian stabiliser problem ''",
    "kitaev @xcite gave an approximate implementation based on `` eigenvalue estimation '' .",
    "here we show how this eigenvalue estimation step can be made exact using `` amplitude amplification '' .",
    "amplitude amplification @xcite is a slight generalisation of grover s algorithm , allowing to apply the square root speed up to any heuristic algorithm .",
    "brassard and hyer @xcite used a variant of it to make simon s algorithm exact .",
    "finally we point out that an exact quantum fourier transform for large prime orders can be used to make shor s discrete logarithm algorithm exact .",
    "the quantum fourier transform of order ( or `` modulus '' ) @xmath4 acts on `` computational '' basis states @xmath5 as follows : @xmath6 for arbitrary , in particular non - smooth n , kitaev @xcite proposes to do this in two steps ( second part of section 5 in @xcite , see also the review by jozsa @xcite ) : @xmath7 where , as usual , registers that `` appear out of nowhere '' are understood to have been initialised in the standard state @xmath8 . similarly in the second step , one of the registers is reset to this state and can thus again be left away .",
    "the first step constructs the fourier state @xmath9 for a given @xmath10 .",
    "this can be done exactly by first obtaining the `` uniform amplitude '' superposition @xmath11 of the first @xmath3 basis states of a register and then `` rephasing '' it : @xmath12 as pointed out by kitaev , @xmath11 can be obtained from @xmath8 by a sequence of so(2 ) rotations applied to each qubit in order from high to low significance , whereby the rotation angle has to be controlled by the previously touched qubits .",
    "the rephasing then simply consists of a rephasing on each qubit , proportional to @xmath10 and the place value of the qubit .",
    "the second step of kitaev s construction is the reverse of @xmath13 this is done through a technique known as `` eigenvalue estimation '' ( see also the article by cleve et al .",
    "@xcite ) , which details how to find the eigenvalue of an unknown eigenstate of some unitary @xmath14 . we will describe this in more detail later .",
    "here we only need to note that although this operation is not exact , it leaves the eigenstate @xmath9 unchanged .",
    "thus it does : @xmath15 where on the right hand side the superposition should be dominated by the term with @xmath16 , such that a measurement would yield @xmath10 with good probability .",
    "we also included some ( unwanted ) `` garbage '' @xmath17 which may be produced along with the eigenvalue .",
    "we now use `` amplitude amplification '' @xcite to eliminate all but the desired term @xmath18 .",
    "we give here a quick review of this generalisation of grover s algorithm .",
    "we are given a unitary operator @xmath19 which , when applied to the initial state @xmath8 , gives an output state which has some component in a `` good '' subspace .",
    "thus the probability @xmath20 is not too small , where @xmath21 is the projector onto the good subspace .",
    "the amplitude of the good component can be increased through the following procedure @xmath22^t   a { { |0\\rangle}}\\ ] ] where the sequence of operations in the brackets is repeated @xmath23 times , depending on the `` success probability '' of the `` algorithm '' @xmath19 alone . as in grover",
    "s algorithm , the fastest increase is achieved when both phases are chosen @xmath24",
    ". the algorithm can be analysed by noting that the state always remains in a subspace spanned by the state we are seeking @xmath25 and by @xmath26 .",
    "usually an integer number of iterations will not lead exactly to the desired state and so we need to chose different ( non - optimal ) phases , either in all steps or only in the last one or two . in our case",
    "we will leave the phases at their standard settings , but will modify @xmath19 so that its success probability is reduced to 1/4 where a single iteration leads exactly to the desired state .",
    "the operator @xmath19 will be given by eq .",
    "[ pest ] , where the state @xmath9 will have to be added as a `` spectator '' that is not changed .",
    "apart from the `` heuristic '' algorithm @xmath19 , amplitude amplification requires a way to `` recognise '' the good states .",
    "more precisely , we need a way to apply the phase @xmath27 to the good subspace and leave its orthogonal complement unchanged .",
    "so how can we check whether a number @xmath28 is the right eigenvalue of @xmath9 , thus whether @xmath16 ?",
    "this can be done because the eigenstate @xmath9 is still available exactly .",
    "thus given a state of the form @xmath29 , we can check the second register against the first one . to do this",
    "we apply the reverse of the steps in eq .",
    "[ prep ] to these two registers , thus : @xmath30 where in the second step we only act on the second register .",
    "the state @xmath11 is mapped back to @xmath8 , while for @xmath31 we get some state @xmath32 orthogonal to @xmath8 .",
    "we can now apply the phase @xmath27 to the @xmath8 state and undo the previous operations .",
    "one obstacle to using amplitude amplification to make algorithms exact is that the success probability of the `` heuristic '' algorithm @xmath19 must be known . but",
    "this probability may depend on the ( unknown ) instance of the problem . in our case",
    "the success probability of eigenvalue estimation on @xmath9 indeed does depend on @xmath10 .",
    "we can fix this problem by modifying @xmath19 such that the new success probability will become instance independent and equal to the average over all instances for the original @xmath19 . to do this uniformisation we pick an integer @xmath33 uniformly at random from @xmath34 and replace @xmath9 with @xmath35 , which is just a rephasing .",
    "we keep a record of @xmath33 and subtract it again from the result of eigenvalue estimation . to do this with a unitary @xmath19 we will need an additional register for @xmath33 , but this is no problem , as we have already included the possibility that eigenvalue estimation ( eq . [ pest ] ) also generates some unwanted garbage @xmath17 .",
    "so now exact amplitude amplification will allow us to do @xmath36 to get rid of the `` garbage '' we can do the usual trick of copying the wanted result @xmath10 into an additional `` save '' register and then undoing the previous steps .",
    "in total this will lead to six applications of @xmath19 for an exact qfft .    in summary , the construction of an exact qfft relies on making eigenvalue estimation ( on fourier states @xmath9 ) exact .",
    "the essential observations are that eigenvalue estimation leaves the eigenstate @xmath9 exactly unchanged and so it can be used for the checking stage of amplitude amplification .",
    "furthermore we used that the success probability of estimating @xmath10 from @xmath9 can rather easily be `` uniformised '' across all @xmath37 .",
    "an exact algorithm for the qfft leads in a straightforward manner to an exact algorithm for the discrete logarithm algorithm of the same order .",
    "this was also observed for finite fields of prime order by brassard and hyer @xcite ( theorem 12 ) . for smooth orders ( only small prime factors ) the problem",
    "can easily be solved classically . here",
    "we give a quick review for the case when the order is a large prime ( see also @xcite , section 2.2.3 ) .    in a discrete logarithm problem",
    "we are given an element @xmath38 which generates a cyclic group of some finite order , here a prime .",
    "thus @xmath39 .",
    "then another element @xmath40 of the group is given and we want to know which power of @xmath38 it is ; that is , the integer @xmath41 for which @xmath42 . this is also written as @xmath43 . in the quantum solution ( see shor @xcite ) , we prepare two registers , each in a uniform amplitude superposition of @xmath3 basis states : @xmath44 then we compute the function @xmath45 in an additional register and measure it .",
    "this will leave the two registers in a superposition of the form @xmath46 where all arithmetic operations are understood to be modulo @xmath3 , @xmath47 is random and @xmath48 runs over @xmath49 . by",
    "fourier transforming each register with a qfft@xmath2 we get a similar state but without the offset @xmath47 , namely an equally weighted superposition of all states of the form @xmath50 with @xmath51 . a measurement will now allow to compute @xmath41 in all cases except when @xmath52 .",
    "thus we have the known and instance independent success probability of @xmath53 , which allows to easily make the algorithm exact by using ( exact ) amplitude amplification .",
    "actually one can directly make the success probability of the dlog algorithm instance independent .",
    "thus one uses the usual algorithm with a qfft@xmath54 , but replaces @xmath40 with @xmath55 where @xmath33 is again chosen uniformly at random from @xmath49 .",
    "we have noted this approach a while ago , but were not able to show that the ( now averaged ) success probability can be computed efficiently , thus it is not clear whether the circuit for a given @xmath3 can be computed efficiently .",
    "in our case we want to estimate the eigenvalue of @xmath9 under the ( unitary ) cyclic shift operator @xmath14 which acts on computational basis states as : @xmath56 . for eigenvalue estimation",
    "we need to do large powers of @xmath14 , which in this case is easy .",
    "namely we first prepare an auxiliary @xmath1-qubit register in a uniform amplitude superposition of all its @xmath57 basis states .",
    "( we will choose @xmath4 to be larger than @xmath3 , see below . )",
    "then we do : @xmath58 where we used that the eigenvalue of @xmath9 under @xmath14 is @xmath59 .",
    "note that the operation we have to do is simply a modular addition on computational basis states , thus @xmath60 .",
    "after a fourier transform of size @xmath0 on the auxiliary register , the probability of measuring @xmath48 would be given by : @xmath61    we illustrate the function @xmath62 with @xmath63 in figure [ sinc ] .",
    "it is peaked around @xmath64 so that after measuring some @xmath48 we would guess for the number we want to find @xmath65 .",
    "the choice with the highest probability of obtaining the correct @xmath10 would be to simply round @xmath66 to the closest integer . partially to simplify notation ,",
    "here we round up to the next integer , thus our guess is @xmath67 .",
    "( for us the loss of some success probability does not matter , at least not as long as it is at least 1/4 . )    because we have @xmath68 , it is clear that if we measure @xmath69 we will calculate the correct @xmath10 . for a given @xmath10 , smaller @xmath48 may also lead to the correct @xmath10 ,",
    "but here we would like to eliminate this contribution to the success probability , as it will lead to a simpler expression . given a @xmath48 it is possible to eliminate these cases by also checking @xmath70 and `` throwing away '' @xmath48 s which do not satisfy this .",
    "( note that in order to obtain an algorithm @xmath19 with a certain success probability , we can think as if this were a non - reversible algorithm including measurements and classical computations .",
    "such an algorithm can then easily be turned into a unitary @xmath19 which , besides the intended answer , also produces some `` garbage '' . )",
    "so now the success probability @xmath71 for correctly getting @xmath10 from @xmath9 is : @xmath72 to get the instance independent success probability of the uniformised algorithm , we average this over all @xmath37 : @xmath73 where we have used that @xmath4 and @xmath3 are coprime and so for each @xmath10 there is exactly one @xmath74 .      for large @xmath3",
    "this sum of course is well approximated by the corresponding integral , which ( for large @xmath4 ) is approximately 0.4514 .",
    "here we show that for each @xmath3 and @xmath4 , the success probability can be approximated efficiently in the sense that the computation time is polynomial in the number of ( e.g. decimal ) digits we want to compute .",
    "the following method achieves this in a simple way , although it is probably not the best one could do .",
    "note that @xmath75 can be expanded in a ( fast converging ) power series in @xmath10 and @xmath76 .",
    "( to compute @xmath77 to @xmath78 digits we will only use polynomially many terms in @xmath78 . )",
    "now each power @xmath79 of @xmath80 can be summed separately , giving : @xmath81 where for each power @xmath82 the coefficients @xmath83 can be calculated ( in various ways ) in time polynomial in @xmath82 .",
    "( a straightforward way is to simply solve the equations resulting from @xmath84 for the @xmath83 .",
    "e.g. for @xmath85 we get the familiar formula @xmath86 . )",
    "once we have calculated the success probability @xmath87 ( to arbitrary precision ) for a given @xmath3 , we can use this to modify the algorithm @xmath19 so that it will succeed exactly with probability 1/4 , so that just one iteration of amplitude amplification leads to an exact algorithm .",
    "one way to do this is to add a qubit prepared in state @xmath88 with @xmath89 and additionally require for success that this qubit be in state @xmath90",
    ". the preparation of this qubit will now require the one `` strange '' gate in our algorithm , although its rotation angle @xmath38 can be computed efficiently in the above sense .",
    "the construction of the exact qfft@xmath91 easily generalises to arbitrary orders @xmath92 . above",
    "we only needed the primality of the order for ( efficiently ) computing the success probability .",
    "and there we only needed that @xmath57 and @xmath92 should be coprime .",
    "things can easily be adjusted for the case when @xmath92 is even .",
    "either we can modify ( a bit ) the calculation of the success probability , or we can consider the qfft@xmath91 as a tensor product of a qfft with odd order and a standard one with order a power of 2 .",
    "similarly , of course , we can generalise to qfft s over finite abelian groups , not just cyclic ones .",
    "also the discrete logarithm algorithm can be generalised to arbitrary orders @xmath92 .",
    "given the exact qfft@xmath91 , the algorithm will be successful whenever the first number in the measured pair @xmath93 is coprime to @xmath92 .",
    "so the success probability is @xmath94 where @xmath95 is the euler totient function . if we know the factorisation of @xmath92 , this is easily calculated and so amplitude amplification can be used to make the algorithm exact .      in the following",
    "we give a more involved solution for the case when the factorisation of the order @xmath92 is not known .",
    "it consists of @xmath96 runs of ( variants of ) the dlog quantum circuit .",
    "what is important is , that these variants still only use the special gates calculated ( efficiently ) at the beginning from @xmath92 .    in the first run it is enough ,",
    "as before , to use amplitude amplification only to get rid of the case @xmath52 .",
    "we now measure a pair @xmath93 .",
    "if @xmath10 is coprime to @xmath92 we can directly calculate @xmath41 and are done .",
    "if @xmath97 , we still get some information about @xmath41 , namely @xmath98 , and of course the factor @xmath78 of @xmath92 .",
    "now we have @xmath99 , where , in a standard way , @xmath100 can be found by solving the dlog problem with @xmath101 and @xmath102 .",
    "this dlog problem has smaller order , as @xmath103 , but we want to reuse the original quantum circuit for order @xmath92 .",
    "if in this original circuit we simply replace @xmath104 with @xmath105 , we get ( after the two qfft s ) : @xmath106 ( note that this is essentially the same as @xmath107 . )",
    "we want to avoid only the case @xmath108 , but in order not to introduce new `` special '' gates , we prefer to eliminate 3/4 of all states , such that one step of standard amplitude amplification will lead to an exact solution .",
    "we can e.g. only retain the last quarter of the values @xmath109 , although , if d is not divisible by 4 , we will have to `` partially tag '' some states .",
    "( this can be done by appending a qubit in state @xmath110 with @xmath111 or @xmath112 . )    now , like in the first step , we will either directly get @xmath100 , or will gain partial information on @xmath100 , together with a factor of @xmath78 .",
    "this can be iterated ( at most @xmath96 times ) till the order of the dlog problem is small .",
    "note that in our construction we have taken care not to introduce new `` special '' gates during the computation .",
    "this means that really the @xmath96 quantum runs can be put together into one quantum circuit whose gates can be computed from @xmath92 alone ( without knowing its factorisation ) .",
    "let us also note that it is not clear how to make shor s integer factorisation algorithm exact with the techniques used here .",
    "thus this is a challenge that remains .",
    "we note that mosca @xcite shows how to make factorisation exact in a slightly generalised model of exact quantum computation .",
    "it is interesting to note that after kitaev @xcite a more efficient and probably also more natural way to approximate the qfft for arbitrary orders has been given by hallgren and hales @xcite .",
    "in particular their construction uses fewer qubits , but it seems not to lend itself to the techniques used here to make it exact .",
    "the two authors have independently found the results described here , although ch.z . acknowledges inspiration by related work of m.m . on using amplitude amplification to make algorithms exact .",
    "ch.z . would like to thank professor david jackson of our department for discussions on summing the m@xmath113 powers of the first @xmath1 integers .",
    "he is supported by cse ( communications security establishment ) and mitacs ( mathematics of information technology and complex systems ) , both from canada .",
    "thanks richard cleve , lisa hales , and john watrous for discussions at msri that prompted him to think about solving the qfft exactly in this context .",
    "m.m . is the canada research chair in quantum computation and is supported by nserc , mitacs , cfi , ordcf , and prea .",
    "g. brassard , p. hyer and a. tapp , _ quantum counting _ ,",
    "icalp98 , ( also quant - ph/9805082 ) g. brassard and p. hyer , _ an exact quantum polynomial - time algorithm for simon s problem _ , istcs97 , ( also quant - ph/9704027 ) r. cleve , a. ekert , c. macchiavello and m. mosca , _ quantum algorithms revisited _ , proc .",
    "lond . a ( 1998 ) * 454 * , pp .",
    "339 - 354 , ( also quant - ph/9708016 )      d. coppersmith , ibm research report rc 19642 ( 1994 ) ( also quant - ph/0201067 ) r. b. griffiths and c. niu , _ semiclassical fourier transform for quantum computation _",
    "* 76 * ( 1996 ) pp.3228 - 3231 ( also quant - ph/9511007 )            p. shor , _",
    "algorithms for quantum computation : discrete logarithms and factoring _ , proc .",
    "35th annual symposium on foundations of computer science .",
    "ieee press , pp 124 - 134 , nov .",
    "1994 , ( also quant - ph/9508027 )"
  ],
  "abstract_text": [
    "<S> we show how the quantum fast fourier transform ( qfft ) can be made exact for arbitrary orders ( first for large primes ) . for most quantum algorithms </S>",
    "<S> only the quantum fourier transform of order @xmath0 is needed , and this can be done exactly . </S>",
    "<S> kitaev @xcite showed how to approximate the fourier transform for any order . here </S>",
    "<S> we show how his construction can be made exact by using the technique known as `` amplitude amplification '' . </S>",
    "<S> although unlikely to be of any practical use , this construction e.g. allows to make shor s discrete logarithm quantum algorithm exact . </S>",
    "<S> thus we have the first example of an exact non black box fast quantum algorithm , thereby giving more evidence that `` quantum '' need not be probabilistic .    </S>",
    "<S> we also show that in a certain sense the family of circuits for the exact qfft is uniform . </S>",
    "<S> namely the parameters of the gates can be calculated efficiently . </S>"
  ]
}