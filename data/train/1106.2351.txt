{
  "article_text": [
    "a trapezoid diagram consists of two horizontal lines and a set of trapezoids with corner points lying on these two lines .",
    "a graph @xmath3 is a trapezoid graph when a trapezoid diagram exists with trapezoid set @xmath4 , such that each vertex @xmath5 corresponds to a trapezoid @xmath6 and an edge exists @xmath7 if and only if trapezoids @xmath6 and @xmath8 intersect within the trapezoid diagram .",
    "a trapezoid @xmath6 between these lines has four corner points @xmath9 , @xmath10 , @xmath11 and @xmath12  which represent the upper left , upper right , lower left and lower right corner points of trapezoid  @xmath13 , respectively .",
    "no two trapezoids share a common endpoint .",
    "ma and spinrad @xcite showed that trapezoid graphs can be recognized in @xmath14 time , while mertzios and corneil @xcite designed structural trapezoid recognition algorithm based on the vertex splitting method in @xmath15 time , which is easier for implementation . here",
    "@xmath2 stands for the number of vertices and @xmath16 for the number of edges .",
    "trapezoid graphs are perfect , subclass of cocomparability graphs and properly contain both interval graphs and permutation graphs  @xcite .",
    "trapezoid graphs were first investigated by corneil and kamula @xcite .",
    "these graphs and their generalizations were applied in various fields , including modeling channel routing problems in vlsi design @xcite and identifying the optimal chain of non - overlapping fragments in bioinformatics @xcite .",
    "many common graph problems , such as minimum connected dominating sets @xcite , all - pair shortest paths @xcite , maximum weighted cliques @xcite , all cut vertices @xcite , chromatic number and clique cover @xcite , all hinge vertices @xcite , minimum vertex covers @xcite in trapezoid graphs , can be solved in polynomial time . for other related problems",
    "see @xcite .",
    "let @xmath3 be a simple undirected graph with @xmath17 and @xmath18 .",
    "a subset @xmath19 is called a vertex cover ( vc for short ) of @xmath20 if and only if every edge in @xmath21 has at least one endpoint in @xmath22 .",
    "a vertex cover @xmath22 is called a minimal vertex cover if and only if no proper subset of c is also a vertex cover .",
    "the size of a vertex cover is the number of vertices that it contains .",
    "a vertex cover with minimum size is called a minimum vertex cover .",
    "notably , a minimum vc is always a minimal vc , but a minimal vc may not be a minimum vc .    given a graph @xmath20 and a fixed parameter @xmath23 , determining whether @xmath20 has a vertex cover of at most @xmath23 vertices is one of the best - known np complete problems @xcite .",
    "many recent studies have focused on developing faster algorithms for the vc problem in special classes of graphs .",
    "the number of vertex covers in a graph is important , particularly because this characteristic typically arises in problems related to network reliability @xcite .",
    "okamoto et al .",
    "@xcite proposed @xmath24 time algorithms for counting the numbers of independent sets and maximum independent sets in a chordal graph .",
    "lin et al .",
    "@xcite considered interval graphs and obtained efficient linear @xmath25 algorithms for counting the number of vcs , minimal vcs , minimum vcs , and maximum minimal vcs in an interval graph .",
    "recently , lin and chen @xcite presented @xmath0 algorithms for the same vertex cover properties in a trapezoid graph .    in graph theory ,",
    "the notions of vertex cover and independent set are dual to each other .",
    "a subset @xmath26 is called an independent set of @xmath20 if and only if every edge in @xmath21 is incident on no more than one vertex in @xmath27 .",
    "[ thm - ind ] a set @xmath22 is a minimal ( minimum ) vertex cover of @xmath20 if and only if @xmath28 is an maximal ( maximum ) independent set of @xmath20 .",
    "a matching in a graph is a set of edges in which no two edges are adjacent .",
    "a single edge in a graph is obviously a matching .",
    "a maximum matching is a matching with the maximum cardinality and the cardinality of the maximum matching is called a matching number .",
    "currently , the best known algorithm for the constructing maximum matching in general graphs is edmonds algorithm @xcite , which is based on the alternating paths , blossom and shrinking and runs in time @xmath29 .",
    "for special classes of graphs , such as interval , chordal and permutation graphs , more efficient algorithms were designed ( see @xcite and references therein ) .",
    "ghosh and pal @xcite presented an efficient algorithm to find the maximum matching in trapezoid graphs , which turns out to be not correct .",
    "the rest of the paper is organized as follows . in section 2",
    "we introduce the binary indexed tree data structure . in section 3",
    "we design @xmath1 time dynamic programming algorithm for calculating the size of the minimum vertex cover , the number of vertex covers and the number of minimum vertex covers , improving the algorithms from @xcite . in section 4 we present family of counterexamples for @xmath0 algorithm from @xcite for finding the maximum matching in trapezoid graphs .",
    "the binary indexed tree ( bit ) is an efficient data structure introduced by fenwick @xcite for maintaining the cumulative frequencies .",
    "the bit was first used to support dynamic arithmetic data compression and algorithm coding .",
    "let @xmath30 be an array of @xmath2 elements .",
    "the binary indexed tree supports the following basic operations :    1 .   for given value @xmath31 and index @xmath13 , add @xmath31 to the element @xmath32 , @xmath33 ; 2 .   for given interval",
    "@xmath34 $ ] , find the sum of values @xmath35 , @xmath33 .",
    "naive implementation of these operations have complexities @xmath36 and @xmath37 , respectively .",
    "we can achieve better complexity , if we speed up the second operation which will also affect the first operation .",
    "another approach is to maintain all partial sums from @xmath38 to @xmath39 for @xmath40 . this way the operations have complexities @xmath25 and @xmath36 , respectively .",
    "the main idea of binary indexed tree structure is that sum of elements from the segment @xmath34 $ ] can be represented as sum of appropriate set of subsegments .",
    "the bit structure is based on decomposition of the cumulative sums into segments and the operations to access this data structure are based on the binary representation of the index . this way the time complexity for both operations will be the same @xmath41 .",
    "we want to construct these subsegments such that each element is contained in at most @xmath42 subsegments , which means that we have to change the partial sums of at most @xmath42 subsegments for the first procedure .",
    "on the other hand , we want to construct these subsegments such that for every @xmath33 the subsegment @xmath34 $ ] is divided in at most @xmath42 subsegments .",
    "it follows that these subsegments can be @xmath43 $ ] , where @xmath44 is the position of the last digit @xmath45 ( from left to right ) in the binary representation of the index @xmath13 .",
    "we store the sums of subsegments in the array @xmath46 ( see algorithm 1 and algorithm 2 ) , and the element @xmath47 represents the sum of elements from index @xmath48 to @xmath13 .",
    "the structure is space - efficient in the sense that it needs the same amount of storage as just a simple array of @xmath2 elements . instead of sum",
    ", one can use any distributive function ( such as maximum , minimum , product ) .",
    "we have the following    calculating the sum of the elements from @xmath49 to @xmath32 , @xmath33 , and updating the element @xmath32 in the binary indexed tree is performed in @xmath50 time .",
    "the fundamental operation involves calculating a new index by stripping the least significant 1 from the old index , and repeating this operation until the index is zero .",
    "for example , to read the cumulative sum @xmath51 , we form a sum @xmath52 an illustrative example is presented in table 1 .",
    "l|llllllllllllllll    @xmath13 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 + @xmath30 & 1 & 0 & 2 & 1 & 1 & 3 & 0 & 4 & 2 & 5 & 2 & 2 & 3 & 1 & 0 & 2 + @xmath46 & 1 & 1 & 2 & 4 & 1 & 4 & 0 & 12 & 2 & 7 & 2 & 11 & 3 & 4 & 0 & 29 + cumulative sums & 1 & 1 & 3 & 4 & 5 & 8 & 8 & 12 & 14 & 19 & 21 & 23 & 26 & 27 & 27 & 29 +    using the fast bitwise and operator , we can calculate the largest power of 2 dividing the integer @xmath2 simply as @xmath53 .",
    "let @xmath56 denote the set of trapezoids in the trapezoid graph @xmath3 . for simplicity",
    ", the trapezoid in @xmath4 that corresponds to vertex @xmath13 in @xmath57 is called trapezoid @xmath6 . without loss of generality ,",
    "the points on each horizontal line of the trapezoid diagram are labeled with distinct integers between @xmath45 and @xmath58 .    for simplicity and easier implementation",
    ", we will consider the maximum independent sets ( according to theorem [ thm - ind ] ) . at the beginning , we add two dummy trapezoids @xmath59 and @xmath60 to @xmath4 , where @xmath61 for the vertex 0 and @xmath62 for the vertex @xmath60 .",
    "trapezoid @xmath13 lies entirely to the left of trapezoid @xmath63 , denoted by @xmath64 , if @xmath65 and @xmath66 .",
    "it follows that @xmath67 is a partial order over the trapezoid set @xmath4 and @xmath68 is a strictly partially ordered set .    in order to get @xmath1 algorithms",
    ", we will use binary indexed tree data structure for sum and maximum functions .      arrange all trapezoids by the upper left corner @xmath69 .",
    "let @xmath70 denote the size of the maximum independent set of @xmath71 that contain trapezoid @xmath72 .",
    "for the starting value , we set @xmath73 .",
    "the following recurrent relation holds @xmath74 this produces a simple @xmath0 dynamic programming algorithm ( similar to @xcite ) .    to speed up the above algorithm , we will store the values from @xmath75 in the binary indexed tree @xmath76 for maintaining the partial maximums .",
    "first initialize each element of @xmath76 with @xmath77 .",
    "we need an additional array @xmath78 , such that @xmath79 contains the index of the trapezoid with left or right coordinate equal to @xmath63 .",
    "we are going to traverse the coordinates from @xmath59 to @xmath80 , and let @xmath63 be the current coordinate . in order to detect which already processed trapezoids are to the left of the current trapezoid @xmath6",
    ", we calculate the value @xmath70 when the current coordinate is the left upper coordinate of @xmath69 and insert it in the binary indexed tree when it is the right upper coordinate @xmath81 .",
    "then we have two cases :    1 .",
    "coordinate @xmath63 is the upper left coordinate of the trapezoid @xmath6 .",
    "we only need to consider the trapezoids that have lower right coordinate smaller than @xmath82 .",
    "as explained , these trapezoids have their corresponding values stored in the segment @xmath83 $ ] in the binary indexed tree and therefore we can calculate @xmath70 based on the maximum values among @xmath84 .",
    "2 .   coordinate @xmath63 is the upper right coordinate of the trapezoid @xmath6 . in this case , the value @xmath70 is already calculated and we put this value in the binary indexed tree at the position @xmath85 .",
    "the final solution is @xmath86 .",
    "the pseudo - code is presented in algorithm 3 .",
    "initialize binary indexed tree for maximum @xmath76 @xmath87 - 1 $ ]    the set of all vcs and the number of vcs of @xmath20 are denoted by @xmath88 and @xmath89 , respectively .",
    "let @xmath90 be the set of vertices adjacent to @xmath91 in the graph @xmath20 . in @xcite",
    "the authors proved the following result .",
    "[ le-1 ] for a graph @xmath20 and arbitrary vertex @xmath92 , it holds @xmath93    for counting the total number of independent sets , we can use the same method as above .",
    "the only difference is that we will have sum instead of maximum function in the binary indexed tree .",
    "let @xmath94 denote the number of independent sets of trapezoids @xmath95 that contain trapezoid @xmath72 .",
    "according to lemma [ le-1 ] the following recurrent relation holds @xmath96 the total number of independent sets is simply @xmath97 and time complexity is the same @xmath1 .      for counting the number of maximum independent sets , we will need one additional array @xmath98 , such that @xmath99 represents the number of maximum independent sets among trapezoids @xmath100 such that @xmath6 belongs to the independent set .",
    "after running the algorithm for calculating the array @xmath75 , for each @xmath101 we need to sum the number of independent sets of all indices @xmath63 , such that @xmath102 and @xmath103 in order to get the number of independent sets with maximum cardinality .",
    "the pseudo - code of the algorithm for counting the number of maximum independent sets from @xcite is presented in algorithm 4 .",
    "@xmath104 = 1 $ ] @xmath105 - 1 $ ]    we will use again binary indexed trees for designing @xmath1 algorithm .",
    "the main problem is how to manipulate the partial sums .",
    "namely , for each trapezoid @xmath72 , we need to sum the values @xmath106 of those trapezoids @xmath107 which are entirely on the left of @xmath72 with additional condition @xmath103 .",
    "this can be done by considering all pairs @xmath108 of two neighboring values @xmath109 . using two additional arrays for the coordinates and trapezoid indices",
    ", we can traverse trapezoids @xmath6 from left to right , such that @xmath110 or @xmath111 .",
    "first , for each @xmath112 one needs to carefully preprocess all trapezoids and store the indices and coordinates of all trapezoids @xmath6 with @xmath110 in order to keep the memory limit @xmath25 .",
    "therefore , all trapezoids will be stored in the dynamic array of arrays @xmath113 , such that @xmath114 contains all trapezoids @xmath6 with @xmath110 .",
    "then we fill the binary indexed tree with the values for trapezoids with @xmath110 , and calculate the value @xmath99 for trapezoids with @xmath115 , as before . instead of resetting the binary indexed tree for each @xmath23 , we can again traverse the trapezoids with @xmath110 and update the values of bit to @xmath59 .",
    "since every trapezoid will be added and removed exactly once from the binary indexed tree data structure , the total time complexity is @xmath1 .",
    "this reusing of the data structure is novel approach to the best of our knowledge and makes this problem very interesting .",
    "we conclude this section by summing the results in the following theorem .",
    "the proposed algorithms calculate the size and the number of maximum independent sets , as well as the total number of independent sets in time @xmath1 of trapezoid graph @xmath20 with @xmath2 vertices .",
    "one can easily extend this algorithm for efficient construction the independence polynomial of a trapezoid graph @xmath116 where @xmath117 is the number of independent sets of cardinality @xmath23 and @xmath118 is the independence number of @xmath20 .",
    "ghosh and pal @xcite presented an efficient algorithm for finding the maximum matching in trapezoid graphs .",
    "the proposed algorithm takes @xmath14 time and @xmath24 space .",
    "they defined the right spread @xmath119 of a trapezoid @xmath6 as the maximum @xmath120 .",
    "let @xmath121 be the set of edges which form a matching of the graph @xmath20 .",
    "deletion of a vertex from the graph means deletion of that vertex and its adjacent edges .",
    "the algorithm is designed as follows .",
    "calculate the right spread @xmath122 and arrange all trapezoids by @xmath123 in ascending order for @xmath33 in linear time @xmath25 .",
    "select the trapezoid @xmath13 with the minimum value of the right spread @xmath122 .",
    "after that , select the second minimum value @xmath124 . if trapezoids @xmath6 and @xmath8 are adjacent , then put the edge @xmath125 in the maximum matching @xmath121 , remove the vertices @xmath13 and @xmath63 from the graph @xmath20 and mark the corresponding elements of the array @xmath123 . if @xmath126 then continue selecting the next minimum elements @xmath127 from the array @xmath123 until the trapezoids @xmath13 and @xmath128 are adjacent . in that case",
    "remove the vertices @xmath13 and @xmath128 , put the edge @xmath129 in the maximum matching @xmath121 and mark the corresponding elements of @xmath123 ; otherwise remove the trapezoid @xmath13 from the graph @xmath20 since it can not be matched .",
    "continue this procedure as long as @xmath130 .",
    "since for each trapezoid we potentially traverse all trapezoids with larger values @xmath122 , the time complexity of the proposed algorithm is @xmath0 .",
    "obviously , the algorithm works for any set of @xmath131 trapezoids . in the configuration on figure 2",
    ", there are four trapezoids and only trapezoids @xmath132 and @xmath133 are not adjacent .",
    "the trapezoids are ordered such that @xmath134 . by proposed algorithm in @xcite",
    ", we will match the trapezoids @xmath45 and @xmath135 and get the maximal matching of cardinality 1 .",
    "but obviously , the size of the maximum matching is 2 by pairing the trapezoids @xmath136 and @xmath137 .",
    "therefore , this algorithm is not correct and gives only an approximation for the maximum matching .",
    "one can easily construct a family of counterexamples based on this minimal example by adding trapezoids to the left and right ."
  ],
  "abstract_text": [
    "<S> the intersection graph of a collection of trapezoids with corner points lying on two parallel lines is called a trapezoid graph . using binary indexed tree data structure , we improve algorithms for calculating the size and the number of minimum vertex covers ( or independent sets ) , as well as the total number of vertex covers , and reduce the time complexity from @xmath0 to @xmath1 , where @xmath2 is the number of trapezoids . furthermore , we present the family of counterexamples for recently proposed algorithm with time complexity @xmath0 for calculating the maximum cardinality matching in trapezoid graphs </S>",
    "<S> .    * keywords : * trapezoid graphs ; vertex cover ; matching ; algorithms ; data structures ; binary indexed tree .    * </S>",
    "<S> ams classifications : * 05c85 , 68r10 . </S>"
  ]
}