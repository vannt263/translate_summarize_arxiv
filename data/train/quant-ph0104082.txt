{
  "article_text": [
    "recently chen and diao @xcite presented a quantum algorithm for searching an unsorted database capable of finding , with certainty , a single target item in an @xmath1-item database after @xmath6 iterations of certain unitary operations .",
    "( @xmath7 denotes the smallest integer greater than or equal to @xmath8 . ) grassl @xcite and tu and long @xcite have given a recursive implementation of these unitary operations , and have pointed out that , with this implementation , the number of oracle calls required for the @xmath9 iteration increases exponentially with @xmath10 .    in this paper",
    "i present a modification of the algorithm of @xcite for searching an unsorted database of @xmath1 items for @xmath11 target items , provided that the number of targets @xmath0 is known in advance . in section 2 below i discuss the case of @xmath0 equal to a power of four ; in this case the algorithm will find one of the target items with unit probability . in section 3",
    "i discuss the case of @xmath0 not equal to a power of four ; in this case the algorithm will find one of the target items with probability of at least one - half .",
    "the number of oracle calls required using the recursive implementation is given in section 4 .",
    "the notation and terminology follow , in general , those of @xcite and @xcite .",
    "denote the @xmath1 items in the database @xmath12 by @xmath13 . of these items ,",
    "a total of @xmath0 are members of the subset @xmath14 of target items .",
    "an oracle function @xmath15 indicates whether a selected item is or is not a target : @xmath16 if @xmath1 is not already a power of four , we embed the database @xmath12 in a larger database @xmath17 containing additional non - target items such that the total number of items in @xmath17 is the smallest power of four larger than @xmath1 : @xmath18 where @xmath19 @xmath20 an integer , i.e. , @xmath21 so @xmath22    the above enlargement of the database is as in @xcite . here ,",
    "in addition , we embed @xmath17 in a database @xmath23 which is four times larger still : @xmath24 where @xmath25 that is , @xmath26 all of the additional items not in @xmath12 are by definition non - targets , so equation ( [ oracle ] ) still holds and the cardinality of @xmath14 is still @xmath0 .    for the database to be searched by a quantum computer @xcite ,",
    "the @xmath27 items in @xmath23 are set in one - to - one correspondence with the @xmath27 computational - basis states @xmath28 : @xmath29 where each of the eigenvalues @xmath30 is either 0 or 1 .",
    "the @xmath31-component vector of @xmath32 s associated with @xmath33 is termed the symbol of @xmath33 : @xmath34 we also define auxiliary symbol functions @xmath35    it should be emphasized that the correspondence ( [ correspondence ] ) is _ not _ chosen to make the symbol @xmath36 a binary representation of the item index @xmath37 . on the contrary",
    ", it is essential for what follows that none of the @xmath3 items in the set @xmath17 be represented by states such that @xmath38 .",
    "that is , we require that @xmath39 ( we could , for example , establish the correspondence ( [ correspondence ] ) so that @xmath40 . ) condition ( [ notin00 ] ) implies @xmath41    extending the technique employed in @xcite to the case of multiple targets , we select @xmath0 of the items with auxiliary symbols @xmath38 to be `` ground state items . ''",
    "specifically , the @xmath0 elements of the set @xmath42 of ground state items , @xmath43 are those with the symbols @xmath44 the rightmost @xmath45 entries in @xmath46 are all 1 s and constitute a binary representation of @xmath47 , where @xmath48    we can now define the auxiliary functions @xmath49 and , in terms of these , the auxiliary oracle functions @xmath50 ( the symbol `` @xmath51 '' denotes logical or . ) note that @xmath52    the starting state for the iteration is the equally - weighted superposition of computational basis states obtained from the state @xmath53 by a walsh - hadamard transformation , @xmath54 starting from @xmath55 , a total of @xmath56 iterations are performed of the transformation @xmath57 where @xmath58 the unitary operator @xmath59 in ( [ iteration ] ) is defined as @xmath60 where i is the identity operator . in terms of its action on computational - basis states , @xmath61 the unitary operator @xmath62 in ( [ iteration ] ) is defined as @xmath63    the proof that , after @xmath56 iterations , the resulting state @xmath64 is an equally - weighted superposition of the @xmath0 states @xmath65 proceeds by induction . using ( [ startingstate ] ) , ( [ iteration ] ) , ( [ i_j2 ] ) and ( [ i_sj ] ) , we find , for @xmath66 , @xmath67.\\ ] ] to evaluate the second sum in ( [ s1_intermediate ] ) , divide the set of @xmath27 states into two groups , those for which @xmath38 and those for which @xmath68 .",
    "the first group contains @xmath69 states , of which the @xmath70 states not in @xmath42 have @xmath71 , and the remaining @xmath0 states in @xmath42 have @xmath72 ( see eqs .",
    "( [ auxiliaryfunction ] ) , ( [ auxiliaryoracle ] ) ) . of the @xmath73 states with @xmath68 , @xmath0 of these",
    "have @xmath71 by virtue of being target states ( @xmath74 ) , and the remaining @xmath75 have @xmath72 .",
    "so , @xmath76 and ( [ s1_intermediate ] ) reduces to @xmath77    we now assume that for some @xmath10 , @xmath78 and derive the form of @xmath79 . from ( [ startingstatej ] ) , ( [ iteration ] ) , ( [ i_j2 ] ) and ( [ i_sj ] ) , @xmath80 . \\label{sj_intermediate}\\ ] ] the second sum in ( [ sj_intermediate ] ) can again be evaluated by counting .",
    "the items @xmath33 for which @xmath81 fall into two disjoint groups , those for which @xmath82 , and the elements of @xmath14 . of the former group , @xmath83 have @xmath84 ( those with @xmath85recall that the elements of @xmath42 are not members of @xmath86 for _ any _ @xmath87 ) , and the remaining @xmath88 have @xmath89 . as for the elements of @xmath14 ,",
    "all @xmath0 have @xmath84 .",
    "therefore , @xmath90 using ( [ sumj ] ) in ( [ sj_intermediate ] ) , we obtain @xmath91    after applying @xmath92 iterations ( [ iteration ] ) to the starting state ( [ startingstate ] ) , we therefore obtain ( keeping in mind that @xmath93 ) @xmath94 a measurement of @xmath95 in the computational basis will with certainty yield one of the states corresponding to a target item .",
    "only a small number of changes are required in the analysis presented above to produce an algorithm which will yield one of the target states with a probability greater than one - quarter when the number of targets is not a power of four , and which reduces to the algorithm of section 2 when the number of targets is a power of four .",
    "all of the definitions through the selection of the ground - state items , eq .",
    "( [ gsymbols ] ) , remain applicable .",
    "however , the integer @xmath96 defined in ( [ pdef0 ] ) must be everywhere replaced with @xmath97 @xmath98 where @xmath5 is the smallest power of four larger than @xmath0 .",
    "i.e. , @xmath99 @xmath100 the rightmost @xmath101 entries in @xmath46 constitute a binary representation of @xmath102 , but they will are not all 1 s . the definitions ( [ auxiliaryfunction ] ) and ( [ auxiliaryoracle ] ) of the auxiliary functions @xmath103 and the auxiliary oracle functions @xmath104 remain unchanged . however , most significantly , eq . ( [ fn_p ] )",
    "is replaced with @xmath105 since not all items with @xmath106 are in @xmath42 .",
    "so , a derivation parallel to that in section 2 leads to the conclusion that , by beginning with the initial state ( [ startingstate ] ) and performing @xmath107 iterations ( [ iteration ] ) , we obtain the state @xmath108 if a measurement in the computational basis is made of the state ( [ sn_pq0 ] ) , the probability that one of the target states will be obtained is @xmath109 where @xmath110 the probability of finding a target state is thus between one , when @xmath111 ( @xmath112 ) , and somewhat above one - quarter , when @xmath113 ( @xmath114 ) .",
    "now suppose that , rather than making a measurement after @xmath107 iterations , we perform an `` extra '' iteration , i.e. , compute @xmath115 before measuring .",
    "the definitions ( [ auxiliaryfunction ] ) , ( [ auxiliaryoracle ] ) of @xmath103 and @xmath104 work for @xmath116 and , with the relations ( [ pdef ] ) , ( [ nudef ] ) , imply that , regardless of the value of @xmath0 , @xmath117 for @xmath118 the summation formula corresponding to ( [ sumj ] ) is @xmath119 the state resulting after one extra iteration is @xmath120\\ ] ] where @xmath121 the probability of obtaining a target state upon measuring @xmath122 is @xmath123    for @xmath124 , @xmath125 , while , for @xmath126 , @xmath127 .",
    "so , the appropriate strategy is to make a measurement after @xmath128 iterations if @xmath129 , and to make a measurement after @xmath130 iterations if @xmath124 . the probability of obtaining a target state will in this way be at least as large as @xmath131 ( see fig .  1 ) .",
    "yet another iteration before measurement gives @xmath132\\ ] ] where @xmath133,\\ ] ] and a probability of target - finding of @xmath134 despite the extra iteration , the probability of obtaining a target state when @xmath135 is not increased ; @xmath136 .",
    "this is true for an arbitrary number of additional iterations .",
    "the quantum state obtained after @xmath137 iterations , @xmath138 , is of the form @xmath139,\\ ] ] where @xmath140 and @xmath141 satisfy the recursion relations @xmath142\\right)a_q \\label{recursionaq } , \\\\",
    "b_{q+1}&=&-\\left(1 + 8\\left[a_q^2\\rho - b_q^2(1-\\rho)\\right]\\right)b_q \\label{recursionbq}.\\end{aligned}\\ ] ] the probability of finding a target upon measurement is @xmath143 from ( [ sn_pq1_result ] ) and ( [ sn_pq_general ] ) we see that @xmath144 and @xmath145 when @xmath135 . the relations ( [ recursionaq])-([p_q ] ) then show that @xmath146    this is not in any sense to claim that iteration algorithms different than those considered here might not improve on the probability of finding a target when @xmath135 . nor",
    "is it to say that iterations beyond @xmath147 necessarily have no use .",
    "probability functions @xmath148 , @xmath149 , can , for values of @xmath150 , be larger than either @xmath151 or @xmath152 , indeed as large as 1 ( see fig .",
    "grassl @xcite and tu and long @xcite have presented the following implementations of the operators @xmath153 and @xmath154 , and have evaluated the number of oracle calls required each time these operators are applied . from eq .",
    "( [ i_j2 ] ) we see that @xmath153 can be written as @xmath155 from the condition ( [ notin00 ] ) on the representation of elements of @xmath17 ( and , therefore , on all elements of the target set @xmath14 ) , and the definitions ( [ auxiliaryfunction ] ) , ( [ auxiliaryoracle ] ) of @xmath156 , @xmath157 , it follows that @xmath158 therefore @xmath159 and we see that each application of @xmath153 requires a single call to the oracle , since the @xmath156 s are independent of @xmath160 .    from the iteration condition ( [ iteration ] ) , the definition ( [ i_sj ] ) of @xmath154 , and the unitarity of @xmath153 and @xmath154 , we see that the operators @xmath154 satisfy the relation @xmath161 let @xmath162 denote the number of oracle calls required by @xmath154 .",
    "since @xmath153 requires one oracle call , ( [ irecursion ] ) implies @xmath163 for @xmath66 , @xmath164 which is independent of @xmath160 , so @xmath165 and @xmath162 has the closed form @xmath166    taking into account the single oracle call required by @xmath153 , the total number of oracle calls required for @xmath167 iterations of ( [ iteration ] ) is @xmath168 which , using ( [ tclosedform ] ) , has the value @xmath169    it follows from the results of section 2 that , for @xmath0 a power of four , the required number of oracle calls to obtain a target with unit probability is @xmath170 if @xmath0 is not a power of four , the results of section 3 imply that the number of oracle calls to obtain a target state with probability of at least one half is @xmath171 if @xmath172 is between 1/2 and 1 , and @xmath173 if @xmath174 is between 1/4 and 1/2 .",
    "the original algorithm of chen and diao @xcite performs two series of @xmath20 iterations of ( [ iteration ] ) , so the number of oracle calls required to find the unique target item by that method is @xmath175    the exponent @xmath176 is approximately equal to 0.7925 .",
    "so , with this particular implementation of the operators @xmath153 and @xmath154 , the computational complexity of the algorithms of @xcite and the present paper scales more slowly than that of the best possible classical algorithm ( @xmath177 ) , but not as slowly as that of grover s algorithm @xcite ( @xmath178 ) . unlike grover s algorithm , these algorithms will find a target item with certainty if the number of targets is a power of four .",
    "it is not known at present whether the implementation employed here is the most efficient possible , or if implementations requiring fewer oracle calls may exist .",
    "i would like to thank markus grassl for providing a prepublication copy of @xcite , and the anonymous reviewer of the previous version of this paper for also pointing out the relation ( [ irecursion ] ) .",
    "99 g.  chen and z.  diao,``exponentially fast quantum search algorithm , '' quant - ph/0011109 v3 ( 2000 ) .",
    "m.  grassl , `` comment on ` an exponentially fast quantum search algorithm , ' '' unpublished ( 2001 ) . c.  c.  tu and g.  l.  long , ``",
    "chen and diao s quantum search algorithm is not exponentially fast , ''",
    "quant - ph/0110098 ( 2001 ) .",
    "n.  d.  mermin , `` lecture notes for physicists on the theory of quantum computation , '' http://www.lassp.cornell.edu/lassp_data/nmermin.html l.  k.  grover , in _ proc .",
    "28th annual symposium on the theory of computing_(acm press , new york , 1996 ) , p. 212 ; _ phys .",
    "lett . _ * 78 * , 325 ( 1997 ) ; _ phys .",
    "lett . _ * 80 * , 4329 ( 1998 ) .",
    "g.  brassard , p.  hyer , m.  mosca , a.  tapp , `` quantum amplitude amplification and estimation , '' quant - ph/0005055 ( 2000 ) .",
    "p.  hyer ,  ` on arbitrary phases in quantum amplitude amplification,' _ phys .",
    "rev . _ * a62 * , 052304 ( 2000 ) ; quant - ph/0006031 .",
    "g.  l.  long , `` grover algorithm with zero theoretical failure rate , '' quant - ph/010607 ( 2001 ) .",
    "probability @xmath179 of finding a target with @xmath180 `` extra '' iterations , as a function of @xmath174 .",
    "solid line : @xmath181 . dashed line : @xmath182 .",
    "dotted line : @xmath183 ."
  ],
  "abstract_text": [
    "<S> the quantum search algorithm of chen and diao , which finds with certainty a single target item in an unsorted database , is modified so as to be capable of searching for an arbitrary specified number of target items . </S>",
    "<S> if the number of targets , @xmath0 , is a power of four , the new algorithm will with certainty find one of the targets in a database of @xmath1 items using @xmath2 oracle calls , where @xmath3 is the smallest power of four greater than or equal to @xmath1 . if @xmath0 is not a power of four , the algorithm will , with a probability of at least one - half , find one of the targets using no more than @xmath4 calls , where @xmath5 is the smallest power of four greater than or equal to @xmath0 . </S>"
  ]
}