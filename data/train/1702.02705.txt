{
  "article_text": [
    "programming efficient concurrent implementations of atomic collections , e.g. , stacks and queues , is error prone . to minimize synchronization overhead between concurrent method invocations , implementors avoid blocking operations like lock acquisition , allowing methods to execute concurrently .",
    "however , concurrency risks unintended inter - operation interference , and risks conformance to atomic reference implementations .",
    "conformance is formally captured by _ ( observational )",
    "refinement _ , which assures that all behaviors of programs using these efficient implementations would also be possible were the atomic reference implementations used instead .",
    "observational refinement can be formalized as a trace inclusion problem , and the latter can itself be reduced to an invariant checking problem , but this requires in general introducing history and prophecy variables  @xcite .",
    "alternatively , verifying refinement requires in general establishing a forward simulation _ and _ a backward simulation  @xcite .",
    "while simulations are natural concepts , backward reasoning , corresponding to the use of prophecy variables , is in general hard and complex for programs manipulating data structures .",
    "therefore , a crucial issue is to understand the limits of forward reasoning in establishing refinement .",
    "more precisely , an important question is to determine for which concurrent abstract data structures , and for which classes of implementations , it is possible to carry out a refinement proof using only forward simulations .",
    "to get rid of backward simulations ( or prophecy variables ) while preserving completeness w.r.t .",
    "refinement , it is necessary to have reference implementations that are _",
    "deterministic_. interestingly , determinism allows also to simplify the forward simulation checking problem . indeed ,",
    "in this case , this problem can be reduced to an invariant checking problem .",
    "basically , the simulation relation can be seen as an invariant of the system composed of the two compared programs .",
    "therefore , existing methods and tools for invariant checking can be leveraged in this context .",
    "but , in order to determine precisely what is meant by determinism , an important point is to fix the alphabet of observable events along computations .",
    "typically , to reason about refinement between two library implementations , the only observable events are the calls and returns corresponding to the method invocations along computations .",
    "this means that only the external interface of the library is considered to compare behaviors , and nothing else from the implementations is exposed .",
    "unfortunately , it can be shown that in this case , it is impossible to have deterministic atomic reference implementations for common data structures such as stacks and queues ( see , e.g. , @xcite )",
    ". then , an important question is what is the necessary amount of information that should be exposed by the implementations to overcome this problem ?",
    "one approach addressing this question is based on linearizability @xcite and its correspondence with refinement @xcite .",
    "linearizability of a computation ( of some implementation ) means that each of the method invocations can be seen as happening at some point , called _ linearization point _ , occurring somewhere between the call and return events of that invocation .",
    "the obtained sequence of linearization points along the computation should define a sequence of operations that is possible in the atomic reference implementation .",
    "proving the existence of such sequences of linearization points , for all the computations of a concurrent library , is a complex problem @xcite .",
    "however , proving linearizability becomes less complex when linearization points are fixed for each method , i.e. , associated with the execution of a designated statement in its source code @xcite . in this case",
    ", we can consider that libraries expose in addition to calls and returns , events signaling linearization points . by extending this way the alphabet of observable events",
    ", it becomes straightforward to define _",
    "deterministic _ atomic reference implementations . therefore ,",
    "proving linearizability can be carried out using forward simulations when linearization points are fixed , e.g. ,  @xcite .",
    "unfortunately , this approach is not applicable to efficient implementations such as the lcrq queue  @xcite ( based on the principle of the herlihy&wing queue @xcite ) , and the time - stamped stack @xcite .",
    "the proofs of linearizability of these implementations are highly nontrivial , very involved , and hard to read , understand and automatize .",
    "therefore , the crucial question we address is what is precisely the kind of information that is necessary to expose in order to obtain deterministic atomic reference implementations for such data structures , allowing to derive simple and natural linearizability proofs for such complex implementations , based on forward simulations , that are amenable to automation ?",
    "we observe that the main difficulty in reasoning about these implementations is that , linearization points of enqueue / push operations occurring along some given computation , depend in general on the linearization points of dequeue / pop operations that occur arbitrarily far in the future . therefore , since linearization points for enqueue / push operations can not be determined in advance , the information that could be fixed and exposed can concern only the dequeue / pop operations .",
    "one first idea is to consider that linearization points are fixed for dequeue / pop methods and only for these methods .",
    "we show that under the assumption that implementations expose linearizations points for these methods , it is possible to define deterministic atomic reference implementations for both queues and stacks .",
    "we show that this is indeed useful by providing a simple proof of the herlihy&wing queue ( based on establishing a forward simulation ) that can be carried out as an invariant checking proof",
    ".    however , in the case of time - stamped stack , fixing linearization points of pop operations is actually too restrictive .",
    "nevertheless , we show that our approach can be generalized to handle this case .",
    "the key idea is to reason about what we call _ commit points _",
    ", and that correspond roughly speaking to the last point a method accesses to the shared data structure during its execution .",
    "we prove that by exposing commit points ( instead of linearization points ) for pop methods , we can still provide deterministic reference implementations .",
    "we show that using this approach leads to a quite simple proof of the time - stamped stack , based on forward simulations .",
    "we formalize several abstraction relations between libraries using a simple yet universal model of computation , namely labeled transition systems ( lts ) .",
    "this model captures shared - memory programs with an arbitrary number of threads , abstracting away the details of any particular programming system irrelevant to our development .    a _ labeled transition system _ ( lts ) @xmath0 over the possibly - infinite alphabet @xmath1 is a possibly - infinite set @xmath2 of states with initial state @xmath3 , and a transition relation @xmath4 .",
    "the @xmath5th symbol of a sequence @xmath6 is denoted @xmath7 , and the empty sequence is denoted by @xmath8 .",
    "an _ execution _ of @xmath9 is an alternating sequence of states and transition labels ( called also actions ) @xmath10 for some @xmath11 such that @xmath12 for each @xmath5 such that @xmath13 .",
    "we write @xmath14 as shorthand for the subsequence @xmath15 of @xmath16 , for any @xmath17 ( in particular @xmath18 ) .",
    "the projection @xmath19 of a sequence @xmath20 is the maximum subsequence of @xmath20 over alphabet @xmath21 .",
    "this notation is extended to sets of sequences as usual .",
    "a _ trace _ of @xmath9 is the projection @xmath22 of an execution @xmath16 of @xmath9 .",
    "the set of executions , resp .",
    ", traces , of an lts @xmath9 is denoted by @xmath23 , resp . , @xmath24 .",
    "an lts is _ deterministic _ if for any state @xmath25 and any sequence @xmath26 , there is at most one state @xmath27 such that @xmath28 . more generally , for an alphabet @xmath29 , an lts is _ @xmath21-deterministic _ if for any state s and any sequence @xmath30 , there is at most one state @xmath27 such that @xmath31 and @xmath20 is a subsequence of @xmath32 .",
    "programs interact with libraries by calling named library _ methods _ , which receive _ parameter values _ and yield _ return values _ upon completion .",
    "we fix arbitrary sets @xmath33 and @xmath34 of method names and parameter / return values .",
    "we fix an arbitrary set @xmath35 of operation identifiers , and for given sets @xmath33 and @xmath34 of methods and values , we fix the sets @xmath36    of _ call actions _ and _ return actions _ ; each call action @xmath37 combines a method @xmath38 and value @xmath39 with an _ operation identifier _ @xmath40 .",
    "operation identifiers are used to pair call and return actions .",
    "we may omit the second field from a call / return action @xmath41 for methods that have no inputs or return values .",
    "for notational convenience , we take @xmath42 for the rest of the paper .",
    "library _ is an lts over alphabet @xmath1 such that @xmath43 .",
    "we assume that the traces of a library satisfy standard well - formedness properties , e.g. , return actions correspond to previous call actions , which for lack of space are delegated to appendix  [ app : prelim ] .",
    "an operation @xmath44 is called _ completed _ in a trace @xmath45 when @xmath46 occurs in @xmath45 , for some @xmath47 and @xmath48 .",
    "otherwise , it is called _",
    "pending_.    the projection of a library trace over @xmath49 is called a _ history_. the set of histories of a library @xmath50 is denoted by @xmath51 .",
    "since libraries only dictate methods executions between their respective calls and returns , for any history they admit , they must also admit histories with weaker inter - operation ordering , in which calls may happen earlier , and/or returns later . a history",
    "@xmath52 is _ weaker _ than a history @xmath53 , written @xmath54 , iff there exists a history @xmath55 obtained from @xmath52 by appending return actions , and deleting call actions , s.t .",
    ": @xmath53 is a permutation of @xmath55 that preserves the order between return and call actions , i.e. ,  if a given return action occurs before a given call action in @xmath55 , then the same holds in @xmath53 . a library @xmath50 is called _ atomic _ when there exists a set @xmath56 of sequential histories such that @xmath51 contains every weakening of a history in @xmath56 .",
    "atomic libraries are often considered as specifications for concurrent objects .",
    "libraries can be made atomic by guarding their methods bodies with global lock acquisitions .    a library @xmath50 is called a _ queue implementation _ when @xmath57 ( @xmath58 is the method that enqueues a value and @xmath59 is the method removing a value ) and @xmath60 where empty is the value returned by @xmath59 when the queue is empty .",
    "similarly , a library @xmath50 is called a _ stack implementation _ when @xmath61 and @xmath60 . for queue and stack implementations ,",
    "we assume that the same value is never added twice , i.e. , for every trace @xmath20 of such a library and every two call actions @xmath62 and @xmath63 where @xmath64 we have that @xmath65 .",
    "as shown in several works  @xcite , this assumption is without loss of generality for libraries that are data independent , i.e. , their behaviors are not influenced by the values added to the collection , which is always the case in practice . on a technical note , this assumption is used to define ( @xmath21-)deterministic abstract implementations of stacks and queues in section  [ sec : queues ] and section  [ sec : stacks ] .",
    "conformance of a library @xmath66 to a specification given as an `` abstract '' library @xmath67 is formally captured by _ ( observational )",
    "refinement_. informally , we say @xmath66 refines @xmath67 iff every computation of every program using @xmath66 would also be possible were @xmath67 used instead .",
    "we assume that a program can interact with the library only through call and return actions , and thus refinement can be defined as history set inclusion .",
    "refinement is equivalent to the _ linearizability _ criterion  @xcite when @xmath67 is an atomic library  @xcite .",
    "a library @xmath66 _ refines _ another library @xmath67 iff @xmath68 .",
    "linearizability  @xcite requires that every history of a concurrent library @xmath66 can be `` linearized '' to a sequential history admitted by a library @xmath67 used as a specification .",
    "formally , a sequential history @xmath53 with only complete operations is called a _ linearization _ of a history @xmath52 when @xmath54 . a history",
    "@xmath52 is _ linearizable _ w.r.t .  a library @xmath67 iff there exists a linearization @xmath53 of @xmath52 such that @xmath69 .",
    "a library @xmath66 is _ linearizable _ w.r.t .",
    "@xmath67 , written @xmath70 , iff each history @xmath71 is linearizable w.r.t . @xmath67 .",
    "@xmath70 iff @xmath66 refines @xmath67 , if @xmath67 is atomic .    in the rest of the paper",
    ", we discuss methods for proving refinement ( and thus , linearizability ) focusing mainly on queue and stack implementations .",
    "library refinement is the instance of a more general notion of refinement between ltss which for some alphabet @xmath21 of _ observable actions _ is defined as the inclusion of sets of traces projected on @xmath21 .",
    "library refinement corresponds to the case @xmath72 .",
    "typically , @xmath21-refinement between two ltss @xmath9 and @xmath73 is proved using _ simulation relations _ which roughly , require that @xmath73 can mimic every step of @xmath9 using a ( possibly empty ) sequence of steps .",
    "mainly , there are two kinds of simulation relations , forward or backward , depending on whether the preservation of steps is proved starting from a similar state forward or backward .",
    "it has been shown that @xmath21-refinement is equivalent to the existence of _ backward simulations _",
    ", modulo the addition of history variables that record events in the implementation , and to the existence of _ forward simulations _ provided that the right - hand side lts @xmath73 is @xmath21-deterministic  @xcite .",
    "we focus on proofs based on forward simulations because they are easier to automatize .",
    "in general , forward simulations are _ not _ a complete proof method for library refinement because libraries are not @xmath49-deterministic ( the same sequence of call / return actions can lead to different states depending on the interleaving of the internal actions ) . however , there are classes of atomic libraries , e.g. , libraries with `` fixed linearization points '' ( defined later in this section ) , for which it is possible to identify a larger alphabet @xmath21 of observable actions ( including call / return actions ) , and implementations that are @xmath21-deterministic . for queues and stacks , section  [ sec : queues ] and section  [ sec : stacks ]",
    "define other such classes of implementations that cover all the implementations that we are aware of .",
    "let @xmath74 and @xmath75 be two libraries over @xmath76 and @xmath77 , resp .",
    ", such that @xmath78 .",
    "also , let @xmath21 be a set of actions s.t . @xmath79 .",
    "[ def : gref ] the library @xmath66 _ @xmath21-refines _ @xmath67 iff @xmath80 .",
    "notice that @xmath21-refinement implies refinement for any @xmath21 as in definition  [ def : gref ] .",
    "we define a notion of _ forward _ simulation that can be used to prove @xmath21-refinement ( a dual notion of _ backward _ simulation is defined in appendix  [ app : backsim ] ) . for a relation @xmath81 ,",
    "@xmath82 $ ] is the set of elements related by @xmath83 to elements of @xmath84 , i.e. , @xmath82={{\\ { y:\\exists x\\in x.\\ r(x , y ) \\}}}$ ] .",
    "a relation @xmath85 is called a _ @xmath21-forward simulation _ from @xmath66 to @xmath67 iff @xmath86 = \\{s_0 ^ 2 \\}$ ] and :    * if @xmath87 , for some @xmath88 , and @xmath89 $ ] , then there exists @xmath90 $ ] such that @xmath91 , @xmath92 , for some @xmath5 , and @xmath93 , for each @xmath94 . *",
    "if @xmath95 , for some @xmath96 and @xmath89 $ ] , then there exists @xmath90 $ ] such that @xmath97 and @xmath98 .",
    "a @xmath21-forward simulation requires that every step of @xmath66 corresponds to a sequence of steps of @xmath67 . to imply @xmath21-refinement",
    ", every step of @xmath66 labeled by an observable action @xmath88 should be simulated by a sequence of steps of @xmath67 where exactly one transition is labeled by @xmath99 and all the other transitions are labeled by non - observable actions .",
    "the following shows the soundness and the completeness of @xmath21-forward simulations ( when @xmath67 is @xmath21-deterministic ) .",
    "it is an instantiation of previous results  @xcite .",
    "[ th : forsim ] @xmath66 @xmath21-refines @xmath67 when there is a @xmath21-forward simulation from @xmath66 to @xmath67 .",
    "moreover , if @xmath66 @xmath21-refines @xmath67 and @xmath67 is @xmath21-deterministic , then there is a @xmath21-forward simulation from @xmath66 to @xmath67 .",
    "the linearization of a concurrent history can be also defined in terms of _ linearization points_. informally , a linearization point of an operation in an execution is a point in time where the operation is conceptually effectuated ; given the linearization points of each operation , the linearization of a concurrent history is the sequential history which takes operations in order of their linearization points .",
    "for some libraries , the linearization points correspond to a fixed set of actions .",
    "for instance , in the case of atomic libraries where method bodies are guarded with a global - lock acquisition , the linearization point of every method invocation corresponds to the execution of the body . when the linearization points are fixed , we assume that the library is an lts over an alphabet that includes actions @xmath100 with @xmath101 , @xmath102 and @xmath103 . the action @xmath100 represents the linearization point of the operation @xmath44 returning value @xmath48 .",
    "let @xmath104 denote the set of such actions .",
    "the projection of a library trace over @xmath105 is called an _ extended history_. a trace or extended history is called _",
    "when every completed operation has a linearization point , i.e. , each return action @xmath46 is preceded by an action @xmath100 .",
    "a library @xmath50 over alphabet @xmath1 is called _ with fixed linearization points _",
    "iff @xmath106 and every trace @xmath107 is @xmath104-complete .    proving the correctness of an implementation @xmath66 of a concurrent object such as a queue or a stack with fixed linearization points reduces to proving that @xmath66 is a @xmath108-refinement of an abstract implementation @xmath67 of the same object where method bodies are guarded with a global - lock acquisition .",
    "since the abstract implementation is usually @xmath108-deterministic , by theorem  [ th : forsim ] , proving @xmath108-refinement is equivalent to finding a @xmath108-forward simulation from @xmath66 to @xmath67 .",
    "section  [ sec : queues ] and section  [ sec : stacks ] extend this result to queue and stack implementations where the linearization point of the methods _ adding _ values to the collection is _ not _ fixed .",
    "the typical abstract implementation of a concurrent queue , denoted as @xmath109 , maintains a sequence of values , the enqueue adds a value atomically to the beginning of the sequence , and the dequeue removes a value from the end of the sequence ( if any , otherwise it returns empty ) .",
    "both methods have a fixed linearization point when the update of the sequence happens .",
    "for some queue implementations , e.g. , the herlihy&wing queue  @xcite ( @xmath110 for short ) , there exists no forward simulation to @xmath109 although they are a refinement of @xmath109 .",
    "the main reason is that the enqueue methods do nt have a _ fixed _ linearization point . in this section , we propose a new abstract implementation for queues , denoted as @xmath111 , which roughly maintains a _ partially - ordered set _ of values instead of a sequence .",
    "we show that there exists a forward simulation from any correct queue implementation where only the _ dequeue _ methods have fixed linearization points ( the enqueue methods are unconstrained ) to @xmath111 .",
    "this covers all the queue implementations that we are aware of , in particular @xmath110 , baskets queue  @xcite , lcrq  @xcite , or time - stamped queue  @xcite ( where the enqueues do nt have fixed linearization points ) .",
    "we also describe a forward simulation from @xmath110 to @xmath111 .",
    "we describe @xmath110 where the linearization points of the enqueue methods are not fixed . the shared state consists of an array items storing the values in the queue and a counter back storing the index of the first unused position in items .",
    "initially , all the positions in the array are null and back is 0 .",
    "an enqueue method starts by reserving a position in items ( i stores the index of this position and back is incremented so the same position ca nt be used by other enqueues ) and then , stores the input value x at this position .",
    "the dequeue method traverses the array items starting from the beginning and atomically swaps null with the encountered value .",
    "if the value is not null , then the dequeue returns that value .",
    "if it reaches the end of the array , then it restarts .",
    "l5.3 cm    .... void enq(int x ) {    i = back++ ;    items[i ] = x ; } int deq ( ) {    while ( 1 ) {      range = back - 1 ;      for ( int i = 0 ; i < = range ; i++ ) {        x = swap(items[i],null ) ;        if ( x !",
    "= null ) return x ; } } }     ....    the linearization points of the enqueues are not fixed , they depend on dequeues executing in the future .",
    "consider the following trace with two concurrent enqueues ( @xmath112 represents the value of i in operation @xmath44 ) : @xmath113 , @xmath114 , @xmath115 , @xmath116 , @xmath117 } = y$ ] .",
    "assuming that the linearization point corresponds to the assignment of i , the history of this trace should be linearized to @xmath113 , @xmath118 , @xmath114 , @xmath119 .",
    "however , a dequeue executing until completion after this trace will return @xmath120 ( only position @xmath121 is filled in the array items ) which is not consistent with this linearization . on the other hand , assuming that enqueues should be linearized at the assignment of items[i ] and extending the trace with @xmath122 } = x$ ] and a completed dequeue that in this case returns @xmath123 , leads to the incorrect linearization : @xmath114 , @xmath119 , @xmath113 , @xmath118 , @xmath124 , @xmath125 .",
    "the dequeue method has a fixed linearization point which corresponds to an execution of swap returning a non - null value .",
    "this action alone contributes to the effect of that value being removed from the queue .",
    "every concurrent history can be linearized to a sequential history where dequeues occur in the order of their linearization points in the concurrent history .",
    "this claim is formally proved in section  [ ssec : herlihywing ] .",
    "since the linearization points of the enqueues are not fixed , there exists no forward simulation from @xmath110 to @xmath109 . in the following ,",
    "we describe the abstract implementation @xmath111 for which such a forward simulation does exist .",
    "informally , @xmath111 records the happens - before order between enqueue operations for which the added value has not been removed by a dequeue operation .",
    "the linearization point of a dequeue operation with return value @xmath126 is enabled only if the happens - before stored in the current state contains a minimal enqueue that adds the value @xmath48 .",
    "the effect of the linearization point is that the minimal enqueue is removed from the current state and the return value is recorded in the library state .",
    "when the return value is empty , the linearization point of a dequeue is enabled only if the current state stores only pending enqueues ( the dequeue overlaps with all the enqueue operations stored in the current state and it can be linearized before all of them ) .",
    "the return of a dequeue is enabled only if the returned value matches the one fixed at the linearization point .",
    "l6.7 cm     figure  [ fig : queuesim ] pictures two executions of @xmath111 for two extended histories ( that include dequeue linearization points ) .",
    "the state of @xmath111 after each action is pictured as a graph below the action .",
    "the nodes of this graph represent enqueue operations and the edges happens - before constraints .",
    "each node is labeled by a value ( the input of the enqueue ) and a flag pend or comp showing whether the operation is pending or completed .",
    "for instance , in the case of the first history , the dequeue linearization point @xmath127 is enabled because the current happens - before contains a _ minimal _ enqueue operation with input @xmath120 .",
    "note that a linearization point @xmath128 is also enabled at this state .",
    "formally , the states of @xmath111 are tuples @xmath129 where @xmath130 is a set of operation identifiers , @xmath131 is a strict partial order , @xmath132 labels every identifier with a value and a pending / completed flag ( the flag is used to track the happens - before order ) , @xmath133 records the return value of a dequeue fixed at its linearization point ( @xmath134 denotes a partial function ) , and @xmath135 records the control point of every enqueue ( @xmath136 ) or dequeue operation ( @xmath137 ) .",
    "all the components are @xmath138 in the initial state , and the transition relation @xmath139 is defined in fig .",
    "[ fig : transitions : absq ] .",
    "the alphabet of @xmath111 contains call / return actions and dequeue linearization points , denoted by @xmath140 .",
    "@xmath141 is the set of all actions @xmath140 .",
    "concerning enqueue operations , the rule call - enq orders the invoked operation after all the completed enqueues in the current state , and the rules ret - enq1/ret - enq2 flip the corresponding flag from pend to comp provided that the operation is still present in the current state . for dequeue operations , call - deq only increments the control point and ret - deq checks whether the return value is the same as the one fixed at the linearization point .",
    "the linearization point rule lin - deq1 corresponds to the case of a non - empty queue , showing that @xmath140 is enabled only if @xmath48 has been added by an enqueue which is minimal in the current happens - before .",
    "when enabled , it removes the enqueue adding @xmath48 from the state .",
    "the linearization point rule lin - deq2 corresponds to the case of dequeue operations linearized with an empty return value .",
    "[ t ]    the following result states that the library @xmath111 has exactly the same set of histories as the standard abstract library @xmath109 ( see appendix  [ app : absimplqueue ] for a proof ) .",
    "[ th : absimplqueue ] @xmath111 is a refinement of @xmath109 and vice - versa .    a trace of a queue implementation is called _",
    "@xmath141-complete _ when every completed dequeue has a linearization point , i.e. , each return action @xmath142 is preceded by an action @xmath140 .",
    "a queue implementation @xmath50 over alphabet @xmath1 , such that @xmath143 , is called _ with fixed dequeue linearization points _ when every trace @xmath107 is @xmath141-complete .",
    "the following result shows that @xmath144-forward simulations are a sound and complete proof method for showing the correctness of a queue implementation with fixed dequeue linearization points ( up to the correctness of the linearization points ) .",
    "it is obtained from theorem  [ th : absimplqueue ] and theorem  [ th : forsim ] using the fact that the alphabet of @xmath111 is exactly @xmath144 and @xmath111 is deterministic .",
    "a queue implementation @xmath50 with fixed dequeue linearization points is a @xmath144-refinement of @xmath109 iff there exists a @xmath144-forward simulation from @xmath50 to @xmath111 .",
    "we describe a forward simulation @xmath145 from @xmath110 to @xmath111 . a @xmath110 state is related by @xmath145 to an @xmath111 state that consists of all the enqueue operations for which the input is still present in the array items and all the pending enqueue operations that have at most reserved an array position , ordered by a relation @xmath146 satisfying the following :    * pending enqueues",
    "are maximal , i.e. , for every two enqueues @xmath44 and @xmath147 such that @xmath147 is pending , we have that @xmath148 , * @xmath146 is consistent with the order in which positions of items have been reserved , i.e. , for every two enqueues @xmath44 and @xmath147 such that @xmath149 , we have that @xmath150 , * an enqueue which has reserved a position @xmath5 ca nt be ordered before another enqueue that has reserved a position @xmath151 when the position @xmath5 has been `` observed '' by a non - linearized dequeue that may `` observe '' @xmath152 in the current array traversal , i.e. , for every two enqueues @xmath44 and @xmath147 , and a dequeue @xmath153 , such that +   @xmath154 + we have that @xmath155 .",
    "the predicate @xmath156 holds when the dequeue @xmath153 is at a control point after a swap returning null and before the increment of i.    an enqueue is labeled by @xmath157 where @xmath48 is the input value if it s pending and by @xmath158 , otherwise .",
    "also , for every dequeue operation @xmath44 such that @xmath159 , we have that @xmath160 .",
    "we show that @xmath145 is indeed a @xmath144-forward simulation .",
    "let @xmath25 and @xmath161 be states of @xmath110 and @xmath111 , respectively , such that @xmath162 .",
    "we omit discussing the trivial case of transitions labeled by call and return actions which are simulated by similar transitions of @xmath111 ( for the return a dequeue operation @xmath44 , we use the equality between the local variable @xmath163 in @xmath25 and the component @xmath164 in @xmath161 ) .",
    "we show that each internal step of an enqueue or dequeue , except the execution of swap returning a non - null value in dequeue ( which represents its linearization point ) , is simulated by an _ empty _ sequence of @xmath111 transitions , i.e. , for every state @xmath27 obtained through one of these steps , if @xmath162 , then @xmath165 for each @xmath111 state @xmath161 . essentially , this consists in proving the following property , called _ monotonicity _ :",
    "the set of possible orders @xmath146 associated by @xmath145 to @xmath27 does nt exclude any order @xmath146 associated to @xmath25 .",
    "concerning enqueues , let @xmath27 be the state obtained from @xmath25 when a pending enqueue @xmath44 reserves an array position .",
    "this enqueue must be maximal in both @xmath161 and any state @xmath166 related to @xmath27 ( since it s pending ) .",
    "moreover , there is no dequeue that can `` observe '' this position before restarting the array traversal .",
    "therefore , item ( c ) in the definition of @xmath146 does nt constrain the order between @xmath44 and some other enqueue neither in @xmath25 nor in @xmath27 . since",
    "this transition does nt affect the constraints on the order between enqueues different from @xmath44 ( their local variables remain unchanged ) , monotonicity holds .",
    "this property is trivially satisfied by the second step of enqueue which does nt affect i.    to prove monotonicity in the case of dequeue internal steps different from its linearization point , it is important to track the non - trivial instantiations of item ( c ) in the definition of @xmath146 over the two states @xmath25 and @xmath27 , i.e. , the triples @xmath167 for which ( [ eq : inst ] ) holds .",
    "instantiations that are enabled only in @xmath27 may in principle lead to a violation of monotonicity ( since they restrict the orders @xmath146 associated to @xmath27 ) .",
    "for the two steps that begin an array traversal , i.e. , reading the index of the last used position and setting i to @xmath168 , there exist no such new instantiations in @xmath27 because the value of i is either not set or @xmath168 .",
    "the same is true for the increment of i in a dequeue @xmath153 since the predicate @xmath156 holds in state @xmath25 .",
    "the execution of swap returning null in a dequeue @xmath153 enables new instantiations @xmath167 in @xmath27 , thus adding potentially new constraints @xmath169 .",
    "we show that these instantiations are however vacuous because @xmath44 must be pending in @xmath25 and thus maximal in every order @xmath146 associated by @xmath145 to @xmath25 .",
    "let @xmath44 and @xmath147 be two enqueues such that together with the dequeue @xmath153 they satisfy the property ( [ eq : inst ] ) in @xmath27 but not in @xmath25 .",
    "we write @xmath170 for the value of the variable i of operation @xmath44 in state @xmath25 .",
    "we have that @xmath171 and @xmath172={\\tt null}$ ] .",
    "the latter implies that the enqueue @xmath44 did nt executed the second statement ( since the position it reserved is still null ) and it is pending in @xmath25 .",
    "the step that checks that the value returned by swap is null does nt modify the variables in property ( [ eq : inst ] ) and also , it does nt change the valuation of the predicate @xmath173 .    finally , we show that the linearization point of a dequeue @xmath44 of @xmath110 , i.e. , an execution of swap returning a non - null value @xmath48 , from state @xmath25 and leading to a state @xmath27 is simulated by a transition labeled by @xmath140 of @xmath111 from state @xmath161 . by the definition of @xmath110",
    ", there is a unique enqueue @xmath174 which filled the position updated by @xmath44 , i.e. , @xmath175 and @xmath176 .",
    "we show that @xmath174 is minimal in the order @xmath146 of @xmath161 which implies that @xmath140 is enabled in @xmath161 .",
    "thus , instantiating item ( c ) in the definition of @xmath146 with @xmath177 and @xmath178 we get that every enqueue that reserved a position smaller than the one of @xmath174 ca nt be ordered before @xmath174 in the order @xmath146 . also ,",
    "applying item ( b ) with @xmath179 we get the same for every enqueue that reserved a bigger position .",
    "an enqueue that did nt reserved a position is by definition maximal in @xmath146 and therefore , not a predecessor of @xmath174 .",
    "then , the state @xmath166 obtained from @xmath161 through a @xmath140 transition is related to @xmath27 because ( 1 ) the value added by @xmath174 is not anymore present in items which implies that @xmath174 does nt occur in any @xmath111 state related to @xmath27 , and ( 2 ) the value of @xmath163 is set to @xmath180 which implies that @xmath164 is set to @xmath48 in every @xmath111 state related to @xmath27 .",
    "while the abstract queue in section  [ sec : queues ] can be adapted to stacks ( the linearization point @xmath181 with @xmath126 is enabled when @xmath44 is added by a push which is maximal in the happens - before order stored in the state ) , it ca nt simulate ( through forward simulations ) existing stack implementations like the time - stamped stack  @xcite ( @xmath182 , for short ) where the linearization points of the pop operations are not fixed . exploiting particular properties of the stack semantics , we refine the ideas used in @xmath111 and define a new abstract implementation for stacks , denoted as @xmath111 , which is able to simulate such implementations .",
    "forward simulations to @xmath183 are complete for proving the correctness of stack implementations provided that the point in time where the return value of a pop operation is determined , called _",
    "commit point _",
    ", corresponds to a fixed action .",
    "we explain the meaning of the commit points on a simplified version of the time - stamped stack  @xcite ( @xmath182 , for short ) given in figure  [ fig : timestamped ] .",
    "this implementation maintains an array of singly - linked lists , one for each thread , where list nodes contain a data value ( field data ) , a timestamp ( field ts ) , the next pointer ( field next ) , and a boolean flag indicating whether the node represents a value removed from the stack ( field taken ) .",
    "initially , each list contains a sentinel dummy node pointing to itself with timestamp @xmath184 and the flag taken set to false .",
    "l5.2 cm    .... struct node {    int data ;    int ts ;    node * next ;    boolean taken ; } ; node * pools[maxthreads ] ; int ts = 0 ;       void push(int x ) {    node * n = new node(x , max_int ,                          null , false ) ;    n->next = pools[mytid ] ;    pools[mytid ] = n ;    int",
    "i = ts++ ;    n->ts = i ; } int pop ( ) {   boolean success = false ;   int maxts = -1 ;   node * youngest = null ;   while ( !",
    "success ) {     maxts = -1 ; youngest = null ;     for(int i=0 ; i < maxthreads ; i++ ) {       node * n = pools[i ] ;       while ( n->taken & & n->next !",
    "= n )         n = n->next ;       if(maxts < n->ts ) {         maxts = n->ts ; youngest = n ;       }     }     if ( youngest ! = null )       success = cas(youngest->taken ,                         false , true ) ;   }   return youngest->data ; } ....    pushing a value to the stack proceeds in several steps : adding a node with maximal timestamp in the list associated to the thread executing the push ( given by the special variable mytid ) , asking for a new timestamp ( given by the shared variable ts ) , and updating the timestamp of the added node . popping a value from the stack",
    "consists in traversing all the lists , finding the first element which does nt represent a removed value ( i.e. , taken is false ) in each list , and selecting the element with the maximal timestamp . a compare - and - swap ( cas )",
    "is used to set the taken flag of this element to true .",
    "the procedure restarts if the cas fails .    .",
    "an operation is pictured by a line delimited by two circles denoting the call and respectively , the return action .",
    "pop operations with identifier @xmath44 and removing value @xmath48 are labeled @xmath185 .",
    "their representation includes another circle that stands for a successful cas which is their commit point .",
    "the library state after an execution prefix delimited at the right by a dotted line is pictured in the bottom part ( the picture immediately to the left of the dotted line ) .",
    "a pair @xmath186 represents a list node with @xmath187 and @xmath188 , and @xmath189 denotes the value of i in the pop with identifier 1 .",
    "we omit the nodes where the field taken is true.,width=434 ]    the push operations do nt have a fixed linearization point because adding a node to a list and updating its timestamp are not executed in a single atomic step .",
    "the nodes can be added in an order which is not consistent with the order between the timestamps assigned later in the execution .",
    "also , the value added by a push that just added an element to a list can be popped before the value added by a completed push ( since it has a maximal timestamp ) .",
    "the same holds for pop operations : the only reasonable choice for a linearization point is a successful cas ( that results in updating the field taken ) .",
    "[ fig : commit ] pictures an execution showing that this action does nt correspond to a linearization point , i.e. , an execution for which the pop operations in every correct linearization are not ordered according to the order between successful cass . in every correct linearization of that execution , the pop operation removing @xmath123 is ordered before the one removing @xmath190 although they perform a successful cas in the opposite order .",
    "an interesting property of the successful cass in pop operations is that they fix the return value , i.e. , the return value is youngest->data where youngest is the node updated by the cas .",
    "we call such actions _ commit points_. more generally , commit points are actions that access shared variables , from which every control - flow path leads to the return control point and contains no more accesses to the shared memory ( i.e. , after a commit point , the return value is computed using only local variables ) .",
    "when the commit points of pop operations are fixed to particular implementation actions ( e.g. , a successful cas ) we assume that the library is an lts over an alphabet that contains actions @xmath191 with @xmath102 and @xmath192 ( denoting the commit point of the pop with identifier @xmath44 and returning @xmath48 ) .",
    "let @xmath193 be the set of such actions .",
    "we define an abstract stack @xmath183 over alphabet @xmath194 that essentially , similarly to @xmath111 , maintains the happens - before order of the pushes whose value has not been yet removed .",
    "pops are treated differently since the commit points are not necessarily linearization points , intuitively , a pop can be linearized before its commit .",
    "each pop operation starts by taking a snapshot of the greatest completed push operations in the happens - before order , and continuously tracks the push operations which are overlapping with it .",
    "the commit point @xmath191 with @xmath195 is enabled only if @xmath48 was added by one of the push operations in the initial snapshot , or by a push happening earlier when all the values from the initial snapshot have been removed , or by one of the push operations that overlaps with pop @xmath44 .",
    "the commit point @xmath196 is enabled only if all the values added by push operations ending before @xmath44 started have been removed .",
    "the effect of the commit points is explained below through examples .",
    "l6.8 cm     figure  [ fig : stacksim ] pictures two executions of @xmath183 for two extended histories ( that include pop commit points ) . for readability , we give the state of @xmath183 only after several execution prefixes delimited at the right by a dotted line .",
    "we focus on pop operations  the effect of push calls and returns is similar to enqueue calls and returns in @xmath111 .",
    "let us first consider the history on the top part .",
    "the first state we give is reached after the call of pop with identifier @xmath197 .",
    "this shows the effect of a pop invocation : the greatest completed pushes according to the current happens - before ( here , the push with identifier @xmath121 ) are marked as @xmath198 ( from `` before '' operation 3 ) , and the pending pushes are marked as @xmath199 ( from `` overlapping '' with operation 3 ) . as a side remark , any other push operation that starts after pop @xmath197 would be also marked as @xmath199 .",
    "the commit point @xmath200 ( pictured with a red circle ) is enabled because @xmath123 was added by a push marked as @xmath198 .",
    "the effect of the commit point is that push @xmath121 is removed from the state ( the execution on the bottom shows a more complicated case ) .",
    "for the second pop , the commit point @xmath201 is enabled because @xmath120 was added by a push marked as @xmath202 .",
    "the execution on the bottom shows an example where the marking @xmath203 for some pop @xmath44 is updated at commit points .",
    "the pushes @xmath197 and @xmath204 are marked as @xmath205 and @xmath206 when the pops @xmath207 and @xmath208 start .",
    "then , @xmath209 is enabled since @xmath161 was added by @xmath210 which is marked as @xmath205 . besides removing @xmath210 , the commit point produces a state where a pop committing later , e.g. , pop @xmath208 , can remove @xmath120 which was added by a predecessor of @xmath210 in the happens - before ( @xmath120 could become the top of the stack when @xmath161 is removed ) .",
    "this history is valid because @xmath211 can be linearized after @xmath212 and @xmath213 .",
    "thus , push 2 , a predecessor of the push which is removed , is marked as @xmath206 .",
    "push @xmath121 which is also a predecessor of the removed push is not marked as @xmath206 because it happens before another push , i.e. , push 3 , which is already marked as @xmath206 ( the value added by push 3 should be removed before the value added by push 1 could become the top of the stack ) .",
    "formally , the states of @xmath183 are tuples @xmath214 where @xmath146 is a strict partial order over the set @xmath215 of operation identifiers , @xmath132 labels every identifier in @xmath215 with a value and a pending / completed flag , @xmath133 records the return value of a pending pop fixed at its commit point , @xmath135 records the control point of every push ( @xmath136 ) or pop operation ( @xmath137 ) , @xmath216 records the greatest completed push operations before a pop started or happening earlier provided that the values of all the push happening later have been removed , and @xmath217 records push operations overlapping with a pop .",
    "all the components are @xmath138 in the initial state , and the transition relation @xmath139 is defined in fig .",
    "[ fig : transitions : abss ] .",
    "the transition rules which do nt correspond to commit point actions are similar to those for @xmath111 .",
    "the rule com - pop1 for @xmath191 is enabled only if there exists a push @xmath147 which added value @xmath48 and which belongs to @xmath203 or @xmath218 .",
    "when enabled , the push @xmath147 is removed from the set @xmath215 ( and the order @xmath146 ) and for every other pop @xmath219 such that @xmath147 belongs to @xmath220 , @xmath147 is replaced in @xmath220 by its predecessors which are followed exclusively by pushes overlapping with @xmath219 ( these predecessors become maximal closed pushes once @xmath147 is removed ) . also , @xmath164 is set to @xmath48 .",
    "the rule com - pop1 for @xmath196 is enabled only if @xmath203 is empty ( i.e. , all the values added by pushes ending before @xmath44 , if any , have been removed ) .",
    "then , @xmath164 is set to @xmath221 .",
    "[ t ]    let @xmath222 be the standard abstract implementation of a stack ( where elements are stored in a sequence ; push , resp . , pop operations add , resp .",
    ", remove , an element from the beginning of the sequence in one atomic step ) . for @xmath61 ,",
    "the alphabet of @xmath222 is @xmath105 .",
    "the following result states that the library @xmath183 has exactly the same set of histories as @xmath222 ( see appendix  [ app : absimplstack ] for a proof ) .",
    "[ th : absimplstack ] @xmath183 is a refinement of @xmath222 and vice - versa .",
    "a trace of a stack implementation is called _",
    "@xmath193-complete _ when every completed pop has a commit point , i.e. , each return @xmath223 is preceded by an action @xmath191 .",
    "a stack implementation @xmath50 over @xmath1 , such that @xmath224 , is called _ with fixed pop commit points _ when every trace @xmath107 is @xmath193-complete .    as a consequence of theorem",
    "[ th : forsim ] , @xmath194-forward simulations are a sound and complete proof method for showing the correctness of a stack implementation with fixed pop commit points ( up to the correctness of the commit points ) .",
    "a stack @xmath50 with fixed pop commit points is a @xmath194-refinement of @xmath183 iff there is a @xmath194-forward simulation from @xmath50 to @xmath183 .",
    "linearization points can also be seen as commit points and thus the following holds .",
    "a stack implementation @xmath50 with fixed pop linearization points where transition labels @xmath181 are substituted with @xmath191 is a @xmath194-refinement of @xmath222 iff there is a @xmath194-forward simulation from @xmath50 to @xmath183 .",
    "we describe a forward simulation @xmath225 from @xmath182 to @xmath183 . except for the constraints on the components @xmath226 and @xmath227 of a @xmath183 state , it is similar to the simulation @xmath145 from @xmath110 to @xmath111 .",
    "thus , the @xmath183 states @xmath228 associated by @xmath225 to a @xmath182 state @xmath25 satisfy the following .",
    "the set @xmath215 consists of all the identifiers of pushes in @xmath25 which did nt added yet a node to pools or for which the input is still present in pools ( i.e. , the node created by the push has taken set to false ) .",
    "a push @xmath44 is labeled by @xmath157 where @xmath48 is the input value if it s pending and by @xmath158 , otherwise .    to describe the order relation @xmath146 we consider the following notations : @xmath229 , resp . ,",
    "@xmath230 , denotes the timestamp of the node created by the push @xmath44 in state @xmath25 ( the ts field of this node ) , resp .",
    ", the i d of the thread executing @xmath44 . by an abuse of terminology ,",
    "we call @xmath229 the timestamp of @xmath44 in state @xmath25",
    ". also , @xmath231 when intuitively , a traversal of pools would encounter the node created by @xmath44 before the one created by @xmath147 .",
    "more precisely , @xmath231 when @xmath232 , or @xmath233 and the node created by @xmath147 is reachable from the one created by @xmath44 in the list pointed to by @xmath234 $ ]",
    ". the order relation @xmath146 satisfies the following : ( 1 ) pending pushes are maximal , ( 2 ) @xmath146 is consistent with the order between node timestamps , i.e. , @xmath235 implies @xmath148 , and ( 3 ) @xmath146 includes the order between pushes executed in the same thread , i.e. , @xmath233 and @xmath236 implies @xmath237 .    the components @xmath226 and @xmath227 satisfy the following constraints ( their domain is the set of identifiers of pending pops ) :    * a pop @xmath44 with @xmath238 that reached a node with timestamp @xmath45 ( its variable n points to this node ) overlaps with every push that created a node with a timestamp bigger than @xmath45 and which occurs in pools before the node reached by @xmath44 , i.e. , @xmath239 , @xmath240 , @xmath241 , @xmath242 , and @xmath243 implies @xmath244 , for each @xmath245 * a pop @xmath44 with @xmath246 overlaps with every push that created a node which occurs in pools before the node reached by @xmath44 , i.e. , @xmath247 , @xmath240 , @xmath241 , and @xmath242 implies @xmath244 , for each @xmath245 * if the variable youngest of a pop @xmath44 points to a node which is not taken , then this node was created by a push in @xmath248 or the node currently reached by @xmath44 is followed in pools by another node which was created by a push in @xmath248 , i.e. , @xmath249 , @xmath250 , and @xmath251 implies @xmath252 or that there exists @xmath253 such that @xmath254 , @xmath255 , and either @xmath256 or @xmath257 and todo @xmath44 is traversing the last list in the array pools , for each @xmath258    there are some more constraints on @xmath226 and @xmath227 that can be seen as invariants of @xmath183 , i.e. , @xmath203 and @xmath218 do nt contain predecessors of pushes from @xmath203 ( for each @xmath245 , @xmath259 and @xmath260 implies @xmath261 ) .",
    "they can be found in appendix  [ app : tss ] .    finally , for every pop operation @xmath44 such that @xmath262 , we have that @xmath263 .",
    "the proof that @xmath225 is indeed a forward simulation from @xmath182 to @xmath183 follows the same lines as the one given for the herlihy&wing queue .",
    "it can be found in appendix  [ app : tss ] .",
    "many techniques for linearizability verification , e.g. ,  @xcite , are based on forward simulation arguments , and typically only work for libraries where the linearization point of every invocation of a method @xmath47 is fixed to a particular statement in the code of @xmath47 .",
    "the works in  @xcite deal with _ external _ linearization points where the action of an operation @xmath44 can be the linearization point of a concurrently executing operation @xmath147 .",
    "we say that the linearization point of @xmath147 is external .",
    "this situation arises in read - only methods like the contains method of an optimistic set  @xcite , libraries based on the elimination back - off scheme , e.g. ,  @xcite , or flat combining  @xcite . in these implementations , an operation can do an update on the shared state that becomes the linearization point of a concurrent read - only method ( e.g. , a contains returning true may be linearized when an add method adds a new value to the shared state ) or an operation may update the data structure on behalf of other concurrently executing operations ( whose updates are published in the shared state ) . in all these cases ,",
    "every linearization point can still be associated syntactically to a statement in the code of a method and does nt depend on operations executed in the future ( unlike @xmath110 and @xmath182 ) . however , identifying the set of operations for which such a statement is a linearization point can only be done by looking at the whole program state ( the local states of all the active operations ) .",
    "this poses a problem in the context of compositional reasoning ( where auxiliary variables are required ) , but still admits a forward simulation argument . for manual proofs , such implementations with external linearization points",
    "can still be defined as ltss that produce @xmath104-complete traces and thus still fall in the class of implementations for which forward simulations are enough for proving refinement .",
    "these proof methods are not complete and they are not able to deal with implementations like @xmath110 or @xmath182 .",
    "there also exist linearizability proof techniques based on backward simulations or alternatively , prophecy variables , e.g. ,  @xcite .",
    "these works can deal with implementations where the linearization points are not fixed , but the proofs are conceptually more complex and less amenable to automation .    the works in",
    "@xcite propose reductions of linearizability to assertion checking where the idea is to define finite - state automata that recognize violations of concurrent queues and stacks .",
    "these automata are simple enough in the case of queues and there is a proof of @xmath110 based on this reduction  @xcite .",
    "however , in the case of stacks , the automata become much more complicated and we are not aware of a proof for an implementation such as @xmath182 which is based on this reduction .",
    "programs interact with libraries by calling named library _ methods _ , which receive _ parameter values _ and yield _ return values _ upon completion .",
    "we fix arbitrary sets @xmath33 and @xmath34 of method names and parameter / return values .",
    "we fix an arbitrary set @xmath35 of operation identifiers , and for given sets @xmath33 and @xmath34 of methods and values , we fix the sets @xmath264 of _ call actions _ and _ return actions _ ; each call action @xmath37 combines a method @xmath38 and value @xmath39 with an _ operation identifier _ @xmath40 .",
    "operation identifiers are used to pair call and return actions .",
    "we assume every set of words is closed under isomorphic renaming of operation identifiers .",
    "we denote the operation identifier of a call / return action @xmath41 by @xmath265 .",
    "call and return actions @xmath266 and @xmath267 are _ matching _ , written @xmath268 , when @xmath269 .",
    "we may omit the second field from a call / return action @xmath41 for methods that have no inputs ( e.g. , the pop method of a stack ) or return values ( e.g. , the push method of a stack ) .",
    "a word @xmath270 over alphabet @xmath271 , such that @xmath272 , is _",
    "well formed _ when :    * each return is preceded by a matching call : + @xmath273 implies @xmath274 for some @xmath275 . *",
    "each operation identifier is used in at most one call / return : + @xmath276 and @xmath275 implies @xmath274 .",
    "we say that the well - formed word @xmath270 is _ sequential _ when    * operations do not overlap : + @xmath277 and @xmath278 implies @xmath274 for some @xmath279 .",
    "well - formed words represent traces of a library .",
    "we assume every set of well - formed words is closed under isomorphic renaming of operation identifiers . for notational convenience ,",
    "we take @xmath42 for the rest of the paper . when the value of a certain field in a call / return action is not important we use the placeholder @xmath280 , e.g. , @xmath281 instead of @xmath37 when the input @xmath48 can take any value .",
    "an operation @xmath44 is called _ completed _ in a well - formed trace @xmath45 when @xmath46 occurs in @xmath45 , for some @xmath47 and @xmath48 .",
    "otherwise , it is called _",
    "pending_. libraries dictate the execution of methods between their call and return points .",
    "accordingly , a library can not prevent a method from being called , though it can decide not to return .",
    "furthermore , any library action performed in the interval between call and return points can also be performed should the call have been made earlier , and/or the return made later .",
    "a library thus allows any sequence of invocations to its methods made by _",
    "some _ program .",
    "[ def : libraries ] a _ library _ @xmath50 is an lts over alphabet @xmath1 such that @xmath43 and each trace @xmath282 is well formed , and    * call actions @xmath266 can not be disabled : + @xmath283 implies @xmath284 if @xmath285 is well formed .",
    "* call actions @xmath266 can not disable other actions : + @xmath286 implies @xmath287 .",
    "* return actions @xmath288 can not enable other actions : + @xmath289 implies @xmath290 .",
    "note that even a library that implements _ atomic methods _",
    ", e.g. ,  by guarding method bodies with a global - lock acquisition , admits executions in which method calls and returns overlap . for simplicity",
    ", definition  [ def : libraries ] assumes that every thread performs a single operation .",
    "the extension to multiple operations per thread is straightforward , e.g. the closure rules must assume that the actions @xmath41 and @xmath291 belong to different threads",
    "we define a class of forward / backward simulations , called _ normal simulations _ , that are used in the proofs in appendix  [ app : absimplqueue ] and appendix  [ app : absimplstack ] .",
    "[ def : for_app ] let @xmath74 and @xmath75 be two libraries over alphabets @xmath76 and @xmath77 , respectively , such that @xmath78 , and @xmath21 a set of actions such that @xmath79 .",
    "a relation @xmath85 is called a _ normal @xmath21-forward simulation _ from @xmath66 to @xmath67 iff the following holds :    * @xmath86 = \\{s_0 ^ 2 \\}$ ] * if @xmath292 , for some @xmath293 , and @xmath89 $ ] , then there exists @xmath90 $ ] such that @xmath91 , @xmath294 , and @xmath295 , for each @xmath296 . *",
    "if @xmath297 , for some @xmath298 , and @xmath89 $ ] , then there exists @xmath90 $ ] such that @xmath91 , @xmath299 , and @xmath295 , for each @xmath300 . *",
    "if @xmath301 , for some @xmath302 , and @xmath303 $ ] , then there exists @xmath304 $ ] such that @xmath305 . *",
    "if @xmath95 , for some @xmath96 and @xmath89 $ ] , then there exists @xmath90 $ ] such that @xmath97 and @xmath98 .    with normal @xmath21-forward simulations , a step of @xmath66 labeled by a call , resp . , return , action is simulated by a sequence of steps of @xmath67 that start , resp",
    ". , end , with the same action , and a step of @xmath66 labeled by another observable action should be matched by a step of @xmath67 labeled by the same action .",
    "the rest of the transitions in @xmath66 are matched to a possibly empty sequence of transitions of @xmath67 with arbitrary labels .",
    "a dual notion of forward simulation is the backward simulation :    [ def : back_app ] let @xmath74 and @xmath75 be two libraries over a common alphabet @xmath1 , and @xmath29 a set of actions such that @xmath306 .",
    "a relation @xmath307 is called a _ normal @xmath21-backward simulation _ from @xmath66 to @xmath67 iff the following holds :    * @xmath308 = \\{s_0 ^ 2 \\}$ ] * if @xmath292 , for some @xmath293 , and @xmath309 $ ] , then there exists @xmath310 $ ] such that @xmath91 , @xmath294 , and @xmath311 , for each @xmath296 . *",
    "if @xmath312 , for some @xmath298 , and @xmath309 $ ] , then there exists @xmath310 $ ] such that @xmath91 , @xmath299 , and @xmath311 , for each @xmath300 . *",
    "if @xmath313 , for some @xmath302 , and @xmath309 $ ] , then there exists @xmath310 $ ] such that @xmath314 * if @xmath95 for some @xmath315 and @xmath309 $ ] , then there exists @xmath310 $ ] such that @xmath91 and @xmath98 .",
    "[ t ]    we show that @xmath111 and @xmath109 refine each other .",
    "we start by giving a formal definition of the standard reference implementation @xmath109 .",
    "thus , the states of @xmath109 are tuples @xmath316 where @xmath317 is a sequence of values , @xmath318 records the input value of an enqueue , @xmath319 records the return value of a dequeue fixed at its linearization point ( @xmath134 denotes a partial function ) , and @xmath320 records the control point of every enqueue ( @xmath321 ) or dequeue operation ( @xmath137 ) . all the components are @xmath138 in the initial state , and the transition relation @xmath139 is defined in fig .",
    "[ fig : transitions : absq_0 ] .",
    "the alphabet of @xmath111 contains call / return actions and enqueue / dequeue linearization points .    to prove that @xmath111 is a refinement of @xmath109 we define a normal @xmath144-backward simulation ( i.e , a backward simulation as in definition  [ def : back_app ] ) from @xmath111 to @xmath109 .",
    "the reverse is shown using a normal @xmath144-forward simulation ( i.e , a forward simulation as in definition  [ def : for_app ] ) .",
    "@xmath111 is a refinement of @xmath109 .",
    "we define a normal @xmath144-backward simulation @xmath322 from @xmath111 to @xmath109 as follows .",
    "given an @xmath111 state @xmath323 and an @xmath109 state @xmath324 we have that @xmath325 iff the following hold :    * the sequence @xmath326 is a linearization of a partial order @xmath327 where @xmath328 contains values labeling elements of @xmath215 and all the values corresponding to completed enqueues , i.e. , @xmath329 ordered according to the happens - before order between the enqueues that added them , i.e. , @xmath330 iff there exists @xmath331 such that @xmath332 , @xmath333 , and @xmath259 .",
    "* the return values fixed at dequeue linearization points are the same , i.e. , for every @xmath44 , @xmath334 , * every dequeue is at the same control point in both @xmath25 and @xmath161 , i.e. , for every @xmath44 and @xmath335 , @xmath336 iff @xmath337 , * every pending enqueue has the same input value in both @xmath25 and @xmath161 ,",
    "i.e. , for every @xmath44 , @xmath338 , * a pending enqueue from @xmath215 has been linearized whenever its value is contained in @xmath326 , i.e. , for every @xmath44 , @xmath339 if @xmath340 and @xmath341 , * a pending enqueue from @xmath215 hasnt been linearized whenever its value is not in @xmath326 , i.e. , for every @xmath44 , @xmath342 iff @xmath343 and @xmath341 , * a pending enqueue which is not in @xmath215 has been linearized , i.e. , for every @xmath44 , @xmath339 if @xmath344 and @xmath345 , * an enqueue is completed in @xmath25 whenever it is completed in @xmath161 , i.e. , for every @xmath44 , @xmath346 iff @xmath347 ,    for the conditions described above , if we fix the set @xmath328 and @xmath348 , then the state @xmath161 related to @xmath25 becomes unique .",
    "we use this fact in the proof . in some places , we only give @xmath328 , @xmath348 and @xmath25 without explicitly defining @xmath161 or show that there exists @xmath161 with the given @xmath348 that is related to @xmath25 by just finding a @xmath328 such that @xmath348 is a linearization of @xmath349 where @xmath350 is induced from @xmath351 .    or",
    "@xmath348 and not describing @xmath161 explicitly .    in the following , we show that indeed @xmath322 is a normal @xmath144-backward simulation from @xmath111 to @xmath109 .    * @xmath352 = \\ { s^{absq_0}_0 \\}$ ] .",
    "* let @xmath353 and @xmath354 $ ] .",
    "either @xmath355 or not .",
    "+ first consider the former case .",
    "we know that @xmath356 and @xmath44 is maximal in @xmath27 .",
    "hence @xmath357 where @xmath358 contains linearization of pending elements in @xmath359 .",
    "then , pick @xmath360 .",
    "we can find such a @xmath361 $ ] with @xmath348 .",
    "let @xmath349 be the partial order that is used while constructing @xmath362 from @xmath363 and @xmath351 .",
    "we can find @xmath364 for relating @xmath25 to @xmath161 such that @xmath365 does not contain the values of pending elements that formed @xmath358 suffix of @xmath366 and @xmath48 coming from linearization of @xmath367 .",
    "+ one can also see that @xmath368 where @xmath369 such that @xmath370 and @xmath371 are the pending elements that are linearized to form @xmath358 .",
    "note that @xmath372 obeys the definition of normal backward simulation definition .",
    "+ for the second case , pick @xmath161 such that @xmath373 .",
    "we can find a @xmath161 with @xmath348 related to @xmath25 by @xmath322 using the same @xmath327 partial order that is used while relating @xmath27 to @xmath166 .",
    "@xmath374 holds because @xmath375 .",
    "* let @xmath376 and @xmath354 $ ] .",
    "pick @xmath161 such that it is equal to @xmath166 in every field except that @xmath377 .",
    "then , @xmath361 $ ] and @xmath378 .",
    "* let @xmath379 , @xmath354 $ ] and @xmath380 .",
    "we pick @xmath161 such that @xmath381 .",
    "we first show that @xmath361 $ ] .",
    "let @xmath349 be the partial order that is linearized to obtain @xmath362 and @xmath382 be the element such that @xmath383 .",
    "we know that @xmath147 is minimal in @xmath351 due to the premise of the rule lin - deq1 .",
    "hence , we can obtain @xmath364 such that @xmath384 and @xmath348 is a linearization of it .",
    "+ in addition , @xmath385 . the action @xmath140 is enabled in state @xmath161 since @xmath48 is the minimum element of @xmath348 . note that the transition relating @xmath161 to @xmath166 obeys the definition of normal forward simulation .",
    "* let @xmath386 and @xmath354 $ ] .",
    "we pick @xmath349 for relating @xmath25 to @xmath161 such that @xmath387 .",
    "such a @xmath328 is a valid choice since all the elements @xmath363 are pending .",
    "then , @xmath388 is the only linearization of @xmath349 .",
    "hence , @xmath389 action is enabled in @xmath109 and @xmath390 holds .",
    "* let @xmath391 , @xmath392 and @xmath354 $ ] .",
    "assume @xmath349 be the partial order of which linearization is @xmath362 .",
    "pick @xmath393 .",
    "then , @xmath394 holds since @xmath395 and @xmath396 .",
    "construct @xmath361 $ ] such that @xmath373 is obtained by linearizing the partial order @xmath397 .",
    "then , @xmath398 holds and it is a valid action with respect to normal backward - simulation relation definition .",
    "* let @xmath391 , @xmath399 and @xmath354 $ ] .",
    "since @xmath400 and @xmath375 , we can pick @xmath401 where @xmath349 is the strict partial order such that @xmath362 is its linearization . construct @xmath361 $ ] such that @xmath373 is obtained by linearizing the partial order @xmath397 . then",
    ", @xmath398 holds and it is a valid action with respect to normal backward - simulation relation definition .",
    "* let @xmath402 and @xmath354 $ ] .",
    "assume @xmath403 is the partial order of which linearization is @xmath362 .",
    "construct @xmath361 $ ] such that @xmath373 and @xmath404 is the partial order @xmath348 is obtained from .",
    "@xmath405 since @xmath375 and @xmath400 .",
    "then , @xmath406 holds .",
    "we have @xmath407 since @xmath361 $ ] .",
    "hence the @xmath142 is enabled in @xmath161 .",
    "moreover , @xmath142 is a valid transition with respect to the normal backward simulation relation definition .",
    "@xmath109 is a refinement of @xmath111 .",
    "we define a normal @xmath144-forward simulation @xmath408 from @xmath109 to @xmath111 as follows . given @xmath109 state @xmath324 and an @xmath111 state @xmath323 we have that @xmath409 iff the following hold :    * the sequence @xmath326 is a linearization of a partial order @xmath327 where @xmath328 contains values labeling elements of @xmath215 and all the values corresponding to completed enqueues , i.e.",
    ", @xmath329 ordered according to the happens - before order between the enqueues that added them , i.e. , @xmath330 iff there exists @xmath331 such that @xmath332 , @xmath333 , and @xmath259 . *",
    "every dequeue is at the same control point in both @xmath25 and @xmath161 , i.e. , for every @xmath44 and @xmath335 , @xmath336 iff @xmath337 , * every enqueue is pending in @xmath25 whenever it is pending in @xmath161 , i.e. , for every @xmath44 , @xmath345 iff @xmath410 , * every enqueue is completed in @xmath25 whenever it is completed in @xmath161 , i.e. , for every @xmath44 , @xmath346 iff @xmath411 , * every pending enqueue which is not linearized or whose value is present in @xmath326 is a member of @xmath215 , i.e. , for every @xmath44 , @xmath412 * every completed enqueue whose value is present in @xmath326 is a member of @xmath215 , i.e. , for every @xmath44 , @xmath413 * pending enqueues are maximal in @xmath146 , i.e. , for every @xmath44 and @xmath147 , @xmath155 if @xmath341 , * the return values fixed at dequeue linearization points are the same , i.e. , for every @xmath44 , @xmath334 .    in the following ,",
    "we show that indeed @xmath408 is a normal @xmath144-forward simulation from @xmath109 to @xmath111 .",
    "* @xmath414 = \\{s_0^{absq}\\}$ ] * let @xmath415 and @xmath416 $ ] .",
    "then , @xmath417 is an enabled action in @xmath111 since premise of call - enq holds in @xmath161 and @xmath416 $ ] .",
    "obtain @xmath27 such that @xmath353 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 .",
    "+ next , we show that @xmath419 $ ] .",
    "let @xmath349 be the partial order used while relating @xmath161 to @xmath25 .",
    "same partial order can be used while relating @xmath420 to @xmath166 since @xmath421 , @xmath422 and @xmath423 .",
    "the only change we have in control point fields after the actions is that @xmath424 and @xmath425 which satisfies the conditions on @xmath408 .",
    "moreover @xmath44 is a maximal pending node in @xmath166 as required by the @xmath408 conditions .",
    "consequently , @xmath419 $ ] .",
    "* let @xmath426 and @xmath416 $ ] .",
    "then , @xmath427 is an enabled action in @xmath111 since premise of call - deq holds in @xmath161 and @xmath416 $ ] .",
    "obtain @xmath27 such that @xmath428 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 .",
    "+ next , we show that @xmath419 $ ] . since @xmath429 , @xmath400 and @xmath421 , we can pick same @xmath327 partial order in @xmath27 and show that @xmath362 is a linearization of it .",
    "the only change in control points after the transitions is that @xmath430 which does not violate any condition in @xmath408 .",
    "consequently , @xmath419 $ ] .",
    "* let @xmath431 and @xmath416 $ ] .",
    "then , pick @xmath432 such that @xmath433 .",
    "note that @xmath8 is a valid transition with respect to the normal forward simulation relation definition .",
    "we show that @xmath434 $ ] .",
    "if @xmath349 is the partial order in @xmath25 of which one linearization is @xmath348 , we pick @xmath435 .",
    "@xmath364 can be linearized to @xmath362 since @xmath44 is a maximal pending node and can be linearized at the end . moreover , the only change in control point @xmath436 which does not violate the @xmath408 conditions . *",
    "let @xmath385 , @xmath380 and @xmath416 $ ] .",
    "then , @xmath140 is an enabled action in @xmath111 .",
    "there must exist @xmath437 such that @xmath383 and @xmath147 is minimal in @xmath328 ( since @xmath48 is linearized as the minimum element in @xmath348 according to premise of lin - deq1 of @xmath111 ) .",
    "obtain @xmath27 such that @xmath379 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 .",
    "+ next , we show that @xmath419 $ ] .",
    "let @xmath349 be the partial order used while relating @xmath161 to @xmath25 such that @xmath348 is a linearization of this partial order .",
    "since we have shown that @xmath147 is minimal in that partial order , @xmath362 is a linearization of @xmath364 where @xmath438 .",
    "note that @xmath439 holds .",
    "the only change in control points is that @xmath440 which does not violate the conditions for relating @xmath166 to @xmath27 .",
    "note that the fifth condition of @xmath408 still holds for @xmath147 while relating @xmath166 to @xmath27 .",
    "after transitions @xmath441 and the last condition on @xmath408 is preserved .",
    "* let @xmath390 and @xmath416 $ ] .",
    "then , @xmath140 is an enabled action in @xmath111 .",
    "if @xmath442 , then @xmath328 use for linearization can not be @xmath138 @xmath443 can not be a linearization of @xmath349 .",
    "obtain @xmath27 such that @xmath386 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 .",
    "+ next , we show that @xmath419 $ ] .",
    "let @xmath349 be the partial order used while relating @xmath161 to @xmath25 such that @xmath444 is a linearization of this partial order .",
    "we can use the same @xmath349 for relating @xmath166 to @xmath27 because @xmath326 field is the same for both @xmath25 , @xmath27 ; and @xmath215 , @xmath146 , @xmath445 fields are same for both @xmath161 and @xmath166 .",
    "the only change in control points is that @xmath440 which does not violate the conditions for relating @xmath166 to @xmath27 .",
    "after transitions @xmath441 and the last condition on @xmath408 is preserved .",
    "* let @xmath398 and @xmath416 $ ] . then , there are two cases assuming data independence : ( i ) @xmath446 and @xmath447 ( ii ) or not .",
    "+ first , consider the former case .",
    "then , ret - enq1 rule of @xmath448 is applicable .",
    "its precondition holds since fifth condition of @xmath408 holds while relating @xmath161 to @xmath25 .",
    "apply this rule ( @xmath449 ) to obtain @xmath27 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 and it is a valid action according to the normal forward - simulation relation definition . + next , we show that @xmath419 $ ] . since @xmath450 , we know that @xmath451 where @xmath349 is the partial order satisfying first condition of @xmath408 while relating @xmath161 to @xmath25 , and @xmath452 takes part in the linearization i.e. , @xmath453 .",
    "we can use the same partial order @xmath327 for relating @xmath166 to @xmath27 such that it satisfies the first condition of @xmath408 . the only change in control points",
    "is that @xmath454 which does not violate the conditions for relating @xmath166 to @xmath27 .",
    "note that the sixth condition of @xmath408 also continue to hold for @xmath44 for the post - states .",
    "+ second , consider the latter case : @xmath446 , but @xmath455 . since @xmath456 , @xmath399 by the fifth and sixth conditions",
    "hence , the pre - condition of ret - enq2 is satisfied by @xmath161 .",
    "apply this rule ( @xmath449 ) to obtain @xmath27 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 and it is a valid action according to the normal forward - simulation relation definition .",
    "+ next , we show that @xmath419 $ ] . for satisfying the first condition",
    ", one can use the same @xmath349 partial order that is used for relating pre - states since @xmath326 fields of @xmath161 , @xmath166 and @xmath215 , @xmath146 , @xmath445 fields of @xmath25 and @xmath27 are the same . the only change in control points",
    "is that @xmath454 which does not violate the conditions for relating @xmath166 to @xmath27 .",
    "* let @xmath406 and @xmath416 $ ] .",
    "then , @xmath142 is an enabled action in @xmath111 due to premise ret - deq of @xmath109 and the last condition on @xmath408 ( since @xmath456 ) .",
    "obtain @xmath27 such that @xmath402 .",
    "note that @xmath27 is unique since @xmath111 is deterministic with respect to @xmath418 .",
    "+ we see that @xmath419 $ ] .",
    "pre - states are equal to the post - states with the only exception in the control points such that @xmath457 .",
    "all the conditions except the third one continues to hold in the post states since they hold in the pre - states .",
    "the third rule regarding the control points of dequeues also continue to the hold since changes in the control point of @xmath44 does not violate it .",
    "we show that @xmath183 and @xmath222 refine each other .",
    "the standard reference implementation @xmath222 is defined exactly as the one for queues , @xmath109 , except that pop linearization points extract values from the beginning of the sequence stored in the state .",
    "[ t ]    thus , the states of @xmath222 are tuples @xmath316 where @xmath317 is a sequence of values , @xmath318 records the input value of a push , @xmath319 records the return value of a pop fixed at its linearization point ( @xmath134 denotes a partial function ) , and @xmath320 records the control point of every push ( @xmath321 ) or pop operation ( @xmath137 ) . all the components are @xmath138 in the initial state , and the transition relation @xmath139 is defined in fig .",
    "[ fig : transitions : abss_0 ] .",
    "the alphabet of @xmath183 contains call / return actions and push / pop linearization points .    to prove that @xmath183 is a refinement of @xmath222 we define a normal @xmath49-backward simulation ( i.e , a backward simulation as in definition  [ def : back_app ] ) from @xmath183 to @xmath222 .",
    "the reverse is shown using a normal @xmath49-forward simulation ( i.e , a forward simulation as in definition  [ def : for_app ] ) .",
    "@xmath183 is a refinement of @xmath222 .",
    "we define a normal @xmath49-backward simulation @xmath322 from @xmath183 to @xmath222 as follows .",
    "given an @xmath183 state @xmath323 and an @xmath222 state @xmath324 we have that @xmath325 iff the following hold :    * if a pop has committed or respectively , it has returned in @xmath25 , then it had been linearized or respectively , it has returned in @xmath161 , i.e. , for every @xmath44 , if @xmath458 then @xmath459 , * a push is completed in @xmath25 whenever the same is true in @xmath161 , i.e. , for every @xmath44 , @xmath346 iff @xmath347 , * a push is pending in @xmath25 iff either it is a non - linearized pending push in @xmath161 or its linearization point has been executed , i.e. , for every @xmath44 , @xmath345 iff @xmath342 and @xmath460 does nt occur in @xmath326 , or @xmath461 , * if a pop did nt commit in @xmath25 then it is pending in @xmath161 and it may have been linearized , i.e. , for every @xmath44 , if @xmath462 then @xmath463 , * there exists a partial injective function @xmath464 which associates uncommitted pops to pushes in @xmath215 such that : * * for every @xmath44 , @xmath465 iff @xmath466 * * the sequence @xmath326 is the mirror of a linearization of a partial order @xmath327 where @xmath328 contains values labeling elements of @xmath215 except for those in the range of @xmath467 , and all the values corresponding to completed pushes which are not in the range of @xmath467 , i.e. , @xmath468 ordered according to the happens - before order between the pushes that added them , i.e. , @xmath330 iff there exists @xmath331 such that @xmath332 , @xmath333 , and @xmath259 * * every pop in the domain of @xmath467 has been linearized , i.e. , for every @xmath44 , @xmath465 implies @xmath469 , * * every pop which is not in the domain of @xmath467 hasnt been linearized , i.e. , for every @xmath44 , @xmath470 implies @xmath471 , * * every push in the range of @xmath467 has been linearized , i.e. , for every @xmath44 , @xmath472 implies @xmath339 , * * a pending enqueue from @xmath215 has been linearized when its value is contained in @xmath326 , i.e. , for every @xmath44 , if @xmath340 and @xmath341 , then @xmath339 .",
    "* the return values fixed at pop commit points are the same , i.e. , for every @xmath44 , if @xmath164 is defined , then @xmath334 , * every pending push has the same input value in both @xmath25 and @xmath161 , i.e. , for every @xmath44 , @xmath338 ,    in the following , we show that indeed @xmath322 is a normal @xmath49-backward simulation from @xmath183 to @xmath222 :    * let @xmath473 be a transition in @xmath183 and @xmath474 .",
    "we consider two cases depending on whether the value @xmath48 occurs on a position @xmath5 in the sequence @xmath326 of @xmath166 or not .",
    "if it occurs , let @xmath161 be a @xmath222 state where essentially , the component @xmath326 is the prefix of the sequence @xmath326 of @xmath166 that contains the first @xmath475 positions ( except for some set of pushes that will be defined hereafter , all operations are at the same control point ) .",
    "let @xmath20 be the following @xmath222 trace : @xmath476 where @xmath477 is the value on position @xmath152 in the sequence @xmath326 of @xmath166 and @xmath478 is the length of this sequence ( we assume that positions are indexed starting from @xmath168 ) .",
    "let @xmath479 .",
    "for every @xmath480 with @xmath481 , we must have that @xmath482 in @xmath166 .",
    "we take @xmath483 in @xmath161 for every @xmath484 and @xmath485 undefined for @xmath486 .",
    "we have that @xmath487 is a valid sequence of transitions of @xmath222 and @xmath325 ( the latter can be proved by taking the same function @xmath467 used in establishing that @xmath474 ) .",
    "now , assume that the value @xmath48 is not in the sequence @xmath326 of @xmath166 .",
    "we consider an @xmath222 state @xmath161 where the component @xmath326 is the same as the one in @xmath166 .",
    "there are two sub - cases depending on whether there exists a pending pop @xmath147 such that @xmath488 when establishing that @xmath474 .",
    "if it exists , the operations are at the same control point in both @xmath161 and @xmath166 except for the push @xmath44 for which @xmath489 is undefined in @xmath161 , and the the pop @xmath147 for which we take @xmath490 in @xmath161 .",
    "we have that @xmath491 in @xmath222 .",
    "if there exists no such pop @xmath147 , it can be easily seen that there exists @xmath161 such that @xmath492 and @xmath325 .",
    "* let @xmath493 be a transition in @xmath183 and @xmath474 .",
    "we consider two cases depending on whether in the function @xmath467 used to relate @xmath27 to @xmath166 we have that @xmath465 .",
    "in other words , either the newly invoked pop operation @xmath44 did not linearize yet ( @xmath470 ) or it linearizes and removes an element inserted by a linearized push ( @xmath465 ) .",
    "the second case also splits into two sub - cases : the value removed by pop @xmath44 is inserted by a push @xmath494 that is still pending or the push has returned .",
    "we will look at all three cases separately .",
    "the easiest one is the first case .",
    "there exists some @xmath161 where essentially the component @xmath326 is the same as the one in @xmath166 , such that @xmath495 and @xmath325 .",
    "+ for the first sub - case of the second case , we take an @xmath222 state @xmath161 where @xmath496 ( we use @xmath348 to denote the component @xmath326 in @xmath161 ) .",
    "it must happen that @xmath497 .",
    "the operations are at the same control point in both @xmath161 and @xmath166 , except for @xmath44 in which case @xmath498 is undefined .",
    "we have that @xmath499 and @xmath325 .",
    "the latter holds because essentially , @xmath147 is a maximal node in @xmath27 ( since it is pending ) .",
    "+ for the second sub - case , we define an @xmath222 state @xmath161 where the sequence @xmath326 is the minimal prefix of @xmath362 that includes the value @xmath48 added by @xmath147 .",
    "let @xmath5 be the index of this value in @xmath362 and @xmath500 with @xmath501 the identifiers of the pushes that added the values following @xmath48 in @xmath362 .",
    "let @xmath20 be the following @xmath222 trace : @xmath502 where @xmath477 is the value on position @xmath152 in the sequence @xmath362 and @xmath478 is the length of this sequence .",
    "we have that @xmath487 is a valid sequence of transitions of @xmath222 and @xmath325 .",
    "the latter relies on the fact that @xmath147 is a greatest completed push in @xmath25 and all pushes @xmath480 with @xmath503 are pending in @xmath25 .",
    "* let @xmath504 be a transition in @xmath183 and @xmath474 .",
    "when this transition results in removing a greatest completed push or a pending push in @xmath25 , then there exists an @xmath222 state @xmath161 such that @xmath487 is a valid sequence of @xmath222 transitions and @xmath325 , for some @xmath161 and @xmath20 defined as in the second case of @xmath505 .",
    "when it removes a completed push which is followed by other completed pushes ( in the happens - before in @xmath25 ) , then we pick @xmath506 .",
    "we have that @xmath507 and @xmath325 ( for the latter we must choose a function @xmath467 such that @xmath508 where @xmath147 is the push removed by the @xmath183 transition .",
    "* let @xmath509 be a transition in @xmath183 and @xmath474 .",
    "we consider two cases depending on whether the happens - before in @xmath25 contains push @xmath44 .",
    "if it contains push @xmath44 , there are two sub - cases : ( 1 ) if its input is present in @xmath362 then there exists an @xmath222 state @xmath161 such that @xmath510 is a valid sequence of @xmath222 transitions and @xmath325 , and ( 2 ) otherwise , we take a state @xmath161 where essentially , @xmath496 for which we have that @xmath511 and @xmath325 .",
    "if the happens - before in @xmath25 does nt contain push @xmath44 , then there exists an @xmath222 state @xmath161 such that @xmath510 . * the case of pop returns @xmath512 is trivial .",
    "such transitions are simulated by @xmath512 transitions of @xmath222 .",
    "@xmath222 is a refinement of @xmath183 .",
    "we define a normal @xmath49-forward simulation @xmath408 from @xmath222 to @xmath183 as follows .",
    "given an @xmath222 state @xmath324 and an @xmath183 state @xmath323 we have that @xmath409 iff the following hold :    1 .",
    "every pop is at the same control point in both @xmath161 and @xmath25 , i.e. , for every @xmath44 and @xmath335 , @xmath337 iff @xmath336 , 2 .",
    "a push has been invoked in @xmath161 whenever it has been invoked in @xmath25 , i.e. , for every @xmath44 , @xmath342 iff @xmath345 , 3 .",
    "a push which is linearized in @xmath161 has been invoked in @xmath25 , i.e. , for every @xmath44 , if @xmath339 then @xmath513 , 4 .",
    "a push is completed in @xmath161 iff the same holds in @xmath25 , i.e. , for every @xmath44 , @xmath347 iff @xmath346 , 5 .",
    "the pair @xmath514 in @xmath25 satisfies the following : * for every @xmath44 , if @xmath515 , @xmath410 , and @xmath48 occurs in @xmath326 , then @xmath516 and @xmath517 , * for every @xmath44 , if @xmath515 , @xmath411 , and @xmath48 occurs in @xmath326 , then @xmath516 and @xmath518 , 6 .",
    "every pending push in @xmath215 is overlapping with every non - linearized pop , i.e. , for every @xmath44 , if @xmath471 then @xmath519 .",
    "every completed push is either overlapping or was the greatest completed push before a non - linearized pop started , i.e. , for every @xmath44 , if @xmath471 , then @xmath520 , 8 .   for every push that overlaps with a pop @xmath44 or was maximal in @xmath146 when @xmath44 started , its successors are overlapping with @xmath44 , i.e. , @xmath252 and @xmath259 implies @xmath521 for each @xmath245 9 .   predecessors of pushes in @xmath203 for a given pop @xmath44 are neither overlapping with @xmath44 nor in @xmath203 , i.e. , @xmath259 and @xmath522 implies @xmath523 for each @xmath524 10 .",
    "pending pushes are maximal in @xmath146 , for every @xmath44 and @xmath147 , @xmath155 if @xmath341 , 11 .",
    "[ item : stack_fs_lin ] the sequence @xmath326 is the mirror of a linearization of a partial order @xmath327 where @xmath328 contains values labeling elements of @xmath215 and all the values corresponding to completed pushes , i.e. , @xmath329 ordered according to the happens - before order between the pushes that added them , i.e. , @xmath330 iff there exists @xmath331 such that @xmath332 , @xmath333 , and @xmath259 . 12 .",
    "the return values fixed at pop linearization / commit points are the same , i.e. , for every @xmath44 , @xmath334 , 13 .",
    "every pending push has the same input value in both @xmath25 and @xmath161 , i.e. , for every @xmath44 , @xmath338 ,    in the following , we show that indeed @xmath408 is a normal @xmath49-backward simulation from @xmath222 to @xmath183 :    * let @xmath492 be a transition in @xmath222 and @xmath409 .",
    "we have that @xmath525 where @xmath473 ( recall that @xmath183 is deterministic ) . since the push @xmath44 is non - linearized in @xmath166 , the component @xmath326 of both @xmath161 and @xmath166 are the same and @xmath341 in @xmath27",
    "then , the component @xmath326 in @xmath526 states related by @xmath408 to @xmath27 is allowed to exclude values added by pushes in @xmath27 which are labeled as pending .",
    "the effect of @xmath527 in @xmath183 implies that @xmath44 overlaps with all pending pops .",
    "* let @xmath495 be a transition in @xmath222 and @xmath409 .",
    "we have that @xmath525 where @xmath493 .",
    "the only difference between @xmath25 and @xmath27 is that the components @xmath203 and @xmath218 in @xmath27 contain the greatest completed pushes in @xmath25 and the pending pushes in @xmath25 , respectively ( these components were undefined in @xmath25 ) .",
    "the relation @xmath408 does nt exclude this particular choice for @xmath203 and @xmath218 when applied to @xmath166 and @xmath27 .",
    "* let @xmath528 be a transition in @xmath526 and @xmath409 .",
    "we have that @xmath529 , i.e. , the @xmath222 transition is simulated by an empty sequence of @xmath183 transitions , because essentially the component @xmath326 of @xmath166 still corresponds to a linearization of the pushes in @xmath25 according to item [ item : stack_fs_lin ] in the definition of @xmath408 .",
    "the sequence @xmath326 in @xmath166 contains the value added by the push @xmath44 at the end , but this is allowed by @xmath408 since @xmath44 is labeled as pending in @xmath25 .",
    "* let @xmath530 be a transition in @xmath222 and @xmath409 .",
    "we have that @xmath525 where @xmath504 . the transition labeled by @xmath191",
    "is enabled in @xmath222 because @xmath48 was the first value in the sequence @xmath326 of @xmath161 .",
    "indeed , this implies that @xmath48 was added by a push @xmath147 which is maximal in the happens - before stored in @xmath25 .",
    "this clearly implies that @xmath531 .",
    "in addition , the sequence @xmath326 in @xmath166 does correspond to a linearization of the pushes in @xmath27 ( which do nt contain @xmath44 anymore ) because @xmath326 in @xmath161 had this property with respect to @xmath25 and @xmath326 in @xmath166 is obtained by deleting the first value in the sequence @xmath326 of @xmath161 .",
    "* let @xmath510 be a transition in @xmath222 and @xmath409 .",
    "we have that @xmath525 where @xmath509 .",
    "there are two cases depending on whether the value added by @xmath44 is still present in the sequence @xmath326 of @xmath161 .",
    "if it is not , then the push @xmath44 does nt occur in the happens - before from @xmath25 , and the only effect of these two transitions is changing the control point of @xmath44 .",
    "therefore , @xmath525 clearly holds . when this value is still present , the effect of @xmath532 in @xmath183 is changing the flag of push @xmath44 from @xmath533 to @xmath534 . since",
    "the order between pushes does nt change , we have that @xmath525 . *",
    "let @xmath535 be a transition in @xmath222 and @xmath409 .",
    "we have that @xmath525 where @xmath536 .",
    "this case is obvious , the only change between @xmath25 and @xmath27 being the control point of @xmath44 .",
    "the lts corresponding to the description of @xmath537 given in fig .",
    "[ fig : timestamped ] is defined as usual .",
    "the control points and transition labels we use in the following proof are pictured in fig .",
    "[ fig : tssflow ] . to simplify the proof , we take the initializations of some local variables together as atomic .    states of the ts - stack contains the global variables and local variables as fields .",
    "global variables are just elements of their domains and local variables are maps from operation identifiers to their domains .",
    "we say @xmath538 for referencing the value of local variable @xmath5 of operation @xmath44 in state @xmath539 .",
    "there is only one special local variable called @xmath540 .",
    "its value is unique to each pending operation in a state i.e. , concurrent operations can not have the same @xmath540 value .",
    "ts - stack states also contains sets @xmath541 which are operation identifier sets of push and pops respectively , and the control point function @xmath485 which is a map from operation identifiers to the control points set that are presented in the flow diagram figure  [ fig : tssflow ] .",
    "transition relation of the ts - stack is presented in figure  [ fig : transitions : tsspush ] ( push rules ) and figure  [ fig : transitions : tsspop ] ( pop rules ) .",
    "next , we show that the linearizability of ts stack",
    ".            let us make some clarifications before defining the relation . in order not to confuse nodes in ts stack and nodes in @xmath183 ,",
    "we call nodes of @xmath183 as vertices from now on . we also define ordering relation ( called traverse order ) among the operations in a state of @xmath542 .",
    "it basically reflects the traverse order of pop operations . for two push operations @xmath543",
    "is state @xmath25 we say that @xmath544 iff either @xmath545 or @xmath546 and @xmath547 is reachable from @xmath548 using next pointers .",
    "@xmath549 is obtained from @xmath550 in the usual way .      *",
    "@xmath553 iff @xmath44 is a push operation in @xmath25 ( @xmath554 ) such that either it has not inserted its node to the pool yet ( @xmath555 and @xmath556 ) or its node is not taken by a pop ( @xmath555 , @xmath557 and @xmath558 ) . *",
    "a vertex @xmath553 is pending ( @xmath559 ) iff @xmath44 satisfies the previous condition , @xmath560 and it is not completed in @xmath25 ( @xmath555 and @xmath561 ) .",
    "similarly , this vertex is completed ( @xmath562 ) iff @xmath44 satisfies the previous condition , @xmath560 and it is completed in @xmath25 ( @xmath563 ) . pending vertices are maximal with respect to @xmath564 i.e. , if @xmath553 is a pending vertex , then for all @xmath565 @xmath566 . *",
    "if a node has a smaller timestamp than the other node in @xmath25 , the operations that inserted them can not be ordered reversely in @xmath161 .",
    "more formally , let @xmath567 s.t . @xmath568 .",
    "then , @xmath569 .",
    "* order among the nodes inserted by the same threads in @xmath25 must be preserved among the operations that inserted them in @xmath161 .",
    "let @xmath567 s.t .",
    "@xmath570 and @xmath571 .",
    "then , @xmath572 . * every maximally closed or pending vertex can be removed by a pending pop .",
    "more formally , let @xmath553 such that @xmath573 . then , for all pops @xmath574 , @xmath575 .",
    "in the other case , let @xmath553 such that @xmath576 and for all other @xmath565 such that @xmath577 , we know @xmath578 . then , for all pop operations @xmath574 , @xmath579 or @xmath575 . *",
    "if a push @xmath553 is a candidate to be removed by a pop @xmath574 , then every other push @xmath147 invoked after @xmath44 is a candidate to be removed by @xmath574 since @xmath44 is concurrent with @xmath574 .",
    "more formally , let @xmath567 such that @xmath572 and there exists a pop @xmath574 such that @xmath579 or @xmath575 . then , @xmath580 .",
    "* if a push @xmath553 has finished before the pop @xmath574 is invoked and yet @xmath44 is a candidate to be removed by @xmath574 , other pushes completed before @xmath44 can not be candidates to be removed by @xmath574 at that state .",
    "more formally , let @xmath567 such that @xmath572 and there exists a pop @xmath574 such that @xmath581 .",
    "then , neither @xmath579 nor @xmath582 . * if all immediate followers @xmath565 of a push @xmath553 are concurrent with pop @xmath574 , then @xmath44 is either concurrent or maximally closed with respect to @xmath574 .",
    "more formally , let @xmath553 and for all @xmath565 such that @xmath583 , @xmath580 , where @xmath574 is a pop operation . then , @xmath584 . *",
    "if a pop @xmath574 is after its commit point action in @xmath25 , then the @xmath585 value of this operation in @xmath161 is fixed to @xmath586 .",
    "more formally , let @xmath574 be the pop operation such that @xmath587 and @xmath588 .",
    "then , @xmath589 . *",
    "if a pop operation @xmath574 is currently visiting node @xmath478 , it has non - null node @xmath120 as the @xmath590 and there is a non - null not taken node @xmath47 coming before @xmath478 in the traverse order with a greater timestamp than @xmath120 , then the operation that inserts @xmath47 must be concurrent with @xmath574 .",
    "more formally , assume @xmath591 and @xmath592 .",
    "let @xmath553 such that @xmath593 , @xmath594 , @xmath595 and @xmath596 .",
    "then , @xmath575 . *",
    "if a pop operation @xmath574 is currently visiting node @xmath478 , and its @xmath590 field is ` null ` , then every other node @xmath47 coming before @xmath478 in the traverse order must be concurrent with @xmath574 .",
    "more formally , let @xmath597 and assume there exists an operation @xmath553 such that @xmath593 , @xmath594 and @xmath595",
    ". then , @xmath575 .",
    "* if a pop operation @xmath574 is currently visiting node @xmath478 that is not null and its youngest element @xmath47 is not null and still not taken in state @xmath25 , then either @xmath47 is a candidate to be removed by @xmath574 in @xmath161 or there exists a later node @xmath598 than @xmath478 such that @xmath598 is a candidate in @xmath161 and it has a bigger timestamp than n. more formally , assume that there exists @xmath567 such that @xmath599 , @xmath600 and @xmath601 .",
    "then , either @xmath602 or there exists @xmath603 s.t .",
    "@xmath604 and @xmath605 and either @xmath606 or @xmath607 .",
    "next , we will show that @xmath225 is really a @xmath194-forward simulation relation . except the trivial base case , we case - split on the transition rules .",
    "we first assume @xmath608 and @xmath609 $ ] .",
    "then , we find corresponding transition @xmath610 obeying the @xmath194-forward simulation relation conditions and obtain @xmath166 such that @xmath611 and @xmath612 $ ] .",
    "let the following describe @xmath372 : @xmath616 where @xmath617 is the precondition ( guard ) that needs to be satisfied for enabling @xmath372 and @xmath618 describe the @xmath619 if @xmath620 ( equivalently @xmath614 ) .    for the cases @xmath614 , we first need to show @xmath619",
    "is enabled in state @xmath161 i.e. , @xmath161 satisfies @xmath621 .",
    "if this can not be directly obtained from the information that @xmath25 satisfies @xmath617 and using one or two obvious conditions on @xmath225 ( since @xmath609 $ ] ) , we show the derivation in the proof .",
    "then , @xmath166 is obtained in a unique way since @xmath183 is deterministic on its alphabet @xmath622 .",
    "the , only other thing to show is @xmath623 $ ] .",
    "we show this by proving that @xmath166 does not violate any of the conditions of the @xmath225 described above .",
    "suppose conditions on @xmath225 are of the form @xmath624 where the @xmath625 is a vector of operation identifiers and @xmath626 defined on states @xmath25 and @xmath161 must hold if the guard defined on @xmath25 and @xmath161 holds .",
    "we say that a vector @xmath627 is a new instantiation of the condtion if @xmath627 does not satisfy the @xmath628 while relating pre - states , but it satisfies @xmath629 while relating post - states .",
    "we only explain why the new instantiations due to the difference between @xmath27 and @xmath25 or the difference between @xmath166 and @xmath161 do not violate the conditions .",
    "we skip the instances that we assumed while relating @xmath25 to @xmath161 .    for the cases in which @xmath615 , we have @xmath630 and the only thing to show is @xmath631 $ ] . again",
    ", we only explain why the new instantiations due to the difference between @xmath27 and @xmath25 do not violate the conditions .",
    "* @xmath633 = \\{{q_0}_{abss}\\}$ ] * the same derivation rule of @xmath537 is applied to @xmath161 to obtain @xmath166 .",
    "the premise of the rule is satisfied by @xmath161 trivially in the sense explained before .",
    "the new vertex @xmath44 is added to the @xmath634 such that @xmath44 is maximal , pending and every completed vertex is ordered before @xmath44 in @xmath166 .",
    "moreover , @xmath44 is overlapping with every pending pop . to see that @xmath612 $ ] we observe the following : _ nodes _ condition is preserved because @xmath635 .",
    "since the newly added vertex @xmath44 is maximal and pending in @xmath166 , _ pend / comp _ condition is preserved .",
    "_ frontiers _ and _",
    "maximalov _ conditions are not violated since @xmath44 is added to @xmath636 set for every pending pop operation @xmath574 . * we have @xmath637 and show @xmath631$]._nodes _ and _ pend / comp _ conditions are still satisfied since @xmath44 remains to be a pending vertex .",
    "_ tsorder _ is still preserved .",
    "timestamp of @xmath638 is maximal and every other nodes of push operations with maximal timestamp in @xmath27 are pending vertices in @xmath161 . hence there can be no ordering between those pushes and @xmath44 in @xmath161 that can violate _",
    "moreover , @xmath44 is maximal in @xmath161 which means that it can not be ordered before another push @xmath147 of which node has a lower timestamp .",
    "_ tidorder _ is also satisfied .",
    "since @xmath44 is ordered after every completed push in @xmath161 and every other push by the same thread is completed , ordering required by the _ tidorder _",
    "is present .",
    "* we have @xmath637 and show @xmath631 $ ] . _ nodes _ and _ pend / comp _ conditions are still satisfied since @xmath44 remains to be a pending vertex .",
    "one can also see that the _ traversebefore _ condition is preserved .",
    "let the pop @xmath574 visiting node @xmath47 and @xmath639 .",
    "since @xmath44 and @xmath574 are both pending in @xmath25 and @xmath609 $ ] , @xmath575 ( by the _ frontiers _ condition ) .",
    "hence , _ traversebefore _ is preserved .",
    "* we have @xmath637 and show @xmath631 $ ] .",
    "we consider two cases : @xmath640 is ` true ` or it is ` false ` .",
    "for the former case , @xmath641 .",
    "the only new instantiation we check is @xmath641 does not violate _ nodes _ condition while relating @xmath27 to @xmath161 .",
    "+ for the latter case , we have @xmath553 . _",
    "nodes _ and _ pend / comp _ conditions are still satisfied since @xmath44 remains to be a pending vertex after changing @xmath25 to @xmath27 .",
    "* we have @xmath637 and show @xmath631 $ ] .",
    "+ we consider two cases : @xmath640 is ` true ` or it is ` false ` . for the former case , _ nodes _ condition is still satisfied since @xmath44 remains to be not a vertex . + for the latter case _ nodes _ and _ pend / comp _ conditions are still satisfied since @xmath44 remains to be a pending vertex . _",
    "tsorder _ condition is still not violated since if @xmath642 , then @xmath147 is a completed vertex in @xmath25 and @xmath27 . by the premise of the rule ( which can be shown to hold for every operation at control point @xmath643 ) @xmath644 and consequently @xmath645 .",
    "since every other push by the thread of @xmath44 is completed , _ tidorder _ still continues to hold for the same reasons .",
    "_ traverseafter _ condition is also preserved .",
    "let @xmath147 be the push and @xmath574 be the pop such that @xmath646 , @xmath647 , @xmath648 and @xmath575 or @xmath579 .",
    "assume @xmath649 after the action .",
    "then , @xmath147 must be a pending push both in @xmath25 and @xmath27 by the premise of the derivation rule and @xmath580 must be true by _ frontiers _ condition and @xmath609 $ ] .",
    "hence , the _ traverseafter _ condition is preserved .",
    "* we consider two cases , @xmath640 is ` false ` or ` true ` .",
    "for the former case , we obtain @xmath166 by applying ret - push1 rule of @xmath183 . _ nodes _ and _ pend / comp _ conditions are still satisfied since @xmath44 becomes a completed vertex in @xmath166 .",
    "_ frontiers _ condition still holds since although @xmath44 become a maximally closed vertex in @xmath166 , we have @xmath650 for all pending nodes @xmath574 ( due to _ frontiers _ condition , @xmath609 $ ] and @xmath44 was a pending operation in state @xmath161 , @xmath575 ) . + for the latter case , we obtain @xmath166 by applying ret - push2 rule of @xmath183 .",
    "_ nodes _ condition is still satisfied since @xmath651 . * the same derivation rule of @xmath537 is applied to @xmath161 to obtain @xmath166 .",
    "_ frontiers _ condition holds for @xmath652 relating @xmath27 to @xmath166 since @xmath653 for every pending vertex @xmath147 and @xmath654 for all completed vertex @xmath655 .",
    "@xmath166 due to action @xmath505 applied on @xmath161 .",
    "_ maximalov _ condition holds for @xmath652 since pending vertices are maximal in @xmath166 and for any maximally closed vertex @xmath147 in @xmath166 , if @xmath147 is ordered before other vertex @xmath655 , then @xmath655 is a pending operation by definition of being maximally closed and @xmath656 due to the changes by inv - pop action on @xmath161 .",
    "_ minimalbe _ condition holds while relating @xmath27 to @xmath166 for the pop @xmath657 because only maximally closed vertices are in @xmath203 and if a push @xmath147 is ordered before a maximally closed push @xmath655 in @xmath161 , neither @xmath658 ( since @xmath655 is not maximally closed ) nor @xmath659 ( since @xmath655 can not be pending ) .",
    "_ reversefrontiers _ condition holds while relating @xmath27 to @xmath166 for the pop @xmath660 because , if @xmath661 for all immediate successors of @xmath147 in @xmath161 , then @xmath662 are pending vertices ( due to _ call - pop _ action of @xmath183 ) , @xmath147 is a maximally closed vertex and @xmath663 ( due to _ call - pop _ action of @xmath183 ) .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* we have @xmath637 and show @xmath631 $ ] .",
    "_ traversebefore _ condition while relating @xmath27 to @xmath161 still holds for @xmath660 .",
    "assume @xmath664 is a non - null node .",
    "then , for all nodes @xmath47 in @xmath27 such that @xmath665 we have @xmath666 in @xmath27 because @xmath667 ( since @xmath668 is added to the pool after @xmath47 by the same thread ) and @xmath669 in @xmath27 ( since either @xmath670 or @xmath671 ) .",
    "_ traverseafter _ does not have any new instatiations since the guard mentions the nodes after @xmath668 while relating @xmath25 to @xmath161 whereas it mentions nodes after or including @xmath638 which contains the all nodes in the former case .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* we have @xmath637 and show @xmath631 $ ] . _ traversebefore _ condition while relating @xmath27 to @xmath161 still holds for @xmath660 since @xmath672 and _ traversebefore _ holds while relating @xmath25 to @xmath161 .",
    "+ _ traverseafter _ condition also continues to hold for @xmath660 .",
    "there are two possible cases : @xmath673 or not .",
    "+ first , consider the former case . since _",
    "traversebeforenull _ is satisfied while relating @xmath25 to @xmath161 , for every operation @xmath674 such that @xmath675 and @xmath676 we have @xmath656 .",
    "consider all such @xmath655 such that @xmath677 .",
    "if there exists such a @xmath655 such that @xmath678 , then @xmath679 since _ reversefrontiers _ condition holds relating @xmath25 to @xmath161 . otherwise , either @xmath147 is maximal in @xmath161 or all the vertices @xmath680 ordered after @xmath147 in @xmath161 we have @xmath681 .",
    "then , either @xmath147 or one of these @xmath680 vertices must be maximal in @xmath161 and must be in @xmath682 since _ frontiers _ condition holds ( one of them is maximal in @xmath161 ) while relating @xmath25 to @xmath161 .",
    "+ second , assume there exists push operations @xmath683 such that @xmath684 and @xmath685 . since _",
    "traversebefore _ is satisfied while relating @xmath25 to @xmath161 , if there exists a push @xmath675 such that @xmath686 is not taken and @xmath687 , then @xmath656 .",
    "then , for all @xmath675 such that @xmath686 is not taken and @xmath688 , then @xmath656 since @xmath689 .",
    "if there exists such a @xmath655 such that @xmath678 , then @xmath679 since _ reversefrontiers _ condition holds relating @xmath25 to @xmath161 . otherwise , either @xmath147 is maximal in @xmath161 or all the vertices @xmath680 ordered after @xmath147 in @xmath161 we have @xmath681 .",
    "then , either @xmath147 or one of these @xmath680 vertices must be maximal in @xmath161 and must be in @xmath682 since _ frontiers _ condition holds ( one of them is maximal in @xmath161 ) while relating @xmath25 to @xmath161 .",
    "* we have @xmath637 and show @xmath631 $ ] .",
    "_ traverseafter _ continues to hold while relating @xmath27 to @xmath161 for @xmath660 .",
    "let @xmath674 such that @xmath690 , @xmath691 and @xmath692 .",
    "note that @xmath606",
    ". then , @xmath693 since @xmath694 and @xmath695 ( @xmath696 can not be ` max_int ` since @xmath147 would be pending and @xmath697 otherwise ) .",
    "hence , there exists another push @xmath152 such that @xmath698 and @xmath699 .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* @xmath166 is obtained by applying com - pop1 rule of @xmath183 .",
    "we first show that precondition of com - pop1 rule of @xmath183 si satisfied by @xmath161 . if @xmath191 removes a node @xmath478 such that there exists a push @xmath147 such that @xmath700 in @xmath25 , then @xmath565 since it is non - null and not taken .",
    "moreover , @xmath679 since _ traverseafter _ is preserved while relating @xmath25 to @xmath161 and all the nodes that come after @xmath668 in terms of traverse order in @xmath25 have lower timestamp values than @xmath701 and @xmath702 . + next , we show that @xmath612 $ ] .",
    "we case split on the conditions of @xmath225 considering new instantiations .",
    "+ _ nodes _ condition is still preserved after @xmath44 removes the node pushed by operation @xmath147 in @xmath25 since @xmath703 anymore by due to @xmath191 action .",
    "+ _ frontiers _",
    "condition is still preserved if @xmath44 removes the vertex @xmath147 and makes another @xmath655 maximally closed in @xmath161 .",
    "since all the other nodes @xmath152 ordered after @xmath655 ( except possibly @xmath147 ) in @xmath161 are pending , @xmath704 ( due to _ frontiers _ condition while relating @xmath25 to @xmath161 ) for some pending pop @xmath705 .",
    "then , @xmath654 by @xmath191 action .",
    "+ for the _ minimalbe _ condition , we do not have a new instance . if @xmath706 becomes true although @xmath707 , we can not have @xmath708 such that @xmath709 and @xmath654 since @xmath191 does not add @xmath655 to @xmath636 if its successor is not pending with respect to @xmath574",
    ". + _ reversefrontiers _ condition is still preserved .",
    "if @xmath44 removes the vertex @xmath147 and there exists an immediate predecessor @xmath655 of @xmath147 such that all of immediate successors of @xmath655 are in @xmath710 , then @xmath711 due to the action @xmath191 .",
    "+ _ traverseafter _ condition is still preserved after @xmath44 removes the node of push @xmath147 .",
    "let @xmath705 be another pop operation such that @xmath712 for some push @xmath152 and @xmath713 be the only node such that @xmath714 and @xmath713 comes after @xmath715 in the traverse order of @xmath25 and @xmath716 .",
    "hence , there is no @xmath655 such that @xmath686 comes after @xmath715 in the traverse order and @xmath717 except @xmath147 ( i ) .",
    "in other direction , if for all @xmath603 such that @xmath686 comes before @xmath715 in the traverse order and @xmath718 , then @xmath719 since _ traversebefore _ condition holds while relating @xmath25 to @xmath161 . then , for all @xmath603 such that @xmath686 comes before @xmath715 in the traverse order of @xmath25 and @xmath720 implies @xmath719 since @xmath721 if @xmath720 ( ii ) .",
    "then , for all @xmath603 such that if @xmath720 , then @xmath719 except @xmath147 due to ( i ) and ( ii ) . if @xmath722 , then @xmath723 since _ reversefrontiers _ hold while relating @xmath25 to @xmath161 and @xmath724 after applying the action @xmath191",
    "otherwise , if @xmath725 , then @xmath726 after applying @xmath191 .",
    "+ _ fixreturn _ condition continues to hold .",
    "if @xmath191 removes the node pushed by @xmath147 in @xmath25 , then @xmath191 removes the vertex @xmath147 ( assuming data independece ) and @xmath727 .",
    "then , @xmath728 after applying commit actions at both sides .",
    "* we have @xmath637 and @xmath631 $ ] .",
    "* @xmath166 is obtained by applying ret - pop rule of @xmath183 and @xmath612 $ ] ."
  ],
  "abstract_text": [
    "<S> linearizability is the standard correctness criterion concurrent data structures such as stacks and queues . </S>",
    "<S> it allows to establish observational refinement between a concurrent implementation and an atomic reference implementation . </S>",
    "<S> proving linearizability requires identifying linearization points for each method invocation along all possible computations , leading to valid sequential executions , or alternatively , establishing forward _ and _ backward simulations . in both cases , carrying out proofs is hard and complex in general . in particular , </S>",
    "<S> backward reasoning is difficult in the context of programs with data structures , and strategies for identifying statically linearization points can not be defined for all existing implementations . in this paper , we show that , contrary to common belief , many such complex implementations , including , e.g. , the herlihy&wing queue and the time - stamped stack , can be proved correct using only forward simulation arguments . </S>",
    "<S> this leads to simple and natural correctness proofs for these implementations that are amenable to automation . </S>"
  ]
}