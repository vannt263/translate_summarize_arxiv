{
  "article_text": [
    "protecting the privacy of information is becoming a crucial concern to many users of the increasingly ubiquitous information and communication technologies .",
    "companies invest a lot of effort into keeping secret their internal costs and their future development strategies from other actors on the market , most importantly from their competitors .",
    "individuals also have a need for privacy of their personal information : for instance , carelessly disclosing one s activity schedule or location might reveal to burglars opportunities to break into one s home . on the other hand , accessing and using such private information is often necessary to solve problems that depend on these data . in the context of supply chain management , companies need to exchange information with their contractors and subcontractors about the quantities of goods that must be produced , and at what price .",
    "when scheduling meetings or various events with friends or co - workers , individuals are confronted with the challenge of taking coordinated scheduling decisions , while protecting their respective availability schedules .    artificial intelligence can be a crucial tool to help people make better decisions under privacy concerns , by delegating part or all of the decision problem to personal _ intelligent agents _ executing carefully chosen algorithms that are far too complex to be performed by the human alone .",
    "in particular , the framework of _ constraint satisfaction problems ( csps ) _ is a core ai technology that has been successfully applied to many decision - making problems , from configuration to scheduling , to solving strategic games .",
    "here we show how distributed ai algorithms can be used to solve such csps , while providing strong guarantees on the privacy of the problem knowledge , through the use of techniques borrowed from cryptography .",
    "this makes it possible to solve coordination problems that depend on secret data , without having to reveal these data to other parties . on the other hand , distributed , encrypted computation involving message exchange",
    "has a cost in terms of performance , such that a suitable tradeoff between privacy and scalability must be found .      in this paper",
    ", we present a set of novel , privacy - protecting algorithms for _ distributed constraint satisfaction problems ( discsps ) _ , a wide class of multi - agent decision - making problems with applications to many problems such as configuration , scheduling , planning , design and diagnosis .",
    "we consider three examples to illustrate the privacy requirements that might arise : _ meeting scheduling _",
    ", _ airport slot allocation _ , and _ computing game equilibria_.    in a meeting scheduling problem @xcite , a number of meetings need to be scheduled , involving possibly overlapping sets of participants . taking into account their respective availability constraints ,",
    "all participants to any given meeting must agree on a time for the meeting .",
    "one given participant can be involved in multiple meetings , which creates constraints between meetings . in this problem class , participants usually want to protect the privacy of their respective availability schedules , as well as the lists of meetings they are involved in .    another problem class is airport slot allocation @xcite , where airlines express interests in combinations of takeoff and landing time slots at airports , corresponding to possible travel routes for their aircraft .",
    "while the end goal for the airports is to efficiently allocate their slots to airlines , from the point of view of the airlines it is crucial that the combinations of slots they are interested in remain private , because they indicate the routes they intend to fly , which is sensitive strategic information that they want to hide from their competitors .    finally , consider the general class of one - shot strategic games , such as the _ party game _",
    "@xcite : the players are invited to a party , and must decide whether to attend , based on their respective intrinsic costs of attendance , and on whether the people they like or dislike also choose to attend .",
    "players would best play strategies that form a _",
    "nash equilibrium _",
    ", where no single player can be better off by deviating from its chosen strategy .",
    "the problem of computing such an equilibrium is a typical example of a multi - agent decision - making problem , in which privacy is an issue : players do not necessarily want to reveal their attendance costs , nor whether they like or dislike another invitee .",
    "as can be seen in the previous examples , the information that participants would like to keep private can differ in nature ; we propose to classify it into four privacy types .",
    "we only briefly introduce and illustrate them here ; more formal definitions are given in section  [ sec : privacy_defs ] .    1 .",
    "_ agent privacy _ relates to the identities of the participants .",
    "consider for instance a ceo who wants to schedule two meetings respectively with a journalist and with another company s ceo .",
    "revealing to the journalist the other ceo s involvement in the decision - making problem could leak out the companies plans to merge . in this case agent privacy can be considered critical .",
    "_ topology privacy _ covers information about the _ presence _ of constraints .",
    "this is the type of critical information that airline companies want to keep secret in the airport slot allocation problem : the presence of a constraint between an airline and a specific airport reveals the airline s strategic plans to offer flights to and from this airport .",
    "constraint privacy _ is about the _ nature _ of the constraints .",
    "this covers for instance the participants availability schedules in the meeting scheduling problem , and , in the party game , whether a player likes or dislikes other invitees .",
    "4 .   _ decision privacy _ has to do with the solution that is eventually chosen to the problem .",
    "depending on the problem class , this type of privacy may or may not be relevant . in the meeting scheduling problem , the time chosen for each meeting necessarily has to be revealed to all participants of the meeting ; however it can be desirable to hide this information from non - attendees .    like in previous work on privacy in discsp , we assume that the participants are _ honest , but curious _",
    "@xcite , in that they honestly follow the algorithm , but are interested in learning as much as possible from other agents private information based on the messages exchanged .",
    "note that this honesty assumption does not mean that all agents are assumed to faithfully report their true constraints to the algorithm ; they may be tempted to strategize by reporting slightly different constraints , hoping that this would lead the algorithm to select a solution to the problem that they deem preferable to them .",
    "this issue of _ incentive - compatibility _ has been addressed in related work such as by @xcite , and is orthogonal to the issue of privacy addressed in this paper .",
    "furthermore , an agent would take a risk in reporting constraints different from its true constraints : reporting relaxed constraints could yield a solution that violates its true constraints and would therefore not be viable , while reporting tighter constraints could make the overall problem infeasible and the algorithm fail to find any solution at all .",
    "on the other hand , our algorithms depart from previous work in two respects .",
    "first , previous work almost exclusively focused on constraint privacy , most often ignoring agent , topology and decision privacy .",
    "we show how to address all four types , and the algorithms we propose correspond to various points in the tradeoff between different levels of privacy and efficiency .",
    "second , while most of the literature focuses on _ quantitatively measuring and reducing _ the amount of privacy loss in various discsp algorithms , we have developed algorithms that give _ strong guarantees _ that certain pieces of private information will not be leaked . in contrast , in previous privacy - protecting algorithms , it is typically the case that any piece of private information may be leaked with some ( small ) probability .",
    "the rest of this paper is organized as follows .",
    "section  [ sec : preliminaries ] first formally defines the discsp framework and the four aforementioned types of privacy .",
    "section  [ sec : p_dpop ] then presents a first algorithm , called _",
    "p - dpop@xmath0_. section  [ sec : p_dpop_value ] then describes the _",
    "p@xmath1-dpop@xmath0 _ algorithm , which is a variant that achieves a higher level of decision privacy , at the expense of an additional computational overhead .",
    "another variant , called _ p@xmath2-dpop@xmath0 _",
    ", is introduced in section  [ sec : elgamal_utilpropagation ] in order to further improve constraint privacy .",
    "finally , section  [ sec : results ] compares the performance of these algorithms with the previous state of the art , on several classes of benchmarks .",
    "this section first formally defines the discsp framework ( section  [ sec : discsp ] ) , and then introduces four types of privacy ( section  [ sec : prelim : privacy ] ) .      after providing a formal definition of distributed constraint satisfaction ( section  [ sec : discspdef ] )",
    ", we recall some existing algorithms for discsp and its optimization variant ( section  [ sec : algos ] ) .",
    "a distributed constraint satisfaction problem can be formally defined as follows .",
    "a discrete _ discsp _ is a tuple @xmath3 :    * @xmath4 is a set of _ agents _ ; * @xmath5 is a set of _ variables _ ; * @xmath6 is a mapping that assigns the control of each variable @xmath7 to an agent  @xmath8 ; * @xmath9 is a set of finite variable _ domains _ ; variable  @xmath7 takes values in  @xmath10 ; * @xmath11 is a set of _ constraints _ , where each @xmath12 is a @xmath13-ary function of scope @xmath14 , @xmath15 , assigning @xmath16 to infeasible tuples , and @xmath17 to feasible ones .",
    "[ def : dcop ]    a _ solution _ is a complete assignment such that the conjunction @xmath18 , which is the case exactly when the assignment is consistent with all constraints .",
    "some of the important assumptions of the discsp framework are the following .",
    "first , we assume that all the details of a given constraint  @xmath12 are known to all agents involved ; if an agent wants to keep some constraints private , it should formulate them in such a way that they only involve variables it controls .",
    "furthermore , we assume that two neighboring agents ( i.e. agents that share at least one constraint ) are able to communicate with each other securely , and that messages are delivered in fifo order and in finite time . on the other hand ,",
    "we assume that two non - neighboring agents initially ignore everything about each other , even including their involvement in the problem .",
    "in particular , a discsp algorithm that protects _ agent privacy _ should not require them to communicate directly , nor should it even allow them to discover each other s presence .",
    "finally , we assume each agent honestly follows the protocol , and we focus on preventing private information leaks to other agents .",
    "= [ circle , draw = black , thick , fill = white , minimum size = 0.7 cm , inner sep=0pt , draw ]    ( x2 ) at ( 0 , 0 ) @xmath19 ; ( x3 ) at ( 2 , 0 ) @xmath20 ; ( x2 )  ( x3 ) [ thick ] ; at ( 1 , -.25 ) @xmath21 ;    ( x5 ) at ( 4 , 0 ) @xmath22 ; ( x3 )  ( x5 ) [ thick ] ; at ( 3 , -.25 ) @xmath21 ; at ( 5.12 , 0 ) @xmath23 ;    ( x1 ) at ( 0 , 2 ) @xmath24 ; ( x2 )  ( x1 ) [ thick ] ; at ( -.25 , 1 ) @xmath21 ; at ( -.75 , 2 ) @xmath25 ;    ( x4 ) at ( 2 , 2 ) @xmath26 ; ( x1 )  ( x4 ) [ thick ] ; at ( 2.75 , 2 ) @xmath27 ; at ( 1 , 2.25 ) @xmath21 ;    ( x4 )  ( x3 ) [ thick ] ; at ( 2.25 , 1 ) @xmath21 ;    figure  [ fig : constraint_graph ] introduces a simple graph coloring problem instance that will be used to illustrate the algorithms throughout the rest of this paper .",
    "we assume that the five nodes in the graph correspond to five different agents , which must each choose a color among red , blue and green .",
    "these decisions are modeled by the five variables @xmath28 with domains @xmath29 .",
    "each agent may express a secret , unary constraint on its variable ; for instance , @xmath24  does not want to be assigned the color red .",
    "binary , inequality constraints are imposed between each pair of neighboring nodes , and are only known to the two agents involved .    _ distributed constraint optimization ( dcop ) _ is an extension of the discsp formalism , in which constraints specify not only which variable assignments are feasible or infeasible , but also assign _ costs _ ( or _ utilities _ ) to these assignments .",
    "an ( optimal ) solution to such a dcop is then one that minimizes the sum of all costs ( or maximizes the sum of all utilities ) .",
    "the algorithms in this paper can easily be generalized to solve dcops , with a complexity increase that is at most linear in an upper bound on the ( assumed integer ) cost of the optimal solution .",
    "such a generalization is left outside the scope of this paper for the sake of conciseness , and has been addressed by @xcite and @xcite .",
    "a range of distributed algorithms exist in the literature to solve discsps and dcops .",
    "they can be seen as belonging to two classes , depending on how they order variables .",
    "the largest class consists of algorithms that order the variables along a _ linear order _ , such as _ abt _",
    "@xcite , _ awc _  @xcite , synchbb  @xcite , _ aas _  @xcite , afc @xcite , disfc  @xcite , _ ( comp)apo _ @xcite , concdb @xcite , afb  @xcite and concfb @xcite . the linear order may be chosen and fixed initially before the algorithm is run , or dynamically revised online .    in the second class",
    ", variables are ordered along a tree - based _",
    "partial order_. this includes _ adopt _",
    "@xcite and its variants such as bnb - adopt @xcite and bnb - adopt@xmath0 @xcite , _ dpop _  @xcite and its countless variants , and ncbb  @xcite , which all order the variables following a _ pseudo - tree _",
    "( definition  [ def : dfs ] ) . among the aforementioned pseudo - tree - based algorithms ,",
    "dpop is the only one using _",
    "dynamic programming ( dp ) _ , while all others are based on _",
    "search_. other algorithms have been proposed that perform dp on different partial variable orders : action - gdl uses _ junction trees _",
    "@xcite , and dcte _ cluster trees _ @xcite .",
    "the dpop algorithm was originally designed to solve optimization problems ( dcops ) and described in terms of utility maximization .",
    "one way to apply it to pure satisfaction problems ( discsps ) is to first reformulate the discsp into a _",
    "max - discsp _ , in which the constraints are no longer boolean but rather take values in @xmath30 , where @xmath31  stands for feasibility and @xmath32  for infeasibility . the cost - minimizing variant of dpop ( described below ) can then be applied to find a solution with minimal cost , where the cost ( hereafter called _ feasibility value _ ) corresponds to the number of constraint violations ( which we want to be equal to  @xmath31 ) .",
    "a pseudo - tree ordering of the variables ; @xmath33 denotes @xmath34 s parent    [ algo : dpop : utilpropagation ]    @xmath35 [ algo : dpop : utilpropagation : local_join ]    wait for the message ( feas , @xmath36 ) from @xmath37 [ algo : dpop : utilpropagation : get_message ] @xmath38 [ algo : dpop : utilpropagation : separator ] @xmath39 [ algo : dpop : utilpropagation : join ]    @xmath40 [ algo : dpop : utilpropagation : argmin ]    send the message ( feas , @xmath41 ) to @xmath33 [ algo : dpop : utilpropagation : sendutil ] * else * @xmath42 [ algo : dpop : utilpropagation : root_value ]    [ algo : dpop : valuepropagation_start ] wait for message ( decision , @xmath43 ) from parent @xmath33 @xmath44 [ algo : dpop : lookup ] * for * each @xmath45 * do * send message ( decision , @xmath46 ) to @xmath37 [ algo : dpop : valuepropagation_end ]    [ [ overview - of - the - algorithm ] ] overview of the algorithm + + + + + + + + + + + + + + + + + + + + + + + + +    dpop is an instance of the general bucket elimination scheme by @xcite , performed distributedly ( algorithm  [ algo : dpop ] ) .",
    "it requires first arranging the constraint graph into a _ pseudo - tree _",
    ", formally defined as follows .",
    "[ def : dfs ] a _ pseudo - tree _ is a generalization of a tree , in which a node is allowed to have links _",
    "( back - edges ) _ with remote ancestors _ ( pseudo - parents ) _ and with remote descendants _ ( pseudo - children ) _ , but never with nodes in other branches of the tree .",
    "[ scale=.9 ]    = [ circle , draw = black , thick , fill = white , minimum size = 0.7 cm , inner sep=0pt , draw ]    ( x1 ) at ( 1 , 0 ) @xmath24 ; ( x4 ) at ( 1 , 2 ) @xmath26 ; ( x1 ) ",
    "( x4 ) [ thick ] ;    ( x5 ) at ( -1 , 2 ) @xmath22 ; ( x3 ) at ( 0 , 4 ) @xmath20 ; ( x5 )  ( x3 ) [ thick ] ; ( x4 )  ( x3 ) [ thick ] ;    ( x2 ) at ( 0 , 6 ) @xmath19 ; ( x3 ) ",
    "( x2 ) [ thick ] ;    ( x1 ) .. controls ( 2 , 2 ) .. ( x2 ) [ thick , dashed ] ;    at ( -2.75 , 3 )     @xmath20 & + @xmath47 & @xmath31 + @xmath48 & @xmath31 + @xmath49 & @xmath32 +    ;    at ( 3.75 , 1.25 )     & + @xmath26 & @xmath47 & @xmath48 & @xmath49 + @xmath47 & @xmath31 & @xmath31 & @xmath31 + @xmath48 & @xmath31 & @xmath31 & @xmath32 + @xmath49 & @xmath31 & @xmath32 & @xmath31 +    ;    at ( 3.75 , 4.75 )     & + @xmath20 & @xmath47 & @xmath48 & @xmath49 + @xmath47 & @xmath31 & @xmath32 & @xmath31 + @xmath48 & @xmath31 & @xmath31 & @xmath31 + @xmath49 & @xmath31 & @xmath31 & @xmath31 +    ;    at ( -2.5 , 5.5 )     @xmath19 & @xmath47 & @xmath48 & @xmath49 + & @xmath31 & @xmath32 & @xmath31 +    ;    a pseudo - tree arrangement of the constraint graph in figure  [ fig : constraint_graph ] is illustrated in figure  [ fig : dfs ] .",
    "this pseudo - tree naturally decomposes the original problem into two , loosely coupled subproblems , corresponding to the two branches , which will perform the rest of the algorithm in parallel .",
    "figure  [ fig : dfs ] also shows the _ feas _ messages ( originally called _ util _ messages in the context of utility maximization ) that are exchanged during the propagation of feasibility values , following a multi - party dynamic programming computation ( lines [ algo : dpop : utilpropagation ] to  [ algo : dpop : utilpropagation : root_value ] ) . in this part of the algorithm , all messages travel bottom - up along tree edges .",
    "consider for instance the message sent by agent  @xmath50 to its parent agent  @xmath51 .",
    "this message is the result of the _ projection _ ( lines [ algo : dpop : utilpropagation : argmin ] and  [ algo : dpop : utilpropagation : sendutil ] ) of variable  @xmath22 out of the conjunction ( line  [ algo : dpop : utilpropagation : local_join ] ) of @xmath22 s two constraints @xmath52 and @xmath53 , and summarizes the minimal number of constraint violations that @xmath50 can achieve , as a function of the ancestor variable  @xmath20 .",
    "more generally , each message sent by a variable  @xmath34 summarizes the minimal number of constraint violations achievable for the aggregate subproblem owned by the entire subtree rooted at  @xmath34 , as a function whose scope is called the _ separator _ of  @xmath34 ( line  [ algo : dpop : utilpropagation : separator ] ) . in dpop ,",
    "the separator of  @xmath34 necessarily includes @xmath34 s parent  @xmath33 , and potentially other ancestor variables ; this is indicated by the notation @xmath54 . for instance , the message @xmath55 summarizes the minimal number of constraint violations achievable for the entire subtree rooted at  @xmath26 , as a function of @xmath26 s separator @xmath56 .",
    "notice that the separator of a variable  @xmath34 can contain variables that are not neighbors of  @xmath34 ; for example , @xmath19 is in @xmath26 s separator because a descendent of  @xmath26 has a constraint with  @xmath19 . in the privacy - aware algorithms presented later in this paper , this notion of separator is extended to allow for separators that do not necessarily include the parent variable , and that may include multiple _ codenames _ referring to the same variables , which might not necessarily be ancestors in the pseudo - tree .    upon receiving the messages @xmath57 and @xmath55 ( line  [ algo : dpop : utilpropagation : get_message ] )",
    ", agent  @xmath51 _ joins _ them ( line  [ algo : dpop : utilpropagation : join ] ) with its constraint @xmath58 .",
    "variable  @xmath20 is then projected out of the resulting joint table , which produces the message @xmath59 ( lines [ algo : dpop : utilpropagation : argmin ] and  [ algo : dpop : utilpropagation : sendutil ] ) . at the end of this feasibility propagation ( line  [ algo : dpop : utilpropagation : root_value ] )",
    ", the root variable  @xmath19 chooses a value  @xmath60 for itself that minimizes the number of constraint violations over the entire problem ( e.g. @xmath61 ) .",
    "this decision can then be propagated downwards along tree - edges via _ decision _ messages ( originally called _ value _ messages ) until all variables have been assigned optimal values ( lines [ algo : dpop : valuepropagation_start ] to  [ algo : dpop : valuepropagation_end ] ) .",
    "[ [ complexity ] ] complexity + + + + + + + + + +    given a pseudo - tree ordering of the @xmath62  variables , dpop s bottom - up and top - down phases each exchange exactly @xmath63 messages ( one through each tree edge ) .",
    "however , while each decision message contains at most @xmath63 variable assignments , the feas message sent by a given variable  @xmath34 can contain exponentially many feasibility values , because it contains a table representation of a function  @xmath64 of @xmath65 variables .",
    "the size of the largest feas message is therefore @xmath66 , where @xmath67 is the size of the largest variable domain , and @xmath68 is the _ width _ of the pseudo - tree . in the best case ,",
    "the width is equal to the _ treewidth _ of the constraint graph ; however finding a pseudo - tree that achieves this minimal width is np - hard . in practice ,",
    "the pseudo - tree is generated by a heuristic , distributed , depth - first traversal of the constraint graph ( online appendix  1 ) , producing a so - called _ dfs tree _ that is a pseudo - tree in which all parent - child relationships are between neighbors in the constraint graph .",
    "since dpop exchanges @xmath63 feas messages , its overall complexity in terms of runtime ( measured in number of constraint checks ) , memory , and information exchange is  @xmath69 .",
    "[ [ privacy - properties ] ] privacy properties + + + + + + + + + + + + + + + + + +    the privacy - aware algorithms in section  [ sec : p_dpop ] are based on dpop , because of two desirable properties that allow for higher levels of privacy .",
    "first , dpop only requires message exchanges between neighboring agents , provided that the pseudo - tree used is a dfs tree ; this is necessary to protect _",
    "agent privacy_. @xcite made the opposite claim that pseudo - trees are detrimental to privacy compared to linear orderings ; however this claim is only valid if the only type of privacy considered is _ constraint privacy _ , and does not hold if _ agent privacy _ and _ topology privacy _ are guaranteed , i.e. if the pseudo - tree is not publicly known to all agents .",
    "the second , dp - inherited property is that dpop s performance does not depend on _ constraint tightness _ , i.e. how easy or hard it is to satisfy each constraint . for all other ,",
    "search - based algorithms , inferences on the constraint tightness can be made by observing the runtime or the amount of information exchanged  @xcite . in the case of meeting scheduling problems , constraint tightness maps directly to the participants levels of availability , which is private information . in application domains where this leak of constraint tightness is tolerable , algorithms",
    "based on search rather than dp can be used , and many of the privacy - enhancing techniques presented in this paper for dpop are also applicable to search - based algorithms .",
    "section  [ sec : privacy_defs ] formally defines the four types of privacy considered in this paper .",
    "section  [ sec : previous_privacy ] then recalls previous work that attempted to address various subsets of these privacy types .",
    "definition  [ def : semi_private ] introduces the concept of _ semi - private information _",
    "@xcite , which may _ inevitably _ be leaked by _ any _ discsp algorithm .",
    "[ semi - private information ] [ def : semi_private ] _ semi - private information _ refers to information about the problem and/or its solution that an agent might consider private , but that can _ inevitably _ be leaked to other agents by their views of the chosen solution to the discsp .    in other words ,",
    "semi - private information covers everything a given agent can discover about other agents by making inferences simply based on its initial knowledge of the problem and on the values its variables take in the solution .",
    "for instance , in a graph coloring problem involving only two colors , each node can infer the color of each of its neighbors from the color it was assigned in the chosen solution , provided that the solution is correct . excluding semi - private information , we now distinguish four types of private information that agents may desire to protect  @xcite .",
    "[ agent privacy ] [ def : agent_privacy ] no agent should be able to discover the identity , or even the existence of non - neighboring agents .",
    "a particular consequence of this type of privacy is that two agents should only be allowed to communicate directly if they share a constraint .    in figure",
    "[ fig : constraint_graph ] , this means for instance that agent  @xmath70 should not be able to discover the existence and identities of agents @xmath51 and  @xmath50 .",
    "even if no two non - neighboring agents communicate directly , agent privacy might still be leaked by the contents of messages ; in this paper we propose a method based on _ codenames _ to fully protect agent privacy .",
    "[ topology privacy ] [ def : topology ] no agent should be able to discover the existence of topological constructs in the constraint graph , such as nodes ( i.e. variables ) , edges ( i.e. constraints ) , or cycles , unless it owns a variable involved in the construct .    in figure",
    "[ fig : constraint_graph ] , topology privacy means for instance that agent  @xmath70 should not discover how many other neighbors @xmath19 has besides itself .",
    "however , @xmath70 might discover the existence of a cycle involving @xmath24 , @xmath19 and @xmath26 .",
    "this is tolerated because @xmath24 is involved in this cycle , but @xmath70 should not discover the length of the cycle ( i.e. that @xmath19 and @xmath26 share a neighbor ) .",
    "[ constraint privacy ] [ def : constraint ] no agent should be able to discover the nature of a constraint that does not involve a variable it owns .    in figure",
    "[ fig : constraint_graph ] , an example of a breach in constraint privacy would be if agent  @xmath70 were able to discover that agent  @xmath71 does not want to be assigned the color _",
    "blue_. this is the type of privacy that the discsp literature mostly focuses on .",
    "[ decision privacy ] [ def : decision ] no agent should be able to discover the value that another agent s variable takes in the chosen solution ( modulo semi - private information ) .    in a distributed graph coloring problem",
    ", this means that no agent can discover the color of any neighbor ( let alone any non - neighboring agent ) in the solution chosen to the problem .      before discussing",
    "what information may be leaked by a given algorithm , and how to prevent it , it is important to clarify what information is assumed to be initially known to each agent .",
    "[ [ initial - knowledge - assumptions ] ] initial knowledge assumptions + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in this paper , we use the following three assumptions , which are currently the most widely used in the discsp literature .    1 .",
    "each agent  @xmath72 knows all agents that own variables that are neighbors of @xmath72 s variables , but does not know any of the other agents ( not even their existence ) ; 2 .   a variable and its domain",
    "are known only to its owner agent and to the agents owning neighboring variables , but the other agents ignore the existence of the variable ; 3 .",
    "a constraint is fully known to all agents owning variables in its scope , and no other agent knows anything about the constraint ( not even its existence ) .",
    "@xcite introduced _ partially known constraints ( pkcs _ ) , whose scopes are known to all agents involved , but the knowledge of whose nature ( which assignments are allowed or disallowed ) is distributed among these agents .",
    "this is a relaxation of assumption  3 ; however it is worth noting that the algorithms presented in this paper can still support pkcs without introducing privacy leaks by enforcing this assumption , because any pkc can be decomposed into a number of constraints over _ copy variables _ such that assumption  3 holds .",
    "for instance , if agents @xmath73 share the knowledge of a unary pkc over variable  @xmath34 , then this constraint can be decomposed into @xmath62  unary constraints , such that each constraint  @xmath12 is known fully and only to agent  @xmath74 and is expressed over a copy variable  @xmath7 owned by @xmath74 .",
    "equality constraints are added to the problem to enforce equality of all copy variables .",
    "however , the introduction of copy variables can be detrimental to decision privacy .",
    "@xcite later proposed the similar concept of _ asymmetric _ constraints , which can also be reformulated as symmetric constraints over copy variables for the purpose of applying our algorithms .",
    "other previous work adopted a dual approach , assuming that variables are public and known to all agents , but each constraint is known to only one agent @xcite .",
    "@xcite even proposed a framework in which the constraints are secret to everyone .",
    "this dual approach has the disadvantage of necessarily violating topology privacy , since all variables are public .",
    "[ [ measuring - constraint - privacy - loss ] ] measuring constraint privacy loss + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    most of the literature on privacy in discsps focuses on constraint privacy .",
    "metrics have been proposed to evaluate constraint privacy loss in algorithms , in particular for distributed meeting scheduling  @xcite . @xcite",
    "designed a framework called _ valuation of possible states ( vps ) _ that they used to measure constraint privacy loss in the optapo and synchbb algorithms , and they considered the impact of whether the problem topology is public or only partially known to the agents .",
    "@xcite also applied vps to evaluate dpop and adopt on meeting scheduling problems , under the assumption that the problem topology is public .",
    "@xcite proposed to consider the cost of privacy loss in optimization problems , in order to elegantly balance privacy and optimality .",
    "[ [ preventing - constraint - privacy - loss ] ] preventing constraint privacy loss + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    some previous work also proposed approaches to partially reduce constraint privacy loss .",
    "for instance , @xcite described a modification of the _ distributed forward checking ( disfc ) _",
    "algorithm for discsps in which agents are allowed to _ lie _ for a finite time in order to achieve higher levels of privacy .",
    "however , the performance of most search - based algorithms like disfc leaks information about constraint tightness , as explained at the end of section  [ sec : dpop ] . to avoid this subtle privacy leak , one must either perform full exhaustive search , which is the option chosen by @xcite , or resort to dynamic programming , which is the option we have chosen in this paper .",
    "the cryptographic technique of _ secret sharing _",
    "@xcite was also applied by @xcite and @xcite to lower constraint privacy in dpop , assuming that the constraint graph topology is public knowledge .",
    "cryptography has also been applied to provide strong guarantees on constraint privacy preservation in multi - agent decision making .",
    "for instance , @xcite , @xcite and @xcite showed how a public key encryption scheme can be used to solve discsps using multiple servers , while protecting both constraint privacy and decision privacy .",
    "@xcite solved single - meeting scheduling problems using similar techniques , and one semi - trusted server . in this paper",
    "however , we only consider algorithms that do not make use of third parties , as such third parties might not be available .",
    "@xcite showed how to use _ _ secure multiparty computation ( smc ) _ _ to securely schedule a single meeting , without relying on servers . in smc , agents collaboratively compute the value of a given , publicly known function on private inputs , without revealing the inputs . for @xcite , the inputs are each participant s availability at a given time , and the function outputs whether they are all available .",
    "[ [ the - mpc - discsp4-algorithm ] ] the mpc - discsp4 algorithm + + + + + + + + + + + + + + + + + + + + + + + + +    @xcite also applied smc to solve general discsps , where the private inputs are the agents constraint valuations , and the function returns a randomly chosen solution .",
    "the algorithm proceeds as follows @xcite .",
    "each agent  @xmath74 first creates a vector  @xmath75 with one entry per candidate solution to the discsp , equal to  @xmath32 if the candidate solution satisfies @xmath74 s private constraints , and to  @xmath31 otherwise . to reduce the size of  @xmath75",
    ", the candidate solutions may be filtered through publicly known constraints , if there exists any . using shamir s polynomial secret sharing technique @xcite ,",
    "agent  @xmath74 then sends one secret share  @xmath76 of its vector  @xmath75 to each other agent  @xmath77 , and receives corresponding secret shares  @xmath78 of their respective vectors .",
    "agent  @xmath74 then multiplies together all the secret shares it received .",
    "the multiplication of shamir secret shares is a non - trivial operation , because each secret share is the value of a polynomial , and multiplying two polynomials increases the degree of the output , which must always remain lower than the number @xmath79 of agents to be resolvable .",
    "therefore , after each multiplication of two secret shares , agent  @xmath74 must perform a complex sequence of operations involving the exchange of messages in order to reduce the degree of the output .    after performing @xmath80 such pairwise multiplications of secret shares ,",
    "agent  @xmath74 s vector  @xmath75 contains secret shares of  @xmath32 at the entries corresponding to globally feasible solutions .",
    "agent  @xmath74 then performs a transformation on  @xmath75 so that only _ one _ such secret share of  @xmath32 remains , identifying one particular feasible solution ( if there exists one ) . just selecting the first such entry",
    "would a posteriori reveal that all previous entries correspond to infeasible solutions to the discsp ; to prevent this privacy leak , the vector  @xmath75 is first collaboratively , randomly permuted using a _ mix - net_. agent  @xmath74 then performs a sequence of iterative operations on  @xmath75 ( including communication - intensive multiplications ) to set all its entries to secret shares of  @xmath31 , except for one secret share of  @xmath32 corresponding to the chosen solution to the discsp ( if any ) .",
    "the vector  @xmath75 is then un - shuffled by re - traversing the mix - net in reverse .",
    "finally , agent  @xmath74 can compute secret shares of the domain index of each variable s chosen assignment , and reveal these secret shares only to the owners of the variables .",
    "this algorithm has numerous drawbacks .",
    "first , each agent must know all variables and their domains to construct its initial vector  @xmath75 , which immediately violates agent privacy and topology privacy ( table  [ table : privacy_summary ] , page  ) .",
    "second , shamir s secret sharing scheme is a majority threshold scheme , which means that if at least half of the agents collude , they can discover everyone s private information . even though , in this paper , we are assuming that agents are honest and do not collude",
    ", a consequence of this threshold is that this scheme does not provide any privacy guarantee when the problem involves only two agents .",
    "third , this algorithm is often only practical for very small problems , because it performs full exhaustive search ; this is demonstrated by our experimental results in section  [ sec : results ] .",
    "this section describes a variant of the dpop algorithm that guarantees full agent privacy .",
    "it also partially protects topology , constraint , and decision privacy .",
    "algorithm  [ algo : p_dpop ] is an improvement over the _",
    "p - dpop _ algorithm we originally proposed @xcite . like dpop",
    ", the algorithm performs dynamic programming on a dfs - tree ordering of the variables ( figure  [ fig : dfs ] ) .",
    "algorithms to first elect one variable , and then generate a dfs tree rooted at this variable are given in online appendices 1 and  2 .",
    "these algorithms do not reveal the pseudo - tree in its entirety to any agent ; instead , each agent only discovers the ( pseudo-)parents and ( pseudo-)children of its own variables . for the sake of simplicity",
    ", we will hereafter assume without loss of generality that the constraint graph consists of a single component .",
    "if the problem actually consisted of two or more fully decoupled subproblems , then each subproblem would be solved in parallel , independently from the others .",
    "a dfs - tree ordering of the variables    wait for a message ( codes , @xmath81 ) from each @xmath82[algo : p_dpop : codenames ] @xmath83 large random number [ algo : p_dpop : choose_var_codename ] @xmath84 list of @xmath85 random , unique identifiers @xmath86 random permutation of @xmath87 $ ] send message ( codes , @xmath88 ) to  @xmath37 [ algo : p_dpop : send_codenames ]    wait for and record a message ( key , @xmath89 ) from each @xmath90 ( if any ) [ algo : p_dpop : got_keys ] @xmath91 vector of large random numbers of @xmath48 bits , indexed by @xmath92 [ algo : p_dpop : key ] send message ( key , @xmath93 ) to @xmath37 [ algo : p_dpop : send_keys ]    propagate feasibility values up the pseudo - tree ( algorithm  [ algo : utilpropagation ] , section  [ sec : utilpropagation ] ) [ algo : p_dpop : utilpropagation ]    [ algo : p_dpop : valuepropagation_start ] wait for message ( decision , @xmath94 ) from parent @xmath33 @xmath95 [ algo : p_dpop : lookup ] send message ( decision , @xmath96 ) to @xmath37 , with @xmath97 from algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : separator ] [ algo : p_dpop : valuepropagation_end ]      as already illustrated for dpop in section  [ sec : dpop ] , the agents perform a bottom - up propagation of feasibility values along the pseudo - tree .",
    "this is done in algorithm  [ algo : utilpropagation ] , which is an extension of dpop s util propagation phase ( the extensions are indicated by comments in bold ) , and improves over the algorithm we originally proposed @xcite by patching an important constraint privacy leak in the single - variable feas messages sent by variables with singleton separators .",
    "the following sections describe the obfuscation techniques used to protect the private information that could be leaked by the feasibility messages , using codenames ( section  [ sec : codenames ] ) and addition of random numbers ( section  [ sec : obfuscation ] ) .",
    "a dfs - tree ordering of the variables ; @xmath33 denotes @xmath34 s parent [ algo : utilpropagation : start ] @xmath35 [ algo : utilpropagation : local_join ]    @xmath98 replace @xmath99 in @xmath100 with @xmath101 from algorithm  [ algo : p_dpop ] , line  [ algo : p_dpop : codenames ] , and apply the permutation  @xmath102 to  @xmath103 [ algo : utilpropagation : codenames ]    @xmath104 large , positive , random number of @xmath48 bits @xmath105 [ algo : utilpropagation : new_obfuscation ]    wait for the message ( feas , @xmath106 ) from @xmath37 [ algo : utilpropagation : get_message ] @xmath38 [ algo : utilpropagation : separator ] @xmath107 identify @xmath108 as @xmath109 in @xmath106 ( if @xmath110 is present ) [ algo : utilpropagation : resolve_codenames ] @xmath111 [ algo : utilpropagation : join ]    @xmath112 [ algo : utilpropagation : deobfuscation ]    @xmath113 [ algo : utilpropagation : argmin ] @xmath114 [ algo : utilpropagation : min ]    @xmath115 [ algo : utilpropagation : obfuscation ]    send the message ( feas , @xmath116 ) to @xmath33 * else * @xmath42 [ algo : utilpropagation : root_value ] //",
    "@xmath117 actually only depends on @xmath34      consider the feasibility message @xmath118 sent by agent  @xmath70 to its parent variable  @xmath26 in figure  [ fig : dfs ] .",
    "this message is recalled in figure  [ fig : msg_to_c33:cleartext ] , reformulated in terms of minimizing the number of constraint violations . if this message were actually received in cleartext , it would breach agent privacy and topology privacy : agent  @xmath71 would be able to infer from the dependency of the message on variable  @xmath19 both the existence of agent  @xmath119 ( which violates agent privacy ) and the fact that @xmath19 is a neighbor of one or more unknown nodes below  @xmath24 .    in order to patch these privacy leaks , variable  @xmath19 and its domain  @xmath120",
    "are replaced with random codenames @xmath121 and @xmath122 ( figure  [ fig : msg_to_c33]b ) preliminarily generated by  @xmath119 and communicated directly to the leaf of the back - edge ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : codenames ] to  [ algo : p_dpop : send_codenames ] ) .",
    "the leaf applies these codenames to its output message ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : codenames ] ) , and they are only resolved once the propagation reaches the root of the back - edge ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : resolve_codenames ] ) . not knowing these codenames , the agents in between , such as  @xmath71 ,",
    "can only infer the existence of a cycle in the constraint graph involving some unknown ancestor and descendent .",
    "this is tolerated by the definition of topology privacy ( definition  [ def : topology ] ) since they are also involved in this cycle .",
    "a secret , random permutation  @xmath123 is also applied to  @xmath124 ; this is useful for problem classes in which variable domains are public .",
    "notice that if @xmath26 also had a constraint with  @xmath19 , the above reasoning would still hold , because @xmath19 would then have sent a _ different _",
    "codename @xmath125 to  @xmath26 , which would then not be able to resolve the unknown codename  @xmath126 to  @xmath19 . in this case , @xmath26 s separator would be @xmath127 , and its message sent to  @xmath20 would be three - dimensional instead of two - dimensional .",
    "hiding variable names and values using codenames addresses the leaks of agent and topology privacy .",
    "however , this does not address the fact that the feasibility values in the message @xmath118 in figure  [ fig : msg_to_c33:cyphertext ] violate constraint privacy , because they reveal to @xmath26 that its subtree can always find a feasible solution to its subproblem when @xmath128 , regardless of the value of the obfuscated variable  @xmath129 .",
    "to patch this privacy leak , feasibility values are obfuscated by adding large , random numbers that are generated by the root of the back - edge ( @xmath19 ) and sent over a secure channel to the leaf of the back - edge ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : got_keys ] to  [ algo : p_dpop : send_keys ] ) .",
    "the number of bits  @xmath48 of the random numbers is a problem - independent parameter of the algorithm .",
    "the obfuscation is performed in such a way that a different random number is added to all feasibility values associated with each value of  @xmath19 , as in figure  [ fig : msg_to_c33:cyphertext2 ] , using the obfuscation key @xmath130 $ ] .",
    "these random numbers are added by the leaf of the back - edge to its outgoing message ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : obfuscation ] ) , and they are only eventually subtracted when the propagation reaches the root of the back - edge ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : deobfuscation ] ) .",
    "notice that this obfuscation scheme achieves two objectives : 1 ) it hides from @xmath26 the absolute feasibility values of its subtree , and 2 ) it hides the relative dependencies of these values on the obfuscated variable  @xmath129 , because different random numbers were used for each value in its obfuscated domain @xmath131 .",
    "agent  @xmath71 is still able to infer the relative dependencies on its own variable  @xmath26 , which is necessary to perform the projection of this variable , but it is unable to tell , for each value of the other ( obfuscated ) variable , whether the subtree s problem is feasible , and if not , how many constraints are violated .",
    "notice in particular that , for a given value of the obfuscated variable ( i.e. for any column ) , agent  @xmath71 does not know whether any of the assignments to  @xmath26 is feasible , and therefore it would be incorrect to simply assume that the lowest of the obfuscated feasibility entries decrypts to  @xmath31 .",
    "similarly , equal entries in the same column correspond with a high probability to entries that have the same number of constraint violations , but this number is not necessarily  0 , so it would be incorrect to infer they correspond to feasible entries .",
    "notice also that this obfuscation scheme is only applicable in the presence of a back - edge , i.e. when the message contains more than just the parent variable .",
    "consider for instance the single - variable message @xmath57 , recalled in figure  [ fig : msg_from_c21:cleartext ] .",
    "if agent  @xmath51 knew that @xmath22 is a leaf of the pseudo - tree , the cleartext message would reveal agent  @xmath50 s private local constraint @xmath132 to agent  @xmath51 , and the previous obfuscation scheme does not apply because of the absence of back - edges .",
    "notice that this threat to constraint privacy is tempered by the fact that p - dpop@xmath0 s guarantees in terms of topology privacy prevent agent  @xmath51 from discovering that @xmath22 is indeed a leaf . from @xmath51 s point of view , a larger subproblem might be hanging below variable  @xmath22 in figure  [ fig : dfs ] , and the message could actually be an aggregation of multiple agents subproblems .    to reduce this privacy leak present in the original algorithm @xcite",
    ", we propose a new additional obfuscation scheme that consists in adding large ( @xmath48-bit ) , positive , random numbers to positive entries in single - variable messages , in order to obfuscate the true numbers of constraint violations ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : new_obfuscation ] and figure  [ fig : msg_from_c21:cyphertext ] ) .",
    "because these random numbers are never subtracted back , they must not be added to zero entries , otherwise the algorithm would fail to find a solution with no violation .",
    "feasible entries are still revealed , but the numbers of constraint violations for infeasible entries remain obfuscated .",
    "once the feasibility values have propagated up all the way to the root of the pseudo - tree , and a feasible assignment to this root variable has been found ( if there exists one ) , this assignment is propagated down the pseudo - tree ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : valuepropagation_start ] to  [ algo : p_dpop : valuepropagation_end ] ) .",
    "each variable uses the assignments contained in the message from its parent , in order to look up a corresponding assignment for itself ( line  [ algo : p_dpop : lookup ] ) .",
    "it then sends to each child the assignments for the variables in its separator ( line  [ algo : p_dpop : valuepropagation_end ] ) , using the same codenames as before so as to protect agent and topology privacy .",
    "decision privacy is only partially guaranteed , because each variable learns the values chosen for its parent and pseudo - parents  but not for other , non - neighboring variables in its separator because they are hidden by unknown codenames .",
    "this section first formally proves that the algorithm is complete , and analyses its complexity .",
    "we then present an algorithm variant with lower complexity .",
    "finally , the privacy guarantees provided by both algorithms ( summarized in table  [ table : privacy_summary ] ) are formally described .",
    ".privacy guarantees of various algorithms . [ cols=\"<,^,^,^,^\",options=\"header \" , ]     [ table : privacy_summary ]      [ thm : p_dpop ] provided that there are no codename clashes , p - dpop@xmath0 ( algorithm  [ algo : p_dpop ] ) terminates and returns a feasible solution to the discsp , if there exists one .    after exchanging codenames and obfuscation keys , which is guaranteed to require a number of messages at most quadratic in the number  @xmath62 of variables , the bottom - up propagation of feasibility values ( algorithm  [ algo : utilpropagation ] ) terminates after sending exactly @xmath63 messages ( one up each tree - edge )",
    ". one can prove by induction ( left to the reader ) that this multi - party dynamic programming computation almost surely correctly reveals to each variable  @xmath34 the ( obfuscated ) feasibility of its subtree s subproblem , as a function of  @xmath34 and possibly of ancestor variables in the pseudo - tree .",
    "this process may only fail in case of collisions of codenames , when the roots of two overlapping back - edges choose the same codenames .",
    "such codename clashes are inherent to most privacy - protecting algorithms , and can be made as improbable as desired by augmenting the size of the codename space .    finally , the top - down decision propagation phase ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : valuepropagation_start ] to  [ algo : p_dpop : valuepropagation_end ] ) is guaranteed to yield a feasible assignment to each variable ( if there exists one ) , after the exchange of exactly @xmath63 messages ( one down each tree - edge ) .",
    "when it comes to the complexity of the algorithm in terms of number of messages exchanged , the bottleneck is in the election of the root variable ( online appendix  1 ) , which requires @xmath133 messages , where @xmath134 is the diameter of the constraint graph , @xmath135  its degree , and @xmath62  is the number of variables .",
    "however , the @xmath63 messages containing feasibility values can be exponentially large : the message sent by variable  @xmath34 is expressed over @xmath136 variable codenames ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : separator ] ) , and therefore contains @xmath137 feasibility values , where @xmath67 is the size of the largest variable domain .",
    "the overall complexity in terms of information exchange , memory and runtime ( measured in number of constraint checks ) is therefore @xmath69 , where @xmath138 .",
    "this is the same as dpop , except that in p - dpop@xmath0 each variable may appear multiple times under different codenames in the same separator , hereby increasing the value of  @xmath139 .",
    "however , this increase is only by a multiplicative factor that is upper bounded by the degree of the constraint graph , since the number of codenames for a given variable is at most equal to its number of neighbors .",
    "empirically , our experimental results in section  [ sec : results ] suggest that , on almost all the problem classes we considered , the median value of @xmath139 tends to grow rather linearly in  @xmath62 .",
    "it is possible to reduce the sizes  @xmath140 of the separators , by enforcing that each agent  @xmath141 send the _",
    "same _ codename  @xmath142 for  @xmath34 to _ all _ of @xmath34 s ( pseudo-)children , unlike in algorithm  [ algo : p_dpop ] ( lines [ algo : p_dpop : codenames ] to  [ algo : p_dpop : send_codenames ] ) .",
    "this variant will be identified by the absence of the plus sign in exponent ; p - dpop is the version of the algorithm that was initially proposed by @xcite .    as a result of this change",
    ", variables that previously may have occurred multiple times in the same feasibility message under different codenames can now only appear at most once , such that we now have @xmath143 .",
    "the worst - case complexity of p - dpop then becomes the same as dpop @xcite , in which @xmath139 is equal to the _ width _ of the pseudo - tree , which is bounded below by the _ treewidth _ of the constraint graph .",
    "however , privacy considerations prevents the use in p - dpop of dpop s more efficient , but less privacy - aware pseudo - tree generation heuristics , resulting in higher - width pseudo - trees .    while the complexity of p - dpop is hereby decreased compared to p - dpop@xmath0 , sending the same codename  @xmath142 for variable  @xmath34 to all its ( pseudo-)children has drawbacks in terms of topology privacy , as analyzed below .",
    "there are only two ways the identity of an agent  @xmath144 could be leaked to a non - neighbor  @xmath48 : 1 ) the algorithm can require @xmath144 and  @xmath48 to exchange messages with each other , or 2 ) agent  @xmath144 can receive a message whose content refers identifiably to  @xmath48 .",
    "case  1 can never happen in any of our algorithms , because they only ever involve exchanging messages with neighboring agents . case  2 is addressed mainly through the use of codenames .",
    "[ thm : agent_privacy : p_dpop ] the p - dpop@xmath145 algorithms guarantee full agent privacy .",
    "the p - dpop@xmath145 algorithms proceed in the following sequential phases ( the preliminary phases of root election and pseudo - tree generation are addressed in online appendices ) :    bottom - up feasibility propagation ( algorithm  [ algo : utilpropagation ] ) : :    each feasibility message contains only a function    ( line  [ algo : utilpropagation : get_message ] ) over a set of variables ,    whose names , if transmitted in clear text , could identify their owner    agent . to prevent this agent privacy leak , p - dpop@xmath145    replaces all variable names with secret , random codenames , as follows .",
    "+    consider a variable  @xmath34 in the pseudo - tree .",
    "note that no    feasibility message sent by  @xmath34 or by any ancestor    of  @xmath34 can be a function of  @xmath34 .",
    "the message    sent by  @xmath34 is not a function of  @xmath34 , because    @xmath34 is projected out before the message is sent    ( line  [ algo : utilpropagation : min ] ) .",
    "variable  @xmath34 can not    re - appear in any feasibility message higher in the pseudo - tree ,    because no agent s local problem can involve any variable lower in the    pseudo - tree ( line  [ algo : utilpropagation : local_join ] ) .",
    "+    similarly , consider now the feasibility message sent by a    descendant  @xmath146 of  @xmath34 in the pseudo - tree , and    assume first that @xmath146 is a leaf of the pseudo - tree .",
    "since    @xmath146 has no children , the feasibility message it sends can    only be a function of the variables in its local problem .",
    "if this    local problem involves  @xmath34 , @xmath146  will replace    @xmath34 by its codename  @xmath147    ( line  [ algo : utilpropagation : codenames ] ) before it sends its    feasibility message .",
    "one can then prove by inference that no    feasibility message sent by any variable between @xmath146    and  @xmath34 will contain  @xmath34 either ; it can only    ( and not necessarily ) contain one or several of its    codenames  @xmath148 .",
    "+    since the codenames  @xmath148 are random numbers    chosen by  @xmath34 ( algorithm  [ algo : p_dpop ] ,    line  [ algo : p_dpop : choose_var_codename ] ) , and only communicated    ( through channels that are assumed secure ) to the respective    neighbors  @xmath37 of  @xmath34    ( algorithm  [ algo : p_dpop ] , line  [ algo : p_dpop : send_codenames ] ) , no    non - neighbor of  @xmath34 receiving a message involving    any  @xmath148 can discover the identity of its    owner agent .",
    "+    the domain  @xmath92 of variable  @xmath34 could also    contain values that might identify its owner agent . to fix this    privacy risk , @xmath34 s domain is also replaced by obfuscated    domains  @xmath149 of random numbers , similarly    to the way variable names are obfuscated . in this paper",
    ", we make the    simplifying assumption that all variables have the same domain size    ( which naturally holds in many problem classes ) , so that one    variable s domain size does not give any information about its owner    agent . otherwise , variable domains can be padded with fake values in    order to make them all have the same size . top - down decision propagation ( section  [ sec : valuepropagation ] ) : :    the messages contain assignments to variables    ( algorithm  [ algo : p_dpop ] , line  [ algo : p_dpop : valuepropagation_end ] ) ,    which are also obfuscated using codenames .",
    "this concludes the proof that , in the p - dpop@xmath145 algorithms , no agent can receive any message from which it can infer the identity of any non - neighboring agent .",
    "[ thm : topo_privacy : p_dpopmin ] p - dpop guarantees _ partial _ topology privacy .",
    "the minor leaks of topology privacy lie in the fact that a variable _ might _ be able to discover a lower bound on a neighbor variable s degree in the constraint graph , and a lower bound on the total number of variables .",
    "root election and pseudo - tree generation are left to the online appendices .",
    "bottom - up feasibility propagation ( algorithm  [ algo : utilpropagation ] ) : :    each variable  @xmath34 receives a feas message from each child ,    containing a function whose scope might reveal topological    information . each variable  @xmath146 in this scope is    represented by a secret codename  @xmath150 , however    @xmath34 may be able to decrypt the    codename  @xmath151 , if and only if @xmath146 is a    neighbor of  @xmath34 ( or is @xmath34 itself ) , because    @xmath146 has sent the _ same _ codename  @xmath151    to all its neighbors .",
    "this results in a leak of topology privacy :    @xmath34 discovers , for each neighboring    ancestor  @xmath146 , whether @xmath146 has at least one    other neighbor below a given child of  @xmath34 .",
    "but it can not    discover exactly how many of these other neighbors there are .",
    "+    furthermore , in the case where @xmath34 and @xmath146 are    not neighbors , @xmath34 can not    decrypt  @xmath151 , but it can still infer there exists    another , non - neighboring ancestor corresponding to this codename .",
    "this    is another breach of topology privacy .",
    "because @xmath146 sent    the same codename  @xmath151 to all its neighbors ,    @xmath34 can also discover whether that other ancestor has at    least one neighbor below each of @xmath34 s children .",
    "moreover ,    since codenames are large random numbers that are almost surely    unique , @xmath34 may discover the existence of _ several ,    distinct _ such non - neighboring ancestors .",
    "top - down decision propagation ( section  [ sec : valuepropagation ] ) : :    each variable receives a message from its parent , which can only    contain codenames for variables and variable values that were already    present in the feas message received during the previous phase .",
    "this concludes the proof that p - dpop only _ partially _ protects topology privacy . the limited topology information leaked to a variable only concerns its branch in the pseudo - tree ; no information can be leaked about any other branch , not even their existence .    the use of different codenames for each ( pseudo-)child improves the topology privacy in p - dpop@xmath0 compared to p - dpop , but the same bounds can still be leaked .",
    "consider a variable  @xmath34 that receives a feas message including a secret codename  @xmath151 corresponding to variable  @xmath146 ( @xmath152 ) . because @xmath146 now sent a _ different _ codename to each of its neighbors , @xmath34 is no longer able to decrypt  @xmath151 , even if @xmath146 is a neighbor of  @xmath34 . as a consequence ,",
    "@xmath34 is no longer able to infer whether @xmath151 refers to a known neighbor of  @xmath34 , or to an unknown , non - neighboring variable .",
    "however , since each codename now corresponds to a unique back - edge in the pseudo - tree , for each pair @xmath153 of unknown codenames in @xmath34 s received feas message ( if such a pair exists ) , at least one of the following statements must hold :    * @xmath154 and @xmath155 refer to two different ancestors of  @xmath34 , and therefore @xmath34 discovers at it has at least two ancestors ( which it might not have known , if it has no pseudo - parent ) ; _ and/or _ * @xmath154 and @xmath155 were sent to two different descendants of  @xmath34 below ( and possibly including ) the sender child  @xmath146 , and therefore @xmath34 discovers that it has at least two descendants below ( and including )  @xmath146 ( which it might not have known , if it has no pseudo - child below  @xmath146 ) .",
    "therefore @xmath34 _ might _ be able to refine its lower bound on the total number of variables .",
    "the p - dpop@xmath145 algorithms guarantee _ partial _ constraint privacy .",
    "the local feasibility of a subproblem for a partial variable assignment  @xmath156 may be leaked , even if @xmath156 can not be extended to an overall feasible solution ( i.e. this is not semi - private information ) .",
    "information about constraints is only transmitted during feasibility propagation ( algorithm  [ algo : utilpropagation ] ) .",
    "based on the knowledge of the optimal variable assignments transmitted during the last phase ( section  [ sec : valuepropagation ] ) , some of the feasibility information may be decrypted .",
    "single - variable feasibility messages : :    when a variable  @xmath33 receives a feasibility message    involving only  @xmath33 , the message has been obfuscated only    by adding secret random numbers to its infeasible entries    ( line  [ algo : utilpropagation : new_obfuscation ] ) .",
    "feasible entries remain    equal to  @xmath31 , and @xmath33 can identify which    entries refer respectively to feasible or infeasible assignments    to  @xmath33",
    ".    +    however , the addition of a secret , positive , random number to each    infeasible entry ensures only an upper bound on the number of    constraint violations is leaked , which can be made as loose as desired    by choosing random numbers as large as necessary .",
    "multi - variable feasibility messages : :    if the feas message involves at least one other    variable  @xmath157 , then all message entries have    been obfuscated by adding large random    numbers  @xmath158 of @xmath48    bits ( line  [ algo : utilpropagation : obfuscation ] ) . furthermore",
    ",    @xmath158 is only known to the    sender  @xmath34 of the message and to its    pseudo - parent  @xmath37 , but not to the    recipient  @xmath33 , which therefore can not subtract it to    de - obfuscate the entries .    +    assume , for simplicity , that the message    @xmath159 involves only the two    variables @xmath160 and  @xmath161 ;    the argument extends easily to more variables .",
    "the    recipient  @xmath33 might be able to make inferences : 1 ) by    fixing @xmath161 and comparing the obfuscated    entries corresponding to different values    for  @xmath160 ; or 2 ) by    fixing  @xmath160 and    varying  @xmath161 instead .",
    "+    1 .   for a given value of  @xmath161",
    ", all entries    have been obfuscated by adding the same random    number  @xmath158    ( line  [ algo : utilpropagation : obfuscation ] ) , so @xmath33 can    compute the relative differences of feasibility values for various    assignments to  @xmath160 . however , it can not decrypt    the absolute values without    knowing  @xmath158 .",
    "in particular , the    lowest obfuscated value is not necessarily equal    to  @xmath158 , because it does not    necessarily decrypt to  @xmath31 : all values    of  @xmath160 may be infeasible for this particular    value of  @xmath161 .",
    "+    there is one exception : if a feasible solution is found to the problem    in which @xmath162 and    @xmath163 , then    @xmath164 necessarily decrypts    to  @xmath31 , and therefore @xmath33 will be able to    infer  @xmath165 . after fixing    @xmath162 in the message and    subtracting  @xmath165 ,",
    "the same    reasoning can be made as for the single - variable case , in which    feasible and infeasible entries are identifiable , but the numbers of    constraint violations for infeasible entries remain obfuscated .",
    "2 .   for a given value of  @xmath160",
    ", each feasibility    value @xmath159 has been    obfuscated by adding a different , secret random    number  @xmath158 . choosing the number    of bits  @xmath48 sufficiently large",
    "makes sure that no useful    information ( relative , or absolute ) can be obtained by comparing the    obfuscated feasibility values .",
    "this concludes the proof that p - dpop@xmath145 guarantees _ partial _ constraint privacy .      the p - dpop@xmath145 algorithms guarantee _ partial _ decision privacy .",
    "the leak lies in the fact that a variable _ might _ discover the values chosen for some or all of its neighbors .",
    "first notice that the algorithm can not leak any information about the chosen values for variables that are _ lower _ in the pseudo - tree , since these variables have been projected out of the feasibility messages received .",
    "however , during the decision propagation phase , each variable receives a message from its parent that contains the chosen values for its parent and pseudo - parents .",
    "the message may also contain codenames for the assignments to other , non - neighboring variables , which the recipient will not be able to decode .",
    "furthermore , domains are shuffled using secret permutations , making it impossible to decode the codename for the value of a non - neighboring variable from its index in the variable s domain .",
    "this section presents another variant of the p - dpop@xmath0 algorithm that achieves _ full _ decision privacy .",
    "this results in a novel algorithm , which can be seen as a hybrid between the p - dpop@xmath0 and p@xmath2-dpop  @xcite algorithms , and is called _",
    "p@xmath1-dpop@xmath0_.    a first temporary dfs tree , a unique i d  @xmath166 , a tight strict lower bound on the next unique i d  @xmath167 , and an upper bound @xmath168 on the total number of variables    @xmath169 $ ] [ algo : p_dpop_value : vector ]    [ algo : p_dpop_value : keys_start ] @xmath170 generate a private elgamal key for @xmath34 @xmath171 generate a set of @xmath172 public key shares corresponding to @xmath173 * for each * @xmath174 * do * toprevious((share , @xmath175 ) ) as in algorithm  [ algo : routing ] wait for and record one message ( share , @xmath175 ) * if * @xmath176 * then * toprevious((share , @xmath175 ) ) as in algorithm  [ algo : routing ] generate the compound elgamal public key based on all the public key shares [ algo : p_dpop_value : keys_end ]    [ algo : p_dpop_value : while ] choose a new root ( algorithm  [ algo : reroot ] , section  [ sec : reroot ] ) construct a new pseudo - tree rooted at the new root ( online appendix  2 ) exchange codenames for @xmath34 and its domain @xmath92 ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : codenames ] to  [ algo : p_dpop : send_codenames])[algo : p_dpop_value : codenames ] choose and exchange obfuscation key for @xmath34 ( algorithm  [ algo : p_dpop ] , lines [ algo : p_dpop : got_keys ] to  [ algo : p_dpop : send_keys ] ) propagate feasibility values up the pseudo - tree ( algorithm  [ algo : utilpropagation ] , except line  [ algo : utilpropagation : argmin ] ) [ algo : p_dpop_value : utilpropagation ] * if * @xmath34 is root * then * add local constraint @xmath177 , with @xmath178 from algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : root_value ] [ algo : p_dpop_value : ground ]      algorithm  [ algo : p_dpop_value ] patches the decision privacy leak in p - dpop@xmath0 by removing its decision propagation phase .",
    "only the root variable is assigned a value , and in order for all variables to be assigned values , each variable is made root in turn ( unless the first feasibility propagation has revealed that the problem is infeasible , in which case the algorithm can terminate early ) .",
    "the intuition behind this p@xmath1-dpop@xmath0 algorithm is therefore that p - dpop@xmath0 s bottom - up feasibility propagation phase is repeated multiple times , each time with a different variable  @xmath34 as the root of the pseudo - tree ( lines [ algo : p_dpop_value : while ] to  [ algo : p_dpop_value : utilpropagation ] ) . at the end of each iteration",
    ", a constraint @xmath177 is added to the problem to enforce consistency across iterations ( line  [ algo : p_dpop_value : ground ] ) .      to iteratively reroot the pseudo - tree , we propose to use an improved version of the rerooting procedure we initially introduced for the p@xmath2-dpop algorithm @xcite .",
    "this procedure requires that each of the @xmath62 variables be assigned a unique i d ; an algorithm to achieve this is presented in online appendix  3 .",
    "this algorithm reveals to each variable  @xmath34 its unique i d  @xmath166 , as well as a tight strict lower bound on the next unique i d  @xmath167 ( i.e. the next unique i d equals @xmath179 ) , and an upper bound @xmath168 on the total number of variables . each variable  @xmath34 then creates a boolean vector  @xmath180 with a single zero entry at the index corresponding to its unique i d  @xmath166 ( algorithm  [ algo : p_dpop_value ] , line  [ algo : p_dpop_value : vector ] ) ; this vector is then shuffled using a random permutation used to hide the sequence in which variables become roots .    to keep the permutation secret , the vector is first encrypted using elgamal encryption ( appendix  [ sec : elgamal ] ) , based on a compound public key jointly produced by the agents ( algorithm  [ algo : p_dpop_value ] , lines [ algo : p_dpop_value : keys_start ] to  [ algo : p_dpop_value : keys_end ] ) .",
    "this asymmetric encryption scheme enables each agent to ( re-)encrypt the entries in the vectors using a common public key , such that the decryption can only be performed collaboratively by all the agents , using their respective private keys .",
    "shufflevectors ( ) for variable  @xmath34 @xmath181 large random number [ algo : reroot : myid ] @xmath182 random permutation of @xmath183 $ ]    @xmath184 toprevious((vect , @xmath185 , 1 ) ) as in algorithm  [ algo : routing ] in appendix  [ sec : routing ] [ algo : reroot : start1 ]    wait for a message ( vect , @xmath186 ) from the next variable    * if * @xmath187 * then * * for * @xmath188 * do * @xmath189 \\leftarrow -1 $ ] [ algo : reroot : addmin1 ] * else * @xmath190 [ algo : reroot : start2 ]    [ algo : reroot : endi ] @xmath190 [ algo : reroot : starti ]    * if * @xmath191 * then * @xmath192 [ algo : reroot : shuffle ] @xmath193 [ algo : reroot : end4 ] * continue *    @xmath194 toprevious((vect , @xmath186 ) ) as in algorithm  [ algo : routing ] in appendix  [ sec : routing ]    reroot ( ) for variable  @xmath34 * repeat * @xmath195 decrypt@xmath196 * while * @xmath197 * if * @xmath198 * then * @xmath34 is the new root    the agents then proceed as in algorithm  [ algo : reroot ] .",
    "each variable  @xmath34 first starts the procedure shufflevectors ( ) , which is run only once  this is a performance improvement over our previous work @xcite , where it was performed at each iteration .",
    "all the vectors are passed from variable to variable in a round - robin fashion , using a circular message routing algorithm presented in appendix  [ sec : routing ] .",
    "each agent applies a secret permutation to each vector to shuffle it .",
    "shufflevectors ( ) proceeds in four rounds . during round  1 ( started on line  [ algo : reroot : start1 ] , algorithm  [ algo : reroot ] ) , each vector makes a full round along the circular ordering , during which each variable  @xmath34 overwrites some of the entries with  @xmath199 ( line  [ algo : reroot : addmin1 ] ) , at the same positions it did for its own @xmath180 ( algorithm  [ algo : p_dpop_value ] , line  [ algo : p_dpop_value : vector ] ) .",
    "these @xmath199 entries account for the ids in @xmath200 $ ] that have not been assigned to any variable ( online appendix  3 ) .",
    "once @xmath34 has received back its own @xmath180 , it enters the incomplete round  2 ( line  [ algo : reroot : start2 ] ) during which @xmath180 is passed on until it reaches the current root ( line  [ algo : reroot : endi ] ) .",
    "the root then starts round  3 ( line  [ algo : reroot : starti ] ) , during which each variable  @xmath34 shuffles each vector using its secret permutation  @xmath33 ( line  [ algo : reroot : shuffle ] ) .",
    "the incomplete round  4 returns the fully shuffled vector to its owner ( line  [ algo : reroot : end4 ] ) .",
    "to reroot the variable ordering at the beginning of each iteration of p@xmath201-dpop@xmath0 , each variable  @xmath34 calls the procedure reroot ( ) , which removes and decrypts the first element of @xmath180 .",
    "entries that decrypt to  @xmath199 correspond to unassigned ids and are skipped .",
    "the single entry that decrypts to  0 identifies the new root .",
    "the decryption process ( algorithm  [ algo : collaborative_decryption ] ) is a collaborative effort that involves each variable using its private elgamal key to partially decrypt the cyphertext , which travels around the circular variable ordering in the same way as the vectors , until it gets back to its sender variable , which can finally fully decrypt it .",
    "decrypt@xmath202 for variable  @xmath34    @xmath203 large random number used as a secret codename for  @xmath34 @xmath204",
    "toprevious((decr , @xmath205 , @xmath206 ) ) as in algorithm  [ algo : routing ] wait for message ( decr , @xmath205 , @xmath207 ) from next variable in the ordering decryption of @xmath206 using @xmath34 s private key    collaborativedecryption@xmath208 for variable  @xmath34    wait for a message ( decr , @xmath209 , @xmath206 ) from next variable in the ordering @xmath210 partial decryption of @xmath206 using @xmath34 s private key toprevious((decr , @xmath209 , @xmath207 ) ) as in algorithm  [ algo : routing ]",
    "we first analyze the completeness and complexity properties of the p@xmath1-dpop@xmath145 algorithms , and then we move on to their privacy properties .",
    "[ thm : p_dpop_value ] provided that there are no codename clashes , the p@xmath1-dpop@xmath0 algorithm terminates and returns a feasible solution to the discsp , if there exists one .    on the basis of theorem  [ thm : p_dpop ] , it remains to prove that the rerooting algorithm  [ algo : reroot ] terminates and is correct , and that the overall algorithm remains correct .",
    "the latter is easy to prove : at each iteration , a feasible value is found for the root variable ( if there exists one ) , and that value is necessarily consistent with the chosen assignments to previous roots since these assignments are enforced by new , additional constraints ( algorithm  [ algo : p_dpop_value ] , line  [ algo : p_dpop_value : ground ] ) .",
    "when it comes to the rerooting procedure , the unique i d assignment algorithm ( online appendix  3 ) ensures that each of the @xmath62 variables gets a unique i d in @xmath211 .",
    "therefore , each variable has a 0  entry at a unique position in its vector ( algorithm  [ algo : p_dpop_value ] , line  [ algo : p_dpop_value : vector ] ) .",
    "round  1 of algorithm  [ algo : reroot ] also makes sure that all vectors have @xmath199  entries at the same positions .",
    "this ensures that exactly one variable will become the new root at each iteration , since all vectors are applied the same sequence of permutations , and no variable will be root twice .    in terms of complexity ,",
    "p@xmath1-dpop@xmath0 proceeds in a similar way to p - dpop@xmath0 ( section  [ sec : p_dpop_properties ] ) , except that the bottom - up feasibility propagation phase is repeated @xmath62  times ( each time with a different root variable ) .",
    "the overall complexity in information exchange therefore becomes @xmath212 , where @xmath213 is the maximum separator size over all variables , _ and _ over all iterations , which therefore is likely to be higher than the exponent for p - dpop@xmath0 .",
    "the information exchanged by the rerooting protocol is negligible in comparison .",
    "the runtime complexity ( measured in number of constraint checks ) is also @xmath212 , but the memory complexity is only @xmath214 , because removing the decision propagation phase makes it become unnecessary to compute and record @xmath215 ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : argmin ] ) .",
    "our experimental results on graph coloring benchmarks ( section  [ sec : coloring ] ) suggest that the median value of @xmath216 may only be greater than the median value of @xmath139 in p - dpop@xmath0 by a small multiplicative factor . in terms of number of elgamal cryptographic operations ,",
    "the rerooting procedure requires a total of @xmath217 encryptions : each of the @xmath62  variables ( re-)encrypts @xmath218 vectors of size  @xmath168 ( each variable s vector performs 3 full rounds , except for the root s vector , which performs only 2 full rounds ) , with @xmath219 , where @xmath220 is a constant input parameter of the algorithm .",
    "the procedure also requires a total of @xmath221 collaborative decryptions : each of the @xmath62  variables ( partially ) decrypts @xmath62  vectors or size  @xmath168 .      the p@xmath1-dpop@xmath145 algorithms guarantee full agent privacy .",
    "the unique i d assignment and circular routing algorithms guarantee full agent privacy , as demonstrated respectively in online appendix  3 and appendix  [ sec : routing ] .",
    "pseudo - tree rerooting ( algorithm  [ algo : reroot ] ) : :    the messages sent by shufflevectors ( ) contain a variable i d , a vector    of elgamal cyphertexts , and a round number .",
    "the i d is used by the    recipient to detect whether the vector is its own vector ; it is a    large random number chosen by the owner agent    ( algorithm  [ algo : reroot ] , line  [ algo : reroot : myid ] ) , and therefore it    can not be linked to the identity of this owner agent by any other    agent .",
    "the elgamal vector and the round number also do not contain any    information that could be used to identify the agent . also note that    the procedure used to exchange elgamal public key shares    ( algorithm  [ algo : p_dpop_value ] , lines [ algo : p_dpop_value : keys_start ]    to  [ algo : p_dpop_value : keys_end ] ) does not leak any information about    agents identities .",
    "the reroot ( ) procedure then makes use of the    collaborative decryption algorithm , whose properties in terms of agent    privacy are discussed below .",
    "collaborative decryption ( algorithm  [ algo : collaborative_decryption ] ) : :    the procedure exchanges messages that contain an elgamal cyphertext ,    and a codename used like the variable i d in algorithm  [ algo : reroot ] .",
    "this codename is similarly set to a large random number chosen by the    current agent , and can not be linked to the identity of this agent by    any other agent .",
    "this concludes the proof that the p@xmath1-dpop@xmath145 algorithms guarantee agent privacy .",
    "the topology privacy in p@xmath1-dpop@xmath145 is only slightly worse than in p - dpop@xmath145 .",
    "the p@xmath1-dpop@xmath145 algorithms guarantee _ partial _ topology privacy .",
    "each variable unavoidably discovers the total number of variables in the problem , and _ might _ also discover a lower bound on a neighbor variable s degree in the constraint graph .",
    "the advantages of p@xmath1-dpop@xmath0 over p@xmath1-dpop are the same as p - dpop@xmath0 over p - dpop .",
    "since there is one feasibility propagation phase per variable in the problem , the total number of variables inevitably becomes public .",
    "the following analyzes the topology privacy properties of each phase of p@xmath1-dpop@xmath145 that is not already present in p - dpop@xmath145 , except for unique i d assignment ( online appendix  3 ) and secure message routing ( appendix  [ sec : routing ] ) .",
    "exchange of elgamal key shares ( algorithm  [ algo : p_dpop_value ] , lines [ algo : p_dpop_value : keys_start][algo : p_dpop_value : keys_end ] ) : :    the messages containing elgamal key shares do not contain any    information that could be used to make inferences about the topology    of the constraint graph .",
    "pseudo - tree rerooting ( algorithm  [ algo : reroot ] ) : :    each message travels along a circular variable ordering using the    message routing algorithm in appendix  [ sec : routing ] , and contains :    +    * a vector that is encrypted ( and re - encrypted after each operation )    and that therefore can not provide any topological information ;    * an @xmath222 that identifies the owner of the vector ; being a    secret , large random number",
    ", only the owner of the vector can identify    itself ;    * a round number can take the following values :    * *",
    "@xmath223 only indicates that the vector is being    modified , each variable setting in turn some of the values    to  @xmath199 ;    * * @xmath224 only indicates that the vector is being    sent to the root of the pseudo - tree .",
    "this does not happen for the    vector of the ( unknown ) root ;    * * @xmath191 only indicates that the vector is being    shuffled by each variable ;    * * @xmath225 only indicates that the vector is on its    way back to its owner .",
    "this does not happen for the vector belonging    to the ( unknown ) root .",
    "+    reroot ( ) then uses the decryption algorithm whose properties are    described below .",
    "collaborative decryption ( algorithm  [ algo : collaborative_decryption ] ) : :    decr messages are passed along the circular variable ordering ,    containing a secret codename for the original sender variable , which    is the only variable capable of deciphering this codename . the last    part of the message payload is an elgamal cyphertext , which remains    encrypted until it reaches back the original sender , and therefore    does not leak any topological information .",
    "this concludes the proof that p@xmath1-dpop@xmath145 guarantees _ partial _ topology privacy .",
    "the constraint privacy properties of the p@xmath1-dpop@xmath145 algorithms differ from those of p - dpop@xmath145 , because the former protect decision privacy ( which benefits constraint privacy ) , but also reveal the total number of variables in the problem ( which hurts constraint privacy ) .    the p@xmath1-dpop@xmath145 algorithms guarantee _ partial _ constraint privacy .",
    "the leaks are the same as in p - dpop@xmath145 ( section  [ sec : constraint_privacy : obfuscation ] ) , but they happen less frequently .",
    "single - variable feasibility messages leak the same amount of constraint privacy as in p - dpop@xmath145 ; notice however that , since the p@xmath1-dpop@xmath145 algorithms now reveal the total number of variables , in some circumstances it may be possible for a variable to discover that a child is a leaf , and that the feasibility message it sends therefore contains information about its local subproblem only . however , multi - variable feasibility messages leak potentially much less information than in p - dpop@xmath145 : consider again the simpler and non - restrictive case of a two - variable message @xmath159 received by  @xmath160 . because p@xmath1-dpop@xmath145 now protects decision privacy , @xmath160 no longer discovers the value  @xmath226 chosen for  @xmath161 , and is therefore no longer able to infer which of the entries corresponding to @xmath163 decrypts to  @xmath31 .",
    "one exception is when the following three conditions simultaneously hold : 1 )  p@xmath1-dpop is used , 2 ) the codename  @xmath161 refers to a variable  @xmath227 that is a neighbor of  @xmath160 , and 3 ) @xmath226 is semi - private information to  @xmath160 ; then @xmath160 will still discover  @xmath226 , and will be able to make the same inferences as in p - dpop@xmath145 .",
    "if the first condition is not satisfied , i.e. p@xmath1-dpop@xmath0 is used instead of p@xmath1-dpop , then @xmath160 will not be able to link the codename  @xmath161 to any known variable .",
    "this is also the case if p@xmath1-dpop is used , but the second condition does not hold . finally ,",
    "if the first two conditions hold , @xmath160 will only be able to discover  @xmath226 if it is semi - private information , i.e. if it can infer it only from its knowledge of the problem , and of its own chosen value  @xmath228 .",
    "[ thm : full_decision ] the p@xmath1-dpop@xmath145 algorithms guarantee full decision privacy .",
    "the leak of decision privacy in p - dpop@xmath145 is fixed by removing the decision propagation phase . instead ,",
    "the variable ordering is rerooted , and the feasibility propagation phase is restarted .",
    "it is not possible to compare the feasibility messages received from one iteration to the next to infer the decision that has been made at the previous iteration : the messages are not comparable , since different codenames and obfuscation keys are used .",
    "we now describe how the previous , non - fully secure obfuscation scheme can be replaced with elgamal homomorphic encryption ( appendix  [ sec : elgamal ] ) to achieve full constraint privacy , which corresponds to the original p@xmath2-dpop algorithm @xcite , improved by the use of multiple codenames .",
    "an important limitation of the elgamal scheme is that it is not _ fully homomorphic _ : it is possible to compute the _ or _ of two encrypted booleans , but it is only possible to compute the _ and _ of an encrypted boolean with a _ cleartext _ boolean . as a consequence ,",
    "the bottom - up feasibility propagation has to be performed on a variable ordering such that each variable can have only _ one _ child , i.e. a _ linear _ variable ordering ( figure  [ fig : circular_ordering ] ) , using the message routing algorithm in appendix  [ sec : routing ] .",
    "otherwise , in a pseudo - tree variable ordering , a variable with two children would not be able to join the two encrypted feasibility messages sent by the children .",
    "this could be addressed using the fully homomorphic encryption scheme by @xcite , however it is unclear whether this scheme would be practically applicable and would have sufficient performance .",
    "[ scale=.8 ]    = [ circle , draw = black , thick , fill = white , minimum size = 0.7 cm , inner sep=0pt , draw ]    ( x1 ) at ( 16:2 ) @xmath24 ; ( x2 ) at ( 90:2 ) @xmath19 ; ( x1 )  ( x2 ) [ thick , dashed ] ;    ( x3 ) at ( 162:2 ) @xmath20 ; ( x2 )  ( x3 ) [ thick ] ;    ( x5 ) at ( 234:2 ) @xmath22 ; ( x3 )  ( x5 ) [ thick ] ;    ( x4 ) at ( 306:2 ) @xmath26 ; ( x3 )  ( x4 ) [ thick ] ; ( x4 )  ( x1 ) [ thick ] ;        @xmath19 & @xmath47 & @xmath48 & @xmath49 + & @xmath229 & @xmath230 & @xmath229 +        & + @xmath20 & @xmath47 & @xmath48 & @xmath49 + @xmath47 & @xmath229 & @xmath230 & @xmath229 + @xmath48 & @xmath229 & @xmath229 & @xmath229 + @xmath49 & @xmath229 & @xmath229 & @xmath229 +    = [ circle , draw = black , thick , fill = white , minimum size = 0.7 cm , inner sep=0pt , draw ]    ( x1 ) at ( 0 , 0 ) @xmath24 ; ( x4 ) at ( -2 , 0 ) @xmath26 ; ( x1 ) .. controls ( -1 , -.5 ) .. ( x4 ) [ thick ] ;    ( x5 ) at ( -4 , 0 ) @xmath22 ; ( x4 ) .. controls ( -3 , .5 ) .. ( x5 ) [ thick ] ;    ( x3 ) at ( -6 , 0 ) @xmath20 ; ( x5 ) .. controls ( -5 , -.5 ) .. ( x3 ) [ thick ] ;    ( x2 ) at (-8 , 0 ) @xmath19 ; ( x3 ) .. controls ( -7 , .5 ) .. ( x2 ) [ thick ] ;     & + @xmath20 & @xmath47 & @xmath48 & @xmath49 + @xmath47 & @xmath229 & @xmath230 & @xmath229 + @xmath48 & @xmath229 & @xmath229 & @xmath229 + @xmath49 & @xmath230 & @xmath230 & @xmath230 +        & + @xmath26 & @xmath47 & @xmath48 & @xmath49 + @xmath47 & @xmath229 & @xmath229 & @xmath229 + @xmath48 & @xmath229 & @xmath229 & @xmath230 + @xmath49 & @xmath229 & @xmath230 & @xmath229 +         in contrast to figure  [ fig : dfs ] , which illustrates multi - party dynamic programming on a pseudo - tree variable ordering ( counting constraint violations ) , figure  [ fig : dynamic_programming ] shows ( in cleartext ) how it can be carried out on a linear ordering ( in the boolean domain ) .",
    "this assumes that a circular communication structure has preliminarily been set up as described in appendix  [ sec : routing ] .",
    "algorithm  [ algo : onevar_propagate ] gives the detailed pseudocode for this procedure , and is intended as a replacement for line  [ algo : p_dpop_value : utilpropagation ] in algorithm  [ algo : p_dpop_value ] .",
    "the differences with the pseudo - tree - based algorithm  [ algo : utilpropagation ] are the following .",
    "first , while algorithm  [ algo : utilpropagation ] initially reformulated the discsp into a max - discsp so as to minimize the number of constraint violations , algorithm  [ algo : onevar_propagate ] works directly on the original discsp problem .",
    "this means that the conjunction operator  @xmath231 replaces the sum operator ( lines [ algo : nevar_propagate : local_join ] and  [ algo : onevar_propagate : join ] ) , and the disjunction operator  @xmath232 replaces the operator  @xmath233 ( line  [ algo : onevar_propagate : project ] ) .",
    "notice also that , in the case of the linear ordering , a variable s local subproblem no longer necessarily involves its parent variable in the ordering ( line  [ algo : nevar_propagate : local_join ] ) , just like @xmath26 shares no constraint with  @xmath22 in figures",
    "[ fig : circular_ordering ] and  [ fig : dynamic_programming ] .",
    "@xmath234 [ algo : nevar_propagate : local_join ]    @xmath235 replace @xmath99 in @xmath236 with @xmath101 from algorithm  [ algo : p_dpop ] , line  [ algo : p_dpop : codenames ] , and apply the permutation  @xmath102 to  @xmath103 [ algo : onevar_propagate : codenames ]    wait for the message ( feas , @xmath237 ) from the next variable in the ordering @xmath238 identify @xmath108 as @xmath109 in @xmath239 ( if @xmath110 is present ) @xmath240 [ algo : onevar_propagate : join ]    @xmath241 [ algo : onevar_propagate : project ]    toprevious((feas , @xmath242 ) ) as in algorithm  [ algo : routing ] [ algo : onevar_propagate : send ]    * else * @xmath243 feasiblevalue@xmath244 as in algorithm  [ algo : log_decryption ] [ algo : onevar_propagate : decrypt ]    the next difference is that variable  @xmath34 no longer partially de - obfuscates its feasibility matrix before projecting itself ( algorithm  [ algo : utilpropagation ] , line  [ algo : utilpropagation : deobfuscation ] ) .",
    "the reason is that the elgamal scheme is homomorphic , and therefore it is no longer necessary to first ( partially ) decrypt the feasibility values to project  @xmath34 using the operator  @xmath245 .",
    "only the root variable requires decryption ( algorithm  [ algo : onevar_propagate ] , line  [ algo : onevar_propagate : decrypt ] ) to find a value  @xmath178 for its variable  @xmath34 whose encrypted feasibility value decrypts to  ` true ` ( if any ) .",
    "this is described in the following section .",
    "the decryption of feasibility values at the root is a collaborative process in which each variable partially decrypts the cyphertext using its private key ( algorithm  [ algo : collaborative_decryption ] ) .",
    "the dichotomy procedure in algorithm  [ algo : log_decryption ] uses at least @xmath246 and at most @xmath247 decryptions to find a feasible assignment to the root variable , or to detect infeasibility .",
    "feasiblevalue@xmath248    @xmath249 $ ]    @xmath250 decrypt@xmath251 as in algorithm  [ algo : collaborative_decryption ] *",
    "if * @xmath252 * then * * return * feasiblevalue@xmath253 * else return * feasiblevalue@xmath254 - i } \\right ) \\right)$ ]    @xmath250 decrypt@xmath255 as in algorithm  [ algo : collaborative_decryption ]      we first analyze the completeness and complexity properties of the p@xmath2-dpop@xmath145 algorithms , and then we move on to their privacy properties .      provided that there are no codename clashes , the p@xmath2-dpop@xmath0 algorithm terminates and returns a feasible solution to the discsp , if there exists one .",
    "termination follows from theorem  [ thm : p_dpop_value ] , and from the fact that the message routing procedure in appendix  [ sec : routing ] guarantees all feasibility messages eventually reach their destinations . when it comes to completeness",
    ", the homomorphic property of the elgamal scheme ensures the projection of a variable  @xmath34 out of an encrypted feasibility matrix is correct , and that the feasibility message received by each variable in the linear ordering summarizes the ( encrypted ) feasibility of the lower agents aggregated subproblems , as a function of higher variables .",
    "in particular , the feasibility message received by the root allows it to find a value for its variable that satisfies the overall problem , if there exists one .",
    "the analysis of the complexity of the algorithm remains similar to the analysis in section  [ sec : p_dpop_value_properties ] : it is @xmath256 in information exchange and in number of constraint checks , and @xmath257 in memory , but @xmath258 is now the maximum separator size _ along the successive linear variable orderings _ , instead of along the pseudo - trees .",
    "the requirement that each variable may have at most one child tends to make this exponent increase significantly , as illustrated empirically in section  [ sec : results ] . in terms of number of elgamal cryptographic operations ,",
    "in addition to the cost of rerooting the variable ordering ( section  [ sec : p_dpop_value_properties ] ) , the algorithm also requires @xmath256 encryptions , and only @xmath259 collaborative decryptions .      the p@xmath2-dpop@xmath145 algorithms guarantee full agent privacy .",
    "the only changes introduced in p@xmath2-dpop@xmath145 with respect to p@xmath1-dpop@xmath145 are in feasibility propagation , and in finding a feasible value for the root variable .",
    "elgamal feasibility propagation ( algorithm  [ algo : onevar_propagate ] ) : :    from the point of view of agent privacy , this is the same procedure as    algorithm  [ algo : utilpropagation ] , but using algorithm  [ algo : routing ]    for message routing , both of which algorithms guarantee agent privacy .",
    "root variable assignment ( algorithm  [ algo : log_decryption ] ) : :    this consists in iteratively calling the procedure in    algorithm  [ algo : collaborative_decryption ] , which has already been    shown to guarantee agent privacy .    this concludes the proof that the p@xmath2-dpop@xmath145 algorithms guarantee agent privacy .      the p@xmath2-dpop@xmath145 algorithms guarantee _ partial _ topology privacy .",
    "in addition to the limited leaks of topology privacy in p@xmath1-dpop@xmath145 , an agent _ might _ also be able to discover that there exists another branch in the constraint graph that it is not involved in .",
    "there are only two relevant differences with p@xmath1-dpop@xmath145 : the linear variable ordering , and the choice of a value for the root variable that requires collaborative decryption .",
    "elgamal feasibility propagation ( algorithm  [ algo : onevar_propagate ] ) : :    to exchange feas messages along a linear variable ordering , the    algorithm makes use of the circular message routing procedure , which    is shown in appendix  [ sec : routing ] to guarantee full topology privacy .",
    "however , the last variable in the linear ordering needs to know it is    the last in order to initiate the feasibility propagation ; therefore ,    by contraposition , non - last variables know they are not the last , and ,    in particular , non - last leaves of the pseudo - tree discover the    existence of another branch .",
    "this minor leak of topology privacy is    already present in the unique variable i d assignment algorithm ( online    appendix  3 ) . besides this",
    ", the topology privacy properties of the    feasibility propagation phases in p@xmath2-dpop and    p@xmath2-dpop@xmath0 are the same as in p - dpop and    p - dpop@xmath0 , respectively .",
    "root variable assignment ( algorithm  [ algo : log_decryption ] ) : :    this algorithm involves recursively calling the collaborative    decryption procedure , shown to guarantee full topology privacy .    this concludes the proof that p@xmath2-dpop@xmath145 guarantees _ partial _ topology privacy .      the p@xmath2-dpop@xmath145 algorithms guarantee full constraint privacy .",
    "the p@xmath2-dpop@xmath145 algorithms fix all the leaks of constraint privacy in p@xmath260-dpop@xmath145 , by replacing the cryptographically insecure obfuscation through addition of random numbers , by the cryptographically secure elgamal encryption ( appendix  [ sec : elgamal ] ) .",
    "this makes it no longer possible to compare two encrypted feasibility values without decrypting them , which would require the collaboration of all agents ( or an amount of computation to break the encryption that can be made arbitrarily high in the worst case by increasing the elgamal key size ) .",
    "in particular , while it is possible to compute the logical _ or _ of two cyphertexts without decrypting them , the result remains encrypted , and can not be compared to the two inputs to decide which one is  ` true ` , if any .      the p@xmath2-dpop@xmath145 algorithms guarantee full decision privacy .",
    "the same proof applies as to theorem  [ thm : full_decision ] .",
    "we report the empirical performance of our algorithms against the state - of - the - art mpc - discsp4 algorithm , on four classes of benchmarks : graph coloring , meeting scheduling , resource allocation , and game equilibrium .",
    "we only compare to mpc - discsp4 , because to our knowledge it is the only other general discsp algorithm that provides strong privacy guarantees . for each problem class , the choice of the discsp formulation is crucial , because it dictates how the four types of privacy defined based on the discsp constraint graph will relate to the actual privacy of the original problem . in particular , the p@xmath261-dpop@xmath145",
    "algorithms use the standard discsp assumption that each constraint is known to all agents owning a variable in its scope ( section  [ sec : previous_privacy ] ) .",
    "therefore , when an agent wants to hide a constraint from neighboring agents , it must express its constraint over _ copies _ of its neighbors variables .",
    "additional equality constraints must be introduced to make copy variables equal to their respective original variables .",
    "in contrast , mpc - discsp4 does not make use of this discsp assumption , and therefore it does not need the introduction of copy variables .",
    "our first performance metric is _ simulated time _",
    "@xcite , which is used , when all agents are simulated on a single machine , to estimate the time it would have taken to solve the problem if they had run in parallel on dedicated machines ( ignoring communication delays ) .",
    "the two other metrics are the number of messages and the amount of information exchanged . for each metric , we report the median over at least 100 problem instances , with 95% confidence intervals . for the obfuscation in p@xmath260-dpop@xmath145 , we used random numbers of @xmath262 128 bits , while p@xmath2-dpop@xmath145 used 512-bit elgamal encryption .",
    "mpc - discsp4 also used 512 bits for its paillier encryption . for the unique variable",
    "i d generation procedure in p@xmath263-dpop@xmath145 , the parameter @xmath220 was set to  10 .",
    "all algorithms were implemented inside the java - based frodo platform for discsp  @xcite , coupled with the csp solver jacop  @xcite .",
    "the experiments were run on a 2.2-ghz , dual - core computer , with java 1.6 and a java heap space of 2  gb .",
    "the timeout was set to 10  min ( wall - clock time ) .",
    "we first report the performance of the algorithms on distributed , 3-color graph coloring problems .",
    "the graphs were randomly generated with varying numbers of nodes , and an edge density fixed to  @xmath264 .",
    "notice that , with a fixed number of colors and a fixed edge density , increasing the number of nodes increases the degree of the graph , and therefore reduces the number of feasible solutions ; this explains the trends in some of the following graphs .",
    "the discsp formulation involves one decision variable per node , and assumes that each variable is controlled by a single - variable agent .",
    "notice that inter - agent constraints are binary inequality constraints , and therefore decision privacy is relevant to this problem class : knowing one s chosen color is insufficient to infer the respective colors of one s neighbors .",
    "to study the tradeoff between privacy and performance in mpc - discsp4 , we considered a variant denoted mpc - discsp4@xmath265 , which assumes all inter - agent inequality constraints ( i.e. node neighborhoods ) are public , and only the final choice of colors is protected .",
    "each agent first enumerates all feasible solutions to the overall problem ( section  [ sec : previous_privacy ] ) , and then uses cryptographic techniques to securely and randomly choose one of the feasible solutions . if there exists none , the algorithm therefore terminates without any cryptographic operations nor exchanging messages .",
    "this explains the phase transition for mpc - discsp4@xmath265 in the following graphs , since the probability of infeasibility increases with the problem size .",
    "figure  [ fig : graphcoloring ] shows that mpc - discsp4 ( denoted as _ mpc _ in these and all subsequent figures ) scales very poorly , timing out on problems with more than 6  nodes .",
    "mpc - discsp4@xmath265 performs better ; however , as mentioned before , it only protects the final choices of colors . for small numbers of nodes ,",
    "the total state space is small , and mpc - discsp4@xmath265 performs relatively well ; for numbers of nodes above  9 , the problem instances are mostly infeasible , and mpc - discsp4@xmath265 quickly detects infeasibility without having to exchange any message .",
    "the most efficient algorithms by far are p - dpop@xmath145 , whose performance curves are at least one order of magnitude below all other algorithms . in particular , p - dpop s runtime is sensibly the same as dpop ( the communication overhead is almost solely due to the root election algorithm ) .",
    "the cost of improved topology privacy in p - dpop@xmath0 vs. p - dpop only starts to show for problem sizes above  7 , when the induced widths of p - dpop@xmath0 s pseudo - trees start to deviate from p - dpop and dpop .",
    "full decision privacy comes at much higher costs : p@xmath1-dpop@xmath145 s curve is between 1 and 3 orders of magnitude above p - dpop@xmath145 s , even though their induced widths remain sensibly the same .",
    "this suggests that rerooting the pseudo - tree ( which involves expensive cryptographic operations ) is by far the complexity bottleneck , even when full constraint privacy is additionally guaranteed as in p@xmath2-dpop@xmath145 , whose linear variable orderings nevertheless have significantly higher induced widths than p@xmath260-dpop@xmath145 s pseudo - tree orderings .",
    "notice that the slope of the runtime curve decreases as the problem size increases ; this is due to the fact that more and more problems become infeasible , and the p@xmath263-dpop@xmath145 algorithms are able to terminate after the first iteration on infeasible problems . similarly to p - dpop@xmath0 vs. p - dpop , the cost of improved topology privacy is only visible above 7  nodes ; p@xmath2-dpop@xmath0 even timed out on problems of size  10 .",
    "finally , figure  [ fig : graphcoloring ] illustrates the fact that mpc - discsp4 tends to send large numbers of small messages , while the p@xmath263-dpop@xmath145 algorithms send lower numbers of larger messages .",
    "figure  [ fig : graphcoloring_large ] compares the performance of p - dpop@xmath145 against dpop on larger graph coloring problem instances . on such larger problems ,",
    "the improved topology privacy in p - dpop@xmath0 comes at a complexity price that is too high to scale above 12  nodes . on the other hand , p - dpop s curves are only between one and two orders of magnitude above dpop , and p - dpop s",
    "median runtime on problem instances of size  22 is below 30  s.      we now report experimental results on random meeting scheduling benchmarks .",
    "we varied the number of meetings , while keeping the number of participants per meeting to  2 . for each meeting ,",
    "participants were randomly drawn from a common pool of 3 agents .",
    "the goal is to assign a time to each meeting among 8  available time slots , such that no agent is required to attend simultaneous meetings .",
    "the pool of agents was deliberately chosen small to increase the complexity of the problems , by increasing the probability that each agent take part in multiple meetings .",
    "note that fixing the pool size and the number of participants per meeting still generates an unbounded number of different problem instances as we increase the number of meetings , since the state space ( the cartesian product of the domains of the decision variables ) keeps increasing with the number of meetings / decisions to be made .",
    "the discsp formulation for this problem class was the following .",
    "each agent owns one variable of domain size  8 for each meeting it participates in .",
    "there is an _",
    "alldifferent _ constraint over all its variables to enforce that all its meetings are scheduled at different times . for each meeting ,",
    "a binary equality constraint expressed over the corresponding variables owned by the two participants enforces that the participants agree on the time for the meeting .",
    "notice that all inter - agent constraints are binary equality constraints , and therefore p@xmath201-dpop@xmath145 do not bring any additional privacy compared to p - dpop@xmath145 , since the values of neighboring variables are semi - private information ; therefore , we do not report the performance of p@xmath201-dpop@xmath145 .",
    "for mpc - discsp4 , we simplified the formulation by only introducing one variable per meeting , owned by its initiator .",
    "this way , for each meeting , only its initiator is made public , but its exact list of participants remains secret ( it is only revealed _ a posteriori _ to the participants of the meeting when they attend it ) .    as can be seen in figure  [ fig : meetings ] ,",
    "p@xmath2-dpop s performance is comparable to that of mpc - discsp4 ( but with much stronger privacy guarantees ) , although the former sends significantly more information on the smallest problems , but significantly fewer messages on the largest problems they could solve within the timeout limit . on the other hand , because it is a majority threshold scheme , mpc - discsp4 actually could not provide any privacy guarantees on problems of size  1 , since they only involved 2  agents .",
    "both algorithms could only scale up to problems of size  4 , and timed out on larger problems .",
    "p@xmath2-dpop@xmath0 s increased topology privacy comes at a price that made it time out earlier than p@xmath2-dpop ; this complexity increase is due to p@xmath2-dpop@xmath0 s steeper induced width curve .",
    "the p - dpop@xmath145 algorithms remain the most efficient by far : they perform between 1 and  2 orders of magnitude better than all others , both in terms of runtime and information exchanged . and like for graph coloring , the improved topology privacy in p - dpop@xmath0 comes at a price that is negligible for small problems , but can grow to one order of magnitude on problems of size  6 , even if its induced width remains close to that of p - dpop . in terms of runtime and information exchange ,",
    "p - dpop is only worse than dpop by a small factor ( since it has the same median induced width ) ; however it sends approximately one order of magnitude more messages ( which is mostly due to the pseudo - tree root election mechanism ) .",
    "next , we performed experiments on distributed resource allocation benchmarks .",
    "problem instances were produced using the combinatorial auction problem generator cats  @xcite , ignoring bid prices .",
    "we used the _ temporal matching _",
    "distribution modeling the allocation of airport takeoff / landing slots , fixing the total number of slots ( i.e. resources ) to  8 , and varying the numbers of bids .",
    "each bid is a request for a bundle of 2 resources ( a takeoff slot and a corresponding landing slot ) .",
    "multiple requests may be placed by the same airline company ; each airline should have exactly one fulfilled .",
    "this problem was modeled as a discsp as follows @xcite .",
    "one agent is introduced for each bidder / airline and for each resource / slot , assuming that each resource is controller by a different resource provider / airport . for each resource",
    "@xmath266 , and for each bidder  @xmath48 that requests the resource , there is one binary variable  @xmath267 controlled by the resource provider , which models whether @xmath48 is allocated the resource ( @xmath268 ) or not ( @xmath269 ) .",
    "the resource provider also expresses one constraint @xmath270 over all her variables to enforce that her resource can only be allocated to at most one of the interested bidders . for each variable  @xmath267",
    ", we also introduce one copy variable  @xmath271 owned by the bidder  @xmath48 , with the constraint  @xmath272 . each bidder",
    "@xmath48 then expresses a constraint over all her variables , enforcing that she should only be allocated two resources that correspond exactly to one of her requests .",
    "the introduction of copy variables is motivated by the discsp assumption that each agent knows all constraints involving its variables , and serves two privacy - related purposes : 1 ) the full list of agents placing requests on a given resource is only known to the resource provider , and 2 ) the full list of resources requested by a given agent ( and in which bundles ) is only known to the agent itself . like for the meeting scheduling problem class , all inter - agent constraints are equality constraints , therefore we do not report the performance of p@xmath201-dpop@xmath145 , whose privacy guarantees are the same as p - dpop@xmath145 .    for mpc - discsp4 ,",
    "the discsp formulation was simplified by not introducing copy variables hold by bidders , since they are not necessary to protect constraint privacy : bidders can request resources by expressing constraints directly over the variables owned by the resource providers .",
    "however , since mpc - discsp4 assumes that all variables are public , in order to increase topology privacy we introduced , for each resource , as many variables as bidders , regardless of whether they are actually interested in the resource .",
    "to reduce the size of the search space , we assumed that the @xmath273 constraints were public .",
    "figure  [ fig : auctions ] shows that the performance of mpc - discsp4 decreases very fast with the number of requests , such that the algorithm was not able to scale beyond problems of size  4 .",
    "the p@xmath2-dpop@xmath145 algorithms seem to scale better , and were able to solve problems involving 5  requests . on all three metrics ,",
    "both algorithms were largely outperformed by p - dpop@xmath145 , whose runtime curve is remarkably flat , and almost overlaps with the runtime curve of dpop , which is consistent with their undistinguishable induced width curves .",
    "the overhead of p - dpop@xmath145 compared to dpop is slightly larger in terms of information exchanged , and goes up to one order of magnitude in terms of number of messages .",
    "p - dpop@xmath0 and p@xmath2-dpop@xmath0 performed the same as their respective  non - plus \" variants .      finally , we report experimental results on one last class of problem benchmarks , which corresponds to the distributed computation of pure nash equilibria in strategic games .",
    "we used the particular example of the _ party game _ introduced by @xcite , which is a one - shot , simultaneous - move , _ graphical game _",
    "@xcite in which all players are invited to a common party , and each player s possible strategies are whether to attend the party or not .",
    "players are arranged in an undirected social graph , which defines which other invitees each player knows .",
    "each player s reward for attending the party depends on whether her acquaintances also decide to attend , and on whether she likes them or not .",
    "the reward is 1 per attendee she likes , minus 1 per attendee she dislikes , and minus a constant cost of attendance in  @xmath274 $ ] .",
    "the reward for not attending is  0 .",
    "the problem of computing a nash equilibrium to such a game can be formulated into a discsp as follows .",
    "each player is an agent , which owns one binary variable for its strategy , and one copy variable for the strategy of each of its acquaintances .",
    "each variable is constrained to be equal to each of its copy variables , using binary equality constraints like for resource allocation problems ( section  [ sec : resource_allocation ] ) .",
    "each agent also expresses one constraint over all its variables , which only allows a particular strategy for the agent if it is a best response to its neighbors joint strategies .",
    "notice that the resulting constraint graph is not the same as the game graph , due to the presence of copy variables .",
    "a solution to the discsp therefore yields a joint strategy profile for all players that is a pure nash equilibrium , since each player plays best - response to her neighbors .",
    "notice also that , since each player holds a copy variable for each of her neighbors strategy , these strategies are semi - private information that can not be protected , which is why we do not report the performance of p@xmath201-dpop@xmath145 .    for mpc - discsp4",
    ", the discsp formulation can be simplified by not introducing copy variables @xcite",
    ". an interesting consequence of this difference is that , contrary to p@xmath275-dpop@xmath145 , mpc - discsp4 is then able to hide each player s chosen strategy from her neighbors . in the context of the party game , this is not very useful to players who decide to attend the party , since they will necessarily eventually discover whether their acquaintances also decided to attend or not . on the other hand",
    ", a player who declines the invitation does not _",
    "directly _ discover anything about the list of attendees",
    ". she might still be able to make indirect inferences about the decisions of her acquaintances , based on the fact that her decision to decline is a best response to their respective chosen strategies .    figure  [ fig : party ] reports on the performance of the algorithms on random acyclic game graphs of degree  2 ( i.e. trees in which each node has at most 2  children ) , with varying numbers of players .",
    "the p@xmath2-dpop@xmath145 algorithms were only able to scale up to problems of size  5 due to the rapidly increasing induced width , and were outperformed by mpc - discsp4 by at least one order of magnitude across all three metrics .",
    "both algorithms still performed largely worse than the p - dpop@xmath145 algorithms , which are capable of scaling to much larger problems .",
    "this is because , in this setting , the induced width remains bounded : since the game graphs are acyclic , dpop s induced width is constantly equal to  2 , because each feas message sent by agent  @xmath276 to its parent agent  @xmath277 is expressed only over @xmath277 s strategy variable and the copy of @xmath276 s strategy variable held by  @xmath277 .",
    "p - dpop@xmath145 s induced width is increased by 2 because agent  @xmath277 has at most 2 children in the pseudo - tree , each using a different codename for @xmath277 s strategy variable . as a result ,",
    "the performance overhead in p - dpop@xmath145 compared to dpop is minimal in terms of runtime ; it is slightly larger in information exchanged , and reaches one order of magnitude in number of messages .",
    "in this paper , we have addressed the issue of providing strong privacy guarantees in distributed constraint satisfaction problems ( discsps ) .",
    "we have defined four types of information about the problem that agents might want to hide from each other : _ agent privacy _ ( hiding an agent s identity from non - neighbors ) , _ topology privacy _ ( keeping the topology of the constraint graph private ) , _ constraint privacy _ ( protecting the knowledge of the constraints ) , and _ decision privacy _ ( the final value of each variable should only be known to its owner agent ) .",
    "departing from previous work in the literature , which only addressed subsets of these privacy types , and often focused on quantifying the privacy loss in various algorithms , we have proposed a set of algorithms with strong guarantees about what information provably will not be leaked .",
    "we have carried out performance experiments on four different classes of benchmarks : graph coloring , meeting scheduling , resource allocation , and game equilibrium computation .",
    "the results show that our algorithms not only provide stronger privacy guarantees , but also scale better than the previous state of the art .",
    "we have explored the tradeoff between privacy and performance : the p - dpop@xmath0 variant was shown to scale much better than the others , but can only guarantee partial constraint and decision privacy , which may still be considered sufficient in many problem classes .",
    "full decision privacy ( p@xmath201-dpop@xmath0 ) and full constraint privacy ( p@xmath2-dpop@xmath0 ) come at significantly higher prices in computation time and information exchange , which , with today s hardware , limits their applicability to smaller problem instances .",
    "we have compared the performance of our algorithms against the mpc - discsp4 algorithm , which can be considered the previous state of the art in discsp with strong privacy guarantees . on the first three classes of benchmarks , all our algorithms almost systematically outperformed mpc - discsp4 in terms of runtime and number of messages exchanged ; however , mpc - discsp4 proved to exchange less information than p@xmath263-dpop@xmath0 .",
    "on game equilibrium computation , mpc - discsp4 scaled much better than p@xmath2-dpop@xmath0 along all three metrics , but was still largely outperformed by p - dpop@xmath0 . in terms of practical applicability , we have shown that some of our algorithms scale to medium - size problems that are beyond reach of the previous state of the art in general discsp with strong privacy guarantees . we have also investigated the application of these algorithms to real - life meeting scheduling , in collaboration with the nokia research center in lausanne .",
    "future work could extend the techniques in this paper along several directions .",
    "first , while we have restricted ourselves to pure satisfaction problems for the sake of simplicity , our algorithms can be easily extended to solve distributed constraint optimization problems ( dcops ) .",
    "in fact , our p@xmath260-dpop@xmath0 algorithms already are optimization algorithms ; only p@xmath2-dpop@xmath0 requires some changes to be applied to dcops .",
    "these changes involve replacing elgamal - encrypted boolean feasibility values with elgamal - encrypted , bit - wise vector representations of integer cost values , as described by @xcite .",
    "this would incur an increase in complexity that is only linear in an upper bound on the cost of the optimal solution .",
    "an optimization variant of mpc - discsp4 , called _ mpc - diswcsp4 _ , was also already proposed by @xcite ; we report performance comparisons with our algorithms in other publications @xcite .",
    "further avenues of future research could result from relaxing our assumption that agents are _ honest , but curious_. a number of challenging issues arise when attempting to apply the techniques in this paper to _ self - interested _ agents that can manipulate the protocol in order to achieve solutions that better suit their selfish preferences .",
    "one such issue is that of _ verifiability _ , which involves making it possible to check whether the protocols were executed as designed , without the need to decrypt the messages exchanged . another interesting issue is whether it is possible to modify the algorithms to make them _ incentive - compatible _ , such that it is in each agent s best interest to honestly follow the protocol",
    "_ homomorphic encryption _ is a crucial building block of the privacy - preserving algorithms introduced in this paper . _",
    "encryption _ is the process by which a message  in this appendix , a boolean  can be turned into a _ cyphertext _",
    ", in such a way that decrypting the cyphertext to retrieve the initial cleartext message is impossible ( or , in this case , computationally very hard in the worst case ) without the knowledge of the secret encryption key that was used to produce the cyphertext .",
    "an encryption scheme is said to be _ homomorphic _ if it is possible to perform operations on cyphertexts that translate to operations on the initial cleartext messages , without the need to know the encryption key .",
    "_ elgamal encryption _",
    "@xcite is one such encryption scheme that possesses this homomorphic property .",
    "elgamal encryption can be used to encrypt booleans such that performing the following operations on encrypted booleans is possible without the knowledge of the decryption key :    * the and of an encrypted and a cleartext boolean ; * the or of two encrypted booleans .",
    "elgamal encryption is a homomorphic , public key cryptography system based on the intractability of the diffie - hellman problem @xcite , which proceeds as follows .",
    "let @xmath278 be a _",
    "safe prime _ of the form @xmath279 , where @xmath280  is a large random number , and @xmath281  is a large prime .",
    "all numbers and all computations will be modulo  @xmath278 .",
    "let  @xmath282 be a _ generator _ of  @xmath283 , i.e. @xmath282 is such that its powers cover  @xmath284 $ ] . with @xmath278 and  @xmath282 assumed public knowledge , the elgamal private key is a chosen random number @xmath285 $ ] , and the associated public key is @xmath286 .",
    "a cleartext number  @xmath64 is then encrypted as follows : @xmath287 where @xmath280 is a random number chosen by the encryptor .",
    "decryption proceeds as follows : @xmath288    a useful feature of elgamal encryption is that it allows to _ randomize _ an encrypted value to generate a new encryption bearing no similarity with the original value . randomizing @xmath289 in eq .",
    "( [ eq : encrypt ] ) yields : @xmath290 which still decodes to  @xmath64 . to encrypt booleans",
    ", we represent @xmath16 by @xmath32 , and @xmath17 by a value @xmath291 , which allows us to compute the and and or operations : @xmath292 @xmath293      in the previous elgamal encryption scheme , decryption can be performed in a single step , using the private key , which is a secret of the agent that originally encrypted the message .",
    "however , it is also possible to perform elgamal encryption in such a way that _ all _ agents need to cooperate in order to perform decryption .",
    "this is possible through the use of a _ compound _ elgamal key @xmath294 that is generated cooperatively by all agents @xcite :    distributed key generation : :    the elgamal key pairs @xmath295 of    @xmath62  agents can be combined in the following fashion to    obtain the compound key pair  @xmath294 :    @xmath296 distributed decryption : :    if each agent publishes its decryption share    @xmath297 , the message can be decrypted as follows :    @xmath298",
    "in order to implement the round - robin exchange of vectors briefly presented in section  [ sec : p_dpop_value_overview ] , the variables are ordered along a circular ordering that is mapped to the chosen pseudo - tree , as illustrated in figure  [ fig : circular_ordering ] ( page  ) . each variable needs to be able to send a message to the previous variable ( i.e. clock - wise ) in the ordering , which is a challenge in itself because only neighboring variables should communicate directly .",
    "furthermore , to protect agent and topology privacy , no agent should know the overall circular ordering .",
    "to solve this issue , algorithm  [ algo : routing ] is the algorithm used in p@xmath2-dpop  @xcite to route messages .",
    "toprevious@xmath299 for variable  @xmath34 * if * @xmath34 is the root of the pseudo - tree * then * send the message ( last , @xmath300 ) to @xmath34 s last child [ algo : routing : root ] * else * send the message ( prev , @xmath300 ) to @xmath34 s parent [ algo : routing : prev_to_parent ]        * if * @xmath37 is @xmath34 s first child * then * deliver the message @xmath300 to @xmath34 [ algo : routing : prev_deliver ] * else * send the message ( last , @xmath300 ) to the child before @xmath37 in @xmath34 s list of children [ algo : routing : first_last ]    consider for instance a message  @xmath300 that agent  @xmath70 wants to send to the previous variable  which is  @xmath26 , but @xmath70 does not know it",
    ". agent  @xmath70 wraps @xmath300 into a prev message that it sends to its parent variable  @xmath26 ( line  [ algo : routing : prev_to_parent ] ) . because the sender variable  @xmath24 is @xmath26 s first ( and only ) child",
    ", @xmath71 infers that it should deliver  @xmath300 to itself ( line  [ algo : routing : prev_deliver ] ) .",
    "consider that @xmath71 now wants to forward  @xmath300 to its previous variable  @xmath22 , which @xmath71 does not know .",
    "like before , @xmath71 sends a message ( prev , @xmath300 ) to its parent variable  @xmath20 , which then reacts by sending a message ( last , @xmath300 ) to its last child preceding  @xmath26 in its list of children , which is  @xmath22 ( line  [ algo : routing : first_last ] ) .",
    "last messages indicate that the payload  @xmath300 should be delivered to the last leaf of the current subtree ( line  [ algo : routing : to_last ] ) ; therefore , @xmath50 delivers  @xmath300 to itself ( line  [ algo : routing : last_deliver ] ) since it has no children .",
    "if the root wants to send a message to its previous variable , it also uses a last message to forward it to the last leaf of the overall pseudo - tree ( line  [ algo : routing : root ] ) .",
    "the goal of this algorithm is precisely to address agent privacy issues in the pseudo - tree rerooting procedure , which involves each variable sending a message to the previous variable in a circular ordering of the variables .",
    "there is no guarantee that there exist a circular ordering such that any two consecutive variables are owned by neighboring agents , which is necessary to protect agent privacy .",
    "therefore , algorithm  [ algo : routing ] is responsible for routing these messages through paths that only involve communication between neighboring agents .",
    "the routing procedure itself only involves encapsulating the routed messages inside prev or last messages , which do not contain any other payload .",
    "therefore , as long as the routed messages do not contain information that can be used to identify a non - neighboring agent , the routing procedure guarantees agent privacy .",
    "the purpose of this algorithm is to enable variables to propagate messages along a circular variable ordering , without the need to know any topological information about the constraint graph , other than the knowledge of their respective ( pseudo-)parents and ( pseudo-)children in the pseudo - tree .",
    "toprevious ( ) makes it possible to send a message to the previous variable in the circular ordering , without knowing which variable this is .",
    "* the reception of a ( prev , @xmath300 ) message only indicates that the sender child wants the included message  @xmath300 to be delivered to its previous variable , which is either the recipient of the prev message , or an unknown descendant thereof .",
    "* the reception of a ( last , @xmath300 ) message from one s parent indicates that an unknown variable ( either the unknown root of the pseudo - tree , or the unknown child of an unknown ancestor , in another branch ) wants @xmath300 to be delivered to its previous variable , which is one s descendant in the pseudo - tree .",
    "ben - or , m. , goldwasser , s. ,  wigderson , a. 1988 .",
    "completeness theorems for non - cryptographic fault - tolerant distributed computation ( extended abstract)in proceedings of the twentieth annual acm symposium on theory of computing ( stoc88 ) ,  110 .",
    "bilogrevic , i. , jadliwala , m. , hubaux , j .-",
    "p . , aad , i. ,  niemi , v. 2011 .",
    "privacy - preserving activity scheduling on mobile devicesin proceedings of the first acm conference on data and application security and privacy ( codaspy11 ) ,  261272 .",
    "brito , i.   meseguer , p. 2003 .",
    "distributed forward checkingin proceedings of the ninth international conference on principles and practice of constraint programming ( cp03 ) ,  2833 of lecture notes in computer science , 801806 .",
    "chechetka , a.   sycara , k. 2006 .",
    "no - commitment branch and bound search for distributed constraint optimizationin proceedings of the fifth international joint conference on autonomous agents and multiagent systems ( aamas06 ) ,  14271429 .",
    "doshi , p. , matsui , t. , silaghi , m .- c . ,",
    "yokoo , m. ,  zanker , m. 2008 .",
    "distributed private constraint optimizationin proceedings of the 2008 ieee / wic / acm international conference on intelligent agent technology ( iat08 ) ,  277281 .",
    "faltings , b. , laut , t. ,  petcu , a. 2008 .",
    "privacy guarantees through distributed constraint satisfactionin proceedings of the 2008 ieee / wic / acm international conference on intelligent agent technology ( iat08 ) ,  350358 .",
    "gentry , c. 2009 .",
    "fully homomorphic encryption using ideal latticesin proceedings of the forty - first annual acm symposium on theory of computing ( stoc09 ) ,  169178 .",
    "acm special interest group on algorithms and computation theory ( sigact ) .",
    "gershman , a. , meisels , a. ,  zivan , r. 2006 .",
    "asynchronous forward - bounding for distributed constraints optimizationin proceedings of the seventeenth european conference on artificial intelligence ( ecai06 ) ,  103107 .",
    "greenstadt , r. , pearce , j.  p. ,  tambe , m. 2006 .",
    "analysis of privacy loss in distributed constraint optimizationin proceedings of the twenty - first national conference on artificial intelligence ( aaai06 ) ,  647653 .",
    "gutierrez , p.   meseguer , p. 2010 .",
    "with several soft arc consistency levelsin proceedings of the nineteenth european conference on artificial intelligence ( ecai10 ) ,  215 in frontiers in artificial intelligence and applications ,  6772 .",
    "herlea , t. , claessens , j. , preneel , b. , neven , g. , piessens , f. ,  decker , b.  d. 2001 . on securely scheduling a meetingin proceedings of the sixteenth international conference on information security  trusted information : the new decade challenge ( sec01 ) , international federation for information processing ( ifip ) series ,  183198 .",
    "hirayama , k.   yokoo , m. 1997 .",
    "distributed partial constraint satisfaction problemin proceedings of the third international conference on principles and practice of constraint programming ( cp97 ) ,  1330 of lecture notes in computer science , 222236 .",
    "laut , t.   faltings , b. 2011 . coordinating logistics operations with privacy guaranteesin proceedings of the twenty - second international joint conference on artificial intelligence ( ijcai11 ) ,  24822487 .",
    "laut , t. , ottens , b. ,  szymanek , r. 2009 . : an open - source framework for distributed constraint optimizationin proc . of the ijcai09 distributed constraint reasoning workshop ( dcr09 ) ,  160164 .",
    "http://frodo2.sourceforge.net .",
    "leyton - brown , k. , pearson , m. ,  shoham , y. 2000 . towards a universal test suite for combinatorial auction",
    "algorithmsin proceedings of the second acm conference on electronic commerce ( ec00 ) ,  6676 .",
    "acm special interest group on electronic commerce ( sigecom ) .",
    "http://www.cs.ubc.ca/~kevinlb/cats .",
    "maheswaran , r.  t. , pearce , j.  p. , bowring , e. , varakantham , p. ,  tambe , m. 2006 .",
    "privacy loss in distributed constraint reasoning : a quantitative framework for analysis and its applications , 13(1 ) , 2760 .",
    "maheswaran , r.  t. , tambe , m. , bowring , e. , pearce , j.  p. ,  varakantham , p. 2004 .",
    "taking dcop to the real world : efficient complete solutions for distributed multi - event schedulingin proceedings of the third international joint conference on autonomous agents and multiagent systems ( aamas04 ) ,  1 ,  310317 .",
    "acm special interest group on artificial intelligence ( sigart ) .",
    "pedersen , t.  p. 1991 .",
    "a threshold cryptosystem without a trusted party ( extended abstract)in advances in cryptology ",
    "eurocrypt91 , workshop on the theory and application of cryptographic techniques , proceedings ,  547 of lecture notes in computer science , 522526 .",
    "silaghi , m .- c",
    ". 2005a . hiding absence of solution for a distributed constraint satisfaction problem ( poster)in proceedings of the eighteenth international florida artificial intelligence research society conference ( flairs05 ) , 854855 .",
    "silaghi , m .- c . , faltings , b. ,  petcu , a. 2006 .",
    "secure combinatorial optimization simulating dfs tree - based variable eliminationin proceedings of the ninth international symposium on artificial intelligence and mathematics .",
    "silaghi , m .- c .",
    "mitra , d. 2004 .",
    "distributed constraint satisfaction and optimization with privacy enforcementin proceedings of the 2004 ieee / wic / acm international conference on intelligent agent technology ( iat04 ) ,  531535 .",
    "silaghi , m .- c . , sam - haroud , d. ,  faltings , b. 2000 .",
    "asynchronous search with aggregationsin proceedings of the seventeenth national conference on artificial intelligence and twelfth conference on innovative applications of artificial intelligence ( aaai / iaai00 ) ,  917922 .",
    "singh , s. , soni , v. ,  wellman , m.  p. 2004 .",
    "computing approximate bayes - nash equilibria in tree - games of incomplete informationin proceedings of the fifth acm conference on electronic commerce ( ec04 ) ,  8190 .",
    "sultanik , e.  a. , lass , r.  n. ,  regli , w.  c. 2007 . : a framework for simulating and deploying distributed constraint optimization algorithmsin proceedings of the ninth international workshop on distributed constraint reasoning ( cp - dcr07 ) .",
    "tsiounis , y.   yung , m. 1998 .",
    "on the security of elgamal - based encryptionin proceedings of the first international workshop on practice and theory in public key cryptography ( pkc98 ) ,  1431 of lecture notes in computer science ,  117134 .",
    "yokoo , m. 1995 .",
    "asynchronous weak - commitment search for solving distributed constraint satisfaction problemsin proceedings of the first international conference on principles and practice of constraint programming ( cp95 ) ,  976 in lecture notes in computer science ,  88102 .",
    "yokoo , m. , durfee , e.  h. , ishida , t. ,  kuwabara , k. 1992 .",
    "distributed constraint satisfaction for formalizing distributed problem solvingin proceedings of the twelfth international conference on distributed computing systems ( icdcs92 ) ,  614621 .",
    "yokoo , m.   suzuki , k. 2002 .",
    "secure multi - agent dynamic programming based on homomorphic encryption and its application to combinatorial auctionsin proceedings of the first international joint conference on autonomous agents and multi - agent systems ( aamas02 ) ,  112119 .",
    "yokoo , m. , suzuki , k. ,  hirayama , k. 2002 .",
    "secure distributed constraint satisfaction : reaching agreement without revealing private informationin proc .",
    "conf . on principles and practice of constraint prog .",
    "( cp02 ) ,  2470 of lncs , 387401 .",
    "zivan , r.   meisels , a. 2004 .",
    "concurrent dynamic backtracking for distributed cspsin proceedings of the tenth international conference on principles and practice of constraint programming ( cp04 ) ,  3258 of lecture notes in computer science , 782787 ."
  ],
  "abstract_text": [
    "<S> as large - scale theft of data from corporate servers is becoming increasingly common , it becomes interesting to examine alternatives to the paradigm of centralizing sensitive data into large databases . </S>",
    "<S> instead , one could use cryptography and distributed computation so that sensitive data can be supplied and processed in encrypted form , and only the final result is made known . in this paper , we examine how such a paradigm can be used to implement _ constraint satisfaction _ , a technique that can solve a broad class of ai problems such as resource allocation , planning , scheduling , and diagnosis . </S>",
    "<S> most previous work on privacy in constraint satisfaction only attempted to protect specific types of information , in particular the feasibility of particular combinations of decisions . </S>",
    "<S> we formalize and extend these restricted notions of privacy by introducing four types of private information , including the feasibility of decisions and the final decisions made , but also the identities of the participants and the topology of the problem . </S>",
    "<S> we present distributed algorithms that allow computing solutions to constraint satisfaction problems while maintaining these four types of privacy . </S>",
    "<S> we formally prove the privacy properties of these algorithms , and show experiments that compare their respective performance on benchmark problems . </S>"
  ]
}