{
  "article_text": [
    "reversible computation has gained more and more attention in many application areas , such as the modeling of biochemical systems , program debugging and testing , and also quantum computing . for the excellent properties reversible computing has",
    ", it will be exploited in many computing devices in the future .",
    "there are several research works on reversible computation .",
    "abramsky maps functional programs into reversible automata @xcite .",
    "danos and krivine s reversible rccs @xcite uses the concept of thread to reverse a ccs @xcite@xcite process .",
    "boudol and castellani @xcite@xcite compare three different non - interleaving models for ccs : proved transition systems , event structures and petri nets .",
    "phillips and ulidowski s ccsk @xcite formulates a procedure for converting operators of standard algebraic process calculi such as ccs into reversible operators , while preserving their operational semantics .",
    "ccsk defines the so - called forward - reverse bisimulation and show that it is preserved by all reversible operators .    in process algebra @xcite ,",
    "acp @xcite can be treated as a refinement of ccs @xcite@xcite .",
    "ccsk uses the so - called communication key to mark the histories of an atomic action ( called past actions ) and remains the structural operational semantics .",
    "we are inspired by the way of ccsk : is there an axiomatic algebra to refine ccsk , just like the relation to acp and ccs ?",
    "we do it along the way paved by ccsk and acp , and lead to a new reversible axiomatic algebra , we called it as reversible acp ( racp ) .",
    "racp is an axiomatic refinement to ccsk :    1 .",
    "it has more concise structural operation semantics for forward transitions and reverse transitions , without more predicates , such as standard process predicate and freshness predicate .",
    "it has four extendible modules , basic reversible processes algebra ( brpa ) , algebra of reversible communicating processes ( arcp ) , recursion and abstraction . while in ccsk , recursion and abstraction are not concerned .",
    "3 .   in comparison to acp",
    ", it is almost a brand new algebra for reversible computation which has the same advantages of acp , such as modularity , axiomatization , etc .",
    "firstly , in racp , the alternative composition is replaced by choice composition , since in reversible computing , all choice branches should be retained .",
    "secondly , the parallel operator can not be captured by an interleaving semantics .",
    "thirdly , more importantly to establish a full axiomatization , all the atomic actions are distinct , the same atomic action in different branches ( including choice branches and parallel branches ) will be deemed as the same * one * atomic action .",
    "also auto - concurrency is out of scope for our work here .",
    "the paper is organized as follows . in section [ pre ] , some basic concepts related to equational logic , structural operational semantics and process algebra acp are introduced .",
    "the brpa is introduced in section [ brpa ] , arcp is introduced in section [ arcp ] , recursion is introduced in section [ recursion ] , and abstraction is introduced in section [ abstraction ] .",
    "an application of racp is introduced in section [ verification ] .",
    "we discuss the extensions of racp in section [ extensions ] .",
    "finally , we conclude this paper in section [ conclusions ] .",
    "for convenience of the reader , we introduce some basic concepts about equational logic , structural operational semantics and process algebra acp ( please refer to @xcite and @xcite for more details ) .",
    "we introduce some basic concepts related to equational logic briefly , including signature , term , substitution , axiomatization , equality relation , model , term rewriting system , rewrite relation , normal form , termination , weak confluence and several conclusions .",
    "these concepts originate from @xcite , and are introduced briefly as follows . about the details ,",
    "please see @xcite .",
    "* definition [ elp].1 ( signature)*. a signature @xmath0 consists of a finite set of function symbols ( or operators ) @xmath1 , where each function symbol @xmath2 has an arity @xmath3 , being its number of arguments .",
    "a function symbol @xmath4 of arity _ zero _ is called a constant , a function symbol of arity one is called unary , and a function symbol of arity two is called binary .    * definition [ elp].2 ( term)*. let @xmath0 be a signature .",
    "the set @xmath5 of ( open ) terms @xmath6 over @xmath0 is defined as the least set satisfying : ( 1)each variable is in @xmath5 ; ( 2 ) if @xmath7 and @xmath8 , then @xmath9 .",
    "a term is closed if it does not contain variables .",
    "the set of closed terms is denoted by @xmath10 .",
    "* definition [ elp].3 ( substitution)*. let @xmath0 be a signature .",
    "a substitution is a mapping @xmath11 from variables to the set @xmath5 of open terms .",
    "a substitution extends to a mapping from open terms to open terms : the term @xmath12 is obtained by replacing occurrences of variables @xmath13 in t by @xmath14 .",
    "a substitution @xmath11 is closed if @xmath15 for all variables @xmath13 .",
    "* definition [ elp].4 ( axiomatization)*. an axiomatization over a signature @xmath0 is a finite set of equations , called axioms , of the form @xmath16 with @xmath17",
    ".    * definition [ elp].5 ( equality relation)*. an axiomatization over a signature @xmath0 induces a binary equality relation @xmath18 on @xmath5 as follows .",
    "( 1)(substitution ) if @xmath16 is an axiom and @xmath11 a substitution , then @xmath19 .",
    "( 2)(equivalence ) the relation @xmath18 is closed under reflexivity , symmetry , and transitivity .",
    "( 3)(context ) the relation @xmath18 is closed under contexts : if @xmath20 and @xmath2 is a function symbol with @xmath21 , then @xmath22 .",
    "* definition [ elp].6 ( model)*. assume an axiomatization @xmath23 over a signature @xmath0 , which induces an equality relation @xmath18 . a model for @xmath23 consists of a set @xmath24 together with a mapping @xmath25 .",
    "( 1)@xmath26 is sound for @xmath23 if @xmath16 implies @xmath27 for @xmath28 ; ( 2)@xmath26 is complete for @xmath23 if @xmath27 implies @xmath16 for @xmath28 .    *",
    "definition [ elp].7 ( term rewriting system)*. assume a signature @xmath0 .",
    "a rewrite rule is an expression @xmath29 with @xmath17 , where : ( 1)the left - hand side @xmath30 is not a single variable ; ( 2)all variables that occur at the right - hand side @xmath31 also occur in the left - hand side @xmath30 .",
    "a term rewriting system ( trs ) is a finite set of rewrite rules .",
    "* definition [ elp].8 ( rewrite relation)*. a trs over a signature @xmath0 induces a one - step rewrite relation @xmath32 on @xmath5 as follows .",
    "( 1)(substitution ) if @xmath29 is a rewrite rule and @xmath11 a substitution , then @xmath33 .",
    "( 2)(context ) the relation @xmath32 is closed under contexts : if @xmath34 and f is a function symbol with @xmath21 , then @xmath35 .",
    "the rewrite relation @xmath36 is the reflexive transitive closure of the one - step rewrite relation @xmath32 : ( 1 ) if @xmath29 , then @xmath37 ; ( 2 ) @xmath38 ; ( 3 ) if @xmath37 and @xmath39 , then @xmath40 .    *",
    "definition [ elp].9 ( normal form)*. a term is called a normal form for a trs if it can not be reduced by any of the rewrite rules .",
    "* definition [ elp].10 ( termination)*. a trs is terminating if it does not induce infinite reductions @xmath41 .",
    "* definition [ elp].11 ( weak confluence)*. a trs is weakly confluent if for each pair of one - step reductions @xmath42 and @xmath43 , there is a term @xmath44 such that @xmath45 and @xmath46 .",
    "* theorem [ elp].1 ( newman s lemma)*. if a trs is terminating and weakly confluent , then it reduces each term to a unique normal form .",
    "* definition [ elp].12 ( commutativity and associativity)*. assume an axiomatization @xmath23 .",
    "a binary function symbol @xmath2 is commutative if @xmath23 contains an axiom @xmath47 and associative if @xmath23 contains an axiom @xmath48 .",
    "* definition [ elp].13 ( convergence)*. a pair of terms @xmath30 and @xmath31 is said to be convergent if there exists a term @xmath44 such that @xmath40 and @xmath39 .",
    "axiomatizations can give rise to trss that are not weakly confluent , which can be remedied by knuth - bendix completion@xcite .",
    "it determines overlaps in left hand sides of rewrite rules , and introduces extra rewrite rules to join the resulting right hand sides , witch are called critical pairs .",
    "* theorem [ elp].2*. a trs is weakly confluent if and only if all its critical pairs are convergent .",
    "the concepts about structural operational semantics include labelled transition system ( lts ) , transition system specification ( tss ) , transition rule and its source , source - dependent , conservative extension , fresh operator , panth format , congruence , bisimulation , etc .",
    "these concepts are coming from @xcite , and are introduced briefly as follows . about the details",
    ", please see @xcite . also , to support reversible computation",
    ", we introduce a new kind of bisimulation called forward - reverse bisimulation ( fr bisimulation ) which first occurred in @xcite .",
    "we assume a non - empty set @xmath49 of states , a finite , non - empty set of transition labels @xmath50 and a finite set of predicate symbols .    *",
    "definition [ sosp].1 ( labeled transition system)*. a transition is a triple @xmath51 with @xmath52 , or a pair @xmath53 with @xmath54 a predicate , where @xmath55 .",
    "a labeled transition system ( lts ) is possibly infinite set of transitions .",
    "an lts is finitely branching if each of its states has only finitely many outgoing transitions .",
    "* definition [ sosp].2 ( transition system specification)*. a transition rule @xmath56 is an expression of the form @xmath57 , with @xmath58 a set of expressions @xmath59 and @xmath60 with @xmath61 , called the ( positive ) premises of @xmath56 , and @xmath62 an expression @xmath59 or @xmath60 with @xmath61 , called the conclusion of @xmath56 .",
    "the left - hand side of @xmath62 is called the source of @xmath56 .",
    "a transition rule is closed if it does not contain any variables . a transition system specification ( tss )",
    "is a ( possible infinite ) set of transition rules .    *",
    "definition [ sosp].3 ( proof)*. a proof from a tss @xmath63 of a closed transition rule @xmath57 consists of an upwardly branching tree in which all upward paths are finite , where the nodes of the tree are labelled by transitions such that : ( 1 ) the root has label @xmath62 ; ( 2 ) if some node has label @xmath64 , and @xmath65 is the set of labels of nodes directly above this node , then ( a ) either @xmath65 is the empty set and @xmath66 , ( b ) or @xmath67 is a closed substitution instance of a transition rule in @xmath63 .",
    "* definition [ sosp].4 ( generated lts)*. we define that the lts generated by a tss @xmath63 consists of the transitions @xmath62 such that @xmath68 can be proved from @xmath63 .",
    "* definition [ sosp].5*. a set @xmath69 of expressions @xmath70 and @xmath71 ( where @xmath31 ranges over closed terms , @xmath72 over @xmath50 and @xmath54 over predicates ) hold for a set @xmath73 of transitions , denoted by @xmath74 , if : ( 1 ) for each @xmath75 we have that @xmath76 for all @xmath77 ; ( 2 ) for each @xmath78 we have that @xmath79 .    * definition [ sosp].6 ( three - valued stable model)*.",
    "a pair @xmath80 of disjoint sets of transitions is a three - valued stable model for a tss @xmath63 if it satisfies the following two requirements : ( 1 ) a transition @xmath62 is in @xmath81 if and only if @xmath63 proves a closed transition rule @xmath82 where @xmath69 contains only negative premises and @xmath83 ; ( 2 ) a transition @xmath62 is in @xmath84 if and only if @xmath63 proves a closed transition rule @xmath82 where @xmath69 contains only negative premises and @xmath85 .    *",
    "definition [ sosp].7 ( ordinal number)*. the ordinal numbers are defined inductively by : ( 1 ) @xmath86 is the smallest ordinal number ; ( 2 ) each ordinal number @xmath87 has a successor @xmath88 ; ( 3 ) each sequence of ordinal number @xmath89 is capped by a limit ordinal @xmath90 .    * definition [ sosp].8 ( positive after reduction)*. a tss is positive after reduction if its least three - valued stable model does not contain unknown transitions .    *",
    "definition [ sosp].9 ( stratification)*. a stratification for a tss is a weight function @xmath91 which maps transitions to ordinal numbers , such that for each transition rule @xmath56 with conclusion @xmath62 and for each closed substitution @xmath11 : ( 1 ) for positive premises @xmath59 and @xmath60 of @xmath56 , @xmath92 and @xmath93 , respectively ; ( 2 ) for negative premise @xmath70 and @xmath71 of @xmath56 , @xmath94 for all closed terms @xmath95 and @xmath96 , respectively .    * theorem [ sosp].1*. if a tss allows a stratification , then it is positive after reduction .    *",
    "definition [ sosp].10 ( process graph)*. a process ( graph ) @xmath97 is an lts in which one state @xmath30 is elected to be the root . if the lts contains a transition @xmath98 ,",
    "then @xmath99 where @xmath100 has root state @xmath101 .",
    "moreover , if the lts contains a transition @xmath102 , then @xmath103 .",
    "( 1 ) a process @xmath104 is finite if there are only finitely many sequences @xmath105 .",
    "( 2 ) a process @xmath104 is regular if there are only finitely many processes @xmath106 such that @xmath105 .    *",
    "definition [ sosp].11 ( reverse transition)*. there are two processes @xmath97 and @xmath100 , two transitions @xmath107 and @xmath108 } } p$ ] , the transition @xmath108 } } p$ ] is called reverse transition of @xmath107 , and the transition @xmath107 is called forward transition . if @xmath107 then @xmath108 } } p$ ] , the forward transition @xmath107 is reversible . where @xmath109 $ ] is a kind of special action constant @xmath109\\in a \\times \\mathcal{k}$ ] , @xmath110 , called the histories of an action @xmath72 , and @xmath111 .",
    "* definition [ sosp].12 ( bisimulation)*. a bisimulation relation @xmath112 is a binary relation on processes such that : ( 1 ) if @xmath113 and @xmath114 then @xmath115 with @xmath116 ; ( 2 ) if @xmath113 and @xmath115 then @xmath114 with @xmath116 ; ( 3 ) if @xmath113 and @xmath103 , then @xmath117 ; ( 4 ) if @xmath113 and @xmath117 , then @xmath103 . two processes @xmath97 and @xmath118 are bisimilar , denoted by @xmath119 , if there is a bisimulation relation @xmath112 such that @xmath113 .    *",
    "definition [ sosp].13 ( forward - reverse bisimulation)*. a forward - reverse ( fr ) bisimulation relation @xmath112 is a binary relation on processes such that : ( 1 ) if @xmath113 and @xmath114 then @xmath115 with @xmath116 ; ( 2 ) if @xmath113 and @xmath115 then @xmath114 with @xmath116 ; ( 3)if @xmath113 and @xmath120}}p'$ ] then @xmath121}}q'$ ] with @xmath116 ; ( 4 ) if @xmath113 and @xmath121}}q'$ ] then @xmath120}}p'$ ] with @xmath116 ; ( 5 ) if @xmath113 and @xmath103 , then @xmath117 ; ( 6 ) if @xmath113 and @xmath117 , then @xmath103 .",
    "two processes @xmath97 and @xmath118 are fr bisimilar , denoted by @xmath122 , if there is a fr bisimulation relation @xmath112 such that @xmath113 .",
    "* definition [ sosp].14 ( congruence)*. let @xmath0 be a signature . an equivalence relation @xmath112 on @xmath10 is a congruence if for each @xmath123 , if @xmath124 for @xmath125 , then @xmath126 .    *",
    "definition [ sosp].15 ( panth format)*. a transition rule @xmath56 is in panth format if it satisfies the following three restrictions : ( 1 ) for each positive premise @xmath127 of @xmath56 , the right - hand side @xmath95 is single variable ; ( 2 ) the source of @xmath56 contains no more than one function symbol ; ( 3 ) there are no multiple occurrences of the same variable at the right - hand sides of positive premises and in the source of @xmath56 .",
    "a tss is said to be in panth format if it consists of panth rules only .",
    "* theorem [ sosp].2*. if a tss is positive after reduction and in panth format , then the bisimulation equivalence that it induces is a congruence .    *",
    "definition [ sosp].16 ( branching bisimulation)*. a branching bisimulation relation @xmath112 is a binary relation on the collection of processes such that : ( 1 ) if @xmath113 and @xmath114 then either @xmath128 and @xmath129 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath131 such that @xmath132 and @xmath133 with @xmath116 ; ( 2 ) if @xmath113 and @xmath115 then either @xmath128 and @xmath134 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath135 such that @xmath136 and @xmath137 with @xmath116 ; ( 3 ) if @xmath113 and @xmath103 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath131 such that @xmath132 and @xmath138 ; ( 4 ) if @xmath113 and @xmath117 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath135 such that @xmath136 and @xmath139 . two processes",
    "@xmath97 and @xmath118 are branching bisimilar , denoted by @xmath140 , if there is a branching bisimulation relation @xmath112 such that @xmath113 .",
    "* definition [ sosp].17 ( branching forward - reverse bisimulation)*. a branching forward - reverse ( fr ) bisimulation relation @xmath112 is a binary relation on the collection of processes such that : ( 1 ) if @xmath113 and @xmath114 then either @xmath128 and @xmath129 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath131 such that @xmath132 and @xmath133 with @xmath116 ; ( 2 ) if @xmath113 and @xmath115 then either @xmath128 and @xmath134 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath135 such that @xmath136 and @xmath137 with @xmath116 ; ( 3 ) if @xmath113 and @xmath103 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath131 such that @xmath132 and @xmath138 ; ( 4 ) if @xmath113 and @xmath117 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath135 such that @xmath136 and @xmath139 ; ( 5 ) if @xmath113 and @xmath120}}p'$ ] then either @xmath128 and @xmath129 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath141 such that @xmath132 and @xmath142}}q'$ ] with @xmath116 ; ( 6 ) if @xmath113 and @xmath121}}q'$ ] then either @xmath128 and @xmath134 or there is a sequence of ( zero or more ) @xmath130-transitions @xmath143 such that @xmath136 and @xmath144}}p'$ ] with @xmath116 ; ( 7 ) if @xmath113 and @xmath103 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath141 such that @xmath132 and @xmath138 ; ( 8) if @xmath113 and @xmath117 , then there is a sequence of ( zero or more ) @xmath130-transitions @xmath143 such that @xmath136 and @xmath139 . two processes",
    "@xmath97 and @xmath118 are branching fr bisimilar , denoted by @xmath145 , if there is a branching fr bisimulation relation @xmath112 such that @xmath113 .",
    "* definition [ sosp].18 ( rooted branching bisimulation)*. a rooted branching bisimulation relation @xmath112 is a binary relation on processes such that : ( 1 ) if @xmath113 and @xmath114 then @xmath115 with @xmath146 ; ( 2 ) if @xmath113 and @xmath115 then @xmath114 with @xmath146 ; ( 3 ) if @xmath113 and @xmath103 , then @xmath117 ; ( 4 ) if @xmath113 and @xmath117 , then @xmath103 .",
    "two processes @xmath97 and @xmath118 are rooted branching bisimilar , denoted by @xmath147 , if there is a rooted branching bisimulation relation @xmath112 such that @xmath113 .",
    "* definition [ sosp].19 ( rooted branching forward - reverse bisimulation)*. a rooted branching forward - reverse ( fr ) bisimulation relation @xmath112 is a binary relation on processes such that : ( 1 ) if @xmath113 and @xmath114 then @xmath115 with @xmath148 ; ( 2 ) if @xmath113 and @xmath115 then @xmath114 with @xmath148 ; ( 3 ) if @xmath113 and @xmath120}}p'$ ] then @xmath121}}q'$ ] with @xmath148 ; ( 4 ) if @xmath113 and @xmath121}}q'$ ] then @xmath120}}p'$ ] with @xmath148 ; ( 5 ) if @xmath113 and @xmath103 , then @xmath117 ; ( 6 ) if @xmath113 and @xmath117 , then @xmath103 .",
    "two processes @xmath97 and @xmath118 are rooted branching fr bisimilar , denoted by @xmath149 , if there is a rooted branching fr bisimulation relation @xmath112 such that @xmath113 .    *",
    "definition [ sosp].20 ( lookahead)*. a transition rule contains lookahead if a variable occurs at the left - hand side of a premise and at the right - hand side of a premise of this rule .    * definition [ sosp].21 ( patience rule)*. a patience rule for the i - th argument of a function symbol @xmath2 is a panth rule of the form    @xmath150    * definition [ sosp].22 ( rbb cool format)*. a tss @xmath63 is in rbb cool format if the following requirements are fulfilled .",
    "( 1 ) @xmath63 consists of panth rules that do not contain lookahead . ( 2 ) suppose a function symbol @xmath2 occurs at the right - hand side the conclusion of some transition rule in @xmath63 .",
    "let @xmath151 be a non - patience rule with source @xmath152 .",
    "then for @xmath125 , @xmath153 occurs in no more than one premise of @xmath56 , where this premise is of the form @xmath154 or @xmath155 with @xmath156 .",
    "moreover , if there is such a premise in @xmath56 , then there is a patience rule for the i - th argument of @xmath2 in @xmath63 .",
    "* theorem [ sosp].3*. if a tss is positive after reduction and in rbb cool format , then the rooted branching bisimulation equivalence that it induces is a congruence .    *",
    "definition [ sosp].23 ( conservative extension)*.",
    "let @xmath157 and @xmath158 be tsss over signatures @xmath159 and @xmath160 , respectively .",
    "the tss @xmath161 is a conservative extension of @xmath157 if the ltss generated by @xmath157 and @xmath161 contain exactly the same transitions @xmath59 and @xmath60 with @xmath162 .    *",
    "definition [ sosp].24 ( source - dependency)*. the source - dependent variables in a transition rule of @xmath56 are defined inductively as follows : ( 1 ) all variables in the source of @xmath56 are source - dependent ; ( 2 ) if @xmath59 is a premise of @xmath56 and all variables in @xmath31 are source - dependent , then all variables in @xmath95 are source - dependent .",
    "a transition rule is source - dependent if all its variables are .",
    "a tss is source - dependent if all its rules are .",
    "* definition [ sosp].25 ( freshness)*. let @xmath157 and @xmath158 be tsss over signatures @xmath159 and @xmath160 , respectively . a term in @xmath163",
    "is said to be fresh if it contains a function symbol from @xmath164 .",
    "similarly , a transition label or predicate symbol in @xmath158 is fresh if it does not occur in @xmath157 .    * theorem [ sosp].4*. let @xmath157 and @xmath158 be tsss over signatures @xmath159 and @xmath160 , respectively , where @xmath157 and @xmath161 are positive after reduction . under the following conditions , @xmath161 is a conservative extension of @xmath157 .",
    "( 1 ) @xmath157 is source - dependent .",
    "( 2 ) for each @xmath165 , either the source of @xmath56 is fresh , or @xmath56 has a premise of the form @xmath59 or @xmath60 , where @xmath166 , all variables in @xmath31 occur in the source of @xmath56 and @xmath95 , @xmath72 or @xmath54 is fresh .",
    "acp@xcite is a kind of process algebra which focuses on the specification and manipulation of process terms by use of a collection of operator symbols . in acp , there are several kind of operator symbols , such as basic operators to build finite processes ( called bpa ) , communication operators to express concurrency ( called pap ) , deadlock constants and encapsulation enable us to force actions into communications ( called acp ) , liner recursion to capture infinite behaviors ( called acp with linear recursion ) , the special constant silent step and abstraction operator ( called @xmath167 with guarded linear recursion ) allows us to abstract away from internal computations .",
    "bisimulation or rooted branching bisimulation based structural operational semantics is used to formally provide each process term used the above operators and constants with a process graph .",
    "the axiomatization of acp ( according the above classification of acp , the axiomatizations are @xmath168 , @xmath169 , @xmath170 , @xmath170 + rdp ( recursive definition principle ) + rsp ( recursive specification principle ) , @xmath171 + rdp + rsp + cfar ( cluster fair abstraction rule ) respectively ) imposes an equation logic on process terms , so two process terms can be equated if and only if their process graphs are equivalent under the semantic model .",
    "acp can be used to formally reason about the behaviors , such as processes executed sequentially and concurrently by use of its basic operator , communication mechanism , and recursion , desired external behaviors by its abstraction mechanism , and so on .",
    "acp is organized by modules and can be extended with fresh operators to express more properties of the specification for system behaviors .",
    "these extensions are required both the equational logic and the structural operational semantics to be extended .",
    "then the extension can use the whole outcomes of acp , such as its concurrency , recursion , abstraction , etc .",
    "in the following , the variables @xmath172 range over the collection of process terms , the variables @xmath173 range over the set @xmath50 of atomic actions , @xmath174 , @xmath175 are closed items , @xmath130 is the special constant silent step , @xmath176 is the special constant deadlock .",
    "we define a kind of special action constant @xmath109\\in a \\times \\mathcal{k}$ ] where @xmath110 , called the histories of an action @xmath72 , denoted by @xmath109,a[n],\\cdots$ ] where @xmath177 .",
    "let @xmath178 .",
    "brpa includes three kind of operators : the execution of atomic action @xmath72 , the choice composition operator @xmath179 and the sequential composition operator @xmath180 .",
    "each finite process can be represented by a closed term that is built from the set @xmath50 of atomic actions or histories of an atomic action , the choice composition operator @xmath179 , and the sequential composition operator @xmath180 .",
    "the collection of all basic process terms is called basic reversible process algebra ( brpa ) , which is abbreviated to brpa .",
    "we give the forward transition rules under transition system specification ( tss ) for brpa as follows .",
    "@xmath181}\\ ] ]    @xmath182 \\quad \\upsilon\\notin y}{x+y\\xrightarrow{\\upsilon}\\upsilon[m]+y } \\quad\\frac{x\\xrightarrow{\\upsilon}x ' \\quad \\upsilon\\notin y}{x+y\\xrightarrow{\\upsilon}x'+y } \\quad\\frac{y\\xrightarrow{\\upsilon}\\upsilon[m ] \\quad \\upsilon\\notin x}{x+y\\xrightarrow{\\upsilon}x+\\upsilon[m ] } \\quad\\frac{y\\xrightarrow{\\upsilon}y'\\quad \\upsilon\\notin x}{x+y\\xrightarrow{\\upsilon}x+y'}\\ ] ]    @xmath182\\quad y\\xrightarrow{\\upsilon}\\upsilon[m]}{x+y\\xrightarrow{\\upsilon}\\upsilon[m ] } \\quad\\frac{x\\xrightarrow{\\upsilon}x'\\quad y\\xrightarrow{\\upsilon}\\upsilon[m]}{x+y\\xrightarrow{\\upsilon}x'+\\upsilon[m ] } \\quad\\frac{x\\xrightarrow{\\upsilon}\\upsilon[m]\\quad y\\xrightarrow{\\upsilon}y'}{x+y\\xrightarrow{\\upsilon}\\upsilon[m]+y ' } \\quad\\frac{x\\xrightarrow{\\upsilon}x'\\quad y\\xrightarrow{\\upsilon}y'}{x+y\\xrightarrow{\\upsilon}x'+y'}\\ ] ]    @xmath182}{x\\cdot y\\xrightarrow{\\upsilon}\\upsilon[m]\\cdot y } \\quad\\frac{x\\xrightarrow{\\upsilon}x'}{x\\cdot y\\xrightarrow{\\upsilon}x'\\cdot y}\\ ] ]    @xmath183}{x\\cdot y\\xrightarrow{\\omega}x\\cdot \\omega[n]}$ ] , x is forward executed successfully .",
    "@xmath184 , x is forward executed successfully .    *",
    "the first transition rule says that each atomic action @xmath185 can execute successfully , and leads to a history @xmath186 $ ] .",
    "the forward transition rule @xmath187}$ ] implies a successful forward execution . *",
    "the next four transition rules say that @xmath188 can execute only one branch , that is , it can execute either @xmath30 or @xmath31 , but the other branch remains . *",
    "the next four transition rules say that @xmath188 can execute both branches , only by executing the same atomic actions .",
    "when one branch @xmath30 or @xmath31 is forward executed successfully , we define @xmath188 is forward executed successfully . *",
    "the last four transition rules say that @xmath189 can execute sequentially , that is , it executes @xmath30 in the first and leads to a successful history , after successful execution of @xmath30 , then execution of @xmath31 follows .",
    "when both @xmath30 and @xmath31 are forward executed successfully , we define @xmath189 is forward executed successfully .",
    "we give the reverse transition rules under transition system specification ( tss ) for brpa as follows .",
    "@xmath190 {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon}\\ ] ]    @xmath191}}\\upsilon\\quad \\upsilon[m]\\notin y}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon+y } \\quad\\frac{x {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x ' \\quad \\upsilon[m]\\notin y}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'+y } \\quad\\frac{y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon \\quad \\upsilon[m]\\notin x}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x+\\upsilon } \\quad\\frac{y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}y ' \\quad \\upsilon[m]\\notin x}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x+y'}\\ ] ]    @xmath191}}\\upsilon\\quad y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon } \\quad\\frac{x {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'\\quad y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'+\\upsilon } \\quad\\frac{x {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon\\quad y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}y'}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon+y ' } \\quad\\frac{x {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'\\quad y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}y'}{x+y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'+y'}\\ ] ]    @xmath191}}\\upsilon}{x\\cdot y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon\\cdot y } \\quad\\frac{x {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'}{x\\cdot y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}x'\\cdot y}\\ ] ]    @xmath192}}\\omega}{x\\cdot y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\omega[n]}}x\\cdot \\omega}$ ] , x is forward executed successfully .",
    "@xmath192}}y'}{x\\cdot y {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\omega[n]}}x\\cdot y'}$],x is forward executed successfully .",
    "* the first transition rule says that each history of an atomic action @xmath186 $ ] can reverse successfully , and leads to an atomic action @xmath185 .",
    "similarly , the reverse transition rule @xmath193 {   \\ext@arrow 0055{\\rightslashedarrowfillg@}{}{\\upsilon[m]}}\\upsilon}$ ] implies a successful reverse . *",
    "the next four transition rules say that @xmath188 can reverse only one branch , that is , it can reverse either @xmath30 or @xmath31 , but the other branch remains . *",
    "the next four transition rules say that @xmath188 can reverse both branches , only by executing the same histories of atomic actions .",
    "when one branch @xmath30 or @xmath31 is reversed successfully , we define @xmath188 is reversed successfully . *",
    "the last four transition rules say that @xmath189 can reverse sequentially , that is , it reverses @xmath31 in the first and leads to a successful atomic action , after successful reverse of @xmath31 , then reverse of @xmath30 follows .",
    "when both @xmath30 and @xmath31 are reversed successfully , we define @xmath189 is reversed successfully .",
    "we design an axiomatization @xmath194 for brpa modulo fr bisimulation equivalence as table [ axiomforbrpa ] shows .",
    ".axioms for brpa [ cols= \" < , < \" , ]     * theorem [ extensions].3*. @xmath195 + rsp + rdp + cfar + rrn1-rrn5 is sound for @xmath196 with guarded linear recursion and renaming operators , modulo rooted branching fr bisimulation equivalence .    since rooted branching fr bisimulation is both an equivalence and a congruence for @xmath196 with guarded linear recursion and renaming operators , only the soundness of the first clause in the definition of the relation @xmath18 is needed to be checked .",
    "that is , if @xmath16 is an axiom in @xmath195 + rsp + rdp + cfar + rrn1-rrn5 and @xmath11 a closed substitution that maps the variable in @xmath30 and @xmath31 to reversible process terms , then we need to check that @xmath197 .",
    "we only provide some intuition for the soundness of axioms in table [ axiomforr ] .",
    "* rrn1-rrn3 are the defining equations for the renaming operator @xmath198 .",
    "* rrn4-rrn5 say that in @xmath199 , the labels of all transitions of @xmath31 are renamed by means of the mapping @xmath2 .",
    "this intuition can be made rigorous by means of explicit rooted branching fr bisimulation relations between the left- and right - hand sides of closed instantiations of rrn1-rrn5 .",
    "* theorem [ extensions].4*. @xmath195 + rsp + rdp + cfar + rrn1-rrn5 is complete for @xmath196 with guarded linear recursion and renaming operators , modulo rooted branching fr bisimulation equivalence .",
    "it suffices to prove that each process term @xmath31 in @xmath196 with guarded linear recursion and renaming operators is provably equal to a process term @xmath200 with @xmath201 a guarded linear recursive specification .",
    "namely , then the desired completeness result follows from the fact that if @xmath202 for guarded linear recursive specifications @xmath203 and @xmath204 , then @xmath205 can be derived from @xmath195 + rsp + rdp + cfar .",
    "structural induction with respect to process term @xmath31 can be applied .",
    "the only new case ( where rrn1-rrn5 are needed ) is @xmath206 .",
    "first assuming @xmath207 with a guarded linear recursive specification @xmath201 , we prove the case of @xmath208 .",
    "let @xmath201 consists of guarded linear recursive equations    @xmath209 for @xmath210 .",
    "let @xmath211 consists of guarded linear recursive equations    @xmath212 for @xmath213 .",
    "@xmath214    replacing @xmath215 by @xmath216 for @xmath217 is a solution for @xmath211 .",
    "so by rsp , @xmath218 .",
    "in this paper , we give reversible computation an axiomatic foundation called racp .",
    "racp can be widely used in verification of applications in reversible computation .    for recursion and abstraction ,",
    "it is reasonable to do extensions based on arcp - rp ( arcp without static parallel operator @xmath219 ) . because in reversible computation",
    ", all choice branches are retained and can execute simultaneously .",
    "the choice operator @xmath179 and the static parallel operator @xmath219 have the similar behaviors , so the static parallel operator can be naturally removed from arcp .",
    "any computable process can be represented by a process term in acp ( exactly @xmath220 with guarded linear recursion ) @xcite .",
    "that is , acp may have the same expressive power as turing machine . and",
    "racp may have the same expressive power as acp .",
    "same as acp , racp has good modularity and can be extended easily .",
    "although the extensions can not improve the expressive power of racp , it still provides an elegant and convenient way to model other properties in reversible computation .",
    "v. danos , j. krivine .",
    ": _ transactions in rccs",
    ". _ proceedings of 16th international conference on concurrency theory , concur 2005 , lecture notes in computer science , vol .",
    "3653 , springer - verlag , 2005 , pp ."
  ],
  "abstract_text": [
    "<S> we design an axiomatization for reversible computation called reversible acp ( racp ) . </S>",
    "<S> it has four extendible modules : basic reversible processes algebra ( brpa ) , algebra of reversible communicating processes ( arcp ) , recursion and abstraction . </S>",
    "<S> just like process algebra acp in classical computing , racp can be treated as an axiomatization foundation for reversible computation .    </S>",
    "<S> [ firstpage ]    reversible computation ; process algebra ; algebra of communicating processes ; axiomatization </S>"
  ]
}