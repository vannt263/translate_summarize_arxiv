{
  "article_text": [
    "[ sec : defi ]    a pfa is generalization of dfa .",
    "many authors have tried to find out (  @xcite ,  @xcite ,  @xcite ,  @xcite a. o. ) the size advantages of pfa over dfa . on the other side",
    "it is known (  @xcite ,  @xcite ) that the size of reversible finite automata ( rfa ) and the size of qfa exceed the size of the corresponding dfa almost exponentially for some regular languages ( i.e. for languages recognizable by dfa ) . and so a. ambainis ,",
    "a. nayak , a. ta - shma , u. vazirani  @xcite wrote :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _   _ another open problem involves the blow up in size while simulating a 1-way pfa by a 1-way qfa .",
    "the only known way for doing this is by simulating the pfa by a 1-way dfa and then simulating the dfa by a qfa .",
    "both simulating a pfa by a dfa (  @xcite ,  @xcite ,  @xcite ) and simulating dfa by a qfa ( this paper ) can involve exponential or nearly exponential increase in size .",
    "this means that the straightforward simulation of a probabilistic automaton by a qfa ( described above ) could result in a doubly - exponential increase in size .",
    "however , we do not known of any examples where both transforming a pfa into a dfa and transforming a dfa into a qfa cause big increases of size .",
    "better simulations of pfa by qfas may well be possible .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we will solve this problem .",
    "we use the definition of 1-way qfa ( further in text simply qfa ) as in  @xcite and  @xcite .",
    "this model was first introduced in @xcite and is not the most general one , but is easy to implement and deal with .",
    "a quantum finite automaton has a finite set of basis states @xmath6 , which consists of tree parts : accepting states ( @xmath7 ) , rejecting states ( @xmath8 ) and non - halting states ( @xmath9 ) .",
    "one of the states , @xmath10 , is distinguished as the starting state .",
    "inputs to a qfa are words over a finite alphabet @xmath11 .",
    "we shall also use the symbols @xmath12 and @xmath13 that do not belong to @xmath11 to denote the left and the right end marker , respectively .",
    "the set @xmath14 denotes the working alphabet of the qfa . for each symbol",
    "@xmath15 , a qfa has a corresponding unitary transformation @xmath16 on the space @xmath17 .    at any time , the state of a qfa is a superposition of basis states in @xmath6 .",
    "the computation starts in the superposition @xmath18 .",
    "then the transformations corresponding to the left end marker @xmath12 , the letters of the input word @xmath19 and the right end marker @xmath13 are applied in succession to the state of the automaton , unless a transformation results in acceptance or rejection of the input .",
    "a transformation consists of two steps :    1 .",
    "first , @xmath16 is applied to @xmath20 , the current state of the automaton , to obtain the new state @xmath21 .",
    "then , @xmath21 is measured with respect to the observable @xmath22 , where @xmath23 , @xmath24 , @xmath25 .",
    "the probability of observing @xmath26 is equal to the squared norm of the projection of @xmath21 onto @xmath26 . on measurement ,",
    "the state of the automaton `` collapses '' to the projection onto the space observed , i.e. , becomes equal to the projection , suitably normalized to a unit superposition .",
    "if we observe @xmath27 ( or @xmath28 ) , the input is accepted ( or rejected ) .",
    "otherwise , the computation continues , and the next transformation , if any , is applied .",
    "a qfa is said to @xmath29 ( or @xmath30 ) a language @xmath31 with probability @xmath32 if it accepts every word in @xmath31 with probability at least @xmath33 , and rejects every word not in @xmath31 with probability at least @xmath33 .",
    "a rfa is a qfa with elements only @xmath34 and @xmath35 in the matrices .",
    "a pfa is the same as a qfa but only instead of unitary matrices it has stochastic ones .",
    "a dfa is a pfa with only @xmath34 and @xmath35 in the matrices .",
    "the @xmath36 of a finite automaton is defined as the number of ( basis ) states in it .",
    "more exact definitions one can find , for example , in  @xcite .    in  @xcite there was given a language @xmath37 consisting of one word @xmath38 in a single - letter alphabet and it was proved :    [ thm : pd ]    1 .   any deterministic automaton that recognizes @xmath37 , has at least n states .",
    "2 .   for any @xmath2 , there is a probabilistic automaton with @xmath39 states recognizing @xmath37 with probability @xmath40",
    ".    _ sketch of proof .",
    "_ the first part is evident . to prove the second part , freivalds  @xcite used the following construction .",
    "@xmath41 different primes are employed and @xmath42 states are used for every employed prime . at first , the automaton randomly chooses a prime p , and the the remainder modulo p of the length of input word is found and compared with the standard .",
    "additionally , once in every p steps a transition to a rejecting state is made with a `` small '' probability @xmath43 .",
    "the number of used primes suffices to assert that , for every input of length less than n , most of primes p give remainders different from the remainder of n modulo p. the `` small '' probability is chosen to have the rejection high enough for every input length n such both @xmath44 and @xmath45-fraction of all the primes used have the same remainders mod p as n.    in  @xcite was definition and theorem :    [ defi : enc ] @xmath46 serially encodes m classical bits into n qubits with p success , if for any @xmath47 $ ] and @xmath48 } = b_{i+1} ...",
    "b_n \\in \\{0 , 1\\}^{n - i}$ ] , there is a measurement @xmath49}}$ ] that returns @xmath34 or @xmath35 and has property that    @xmath50 } } | f(b ,",
    "r)\\rangle = b_i ) \\geq p$ ] .",
    "[ thm : encod ] any quantum serial encoding of m bits into n qubits with constant success probability @xmath51 has @xmath52 .    and also in  @xcite there was defined an r - restricted 1-way qfa for a language l as a 1-way qfa that recognizes the language with probability @xmath51 , and which halts with non - zero probability before seeing the right end marker only after it has read r letters of the input .",
    "the following theorem was proved :    [ thm : rr ] let m be a 1-way qfa with s states recognizing a language l with probability @xmath33 .",
    "then there is an r - restricted 1-way qfa @xmath53 with @xmath54 states that recognizes l with probability @xmath33 .",
    "one of the components of the proof of theorem [ thm : pr ] below is the following lemma :    language [ lemma : div0 ] @xmath55    is recognizable by a dfa .    _",
    "sketch of proof .",
    "_ the automaton has five states : @xmath56 , @xmath57 , @xmath58 , @xmath59 and @xmath60 .",
    "values of the transition function between states are : f(@xmath56 , 0 ) = @xmath57 , f(@xmath56 , 1 ) = @xmath56 , f(@xmath57 , 0 ) = @xmath58 , , f(@xmath57 , 1 ) = @xmath56 , f(@xmath58 , 0 ) = @xmath58 , f(@xmath58 , 1 ) = @xmath58 , f(@xmath56 , $ ) = @xmath60 , f(@xmath57 , $ ) = @xmath60 , f(@xmath58 , $ ) = @xmath59 .",
    "[ thm : pr ] for all @xmath61 , n = 2*k , we define language    @xmath62    1 .",
    "there is a rfa ( so also a qfa , a pfa and a dfa ) that recognize @xmath0 .",
    "2 .   any rfa that recognizes @xmath0 , has at least @xmath63 states .",
    "any qfa that recognizes @xmath0 with probability @xmath51 , has at least @xmath64 states .",
    "any dfa that recognizes @xmath0 , has at least @xmath4 states .",
    "5 .   for any @xmath2",
    ", there is a pfa with @xmath39 states recognizing @xmath0 with probability @xmath40 .",
    "_    zero part follows from fact that all finite languages are recognizable by some rfa and @xmath0 is finite language .",
    "first part : we give to automaton word @xmath65 , where @xmath66 .",
    "it is obvious that then automaton can not decide what to answer till the end of word .",
    "we prove that automaton always has to branch at every @xmath67 .",
    "suppose contrary , there is @xmath67 where automaton goes to the same state whether it read @xmath68 or @xmath69 .",
    "then forward we give the next symbols @xmath70 and automaton can not decide what to answer .",
    "so it must branch for every @xmath67 , we can say it @xmath71 this bit .",
    "but maybe it can merge ( @xmath72 ) afterwards ?",
    "no , because constructions     +    are forbidden by reversibility , but construction     +    by the same reason as branching must occur ( for all states @xmath73 , @xmath74 , @xmath75 , i @xmath76 j )",
    ". then it follows that automaton @xmath71 all bits and the total number of states is at least @xmath77 .",
    "second part : we use technique introduced by  @xcite .",
    "let m be any n - restricted qfa accepting @xmath0 with probability @xmath51 .",
    "the following claim formalizes the intuition that the state of m after n symbols in form @xmath65 have been read is an @xmath78 ( in case of rfa , so deterministic , we said @xmath79 ) of the @xmath80 .    there is a serial encoding of k bits into @xmath17 , and hence into @xmath81 qubits , where q is the set of basis states of the m.    _ proof .",
    "_ let @xmath7 and @xmath8 be the set of accepting and rejecting states respectively .",
    "let @xmath82 be a unitary operator of m corresponding to the symbol @xmath83@xmath84 .",
    "we define an encoding @xmath85 of k - bit strings into unit superpositions over the basis states of the qfa m by letting @xmath86 be the state of the automaton m after the input string @xmath65 where @xmath66 has been read .",
    "we assert that f is a serial encoding .    to show that indeed f is such an encoding , we exhibit a suitable measurement for the @xmath67th bit for every @xmath87 $ ] .",
    "let , for @xmath88 , @xmath89 .",
    "the @xmath90th measurement then consists of first applying the unitary transformation @xmath91 to @xmath86 , and then measuring the resulting superposition with respect to @xmath92 . since for words with form @xmath93 , containment in @xmath0",
    "is decided by the @xmath67 , and because such words are accepted or rejected by then n - restricted qfa m with probability at least p only after the entire input has been read , the probability of observing @xmath27 if @xmath68 , or @xmath28 if @xmath94 , is at least p. thus , f defines a serial encoding .",
    "then it follows from theorem  [ thm : encod ] that @xmath95 , but since @xmath96 , we have @xmath97 . from theorem  [ thm : rr ]",
    "it follows that any quantum automaton that recognize @xmath0 also require @xmath64 states .",
    "third part : easy .",
    "fourth part : the pfa q in theorem  [ thm : pd ] has one rejecting ( @xmath60 ) , one accepting ( @xmath59 ) , one initial ( @xmath10 ) state and many non - halting states @xmath73 .",
    "we build pfa @xmath98 recognizing language @xmath0 with one rejecting ( @xmath99 ) , one accepting(@xmath100 ) , one starting ( @xmath101 ) state and several non - halting states @xmath102 , @xmath103 and @xmath104 , where i is from set of states indexes from automaton q. for every transition from state @xmath73 to state @xmath74 with probability p for the input symbol a ( we denote this by f(@xmath73 , a , @xmath74 , p ) ) there are @xmath105 transitions in @xmath98 ( we denote it by f ) :    1 .",
    "f(@xmath102 , @xmath35 , @xmath102 , p ) 2 .",
    "f(@xmath102 , @xmath34 , @xmath103 , p ) 3 .",
    "f(@xmath103 , @xmath35 , @xmath102 , p ) 4 .",
    "f(@xmath103 , @xmath34 , @xmath104 , p ) 5 .",
    "f(@xmath104 , @xmath35 , @xmath104 , p ) 6 .",
    "f(@xmath104 , @xmath34 , @xmath104 , p )    for every transformation f(@xmath10 , @xmath12 , @xmath73 , p ) , there is a transformation f(@xmath101 , @xmath12 , @xmath102 , p ) . for every f(@xmath73 , a , @xmath60 , p ) there is f(@xmath106 , @xmath19 , @xmath99 , p ) such that for all @xmath107 , @xmath108 , and for every f(@xmath73 , @xmath13 , @xmath60 , p ) there is f(@xmath106 , @xmath13 , @xmath99 , p ) for all @xmath109 , and for any f(@xmath73 , @xmath13 , @xmath59 , p ) there are f(@xmath104 , @xmath13 , @xmath100 , p ) , f(@xmath102 , @xmath13 , @xmath99 , p ) , f(@xmath103 , @xmath13 , @xmath99 , p ) .",
    "informally , we make 3 copies from states in q and their meaning is similar than for states of automaton from lemma  [ lemma : div0 ] .",
    "automata computes parallel two things : is length of input word @xmath110 and is there any adjacent zeroes in it .",
    "it is obviously that the accepted words are those whose length is @xmath110 and there are two adjacent @xmath34 in them .",
    "we have shown that sometimes quantum automata must be almost doubly exponential larger than classical automaton .",
    "but there still remains open the other question . as follows from result of ambainis and freivalds  @xcite ,",
    "any language accepted by a qfa with high enough probability can be accepted by a rfa which is at most exponentially bigger that minimal dfa accepting the language .",
    "thus follows that theorem  [ thm : pr ] is close to maximal gap between probabilistic and quantum automaton with high enough ( this was precisely computed by ambainis and kikusts  @xcite - greater than @xmath111 ) probability of success .",
    "but it is not clear how it is when we allow smaller probability of correctness .",
    "author do not now any lower or upper bound in this case .",
    "i would like to thank r= usin freivalds for suggesting the problem and help during research ."
  ],
  "abstract_text": [
    "<S> we present a language @xmath0 which is recognizable by a probabilistic finite automaton ( pfa ) with probability @xmath1 for all @xmath2 with @xmath3 states , with a deterministic finite automaton ( dfa ) with @xmath4 states , but a quantum finite automaton ( qfa ) needs at least @xmath5 states . </S>"
  ]
}