{
  "article_text": [
    "gpus are specialized devices offering high computational power as well as high memory throughput @xcite .",
    "their architecture is very similar to processor arrays @xcite .",
    "gpus are efficient for algorithms exhibiting massively parallel and homogeneous computations .",
    "even though most operations from linear algebra are not computationally intensive , corresponding algorithms can profit from high memory throughput reaching almost 200 gb / s .",
    "this has been demonstrated in many works dealing with dense matrices @xcite .",
    "situation is more complicated in case of sparse matrices .",
    "they often have irregular pattern of non - zero elements and they significantly reduce available parallelism .",
    "it makes processing of the sparse matrices on gpu difficult but also challenging .    in this article",
    "we concentrate on the sparse - matrix vector multiplication ( spmv ) since it is a key part of many iterative solvers for linear systems .",
    "the performance is influenced mainly by the format used to store the matrix .",
    "formats for storing the sparse matrices often involves additional data , typically column indexes . on the vector architectures , the data must by aligned in the memory .",
    "cuda developers speak about coalesced global memory accesses .",
    "their importance for the efficiency of spmv is discussed in @xcite .",
    "for this reason , artificial zeros must be often inserted . moreover , with different number of non - zero elements in each row , the multiprocessors may be load unequally .",
    "efficient format should address the following :    1 .",
    "reduce amount of additional data while keep coalesced global memory accesses , 2 .",
    "distribute the non - zero elements of the matrix evenly .",
    "we present new format for storing the sparse - matrices on gpu .",
    "it is optimized for matrix - vector multiplication . with some types of matrices ,",
    "it is several times faster compared to today state - of - the - art formats like cusparse , hybrid ( in cusp library ) @xcite , row - grouped csr @xcite and sliced ellpack @xcite .",
    "we analyze on what type of matrices the new format outperforms the others and vice versa .      the article is organized as follows . in section [",
    "sect : spmv - on - gpu ] , we briefly summarize existing formats for storing sparse matrices on gpu . the new format is presented in section [ sect : arg - csr - format ] together with description of conversion from csr format .",
    "the implementation in cuda with a source code of matrix - vector multiplication kernel is in section [ sect : cuda - implementation ] . achieved results with short performance analysis",
    "are topics of the last section [ sect : results ] .",
    "csr ( compressed sparse rows ) format ( figure [ fig : csr ] ) is standard and most popular format for storing sparse matrices @xcite .",
    "it consists of arrays values storing rowisely the non - zero elements of the matrix , columns storing column index of each non - zero element and rowpointers containing offset of each matrix row in arrays values and columns .",
    "this format is easy to implement .",
    "storing data in arrays improves efficiency of data transfer .",
    "works by bell and garland @xcite or bautois et al .",
    "@xcite showed that this format is inefficient on gpu for matrix - vector multiplication .",
    "better formats are based on the ellpack format ( figure [ fig : ellpack ] ) by monakov and avetisian @xcite or our similar format studied in @xcite .",
    "formats based on ellpack require homogeneous distribution of non - zero elements in rows .",
    "if the number of non - zero elements in each row is very different , the ellpack format loses efficiency .",
    "bell and garland @xcite proposed hybrid format which is part of cusp library .",
    "it has also achieved great popularity .",
    "recently cusparse @xcite showed that even pure csr format can be implemented efficiently on gpu .",
    "nevertheless , tests on large sets of sparse matrices like those in @xcite show that there are a lot of matrices for which common cpu performs better .",
    "there is still great potential to improve formats for sparse matrices on gpu .",
    "the ellpack format , as depicted on the figure [ fig : ellpack ] , allocates the same number of elements for each matrix row .",
    "if there are less non - zero elements on some row , artificial zeros are added to align the data .",
    "this increases memory requirements and slow down matrix - vector multiplication because more data must be transferred . on gpu , usually one thread",
    "is mapped to one row .",
    "arrays values and columns are stored in global memory and so the accesses to these arrays must coalesced ( see @xcite ) .",
    "this is reason why these arrays are stored columnwise instead of rowise .",
    "since the coalesced memory accesses must be fulfilled only for threads in one warp we may split the matrix into slices of rows processed by the same warp .",
    "the slices are stored separately .",
    "if there is a row having significantly more non - zero elements than the others , only one slice is affected .",
    "this modification , introduced independently in @xcite , reduces number of artificial zeros required by original ellpack format .",
    "however , for some matrices these formats still generate too many artificial zeros and matrix - vector multiplication can be several orders slower compared to csr format on cpu .    the next step is to split long rows ( i.e. with a lot of non - zero elements ) and process them by more threads . the matrix is again divided into groups of rows .",
    "we introduce _ chunks _ of non - zero elements .",
    "each chunk in the same group has the same size .",
    "one row can be splitted into more chunks ( but one chunk can not cross boundary of one row ) .",
    "chunks are stored in the same way as matrix rows in the ellpack format ( also stored columnwise to get the coalesced memory accesses ) .",
    "when performing the matrix - vector multiplication , we map one thread to each chunk .",
    "first the chunks are processed which results to array of partial sums .",
    "if some row consists of more chunks , its partial sums must be summed to get the final result . in the following text",
    ", we explain this format in more details .",
    "figure [ fig : argcsr-1 ] shows an example of matrix for which the ellpack format is inefficient .",
    "all rows except the last one have only one non - zero element and the last row is full .",
    "assume that we map 12 threads to this matrix .",
    "we first assign one thread to each row .",
    "the thread mapped to the last row must process 8 elements .",
    "therefore the chunk size is 8 and all other threads must process 8 elements as well because they belong to the same warp . we would have to allocate 49 artificial zeros to align the data . since we have 4 threads left we may use them to diminish the chunk size by mapping them to the last row . as depicted in the figure [ fig : argcsr-1 ] ,",
    "if there are 4 threads assigned to the last row , the chunk size is only 2 .",
    "one thread remains free and we need to allocate only 7 artificial zeros . to ensure the coalesced global memory accesses we store the chunks in the same way as rows are stored in sliced ellpack format @xcite or row - grouped csr format @xcite .",
    "in other words , if chunks were rows of some matrix , the matrix would be stored columnwise .",
    "large matrices are splitted into small groups of rows .",
    "each group is defined by the following structure ( listing [ listing : group - info ] ) :    .... struct argcsrgroupinfo {     int firstrow ;     int size ;     int offset ;     int chunksize ; } ; ....    parameter firstrow is the first matrix row and size is number of rows in the group i.e. the group contains rows indexed from firstrow to firstrow + size - 1 .",
    "parameter offset points to the first element of the group in arrays values and columns and chunksize describes number of elements in chunk .",
    "it is constant in each group but it can be different for different groups .",
    "the number of chunks is the same for each group and equals cuda block size . for each group",
    "there are chunksize * blockdim.x elements in arrays values and columns starting at position offset .",
    "let us now comment a conversion from the csr format . for good performance ,",
    "it is necessary that all groups have approximately the same number of non - zero elements .",
    "otherwise the load balance of multiprocessors would be unequal .",
    "one parameter , entering the converting algorithm is desiredchunksize .",
    "we allocate new group , read the matrix row by row and compute number of non - zero elements . once it is larger than desiredchunksize * blockdim.x or there would be more rows than blockdim.x in the current group , we close it and allocate new one .",
    "the groups are defined by array of structures argcsrgroupinfo . in the next step of the conversion ,",
    "we compute the chunk size in each group .",
    "this can be done in parallel .",
    "we start by mapping one thread to each row of the group",
    ". the chunk size would be now equal to the number of non - zero elements in row with greatest filling .",
    "we define _ the chunk filling _ as number of non - zero elements in given chunk .",
    "if there are some threads left , we always find row with greatest chunk filling and map one more thread to it . when all threads are distributed to the rows we can compute the final chunk size .",
    "we also need to store mapping of threads to rows . for this",
    "we allocate array globalthreadsmapping .",
    "it contains number of threads mapped to each row of matrix",
    ". then we perform exclusive prefix - sum on this array separately for each group .",
    "the last step is filling the arrays values and columns by data belonging to particular chunks .",
    "since we know the chunk size in each group we know how many elements will be inserted by each group .",
    "this phase thus can be done in parallel as well .",
    "we read the data chunkwise from csr format and copy them in appropriate order to the mentioned arrays .    in the next section",
    "we explain matrix - vector multiplication .",
    "for better understanding , we show the source code of the kernel in cuda  see listing [ listing : spmv - kernel ] .",
    ".... template < class real > _ _ global _ _ void spmvkernel (      real * target ,     real * vect ,     real * values ,     int * columns ,     argcsrgroupinfo * globalgroupinfo ,     int * globalthreadsmapping ) {     extern _ _ shared _ _ int sdata [ ] ;     const int * globalgroupinfopointer =         reinterpret_cast < const int * > ( globalgroupinfo ) ;     argcsrgroupinfo * groupinfo =         reinterpret_cast < argcsrgroupinfo * > ( & sdata [ 0 ] ) ;     int * threadsmapping =         reinterpret_cast < int * > ( & sdata [ 4 ] ) ;     real * partialsums =         reinterpret_cast < real * > ( & sdata [ 4 + blockdim .",
    "x ] ) ;       int bid = blockidx.x ;         / * * * *      * fetch the group info from the global memory      * /     if ( threadidx.x < 4 )        sdata [ threadidx.x ] =            globalgroupinfopointer [ 4 * bid + threadidx.x ] ;     _ _ syncthreads ( ) ;       / * * * *      * fetch mapping of threads to rows .      * /     if ( threadidx .",
    "x < groupinfo - > size )        threadsmapping [ threadidx .",
    "x ] =            globalthreadsmapping [ groupinfo - > firstrow + threadidx .",
    "x ] ;       / * * * *      * each thread computes partial sum in its chunk      * /     real sum = 0 ;     int threadoffset = groupinfo - > offset + threadidx .",
    "x ;     for ( int i = 0 ; i < groupinfo - > chunksize ; i + + )     {        const int column = columns [ threadoffset ] ;        if ( column !",
    "= -1 )           sum + = values [ threadoffset ] * vect [ column ] ;        else           break ;        threadoffset + = blockdim .",
    "x ;     }     partialsums [ threadidx .",
    "x ] = sum ;     _ _ syncthreads ( ) ;        / * * * *      * sum the partial sums in each row      * /     if ( threadidx .",
    "x < groupinfo - > size )     {        sum = 0 ;        int begin ( 0 ) ;        const int row = groupinfo - > firstrow + threadidx .",
    "x ;        if ( threadidx .",
    "x > 0 )           begin = threadsmapping [ threadidx .",
    "x - 1 ] ;        int end = threadsmapping [ threadidx .",
    "x ] ;        for ( int",
    "i = begin ; i < end ; i++ )           sum + = partialsums [ i ] ;        target [ row ] = sum ;     } } ....    the kernel first fetch data with reuse to fast shared memory .",
    "we allocate shared memory ( lines 1018 ) for one argcsrgroupinfo structure , array threadsmapping keeping track of thread indexes mapped to rows of the group and array partialsums meaning of which is explained later . then we fetch the group info structure . to achieve coalesced memory access we employ four threads to this task ( lines 2528 ) .",
    "thread synchronization is important here .",
    "next , we may fetch array with mapping of threads to rows .",
    "the next part is independent on this array and therefore synchronization is not necessary .",
    "each thread takes its own chunk and perform multiplication of this part of matrix data with given part of input vector .",
    "result of this is partial sum .",
    "we remind that we mark artificial zeros by column index -1 . once",
    "a thread reaches this column index it exits the loop on lines 4250 .",
    "if it happens in whole warp , it exits too and it omits the rest of artificial zeros .",
    "the last step is summing of the partial sums .",
    "there is data dependency with the previous part and so thread synchronization on the line 52 is necessary .",
    "the results , we present in this section , were obtained on a system equipped with cpu amd phenom ii x6 1100 t with 16 gb ddr3 ram and gpu nvidia tesla c2070 having 6 gb gddr5 with memory bandwidth 144 gb / s ( ecc was turned off ) .",
    "all tests were done in double precision and sequentially on cpu .",
    "testing matrices were fetched from matrix databases @xcite .",
    "the testing set contained almost 1 600 sparse square matrices .",
    "the best performance was achieved with 128 threads in block .",
    "test show that the parameter desiredchunksize can have strong impact on the efficiency .",
    "simple rule might be : the more regular the matrix is ( in sense that there are almost the same non - zero elements in each row ) , the larger the desired chunk size should be . with desired chunk size 32",
    "we have achieved the highest performance almost 18 gflops with matrices schenk_afe originating in structural problems .",
    "with desiredchunksize set to one , the performance dropped to 11 gflops for this matrix . on the other hand , with the matrix rajat23 ,",
    "the performance was six times higher with desiredchunksize 1 ( 5.1 gflops and speed - up 11 compared to csr on cpu ) than with desiredchunksize 32 ( 0.81 gflops ) . in the rest of this section we present results obtained with the desired chunk size set to 1 because it seems to be more robust setting .",
    "figure [ fig : csr - comparison ] shows speed - up of tested formats compared to csr format on cpu . the vertical axis shows the speed - up in logarithmic scale and the horizontal axis shows on how many matrices the formats attain given speed - up .",
    "there is one curve for each format and the slower it decreases the better the format is .",
    "our test shows that the hybrid format , row - grouped csr format , cusparse library and the new format are is faster for 726 , 907 , 994 and 1168 matrices of 1600 respectively .",
    "this figure also shows that there are few matrices for which cpu is two orders of magnitude faster .",
    "they are mainly small matrices having tens or hundreds of unknowns as our previous test in @xcite show .",
    "figure [ fig : argcsr - comparison ] shows speed - up of the new format compared to the others . the vertical axis shows speed - up in logarithmic scale while the horizontal number of matrices for which the new format attains given speed - up compared to other formats .",
    "the higher the curve is , the better the new format is .",
    "our test show that the the hybrid format is slower on 1318 matrices , row - grouped csr on 1072 matrices and cusparse on 1358 matrices .    both figures [ fig : csr - comparison ] and [ fig : argcsr - comparison ]",
    "demonstrate that the performance of sparse - matrix and vector multiplication on gpu is very variable .",
    "if high performance is the top priority , one should test more formats and choose the best one .",
    "for example the cusparse library is almost 4 times faster than the new format on tsopf and case39 matrix sets from @xcite .",
    "both types of matrices model `` transient stability - constrained optimal power flow '' and usually the hybrid format outperforms the others in these cases . on the other hand , the new format is ten times faster than cusparse ( and at the same time 5 - 8 times faster than csr on cpu ) for matrices raj , rajat , ghs_indef , ibm_eda .",
    "these matrices come from circuit simulations or optimizations problems .",
    "original row - grouped csr format ( or similar sliced ellpack ) is almost twice faster for norris / torso2 and t2d_q matrices originating in finite difference methods .",
    "the mentioned matrices are all difficult to visualize in this paper because of very large dimensions and we refer reader to @xcite for more details .",
    "the source code of the format is freely available as a part of the template numerical library ( tnl ) at      this work was partially supported by the jindich neas center for mathematical modelling , research center of the ministry of education of the czech republic lc06052 , research direction project of the ministry of education of the czech republic no .",
    "msm6840770010 , and advanced supercomputing methods for implementation of mathematical models , project of the student grant agency of the czech technical university in prague no .",
    "sgs11/161/ohk4/3t/14 , 2011 - 13 .",
    "z.  bai , d.  day , j.  demmel , and j.  dongarra . test matrix collection ( non - hermitian eigenvalue problems ) , release 1 .",
    "technical report , university of kentucky , 1996 .",
    "ftp://ftp.ms.uky.edu/pub/misc/bai/collection .",
    "n.  galoppo , n.  k. govindaraju , m.  henson , and d.  manocha .",
    "lu - gpu : efficient algorithms for solving dense linear systems on graphics hardware , page 3 , washington , dc . in _ 2005 acm / ieee conference on supercomputing  sc2005 _ ,",
    "pages 314 , 2005 .",
    "v.  w. lee , ch .",
    "kim , j.  chhugani , m.  deisher , d.  kim , a.  d. nguyen , n.  satish , m.  smelyanskiy , s.  chennupaty , p.  hammarlund , r.  singhal , and p.  dubey . debunking the 100x gpu vs. cpu",
    "myth : an evaluation of throughput computing on cpu and gpu . in _",
    "isca10 _ , pages 451460 , 2010",
    ".                  v.  volkov and j.  demel .",
    "lu , qr and cholesky factorizations using vector capabilities of gpus .",
    "technical report ucb / eecs-2008 - 49 , electrical engineering and computer sciences university of california at berkeley , 2008 ."
  ],
  "abstract_text": [
    "<S> we present new adaptive format for storing sparse matrices on gpu . </S>",
    "<S> we compare it with several other formats including cusparse which is today probably the best choice for processing of sparse matrices on gpu in cuda . </S>",
    "<S> contrary to cusparse which works with common csr format , our new format requires conversion . </S>",
    "<S> however , multiplication of sparse - matrix and vector is significantly faster for many matrices . we demonstrate it on set of 1 600 matrices and we show for what types of matrices our format is profitable </S>"
  ]
}