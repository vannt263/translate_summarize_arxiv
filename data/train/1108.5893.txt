{
  "article_text": [
    "with the advent of the internet , the growth of large communication networks , and the staggering rate of interaction and data exchange , the need for self maintaining distributed networks has grown tremendously .",
    "while such huge networks provide an excellent backbone for processing and exchanging data at a scale that was unimaginable before , they also call for radically improved and novel techniques that are efficient and fault tolerant at the same magnitude . at this scale ,",
    "managing resources centrally is untenable .",
    "it is imperative that we design distributed and localized healing algorithms for failures , that achieve and maintain all desired global connectivity properties .",
    "the challenge lies in several dimensions : ( a ) localized distributed algorithms have the inability to look far into the network and so maintaining global properties is unclear , ( b ) several of the properties desired may themselves be conflicting on first sight such as ensuring upper bounds on degrees while maintaining low stretch and high expansion ( c ) the rate and nature of failures can be completely arbitrary ( or adversarial ) and thus , hard to predict , and finally yet very importantly ( d ) reacting to failures by deleting and adding new communication edges can be expensive in both cost and time .",
    "this line of work adopts a responsive approach , in the sense that it responds to an attack ( or component failure ) by changing the topology of the network .",
    "this approach works irrespective of the initial state of the network , and is thus orthogonal and complementary to traditional non - responsive techniques . in this setting , these papers seek to address the important and challenging problem of efficiently and responsively maintaining global invariants in a localized , distributed manner .",
    "healing algorithms play a crucial part in distributed peer - to - peer networks where failures occur continuously and frequently .",
    "several self - healing algorithms have been suggested in the recent literaureture  @xcite in a line of work that has yielded gradual improvements in the properties ensured on the graph .",
    "the competing requirements normally imposed are that of maintaining small degrees , while ensuring high connectivity in terms of shortest path dilation . in a recent work",
    "@xcite , an additional requirement of _ expansion _ was added , and an improved self - healing algorithm for maintaining the same was presented .",
    "this work motivates a strong general phenomenon of _ edge - preserving _ healing that aims at obtaining self - healing algorithms with the constraint that all the original edges in the graph ( not deleted by the adversary ) , be retained in _ every _ intermediate graph .",
    "this naturally further restricts the ability to add new edges during failures , due to the degree bound constraints .",
    "this is the primary focus of our paper and we motivate this further in the next paragraph .",
    "several algorithms have been designed to obtain self - healing in such distributed networks , and in a series of papers , some of these concerns have been addressed .",
    "one challenge in particular , however , has received little attention : namely , the cost of deleting and adding new edges .",
    "past work has bounded this cost by restricting the number of edges that can be deleted or added . however , none of the works appeal to the concept of _ minimizing _ the edge _ deletions _ of the network , at any healing stage .",
    "the most recent algorithm , and arguably the best for this problem , suffers from requiring deletion of edges with _ every _ possible local healing step . in this paper",
    ", we address this question by designing _",
    "edge - preserving _ healing algorithms : we require that a self - healing algorithm not delete _ any _ edge that was originally present or was inserted during a node insertion into the network .",
    "we however do allow deleting edges that were added in subsequent localized healing steps .",
    "while the edge - preserving property helps us minimize , or rather completely eliminate , the need to rewire communication paths originally present in any network , surprisingly , we can show much more .",
    "we are able to not only prove all the previous guarantees on all other requirements , but also show that edge - preservation immediately leads to several other very desirable global properties .",
    "most notably , this helps us preserve the _",
    "density _ of _ every _ current induced subgraph between nodes that were present originally in the network . in fact",
    ", edge - preserving self - healing ensures that every subgraph property that is edge - monotone i.e. non - decreasing with an increase in the number of edges does not suffer .",
    "density is an important example of such a property .",
    "density is a very well studied notion in graphs and is an excellent measure of the inter - connectivity between groups of nodes .",
    "density measures the _ strength _ of a set of nodes by the graph induced on them from the overall structure .",
    "the power of density lies in locally observing the strength of _ any _ set of nodes , large or small , independent of the entire network .",
    "expansion , on the other hand measures the connection between a set of nodes and the rest of the network .",
    "therefore , density constraints would be able to assess and better maintain the strength between specified ( or all ) subsets of nodes ( even though there are exponential such sets ) in a more robust manner .",
    "consider for example a distributed network that contains a small set @xmath0 of @xmath1 nodes where these @xmath1 nodes are _ hubs _ , or central and crucial to the overall backbone of the network .",
    "it is conceivable and even likely that they would incur a larger communication interaction between them , and therefore demand larger connectivity structure , lower latency , and higher resilience to failures .",
    "therefore , a peer to peer network would have a larger number of connections between these @xmath1 nodes as compared to any random set of @xmath1 nodes .",
    "it is then crucial that any self - healing algorithm retain this stronger interconnection within @xmath0 , and not accidently compromise these connections for increasing connectivity at less desired places .",
    "ensuring that the _ density _ between these nodes is preserved guarantees higher tolerance to failures , lower latencies and more efficient communication paths between the important set of nodes , namely @xmath0 .",
    "unfortunately not all previous healing algorithms were able to ensure this density requirement even if it were present in the original network ; the healing stages would inadvertently compromise such hidden dense structures for more smoothed global connectivity properties ( since expansion and other previous requirements did not capture this notion of induced density ) .",
    "the algorithms we present here are able to maintain ( or even further improve ) the density of _ every _ subset of nodes from the initial network , and through all stages of the self - healing steps .",
    "surprisingly , we are able to achieve this without compromising on any of the other requirements . therefore",
    ", in addition to all subgraph densities , our paper continues to satisfy degree constraints , preserve or even improve expansion , while maintaining low stretch , like the previous paper .",
    "our algorithms are simple and largely exploit the previous algorithms , yet guarantee the strong _ edge - preserving _ property .",
    "the papers on this topic admit that they need the network to be _",
    "reconfigurable _ in that edges may need to be continuously deleted and added .",
    "however , continuous deletion and addition of edges can be costly . with the necessity to delete original edges eliminated ,",
    "the applicability of our algorithms suggested in this paper extends more effectively to a larger class of networks including peer - to - peer , wireless mesh , and ad - hoc computer networks , and infrastructure networks ( e.g. airline transportation ) .",
    "most of these networks , while dynamic , would incur initiation and termination costs for new connections and dropping connections , whenever making an alteration in the networks .",
    "our algorithms also help these networks retain their backbone connections and thereby minimize any reconstruction / rconfiguration costs .    * our model : * our model - _ the general self - healing model _ is a generalization of the models used in  @xcite .",
    "we describe it here briefly .",
    "we assume that the network is initially a connected graph over @xmath2 nodes .",
    "an adversary repeatedly attacks the network .",
    "this adversary knows the network topology and our algorithm , and it has the ability to delete arbitrary nodes from the network or insert a new node in the system which it can connect to any subset of nodes currently in the system .",
    "however , we assume the adversary is constrained in that in any time step it can only delete or insert a single node . in this context",
    ", the self - healing algorithm is supposed to fulfill certain success metrics , according to the particular requirements of the problem .",
    "the detailed model is described in section  [ sec : xmodel ] .",
    "* our contributions . *",
    "* we introduce edge preservation as a novel consideration for healing algorithms , motivated by the cost associated with switching physical network communication lines .",
    "we show edge preservation not only reduces the cost but also results in desirable network structural consequences such as preserving or improving various monotonic graph properties . in particular , we motivate and use density as a running example for an interesting monotonic property .",
    "we then consider density as a novel constraint for the design of self - healing algorithms .",
    "* we generalize and strengthen previous algorithms to consider edge - preservation , and in particular maintaining or increasing all subgraph densities , as a constraint to the algorithmic problem .",
    "this enforces the constraint of maintaining any strong connectivity structure between hub nodes , or nodes with high bandwidth / communication . * finally , we present proofs for the unified algorithm presented in this paper by showing strong guarantees on the density constraint , as well as show how the previously considered measures , such as connectivity , diameter , degree constraint , network stretch , and expansion , continue to hold without being compromised .",
    "our proofs are simple and the algorithm and proof essentially fall out from a fairly simple generalization of the previous techniques by a small modification that enforces the edge - preserving property .    * related work : * this work builds upon previous works of self - healing .",
    "it investigates the algorithms discussed in  @xcite ; in particular , we introduce an edge - preserving ( formally defined later ) version of the algorithm _ xheal _ and show that this new version self - heals subgraph density .",
    "these works show a progressive increase in the number of properties self - healed and increasing sophistication in the techniques used .",
    "the earliest works  @xcite maintained connectivity while ensuring low degree increase .",
    "later , hayes , rustagi , saia and trehan introduced the _ forgiving tree _",
    "@xcite , which is a tree maintenance algorithm , that while being much more efficient also maintained the diameter of the network .",
    "however , it does not handle insertion ( this is still an open problem in the tree maintenance setting ) .",
    "hayes , saia and trehan later introduced the _ forgiving graph _",
    "@xcite , which improved upon forgiving tree by not only handling insertions but also maintaining network stretch ( which is a stronger property than network diameter ) .",
    "all the above algorithms use tree like structures for self - healing ; pandurangan and trehan instead use expander structures in xheal  @xcite and show that they can also self - heal network expansion in addition to the previous properties .",
    "our work augments these previous works by adding a new desirable property for self - healing algorithms , adding subgraph density to the list of properties maintained , analyzing the previous algorithms for these properties and modifying them ( when required ) .",
    "further , the problem of finding densest subgraphs is well - studied .",
    "finding a maximum density subgraph on an undirected graph can be solved in polynomial time  @xcite .",
    "however , the problem becomes np - hard when a size restriction is enforced .",
    "in particular , finding a maximum density subgraph of size exactly @xmath1 is np - hard  @xcite and no approximation scheme exists under a reasonable complexity assumption  @xcite .",
    "khuller and saha  @xcite considered the problem of finding densest subgraphs with size restrictions and showed that these are np - hard .",
    "khuller and saha  @xcite and also andersen and chellapilla  @xcite gave constant factor approximation algorithms .",
    "there are several more papers related to finding dense subgraphs , both theoretical and practical , but we avoid listing a comprehensive survey of this literature and refer the reader to the references in the aforementioned papers .",
    "the nice aspect of our self - healing algorithms approach is that it completely bypasses the problem of actually computing dense subgraphs ; the density of any subgraph is simply retained ( or increased ) as an immediate consequence of the edge - preserving property .",
    "let @xmath3 be an undirected graph and @xmath4 be a set of nodes .",
    "* graph density : * the density of a graph @xmath5 is defined as @xmath6 .",
    "* subgraph density : * the density of a subgraph defined by a subset of nodes @xmath0 of @xmath7 is defined as its induced density . we will use @xmath8 to denote the density of the subgraph induced by @xmath0 .",
    "therefore , @xmath9 . here @xmath10 is the subset of edges @xmath11 of @xmath12 where @xmath13 and @xmath14 .",
    "in particular , when talking about the density of a subgraph defined by set of vertices @xmath0 induced on @xmath15 , we use the notation @xmath16 . however , when clear from context , we omit the subscript @xmath15 .",
    "* edge expansion : * we denote @xmath17 .",
    "let @xmath18 be the number of edges crossing the cut @xmath19 .",
    "we define the _ volume _ of @xmath0 to be the sum of the degrees of the vertices in @xmath0 as @xmath20 .",
    "the edge expansion of the graph @xmath21 is defined as , @xmath22 ,",
    "0.5    each node of @xmath23 is a processor .",
    "each processor starts with a list of its neighbors in @xmath23 .",
    "pre - processing : processors may send messages to and from their neighbors . adversary deletes or inserts a node @xmath24 from / into @xmath25 , forming @xmath26 .",
    "the new neighbors of @xmath24 may update their information and send messages to and from their neighbors .",
    "all neighbors of @xmath24 are informed of the deletion .",
    "nodes of @xmath26 may communicate ( synchronous / asynchronous , in parallel ) with their immediate neighbors .",
    "these messages are never lost or corrupted , and may contain the names of other vertices . during this phase , each node may insert edges joining it to any other nodes as desired .",
    "nodes may also drop edges from previous rounds if no longer required . at the end of this phase , we call the graph @xmath27 .    ' '' ''    * * maintaining properties : * maintain certain well stated invariants/ minimize certain(local / global ) `` complexity '' measures .",
    "* * recovery time : * the maximum total time for a recovery round , assuming it takes a message no more than @xmath28 time unit to traverse any edge and we have unlimited local computational power at each node . * * communication complexity : * number of messages used for recovery .",
    "0.5    consider the graph @xmath29 which is the graph , at timestep @xmath30 , consisting solely of the original nodes ( from @xmath23 ) and insertions without regard to deletions and healings .    1 .   * connectivity . * if @xmath29 is connected , so is @xmath27 .",
    "* degree increase .",
    "* @xmath31 .",
    "3 .   * density .",
    "* @xmath32 .",
    "4 .   * edge expansion .",
    "* @xmath33 ; for constants @xmath34 . 5 .",
    "* diameter .",
    "* diameter(@xmath27)/ diameter(@xmath29 ) .",
    ".   * network stretch .",
    "* @xmath35 , where , for a graph @xmath15 and nodes @xmath36 and @xmath37 in @xmath15 , @xmath38 is the length of the shortest path between @xmath36 and @xmath37 in @xmath15 .",
    "this model was introduced in  @xcite .",
    "somewhat similar models were also used in  @xcite .",
    "we now describe the details .",
    "let @xmath39 be a self - healing algorithm .",
    "let @xmath40 be an arbitrary graph on @xmath2 nodes , which represent processors in a distributed network . in each step , the adversary either deletes or adds a node .",
    "after each deletion , the algorithm gets to add some new edges to the graph , as well as deleting old ones . at each insertion , the processors follow a protocol to update their information .",
    "s goal is to maintain a certain set of properties e.g. those given in figure  [ algo : sh - complexitymeasures ] . at the same time , the algorithm wants to minimize the resources spent on this task , which usually also includes keeping node degree small .",
    "initially , each processor only knows its neighbors in @xmath23 , and is unaware of the structure of the rest of @xmath23 .",
    "after each deletion or insertion , only the neighbors of the deleted or inserted vertex are informed that the deletion or insertion has occurred .",
    "after this , processors are allowed to communicate ( synchronously or asynchronously depending on the constraints ) by sending a limited number of messages to their direct neighbors .",
    "we assume that these messages are always sent and received successfully .",
    "the processors may also request new edges be added to the graph .",
    "we make sure that no other vertex is deleted or inserted until the end of this round of computation and communication has concluded .",
    "we also allow a certain amount of pre - processing to be done before the first attack occurs .",
    "for example , we assume that all nodes know the address of all the neighbors of its neighbors ( non ) . our full model is described in figure  [ algo : model-2 ] .",
    "here , we introduce edge - preservation , which we contend is a strongly desirable property for self - healing . a self - healing algorithm is edge - preserving in our model",
    "if the original edges and those inserted by the adversary are never deleted by the algorithm . more formally , we state : + * edge preserving : * a self - healing algorithm @xmath39 is edge - preserving in the general self - healing model ( figure  [ algo : model-2 ] ) , if we have that , for all @xmath41 , if @xmath42 , then @xmath43 . we also define the notion of an edge - monotonic property as follows : + * edge - monotonic graph property / function : * given a graph @xmath5 , and a subgraph @xmath44 , a subgraph property / function @xmath45 is said to be edge - monotonic or edge - monotonically non - decreasing if for any two graphs @xmath46 , @xmath47 with @xmath48 , we have @xmath49 .",
    "further , the property is said to be edge - monotonically increasing if for @xmath50 , we have @xmath51 .",
    "it is quite straightforward to maintain edge - monotonic graph properties once edge - preservation is achieved .",
    "we show this more formally in section  [ sec : xanalysis ] for the algorithm xheal+ ( described later ) and the edge - monotonic property of density .",
    "here , we describe _ xheal+ _ , which is the algorithm xheal  @xcite modified to make it edge - preserving .",
    "the main difference from xheal is that we allow multiple ` colorings ' ( explained more formally later ) for a single edge in xheal+ .",
    "this enables us to detect if the edge was originally present or inserted by the adversary in the graph and has been recolored by the algorithm . at certain points in its execution ,",
    "xheal removed edges from the graph ; in xheal+ , if the edge was not an ` original ' edge , we delete the edge as in xheal , but otherwise , we simply remove the required label / color from the edge without deleting it .",
    "the algorithm is summarized in figure  [ algo : repairbyexpander ] ; to make it easy to understand the modifications from xheal , we have added the symbol _ + _ to the lines we have changed .",
    "we have also rewritten some of the subroutines more clearly and added the subroutines given in figures  [ algo : mergeclouds ] , [ algo : maketopology ] , [ algo : markedges ] , and  [ algo : deleteedges ] .    here",
    ", we will not describe the details of the algorithm which are already given in  @xcite .",
    "however , we shall very briefly summarise the algorithm for completeness and explain in more detail the enhancements in xheal+ .",
    "let @xmath52 be a fixed parameter that is implementation dependent .",
    "for the purposes of this algorithm , we assume the existence of a @xmath52-regular expander with edge expansion @xmath53 . to describe the algorithm , in xheal+ , we associate a set of colors ( as opposed to a single color in xheal ) with each edge of the graph i.e. for an edge @xmath54",
    ", @xmath55 is a set of colors associated with an edge .",
    "each color associates a property or functionality with an edge .",
    "we assume that the original edges of @xmath56 and those added by the adversary are all colored * black * initially i.e. for such an edge @xmath54 , @xmath57 .",
    "if @xmath58 is a black ( colored ) edge , we say that @xmath59(@xmath60 ) is a black ( colored ) neighbor of @xmath60(@xmath59 ) . in xheal+ , the algorithm can later add functionality to the edge ( add as part of primary or secondary clouds , as described later ) by adding new colors to the set , and remove the functionality by simply removing that color .    at any time step",
    ", the adversary can add a node ( with its incident edges ) or delete a node ( with its incident edges ) .",
    "addition is straightforward , the algorithm takes no action and the added edges simply get colored * black * ( notice the edge did not exist before , so this will be its first color ; in a model where edges may be adversarially added to previously existing nodes , this may not hold ) .",
    "the self - healing algorithm is mainly concerned with what edges to add when a node is deleted and this is done based on the colors of the edges deleted as well as on other factors . in brief , the neighbors of the deleted node may be all black i.e. @xmath61 for all edges @xmath54 deleted in this step , or not all black .",
    "if they are all black , the neighbors reconnect as a primary cloud(figure   [ algo : makecloud ] ) i.e. as a @xmath52-regular expander or as a clique if number of neighbors are less than @xmath52 ( figure  [ algo : maketopology ] ) .",
    "this cloud has its own color ( e.g. it could be the label or i d of the deleted node ) ; if a required edge does not exist , a new one is created and it takes this color , but if the edge already exists , in xheal+ , this color is added to the color set of the edge ( figure  [ algo : maketopology ] ) . if the neighbors of the deleted node are not all black , this implies that the deleted node was part of at least one primary cloud ( a node participates exactly once in a primary cloud for each of its deleted neighbor ) ; we fix these primary clouds by redrawing ( deleting / adding / reusing ) some edges ( figure   [ algo : fixprimary ] ) to restore them to be expanders . in xheal+ , since you are not allowed to remove original edges , there may be a need or advantage in doing this more efficiently reusing existing edges .",
    "now , we select a ` free ' node ( explained later ) from each of these primary clouds and construct a secondary cloud ( figure  [ algo : makesecondary ] ) .",
    "a free node is simply a node which is not taking part in any secondary cloud , thus , a node can take part in at most one secondary cloud . when a node is a part of a secondary cloud , it is called a bridge node for the primary cloud it represents .",
    "each secondary cloud also has its own distinct color and this gets added onto the edge if it s also used for secondary cloud duties . on deletion of a node , secondary cloud edges",
    "may also be lost , in which case we repair this cloud too ( figure  [ algo : fixsecondary ] ) .",
    "we do this by finding a new free node for the primary cloud that lost the bridge node ( i.e. the deleted node ) , if need be , by borrowing from neighboring primary clouds .",
    "however , some times this may not be possible , in which case , we merge all the primary and secondary clouds effected and make a new primary cloud from all their nodes ( figure  [ algo : mergeclouds ] ) .",
    "merging is an expensive operation but since it will not happen often , its cost is amortized over previous operations .",
    "edges may be deleted in the cloud fixing and merging operations , thus , these operations need to be edge preserving . also , we have to ensure the nodes can communicate while the reconstruction is underway . to ensure this",
    ", we have added the algorithms markedges()(fig .",
    "[ algo : markedges ] ) , maketopology()(fig .  [ algo : maketopology ] ) , and deleteedges(fig .",
    "[ algo : deleteedges ] ) .",
    "the algorithm markedges ( ) prepares the clouds for construction or repair by removing the cloud s color from the edges and marking those edges which can be safely removed ( if an edge was originally present or added by the adversary , it will have the color black in its set and thus will not be marked ) .",
    "notice that the edges themselves can not be removed at this stage since these edges will form the network of communication for the present round of repair .",
    "maketopology is used to make the cloud edges ; it checks for existence of a required edge for the cloud being constructed , if that edge already exists , it simply adds the color of the cloud to the color set of the edge .",
    "if an edge does not exist between the two nodes , a new edge is constructed and the edge s color set is initialized by the color of the cloud .",
    "deleteedges is the subroutine called after a new cloud is in place to clean up .",
    "it checks all the marked edges to see which ones have no color left .",
    "this means these edges were not reused and they are also not original edges and can thus be deleted .    *",
    "+ @xmath62 inserted edges @xmath54 , @xmath63 . *",
    "[ algoline : xh - black ] makecloud(@xmath64 ) let @xmath65 be primary clouds that lost an edge fixprimary(@xmath66 $ ] ) makesecondary(@xmath67 \\cup blacknbrs(v)$ ] ) let @xmath67 \\leftarrow$ ] primary clouds of @xmath59 ; @xmath68 secondary cloud of @xmath59 ; @xmath69 \\leftarrow$ ] @xmath70 $ ] , @xmath71 \\leftarrow f \\cap [ c_1 , \\dots , c_{j } ]   $ ] fixprimary(@xmath66 $ ] ) fixsecondary(@xmath72 ) makesecondary(@xmath73 \\cup blacknbrs(v)$ ] )    [ algo : repairbyexpander ]    * + * markedges(@xmath74 $ ] ) makecloud(@xmath75 ) * + * deleteedges(@xmath74 $ ] )    [ algo : fixprimary ]    * + * mergeclouds(@xmath74 $ ] ) return makecloud(@xmath76 $ ] , secondary , @xmath77 )    [ algo : makesecondary ]    * + * mergeclouds(@xmath78 ) * + * markedges(@xmath78 ) makecloud(@xmath79 $ ] , secondary , color(f ) ) * + * deleteedges(@xmath78 )    [ algo : fixsecondary ]    * + * maketopology(@xmath80 , type , clr , clique$ ] ) * + * maketopology(@xmath80 , type , clr,\\kappa - reg expander $ ] )    [ algo : makecloud ]    markedges(@xmath74 $ ] ) makecloud(@xmath81 , primary , clr_{new}$ ] ) deleteedges(@xmath74 $ ] )    [ algo : mergeclouds ]    design graph @xmath82 , e)$ ] of topology @xmath83 @xmath84 , @xmath85 make new edge @xmath54 ; set @xmath86 , @xmath85    [ algo : maketopology ]    @xmath87 mark @xmath54 for deletion    [ algo : markedges ]    delete edge unmark edge    [ algo : deleteedges ]    let a free node be a primary node without secondary duties return free node ask neighbor clouds ; if a free node found , return node , else return null    [ algo : pickfreenode ]",
    "our main claim is that xheal+ , the edge - preserving version of xheal , improves xheal by giving not only the same self - healing guarantees but also self - healing monotonic subgraph induced properties such as subgraph density .",
    "recall the definition of an edge - monotonic graph property / function ( section  [ edge - preserving ] ) .",
    "it is easy to see that @xmath88 as the density function @xmath89 is an edge - monotonically increasing graph property .",
    "we now return to stating the main theorem of our paper in full generality and then turn to proving it formally .",
    "the proof only focuses on density , for ease of presentation .",
    "it is self - evident why similar guarantees translate to various monotonic graph properties .",
    "[ th : xmain ] the algorithm xheal+ :    1 .",
    "provides the same self - healing guarantees as xheal .",
    "2 .   further , for graph @xmath27(present graph ) and graph @xmath29 ( of only original and inserted edges ) , at any time t , where a timestep is an insertion or deletion followed by healing : for all @xmath90 , and any edge - monotonically non - decreasing function @xmath91 , we have @xmath92 .",
    "in particular , we have @xmath32 .",
    "expanding the above theorem using  @xcite , we get the main theorem on the guarantees that xheal+ provides on the topological properties of the healed graph , assuming xheal+ is able to construct a @xmath52-regular expander ( deterministically ) , for a fixed constant @xmath93 .",
    "[ th : main ] for graph @xmath27(present graph ) and graph @xmath29 ( of only original and inserted edges ) , at any time t , where a timestep is an insertion or deletion followed by healing :    1 .",
    "[ thpart : stretch ] for any two nodes @xmath94 , @xmath95 , where @xmath96 is the shortest path between @xmath60 and @xmath59 , and @xmath2 is the number of nodes in @xmath27 .",
    "[ thpart : exp ] @xmath97 , for some fixed constant @xmath98 , where @xmath99 is the edge expansion of a graph @xmath15 3 .",
    "[ thpart : cond ] @xmath100 , where @xmath101 is the second smallest eigenvalue of the laplacian of @xmath27 , @xmath102 , @xmath103 , @xmath104 and @xmath105 are the minimum and maximum degrees of @xmath29 .",
    "[ thpart : deg ] for all @xmath106 , @xmath107 , for a fixed constant @xmath108 .",
    "5 .   [ thpart : density ] for all @xmath90 , and",
    "any edge - monotonically non - decreasing function @xmath91 , we have @xmath92 . in particular , we have @xmath32 .",
    "observe that a graph healed by xheal+ can only have more edges than one healed by xheal , since certain edges are prohibited to be deleted in xheal+ . also , they are identical algorithms in other aspects",
    ". since both stretch can only be lower and expansion can only be higher if the edges are more , parts [ thpart : stretch ] and [ thpart : exp ] follow ( since these are proven to hold for xheal ) .",
    "part  [ thpart : cond ] is not affected since it is a statement bounding the conductance of the graph in relation to the minimim degree and maximum degree of nodes .",
    "we only need to worry about parts  [ thpart : deg ] and [ thpart : density ] .",
    "these follow from lemmas [ lemma : degree ] and [ lemma : density - lb ] .      in theorem",
    "[ th : main ] , we claim that for all @xmath90 , @xmath109 .",
    "we initiate the proof of this lemma via a significantly stronger , and independently desirable , property that we call edge - preservering property :    * edge preserving : * for all @xmath41 , if @xmath42 , then @xmath43 . we state and prove this in the following lemma .",
    "[ lemma : edgepreserving ] xheal+ is edge - preserving .",
    "the proof follows directly from the algorithm .",
    "the algorithm explicitly makes sure that it never deletes an edge that was present in the original graph , or was inserted by an adversary .",
    "this is clear from the algorithms markedges()(fig .",
    "[ algo : markedges ] ) , maketopology()(fig .",
    "[ algo : maketopology ] ) , and deleteedges(fig .",
    "[ algo : deleteedges ] ) , which are the only subroutines ultimately responsible for adding or deleting edges .",
    "the algorithm markedges ( ) marks the present edges which may possibly be affected by the reconstruction and those safe for deletion if not reused .",
    "maketopology reuses existing edges if they are part of the new clouds being formed or constructs new ones initializing the edge s color vector .",
    "deleteedges is the subroutine called after a new cloud is in place to clean up .",
    "it checks all the marked edges to determine the edges which are safe to be deleted by simply checking if their color set is empty .",
    "if the edge has no color i.e. empty color set , this means it was not an original or adversary inserted edge and has not been reused , and thus , can be safely deleted .",
    "now , we prove our main lemma about subgraph density .",
    "we are mainly concerned with lower bounding the density but in the following section , we also put in the upper bound for completeness .",
    "[ lemma : density - lb ] for all @xmath90 , @xmath110 .",
    "subgraph density is defined as @xmath9 for an induced subgraph of a subset @xmath0 of @xmath7 .",
    "consider any subset @xmath90 . since xheal+ is edge - preserving and @xmath29 contains only original or adversary inserted edges , @xmath111 and therefore @xmath112 .      in our paper",
    "we have been mainly concerned with making sure the density does not decrease . here , for completeness , we also study how much the density can increase .",
    "[ lemma : density - ub ] for all @xmath90 , @xmath113 .    from lemma  [",
    "th : main ] , part [ thpart : deg ] ( or lemma  [ lemma : degree ] ) , it follows that for the subset @xmath0 , if each node had the maximum degree increase and all the added edges were part of the induced subgraph @xmath114 , then @xmath115 . in the equation",
    ", @xmath116 comes from the fact that each edge contributes to the degree increase of two nodes .",
    "dividing by @xmath0 , the lemma follows .",
    "notice that the worst case comes when there was no edge between any node of @xmath0 in @xmath29 i.e. @xmath117 .",
    "let us consider the change in density of the present graph .",
    "[ lemma : density - graph - ub ] the density of the present graph @xmath27 , @xmath118 .    in the above statement , the l.h.s . represents the density of the present graph @xmath27 and the r.h.s .",
    "the density of the subgraph induced by the present graph @xmath27 on @xmath29 ( note that since @xmath29 suffers no deletions , @xmath119 ) . in lemma  [ lemma : density - ub ] , substituting @xmath120 for @xmath0 , we get , @xmath121 since the number of edges , @xmath122 is @xmath123 , we get the lemma .",
    "[ lemma : degree ] for all @xmath106 , @xmath124 , for a fixed parameter @xmath108 .",
    "the proof is essentially the same as in @xcite .",
    "recall that we call the original edges or the edges inserted by the adversary as black edges since they have the color black as part of their color set .",
    "intuitively , the same proof as that in xheal  @xcite holds since xheal does not depend on removing any black edges , and thus also covers the edge - preserving case .",
    "we give a brief proof counting the edges :    we bound the increase in degree of any node @xmath36 that belongs to both @xmath27 and @xmath29 .",
    "the degree of @xmath36 in @xmath29 , @xmath125 , is simply the count of its black edges .",
    "there are three cases :    1 .   _",
    "@xmath36 loses a black edge : _ in xheal+ , this can only happen when the adversary deletes a node ( since xheal+ is edge preserving ) .",
    "now , xheal+ may add upto @xmath52 edges by making @xmath36 part of a primary or a secondary cloud .",
    "thus , here , @xmath36 s degree can increase by a factor of @xmath52 2 .   _",
    "@xmath36 loses a edge with a non - black color : _ this can happen due to adversarial node deletion or during reconstruction by the algorithm .",
    "this node deletion initiates a reconstruction of the @xmath52-regular primary or secondary expander cloud ( during which some non - black edges may be removed ) . at the end of this reconstruction ,",
    "@xmath36 remains part of the @xmath52 ( or smaller)-regular degree cloud , and thus , does not increase its degree .",
    "notice that only time the algorithm itself deletes non - black edges is during reconstruction and does not add any more edges in lieu of these deleted edges .",
    "@xmath36 becomes a bridge node : _ this means that @xmath36 takes part in a secondary cloud for the first time , either for its own primary cloud or as a borrowed member by another cloud . since the secondary cloud itself is a @xmath52-regular expander , @xmath36 gains a degree of @xmath52 .",
    "however , @xmath36 never takes part in more than one secondary cloud .",
    "thus , from the above , we get that @xmath124 .",
    "we look at two other recent self - healing algorithms , forgiving graph  @xcite and forgiving tree  @xcite .",
    "our analysis shows that these algorithms are implicitly edge - preserving in the sense that they may not work properly if the algorithm ever deleted original or adversary added edges . at a high level , these algorithms have virtual nodes and edges , which are a counterpart of the clouds in xheal+ , and real nodes and edges , which will be like black edges in xheal+ .",
    "the basic mechanism is to replace the deleted node by a reconstruction tree of virtual nodes and edges ( i.e. placeholder nodes simulated by the real i.e. existing nodes in the network ) ; this is shown in figure  [ fig : rt ] ( from  [ hayespodc09 ] . without going into details , it is simple to use this mechanism of virtual structures instead of the marking scheme used in xheal+ to ensure edge - preservation if the underlying algorithm does not explicitly delete original edges . let us have a brief look at the measure of density ( as an example of an edge - monotonically non - decreasing property ) for these algorithms",
    ".     replaced by its reconstruction tree .",
    "the triangle shaped nodes are virtual helper nodes simulated by the real nodes which are in the leaf layer . ]",
    "forgiving graph confirms to the general self - healing model(figure  [ algo : model-2 ] ) maintaining as it s success metrics connectivity , degree increase and network stretch .",
    "it has the following bound on degree increase ( theorem 1 from  @xcite ) :    [ lemma : fg - deg ] for any node @xmath59 in @xmath120 , after any number of time steps , @xmath30 , @xmath126 .    the edge - preserving property and the above lemma yield ( lemma and proof similar to lemmas  [ lemma : density - lb ] , [ lemma : density - ub ] , and [ lemma : density - graph - ub ] ) :    [ lemma : fg - density ] for all @xmath90 , @xmath127 . for the graph density",
    "i.e. for @xmath128 , @xmath129      forgiving tree is essentially a spanning tree maintenance algorithm and confirms to the general self - healing model(figure  [ algo : model-2 ] ) except that it does not handle node insertions .",
    "thus , the comparison graph at any time @xmath30 @xmath29 is the same as the initial graph @xmath23 .",
    "forgiving tree maintains as its success metrics connectivity , degree increase and network stretch .",
    "it has the following bound on degree increase ( adapted from theorem 1 of  @xcite ) :    [ lemma : fg - deg ] for any node @xmath59 in @xmath120 , after any number of time steps , @xmath30 , @xmath130 .    the edge - preserving property and the above lemma yield :    [ lemma : fg - density ] for all @xmath90 , @xmath131 . for the graph density",
    "i.e. for @xmath128 , @xmath132 .",
    "we have presented an efficient , distributed algorithm that withstands repeated adversarial node insertions and deletions by adding a small number of new edges after each deletion .",
    "it maintains key global invariants of the network while doing only localized changes and using only local information .",
    "furthermore , it is edge - preserving , i.e. does not require any of the original edges to be deleted during any healing phase .",
    "this is a novel addition to all previous work and yields several desirable properties as a consequence including preserving subgraph densities .",
    "in addition , the algorithm maintains all previously studied global invariants .",
    "firstly , assuming the initial network was connected , the network stays connected .",
    "secondly , the ( edge ) expansion of the network is at least as good as the expansion would have been without any adversarial deletion , or is at least a constant .",
    "thirdly , the distance between any pair of nodes never increases by more than a @xmath133 multiplicative factor than what the distance would be without the adversarial deletions .",
    "lastly , the above global invariants are achieved while not allowing the degree of any node to increase by more than a small multiplicative factor .",
    "our work opens a new line of work towards obtaining healing algorithms that respect some initial structure - beyond just certain global measures .",
    "we have shown that edge - preservation is possible and that this leads to several desirable properties .",
    "can we go beyond this to maintain even more properties of the initial graph , such as the spectrum ( with some slack ) ?",
    "what about preserving some notion of proximity sketches with nodes ?",
    "this seems to open a new line of work .",
    "further , the goal of maintaining edge - preserving was two fold : first to obtain structural guarantees on local and global properties , and second to minimize the cost of modifications ( termination or initiation of new communication edges ) .",
    "for the first , can we reach a theoretical characterization of what network properties are amenable to self - healing , especially , global properties which can be maintained by local changes ?",
    "what about combinations of desired network invariants ?",
    "for the latter , can the costs be modeled in more robust and direct manner ?",
    "another interesting orthogonal question is whether there are deterministic algorithms that can yield the same bounds on all metrics as the current randomized healing algorithm .",
    "we can also extend the work to different models and domains .",
    "we can look at designing algorithms for less flexible networks such as sensor networks , explore healing with non - local edges or more complex notions of failure .",
    "j.  saia and a.  trehan , `` picking up the pieces : self - healing in reconfigurable networks , '' in _ _ ipdps .",
    "22nd ieee international symposium on parallel and distributed processing.__1em plus 0.5em minus 0.4emieee , april 2008 , pp .",
    "[ online ] .",
    "available : http://arxiv.org/pdf/0801.3710    t.  hayes , n.  rustagi , j.  saia , and a.  trehan , `` the forgiving tree : a self - healing distributed data structure , '' in _",
    "podc 08 : proceedings of the twenty - seventh acm symposium on principles of distributed computing_.1em plus 0.5em minus 0.4emnew york , ny , usa : acm , 2008 , pp .",
    "203212 .",
    "t.  p. hayes , j.  saia , and a.  trehan , `` the forgiving graph : a distributed data structure for low stretch under adversarial attack , '' in _",
    "podc 09 : proceedings of the 28th acm symposium on principles of distributed computing_.1em plus 0.5em minus 0.4emnew york , ny , usa : acm , 2009 , pp .",
    "121130 .",
    "a.  trehan , `` algorithms for self - healing networks , '' dissertation , university of new mexico , 2010 .",
    "[ online ] .",
    "available : http://proquest.umi.com/pqdlink?did=2085415901&fmt=2&clienti    d=11910&rqt=309&vname = pqd[http://proquest.umi.com / pqdlink?did=2085415901&fmt=2&clienti    d=11910&rqt=309&vname = pqd ]    g.  pandurangan and a.  trehan , `` xheal : localized self - healing using expanders , '' in _ proceedings of the 30th annual acm sigact - sigops symposium on principles of distributed computing _ , ser .",
    "podc 11.1em plus 0.5em minus 0.4emnew york , ny , usa : acm , 2011 , pp . 301310 .",
    "[ online ] .",
    "available : http://doi.acm.org/10.1145/1993806.1993865    i.  boman , j.  saia , c.  t. abdallah , and e.  schamiloglu , `` brief announcement : self - healing algorithms for reconfigurable networks . '' in _",
    "symposium on stabilization , safety , and security of distributed systems(sss ) _ , 2006 ."
  ],
  "abstract_text": [
    "<S> healing algorithms play a crucial part in distributed peer - to - peer networks where failures occur continuously and frequently . </S>",
    "<S> the general goal of self - healing distributed graphs is to maintain good connectivity throughout the network . </S>",
    "<S> this comes with the constraint that with every failure , one is allowed to only make bounded alterations locally . </S>",
    "<S> several self - healing algorithms have been suggested in the recent literature [ ipdps08 , podc08 , podc09 , podc11 ] in a line of work that has yielded gradual improvements in the properties ensured on the graph . </S>",
    "<S> the competing requirements normally imposed are that of maintaining small degrees , while ensuring high connectivity in terms of shortest path dilation . in a recent work in podc11 , an additional requirement on _ expansion _ was added , and an improved self - healing algorithm for maintaining the same was presented . </S>",
    "<S> this work motivates a strong general phenomenon of _ edge - preserving _ healing that aims at obtaining self - healing algorithms with the constraint that all original edges in the graph ( not deleted by the adversary ) , be retained in _ every _ intermediate graph . </S>",
    "<S> this naturally further restricts the ability to add new edges during failures , due to the degree bound constraints .    </S>",
    "<S> none of the previous algorithms , in their nascent form , are explicitly edge preserving . in this paper </S>",
    "<S> we show that the previous algorithms can be suitably modified with very simple changes such that all the previous properties are maintained , and in addition , the algorithms are _ edge - preserving_. towards this end , we present a general self - healing model that unifies the previous algorithms and shall hopefully be a definitive model . </S>",
    "<S> the main contribution of this paper is not in the technical complexity , rather in the simplicity with which the edge - preserving property can be ensured and the message that this is a crucial property with several benefits . in particular , we highlight the power of _ edge - preserving _ self - healing algorithms by showing that , almost as an immediate corollary , subgraph densities are preserved or increased . maintaining density is a notion that is clearly motivated by the fact that in certain distributed networks , certain nodes may require and initially have a larger number of inter - connections ( perhaps due to their larger bandwidth / communication requirements ) . </S>",
    "<S> it is vital that a healing algorithm , even amidst failures , respect these requirements ; this is something that was not guaranteed by any of the previous algorithms . </S>",
    "<S> our suggested modifications yield such subgraph density preservation as a by product . </S>",
    "<S> in addition , edge preservation helps maintain any subgraph induced property that is monotonic . </S>",
    "<S> also , algorithms that are edge - preserving require minimal alteration of edges which can be an expensive cost in healing - something that has not been modeled in any of the past work . </S>",
    "<S> all the algorithms and proofs presented are simple and yet powerful enough to guarantee edge preservation in addition to all previous requirements . </S>"
  ]
}