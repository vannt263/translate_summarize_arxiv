{
  "article_text": [
    "in the stabbing - max problem , a set of rectangles is stored in a data structure , and each rectangle @xmath8 is assigned a priority @xmath9 . for a query point @xmath10 ,",
    "we must find the highest priority rectangle @xmath8 that contains ( or is stabbed by ) @xmath10 . in this paper we describe a dynamic data structure that answers stabbing - max queries on a set of one - dimensional rectangles ( intervals ) in optimal @xmath2 time .",
    "we also show how this result can be extended to @xmath11 dimensions",
    ".    * previous work . *",
    "the stabbing - max problem has important applications in networking and geographic information systems .",
    "solutions to some special cases of the stabbing - max problem play a crucial role in classification and routing of internet packets ; we refer to e.g. ,  @xcite for a small selection of the previous work and to  @xcite for more extensive surveys .",
    "below we describe the previous works on the general case of the stabbing - max problem .",
    "the semi - dynamic data structure of yang and widom  @xcite maintains a set of one - dimensional intervals in linear space ; stabbing - max queries and insertions are supported in @xmath1 time .",
    "agarwal et al .",
    "@xcite showed that stabbing - max queries on a set of one - dimensional intervals can be answered in @xmath12 time ; the data structure of agarwal et al .",
    "@xcite uses linear space and supports updates in @xmath1 time . the linear space data structure of kaplan et al .",
    "@xcite supports one - dimensional queries and insertions in @xmath1 time , but deletions take @xmath13 time . in  @xcite , the authors also consider the stabbing - max problem for a nested set of intervals : for any two intervals @xmath14 , either @xmath15 or @xmath16 or @xmath17 .",
    "their data structure for a nested set of one - dimensional intervals uses @xmath18 space and supports both queries and updates in @xmath1 time .",
    "thorup  @xcite described a linear space data structure that supports very fast queries , but needs @xmath19 time to perform updates .",
    "his data structure supports stabbing - max queries in @xmath20 time and updates in @xmath21 time for any parameter @xmath22 .",
    "however the problem of constructing a data structure with poly - logarithmic update time is not addressed in  @xcite .",
    "agarwal et al .",
    "@xcite described a data structure that uses linear space and supports both queries and updates in @xmath1 time for an arbitrary set of one - dimensional intervals .",
    "the results presented in  @xcite and  @xcite are valid in the pointer machine model  @xcite .",
    "the one - dimensional data structures can be extended to @xmath11 dimensions , so that space usage , query time , and update time increase by a factor of @xmath23 .",
    "thus the best previously known data structure  @xcite for @xmath4-dimensional stabbing - max problem uses @xmath24 space , answers queries in @xmath25 time , and supports updates in @xmath26 time .",
    "kaplan et al .",
    "@xcite showed that @xmath4-dimensional stabbing - max queries can be answered in @xmath1 time for any constant @xmath4 in the special case of nested rectangles .    * our result . *",
    "the one - dimensional data structure described in  @xcite achieves optimal query time in the pointer machine model . in this paper",
    "we show that we can achieve sublogarithmic query time without increasing the update time in the word ram model of computation .",
    "our data structure supports deletions and insertions in @xmath0 and @xmath1 amortized time respectively .",
    "as follows from the lower bound of  @xcite , any fully - dynamic data structure with poly - logarithmic update time needs @xmath27 time to answer a stabbing - max query that is stabbed by a query point @xmath10 ? ] .",
    "thus our data structure achieves optimal query time and space usage .",
    "our result can be also extended to @xmath11 dimensions .",
    "we describe a data structure that uses @xmath3 space and answers stabbing - max queries in @xmath28 time ; insertions and deletions are supported in @xmath29 and @xmath28 amortized time respectively .",
    "moreover , our construction can be modified to support stabbing - sum . ]",
    "queries : we can count the number of one - dimensional intervals stabbed by a query point @xmath10 in @xmath2 time .",
    "the stabbing - sum data structure also supports insertions and deletions in @xmath1 and @xmath0 amortized time",
    ".    * overview .",
    "* we start by describing a simple one - dimensional stabbing - max data structure in section  [ sec : stabover ] .",
    "this data structure achieves the desired query and update times but needs @xmath30 space .",
    "all intervals are stored in nodes of the base tree of height @xmath2 ; the base tree is organized as a variant of the segment tree data structure .",
    "intervals in a node @xmath31 are stored in a variant of the van emde boas ( veb ) data structure  @xcite .",
    "we can answer a stabbing - max query by traversing a leaf - to - root path in the base tree ; the procedure spends @xmath32 time in each node on the path .",
    "in section  [ sec : compact ] , we show how all secondary data structures in the nodes of the base tree can be stored in @xmath33 bits of space . the main idea of our method is the compact representation of intervals stored in each node .",
    "similar compact representations were also used in data structures for range reporting queries  @xcite and some other problems  @xcite .",
    "however the previous methods are too slow for our goal : we need @xmath34 time to obtain the representation of an element @xmath35 in a node @xmath31 if the representation of @xmath35 in a child of @xmath31 is known",
    ". therefore it would take @xmath1 time to traverse a leaf - to - root path in the base tree . in this paper",
    "we present a new , improved compact storage scheme . using our representation",
    ", we can traverse a path in the base tree and spend @xmath32 time in each node .",
    "we believe that our method is of independent interest and can be also applied to other problems .",
    "the results for multi - dimensional stabbing - max queries and stabbing - sum queries are described in theorems  [ theor : multidim ] and  [ theor : sum1d ] ; an extensive description of these results is provided in appendices  c and  d.",
    "* base tree . * in this section we describe a data structure that answers stabbing - max queries in optimal time .",
    "endpoints of all intervals from the set @xmath36 are stored in the leaves of the base tree @xmath37 .",
    "every leaf of @xmath37 contains @xmath38 endpoints .",
    "every internal node , except of the root , has @xmath39 children ; the root has @xmath40 children . throughout this paper @xmath41",
    "denotes an arbitrarily small positive constant .",
    "the range @xmath42 of a node @xmath31 is an interval bounded by the minimal and maximal values stored in the leaf descendants of @xmath31 .    for a leaf node @xmath43 ,",
    "the set @xmath44 contains all intervals @xmath8 , such that at least one endpoint of @xmath8 belongs to @xmath43 . for an internal node @xmath31 ,",
    "the set @xmath45 contains all intervals @xmath8 , such that @xmath46 for at least one child @xmath47 of @xmath31 but @xmath48 .",
    "see fig .",
    "[ fig : basetree ] for an example .",
    "thus each interval is stored in @xmath0 sets @xmath45 . for every pair @xmath49",
    ", @xmath50 denotes the set of all intervals @xmath51 such that @xmath52 for a child @xmath53 of @xmath31 if and only if @xmath54 . for simplicity",
    ", we will sometimes not distinguish between intervals and their priorities .",
    "internal nodes of the base tree",
    ". intervals @xmath55 and @xmath56 are stored in the set @xmath57 , but are not stored in the set @xmath45 .",
    "interval @xmath58 is stored in @xmath45 , but @xmath58 is not stored in @xmath57 .",
    "interval @xmath59 is stored in both @xmath45 and @xmath57 .",
    "moreover , @xmath55 , @xmath59 , and @xmath56 belong to the sets @xmath60 , @xmath61 , and @xmath61 respectively .",
    "intervals @xmath59 and @xmath58 belong to @xmath62 and @xmath63 respectively . ]",
    "= 1000 * secondary data structures . * for each internal node @xmath31 , we store a data structure @xmath64 described in the following proposition .    [ lemma : search1d ] suppose that priorities of all intervals in @xmath45 are integers in the interval @xmath65 $ ] for @xmath66 .",
    "there exists a data structure @xmath64 that uses @xmath67 words of space and supports the following queries : for any @xmath68 , the predecessor of @xmath10 in @xmath69 can be found in @xmath34 time and the maximum element in @xmath69 can be found in @xmath32 time .",
    "the data structure supports insertions in @xmath34 time .",
    "if a pointer to an interval @xmath51 is given , @xmath8 can be deleted in @xmath32 amortized time .",
    "it suffices to store all intervals from @xmath69 in a veb data structure @xmath70 .",
    "each @xmath70 uses @xmath71 words of space and answers queries in @xmath72 time  @xcite .",
    "it is a folklore observation that we can modify the veb data structure so that maximum queries are supported in constant time .",
    "we also store a data structure @xmath73 that contains the interval @xmath74 with maximal priority among all intervals in @xmath50 for each @xmath49 .",
    "since each internal node has @xmath39 children , @xmath73 contains @xmath75 elements . for any query index @xmath76",
    ", @xmath73 reports the largest element among all @xmath77 , @xmath54 .",
    "in other words for any child @xmath53 of @xmath31 , @xmath73 can find the interval with the highest priority that covers the range of the @xmath76-th child of @xmath31 .",
    "using standard techniques , we can implement @xmath73 so that queries and updates are supported in @xmath32 time . for completeness",
    ", we describe the data structure @xmath73 in appendix a. * queries and updates .",
    "* let @xmath78 denote the search path for the query point @xmath10 in the base tree @xmath37 .",
    "the path @xmath78 consists of the nodes @xmath79 where @xmath80 is a leaf node and @xmath81 is the root node . let @xmath82 be the interval with the highest priority among all intervals that are stored in @xmath83 and are stabbed by @xmath10 .",
    "the interval @xmath84 can be found by examining all @xmath40 intervals stored in @xmath85 .",
    "suppose that we reached a node @xmath86 and the interval @xmath87 is already known .",
    "if @xmath10 stabs an interval @xmath8 stored in @xmath88 , then @xmath89 . therefore @xmath10 stabs an interval @xmath90 if and only if @xmath8 is stored in some set @xmath91 such that @xmath92 and @xmath93 is the @xmath76-th child of @xmath86 . using the data structure @xmath94",
    ", we can find in constant time the maximal interval @xmath95 , such that @xmath96 and @xmath92 .",
    "then we just set @xmath97 and proceed in the next node @xmath98 .",
    "the total query time is @xmath2 .",
    "when we insert an interval @xmath8 , we identify @xmath2 nodes @xmath86 such that @xmath8 is to be inserted into @xmath88 . for every such @xmath86 ,",
    "we proceed as follows .",
    "we identify @xmath99 and @xmath100 such that @xmath8 belongs to @xmath91 . using @xmath101",
    ", we find the position of @xmath8 in @xmath91 , and insert @xmath8 into @xmath91 . if @xmath8 is the maximal interval in @xmath91 , we delete the old interval @xmath102 from the data structure @xmath94 , set @xmath103 , and insert the new @xmath102 into @xmath94 .    when an interval @xmath8 is deleted , we also identify nodes @xmath86 , such that @xmath90 . for each @xmath86",
    ", we find the indices @xmath99 and @xmath100 , such that @xmath104 .",
    "using the procedure that will be described in the next section , we can find the position of @xmath8 in @xmath91 .",
    "then , @xmath8 is deleted from the data structure @xmath101 . if @xmath105 , we remove @xmath102 from @xmath94 , find the maximum priority interval in @xmath91 , and insert it into @xmath94 .",
    "we will show in section  [ sec : compact ] that positions of the deleted interval @xmath8 in @xmath91 for all nodes @xmath86 can be found in @xmath0 time . since all other operations take @xmath32 time per node , the total time necessary for a deletion of an interval is @xmath2 .",
    "unfortunately , the space usage of the data structure described in this section is very high : every veb data structure @xmath70 needs @xmath71 space , where @xmath106 is the highest possible interval priority .",
    "even if @xmath66 , all data structures @xmath64 use @xmath107 space . in the next section",
    "we show how all data structures @xmath64 , @xmath108 , can be stored in @xmath33 bits without increasing the query and update times .",
    "the key idea of our compact representation is to store only interval identifiers in every node @xmath31 of @xmath37 .",
    "our storage scheme enables us to spend @xmath34 bits for each identifier stored in a node @xmath31 . using the position of an interval @xmath8 in a node @xmath31 ,",
    "we can obtain the position of @xmath8 in the parent @xmath109 of @xmath31 .",
    "we can also compare priorities of two intervals stored in the same node by comparing their positions .",
    "these properties of our storage scheme enable us to traverse the search path for a point @xmath10 and answer the query as described in section  [ sec : stabover ] .",
    "similar representations were also used in space - efficient data structures for orthogonal range reporting  @xcite and orthogonal point location and line - segment intersection problems  @xcite .",
    "storage schemes of  @xcite also use @xmath34 bits for each interval stored in a node of the base tree .",
    "the main drawback of those methods is that we need @xmath34 time to navigate between a node and its parent .",
    "therefore , @xmath110 time is necessary to traverse a leaf - to - root path and we need @xmath111 time to answer a query . in this section",
    "we describe a new method that enables us to navigate between nodes of the base tree and update the lists of identifiers in @xmath32 time per node .",
    "the main idea of our improvement is to maintain identifiers for a set @xmath112 in every @xmath108 .",
    "when an interval is inserted in @xmath45 , we also add its identifier to @xmath113 .",
    "but when an interval is deleted from @xmath45 , its identifier is not removed from @xmath113 .",
    "when the number of deleted interval identifiers in all @xmath113 exceeds the number of intervals in @xmath45 , we re - build the base tree and all secondary structures ( global re - build ) .",
    "* compact lists . *",
    "we start by defining a set @xmath114 . if @xmath31 is a leaf node , then @xmath115 . if @xmath31 is an internal node , then @xmath116 for all children @xmath47 of @xmath31 .",
    "an interval @xmath8 belongs to @xmath117 if at least one endpoint of @xmath8 is stored in a leaf descendant of @xmath31 .",
    "hence , @xmath118 where the union is taken over all nodes @xmath119 that are situated on the same level of the base tree @xmath37 .",
    "since the height of @xmath37 is @xmath0 , the total number of intervals stored in all @xmath117 , @xmath108 , is @xmath120 .",
    "let @xmath113 be the set that contains all intervals from @xmath117 that were inserted into @xmath117 since the last global re - build .",
    "we will organize global re - builds in such way that at most one half of elements in all @xmath113 correspond to deleted intervals .",
    "therefore the total number of intervals in @xmath121 is @xmath122 .",
    "we will show below how we can store the represntations of sets @xmath113 in compact form , so that an element of @xmath113 uses @xmath123 bits in average .",
    "since @xmath124 , we can also use the same method to store all @xmath45 and @xmath64 in @xmath33 bits .",
    "sets @xmath117 and @xmath113 are not stored explicitly in the data structure . instead , we store a list @xmath125 that contains a compact representation for identifiers of intervals in @xmath113 .",
    "@xmath125 is organized as follows .",
    "the set @xmath113 is sorted by interval priorities and divided into blocks .",
    "if @xmath126 , then each block of @xmath113 contains at least @xmath127 and at most @xmath128 elements .",
    "otherwise all @xmath129 belong to the same block .",
    "each block @xmath130 is assigned an integer block label @xmath131 according to the method of  @xcite .",
    "labels of blocks are monotone with respect to order of blocks in @xmath125 : the block @xmath132 precedes @xmath133 in @xmath125 if and only if @xmath134 . besides that",
    ", all labels assigned to blocks of @xmath125 are bounded by a linear function of @xmath135 : for any block @xmath130 in @xmath125 , @xmath136 . when a new block is inserted into a list , we may have to change the labels of @xmath12 other blocks .",
    "for every block @xmath130 , we store its block label as well as the pointers to the next and the previous blocks in the list @xmath125 . for each interval @xmath137 in a block @xmath130 of @xmath113 , the list @xmath125 contains the _ identifier _ of @xmath137 in @xmath125 .",
    "the identifier is simply the list of indices of children @xmath47 of @xmath31 , such that @xmath138 .",
    "as follows from the description of the base tree and the sets @xmath113 , we store at most two child indices for every interval @xmath137 in a block ; hence , each identifier uses @xmath34 bits . to simplify the description , we sometimes will not distinguish between an interval @xmath8 and its identifier in a list @xmath125 .",
    "we say that the position of an interval @xmath8 in a list @xmath125 is known if the block @xmath130 that contains @xmath8 and the position of @xmath8 in @xmath130 are known .",
    "if we know positions of two intervals @xmath139 and @xmath140 in @xmath125 , we can compare their priorities in @xmath32 time .",
    "suppose that @xmath139 and @xmath140 belong to blocks @xmath132 and @xmath133 respectively .",
    "then @xmath141 if @xmath142 , and @xmath143 if @xmath134 .",
    "if @xmath144 , we can compare priorities of @xmath139 and @xmath140 by comparing their positions in the block @xmath145 .",
    "the rest of this section has the following structure .",
    "first , we describe auxiliary data structures that enable us to search in a block and navigate between nodes of the base tree . each block @xmath130 contains a poly - logarithmic number of elements and every identifier in @xmath130 uses @xmath123 bits .",
    "we can use this fact and implement block data structures , so that queries and updates are supported in @xmath32 time .",
    "if the position of some @xmath137 in a list @xmath125 is known , we can find in constant time the positions of @xmath137 in the parent of @xmath31 .",
    "next , we show how data structures @xmath64 and @xmath73 , defined in section  [ sec : stabover ] , are modified .",
    "finally , we describe the search and update procedures .    * block data structures .",
    "* we store a data structure @xmath146 that supports rank and select queries in a block @xmath130 of @xmath125 : a query @xmath147 returns the number of intervals that also belong to @xmath148 among the first @xmath149 elements of @xmath130 .",
    "a query @xmath150 returns the smallest @xmath151 , such that @xmath152 ; in other words , @xmath150 returns the position of the @xmath149-th interval in @xmath130 that also belongs to @xmath148 . we can answer @xmath153 and @xmath154 queries in a block in @xmath32 time .",
    "we can also count the number of elements in a block of @xmath125 that are stored in the @xmath76-th child of @xmath31 , and determine for the @xmath100-th element of a block in which children of @xmath31 it is stored .",
    "implementation of @xmath146 will be described in appendix a. for each block @xmath155 and for any child @xmath53 of @xmath31 , we store a pointer to the largest block @xmath156 before @xmath157 that contains an element from @xmath158 .",
    "these pointers are maintained with help of a data structure @xmath159 for each child @xmath53 .",
    "we implement @xmath159 as an incremental split - find data structure  @xcite .",
    "insertion of a new block label into @xmath159 takes @xmath32 amortized time ; we can also find the block @xmath156 for any block @xmath155 in @xmath32 worst - case time .",
    "using the data structure @xmath160 for a block @xmath157 , we can identify for any element @xmath35 in a block @xmath157 the largest @xmath161 , @xmath162 , such that @xmath163 belongs to @xmath158 .",
    "thus we can identify for any @xmath164 the largest element @xmath165 , such that @xmath161 and @xmath166 , in @xmath32 time .",
    "* navigation in nodes of the base tree .",
    "* finally , we store pointers to selected elements in each list @xmath125 .",
    "pointers enable us to navigate between nodes of the base tree : if the position of some @xmath164 is known , we can find the position of @xmath35 in @xmath167 for the parent @xmath109 of @xmath31 and the position of @xmath35 in @xmath168 for any child @xmath47 of @xmath31 such that @xmath168 contains @xmath35 .",
    "we associate a _ stamp _",
    "@xmath169 with each element stored in a block @xmath130 ; every stamp is a positive integer bounded by @xmath170 .",
    "a pointer to an element @xmath35 in a block @xmath130 consists of the block label @xmath131 and the stamp of @xmath35 in @xmath130 .",
    "when an element is inserted into a block , stamps of other elements in this block do not change .",
    "therefore , when a new interval is inserted into a block @xmath130 we do not have to update all pointers that point into @xmath130 .",
    "furthermore , we store a data structure @xmath171 for each block @xmath130 . using @xmath171",
    ", we can find the position of an element @xmath35 in @xmath130 if its stamp @xmath169 in @xmath130 is known .",
    "if an element @xmath35 must be inserted into @xmath130 after an element @xmath172 , then we can assign a stamp @xmath173 to @xmath35 and insert it into @xmath171 in @xmath32 time .",
    "implementation of @xmath171 is very similar to the implementation of @xmath146 and will be described in the full version .",
    "if @xmath35 is the first element in the block @xmath130 of @xmath125 that belongs to @xmath168 , then we store the pointer from the copy of @xmath35 in @xmath125 to the copy of @xmath35 in @xmath168 .",
    "if an element @xmath164 is also stored in @xmath168 and @xmath35 is the first element in a block @xmath174 of @xmath168 , then there is a pointer from the copy of @xmath35 in @xmath125 to the copy of @xmath35 in @xmath168 .",
    "such pointers will be called child pointers . for any pointer from @xmath164 to @xmath175",
    ", we store a pointer from @xmath175 to @xmath164 .",
    "such pointers will be called parent pointers .",
    "see fig .",
    "[ fig : pointers ] for an example .    we can store each pointer in @xmath1 bits .",
    "the total number of pointers in @xmath125 equals to the number of blocks in @xmath125 and @xmath168 for all children @xmath47 of @xmath31 .",
    "hence , all pointers and all block data structures use @xmath33 bits .",
    "if we know the position of some interval @xmath8 in @xmath176 , we can find the position of @xmath8 in the parent @xmath109 of @xmath119 as follows .",
    "suppose that an interval @xmath8 is stored in the block @xmath130 of @xmath176 and @xmath119 is the @xmath76-th child of @xmath109 .",
    "we find the last interval @xmath177 in @xmath130 stored before @xmath8 , such that there is a parent pointer from @xmath177 .",
    "let @xmath178 denote the number of elements between @xmath177 and @xmath8 in @xmath130 .",
    "let @xmath174 be the block in @xmath167 that contains @xmath177 .",
    "using @xmath179 , we find the position @xmath180 of @xmath177 in the block @xmath174 of @xmath167 .",
    "then the position of @xmath8 in @xmath174 can be found by answering the query @xmath181 to a data structure @xmath182 . using a symmetric procedure",
    ", we can find the position of @xmath8 in @xmath176 if its position in @xmath167 is known .",
    "* root and leaves of the base tree .",
    "* elements of @xmath183 are explicitly stored in the root node @xmath81 .",
    "that is , we store a table in the root node @xmath81 that enables us to find for any interval @xmath8 the block @xmath130 that contains the identifier of @xmath8 in @xmath184 and the stamp of @xmath8 in @xmath130 .",
    "conversely , if the position of @xmath8 in a block @xmath130 of @xmath184 is known , we can find its stamp in @xmath130 in @xmath32 time .",
    "if the block label and the stamp of an interval @xmath8 are known , we can identify @xmath8 in @xmath32 time .",
    "in the same way , we explicitly store the elements of @xmath185 for each leaf node @xmath43 . moreover , we store all elements of @xmath183 in a data structure @xmath186 , so that the predecessor and the successor of any value @xmath187 can be found in @xmath0 time .    * data structures @xmath73 and @xmath64 . *",
    "each set @xmath45 and data structure @xmath64 are also stored in compact form .",
    "@xmath64 consists of structures @xmath70 for every pair @xmath68 .",
    "if a block @xmath130 contains a label of an interval @xmath188 , then we store the label of @xmath130 in the veb data structure @xmath70 .",
    "the data structure @xmath189 contains data about intervals in @xmath190 . for every @xmath191 , we store indices @xmath192 if @xmath188 ; if an element @xmath193 does not belong to @xmath36 ( i.e. , @xmath8 was already deleted )",
    ", then we set @xmath194 . for a query index @xmath76 ,",
    "@xmath189 returns in @xmath32 time the highest priority interval @xmath193 , such that @xmath188 and @xmath92 .",
    "a data structure @xmath189 uses @xmath195 bits of space and supports updates in @xmath32 time .",
    "implementation of @xmath189 is very similar to the implementation of @xmath146 and will be described in the full version of this paper .",
    "we store a data structure @xmath73 in every node @xmath108 , such that @xmath125 consists of at least two blocks . for each pair",
    "@xmath68 , the data structure @xmath73 stores the label of the block that contains the highest priority interval in @xmath69 . for a query @xmath76",
    ", @xmath73 returns the label of the block that contains the highest priority interval in @xmath196 .",
    "such queries are supported in @xmath32 time ; a more detailed description of the data structure @xmath73 will be given in appendix a.    * search procedure .",
    "* we can easily modify the search procedure of section  [ sec : stabover ] for the case when only lists @xmath125 are stored in each node .",
    "let @xmath86 be a node on the path @xmath197 , where @xmath78 is the search path for the query point @xmath10 .",
    "let @xmath82 denote the interval that has the highest priority among all intervals that belong to @xmath198 and are stabbed by @xmath10 .",
    "we can examine all intervals in @xmath85 and find @xmath84 in @xmath40 time .",
    "the position of @xmath84 in @xmath199 can also be found in @xmath32 time . during the @xmath149-th step , @xmath200",
    ", we find the position of @xmath82 in @xmath201 .",
    "an interval @xmath8 in @xmath88 is stabbed by @xmath10 if and only if @xmath104 , @xmath92 , and @xmath93 is the @xmath76-th child of @xmath86 .",
    "using @xmath94 , we can find the block label of the maximal interval @xmath95 among all intervals stored in @xmath91 for @xmath92 .",
    "let @xmath202 be the block that contains @xmath95 . using the data structure @xmath203",
    ", we can find the position of @xmath95 in @xmath202 .    by definition , @xmath97 .",
    "although we have no access to @xmath95 and @xmath87 , we can compare their priorities by comparing positions of @xmath95 and @xmath87 in @xmath201 .",
    "since the position of @xmath87 in @xmath204 is already known , we can find its position in @xmath201 in @xmath32 time .",
    "we can also determine , whether @xmath95 precedes or follows @xmath87 in @xmath201 in @xmath32 time .",
    "since a query to @xmath94 also takes @xmath32 time , our search procedure spends constant time in each node @xmath86 for @xmath200 . when we know the position of @xmath205 in @xmath184 , we can find the interval @xmath205 in @xmath32 time .",
    "the interval @xmath205 is the highest priority interval in @xmath36 that is stabbed by @xmath10 .",
    "hence , a query can be answered in @xmath2 time .",
    "we describe how our data structure can be updated in section  [ sec : rebal ] .",
    "our result is summed up in the following theorem .",
    "[ theor:1d ] there exists a linear space data structure that answers orthogonal stabbing - max queries in @xmath2 time .",
    "this data structure supports insertions and deletions in @xmath1 and @xmath2 amortized time respectively .",
    "suppose that an interval @xmath8 is inserted into @xmath36 .",
    "the insertion procedure consists of two parts .",
    "first , we insert @xmath8 into lists @xmath201 and update @xmath201 for all relevant nodes @xmath86 of @xmath37",
    ". then , we insert @xmath8 into data structures @xmath101 and @xmath94 .    using the data structure @xmath186",
    ", we can identify the segment @xmath206 that precedes @xmath8 in @xmath183 .",
    "then , we find the position of @xmath206 in @xmath184 .",
    "we also find the leaves @xmath207 and @xmath208 of @xmath37 , in which the left and the right endpoints of @xmath8 must be stored .    the path @xmath209 is traversed starting at the root node .",
    "let @xmath210 be the segment that precedes @xmath8 in @xmath201 and let @xmath211 be the block that contains @xmath210 . in every node @xmath86 , we insert the identifier for @xmath8 after @xmath210 .",
    "we also update data structures @xmath212 and @xmath213 for the block @xmath211 that contains @xmath8 .",
    "if the number of intervals in @xmath211 equals @xmath214 , we split the block @xmath211 into two blocks @xmath215 and @xmath216 of equal size .",
    "we assign a new label to @xmath216 and update the labels for some blocks of @xmath201 in @xmath217 time .",
    "we also may have to update @xmath40 split - find data structures @xmath218 .",
    "besides that , @xmath32 child pointers in the parent of @xmath86 and @xmath40 parent pointers in the children of @xmath86 may also be updated .",
    "we split the block after @xmath219 insertions ; hence , an amortized cost of splitting a block is @xmath32 .",
    "when @xmath8 is inserted into @xmath201 , we find the largest element @xmath220 , such that @xmath221 is also stored in @xmath204 . then , we find the position of @xmath221 in @xmath204 and proceed in the node @xmath93 .",
    "let @xmath222 be the lowest common ancestor of @xmath207 and @xmath208 , and let @xmath223 be the path from @xmath222 to @xmath208 .",
    "we also insert @xmath8 into @xmath224 for all @xmath225 ; nodes @xmath225 are processed in the same way as nodes @xmath226    during the second stage , we update data structures @xmath101 and @xmath94 for @xmath227 . for any such @xmath86 we already know the block @xmath228 that contains @xmath8 and the position of @xmath8 in @xmath130 .",
    "hence , a data structure @xmath189 can be updated in @xmath32 time",
    ". if @xmath8 is the only interval in @xmath130 that belongs to @xmath91 for some @xmath99 , @xmath100 , we insert @xmath131 into @xmath229 .",
    "if @xmath131 is the greatest label in @xmath229 , we also update @xmath94 .",
    "an insertion into a data structure @xmath229 , @xmath230 , takes @xmath34 time .",
    "updates of all other structures in @xmath86 take @xmath32 time .",
    "hence , an insertion takes @xmath1 time in total .",
    "when an interval is deleted , we identify its position in every relevant node @xmath86 .",
    "this can be done in the same way as during the first stage of the insertion procedure .",
    "then , we update the data structures @xmath101 , @xmath94 , and @xmath231 if necessary . since a block label can be removed from @xmath229 in @xmath32 time , the total time necessary to delete an interval is @xmath0 .    *",
    "re - balancing of the tree nodes . *",
    "it remains to show how the tree can be rebalanced after updates , so that the height of @xmath37 remains @xmath0 .",
    "we implement the base tree @xmath37 as a weight - balanced b - tree  @xcite with branching parameter @xmath232 and leaf parameter @xmath232 for @xmath233 .",
    "we assume that the constant @xmath234 .    when a segment @xmath8 is deleted , we simply mark it as deleted .",
    "after @xmath235 deletions , we re - build the base tree and all data structures stored in the nodes . this can be done in @xmath122 time .",
    "now we show how insertions can be handled .",
    "we denote by the weight of @xmath31 the total number of elements in the leaf descendants of @xmath31 .",
    "the weight @xmath236 of @xmath31 also equals to the number of segment identifiers in @xmath125 .",
    "our weight - balanced b - tree is organized in such way that @xmath237 , where @xmath238 and @xmath239 is the level of a node @xmath31 .",
    "a node is split after @xmath240 insertions ; when a node @xmath31 is split into @xmath241 and @xmath242 , the ranges of the other nodes in the base tree do not change ; see  @xcite for a detailed description of node splitting .",
    "we will show that all relevant data structures can be re - built in @xmath243 time .",
    "hence , the amortized cost of splitting a node is @xmath32 .",
    "when a segment is inserted , it is inserted into @xmath2 nodes of the base tree .",
    "hence , the total amortized cost of all splitting operations caused by inserting a segment @xmath8 into our data structure is @xmath2 .",
    "it remains to show how secondary data structures are updated when a node @xmath31 is split .",
    "let @xmath109 be the parent of @xmath31 .",
    "the total number of segments in @xmath244 and @xmath245 does not exceed @xmath246 .",
    "hence , we can construct data structures @xmath247 , @xmath248 and lists @xmath249 , @xmath250 with all block data structures in @xmath251 time .",
    "we can find the positions of all elements @xmath252 in @xmath167 , update their identifiers in @xmath167 , and update all auxiliary data structures in @xmath243 time .    [",
    "cols=\"^,^,^ \" , ]     some of the intervals stored in @xmath45 can be moved from @xmath45 to @xmath57 : if an interval @xmath253 does not cover @xmath42 but covers @xmath254 or @xmath255 , then @xmath8 must be stored in @xmath57 after splitting .",
    "see fig .",
    "[ fig : split ] for an example .",
    "the total number of elements in @xmath167 is @xmath256 ; hence , the total number of blocks in @xmath167 is @xmath257 .",
    "identifiers of all segments in @xmath45 are already stored in @xmath167 .",
    "we can update all block data structures in @xmath32 time per segment .",
    "every update of the data structure @xmath258 takes @xmath123 time .",
    "but the total number of insertions into @xmath258 does not exceed the number of blocks in @xmath258 .",
    "therefore the total time needed to update @xmath258 is @xmath259 .",
    "suppose that @xmath31 was the @xmath260-th child of @xmath109 .",
    "some segments stored in @xmath261 for @xmath262 can be moved to @xmath263 , and some segments in @xmath264 for @xmath265 can be moved to @xmath266 .",
    "since the total number of blocks in @xmath167 is @xmath267 , all updates of data structures @xmath268 take @xmath269 time . at most @xmath236 segments",
    "were stored in @xmath261 and @xmath264 before the split of @xmath31 .",
    "hence , we can update all block data structures in @xmath243 time .    finally , we must change the identifiers of segments stored in @xmath167 and data structures @xmath189 . recall that an identifier indicates in which children of @xmath109 a segment @xmath8 is stored .",
    "suppose that a segment @xmath8 had an identifier @xmath265 in @xmath167 .",
    "then its identifier will be changed to @xmath270 after the split of @xmath31 .",
    "the total number of segments with incremented identifiers does not exceed @xmath271 .",
    "however , each identifier is stored in @xmath34 bits .",
    "we can use this fact , and increment the values of @xmath272 identifiers in @xmath32 time using the following look - up table @xmath273 .",
    "there are @xmath274 different sequences of @xmath272 identifiers . for every such sequence @xmath55 and any @xmath275 , @xmath276[j]=\\alpha'$ ] . here",
    "@xmath277 is the sequence that we obtain if every @xmath278 in the sequence @xmath55 is replaced with @xmath279 .",
    "thus the list @xmath167 can be updated in @xmath280 time . using the same approach , we can also update data structures @xmath146 and @xmath189 for each block @xmath130 in @xmath281 time . hence , the total time necessary to update all data structures in @xmath109 because some identifiers must be incremented is @xmath243 .    since all data structures can be updated in @xmath243 time when a node @xmath31 is split",
    ", the total amortized cost of an insertion is @xmath1 .",
    "our data structure can be extended to the case of @xmath4-dimensional stabbing - max queries for @xmath11 . in this section",
    "we prove the following theorem .",
    "[ theor : multidim ] there exists a data structure that uses @xmath282 space and answers @xmath4-dimensional stabbing - max queries in @xmath28 time . insertions and deletions are supported in @xmath283 and @xmath284 amortized time respectively .",
    "let @xmath285-stabbing problem denote the @xmath286-dimensional stabbing - max problem for the case when the first @xmath4 coordinates can assume arbitrary values and the last @xmath287 coordinates are bounded by @xmath288 , for @xmath289 .",
    "first , we show that the data structure of theorem  [ theor:1d ] can be modified to support @xmath290-stabbing queries for any constant @xmath287 .",
    "then , we will show how arbitrary @xmath4-dimensional queries can be answered . throughout this section",
    "@xmath291 denotes the projection of a rectangle @xmath8 on the @xmath149-th coordinate .",
    "we denote by @xmath292 and @xmath293 the @xmath149-th coordinates of endpoints in a rectangle @xmath8 , so that @xmath294 $ ] .    * a data structure for the @xmath290-stabbing problem . *",
    "the solution of the @xmath290-stabbing problem is very similar to our solution of the one - dimensional problem .",
    "we construct the base tree @xmath37 on the @xmath187-coordinates of all rectangles .",
    "@xmath37 is defined as in section  [ sec : stabover ] , but we assume that @xmath295 .",
    "sets @xmath45 , @xmath69 , and @xmath113 are defined as in sections  [ sec : stabover ] ,  [ sec : compact ] .",
    "we define @xmath296(u)$ ] as the set of rectangles @xmath8 in @xmath69 such that @xmath297 , @xmath298 , @xmath299 , @xmath300 , @xmath298 , @xmath301 .",
    "a rectangle identifier for a rectangle @xmath8 stored in a list @xmath125 consists of one or two tuples with @xmath302 components .",
    "the first component of each tuple is an index @xmath151 , such that @xmath8 belongs to the @xmath151-th child of @xmath31 ; remaining @xmath303 components are the last @xmath287 coordinates of the rectangle endpoints .",
    "the data structure @xmath73 contains the maximum priority rectangle in @xmath304(u)$ ] for each @xmath305 .",
    "@xmath73 can find for any @xmath306 the highest priority rectangle in all @xmath304(u)$ ] , such that @xmath307 , and @xmath308 for @xmath309 .",
    "we can implement @xmath73 as for the one - dimensional data structure .",
    "data structure @xmath64 consists of veb structures @xmath310(u)$ ] .",
    "if a block @xmath130 of @xmath125 contains a rectangle from @xmath304(u)$ ] , then @xmath131 is stored in @xmath310(u)$ ] .",
    "we can answer a query @xmath311 by traversing the search path @xmath312 for @xmath313 in the base tree @xmath37 . as in theorem",
    "[ theor:1d ] , we start at the leaf node @xmath80 and find the maximal rectangle stored in @xmath314 that is stabbed by the query point @xmath10 . the search procedure in nodes @xmath315 is organized in the same way as the search procedure in section  [ sec : compact ] : the rectangle @xmath82 is defined as in section  [ sec : compact ] .",
    "if @xmath93 is the @xmath76-th child of @xmath86 , we answer the query @xmath316 using the data structure @xmath94 .",
    "then we visit the block @xmath202 returned by @xmath94 and find the last rectangle @xmath95 in @xmath202 with an identifier @xmath317 such that @xmath318 for @xmath309 .",
    "finally we compare @xmath95 with the rectangle @xmath87 by comparing their positions in @xmath201 .",
    "thus we can find the position of @xmath82 in @xmath201 .",
    "when we reach the root @xmath81 , @xmath205 is the highest priority segment that is stabbed by @xmath10 .",
    "updates of the list @xmath125 and all auxiliary data structures are implemented as in section  [ sec : rebal ] .    [ lemma:1 g ] there exists a data structure that answers @xmath290-stabbing queries in @xmath0 time and uses @xmath18 space . insertions and deletions are supported in @xmath1 and @xmath2 amortized time respectively .",
    "= 1500 * a data structure for the @xmath285-stabbing problem . *",
    "the result for @xmath290-stabbing can be extended to @xmath285-stabbing queries using the following lemma .",
    "[ lemma : dg ] suppose that there is a @xmath319 space data structure @xmath320 that answers @xmath321-stabbing queries in @xmath322 time ; @xmath320 supports insertions and deletions in @xmath323 and @xmath324 amortized time respectively . +",
    "then there exists a @xmath325 space data structure @xmath326 that answers @xmath285-stabbing queries in @xmath327 time ; @xmath326 supports insertions and deletions in amortized time @xmath328 and @xmath329 respectively .    the main idea is to construct the base tree @xmath37 on the @xmath4-th coordinates of rectangles and store a data structure for @xmath321-stabbing queries in each tree node .",
    "the tree is organized as in section  [ sec : stabover ] and the first part of this section .",
    "let @xmath330 denote the @xmath4-th coordinate of a point .",
    "leaves contain @xmath4-th coordinates of rectangle endpoints .",
    "a rectangle @xmath8 is stored in a set @xmath45 for a leaf @xmath31 if @xmath331 and @xmath332 .",
    "a rectangle @xmath8 is stored in a set @xmath45 for an internal node @xmath31 if @xmath333 and @xmath334 for at least one child @xmath47 of @xmath31 .",
    "@xmath50 is the set of all intervals @xmath51 such that @xmath335 for a child @xmath53 of @xmath31 if and only if @xmath54 .",
    "we store a data structure @xmath336 for @xmath321-stabbing queries in each internal node @xmath31 . for a rectangle @xmath188",
    ", @xmath336 contains a rectangle @xmath177 such that @xmath337 for @xmath338 and @xmath339 $ ] . in other words ,",
    "we replace the @xmath4-th coordinates of @xmath8 s endpoints with @xmath99 and @xmath100 .",
    "a query @xmath10 is answered by traversing the search path for @xmath10 . for a leaf node @xmath80",
    ", we examine all rectangles in @xmath85 and find the highest priority rectangle in @xmath85 . in an internal node @xmath86 , @xmath200",
    ", we answer the query @xmath340 using the data structure @xmath341 .",
    "the query @xmath342 is obtained from @xmath10 by replacing the @xmath4-th coordinate with an index @xmath76 , such that @xmath93 is the @xmath76-th child of @xmath86 .",
    "when a node @xmath86 is visited , our procedure finds the highest priority rectangle @xmath82 that is stored in @xmath88 and is stabbed by @xmath10 .",
    "all rectangles that are stabbed by @xmath10 are stored in some @xmath88 .",
    "hence , the highest priority rectangle stabbed by @xmath10 is the maximum rectangle among all @xmath82 . since our procedure spends @xmath343 time in each node , the total query time is @xmath28 .    when a rectangle @xmath8 is inserted or deleted , we update @xmath0 data structures @xmath336 in which @xmath8 is stored .",
    "hence , deletions and insertions are supported in @xmath28 and @xmath344 time respectively .",
    "we can re - balance the base tree using a procedure that is similar to the procedure described in section  [ sec : rebal ] .",
    "* proof of theorem  [ theor : multidim ] .",
    "* theorem  [ theor : multidim ] follows easily from lemmas  [ lemma:1 g ] and  [ lemma : dg ] . by lemma  [ lemma:1 g ]",
    ", there exists a linear space data structure that answers @xmath345-stabbing queries in @xmath0 time .",
    "we obtain the main result for @xmath4-dimensional stabbing - max queries by applying the result of lemma  [ lemma : dg ] to the data structure for @xmath345-stabbing queries .",
    "we can also modify our data structure so that it supports stabbing - sum queries : count the number of intervals stabbed by a query point @xmath10 .",
    "[ theor : sum1d ] there exists a linear space data structure that answers orthogonal stabbing - sum queries in @xmath2 time .",
    "this data structure supports insertions and deletions in @xmath1 and @xmath2 amortized time respectively .",
    "the only difference with the proof of theorem  [ theor:1d ] is that we store data structures for counting intervals instead of @xmath73 .",
    "we maintain a data structure @xmath346 in each internal node @xmath31 .",
    "for a query index @xmath76 , @xmath346 reports in @xmath32 time the total number of intervals in @xmath196 . in every leaf node @xmath43",
    ", we maintain a data structure @xmath347 that supports stabbing sum queries on @xmath44 and updates in @xmath34 time .",
    "as above , let @xmath348 denote the search path for a query point @xmath10 . in every node @xmath349 , @xmath200 , we count the number @xmath350 of intervals in @xmath196 using @xmath351 ; the index @xmath76 is chosen so that @xmath93 is the @xmath76-th child of @xmath86 .",
    "we also compute the number @xmath352 of intervals that belong to @xmath85 and are stabbed by @xmath10 using @xmath353 .",
    "an interval @xmath8 is stabbed by @xmath10 either if @xmath8 is stored in @xmath88 , @xmath200 , and @xmath89 or if @xmath8 is stored in @xmath85 and @xmath8 is stabbed by @xmath10 .",
    "hence , @xmath10 stabs @xmath354 intervals .",
    "each @xmath350 , @xmath200 , can be found in @xmath32 time and @xmath352 can be found in @xmath123 time .",
    "hence , a query can be answered in @xmath0 time .",
    "now we turn to the description of the data structure @xmath346 .",
    "following the idea of  @xcite , we store information about the recent updates in a word @xmath130 ; the array @xmath355 reflects the state of the structure before recent updates .",
    "@xmath355 is a static array that is re - built after @xmath356 updates of @xmath346 .",
    "when we construct @xmath355 , we set @xmath357=\\sum_{l\\leq f\\leq r } |s_{lr}(u)|$ ] .",
    "the word @xmath130 contains one integer value @xmath358 for each pair @xmath68 ( @xmath358 can also be negative , but the absolute value of each @xmath358 is bounded by @xmath40 ) . when a segment is inserted into ( deleted from ) @xmath69 , we increment ( decrement ) the value of @xmath358 by @xmath359 .",
    "we can find @xmath360 in @xmath32 time using a look - up table .",
    "after @xmath361 updates we rebuild the array @xmath355 and set all @xmath362 .",
    "the amortized cost of rebuilding @xmath355 is @xmath32 .",
    "the total number of segments in @xmath196 equals to @xmath357+\\sum_{l\\leq f\\leq r } m(l , r)$ ] .",
    "hence , a query to @xmath346 is answered in @xmath32 time .",
    "we implement @xmath355 in such way that each entry @xmath363 $ ] uses @xmath364 bits .",
    "thus each data structure @xmath346 uses @xmath365 bits and all @xmath346 , @xmath366 , use @xmath33 bits in total .",
    "it remains to describe the data structure @xmath367 .",
    "let @xmath368 be the set that contains endpoints of all intervals in @xmath45 . since @xmath31 is a leaf node",
    ", @xmath45 contains @xmath369 elements .",
    "hence , it takes @xmath123 time to find the rank @xmath370 of @xmath10 in @xmath368 . for each @xmath371 ,",
    "@xmath372 $ ] equals to the number of intervals that are stabbed by a point @xmath10 with rank @xmath373 .",
    "the array @xmath374 enables us to count intervals stabbed by @xmath10 in @xmath32 time if the rank of @xmath10 in @xmath368 is known . since @xmath375 and @xmath372=o(\\log^{{\\varepsilon } } n)$ ] , the array @xmath374 uses @xmath376 bits of memory .",
    "when a set @xmath45 is updated , we can update @xmath374 in @xmath32 time using a look - up table .",
    "thus @xmath367 uses linear space and supports both queries and updates in @xmath34 time .",
    "99 p. k. agarwal , l. arge , j. yang , and k. yi , _",
    "i / o efficient structures for orthogonal range max and stabbing max queries _ , proc .",
    "esa 2003 , 7 - 18 .",
    "p. k. agarwal , l. arge , k. yi , _ an optimal dynamic interval stabbing - max data structure ?",
    "soda 2005 , 803 - 812 .",
    "s. alstrup , t. husfeldt , t rauhe , _ marked ancestor problems _ , proc .",
    "focs 1998 , 534 - 544 .",
    "l. arge , j. s. vitter , _ optimal external memory interval management _ , siam j. comput .",
    "32(6 ) , 1488 - 1508 ( 2003 ) .",
    "g. e. blelloch , _ space - efficient dynamic orthogonal point location , segment intersection , and range reporting _",
    "soda 2008 , 894 - 903 .",
    "b. chazelle , _ a functional approach to data structures and its use in multidimensional searching _ , siam j. on computing , 17 , 427 - 462 ( 1988 ) .",
    "h. edelsbrunner , _ a new approach to rectangle intersections _",
    ", part i , int .",
    "j. computer mathematics , 13 , 209 - 219 ( 1983 ) .",
    "p. van emde boas , r. kaas , e. zijlstra , _ design and implementation of an efficient priority queue _ , mathematical systems theory 10 , 99 - 127 ( 1977 ) .",
    "p. gupta and n. mckeown .",
    "_ dynamic algorithms with worst - case performance for packet classification _ , proc .",
    "ifip networking 2000 , 528- 539 .",
    "p. gupta and n. mckeown .",
    "_ algorithms for packet classification _ , ieee network , 15(2 ) , 24 - 32 ( 2001 ) .",
    "a. feldmann , s. muthukrishnan , _",
    "tradeoffs for packet classification _ , proc .",
    "infocom 2000 , 1193 - 1202 .",
    "m. l. fredman , d. e. willard , _ trans - dichotomous algorithms for minimum spanning trees and shortest paths _ , j. comput .",
    "48(3 ) , 533 - 551 ( 1994 ) . h. imai and t. asano , _ dynamic orthogonal segment intersection search _ , journal of algorithms 8(1 ) , 1 - 18 ( 1987 ) .",
    "a. itai , a. g. konheim , m. rodeh , _ a sparse table implementation of priority queues _ ,",
    "8th icalp 1981,417 - 431 .",
    "h. kaplan , e. molad , r.  e. tarjan , _ dynamic rectangular intersection with priorities _ , proc .",
    "stoc 2003 , 639 - 648 .",
    "y. nekrich , _ orthogonal range searching in linear and almost - linear space _ ,",
    "42(4 ) , 342 - 351 ( 2009 ) .",
    "m. ptracu , e. d. demaine , _ tight bounds for the partial - sums problem _ , proc .",
    "15th soda 2004 , 20 - 29 .",
    "s. sahni and k. kim ,",
    "_ @xmath1 dynamic packet routing _ ,",
    "ieee symposium on computers and communications 2002 , 443 - 448 .",
    "s. sahni , k. kim , and h. lu .",
    "_ data structures for one - dimensional packet classification using most specific rule matching _ , proc .",
    "ispan 2002 , 3 - 14 .",
    "r. e. tarjan , _ a class of algorithms which require nonlinear time to maintain disjoint sets _ , j. comput .",
    "18(2 ) , 110 - 127 ( 1979 ) .",
    "m. thorup , _ undirected single - source shortest paths with positive integer weights in linear time _ , j. acm 46(3 ) , 362 - 394 ( 1999 ) .",
    "m. thorup , _ space efficient dynamic stabbing with fast queries _",
    "stoc 2003 , 649 - 658 .",
    "d. e. willard , _ a density control algorithm for doing insertions and deletions in a sequentially ordered file in good worst - case time _ ,",
    "information and computation 97 , 150 - 204 ( 1992 ) .",
    "j. yang , j. widom , _ incremental computation and maintenance of temporal aggregates _",
    "ieee intl .",
    "conf . on data engineering 2001 , 51 - 60 .",
    "using bitwise operations and table look - ups , we can implement the data structure @xmath73 and the block data structures so that queries are supported in constant time .",
    "* data structure @xmath73 .",
    "* let @xmath377 be the set of all interval priorities stored in @xmath73 . recall that @xmath377 contains an element @xmath77 for each set @xmath50 , where @xmath77 is the highest priority interval ( or its block label ) stored in @xmath50 . for simplicity",
    ", we assume that @xmath378 if @xmath379 .",
    "let the rank of @xmath187 in @xmath377 be defined as @xmath380 .",
    "let @xmath381 be the set in which every element of @xmath377 is replaced with its rank in @xmath377 .",
    "that is , for each @xmath77 stored in @xmath377 we store @xmath382 in the set @xmath381 .",
    "each of @xmath383 elements in @xmath381 is bounded by @xmath383 .",
    "hence , we can store @xmath381 in one bit sequence @xmath384 ; @xmath384 consists of @xmath385 bits and fits into a machine word . we can store a table @xmath386 with an entry for each possible value of @xmath384 and for each @xmath76 .",
    "the entry @xmath387[f]$ ] contains the pair @xmath388 , such that @xmath389 is the highest value in the set @xmath390 .      when @xmath73 is updated , the value of some @xmath77 is changed .",
    "we store all elements of @xmath377 in an atomic heap  @xcite that supports predecessor queries and updates in @xmath32 time .",
    "hence , the new rank of @xmath77 in @xmath377 can be found in @xmath32 time .",
    "if the rank of @xmath77 has changed , the ranks of all other elements in @xmath377 also change .",
    "fortunately , @xmath396 can assume only @xmath383 values .",
    "there are @xmath383 elements @xmath396 in a set @xmath381 , and there are @xmath397 different sets @xmath381 .",
    "besides that , each @xmath394 fits into one word .",
    "hence , we can update the set @xmath381 using a look - up in a table @xmath386 .",
    "suppose that the rank of the @xmath76-th element in a set @xmath381 is changed to @xmath100 .",
    "then the new set @xmath381 is stored in an entry @xmath398[f][r]$ ] of @xmath386 ; here @xmath384 is the bit sequence that corresponds to the old set @xmath381 .",
    "thus an update of @xmath73 can be implemented in @xmath32 time .",
    "* data structure @xmath146 . * the data structure @xmath146 for a block @xmath401",
    "is implemented as a b - tree @xmath402 .",
    "every leaf of @xmath402 contains @xmath403 identifiers and each internal node has degree @xmath403 for @xmath404 .",
    "recall that each identifier consists of at most two indices @xmath405 , @xmath406 such that the corresponding interval is stored in the @xmath405-th and @xmath406-th children of the node @xmath31 in the base tree .",
    "all identifiers stored in a leaf node can be packed into @xmath407 bits . in every internal node @xmath408 of @xmath402",
    ", we store the bit sequence @xmath409 . for every child @xmath410 and for every possible value of @xmath151",
    ", @xmath409 contains the total number of indices @xmath151 in the @xmath149-th child @xmath410 of @xmath408 ; @xmath409 consists of @xmath411 bits . using a look - up table",
    ", we can count for any @xmath409 and for any @xmath149 the total number of elements stored in the children @xmath412 of @xmath408 . for any @xmath409 and @xmath149",
    ", we can also count the total number of indices @xmath151 in the children @xmath412 of @xmath408 . for any @xmath413 and any @xmath409 , @xmath151 , we can find the largest @xmath149 such that the total number of indices @xmath151 in @xmath414 does not exceed @xmath260 .",
    "look - up tables that support such queries use @xmath400 space and can be initialized in @xmath400 time .",
    "we need only one instance of each table for all blocks @xmath130 and all @xmath146 .",
    "all queries and updates of a data structure @xmath146 can be processed by traversing a path in @xmath402 . using the above described look - up - tables",
    ", we spend only constant time in each node of @xmath402 ; hence , queries and updates are supported in @xmath32 time .",
    "details will be given in the full version of this paper .",
    "data structures @xmath189 and @xmath171 can be implemented in a similar way ."
  ],
  "abstract_text": [
    "<S> in this paper we describe a dynamic data structure that answers one - dimensional stabbing - max queries in optimal @xmath0 time . </S>",
    "<S> our data structure uses linear space and supports insertions and deletions in @xmath1 and @xmath2 amortized time respectively .    </S>",
    "<S> we also describe a @xmath3 space data structure that answers @xmath4-dimensional stabbing - max queries in @xmath5 time . </S>",
    "<S> insertions and deletions are supported in @xmath6 and @xmath7 amortized time respectively . </S>"
  ]
}