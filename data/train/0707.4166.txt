{
  "article_text": [
    "`` _ metaphor is an invitation to see the world anew .... metaphor transfers meaning from one domain into another and thereby enriches and enhances both domains . _ ''",
    "@xcite    the design theorist donald schn wrote extensively on the role of metaphor in design .",
    "one of his most famous ideas is that of _ generative metaphor _",
    "@xcite , which describes a frame or perspective carried over from one domain to another to produce new insights .",
    "a consciously embraced metaphor can be enabling , but an unacknowledged ( tacit ) metaphor can cast a ` spell ' over problem solvers , restricting their ability to see problems objectively .    consciously or not ,",
    "in software engineering we inevitably find ourselves invested in generative metaphors .",
    "particularly prominent is mcilroy s fecund metaphor of `` mass - produced software components , '' which spawned multiple generations of research on software factories , software product lines , software assembly lines , software robots , and so forth . in this paper",
    "we explore the three generative metaphors for software components :    1 .",
    "software as communication ; 2 .",
    "component design as statistical model - fitting ; 3 .",
    "software abstractions as computable functions .",
    "* software as communication . *",
    "a fruitful viewpoint for understanding the role of abstractions in design is that of software as a communication system .",
    "the subject of the communication is _ program behaviors _ , as encoded in a programming language .",
    "communication systems are a primary object of study in the field of information theory , and so information theory can rightly be expected to have much to say about abstractions and their role in design .",
    "efficient communication can be achieved by identifying frequently - occurring patterns or motifs in messages .",
    "messages can then be compressed on average by assigning shorter codes to motifs . for instance",
    ", in spoken english the term `` automobile carriage '' was supplanted in the 20th century by `` car , '' a more efficient form that reflects its increased use frequency .",
    "these ideas carry over in a straightforward way to software .",
    "good software abstractions capture commonly occurring motifs , and we can represent our programs more concisely ( i.e. , compress them ) by referring to predefined abstractions , rather than describing them anew for each program . abstractions also compress the design process itself , allowing us to discuss and reason about designs in terms of recognizable , high - level chunks .    the suggested correspondence between software design and information theory is summarized by the following table :    [ cols= \" < ,",
    "< \" , ]      the fact that programming languages provide a variety of abstraction mechanisms ( i.e. , metalanguages ) suggests that there is no single best ` universal abstraction mechanism . ' instead we find that metalanguages offer a broad variety of tradeoffs between desirable facets , namely :    * the expressive power of the metalanguage , i.e. , what abstractions are definable in it . * the safety properties we are guaranteed about instances .",
    "for example , an ongoing concern in programming language design is finding metalanguages that can generalize over types in a safe way , e.g. , generics @xcite .",
    "* succinctness , that is , how long the description of an abstraction must be , and how long parameters must be to produce instances of interest . *",
    "the time and space complexity of instantiating an abstraction ( i.e. , how intensive the compilation process must be . ) * the difficulty of finding parameters to an abstraction that will produce a particular instance , i.e. , _ inversion _ of an abstraction . * the effort required to devise an appropriate abstraction , given an instance or class of instances over which we wish to generalize .    in previous work we used tools from computability theory and the theory of subrecursive languages to study tradeoffs between succinctness ( code length ) and safety properties @xcite .    in the present work",
    "we examine tradeoffs between the expressive power of abstractions , the amount of ` compression ' they allow , and the cognitive effort required to use them .      in designing a compression algorithm ,",
    "one is is interested in the tradeoff between the degree of compression achieved and the computational cost of compression and decompression . in programming languages , humans",
    "do the compression and compilers do the decompression , so to speak . in designing a programming language , the tradeoff is largely between the succinctness a language offers ( i.e. , amount of compression ) and the cognitive difficulty of recognizing and exploiting motifs ( i.e. , the cost of compression ) .",
    "perhaps not surprisingly , the difficulty of cognitive tasks we encounter in design appears to correlate with the computational complexity of abstraction mechanisms @xcite .",
    "for instance , a crucial design activity is deciding whether an abstraction can be adapted to a use scenario . to support rapid design work ,",
    "the cognitive task ought to be simple  abstractions that require great deviousness to adapt are unlikely to be used frequently .",
    "the equivalent problem in our formalism is deciding whether there exist parameters for the abstraction function that will cause it to produce a desired output  the problem of _ inverting _ the abstraction function ( not to be confused with inverting a runtime computation , an altogether different problem . )",
    "double hypot(double a , double b ) return a*a + b*b ;    for example , macros and subroutines are forms of abstraction `` instantiated '' by substitution of arguments for variables .",
    "consider the function @xmath0 of figure  [ f : hypot ] .",
    "for the function @xmath0 to be useful , it must be possible for us to recognize places in our design where it might be used , and to determine what parameters will make it do what we want : given the fragment @xmath1 it is easy to see that the term @xmath2 can be replaced by @xmath3 . this can be understood as inverting the substitution process .",
    "the inverse of substitution is unification , which can be performed in almost linear time @xcite .",
    "it seems significant that _",
    "almost all the abstraction mechanisms we find useful in practice lie in low computational complexity classes , and are easy to invert .",
    "_ this suggests that we tend to favor simple , easy - to - reuse design abstractions over more complicated ( but possibly more general ) ones .",
    "thus , for example , method invocations and inheritance , the workhorses of object - oriented programming , both appear easy to invert . on the other hand , arbitrary program generation",
    "( e.g. , as in staged languages @xcite , generative programming @xcite , and template metaprogramming @xcite ) tends to be used sparingly and often in only simple ways .",
    "cognitive tradeoffs in design notations have been summarized by thomas green and colleagues in the popular _ cognitive dimensions of notations _",
    "framework @xcite .",
    "green argues that programming languages are properly regarded as a medium in which we hash out design decisions , not just record them after the fact . human design work",
    " even that of experts  has been shown in numerous studies to be disorderly , characterized by false starts , frequent rewriting , and simultaneous attacks on the problem at many levels of abstraction : `` design is redesign , programming is reprogramming . ''",
    "@xcite . to support the way humans design",
    ", notations must be malleable it must be possible to quickly evolve code to match our changing understanding of the design . in the cognitive dimensions framework this quality is dubbed _ viscosity _ : the resistance of a notation to change .",
    "one way to evaluate the ` viscosity ' of an abstraction mechanism is to analyze how sensitive the input of the abstraction function is to small changes in its desired output . returning to our earlier @xmath4 example ,",
    "consider a small change in the use scenario from @xmath5 to @xmath6 .",
    "this change that requires only a minor change to the parameters : from @xmath3 to @xmath7 .",
    "@xmath8^{\\mathsf{hypot } } \\ar[d]_{d(x , x ' ) } & & y = r*r+f(s)*f(s ) \\ar[d]^{d(y , y')}\\\\ x'=(r , f(s+1 ) ) \\ar[rr]^{\\mathsf{hypot } } & & y'=r*r + f(s+1)*f(s+1 ) } \\end{aligned}\\ ] ]    this can be formalized by examining the relation between tree edit distance @xcite of the inputs and outputs to the abstraction function .",
    "roughly speaking , tree edit distance measures how many `` editing operations '' would be required to transform a term @xmath9 to a term @xmath10 , giving a distance metric @xmath11 on terms .",
    "if making small changes in the instantiated code requires large changes to the parameters , we expect the notation to be `` viscous '' in the sense of green , resisting our efforts to evolve our design .",
    "the cognitive dimensions framework suggests that _ small changes in the instantiation should be realizable by small changes in parameters .",
    "_ this is illustrated in figure  [ f : distance ] .",
    "we can formalize this intuition in terms of lipschitz continuity .",
    "a lipschitz condition on a real function @xmath12 is a requirement of the form @xmath13 its _ lipschitz constant_. the notion generalizes easily to metric spaces : given a metric space @xmath14 , and a function @xmath15 , we can call @xmath16 lipschitz if @xmath17 for some @xmath18 . viewing abstractions as functions from terms to terms , and tree edit distance as the distance metric , we can make the following conjecture :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the ease with which an abstraction can be used in design work is strongly influenced by whether it is lipschitz , and if so , the magnitude of its lipschitz constant .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "again , it seems significant that the abstraction mechanisms we find useful in practice usually satisfy this requirement .",
    "for instance , with substitution ( the abstraction mechanism for subroutines ) , the edit distance between parameters is at most the edit distance between instantiations .",
    "this property does not hold in general for abstraction mechanisms that lie in higher computational complexity classes , so again we return to the observation that useful abstraction mechanisms tend to be computationally very simple .      the formalization of abstraction mechanisms as metalanguages lends itself to understanding tradeoffs between forms of abstraction : between their generality and ease - of - use , between safety properties and succinctness , for example . in engineering",
    "it is common to sketch tradeoff curves between opposing factors to aid in choosing the ` sweet spot ' where a suitable balance is reached .",
    "we can draw such curves for abstractions also , and we believe these curves provide an intuitive tool for understanding tradeoffs .",
    "the tradeoff we are interested in here is that between    1 .   the complexity of the abstractions used ; 2 .",
    "the degree to which programs can be ` compressed ' using those abstractions ; 3 .   the cognitive difficulty of using ( @xmath19 inverting ) abstractions .    intuitively , if we put ` abstraction complexity ' on an @xmath20-axis , we expect that the program length we can obtain decreases as we increase the complexity of our abstractions , and the cognitive difficulty increases .",
    "to draw such tradeoff curves in a meaningful way , we need a few justifications ; it is not immediately clear , for example , how one can put ` abstraction complexity ' on the @xmath20-axis in a meaningful way .",
    "we need a suitable mapping from metalanguages ( e.g. , classes of partial computable functions ) to points on an @xmath20-axis .",
    "if we have a chain of metalanguages of increasing complexity , we can map this chain onto an axis by appealing to the classical result of cantor that every dense total order without endpoints is order - isomorphic to @xmath21 , the rational numbers .",
    "this suggests we can take a set of metalanguages , excise a substructure that is a total order ( possibly dense ) , and embed it in the rationals .",
    "this provides a clean , if somewhat roundabout , explanation for drawing an @xmath20-axis of metalanguages .",
    "this correspondence is not unique , and so the placement of particular elements on the axes is arbitrary ( up to ordering ) ; the observed shape of the graph is meaningful only up to squeezing and stretching of the axes . indeed",
    "even the shape of the curve itself is usually a sketch based on scanty information , and is intended to convey intuition rather than exact information .    to formalize the notion of ` achievable program length , ' we could appeal to either yao - pseudoentropy @xcite or a nonuniform variant of resource - bounded kolmogorov complexity .    to formalize ` cognitive difficulty , ' we assume a correspondence between the time complexity of the inversion problem and its cognitive difficulty .",
    "tradeoffs between abstraction power , component reuse , and difficulty of reusing components . ]",
    "this is all a little vague , and perhaps the analogy is strained .",
    "but such graphs can tell useful stories .",
    "figure  [ f : compress ] illustrates the tradeoff between the complexity of abstractions , their ability to reduce program length , and their ease of use .",
    "the horizontal axis represents _ abstraction complexity _",
    ", here normalized so that @xmath22 represents no power whatsoever , and @xmath23 represents unrestricted power , e.g. , turing - complete program generators .",
    "the left vertical axis shows the expected program size achievable . as abstraction power increases , so does the scope for component reuse , and the expected program size ( thick line , left axis ) decreases , tending to some optimal value greater than @xmath24 , the entropy for the problem domain @xcite ) .",
    "it is possible we can not achieve the maximum possible compression @xmath24 because there might be patterns in programs which are not exploitable in any effective way , leading to what is labeled the `` computability gap '' in figure  [ f : compress ] . to achieve the best possible compression ,",
    "this curve suggests we ought to use a high level of abstraction power , i.e. , arbitrary program generators . on the other hand , as the power of abstractions increases , the difficulty of using them in a given situation ( the complexity of the _ inverse problem _ ) increases rapidly , quickly becoming noncomputable ( dashed line , right axis ) .",
    "thus we have a tradeoff between the power of abstractions to generalize , and the difficulty of adapting them to a particular use scenario .",
    "the dotted line shows a tradeoff curve with a hypothetical ` sweet spot ' that balances the complexity of abstractions against the program length achievable .",
    "this graph illustrates why in practice we tend to use computationally weak forms of abstraction , and use complex forms of abstraction ( e.g. , program generators ) sparingly , even though they might _ in principle _ allow us to achieve much shorter program lengths .",
    "we have proposed using the mdl principle to answer the ` generality problem , ' of how one chooses the right level of generality for a software component . as applied to software components",
    ", the mdl principle suggests that ` the best component yields the most succinct representation of the use cases . ' in forthcoming work we use this approach to retrospectively evaluate the interface design of generic libraries .",
    "the second portion of this paper suggested an approach to understanding the tradeoff in programming language design between the power of abstraction mechanisms , their ability to reduce program length , and the cognitive difficulty of their use .",
    "we observed that almost all the abstraction mechanisms popular in practice lie in low computational complexity classes .",
    "a plausible explanation for this is that such mechanisms are easy to ` invert , ' e.g. , we can readily figure out what parameters to provide a macro to achieve a desired result .",
    "we connected thomas green s notion of _ notational viscosity _ to the theoretical notion of lipschitz continuity , which formalizes the bridge between cognitive difficulty and computational difficulty .",
    "finally , we summarized the tradeoffs in abstraction mechanism design by sketching a curve illustrating the ` sweet spot ' that balances the complexity of abstractions , their cognitive difficulty , and the amount by which they reduce program length .",
    "b.  barak , r.  shaltiel , and a.  wigderson .",
    "computational analogues of entropy . in s.",
    "arora , k.  jansen , j.  d.  p. rolim , and a.  sahai , editors , _ random - approx _ , volume 2764 of _ lecture notes in computer science _ , pages 200215 .",
    "springer , 2003 .",
    "d.  bert , p.  drabik , r.  echahed , o.  declerfayt , b.  demeuse , p .- y .",
    "schobbens , and f.  wautier . : a generic , logic and functional programming language . in h.",
    "ganzinger , editor , _",
    "esop88 , 2nd european symposium on programming _ , volume 300 of _ lecture notes in computer science _ , pages 376377 , nancy , france , 2124  mar .",
    "springer .",
    "a.  f. blackwell , c.  britton , a.  cox , t.  green , c.  gurr , g.  kadoda , m.  s. kutar , m.  loomes , c.  l. nehaniv , m.  petre , c.  roast , c.  roes , a.  wong , and r.  m. young . cognitive dimensions of notations : design tools for cognitive technology . , 2117:325341 , 2001 .",
    "j.  carette .",
    "understanding expression simplification . in _",
    "issac 04 : proceedings of the 2004 international symposium on symbolic and algebraic computation _ , pages 7279 , new york , ny , usa , 2004 .",
    "acm press .",
    "r.  garcia , j.  jarvi , a.  lumsdaine , j.  siek , and j.  willcock .",
    "a comparative study of language support for generic programming . in _ proceedings of the 18th acm sigplan conference on object - oriented programing , systems , languages , and applications _ , pages 115134 .",
    "acm press , 2003 .",
    "p.  n. klein .",
    "computing the edit - distance between unrooted ordered trees . in g.",
    "bilardi , g.  f. italiano , a.  pietracaprina , and g.  pucci , editors , _ proceedings of the 6th annual european symposium on algorithms , esa98 ( venice , italy , august 24 - 26 , 1998 ) _ , volume 1461 of _ lncs _ , pages 91102 .",
    "springer - verlag , berlin , 1998 ."
  ],
  "abstract_text": [
    "<S> software is a communication system . </S>",
    "<S> the usual topic of communication is program behavior , as encoded by programs . </S>",
    "<S> domain - specific libraries are codebooks , domain - specific languages are coding schemes , and so forth . to turn metaphor into method </S>",
    "<S> , we adapt tools from information theory  the study of efficient communication  to probe the efficiency with which languages and libraries let us communicate programs . in previous work we developed an information - theoretic analysis of software reuse in problem domains . </S>",
    "<S> this new paper uses information theory to analyze tradeoffs in the design of components , generators , and metalanguages . </S>",
    "<S> we seek answers to two questions : ( 1 ) how can we judge whether a component is over- or under - generalized ? </S>",
    "<S> drawing on minimum description length principles , we propose that the best component yields the most succinct representation of the use cases . </S>",
    "<S> ( 2 ) if we view a programming language as an assemblage of metalanguages , each providing a complementary style of abstraction , how can these metalanguages aid or hinder us in efficiently describing software ? </S>",
    "<S> we describe a complex triangle of interactions between the power of an abstraction mechanism , the amount of reuse it enables , and the cognitive difficulty of its use . </S>"
  ]
}