{
  "article_text": [
    "the study of repetitions in words is a classical topic in stringology .",
    "a word is called an ( integer ) power if it can be written as the concatenation of two or more copies of another word , like .",
    "however , any word can be written as a _",
    "fractional _ power ; that is , given a word @xmath3 , one can always find a word @xmath4 such that @xmath5 , where @xmath6 is a ( possible empty ) prefix of @xmath4 and @xmath1 is an integer greater than or equal to one . in this case , the length of @xmath4 is called _ a period _ of the word @xmath3 .",
    "a word @xmath3 can have different periods , the least of which is usually called _ the period _ of @xmath3 .",
    "recently , a natural extension of this setting has been considered involving the notion of commutative equivalence .",
    "two words are called commutatively equivalent if they have the same number of occurrences of each letter ; that is , if one is an anagram of the other .",
    "an abelian power ( also called a weak repetition  @xcite ) is a word that can be written as the concatenation of two or more words that are commutatively equivalent , like .",
    "recall that the parikh vector @xmath7 of a word @xmath3 is the vector whose @xmath8th entry is the number of occurrences of the @xmath8th letter of the alphabet in @xmath3 .",
    "for example , given the ( ordered ) alphabet @xmath9 , the parikh vector of the word @xmath10 is @xmath11 .",
    "two words are therefore commutatively equivalent if and only if they have the same parikh vector .",
    "constantinescu and ilie  @xcite introduced the definition of an abelian period with head and tail of a word @xmath3 over a finite ordered alphabet @xmath12 : an integer @xmath13 is an abelian period of @xmath3 if one can write @xmath14 where for @xmath15 all the factors @xmath16 s have the same parikh vector @xmath17 such that @xmath18=p$ ] and the parikh vectors of @xmath19 and @xmath20 are `` contained '' in @xmath17 , in the sense that they are proper sub - parikh vectors of @xmath17 ( see next section for the formal definition of `` contained '' ) . in this case ,",
    "@xmath19 and @xmath20 are called the head and the tail of the abelian period @xmath21 , respectively . this definition of an abelian period matches that of an abelian power when @xmath19 and @xmath20 are both empty and @xmath22 .    as an example , the word @xmath23 over the alphabet @xmath24 can be written as @xmath25 , where @xmath26 , @xmath27 , @xmath28 , @xmath29 , with @xmath30 the empty word , so that @xmath31 is an abelian period of @xmath3 with parikh vector @xmath32 ( the parikh vector of @xmath33 is @xmath34 and that of @xmath35 is @xmath36 which are both `` contained '' in @xmath32 ) .",
    "notice that @xmath3 has also abelian period @xmath37 , since it can be written as @xmath38 , with @xmath39 , @xmath40 , @xmath41 , @xmath42 , @xmath43 .",
    "this example shows that a word can have different abelian periods .",
    "moreover , a word can have the same abelian period @xmath21 corresponding to different factorizations ; that is , with different heads .",
    "actually , a word of length @xmath1 can have @xmath44 many different abelian periods @xcite , if these are represented in the form @xmath45 , where @xmath46 is the length of the head  the length of the tail is uniquely determined by @xmath46 and @xmath21 .",
    "recently  @xcite we described algorithms for computing all the abelian periods of a word of length @xmath1 in time @xmath47 .",
    "this was improved to time @xmath48 in  @xcite . in",
    "@xcite the authors derived an efficient algorithm for computing the abelian periods based on prior computation of the abelian squares .",
    "an abelian period is called _ full _ if both the head and the tail are empty . clearly , a full abelian period is a divisor of the length of the word .",
    "a preliminary version of the present paper appeared in  @xcite where we presented brute force algorithms to compute full abelian periods and abelian periods without head and with tail in @xmath48 time and a quasi - linear time algorithm qlfap for computing all the full abelian periods of a word . in @xcite kociumaka et al .",
    "gave a linear time algorithm lfap for the same problem .",
    "here we first briefly outline lfap , followed by a description of qlfap . then , extending the presentation in  @xcite , we add an experimental section to demonstrate that our algorithm significantly outperforms lfap in practice , both on pseudo - randomly generated and genomic data .",
    "our method has the additional advantage of being conceptually simple and easy to implement .",
    "let @xmath49 be a finite ordered alphabet of cardinality @xmath50 and @xmath51 the set of finite words over @xmath52 .",
    "we let @xmath53 denote the length of the word @xmath3 . given a word @xmath54 $ ] of length @xmath55 , we write @xmath56 $ ] for the @xmath57-th symbol of @xmath3 and , for @xmath58 , we write @xmath59 $ ] for the factor of @xmath3 from the @xmath57-th symbol to the @xmath60-th symbol , both included .",
    "we let @xmath61 denote the number of occurrences of the symbol @xmath62 in the word @xmath3 .",
    "the _ parikh vector _ of @xmath3 , denoted by @xmath7 , counts the occurrences of each letter of @xmath52 in @xmath3 , that is , @xmath63 .",
    "notice that two words have the same parikh vector if and only if one word is a permutation of the other ( in other words , an anagram ) .",
    "given the parikh vector @xmath7 of a word @xmath3 , we let @xmath64 $ ] denote its @xmath8-th component and @xmath65 its norm , defined as the sum of its components . thus , for @xmath66 and @xmath67",
    ", we have @xmath64=|\\s{w}|_{a_i}$ ] and @xmath68=|\\s{w}|$ ] .",
    "finally , given two parikh vectors @xmath69 , we write @xmath70 if @xmath71\\leqslant \\qv[i]$ ] for every @xmath72 and @xmath73 .",
    "this makes precise the notion of `` contained '' used in the introduction .",
    "[ def - ap ] a word @xmath3 has an abelian period @xmath45 if @xmath74 such that :    * @xmath75 , * @xmath76 , @xmath77",
    ".    we call @xmath19 and @xmath20 respectively the _ head _ and the _ tail _ of the abelian period . notice that the length @xmath78 of the tail is uniquely determined by @xmath46 , @xmath21 and @xmath53 , namely @xmath79 .",
    "the following lemma gives a bound on the maximum number of abelian periods of a word .",
    "[ lemma - max ] the maximum number of different abelian periods @xmath45 for a word of length @xmath1 over an alphabet of size @xmath50 is @xmath80 .",
    "the word @xmath81 has abelian period @xmath45 for any @xmath82 and every @xmath46 such that @xmath83 .",
    "an abelian period is called _ full _ if it has head and tail both empty .",
    "we are interested in computing all the full abelian periods of a word .",
    "notice that a full abelian period of a word of length @xmath1 is a divisor of @xmath1 . in the remainder of this note",
    ", we will therefore write that a word @xmath3 has an abelian period @xmath21 if and only if it has full abelian period @xmath84 .",
    "we now outline the linear algorithm lfap given in  @xcite .",
    "let @xmath85 be a word of length @xmath1 .",
    "let @xmath86}$ ] .",
    "two positions @xmath87 are called proportional , which is denoted by @xmath88 , if @xmath89 = c\\times \\pv_{w_j}[k]$ ] for each @xmath90 , where @xmath91 is a real number independent of @xmath90 .",
    "an integer @xmath90 is called a candidate ( as a potential abelian period ) if @xmath92 for each @xmath93 where @xmath94 is the set of multiples of @xmath90 not exceeding @xmath1 , or equivalently @xmath95 .    a positive integer @xmath96 is a full abelian period of @xmath85 if and only if @xmath97 and @xmath98 is a candidate .",
    "the algorithm first computes the set @xmath99 and then the set @xmath100 .",
    "let @xmath101 be the rank in the alphabet of a least frequent letter @xmath102 of @xmath85 .",
    "let @xmath103 be the position of the first occurrence of @xmath102 in @xmath85 .",
    "for @xmath104 let @xmath105 $ ] .",
    "vectors @xmath106 are used in order to deal with vector equality instead of vector proportionality .    if @xmath107 then @xmath108 is equivalent to @xmath109 .",
    "the problem of computing the set @xmath110 reduces to check if @xmath111 is equal to @xmath112 for @xmath113 .",
    "this is done in linear time by using what the authors called a diff - representation of the @xmath106 s ( see  @xcite for details ) .",
    "the authors show that the set @xmath114 can be computed in linear time .",
    "this can be done by showing that after an @xmath2 time preprocessing , the value @xmath115 for any @xmath116 can be computed in constant time ( see  @xcite for details ) .",
    "in this section , we describe our algorithm qlfap for computing all the full abelian periods of a word @xmath3 of length @xmath1 over a constant - size alphabet @xmath117 .    in a linear - time preprocessing phase ,",
    "we compute @xmath118 $ ] for @xmath119 , i.e. , the components of the parikh vector of the word @xmath3 .",
    "let @xmath120 denote the greatest common divisor of the elements of the parikh vector of @xmath3 , computable in @xmath121 time  @xcite .",
    "then we compute @xmath122 .",
    "we can suppose @xmath123 and @xmath124 , otherwise the solution is trivial . in @xmath125 time",
    "we compute a stack @xmath126 of all divisors @xmath127 of @xmath120 in increasing order .",
    "[ obs - poss ] the only possible full abelian periods of @xmath3 are of the form @xmath128 , where @xmath129 is an entry in @xmath126 .",
    "therefore , the smallest possible full abelian period of @xmath3 is @xmath130 .",
    "[ def - scaled ] a factor @xmath4 of a word @xmath3 is if and only if there exists @xmath131 such that @xmath132 , where @xmath133 is the smallest possible abelian period of @xmath3 .",
    "[ obs - scaled ] if @xmath134 and @xmath4 is scaled , then @xmath135 is scaled .",
    "a scaled factor is called _ irreducible _ if it can not itself be factored into scaled factors . according to definition",
    "[ def - scaled ] and observation  [ obs - scaled ] , every word @xmath3 can be factored uniquely into irreducible scaled factors by computing the shortest scaled prefix @xmath4 of @xmath134 and then factoring the suffix @xmath135 recursively , until this suffix is empty .",
    "this factorization is computed by calling procedure computel given in  [ algo - computel ] , which computes the scaled prefixes of @xmath3 ( or analogously , by the previous observation , the scaled suffixes of @xmath3 ) .",
    "it returns a boolean array @xmath136 of length @xmath1 defined by : @xmath137=1 $ ] if and only if @xmath8 is the starting position of a scaled suffix of @xmath3",
    ". it also returns the value @xmath138 such that the longest scaled factor computed is of length @xmath139 .",
    "[ obs - fact ] consider two positions @xmath140 , with @xmath141 , such that @xmath137=l[j]=1 $ ] . then @xmath142 $ ] is scaled .",
    "[ obs - t ] a full abelian period of @xmath85 must be greater than or equal to @xmath139 .",
    "computel , s , g , [ loop - scaled ] [ loop - pv ] [ internalloop ]    the algorithm computel computes the boolean array @xmath136 of a word @xmath3 of length @xmath1 over an alphabet of size @xmath50 in time @xmath2 .",
    "the internal loop in line  [ loop - scaled ] is performed until a scaled factor of length @xmath143 is found : the loop in line  [ loop - pv ] computes the parikh vector of the factor @xmath144 $ ] and the loop in line  [ internalloop ] verifies that this factor is scaled : its length is equal to @xmath143 and it should hold for every letter @xmath145 that @xmath146/(t\\times s)=\\pvw[j]/n$ ] .",
    "this can be rewritten as @xmath146/t=\\pvw[j]/g$ ] since @xmath147 . since , by definition of @xmath120 , @xmath118/g$ ] is an integer the test can be reduced to @xmath148/t \\rfloor=\\pvw[j]/g$ ] since it should hold for every letter .",
    "this avoids to use real numbers .",
    "furthermore the @xmath118/g$ ] are constant for a given @xmath3 and can thus be precomputed .",
    "when such a scaled factor is found , its starting position is @xmath149 and @xmath150 $ ] is set to @xmath151 . since the algorithm starts from position @xmath152 , therefore , according to observation  [ obs - scaled ] , array @xmath136 is filled correctly .",
    "the algorithm visits each position @xmath8 in @xmath3 exactly once , and corresponding to each @xmath8 performs a constant - time processing . the internal loop in line  [ internalloop ] is performed at most @xmath50 times , every @xmath130 positions .",
    "it is performed @xmath153 times and since @xmath154 , each iteration costs @xmath155 time .",
    "thus the algorithm runs in time @xmath156 .",
    "@xmath157 , @xmath158 .",
    "the word @xmath3 is factored into irreducible scaled factors in the following way : @xmath159 . since the length of the longest word in this factorization is @xmath160 and @xmath161 , the value of @xmath138 is @xmath31 .",
    "[ lem - seg ] the word @xmath3 has full abelian period @xmath21 if and only if for every @xmath162 , @xmath163 is the starting position of a scaled suffix of @xmath3 .",
    "suppose that @xmath21 is an abelian period of @xmath3 .",
    "according to observation  [ obs - fact ] , we have that for every @xmath162 the position @xmath163 is the starting position of a scaled factor and then of a scaled suffix of @xmath3 .",
    "conversely , if @xmath163 is the starting position of a scaled suffix of @xmath3 for every @xmath162 , it follows from observation  [ obs - fact ] that @xmath164 $ ] is scaled and consequently that @xmath21 is an abelian period of @xmath3 .",
    "the algorithm , given in  [ alg - arep ] , computes all the full abelian periods of a word @xmath3 .",
    "it first computes the greatest common divisor @xmath120 of the elements of @xmath7 ( line  [ inst1 ] )",
    ". then it computes @xmath133 ( line  [ inst2 ] ) .",
    "this is followed by the computation of the array @xmath136 giving the starting positions of the scaled suffixes and of the threshold @xmath138 ( line  [ inst3 ] ) .",
    "then it computes the stack @xmath126 of all the divisors of @xmath120 greater than or equal to @xmath138 ( line  [ inst4 ] ) .",
    "then it checks for every divisor @xmath129 of @xmath120 in @xmath126 , whether all the multiples of @xmath129 are starting positions of scaled suffixes ( lines  [ inst5][inst6 ] ) .    @xmath157 .",
    "we have @xmath165 , @xmath166=\\pvw[2]=15 $ ] , @xmath167 , @xmath161 , @xmath168 . when @xmath169 , @xmath170 and @xmath171 is not a starting position of a scaled suffix . when @xmath172 , @xmath173 and @xmath160 is not a starting position of a scaled suffix .",
    "when @xmath174 , @xmath175 and @xmath176 , @xmath177 are starting positions of scaled suffixes , hence @xmath176 is a full abelian period of @xmath3 .",
    "the case where @xmath178 is trivial since it corresponds to abelian period @xmath1 .",
    "thus the algorithm returns @xmath179 , which is the set of full abelian periods of @xmath3 .",
    "the algorithm computes all the full abelian periods of a word @xmath3 of length @xmath1 over an alphabet of size @xmath50 in time @xmath0 and space @xmath2 .",
    "the correctness comes from observation  [ obs - poss ] and from lemma  [ lem - seg ] .",
    "the algorithm scans all the multiples of the divisors @xmath180 , whose number is equal to the sum of the divisors of @xmath130 , which in turn is @xmath0  @xcite .",
    "the algorithm requires @xmath2 space for @xmath136 and @xmath126 .",
    "quasilinearfullabelianperiods=[_0_n-1 ] [ inst1 ] [ inst2 ] [ inst3 ] [ inst4 ] [ inst5 ] [ inst6 ]",
    "we implemented both quasilinearfullabelianperiods ( qlfap ) and the algorithm linearfullabelianperiods ( lfap ) of  @xcite in a homogeneous way in ` c ` .",
    "lfap requires seven integer arrays of space @xmath2 to compute the diff - representation plus five more for the preprocessing of the set b ( see sect .",
    "[ sec - prev - work ] for terminology ) . on the other hand , qlfap requires only two integer arrays @xmath136 and @xmath181 of length @xmath1 , together with the parikh vector of length @xmath50 and the stack @xmath126 ( implemented as an integer array of length @xmath120 ) .    in both algorithms ,",
    "the memory space for the different arrays has been allocated one by one .",
    "all the experiments have been performed on a computer with a @xmath182 ghz intel core i5 processor and 4 go 1600 mhz ddr3 ram .      s  [ fig - expe1 ] and  [ fig - expe2 ] plots the raw execution times versus the word length ( in logarithmic scale ) while s  [ fig - ratio1][fig - ratio3 ] shows execution time ratios for lfap over qlfap .",
    "experiments were performed on alphabet sizes @xmath37 , @xmath183 , @xmath176 and @xmath177 , and input words of lengths @xmath184 , @xmath185 ,  , @xmath186 . for each alphabet size and word length , @xmath184 words were randomly generated .    in order to verify the correct execution of both algorithms ,",
    "words have been generated in such a way that they have at least one non trivial abelian period .",
    "both algorithms have been compiled with the same options and run on the same machine under the same conditions .",
    "+     +     +    the plots show that , on the range of tested values , the two algorithms have a linear behaviour .",
    "the results show that our algorithm is significantly faster than linearfullabelianperiods algorithm .",
    "one can also observe that the ratio increases both with word length and with the length of the abelian period ( see  [ fig - ratio3 ] ) .",
    "this may be due to the larger number of arrays needed by the linearfullabelianperiods algorithm .",
    "similar results were obtained with the ` e.coli ` file from the canterbury large corpus ( s  [ fig - expe - ecoli ] and [ fig - ratio - ecoli ] ) .    [ cols=\"<,^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     the source codes of lfap and qlfap algorithms can be found at bioinfo.univ-rouen.fr/qlfap .",
    "in this note we presented an algorithm for computing all the full abelian periods of a word of length @xmath1 in time @xmath0 and space @xmath2 .",
    "we showed that this algorithm is very efficient in practice , even if its theoretical worst - case behavior is superlinear .",
    "our experiments show that it is between 6 to 19 times faster than the linear time algorithm of  @xcite and we can expect that the ratio will be even larger for longer strings .",
    "our method requires less space .",
    "in addition the latter algorithm needs to compare real numbers , which can be tricky in practice , while our method avoids this difficulty .",
    "furthermore , our algorithm is conceptually simple , and stems from the notion of scaled factorization of a word , which could be of some interest in other related problems on abelian combinatorics on words .",
    "a possible direction of further investigation could be that of extending the same approach to the computation of all the abelian periods with empty head but non - empty tail , or even to compute the smallest of such abelian periods .",
    "the authors thank the anonymous reviewers that greatly improved a first version of this paper .",
    "g.  fici , t.  lecroq , a.  lefebvre , e.  prieur - gaston , w.  f. smyth , quasi - linear time computation of the abelian periods of a word , in : j.  holub , j.  zdrek ( eds . ) , prague stringology conference , psc 2012 .",
    "prague , czech republic , august 2728 , 2012 .",
    "proceedings , czech technical university in prague , 2012 , pp . 103110 .",
    "g.  fici , t.  lecroq , a.  lefebvre ,  .",
    "prieur - gaston , computing abelian periods in words , in : j.  holub , j.  rek ( eds . ) , proceedings of the prague stringology conference 2011 , czech technical university in prague , czech republic , 2011 , pp .",
    "184196 .",
    "m.  christou , m.  crochemore , c.  s. iliopoulos , identifying all abelian periods of a string in quadratic time and relevant problems , international journal of foundations of computer science 23  ( 6 ) ( 2012 ) 13711384 .",
    "m.  crochemore , c.  iliopoulos , t.  kociumaka , m.  kubica , j.  pachocki , j.  radoszewski , w.  rytter , w.  tyczyski , t.  wale , a note on efficient computation of all abelian periods in a string , information processing letters 113  ( 3 ) ( 2013 ) 7477 ."
  ],
  "abstract_text": [
    "<S> constantinescu and ilie ( bulletin of the eatcs 89 , 167170 , 2006 ) introduced the idea of an abelian period with head and tail of a finite word . </S>",
    "<S> an abelian period is called full if both the head and the tail are empty . </S>",
    "<S> we present a simple and easy - to - implement @xmath0-time algorithm for computing all the full abelian periods of a word of length @xmath1 over a constant - size alphabet . </S>",
    "<S> experiments show that our algorithm significantly outperforms the @xmath2 algorithm proposed by kociumaka et al .  </S>",
    "<S> ( proc .  of stacs , 245256 , 2013 ) for the same problem .    </S>",
    "<S> abelian period ; abelian power ; weak repetition ; design of algorithms ; text algorithms ; combinatorics on words . </S>"
  ]
}