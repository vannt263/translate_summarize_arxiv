{
  "article_text": [
    "in this paper , we describe an algorithm for using a quantum computer to calculate mean values of observables and the partition function of a quantum system .",
    "our algorithm includes two sub - algorithms .",
    "one sub - algorithm is for calculating , with polynomial efficiency , certain diagonal matrix elements of an observable .",
    "this sub - algorithm is performed on a quantum computer , using quantum phase estimation and tomography .",
    "this sub - algorithm is very similar to the algorithm of ref.@xcite by harrow et al .",
    ", except that we modify it to accomplish a substantially different job that has nothing to do whatsoever with systems of linear equations .",
    "a second sub - algorithm is for sampling a probability distribution .",
    "this sub - algorithm is not polynomially efficient .",
    "it can be performed either on a classical or a quantum computer . however , a quantum computer can perform it quadratically faster that a classical computer , if one uses a quantum sampling technique based on szegedy operators , like , for instance , the quantum gibbs sampling algorithm described in ref.@xcite .",
    "we end the paper with a brief section comparing the algorithms proposed in this paper with quantum algorithms proposed in earlier papers for calculating the same things .",
    "in particular , we compare our work to ref.@xcite by wocjan et al .",
    ", ref.@xcite by poulin and wocjan , and ref.@xcite by temme et al ..",
    "in this section , we will define some notation that is used throughout this paper . for additional information about my notational quirks ,",
    "i recommend that the reader consult the notation section of some of my previous papers ; for example , ref.@xcite .",
    "we will often use the symbol @xmath0 for the number ( @xmath1 ) of qubits and @xmath2 for the number of states with @xmath0 qubits .",
    "the quantum computing literature often uses @xmath3 for @xmath0 and @xmath4 for @xmath5 , but we will avoid this notation .",
    "we prefer to use @xmath3 for the number operator @xmath6 .",
    "let @xmath7 . as usual",
    ", let @xmath8 represent the set of integers ( negative and non - negative ) , real numbers , and complex numbers , respectively . we will also sometimes add a superscript to the symbols @xmath9 to indicate a subset of these sets .",
    "for example , we will use @xmath10 to denote the non - negative reals . for integers",
    "@xmath11 , @xmath12 such that @xmath13 , let @xmath14 .",
    "we will use @xmath15 to represent the  truth function \" ; @xmath15 equals 1 if statement @xmath16 is true and 0 if @xmath16 is false .",
    "for example , the kronecker delta function is defined by @xmath17 .    if @xmath18 , where @xmath19 , then @xmath20 .",
    "conversely , @xmath21 .",
    "however , when our meaning is clear from context , we will omit the @xmath22 and @xmath23 .",
    "hence , in some places @xmath24 might stand for an element of @xmath25 , and in other places for the corresponding element of @xmath26 .",
    "we wo nt usually put a caret over a symbol to indicate that it is an operator , but sometimes we will .",
    "for example , we will usually use @xmath27 for a hamiltonian , but sometimes , for clarity , we will call it @xmath28 .    note that in our quantum circuit diagrams , time flows from the right to the left of the diagram ( this is the * dirac convention * ) .",
    "careful : many workers in quantum computing draw their diagrams so that time flows from left to right ( the * quayle convention * ) .",
    "we will say a problem can be solved * with polynomial efficiency * , or * p - efficiently * for short , if its solution can be achieved in a time polynomial in @xmath0 . here",
    "@xmath0 is the number of bits required to encode the input for the algorithm that solves the problem .    by * compiling a unitary matrix * , we mean decomposing it into a * seo * ( sequence of elementary operators ) , where by elementary operators we mean operators that act on only a few qubits ( usually 1 , 2 or 3 ) , such as single - qubit rotations and cnots .",
    "compilations can be either exact , or approximate ( within a certain precision ) .",
    "we will say a unitary operator @xmath29 acting on @xmath30 can be * compiled with polynomial efficiently * , or * p - compiled * for short , if @xmath29 can be expressed , either approximately or exactly , as a seo of length polynomial in @xmath0 .",
    "when necessary , we specify whether a p - compilation is exact or approximate .",
    "next , we explain our notation related to discrete fourier transforms .    for any @xmath31 , define @xmath32 by    k_x = .",
    "let @xmath33 and @xmath34 be operators acting on @xmath30 with eigenvectors and eigenvalues given by = x and    = k_x for any @xmath31 .",
    "let the eigenvectors of @xmath34 and @xmath33 be related by a  discrete fourier transformation \" :    = _",
    "y=0^n_s-1 e^ik_x y . [ eq - dft ] eq.([eq - dft ] ) defines a  basis - changer \"",
    "unitary operator @xmath35 with matrix elements given by    u_ft= = e^ik_x y = e^ix k_y .",
    "assume that the eigenstates of @xmath34 are orthonormal and complete :    = ( y , x ) for all @xmath36 , and    _",
    "x=0 ^ -1 = 1 .",
    "then it follows that the eigenstates of @xmath33 are orthonormal and complete too , because    = u^_ft u_ft = ( y , x ) , and    _ x = _ x u_ft u_ft^=1 .    often in quantum computing we come across quantum states of the form    = _",
    "y=0^n_s-1 e^ik y , with k = k_z + k , [ eq - k - def ] for some @xmath37 and @xmath38 .",
    "if @xmath39 is neither @xmath40 nor @xmath41 but lies somewhere in between , then @xmath42 is close to but not exactly equal to an eigenstate of @xmath33 .",
    "note that when @xmath43 ,    u_ft^ = = ( x , z ) . for @xmath44 where",
    "@xmath39 is given by eq.([eq - k - def ] ) , this generalizes to    u_ft^ & = & _ y=0^n_s-1 e^i(k - k_x ) y + & = & + & = & .",
    "in this section , we give an algorithm for calculating certain diagonal matrix elements p - efficiently , using a quantum computer .",
    "this algorithm will be used as a subroutine in the algorithms proposed in later sections .",
    "the algorithm described in the proof of claim [ cl - diag - mat - elem ] below is very similar to the algorithm of ref.@xcite , except that we modify it to accomplish a different job . in a nutshell ,",
    "ref.@xcite combines two operations that were separately familiar to most quantum computerists long before ref.@xcite : a phase estimation ( pe ) operation , followed by a quantum tomography operation .",
    "[ cl - diag - mat - elem ] let @xmath45 be an @xmath5 dimensional hermitian matrix with non - negative eigenvalues , @xmath46 an @xmath5 dimensional unitary matrix , @xmath47 , and @xmath48 , where @xmath49 .",
    "assume that @xmath50 is simple ( that is , that it can be calculated p - efficiently ) .",
    "assume that we know how to p - compile @xmath46 and @xmath51 for any @xmath52 .",
    "then we can calculate p - efficiently the diagonal matrix element    ( x_0)= v^f(a ) v .",
    "[ eq - tar - diag - mat - elem ]    let @xmath53 be the number of states of @xmath54 bits , for a set of bits labeled @xmath55 .",
    "the diagonal matrix element eq.([eq - tar - diag - mat - elem ] ) can be calculated by running on a quantum computer the quantum circuit shown in fig.[fig - tom - pe ] . in that figure , there are three sets of qubits . at the top",
    "are @xmath54  probe \" qubits . below the probe qubits",
    "are the @xmath0  main \" qubits which are initially in state @xmath56 . finally , below the main qubits is a single  ancilla \" qubit that is used in the final tomography step .    in a moment",
    ", we will describe the evolution of the state vector as it courses down this quantum circuit .",
    "but before doing so , we need to specify some of the blocks in fig.[fig - tom - pe ] more precisely .",
    "note that h^^ = _",
    "j=0 ^ -1 . as for the @xmath57 box , it represents    c @c=1em @r=2em @!r & & + & & + & & + & &    & = &    c @c=1em @r=.5em @!r & & & & + & & & & + & & & & + & & & &    [ eq - pe-3bits ] + & = & _ j=0 ^ -1    c @c=1em @r=2em @!r & & + & &    , where    u_pe= e^i a t .",
    "( for definiteness , some parts of eq.([eq - pe-3bits ] ) assume that @xmath58 . ) finally , the operation with the  half moon \" nodes represents    c @c=1em @r=.5em @!r & & + & & + & & + & & + & &    & = & _ j=0 ^ -1    c @c=1em",
    "@r=1em @!r & & + & & + & &    , [ eq - muxor ] ( note that some parts of eq.([eq - muxor ] ) again assume that @xmath58 . ) where @xmath59 is defined by    r_j = with    c_j = ,    s_j = .",
    "@xmath60 is defined so that @xmath61 for all @xmath62 .",
    "eq.([eq - muxor ] ) is an su(2 ) multiplexor with @xmath54 controls",
    ". it can be p - compiled approximately ( the software application ",
    "multiplexor expander\"@xcite can do this ) .",
    "let    a= a_x for @xmath63 .",
    "define the basis - changer unitary operator @xmath64 by    u_a= for @xmath65 .",
    "fig.[fig - tom - pe ] includes at its bottom a time axis marked with notches for times 1 thru 4 .",
    "let @xmath66 for @xmath67 denote the quantum state at those times .",
    "let us represent such states by sums over 3 rows , where the first row refers to the @xmath54 probe bits , the second row refers to the @xmath0 main bits , and the final row refers to the single ancilla bit .",
    "one has & = & [    l _",
    "j=0 ^ -1 + _",
    "x=0 ^ -1 v +    .",
    ",    & = & [    l _ j=0 ^ -1 _",
    "j=0 ^ -1 + e^i t j _",
    "x=0 ^ -1 v +    .",
    "+ & = & _ j=0 ^ -1 _",
    "x=0 ^ -1 [    l + v +    . ,    & = & _ j=0 ^ -1 _",
    "x=0 ^ -1 [    l",
    "_ j=0 ^ -1 u^_ft + v +    .",
    "+ & = & _ x=0 ^ -1 [    l _ j=0 ^ -1 _ j=0 ^ -1 + v +    .",
    "+ & = & _ x=0 ^ -1 _ j=0 ^ -1 [    l ( , a_xt ) + v +    .",
    "+ & = & _ x=0 ^ -1 [    l + v +    . , and    & = & _ x=0 ^ -1 [    l + v + +    . .",
    "[ eq - psi4 ] note that we are treating the quantity @xmath68 as if it were an integer in the range @xmath69 .",
    "this quantity is non - negative because @xmath70 and @xmath71 are non - negative by assumption .",
    "@xmath71 can be chosen small enough so that this quantity is always smaller than @xmath72 .",
    "as to whether the quantity is an integer , it need not be in general",
    ". when it is nt , one has to do a more careful treatment ( as done in ref.@xcite ) . by using the treatment given above instead of a more careful one like the one of ref.@xcite",
    ", we are introducing a small error in what we shall say next .",
    "it follows from eq.([eq - psi4 ] ) that so if we were actually going to observe the @xmath73 of the main qubits , this would require that we know and apply @xmath74 to them and then measure @xmath75 . however , it turns out that we do nt need to observe / measure the main qubits to calculate @xmath76 , so we do nt need to know or apply @xmath74 after all . ]",
    "r +   +    = ^j_f _ a _ , where @xmath77 , @xmath78 , @xmath79 .",
    "the index @xmath80 labels @xmath81 samples .",
    "we can define an empirical probability distribution @xmath82 by    _",
    ", ( x , b ) = _ s=1^ _ x^ _ b^ , where @xmath31 and @xmath83 . then    _ , ( x , b ) | v |^2 _ b^0 + | v |^2 _ b^1 . therefore ,    _",
    "( b)= _ x=0 ^ -1_,(x , b ) = _ s=1^ _ b^ , and    _ ( b)v^f(a )",
    "v_b^0 + v^v_b^1 .",
    "finally , we conclude that    v^f(a ) v = _",
    "s=1^ _ 0^ .",
    "in this section , we give algorithms for calculating , under various scenarios , the expected value of an observable @xmath84 of a quantum system , and the boltzmann partition function @xmath85 for an inverse temperature @xmath86 , where @xmath87 are the eigenvalues of the hamiltonian of the quantum system .",
    "consider a quantum system with density matrix @xmath88 and hamiltonian @xmath27 , where both operators act on @xmath30 .",
    "( careful : @xmath27 is also used for the single qubit hadamard transformation ) .",
    "let    h= e_x for @xmath63 .",
    "define the basis - changer unitary operator @xmath89 by    u_h= for @xmath65 . furthermore , consider a hermitian operator @xmath84 acting on @xmath30 ( what we call an  observable \" of the quantum system ) with    = _ x and    u_= for @xmath65 .",
    "some important scenarios that we would like to consider are    1 .   _",
    "assume that @xmath90 for all @xmath63 and @xmath91 are known .",
    "furthermore , assume that we know how to p - compile @xmath91 and @xmath92 for any @xmath93 .",
    "then @xmath94 can be calculated as follows . _ + in claim [ cl - diag - mat - elem ] , set @xmath95 , @xmath96 and @xmath97 for @xmath98 .",
    "thus + ( x)= u_^u _ [ eq - px - case - a ] can be calculated p - efficiently for any @xmath63 .",
    "now a quantum sampling algorithm like the quantum gibbs sampling algorithm of ref.@xcite can be used to sample the probability distribution @xmath99 given by eq.([eq - px - case - a ] ) .",
    "if this yields the sample points @xmath100 for @xmath101 , then + ( ) _ s=1^ _ . [ eq - omega - est ] 2 .   _",
    "assume that @xmath90 for all @xmath63 and @xmath91 are known .",
    "furthermore , assume that we know how to p - compile @xmath91 and @xmath102 for any @xmath93 .",
    "let @xmath103 where @xmath104 and @xmath105",
    ". then @xmath94 can be calculated as follows . _ + in claim [ cl - diag - mat - elem ] , set @xmath95 , @xmath106 and @xmath107 for @xmath98 .",
    "( assume that the eigenvalues of @xmath27 are bounded below , as is true for any physical hamiltonian , and , if necessary , add a constant to @xmath27 so as to make all its eigenvalues non - negative . ) thus + ( x)= u_^e^-h u _ [ eq - px - case - b ] can be calculated p - efficiently for any @xmath63 .",
    "now a quantum sampling algorithm like the quantum gibbs sampling algorithm of ref.@xcite can be used to sample @xmath108 given by eq.([eq - px - case - b ] ) .",
    "( no need to know @xmath109 since the sampling algorithm only uses probability ratios . )",
    "if this yields the sample points @xmath100 for @xmath101 , then an estimate of the expected value of @xmath84 is again given by eq.([eq - omega - est ] ) .",
    "assume that function @xmath110 is simple ( that is , that it can be calculated p - efficiently ) .",
    "assume that we know how to p - compile @xmath102 for any @xmath93 .",
    "let @xmath103 where @xmath104 and @xmath105 .",
    "let @xmath111 .",
    "then @xmath112 and @xmath113 can be calculated as follows . _",
    "+ in claim [ cl - diag - mat - elem ] , set @xmath114 , @xmath106 and @xmath115 for @xmath98 .",
    "( if necessary , add a constant to @xmath27 so as to make all its eigenvalues non - negative . )",
    "thus + ( x)= g(h ) e^-h [ eq - px - case - c ] can be calculated p - efficiently for any @xmath63 .",
    "now a quantum sampling algorithm like the quantum gibbs sampling algorithm of ref.@xcite can be used to sample @xmath108 given by eq.([eq - px - case - c ] ) .",
    "if this yields the sample points @xmath100 for @xmath101 , then an estimate @xmath116 of @xmath112 can be obtained as follows .",
    "+ _ ( x)= _ s=1^ _ x^ , + = _ s=1^ z_g . to estimate @xmath113",
    ", we can use + = \\{g(h ) } .",
    "[ eq - est - tr - g - rho ] note that if @xmath117 instead of @xmath110 , one can set @xmath118 where @xmath119 .",
    "then @xmath120 .",
    "so we can estimate @xmath112 by first estimating @xmath121 . since we can estimate @xmath112 and @xmath122 , we can estimate @xmath113 using eq.([eq - est - tr - g - rho ] ) .",
    "in this section , we compare the algorithms of this paper with algorithms in earlier papers for calculating the same things (  our competition \" ) .",
    "this paper has not addressed the problem of finding useful estimates and bounds for the convergence rate and error of its algorithms .",
    "such analysis will hopefully be done in future papers by me or others more capable . lacking this analysis , the comparisons in this section",
    "should be taken as incomplete and preliminary .",
    "note that in the algorithms @xmath128 , finding the needed diagonal matrix elements is p - efficient .",
    "so the rate determining step of these algorithms is the quantum sampling part , which is not p - efficient .",
    "however , if the quantum sampling is done using the algorithm of ref.@xcite , then the sampling converges ( to a given precision ) in @xmath129 steps , where @xmath130 is the distance between the two largest eigenvalue magnitudes of the underlying markov chain .",
    "ref.@xcite by wocjan et al . presents an algorithm for calculating the partition function of a quantum system with hamiltonian @xmath27 , but it requires that the eigenvalues of @xmath27 be known a priori ( as is the case when the system is classical ) .",
    "the more recent ref.@xcite by poulin and wocjan does not require that the eigenvalues of @xmath27 be known a priori .",
    "however , the algorithm of ref.@xcite physically creates a sequence of boltzmann quantum states ( purifications of @xmath131 ) , each state characterized by a different inverse temperature , with the sequence of inverse temperatures increasing gradually , according to an  annealing schedule \" , from 0 towards the target @xmath132 .",
    "algorithm @xmath133 also calculates the partition function of a quantum system without assuming that the eigenvalues of @xmath27 are known a priori . but",
    "algorithm @xmath133 never produces physically any boltzmann quantum state . nor",
    "does it introduce error at every stage of an annealing schedule ( all its calculations are done at the target @xmath132 ) .",
    "ref.@xcite by temme et al .",
    "gives an algorithm that physically produces a boltzmann quantum state @xmath131 .",
    "instead of producing this @xmath88 or a purification of it , algorithm @xmath134 produces a @xmath127 state . if one wants to use the algorithm of temme et al . to get @xmath94",
    ", one still must assume the same things as @xmath134 above ( namely , that @xmath90 for all @xmath24 and @xmath91 are known , and that we know how to p - compile @xmath91 and @xmath102 ) .",
    "if these assumptions are satisfied , one can use the algorithm of temme et al . to produce @xmath135 physically , and then measure @xmath136 on it . after obtaining @xmath81 samples of @xmath24 ,",
    "one can then use eq.([eq - omega - est ] ) to estimate @xmath94 .",
    "thus , the temme et al .",
    "algorithm assumes the same things as @xmath134 to estimate @xmath94 .",
    "a big advantage of @xmath134 over temme et al .",
    "is that @xmath134 converges in @xmath129 steps , whereas temme et al .",
    "converges , just like classical algorithms , in @xmath137 steps ."
  ],
  "abstract_text": [
    "<S> we describe an algorithm for using a quantum computer to calculate mean values of observables and the partition function of a quantum system . </S>",
    "<S> our algorithm includes two sub - algorithms . </S>",
    "<S> the first sub - algorithm is for calculating , with polynomial efficiency , certain diagonal matrix elements of an observable . </S>",
    "<S> this sub - algorithm is performed on a quantum computer , using quantum phase estimation and tomography . </S>",
    "<S> the second sub - algorithm is for sampling a probability distribution . </S>",
    "<S> this sub - algorithm is not polynomially efficient . </S>",
    "<S> it can be performed either on a classical or a quantum computer , but a quantum computer can perform it quadratically faster . </S>"
  ]
}