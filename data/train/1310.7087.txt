{
  "article_text": [
    "nowadays graphics processing units ( gpu ) play a rather important role in high - performance computing ( hpc ) .",
    "the proportion of computing systems equipped with the special accelerators ( gpus , mic , etc . ) is growing among supercomputers , which is reflected in the well - known top500 list of the most powerful supercomputing systems of the world @xcite . the most popular programming languages for general - purpose computing on gpu ( gpgpu )",
    "are cuda ( for nvidia gpus only ) and open computing language ( opencl ) @xcite .",
    "currently more than 80% of all scientific researches are using gpu accelerators performed with cuda @xcite .",
    "one of the main approaches to study high - energy physics ( hep ) phenomena is the lattice monte carlo simulations . in 1974",
    "kenneth g. wilson proposed a formulation of quantum chromodynamics ( qcd ) on a space - time lattice @xcite  a lattice gauge theory ( lgt ) , which allows to calculate infinite - dimensional path integral with the procedure of computation of finite sums .",
    "lgt has many important features , in particular , lgt makes it possible to study low - energy limit of qcd , which is not achievable by analytic methods . in the limit of an infinite number of lattice sites and zero lattice spacing ,",
    "lgt becomes an ordinary quantum field theory ( qft ) .",
    "numerical results , obtained by means of lattice approximation , depend on number of lattice sites , the using of lattices with large size is preferable . moreover , some phenomena could be studied on big lattices only , because small lattices are not sensitive to such effects .",
    "the use of large lattices puts special demands on computer systems on which the investigation is performed .",
    "thus , the need for high computing performance in addition to the existence of well parallelized algorithms makes the application of gpus for lattice simulations particularly important .",
    "now hep is one of the main consumers of supercomputing facilities .",
    "major hep research collaborations develop software environments to achieve their scientific goals ( see below ) .",
    "the standard practice is to incorporate into packages special utilities for data exchange among collaborations . while software development programmers optimize their code according to the hardware available for collaboration .",
    "so , due to severe competition among hardware manufacturers it is necessary to take into consideration the cross - platform principles while constructing a new hep package .     of all scientific researches using gpu accelerators are performed with opencl @xcite , scaledwidth=60.0% ]    obviously , each software package has limited scope of scientific tasks , which could be solved with it .",
    "current hep development leads to emerging the problems beyond this scope .",
    "the spontaneous vacuum magnetization at high temperature @xcite , phase transition behavior in external fields @xcite , dependence of the phase transition order in o(n ) models on coupling constant value @xcite and so on are some of such tasks . in 2008",
    "we created the ids package @xcite , which allows to research quantum effects in external chromomagnetic field .",
    "it was written in ati il for amd / ati gpus and provided fast derivation of a huge statistic , desired for solving applied tasks .",
    "after the deprecation to maintain ati il by amd , the demand to port the package to a modern gpgpu language has been appeared .",
    "currently @xmath0 of all scientific researches using gpu accelerators are performed with opencl @xcite ( see figure [ fig : openclstat ] ) .",
    "so , opencl was chosen to provide a multi - platform usage .    in this paper",
    "we present qcdgpu package and describe its program architecture and possibilities .",
    "the general aim of the package is production of lattice gauge field configurations for pre described models with following statistical processing of different measurable quantities .",
    "the current version of qcdgpu allows to study su(2 ) , su(3 ) gauge theories as well as o(n ) models .",
    "the extension of available groups in the package may be made by linking the file with appropriate algebra and core of the monte carlo procedure for particular groups .",
    "the number of space - time dimensions is one of the run - time parameters in qcdgpu . @xmath1",
    "dimensional space - time is assumed by default .",
    "the list of measurable quantities may be changed accordingly to the problem investigated .",
    "all lattice simulations as well as measurements can be performed whether with single or double precisions .",
    "the package is easily - scalable to the number of available devices .",
    "the paper is organized as follows .",
    "the overview of existing packages is made in the sect.[sect : relworks ] .",
    "the structure of the qcdgpu package is shown in the sect.[sect : architecture ] .",
    "the description of multi - gpu mode and the capability of distributed simulations are provided in the sect.[sect : multigpu ] .",
    "some performance results are shown in sect.[sect : performance ] .",
    "the last sect.[sect : discussion ] is devoted to discussion of the scope of the package and summarizes the results .",
    "while a great amount of new experimental data appeared , modern high - energy physics requires extremely resource - intensive computations , in particular monte carlo lattice simulations .",
    "therefore , only big scientific collaborations , which have enough computation time on supercomputers can run such simulations . as usual",
    "such collaborations ( ukqcd , usqcd , twqcd , ptqcd , etc . ) have own software packages for simulations .",
    "the most well - known among them are :    * * fermiqcd * : an open c++ library for development of parallel lattice quantum field theory computations  @xcite , * * milc * : an open code of high performance research software written in c for doing @xmath2 lattice gauge theory simulations on several different ( mimd ) parallel computers  @xcite , * * qdp++/chroma * : package supporting data - parallel programming constructs for lattice field theory and in particular lattice qcd  @xcite .",
    "the first paper relating application of gpus in hep lattice simulations was published in 2007 @xcite .",
    "the authors of this work used opengl as programming language and for the first time denoted the need to store lattice data in the form of four - component vectors .",
    "shortly after of the publication , nvidia unveiled a new architecture cuda and opengl ceased to be used as a gpgpu - computation language in further works .",
    "recently some open - source software packages have been developed targeted to use gpus :    * * quda * : a library for performing calculations in lattice qcd on cuda - ready gpus  @xcite , * * ptqcd * : a collection of lattice su(n ) gauge production programs on cuda - ready gpus  @xcite , * * culgt * : code for gauge fixing in lattice gauge field theories with cuda - ready gpus  @xcite ,    and several other packages with closed - access source codes ( @xcite , @xcite , @xcite , @xcite , @xcite , @xcite ) .",
    "some hep collaborations link special gpu - libraries for their projects to engage gpgpu computing possibility without code refactoring .",
    "in particular , milc collaboration uses quda package @xcite , but only in single - device mode now .",
    "usqcd collaboration also has powered its qdp++/chroma software with cuda @xcite .    most of the gpu - targeted packages are based on nvidia cuda environment",
    ". however , the development of hpc market leads to increasing of cross - platform heterogeneous computing importance . in spite of unchallenged leadership of cuda",
    "the software packages adapted for cuda - ready devices could not be executed on other ( even hardware - compatible ) accelerators because of its closed standard .",
    "the qcdgpu package architecture is based on the full platform - independence principle .",
    "all modules of the package are written in c++ and opencl with minimal external libraries dependence .",
    "qcdgpu can run equally well both on windows operating system ( os ) , and on linux without any code modifications . the os - independence is implemented by the inclusion into the package of special file platform.h , which adapts the os - dependent commands by means of precompiler directives .",
    "the package is tested on different oss , opencl sdk of different vendors and on several devices :    * * os : * windows xp , windows 7 , opensuse 11.4 , opensuse 12.2 ; * * sdk : * nvidia cuda sdk 5.5 , amd app sdk 2.8.1 , intel sdk for applications opencl 2013 ; * * devices : * amd radeon hd7970 , hd6970 , hd5870 , hd5850 , hd4870 , hd4850 ( single - precision mode ) , nvidia geforce gtx 560 ti , nvidia geforce gtx 560 m , intel core i7 - 2600 , intel core i7 - 2630qm , amd phenom ii x6 .",
    "the package can be executed on all versions of opencl ( 1.0 , 1.1 , 1.2 ) without any code changes .",
    "the schematic diagram of the qcdgpu is shown in figure [ fig : structure ] .",
    "the package core compounds of the block clinterface , which provides the interaction of host code with computing devices .",
    "it performs all services for the preparation of devices , run of kernels and release the host memory and devices .",
    "next important block is the block with physical model description model description ( suncl or oncl depending on the model under investigation ) .",
    "memory organization on the host in accordance with the physical model ( gauge group , space - time dimension , etc . )",
    "is made in this block , as well as preparation and configuration of kernels in accordance with simulation conditions .",
    "algorithms based on pseudo - random number generators are the base of monte carlo procedure .",
    "library prngcl performs the function of generating pseudo - random numbers with required generator selection .",
    "the block big lattice is designed to provide the possibility to produce simulations on large lattices , and to use multiple devices on a single host .",
    "the package performs all the necessary calculations on computing devices and provides the final simulation results to the host",
    ". statistical analysis of the results over the run is performed by the block data analysis .",
    "validation of the data is performed by the block cpu results checking , which produces control measurements of required quantities on the last gauge configuration by cpu means .",
    "the block is basically designed for debugging ( for example , if a device has non - ecc memory ) , it can independently produce correspondent lattice gauge configurations on the same pseudo - random numbers as the device",
    ". the block can be turned off to save host resources .",
    "the interaction of several copies of the main program on different hosts is performed by a separate program qcdgpu - dispatcher .",
    "the program realizes task scheduling for the available copies of the main program according to the parameter space of the problem under investigation .",
    "the results of simulations are written in separate text files that are sent for further processing by external means .",
    "each file contains the startup parameters needed for reproduction of the run , as well as run average values and average configurations quantities table . also , for the possibility of resuming the interrupted simulation , the possibility of regular saving of computation package state is realized",
    ", it allows to interrupt the simulation at any time , and provides basic fault tolerance ( power or hardware failure ) . saving frequency",
    "is set at the beginning of the simulations by the corresponding parameter .",
    "saved file with the computation state is portable ( the calculation can be continued on another device ) .",
    "detailed description of the package blocks is below .",
    "block clinterface is designed to hide all preparatory work for opencl - kernels startup from the main program . at the same time",
    "fine adjustment of all programming units is available .",
    "every memory object and kernel obtain its own i d number and further kernel execution , memory object binding to the kernel , results output and so on are carried out by this i d number .",
    "this principle is initially used in the opencl standard @xcite , but the numbering of objects is produced mainly for the purposes of memory usage monitoring , users are not granted with the possibility to use these internal i d numbers .",
    "as far as lattice simulation implies multiply startup of the same kernels , block clinterface allows to adjust parameters of each kernel startup by default .",
    "meanwhile , there is only kernel s i d number in startup command arguments , which makes the program code shorter . at the same time",
    "there is a separate control of workgroupsize in case of intel opencl sdk usage , as it returns overestimated values workgroupsize for some devices .",
    "the unit also controls compute device errors .",
    "all errors are recorded in .log - file .",
    "noncritical errors do nt cause stop of the program .",
    "the block also performs caching of previously compiled programs to reduce the startup time of their launch .",
    "built - in compute cache is realized only in the nvidia cuda sdk .",
    "amd app sdk stores only the last compiled program , while intel sdk for applications opencl makes re - compilation while each startup . in spite of compute cache in the nvidia cuda sdk",
    ", there is a problem with the re - compilation necessity of dependent files ( included in the device - side opencl - program by directive # include )  sdk up to 5.5 version does not monitor such file changes .",
    "all mentioned above necessitates to create own compute cache .",
    "this compute cache is realized by creating .bin - files with compiled code for a particular device with distinct compilation parameters .",
    ".inf files are created along with these files , in which compilation - specific and additional parameters ( program number , platform , device , program options , md5-hash of program source , compilation timestamp ) are indicated .",
    "for each source code md5-hash is calculated , which is de facto i d number of the source code version .",
    "new .bin and .inf are created if startup parameters change . while changing md5-hash of the source code , old .bin and .inf files are overwritten .",
    "such internal compute cache can be turned off in startup parameters .",
    "the unit can perform a run - time profiling of kernels and memory objects .",
    "it allows to optimize new kernels during designing of them . by default profiling",
    "is turned off .",
    "startup parameters are passed to kernels by 3 means :    1 .   by determined parameters of internal precompiler ; 2 .   by constant buffers ; 3 .   directly by binding values .    undoubtedly , from the performance point of view , the most preferred way of passing parameters to kernels is the first mean .",
    "but it necessitates its re - compilation .",
    "that s why only rarely changed parameters are passed by this mean ( lattice geometry , gauge group , precision and so on ) .",
    "often changed parameters are passed mainly by the second mean ( coupling constant values , magnetic field flux and so on ) , which are common for all kernels .",
    "specific parameters for the particular kernel are passed by the third mean ( reducing size , memory offsets , etc . ) .",
    "such division allows to use computational time efficiently , which is formed from both program execution time , and its compilation time .",
    "the package block of qcdgpu , which is responsible for the physical model description , is modules suncl and oncl , which provide simulation su(n ) gluodynamics and o(n ) models correspondingly .",
    "as it is well known , the gauge fields in the group su(n ) are presented with @xmath3 complex matrices .",
    "these matrices are associated with lattice links . in case of o(n )",
    "models the fields are set with @xmath4-vectors , which are associated with lattice sites .",
    "that s why it is possible to unify storage of lattice data in the memory by the following means .",
    "the fastest index  number of lattice site .",
    "next index  spatial direction of lattice link . in case of o(n)-model",
    ", this index is not used .",
    "the slowest index is connected with gauge group . at the same time",
    "group matrices are represented as structures of defined quantity 4-vectors , each of which contains a piece of information about corresponding matrix .",
    "this is due to the architecture of gpu - devices memory .    in order to carry out lattice update ,",
    "lattice is traditionally divided into even and odd sites ( checkerboard scheme ) , and , if necessary , into separate parts , which makes it possible to study big lattices ( see below ) .",
    "( pseudo)heat - bath algorithm is used for su(n ) model update .",
    "improved metropolis algorithm @xcite is used for o(n ) update .",
    "due to the equalizing of array lengths , as well as offsets in accordance with workgroup size , it achieves coalesced memory access , which has a positive effect on overall performance .",
    "all pseudo - random numbers ( prn ) needed for kernel operation are produced by own library prngcl .",
    "the library is a porting and development of the library prngcal , written for amd / ati gpus on ati cal @xcite .",
    "the most popular pseudo - random number generators ( prng ) , which are used in hep lattice simulations ( ranmar , ranecu , xor128 , xor7 , mrg32k3a , ranlux with different luxury levels ) , are realized in it .",
    "realization of park - miller prng and `` constant generator '' , which produces a given constant , is included for testing and debugging purposes .",
    "the selection of the generator used is made by one external parameter , which gives the possibility to check obtained results stability in relation to prng used .    by  default ,  the  package  generates  prns  by  the  number of threads equal to the parameter value cl_device_image3d_max_width ( maximal width of 3d image ) , which the device returns . in practice",
    "this parameter connects to gpu device architecture and does not depend on the vendor .",
    "our observations show , that using this parameter as launched threads quantity allows to achieve the best performance .",
    "users can choose the quantity of threads for prns producing manually .",
    "as soon as almost all realized generators do not have a general scheme of multi - stream execution ( apart from mrg32k3a ) prng parallelization is made by various initializations of seed tables .",
    "every prng thread keeps own seed table with own initial values .",
    "the generator initialization is made by one value of the external parameter ( randseries ) , on which base prng seed tables are initialized . at the same time , if this parameter equals zero , then system time is chosen as its value .",
    "the value of parameter randseries definitely reproduces simulation results , so the value along with the name of prng used is presented in output files .",
    "one of the main features of package qcdgpu is its possibility to launch in multi - gpu mode . at this time several devices on the host system",
    "can be used for one simulation .",
    "it is evident that it is necessary to divide lattice into parts . in the general case dividing lattice",
    "is made into unequal parts , which partly allows to hide the difference in devices performances .    since the package is mainly designed to research finite - temperature effects , dividing lattice into parts is made in first spatial coordinate direction @xmath5 .",
    "this is due to the fact that the temperature is associated with the time direction @xmath6 and the case high temperature corresponds to @xmath7 .",
    "divided lattice simulation differs from a full lattice simulation only in necessity to carry out the exchanging values of boundary sites . to divide the lattice into parts",
    "so - called second - level checkerboard scheme is used .",
    "it is carried out in the alternate update of odd and even parts of the lattice . in this case , the border information exchange is performed in asynchronous mode  while even sites update is being made , fulfil the information at border sites is taken place and vise verse .",
    "so while dividing the lattice , it is preferable to use an even quantity of parts . dividing the lattice",
    "is also used in cases when compute device memory is not enough for the simulation .",
    "the package also allows to make simulations on several hosts at the same time . each copy of the main computational program launches on the corresponding host , while parameters passing and launch control are carried out by external program qcdgpu - dispatcher .",
    "a very simple scheme is used for interaction of the control and computational programs : in case of computational program launch in this mode , the program waits for the special file finish.txt deleting before simulation begins .",
    "if there is qcdgpu and qcdgpu - dispatcher in general folder , it means `` the previous run is completed  you can collect the results , waiting for the next run '' . after collecting files with simulation results",
    ", the control program creates a special file init.dat , in which parameters of next run are written , and file finish.txt is deleted .",
    "as soon as the computational program does not find the file finish.txt , it reads new parameters of the launch from the file init.dat .",
    "the cycle repeats . at the same time in case of using several copies of computational program qcdgpu - dispatcher sequentially looks through catalogues and set a new task for the first free host .",
    "names of files with results contain simulation finish time and unique prefix of computational program copy , which makes each file unique .",
    "in order to demonstrate some benchmarks we performed at several mc simulations for o(4 ) , su(2 ) , su(3 ) models on various lattices on the following gpus : nvidia geforce gtx 560 m ( windows 7 ) , nvidia geforce gtx 560 ti , amd radeon hd 7970 ( opensuse 12.2 ) , hd 6970 , hd 5870 ( opensuse 11.4 ) . for all mc simulations",
    "the `` hot '' lattice initialization and ranlux pseudo - random number generator with luxury level 3 were used . for o(4 ) model @xmath8 tries were used to update each lattice site ( this provides acceptance rate up to 50% ) . for su(2 ) and su(3 ) models @xmath9 and reunitarization were used .",
    "one bulk sweep was performed to decorrelate configurations to be measured .",
    "there are two types of sweeps : thermalization and working sweeps . during thermalization",
    "sweep each lattice element ( sites or links ) is updated . in working sweep the lattice is updated and some quantities are measured .",
    "so , working sweeps are some longer than thermalization sweeps . here",
    "we present the timings for working sweeps only .",
    ".the timings of one working sweep for o(4 ) , su(2 ) and su(3 ) models in single- and double - precision mode ( in seconds ) . [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     [ tab : tab1 ]    the performance results are collected in the table 1 .",
    "the gauge model and computing devices used in mc simulations are shown in first and second columns , correspondingly . due to the memory limit of particular computing device whole lattice",
    "should be divided into several parts to perform mc simulations .",
    "the number of parts is presented in the third column .",
    "obviously , the bigger number of lattice parts means the bigger number of boundary elements transmission between host and device ( or between devices in multi - gpu mode ) , which reduces the overall performance .",
    "the last two columns contain the timings for single- and double - precision mode simulations , correspondingly .",
    "among all the data in the table the case of cooperative simulation of one lattice on two different opencl platforms is shown ( amd radeon hd 7970 on amd app sdk 2.8 and nvidia geforce gtx 560 ti on nvidia cuda 5.5 ) . in this case",
    "the timings are better only on 10 - 25% than simulation on a single best device .",
    "nevertheless , simultaneous multi - platform simulations might be interesting for very big lattices .    in @xcite cardoso and",
    "bicudo reported the timings @xmath10 ( @xmath11 with double precision ) and @xmath12 ( @xmath13 with dp ) seconds per single sweep on lattice @xmath14 for su(2 ) and su(3 ) models , respectively .",
    "the authors used nvidia geforce gtx 580 and nvidia cuda .",
    "we performed the same performance measurements with qcdgpu ( lattice sweep with reunitarization , without any measurements ) and obtain the following values in seconds : @xmath10 ( @xmath15 with dp ) for su(2 ) and @xmath16 ( @xmath17 with dp ) for su(3 ) on nvidia geforce gtx 560 ti and @xmath18 ( @xmath19 with dp ) for su(2 ) and @xmath20 ( @xmath21 with dp ) for su(3 ) on amd radeon hd 7970 .    in actual mc simulations the trivial parallelization scheme ( each computing device receives from dispatcher unique parameters set for simulation of whole lattice ) we often use .",
    "the best performance results are obtained in this case . undoubtedly , due to many tuning parameters ( such as number of lattice parts , size of parts for different computing devices , part sequence , workgroup sizes , etc . )",
    "the qcdgpu package performance of multi - gpu mode is the subject for special research .",
    "in the present work a new package qcdgpu is introduced .",
    "this package is designed for monte carlo simulations of su(n ) gluodynamics in external field and o(n ) model on opencl - compatible devices .",
    "the package allows to carry out the simulations for very big lattices in single- or multi - gpu mode .",
    "simulations can be run with single or double precision .",
    "the package claims low demands to the host cpu and practically does not load it , which provides the possibility to use the package along with other traditional computational programs .",
    "if the size of the lattice under investigation allows its location in device memory , all necessary operations are carried out on device memory , the result returns to the host program after finishing the simulation . if the lattice is too big to locate it in device memory , it is divided into parts and work on separate parts is made by all computing devices available at the host .",
    "qcdgpu package allows the simultaneous run of several instances of the computational program on all tested oss .",
    "the current version of the program uses trivial parallelization scheme to distribute computing  every computing node gets separate task for simulation . at the same time os type on every used host",
    "is not important .",
    "the main requirement is to create a folder with shared access at the host .",
    "now it is made within the local network framework and by the means of virtual private network ( vpn ) organization for remote nodes .",
    "using small pieces of text information between task scheduling module qcdgpu - dispatcher and the host does not impose load on the network .",
    "built - in mechanism for saving the computational state while achieving some conditions ( every n sweeps or every m seconds ) allows to interrupt long calculations without threat of data loss and to continue them on another available device .",
    "it is also very useful while often power failures .      * using the base of the built - in profiling mechanism , as well as additional micro - benchmarks to make automatic adjustments of package start - up parameters ; * realization of rhmc algorithm for including fermionic fields on a lattice ; * running of one simulation on several hosts at the same time on the base of mpi , which is very important in case of accounting of fermionic fields . using mixed - precision possibility",
    "will be realized to reduce amount of exchanging information .    in this work",
    "we did not bring attention to the details of realized algorithms , as well as to detailed description of the package parameters .",
    "the package is being constantly developed . in the first place methods and algorithms needed for actual research in the quantum chromoplasma laboratory of dnepropetrovsk national university",
    "is realized .",
    "obtained physical results are published in particular in the works : @xcite , @xcite , etc ."
  ],
  "abstract_text": [
    "<S> the multi - gpu open - source package qcdgpu for lattice monte carlo simulations of pure su(n ) gluodynamics in external magnetic field at finite temperature and o(n ) model is developed . </S>",
    "<S> the code is implemented in opencl , tested on amd and nvidia gpus , amd and intel cpus and may run on other opencl - compatible devices . </S>",
    "<S> the package contains minimal external library dependencies and is os platform - independent . </S>",
    "<S> it is optimized for heterogeneous computing due to the possibility of dividing the lattice into non - equivalent parts to hide the difference in performances of the devices used . </S>",
    "<S> qcdgpu has client - server part for distributed simulations . </S>",
    "<S> the package is designed to produce lattice gauge configurations as well as to analyze previously generated ones . </S>",
    "<S> qcdgpu may be executed in fault - tolerant mode . </S>",
    "<S> monte carlo procedure core is based on prngcl library for pseudo - random numbers generation on opencl - compatible devices , which contains several most popular pseudo - random number generators .    _ </S>",
    "<S> keywords : _ lattice gauge theory , monte carlo simulations , gpgpu , opencl </S>"
  ]
}