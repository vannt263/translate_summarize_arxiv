{
  "article_text": [
    "a timed automaton @xcite can be considered as a finite automaton augmented with a number of dense ( either real or rational ) clocks .",
    "clocks can be reset or progress at rate 1 depending upon the truth values of a number of clock constraints in the form of clock regions ( i.e. , comparisons of a clock or the difference of two clocks against an integer constant ) . due to their ability to model and analyze a wide range of real - time systems , timed automata",
    "have been extensively studied in recent years ( see @xcite for recent surveys ) . in particular , by using the standard region technique , it has been shown that region reachability for timed automata is decidable @xcite .",
    "this fundamental result and the technique help researchers , both theoretically and practically , in formulating various timed temporal logics @xcite and developing verification tools @xcite .",
    "region reachability is useful but has intrinsic limitations . in many real - world applications",
    "@xcite , we might also want to know whether a timed automaton satisfies a non - region property , e.g. , @xmath1 holds whenever clock values @xmath2 can reach @xmath3 .",
    "recently , comon and jurski @xcite have shown that the binary reachability of a timed automaton is definable in the additive theory of reals augmented with an integral predicate that tells whether a term is an integer , by flattening a timed automaton into a real - valued counter machine without nested cycles @xcite .",
    "the result immediately paves the way for automatic verification of a class of non - region properties that previously were not possible using the region technique .    on the other hand , a strictly more powerful system , called a _",
    "pushdown timed automaton _ ( pta ) , can be obtained by augmenting a timed automaton with a pushdown stack .",
    "ptas are particularly interesting because they contain both dense clocks and unbounded discrete structures .",
    "they can be used to study , for instance , a timed version of pushdown processes @xcite or real - time programs with procedure calls .",
    "a configuration of a pta is a tuple of a control state , dense clock values , and a stack word .",
    "the binary reachability of a pta is the set of all pairs of configurations such that one can reach the other .",
    "comon and jurski s result for timed automata inspires us to look for a similar result for ptas .",
    "is there a decidable binary reachability characterization for ptas such that a class of non - region properties can be verified ?",
    "the main result in this paper answers this question positively .",
    "there are several potential ways to approach the question",
    ". the first straightforward approach would be to treat a pta as a cartesian product of a timed automaton and a pushdown automaton . in this way",
    ", the binary reachability of a pta can be formulated by simply combining comon and jurski s result and the fact that pushdown automata accept context - free languages .",
    "obviously , this is wrong , since stack operations depend on clock values and thus can not be simply separated .",
    "the second approach is to closely look at the flattening technique of comon and jurski s to see whether the technique can be adapted by adding a pushdown stack .",
    "however , the second approach has an inherent difficulty : the flattening technique , as pointed out in their paper , destroys the structure of the original timed automaton , and thus , the sequences of stack operations can not be maintained after flattening .",
    "very recently , the question has been answered positively , but only for integer - valued clocks ( i.e. , for discrete ptas ) .",
    "it has been shown in @xcite that the binary reachability of a discrete pta can be accepted by a nondeterministic pushdown automaton augmented with reversal - bounded counters ( npca ) , whose emptiness problem is known to be decidable @xcite . however , as far as dense clocks are concerned , the automata - based technique used in @xcite does not apply .",
    "the reason is that traditional automata theories do not provide tools to deal with machines containing both real - valued counters ( for dense clocks ) and unbounded discrete data structures .",
    "in order to handle dense clocks , we introduce a new technique , called the pattern technique , by separating a dense clock into an integral part and a fractional part .",
    "consider a pair @xmath4 of two tuples of clock values .",
    "we define ( see section [ pattern ] for details ) an ordering , called the pattern of @xmath4 , on the fractional parts of @xmath5 and @xmath6 .",
    "the definition guarantees that there are only a finite number of distinct patterns .",
    "an equivalent relation ",
    "@xmath7 \" is defined such that @xmath8 iff @xmath5 and @xmath9 ( @xmath6 and @xmath10 will also ) have the same integral parts , and both @xmath4 and @xmath11 have the same pattern .",
    "the  @xmath7 \" essentially defines an equivalent relation with a countable number of equivalent classes such that the integral parts of @xmath5 and @xmath6 together with the pattern of the fractional parts of @xmath5 and @xmath6 determine the equivalent class of @xmath4 .",
    "a good property of  @xmath7 \" is that it preserves the binary reachability : @xmath5 can reach @xmath6 by a sequence of transitions iff @xmath9 can reach @xmath10 by the ( almost ) same sequence of transitions , whenever @xmath8 .",
    "therefore , the fractional parts can be abstracted away from the dense clocks by using a pattern . in this way , by preserving the ( almost ) same control structure , a pta can be transformed into a discrete transition system ( called a pattern graph ) containing discrete clocks ( for the integral parts of the dense clocks ) and a finite variable over patterns . by translating a pattern back to a relation over the fractional parts of the clocks ,",
    "the decidable binary reachability characterization of the pattern graph derives the decidable characterization ( namely , @xmath12-definable ) for the pta , since the relation is definable in the additive theory of reals . with this characterization",
    ", it can be shown that the particular class of safety properties that contain mixed linear relations over both dense variables ( e.g. , clock values ) and discrete variables ( e.g. , word counts ) can be automatically verified for ptas .",
    "for instance ,    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ whenever configuration @xmath13 can reach configuration @xmath14 , @xmath15 holds .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    can be verified , where @xmath16 is the dense value for clock @xmath17 in @xmath13 , @xmath18 is the number of symbols @xmath19 in the stack word of @xmath13 .",
    "the results can be easily extended to ptas augmented with reversal - bounded counters . in particular , we can show that the binary reachability of a timed automaton is definable in the first - order additive theory over reals and integers with @xmath20 and @xmath21 , i.e. , @xmath22 . essentially , for timed automata , comon and jurski s characterization ( the additive theory of reals augmented with an integral predicate ) is equivalent to ours ( the additive theory of reals and integers ) .",
    "the additive theory over reals and integers is decidable , for instance , by the buchi - automata based decision procedure presented in @xcite .",
    "fractional orderings are an effective way to abstract the fractional parts of dense clocks .",
    "the idea of using fractional orderings can be traced back to the pioneering work of alur and dill in inventing the region technique @xcite .",
    "essentially , the region technique makes a finite partition of the clock space such that clock values in the same region give the same answer to each clock constraint in the system ( i.e. , the automaton of interest ) .",
    "comon and jurski @xcite notice that alur and dill s partition is too coarse in establishing the binary reachability of a timed automata .",
    "they move one step further by bringing in the clock values before a transition was made . but comon and jurski s partition is still finite , since their partition , though finer than alur and dill s , is still based on answers to all the clock constraints ( there are finitely many of them ) in the system . in this paper , @xmath7 deduces an",
    "_ infinite _ partition of both the initial values @xmath5 and the current values @xmath6 of the clocks .",
    "essentially , this partition is based on answers to all clock constraints ( not just the ones in the system ) .",
    "that is , @xmath7 is finer than comon and jurski s partition as well as alur and dill s .",
    "this is why the flattening technique @xcite destroys the transition structure of a timed automaton but the technique presented in this paper is able to preserve the transition structure .",
    "a class of pushdown timed systems was discussed in @xcite . however , that paper focuses on region reachability instead of binary reachability .",
    "this paper is organized as follows .",
    "section [ prel ] reviews a number of definitions and , in particular , defines a decidable formalism in which the binary reachability of ptas are expressed .",
    "section [ pattern ] and section [ ccp ] give the definition of patterns and show the correctness of using patterns as an abstraction for fractional clock values . section",
    "[ pta ] and section [ graph ] define ptas and show that the pattern graph of a pta has a decidable binary reachability characterization . section [ verif ] states the main results of the paper . in section [ concl ] , we point out that the results in this paper can be extended to many other infinite state machine models augmented with dense clocks .",
    "a nondeterministic multicounter automaton is a nondeterministic automaton with a finite number of states , a one - way input tape , and a finite number of integer counters .",
    "each counter can be incremented by 1 , decremented by 1 , or stay unchanged . besides",
    ", a counter can be tested against 0 .",
    "it is well - known that counter machines with two counters have an undecidable halting problem , and obviously the undecidability holds for machines augmented with a pushdown stack .",
    "thus , we have to restrict the behaviors of the counters .",
    "one such restriction is to limit the number of reversals a counter can make .",
    "a counter is _ @xmath23-reversal - bounded _ if it changes mode between nondecreasing and nonincreasing at most @xmath23 times .",
    "for instance , the following sequence of counter values : @xmath24 demonstrates only one counter reversal .",
    "a counter is _ reversal - bounded _ if it is @xmath23-reversal - bounded for some fixed number @xmath23 independent of computations .",
    "a _ reversal - bounded nondeterministic multicounter automaton ( nca ) _ is a nondeterministic multicounter automaton in which each counter is reversal - bounded .",
    "a _ reversal - bounded nondeterministic pushdown multicounter automaton ( npca ) _ is an nca augmented with a pushdown stack .",
    "in addition to counter operations , an npca can pop the top symbol from the stack or push a word onto the top of the stack .",
    "it is known that the emptiness problem ( i.e. , whether a machine accepts some words ? ) for npcas ( and hence ncas ) is decidable .",
    "[ emptiness ] the emptiness problem for reversal - bounded nondeterministic pushdown multicounter automata is decidable .",
    "@xcite    when an automaton does not have an input tape , we call it a machine . in this case , we are interested in the behaviors generated by the machine rather than the language accepted by the automaton",
    ". we shall use npcm ( resp .",
    "ncm ) to stand for ncpa ( resp .",
    "nca ) without an input tape .    let @xmath25 be integers , @xmath26 ( rationals ) or @xmath27 ( reals ) , @xmath28 be an alphabet .",
    "we use @xmath29 and @xmath30 to denote non - negative values in @xmath25 and @xmath31 , respectively .",
    "each value @xmath32 can be uniquely expressed as the sum of @xmath33 , where @xmath34 is the integral part of @xmath35 , and @xmath36 is the fractional part of @xmath35 .",
    "dense variable _ is a variable over @xmath31 .",
    "integer variable _ is a variable over @xmath25 .",
    "a _ word variable _ is a variable over @xmath37 .",
    "let @xmath38 . for each @xmath39 , we use @xmath40 , @xmath41 , and @xmath42 to denote a dense variable , an integer variable , and a word variable , respectively .",
    "we use @xmath43 to denote a _ count variable _ representing the number of symbol @xmath44 in @xmath42 . a _ linear term _",
    "@xmath45 is defined as follows : @xmath46 where @xmath47 and @xmath39 .",
    "mixed linear relation _",
    "@xmath48 is defined as follows : @xmath49 where @xmath45 is a linear term , @xmath50 , and @xmath51 is a linear term not containing dense variables . notice that a mixed linear relation could contain dense variables , integer variables and word count variables .",
    "dense linear relation _ is a mixed linear relation that contains dense variables only .",
    "a _ discrete linear relation _ is a mixed linear relation that does not contain dense variables . obviously , any discrete linear relation is a presburger formula over integer variables and word count variables .",
    "each integer can be represented as a unary string , e.g. , string  @xmath52 \" ( resp .",
    " @xmath53 \" ) for integer @xmath54 ( resp .",
    "@xmath55 ) . in this way",
    ", a tuple of integers and words can be encoded as a string by concatenating the unary representations of each integer and each of the words , with a separator @xmath56 .",
    "for instance , @xmath57 is encoded as string  @xmath58 \" .",
    "consider a predicate @xmath59 over integer variables and word variables .",
    "the domain of @xmath59 is the set of tuples of integers and words that satisfy @xmath59 . under the encoding ,",
    "the domain of @xmath59 can be treated as a set of strings , i.e. , a language .",
    "a predicate @xmath59 over integer variables and word variables is an _ npca predicate _ ( or simply npca ) if there is an npca accepting the domain of @xmath59 .",
    "a _ @xmath12-formula _",
    "@xmath60 is defined as follows : @xmath61 where @xmath62 is a dense linear relation and @xmath59 is an npca predicate .",
    "therefore , a @xmath12 formula is a finite disjunction of formulas in the form of @xmath63 or @xmath64 , where dense variables ( contained only in each @xmath62 ) and discrete variables ( contained only in each @xmath59 ) are separated .",
    "let @xmath65 . a predicate @xmath66 on tuples in @xmath67 is _",
    "@xmath12-definable _ if there is a @xmath12-formula @xmath60 with @xmath68 dense variables , @xmath69 integer variables , and @xmath70 word variables , such that , for all @xmath71 in @xmath31 , for all @xmath72 in @xmath25 , and for all @xmath73 in @xmath37 , @xmath74 @xmath75    [ basicprop ] ( 1 ) .",
    "both @xmath76 and @xmath77 are npca predicates , if @xmath78 is a discrete linear relation and @xmath59 is an npca predicate .",
    "npca predicates are closed under existential quantifications ( over integer variables and word variables ) .",
    "( 3 ) . if @xmath66 is @xmath12-definable and @xmath48 is a mixed linear relation , then both @xmath79 and @xmath80 are @xmath12-definable .",
    "the emptiness ( or satisfiability ) problem for @xmath12-definable predicates is decidable .",
    "@xmath78 is a presburger formula .",
    "( the domain of ) @xmath78 can therefore be accepted by a deterministic nca @xcite .",
    "hence , @xmath76 and @xmath77 can be accepted by npcas by  intersecting \" and  joining \" the deterministic nca and the npca that accepts @xmath59 , respectively .",
    "let @xmath59 be an npca predicate containing variable @xmath81 ( either an integer variable or a word variable ) .",
    "assume @xmath59 is accepted by npca @xmath82 .",
    "an npca @xmath83 can be constructed to accept @xmath84 by guessing each symbol in the encoding of @xmath81 ( on the input tape of @xmath82 ) and simulating @xmath82 .",
    "we first show that any mixed linear relation @xmath48 is definable by a _",
    "separately _ mixed linear relation @xmath85 ( i.e. , @xmath85 is a boolean combination of dense linear relations and discrete linear relations .",
    "so , @xmath85 does not have a term containing both dense variables and discrete variables . ) .",
    "that is , for all @xmath86 , @xmath87 instead of giving a lengthy proof , we look at an example of @xmath48 : @xmath88 .",
    "this can be rewritten as : @xmath89 term @xmath90 is the only part containing dense variables . since @xmath90 is bounded , separating cases for this term being at ( and between ) -1 , 0 , 1 will give a separately mixed linear relation @xmath85 .",
    "this separation idea can be applied for any mixed linear relation @xmath48 . if @xmath66 is definable by a @xmath12-formula @xmath60 , then @xmath79 ( resp .",
    "@xmath80 ) is definable by @xmath91 ( resp .",
    "@xmath92 ) . by re - organizing",
    "the dense linear relations ( in @xmath85 and @xmath60 ) and the discrete linear relations ( in @xmath85 ) such that the discrete linear relations are grouped with the npca predicates in @xmath60 , @xmath91 and @xmath92 can be made @xmath12-formulas using lemma [ basicprop ] ( 1 ) .",
    "the emptiness problem for @xmath63 and @xmath64 is decidable , noticing that the emptiness for @xmath62 , which is expressible in the additive theory of reals ( or rationals ) , is decidable , and the emptiness of npca predicate @xmath59 is decidable ( lemma [ emptiness ] ) .",
    "therefore , the emptiness of any @xmath12 formulas , as well as , from lemma [ basicprop ] ( 3 ) , any @xmath12-definable predicates , is decidable .",
    "a dense clock is simply a dense variable taking non - negative values in @xmath30 .",
    "now we fix a @xmath93 and consider @xmath94 clocks @xmath95 . for technical reasons",
    ", @xmath96 is an auxiliary clock indicating the current time @xmath97 .",
    "let @xmath98 , and @xmath99 .",
    "a subset @xmath100 of @xmath101 is abused as a set of clocks ; i.e. , we say @xmath102 if @xmath103 .",
    "a _ ( clock ) valuation _",
    "@xmath104 is a function @xmath105 that assigns a value in @xmath30 to each clock in @xmath101 .",
    "a _ discrete ( clock ) valuation _",
    "@xmath106 is a function @xmath107 that assigns a value in @xmath29 to each clock in @xmath101 . for each valuation @xmath104 and @xmath108 , @xmath109 , @xmath110 and @xmath111",
    "are valuations satisfying @xmath112 , @xmath113 and @xmath114 for each @xmath115 .",
    "the _ relative representation _",
    "@xmath116 of a valuation @xmath104 is a valuation satisfying :    * @xmath117 , * @xmath118 , * @xmath119 , for each @xmath120 .",
    "a valuation @xmath5 is _ initial _ if the auxiliary clock @xmath96 has value 0 in @xmath5 .",
    "[ ex1 ] let @xmath121 and @xmath122 .",
    "it can be calculated that @xmath123 let @xmath124 @xmath125 @xmath126 .",
    "then , @xmath127 it is noticed that all the fractional parts ( except for @xmath128 and @xmath129 ) are the same in @xmath130 and @xmath131 . it is easy to show that a clock progress ( i.e. , @xmath132 progress by the same amount such as .268 ) will not change the fractional parts of clock values ( for clocks @xmath133 ) in a relative representation .",
    "we distinguish two disjoint sets , @xmath134 and @xmath135 , of indices .",
    "a _ pattern _",
    "@xmath136 is a sequence @xmath137 for some @xmath138 , of nonempty and disjoint subsets of @xmath139 such that    * @xmath140 and * @xmath141 .    in pattern @xmath136",
    ", @xmath142 is called the _ @xmath143-position_.",
    "a pair of valuations @xmath144 is _ initialized _ if @xmath5 is initial .",
    "the pattern of @xmath144 characterizes the fractional ordering between elements in @xmath145 and @xmath146 ( where @xmath147 is for indices of @xmath5 and @xmath148 is for indices of @xmath6 ) .",
    "formally , an initialized pair @xmath144 _ has pattern @xmath149 _ , written @xmath150 , or @xmath151=\\eta$ ] , if , for each @xmath152 , each @xmath153 , and each @xmath154 , @xmath155 and @xmath156 imply that @xmath157 though this definition of a pattern is quite complex , a pattern can be easily visualized after looking at the following example .",
    "[ ex2 ] consider @xmath6 in example [ ex1 ] and an initial valuation @xmath158 @xmath159 . since @xmath5 is initial , @xmath160 .",
    "the fractional parts of @xmath5 and @xmath6 , in the relative representation , can be put on a big circle representing the interval @xmath161 as shown in figure [ fig1 ] .",
    "each fractional value @xmath162 for @xmath5 is represented by an oval ; each fractional value @xmath163 for @xmath6 is represented by a box .",
    "the pattern of @xmath144 can be drawn by collecting clockwisely ( from the top , i.e. , @xmath164 ) the indices ( superscripted with 0 , e.g. , @xmath165 for @xmath166 ) for each component in @xmath167 and the indices ( superscripted with 1 , e.g. , @xmath168 for @xmath169 ) for each component in @xmath170 ; i.e. , the pattern is @xmath171 with @xmath172    there are at most @xmath173 distinct patterns .",
    "let @xmath174 denote the set of all the patterns ( for the fixed @xmath175 ) .",
    "a pattern is _ initial _ if it is the pattern of @xmath176 for some initial valuation @xmath5 .",
    "if @xmath136 is the pattern of @xmath144 , we use @xmath177 to denote the pattern of @xmath176 .",
    "@xmath177 is unique for each @xmath136 . given two initialized pairs @xmath178 and @xmath179 , we write @xmath180 , if @xmath178 and @xmath179 have the same pattern , and have the same integral parts ( i.e. , @xmath181 ) . the following lemma can be observed .",
    "[ initialpattern ] for any two initialized pairs @xmath178 and @xmath179 with @xmath180 , the following statements hold :    ( 1 ) .",
    "the pattern of @xmath178 is initial iff @xmath182 ,    ( 2 ) .",
    "@xmath6 is initial ( i.e. , @xmath183 ) iff @xmath184 is initial ,    ( 3 ) . @xmath185",
    "iff @xmath186 .",
    "a valuation @xmath6 _ has pattern _",
    "@xmath136 if there is an initial @xmath5 such that @xmath144 has pattern @xmath136 .",
    "@xmath6 may have a number of patterns , by different choices of @xmath5 .",
    "a pattern of @xmath6 tells the truth values of all the _ fractional orderings _ @xmath187 and @xmath188 ( where @xmath189 stands for @xmath190 . ) , for all @xmath191 , as shown in the following lemma .",
    "[ densetest ] let @xmath149 be a pattern of a valuation @xmath104 .",
    "assume @xmath192 for some @xmath193 .",
    "then , for any @xmath194 and @xmath195 ( with @xmath196 ) , for any @xmath197 and @xmath198 in @xmath199 ( with @xmath200 and @xmath201 ) , the following statements hold .",
    "@xmath202 iff one of the following conditions holds :    @xmath203 ,    @xmath204 ,    @xmath205 .",
    "@xmath206 iff @xmath207 .",
    "@xmath208 iff @xmath209 .",
    "@xmath210 iff @xmath211 .    directly from the definition of a pattern .",
    "recall @xmath212 stands for the index for the value of clock @xmath96 ( representing @xmath97 ) in @xmath6 .",
    "let @xmath149 be a pattern .",
    "@xmath142 is the _ now - position _ of @xmath136 if @xmath192 .",
    "a pattern @xmath136 is _ regulated _ if the now - position of @xmath136 is @xmath213 .",
    "note that the pattern of an initialized pair @xmath144 is regulated if and only if the auxiliary clock @xmath96 takes an integral value in @xmath6 ( i.e. , @xmath214 ) .",
    "a pattern is a _ merge - pattern _ if the now - position is a singleton set ( i.e. , @xmath215 is the only element ) .",
    "a pattern is a _ split - pattern _ if it is not a merge - pattern , i.e. , the now - position contains more than one element .",
    "(  merge \" and  split \" will be made clear in a moment . ) obviously , a regulated pattern is always a split - pattern .",
    "this is because the now - position of a regulated pattern , which is @xmath213 , contains at least two elements @xmath216 and @xmath215 .      for each @xmath217",
    ", @xmath111 is the result of a clock progress from @xmath104 by an amount of @xmath218 . how does a pattern change according to the progress ?",
    "let us first look at an example .",
    "[ ex4 ] consider @xmath219 ( @xmath220 ) in example [ ex1 ] , and @xmath5 in example [ ex2 ] . in example",
    "[ ex2 ] , we indicated that the pattern @xmath221 of @xmath144 is @xmath222 similar steps can be followed to show that the pattern @xmath223 of @xmath224 is @xmath225 a helpful way to see the relationship between @xmath221 and @xmath223 is by looking at figure [ fig1 ] . holding the box labeled by @xmath128 ( for the current time ) and sliding counter - clockwisely along the big circle for an amount of @xmath226 will stop at the box labeled by @xmath227 and @xmath228 .",
    "thus , the pattern @xmath223 ( after sliding ) is exactly @xmath221 ( before sliding ) except that @xmath215 in the @xmath229-position in @xmath221 is merged into the @xmath230-position in @xmath223 .",
    "notice that @xmath221 is a merge - pattern and the resulting @xmath223 is a split - pattern .",
    "the integral parts @xmath231 and @xmath232 change to @xmath233 and @xmath234 . but all the other components of @xmath235 do not change .",
    "the reason is that , after merging @xmath215 with @xmath236 and @xmath237 in @xmath223 , the fractional parts @xmath238 and @xmath239 are  rounded \" ( i.e. , become 0 ) .",
    "what if we further make a clock progress from @xmath184 for an amount of @xmath240 ?",
    "the resulting pattern @xmath241 of @xmath242 with @xmath243 is the result of splitting @xmath215 from the 2-position @xmath244 .",
    "that is , @xmath241 is @xmath245 which is a merge - pattern again .",
    "this process of merging and splitting can be formally defined as the following function @xmath246 .",
    "function @xmath247 describes how a pattern changes upon a clock progress .",
    "given any discrete valuation @xmath106 and pattern @xmath149 with the now - position being @xmath142 for some @xmath143 , @xmath248 is defined to be @xmath249 such that ,    * ( the case when @xmath136 is a merge - pattern ) if @xmath250 and @xmath251 ( that is , the now - position @xmath252 ) , then @xmath253 is @xmath254 ( that is , @xmath253 is the result of merging the now - position to the previous position ) , and for each @xmath255 , if @xmath256 , then @xmath257 else @xmath258 . besides , if @xmath259 ( i.e. , the now - position is merged to @xmath213 ; in this case , @xmath253 is a regulated pattern ) , then @xmath260 else @xmath261 , * ( the case when @xmath136 is a split pattern ) if @xmath262 and @xmath263 , then @xmath253 is the result of splitting @xmath215 from the now - position . that is , if @xmath264 , @xmath253 is @xmath265 however , if @xmath266 , @xmath253 is @xmath267 in either case , @xmath268 .    if @xmath269 , ( 1 ) .",
    "@xmath253 is called _ the next pattern of @xmath136 _ , written @xmath270 , ( 2 ) .",
    "@xmath271 is called the _ increment vector _ of @xmath136 with @xmath272 . obviously , @xmath273 and @xmath274 is total and 1 - 1 .",
    "to better understand @xmath274 , we visualize pattern @xmath136 as a circle shown in figure [ fig3 ] . applications of @xmath274 can be regarded as moving the index @xmath215 along the circle , by performing merge - operations ( figure [ fig3 ] ( a ) ) and split - operations ( figure [ fig3 ] ( b ) ) alternatively .",
    "after enough number of applications of @xmath274 , @xmath215 will return to the original now - position after moving through the entire circle .",
    "that is , for each pattern @xmath136 , there is a smallest positive integer @xmath275 such that @xmath276 ; i.e. , @xmath277 satisfies @xmath278 , and @xmath279 for each @xmath280 .",
    "more precisely , by looking at figure [ fig3 ] , if @xmath136 is a merge - pattern , @xmath281 ; if @xmath136 is a split - pattern , @xmath282 .",
    "furthermore , elements @xmath283 are distinct .",
    "the sequence @xmath277 is called a _",
    "pattern ring_. the pattern ring is unique for each fixed @xmath284 .",
    "notice that @xmath285 for each @xmath106 .",
    "since the next pattern @xmath270 is a merge - pattern ( resp .",
    "split - pattern ) if @xmath136 is a split - pattern ( resp .",
    "merge - pattern ) , on a pattern ring , merge - patterns and split - patterns appear alternately .",
    "fix any initialized pair @xmath286 and @xmath287 .",
    "assume the patterns of @xmath286 and @xmath288 are @xmath136 and @xmath253 , respectively .",
    "@xmath104 has no pattern change for @xmath218 _ if , for all @xmath289 , @xmath290 has the same pattern .",
    "@xmath104 has one pattern change for @xmath218 _ if @xmath291 and , for all @xmath292 , @xmath290 has pattern @xmath136 , or , for all @xmath292 , @xmath290 has pattern @xmath253 .",
    "the following lemma on the correctness of @xmath246 can be observed .",
    "[ progresspatternchange ] for any initialized pair @xmath286 and any @xmath287 , the following statements are equivalent :    ( 1 ) .",
    "@xmath293,\\up{\\v})=([(\\v_0,\\v+\\delta)],\\up{\\v+\\delta}),$ ]    ( 2 ) .",
    "@xmath104 has one pattern change for @xmath218 .",
    "@xmath104 has @xmath23 pattern changes for @xmath218 _ with @xmath294 , if there are positive @xmath295 in @xmath30 with @xmath296 such that @xmath297 has one pattern change for @xmath298 , for each @xmath299 .",
    "it is noticed that for any @xmath300 , @xmath104 has at most @xmath275 pattern changes , where @xmath275 is the length of the pattern ring starting from the pattern @xmath136 of @xmath286 .",
    "this @xmath275 is uniformly bounded by @xmath301 .",
    "[ maxpatternchange ] for any initialized pair @xmath286 and any @xmath108 , ( 1 ) @xmath104 has at most @xmath301 pattern changes for @xmath218 if @xmath300 , ( 2 ) @xmath104 has at least one pattern change for @xmath218 if @xmath302 , ( 3 ) if @xmath104 has no pattern change for @xmath218 then @xmath303 .",
    "in addition to clock progresses , clock resets are the other form of clock behaviors .",
    "let @xmath304 be ( a set of ) _ clock resets_. @xmath305 denotes the result of resetting each clock @xmath306 ( i.e. , @xmath307 ) .",
    "that is , for each @xmath115 , @xmath308    [ ex6 ] consider @xmath5 and @xmath6 given in example [ ex2 ] and example [ ex1 ] .",
    "assume @xmath309 . by definition , @xmath310 @xmath311 .",
    "it can be calculated that the relative representation of @xmath312 is @xmath313 @xmath314 @xmath315 .",
    "the pattern of @xmath316 can be figured out again by looking at figure [ fig1 ] .",
    "the reset of clock @xmath317 can be conceptually regarded as moving the label @xmath228 from the box of @xmath227 and @xmath228 to the box of @xmath128 ( the current time ) .",
    "therefore , the pattern after the reset changes from @xmath318 of @xmath144 to @xmath319 of @xmath316 by moving @xmath237 into the position containing @xmath215 .",
    "functions @xmath320 for @xmath304 describe how a pattern changes after clock resets . given any discrete valuation @xmath106 and any pattern @xmath149 with the now - position being @xmath142 for some @xmath143 , @xmath321 is defined to be @xmath249 such that ,    * @xmath253 is @xmath322 , where @xmath323 . therefore , @xmath253 is the result of bringing every index in @xmath324 into the now - position .",
    "notice that some of @xmath325 may be empty after moving indices in @xmath324 out of @xmath326 , for @xmath327 . in this case",
    ", these empty elements are removed from @xmath253 ( to guarantee that @xmath253 is well defined . ) , * for each @xmath328 , if @xmath329 , then @xmath330 else @xmath258 .",
    "if @xmath331 , @xmath253 is written as @xmath332 .",
    "note that @xmath332 is unique for each @xmath136 and @xmath70 , and is independent of @xmath106 .",
    "the following lemma states that _ reset _ is correct .",
    "[ resetpatternchange ] for any initialized pair @xmath286 and any @xmath304 , @xmath333,\\up{\\v})= ( [ ( \\v_0,\\v\\downarrow_r)],\\up{\\v\\downarrow_r}).\\ ] ]",
    "an _ atomic clock constraint _ ( over clocks @xmath133 , excluding @xmath96 ) is a formula in the form of @xmath334 or @xmath335 where @xmath336 and @xmath189 stands for @xmath190 .",
    "a _ clock constraint _",
    "@xmath337 is a boolean combination of atomic clock constraints .",
    "let @xmath338 be the set of all clock constraint ( over clocks @xmath133 ) .",
    "we say @xmath339 if clock valuation @xmath104 ( for @xmath340 ) satisfies clock constraint @xmath337 .",
    "any clock constraint @xmath337 can be written as a boolean combination @xmath341 of clock constraints over discrete clocks @xmath342 and fractional orderings @xmath343 and @xmath344 .",
    "for instance , @xmath345 is equivalent to : @xmath346 , or , @xmath347 and @xmath348 .",
    "@xmath349 is equivalent to : @xmath350 , or , @xmath351 and @xmath352 .",
    "therefore , testing @xmath339 is equivalent to testing @xmath353 and the fractional orderings on @xmath354 satisfying @xmath341 .",
    "assume @xmath104 has a pattern @xmath149 .",
    "a fractional ordering on @xmath354 is equivalent to a boolean condition on @xmath136 , as shown in lemma [ densetest ] .",
    "whenever @xmath136 is fixed , each fractional ordering in @xmath341 has a specific truth value ( either 0 or 1 ) . in this case , we use @xmath355 , or simply @xmath356 , to denote the result of replacing fractional orderings in @xmath341 by the truth values given by @xmath136 .",
    "@xmath356 , without containing fractional orderings , is just a clock constraint ( over discrete clocks ) .",
    "notice that the pattern space @xmath174 is finite , therefore , @xmath339 is equivalent to @xmath357 hence , the truth value of @xmath339 only depends on a pattern of @xmath104 and the integral parts of @xmath104 .",
    "these observations conclude the following results . in particular , lemma [ tests ] ( 2 ) indicates that it is sufficient to test the two end points @xmath339 and @xmath358 in order to make sure that @xmath337 is consistently satisfied on each @xmath359 , @xmath289 , if from @xmath104 to @xmath111 , there is at most one pattern change .",
    "[ tests ] ( 1 ) . for any initialized pair @xmath286 , any pattern @xmath360 ,",
    "if @xmath286 has pattern @xmath136 , then , for any clock constraint @xmath361 , @xmath339 iff @xmath362 .",
    "( 2 ) . for any initialized pair @xmath286 and any @xmath287 , if @xmath104 has at most one pattern change for @xmath218 , then , for any clock constraint @xmath361 , @xmath363    ( 3 ) . for any initialized pairs @xmath364 and @xmath365 , if @xmath366 , then , for any @xmath361 , @xmath367 iff @xmath368 .",
    "\\(1 ) is from the observations made before this lemma in this section .",
    "( 2 ) is from ( 1 ) and lemma [ progresspatternchange ] .",
    "( 3 ) is directly from ( 1 ) .",
    "now , we consider two initialized pairs @xmath369 and @xmath370 such that @xmath371 that is , from the definition of @xmath7 , @xmath372 ( resp .",
    "@xmath6 ) has the same integral parts as @xmath373 ( resp .",
    "@xmath184 ) . besides",
    ", the two pairs have the same pattern . from lemma [ tests](3 )",
    ", any test @xmath361 will not tell the difference between @xmath6 and @xmath184 .",
    "assume @xmath6 can be reached from a valuation @xmath374 via a clock progress by an amount of @xmath375 , i.e. , @xmath376 .",
    "we would like to know whether @xmath184 can be reached from some valuation @xmath377 also via a clock progress but probably by a slightly different amount of @xmath378 such that @xmath379 and @xmath380 are still equivalent(@xmath7 ) .",
    "we also expect that for any test @xmath337 , if during the progress of @xmath374 , @xmath337 is consistently satisfied , then so is @xmath337 for the progress of @xmath377 .",
    "the following lemma concludes that these , as well as the parallel case for clock resets , can be done .",
    "this result can be used later to show that if @xmath6 is reached from @xmath372 by a sequence of transitions that repeatedly perform clock progresses and clock resets , then @xmath184 can be also reached from @xmath373 via a very similar sequence such that no test @xmath337 can distinguish the two sequences .    [ backwards ] for any initialized pairs @xmath369 and @xmath370 with @xmath369 @xmath381 ,    ( 1 ) . for any @xmath382 , for any clock valuation @xmath374 , if @xmath376 , then there exist @xmath383 and clock valuation @xmath377 such that    ( 1.1 ) . @xmath384 and @xmath385 ,    ( 1.2 ) .",
    "@xmath374 is initial iff @xmath377 is initial ,    @xmath386 iff @xmath387 , and    for any @xmath361 , @xmath388 ( resp .",
    "@xmath367 ) iff @xmath389 ( resp .",
    "@xmath368 ) ,    ( 1.3 ) . for any clock constraint @xmath361 , @xmath390 iff @xmath391 .    ( 2 ) . for any @xmath304 , for any clock valuation @xmath374 ,",
    "if @xmath392 , then there exists a valuation @xmath377 such that    ( 2.1 ) .",
    "@xmath393 and @xmath385 ,    ( 2.2 ) .",
    "same as ( 1.2 ) .",
    "assume @xmath375 is  small \" , i.e. , from @xmath374 to @xmath394 , there is at most one pattern change .",
    "let @xmath149 be the pattern for @xmath370 ( and , hence , for @xmath369 ) .",
    "assume @xmath192 for some @xmath143 .",
    "if @xmath375 causes no pattern change for @xmath374 , then simply take @xmath395 .",
    "if @xmath375 causes one pattern change for @xmath374 , then we put @xmath370 on a circle ( e.g. figure [ fig1 ] ) .",
    "if @xmath136 is a split - pattern ( i.e. , @xmath263 ) , then we separate a new box ( only labeled by @xmath396 ) from the original box labeled by @xmath396 and slide the new box backwards ( i.e. , clockwisely ) for a small positive amount ( taken as @xmath378 ) without hitting any box or oval .",
    "if @xmath136 is a merge - pattern ( i.e. , @xmath251 ) , then we slide the box labeled by @xmath396 ( this is the only label ) backwards ( i.e. , clockwisely ) for a positive amount ( taken as @xmath378 ) until a box or an oval is hit .",
    "take @xmath397 .",
    "obviously , @xmath385 .",
    "it can be checked that ( 1.2 ) and ( 1.3 ) hold using lemma [ tests ] and lemma [ initialpattern ] .",
    "any larger @xmath375 that causes multiple pattern changes for @xmath374 can be split into a finite ( lemma [ maxpatternchange ] ) sequence of small @xmath218 s that causes exactly one pattern change . in this case",
    ", @xmath378 can be calculated by working on each small @xmath218 ( the last one first ) as in the above proof .",
    "the case when @xmath398 is obvious .",
    "assume @xmath70 contains only one element @xmath255 .",
    "assume @xmath136 is the pattern of @xmath399 .",
    "a desired @xmath377 is picked as follows .",
    "the integral parts of @xmath377 are exactly those of @xmath374 ; i.e. , @xmath400 .",
    "the fractional parts of @xmath377 are exactly those of @xmath184 , except that , in the relative representation , @xmath401 may be different from @xmath402 .",
    "then what is @xmath401 ?",
    "it is chosen such that the pattern of @xmath380 is @xmath136 .",
    "for instance , if @xmath403 equals to , say , @xmath404 ( resp .",
    "@xmath405 ) , for some @xmath197 , then @xmath401 is picked as @xmath406 ( resp .",
    "@xmath407 ) .",
    "if @xmath403 lies strictly between , say , @xmath404 ( or , @xmath405 ) and @xmath408 ( or , @xmath409 ) , for some @xmath197 and @xmath198 , such that no other component in @xmath410 and @xmath411 lies strictly between these two values , then @xmath401 is picked as any value lies strictly between @xmath406 ( or , @xmath407 ) and @xmath412 ( or , @xmath413 ) accordingly . since @xmath414 , we can show @xmath401 can always be picked . the choice of @xmath401 guarantees that the pattern of @xmath399 is the same as the pattern of @xmath415 .",
    "the rest of conditions in ( 2 ) can be checked easily .",
    "for the case when @xmath70 contains more than one element , the above proof can be generalized by resetting clocks in @xmath70 one by one .",
    "a _ pushdown timed automaton _ ( pta ) @xmath416 is a tuple @xmath417 where    * @xmath418 is a finite set of _ states _ , * @xmath133 are ( dense ) clocks , * @xmath419 assigns a clock constraint over clocks @xmath133 , called an _ invariant _ , to each state , * @xmath420 assigns a clock constraint over clocks @xmath133 , called a _ reset condition _ , and a subset of clocks , called clock resets , to a ( directed ) edge in @xmath421 , * @xmath28 is the _ stack alphabet_. @xmath422 assigns a pair @xmath423 with @xmath44 and @xmath424 , called a _ stack operation _ , to each edge in @xmath421 .",
    "a stack operation @xmath423 replaces the top symbol @xmath19 of the stack with a string ( possibly empty ) in @xmath37 .",
    "a _ timed automaton _ is a pta without the pushdown stack .",
    "the semantics of @xmath416 is defined as follows .",
    "configuration _ is a triple @xmath425 of a state @xmath426 , a clock valuation @xmath104 on @xmath340 ( where @xmath96 is the auxiliary clock ) , and a stack word @xmath427 .",
    "@xmath428 denotes a _",
    "one - step transition _ of @xmath416 if one of the following conditions is satisfied :    * ( _ a progress transition _ ) @xmath429 , @xmath430 , and @xmath431 , @xmath432 and for all @xmath433 satisfying @xmath289 , @xmath434 .",
    "that is , a progress transition makes all the clocks synchronously progress by amount @xmath435 , during which the invariant is consistently satisfied , while the state and the stack content remain unchanged . *",
    "( _ a reset transition _ ) @xmath436 , @xmath437 , and @xmath438 for some @xmath427 , where @xmath439 for some clock constraint @xmath337 and clock resets @xmath70 , and @xmath440 for some stack symbol @xmath44 and string @xmath424 .",
    "that is , a reset transition , by moving from state @xmath441 to state @xmath442 , resets every clock in @xmath70 to 0 and keeps all the other clocks unchanged .",
    "the stack content is modified according to the stack operation @xmath423 given on edge @xmath443 .",
    "clock values before the transition satisfy the invariant @xmath444 and the reset condition @xmath337 ; clock values after the transition satisfy the invariant @xmath445 .",
    "can also be assigned with a stack operation @xmath423 such that each progress transition by an amount @xmath435 on state @xmath426 also modifies the stack content according to @xmath423 . however , this progress transition can be treated as a sequence of three transitions : a progress transition ( without a stack operation ) by @xmath446 , a clock reset transition ( by adding a dummy clock ) performing stack operation @xmath423 , followed by a progress transition ( without a stack operation ) by @xmath447 , whenever @xmath448 . a translation can be worked out by expressing any pta with a stack operation for each progress transition by a pta defined in this paper . since we focus on the clock / stack behaviors of a pta , instead of the @xmath449-language accepted by it ,",
    "input symbols are not considered in our definition .",
    "( the input to a timed automaton is always one - way .",
    "thus , input symbols can always be built into states . ) ]    we write @xmath450 to be the transitive closure of @xmath451 .",
    "given two valuations @xmath452 and @xmath6 , two states @xmath453 and @xmath441 , and two stack words @xmath454 and @xmath455 , assume the auxiliary clock @xmath96 starts from 0 , i.e. , @xmath452 is initial .",
    "the following result is surprising .",
    "it states that , for * any * initialized pair @xmath365 with @xmath366 , @xmath456 if and only if @xmath457 @xmath458 this result implies that , from the definition of @xmath7 , for any fixed @xmath459 and @xmath455 , the pattern of @xmath460 ( instead of the actual values of @xmath461 and @xmath462 ) , the integral values @xmath463 , and the integral values @xmath235 are sufficient to determine whether @xmath464 can reach @xmath465 in @xmath416 .",
    "[ strongbisim ] let @xmath416 be a pta .",
    "for any states @xmath453 and @xmath441 , any two initial clock valuations @xmath452 and @xmath466 , any two clock valuations @xmath6 and @xmath184 , and any two stack words @xmath454 and @xmath455 , if @xmath366 , then , @xmath467    lemma [ backwards ] and lemma [ tests ] already give the result , but for @xmath451 instead of @xmath450 , noticing that lemma [ tests ] guarantees that tests ( and obviously stack operations ) are consistent in @xmath468 and in @xmath469 an induction ( on the length of @xmath450 ) can be used to show the lemma , by working from @xmath465 back to @xmath464 .",
    "[ ex100 ] it is the time to show an example to convince the reader that lemma [ strongbisim ] indeed works . consider a timed automaton @xmath416 shown in figure [ fig2 ] .",
    "let @xmath470 @xmath471 .",
    "@xmath472 is witnessed by : @xmath473 ( progress by @xmath474 at @xmath441 ) @xmath475 ( reset @xmath17 and transit to @xmath442 ) @xmath476 ( progress by @xmath477 at @xmath442 ) @xmath478 take a new pair @xmath479 @xmath480 it is easy to check @xmath481 . from lemma [ strongbisim ] , @xmath482 .",
    "indeed , this is witnessed by @xmath483 ( progress by @xmath484 at @xmath441 ) @xmath485 ( reset @xmath17 and transit to @xmath442 ) @xmath486 ( progress by @xmath487 at @xmath442 ) @xmath488 these two witnesses differ slightly ( @xmath474 and @xmath477 , vs. @xmath484 and @xmath487 ) .",
    "we choose @xmath487 and @xmath484 by looking at the first witness backwardly .",
    "that is , @xmath489 is picked such that @xmath490 .",
    "then , @xmath491 is picked such that @xmath492 .",
    "the existence of @xmath489 and @xmath491 is guaranteed by lemma [ backwards ] . finally , according to lemma [ backwards ] again , @xmath491 is able to go back to @xmath373 .",
    "this is because @xmath493 goes back to @xmath372 through a one - step transition and @xmath372 is initial .",
    "now , we express @xmath450 in a form treating the integral parts and the fractional parts of clock values separately . for any pattern @xmath360 , any discrete valuations @xmath494 and @xmath495 , and any stack words @xmath454 and @xmath455 , define @xmath496 to be @xmath497 @xmath498    [ character ] let @xmath416 be a pta .",
    "for any states @xmath453 and @xmath441 , any initialized pair @xmath144 , and any stack words @xmath454 and @xmath455 , @xmath499 iff @xmath500    ( @xmath501 ) is immediate .",
    "( @xmath502 ) uses the following observation ( from the definition of @xmath503 and lemma [ strongbisim ] ) : for any pattern @xmath136 , @xmath504 implies @xmath505 .",
    "once we give a characterization of @xmath503 , lemma [ character ] immediately gives a characterization for @xmath506 .",
    "fortunately , the characterization of @xmath503 is a decidable one , as shown in the next section .",
    "let @xmath507 be a pta specified in the previous section .",
    "the _ pattern graph _",
    "@xmath508 of @xmath416 is a tuple @xmath509 where    * @xmath418 is the states in @xmath416 , * @xmath174 is the set of all patterns .",
    "node _ is an element in @xmath510 , * _ discrete clocks _",
    "@xmath511 are the integral parts of the clocks @xmath340 in @xmath416 , * @xmath512 is a finite set of ( directed ) _ edges _ that connect between nodes .",
    "an edge can be a _ progress _ edge , a _",
    "stay _ edge , or a _ reset _ edge .",
    "a progress edge corresponds to progress transitions in @xmath416 that cause one pattern change .",
    "a stay edge corresponds to progress transitions in @xmath416 that cause no pattern change .",
    "since a progress transition can cause no pattern change only from a merge - pattern , a stay edge connects a merge - pattern to itself .",
    "a reset edge corresponds to a reset transition in @xmath416 .",
    "formally , a progress edge @xmath513 that connects node @xmath514 to node @xmath515 is in the form of @xmath516 such that @xmath517 , @xmath518 ( thus @xmath519 ) .",
    "a stay edge @xmath520 , with @xmath136 being a merge - pattern , that connects node @xmath514 to itself is in the form of @xmath521 such that @xmath517 .",
    "a reset edge @xmath522 that connects node @xmath514 to node @xmath523 is in the form of @xmath524 where @xmath525 and @xmath526 .",
    "@xmath512 is the set of all progress edges , stay edges , and reset edges wrt @xmath416 .",
    "obviously , @xmath512 is finite .",
    "a configuration of @xmath508 is a tuple @xmath527 of state @xmath528 , pattern @xmath360 , discrete valuation @xmath529 and stack word @xmath427 .",
    "@xmath530 denotes a _",
    "one - step transition _ through edge @xmath531 of @xmath508 if the following conditions are satisfied :    * if @xmath531 is a progress edge , then @xmath531 takes the form @xmath532 and @xmath533 , @xmath534 , @xmath535 , @xmath536 and @xmath537 . here",
    "@xmath356 and @xmath538 are called the _ pre- _ and the _ post- ( progress ) tests _ on edge @xmath531 , respectively . *",
    "if @xmath531 is a stay edge , then @xmath531 takes the form @xmath539 and @xmath540 and @xmath537 . here",
    "@xmath356 is called the _ pre- _ and the _ post- ( stay ) tests _ on edge @xmath531 . *",
    "if @xmath531 is a reset edge , then @xmath531 takes the form @xmath541 and @xmath542 , @xmath543 , @xmath544 and @xmath545 for some @xmath546 ( i.e. , @xmath547 changes to @xmath548 according to the stack operation ) . here",
    "@xmath549 and @xmath550 are called the _ pre- _ and the _ post- ( reset ) tests _ on edge @xmath531 , respectively .",
    "we write @xmath551 if @xmath552 for some @xmath531 .",
    "the binary reachability @xmath553 of @xmath508 is the transitive closure of @xmath554 .",
    "the pattern graph @xmath508 simulates @xmath416 in a way that the integral parts of the dense clocks are kept but the fractional parts are abstracted as a pattern .",
    "edges in @xmath508 indicate how the pattern and the discrete clocks change when a clock progress or a clock reset occurs in @xmath416 .",
    "however , a progress transition in @xmath416 could cause more than one pattern change . in this case , this big progress transition is treated as a sequence of small progress transitions such that each causes one pattern change ( and therefore , each small progress transition in @xmath416 can be simulated by a progress edge in @xmath508 ) .",
    "we first show that the binary reachability @xmath553 of @xmath508 is npca .",
    "observe that discrete clocks @xmath555 are the integral values of dense clocks @xmath340 . even though the dense clocks progress synchronously",
    ", the discrete clocks may not be synchronous ( i.e. , that one discrete clock is incremented by 1 does not necessarily cause * all * the other discrete clocks incremented by the same amount . ) .",
    "the proof has two parts . in the first part of the proof ,",
    "a technique is used to translate @xmath555 into another array of discrete clocks that are synchronous . in the second part of the proof",
    ", @xmath508 can be treated as a discrete pta @xcite by replacing @xmath555 with the synchronous discrete clocks .",
    "therefore , lemma [ presburger ] is obtained from the fact @xcite that the binary reachability of discrete pta is npca .",
    "@xmath553 is restricted in such a way that @xmath136 is a regulated pattern whenever @xmath556 .",
    "this is because the auxiliary clock @xmath96 in @xmath416 starts from 0 . ]",
    "[ presburger ] for any pta @xmath416 , the binary reachability @xmath553 of the pattern graph @xmath508 of @xmath416 is npca . in particular , if @xmath416 is a timed automaton , then the binary reachability @xmath553 is presburger .",
    "we start with a technique that makes discrete clocks @xmath511 ( i.e. , the integral parts of dense clocks ) synchronous on any path of @xmath508 .    a _ pattern ordering graph _",
    "@xmath557 is a directed graph on @xmath174 .",
    "for each ( ordered ) pair @xmath558 in @xmath559 , @xmath558 is a progress edge , written @xmath560 , if @xmath291 . in this case",
    ", we say the edge has label @xmath68 ( stands for  progress \" ) and @xmath253 is called the _",
    "@xmath68-successor _ of @xmath136 .",
    "@xmath558 is a reset edge with @xmath304 , written @xmath561 , if @xmath562 . in this case",
    ", we say the edge has label @xmath70 and @xmath253 is called the _",
    "@xmath70-successor _ of @xmath136 .",
    "an edge can have multiple labels .    a _ path _",
    "@xmath563 on @xmath557 is a sequence of edges @xmath564 such that each @xmath565 is a label ( either @xmath68 or some @xmath304 ) .",
    "@xmath255 _ is reset on path @xmath563 _ if @xmath566 for some @xmath39 .",
    "path @xmath563 is a _",
    "@xmath68-path _ if each edge on the path is a progress edge ; i.e. , label @xmath565 is @xmath68 for all @xmath39 .",
    "path @xmath563 is a _ regulated path _ if @xmath284 is a regulated pattern .",
    "path @xmath563 is a _",
    "@xmath68-ring of @xmath284 _ if @xmath563 is a @xmath68-path , and @xmath277 is the pattern ring of @xmath284 .",
    "now we augment @xmath557 with counters @xmath567 ( @xmath568 ) taking values in @xmath569 .",
    "values of counters @xmath567 change along a path in @xmath557 . for each progress edge @xmath560",
    ", counters @xmath567 change to @xmath570 as follows : @xmath571 ( recall @xmath572 is the increment vector for @xmath136 ) , consistent to the definition that @xmath573 . for each reset edge @xmath561 , counters @xmath567 change to @xmath570 as follows : @xmath574 , consistent to the definition that @xmath575 . for a @xmath68-path @xmath576",
    ", @xmath577 is the net increment for counters @xmath567 after walking through the path . in particular , @xmath578 for each @xmath68-ring @xmath563 .",
    "a progress edge @xmath560 is _ add-@xmath579 _ if @xmath253 is a regulated pattern .",
    "a path is _ short _ if it is a regulated path and , it does not contain an add-@xmath579 edge or it contains an add-@xmath579 edge but only at the end of the path .",
    "a path is _",
    "add-@xmath579 _ if it is a short path containing an add-@xmath579 edge . by definition , an add-@xmath579 path starts and ends with regulated patterns and each pattern in between along the path is not a regulated pattern .",
    "the following lemma is directly from the definitions of @xmath580 and @xmath246 .",
    "[ add1 ] for any path @xmath563 , ( 1 ) .",
    "if @xmath563 is a short path , then for each @xmath120 that is reset on @xmath563 , @xmath41 has value 0 at the end of @xmath563 , ( 2 ) .",
    "if @xmath563 is an add-@xmath579 path , then for each @xmath120 that is not reset on @xmath563 , @xmath41 has progressed by exactly 1 at the end of @xmath563 .",
    "when walking along a path in @xmath557 , a counter in @xmath567 is always nondecreasing except sometimes it resets .",
    "however , counters @xmath567 are not synchronous : that one counter s advancing by 1 at some progress edge does not always cause * all * the other counters to advance by the same amount .",
    "now we are going to show that , on any regulated path , @xmath567 can be simulated by a set of synchronous counters @xmath581 .",
    "the ideas are as follows .",
    "let @xmath563 be any regulated path of @xmath557 .",
    "@xmath563 then can be concatenated by _",
    "segments _ : a number of add-@xmath579 paths followed by a short path .",
    "we introduce an increment vector @xmath582 to denote how much a counter in @xmath567 progresses on a segment . besides , we use @xmath583 to remember the indices @xmath120 that are reset on each segment .",
    "assume counters @xmath567 walk through @xmath563 and change counter values from @xmath106 to @xmath584 .",
    "then , in the simulation , counters @xmath585 starts from @xmath106 with @xmath586 and @xmath587 . after walking through @xmath563 ( while updating @xmath588 and @xmath589 along the path ) , counters @xmath585 have values satisfying @xmath590 .",
    "the simulation is defined by the following translation . for each progress edge @xmath560 ,",
    "the instruction @xmath571 is replaced by :    * if @xmath253 is a regulated pattern ( hence the edge is an add-@xmath579 edge ) , i.e. , the end of the current segment , then @xmath591 ( synchronous progress followed by resets ) ; @xmath592 ; @xmath593 ; * else , @xmath594 ; @xmath595 ; @xmath596 .    for each reset edge @xmath561 ,",
    "the instruction @xmath574 is replaced by :    * @xmath597 ; @xmath598 ; @xmath599 .",
    "obviously @xmath585 are synchronous .",
    "the correctness of the algorithm is stated as follows .",
    "* claim . * for any regulated path @xmath563 , @xmath600 at the end of @xmath563 .    given a regulated path @xmath563 . since @xmath563 can be split into a number of segments as mentioned before , and by looking at the translation , at the end of each add-@xmath579 path , @xmath586 and @xmath587 ( i.e. , the initial values for @xmath588 and @xmath589 ) .",
    "therefore , it suffices to show the claim for a segment , i.e. , a short path @xmath563 , by induction on the length of @xmath563 .",
    "notice that , from the translation , @xmath589 stands for the set of indices that has been reset on the short path ; @xmath588 stands for the increment that has been made on the short path for counters @xmath567 .",
    "the relationship between @xmath589 and @xmath588 is established in lemma [ add1 ] , which will be used in the proof .",
    "the claim trivially holds for @xmath563 with length 1 .",
    "assume the claim holds for short paths with length @xmath601 .",
    "now consider a short path with length @xmath602 .",
    "this path can be written as a short path @xmath563 followed by an edge @xmath531 of @xmath558 .",
    "note that , by the induction hypothesis , @xmath600 at @xmath136 ( the end of @xmath563 ) .",
    "now we are going to show @xmath603 where primed values are for node @xmath253 .",
    "if edge @xmath531 is a progress edge and @xmath253 is a regulated pattern , then , from the translation , @xmath604 , @xmath605 , @xmath606 , therefore ,    @xmath607 ( induction )    @xmath608 ( lemma [ add1](1 ) )    @xmath609 ( lemma [ add1](2 ) )    @xmath610 ( since @xmath611 )    @xmath612 .",
    "if the edge is a progress edge and @xmath253 is not a regulated pattern , then , from the translation , @xmath613 , @xmath614 , and @xmath615 .",
    "therefore ,    @xmath607 ( induction )    @xmath608 ( lemma [ add1](1 ) )    @xmath609 ( since @xmath614 , and @xmath615 )    @xmath612 .",
    "if the edge is a reset edge @xmath561 , then , from the translation , @xmath616 , @xmath617 , and @xmath618 . therefore ,    @xmath619 ( induction )    @xmath620    @xmath612 .",
    "hence , the claim holds .",
    "now we continue the proof of lemma [ presburger ] .",
    "let @xmath508 be the pattern graph of a timed automaton @xmath416 .",
    "a path in @xmath508 witnessing @xmath621 ( with @xmath136 being a regulated pattern ) between two configurations corresponds to a regulated path ( by properly adding stack operations ) in the pattern ordering graph @xmath557 . in above",
    ", we have demonstrated a technique such that counters @xmath622 can be simulated by synchronous counters @xmath581 using an increment vector @xmath623 and a reset set @xmath583 .",
    "the relationship between @xmath567 and @xmath585 is @xmath600 .",
    "tests in @xmath508 ( including all the pre- and post- ( progress , stay and reset ) tests ) are in the form of boolean combinations of @xmath624 , @xmath625 with @xmath191 and @xmath626 ( section [ ccp ] ) .",
    "since there are only a finite number of choices for @xmath589 and @xmath588 , these tests can be accordingly translated to tests on @xmath627 , using the relationship @xmath600 .",
    "observe that the translated tests are still in the form of boolean combinations of @xmath628 , @xmath629 with @xmath191 and with probably larger or smaller @xmath630 .",
    "since @xmath585 are synchronous , @xmath508 , with @xmath567 simulated by @xmath585 , is a discrete pta @xcite . in that paper",
    ", these synchronized discrete clocks @xmath585 can be further translated into reversal - bounded counters .",
    "hence , the binary reachability of a discrete pta is npca as shown in @xcite",
    ". therefore , the lemma follows by translating back from @xmath585 to @xmath567 using @xmath600 at the initial and at the end of the simulation ( this requires only a finite number of counter reversals ) .",
    "thus , @xmath553 is npca .",
    "in particular , when @xmath416 is a timed automaton , @xmath508 , with @xmath567 simulated by @xmath585 , is a discrete timed automaton @xcite . using the fact @xcite that the binary reachability of a discrete timed automaton is presburger , @xmath553 is also presburger after the translation from @xmath585 back to @xmath567 .    the following lemma states that @xmath508 faithfully simulates @xmath416 when the fractional parts of dense clocks are abstracted away by a pattern .",
    "[ presburgersimulation ] let @xmath416 be a pta with pattern graph @xmath508 .",
    "for any states @xmath453 and @xmath441 in @xmath418 , any pattern @xmath360 , any stack words @xmath454 and @xmath455 in @xmath37 , and any discrete valuation pairs @xmath631 with @xmath632 , we have , @xmath633    fix any states @xmath634 , any pattern @xmath360 , any stack words @xmath454 and @xmath455 in @xmath37 , and any discrete valuation pairs @xmath631 with @xmath632 .",
    "( @xmath501 ) . by the definition of @xmath635",
    ", there exists an initialized pair @xmath4 such that    * @xmath4 has pattern @xmath136 , * @xmath636 , * @xmath499 .    in order to show that @xmath637,\\up{\\v_0 } , w_0)\\to^*_g ( s_1 ,   [ ( \\v_0,\\v_1)],\\up{\\v_1 } , w_1)$ ] ( notice that @xmath638 $ ] ) , it suffices to show that each one - step transition in @xmath416 can be simulated by @xmath639 properly : for any valuations @xmath640 , any states @xmath426 and @xmath641 , and any stack words @xmath547 and",
    "@xmath548 , if @xmath642 then @xmath643,\\up{\\v } , w)\\to^*_g ( s',[(\\v_0,\\v')],\\up{\\v ' } , w')$ ] .    case 1 . for any valuation @xmath104 and state @xmath426 ,",
    "consider a progress transition in @xmath416 , @xmath425 @xmath644 , @xmath435 , such that ( by definition ) @xmath537 , and @xmath645 .",
    "let @xmath284 be the pattern of @xmath286 .",
    "if @xmath104 has no pattern change for @xmath218 , then @xmath284 must be a merge - pattern .",
    "this progress transition in @xmath416 can therefore be simply simulated by the stay edge in @xmath508 at state @xmath426 .",
    "if , however , @xmath104 has at least one pattern change for @xmath218 , then assume the @xmath68-ring of @xmath284 is @xmath646 .",
    "this progress transition in @xmath416 can be simulated by the following path consisting of progress edges in @xmath508 : looping along the @xmath68-ring for @xmath647 times on state @xmath426 in @xmath508 , followed by a prefix of the @xmath68-ring ended with the pattern @xmath648 , for some @xmath143 , of @xmath288 . from lemma [ progresspatternchange ] and lemma [ maxpatternchange ] ,",
    "it can be established @xmath649 through the path in @xmath508 , noticing that tests for @xmath650 are consistent in @xmath416 and @xmath508 ( lemma [ tests ] ) , and the stack word does not change for progress transitions in both @xmath416 and @xmath508 .",
    "case 2 . for any valuation @xmath104 and states",
    "@xmath426 and @xmath641 , consider a reset transition @xmath425 @xmath451 @xmath651 in @xmath416 such that ( by definition ) @xmath545 for some @xmath652 with @xmath526 , @xmath525 and @xmath653 , @xmath654",
    ". assume the pattern of @xmath286 is @xmath284 and the pattern of @xmath655 is @xmath656 .",
    "this reset transition in @xmath416 corresponds to the reset edge in @xmath508 : @xmath657 . from lemma [ resetpatternchange ]",
    ", it can be established @xmath658 through this edge , noticing that tests for @xmath659 and @xmath660 are consistent in @xmath416 and @xmath508 ( lemma [ tests ] ) , and the stack operations are the same in @xmath416 and @xmath508 .",
    "( @xmath502 ) .",
    "suppose @xmath661 .",
    "we would like to show @xmath662 pick any initial valuation @xmath5 such that @xmath176 has pattern @xmath177 and @xmath663 .",
    "suppose @xmath664 is a path ( in @xmath508 ) witnessing @xmath661 through edges @xmath665 such that @xmath666 and @xmath667 a path in @xmath416 @xmath668 is constructed as follows , where @xmath669 and each transition @xmath670 in @xmath416 corresponds to each edge @xmath671 in @xmath508 . from @xmath259 to @xmath275 , each @xmath671 belongs to one of the following three cases :    case 1 .",
    "@xmath671 is a progress edge in @xmath508 . in this case ,",
    "@xmath672 , @xmath673 , and @xmath674 .",
    "we pick @xmath670 to be a progress transition ( at state @xmath675 ) in @xmath416 from @xmath676 with an amount of @xmath218 that causes exactly one pattern change ( lemma [ maxpatternchange ] and lemma [ progresspatternchange ] ) .",
    "take @xmath677 .",
    "notice that both the progress edge and the progress transition do not change the stack content , i.e. , @xmath673 .",
    "@xmath671 is a stay edge in @xmath508 . in this case",
    ", @xmath678 must be a merge - pattern with @xmath673 and and @xmath674 .",
    "we pick @xmath670 to be a progress transition ( at state @xmath675 ) in @xmath416 from @xmath676 with an amount of @xmath218 that causes no pattern change ( lemma [ maxpatternchange ] ) . similarly to case 1 , @xmath673 .",
    "@xmath671 is a reset edge from state @xmath675 to state @xmath679 with clock resets @xmath70 in @xmath508 , then @xmath670 is the reset transition from state @xmath675 to state @xmath679 with clock resets @xmath70 in @xmath416 .",
    "notice that both @xmath671 and @xmath670 have the same stack operation .",
    "take @xmath680 and @xmath681 is the result of the stack operation on @xmath682 .",
    "notice that , for each @xmath683 ,    * @xmath684 has pattern @xmath648 , * @xmath685 .",
    "this can be shown using lemma [ progresspatternchange ] for case 1 , lemma [ maxpatternchange ] for case 2 , and lemma [ resetpatternchange ] for case 3 .",
    "therefore , this constructed path of @xmath416 keeps the exactly the same patterns and integral parts of clocks as well as the stack word as in the path for @xmath508 . from lemma [ tests ] ,",
    "clock tests ( and obviously the stack operations ) are consistent between the path in @xmath508 and the constructed path in @xmath416 .",
    "hence , @xmath635 since , by taking @xmath686 ,    * @xmath4 has pattern @xmath136 , * @xmath636 , * @xmath499 .",
    "now , we conclude this section by claiming that @xmath503 is npca by combining lemma [ presburger ] and lemma [ presburgersimulation ] .",
    "[ integral ] for any pta @xmath416 and any fixed pattern @xmath360 , @xmath503 is npca . in particular ,",
    "if @xmath416 is a timed automaton , then @xmath503 is presburger .",
    "recall that pta @xmath416 actually has clocks @xmath687 .",
    "@xmath96 is the auxiliary clock .",
    "the _ binary reachability _ @xmath688 of @xmath416 is the set of tuples @xmath689 such that there exist @xmath690 satisfying @xmath691 the main theorem of this paper gives a decidable characterization for the binary reachability as follows .",
    "[ main ] the binary reachability @xmath688 of a pta @xmath416 is @xmath12-definable . in particular ,",
    "if @xmath416 is a timed automaton , then the binary reachability @xmath688 can be expressed in the additive theory of reals ( or rationals ) and integers .    from lemma [ character ] ,",
    "@xmath688 is definable by the following formula : @xmath692    @xmath693 on integer variables @xmath694 ( over @xmath29 ) , and dense variables @xmath695 @xmath696 ( over @xmath697 ) , and on word variables @xmath547 and @xmath548 .",
    "this formula is equivalent to @xmath698 where @xmath699 stands for @xmath700 and @xmath701 stands for @xmath702 from the definition of patterns , @xmath703 , after eliminating the existential quantification , is a dense linear relation . on the other hand , @xmath704 ( after eliminating the existential quantification , from lemma [ integral ] and lemma [ basicprop ] ) is npca .",
    "therefore , @xmath688 is @xmath12-definable .",
    "in particular , if @xmath416 is a timed automaton , @xmath688 is @xmath12-definable by a formula in the additive theory of reals ( or rationals ) and integers .",
    "hence , @xmath688 itself can be expressed in the same theory .",
    "the importance of the above characterization for @xmath688 is that , from lemma [ basicprop ] , the emptiness of @xmath12-definable predicates is decidable . from theorem [ main ] and lemma [ basicprop ] ( 3)(4 ) , we have ,    [ verification ] the emptiness of @xmath705 with respect to a pta @xmath416 for any mixed linear relation @xmath48 is decidable .    the emptiness of @xmath705 is called a _ mixed linear property _ of @xmath416 .",
    "many interesting safety properties ( or their negations ) for ptas can be expressed as a mixed linear property .",
    "for instance , consider the following property of a pta @xmath416 with three dense clocks @xmath17 , @xmath706 and @xmath707 :     for any two configurations @xmath13 and @xmath14 with @xmath708 , if the difference between @xmath709 ( the value of clock @xmath707 in @xmath14 ) and @xmath710 ( the sum of clocks @xmath17 and @xmath706 in @xmath13 ) is greater than the difference between @xmath18 ( the number of symbol @xmath19 appearing in the stack word in @xmath13 ) and @xmath711 ( the number of symbol @xmath712 appearing in the stack word in @xmath14 ) , then @xmath713 is greater than 5 . \"",
    "the negation of this property can be expressed as the emptiness of @xmath714 where @xmath48 is the negation of a mixed linear relation ( hence @xmath48 itself is also a mixed linear relation ) : @xmath715 thus , from theorem [ verification ] , this property can be automatically verified .",
    "we need to point out that    * @xmath716 is a linear relation on both dense variables and discrete variables .",
    "thus , this property can not be verified by using the decidable characterization for discrete ptas @xcite , where only integer - valued clocks are considered . * even without clocks , @xmath717 expresses a non - regular set of stack word pairs .",
    "therefore , this property can not be verified by the model - checking procedures for pushdown systems @xcite . * even without the pushdown stack , @xmath718 ( by taking @xmath719 as a constant such as 0 ) is not a clock region , therefore , the classical region - based techniques can not verify this property .",
    "this is also pointed out in @xcite . * with both dense clocks and the pushdown stack , this property can not be verified by using the region - based techniques for timed pushdown systems @xcite .    when @xmath416 is a timed automaton , by theorem [ main ] , the binary reachability @xmath688 can be expressed in the additive theory of reals ( or rationals ) and integers . notice that our characterization is essentially equivalent to the one given by comon and jurski @xcite in which @xmath688 can be expressed in the additive theory of reals augmented with a predicate telling whether a term is an integer .",
    "because the additive theory of reals and integers is decidable @xcite , we have ,    [ comon ] the truth value for any closed formula expressible in the ( first - order ) additive theory of reals ( or rationals ) augmented with a predicate @xmath688 for a timed automaton @xmath416 is decidable .",
    "( also shown in @xcite )    for instance , consider the following property for a timed automaton @xmath416 with two real clocks :     there are states @xmath426 and @xmath641 such that , for any @xmath720 , there exists @xmath721 such that if @xmath722 can reach @xmath723 in @xmath416 , then @xmath724 . \"",
    "it can be expressed as @xmath725 and thus can be verified according to theorem [ comon ] .",
    "in this paper , we consider ptas that are timed automata augmented with a pushdown stack .",
    "a configuration of a pta includes a control state , finitely many dense clock values and a stack word . by introducing the concept of a clock pattern and using an automata - theoretic approach",
    ", we give a decidable characterization of the binary reachability of a pta .",
    "since a timed automaton can be treated as a pta without the pushdown stack , we can show that the binary reachability of a timed automaton is definable in the additive theory of reals and integers .",
    "the results can be used to verify a class of safety properties containing linear relations over both dense variables and unbounded discrete variables .",
    "a pta studied here can be regarded as the timed version of a pushdown machine .",
    "carefully looking at the proofs of the decidable binary reachability characterization , we find out that the underlying untimed machine ( e.g. , the pushdown machine ) is not essential .",
    "we can replace it with many other kinds of machines and the resulting timed system still has a decidable binary reachability characterization .",
    "we will summarize some of these machines in this section .    consider a class of machines * x*. we use * xcm * to denote machines in * x",
    "* augmented with reversal - bounded counters .",
    "we are looking at the binary reachability characterization of the timed version of machines in * x*. the characterization is established in the previous sections when * x * represents pushdown machines . in the proofs , a dense clock is separated into a fractional part and an integral part .",
    "the fractional parts of dense clocks are abstracted as a pattern and the integral parts are translated into synchronous discrete clocks , which are further translated into reversal - bounded counters @xcite .",
    "the result of the translation is the underlying untimed machine in * x * augmented with these reversal - bounded counters , i.e. , a machine in * xcm*. suppose a class of automata * y * accept the binary reachability of machines in * xcm*. in the case of * x * being pushdown machines , * xcm * represents npcms and * y * can be chosen as npcas ( it is known that the binary reachability of npcms can be accepted by npcas @xcite . ) .",
    "the fact that this * y * ( i.e. , npca ) satisfies lemma [ basicprop ] is the only condition we need in order to obtain the decidable reachability characterization in theorem [ main ] .",
    "definitions like npca predicates and @xmath12-definability can be accordingly modified into * y * predicates and ( * d+y*)-definability once * y * is clear .",
    "the above discussions give the following result .",
    "[ generaldense ] let * y * be a class of automata , * x * be a class of machines and * xcm * be the class of machines in * x * augmented with reversal - bounded counters . if , for each machine in * xcm * , an automaton in * y * can be constructed that accepts the binary reachability of the machine , and lemma [ basicprop ] holds ( replacing npca with * y * ) , then the binary reachability of the timed version of * x * is ( * d+y*)-definable .    notice that lemma [ basicprop ] ( 4 ) requires that the emptiness problem for * y * in theorem [ generaldense ] be decidable .",
    "theorem [ verification ] can be immediately followed from theorem [ generaldense ] for the timed version of * x*.      * npcm . here",
    "* y*=npca ; * ncm with an unrestricted counter .",
    "notice that the counter is a special case of a pushdown stack ( when the stack alphabet is unary ) . here , * y*=npca ; * finite - crossing ncm @xcite ( i.e. , ncm augmented with a finite - crossing read - only worktape .",
    "the head on the worktape is two - way , but for each cell of the tape , the head crosses only a bounded number of times . ) . here",
    ", * y * is finite - crossing ncas @xcite that are ncm augmented with a finite - crossing input tape .",
    "* reversal - bounded multipushdown machines @xcite that are multipushdown machines @xcite augmented with reversal - bounded counters . here ,",
    "* y * is reversal - bounded multipushdown automata @xcite .    let *",
    "x * be a class of machines .",
    "the pattern technique tells us that , for a decidable binary reachability characterization of the timed version of * x * , the density of clocks ( and even clocks themselves ) is not the key issue .",
    "this is because , using the technique , these dense clocks can be reduced to reversal - bounded integer counters .",
    "the key issue is whether * x * and its reversal - bounded version * xcm * have a decidable binary reachability characterization ( i.e. , the binary reachability can be accepted by a class * y * of automata with a decidable emptiness problem ) . in particular , when the binary reachability of * x * is effectively semilinear ( and hence the binary reachability is decidable ) , in most cases , the binary reachability of * xcm * is also effectively semilinear .",
    "such * x * includes all the machines mentioned above . in this case , once we can show the untimed machines in * x * have a decidable binary reachability characterization , we are getting really close to the decidable characterization for their timed version .",
    "but , we do have exceptions .",
    "for instance , consider * x * to be a finite state machine with a two - way read only worktape .",
    "* x * has a decidable binary reachability characterization ( witnessed by two - way multitape finite automata ) .",
    "however , augmenting * x * with reversal - bounded counters makes the binary reachability undecidable .",
    "the pitfall here is that a two - way tape makes reversal - bounded counters too powerful .",
    "in fact , the emptiness problem is undecidable for two - way automata augmented with reversal - bounded counters . in the case",
    "when there is only one reversal - bounded counter , the emptiness problem is decidable if the machines are deterministic .",
    "the nondeterministic case is still open @xcite .    in practice , augmenting timed automata with other unbounded data structures allows us to study more complex real - time applications .",
    "for instance , the decidable characterization of ptas makes it possible to implement a tool verifying recursive real - time programs containing finite - state variables against safety properties containing linear constraints over dense clocks and stack word counts .",
    "this tool will be a good complement to available tools for recursive finite state programs ( for _ regular _ safety properties , e.g. , termination ) @xcite . on the other hand , for the existing tools analyzing real - time systems ( such as uppaal @xcite and its extensions @xcite , trex @xcite , hytech @xcite , kronos @xcite ) , the traditional region - based technique used in the tools",
    "may be enhanced with the pattern technique .",
    "doing this makes it possible for the tools to verify complex timing requirements that may not be in the form of clock regions . the results in this paper can also be used to implement a model - checker for a subset of the real - time specification language astral @xcite .",
    "the subset includes history - independent astral specifications containing both dense clocks and unbounded discrete control variables .",
    "as mentioned in this section , the timed version of npcm ( i.e. , ptas further augmented with reversal - bounded counters ) also has a decidable characterization .",
    "this timed model has many important applications .",
    "for instance , a real - time recursive program ( containing unbounded integer variables ) can be automatically debugged using the reversal - bounded approximation ( i.e. , assign a reversal - bound to the variables ) . additionally , a free counter ( i.e. , an unrestricted counter ) is a special case for a pushdown stack ( when the stack alphabet is unary ) .",
    "therefore , this model can also be used to specify real - time systems containing a free counter and many reversal - bounded counters .",
    "it seems that  reversal - bounded counters \" appear unnatural and therefore their applications in practice are remote .",
    "however , a non - decreasing counter is also a reversal - bounded counter ( with zero reversal - bound ) .",
    "this kind of counters have a lot of applications .",
    "for instance , a non - decreasing counter can be used to count digital time elapse , the number of external events , the number of a particular branch taken by a nondeterministic program ( this is important , when fairness is taken into account ) , etc .",
    "for instance , consider a timed automaton with input symbols ( i.e. , a transition is triggered by an external event as well as the enabling condition ) .",
    "we use @xmath726 to denote the number of event @xmath19 occurred so far .",
    "the enabling condition of a transition , besides clock constraints , may also include comparisons of the counts @xmath726 against an integer constant and comparisons of one specific linear term @xmath727 ( on all @xmath726 ) against an integer constant .",
    "for instance , a transition may look like this ( in pseudo - code ) :      where @xmath17 and @xmath706 are dense clocks .",
    "notice that comparisons of the linear term @xmath731 against an integer constant may show up in other transitions .",
    "but this term is unique in the automaton : a comparison like @xmath732 that involves a different term @xmath733 can not be used in the enabling conditions of the automaton .",
    "this timed automaton is a standard timed automaton augmented with reversal - bounded counters @xmath726 ( which are non - decreasing ) and a free counter ( representing the linear term @xmath731 ) .",
    "hence , the following property can be automatically verified :      a future research issue is to investigate whether the decidable results @xcite for presburger liveness of discrete timed automata can be extended to timed automata ( with dense clocks ) using the technique in this paper .",
    "we are also going to look at the possibility of extending the approximation approaches for parameterized discrete timed automata @xcite to the dense clocks .",
    "this is particularly interesting , since the reachability set presented in @xcite is not necessarily semilinear .",
    "another issue is on the complexity analysis of the decision procedure presented in this paper .",
    "however , the complexity for the emptiness problem of npcas is still unknown , though it is believed that it can be derived along gurari and ibarra @xcite .",
    "the author would like to thank h. comon and o. h. ibarra for discussions on the topic of dense timed pushdown automata during cav00 in chicago , b. boigelot , p. san pietro and j. su for recent discussions on @xcite , j. nelson , f. sheldon and g. xie for reading an earlier draft of this paper .",
    "thanks also go to t. bultan , h. comon , j. esparza and k. larsen for comments on the short version of this paper presented in cav01 in paris .",
    "j. r. buchi , _  on a decision method in restricted second order arithmetic , \" _",
    "_ proceedings of the international congress on logic , method , and philosophy of sciences , _ stanford university press , pp . 1 - 12 , 1962                                                k. g. larsen , g. behrmann , ed brinksma , a. fehnker , t. hune , p. pettersson , and j. romijn , _  as cheap as possible : efficient cost - optimal reachability for priced timed automata , \" _ _ cav01 _ , lncs 2102 , pp . 493"
  ],
  "abstract_text": [
    "<S> we consider pushdown timed automata ( ptas ) that are timed automata ( with dense clocks ) augmented with a pushdown stack . </S>",
    "<S> a configuration of a pta includes a control state , dense clock values and a stack word . by using the pattern technique </S>",
    "<S> , we give a decidable characterization of the binary reachability ( i.e. , the set of all pairs of configurations such that one can reach the other ) of a pta . </S>",
    "<S> since a timed automaton can be treated as a pta without the pushdown stack , we can show that the binary reachability of a timed automaton is definable in the additive theory of reals and integers . </S>",
    "<S> the results can be used to verify a class of properties containing linear relations over both dense variables and unbounded discrete variables . </S>",
    "<S> the properties previously could not be verified using the classic region technique nor expressed by timed temporal logics for timed automata and ctl@xmath0 for pushdown systems . </S>",
    "<S> the results are also extended to other generalizations of timed automata .    </S>",
    "<S> # 1    # 1 # 1    p    v u # 1 </S>"
  ]
}