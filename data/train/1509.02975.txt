{
  "article_text": [
    "string similarity is a fundamental problem touching on computer science , bioinformatics , machine learning , and many other areas @xcite .",
    "most fast approaches to string similarity ( e.g. , bag - of - words or kernel methods ) are heuristic , whereas most theoretically grounded approaches to string similarity ( e.g. , kolmogorov complexity methods ) are slow . in this paper",
    ", we discuss a technique that bridges the gap , offering performance that can be tuned between linear and ( in a sufficiently optimized implementation ) subquadratic time while offering a clear interpretation in terms of combinatorial and information - theoretical primitives .",
    "our technique is particularly well suited for comparing words based on their local structure and is agnostic to global structure , which is particularly interesting for comparing strings / words encoding paths through digraphs with cycles ( e.g. , control flow graphs of computer programs ) or for streaming data .",
    "the paper is structured as follows .",
    "we begin by establishing notation and graph constructions in  [ sec : preliminaries ] before discussing basic combinatorial properties in  [ sec : combinatorics ] and our ultimate information - theoretical considerations in  [ sec : informationtheory ] . finally , we outline applications , focusing in particular on molecular phylogeny as an example where an approximate `` ground truth '' furnishes a basis for evaluating the performance of our approach and its comparison with conventional techniques .",
    "appendices on spin models as well as code for reproducing and extending our results are included .",
    "we begin with some preliminaries to establish basic definitions and notation .",
    "let @xmath0 and consider a finite set @xmath1 which we call an _ alphabet_. a _ word _ or _ string",
    "_ over @xmath2 of length @xmath3 is an element of @xmath4 ; a _ symbol _ is a word of length 1 .",
    "the word @xmath5 will typically be written as @xmath6 . with a slight abuse of notation ,",
    "we write @xmath7 .",
    "the _ concatenation _ of two words @xmath6 and @xmath8 is @xmath9 .    a _ cyclic word _ or _ necklace _",
    "@xcite of length @xmath3 is the set of cyclic shifts of a word .",
    "we shall engage in a minor abuse of notation by letting @xmath10 denote either a word or a cyclic word depending on context . if @xmath10 is cyclic , @xmath11 .",
    "recall that a _ quiver _ ( also known as a _ multidigraph _ , _ directed multigraph _ , etc . )",
    "@xmath12 is an ordered pair @xmath13 s.t .",
    "@xmath14 is a multiset over @xmath15 @xcite .",
    "the _ adjacency matrix _",
    "@xmath16 of @xmath12 is defined so that if there are @xmath17 edges from @xmath18 to @xmath19 , then @xmath20 .",
    "it is clear that a quiver may be reconstructed from its adjacency matrix and _ vice versa _ , so that we may write @xmath21 for a generic function @xmath22 without any ambiguity so long as either side is defined .",
    "furthermore , we may make the implicit identifications @xmath23 and @xmath24 for convenience .    for @xmath10 cyclic and @xmath25 , the _ _ order @xmath26 de bruijn quiver _ _ @xmath27 is given by    * @xmath28 ; * @xmath29 .",
    "that is , the edges of @xmath27 correspond to the subwords of length @xmath30 ( a / k / a _ @xmath30-grams _ ) of @xmath10 , with multiplicities counted .",
    "figure [ fig : atagtcandagtatc ] shows an example .",
    "@xmath31[d]_{{\\color{olive}ag@3 } } \\ar@/^1pc/@[red][dr]^{{\\color{red}at@1 } } & c \\ar@/^-1pc/@{-->}@[blue][l]_{{\\color{blue}ca@6 } }   & & a \\ar@/^-1pc/@[red][d]_{{\\color{red}ag@1 } } \\ar@/^1pc/@[green][dr]^{{\\color{green}at@4 } } & c \\ar@/^-1pc/@{-->}@[blue][l]_{{\\color{blue}ca@6 } } \\\\ g \\ar@/^-1pc/@[green][r]_{{\\color{green}gt@4 } }",
    "& t \\ar@/^1pc/@[orange][ul]^{{\\color{orange}ta@2 } } \\ar@/^-1pc/@[cyan][u]_{{\\color{cyan}tc@5 } } & & g \\ar@/^-1pc/@[orange][r]_{{\\color{orange}gt@2 } } & t \\ar@/^1pc/@[olive][ul]^{{\\color{olive}ta@3 } } \\ar@/^-1pc/@[cyan][u]_{{\\color{cyan}tc@5 } } } \\nonumber\\ ] ]    remarks .",
    "* the order 0 de bruijn quiver of a word @xmath10 has one vertex corresponding to the empty word and edges corresponding to each symbol in @xmath10 , with multiplicity . * if @xmath10 is a @xmath32-ary de bruijn sequence of length @xmath33 , then @xmath34 is the @xmath32-ary de bruijn graph with @xmath33 edges .",
    "* @xmath27 is _ eulerian _",
    "( i.e. , [ strongly ] connected and with indegrees equal to outdegrees , so that we may unambiguously write @xmath35 for either quantity at vertex @xmath36 ) iff @xmath10 contains every possible @xmath26-gram ( otherwise , there are isolated vertices , but we may elide this technicality without comment at times ) .",
    "an euler circuit on @xmath27 corresponds to a hamiltonian path on @xmath37 .",
    "these properties are why we deal with cyclic words .",
    "to begin this section , we remark that it is a concrete application ( though perhaps of sufficient generality as to border on a reformulation ) of the so - called _ transfer matrix _",
    "method @xcite .",
    "write @xmath38 iff @xmath39 .",
    "it is clear that @xmath40 is an equivalence relation ; denote the corresponding equivalence class of @xmath10 by @xmath41_k$ ] .",
    "let @xmath42_k|$ ] denote the number of cyclic words with the same order @xmath26 de bruijn quiver as @xmath10 .",
    "in order to compute @xmath43 it is convenient to consider the adjacency matrix @xmath44 .    if @xmath45 is a square matrix , write @xmath46 for the vector with components given by the diagonal entries of @xmath45 .",
    "if now @xmath47 denotes a vector of ones , then @xmath48 is the _",
    "laplacian _ of @xmath45 .",
    "we recall the following two classical theorems :    matrix - tree theorem .",
    "let @xmath12 be a quiver .",
    "the diagonal cofactors of @xmath49 are all equal to each other and to the number @xmath50 of directed spanning trees of @xmath12 oriented towards any fixed vertex .",
    "@xmath51    best [ de bruijn , van aardenne - ehrenfest , smith , and tutte ] theorem .",
    "let @xmath12 be an eulerian quiver .",
    "then the number @xmath52 of euler circuits of @xmath12 is @xmath53    these readily yield the following    corollary .",
    "@xcite let @xmath54 correspond to an eulerian de bruijn quiver .",
    "then @xmath55 here @xmath56 is the totient function , the gcd is defined elementwise and @xmath57 .",
    "the @xmath58 term dominates , giving the simple and effective approximation @xmath59 .",
    "we note that if @xmath12 is an eulerian ( not necessarily de bruijn ) quiver with adjacency matrix @xmath45 , then we may still write @xmath60 or @xmath61 for the rhs of . however , it is not necessary to directly interpret @xmath62 in this more abstract context , since any finite eulerian quiver can be embedded in some de bruijn quiver .",
    "sketch of proof .",
    "the formula is obvious when @xmath63 , as in this case every cyclic word in @xmath41_k$ ] corresponds to @xmath64 euler circuits . more generally , for @xmath65 , the term @xmath66 counts the cyclic words in @xmath41_k$ ] of period @xmath67 with multiplicity @xmath68 . since @xmath69 , the result follows .",
    "@xmath51      consider @xmath70 over @xmath71 .",
    "@xmath72 and @xmath73 are depicted in figure [ fig : abracadabra ] .",
    "@xmath74 & & c \\ar@/^1pc/[ld ] \\\\ & a \\ar@/^1pc/[ld ] \\ar[ld ] \\ar@(lu , ru ) [ ] \\ar[lu ] \\ar[ru ] & \\\\ b \\ar@/^-1pc/[rr ] \\ar@/^-2pc/[rr ] & & r \\ar[lu ] \\ar@/^1pc/[lu ]   } \\quad \\quad \\quad \\xymatrix@c=5 mm { & ad \\ar[ld ]   & & ca \\ar[ll ] & \\\\ da \\ar[rd ] & & aa \\ar[ld ] & & ac \\ar[lu ] \\\\ & ab \\ar[rd ] \\ar@/^-1pc/[rd ] & & ra \\ar[lu ] \\ar[ru ] & \\\\ & & br \\ar[ru ] \\ar@/^-1pc/[ru ] & & \\\\ } \\nonumber\\ ] ]    we have that @xmath75 where for convenience we have annotated matrix entries with subscripts corresponding to the 2-grams .",
    "it is easy to check that @xmath76 .",
    "meanwhile , the ordered tuple of vertex degrees ( i.e. , the row or column sums of @xmath45 ) is @xmath77 , so @xmath78 . therefore @xmath79 .",
    "the sum in equation has only a single term , corresponding to @xmath58 , and so @xmath80 . by noting the cycle structure of @xmath72",
    ", we can list the 12 elements of @xmath41_1 $ ] by hand . in the lexicographical order inherited from the usual order on @xmath2 ,",
    "these are :    [ cols=\"^,^,^,^,^,^,^,^,^,^,^,^ \" , ]     it is not difficult to similarly show that @xmath81 .    finally , consider @xmath82 .",
    "this is a degenerate case as the symbols @xmath83 and @xmath84 are not present , so that the de bruijn quiver is only _ componentwise eulerian _ :",
    "i.e. , the in- and outdegrees coincide , but some are zero , so that the quiver is not connected . taking @xmath85 ( or equivalently and perhaps more straightforwardly , modifying the laplacian by changing any zeros along the diagonal to ones ) to remedy this , we get that @xmath86",
    ". the ordered tuple of vertex degrees is @xmath87 , so @xmath88 and @xmath89 .",
    "as before , there is a single term in the sum for @xmath90 .",
    "the other element of @xmath91_1 $ ] is @xmath92 .",
    "@xmath51      consider @xmath93 , @xmath94 , and fix @xmath3 . if @xmath95 , let @xmath96 be the number of times that @xmath97 occurs in @xmath10 . because @xmath10 is cyclic , we must have @xmath98 , and @xmath99 .",
    "corresponds to the words @xmath100 and @xmath101 , and must be treated separately .",
    "] we have that @xmath102 , so @xmath103 .",
    "furthermore , @xmath104 and @xmath105 , so @xmath106 .",
    "it follows after a line or two of algebra that @xmath107    explicitly , for @xmath108 , we have the following table of values , with zeros omitted : ; ce16(j , k ) = cequiverentropy(a ) ; end , end , w = exp(ce16 ) ` ]    c c & @xmath109 + @xmath110 &    c | * 17p8 mm @xmath111 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 + 0 & 1 & & & & & & & & & & & & & & & & 1 + 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & + 2 & 7 & 12 & 17 & 20 & 23 & 24 & 25 & 24 & 23 & 20 & 17 & 12 & 7 & & & & + 3 & 22 & 55 & 90 & 120 & 140 & 147 & 140 & 120 & 90 & 55 & 22 & & & & & & + 4 & 43 & 120 & 212 & 280 & 309 & 280 & 212 & 120 & 43 & & & & & & & & + 5 & 42 & 126 & 210 & 245 & 210 & 126 & 42 & & & & & & & & & & + 6 & 22 & 56 & 75 & 56 & 22 & & & & & & & & & & & & + 7 & 4 & 7 & 4 & & & & & & & & & & & & & & + 8 & 1 & & & & & & & & & & & & & & & & +    summing over the table entries shows that there are 4116 distinct cyclic binary words of length 16 , a fact which can be confirmed via the cauchy - frobenius lemma .",
    "figure [ fig : gaussian ] shows results in the same vein for @xmath112 .",
    "it is evident that @xmath111 behaves very much like a gaussian , with the only significant qualitative difference resulting from the triangular domain .",
    "similar results hold for more general contexts , and this fact might enable analytical estimates for @xmath60 . @xmath51",
    "the _ order @xmath26 de bruijn entropy _ of a cyclic word @xmath10 is @xmath113 .    as in ",
    "[ sec : combinatorics ] , we may also consider the entropy of an eulerian quiver @xmath12 or of its adjacency matrix @xmath45 , written respectively @xmath114 and @xmath115 .",
    "typically the logarithm will be taken with base @xmath116 unless otherwise indicated .",
    "this definition evokes boltzmann s physical interpretation of entropy as the logarithm of the number of microscopic configurations of a system that are consistent with the system s macroscopic characterization . here ,",
    "the `` macroscopic characterization '' of @xmath10 is just @xmath27 , and `` microscopic configurations '' are just members of @xmath41_k$ ] .",
    "another perspective realizes this definition as an analogue for finite words of the capacity of the discrete noiseless channel _  la _",
    "shannon @xcite , or equivalently of the topological entropy of a subshift of finite type @xcite .",
    "recall now the context of  [ sec : example2 ] . in order to completely specify a cyclic binary word @xmath10",
    ", it suffices to specify both    * @xmath117 , which requires a total of @xmath118 bits ( because it requires @xmath119 bits to specify @xmath109 and @xmath120 bits to specify @xmath110 ) ; * the appropriate element of @xmath41_1 $ ] , which requires at most @xmath121 bits ( because there are roughly @xmath122 cyclic binary words of length @xmath3 ) .    in particular ,",
    "if @xmath123 , then we have the outline of a scheme for losslessly compressing @xmath10 ( the generalizations to @xmath124 and @xmath125 are not fundamentally different ) .",
    "note that while most words are too statistically uniform ( or more precisely , the adjacency matrices of their de bruijn quivers have elements that are too similar ) to be compressed in this way , in practice one is rarely interested in compressing statistically uniform data .",
    "indeed , we recall that a standard diagonal argument shows that any fixed compression scheme will fail to compress most data @xcite",
    ".    the perspective of algorithmic information theory hinted at here will directly motivate the definition of relative de bruijn entropy in  [ sec : relativedebruijnentropy ] .",
    "although the paper @xcite leverages the empirical probability distribution of @xmath26-tuples rather than the more detailed notion of de bruijn quivers , it nevertheless gives strong experimental evidence that the natural heuristic @xmath126 is a good approximation for the lower limit of a reasonably narrow range of maximally informative values of @xmath26 in practice . while this paper also discusses upper limits on this range , these depend on the particular word and are of less practical interest for the obvious reason that increasing @xmath26 requires more storage .",
    "a detailed analysis of the complexity of computing the de bruijn entropy is likely to be both more intricate and less informative than an experimental one , owing to the complex relationship between the local statistical behavior of words and their corresponding quiver connectivity structure as a function of @xmath26 ( this is particularly true for the relative de bruijn entropy , for which see below ) .",
    "however , we note that the dominant contribution to runtime is a matrix determinant ( note that forming the adjacency matrices of quivers of words can be done in linear time ) , and we briefly discuss its complexity here .",
    "let @xmath127 denote the exponent for the complexity of matrix multiplication / inversion / determinant evaluation ( say , 3 or perhaps @xmath128 in practice , or @xmath129 in theory @xcite ) .",
    "now @xmath130 determines @xmath26 s.t .",
    "computing the de bruijn entropy requires linear time with standard techniques of linear algebra ( e.g. , computing the determinant via lu or qr decomposition as in our current implementation ) .",
    "meanwhile , as pointed out in  [ sec : maximallyinformativevaluesofk ] , a reasonable rule of thumb for the maximally informative value of @xmath26 is @xmath131 .",
    "these two observations can be combined by thinking of @xmath26 as a scale below which where we have complete information about the structure of words and of @xmath132 as a scale above which negligible information suitable for comparisons between words is discernable in linear time using standard techniques of linear algebra .",
    "that is , the computation of a de bruijn entropy can be _ forced _ to run in linear time by choosing @xmath133 ( or , for that matter , @xmath134 ) , with the consequence that this amounts to neglecting not only correlations at scales greater than @xmath26 ( as usual ) , but also the ability to capture statistical fluctuations _ of any sort _ at scales beyond @xmath132 . insisting on @xmath126 means in practical terms that our technique requires cubic time in the implementation used here .",
    "however , it is possible to do better , though for the sake of keeping this paper reasonably circumscribed we will confine ourselves here to a brief discussion .",
    "the reader will probably have noticed the phrase `` standard techniques of linear algebra '' repeated above , and considered the associated references to matrix decompositions for computing a determinant in ( what is in practice ) cubic time .",
    "in fact the determinant can be evaluated in less than @xmath135 time : it can be done in @xmath136 or even @xmath137 time using so - called _ black box linear algebra _ @xcite .",
    "the key here is that a diagonal minor @xmath138 of the laplacian has a predetermined sparse structure , so that the oracle @xmath139 can be realized in subquadratic time .",
    "this faciliates the computation of the characteristic polynomial of @xmath138 using so - called _ superfast _ toeplitz solvers in @xmath137 time @xcite , from which the determinant follows trivially .",
    "thus although our current implementation essentially has cubic time complexity for maximally informative values of @xmath26 , it can already be regarded as having linear complexity for @xmath26 independent of @xmath3 , and a sufficiently optimized linear algebra subroutine would yield complexity that is just the product of a linear and a polylogarithmic term in the general regime of interest , rendering it competitive with bag - of - words or kernel methods @xcite that have linear complexity but weaker or more _ ad hoc _ theoretical justification .",
    "write @xmath140 where the maxima are taken elementwise .",
    "it is easy to see that if @xmath45 and @xmath141 both correspond to componentwise eulerian quivers , then so does @xmath142 .",
    "indeed , this is the adjacency matrix of the quiver that naturally corresponds to @xmath143 after reversing edges with negative matrix entries .. if @xmath45 and @xmath141 both correspond to eulerian ( resp .",
    ", componentwise eulerian ) quivers , then so does @xmath144 .",
    "the operations @xmath145 and @xmath146 therefore induce an abelian semigroup structure on the set of ( possibly degenerate ) eulerian quivers and an abelian group structure on the set of ( possibly degenerate ) componentwise eulerian quivers . ]    with this in mind , let @xmath147 be adjacency matrices respectively corresponding to eulerian quivers @xmath148 , so that @xmath149 is a componentwise eulerian quiver with corresponding adjacency matrix @xmath45 .",
    "define @xmath150 and @xmath151 to avoid degeneracies , we define @xmath152 and @xmath153 , where here @xmath17 is the @xmath154 adjacency matrix corresponding to the quiver @xmath155 with a single vertex and @xmath156 edges ( i.e. , loops ) .",
    "this definition extends the prior one from eulerian quivers to componentwise eulerian quivers .",
    "note that @xmath157 and @xmath158 , so that @xmath159 .",
    "suppose now that we have two cyclic words @xmath10 and @xmath160 over @xmath2 .",
    "given @xmath10 and therefore also @xmath161 , all that is needed to determine @xmath162 is the difference @xmath163 , or equivalently the two nonnegative matrices @xmath164 \\vee 0 ; \\\\",
    "a_k(w'|w ) & : = & [ a_k(w')-a_k(w ) ] \\vee 0.\\end{aligned}\\ ] ] in order to completely specify @xmath160 given @xmath10 , it therefore suffices to specify @xmath165 , @xmath166 , and a number of roughly @xmath167 bits .",
    "it is clear that @xmath168 .",
    "if @xmath160 is far from statistically uniform , then there will be some critical value @xmath169 s.t .",
    "@xmath170 ( note that @xmath171 ) . at this point",
    "all the information in @xmath160 that is not latent in @xmath10 is encoded in the matrices @xmath165 and @xmath166 . in other words ,",
    "the conditional kolmogorov complexity @xmath172 as well as the information distance @xcite can be approximated by a function of these matrices .",
    "this motivates the following    definition .",
    "the _ order @xmath26 relative de bruijn entropy _ of @xmath160 given @xmath10 is @xmath173 , where @xmath174 .",
    "more generally , the relative entropy of @xmath141 given @xmath45 is defined as @xmath175 .",
    "note that ( unlike the kullback - leiber incarnation of relative entropy for probability distributions ) the relative entropy of componentwise eulerian quivers is symmetric .",
    "our experiments have shown that it is however not a pseudometric : i.e. , it does not satisfy the triangle inequality .",
    "nevertheless , it is straightforward to use the relative entropy to derive a pseudometric on a fixed set of words using the results of @xcite .      setting @xmath176 and @xmath177",
    ", we have that @xmath178 , where @xmath179 and @xmath180 , so @xmath181 .",
    "meanwhile , the ( levenshtein ) edit distance between @xmath182 and @xmath36 turns out to equal 5",
    ". it is evident at least in this particular case that the relative entropy better captures similarity in the local structure of words than an edit distance does .      for @xmath183 ,",
    "let @xmath184 and @xmath185 . for @xmath186 ,",
    "a straightforward ( if somewhat tedious ) calculation shows that @xmath187 , whereas the ( levenshtein ) edit distance between @xmath10 and @xmath160 is @xmath188 .",
    "that is , for @xmath26 and @xmath189 fixed we have that @xmath190 , whereas the corresponding edit distance is @xmath191 .",
    "figure [ fig : relative ] depicts the relative entropy @xmath192 of cyclic binary words @xmath193 as a function of @xmath194 and @xmath195 , where @xmath112 , @xmath196 , and @xmath197 .",
    "the relative entropy is zero along the strip @xmath198 ( and nowhere else ) .",
    "this is because in the strip , @xmath199 corresponds to coherently inserting and/or deleting only cyclic subwords of the form @xmath200 , @xmath201 , and @xmath202 . while there are generally many ways to do this , the cyclic subword @xmath203 satisfies @xmath204 .",
    "this in turn is a manifestation of the simple cycle structure of @xmath199 in the strip .",
    "the cycle structure of @xmath199 is also behind the more significant phenomenon of relative entropy values exceeding @xmath205 .",
    "this highlights the constraint that any modified relative de bruijn entropies of the form @xmath206 should be such that @xmath207 is still a componentwise eulerian adjacency matrix .",
    "molecular phylogenetics  i.e . , the analysis of evolutionary relationships based on hereditary molecular characteristics  and biological classification of organisms typically focus on comparing dna sequences @xcite . a particularly convenient form of dna for this purposes is mitochondrial dna ( mtdna ) .",
    "mtdna is an extremely economical repository of information in that nearly every base pair in human mtdna is known to code for some protein or rna product , and there is even overlap between coding regions ; meanwhile mammalian mtdna sequences are only on the order of 20k base pairs .",
    "moreover , mtdna is not highly conserved and mutates rapidly .    in figures [ fig : k7avg ] and [ fig : k7avgnorm ] below we show that relative de bruijn entropy produces results comparable if not superior to an edit distance ( cf . figure [ fig : ldavg ] ) for constructing phylogenetic trees that easily capture most of the evolutionary relationships among primates ( cf .",
    "figures [ fig : primatetree ] and [ fig : comparison ] ) from mtdna sequences alone .",
    "furthermore , the comparative performance of the relative entropy is likely to improve in other problem domains that can actually leverage the fact that the relative entropy captures local correlations while ignoring global correlations ( cf . ",
    "[ sec : vet ] ) .",
    "it is worth noting that the technique outlined here is _ alignment - free _",
    "@xcite , and a suitable implementation optimized for speed ( which our current implementation certainly is not , cf . ",
    "[ sec : computationalcomplexity ] ) is a promising candidate tool for bioinformatics . in particular",
    ", it is an attractive alternative to current techniques such as those in @xcite and the older but perhaps conceptually closer approach of @xcite .",
    "we note also that de bruijn quivers have been considered in the context of multiple alignment @xcite .",
    "there are numerous downstream applications of textual comparison , e.g. authorship attribution ( see , e.g. , @xcite )",
    ". it may be fruitful to engage in a dramatic simplification of textual comparison at large scales with relative de bruijn entropy by , e.g. , working with the results of part - of - speech tagging ( perhaps focusing in particular on function words versus content words ) .",
    "another possibility is to omit or `` do nt care '' words that do not frequently occur in a corpus and treat the words themselves as symbols in a very large alphabet while keeping the order of the induced quivers very small .      notwithstanding the interesting applications discussed above ,",
    "the _ raison dtre _ of the present paper is the anticipated application of its theory to the low - level behavioral analysis of computer programs of unknown provenance .",
    "although the general problem of disassembly of binary executable code is undecidable , interactive disassembly and automated reverse engineering techniques can facilitate static code analysis .",
    "in particular , a disassembled binary executable program may be conveniently represented in a platform - independent intermediate language such as reil @xcite or an enhanced variant called power - reil ( preil ) . in turn , individual machine - level instructions ( or short sequences of them ) can be mapped to a reduced set of behaviors , which serve as the symbols in a prospective alphabet .",
    "one or more of these behaviors or symbols may serve as a flavor of `` do nt care '' .",
    "an abstract view of the preceding enterprise consists of annotating ( a suitable coarse - graining of ) the program s control flow graph with the appropriate behaviors : vertices are annotated with a control flow behavior , and edges are annotated with a sequence of other behaviors .",
    "specific executions of the program correspond to walks in the control flow graph , which induce corresponding sequences of behaviors  i.e .",
    ", words over the behavior alphabet",
    ". broad coverage of the control flow graph can be accelerated through dynamic execution @xcite .",
    "at this point one has a set of words corresponding to representative program behavior sequences . comparing these ( or extracted subwords ) to words containing exemplars of bad behavior",
    "can then inform security assessments @xcite .",
    "the rationale for using relative de bruijn entropy here versus a more familar construct such as edit distance is straightforward .",
    "the relative de bruijn entropy compares all of the local structure of words while remaining agnostic to the global structure .",
    "because of this , it is particularly well suited to comparing words corresponding to different paths through a control flow graph , where `` motifs '' may appear with greater location variability than in biological sequences . _ in particular",
    ", it is natural to expect that loops containing complex sub - flow graphs are better suited to analysis with relative de bruijn entropy than an edit or dynamic programming metric on words .",
    "_    the authors are grateful to r. ross for his helpful comments and assistance .",
    "prior conversations between the first author and h. fredricksen and d. h. wood also substantively informed the discussion here .",
    "we are also grateful to referees of words 2015 , where a brief version of this paper was presented .",
    "in this appendix , we briefly mention the simple connection ( via the transfer matrix method ) of de bruijn quivers and entropies with the physics of finite one - dimensional spin models .    a _ local potential _ of order @xmath26 is a function @xmath208 .",
    "the corresponding _ energy _ of a cyclic word @xmath10 with @xmath209 is @xmath210 a probability distribution of the form @xmath211 over cyclic words of some fixed length @xmath3 defines the _ canonical ensemble _ of a circular one - dimensional _ spin model _ , or more generally a gibbs field @xcite . in statistical physics , @xmath212 , where @xmath213 is the boltzmann constant",
    ", @xmath214 is the absolute temperature , and the normalizing factor @xmath215 is the so - called _",
    "partition function_. it turns out that every quantity of physical interest ( e.g. , entropy , internal energy , free energy , etc . ) can be computed from a system s partition function , and its determination is correspondingly the central goal of statistical physics @xcite .    for example , taking @xmath93 , @xmath216 , and @xmath217 reproduces the 1d ( spin-1/2 ) ising model describing model magnetic systems . here the spins @xmath218 represent magnetic dipoles , @xmath219 represents the strength of the dipole - dipole coupling , and @xmath220 represents the external magnetic field .",
    "another example is furnished by taking @xmath221 and defining a local potential by the nearest - neighbor gibbs free energy parameters quantitatively describing oligomeric dna hybridization @xcite .",
    "and @xmath222 could reflect bending and torsional degrees of freedom .",
    "however , since the bending and torsional modes are so much more easily excited than the vibrational modes , there is unlikely to be any significant improvement from addressing such considerations . ]",
    "the transfer matrix method facilitates the calculation of @xmath223 and its limit as @xmath224 .",
    "for example , it is a standard result that for the 1d ising model @xmath225 the particular flavor of transfer matrix method embodied in enables the exact calculation of @xmath223 for @xmath226 by noting that @xmath227 along with @xmath228 this is superfically rather different than writing an expression of the form @xmath229 as per a typical application of the transfer matrix method in physics , but in fact both approaches turn out to have the same essential content and structure @xcite .",
    "nb . matlab code detailed in  [ sec : matlabcode ] is called throughout this section .",
    "the figures in  [ sec : example2 ] were generated using the following matlab commands :    .... a1 = 4*[2,5;5,4 ] ; l = sum(sum(a1 ) ) ;    % 256 e = nan(l/2,l ) ; ce = nan(l/2,l ) ; e2 = nan(l/2,l ) ; ce2 = nan(l/2,l ) ; for j = 1:l/2     for k = 1:(l-1 )         [ j k ] % for tracking progress         a2 = [ k-1,j;j , l-(k-1)-2*j ] ; % same length         aa = max(a1-a2,0 ) ;         ab = max(a2-a1,0 ) ;         a = aa'+ab ;         if any(any(a2<0 ) ) % then a2 is ill - formed         else             e(j , k ) = equiverentropy(a ) ;             ce(j , k ) = cequiverentropy(a ) ;         end         e2(j , k ) = equiverentropy(a2 ) ;         ce2(j , k ) = cequiverentropy(a2 ) ;     end end    h = ce2/log(2 ) ; figure;[c , h ] = contour(h,16:16:256,'k ' ) ; clabel(c,'manual ' ) ; hold;plot((1:l/2),l/2-(1:l/2)+1,'k : ' ) ; set(gca,'xtick',0:32:256 ) set(gca,'ytick',0:32:128 ) xlabel('x_0_0 ' ) ; ylabel('x _ * ' ) ; title('h_1 = log_2 w_1 ' ) ;    hmid = mean(h(:,[l/2,l/2 + 1]),2 ) ; ind = find(~isnan(hmid ) ) ; p = polyfit(ind , hmid(ind),2 ) ; figure;plot(1:4:(l/2),hmid(1:4:end),'ko',1:(l/2),p(1)*(1:(l/2)).^2+p(2)*(1:(l/2))+p(3),'k : ' ) ; axis([0 l/2 0 l ] ) ; set(gca,'xtick ' , [ ] ) ; set(gca,'ytick ' , [ ] ) ; xlabel({'x _ * with ( x_0_0,x _ * ) intermittently sampled','along vertical domain bisector ' } ) ; h = legend('h_1 = log_2 w_1','naive quadratic fit',4 ) ; pvert = p ;    hmid = mean(h([l/4,l/4 + 1],:),1 ) ; ind = find(~isnan(hmid ) ) ; p = polyfit(ind , hmid(ind),2 ) ; figure;plot(ind(1:8:end),hmid(ind(1:8:end)),'ko',1:l , p(1)*(1:l).^2+p(2)*(1:l)+p(3),'k : ' ) ; axis([0 l",
    "l/2 l ] ) ; set(gca,'xtick ' , [ ] ) ; set(gca,'ytick ' , [ ] ) ; xlabel({'x _ * with ( x_0_0,x _ * ) intermittently sampled','along horizontal domain bisector ' } ) ; h = legend('h_1 = log_2 w_1','naive quadratic fit',4 ) ; phorz = p ;    [ x , y ] = meshgrid(1:l,1:l/2 ) ; x2 = x+(x.*y)./(l/2-y ) ; y2 = y ; ind = intersect(find(~isnan(h)),find(~isinf(x2 ) ) ) ; w = griddata(x2(ind),y2(ind),h(ind),x , y ) ;    figure;[c , h ] = contour(w,16:16:l,'k ' ) ;   clabel(c,'manual ' ) ; hold;plot(1:l , l/4,'k-- ' ) ; g = phorz(1)*x.^2+phorz(2)*x+phorz(3)+pvert(1)*y.^2+pvert(2)*y+pvert(3 ) ; g = g/2 ;     % horz and vert double count [ c2,h2 ] = contour(g,[224,240],'r ' ) ; clabel(c2,'manual','color','r ' ) ; set(gca,'xtick',0:32:256 ) set(gca,'ytick',0:32:128 ) xlabel('(1+x_*/(l/2-x_*))x_0_0 ' ) ; ylabel('x _ * ' ) ; title('black",
    ": h_1 = log_2 w_1 ; red : contours of naive quadratic fit ' ) ; ....    width 0.4pt      figure [ fig : relative ] in  [ sec : example5 ] was generated using the following matlab commands :    .... a1 = 4*[2,5;5,4 ] ; l = sum(sum(a1 ) ) ; % 256 ce = nan(l/2,l ) ; ce2 = nan(l/2,l ) ; for j = 1:l/2     for k = 1:(l-1 )         [ j k ] % for tracking progress         a2 = [ k-1,j;j , l-(k-1)-2*j ] ; % same length         aa = max(a1-a2,0 ) ;         ab = max(a2-a1,0 ) ;         a = aa'+ab ;         if any(any(a2<0 ) )         else             ce(j , k ) = cequiverentropy(a ) ;         end         ce2(j , k ) = cequiverentropy(a2 ) ;     end end    ll = nan(l/2,l ) ; lm = nan(l/2,l ) ; for j = 1:l/2     for k = 1:(l-1 )         a2 = [ k-1,j;j , l-(k-1)-2*j ] ; % same length         aa = max(a1-a2,0 ) ;         ab = max(a2-a1,0 ) ;         a = aa'+ab ;         if any(any(a2<0 ) )         else             ll(j , k ) = sum(sum(a ) ) ;             lm(j , k ) = 1 ;         end     end end    delta = l/8 ; figure ;   contourf(ce / log(2),[l , l],'k','linecolor','none ' ) ; colormap(gray ) ; hold ; [ c , h ] = contour(ce / log(2),delta : delta:2*l,'k ' ) ; contour(ll,[l , l],'r ' ) caxis([0 l*1.25 ] ) ; set(gca,'xtick',1:delta:(l+1),'xticklabel',0:delta : l ) set(gca,'ytick',0:delta/2:l/2 ) xlabel('x''_0_0 ' ) ; ylabel('x '' _ * ' ) ; title('h_1(w''||w ) with x_0_0 = 32 and x _ * = 80 ' ) ; clabel(c,'manual ' ) ....    width 0.4pt      the following commands were applied to two input text files : ` genbankfile ` and ` fastafile ` , which respectively contained 109 genbank and fasta - formatted mtdna sequences of a broadly representative set of primates , and obtained as described in the code comments in  [ sec : fastaparse ] . `",
    "genbankfile ` was used purely for its annotations ; the remainder of the analysis used ` fastafile ` .",
    "the computation required less than 2 hours in a single matlab session on a standard laptop and automatically generated figures [ fig : k7avg ] and [ fig : k7avgnorm ] .",
    "figure [ fig : ldavg ] was generated along similar lines using data produced by the second author from a levenshtein distance routine in python that is not included here .",
    ".... % % preliminaries fp = fastaparse(fastafile ) ; n = length(fp.seq ) ; kmax = 7 ; alpha = ' acgtn ' ; % % radix word quivers for k = 1:kmax      for j = 1:n          rwq{k}{j } = radixwordquiver(fp.seq{j},k , alpha ) ;           [ j , k ] % for tracking progress      end   end disp('radix word quivers done ' ) ; % % entropies of individual words for k = 1:kmax      h1{k } = zeros(1,n ) ;       for j = 1:n          h1{k}(j ) = cequiverentropy(rwq{k}{j } ) ;      end      k % for tracking progress end disp('individual entropies done ' ) ; % % relative entropies for k = 1:kmax      h{k } = zeros(n ) ;       for ja = 1:n          for jb = ja : n              m = boxminus(rwq{k}{ja},rwq{k}{jb } ) ;              h{k}(ja , jb ) = cequiverentropy(m ) ;          end          [ ja , k ] % for tracking progress      end      h{k } = h{k}+h{k } ' ; end disp('relative entropies done ' ) ; % % construct radix quivers for concatenated words and compute their entropy % this is significantly more efficient than forming the radix quivers   % directly n = length(alpha ) ; for k = 1:kmax      for i = 1:n          u = fp.seq{i } ;          au = rwq{k}{i } ;          for j = i : n              v = fp.seq{j } ;              av = rwq{k}{j } ;              crwq = concatenateradixwordquiver(u , v , au , av , alpha ) ;              hcrwq{k}(i , j ) = cequiverentropy(crwq ) ;          end          [ i , k ] % for tracking progress      end      % symmetrize and avoid double - counting the diagonal      hcrwq{k } = hcrwq{k}+hcrwq{k}'-diag(diag(hcrwq{k } ) ) ; end disp('concatenated radix quivers and entropies done ' ) ; % % linkages for k = 1:kmax      sf{k } = squareform(h{k } ) ;      sfnorm{k } = squareform(h{k}./hcrwq{k } ) ;      tree{k } = linkage(sf{k } ) ;      treeav{k } = linkage(sf{k},'average ' ) ;      treecp{k } = linkage(sf{k},'complete ' ) ;      treenorm{k } = linkage(sfnorm{k } ) ;      treenormav{k } = linkage(sfnorm{k},'average ' ) ;      treenormcp{k } = linkage(sfnorm{k},'complete ' ) ;      k % for tracking progress end disp('linkages done ' ) ; % % taxonomic info % genus / species for j = 1:n      i1 = max(strfind(fp.desc{j},'|'))+2 ;      i2 = min(strfind(fp.desc{j},'mitochondrion , complete genome'))-1 ;      desc{j } = fp.desc{j}(i1:i2 ) ;       [ genus{j},remain ] = strtok(desc{j } , ' ' ) ;      species{j } = strtok(remain , ' ' ) ;       genusspecies{j } = [ genus{j } , ' ' , species{j } ] ; end % other info taxa = genbankorganism(genbankfile ) ; % exclude taxonomic info above order ( for primates ) for j = 1:n      taxa{j } = taxa{j}(10:end ) ; end % % produce phylogenetic trees phylotree(treeav{kmax},genusspecies , taxa ) ; phylotree(treenormav{kmax},genusspecies , taxa ) ; phylotree(treenormcp{kmax},genusspecies , taxa ) ; ....    width 0.4pt",
    "% given two compatible outputs of radixwordquiver , this rapidly produces   % the quiver corresponding to the concatenation of the underlying words .",
    "% that is , given words u , v with corresponding radix word quiver matrices % au , av , the rwq matrix for uv is auv = au+av+b , where b corresponds to   % the deletion of 2k edges and the insertion of 2k ( typically different )   % edges .",
    "note that this is symmetric because the cyclic word uv equals the   % cyclic word vu .",
    "% alpha is the alphabet used to construct au and av .",
    "% example : % i1 = 56 ; i2 = 78 ; % temp = concatenateradixwordquiver(fp.seq{i1},fp.seq{i2 } , ... %      rwq{3}{i1},rwq{3}{i2},'acgtn ' ) ; % temp2 = radixwordquiver([fp.seq{i1},fp.seq{i2}],3,'acgtn ' ) ; % temp - temp2 % should be zero ( as when tested at time of writing )    % % rudimentary error checking s = size(au ) ; n = length(alpha ) ; k = fix(log(s(1))/log(n ) ) ; if any(s - size(av ) )      error('incompatible sizes ' ) ; elseif s(1)-s(2 )      error('not square ' ) ; elseif abs(k - log(s(1))/log(n ) ) > 10 ^ -6      error('k not an integer ' ) ; end    % % other preliminaries nary = n.^((k-1):-1:0 ) ' ; lu = length(u ) ; lv = length(v ) ; % map letters to 0:(n-1 ) u = zeros(size(u ) ) ; v = zeros(size(v ) ) ; for j = 1:n      u(u==alpha(j))=j-1 ;      v(v==alpha(j))=j-1 ; end uu = [ u , u ] ; vv = [ v , v ] ; uv = [ u , v ] ; vu = [ v , u ] ; % initialize sparse matrix b = sparse(n^k , n^k ) ;    % % deletions for j = 1:k      del01 = uu((lu - k+j):(lu-1+j))*nary ;      del11 = uu((lu - k+j+1):(lu+j))*nary ;      b(del01 + 1,del11 + 1 ) = b(del01 + 1,del11 + 1)-1 ;       del02 = vv((lv - k+j):(lv-1+j))*nary ;      del12 = vv((lv - k+j+1):(lv+j))*nary ;      b(del02 + 1,del12 + 1 ) = b(del02 + 1,del12 + 1)-1 ;   end    % % insertions for j = 1:k      ins01 = uv((lu - k+j):(lu-1+j))*nary ;      ins11 = uv((lu - k+j+1):(lu+j))*nary ;      b(ins01 + 1,ins11 + 1 ) = b(ins01 + 1,ins11 + 1)+1 ;       ins02 = vu((lv - k+j):(lv-1+j))*nary ;      ins12 = vu((lv - k+j+1):(lv+j))*nary ;      b(ins02 + 1,ins12 + 1 ) = b(ins02 + 1,ins12 + 1)+1 ;   end              % basic care has been exercised to ensure that most of the computation time   % is spent on the fundamental determinant evaluation instead of , e.g. ,   % computing a gcd or the sum of log - factorial terms .",
    "there is probably % still room for improvement though .",
    "% % basic error checking if size(a,1)-size(a,2 )      error('a not square ' ) ; end deg1 = sum(a,1 ) ; deg2 = sum(a,2 ) ' ; if any(deg1-deg2 )      error('a not eulerian ' ) ; end if any(any(a<0 ) )      warning('negative entry ' ) ; y = nan ; return ; end if ~any(any(a ) )      y = 0 ; return ; end        % % find g = gcd(a ) non - recursively ( for speed ) and construct its divisors % this approach is much faster in matlab than a recursive gcd , let alone % one that does n't restrict consideration to unique nonzero entries of a. % in , e.g. , c this would not be the correct approach [ j , k ] = find(a ) ; g = 1 ; if numel(j )      % form vertical array of relevant entries      ajk = a(sub2ind(size(a),j , k ) ) ;      % only consider the unique values in ajk ( note that these are sorted      % from smallest to largest ) .",
    "this approach appears to be faster      % than , e.g. , omitting [ j , k ] = find(a ) , changing \" if numel(j ) \" to       % \" if any(a ) \" and setting ajk = setdiff(unique(a),0 ) ;      ajk = unique(ajk ) ;      % the gcd must be a divisor of ajk(1)--so first form all the divisors      divajk1 = divisors(ajk(1 ) ) ;      % now just look for any remainders under trial division of the entries       % of a by each divisor      for k = 1:numel(divajk1 )          if ~mod(ajk , divajk1(k ) )              g = divajk1(k ) ;           end      end end div = divisors(g ) ; nd = numel(div ) ;    % % totient of each divisor phi = ones(1,nd ) ; for k = 1:nd      d = div(k ) ;      fd = factor(d ) ;      ufd = unique(fd ) ;      nufd = length(ufd ) ;      phi(k ) = 1 ;      for m = 1:nufd          nm = sum(fd==ufd(m ) ) ;          phi(k ) = phi(k)*max((ufd(m)^(nm-1))*(ufd(m)-1),1 ) ;      end end    % % compute the entropy h = 0 ;   % the initialization to 0 vs -inf is ameliorated at the very end for k = 1:nd      d = div(k ) ;      ad = a / d ;      degd = sum(ad,2 ) ' ;   % = sum(ad,1 )      l = diag(degd)-ad ;      l2 = l(2:end,2:end ) ;      % % compute log(det(l2 ) ) with a modicum of care      % a naive yet nontrivial approach would be to compute      %     logt = real(trace(logm(full(l2 ) ) ) ) ;      % but this is bad : logm requires a full matrix and it 's a      % computationally nasty way to do things -- though not quite as bad as      %     logt = log(det(l2 ) ) ;      % we can do better with a sparse lu decomposition      %     [ ll , ul , pl , ql , rl ] = lu(l2 ) ;      %     logt = sum(log(abs(diag(ul))))+sum(log(abs(diag(rl ) ) ) ) ;      % though on at least one occasion this gave the error message       % \" sparse lu failed . \"",
    "this error was not found on the internet and no      % real attempt was made to understand it -- instead we use the      % perfunctory remedy of a try - catch block to deal with it below using      % the alternative of the q - less sparse qr decomposition , e.g.      %     rl = qr(l2 ) ;      %     logt = sum(log(abs(diag(rl ) ) ) ) ;      % which folklore suggests is more stable -- though testing indicates that      % this is also much slower .",
    "%      % we could go much deeper down the rabbit hole , exploiting the sparsity      % and integrality of l with great sophistication by , e.g. using       % chinese remaindering / lifting and/or smith normal forms ) . a partial      % bibliography of relevant references follows :      % \\bibitem{panyustewart}pan , v. y. , yu , y. , and stewart , c. `` algebraic      % and numerical techniques for the computation of matrix      % determinants . '' \\emph{comp .",
    "{ \\bf 34 } , 43 ( 1997 ) .",
    "% \\bibitem{kaltofenvillard}kaltofen , e. and villard , g. `` computing the      % sign or the value of the determinant of an integer matrix , a      % complexity survey . ''",
    "\\emph{j . comp .",
    "appl . math . } { \\bf 162 } , 133      % ( 2004 ) .",
    "% \\bibitem{ogita}ogita , t. `` exact determinant of integer matrices . ''",
    "% \\emph{proc .",
    "workshop on reliable engineering computing . }      % ( 2010 ) .",
    "% \\bibitem{elsheikhetal}elsheikh , m. \\emph{et al . }",
    "`` fast computation      % of smith forms of sparse matrices over local rings . ''",
    "\\emph{isaac }      % ( 2012 ) .",
    "% \\bibitem{eberlyetal}eberly , w. \\emph{et al .",
    "} `` faster inversion and      % other black box matrix computations using efficient block      % projections . ''",
    "\\emph{isaac } ( 2007 ) .",
    "% \\bibitem{dumassaundersvillard}dumas , j .-",
    "g . , saunders , b. d. , and      % villard , g. `` on efficient sparse integer matrix smith normal form      % computations . '' \\emph{j .",
    "symb . comp . }",
    "{ \\bf 32 } , 71 ( 2001 ) .",
    "try           % nb .",
    "it may be advantageous to permute l2 , but as yet we do n't          [ ll , ul , pl , ql , rl ] = lu(l2 ) ;          logt = sum(log(abs(diag(ul))))+sum(log(abs(diag(rl ) ) ) ) ;      catch err          if ( strcmp(err.identifier,'matlab : sparselufactor : internalerror ' ) )              % try the supposedly more stable but slower q - less qr              rl = qr(l2 ) ;              logt = sum(log(abs(diag(rl ) ) ) ) ;          else              rethrow(err ) ;          end      end          % %      logc = logt+quicksumlogfactorial(degd-1,logfac ) ;      logfad = quicksumlogfactorial(ad , logfac ) ;      logterm = log(phi(k))+logc - log(d)-logfad ;      h = logplus(h , logterm ) ; end              fx = factor(x ) ; nf = numel(fx ) ; mask = zeros(2^nf , nf ) ; temp = dec2bin(0:((2^nf)-1),nf ) ; div0 = zeros(2^nf,1 ) ; for j = 1:2^nf      for k = 1:nf          mask(j , k ) = str2num(temp(j , k ) ) ;      end      div0(j ) = prod(max(mask(j,:).*fx,1 ) ) ; end y = unique(div0 ) ' ;                            % parses fasta format text file .",
    "the ( canonical ) example used here is a % file containing 616 complete mammalian mitochondrial genomes accessed   % 20140124 from the url % http://www.ncbi.nlm.nih.gov / nuccore/?term = mitochondrion[definition]+and+ \" % complete+genome\"[definition]+and+srcdb_refseq[properties]+and+mammalia[or % ganism ] %   % a smaller example is a file containing 109 complete primate genomes % accessed 20140205 from the url % http://www.ncbi.nlm.nih.gov / nuccore/?term = mitochondrion[definition]+and+ \" % complete+genome\"[definition]+and+srcdb_refseq[properties]+and+primates[or % ganism ]    % example usage for mtdna fasta files : % fp = fastaparse(fastafile ) ; % for j = 1:length(fp.desc ) %      i1 = max(strfind(fp.desc{j},'|'))+2 ;   %      i2 = min(strfind(fp.desc{j},'mitochondrion , complete genome'))-1 ; %      desc{j } = fp.desc{j}(i1:i2 ) ;   %      [ genus{j},remain{j } ] = strtok(desc{j } , ' ' ) ;   %      [ species{j},remain{j } ] = strtok(remain{j } , ' ' ) ; %      seq{j } = fp.seq{j } ; % end            % assemble components into sequences and their descriptions for j = 1:n      n = dline(j ) ;      s.desc{j } = strtrim(lb{n } ) ;      n = n+1 ;      s.seq{j } = '' ;      while n < dline(j+1 )          s.seq{j } = [ s.seq{j},strtrim(lb{n } ) ] ;          n = n+1 ;      end      % % for convenience replace any non - acgt characters with ' n '      s.seq{j } = regexprep(s.seq{j},'[^acgt]','n ' ) ; end                      n = length(orgline ) ; for j = 1:n      % get the first reference line after each organism line      nextrefline = refline(find(refline > orgline(j),1 ) ) ;      lines = ( orgline(j)+1):(nextrefline-1 ) ;      tax{j } = '' ;      for k = 1:numel(lines )          tax{j } = [ tax{j},strtrim(lb{lines(k ) } ) ] ;      end      tax{j } = strrep(tax{j } , ' ' , '' ) ;      tax{j } = strrep(tax{j } , ' . ' , '' ) ;      remain = tax{j } ;      k = 1 ;      while remain          [ taxa{j}{k},remain ] = strtok(remain , ' ; ' ) ;          k = k+1 ;      end end                                  % % preliminary plot figure ; [ h , t , outperm ] = dendrogram(tree,0,'orientation','right','labels',labs ) ; set(h,'color','k ' ) ; hold ; % plot geometry dar = get(gca,'dataaspectratio ' ) ; xyr = dar(1)/dar(2 ) ; xl = get(gca,'xlim ' ) ;        % % get children of jth internal node % nodes are 1:n for leaves and",
    "( n+1):(2*n-1 ) for internals , from bottom up .",
    "% i.e. , the shortest branches come from node n+1 , etc . for j",
    "= 1:n-1      children{j } = tree(j,1:2 ) ;      while any(children{j}>n )          % find next child with children ( an \" adult \" )          ind = find(children{j}>n,1,'first ' ) ;          % remove the adult and add its children          adult = children{j}(ind ) ;          children{j } = union(setdiff(children{j},adult),tree(adult - n,1:2 ) ) ;      end      end    % % for each internal node , find two key cell arrays of words % a : the intersection of taxa words under the node % b : the union of taxa words not under the node % along the way , find the union alltaxa of all taxa words for the tree alltaxa = { } ; % this loop builds a and alltaxa for j = ( n-1):-1:1      t = taxa{children{j}(1 ) } ;      alltaxa = union(alltaxa , t ) ;      a{j } = t ;      for k = 2:length(children{j } )          t = taxa{children{j}(k ) } ;          alltaxa = union(alltaxa , t ) ;          a{j } = intersect(a{j},t ) ;          % b0{j } = union(b0{j},t ) ;      end end % % this loop builds b for j = ( n-1):-1:1      otherchildren = setdiff(1:n , children{j } ) ;      b{j } = { } ;      for k = 1:length(otherchildren )          b{j } = union(b{j},taxa{otherchildren(k ) } ) ;      end end    % % for each internal node , its label is the \" highest - ranking \" member of a\\b for j = ( n-1):-1:1      % the first child is as good as any to use ...",
    "t = taxa{children{j}(1 ) } ;      c = setdiff(a{j},b{j } ) ;      label{j } = '' ;      for k = length(t):-1:1          if any(strcmp(t{k},c ) )              label{j } = t{k } ;          end      end end    % % add labels dx1 = .005*(xl(2)-xl(1 ) ) ; for j = 1:n-1      if length(label{j } )          x1 = tree(j,3)+2*dx1 ;          x2 = mean(invperm(children{j } ) ) ;          text(x1,x2,label{j},'fontunits','normalized','fontsize',1/n ) ;          x2max = max(invperm(children{j } ) ) ;          x2min = min(invperm(children{j } ) ) ;          x01 = x1-dx1 ;          plot([x01,x01],[x2min , x2max],'r ' ) ;      end end              % constructs a de bruijn quiver of order k for a word w over the alphabet % alpha , whose order is presumed to induce the lex order , which is used for % the adjacency matrix a that is actually returned .",
    "y = radixwordquiver('ggattaatgactaatcagc',1,'acgt ' ) ; % nb . instead of ' acgt ' for the last argument",
    ", it might be necessary to % use , e.g. ' acgtn ' , cf .",
    "fastaparse .",
    "% %   if numel(setdiff(unique(w),alpha ) )      setdiff(unique(w),alpha )      error('wrong alphabet ' ) ; end % alphabet radix n",
    "= length(alpha ) ; if n^k > 2 ^ 64      error('n^k > 2 ^ 64 ; try wordquiver instead ' ) ; end    % % preliminaries l = length(w ) ; % cheap proxy for cyclic word w = [ w , w(1:k ) ] ; % map letters to 0:(n-1 ) w = zeros(size(w ) ) ; for j = 1:n      w(w==alpha(j))=j-1 ; end % initialize sparse matrix a = sparse(n^k , n^k ) ;      % % main loop for j = 1:l      ind0 = ind1 ;      % get upcoming k - gram      j0 = j+1 ;      j1 = j+k ;      kg = w(j0:j1 ) ;      ind1 = kg*nary ;      % update the adjacency matrix      a(ind0 + 1,ind1 + 1 ) = a(ind0 + 1,ind1 + 1)+1 ; end                                      % % main loop for j = 1:l      kg0 = kg1 ;      ind0 = ind1 ;      % get upcoming k - gram      j0 = j+1 ;      j1 = j+k ;      kg1 = w(j0:j1 ) ;      % see if we 've encountered the upcoming k - gram before      ind1 = find(strcmp(kg1,kgs ) ) ;      nind1 = numel(ind1 ) ;      if nind1 = = 1    % we 've seen the upcoming k - gram before ...",
    "% ... so do nothing      elseif nind1 = = 0    % we haven't seen it yet , so include it ...",
    "ind1 = length(kgs)+1 ;          kgs{ind1 } = kg1 ;          % ... and appropriately expand the adjacency matrix          a(ind1,ind1 ) = 0 ;         else     % something is amiss          error('more than one index ' ) ;      end      % update the adjacency matrix      a(ind0,ind1 ) = a(ind0,ind1)+1 ; end"
  ],
  "abstract_text": [
    "<S> we introduce the notion of _ de bruijn entropy _ of an eulerian quiver and show how the corresponding relative entropy can be applied to practical string similarity problems . </S>",
    "<S> this approach explicitly links the combinatorial and information - theoretical properties of words and its performance is superior to edit distances in many respects and competitive in most others . </S>",
    "<S> the computational complexity of our current implementation is parametrically tunable between linear and cubic , and we outline how an optimized linear algebra subroutine can reduce the cubic complexity to approximately linear . </S>",
    "<S> numerous examples are provided , including a realistic application to molecular phylogenetics . </S>"
  ]
}