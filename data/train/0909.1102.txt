{
  "article_text": [
    "pushdown automata ( pdas ) ( or recursive state machines ; rsms ) are a natural model for sequential programs with recursive procedure calls , and their verification problems have been studied extensively .",
    "the complexity of model checking problems for pdas is quite well understood : the reachability problem for pdas can be solved in polynomial time @xcite .",
    "model checking modal @xmath2-calculus over pdas was shown to be @xmath9-complete in @xcite , and the global version of the model checking problem has been considered in @xcite .",
    "the @xmath9 lower bound for model checking pdas also holds for the simpler logic @xmath0 and its fragment eg @xcite , even for a fixed formula ( data complexity ) or a fixed pda ( expression complexity ) .",
    "on the other hand , model checking pdas against the logic @xmath4 ( another natural fragment of @xmath0 ) is @xmath1-complete @xcite , and again the lower bound still holds if either the formula or the pda is fixed @xcite .",
    "model checking problems for various fragments and extensions of pdl ( propositional dynamic logic ) over pdas were studied in @xcite .",
    "one - counter processes ( ocps ) are minsky counter machines with just one counter and action labels on the transitions .",
    "they can also be seen as a special case of pdas with just one stack symbol , plus a non - removable bottom symbol which indicates an empty stack ( and thus allows to test the counter for zero ) and hence constitute a natural and fundamental computational model . in recent years",
    ", model checking problems for ocps received increasing attention @xcite .",
    "clearly , all upper complexity bounds carry over from pdas .",
    "the question , whether these upper bounds can be matched by lower bounds was just recently solved for several important logics : model checking @xmath2-calculus over ocps is @xmath1-complete .",
    "the @xmath1 upper bound was shown in @xcite , and a matching lower bound can easily be shown by a reduction from emptiness of alternating unary finite automata , which was shown to be @xmath1-complete in @xcite .",
    "this lower bound even holds if either the ocp or the formula is fixed .",
    "the situation becomes different for the fragment @xmath4 . in @xcite",
    ", it was shown that model checking @xmath4 over ocps is in the complexity class @xmath10 ( the class of all problems that can be solved on a deterministic polynomial time machine with access to an oracle from @xmath11 ) . moreover ,",
    "if the input formula is represented succinctly as a dag ( directed acyclic graph ) , then model checking @xmath4 over ocps is also hard for @xmath10 . for the standard ( and less succinct ) tree representation for formulas , only hardness for the class @xmath12}$ ] (",
    "the class of all problems that can be solved on a deterministic polynomial time machine which is allowed to make @xmath13 many queries to an oracle from @xmath11 ) was shown in @xcite .",
    "in fact , there already exists a fixed @xmath4 formula such that model checking this formula over a given ocp is hard for @xmath12}$ ] , i.e. , the data complexity is @xmath12}$]-hard .    in this paper",
    "we consider the model checking problem for @xmath0 over ocps . by the known upper bound for the modal @xmath2-calculus @xcite this problem belongs to @xmath1 .",
    "first , we analyze the combinatorics of @xmath0 model checking over ocps .",
    "more precisely , we analyze the periodic behaviour of the set of natural numbers that satisfy a given @xmath0 formula in a given control location of the ocp ( theorem  [ thm - ctl - periodic ] ) . by making use of theorem  [ thm - ctl - periodic ]",
    ", we can derive a model checking algorithm whose running time is exponential only in the number of control locations and a syntactic measure on @xmath0 formulas that we call leftward until depth ( theorem  [ ctl upper bound_0 ] ) . as a corollary",
    ", we obtain that model checking a fixed ocp against @xmath0 formulas of fixed leftward until depth lies in @xmath3 ( corollary  [ ctl upper bound ] ) .",
    "this generalizes a recent result from @xcite , where it was shown that the expression complexity of @xmath4 over ocps lies in @xmath3 .",
    "next , we focus on lower bounds .",
    "we show that model checking @xmath0 over ocps is @xmath1-complete , even if we fix either the ocp ( theorem  [ theo - ctl - expression ] ) or the @xmath0 formula ( theorem  [ theo ctl data ] ) . the proofs for theorem  [ theo - ctl - expression ] uses an intriguing reduction from qbf .",
    "we have to construct a fixed ocp for which we can construct for a given unary encoded number @xmath14 @xmath0 formulas that express , when interpreted over our fixed ocp , whether the current counter value is divisible by @xmath15 and whether the @xmath16 bit in the binary representation of the current counter value is @xmath8 , respectively . for the proof of theorem  [ theo ctl data ] ( @xmath1-hardness of data complexity for @xmath0 )",
    "we use two techniques from complexity theory , which to our knowledge have not been applied in the context of verification so far :    * the existence of small depth circuits for converting a number from chinese remainder representation to binary representation ( see section  [ sec - circuits ] for details ) and * the fact that @xmath1-computations are serializable in a certain sense ( see section  [ sec real ] for details ) .",
    "one of the main obstructions in getting lower bounds for ocps is the fact that ocps are well suited for testing divisibility properties of the counter value and hence can deal with numbers in chinese remainder representation , but it is not clear how to deal with numbers in binary representation .",
    "small depth circuits for converting a number from chinese remainder representation to binary representation are the key in order to overcome this obstruction .",
    "we are confident that our new lower bound techniques described above can be used for proving further lower bounds for ocps .",
    "we present two other applications of our techniques :    * we show that model checking @xmath4 over ocps is complete for @xmath10 even if the input formula is represented by a tree ( theorem  [ t ef ] ) and thereby solve an open problem from @xcite .",
    "figure  [ f model checking ] summarizes the picture on the complexity of model checking for pdas and ocps .",
    "* we improve a lower bound on a decision problem for one - counter markov decision processes from @xcite ( theorem  [ t valone ] ) .",
    "more details on this problem are provided below .",
    ".model checking over pda and ocp[f model checking ] ; our new results are marked with ( * ) . [",
    "cols=\"<,<,<\",options=\"header \" , ]     _ markov decision processes _ ( mdps ) extend classical markov chains by allowing so called _",
    "nondeterministic vertices_. in these vertices , no probability distribution on the outgoing transitions is specified .",
    "the other vertices are called _ probabilistic vertices _ ; in these vertices a probability distribution on the outgoing transitions is given .",
    "the idea is that in an mdp a player eve plays against nature ( represented by the probabilistic vertices ) . in each nondeterministic vertex @xmath17",
    ", eve chooses a probability distribution on the outgoing transitions of @xmath17 ; this choice may depend on the past of the play ( which is a path in the underlying graph ending in @xmath17 ) and is formally represented by a strategy for eve .",
    "an mdp together with a strategy for eve defines an ordinary markov chain , whose state space is the unfolding of the graph underlying the mdp . in section  [ s markov ] , we consider infinite mdps , which are finitely represented by one - counter processes ; this formalism was introduced in @xcite under the name _ one - counter markov decision process _",
    "( oc - mdp ) . for a given oc - mdp @xmath18 and a set @xmath19 of control locations of the ocp underlying @xmath18 ( a so called _ reachability constraint _ ) the following two sets @xmath20 and @xmath21 were considered in @xcite : @xmath20 is the set of all states @xmath22 of the mdp defined by @xmath18 such that for every @xmath23 there exists a strategy @xmath24 for eve under which the probability of finally reaching from @xmath22 a control location in @xmath19 and at the same time having counter value @xmath25 is at least @xmath26 .",
    "@xmath21 is the set of all states @xmath22 of the mdp defined by @xmath18 for which there exists a specific strategy for eve under which this probability becomes @xmath8 .",
    "it was shown in @xcite that for a given oc - mdp @xmath18 , a set of control locations @xmath19 , and a state @xmath22 of the mdp defined by @xmath18 ,    * the question whether @xmath27 is @xmath1-hard and in @xmath9 , and * the question whether @xmath28 is hard for every level of the boolean hierarchy @xmath29 .",
    "the boolean hierarchy is a hierarchy of complexity classes between @xmath30 and @xmath12}$ ] , see section  [ s tools ] for a definition .",
    "we use our lower bound techniques in order to improve the second hardness result for the levels of @xmath29 to @xmath1-hardness . as a byproduct",
    ", we also reprove @xmath1-hardness for @xmath21 . currently , it is open , whether @xmath20 is decidable ; the corresponding problem for mdps defined by pushdown processes is undecidable @xcite .",
    "the paper is organized as follows . in section  [ s pre ]",
    "we introduce general notation . in section  [ s ocp ctl ]",
    "we define one - counter processes and the branching - time logic @xmath0 .",
    "periodicity of @xmath0 on ocps and a derived model checking algorithm is content of section  [ s upper ] . in section  [ s expression ]",
    "we give a fixed one - counter net ( which is basically a one - counter process that can not test if the counter is zero ) for which ctl model checking is @xmath1-hard . section  [ s tools ] recalls tools from complexity theory that we need in subsequent sections .",
    "we show that there already exists a fixed @xmath0 formula for which model checking over one - counter nets is @xmath1-hard in section  [ s data ] .",
    "finally , we apply our lower bound technique and provide two applications .",
    "we prove in section  [ s combined ] that model checking @xmath4 over one - counter nets is @xmath7-hard , thus matching the @xmath7 upper bound from @xcite . in section  [ s markov ]",
    "we show that membership in @xmath20 over one - counter markov decision processes is @xmath1-hard .",
    "[ s pre ]    we denote the naturals by @xmath31 and the rational numbers by @xmath32 . for each @xmath33",
    "we define @xmath34=\\{k\\in{\\mathbb{n}}\\mid i\\leq k\\leq j\\}$ ] and @xmath35=[1,j]$ ] .",
    "in particular @xmath36 = \\emptyset$ ] . for each @xmath37 and each position",
    "@xmath38 , let @xmath39 denote the @xmath16 least significant bit of the binary representation of @xmath40 , i.e. , @xmath41",
    ". for every finite and non - empty subset @xmath42 , define @xmath43 to be the _ least common multiple _ of all numbers in @xmath44 .",
    "due to a result of nair @xcite it is known that @xmath45)\\leq4^k$ ] for all @xmath46 . as usual , for ( a possibly infinite ) alphabet @xmath47 , @xmath48 denotes the set of all finite words over @xmath47 , @xmath49 denotes the set of all finite non - empty words over @xmath47 , and @xmath50 denotes the set of all infinite words over @xmath47 .",
    "let @xmath51 .",
    "the length of a finite word @xmath52 is denoted by @xmath53 . for a word @xmath54 ( resp .",
    "@xmath55 ) with @xmath56 and @xmath57 $ ] ( resp .",
    "@xmath38 ) , we denote by @xmath58 the @xmath16 letter @xmath59 . a ( possibly infinite ) directed graph @xmath60 ( with @xmath61 ) is called _ deadlock - free _ if for all @xmath62 there exists @xmath63 with @xmath64 . if for all @xmath62 there are only finitely many @xmath63 with @xmath64 , then @xmath65 is called _ image - finite_. the set of all _ finite paths in @xmath65 _ is the set @xmath66 : ( \\pi_i , \\pi_{i+1 } ) \\in e \\}$ ] .",
    "the set of all _ infinite paths in @xmath65 _ is the set @xmath67 .",
    "a nondeterministic finite automaton ( nfa ) is a tuple @xmath68 , where @xmath69 is a finite set of _ states _ , @xmath70 is a _ finite alphabet _ , @xmath71 is the _ transition relation _",
    ", @xmath72 is the _ initial state _ , and @xmath73 is a set of _ final states_. we assume that the reader has some basic knowledge in complexity theory , see e.g. @xcite for more details .",
    "[ s ocp ctl ]    fix some countable set @xmath74 of _ atomic propositions_. a _ transition system _ is a triple @xmath75 , where @xmath76 is a directed graph and @xmath77 for all @xmath78 with @xmath79 for all but finitely many @xmath80 .",
    "elements of @xmath69 ( resp .",
    "@xmath81 ) are also called _ states _ ( resp . _",
    "transitions _ ) . we prefer to use the infix notation @xmath82 instead of @xmath83 . for @xmath84 let @xmath85 . for a subset @xmath86 of states , a ( finite or infinite ) path @xmath87",
    "is called a _ @xmath88-path _ if @xmath89 .",
    "a _ one - counter process _ ( ocp ) is a tuple @xmath90 , where @xmath91 is a finite set of _ control locations _",
    ", @xmath92 for each @xmath80 but @xmath93 for all but finitely many @xmath80 , @xmath94 is a finite set of _ zero transitions _ , and @xmath95 is a finite set of _ positive transitions_. the _ size _ of an ocp is defined as @xmath96 .",
    "a _ one - counter net _ ( ocn ) is an ocp , where @xmath97 .",
    "a one - counter process @xmath90 defines a transition system @xmath98 , where @xmath99 if and only if either @xmath100 and @xmath101 , or @xmath102 and @xmath103 .",
    "more details on @xmath0 and @xmath4 can be found for instance in @xcite .",
    "_ formulas _ @xmath104 of the logic @xmath0 are given by the following grammar , where @xmath80 , @xmath105 given a transition system @xmath106 and a @xmath0 formula @xmath104 , we define the semantics @xmath107\\!]}_t\\subseteq s$ ] by induction on the structure of @xmath104 as follows : @xmath108\\!]}}}_t&\\   = \\ & s_p\\quad \\text{for each } p\\in{\\mathcal{p}}\\\\ { \\ensuremath{{[\\![}\\neg\\varphi { ] \\!]}}}_t & = & s\\setminus{\\ensuremath{{[\\![}\\varphi { ] \\!]}}}_t\\\\ { \\ensuremath{{[\\![}\\varphi_1\\wedge\\varphi_2 { ] \\!]}}}_t&= & { \\ensuremath{{[\\![}\\varphi_1 { ] \\!]}}}_t\\cap{\\ensuremath{{[\\![}\\varphi_2 { ] \\!]}}}_t\\\\ { \\ensuremath{{[\\![}\\exists{\\mathsf{x}}\\varphi { ] \\!]}}}_t & = & \\{s\\in s\\mid \\exists s'\\in{\\ensuremath{{[\\![}\\varphi { ] \\!]}}}_t : s\\rightarrow s'\\}\\ \\\\ { \\ensuremath{{[\\![}\\exists\\varphi_1\\u\\varphi_2 { ] \\!]}}}_t &   = &   \\{s\\in s\\mid \\exists   \\pi \\in \\path_+(t ) : \\pi_1 = s ,   \\pi_{|\\pi| } \\in{\\ensuremath{{[\\![}\\varphi_2 { ] \\!]}}}_t , \\forall i\\in[|\\pi|-1 ] : \\pi_i\\in{\\ensuremath{{[\\![}\\varphi_1 { ] \\!]}}}_t\\}\\\\ { \\ensuremath{{[\\![}\\exists\\varphi_1{\\mathsf{wu}}\\varphi_2 { ] \\!]}}}_t &   = &   { \\ensuremath{{[\\![}\\exists\\varphi_1\\u\\varphi_2 { ] \\!]}}}_t\\cup \\{s\\in s\\mid \\exists \\pi \\in \\path_\\omega(t ) : \\pi_1 = s ,   \\forall i\\geq 1 : \\pi_i\\in{\\ensuremath{{[\\![}\\varphi_1 { ] \\!]}}}_t\\}\\end{aligned}\\ ] ] we write @xmath109 as an abbreviation for @xmath110\\!]}}}_t$ ] . when additionally @xmath111 is clear from the context , we just write @xmath112 . we introduce the usual abbreviations @xmath113 , @xmath114 for some @xmath80 , @xmath115 , @xmath116 , and @xmath117 .",
    "formulas of the @xmath0-fragment @xmath4 are given by the following grammar , where @xmath80 , @xmath118 define the _ size _ @xmath119 of @xmath0 formulas @xmath104 inductively as follows : @xmath120 , @xmath121 , @xmath122 , @xmath123 , and @xmath124 .",
    "the goal of this section is to prove a periodicity property of @xmath0 over one - counter processes .",
    "we will use this property in order to establish an upper bound for @xmath0 on ocps , see theorem  [ ctl upper bound_0 ] . as a corollary",
    ", we show that for a fixed one - counter process , @xmath0 model checking restricted to formulas of fixed leftward until depth ( see the definition below ) can be done in polynomial time , see corollary  [ ctl upper bound ] . for this , let us define the _ leftward until depth @xmath125 _ of @xmath0 formulas inductively as follows : @xmath126 a similar definition of the until depth can be found in @xcite , but there the until depth of @xmath127 is 1 plus the maximum of the until depths of @xmath128 and @xmath129 .",
    "note that @xmath130 for each @xmath4 formula @xmath104 .",
    "let us fix some one - counter process @xmath131 for the rest of this section .",
    "let us introduce a bit more notation .",
    "let @xmath132 , let @xmath133 , and let @xmath134 ( resp .",
    "@xmath135 ) be a finite ( resp .",
    "infinite ) path in @xmath136 such that moreover @xmath137 for all @xmath14 .",
    "define @xmath138 to be the path that emerges from @xmath87 by replacing each @xmath139 by @xmath140 . for each position",
    "@xmath14 and @xmath141 of @xmath87 with @xmath142 , define @xmath143 $ ] to be the subpath of @xmath87 that begins in @xmath144 and that ends in @xmath145 .",
    "we aim to prove the following : for each @xmath0 formula @xmath104 we can compute some threshold @xmath146 and some period @xmath147 , where @xmath148 , such that for all @xmath37 with @xmath149 only @xmath40 s residue class modulo @xmath147 determines whether @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] or not , where @xmath151 is an arbitrary control location .",
    "the goal of this section is to give rather precise bounds on the size of the threshold @xmath146 and the period @xmath147 embracing the notion of leftward until depth from above .",
    "let us assume that @xmath152 .",
    "define @xmath153)$ ] and @xmath154 for each @xmath0 formula @xmath104 .",
    "[ thm - ctl - periodic ] let @xmath104 be a @xmath0 formula .",
    "then we can compute in polynomial time a threshold @xmath155 such that for all @xmath156 that satisfy @xmath157 we have @xmath158\\!]}}}_{t({\\mathcal{o}})}\\quad \\text{\\ if and only if\\ } \\quad   ( q , n')\\in{\\ensuremath{{[\\![}\\varphi { ] \\!]}}}_{t({\\mathcal{o}})}\\end{aligned}\\ ] ] for each control location @xmath151 .",
    "we prove the theorem by induction on the structure of @xmath104 .",
    "that @xmath159 can be computed in polynomial time will be obvious .",
    ". then we put @xmath161 .",
    "recall that @xmath162 .",
    "trivially , ( [ e period ] ) holds .",
    ". then we put @xmath164 .",
    "equation ( [ e period ] ) follows immediately by induction hypothesis .",
    ". then we put @xmath166 .",
    "we have @xmath167 and hence @xmath159 satisfies the requirement of the theorem .",
    "note that @xmath168 by definition . by choice of @xmath159 , equation ( [ e period ] ) holds immediately due to induction hypothesis .",
    "assume @xmath169 .",
    "then we put @xmath170 .",
    "thus we get @xmath171 and hence @xmath159 satisfies the requirement of the theorem . since @xmath172 , we have that ( [ e period ] ) follows immediately by induction hypothesis .",
    "assume @xmath173 .",
    "let us first define the threshold .",
    "let @xmath174 .",
    "we put @xmath175 .",
    "hence we have @xmath176 and thus @xmath159 satisfies the requirement of the theorem .",
    "it remains to prove ( [ e period ] ) .",
    "recall that @xmath177 by definition .",
    "let us fix an arbitrary control location @xmath151 and naturals @xmath178 such that @xmath179 and @xmath157 .",
    "we have to prove that ( [ e period ] ) holds , i.e. , @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] if and only if @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] . for this ,",
    "let @xmath181 , which is a multiple of @xmath182 .",
    "the current situation is shown in figure  [ f situation ] .",
    "( 200,250)(0,-20 )    ( li)(50,0 ) ( re)(163,0 ) ( u)(160,-1 ) ( o)(160,121 ) ( 170,230)counter value ( 163,-1)@xmath25 ( 155,109)@xmath183 ( 159,128)@xmath184 ( 70,-20)@xmath185 s control locations ( u1)(160,139 ) ( o1)(160,161 ) ( 155,149)@xmath183 ( 159,168)@xmath184 ( u2)(160,179 ) ( o2)(160,201 ) ( 155,189)@xmath183 ( u3)(160,199 ) ( o3)(160,230 ) ( n)(140,145)@xmath186 ( 144,143.5)@xmath40 ( n)(140,185)@xmath186 ( 144,183.5)@xmath187 ( 119,162)@xmath188 ( 50,0)(160,0)(160,40)(50,40 ) ( t)(195,40)@xmath174 ( 159,40)(161,40 ) ( tp)(195,99)@xmath175 ( 159,100)(161,100 ) ( 159,120)(161,120 ) ( 159,140)(161,140 ) ( 159,160)(161,160 ) ( 159,180)(161,180 ) ( 159,200)(161,200 ) ( li , re ) ( u , o ) ( u1,o1 ) ( u2,o2 ) ( u3,o3 ) ( 140,2)(140,-2 ) ( 141,-5)@xmath189    only - if :",
    "let us assume that @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "hence , there exists a finite path @xmath190 where @xmath191 , @xmath192 $ ] is a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path , @xmath194 , and @xmath195\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "now we make a case distinction .",
    "_ case a : _ @xmath196 for each @xmath197 $ ] .",
    "since @xmath198 and @xmath199 we obtain that @xmath200 witnesses @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] by induction hypothesis .",
    "this is depicted in figure  [ f delta ] .",
    "( 200,260)(0,-20 ) ( li)(50,0 ) ( re)(163,0 ) ( u)(160,-1 ) ( o)(160,121 ) ( 170,230)counter value ( 70,-20)@xmath185 s control locations ( 163,-1)@xmath25 ( 155,109)@xmath183 ( 159,128)@xmath184 ( u1)(160,139 ) ( o1)(160,161 ) ( 155,149)@xmath183 ( 159,168)@xmath184 ( u2)(160,179 ) ( o2)(160,201 ) ( 155,189)@xmath183 ( u3)(160,199 ) ( o3)(160,230 ) ( n)(140,145)@xmath186 ( 144,143.5)@xmath40 ( n)(140,185)@xmath186 ( 144,183.5)@xmath187 ( 120,100)@xmath87 ( 100,155)@xmath200 ( 140,145)(120,90)(100,105)(80,62)(100,80)(60,102)(40,144 ) ( 140,185)(120,130)(100,145)(80,102)(100,120)(60,142)(40,184 ) ( 50,0)(160,0)(160,40)(50,40 ) ( 140,2)(140,-2 ) ( 141,-5)@xmath189 ( t)(195,40)@xmath174 ( 159,40)(161,40 ) ( tp)(195,99)@xmath175 ( 159,100)(161,100 ) ( 159,120)(161,120 ) ( 159,140)(161,140 ) ( 159,160)(161,160 ) ( 159,180)(161,180 ) ( 159,200)(161,200 ) ( li , re ) ( u , o ) ( u1,o1 ) ( u2,o2 ) ( u3,o3 )    _ case b : _ @xmath201 for some",
    "@xmath197 $ ] . for each of @xmath87 s counter values @xmath202\\}$ ] ,",
    "define @xmath203\\mid n_i = h\\}\\ ] ] to be the minimal position in @xmath87 whose corresponding state has counter value @xmath204 .",
    "we are interested in @xmath87 s first states of counter value @xmath205 , and so on . for this , define @xmath206 for every appropriate @xmath207 . by the pigeonhole principle , there are distinct @xmath208 $ ] such that @xmath209 and @xmath210 .",
    "note that @xmath211 and @xmath212 are well - defined since @xmath213 let @xmath214 and @xmath215 $ ] .",
    "hence , @xmath216 divides @xmath217",
    ". moreover , let @xmath24 denote @xmath87 s subpath from @xmath218 down to @xmath219 , i.e. , formally @xmath220 $ ] .",
    "the current situation is depicted in figure  [ f catch ] .",
    "the path @xmath24 is indicated thick .",
    "( 200,340)(0,-20 ) ( li)(50,0 ) ( re)(163,0 ) ( u)(160,-1 ) ( o)(160,121 ) ( 170,340)counter value ( 163,-1)@xmath25 ( 155,109)@xmath183 ( 159,128)@xmath184 ( u1)(160,139 ) ( o1)(160,161 ) ( 155,149)@xmath183 ( 159,228)@xmath184 ( u2)(160,209 ) ( o2)(160,241 ) ( 155,309)@xmath183 ( u3)(160,279 ) ( o3)(160,340 ) ( n)(140,145)@xmath186 ( 144,143.5)@xmath40 ( n)(140,305)@xmath186 ( 144,303.5)@xmath187 ( 50,0)(160,0)(160,40)(50,40 ) ( 70,-20)@xmath185 s control locations ( 140,2)(140,-2 ) ( 141,-5)@xmath189 ( 105,2)(105,-2 ) ( 106,-5)@xmath221 ( mi1)(105,100)@xmath186 ( 92,93)@xmath222 ( mi1)(105,260)@xmath186 ( 92,253)@xmath223 ( mi2)(105,60)@xmath186 ( 77,53)@xmath224 ( 140,305)(130,340)(135,290)(110,285)(105,260 ) ( 87,265)(105,220)(87,225)(105,180)(87,185)(105,140)(87,145)(105,100)(104.9,100.1 ) ( 140,145)(130,180)(135,130)(110,125)(105,100)(87,105)(105,60)(70,102)(78,30)(130,49)(150,11)(75,25 ) ( 105.2,101)(105,100)(87,105)(105,60)(104.7,60.42 ) ( t)(195,40)@xmath174 ( 159,40)(161,40 ) ( tp)(195,99)@xmath175 ( 159,100)(161,100 ) ( 159,120)(161,120 ) ( 159,140)(161,140 ) ( 159,160)(161,160 ) ( 159,300)(161,300 ) ( 159,320)(161,320 ) ( li , re ) ( u , o ) ( u1,o1 ) ( u3,o3 )    we have to prove @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "for this , we show that there exists a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path @xmath225 from @xmath226 down to @xmath227 .",
    "thus , since @xmath225 meets @xmath87 in @xmath228 , it follows @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "the path @xmath225 is indicated by a dashed curve in figure  [ f catch ] .",
    "our path @xmath225 consists of two concatenated paths .",
    "first recall that the path @xmath24 loses a counter height of precisely @xmath229 .",
    "the first part of @xmath225 is the path @xmath230 $ ] shifted upwards by the offset @xmath231 .",
    "the second part of @xmath225 is the path from @xmath232 down to @xmath227 that we can obtain by first shifting @xmath24 up by the offset @xmath231 and then downward pumping it precisely @xmath233 many times .",
    "this is possible since @xmath231 is a multiple of @xmath182 , which is in turn a multiple of @xmath234 , hence @xmath235 .",
    "if : assume that @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] . to prove that @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ]",
    ", we will use the following claim .",
    "_ claim : _ assume some @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path @xmath236 whose counter values are all strictly above @xmath111 and where @xmath237 .",
    "then there exists a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path from @xmath238 to @xmath239 strictly above @xmath240 .",
    "the statement of the claim is depicted in figure  [ f claim ] .",
    "( 200,250)(0,-20 ) ( 40,0)(160,0)(160,40)(40,40 ) ( li)(40,0 ) ( re)(163,0 ) ( u)(160,-1 ) ( o)(160,121 ) ( 170,230)counter value ( 163,-1)@xmath25 ( u1)(160,139 ) ( o1)(160,161 ) ( u2)(160,179 ) ( o2)(160,201 ) ( u3)(160,199 ) ( o3)(160,230 ) ( t)(195,40)@xmath174 ( 159,40)(161,40 ) ( tp)(195,99)@xmath175 ( 159,100)(161,100 ) ( li , re ) ( u , o3 ) ( q1)(50,215)@xmath241 ( 50,220)@xmath242 ( ql)(110,88)@xmath241 ( 110,83)@xmath243 ( ql)(110,110)@xmath241 ( 110,115)@xmath244 ( 50,2)(50,-2 ) ( 51,-5)@xmath245 ( 110,2)(110,-2 ) ( 111,-5)@xmath246 ( 50,215)(60,180)(90,150)(90,64)(110,110 ) ( 40,215)(160,215 ) ( 40,88)(160,88 ) ( 40,62)(160,62 ) ( 40,110)(160,110 ) ( 50,215)(60,120)(70,150)(70,95)(50,110)(90,42)(110,88 ) ( 119,162 ) ( 60,-20)@xmath185 s control locations ( 105,97)@xmath247 ( 105,49)@xmath247 ( -5,150)@xmath248 @xmath249    thus , the claim tells us that paths that lose height at least @xmath250 and whose states all have counter values strictly above @xmath111 can be lifted by a height precisely @xmath234 .",
    "let us postpone the proof of the claim and first finish the proof of the if - direction .",
    "since by assumption @xmath180\\!]}}}_{t({\\mathcal{o}})}$ ] , there exists a finite path @xmath190 where @xmath192 $ ] is a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path , @xmath251 , and where @xmath195\\!]}}}_{t({\\mathcal{o}})}$ ] . to prove @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ]",
    ", we make a case distinction .",
    "_ case a : _",
    "@xmath196 for each @xmath197 $ ] .",
    "assume that the path @xmath192 $ ] contains two states whose counter difference is at least @xmath252 which is ( strictly ) greater than @xmath250 . since @xmath182 is a multiple of @xmath253 by definition",
    ", we can shorten @xmath192 $ ] by a height precisely @xmath182 by applying the above claim @xmath254 many times .",
    "we repeat this shortening process of @xmath192 $ ] by height @xmath182 as long as this is no longer possible , i.e. , until there are no two states whose counter difference is at least @xmath255 .",
    "let @xmath24 denote the @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path starting in @xmath226 that we obtain from @xmath192 $ ] until the before mentioned shortening is no longer possible .",
    "thus , @xmath24 ends in some state with a counter value that is congruent @xmath256 modulo @xmath182 ( since we shortened @xmath192 $ ] by a multiple of @xmath182 ) . since @xmath182 is in turn a multiple of @xmath257 , we can build a path @xmath258 which extends the path @xmath24 by a single transition to some state that satisfies @xmath259 by induction hypothesis . moreover , by our shortening process , the counter difference between any two states in @xmath258 is at most @xmath260    since @xmath261 , it follows that the path @xmath262 ( which starts in @xmath263 ) is strictly above @xmath111 .",
    "moreover , since @xmath231 is a multiple of @xmath264 and @xmath257 , this path witnesses @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] by induction hypothesis .",
    "_ case b : _ @xmath265 for some @xmath197 $ ] .",
    "let @xmath266 $ ] be minimal such that @xmath267 .",
    "note that @xmath268 $ ] is a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path whose counter values are all strictly above @xmath111 .",
    "moreover the maximal counter difference between two states of @xmath268 $ ] is at least @xmath269 hence , in analogy to case a , we can shorten @xmath268 $ ] _ precisely _ by height @xmath231 .",
    "let @xmath24 denote the resulting path .",
    "then @xmath270 is a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path that ends in @xmath271 and starts in @xmath263 .",
    "we can append @xmath272 $ ] to this path .",
    "the resulting path witnesses @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "it remains to prove the above claim .",
    "_ proof of the claim .",
    "_ for each counter value @xmath202\\}$ ] that appears in @xmath87 , let @xmath273\\mid n_i = h\\}\\ ] ] denote the minimal position in @xmath87 whose corresponding state has counter value @xmath204 .",
    "define @xmath274 .",
    "we will be interested in @xmath275 many consecutive intervals ( of counter values ) each of size @xmath276  we will call these intervals blocks . define the bottom @xmath277 .",
    "block _ is an interval @xmath278 $ ] for some @xmath279 $ ] .",
    "since each block has size @xmath274 , we can think of each block @xmath280 to consist of @xmath281 consecutive _ subblocks _ of size @xmath264 each .",
    "note that each subblock has two extremal elements , namely its _ upper _ and _ lower boundary_. thus all @xmath281 subblocks have @xmath282 boundaries in total .",
    "hence , by the pigeonhole principle , for each block @xmath280 , there exists some distance @xmath283 $ ] and two distinct boundaries @xmath284 and @xmath285 of distance @xmath286 such that the control location of @xmath87 s earliest state of counter value @xmath284 agrees with the control location of @xmath87 s earliest state of counter value @xmath285 , i.e. , formally @xmath287 the situation is depicted in figure  [ f blocks ] .",
    "observe that shortening the path @xmath87 by gluing together @xmath87 s states at position @xmath288 and @xmath289 still results in a @xmath193\\!]}}}_{t({\\mathcal{o}})}$]-path by induction hypothesis , since we shortened the height of @xmath87 by a multiple of @xmath264 .",
    "our overall goal is to shorten @xmath87 by gluing together states only of certain blocks such that we obtain a path whose height is in total precisely @xmath234 smaller than @xmath87 s .",
    "recall that there are @xmath275 many blocks . by the pigeonhole principle",
    "there is some @xmath290 $ ] such that @xmath291 for at least @xmath217 many blocks @xmath280 . by gluing together @xmath292 pairs of states of distance @xmath229",
    "each , we shorten @xmath87 by a height of @xmath293 .",
    "this proves the claim .",
    "( 200,280)(0,-20 ) ( 170,230)counter value ( 163,-1)@xmath25 ( li)(50,0 ) ( re)(163,0 ) ( u)(160,-1 ) ( o3)(160,230 ) ( li , re ) ( u , o3 ) ( 49,29 ) ( 50,180)(80,200)(70,160)(50,175)(70,130)(65,120)(40,110)(45,100)(55,90)(60,80)(65,70)(44,50)(54,69)(70,49)(70,35 ) ( 50,180)@xmath241 ( 47,185)@xmath242 ( 40,180)(80,180 ) ( 40,170)(80,170 ) ( 40,160)(80,160 ) ( 40,150)(80,150 ) ( 40,140)(80,140 ) ( 40,130)(80,130 ) ( 40,120)(80,120 ) ( -6,147)@xmath274@xmath294 ( 0,135)block @xmath295 ( 53,143)@xmath296 ( 64,93)@xmath297 ( 88,173)@xmath298 ( 40,120)(80,120 ) ( 40,110)(80,110 ) ( 40,100)(80,100 ) ( 40,90)(80,90 ) ( 40,80)(80,80 ) ( 40,70)(80,70 ) ( 40,60)(80,60 ) ( 3,86)block @xmath299@xmath294 ( 30,-45)@xmath185 s control locations ( 69,26)@xmath300    assume @xmath301 .",
    "this can can easily seen to be proven analogously to the case when @xmath302 .",
    "[ ctl upper bound_0 ] the following problem can be solved in time @xmath303 :    input : a one - counter process @xmath90 , a @xmath0 formula @xmath104 , a control location @xmath151 and some natural @xmath37 given in binary .",
    "question : @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] ?",
    "let @xmath304 .",
    "we first compute the threshold @xmath305 from theorem  [ thm - ctl - periodic ] .",
    "then we have @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] if and only if @xmath306\\!]}}}_{t({\\mathcal{o}})}$ ] , where either @xmath307 or @xmath308 and @xmath309 is the unique number in the interval @xmath310 $ ] , which is congruent @xmath40 modulo @xmath182 .",
    "we can find this number in time @xmath13 .",
    "now we check @xmath306\\!]}}}_{t({\\mathcal{o}})}$ ] using the standard algorithm for model checking @xmath0 on finite transition systems .",
    "the only difference is that if we reach a counter value of @xmath311 , then we replace this value by @xmath312 .",
    "more precisely , we compute inductively for every subformula @xmath313 of @xmath104 the set @xmath314\\!]}}}_{t({\\mathcal{o } } ) } \\cap ( q \\times [ t(\\varphi)+k_\\varphi]).\\ ] ] let us sketch the case of an until formula @xmath315 . by induction , we have already computed the sets @xmath316 and @xmath317 .",
    "the set @xmath318 is computed by a fixpoint iteration .",
    "initially , we put all elements from @xmath317 into @xmath318 .",
    "then , we perform the following fixpoint iteration process as long as possible .",
    "assume that @xmath319 is a state , which does not belong to the current @xmath318 .",
    "assume that @xmath320 has a @xmath136-successor ( where a counter value of @xmath311 is reduced to @xmath312 ) in @xmath318 .",
    "then we add @xmath320 to @xmath318 .",
    "the correctness of this fixpoint iteration process follows from theorem  [ thm - ctl - periodic ] .",
    "the size of each set @xmath318 is bounded by @xmath321 .",
    "computing @xmath318 can be done in time @xmath322 .",
    "hence , the total time bound is @xmath323 for every fixed one - counter process @xmath131 and every fixed @xmath281 the following problem is in @xmath324 :    input : a @xmath0 formula @xmath104 with @xmath325 , a control location @xmath151 and some natural @xmath37 given in binary .",
    "question : @xmath150\\!]}}}_{t({\\mathcal{o}})}$ ] ?",
    "corollary  [ ctl upper bound ] generalizes a result from @xcite , stating that the expression complexity of @xmath4 over one - counter processes is in @xmath324 .",
    "[ s expression ]    the goal of this section is to prove that model checking @xmath0 is @xmath1-hard already over a fixed one - counter net . we show this via a reduction from the well - known @xmath1-complete problem qbf .",
    "our lower bound proof is separated into three steps . in step one , we define a family of @xmath0 formulas @xmath326 such that over the fixed the one - counter net @xmath185 that is depicted in figure  [ fig - fixed - ccp ] we can express ( non-)divisibility by @xmath15 . in step two , we define a family of @xmath0 formulas @xmath327 such that over @xmath185 we can express if the @xmath16 bit in the binary representation of a natural is set to @xmath8 . in our final step ,",
    "we give the reduction from qbf .    for step one ,",
    "we need the following simple fact which characterizes divisibility by powers of two . recall that @xmath328 = \\{1,\\ldots , n\\}$ ] , in particular @xmath36 = \\emptyset$ ] .",
    "[ f div ] let @xmath329 and @xmath38 .",
    "then the following two statements are equivalent :    * @xmath15 divides @xmath40 . *",
    "@xmath330 divides @xmath40 and @xmath331 \\mid   2^{i-1 } \\text { divides } n'\\}|\\   \\text { is even.}$ ]    ( 300,133)(-90,-10 ) ( -65,40)@xmath332 ( tb)(45,80)@xmath333 ( t)(45,40)@xmath146 ( q0)(100,20)@xmath334 ( q2)(100,100)@xmath335 ( q1)(135,60)@xmath336 ( q1)@xmath337 ( q3)(65,60)@xmath338 ( q3)@xmath337 ( q0,q1)@xmath337 ( q1,q2)@xmath337 ( q2,q3)@xmath337 ( q3,q0)@xmath337 ( f)(10,50)@xmath339 ( g)(10,90)@xmath340 ( q0,t)@xmath25 ( q1,tb)@xmath25 ( q2,tb)@xmath25 ( q3,tb)@xmath25 ( q2,t)@xmath25 ( t , f)@xmath25 ( tb , f)@xmath337 ( g , f)@xmath337 ( p0)(25,120)@xmath341 ( p1)(65,120)@xmath342 ( tb , p1)@xmath343 ( p1,tb)@xmath25 ( p0,tb)@xmath25 ( p1)@xmath343    ( 300,40)(-30,-15 ) ( 5,15)@xmath344 ( tb)(105,0)@xmath333 ( t)(165,10)@xmath146 ( q0)(190,0)@xmath334 ( f)(140,20)@xmath339 ( t , q0)@xmath25 ( t , f)@xmath25 ( p0)(85,40)@xmath341 ( p1)(125,40)@xmath342 ( tb , p1)@xmath343 ( p0,tb)@xmath25    the set of atomic propositions of @xmath185 in figure  [ fig - fixed - ccp ] coincides with its control locations .",
    "recall that @xmath185 s zero transitions are denoted by @xmath345 and @xmath185 s positive transitions are denoted by @xmath346 . since @xmath97 , we have that @xmath185 is indeed a one - counter net .",
    "note that both @xmath146 and @xmath333 are control locations of @xmath185 .",
    "now we define a family of @xmath0 formulas @xmath326 such that for each @xmath37 we have that first @xmath347 if and only if @xmath15 divides @xmath40 and second @xmath348 if and only if @xmath15 does _ not _ divide @xmath40 . on first sight , it might seem superfluous to let the control location @xmath146 represent divisibility by powers of two and the control location @xmath333 to represent non - divisibility by powers of two since @xmath0 allows negation .",
    "however the fact that we have _ only one _ family of formulas @xmath326 to express both divisibility and non - divisibility is a crucial technical subtlety that is necessary in order to avoid an exponential blowup in formula size . by making use of fact  [ f div ]",
    ", we construct the formulas @xmath349 inductively .",
    "first , let us define the auxiliary formulas @xmath350 and @xmath351 .",
    "think of @xmath352 to hold in those control locations that altogether are situated in the `` diamond '' in figure  [ fig - fixed - ccp ] .",
    "we define @xmath353 now assume @xmath354",
    ". then we define @xmath355 observe that @xmath349 can only be true either in control location @xmath146 or @xmath333 .",
    "note that the formula right to the until symbol expresses that we are in @xmath334 and that the current counter value is zero .",
    "also note that the formula left to the until symbol requires that @xmath352 holds , i.e. , we are always in one of the four `` diamond control locations '' . in other words , we decrement the counter by moving along the diamond control locations ( by possibly looping ) and always check if @xmath356 holds , just until we are in @xmath334 and the counter value is zero .",
    "since @xmath357 is only used once in @xmath349 , we get :    [ f size varphi ] @xmath358 .",
    "the following lemma shows the correctness of the construction .",
    "[ l correctness ] let @xmath359 and @xmath38 .",
    "then    1 .",
    "@xmath347 if and only if @xmath15 divides @xmath40 .",
    "2 .   @xmath348 if and only if @xmath15 does not divide @xmath40 .",
    "we prove statements ( 1 ) and ( 2 ) simultaneously by induction on @xmath14 .",
    "for the induction base , assume @xmath360 .",
    "we only show point ( 2 ) , i.e. @xmath361\\!]}}}_{t({\\mathcal{o}})}$ ] if and only if @xmath40 is odd .",
    "we have the following equivalences : @xmath362 point ( 1 ) can be shown analogously for @xmath363",
    ".    for the induction step , assume @xmath364 and that the statement in the lemma holds for @xmath365 .",
    "it is easy to verify by the construction of @xmath185 and by induction hypothesis that the following claim holds .    _",
    "claim a : _ for every @xmath366 the following equivalences hold : @xmath367 using claim a , one can easily show the following ( recall that @xmath368 ) :    _ claim b : _ for every @xmath329 the following equivalences hold : @xmath369\\mid 2^{i-1}\\text { divides } n'\\}|\\text { is even } \\\\",
    "( q_1,n)\\models\\mu_i   & \\quad\\longleftrightarrow \\quad &       2^{i-1 } \\text { does not divide } n \\text { and }      |\\{n'\\in[n]\\mid 2^{i-1}\\text { divides } n'\\}|\\text { is odd } \\\\ ( q_2,n)\\models\\mu_i   & \\quad\\longleftrightarrow \\quad &       2^{i-1 } \\text { divides } n \\text { and }      |\\{n'\\in[n]\\mid 2^{i-1}\\text { divides } n'\\}|\\text { is odd } \\\\ ( q_3,n)\\models\\mu_i   & \\quad\\longleftrightarrow \\quad &       2^{i-1 } \\text { does not divide } n \\text { and }      |\\{n'\\in[n]\\mid 2^{i-1}\\text { divides } n'\\}|\\text { is even } \\\\\\end{aligned}\\ ] ] let us now prove point ( 1 ) from the lemma for @xmath370 .",
    "we have the following equivalences : @xmath371 for point ( 2 ) , we have the following equivalences : @xmath372    for expressing if the @xmath16 bit of a natural is set to @xmath8 , we make use of the following fact .    [ f bit ]",
    "let @xmath359 and @xmath38 .",
    "then @xmath373 if and only if @xmath374\\mid 2^{i-1 } \\text { divides } n'\\}|\\ \\text { is odd.}$ ]    we have @xmath375 \\\\ \\quad & \\longleftrightarrow & \\quad \\exists r \\in [ 0,2^{i-1}-1 ] , k \\geq 0 : n = r + ( 2k+1 ) \\cdot 2^{i-1 } \\\\ & \\longleftrightarrow & \\quad |\\{n'\\in[n]\\mid 2^{i-1}\\text { divides } n'\\}|\\text { is odd}.\\end{aligned}\\ ] ]    let us now define a family of @xmath0 formulas @xmath327 such that for each @xmath37 we have @xmath373 if and only if @xmath376 .",
    "we set @xmath377 fact  [ f size varphi ] and the construction of @xmath378 immediately yield the following fact .",
    "[ f size psi ] @xmath379 .",
    "the following lemma shows the correctness of the construction .",
    "[ l bit ] let @xmath329 and let @xmath38 .",
    "then @xmath376 if and only if @xmath373 .",
    "the case @xmath360 is covered by lemma  [ l correctness ] . for @xmath370 , the following equivalences hold : @xmath380    for our final step , let us give a reduction from qbf .",
    "let @xmath381 be the following quantified boolean formula @xmath382 where @xmath383 is a boolean formula over variables @xmath384 and @xmath385 is a quantifier for each @xmath386 $ ] .",
    "our overall goal is to give a @xmath0 formula @xmath387 such that our qbf formula @xmath381 is valid if and only if @xmath388 . a truth assignment @xmath389 corresponds to the natural number @xmath390 $ ] , where @xmath391 if and only if @xmath392 , for each @xmath386 $ ] .",
    "first , let @xmath393 be the @xmath0 formula that is obtained from the boolean formula @xmath383 by replacing every occurrence of every variable @xmath394 by @xmath378 .",
    "hence we obtain that for each @xmath395 we have @xmath396 if and only if @xmath397 by lemma  [ l bit ] .",
    "it remains to define @xmath387 .",
    "recall that @xmath387 will be evaluated in @xmath398 .",
    "let us parse our quantified boolean formula @xmath381 from left to right . setting the variable @xmath399 to @xmath8 will correspond to adding @xmath400 to the counter and getting to state @xmath401 . setting @xmath399",
    "to @xmath25 on the other hand will correspond to adding @xmath25 to the counter and hence remaining in state @xmath398 .",
    "next , setting @xmath402 to @xmath8 corresponds to adding to the current counter value @xmath403 , whereas setting @xmath402 to @xmath25 corresponds to adding @xmath25 , as expected .",
    "adding zero to the counter will be realized by the finite path that jumps from control location @xmath333 to @xmath341 and then back to @xmath333 .",
    "adding @xmath330 to the counter , on the other hand , will be realized by a finite path that jumps from control location @xmath333 to @xmath342 ( and thereby adds @xmath8 to the counter ) , then loops at @xmath342 as long as the counter value is not divisible by @xmath330 ( which can be ensured by checking if @xmath404 by lemma  [ l correctness ] ) and finally jumps back to @xmath333 when the counter value is divisible by @xmath330 for the first time again .",
    "we repeat this process until we have to set @xmath405 either to @xmath8 or to @xmath25 . eventually setting @xmath405 to @xmath8",
    "will correspond to go from @xmath333 to @xmath342 ( hence adding @xmath8 to the counter ) and then getting back to @xmath333 , whereas setting @xmath405 to @xmath25 will correspond to go from @xmath333 to @xmath341 and then back to @xmath333 .",
    "after that , we finally check if @xmath393 holds .",
    "recall that @xmath406 are the quantifiers of our quantified boolean formula @xmath381 .",
    "for each @xmath407 $ ] , let us define formula @xmath408 as @xmath409 with @xmath410 in case @xmath411 and @xmath412 in case @xmath413 for each @xmath386 $ ] .",
    "as expected , we put @xmath414 .",
    "observe that the size of @xmath387 is polynomial in the size of @xmath381 and that @xmath387 can be computed in logarithmic space from @xmath381 .",
    "we finally obtain the following easy equivalence .",
    "the formula @xmath381 is valid if and only if @xmath415\\!]}}}_{t({\\mathcal{o}})}$ ] .",
    "this finishes our @xmath1 lower bound proof for expression complexity of @xmath0 over one - counter nets .",
    "we have the following theorem .",
    "[ theo - ctl - expression ] @xmath0 model checking of the fixed one - counter net @xmath185 from figure  [ fig - fixed - ccp ] is @xmath1-hard .",
    "note that the formula @xmath387 in our reduction necessarily has a leftward until depth that depends on the size of @xmath381 . by corollary  [",
    "ctl upper bound ] this can not be avoided unless @xmath416 .",
    "observe that in order to express divisibility by powers of two , our @xmath0 formulas @xmath417 have a linearly growing leftward until depth .",
    "for section  [ s data][s markov ] we need some concepts from complexity theory .",
    "the _ @xmath16 level @xmath418 of the boolean hierarchy _ is defined as follows : @xmath419 , @xmath420 , and @xmath421 .",
    "boolean hierarchy @xmath29 _ is defined as @xmath422 .",
    "the class @xmath10 is the class of all problems that can be solved on a polynomially time bounded deterministic turing machine with access to an oracle from @xmath30 . by @xmath423}$ ] we denote the class of all problems that can be solved on a polynomially time bounded deterministic turing machines which can have access to an @xmath30-oracle only logarithmically many times .",
    "it is known that @xmath424}$ ] .    for naturals",
    "@xmath425 and @xmath426 let @xmath427 denote the @xmath309-bit binary representation of @xmath44 . in @xcite , it was shown that the following problem is complete for @xmath10 :    input : a boolean formula @xmath428 ?",
    "question : is @xmath313 satisfiable and is the maximal number @xmath429 $ ] with @xmath430 even ( i.e. is the lexicographically maximal satisfying assignment even ) ?",
    "more details on circuit complexity can be found in @xcite .",
    "a boolean circuit @xmath431 is a directed acyclic graph ( dag ) with the following properties ( in the following , nodes of @xmath432 are called _ gates _ , the in - degree ( resp .",
    "out - degree ) of a gate is called its _ fan - in _ ( resp . _",
    "fan - out _ ) ) :    * the gates with fan - in @xmath25 ( they are called _ input gates _ in the following ) are labeled with one of the symbols @xmath405 , @xmath433 , @xmath434 . *",
    "every gate with fan - in at least one is labeled with either and or with or . * the gates of fan - out",
    "0 ( they are called _ output gates _ in the following ) are linearly ordered , we denote this order by @xmath435 in the following .",
    "such a circuit computes a function @xmath436 in the obvious way .",
    "_ threshold circuits _ may in addition to boolean circuits contain _",
    "majority gates_. such a gate outputs @xmath8 if and only if at least half of its input gates evaluate to @xmath8 .",
    "the _ fan - in of a circuit _ is the maximal fan - in of a gate in the circuit .",
    "the _ size of a circuit _ is the number of gates in the circuit .",
    "the _ depth of a circuit _ is the number of gates along a longest path from an input gate to an output gate .",
    "@xmath6-circuit family _ ( resp .",
    "_ @xmath437-circuit family _ ) is a sequence @xmath438 of boolean circuits ( resp .",
    "threshold circuits ) such that for some polynomial @xmath439 and constant @xmath440 :    * the size of @xmath441 is at most @xmath439 , * the depth of @xmath441 is at most @xmath440 , and * for each @xmath309 there is at most one circuit in @xmath438 with exactly @xmath309 input gates",
    "@xmath5-circuit family _ is a sequence @xmath438 of boolean circuits such that for some polynomial @xmath439 and constant @xmath440 :    * the size of @xmath441 is at most @xmath439 , * the depth of @xmath441 is at most @xmath442 , * the fan - in of @xmath441 is at most @xmath443 , and * for each @xmath309 there is at most one circuit in @xmath438 with exactly @xmath309 input gates .",
    "circuit families of these types compute partial mappings on @xmath444 in the obvious way . a circuit with exactly @xmath40 input gates in the family ,",
    "therefore the computed mapping is in general only partially defined . ] finally , a circuit family @xmath445 is called _ logspace - uniform _ if there exists a logspace transducer that computes on input @xmath446 a representation ( e.g. as a node - labeled dag ) of the circuit @xmath441 . in the literature on circuit complexity one can find more restrictive notions of uniformity , see e.g. @xcite , but logspace uniformity suffices for our purposes .",
    "in fact , polynomial time uniformity suffices for proving our lower bounds w.r.t .",
    "polynomial time reductions .    for our lower bound on the data complexity of @xmath0",
    ", we use a deep result from @xcite .",
    "first , we need a few definitions .",
    "let @xmath447 denote the @xmath16 prime number .",
    "it is well - known from number theory that the @xmath16 prime requires @xmath448 bits in its binary representation . for a number @xmath449",
    "we define the _ chinese remainder representation _ @xmath450 as the boolean tuple @xmath451 , 0 \\leq r < p_i}\\quad \\text { with } \\\\ x_{i , r } = \\begin{cases } 1 & \\text{if } m \\text { mod } p_i = r \\\\ 0 & \\text{else }   \\end{cases}\\ ] ] by the following theorem , we can transform a crr - representation very efficiently into binary representation .",
    "[ theorem hesse und co ] there is a logspace - uniform @xmath5-circuit family @xmath452 , 0 \\leq r < p_i } ) ) _ { m \\geq 1}$ ] such that for every @xmath425 , @xmath453 has has @xmath309 output gates and @xmath454    by @xcite , we could replace logspace - uniform @xmath5-circuits in theorem  [ theorem hesse und co ] even by @xmath455-uniform @xmath437-circuits .",
    "the existence of a @xmath324-uniform @xmath5-circuit family for converting from crr - representation to binary representation was already shown in @xcite .",
    "usually the chinese remainder representation of @xmath44 is the tuple @xmath456}$ ] , where @xmath457 .",
    "since the primes @xmath447 will be always given in unary notation , there is no essential difference between this representation and our chinese remainder representation .",
    "the latter is more suitable for our purpose .",
    "intuitively , a complexity class @xmath458 is called @xmath459-serializable ( where @xmath459 is another complexity class ) if every language @xmath460 can be accepted in the following way : there exists a polynomial @xmath439 and a @xmath459-machine ( or @xmath459-circuit family ) @xmath47 such that @xmath461 is checked in @xmath462 many stages , which are indexed by the strings from @xmath463 . in stage @xmath464",
    ", @xmath47 gets from the stage indexed by the lexicographic predecessor of @xmath465 a constant number of bits @xmath466 and computes from these bits , the index @xmath465 and the original input @xmath467 new bits @xmath468 which are delivered to the lexicographic next stage . in @xcite",
    "it was shown that @xmath1 is @xmath324-serializable ; in @xcite this result was sharpened to @xmath6-serializability , see also @xcite .",
    "it is not stated in @xcite but easy to see from the proofs that _ logspace - uniform _",
    "@xmath6 suffices for serializing @xmath1 , see the appendix for more details .    for our purpose ,",
    "a slightly different definition of @xmath6-serializability is useful : a language @xmath469 is @xmath6-serializable if there exists an nfa @xmath47 over the alphabet @xmath470 , a polynomial @xmath439 , and a logspace - uniform @xmath6-circuit family @xmath445 , where @xmath441 has exactly @xmath471 many inputs and one output , such that for every @xmath472 we have : @xmath473 where `` @xmath474 '' refers to the lexicographic order on @xmath475 .",
    "a proof that every language in @xmath1 is @xmath6-serializable in this sense can be found in the appendix .",
    "in this section , we prove that also the data complexity of @xmath0 over one - counter nets is hard for @xmath1 and therefore @xmath1-complete by the known upper bounds for the modal @xmath2-calculus @xcite .",
    "let us fix the set of propositions @xmath476 for this section . in the following , w.l.o.g .",
    "we allow in @xmath345 ( resp . in @xmath346 )",
    "transitions of the kind @xmath477 , where @xmath478 ( resp .",
    "@xmath479 ) is given in unary representation with the expected intuitive meaning .",
    "[ prop main ] for the fixed @xmath4 formula @xmath480 the following problem can be solved with a logspace transducer :    input : a list of the first @xmath309 consecutive ( unary encoded ) prime numbers and a boolean formula @xmath481 , 0 \\leq r < p_i})$ ]    output : an ocn @xmath482 with distinguished control locations @xmath483 and @xmath484 , such that for every number @xmath449 the following are equivalent :    * @xmath485 * there exists a @xmath486\\!]}}}_{t(\\omc(f))}$]-path from @xmath487 to @xmath488 in @xmath489 .",
    "we may assume that negations occur in @xmath490 only in front of variables .",
    "then , a negated formula @xmath491 can be replaced by the disjunction @xmath492 .",
    "note that this can be done in logspace , since the primes @xmath447 are given in unary .",
    "hence , we can assume that @xmath490 does not contain negations .",
    "the idea is to traverse the boolean formula @xmath490 with the ocn @xmath482 in a depth first manner .",
    "each time a variable @xmath493 is seen , the ocn may also enter another branch , where it is checked , whether the current counter value is congruent @xmath494 modulo @xmath447 .",
    "let @xmath495 , 0 \\leq r < p_i \\ } \\\\ q_\\beta & = & \\ { \\div(p_1 ) , \\ldots,\\div(p_m ) \\ } \\\\ q_\\gamma & = &   \\ { \\perp \\}.\\end{aligned}\\ ] ] we set @xmath496 and @xmath497 .",
    "let us now define the transition sets @xmath345 and @xmath346 . in case @xmath498",
    "is a subformula of @xmath490 , we add the following transitions to @xmath345 and @xmath346 : @xmath499 in case @xmath500 is a subformula of @xmath490 , we add the following transitions to @xmath345 and @xmath346 : @xmath501 for every variable @xmath493 we add to @xmath345 and @xmath346 the transition @xmath502 moreover , we add to @xmath346 the transitions @xmath503 the transition @xmath504 is also added to @xmath345 . for the control locations @xmath505 we add to @xmath346 the transitions @xmath506 and @xmath507 .",
    "this concludes the description of the ocn @xmath482 .",
    "correctness of the construction can be easily checked by induction on the structure of the formula @xmath490 .",
    "we are now ready to prove @xmath1-hardness of the data complexity .",
    "[ theo ctl data ] there exists a fixed @xmath0 formula of the form @xmath508 , where @xmath128 and @xmath129 are @xmath4 formulas , such that the following problem is @xmath1-complete :    input : an ocn @xmath509 and a control location @xmath510 of @xmath509 .",
    "question : @xmath511 ?",
    "let us take an arbitrary @xmath1-complete language @xmath469 .",
    "recall from section  [ sec real ] that @xmath1 is @xmath6-serializable @xcite and hence @xmath5-serializable .",
    "thus , there exists an nfa @xmath512 over the alphabet @xmath470 , a polynomial @xmath439 , and a logspace - uniform @xmath5-circuit family @xmath445 , where @xmath441 has @xmath471 many inputs , such that for every @xmath472 we have : @xmath513 where `` @xmath474 '' refers to the lexicographic order on @xmath475 .",
    "fix an input @xmath472 .",
    "our reduction can be split into the following five steps :    _ step 1 .",
    "_ construct in logarithmic space the circuit @xmath441 .",
    "fix the the first @xmath40 inputs of @xmath441 to the bits in @xmath467 , and denote the resulting circuit by @xmath432 ; it has only @xmath514 many inputs .",
    "equivalence ( [ eq c_n ] ) can be written as @xmath515 _ step 2 .",
    "_ compute the first @xmath309 consecutive primes @xmath516 .",
    "this is possible in logarithmic space , see e.g. @xcite . note that every @xmath447 is bounded polynomially in @xmath40 .",
    "hence , every @xmath447 can be written down in unary notation .",
    "note that @xmath517 ( if @xmath518 ) .",
    "_ step 3 . _",
    "compute in logarithmic space the circuit @xmath519 , 0 \\leq r < p_i } ) $ ] from theorem  [ theorem hesse und co ] .",
    "thus , @xmath520 is a boolean circuit of fan - in 2 and depth @xmath521 with @xmath522 for every @xmath449 .",
    "_ now we compose the circuits @xmath520 and @xmath432 : for every @xmath523 $ ] , connect the @xmath16 input of the circuit @xmath524 with the @xmath16 output of the circuit @xmath520 .",
    "the result is a circuit with fan - in 2 and depth @xmath13 .",
    "we can unfold this circuit into a boolean formula @xmath525 , 0 \\leq r < p_i})$ ] .",
    "the resulting formula ( or tree ) has the same depth as the circuit , i.e. , depth @xmath13 and every tree node has at most 2 children .",
    "hence , @xmath490 has polynomial size .",
    "thus , for every @xmath526 we have @xmath527 and equivalence ( [ eq c ] ) can be written as @xmath528 _ step 5 .",
    "_ we now apply our construction from proposition  [ prop main ] to the formula @xmath490 .",
    "more precisely , let @xmath65 be the boolean formula @xmath529 } x_{i , r_i}$ ] were @xmath530 for @xmath523 $ ] ( these remainders can be computed in logarithmic space ) . for every @xmath8-labeled transition @xmath531 of the nfa @xmath47",
    "let @xmath532 be a copy of the ocn @xmath533 .",
    "for every @xmath25-labeled transition @xmath531 let @xmath532 be a copy of the ocn @xmath534 . in both cases we write",
    "@xmath532 as @xmath535 .",
    "denote with @xmath536 ( resp .",
    "@xmath537 ) the control location of this copy that corresponds to @xmath483 ( resp .",
    "@xmath484 ) in @xmath482 .",
    "hence , for every @xmath538-labeled transition @xmath531 ( @xmath539 ) and every @xmath449 there exists a @xmath486\\!]}}}_{t(\\omc(\\tau))}$]-path ( @xmath104 is from proposition  [ prop main ] ) from @xmath540 to @xmath541 if and only if @xmath542 and @xmath543 .",
    "we now define an ocn @xmath544 as follows : we take the disjoint union of all the ocns @xmath532 for @xmath531 .",
    "moreover , every state @xmath545 of the automaton @xmath47 becomes a control location of @xmath509 : @xmath546 we add to @xmath345 and @xmath346 for every @xmath547 the following transitions : @xmath548 then , by proposition  [ prop main ] and ( [ gl f ] ) we have @xmath461 if and only if there exists a @xmath486\\!]}}}_{t(\\omc)}$]-path in @xmath549 from @xmath550 to @xmath551 for some @xmath552 .",
    "also note that there is no @xmath486\\!]}}}_{t(\\omc)}$]-path in @xmath549 from @xmath550 to some configuration @xmath553 with @xmath545 and @xmath554 .",
    "it remains to add to @xmath509 some structure that enables @xmath509 to check that the counter has reached the value @xmath555 .",
    "for this , use proposition  [ prop main ] to construct the ocn @xmath556 ( where @xmath65 is from above ) and add it disjointly to @xmath509 .",
    "moreover , add to @xmath346 and @xmath345 the transitions @xmath557 for all @xmath552 , where @xmath483 is the in control location of @xmath556 . finally , introduce a new proposition @xmath558 and set @xmath559 , where @xmath484 is the out control location of @xmath556 . by putting @xmath560",
    "we obtain : @xmath561 this concludes the proof of the theorem .    by slightly modifying the proof of theorem  [ theo ctl data ] ,",
    "the following corollary can be shown .",
    "there exists a fixed @xmath0 formula of the kind @xmath562 , where @xmath313 is an @xmath4 formula , such that the following problem is @xmath1-complete :    input : an ocn @xmath185 and a control location @xmath510 of @xmath185 .",
    "question : @xmath563 ?",
    "the proof is almost identical to the proof of theorem  [ theo ctl data ] , except that we do not introduce the atomic proposition @xmath558 .",
    "we rather add both to @xmath345 and @xmath346 the transition @xmath564 , where @xmath484 is the out control location of @xmath556 and @xmath483 is the in control location of @xmath565 . we define @xmath566 , where again @xmath104 is the formula from proposition  [ prop main ] .",
    "[ s combined ]    in this section , we will apply the efficient transformation from chinese remainder representation to binary representation ( theorem  [ theorem hesse und co ] ) in order to prove that the combined complexity for @xmath4 over one - counter nets is hard for @xmath10 . for formulas represented succinctly by dags ( directed acyclic graphs ) this was already shown in @xcite .",
    "the point here is that we use the standard tree representation for formulas .",
    "[ prop main ef ] the following problem can be solved by a logspace transducer :    input : a list of the first @xmath309 consecutive ( unary encoded ) prime numbers and a boolean circuit @xmath567 , 0 \\leq r < p_i})$ ] ( with a single output gate )    output : an ocn @xmath568 with a distinguished state @xmath483 and an @xmath4 formula @xmath569 such that for every number @xmath449 we have : @xmath570    as in the proof of proposition  [ prop main ] we can eliminate in @xmath432 all input gates labeled with a negated variable .",
    "moreover , we can w.l.o.g .",
    "assume that the circuit @xmath432 is organized in @xmath282 layers , where each layer either contains only and- or or - gates .",
    "all children of a node in layer @xmath14 belong to layer @xmath571 .",
    "layer @xmath8 contains only the unique output gate of the circuit , whereas layer @xmath282 contains the input gates . for @xmath572 $ ] ,",
    "let @xmath573 ( resp .",
    "@xmath574 ) if layer @xmath14 consists of and - gates ( resp . or - gates ) .",
    "the state set of the ocn @xmath575 contains all gates of the circuit @xmath432 ; the unique output gate becomes the distinguished state @xmath483 .",
    "we add the transition @xmath576 to @xmath345 and @xmath346 if gate @xmath577 is a child of gate @xmath578 .",
    "if gate @xmath340 is an input gate labeled with @xmath493 then we add the transition @xmath579 to @xmath346 .",
    "if @xmath580 , then the transition @xmath581 is also added to @xmath345 . finally , for the states @xmath505 we have the same transitions as in the proof of proposition  [ prop main ] .",
    "this concludes the description of the ocn @xmath568 .    in order to describe the @xmath4 formula @xmath569",
    "let @xmath582 ( resp .",
    "@xmath583 ) if @xmath574 ( resp .",
    "@xmath573 ) for @xmath572 $ ] . then let @xmath584 where the proposition @xmath585 is used in the same way as in the proof of proposition  [ prop main ] to allow to test if the counter value is zero .",
    "it is clear that this formula fulfills the requirements of the theorem .",
    "[ t ef ] the following problem is @xmath10-hard :    input : an ocn @xmath509 , a state @xmath334 of @xmath509 , and an @xmath4 formula @xmath104 .",
    "question : @xmath586 ?",
    "let us take a boolean formula @xmath428 .",
    "we construct an ocn @xmath587 with a distinguished state @xmath334 and an @xmath4 formula @xmath588 such that @xmath589 if and only if @xmath313 is satisfiable and the maximal number @xmath429 $ ] with @xmath430 is even .    as in the proof of theorem",
    "[ theo ctl data ] ( steps 2 and 3 ) , we compute in logarithmic space the list @xmath516 of the first @xmath309 consecutive primes and the circuit @xmath519 , 0 \\leq r < p_i } ) $ ] of logarithmic depth and fan - in at most two from theorem  [ theorem hesse und co ] .",
    "we combine @xmath520 with the boolean formula @xmath428 and obtain a boolean circuit @xmath590 , 0 \\leq r < p_i})$ ] such that for every number @xmath426 : @xmath591 as in the proof of theorem  [ theo ctl data ] let @xmath65 be the boolean formula @xmath529 } x_{i , r_i}$ ] were @xmath530 for @xmath523 $ ] .",
    "the main structure of the ocn @xmath587 is described by the following diagram :    ( 100,40)(-10,-15 ) ( -15,4)@xmath346 : ( q)(0,5)@xmath334 ( q)@xmath343 ( p)(20,0)@xmath147 ( q , p)@xmath25 ( p)@xmath337 ( r)(20,10)@xmath494 ( q , r)@xmath343 ( r)@xmath343 ( s)(40,10)@xmath22 ( r , s)@xmath25 ( s)@xmath337 ( 55,4)@xmath592 : ( q)(70,5)@xmath334 ( q)@xmath343 ( p)(90,0)@xmath147 ( q , p)@xmath25 ( r)(90,10)@xmath494 ( q , r)@xmath343    from the states @xmath334 , @xmath593 , and @xmath22 some further @xmath25-labeled transitions emanate to ocns of the form constructed in proposition  [ prop main ef ] :    * from @xmath334 a transition into the initial state @xmath483 of a copy of @xmath568 . * from @xmath147 and @xmath22 a transition into the initial state @xmath483 of a copy of @xmath556 . * from @xmath494 a transition into the initial state @xmath483 of a copy of @xmath594 .",
    "now our @xmath4 formula @xmath588 expresses the following : we can reach a configuration @xmath595 from @xmath596 in the ocn @xmath587 such that the following holds :    * @xmath597 , * from @xmath595 we can not reach a configuration @xmath598 with @xmath599 and @xmath600 ( i.e. , @xmath601 ) , and * for all configurations @xmath602 that are reachable from @xmath595 ( hence @xmath603 ) the following holds : if we can not reach a configuration @xmath604 from @xmath605 with @xmath606 then @xmath607 .    using the formulas constructed in proposition  [ prop main ef ]",
    ", it is straightforward to transform this description into a real @xmath4 formula .",
    "this concludes the proof .    at the moment",
    "we can not prove @xmath608-hardness for the data complexity of @xmath4 over ocps .",
    "for this , it would be sufficient to have a fixed @xmath4 formula @xmath569 in ( [ varphi(c , b ) ] ) . note that this formula only depends on the number of layers @xmath281 of the circuit @xmath432 .",
    "hence , if @xmath432 is from an @xmath6-circuit family , then @xmath569 is in fact a fixed formula . in our case",
    ", the circuit is the composition of two circuits , one from an @xmath5-circuit family ( coming from theorem  [ theorem hesse und co ] , where we could even assume a @xmath437-circuit family ) and a boolean formula , which can be assumed to be in conjunctive normal form .",
    "hence , the main obstacle for getting a fixed formula is the fact that converting from chinese remainder representation to binary representation is not possible in @xmath6 ( this is provably the case ) .",
    "in this section we show that the techniques developed in the previous sections can be used to improve a lower bound on verifying reachability objectives on one - counter markov decision processes from @xcite .",
    "a _ probability distribution _ on a non - empty finite set @xmath69 is a function @xmath609 such that @xmath610 .",
    "we restrict here to rational probabilities , in order to get finite representations for probability distributions .",
    "a ( image - finite ) _ markov chain _ is a triple @xmath611 , where @xmath612 is an image - finite and deadlock - free directed graph ( @xmath69 is also called the set of states of @xmath613 ) and @xmath339 assigns to each @xmath614 a probability distribution @xmath615 over all ( the finitely many ) successors of @xmath22 w.r.t .",
    "if @xmath616 , then we also use the notations @xmath617 or @xmath618 for @xmath619 .",
    "a ( image - finite ) _ markov decision process _ ( mdp ) is a triple @xmath620 , where @xmath621 is again an image - finite and deadlock - free directed graph , the set @xmath622 of vertices is partitioned as @xmath623 ( @xmath624 is the set of _ nondeterministic _ vertices , @xmath625 is the set of _ probabilistic _ vertices ) , and @xmath339 assigns to each probabilistic vertex @xmath626 a probability distribution on @xmath17 s successors .",
    "a _ strategy _",
    "@xmath24 is a function that assigns to each @xmath627 with @xmath628 and @xmath629 a probability distribution on @xmath17 s successors .",
    "if @xmath24 assigns to @xmath627 and @xmath630 ( where @xmath631 ) the probability @xmath467 , then we write @xmath632 .",
    "every strategy @xmath24 determines a markov chain @xmath633 , where @xmath634 if and only if @xmath635 and moreover either @xmath626 and @xmath636 , or @xmath637 and @xmath632 .",
    "let @xmath638 and @xmath639 ; paths in these sets will be called",
    "_ runs _ in @xmath640 or @xmath641 , respectively .",
    "note that every run in @xmath640 corresponds to a unique run in @xmath641 and vice versa in a natural way .",
    "in order to simplify notation , we will quite often identify these corresponding runs .",
    "let us fix a set of _ target vertices _ ( also called a _ reachability objective _ ) @xmath642 of the mdp @xmath640 .",
    "for each strategy @xmath24 and each vertex @xmath643 of @xmath640 , let @xmath644 denote all runs in @xmath641 that start in @xmath17 and that satisfy the reachability objective @xmath111 in @xmath640 .",
    "for each @xmath111 and each @xmath17 , the set @xmath645 is measurable .",
    "the probability @xmath646 for the set @xmath645 can be obtained as follows : take all finite paths @xmath647 that start in @xmath17 and such that the last state of @xmath52 is from @xmath648 but no previous state in @xmath52 is from @xmath648 ( this set is prefix free ) .",
    "for each such finite path @xmath649 such that @xmath650 in @xmath641 the probability is @xmath651 . finally , the probability for @xmath645 is the ( possibly infinite ) sum of all these probabilities .",
    "now , let us define the _ @xmath111-reachability value in @xmath17 _ by @xmath652 observe that it is not required that this supremum is actually reached by a certain strategy @xmath24 .",
    "if however a strategy @xmath24 does reach the @xmath111-reachability value , i.e. , @xmath653 , then @xmath24 is called _",
    "optimal_.    a one - counter markov decision process ( oc - mdp ) is a tuple @xmath654 , where @xmath655 is a finite set of _ control locations _ which is partitioned into _ nondeterministic control locations _ @xmath656 and _ probabilistic control locations _ @xmath657 , @xmath658 is a set of _ zero transitions _ and @xmath659 is a set of _ positive transitions _ such that each @xmath151 has at least one outgoing zero transition and at least one outgoing positive transition , and finally @xmath660 ( resp .",
    "@xmath661 ) assigns to each @xmath662 a probability distribution over all outgoing zero ( resp .",
    "positive ) transitions of @xmath510 .",
    "the mdp that @xmath663 describes is @xmath664 , where    * @xmath665 and @xmath666 , and * @xmath667 if and only if one of the following two holds : * * @xmath668 and @xmath669 . in this case",
    "@xmath339 assigns to @xmath667 the probability @xmath670 .",
    "* * @xmath671 and @xmath672 . in this case",
    "@xmath339 assigns to @xmath667 the probability @xmath673 .",
    "given an oc - mdp @xmath654 and a set of control locations @xmath674 , define @xmath675 and @xmath676 ( both sets are defined w.r.t @xmath677 ) . in other words : @xmath20 is the set of all states @xmath263 of the mdp @xmath677 such that for every @xmath23 there exists a strategy @xmath678 under which the probability of reaching from @xmath263 a control location in @xmath19 and at the same time having counter value @xmath25 is at least @xmath26 .",
    "@xmath21 is the set of all states @xmath263 of the mdp @xmath677 for which there exists a specific strategy under which this probability becomes @xmath8 .",
    "[ oc - mdp-1 ] the following problem is @xmath1-hard and in @xmath9 :    input : an ocp - mdp @xmath654 , @xmath674 , and @xmath151 .",
    "question : @xmath679 ?",
    "theorem  [ oc - mdp-1 ] was proven by a reduction from the @xmath1-complete emptiness problem for alternating finite word automata over a singleton alphabet ( @xcite , see also @xcite for a simplified presentation ) .",
    "[ oc - mdp-2 ] the following problem is hard for every level of @xmath29 :    input : an oc - mdp @xmath654 , @xmath674 , and @xmath151 .",
    "question : @xmath680 ?",
    "currently , it is open whether the problem stated in theorem  [ oc - mdp-2 ] is decidable ; the corresponding problem for mdps defined by pushdown processes is undecidable @xcite .    from the proof of theorem  [ oc - mdp-2 ]",
    "it can be seen that the authors prove actually hardness for @xmath423}$ ] .",
    "moreover , it is pointed out in @xcite that various difficulties arise when trying to improve the latter lower bound . in this section",
    ", we will improve the lower bound for membership in @xmath20 to @xmath1 . from our proof",
    "one can easily see that we reprove @xmath1-hardness of @xmath681 as a byproduct . but first , we need the following lemma .",
    "[ l prob ] the following problem can be solved by a logspace transducer :    input : a list of the first @xmath309 consecutive ( encoded in unary ) prime numbers and a boolean formula @xmath682 , 0 \\leq r < p_i})$ ] .",
    "output : an oc - mdp @xmath683 with control locations @xmath91 , a set @xmath684 , and some control location @xmath685 such that for every number @xmath686 the following holds :    * if @xmath485 , then there exists a strategy @xmath24 such that @xmath687 . * if @xmath688 , then for every strategy @xmath24 we have @xmath689 .    as in the proof of proposition  [ prop main ] we can eliminate all input gates labeled with a negated variable @xmath491 .",
    "the oc - mdp @xmath690 will have for each subformula @xmath65 of @xmath490 a control location @xmath691 . if @xmath65 is of the form @xmath692 , then @xmath691 will be nondeterministic and both in @xmath345 and in @xmath346 there is a transition from @xmath691 to both @xmath693 and @xmath694 that does not change the counter value . if @xmath65 is of the form @xmath695 , then @xmath691 will be probabilistic and both in @xmath345 and in @xmath346 there will be a transition to both @xmath693 and @xmath694 that does not change the counter value and which will be chosen with probability @xmath696 each .",
    "now assume that @xmath65 is a variable @xmath493 . recall that @xmath493 is set to one if and only if @xmath697 .",
    "we introduce in @xmath663 further ( deterministically behaving ) control locations @xmath698 for @xmath699 that allow to test if @xmath44 is congruent @xmath494 modulo @xmath447 by allowing the following transitions in @xmath346 for each @xmath699 : @xmath700 since each @xmath698 has to have an outgoing transition both in @xmath345 and @xmath346 , we add the transition @xmath701 to @xmath345 for each @xmath699 .",
    "we put @xmath702 to be nondeterministic with a transition both in @xmath345 and in @xmath346 from @xmath702 to @xmath703 that does not change the counter value .",
    "finally we put @xmath704\\}$ ] .",
    "assume first that @xmath485 .",
    "we prove that there exists a strategy @xmath24 such that @xmath705 in @xmath677 .",
    "note that the only nondeterministic states in @xmath677 that have more than one successor are states which correspond to a disjunctive subformula @xmath692 of @xmath490 . if @xmath706 , then there exists some @xmath707 such that @xmath708 .",
    "our strategy @xmath24 will choose @xmath709 s successor @xmath710 with probability @xmath8 . if @xmath711 , then the choice of @xmath24 is irrelevant and we let @xmath24 choose @xmath709 s successor uniformly distributed , say .",
    "it is now easy to verify that @xmath687 .    on the other hand , assume that @xmath688 and consider an arbitrary strategy @xmath24 .",
    "the question is how close can @xmath712 reach @xmath8 .",
    "we prove by induction on the structure of the formula @xmath490 that @xmath713 where @xmath281 is the number of conjunctions that appear in @xmath490 .",
    "if @xmath490 is a variable @xmath493 , then @xmath714 if @xmath715 then @xmath716 .",
    "assume that @xmath24 assigns to the transition from @xmath717 to @xmath718 the probability @xmath394 , where @xmath719 .",
    "with the induction hypothesis , we get @xmath720 where @xmath721 the number of conjunctions that appear in @xmath722 .",
    "since @xmath723 , we get ( [ case f=0 ] ) .",
    "finally , assume that @xmath724 and let @xmath721 be the number of conjunctions that appear in @xmath722 .",
    "hence , @xmath725 .",
    "if @xmath716 then we get @xmath726 . on the other hand ,",
    "if e.g. @xmath727 but @xmath728 ( the other case is symmetric ) , then we get @xmath729 this concludes the proof of ( [ case f=0 ] ) . since @xmath730 we obtain @xmath689",
    "this concludes the proof of lemma  [ l prob ] .",
    "[ t valone ] the following problem is @xmath1-hard :    input : an oc - mdp @xmath654 , @xmath674 , and @xmath151 .",
    "question : @xmath680 ?",
    "let @xmath731 be an arbitrary @xmath1-complete language , let @xmath732 be a word of length @xmath40 .",
    "we repeat steps 1 to 4 of the proof of theorem  [ theo ctl data ] .",
    "this means , we compute in logspace a boolean formula @xmath682 , 0 \\leq r < p_i})$ ] of polynomial size in @xmath40 such that for some fixed nfa @xmath733 we have @xmath734 by doubling , if necessary , the set of final states of @xmath47 we can assume that states from @xmath735 do not have outgoing transitions but every state from @xmath736 has at least one outgoing transition .",
    "this assumption will slightly simplify our construction .",
    "let @xmath737 } x_{i , r_i}$ ] with @xmath738 for each @xmath523 $ ] be the boolean formula that tests if @xmath44 equals @xmath555 .",
    "we will build an oc - mdp @xmath654 with @xmath739 and a target set of control locations @xmath674 such that @xmath740 moreover , our reduction will have the additional property that @xmath741 hence , we prove @xmath1-hardness of @xmath681 as a byproduct .",
    "the control locations in @xmath736 are nondeterministic in @xmath663 ( @xmath663 will hence behave nondeterministically in control locations from @xmath736 ) .",
    "the nfa @xmath47 on input @xmath742 will be simulated by @xmath663 from state @xmath743 by consecutively incrementing the counter and checking if for the current counter value @xmath44 and for the current ( to be simulated ) @xmath538-labeled transition of @xmath47 we have @xmath542 .",
    "this simulation will be done until a state @xmath551 with @xmath552 is reached . recall that by lemma  [ l prob ] we can compute oc - mdps @xmath744 , @xmath745 , and @xmath746 together with sets of control locations @xmath747 , @xmath748 , and @xmath749 , and control locations @xmath750 , @xmath751 , and @xmath691 such that , e.g. , @xmath744 satisfies for each @xmath752 : @xmath753 the oc - mdps @xmath745 and @xmath746 have analogous properties .    in the following diagrams we draw transitions that do _",
    "not _ modify the counter value in normal width and we draw transitions that increase the counter value by one in thicker width .",
    "we realize each nfa - transition @xmath754 with @xmath755 both in @xmath345 and in @xmath346 by    ( 60,35)(0,0 ) ( s)(0,30)@xmath22 ( b)(30,30)@xmath756 ( t)(60,30)@xmath146 ( f)(30,0)@xmath757 ( s , b ) ( b , t)@xmath758 ( b , f)@xmath758    whereas each transition @xmath759 with @xmath755 is realized in @xmath663 by    ( 60,35)(0,0 ) ( s)(0,30)@xmath22 ( b)(30,30)@xmath760 ( t)(60,30)@xmath146 ( f)(30,0)@xmath761 ( s , b ) ( b , t)@xmath758 ( b , f)@xmath758    i.e. we connect the intermediate control location @xmath762 to @xmath763 ( if @xmath764 ) or @xmath765 ( if @xmath766 ) for checking if @xmath542 and @xmath767 for the current counter value @xmath44 . moreover , for all final states @xmath552 we add a transition @xmath768 to both @xmath345 and @xmath346 that does not change the counter value .",
    "as expected , we put @xmath769 .",
    "let @xmath770 in the following .",
    "note that since every non - final state has at least one outgoing transition in @xmath47 , @xmath640 is indeed an mdp , i.e. , the underlying graph is deadlock - free .",
    "now assume that @xmath771 .",
    "we show that there exists a strategy @xmath24 such that @xmath772 .",
    "since @xmath771 , we have @xmath773 along with some accepting run @xmath774 where @xmath775 and @xmath776 for all @xmath777 $ ] . for each @xmath777 $ ] our strategy @xmath24 will assign to @xmath778 s successor @xmath779 probability @xmath8 .",
    "moreover , by lemma  [ l prob ] we can choose the strategy @xmath24 such that : @xmath780 for each @xmath781 and @xmath782 .",
    "it follows @xmath783 conversely , assume now that @xmath784 .",
    "our goal is to prove a global non - zero lower bound on the probability of runs in @xmath641 that begin in @xmath743 and that do _ not _ reach @xmath785 , where @xmath24 is an arbitrary strategy .",
    "for this , let us first fix an arbitrary strategy @xmath24 in @xmath640 .",
    "we distinguish the following three types @xmath786 , @xmath787 and @xmath788 of finite paths @xmath87 in the markov chain @xmath641 :    _ case ( a ) _",
    ": @xmath87 is of the form @xmath789 where @xmath790 , @xmath791 , and @xmath792 for all @xmath793 $ ] .",
    "the @xmath794 are probabilities that result from the strategy @xmath24 .",
    "let @xmath795 } \\alpha_n$ ] .",
    "the probability for the set of all runs from @xmath743 that ( i ) start with @xmath87 , then ( ii ) proceed to @xmath796 ( if @xmath797 ) or to @xmath798 ( if @xmath799 ) , and ( iii ) do _ not _ visit @xmath785 is at least @xmath800 _ case ( b ) _ :",
    "@xmath87 is of the form @xmath801 where @xmath790 , @xmath802 , and @xmath792 for all @xmath793 $ ] .",
    "let @xmath803 } \\beta_n$ ] .",
    "the probability for the set of all runs from @xmath743 that ( i ) start with @xmath87 and ( ii ) do _ not _ visit @xmath785 is at least @xmath804 _ case ( c ) _ : @xmath87 is of the form @xmath805 where @xmath806 and @xmath792 for all @xmath807 $ ] .",
    "let @xmath808 } \\gamma_n$ ] .",
    "the probability of the set of runs in @xmath641 that ( i ) begin with @xmath87 , then ( ii ) proceed ( via an intermediate control location of the form @xmath809 ) to either @xmath810 or @xmath811 and ( iii ) that do _ not _ reach @xmath785 is at least @xmath812 now , the crucial point is that the sum of all values @xmath381 from ( a ) , all values @xmath383 from ( b ) , and all values @xmath585 from ( c ) is @xmath8 . to see this , note that the nondeterministic choices in @xmath640 correspond exactly to the selection of transitions in the nfa @xmath47 .",
    "but , since @xmath813 , every sequence of consecutive transitions in @xmath47 either ( i ) reads in the @xmath814 step ( for some @xmath426 ) a symbol different from @xmath815 ( case ( a ) ) or ( ii ) reaches a final state after less than @xmath555 steps ( case ( b ) ) , or ( iii ) make at least @xmath555 steps and is not in a final state after exactly @xmath555 steps ( case ( c ) ) .",
    "since moreover the set of paths in ( a ) , ( b ) , and ( c ) are pairwise disjoint , it follows that the probability of the set of runs that do _ not _ reach @xmath785 is at least @xmath816 .",
    "this concludes the proof of the theorem .",
    "10    s.  arora and b.  barak . .",
    "cambrdige university press , 2009 .    c.  baier and j.  p. katoen .",
    ". mit press , 2009 .",
    "w. beame , s.  a. cook , and h.  j. hoover .",
    "log depth circuits for division and related problems . , 15(4):9941003 , 1986 .",
    "a.  bouajjani , j.  esparza , and o.  maler .",
    "reachability analysis of pushdown automata : application to model - checking . in a.",
    "w. mazurkiewicz and j.  winkowski , editors , _ proceedings of the 8th international conference on concurrency theory ( concur97 ) _ , number 1243 in lecture notes in computer science , pages 135150 .",
    "springer , 1997 .",
    "t.  brazdil , v.  brozek , k.  etessami , a.  kucera , and d.  wojtczak .",
    "one - counter markov decision processes .",
    "technical report , arxiv.org , 2009 . .",
    "t.  cachat .",
    "uniform solution of parity games on prefix - recognizable graphs . , 68(6 ) , 2002 .",
    "cai and m.  furst .",
    "pspace survives constant - width bottlenecks .",
    ", 2(1):6776 , 1991 .",
    "a.  chiu , g.  davida , and b.  litow .",
    "division in logspace - uniform @xmath817 .",
    ", 35(3):259275 , 2001 .",
    "j.  esparza , d.  hansel , p.  rossmanith , and s.  schwoon .",
    "efficient algorithms for model checking pushdown systems . in e.",
    "a. emerson and a.  p. sistla , editors , _ proceedings of the 12th international conference on computer aided verification ( cav 2000 ) _ , number 1855 in lecture notes in computer science , pages 232247 .",
    "springer , 2000 .",
    "k.  etessami and m.  yannakakis .",
    "recursive markov decision processes and recursive stochastic games . in _ proceesing of the 32nd international colloquium on automata , languages and programming ( icalp 2005 ) _ , number 3580 in lecture notes in computer science , pages 891903 , 2005 .",
    "s.  gller and m.  lohrey .",
    "infinite state model - checking of propositional dynamic logics . in _ proceedings of the 20th international conference on computer science logic ( csl 2006 ) _ , number 4207 in lecture notes in computer science , pages 349364 .",
    "springer , 2006 .",
    "s.  gller , r.  mayr , and a.  w. to . on the computational complexity of verifying one - counter processes . in _ proceedings of the 24th annual ieee symposium on logic in computer science ( lics 2009 ) _ , pages 235244 .",
    "ieee computer society press , 2008 .    c.  haase , s.  kreutzer , j.  ouaknine , and j.  worrell .",
    "reachability in succinct and parametric one - counter automata . in m.",
    "bravetti and g.  zavattaro , editors , _ proceedings of the 20th international conference on concurrency theory ( concur09 ) _ , number 5710 in lecture notes in computer science , pages 369383 .",
    "springer , 2009 .",
    "u.  hertrampf , c.  lautemann , t.  schwentick , h.  vollmer , and k.  w. wagner . on the power of polynomial time bit - reductions . in _ proceedings of the eighth annual structure in complexity",
    "theory conference _",
    ", pages 200207 .",
    "ieee computer society press , 1993 .",
    "w.  hesse , e.  allender , and d.  a.  m. barrington .",
    "uniform constant - depth threshold circuits for division and iterated multiplication . , 65:695716 , 2002 .    m.  holzer . on emptiness and counting for alternating finite automata . in _ proceedings of the 2nd international conference on developments in language theory ( dlt 1995 ) _",
    ", pages 8897 .",
    "world scientific , 1996 .",
    "p.  janar and z.  sawa . a note on emptiness for alternating finite automata with a one - letter alphabet .",
    "104(5):164167 , 2007 .    m.  nair .",
    "on chebyshev - type inequalities for primes .",
    ", 89(2):126129 , 1982 .",
    "n.  piterman and m.  y. vardi .",
    "global model - checking of infinite - state systems . in r.",
    "alur and d.  peled , editors , _ proceedings of the 16th international conference on computer aided verification ( cav 2004 ) _ , number 3114 in lecture notes in computer science , pages 387400 .",
    "springer , 2004 .",
    "o.  serre .",
    "parity games played on transition graphs of one - counter processes . in l.",
    "aceto and a.  inglfsdttir , editors , _ proceedings of the 9th international conference on foundations of software science and computation structures ( fossacs 2006 ) _ , number 3921 in lecture notes in computer science .",
    "springer , 2006 .",
    "d.  thrien and t.  wilke .",
    "temporal logic and semidirect products : an effective characterization of the until hierarchy . in _ in proceedings of the 37th annual symposium on foundations of computer science ( focs 96 ) _ , pages 256263 .",
    "ieee computer society press , 1996 .",
    "a.  w. to .",
    "model checking fo(r ) over one - counter processes and beyond . in",
    "_ proceedings of the 23rd international conference on computer science logic ( csl 2009 ) _ , number 5771 in lncs .",
    "springer verlag , 2009 . to appear .",
    "h.  vollmer .",
    "a generalized quantifier concept in computational complexity theory .",
    "technical report , arxiv.org , 1998 .",
    "http://arxiv.org/abs/cs.cc/9809115 .",
    "h.  vollmer . .",
    "springer , 1999 .    k.  w. wagner .",
    "more complicated questions about maxima and minima , and some closures of np .",
    ", 51:5380 , 1987 .",
    "i.  walukiewicz .",
    "model checking ctl properties of pushdown systems . in s.",
    "kapoor and s.  prasad , editors , _ proceedings of the 20th conference on foundations of software technology and theoretical computer science ( fsttcs 2000 ) _ , number 1974 in lecture notes in computer science , pages 127138 .",
    "springer , 2000 .",
    "i.  walukiewicz .",
    "pushdown processes : games and model - checking . , 164(2):234263 , 2001 .",
    "let @xmath44 be a nondeterministic turing machine with a linear ordering on the set of all transition tuples .",
    "assume furthermore that @xmath44 does not contain infinite computation paths .",
    "then , for every input @xmath467 , the computation tree @xmath818 of the machine @xmath44 on input @xmath467 is a finite ordered tree .",
    "let @xmath819 be a list of all leafs of @xmath818 in left - to - right enumeration .",
    "then the _ leaf string _",
    "@xmath820 is the string @xmath821 , where @xmath822 ( resp .",
    "@xmath823 ) if @xmath824 is an accepting ( resp . rejecting ) configuration .",
    "let @xmath47 be a language in @xmath1 .",
    "then @xmath47 is @xmath6-serializable , i.e. , there exists a regular language @xmath731 , a polynomial @xmath439 , and a logspace - uniform @xmath6-circuit family @xmath825 , where @xmath826 has exactly @xmath471 many inputs and one output , such that for every @xmath472 we have : @xmath827 where `` @xmath474 '' refers to the lexicographic order on @xmath475 .",
    "let @xmath828 be a language in @xmath1 . by the work of @xcite there exists a nondeterministic polynomial time turing machine @xmath829 and a regular language @xmath830 such that @xmath831 here , @xmath91 is the set of states",
    ", @xmath832 is the tape alphabet , @xmath833 is the set of transition tuples , @xmath334 is the initial state , @xmath834 is the final ( accepting ) state , and @xmath835 is the blank symbol .",
    "we can assume that every computation path of @xmath44 on an input of length @xmath40 has length @xmath836 for a polynomial @xmath510 .",
    "this can be enforced by introducing a counter .",
    "note that the counter can be incremented deterministically , hence the produced leaf string does not change .",
    "assume that @xmath837 , where @xmath838 is the fixed order on the transition tuples of @xmath44 .",
    "let @xmath839 , where all three sets are assumed to be pairwise disjoint .",
    "we will encode a computation of @xmath44 of length @xmath836 , starting on input @xmath840 , by a word from the language @xmath841 here , @xmath842 means that configuration @xmath843 results from configuration @xmath844 by applying transition @xmath845 .",
    "let @xmath846 be the subset of @xmath847 consisting of all successful computations @xmath848 , where in addition @xmath849 .",
    "note that every word in @xmath847 has length @xmath850 .",
    "we use some block encoding @xmath851 such that @xmath852 is lexicographically larger than @xmath853 for @xmath854 $ ] .",
    "this ensures that if we list all bit strings of length @xmath855 in lexicographic order than the subset @xmath847 of all ( encodings of ) valid computations appears as a subsequence in the same order as in the computation tree @xmath818 .",
    "let us next describe a logspace - uniform @xmath6-circuit family @xmath445 , where the @xmath40-th circuit @xmath441 has @xmath856 many inputs and accepts exactly all strings of the form @xmath857 , where @xmath472 and @xmath858 .",
    "constructing @xmath441 is tedious but straightforward .",
    "the most difficult part is to check @xmath842 for all @xmath859 . for this",
    ", we use an and - gate @xmath340 with @xmath836 many children @xmath860 .",
    "gate @xmath861 is an or - gate with @xmath836 many children @xmath862 .",
    "gate @xmath863 evaluates to @xmath8 if and only if @xmath843 results from @xmath844 by applying the transition @xmath845 at position @xmath141 . to achieve this",
    ", @xmath863 becomes an and - gate with @xmath864 many input gates .",
    "each of these gates compares two corresponding bits in the @xmath585-encodings of @xmath844 and @xmath843",
    ". it should be clear that such a circuit @xmath441 can be built in logarithmic space .",
    "analogously we can construct a logspace - uniform @xmath6-circuit family @xmath865 which accepts all strings of the form @xmath857 , where @xmath472 and @xmath866 .",
    "finally , we construct from the two families @xmath445 and @xmath865 a new logspace - uniform @xmath6-circuit family @xmath825 , where @xmath826 has @xmath867 many inputs . on input",
    "@xmath868 ( with @xmath840 ) it outputs @xmath869 . on input @xmath870 , @xmath826 outputs @xmath871 .",
    "now , let us construct from the regular language @xmath830 the new regular language @xmath872 , where @xmath873 is the shuffle operator , @xmath874 is a new symbol , and @xmath104 is the homomorphism with @xmath875 , @xmath876 , @xmath877 ."
  ],
  "abstract_text": [
    "<S> one - counter processes ( ocps ) are pushdown processes which operate only on a unary stack alphabet </S>",
    "<S> . we study the computational complexity of model checking computation tree logic ( @xmath0 ) over ocps . </S>",
    "<S> a @xmath1 upper bound is inherited from the modal @xmath2-calculus for this problem @xcite . </S>",
    "<S> first , we analyze the periodic behaviour of @xmath0 over ocps and derive a model checking algorithm whose running time is exponential only in the number of control locations and a syntactic notion of the formula that we call leftward until depth . </S>",
    "<S> in particular , model checking fixed ocps against @xmath0 formulas with a fixed leftward until depth is in @xmath3 . </S>",
    "<S> this generalizes a corresponding result from @xcite for the expression complexity of @xmath0 s fragment @xmath4 . </S>",
    "<S> second , we prove that already over some fixed ocp , @xmath0 model checking is @xmath1-hard , i.e. , expression complexity is @xmath1-hard . </S>",
    "<S> third , we show that there already exists a fixed @xmath0 formula for which model checking of ocps is @xmath1-hard , i.e. , data complexity is @xmath1-hard as well . to obtain the latter result , we employ two results from complexity theory : ( i ) converting a natural number in chinese remainder presentation into binary presentation is in logspace - uniform @xmath5 @xcite and ( ii ) @xmath1 is @xmath6-serializable @xcite . </S>",
    "<S> we demonstrate that our approach can be used to obtain further results . </S>",
    "<S> we show that model - checking @xmath0 s fragment @xmath4 over ocps is hard for @xmath7 , thus establishing a matching lower bound and answering an open question from @xcite . </S>",
    "<S> we moreover show that the following problem is hard for @xmath1 : given a one - counter markov decision process , a set of target states with counter value zero each , and an initial state , to decide whether the probability that the initial state will eventually reach one of the target states is arbitrarily close to @xmath8 . </S>",
    "<S> this improves a previously known lower bound for every level of the boolean hierarchy shown in @xcite . </S>"
  ]
}