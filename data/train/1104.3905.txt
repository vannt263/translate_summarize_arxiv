{
  "article_text": [
    "the power set of a set @xmath31 is denoted by @xmath44 .",
    "the disjoint union of two sets @xmath45 is denoted by  @xmath46 .",
    "we assume that trees are rooted and denote the root of a tree @xmath47 by @xmath48 .",
    "for every @xmath49 , @xmath50 is a @xmath51-times iterated exponential , i.e. , @xmath52 and @xmath53 .    for a set @xmath31 and object @xmath37 ,",
    "we let @xmath54 be defined as @xmath55    to avoid cluttered notation , we may , for elements @xmath56 and @xmath57 , abbreviate @xmath58 , @xmath59 , and @xmath60 .",
    "we fix a countably infinite set of _",
    "symbols_. each symbol @xmath61 has an _ arity _  @xmath62 .",
    "we distinguish between _ nullary _ symbols with arity zero and _ relation symbols _ that have arity greater than zero .",
    "relation symbols with arity one are called _",
    "unary_. for convenience , we shall denote relation symbols by capital letters and nullary symbols by lower case letters .    a _ vocabulary _",
    "@xmath63 is a finite set of symbols .",
    "we denote by @xmath64 the set of nullary symbols in @xmath63 , by @xmath65 the set of relation symbols in @xmath63 , and by @xmath66 the set of unary relation symbols in @xmath63 .",
    "let @xmath67 be the maximum arity over all relation symbols in @xmath63 . if @xmath68 , we call @xmath63 _ relational_.    let @xmath63 be a vocabulary . a _ structure  @xmath34 over @xmath63 _ ( or @xmath63-structure ) is a tuple @xmath69 , where @xmath2 is a finite set called the _ universe _ of @xmath34 , and @xmath70 and @xmath71 are _ interpretations _ of the @xmath63-symbols in  @xmath34 . here , @xmath72 for each relation symbol @xmath73 .",
    "for a nullary symbol @xmath74 we either have @xmath75 and say that @xmath76 is _ interpreted _ in  @xmath34 , or we write @xmath77 and say that  @xmath76 is _ uninterpreted_. the set of nullary symbols interpreted in @xmath34 is denoted by @xmath78 .",
    "if all symbols are interpreted , we say the structure is _ fully interpreted _ , and _ partially interpreted _ otherwise .",
    "we note that a related concept of _ partially equipped signatures _ has been used in , e.g. ,  @xcite .",
    "the set of all @xmath63-structures is denoted by @xmath79 .",
    "we shall always denote structures in script letters @xmath80 and in roman letters @xmath81 their corresponding universes .",
    "if the universe is empty , then we say that the structure is _",
    "empty_. structures over a relational vocabulary @xmath63 are called _",
    "relational structures_.    for a structure @xmath34 , we denote by @xmath82 the vocabulary of @xmath34 . for sets",
    "@xmath83 and @xmath84 , we let @xmath85 , and @xmath86 be their corresponding interpretations .",
    "[ ex : taugraph ] a graph @xmath87 can in a natural way be identified with a structure  @xmath88 over the vocabulary @xmath89 , where @xmath90 represents the binary adjacency relation .",
    "the universe of @xmath88 is @xmath91 , and we interpret @xmath90 as @xmath92 in  @xmath88 .",
    "let @xmath63 be a vocabulary and @xmath93 be a set of symbols , each of which is not contained in  @xmath63 .",
    "the vocabulary @xmath94 is called an _ expansion _ of  @xmath63 . similarly ,",
    "if @xmath34 is a @xmath63-structure and @xmath35 is a @xmath95-structure that agrees with @xmath34 on @xmath63 , i.e. , @xmath96 for each @xmath73 and @xmath97 for each @xmath98 , then we call @xmath35 a @xmath95-expansion of  @xmath34",
    ". if  @xmath34 is a @xmath63-structure , and @xmath99 are relations over  @xmath2 , such that @xmath100 , @xmath101 , and @xmath102 , we write @xmath103 to indicate that @xmath35 is a @xmath95-expansion of @xmath34 , such that @xmath104 , @xmath101 , and @xmath105 , @xmath106 .",
    "let @xmath34 be a @xmath63-structure and @xmath107 .",
    "then @xmath108 $ ] is the _ substructure of @xmath34 induced by @xmath109 _",
    ", where @xmath108 $ ] has universe @xmath109 , for each relation symbol @xmath110 we have @xmath111 } = r^{{\\ensuremath{\\mathscr{a } } } } \\cap \\bar a^{{\\ensuremath{{\\it arity}}}(r)}$ ] , and nullary symbols @xmath76 are interpreted as @xmath112 } = c^{{\\ensuremath{\\mathscr{a}}}}$ ] if @xmath113 and become uninterpreted otherwise .",
    "two @xmath63-structures @xmath34 and @xmath114 over the same vocabulary  @xmath63 are _ isomorphic _ , denoted by @xmath115 , if there is an _ isomorphism _ @xmath116 , where @xmath117 is a bijection between @xmath2 and @xmath118 and    * @xmath119 if and only if @xmath120 for all @xmath98 , * @xmath121 for every nullary symbol @xmath122 , and * for every relation symbol @xmath110 and @xmath123 , where @xmath124 , @xmath125    we call two @xmath63-structures @xmath126 and @xmath127 _ compatible _ , if for all nullary symbols @xmath128 we have @xmath129 and the identity @xmath130 is an isomorphism between @xmath131 $ ] and @xmath132 $ ] .    in this case , we define the _ union _ of @xmath126 and @xmath127 , denoted by @xmath133 , as the @xmath63-structure with universe @xmath134 and interpretations @xmath135 for every relation symbol @xmath110 .",
    "nullary symbols @xmath98 with @xmath136 remain uninterpreted in @xmath133 ; otherwise @xmath137 if @xmath138 for some @xmath139 .",
    "tree decompositions and treewidth were introduced by robertson and seymour  @xcite in their works on the graph minors project , cf .",
    "@xcite .",
    "a _ tree decomposition _ of a relational @xmath63-structure @xmath34 is a tuple @xmath140 , where @xmath141 is a rooted tree and @xmath142 is a collection of subsets @xmath143 , such that    * @xmath144 , * for all @xmath145-ary relation symbols @xmath110 and all @xmath146 , there is an @xmath147 such that @xmath148 , and * for all @xmath149 , if @xmath150 is on the path between @xmath151 and @xmath152 in @xmath47 , then @xmath153 .    the sets @xmath154 are called _",
    "bags_. the _ width _ of a tree decomposition is the size of its largest bag minus one , and the _ treewidth _ of a structure @xmath34 is the minimum width of all tree decompositions of  @xmath34 .    without loss of generality , we assume that each tree decomposition we consider is _ nice_. nice tree decompositions are directed , where each edge in @xmath155 has a direction away from the root , and have the following properties : each node @xmath147 has at most two children . for leafs @xmath147",
    ", we have @xmath156 .",
    "if @xmath150 has exactly one child  @xmath157 , then there is @xmath158 such that either @xmath159 or @xmath160 . in the former case ,",
    "we say @xmath150 is an _ introduce _ node , in the latter case we call @xmath150 a _ forget _ node of the tree decomposition . finally , if a node @xmath150 has two children @xmath151 and @xmath152 , then we require @xmath161 and call such nodes _ join _ nodes .",
    "if @xmath162 is a directed path in @xmath47 pointing away from the root , we say @xmath157 appears _ below _",
    "@xmath150 in @xmath47 .    with every node @xmath147 of a ( nice ) tree decomposition of a @xmath63-structure @xmath34",
    "we associate a substructure @xmath163 defined as follows : let @xmath164 be the set of objects in @xmath154 or in bags @xmath165 for nodes @xmath157 below @xmath150 in the tree decomposition",
    ". then we let @xmath166 $ ] be the substructure of @xmath34 induced by @xmath167 .    computing the treewidth of a graph is np - complete  @xcite .",
    "however , the algorithms in this paper rely on a given tree decomposition of the input structure . for graphs",
    "@xmath15 , there is a fixed - parameter tractable algorithm  @xcite with a running time of @xmath168 , whose dependence on the treewidth might become a problem in practical applications . in a practical setting , heuristics seem to work well and often nearly optimal tree decompositions can be computed  @xcite . using _ gaifman graphs _ , one can also compute tree decompositions of arbitrary structures , cf .",
    ",  ( * ? ? ?",
    "* section  11.3 ) . in the following ,",
    "we therefore just assume a tree decomposition is given as part of the input .",
    "for more information on treewidth , we refer the reader to surveys such as  @xcite .",
    "mso logic over a vocabulary @xmath63 , denoted by @xmath169 , is simultaneously defined over all vocabularies  @xmath63 by induction .",
    "firstly , for every @xmath145-ary relation symbol @xmath110 and any nullary symbols @xmath170 , @xmath169 contains the _ atomic _ formula @xmath171 . if @xmath29 is unary , we may abbreviate @xmath172 as @xmath173 . secondly :    * if @xmath174 are in @xmath169 , then @xmath175 , @xmath176 , and @xmath177 are in @xmath169 , * if @xmath178 for some nullary symbol  @xmath76 , then both , @xmath179 and @xmath180 are in @xmath169 .",
    "this is called _ first order _ or _",
    "object quantification_. * if @xmath181 for a unary relation symbol @xmath29 , then both , @xmath182 and @xmath183 are in @xmath169 .",
    "the corresponding case is called _ second order _ or _ set quantification_.    note that we do not distinguish between `` basic '' symbols ( contained in a certain `` base '' vocabulary such as @xmath184 ) , and symbols that are used as _ variables _ subject to quantification .",
    "let @xmath63 be a vocabulary and @xmath185 be a formula .",
    "let @xmath186 be the smallest vocabulary with @xmath187 .",
    "then we call the symbols in @xmath188 the _ free _ symbols of @xmath8 .",
    "let @xmath9 be the size of a suitable encoding of  @xmath8 .",
    "if @xmath189 for some @xmath76 , @xmath29 , @xmath190 , @xmath191 , and @xmath192 , we call @xmath8 _ universal_. similarly , we call @xmath8 _ existential _ if @xmath193 .",
    "if @xmath8 does not contain set quantifiers , then we say @xmath8 is _ first order _ and contained in @xmath194 .",
    "note that in particular all atomic formulas of @xmath169 are first order .",
    "the _ quantifier rank _",
    "@xmath195 of a formula @xmath196 denotes the maximum number of nested quantifiers in @xmath8 , counting both first order and second order quantifiers , and is defined by induction over the structure of  @xmath8 as    * @xmath197 if @xmath8 is an atomic formula , * @xmath198 , * @xmath199 if @xmath200 , and * @xmath201 if @xmath202 .    without loss of generality ,",
    "we assume throughout the paper that every formula is in negation normal form , i.e. , the negation symbol  @xmath203 only occurs in front of atomic formulas",
    ". this can be achieved by a simple rewriting of the formula .",
    "for a fully interpreted @xmath63-structure @xmath34 and a formula @xmath204 , we write @xmath38 if and only if @xmath8 _ holds _ in @xmath34 or is _ true _ in @xmath34 in the classical sense , cf .",
    ". we shall do not specify this further , since we will switch to a game - theoretic characterization in the remainder of this paper , cf .",
    ", section  [ sec : mcg ] .    in  @xcite , extended mso was introduced . here",
    ", an mso - formula over a relational vocabulary is given together with an evaluation or optimization goal over the unary relation symbols ( set variables ) .",
    "this principle was furthermore generalized to semiring homomorphisms in  @xcite , where satisfying interpretations of the free relation symbols are to be translated into an appropriate semiring .    in this paper",
    ", we shall consider mso - definable linear optimization problems , also called @xmath205-definable optimization problems .",
    "it is not hard to see that the methods in this paper extend to other classes of mso - definable problems , such as counting and enumeration problems .",
    "see , e.g. ,  ( * ? ? ?",
    "* chapter  6 ) for an overview of mso - definable problems and their algorithmic applications .",
    "let @xmath63 be a relational vocabulary , @xmath206 be a set of unary relation symbols , @xmath204 , and @xmath207 .",
    "let @xmath208 and @xmath209 .",
    "then we call the problem of , given a @xmath95-structure @xmath34 , computing @xmath210 a _",
    "@xmath205-definable optimization problem_.    [ ex : mso - examples ] consider the following formulas : @xmath211 then , given a @xmath184-structure @xmath88 , @xmath212 encode the well known graph problems minimum vertex cover , minimum dominating set , and 3-colorability , respectively .",
    "the semantics of mso in the classical sense ( cf .",
    "@xcite ) can be characterized using a two player pebble game , called the _ hintikka game _ or _ model checking game _ , cf .",
    "@xcite .",
    "a pebble _ game _ @xmath213 between two players , say player  0 and player  1 , consists of a finite set  @xmath214 of _ positions _ , two disjoint sets @xmath215 assigning positions to the two players , an _ initial position _",
    "@xmath216 , and an acyclic binary relation @xmath217 , which specifies the valid _ moves _ in the game .",
    "we only allow moves from positions assigned to one of the two players , i.e. , we require @xmath218 for all @xmath219 . on the other hand , we do allow that positions without outgoing moves are assigned to players .",
    "let @xmath220 be the _ size _ of  @xmath6 .    for @xmath221 , we let @xmath222 be the set of positions reachable from @xmath145 via a move in  @xmath223 . for any position  @xmath224 we let @xmath225 be a _",
    "subgame _ of  @xmath6 , which is issued from the new initial position  @xmath145 .",
    "the set of all subgames of  @xmath6 is denoted by  @xmath226 .",
    "if @xmath6 is clear from the context , we usually omit the subscript and write  @xmath227 and  @xmath228 .",
    "a _ play _ of  @xmath6 is a maximal sequence @xmath229 of positions @xmath230 , such that between any subsequent positions @xmath231 and @xmath232 there is a valid move , i.e. , @xmath233 for @xmath234 .",
    "such a play is said to have  @xmath235 _ rounds _ and to _ end _ in position  @xmath236 .",
    "the rules of the game are that in the @xmath150th round of the play , where @xmath237 , the player assigned to position @xmath231 has to place a valid _ move _",
    ", i.e. , has to choose the next position @xmath238 .",
    "if no such position @xmath232 exists , or the position @xmath231 is not assigned to either of the players , the play ends . if the play ends in a position @xmath236 with @xmath239 , where @xmath240 , then the other player , player  @xmath241 , _ wins _ the play .",
    "if , however , the play ends in a position @xmath236 with @xmath242 , then there is a draw and none of the players wins the play . the goal of game is to force the other player into a position where they can not move .",
    "we say that a player has a _ winning strategy on @xmath6 _ , if and only if they can win every play of the game irrespective of the choices of the other player .",
    "for instance , player  0 has a winning strategy on @xmath6 if and only if either    * @xmath243 and there is a move @xmath244 such that player  0 has a winning strategy on @xmath245 ; or * @xmath246 and player  0 has a winning strategy on @xmath245 for all moves @xmath244 .",
    "note that this includes the case that player  1 can not move at all .    a game @xmath6 is said to be _ determined _ or _ well - founded _",
    "if either one of the players has a winning strategy on  @xmath6 , otherwise @xmath6 is _",
    "undetermined_.    we fix two special games @xmath247 and @xmath248 on which the first player and the second player , respectively , have winning strategies .",
    "one can efficiently test whether one of the player has a winning strategy on a game  @xmath6 , cf .",
    ",  @xcite .",
    "algorithm  [ alg : eval ] determines whether one of the players has a winning strategy on a game  @xmath6 and returns either @xmath247 or @xmath248 if this is the case .",
    "if none of the players has a winning strategy , the algorithm returns a corresponding `` proof '' , a list of all the plays of  @xmath6 that ended with a draw .",
    "algorithm @xmath249 @xmath250 [ then ] [ return ] @xmath6    let @xmath251 , @xmath252 , @xmath253 , and @xmath254 .",
    "[ for ] @xmath255 [ do ] let @xmath256 .",
    "update @xmath257 and @xmath258 , @xmath259 .",
    "update @xmath260 .",
    "let @xmath261 and compute @xmath262 . [ if ] @xmath263 [ then ] [ if ] @xmath264 [ or ] @xmath265 [ then ] [ return ] @xmath248 [ if ] @xmath266 [ then ] [ return ] @xmath247 [ if ] @xmath267 [ then ] [ if ] @xmath268 [ or ] @xmath265 [ then ] [ return ] @xmath247 [ if ] @xmath269 [ then ] [ return ] @xmath248 [ return ] @xmath270    in the case of the model checking game , we call the two players the _ falsifier _ and the _ verifier_. the verifier wants to prove that a formula is _ true _ on a structure ( or , the structure _ satisfies _ the formula ) , while the falsifier tries to show that it is _ false _ ( or , the structure does not satisfy the formula )",
    ". the reader may therefore call @xmath248 `` true '' and @xmath247 `` false '' .    [",
    "def : model - checking - game ] the ( classical ) _ model checking game _ @xmath271 over a fully interpreted @xmath63-structure  @xmath34 and a formula  @xmath204 is defined by induction over the structure of  @xmath8 as follows .",
    "let @xmath272 , \\varphi)$ ] , where @xmath273 . if @xmath8 is an atomic or negated formula , then @xmath274 , where    * @xmath243 if and only if * * @xmath275 and @xmath276 , or * * @xmath277 and @xmath278 . * @xmath246 if and only if * * @xmath275 and @xmath278 , or * * @xmath277 and @xmath276 .",
    "if @xmath279 for some relation symbol  @xmath29 , let @xmath280 for @xmath281 be the @xmath282-expansion of  @xmath34 with @xmath283 , and let @xmath284 be the corresponding model checking game over  @xmath285 and  @xmath190 .",
    "then @xmath271 , where    * @xmath286 , * @xmath287 , * @xmath288 , where @xmath289 iff @xmath290 and @xmath291 otherwise , * @xmath292 , where @xmath293 iff @xmath294 and @xmath295 otherwise .",
    "if @xmath296 for some nullary symbol  @xmath76 , let @xmath297 be the @xmath298-expansion of  @xmath34 with @xmath299 , and let @xmath300 be the corresponding model checking game over  @xmath301 and  @xmath190 .",
    "then @xmath271 , where    * @xmath302 , * @xmath303 , * @xmath304 , where @xmath289 iff @xmath305 and @xmath291 otherwise , *",
    "@xmath306 , where @xmath293 iff @xmath307 and @xmath295 otherwise .",
    "if @xmath200 , let @xmath308 be the model checking game over  @xmath34 and  @xmath309 . then @xmath271 , where    * @xmath310 , * @xmath311 , * @xmath312 , where @xmath289 iff @xmath313 and @xmath291 otherwise , * @xmath314 , where @xmath293 iff @xmath315 and @xmath295 otherwise .",
    "note that the falsifier is the _",
    "universal _ player and moves on universal formulas , while the verifier is the _ existential _ player and moves on existential formulas .",
    "furthermore , if the structure  @xmath34 is empty , then , by definition , @xmath316 and @xmath317 for all @xmath190 . in the model checking game , this corresponds to the case that there are no moves from the current position .",
    "consequently , the play ends and the player assigned to this position looses . on non - empty structures",
    ", each play ends in an atomic or negated atomic formula .",
    "the goal of the verifier is to make the play end in a position  @xmath318 with @xmath319 , and conversely the goal of the falsifier is to force the play into an ending position @xmath318 with @xmath320 .",
    "it is well - known that the classical model checking game is well - founded  @xcite and that the verifier has a winning strategy on @xmath321 if and only if @xmath38 , see , e.g. ,  @xcite .",
    "we shall now consider an extension of the model checking game that has the following two central properties :    * it is defined for partially interpreted structures ; and * it is `` well - defined '' under taking the union of structures in the sense that if one of the players has a winning strategy on the game on @xmath34 and @xmath8 , then the same player has a winning strategy in the game on @xmath322 and @xmath8 for all structures  @xmath114 compatible with  @xmath34 .",
    "before we give the formal definition of the new game , let us briefly mention why we require these properties : recall that we want to use the model checking game @xmath321 to decide algorithmically whether a @xmath63-structure  @xmath34 holds on a formula  @xmath323 . if @xmath8 contains set quantifiers ,",
    "then there is a number of positions in @xmath321 that grows exponentially with the size of  @xmath2 . in order to avoid exponential running time on structures of bounded treewidth , a tree decomposition  @xmath140 of  @xmath34 , where @xmath324 , is traversed bottom - up by a dynamic programming algorithm . at a node",
    "@xmath147 , we only consider the substructure @xmath163 of @xmath34 .",
    "let @xmath35 be some expansion of @xmath34 .",
    "then @xmath325 $ ] is in general not fully interpreted , which explains the first requirement .    for",
    "the second requirement , note that for each @xmath147 there is a @xmath63-structure  @xmath326 , such that @xmath34 can be written as @xmath327 .",
    "the structure @xmath326 is sometimes called the `` future '' of  @xmath163 in the literature . therefore ,",
    "if one of the players has a winning strategy in the game on @xmath163 and @xmath8 , we require that the same player has a winning strategy on @xmath327 and @xmath8 .    in order to make the inductive construction work",
    ", we additionally need to distinguish the nodes in the `` current '' bag @xmath154 of the tree decomposition .",
    "the game therefore additionally depends on a given set @xmath328 .",
    "[ def : extended - model - checking - game ] [ def : outcome ]    the _ extended model checking game _ @xmath329 over a @xmath63-structure  @xmath34 , a set @xmath330 , and a formula  @xmath204 is defined by induction over the structure of  @xmath8 as follows .",
    "let @xmath331 , x , \\varphi)$ ] , where @xmath273 . if @xmath8 is an atomic or negated formula , then @xmath332 , where    * @xmath243 if and only if either * * @xmath275 , such that @xmath333 , and @xmath276 , or * * @xmath334 , such that @xmath333 , and @xmath278 . * @xmath246 if and only if either * * @xmath275 , such that @xmath333 , and @xmath278 , or * * @xmath334 , such that @xmath333 , and @xmath276 .",
    "if @xmath279 for some relation symbol  @xmath29 , or @xmath200 , then @xmath335 is defined analogously to  @xmath321 .",
    "if @xmath296 for some nullary symbol  @xmath76 , let @xmath336 be the @xmath298-expansion of  @xmath34 with @xmath337 , and let @xmath338 be the corresponding extended model checking game over  @xmath339 and  @xmath190",
    ". then @xmath329 , where    * @xmath340 , * @xmath341 , * @xmath342 , where @xmath289 iff @xmath305 and @xmath291 otherwise , * @xmath343 , where @xmath293 iff @xmath307 and @xmath295 otherwise .    for the games we consider throughout this paper",
    ", one can derive from a position  @xmath221 whether @xmath344 or @xmath345 ( cf .",
    ", the definitions of  @xmath346 and @xmath347 ) . to avoid cluttered notation",
    ", we shall therefore usually omit the sets  @xmath348 and @xmath349 from the tuple @xmath350 and identify games with the triple  @xmath351 .",
    "figure  [ fig : unfolding ] shows a simplified schematic of an extended model checking game and the result after an application of the evaluation algorithm  @xmath352 .     for the structure @xmath34 with universe @xmath353 and @xmath354 .",
    "bottom : @xmath355 .",
    "the lower branch witnesses a play that ends with a draw.[fig : unfolding ] [ fig : eval ] ]     for the structure @xmath34 with universe @xmath353 and @xmath354 . bottom : @xmath355 .",
    "the lower branch witnesses a play that ends with a draw.[fig : unfolding ] [ fig : eval ] ]    if @xmath34 is a fully interpreted structure , @xmath321 can be embedded into @xmath335 such that for each play of @xmath321 there is a corresponding , equivalent play of  @xmath335 .",
    "algorithm  [ alg : convert ] effectively computes this embedding ( lemma  [ lem : convert - me ] ) .",
    "furthermore , if @xmath335 is determined , then so is @xmath321 ( lemma [ lem : emcg - determines - mcg ] ) .    [",
    "lem : convert - me ] let @xmath34 be a fully interpreted @xmath63-structure , @xmath330 , and @xmath204 .",
    "then , using algorithm  [ alg : convert ] , we have @xmath356    the proof is an induction over the structure of  @xmath8 . for atomic or negated atomic formulas ,",
    "the statement trivially holds by definition of  @xmath321 , since @xmath357 .",
    "let @xmath358 .",
    "let @xmath279 or @xmath200 and @xmath309 and consider @xmath359 .",
    "we have @xmath360 , where either @xmath361 is an @xmath282-expansion of  @xmath34 for some @xmath281 , or @xmath362 , respectively .",
    "since @xmath34 is fully interpreted , @xmath35 is fully interpreted , and we obtain @xmath363 by the induction hypothesis .",
    "if otherwise @xmath296 , consider @xmath359 . by definition , @xmath360 , where @xmath35 is a @xmath298-expansion of  @xmath34 with @xmath364 .",
    "if all constant symbols are interpreted in @xmath365 , then @xmath366 , i.e. , @xmath35 is fully interpreted . by the induction hypothesis",
    "we get @xmath363 .    together",
    ", the statement follows .",
    "algorithm @xmath367    @xmath250 [ then ] [ return ] @xmath6 .",
    "let @xmath368 and @xmath369 .",
    "let @xmath370 , \\varphi)$ ] , @xmath371 , and @xmath252 .",
    "[ for ] @xmath372 s.t .  @xmath373 is fully interpreted [ do ] let @xmath374 .",
    "update @xmath375 and @xmath376 .",
    "[ return ] @xmath377    we now prove that if an extended model game is determined , then the corresponding player can win the game without using any further `` @xmath378-moves '' .",
    "this will be useful in the proof of lemma  [ lem : emcg - determines - mcg ] .",
    "[ lem : partially - replaced ] let @xmath126 and @xmath127 be @xmath63-structures with @xmath379 and @xmath98 , such that @xmath380 , @xmath381 for all @xmath73 and @xmath382 for all @xmath383 .",
    "let @xmath204 .",
    "if @xmath384 , then @xmath385 and @xmath386    before we give the formal proof , consider the following high - level argument : suppose that @xmath387 . then there is at least one play of the game @xmath388 that is won by the verifier .",
    "consider an arbitrary play @xmath229 won by the verifier and let @xmath389 .",
    "since @xmath236 is assigned to the falsifier , all constant symbols occurring in @xmath190 are interpreted and hence different from  @xmath76 .",
    "the verifier can therefore win the game without depending on formulas where  @xmath76 occurs .",
    "the proof is an induction over the structure of  @xmath8 .",
    "let @xmath384 .",
    "if @xmath8 is an atomic or negated formula , say @xmath275 , then @xmath390 .",
    "therefore , @xmath385 and for all @xmath391 , we have @xmath392 and @xmath393 , which implies @xmath394 .",
    "if @xmath279 for a relation symbol  @xmath29 , let @xmath281 and @xmath395 , @xmath396 be the @xmath282-expansions of  @xmath126 and @xmath127 , respectively , with @xmath397 .",
    "then by the induction hypothesis @xmath398 if @xmath399 .    similarly , if @xmath400 for a nullary symbol  @xmath401 , let @xmath395 and @xmath396 be @xmath402-expansions of  @xmath126 and @xmath127 , respectively , such that @xmath403",
    ". then by the induction hypothesis @xmath404 , if @xmath399 .    finally , if @xmath200 , then from @xmath405 , where @xmath309 , we get @xmath398 .    together , the statement of the lemma follows .",
    "we can now prove that if some player has a winning strategy in the extended model checking game , then the same player has a winning strategy in the classical model checking game .",
    "[ lem : emcg - determines - mcg ] let @xmath34 be a fully interpreted @xmath63-structure , @xmath330 , and @xmath204 .",
    "if @xmath406 , then @xmath407    the proof is an induction over the structure of  @xmath8 .",
    "suppose @xmath408 ( the case @xmath247 is shown analogously ) .",
    "if @xmath8 is an atomic or negated atomic formula , then the statement clearly holds .",
    "if @xmath313 , then for each @xmath309 we have @xmath409 .",
    "this implies @xmath410 by the induction hypothesis , and therefore  @xmath411 .",
    "similarly , if @xmath290 for a relation symbol  @xmath29 , then @xmath412 for each @xmath282-expansion @xmath35 of @xmath34 , each of which is fully interpreted .",
    "we get @xmath413 by the induction hypothesis .",
    "hence , @xmath411 .",
    "if @xmath305 for a nullary symbol  @xmath76 , then @xmath412 for each fully interpreted @xmath298-expansion @xmath35 of @xmath34 .",
    "this implies @xmath413 by the induction hypothesis , and therefore  @xmath411 .    if @xmath315 , then there is @xmath309 with @xmath409 .",
    "we get @xmath410 by the induction hypothesis , and therefore  @xmath411 .    similarly ,",
    "if @xmath294 for a relation symbol  @xmath29 , then there is a @xmath282-expansion @xmath35 of @xmath34 with @xmath412 .",
    "since @xmath34 is fully interpreted , @xmath35 is fully interpreted . using the induction hypothesis",
    ", we have @xmath413 and therefore  @xmath411 .    finally ,",
    "if @xmath307 for a nullary symbol  @xmath76 , then there is a @xmath298-expansion @xmath35 of @xmath34 with @xmath412 . by lemma  [ lem :",
    "partially - replaced ] , we can assume  @xmath414 .",
    "then @xmath35 is fully interpreted and we get @xmath413 by the induction hypothesis . therefore @xmath411 .",
    "we can significantly strengthen this statement further : if @xmath335 is determined , then @xmath415 is also determined for _ all _  @xmath114 compatible with  @xmath34 . note that the union @xmath322 arises on _ join _ or _",
    "introduce _ nodes  @xmath150 of the tree decomposition , where @xmath416 is the current bag , cf .",
    ", figure  [ fig : join ] .",
    "recall , for instance , the example 3-colorability from the introduction : if a subgraph @xmath35 of a graph @xmath34 is not three - colorable , then clearly @xmath34 is not three - colorable either .",
    "the following lemma formalizes this observation .",
    "let us give a brief high - level explanation before we state the lemma and give its proof .",
    "roughly speaking , if @xmath417 is determined , then moves to objects @xmath418 in @xmath419 are either `` irrelevant '' for a player s strategy or already `` sufficiently '' captured by moves to @xmath378 ( cf .",
    ", lemma  [ lem : partially - replaced ] ) .",
    "if therefore one of the players , say the falsifier , has a winning strategy in @xmath6 , then in some sense this winning strategy carries over to @xmath270 . in the case of 3-colorability , if @xmath34 is not three - colorable , then the falsifier has a winning strategy on  @xmath420 : no matter which three sets the verifier chooses , either these sets are not a partition or not independent sets . in either case",
    "there are witnessing vertices that the falsifier can choose .",
    "thus , no matter which subsets the verifier chooses in @xmath421 , the falsifier can then choose the same witnessing vertices to win each play of  @xmath270 .",
    "[ lem : emcg - eval - introduce ] let @xmath34 and @xmath114 be compatible @xmath63-structures with @xmath422 .",
    "let @xmath330 and @xmath204 .",
    "let @xmath417 and @xmath423 .    1 .   if @xmath424 , then @xmath425 .",
    "2 .   if @xmath426 , then @xmath427 .",
    "we prove the lemma by induction over the structure of  @xmath8 .",
    "let @xmath273 .",
    "let @xmath428 and @xmath429 with @xmath430 and @xmath431 , where @xmath432 $ ] and @xmath433 $ ] .",
    "suppose @xmath424 ( the second case @xmath434 is proven analogously ) .",
    "let @xmath275 or @xmath435 for a relation symbol @xmath110 .",
    "we have @xmath424 , and hence , by definition @xmath436 for all @xmath391 . here , @xmath437 for all @xmath391 , since @xmath34 and @xmath114 are compatible , and therefore @xmath438 , since @xmath439 . hence , @xmath440 if and only if @xmath441 , and thus @xmath425 .",
    "assume now that @xmath313 or @xmath442 . by definition , for each @xmath309",
    "there is a subgame @xmath443 and a subgame @xmath444 . by the induction hypothesis , @xmath445 if @xmath446 , and hence @xmath425 if @xmath424 .",
    "if @xmath290 or @xmath447 , then for each @xmath281 there is a subgame @xmath448 , and for each @xmath449 there is a subgame @xmath450 .    if @xmath290 , consider an arbitrary @xmath449 and let @xmath451 . we know , by definition of @xmath249 , that @xmath452 . furthermore , @xmath453 and @xmath454 are compatible , and therefore , by the induction hypothesis , also @xmath455 .",
    "therefore , @xmath456 for all @xmath449 , and hence @xmath425 .",
    "if otherwise @xmath294 , then there is some @xmath281 such that @xmath452 . since @xmath453 and @xmath457 are compatible , @xmath458 by the induction hypothesis .",
    "therefore , @xmath425 .",
    "if @xmath305 , consider an arbitrary @xmath298-expansion  @xmath459 of  @xmath114 and let @xmath460 $ ] .",
    "note that if @xmath461 , then @xmath462 , and if @xmath463 or @xmath464 , then @xmath465 . in either case ,",
    "@xmath35 and @xmath459 are compatible .",
    "we know , by definition of @xmath249 , that @xmath412 .",
    "hence , by the induction hypothesis , @xmath466 .",
    "all in all , @xmath425 .",
    "assume now that @xmath307 . since @xmath424 , we know that there is a @xmath298-expansion  @xmath35 of @xmath34 , such that @xmath412 .",
    "let @xmath459 the @xmath298-expansion of @xmath114 with @xmath467 .",
    "then @xmath35 and @xmath459 are compatible , and using the induction hypothesis as above , we obtain @xmath425 .     and @xmath114 are such that @xmath468 $ ] , then winning strategies for @xmath335 carry over to @xmath469 .",
    "join / union ( right ) : if @xmath34 and @xmath114 are compatible , then winning strategies for @xmath335 carry over to @xmath470 .",
    "[ fig : join ] , title=\"fig : \" ]   and @xmath114 are such that @xmath468 $ ] , then winning strategies for @xmath335 carry over to @xmath469 .",
    "join / union ( right ) : if @xmath34 and @xmath114 are compatible , then winning strategies for @xmath335 carry over to @xmath470 .",
    "[ fig : join ] , title=\"fig : \" ]    [ cor : introduce - join ] let @xmath34 and @xmath114 be compatible @xmath63-structures with @xmath471 .",
    "let @xmath330 and @xmath204 .",
    "let @xmath417 and @xmath472 .    1 .   if @xmath424 , then @xmath425 .",
    "2 .   if @xmath426 , then @xmath427 .",
    "we use lemma  [ lem : emcg - eval - introduce ] and induction over @xmath473 .",
    "let @xmath474 .    if @xmath475 and therefore @xmath476 , the statement clearly holds . otherwise , consider @xmath418 and let @xmath477 $ ] .",
    "from @xmath474 we get @xmath478 by lemma  [ lem : emcg - eval - introduce ] .",
    "we can now use the induction hypothesis on @xmath35 , @xmath114 and @xmath479 , since @xmath35 and @xmath114 a compatible and @xmath480 , and obtain @xmath481 .",
    "the _ forget _ operation at a node  @xmath150 of a tree decomposition does not change the underlying structure  @xmath163 .",
    "it is therefore not surprising that any winning strategies carry over .",
    "[ lem : emcg - eval - forget ] let @xmath34 be a @xmath63-structure , @xmath482 and @xmath204 .",
    "let @xmath417 and @xmath483 .    1 .   if @xmath424 , then @xmath425 .",
    "2 .   if @xmath426 , then @xmath427 .",
    "let @xmath484 and @xmath485 .",
    "it is not hard to see that @xmath6 and @xmath270 are almost identical , the only difference being slightly differently labeled positions : by definition , @xmath368 and @xmath486 , where @xmath487 $ ] and @xmath488 $ ] . in particular , @xmath489 if and only if @xmath490 , where @xmath139 . by induction over the structure of @xmath8 ,",
    "the claim then easily follows .",
    "finally we show that the same holds for _ join _ nodes of a tree decomposition .",
    "note that the corresponding operation on structures is the union .",
    "[ lem : emcg - eval - union ] let @xmath491 be compatible @xmath63-structures , @xmath492 , and @xmath204 .",
    "let @xmath417 and @xmath493    1 .   if @xmath424 , then @xmath425 .",
    "2 .   if @xmath426 , then @xmath427 .",
    "let @xmath406 . by corollary  [ cor :",
    "introduce - join ] , @xmath494 . the claim then immediately follows by lemma  [ lem : emcg - eval - forget ] .",
    "in this section we show that for every game @xmath495 one can construct a game @xmath496 such that @xmath497 if @xmath474 , but @xmath498 and @xmath499 are typically much smaller than @xmath214 and @xmath223 . this will be crucial for obtaining the desired running times of our algorithm .",
    "we first define a suitable notion of _ equivalence _ between games .",
    "[ def : equivalent - games ] we say that two positions @xmath500 are _ equivalent _ , denoted by @xmath501 iff    * @xmath502 and @xmath503 for some formula @xmath8 and set @xmath504 , * there is an isomorphism @xmath505 between @xmath373 and @xmath506 , such that @xmath507 for all @xmath508 .",
    "we say that two games @xmath509 and @xmath510 are _ equivalent _ , denoted by @xmath511 , if @xmath501 and there is a bijection @xmath512 , such that @xmath513 for all @xmath514 .    algorithm @xmath515 @xmath250 [ then ] [ return ] @xmath6 [ if ] @xmath8 is an atomic or negated atomic formula [ then ] [ return ] @xmath249 let @xmath516 and @xmath517 . [ for ] @xmath518 [ do ] let @xmath519 . [ if ] @xmath8 is universal [ and ] @xmath520 [ then ] [ return ] @xmath247 [ if ] @xmath8 is existential [ and ] @xmath521 [ then ] [ return ] @xmath248 [ if ] @xmath522 [ and ] @xmath523 for all @xmath524 [ then ] update @xmath375 and @xmath525 .",
    "[ if ] @xmath251 [ then ] [ return ] @xmath526 .",
    "[ return ] @xmath527    we now define a _ reduce operation _ that significantly shrinks the size of a game  @xmath6 ( see algorithm  [ alg : reduce ] ) .",
    "firstly , subgames won by the opponent player are removed .",
    "if , for instance , the formula is universal , then the falsifier can safely ignore subgames that evaluate as @xmath248 , i.e. , for which the verifier has a winning strategy .",
    "for example , it is easy to see that we can remove the two subgames @xmath248 and @xmath247 in figure  [ fig : eval ] .",
    "secondly , we only need to keep one representation per equivalence class under  @xmath528 for all undetermined games . here",
    ", we use the fact that @xmath529 for any @xmath530 with @xmath511 .",
    "we will not explicitly prove this claim . if , however , @xmath531 and @xmath532 for some @xmath63-structures @xmath126 and @xmath127 , for @xmath533 and @xmath204 , then the bijection @xmath534 induced by the definition of @xmath528 yields a bisimulation between @xmath388 and @xmath535 . in particular ,",
    "if both @xmath536 and @xmath537 are subgames of the same game  @xmath88 , then it suffices to keep either subgame as `` witness '' for possible winning positions for the respective player in the model checking game .",
    "thus , removing equivalent subgames from a game  @xmath6 can be seen as a variant of taking the _ bisimulation quotient _ ( cf .",
    ", ( * ? ? ?",
    "* chapter 7 ) ) of @xmath6 .",
    "see figures  [ fig : vc - unfolding ] and  [ fig : ds - unfolding ] in section  [ sec : concrete - problems ] for two examples .",
    "[ lem : eval - equals - reduce ] let @xmath34 be a @xmath63-structure , @xmath330 , and @xmath204 .",
    "let @xmath417 .",
    "then    * @xmath424 , if and only if @xmath538 , and * @xmath426 , if and",
    "only if @xmath539 .    let @xmath540 , where @xmath368 .",
    "without loss of generality , we assume that @xmath541 .",
    "we only show the first case ( ) , the second statement is proven analogously .",
    "the proof is an induction over the structure of  @xmath8 .",
    "if @xmath8 is an atomic or negated atomic formula or @xmath542 , then the statement holds by definition of  @xmath515 . for the induction step ,",
    "assume @xmath8 is not an atomic or negated formula , and @xmath543 .",
    "let @xmath544 for all @xmath518 and let @xmath424 . if @xmath8 is existential , then there is @xmath518 with @xmath545 . by the induction hypothesis , @xmath546 , and therefore @xmath538",
    "similarly , if @xmath8 is universal , then @xmath545 for all @xmath518 . by the induction hypothesis , @xmath547 for each @xmath518 .",
    "hence , we have @xmath251 after the for - loop . since @xmath8 is universal , the call to @xmath526 returns @xmath248 by definition , and therefore @xmath538",
    ".    conversely , let @xmath538 . if @xmath8 is existential , then there must be some @xmath518 with @xmath547 . assume for a contradiction that @xmath548 for all @xmath518 .",
    "then @xmath251 after the for - loop , which implies @xmath549 , a contradiction .",
    "let therefore @xmath145 be such a position with @xmath547 .",
    "then , by the induction hypothesis , @xmath545 for this  @xmath145 , and therefore also @xmath424 .",
    "if @xmath8 is universal , then we know @xmath251 after the for - loop , as this is the only possibility how  @xmath515 can return  @xmath248 . therefore , @xmath547 for all @xmath518 , and hence @xmath424 by the induction hypothesis and definition of  @xmath249 .",
    "now we prove an upper bound for the size of a reduced game .",
    "since this is a general upper bound for arbitrary formulas and structures , we can not expect better bounds than the known lower bounds ( unless @xmath550 )  @xcite .",
    "let @xmath63 be a vocabulary and @xmath204 .",
    "let @xmath551 be two @xmath63-structures and @xmath533 .",
    "we call @xmath126 and @xmath127 _ equivalent with respect to @xmath8 and @xmath21 _ , denoted by @xmath552 , if @xmath553 .    for an arbitrary set @xmath21 of objects ,",
    "we let @xmath554 be the set of all @xmath63-structures that contain @xmath21 , and @xmath555 the set of equivalence classes of @xmath556 under @xmath557 .",
    "we let @xmath558    [ lem : number ] let @xmath63 be a vocabulary , @xmath204 , and @xmath21 be a set of objects .",
    "then @xmath559 where @xmath9 is the length of an encoding of  @xmath8 .",
    "without loss of generality , we assume @xmath63 is minimal such that @xmath204 and therefore @xmath560 .",
    "we prove the claim by induction over the structure of  @xmath8 .",
    "if @xmath8 is an atomic or negated atomic formula , let @xmath273 , and @xmath561 .",
    "let @xmath562 .",
    "then either @xmath563 , or @xmath564 , where @xmath368 and @xmath487 $ ] .",
    "hence , @xmath565 depends on the number of non - isomorphic structures on at most latexmath:[$n : = |x| +    objects .",
    "for a fixed relation symbol @xmath110 , there are @xmath567 ways to choose the interpretation  @xmath568 .",
    "the total number of non - isomorphic @xmath63-structures over at most @xmath32 objects is therefore bounded by @xmath569 .    if @xmath313 or @xmath570 , then @xmath571 and @xmath572 .",
    "furthermore , by the induction hypothesis we get @xmath573 .",
    "we conclude that @xmath574 .    if @xmath575 , then @xmath576 , @xmath577 , and , by the induction hypothesis , @xmath578 .",
    "since @xmath579 ignores equivalent subgames , the total number @xmath565 is upper - bounded by @xmath580 .",
    "[ lem : size ] let @xmath34 be a @xmath63-structure , @xmath330 and @xmath204 .",
    "then @xmath581 where @xmath9 is the length of an encoding of  @xmath8 .",
    "we use induction over the structure of  @xmath8 . if @xmath8 is an atomic or negated atomic formula , then @xmath417 contains only a single position and @xmath582 .    if @xmath313 or @xmath315 , let ,",
    "for @xmath139 , be @xmath583 . by the induction hypothesis , @xmath584 where @xmath585 and @xmath572 , and therefore , @xmath586    if otherwise @xmath575 , then @xmath576 and @xmath577 .",
    "since equivalent subgames are ignored , @xmath587",
    "in this section , we show how model checking games on structures can be computed inductively .",
    "we will introduce two algorithms : algorithm  [ alg : combine ] will be used when structures are _ combined _ , i.e. , taking the union of two compatible structures .",
    "this happens at _ join _ and _ introduce _ nodes of the tree decomposition .",
    "algorithm  [ alg : forget ] will be used when objects are removed from the set  @xmath21 , which happens at _ forget _ nodes of the tree decomposition .",
    "we first will study the case of combining games .",
    "the next lemma is required for technical reasons .",
    "algorithm @xmath588 let @xmath589 , @xmath590 and @xmath591 . [ for ]",
    "each @xmath592 [ do ] let @xmath593 and @xmath594 .",
    "[ if ] @xmath595 [ and ] @xmath596 and @xmath597 are compatible [ then ] let @xmath598 .",
    "update @xmath599 and @xmath600 .",
    "[ return ] @xmath601    [ lem : matches - compatible ] let @xmath126 and @xmath127 be compatible @xmath63-structures , @xmath204 and let @xmath602 and @xmath603 with @xmath604 .",
    "let , for @xmath139 , @xmath605 and @xmath606 , where @xmath607",
    ". then @xmath373 and @xmath506 are compatible .",
    "let @xmath273 .",
    "since @xmath608 , we have , by definition  [ def : equivalent - games ] , @xmath609 $ ] for an isomorphism @xmath610 with @xmath611 for all @xmath612 .    by definition , @xmath613 , and therefore @xmath138 if and only if @xmath614 .",
    "if @xmath615 , then in particular @xmath616 . hence , @xmath617 . since @xmath126 and @xmath127 are compatible , @xmath129 for all @xmath618 , and therefore @xmath619 for all @xmath615 .",
    "accordingly , @xmath373 and @xmath506 are compatible .",
    "we now prove that for a structure @xmath34 with @xmath620 the reduced model checking game @xmath621 can , up to equivalence , be computed from @xmath622 and @xmath623 . here , @xmath624 essentially computes the cartesian product of plays in the games over @xmath126 and @xmath127 , respectively .",
    "this is possible because each set @xmath281 can be split into @xmath625 and @xmath626 , such that @xmath627 .",
    "similarly , each interpretation of a nullary symbol is either @xmath378 , or contained in @xmath628 , in @xmath629 , or in @xmath630 ( cf .",
    ", figure  [ fig : join ] ) .",
    "these cases can be reconstructed from the respective subgames on @xmath126 and @xmath127 .",
    "[ lem : combine ] let @xmath126 and @xmath127 be compatible @xmath63-structures , @xmath204 and let @xmath602 and @xmath603 with @xmath604 .",
    "let , for @xmath139 , @xmath605 and @xmath608 .",
    "then @xmath631    the proof is an induction over the structure of  @xmath8 .",
    "let @xmath632 , @xmath633 , and @xmath273 .",
    "let @xmath634 and @xmath635 .",
    "let , for @xmath139 , @xmath636 and @xmath637 .    by lemma  [ lem : matches - compatible ] , @xmath373 and @xmath506 are compatible .",
    "furthermore , @xmath638 \\cong { \\ensuremath{\\mathscr{h}}}_i$ ] , and thus @xmath639 = { \\ensuremath{\\mathscr{a}}}_1[x_1 \\cup \\bar c^{{\\ensuremath{\\mathscr{a}}}_1 } ] \\cup { \\ensuremath{\\mathscr{a}}}_2[x_2 \\cup \\bar c^{{\\ensuremath{\\mathscr{a}}}_2 } ] \\cong { \\ensuremath{\\mathscr{h}}}_1 \\cup { \\ensuremath{\\mathscr{h}}}_2 $ ] .",
    "if @xmath640 , then @xmath641 , x , \\varphi)$ ] . therefore , @xmath642 , x , \\varphi ) \\cong ( { \\ensuremath{\\mathscr{h}}}_1 \\cup { \\ensuremath{\\mathscr{h}}}_2 , x_1 \\cup x_2 , \\varphi ) = p_{\\mathcal g}.\\ ] ]    let @xmath8 be an atomic or negated atomic formula . if @xmath643 the lemma already holds with above considerations",
    ". therefore consider the case @xmath644 , say  @xmath645 .",
    "then @xmath646 by lemma  [ lem : eval - equals - reduce ] .",
    "therefore , @xmath645 if and only if the verifier wins the play @xmath647 , where @xmath648 is the initial position of @xmath649 , x , \\varphi)$ ] .",
    "the claim then follows , since @xmath331 , x , \\varphi ) \\cong p_{\\mathcal g}$ ] , where in particular @xmath639 \\cong { \\ensuremath{\\mathscr{h}}}_1 \\cup { \\ensuremath{\\mathscr{h}}}_2 $ ] and @xmath633 .    for the induction step ,",
    "we distinguish the following cases .    [ [ case - varphi - psi_1-wedge - psi_2-or - varphi - psi_1-vee - psi_2 ] ] case @xmath313 or @xmath650 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +       let , for @xmath309 , @xmath651 and , for each @xmath139 , be @xmath652 .",
    "consider @xmath309 with @xmath653 and suppose there was @xmath139 , say @xmath654 , with @xmath655 .",
    "let @xmath656 and @xmath657 .",
    "by lemma  [ lem : eval - equals - reduce ] , @xmath658 , and therefore by corollary  [ cor : introduce - join ] , @xmath659 . since @xmath660 , also @xmath661 .",
    "this contradicts @xmath662 via lemma  [ lem : eval - equals - reduce ] .",
    "therefore , we have @xmath663 for each @xmath139 , which implies @xmath664 . since @xmath608 for @xmath139 , there is @xmath665 with @xmath666 .",
    "the algorithm @xmath667 will eventually call @xmath668 . then",
    ", by the induction hypothesis , @xmath669 contains the required subgame @xmath670 .",
    "conversely , let @xmath309 and @xmath671 such that @xmath588 recursively calls @xmath668 . from @xmath608",
    "we get @xmath666 .",
    "then @xmath672 by the induction hypothesis .    together",
    ", the statement of the lemma follows .",
    "[ [ case - varphi - forall - r - psi - or - varphi - exists - r - psi ] ] case @xmath290 or @xmath673 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +       consider an arbitrary @xmath281 and let @xmath674 , where @xmath361 with @xmath675 .",
    "for @xmath139 , let @xmath676 and @xmath677 , where @xmath678 .",
    "if @xmath679 , then @xmath680 for each @xmath139 by using a combination of lemma  [ lem : eval - equals - reduce ] and corollary  [ cor : introduce - join ] .",
    "therefore , @xmath681 .",
    "since @xmath608 , there is @xmath682 with @xmath683 .",
    "let @xmath684 .",
    "since @xmath395 and @xmath396 are compatible and @xmath685 , we by lemma  [ lem : matches - compatible ] have that @xmath596 and @xmath597 are compatible .",
    "therefore , the algorithm eventually recursively calls @xmath686 . by the induction hypothesis , @xmath687 .",
    "conversely , assume the algorithm recursively calls @xmath686 , where @xmath682 for each @xmath139 .",
    "from @xmath608 we get @xmath688 , where @xmath678 for some @xmath689 .",
    ". since @xmath373 and @xmath506 are compatible and @xmath690 , also @xmath395 and @xmath396 are compatible .",
    "therefore , the induction hypothesis implies @xmath691 , where @xmath692 with @xmath693 .",
    "together , the statement of the lemma follows .",
    "[ [ case - varphi - forall - c - psi - or - varphi - exists - c - psi ] ] case @xmath305 or @xmath307 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +       consider a @xmath298-expansion @xmath35 of @xmath34 and let @xmath674 .",
    "let , for @xmath139 , @xmath694 $ ] be the @xmath298-expansion of @xmath163 with @xmath695 if @xmath696 , and @xmath697 otherwise .",
    "let @xmath677 .",
    "if @xmath679 , then @xmath698 by a combination of lemma  [ lem : eval - equals - reduce ] and corollary  [ cor : introduce - join ] .",
    "therefore , @xmath664 .",
    "since @xmath608 , there is @xmath682 with @xmath685 .",
    "let @xmath684 .",
    "since @xmath395 and @xmath396 are compatible and @xmath683 , lemma  [ lem : matches - compatible ] implies that @xmath596 and @xmath597 are compatible .",
    "the algorithm therefore eventually calls @xmath686 . by the induction hypothesis , @xmath687 .",
    "conversely , assume the algorithm recursively calls @xmath686 , where @xmath682 for each @xmath139 .",
    "from @xmath608 we get @xmath699 for some @xmath298-expansion  @xmath700 of  @xmath163 .",
    "since @xmath373 and @xmath506 are compatible and @xmath690 , also @xmath395 and @xmath396 are compatible . by the induction hypothesis , @xmath691 , where @xmath701 .",
    "together , the statement of the lemma follows .",
    "algorithm @xmath702 there is @xmath703 with @xmath704 [ then ] let @xmath705 [ else ] let @xmath706 , x \\setminus \\{x\\ } , \\varphi)$ ] .",
    "let @xmath371 and @xmath252 .",
    "[ for ] each @xmath707 [ do ] let @xmath708 .",
    "set @xmath257 and @xmath709 .",
    "[ return ] @xmath710    [ lem : forget ] let @xmath34 be a @xmath63-structure , @xmath330 and @xmath711 .",
    "let @xmath204 and @xmath712 .",
    "then @xmath713    we use induction over the structure of  @xmath8 .",
    "let @xmath273 , @xmath714 , @xmath715 .",
    "let @xmath716 with @xmath717 . here",
    ", @xmath718 $ ] , since @xmath719 .    if @xmath8 is an atomic or negated atomic formula and @xmath679 , the statement holds since @xmath720 , x ' , \\varphi)$ ] by definition .",
    "if otherwise @xmath8 is an atomic or negated atomic formula and @xmath721 , let @xmath722 $ ] if @xmath723 for all @xmath703 , and @xmath724 otherwise .",
    "if @xmath721 , then @xmath725 by lemma  [ lem : eval - equals - reduce ] .",
    "since @xmath726 $ ] , we have @xmath727 and @xmath728    for the induction step , let @xmath707 be an arbitrary subgame of  @xmath6 .",
    "since @xmath729 , we know that @xmath730 for some expansion @xmath35 of @xmath34 and subformula @xmath190 of @xmath8 . by the induction hypothesis , @xmath731    conversely , if @xmath732 is a subgame of  @xmath733 , then @xmath734 .",
    "this implies @xmath735 by lemmas  [ lem : emcg - eval - forget ] and  [ lem : eval - equals - reduce ] .",
    "therefore , there is @xmath707 with @xmath730 . by the induction hypothesis , @xmath736 .",
    "together , the statement of the lemma follows .",
    "finally , we come back to algorithm  [ alg : convert ] and show that its correctness translates to reduced games .",
    "[ lem : convert ] let @xmath34 be a fully interpreted @xmath63-structure , @xmath330 , and @xmath204 .",
    "let @xmath729 .",
    "then @xmath737    we prove the statement by induction over the structure of  @xmath8 .",
    "recall that @xmath738 is determined and hence @xmath739 .",
    "if @xmath250 , then @xmath740 .",
    "we get @xmath741 from lemma  [ lem : eval - equals - reduce ] and therefore , using lemmma  [ lem : emcg - determines - mcg ] for the first equality , @xmath742    let therefore @xmath743 with @xmath368 and suppose @xmath744 ( the case @xmath247 is shown analogously ) . for atomic or negated atomic formulas , the statement holds since , by definition , @xmath745 , and hence @xmath746 by lemma  [ lem : convert - me ] .",
    "if @xmath279 , say @xmath290 , consider @xmath281 and let @xmath361 with @xmath675 . if there is @xmath707 with @xmath730 , then @xmath747 by the induction hypothesis",
    "if otherwise there is no such @xmath270 in @xmath226 , then @xmath748 by definition of  @xmath579 , since @xmath541 . by lemmas  [ lem : eval - equals - reduce ] and  [ lem : convert - me ] , we then conclude @xmath413 .",
    "together , the lemma follows .    similarly , if @xmath749 , then for @xmath309 either there is @xmath707 , such that @xmath750 , or there is no such @xmath270 contained in  @xmath226 . in the former case we again obtain @xmath751 by the induction hypothesis , and in the latter case",
    "we can again argue that @xmath752 .",
    "finally , let @xmath296 .",
    "for any @xmath158 and @xmath753 , where @xmath754 , we argue analogously to the previous cases that either there is @xmath755 , such that @xmath756 , or there is no such @xmath270 contained in  @xmath757 , which implies @xmath758 .",
    "hence , consider the @xmath298-expansion @xmath35 of  @xmath34 with @xmath465 . if there is @xmath759 with @xmath730 , then @xmath522 .",
    "in particular , @xmath760 , where @xmath761 is not fully interpreted . therefore , @xmath367 removes the subgame  @xmath270 from  @xmath6 . in either case ,",
    "@xmath367 does only contain subgames where  @xmath76 has been interpreted as an object in  @xmath2 , as considered above .",
    "together , the statement of the lemma then follows .",
    "we can now reprove courcelle s theorem for @xmath205-definable optimization problems . throughout this section , we shall abbreviate @xmath762 .",
    "[ thm : main ] fix a relational vocabulary @xmath63 , a set @xmath763 of unary relation symbols , and @xmath207 .",
    "let @xmath204 , and @xmath764 be constants . given a @xmath95-structure @xmath34 together with a tree decomposition @xmath140 of @xmath34 having width at most  @xmath1 , where @xmath141 and @xmath142",
    ", one can compute @xmath210 in time @xmath765 .",
    "the remainder of this section is devoted to the proof of this theorem .",
    "we give an algorithm that essentially works as follows : in a first phase , the algorithm uses dynamic programming on the tree decomposition ( based on lemmas  [ lem : alg - leaf][lem : alg - join ] ) to compute the reduced extended model checking games @xmath766 and the values @xmath767 for _ all _ structures @xmath768 where @xmath769 for @xmath101 .",
    "note that by the previous sections the algorithm does not need to distinguish between equivalent games . in a second phase",
    ", the algorithm tests whether the verifier has a winning strategy on @xmath770 , or , in other words ( lemma  [ lem : convert ] ) , whether @xmath771 .",
    "the algorithm then collects the values @xmath767 for all @xmath772 with @xmath773 and outputs the optimal one . since most of the games considered are equivalent ( lemma  [ lem : number ] )",
    ", we can obtain the desired run time bounds .    without loss of generality",
    ", we assume @xmath774 . recall that for each @xmath147",
    ", @xmath163 is the substructure of @xmath34 induced by those objects that appear at or below @xmath150 in the tree decomposition .",
    "let , for @xmath147 , @xmath775 be the set of possible interpretations of the free relation symbols @xmath776 in @xmath163 , @xmath777 be the set of their corresponding @xmath63-expansions of @xmath163 , where for each @xmath778 the symbol @xmath779 is interpreted as @xmath780 , and @xmath781 be the corresponding extended model checking games in their reduced form .",
    "we let @xmath782 and @xmath783 be the restriction of @xmath784 to @xmath154 , and let , for @xmath785 , @xmath786 be the set of @xmath63-expansions of  @xmath34 that `` match '' @xmath787 on @xmath154 .",
    "let @xmath788 be the corresponding games , and , for arbitrary games @xmath789 , @xmath790 and @xmath791 finally , we let , for @xmath792 , @xmath793,\\ ] ] where @xmath794 for each @xmath101 , and @xmath795      we use dynamic programming on the tree decomposition as follows . as usual , we associate with each node @xmath147 of the tree decomposition a _ table _ @xmath796 that contains feasible , _ partial _ solutions and their corresponding _ value _",
    "@xmath797 under the optimization function .",
    "formally , we let @xmath798 map tuples @xmath799 to sets of _ feasible _ games over @xmath163 , i.e. , games @xmath789 with @xmath800 , and let @xmath801 be the corresponding values , where @xmath802 .    initially , we let @xmath803 for all @xmath799 and @xmath804 for all @xmath805 .",
    "[ [ phase-1 ] ] phase 1 + + + + + + +    the algorithm traverses the tree decomposition bottom - up .",
    "recall that each node @xmath147 is either a leaf , or of one of the three types _ introduce _ , _ forget _ , or _",
    "join_. the algorithm distinguishes these four cases as follows .    leaf : :    let @xmath806 . for all    @xmath807",
    "the algorithm considers    @xmath808 .",
    "if @xmath809 , then the algorithm    sets    @xmath810 introduce : :    let @xmath157 be the unique child of @xmath150 and    @xmath811 for @xmath812 .",
    "+    for each    @xmath813 ,    and each    @xmath814    such that    @xmath815 ,    the algorithm considers each    @xmath816",
    ".    +    let @xmath817 if there is    @xmath818 with    @xmath819 , then let    @xmath820 instead .    +    if @xmath821 , the algorithm sets    @xmath822 forget : :    let @xmath157 be the unique child of @xmath150 and    @xmath823 for @xmath824 .",
    "+    for each    @xmath813    the algorithm considers each    @xmath816 .",
    "let    @xmath825 and    @xmath826 if there is    @xmath818 with    @xmath819 , then let    @xmath820 instead .",
    "if now    @xmath821 , the algorithm sets    @xmath827 and    @xmath828    where @xmath829 as defined in    section  [ sec : prel ] .",
    "join : :    let @xmath830 be the children of @xmath150 . then    @xmath831 .",
    "+    for each    @xmath785    the algorithm considers each pair    @xmath832 .",
    "let @xmath833 if there is    @xmath818 with    @xmath819 , then let    @xmath820 instead .",
    "if now    @xmath821 , the algorithm sets    @xmath827 and    @xmath834    [ [ phase2 ] ] phase  2 + + + + + + +    let @xmath835 and @xmath836 the algorithm starts with @xmath837 and considers each @xmath838 .",
    "if @xmath839 , then the algorithm updates @xmath840 finally , the algorithm outputs @xmath841 .      in order to show that the algorithm is correct and computes the optimal solution , we use induction over the structure of the tree decomposition to show the following invariant .    [ inv : alg ] after the algorithm has processed a node @xmath147 in phase  1 , for each @xmath785 we have that    * for each @xmath842 with @xmath843 there is exactly one @xmath844 with @xmath845 , * for each game @xmath846 we have @xmath800 and @xmath847 , and * for each @xmath846 we have @xmath848    here , ( i ) guarantees that @xmath796 is _ complete _ , i.e. , @xmath849 contains games for all feasible partial solutions , ( ii ) guarantees that all games in @xmath849 do , in fact , correspond to a reduced game over some @xmath63-expansion of @xmath163 , and ( iii ) guarantees that we also compute the correct solution , i.e. , @xmath850 is optimal for @xmath851 .",
    "note that the `` exactly one '' in ( i ) is required for the claimed running time , but not for the correctness of the solution .",
    "[ lem : alg - leaf ] invariant  [ inv : alg ] holds for leafs of the tree decomposition .",
    "let @xmath147 be a leaf and @xmath852 .",
    "since  @xmath150 is a leaf , we have @xmath853 such that ( i ) and ( ii ) clearly hold .",
    "furthermore , @xmath854 for all @xmath778 , since @xmath855 , and therefore @xmath856 for all @xmath805 .",
    "[ lem : alg - introduce ] let @xmath147 be an introduce node of the tree decomposition and @xmath857 be the unique child of @xmath150 .",
    "if invariant  [ inv : alg ] holds for  @xmath157 before the algorithm processes  @xmath150 , then it also holds for  @xmath150 .",
    "let @xmath811 , where @xmath812 .",
    "let @xmath814 and @xmath813 with @xmath815 .",
    "consider @xmath858 and let @xmath859 $ ] .",
    "if @xmath860 , then also @xmath861 by lemma  [ lem : emcg - eval - introduce ] and lemma  [ lem : eval - equals - reduce ] . by invariant  [ inv : alg ] , @xmath862 therefore contains exactly one game @xmath863 with @xmath864 .",
    "if @xmath865 , then @xmath866 by lemma  [ lem : emcg - eval - introduce ] and lemma  [ lem : eval - equals - reduce ] .",
    "otherwise , the algorithm computes @xmath867 . by lemma  [ lem :",
    "combine ] , @xmath819 , which implies part  ( i ) of the invariant .",
    "conversely , consider @xmath868 .",
    "then either @xmath866 and there is @xmath816 with @xmath869 , or there is @xmath816 with @xmath870 . by the invariant for  @xmath157 , @xmath871 . from this",
    "we get there is @xmath872 such that @xmath864 and @xmath873 for some @xmath874 .",
    "let @xmath858 , chosen in a way such that @xmath875 .",
    "if @xmath869 , then , by lemma  [ lem : emcg - eval - introduce ] and lemma  [ lem : eval - equals - reduce ] , @xmath876 . otherwise , @xmath877 by lemma  [ lem : combine ] .",
    "either case implies  ( ii ) .",
    "finally , let @xmath868 and @xmath878 with @xmath879 and @xmath880 let @xmath881 $ ] . by lemmas [ lem : emcg - eval - introduce ] and  [ lem : eval - equals - reduce ] , @xmath882 .",
    "therefore , either @xmath883 , or otherwise @xmath884 by lemma  [ lem : combine ] .",
    "we need that @xmath885 is optimal for @xmath886 . to this end , assume there was @xmath887 with @xmath873 , such that either @xmath865 or @xmath888 , and furthermore @xmath889 since , @xmath864 , we have , by lemma  [ lem : combine ] , @xmath890 where @xmath891 and @xmath892",
    ". therefore , @xmath893 a contradiction to the minimality of @xmath894 .",
    "we conclude that @xmath885 is optimal for @xmath886 . from this",
    "we get that @xmath895 by the invariant for  @xmath157 , which implies  ( iii ) .",
    "[ lem : alg - forget ] let @xmath147 be a forget node of the tree decomposition and @xmath857 be the unique child of @xmath150 .",
    "if invariant  [ inv : alg ] holds for  @xmath157 before the algorithm processes  @xmath150 , then it also holds for  @xmath150 .",
    "let @xmath157 be the unique child of @xmath150 and @xmath823 for @xmath896 .",
    "note that @xmath897 .",
    "let @xmath814 .",
    "consider @xmath858 with @xmath860 and let @xmath898 and @xmath899 .",
    "then , by lemma  [ lem : emcg - eval - introduce ] and lemma  [ lem : eval - equals - reduce ] , @xmath900 . therefore , by the invariant for  @xmath157 , there is @xmath901 with @xmath864 .",
    "if @xmath902 , then , by lemma  [ lem : emcg - eval - forget ] , also @xmath866 . otherwise , the algorithm computes @xmath903 .",
    "either case implies  ( i ) .",
    "conversely , consider @xmath868 .",
    "then either @xmath866 and there is @xmath904 and @xmath816 with @xmath869 and @xmath905 , or there is @xmath904 and @xmath816 , such that @xmath905 and @xmath906 . by the invariant for  @xmath157 , in either case @xmath871 . therefore , there is @xmath907 , where @xmath864 and @xmath873 , for some @xmath874",
    ".    let @xmath908 . if @xmath869 , then , by lemmas [ lem : emcg - eval - forget ] and  [ lem : eval - equals - reduce ] , @xmath876 . otherwise , @xmath909 according to lemma  [ lem : forget ] .",
    "either case implies  ( ii ) .    finally , consider @xmath868 and let @xmath878 such that @xmath910 and @xmath879 .",
    "let @xmath911 .",
    "then , by lemmas  [ lem : emcg - eval - forget ] and  [ lem : eval - equals - reduce ] , @xmath882 . by ( ii ) , there is @xmath901 with @xmath864 , where @xmath912 .",
    "analogue to the previous case , we obtain that @xmath885 is optimal in @xmath913 .",
    "therefore , by the induction hypothesis , @xmath914 which implies  ( iii ) .",
    "[ lem : alg - join ] let @xmath147 be a join node of the tree decomposition with children  @xmath915 . if invariant  [ inv : alg ] holds for  @xmath151 and @xmath152 before the algorithm processes  @xmath150 , then it also holds for  @xmath150 .",
    "note that @xmath831 .",
    "let @xmath916 .",
    "consider @xmath842 and let , for @xmath917 , be @xmath859 $ ] .",
    "if @xmath860 , then , for @xmath917 , also @xmath861 by lemma  [ lem : emcg - eval - union ] and lemma  [ lem : eval - equals - reduce ] . by the invariant for @xmath917",
    ", @xmath918 therefore contains exactly one  @xmath863 with @xmath864 .",
    "if @xmath865 , then @xmath866 by lemma  [ lem : emcg - eval - union ] and lemma  [ lem : eval - equals - reduce ] .",
    "otherwise , the algorithm computes @xmath919 .",
    "by lemma  [ lem : combine ] , @xmath819 , which implies  ( i ) .",
    "conversely , consider @xmath920 .",
    "then either @xmath866 and there is @xmath917 and @xmath921 with @xmath869 , or there is @xmath832 , such that @xmath922 . by the invariant for @xmath917 , we have @xmath871 , and therefore there is @xmath923 with @xmath864 and @xmath873 , where @xmath924 .",
    "let @xmath925 , such that @xmath926 for all @xmath927 .",
    "if @xmath928 , then , by lemmas [ lem : emcg - eval - union ] and  [ lem : eval - equals - reduce ] , @xmath929",
    ". otherwise , @xmath930 by lemma  [ lem : combine ] .",
    "either case implies  ( ii ) .",
    "now consider @xmath920 and @xmath931 with @xmath879 and @xmath932 let , for @xmath917 , @xmath881 $ ] .",
    "then , by lemma  [ lem : emcg - eval - union ] and lemma  [ lem : eval - equals - reduce ] , @xmath882 .",
    "therefore , either @xmath883 for some @xmath917 , or @xmath933 by lemma  [ lem : combine ] .",
    "assume there were @xmath917 , say @xmath934 , and @xmath935 with @xmath873 , such that @xmath936 and either @xmath865 or @xmath937 for some @xmath938 . since @xmath939 , structures @xmath940 are compatible .",
    "by the invariant , part  ( ii ) , we have @xmath941 for some @xmath942 . without loss of generality ,",
    "we assume @xmath943 , since each @xmath944 with @xmath945 yields the same contradiction . therefore , since @xmath864 , we have @xmath946 by lemma  [ lem : combine ] , where @xmath947 .",
    "therefore , @xmath948 a contradiction to the minimality of @xmath894 . therefore , for @xmath917",
    ", @xmath885 is optimal in @xmath949 , and @xmath895 by the invariant for  @xmath157 . by ( ii ) , there is @xmath950 with @xmath864 , which then implies  ( iii ) .",
    "[ lem : alg - root ] let @xmath835 be the root of the tree decomposition , where @xmath951 , and let invariant  [ inv : alg ] hold for  @xmath952 .",
    "let @xmath953 and @xmath954 be an optimal solution for the @xmath205-problem .",
    "then @xmath955    note that @xmath956 .",
    "let @xmath35 be optimal , i.e. , let @xmath35 be a @xmath63-expansion of  @xmath34 , such that @xmath957 and @xmath958 let @xmath959 .",
    "we have @xmath960 since @xmath957 , and therefore @xmath961 by lemma  [ lem : convert ] .",
    "note that @xmath951 and therefore @xmath962 . by invariant  [ inv : alg ] ,",
    "part  ( i ) , there is @xmath963 , such that @xmath845 , which implies @xmath964 by part  ( iii ) and the optimality of  @xmath35 for @xmath965 .",
    "since @xmath966 , we also have @xmath967 conversely , let @xmath968 , such that @xmath969 and @xmath970 by part  ( ii ) of the invariant , there is a @xmath63-expansion @xmath971 of  @xmath34 , such that @xmath972 . since @xmath969",
    ", we have @xmath973 by lemma  [ lem : convert ] . without loss of generality",
    ", we can assume by part  ( iii ) , that @xmath971 is optimal for @xmath965 , i.e. , @xmath974 .",
    "we then directly conclude @xmath975    we can now prove theorem  [ thm : main ] .",
    "using induction over the structure of the tree decomposition and lemmas  [ lem : alg - leaf][lem : alg - join ] for the respective nodes , we know that invariant  [ inv : alg ] holds for the root node of the tree decomposition after the algorithm has finished phase  1 . by lemma  [ lem : alg - root ] , the algorithm outputs the correct solution in phase  2 .    for the running time , consider @xmath147 .",
    "we have @xmath976 , which for constant @xmath977 and @xmath978 is a constant . for @xmath799 , consider the set @xmath849 . since the algorithm only inserts games into @xmath849 , if @xmath849 does not already contain an equivalent game , @xmath979 by lemma  [ lem : number ] , which for bounded @xmath980 is constant .",
    "furthermore , by lemma  [ lem : size ] , for each @xmath846 , @xmath981 again a constant . finally , each position of each game is of the form @xmath982 , where @xmath983 and @xmath984 , where @xmath985 denotes the size of a suitable encoding of  @xmath365 .",
    "all operations on games , i.e. , @xmath579 , @xmath986 , @xmath987 , @xmath988 , and @xmath989 , therefore take constant time .    in total , at a node @xmath147 , a constant number of entries or pairs , respectively , is considered , and each operation takes constant time .",
    "the running time is therefore @xmath765 .",
    "[ [ semiring - homomorphisms ] ] semiring homomorphisms + + + + + + + + + + + + + + + + + + + + + +    note that the algorithm implicitly used a homomorphism @xmath990 from the semiring @xmath991 into the semiring @xmath992 . here",
    ", @xmath993 is the set of all possible interpretations of the free relation symbols ( i.e. , a set of tuples of sets ) , @xmath994 is a component - wise , disjoint union with neutral element @xmath995 , and @xmath996 is the regular union of sets .",
    "the extension to other semiring homomorphisms , e.g. , to count the number of interpretations satisfying the mso property @xmath8 , is rather straightforward .",
    "see  @xcite for a list of many interesting semirings .",
    "[ [ many - sorted - structures ] ] many - sorted structures + + + + + + + + + + + + + + + + + + + + + +    in this article , we considered one - sorted structures , i.e. , structures whose universe contains objects of a single sort only .",
    "the corresponding theory is also called @xmath997-theory in the literature and is strictly less powerful than corresponding logics for multi - sorted structures .",
    "for instance , recall from example  [ ex : taugraph ] that a graph @xmath998 can in a natural way be identified with a structure over the vocabulary @xmath89 , where @xmath91 is identified with the one - sorted universe of _ vertices _ , and @xmath90 is interpreted as  @xmath999 .",
    "the hamiltonian path problem for graphs can not be expressed in @xmath1000 , since this requires the use of edge - set quantification ( see  @xcite , for instance ) .",
    "fortunately , this poses no restriction in algorithmic applications .",
    "firstly , it is not hard to extend the techniques in this paper to many - sorted structures .",
    "original works  @xcite were already proven for many - sorted structures .",
    "secondly , one can easily simulate many - sorted structures by introducing relation symbols that distinguish the respective objects in a common universe accordingly .",
    "for example , one can consider the incidence graph of a graph and introduce unary relation symbols @xmath91 and @xmath999 , which allow to distinguish objects of sort `` vertex '' or `` edge '' , and a new binary relation symbol @xmath1001 for the incidence relation .",
    "transforming a structure and a corresponding tree decomposition accordingly can be done efficiently and does not increase the width of the decomposition .",
    "graphs with multi - edges can be represented similarly .",
    "in the analysis of the running time of the algorithm , we were rather pessimistic w.r.t .  the constants hidden in the @xmath765 .",
    "recall that unless @xmath1002 , these can not be bounded by an elementary function , i.e. , the running time of the algorithm can not be @xmath1003 for a fixed function @xmath1004 that is a nesting of exponentials of bounded depth  @xcite .",
    "the picture changes dramatically once we assume the _ problem _ is fixed , i.e. , the problem description consisting of the vocabulary @xmath63 , a formula @xmath204 and the integers @xmath1005 are constants .",
    "specialized and comparably efficient algorithms exist for many problems , e.g. , of running time @xmath1006 for the minimum vertex cover problem , or of @xmath1007 for minimum dominating set and 3-colorability , cf .",
    "@xcite , where @xmath1008 is a fixed polynomial in  @xmath1 .",
    "recent results furthermore indicate that better running times are improbable  @xcite . assuming small treewidth , such algorithms might still turn out to be feasible in many practical applications , cf .",
    "@xcite .    in this section",
    ", we estimate the running times of our generic approach for the three aforementioned problems .",
    "let @xmath1009 be a tree decomposition of the input graph structure @xmath34 over @xmath184 , where @xmath141 and @xmath142 with @xmath1010 for all @xmath147 , i.e. , @xmath34 has treewidth at most  @xmath1011 .      , where @xmath34 has universe @xmath353 , @xmath1012 and @xmath1013 .",
    "if any of the symbols @xmath37 or @xmath1014 remains uninterpreted ( cases @xmath36 and @xmath1015 in the figure ) , then some of the plays in @xmath1016 end with a draw and still persist in the reduced game .",
    "if @xmath1017 and @xmath1018 for a node @xmath150 of a tree decomposition , then this essentially means that it is still open whether nodes in the `` future '' of  @xmath150 will be adjacent or whether they will be contained in  @xmath29.[fig : vc - unfolding ] ]    recall from example  [ ex : mso - examples ] that the formula @xmath1019 is true on a @xmath1020-structure @xmath1021 if and only if @xmath1022 is a vertex cover for the graph  @xmath88 . using the notation from the previous section , we claim that for each @xmath147 and for all @xmath1023 , the set @xmath849 contains at most one entry @xmath1024 , and if @xmath846 for some @xmath787 , then @xmath1025 . to this end , consider arbitrary @xmath1026 and let @xmath1027 .    for any @xmath1028 , such that @xmath1029 , the verifier has a winning strategy on @xmath1030 , where @xmath1031 with @xmath1032 , since the atomic formula  @xmath1033 is always satisfied for all  @xmath1014 .",
    "therefore , @xmath1034 and @xmath579 removes the subgame @xmath6 from @xmath1035 .",
    "consider now a subgame @xmath1036 , where @xmath1031 with @xmath1037 .",
    "if there is @xmath1038 , such that @xmath1039 and @xmath1040 , then the falsifier has a winning strategy on @xmath1035 and consequently @xmath1041 .",
    "if otherwise for all @xmath1038 either @xmath1042 or @xmath1043 , then we get @xmath1044 , and the corresponding subgame will be removed by @xmath579 .",
    "therefore only the subgame on @xmath1045 with @xmath1046 remains undetermined .",
    "we conclude @xmath1047 for all @xmath1048 .    due to the symmetry of @xmath37 and @xmath1014 in the vertex cover formula",
    ", we can argue analogously for the cases where the roles of @xmath37 and @xmath1014 have been interchanged .",
    "therefore , @xmath1049 for all @xmath1050 , from which we conclude @xmath1051 .",
    "each game is of size @xmath1052 , since by above considerations @xmath1053 and @xmath1054 : in both cases , we have @xmath980 subgames for the vertices in @xmath154 , one subgame for all vertices in @xmath1055 ( since all of them are equivalent ) , and one subgame for the case that @xmath37 and @xmath1014 , respectively , remain uninterpreted .",
    "see figure  [ fig : vc - unfolding ] for an example .",
    "it is not hard to see that @xmath1056 , @xmath1057 , @xmath1058 , @xmath1059 and @xmath1060 can be implemented in a way such that they run in time polynomial in @xmath1061 and @xmath1062 .",
    "hence , we immediately find that the generic algorithm introduced in this article reaches , up to factors polynomial in  @xmath1 , the running time of @xmath1063 of the specialized algorithm , since @xmath1064 for all @xmath147 .",
    "the formula @xmath1065 holds in @xmath1021 if and only if @xmath1022 is a dominating set for the graph  @xmath88 .",
    "let for each @xmath147 and @xmath1066 be @xmath1067 .",
    "we claim that @xmath1068 . to this end , let again @xmath842 and @xmath1069 .",
    "let @xmath1070 be such that @xmath1071 .    if @xmath31 dominates @xmath1028 , then either @xmath1072 and @xmath1073 , or there is @xmath1074 that is adjacent to  @xmath1075 , and @xmath1076 . in both cases",
    "we get @xmath1077 , and therefore @xmath1078 .",
    ", where @xmath34 has universe @xmath1079 , @xmath1012 , and @xmath1080 , such that @xmath1075 and @xmath1081 are not adjacent . then @xmath1075 might still be dominated by a `` future '' vertex ; the corresponding plays ( following the upper @xmath1015 branch in the figure ) end with a draw and therefore persist in the reduced game .",
    "similarly , the branch @xmath36 corresponds to the case that `` future '' vertices are chosen as interpretations for  @xmath37 .",
    "such vertices can also be dominated by @xmath1081 , which is represented by the @xmath1082 branch in the figure .",
    "[ fig : ds - unfolding ] ]    if @xmath1028 is not dominated by  @xmath31 , then @xmath1083 and @xmath1084 for all @xmath1045 with @xmath1032 and @xmath1085 .",
    "these games are therefore removed by  @xmath579 .",
    "only the game @xmath1086 with @xmath1032 and @xmath1046 remains undetermined .",
    "thus for all @xmath1087 that are not dominated by  @xmath31 we have @xmath1088 .    for @xmath1045 with @xmath1089",
    "the game @xmath1090 remains undetermined .",
    "for all @xmath1091 we have @xmath1092 due to the subformula @xmath1093 ; the corresponding subgame is therefore removed from @xmath1094 . for all @xmath1095 we again",
    "have @xmath1096 .",
    "all in all , either two games @xmath1097 only differ w.r.t .",
    "the subset of _ undominated _ nodes in @xmath154 .",
    "since there are @xmath23 nodes in @xmath154 that are not contained in @xmath31 , this bounds @xmath1098 .",
    "for each of them , we have @xmath1099 corresponding to at most @xmath980 undominated nodes in  @xmath154 , at most one undominated node in @xmath1100 and the subgame for @xmath1045 with @xmath1101 .",
    "furthermore , @xmath1102 for @xmath1045 with @xmath1103 and @xmath1104 .",
    "we conclude that @xmath1105 .",
    "see figure  [ fig : ds - unfolding ] for an example .    in total , at a node @xmath147",
    ", there are therefore at most @xmath1106 entries stored , and each entry has size @xmath1107 .",
    "nodes @xmath147 of type _ leaf _ , _ forget _ are therefore processed in time @xmath1108 . for _",
    "join _ nodes @xmath147 with children @xmath830 , every pair in @xmath1109 is considered .",
    "therefore , at most @xmath1110 entries are considered , which yields a running time of @xmath1111 .",
    "this does not yet match the best specialized algorithm for the minimum dominating set problem  @xcite with a running time of @xmath1112 , but is still faster than combining all pairs with a running time of @xmath1113 .",
    "we note that both the @xmath1007 bound from  @xcite and the @xmath1114 bound from  @xcite exploit a certain `` monotonicity '' property of domination like problems , which does not hold for all problems that are expressible in mso ( independent dominating set being an example ) .",
    "the formula @xmath1115 defining the 3-colorability problem has no free symbols .",
    "therefore @xmath1116 , where @xmath1117 is the empty tuple , and the table @xmath1118 contains at most one entry @xmath1119 .",
    "we estimate the size of @xmath789 . for , let @xmath1120 , where @xmath1121 . here",
    ", @xmath1122 expresses that the @xmath1123 are a partition of the universe , and @xmath1124 ensures that each @xmath779 is an independent set .",
    "if @xmath1125 is not a partition of @xmath167 , then the falsifier wins @xmath1126 , and therefore @xmath1127 .",
    "otherwise , @xmath1128 for all @xmath1028 and undetermined when @xmath37 remains uninterpreted . using the same arguments as for the similar vertex cover formula  @xmath1129",
    ", we have @xmath1049 for all @xmath1130 with @xmath1131 and @xmath1132 , @xmath1133 .",
    "this implies @xmath1134 .",
    "thus , @xmath1135 contains at most @xmath1136 subgames @xmath1137 , which bounds @xmath1138 .",
    "thus , assuming @xmath1060 requires time @xmath1139 , we only can bound the total running time by @xmath1140 .",
    "this can probably be improved to @xmath1141 using a similar approach as for the tables @xmath918 .",
    "we started to implement the approach presented in this article in c++ .",
    "the current version works for graphs over the vocabulary @xmath89 . at certain places ,",
    "the implementation varies from the algorithms presented in this paper for increased efficiency .",
    "for instance , @xmath579 is usually not called explicitly but computed directly where needed .",
    "we list some running times and memory usage of the implementation when solving the three problems discussed in the previous section .",
    "input graphs are randomly generated subgraphs of @xmath1142 grids and erds  rnyi random graphs .",
    "all graphs have about 200 vertices and the probability to include an edge ranges between @xmath1143 and @xmath1144 . for the grid - subgraphs we used path decompositions of width  @xmath32 .",
    "tree decompositions for the random graphs were computed by a triangulation heuristics ( cf .",
    "the tests were done under linux 2.6.32 on a intel core 2 quad cpu q6600 ( 2.40ghz ) with 4 gb ram .",
    "motivated by a practical application , we present an alternative proof of courcelle s theorem . our proof is based on model checking games and tries to avoid expensive constructions such as the power set construction for tree automata , which turned out to cause some problems in practice .",
    "let us mention that our approach could be made simpler if we applied it to graphs of bounded clique - width .",
    "the union operation for _ join _ nodes of a tree decomposition involves a `` fusion '' of elements and of interpretations of nullary symbols .",
    "the clique - width parse trees do not use nullary symbols and the union is replaced by a disjoint union , which simplifies many of the operations . on the other hand , the lack of suitable algorithms to compute the mandatory clique - width parse trees favors treewidth based techniques for practical applications .",
    "first experiments with our approach do indeed indicate practical feasibility .",
    "an implementation based on our proof can solve the 3-colorability problem for some graphs where the automata theoretic approach based on the well - known mona tool failed .",
    "the running times of our generic implementation can still not compete with specialized , hand - written algorithms that can easily solve problems such as , say 3-colorability , for graphs of treewidth  15 and beyond .",
    "we are confident that further optimization can improve the feasibility of our generic approach in practical applications even more .",
    "the authors thank an anonymous referee for valuable comments and suggestions that significantly helped to improve the quality of the paper .",
    "the authors thank somnath sikdar for useful discussions on earlier drafts of this paper .",
    "the third author thanks bruno courcelle for pointing out how to use incidence graphs to handle edge set quantifications in a simple way .",
    "# 1proceedings of the # 1  conference on foundations of software technology and theoretical computer science ( fsttcs ) # 1proceedings of the # 1  international colloquium on automata , languages , and programming ( icalp ) # 1proceedings of the # 1  symposium on latin american theoretical informatics ( latin )                                                    b.  courcelle , i.  a. durand , tractable constructions of finite automata from monadic second - order formulas , presented at _",
    "logical approaches to barriers in computing and complexity _ , greifswald , germany ( 2010 ) .",
    "k.  a. abrahamson , m.  r. fellows , finite automata , bounded treewidth , and well - quasiordering , in : graph structure theory , contemporary mathematics , vol .",
    "147 , american mathematical society , 1993 , pp . 539564"
  ],
  "abstract_text": [
    "<S> courcelle s theorem states that every problem definable in monadic second - order logic can be solved in linear time on structures of bounded treewidth , for example , by constructing a tree automaton that recognizes or rejects a tree decomposition of the structure . </S>",
    "<S> existing , optimized software like the mona tool can be used to build the corresponding tree automata , which for bounded treewidth are of constant size . </S>",
    "<S> unfortunately , the constants involved can become extremely large  every quantifier alternation requires a power set construction for the automaton . here </S>",
    "<S> , the required space can become a problem in practical applications .    in this paper </S>",
    "<S> , we present a novel , direct approach based on model checking games , which avoids the expensive power set construction . </S>",
    "<S> experiments with an implementation are promising , and we can solve problems on graphs where the automata - theoretic approach fails in practice .    </S>",
    "<S> courcelle s celebrated theorem essentially states that every problem definable in monadic second - order logic ( mso ) can be solved in linear time on graphs of bounded treewidth  @xcite . </S>",
    "<S> however , the multiplicative constants in the running time , which depend on the treewidth and the mso - formula , can be extremely large  @xcite .    </S>",
    "<S> [ thm : courcelle ] let @xmath0 be an mso problem and @xmath1 be a positive integer . </S>",
    "<S> there is an algorithm @xmath2 and a function @xmath3 such that for every graph @xmath4 of order @xmath5 and treewidth at most @xmath1 , @xmath2 solves @xmath0 on input @xmath6 in time @xmath7 , where @xmath8 is the mso formula defining  @xmath0 and @xmath9 is its length . </S>",
    "<S> furthermore , unless @xmath10 , the function @xmath11 can not be upper bounded by an iterated exponential of bounded height in terms of  @xmath8 and  @xmath1 .    </S>",
    "<S> this result has been generalized by arnborg , lagergren , and seese to extended mso  @xcite , and by courcelle and mosbah to monadic second - order evaluations using semiring homomorphisms  @xcite . in both cases , an mso - formula with free set variables </S>",
    "<S> is used to describe a property , and satisfying assignments to these set variables are evaluated in an appropriate way .    </S>",
    "<S> courcelle s theorem is usually proved as follows : in time only dependent on  @xmath8 and the treewidth  @xmath1 , a tree automaton @xmath12 is constructed that accepts a tree decomposition of width  @xmath1 if and only if the corresponding graph satisfies the formula . </S>",
    "<S> this construction can either be done explicitly , by actually constructing the tree automaton ( see , e.g. , @xcite ) , or implicitly via auxiliary formulas obtained by applying the feferman  </S>",
    "<S> vaught theorem  @xcite extended to mso  @xcite ( see , e.g. , @xcite ) .    in a practical </S>",
    "<S> setting , the biggest strength of courcelle s theorem is at the same time its largest weakness : mso logic has extremely large expressive power , and very short formulas can be used to encode np - hard problems . </S>",
    "<S> this is used in  @xcite to prove non - elementary worst - case lower bounds for the multiplicative constants in the linear running time . </S>",
    "<S> even worse , these lower bounds already hold for the class of trees , i.e. , graphs of treewidth one .    </S>",
    "<S> on the other hand , these are worst - case lower bounds for very special classes of formulas and trees , and thus there is a good chance that in practice problems can be solved much faster . </S>",
    "<S> in fact , existing software like the mona tool  @xcite for weak second - order logic on two successors ( ws2s ) is surprisingly successful even though it is subject to the same theoretical lower bounds .    </S>",
    "<S> the automata - theoretic approach is therefore a promising starting point for practical applications of courcelle s theorem , particularly since advanced and optimized tools like mona can be used as a black box for the majority of the work , and techniques like minimizing tree automata are very well understood .    </S>",
    "<S> there are , however , some cases where the automata - theoretic approach is infeasible in practice , i.e. , when the automata ( or set of auxiliary formulas ) are too large to be practically computable . </S>",
    "<S> this can even happen when the final minimal automata are small , but intermediate automata can not be constructed in reasonable time and space ( note that each quantifier alternation requires an automaton power set construction ) .    in his thesis  @xcite , soguet has studied the sizes of tree automata corresponding to various problems for small clique - width  @xcite . </S>",
    "<S> the automata were generated using mona , and in many cases , the corresponding automata were surprisingly small , thanks to the well - understood minimization of tree automata . on the other hand , even for graphs of clique - width three , mona was unable to construct the corresponding tree automata for the classical 3-colorability problem . </S>",
    "<S> even worse , the same happened for simple problems such as deciding whether the graph is connected or if its maximum degree is two .    these negative results are somewhat unsatisfying because the respective algorithm already fails in the first phase , when the automaton is constructed . </S>",
    "<S> the first phase , however , only depends on the treewidth ( or clique - width in above cases ) and the formula ( i.e. , the problem ) , but is independent of the actual input graph . on the other hand , </S>",
    "<S> when running the tree automaton on most graphs arising from practical problems , only few states are actually visited .    </S>",
    "<S> recently , there have been a few approaches to this problem , see , e.g. ,  @xcite . </S>",
    "<S> for example , the approach of  @xcite avoids an explicit construction of the tree automaton . instead </S>",
    "<S> , the state - transition function is computed _ on - the - fly_. experiments indicate practical feasibility . </S>",
    "<S> courcelle  @xcite introduces _ special tree - width _ , where the corresponding automata are easier to construct .    in this paper , we present a novel , game - theoretic approach , where the input structure is taken into account from the beginning via model checking games ( cf . ,  @xcite ) . </S>",
    "<S> therefore , only the amount of information is stored that is needed by the algorithm to solve the problem on this explicit input , and , in some sense , transitions between nodes of the tree decompositions are as well computed _ on - the - fly_. we particularly avoid the expensive power set construction .    </S>",
    "<S> we hope that the approach can be used in those cases , where the automata are too large to be constructed in practice , but the input graphs itself are simple enough . </S>",
    "<S> in fact , first experiments are promising . using the generic approach , </S>",
    "<S> we can , for example , solve the 3-colorability problem on grids of size @xmath13 ( treewidth  6 ) in about 21 seconds and with 8 mb memory usage on standard pc hardware , and the minimum vertex cover problem on the same graph in less than a second and only 1 mb of memory usage . </S>",
    "<S> we note that the automata construction using mona in @xcite already failed for @xmath14 grids ( clique - width  3 ) .      </S>",
    "<S> we briefly survey other approaches to courcelle s theorem . </S>",
    "<S> we already mentioned that , given the mso formula @xmath8 , one can construct a finite - state bottom - up tree automaton that accepts a tree decomposition of the input graph  @xmath15 if and only if @xmath16 . </S>",
    "<S> this is sometimes called the automata theoretic approach . </S>",
    "<S> a direct construction of the tree automata is described in , e.g. ,  @xcite or  ( * ? ? ? </S>",
    "<S> * chapter 6 ) . in @xcite a myhill - nerode type argument is used to show that the treewidth parse tree operators admit a right congruence with finitely many congruence classes . </S>",
    "<S> the method of test sets can then be used to construct the tree automaton . </S>",
    "<S> one can also use a reduction to the classical model checking problem for mso on labeled trees  @xcite . </S>",
    "<S> it is well - known  @xcite that this problem can be solved by constructing suitable finite - state tree automata . </S>",
    "<S> this approach is favorable if one likes to use existing software such as the mona tool  @xcite .    </S>",
    "<S> a model theoretic approach is based on variants of the feferman  </S>",
    "<S> vaught theorem  @xcite : if a graph @xmath15 can be decomposed into components @xmath17 and @xmath18 , then from the input formula  @xmath8 one can construct a suitable _ reduction sequence _ consisting of boolean combinations ( _ and _ , _ or _ , </S>",
    "<S> _ not _ ) of finitely many formulas that hold in @xmath17 and @xmath18 if and only if @xmath8 holds in @xmath15 ( cf . ,  @xcite ) </S>",
    "<S> one can therefore use dynamic programming on the tree decomposition to compute the _ </S>",
    "<S> @xmath19-theory _ of @xmath15 , i.e. , set of formulas of quantifier rank at most  @xmath19 that hold in  @xmath15 ( cf . ,  </S>",
    "<S> @xcite ) . </S>",
    "<S> similarly , one can also inductively compute the set of satisfying assignments to the input formula  @xcite .    </S>",
    "<S> we are not aware of any implementations of courcelle s theorem based on the feferman  </S>",
    "<S> vaught approach . </S>",
    "<S> the construction of all possible reduction sequences for mso formulas `` obviously is not practical ''  ( * ? ? ? </S>",
    "<S> * section 1.6 ) . </S>",
    "<S> the algorithms presented in  @xcite are therefore infeasible in practice . </S>",
    "<S> however , from  @xcite we get that computing the particular reduction sequence for the input formula  @xmath8 suffices . </S>",
    "<S> some lower bounds are known for the necessary conversions into disjunctions  @xcite , but it would still be interesting to see how this approach behaves in practice .    </S>",
    "<S> a few authors studied practical aspects of the automata theoretic approach . </S>",
    "<S> it is mentioned in  @xcite that a myhill  </S>",
    "<S> nerode based program has been implemented as part of an m.sc .  </S>",
    "<S> thesis , which unfortunately does not seem to be publicly available . </S>",
    "<S> the mona tool  @xcite is a well - known and optimized implementation for the tree automata construction . </S>",
    "<S> the space required to construct the automata with mona still turns out to cause severe problems in practical applications  @xcite . </S>",
    "<S> one idea  ( * ? ? ? </S>",
    "<S> * chapter 6 ) is to use precomputed automata for commonly used predicates such as @xmath20 expressing that the set  @xmath21 is connected . </S>",
    "<S> note however that the @xmath20 automaton requires @xmath22 states for graphs of clique - width  @xmath23  ( * ? ? ? </S>",
    "<S> * chapter 6 ) . </S>",
    "<S> an automatic translation into monadic datalog is proposed in  @xcite . </S>",
    "<S> some experiments indeed suggest feasibility in practice ; their prototype implementation was , however , obtained by manual construction and not by an automatic transformation from the underlying mso formula . in  </S>",
    "<S> @xcite the power set construction is avoided by considering existential formulas only . </S>",
    "<S> the automata thus remain non - deterministic , but of course standard methods to simulate runs of the automata apply . </S>",
    "<S> since the state transition function is given only implicitly , the automaton is essentially computed _ on - the - fly _ while recognizing a clique - decomposition . </S>",
    "<S> experiments have been conducted on graphs of comparably high clique - width and the approach is quite promising . </S>",
    "<S> in fact , the lack of feasible algorithms to compute the necessary clique - width parse trees seems to be the major limitation . to ease the specification of such _ fly - automata _ , courcelle  @xcite introduces _ special tree - width_. special tree - width lies between path - width and treewidth , but the automata are significantly smaller and easier to construct than those for treewidth .    in this article </S>",
    "<S> , we present a new approach that neither uses automata theoretic methods nor uses a feferman  vaught style splitting theorem . </S>",
    "<S> instead , we essentially evaluate the input formula on the graph using a simple recursive model checking algorithm . in what follows </S>",
    "<S> , we shall outline this approach .      </S>",
    "<S> our starting point is the _ model checking game _ for mso ( definition  [ def : model - checking - game ] ) , a pebble game between two players called the _ verifier _ and the _ falsifier _ also known as the hintikka game  @xcite . </S>",
    "<S> the verifier tries to prove that the formula holds on the input structure , while the falsifier tries to prove the opposite . in the game , the verifier moves on existential formulas ( @xmath24 , @xmath25 ) , while the falsifier moves on universal formulas ( @xmath26 , @xmath27 ) .    </S>",
    "<S> this game can in a natural way be identified with a simple algorithm that _ evaluates _ the formula on the input structure in a recursive manner . </S>",
    "<S> if , for example , the formula is @xmath28 for a set variable  @xmath29 , the algorithm checks whether @xmath30 holds for all sets @xmath31 . in this sense </S>",
    "<S> , the computation tree of this simple algorithm can be interpreted as the _ unfolding _ ( cf . ,  </S>",
    "<S> @xcite ) of the model checking game . on a structure with @xmath32 elements , </S>",
    "<S> this straight - forward recursive model - checking algorithm takes time @xmath33 for a formula of quantifier rank  @xmath19 . by dynamic programming on the tree decomposition </S>",
    "<S> , we can improve this to time linear in @xmath32 on structures of bounded treewidth .    </S>",
    "<S> this works as follows : we traverse the tree decomposition of the input structure @xmath34 bottom - up . at each node of the tree decomposition </S>",
    "<S> we preliminary try to evaluate the formula @xmath8 on @xmath34 using the model checking game on the `` current '' substructure  @xmath35 of @xmath34 . to this end , we allow `` empty '' assignments @xmath36 to first order variables @xmath37 . </S>",
    "<S> such empty assignments correspond to objects in @xmath34 that are not contained in @xmath35 and are to be assigned in later steps . </S>",
    "<S> then , two things may happen :    * we can _ already now _ determine whether @xmath38 or @xmath39 . </S>",
    "<S> + if , for instance , the formula @xmath40 encodes the 3-colorability problem and even @xmath35 is not three - colorable , it locally violates @xmath40 and we can derive @xmath41 . * we can not _ yet _ determine whether @xmath38 or @xmath39 . </S>",
    "<S> + for example , if the formula encodes dominating set problem , then a vertex  @xmath42 in the `` current '' bag might be undominated in the current subgraph , but we do not know whether in the `` future '' another vertex might dominate  @xmath42 .    </S>",
    "<S> the first case is formalized in lemma  [ lem : emcg - eval - introduce ] and lemma  [ lem : emcg - eval - union ] . in the second case </S>",
    "<S> , we found a `` witness , '' i.e. , a subgame that we were unable to evaluate . </S>",
    "<S> we then will re - visit those undetermined subgames during the course of the dynamic programming until we finally arrive in the root of the tree decomposition , where all subgames become determined .    </S>",
    "<S> the next crucial observation is that mso and fo formulas with bounded quantifier rank have limited capabilities to distinguish structures ( formally captured in the @xmath43-equivalence of structures , cf .  </S>",
    "<S> @xcite ) . </S>",
    "<S> we exploit this fact and show that we can delete redundant equivalent subgames ( cf . , algorithm  [ alg : reduce ] ) for a suitable definition of equivalence ( cf . , definition  [ def : equivalent - games ] ) . </S>",
    "<S> we can then show that , assuming a fixed formula and bounded treewidth , the number of reduced , non - equivalent games is bounded by a constant ( lemma  [ lem : number ] ) , which allows us to obtain running times linear in the size of the tree decomposition .    while this game - theoretic approach is subject to the same non - elementary lower bounds as the other approaches , </S>",
    "<S> the actual number of ways to play the model checking game highly depends on the input graph . </S>",
    "<S> for example , if the graph does not contain , say , a triangle , then the players will never move to a set of nodes that induce a triangle , while a tree automaton must work for all graphs . </S>",
    "<S> this observation is reflected in practical experiments , where the actual number of entries considered is typically much smaller than the corresponding worst - case bound . </S>"
  ]
}