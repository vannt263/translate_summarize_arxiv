{
  "article_text": [
    "logics for expressing properties of labeled trees and forests figure importantly in several different areas of computer science .",
    "this paper is about logics on finite trees .",
    "all the logics we consider are less expressive than monadic second - order logic , and thus can be captured by finite automata on finite trees . even with these restrictions , this encompasses a large body of important logics , such as variants of first - order logic , temporal logics including ctl * or ctl , as well as query languages used in xml .    one way of trying to understand a logic is to give an effective characterization .",
    "an effective characterization for a logic @xmath2 is an algorithm which inputs a tree automaton , and says if the language recognized by the automaton can be defined by a sentence of the logic @xmath2 .",
    "although giving an effective characterization may seem an artificial criterion for understanding a logic , it has proved to work very well , as witnessed by decades of research , especially into logics for words . in the case of words ,",
    "effective characterizations have been studied by applying ideas from algebra : a property of words over a finite alphabet @xmath3 defines a set of words , that is a language @xmath4 as long as the logic in question is no more expressive than monadic second - order logic , @xmath5 is a regular language , and definability in the logic often boils down to verifying a property of the _ syntactic monoid _ of @xmath5 ( the transition monoid of the minimal automaton of @xmath5 ) .",
    "this approach dates back to the work of mcnaughton and papert  @xcite on first - order logic over @xmath6 ( where @xmath6 denotes the usual linear ordering of positions within a word ) .",
    "a comprehensive survey , treating many extensions and restrictions of first - order logic , is given by straubing  @xcite . thrien and wilke  @xcite similarly study temporal logics over words .",
    "an important early discovery in this vein , due to simon  @xcite , treats word languages definable in first - order logic over @xmath6 with low quantifier complexity .",
    "recall that a @xmath0 sentence is one that uses only existential quantifiers in prenex normal form , e.g.  @xmath7 .",
    "simon proved that a word language is definable by a boolean combination of @xmath0 sentences over @xmath6 if and only its syntactic monoid @xmath8 is _ @xmath1-trivial_.",
    "this means that for all @xmath9 if @xmath10 then @xmath11 ( in other words , distinct elements generate distinct two - sided semigroup ideals . )",
    "thus one can effectively decide , given an automaton for @xmath12 whether @xmath5 is definable by such a sentence .",
    "( simon did not discuss logic _",
    "per se _ , but phrased his argument in terms of _ piecewise testable languages _ which are exactly those definable by boolean combinations of @xmath0 sentences . )",
    "there has been some recent success in extending these methods to trees and forests .",
    "( we work here with unranked trees and forests , and not binary or ranked ones , since we believe that the definitions and proofs are cleaner in this setting . )",
    "the algebra is more complicated , because there are two multiplicative structures associated with trees and forests , both horizontal and a vertical concatenation .",
    "benedikt and segoufin  @xcite use these ideas to effectively characterize sets of trees definable by first - order logic with the parent - child relation .",
    "bojaczyk  @xcite gives a decidable characterization of properties definable in a temporal logic with unary ancestor and descendant operators .",
    "similarly bojaczyk and segoufin  @xcite and place and segoufin  @xcite provided decidable characterizations of tree languages definable in @xmath13 and @xmath14 where @xmath6 denotes the descendant - ancestor relationship while @xmath15 denotes the sibling relationship .",
    "the general theory of the ` forest algebras ' that underlie these studies is presented by bojaczyk and walukiewicz  @xcite .    in the present paper",
    "we provide a further illustration of the utility of these algebraic methods by generalizing simon s theorem from words to trees .",
    "in fact , we give several such generalizations , differing in the kinds of atomic formulas we allow in our @xmath0 sentences .    in section 2",
    "we present our basic terminology concerning trees , forests , and logic .",
    "initially our logic contains two orderings : the ancestor relation between nodes in a forest , and the depth - first , left - first , total ordering of the nodes of a forest . in section 3",
    "we describe the algebraic apparatus .",
    "this is the theory of forest algebras developed in  @xcite .    in section 4",
    "we give our main result , an effective test of whether a given language is piecewise testable ( theorem 4 . )",
    "the test consists of verifying that the syntactic forest algebra satisfies a particular identity .",
    "while we have to some extent drawn on simon s original argument , the added complexity of the tree setting makes both formulating the correct condition and generalizing the proof quite nontrivial . we give a quite different , equivalent identity in proposition 18 , which makes clear the precise relation between piecewise testability for forest languages and @xmath1-triviality .    in section 5",
    ", we study in detail a variant of our logic in which the binary ancestor relation is replaced by a ternary closest common ancestor relation , and prove a version of our main theorem for this case .",
    "section 6 is devoted to other variants : the far simpler case of languages defined by @xmath0 sentences ( instead of boolean combinations thereof ) ; the logics in which only the ancestor relation is present , and in which the horizontal ordering on siblings is present ; and , since our algebraic formalism concerns forests rather than trees , the modifications necessary to obtain an effective characterization of the piecewise testable tree languages .",
    "we discuss some directions for further research in the concluding section 7 .",
    "an earlier , much abbreviated version of this paper , without complete proofs , was presented at the 2008 ieee symposium on logic in computer science .",
    "[ [ trees - forests - and - contexts . ] ] trees , forests and contexts .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    in this paper we work with finite unranked ordered trees and forests over a finite alphabet @xmath16 .",
    "formally , these are expressions defined inductively as follows : for any @xmath17 , @xmath18 is a tree .",
    "if @xmath19 is a finite sequence of trees , then @xmath20 is a forest .",
    "if @xmath21 is a forest and @xmath22 , then @xmath23 is a tree .",
    "it will also be convenient to have an _ empty forest _ , that we will denote by 0 , and this forest is such that @xmath24 and @xmath25 .",
    "forests and trees alike will be denoted by the letters @xmath26    for example , the forest that we conventionally draw as        corresponds to the expression @xmath27 when there is no ambiguity we use @xmath23 instead of @xmath28 . in",
    "particular @xmath29 stands for the tree whose root has label @xmath30 and has a unique child of label @xmath31 .",
    "the notions of node , child , parent , descendant and ancestor relations between nodes are defined in the usual way .",
    "we write @xmath32 to say that @xmath33 is a strict ancestor of @xmath34 or , equivalently , that @xmath34 is a strict descendant of @xmath33 .",
    "we say that a sequence @xmath35 of nodes forms a _ chain _ if we have @xmath36 for all @xmath37 .",
    "as our forests are ordered , each forest induces a natural linear order on its set of nodes that we call the _ forest - order _ and denote by @xmath38 , which corresponds to the depth - first left - first traversal of the forest or , equivalently , to the order provided by the expression denoting the forest seen as a word .",
    "we write @xmath39 for the _ horizontal - order _ , i.e. @xmath40 expresses the fact that @xmath33 is a sibling of @xmath34 occurring strictly before @xmath34 in the forest - order . finally , the _ _ of two nodes @xmath41 is the unique node @xmath42 that is a descendant of all nodes that are ancestors of both @xmath33 and @xmath34 .",
    "if we take a forest and replace one of the leaves by a special symbol @xmath43 , we obtain a _ context .",
    "_ this special node is called the _ hole _ of the context .",
    "contexts will be denoted using letters @xmath44 .",
    "for example , from the forest @xmath45 given above , we can obtain , among others , the context @xmath46    a forest @xmath21 can be substituted in place of the hole of a context @xmath47 ; the resulting forest is denoted by @xmath48 . if we take the context @xmath47 above and if @xmath49 then @xmath50 this is depicted in the figure below .",
    "there is a natural composition operation on contexts : the context @xmath51 is formed by replacing the hole of @xmath52 with @xmath47 .",
    "this operation is associative , and satisfies @xmath53 for all forests @xmath21 and contexts @xmath47 and @xmath52 .",
    "we distinguish a special context , _ the empty context _",
    ", denoted @xmath43 .",
    "it satisfies @xmath54 and @xmath55 for any forest @xmath21 and context @xmath47 .",
    "[ [ regular - forest - languages . ] ] regular forest languages .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    a set @xmath5 of forests over @xmath16is called a _ forest language .",
    "_ there are several notions of automata for unranked ordered trees , see for instance  @xcite .",
    "they all recognize the same class of forest languages , called _ regular _ , which also corresponds to definability in as defined below .",
    "[ [ piecewise - testable - languages . ] ] piecewise testable languages .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we say that a forest @xmath21 _ is a piece _ of a forest @xmath45 if there is an injective mapping from nodes of @xmath21 to nodes of @xmath45 that preserves the label of the node together with the forest - order and the ancestor relationship .",
    "an equivalent definition is that the piece relation is the reflexive transitive closure of the relation @xmath56 in other words , a piece of @xmath45 is obtained by removing nodes from @xmath45 while preserving the forest - order and the ancestor relationship .",
    "we write @xmath57 to say that @xmath21 is a piece of @xmath45 .",
    "in the example above , @xmath58 is a piece of @xmath45 .",
    "we extend the notion of piece to contexts . in this case",
    ", the hole must be preserved while removing the nodes :        the size of a piece is the size of the corresponding forest , i.e.  the number of its nodes .",
    "the notions of piece for forests and contexts are related , of course .",
    "for instance , if @xmath47 , @xmath52 are contexts with @xmath59 , then @xmath60 . also , conversely , if @xmath57 , then there are contexts @xmath59 with @xmath61 and @xmath62 .",
    "a forest language @xmath5 over @xmath16is called _ piecewise testable _ if there exists @xmath63 such that membership of @xmath45 in @xmath5 is determined by the set of pieces of @xmath45 of size @xmath64 or less .",
    "equivalently , @xmath5 is a finite boolean combination of languages @xmath65 where @xmath21 is a forest .",
    "every piecewise testable forest language is regular , since given @xmath66 a finite automaton can calculate on input @xmath45 the set of pieces of @xmath45 of size no more than  @xmath67    [ [ logic . ] ] logic .",
    "+ + + + + +    regularity and piecewise testability correspond to definability in a logic , which we now describe .",
    "a forest can be seen as a logical relational structure .",
    "the domain of the structure is the set of nodes .",
    "the signature contains a unary predicate @xmath68 for each symbol @xmath18 of the label alphabet @xmath16 , plus possibly some extra predicates on nodes , such as the descendant relationship , the forest - order or the closest common ancestor .",
    "let @xmath69 be a set of predicates .",
    "the predicates @xmath69 that we use always include @xmath70 and equality , hence we do not explicitly mention them in the sequel .",
    "we use the classical syntax and semantics for first - order logic , @xmath71 , and monadic second order logic , @xmath72 , building on the predicates in @xmath69 . given a sentence @xmath73 of any of these formalisms , the set of forests that are a model for @xmath73 is called _ the language defined by @xmath73_. in particular a language is definable in @xmath74 iff it is regular  @xcite .",
    "a @xmath75 formula is a formula @xmath76 , where the formula @xmath77 is quantifier - free and uses predicates from @xmath69 .",
    "initially we will consider two predicates on nodes : the ancestor order @xmath78 and the forest - order @xmath79 .",
    "later on , we will see other combinations of predicates , for instance when the closest common ancestor is added , and the forest - order is removed .",
    "it is not too hard to show that a forest language @xmath5 can be defined by a @xmath80 sentence if and only if it is closed under adding nodes , i.e. @xmath81 holds for all contexts @xmath47 , @xmath52 and forests @xmath45 .",
    "moreover this condition can be effectively decided given any reasonable representation of the language @xmath5 .",
    "we will carry out the details in section  [ sec - sigma1 ] .",
    "we are more interested here in the boolean combinations of properties definable in @xmath80 .",
    "it is easy to see that :    [ boolean_sigma_1 ] a forest language is piecewise testable iff it is definable by a boolean combination of @xmath80 sentences .",
    "one direction is immediate as for any forest @xmath21 , the set of forests having @xmath21 as a piece is easily definable in @xmath80 .",
    "for instance the sentence @xmath82 defines the language of forests having @xmath58 as a piece .",
    "for the other direction , notice that for any language definable in @xmath80 , by disambiguating the relative positions between each pair of variables , one can compute a finite set of pieces such that a forest belongs to the language iff it has one of them as a piece .",
    "for instance the sentence @xmath83 defines the language of forests having @xmath58 , @xmath84 or @xmath85 as a piece .",
    "this result does not address the question of effectively determining whether a given regular forest language admits either of these equivalent descriptions .",
    "such an effective characterization is the goal of this paper :    [ [ the - problem . ] ] the problem .",
    "+ + + + + + + + + + + +    find an algorithm that decides whether or not a given regular forest language is piecewise testable .",
    "as noted in the introduction , the corresponding problem for words was solved by simon , who showed that a word language @xmath5 is piecewise testable if and only if its syntactic monoid @xmath86 is @xmath87-trivial  @xcite ; that is , if distinct elements @xmath88 always generate distinct two - sided ideals .",
    "note that one can test , given the multiplication table of a finite monoid @xmath89 whether @xmath8 is @xmath90-trivial in time polynomial in @xmath91 : for each @xmath92 , one calculates the ideals @xmath93 and @xmath94 and then verifies that they are different .",
    "therefore , it is decidable if a given regular word language is piecewise testable .",
    "we assume that the language @xmath5 is given by its syntactic monoid and syntactic morphism , or by some other representation , such as a finite automaton , from which these can be effectively computed .",
    "we will show that a similar characterization can be found for forests ; although the characterization will be more involved . for decidability ,",
    "it is not important how the input language is represented . in this paper",
    ", we will represent a forest language by a morphism into a finite forest algebra that recognizes it .",
    "forest algebras are described in the next section .",
    "[ [ forest - algebras . ] ] forest algebras .",
    "+ + + + + + + + + + + + + + + +    forest algebras were introduced by bojaczyk and walukiewicz as an algebraic formalism for studying regular tree languages  @xcite . here",
    "we give a brief summary of the definition of these algebras and their important properties .",
    "a forest algebra consists of a pair @xmath95 of monoids , subject to some additional requirements , which we describe below .",
    "we write the operation in @xmath96 multiplicatively and the operation in @xmath97 additively , although @xmath97 is not assumed to be commutative .",
    "we denote the identity of @xmath96 by @xmath43 and that of @xmath97 by 0 .",
    "we require that @xmath96 act on the left of @xmath97 .",
    "that is , there is a map @xmath98 such that @xmath99 for all @xmath100 and @xmath101 we further require that this action be _ monoidal , _ that is , @xmath102 for all @xmath103 and that it be _ faithful _ , that is , if @xmath104 for all @xmath103 then @xmath105    we further require that for every @xmath106 @xmath96 contains elements @xmath107 and @xmath108 such that @xmath109 for all @xmath110 observe , in particular , that for all @xmath111 @xmath112 so that the map @xmath113 is a morphism embedding @xmath97 as a submonoid of @xmath114    a morphism @xmath115 of forest algebras is actually a pair @xmath116 of monoid morphisms @xmath117 , @xmath118 such that @xmath119 for all @xmath103 @xmath120 however , we will abuse notation slightly and denote both component maps by @xmath121    let @xmath16be a finite alphabet , and let us denote by @xmath122 the set of forests over @xmath16 , and by @xmath123 the set of contexts over @xmath16 .",
    "clearly @xmath122 forms a monoid under @xmath124 @xmath123 forms a monoid under composition of contexts ( the identity element is the empty context @xmath43 ) , and substitution of a forest into a context defines a left action of @xmath123 on @xmath125 it is straightforward to verify that this action makes @xmath126 into a forest algebra , which we denote @xmath127 if @xmath95 is a forest algebra , then every map @xmath128 from @xmath16to @xmath96 has a unique extension to a forest algebra morphism @xmath129 such that @xmath130 for all @xmath131 in view of this universal property , we call @xmath132 the _ free forest algebra _ on @xmath16 .",
    "we say that a forest algebra @xmath95 _ recognizes _ a forest language @xmath133 if there is a morphism @xmath129 and a subset @xmath134 of @xmath97 such that @xmath135 we also say that the morphism @xmath136 recognizes @xmath137 it is easy to show that a forest language is regular if and only if it is recognized by a _",
    "forest algebra .    given @xmath133",
    "we define an equivalence relation @xmath138 on @xmath122 by setting @xmath139 if and only if for every context @xmath140 @xmath48 and @xmath141 are either both in @xmath5 or both outside of @xmath137 we further define an equivalence relation on @xmath123 , also denoted @xmath142 by @xmath143 if for all @xmath144 @xmath145 this pair of equivalence relations defines a congruence of forest algebras on @xmath127 the quotient @xmath146 is called the _ syntactic forest algebra _ of @xmath137 the projection morphism of @xmath132 onto @xmath146 is denoted @xmath147 and called the _",
    "syntactic morphism _ of @xmath5 .",
    "@xmath147 always recognizes @xmath5 and it is easy to show that @xmath5 is regular iff @xmath146 is finite .",
    "[ [ idempotents - and - aperiodicity . ] ] idempotents and aperiodicity .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we recall the well known notions of idempotent and aperiodicity .",
    "if @xmath8 is a finite monoid and @xmath148 then there is a unique element @xmath149 where @xmath150 such that @xmath151 is _ idempotent , _ _",
    "@xmath152 if we take a common multiple of these exponents @xmath64 over all @xmath148 we obtain an integer @xmath153 such that @xmath154 is idempotent for every @xmath155 observe that while infinitely many different values of @xmath156 have this property with respect to @xmath89 the value of @xmath154 is uniquely determined for each @xmath157    let @xmath95 be a forest algebra .",
    "since we write the operation in @xmath97 additively , we denote powers of @xmath100 by @xmath158 where @xmath159 as noted above , @xmath97 embeds in @xmath160 so any @xmath153 that yields idempotents for @xmath96 serves as well for @xmath161 that is , there is an integer @xmath153 such that @xmath162 is idempotent for all @xmath163 and @xmath164 is idempotent for all @xmath110    we say that a finite monoid @xmath8 is _ aperiodic _ if it contains no nontrivial groups .",
    "since the set of elements of the form @xmath165 for @xmath166 is a group , aperiodicity is equivalent to having @xmath167 for all @xmath155 in this case we can take @xmath168 all the finite monoids that we encounter in this paper are aperiodic . in particular , every @xmath1-trivial monoid is aperiodic , because all elements of a group in a finite monoid generate the same two - sided ideal .    [ [ pieces . ] ] pieces .",
    "+ + + + + + +    recall that in section  [ sec : notation ] , we defined the piece relation for contexts in the free forest algebra .",
    "we now extend this definition to an arbitrary forest algebra @xmath95 .",
    "the general idea is that a context @xmath169 is a piece of a context @xmath170 , denoted by @xmath171 , if one can construct a term ( using elements of @xmath97 and @xmath96 ) which evaluates to @xmath172 , and then take out some parts of this term to get @xmath173 .",
    "let @xmath95 be a forest algebra .",
    "we say @xmath169 _ is a piece _ of @xmath170 , denoted by @xmath171 , if @xmath174 and @xmath175 hold for some morphism @xmath176 and some contexts @xmath59 over @xmath16 .",
    "the relation @xmath177 is extended to @xmath97 by setting @xmath178 if @xmath179 and @xmath180 for some contexts @xmath171 .    as we will see in the proof of lemma  [ lemma : equivalent - def ] , in the above definition",
    ", we can replace the term `` some morphism '' by `` any surjective morphism '' .",
    "the following example shows that although the piece relation is transitive in the free algebra @xmath181 , it may no longer be so in a finite forest algebra .",
    "consider the syntactic algebra of the language @xmath182 , which contains only one forest , which in turn has just one path , labeled by @xmath183 .",
    "the context part of the syntactic algebra has twelve elements : an error element @xmath184 , and one element for each infix of @xmath183 .",
    "we have @xmath185 but we do not have @xmath186 .    we will now show that in a finite forest algebra , one can compute the relation @xmath177 in time polynomial in @xmath187 . the idea is to use a different but equivalent definition .",
    "let @xmath188 be the smallest relation on @xmath96 that satisfies the following rules , for all @xmath189 : @xmath190    [ lemma : equivalent - def ] over any finite forest algebra the relations @xmath188 and @xmath177 are the same .    in any finite algebra ,",
    "the relation @xmath188 can be computed by applying the rules until no new relations can be added .",
    "this gives the following corollary :    [ cor : decidable ] in any given finite forest algebra , the relation @xmath177 on contexts ( also on forests ) can be calculated in polynomial time .",
    "we first show the inclusion of @xmath188 in @xmath177 .",
    "let @xmath191 be any surjective morphism . a simple induction on the number of steps used to derive @xmath192 , produces contexts @xmath59 with @xmath174 and @xmath175 .",
    "the surjectivity of @xmath136 is necessary for starting the induction in the case @xmath193 .    for the opposite inclusion ,",
    "suppose @xmath194 then there is a morphism @xmath191 and contexts @xmath195 such that @xmath196 @xmath197 we will show that @xmath198 by induction on the size of @xmath47 :    @xmath199    if @xmath47 is the empty context , then the result follows thanks to the first rule in the definition of @xmath188 . if @xmath200 then from @xmath201 it follows that @xmath202 for some contexts @xmath203 and using the first three rules in the definition of @xmath188 we get that @xmath204 and hence @xmath205 .    if there is a decomposition @xmath206 where @xmath207 and @xmath208 are not empty contexts , then from @xmath195 there must be a decomposition @xmath209 with @xmath210 and @xmath211 . by induction",
    "we get that @xmath212 and @xmath213",
    ". then @xmath214 follows by using the third rule in the definition of @xmath188 .",
    "suppose now @xmath215 or @xmath216 .",
    "we can assume that @xmath21 is a tree , since otherwise the context @xmath47 can be decomposed as @xmath217 .",
    "since @xmath21 is a tree , it can be decomposed as @xmath218 , with @xmath18 being a context with a single letter and the hole below and @xmath219 a context smaller than @xmath47 . by inspecting the definition of @xmath177",
    ", there must be some decomposition @xmath220 or @xmath221 , with @xmath222 . by the induction assumption , @xmath223 .",
    "from this the result follows by applying rules three , four and five in the definition of @xmath188 .",
    "this argument shows that if @xmath224 with respect to a particular morphism @xmath225 then @xmath226 and consequently @xmath224 with respect to every morphism .",
    "thus we have also established the claim made above that the @xmath177 relation on @xmath97 is independent of the underlying morphism .",
    "the main result in this paper is a characterization of piecewise testable languages :    [ thm : main ] a forest language is piecewise testable if and only if its syntactic algebra satisfies the identity @xmath227 for all @xmath228 such that @xmath229    the identity  ( [ eq : context - absorb ] ) is illustrated in figure  [ fig : rule ] .    , with @xmath230 .",
    "the gray nodes are from @xmath173 . ]    in view of corollary  [ cor : decidable ] , an immediate consequence of theorem [ thm : main ] is that piecewise testability is a decidable property .",
    "it is decidable if a regular forest language is piecewise testable .",
    "we assume the language is given by its syntactic forest algebra , which can be computed in polynomial time from any recognizing forest algebra .",
    "the new identities can easily be verified in time polynomial in @xmath231 by enumerating all the elements of @xmath232 .",
    "the above procedure gives an exponential upper bound for the complexity in case the language is represented by a deterministic or even nondeterministic automaton , since there is an exponential translation from automata into forest algebras .",
    "we do not know if this upper bound is optimal .",
    "in contrast , for languages of words , when the input language is represented by a deterministic automaton , there is a polynomial - time algorithm for determining piecewise testability  @xcite .    in sections  [ sec : corr - equat ] and  [ sec : compl - equat ] , we prove both implications of theorem  [ thm : main ] .",
    "finally , in section  [ sec : an - equivalent - set ] , we give an equivalent statement of theorem  [ thm : main ] , where the relation @xmath177 is not used .",
    "but before we prove the theorem , we would like to show how it relates to the characterization of piecewise testable word languages given by simon .",
    "let @xmath8 be a monoid . for @xmath233 , we write @xmath234 if @xmath235 is a  not necessarily connected  subword of @xmath64 , i.e.  there are elements @xmath236 such that @xmath237",
    "we claim that , using this relation , the word characterization can be written in a manner identical to theorem  [ thm : main ] :    a word language is piecewise testable if and only if its syntactic monoid satisfies the identity @xmath238    recall that simon s theorem says a word language is piecewise testable if and only if its syntactic monoid is @xmath239-trivial . therefore , we need to show @xmath240-triviality is equivalent to  ( [ eq : monoid - context - absorb ] ) .",
    "we use an identity known to be equivalent to @xmath240-triviality ( see , for instance ,  @xcite , sec .",
    "v.3 . ) : @xmath241 since the above identity is an immediate consequence of  ( [ eq : monoid - context - absorb ] ) , it suffices to derive  ( [ eq : monoid - context - absorb ] ) from the above .",
    "we only show @xmath242 .",
    "as we assume @xmath234 , there are decompositions @xmath237 by induction on @xmath243 , we show @xmath244 the result then follows immediately .",
    "the base @xmath245 , is immediate . in the induction step ,",
    "we use the induction assumption to get : @xmath246 by applying  ( [ eq : j - trivial ] ) , we have @xmath247 and therefore @xmath248    note that since the vertical monoid @xmath96 in a forest algebra is a monoid , it would make syntactic sense to have the relation @xmath249 instead of @xmath177 in theorem  [ thm : main ] .",
    "unfortunately , the `` if '' part of such a statement would be false , as we will show in section  [ sec : an - equivalent - set ] .",
    "that is why we need to have a different relation @xmath177 on the vertical monoid , whose definition involves all parts of a forest algebra , and not just composition in the vertical monoid .      in this section",
    "we show the easy implication in theorem  [ thm : main ] .",
    "[ prop : correcntess ] if a language is piecewise testable , then its syntactic algebra satisfies identity  ( [ eq : context - absorb ] ) .    fix a language @xmath5 that is piecewise testable and let @xmath64 be such that membership of @xmath250 in @xmath5 only depends on the pieces of @xmath45 with at most @xmath64 nodes .",
    "we will use the following simple fact :    [ fact : descendant - obvious ] if @xmath251 is any context , @xmath59 are contexts and @xmath45 is a forest , then @xmath252 .",
    "we only show the first part of the identity , i.e. @xmath253    fix @xmath230 as above . by definition of @xmath156",
    ", we can write the identity as an implication : for @xmath254 , if @xmath255 then @xmath256 . let @xmath257 be as above .",
    "let @xmath258 be contexts that are mapped to @xmath173 and @xmath259 respectively by the syntactic morphism of @xmath5 . by unraveling the definition of the syntactic algebra , we need to show that @xmath260 holds for any context @xmath251 and forest @xmath45 .",
    "consider now the forests @xmath261 as @xmath262 , thanks to fact  [ fact : descendant - obvious ] , we get @xmath263 when @xmath243 is increasing , the number of pieces of size @xmath64 of @xmath264 is increasing .",
    "as there are only finitely many pieces of size @xmath64 , for @xmath243 sufficiently large , the two forests @xmath264 and @xmath265 have the same set of pieces of size @xmath64 .",
    "therefore , for sufficiently large @xmath243 , the two forests @xmath264 and @xmath266 have the same set of pieces of size @xmath64 , and either both belong to @xmath5 , or both are outside @xmath5 . however , since @xmath267 we have @xmath268 which gives the desired result .      this section is devoted to showing completeness of the identities : an algebra that satisfies identity  ( [ eq : context - absorb ] ) in theorem  [ thm : main ] can only recognize piecewise testable languages .",
    "we fix an alphabet @xmath16 , and a forest language @xmath5 over this alphabet , whose syntactic forest algebra @xmath146 satisfies the identity .",
    "we will write @xmath136 rather than @xmath147 to denote the syntactic morphism of @xmath5 , and sometimes use the term `` type of @xmath21 '' for the image @xmath269 ( likewise for contexts ) .    we write @xmath270 if the two forests @xmath271 have the same pieces of size no more than @xmath64 .",
    "likewise for contexts .",
    "the completeness part of theorem  [ thm : main ] follows from the following two results .",
    "[ lemma : eilenberg ] let @xmath272 . for @xmath257",
    "sufficiently large , if two forests satisfy @xmath273 , then they have a common piece @xmath45 in the same @xmath274-class , i.e.   @xmath275    [ lemma : remover ] for @xmath64 sufficiently large , @xmath276 entails @xmath277 .",
    "take @xmath64 as in proposition  [ lemma : remover ] , and then apply lemma  [ lemma : eilenberg ] to this @xmath64 , yielding @xmath257 .",
    "we show that @xmath278 implies @xmath279 , which immediately shows that @xmath5 is piecewise testable , by inspecting pieces of size @xmath257 .",
    "indeed , assume @xmath278 , and let @xmath45 be their common piece as in lemma  [ lemma : eilenberg ] . since @xmath45 is a piece of @xmath21 with the same pieces of size @xmath64 , it can be obtained from @xmath21 by a sequence of steps where a single letter is removed in each step without affecting the @xmath274-class .",
    "each such step preserves the type thanks to proposition  [ lemma : remover ] . applying the same argument to @xmath280",
    ", we get @xmath281 which gives the desired conclusion .",
    "we begin by showing lemma  [ lemma : eilenberg ] , and then the rest of this section is devoted to proving proposition  [ lemma : remover ] , the more involved of the two results .",
    "we begin with the following observation .",
    "[ fact : pumping ] let @xmath272 and let @xmath282 be a regular language .",
    "there is some constant @xmath257 , such that every @xmath283 contains a piece @xmath284 of size at most @xmath257 such that @xmath285 .",
    "let @xmath286 be a morphism into a finite forest algebra .",
    "let @xmath287 there is a @xmath257 such that every forest @xmath21 of size greater than @xmath257 can be written as @xmath288 where @xmath280 is a forest and the @xmath289 are nonempty contexts : this is because every large enough forest contains either a collection of @xmath235 siblings or a chain of length @xmath290 it follows that the sequence of values @xmath291 contains a repeat , and so we can remove a subsequence of the @xmath289 and obtain a proper piece @xmath45 of @xmath21 such that @xmath292 thus every forest @xmath21 has a piece @xmath45 of size at most @xmath257 such that @xmath292    now let @xmath95 be the direct product of the syntactic algebra @xmath293 and the quotient algebra @xmath294 and let @xmath295 be the product of the syntactic moprhism of @xmath282 and the natural projection onto the quotient by @xmath296 if @xmath297 then there is a piece @xmath45 of @xmath21 of size at most @xmath257 such that @xmath292 thus @xmath298 and @xmath299 proving the fact .",
    "we are now ready to prove lemma  [ lemma : eilenberg ] .",
    "fix @xmath300 .",
    "notice that each @xmath274 class is a regular language and @xmath274 has finitely many classes .",
    "for each @xmath274-class @xmath301 fact  [ fact : pumping ] gives a constant @xmath302 let @xmath257 be the maximum of @xmath64 and all these @xmath303 ; we claim the lemma holds for @xmath304 indeed , take any two forests @xmath273 .",
    "let @xmath45 be a piece of @xmath21 of size at most @xmath257 with @xmath270 , as given by fact  [ fact : pumping ] .",
    "since @xmath273 , the forest @xmath45 is also a piece of @xmath280 .",
    "furthermore since @xmath305 implies @xmath274 ( by @xmath306 ) , we get @xmath307 , which implies @xmath308 by transitivity of @xmath274 .",
    "we now show proposition  [ lemma : remover ] .",
    "let us fix a context @xmath47 , a label @xmath18 and a forest @xmath45 as in the statement of the proposition .",
    "the context @xmath47 may be empty , and so may be the forest @xmath45 .",
    "we search for the appropriate @xmath64 ; the size of @xmath64 will be independent of @xmath309 .",
    "we also fix the types @xmath310 , @xmath311 for the rest of this section . in terms of these types ,",
    "our goal is to show that @xmath312 . to avoid clutter",
    ", we will sometimes identify @xmath18 with its image @xmath313 , and write @xmath314 instead of @xmath315 .",
    "let @xmath21 be a forest and @xmath134 be a set of nodes in @xmath21 .",
    "the _ restriction of @xmath21 to @xmath134 _ , denoted @xmath316 $ ] , is the piece of @xmath21 obtained by only keeping the nodes in @xmath134 .",
    "let @xmath21 be a forest , @xmath134 a set of nodes in @xmath21 , and @xmath317 .",
    "we say that @xmath317 is a @xmath318-decomposition of @xmath21 if : a ) if we restrict @xmath21 to @xmath134 , remove descendants of @xmath33 , and place the hole in @xmath33 , the resulting context has type @xmath173 ; b ) the node @xmath33 has label @xmath18 ; c ) if we restrict @xmath21 to @xmath134 and only keep nodes in @xmath134 that are proper descendants of @xmath33 , the resulting forest has type @xmath319 .",
    "a _ fractal _ of length @xmath257 inside a forest @xmath21 is a sequence @xmath320 of @xmath318-decompositions of @xmath21 , where @xmath321 holds for @xmath322 .",
    "a _ subfractal _ is extracted by only using a subsequence @xmath323 of the @xmath318-decompositions .",
    "such a subsequence is also a fractal .",
    "[ lemma - fractal ] let @xmath254 . for @xmath64",
    "sufficiently large , @xmath276 entails the existence of a fractal of length @xmath257 inside @xmath324 .",
    "the proof is by induction on @xmath257 .",
    "the case @xmath325 is obvious .",
    "assume the lemma is proved for @xmath257 and @xmath64 and consider the case @xmath326 .",
    "the set of forests which have a fractal of length @xmath257 is a regular language , call it @xmath282 . by fact",
    "[ fact : pumping ] applied to @xmath282 , there is some constant @xmath235 such that every forest in @xmath282 has a piece that is also in @xmath282 , and whose size is bounded by @xmath235 .",
    "( in this reasoning , we do not use the parameter @xmath64 of fact  [ fact : pumping ] , so we can call fact  [ fact : pumping ] with @xmath327 ) .",
    "we can assume without loss of generality that @xmath328 .",
    "in other words , if a forest has a fractal of length @xmath257 , then it has a piece of size at most @xmath235 which has a fractal of length @xmath257 .",
    "this means that if a forest has a fractal of length @xmath257 , then it has a fractal of length @xmath257 which has at most @xmath235 nodes ( the number of nodes in a fractal is the number of nodes in the largest of its @xmath318-decompositions ) .",
    "assume now that @xmath329 . by the induction assumption , as @xmath330",
    ", we have a fractal of length @xmath257 inside @xmath324 .",
    "from the previous observation , this fractal can be assumed to be of size smaller than @xmath235 .",
    "hence we obtain a piece of @xmath331 which is a fractal of length @xmath257 inside @xmath331 .",
    "clearly , this resulting fractal can be extended to a fractal of length @xmath326 by taking for @xmath332 all the nodes of @xmath324 and for @xmath333 the node @xmath18 .",
    "thanks to the above lemma , proposition  [ lemma : remover ] is a consequence of the following result :    for @xmath257 sufficiently large , the existence of a fractal of length @xmath257 inside @xmath324 entails @xmath314 .",
    "the rest of this section is devoted to a proof of this proposition .",
    "the general idea is as follows .",
    "using some simple combinatorial arguments , and also ramsey s theorem , we will show that there is also a large subfractal whose structure is very regular , or tame , as we call it",
    ". we will then apply identity  ( [ eq : context - absorb ] ) to this regular fractal , and show that a node with label @xmath18 can be eliminated without affecting the type .",
    "a fractal @xmath320 inside a forest @xmath21 is called _ tame _ if @xmath21 can be decomposed as @xmath334 ( or @xmath335 ) such that for each @xmath336 , the node @xmath337 is part of the context @xmath289 , see fig .  [",
    "fig : tame ] .",
    "this does not necessarily mean that the nodes @xmath338 form a chain , since some of the contexts @xmath289 may be of the form @xmath339 .",
    "[ lemma : decompose ] let @xmath254 . for @xmath64 sufficiently large ,",
    "if there is a fractal of length @xmath64 inside @xmath324 , then there is a tame fractal of length @xmath257 inside @xmath324 .",
    "the main step is the following claim .",
    "[ claim : decompose ] let @xmath340 . for @xmath64",
    "sufficiently large , for every forest @xmath21 , and every set @xmath134 of at least @xmath64 nodes , there is a decomposition @xmath341 where every context @xmath289 contains at least one node from @xmath134 .",
    "let @xmath342 be the smallest set of nodes that contains @xmath134 and is closed under closest common ancestors . if @xmath64 is chosen large enough , either @xmath343 $ ] consist of more than @xmath235 trees , or it contains a node having more than @xmath235 children , or @xmath343 $ ] contains a chain of length bigger than @xmath235 .",
    "we are thus left with three cases :    @xmath199    in the set @xmath342 , there is a path @xmath344 . for @xmath345 , consider the set of nodes @xmath346 each set @xmath347 contains at least one node of @xmath134 , by definition of the set @xmath342 .",
    "the decomposition in the statement of the lemma is chosen so that context @xmath289 corresponds to the set @xmath347 .",
    "the context @xmath52 corresponds to all nodes that are not descendants of @xmath348 , and the forest @xmath280 corresponds to all descendants of @xmath349 .",
    "there is a node @xmath350 such that at least @xmath351 children of @xmath34 have some node from @xmath342 ( and therefore also @xmath134 ) in their subtree .",
    "let @xmath45 be the forest containing all proper descendants of @xmath34 .",
    "by assumption on @xmath34 , the forest @xmath45 can be decomposed as @xmath352 so that each of the forests contains at least one node from @xmath134 . for the decomposition in the statement of the lemma",
    ", we define @xmath52 to be the set of nodes outside @xmath45 , which includes @xmath34 , and we define @xmath289 to be @xmath353 and @xmath280 as @xmath354 .",
    "the forest @xmath21 can be decomposed as @xmath355 so that each of the forests contains at least one node from @xmath134 .",
    "we conclude as in the previous case but with an empty @xmath52 .",
    "we now come back to the proof of the lemma .",
    "for @xmath356 let @xmath64 be the number defined by claim  [ claim : decompose ] for @xmath357 .",
    "let @xmath358 be a fractal of length @xmath64 inside @xmath359 .",
    "we apply claim  [ claim : decompose ] , with @xmath360 and obtain a decomposition @xmath361 . for each @xmath362 the context",
    "@xmath289 contains at least one node of @xmath134 .",
    "we chose arbitrarily one of them and denote it by @xmath363 .",
    "unfortunately , the function @xmath364 need not be monotone , as required in a tame fractal .",
    "however , we can always extract a monotone subsequence , since any number sequence of length @xmath365 is known to have a monotone subsequence of length  @xmath257  @xcite    we now assume there is a tame fractal @xmath366 inside @xmath359 , which is decomposed as @xmath367 , with the node @xmath337 belonging to the context @xmath289 .",
    "the dual case when the decomposition is @xmath368 , corresponding to a decreasing sequence in the proof of lemma  [ lemma : decompose ] , is treated analogously .",
    "the general idea is as follows .",
    "we will define a notion of monochromatic tame fractal , and show that @xmath369 follows from the existence of large enough monochromatic tame fractal .",
    "furthermore , a large monochromatic tame fractal can be extracted from any sufficiently large tame fractal thanks to the ramsey theorem .",
    "let @xmath370 be such that @xmath371 .",
    "we define @xmath372 to be the image under @xmath136 of the context obtained from @xmath373 by only keeping the nodes from @xmath374 ( with the hole staying where it is ) .",
    "we define @xmath375 to be the image under @xmath136 of the context obtained from @xmath376 by only keeping the nodes from @xmath377 .",
    "straight from this definition , as @xmath378 we have @xmath379    a tame fractal is called _ monochromatic _ if for all @xmath380 and all @xmath381 taken from @xmath382 , we have @xmath383 note that in the above definition , we require @xmath384 , even though @xmath372 is defined even when @xmath385 .",
    "we apply the following form of ramsey s theorem ( see , for example , bollobas  @xcite ) : let @xmath386 be positive integers .",
    "then there exists an integer @xmath387 with the following property .",
    "let @xmath388 and suppose that the subsets of @xmath389 of cardinaility @xmath251 are colored with @xmath31 colors .",
    "then there exists a subset @xmath390 of @xmath389 with @xmath391 such that all subsets of @xmath390 with of cardinality @xmath251 have the same color .",
    "let @xmath156 be the exponent associated to the syntactic forest algebra @xmath146 as defined in section  [ sec : forest - algebras ] .",
    "if there is a tame fractal of size @xmath387 inside @xmath392 then the map @xmath393 gives us a coloring of the cardinality 3 subsets of @xmath394 with @xmath231 colors . by ramsey s theorem , if @xmath387 is sufficiently large , there is a monochromatic fractal of length  @xmath395 inside @xmath21 .",
    "we conclude by showing the following result :    [ lemma : mono - vertical ] if there is a monochromatic tame fractal of length  @xmath395 inside @xmath396 , then @xmath369 .",
    "fix a monochromatic tame fractal @xmath397 inside a forest @xmath398 .",
    "since @xmath399 is a @xmath318-decomposition , the statement of the lemma follows if @xmath136 assigns the same type to the two restrictions @xmath400 $ ] and @xmath401 $ ] .",
    "recall the definition of @xmath372 and @xmath375 above .",
    "the type of the forest @xmath400 $ ] can be decomposed as @xmath402 ) = \\alpha(q[x_k ] ) \\cdot     u_{01k } \\cdot u_{12k } \\cdot u_{23k } \\cdots u_{(k-1)kk } \\cdot \\alpha(s'[x_k])\\end{aligned}\\ ] ] the type of @xmath401 $ ] is decomposed the same way , only @xmath403 is replaced by @xmath404 . therefore",
    ", the lemma will follow if @xmath405 since the fractal is monochromatic , and since @xmath395 the above becomes @xmath406 by  ( [ eq : vert - piece1 ] ) and monochromaticity we have @xmath407 therefore identity  ( [ eq : context - absorb ] ) can be applied to show that both sides are equal to @xmath408 . note that we use only one side of identity  ( [ eq : context - absorb ] ) , @xmath409 .",
    "we would have used the other side when considering the case when @xmath410 .          in this section , we rephrase the identities used in theorem  [ thm : main ] .",
    "there are two reasons to rephrase the identities .",
    "the first reason is that identity  ( [ eq : context - absorb ] ) refers to the relation @xmath171 .",
    "one consequence is that we need to prove corollary  [ cor : decidable ] before concluding that identity  ( [ eq : context - absorb ] ) can be checked effectively .",
    "the second reason is that we want to pinpoint how identity  ( [ eq : context - absorb ] ) diverges from @xmath240-triviality of the context monoid @xmath96 .",
    "consider the forest language `` all trees in the forest are of the form @xmath411 '' .",
    "it is easy to verify that the syntactic forest algebra of this language is such that @xmath96 is @xmath240-trivial .",
    "but this language is not piecewise testable , since for any @xmath412 the forests @xmath413 and @xmath414 contain the same pieces of size at most @xmath415 but the first of these forests is in the language , while the second is not .",
    "the proposition below identifies an additional condition ( depicted in figure  [ fig : omega ] ) that must be added to @xmath240-triviality .",
    "[ prop : other - eq ] identity  ( [ eq : context - absorb ] ) is equivalent to @xmath239-triviality of @xmath96 , and the identity @xmath416    one implication is obvious : both @xmath240-triviality and  ( [ eq : new - eq ] ) follow from  ( [ eq : context - absorb ] ) . for the other implication",
    ", we assume @xmath417 is @xmath240-trivial and that  ( [ eq : new - eq ] ) holds . we must show that if @xmath230 , then @xmath418 we will only show the first equality , the other is done the same way . by unraveling the definition of @xmath230",
    ", there is a morphism @xmath419 and two contexts @xmath59 over @xmath16such that @xmath174 and @xmath420 .",
    "the proof goes by induction on the size of @xmath47 .",
    "if @xmath47 can be decomposed as @xmath421 with @xmath422 nonempty , then we have @xmath423 and @xmath424 and , by induction , @xmath425 , @xmath426 .",
    "hence we get : @xmath427    if @xmath47 consists of single node with a hole below , then we have @xmath428 for some two contexts @xmath429 , and therefore also @xmath430 for some @xmath431 .",
    "the result then follows by @xmath240-triviality of @xmath96 ( recall that @xmath240-triviality implies identity  ): @xmath432 in the above , we used twice identity  : once when adding @xmath433 to @xmath434 , and then when removing @xmath435 from after @xmath434 .",
    "the interesting case is when @xmath436 for some tree @xmath21 . in this case",
    ", the context @xmath52 can be decomposed as @xmath437 , with @xmath438 .",
    "we have @xmath439 thanks to identity  , the above can be rewritten as @xmath440 notice now that @xmath441 it is therefore sufficient to show that @xmath57 implies @xmath442 the proof of the above equality is by induction on the number of nodes that need to be removed from @xmath45 to get @xmath21 . the base case @xmath443 follows by aperiodicity of @xmath97 , which follows by aperiodicity of @xmath96 , itself a consequence of @xmath240-triviality .",
    "consider now the case when @xmath45 is bigger than @xmath21 .",
    "in particular , we can remove a node from @xmath45 and still have @xmath21 as a piece .",
    "in other words , there is a decomposition @xmath444 such that @xmath445 . applying the induction assumption , we get @xmath446 furthermore , applying identity  ( [ eq : new - eq ] )",
    ", we get @xmath447 combining the two equalities , we get the desired result .",
    "according to the definition of piece in section  [ sec : notation ] , @xmath448 is a piece of the forest @xmath449 in this section we consider a notion of piece which does not allow removing the closest common ancestor of two nodes , in particular removing the node @xmath31 in the example above .",
    "the logical counterpart of this notion is a signature where the closest common ancestor ( a three argument predicate ) is added .",
    "recall that in a forest @xmath21 we say that a node @xmath42 is the _ _ of the nodes @xmath33 and @xmath34 , denoted @xmath450 , if @xmath42 is an ancestor of both @xmath33 and @xmath34 and all other nodes of @xmath21 with this property are ancestors of @xmath42 . note that the ancestor relation can be defined in terms of the , since a node @xmath33 is an ancestor of @xmath34 if and only if @xmath33 is the of @xmath33 and @xmath34 .",
    "we now say that a forest @xmath21 _ is a _ of a forest @xmath45 , and write this as @xmath451 , if there is an injective mapping from nodes of @xmath21 to nodes of @xmath45 that preserves the label of the node together with the forest - order and the relationship ( the ancestor relationship is then necessarily preserved ) .",
    "an equivalent definition is that the relation is the reflexive transitive closure of the relation @xmath452 notice the difference with the notion of piece as defined in section  [ sec : notation ] , where @xmath45 could be an arbitrary forest .",
    "similarly we say that a context @xmath47 is a of the context @xmath52 , @xmath453 , if there is an injective mapping from @xmath47 to @xmath52 as above that also preserves the hole .",
    "a forest language @xmath5 is called _ testable _ if there exists @xmath454 such that membership of @xmath45 in @xmath5 depends only on the set of s of @xmath45 of size @xmath64 .    as before ,",
    "every testable language is regular and an analogue of proposition  [ boolean_sigma_1 ] holds as well .",
    "[ boolean_sigma_1-cca ] a forest language is testable iff it is definable by a boolean combination of @xmath455 formulas .",
    "recall that the ancestor relation can be expressed using the relation hence @xmath455 could be replaced by @xmath456 in the statement of proposition  [ boolean_sigma_1-cca ] .",
    "a first remark is that there are more testable languages than there are piecewise testable ones . hence the identities that characterize piecewise testable languages are no longer valid . in particular , in the syntactic algebra of a testable language , the context monoid @xmath96 may no longer be @xmath240-trivial . to see this",
    "consider the language @xmath5 of forests over @xmath457 that contain the @xmath458 .",
    "this is the language `` some @xmath18 is the of some @xmath30 and @xmath31 '' .",
    "then , for all @xmath64 , the context @xmath459 is not the same as the context @xmath460 as @xmath461 while @xmath462 .",
    "hence the identity @xmath463 does not hold in the syntactic context monoid of @xmath5 .",
    "however as we noted earlier , any @xmath90-trivial monoid satisfies this identity .",
    "note however that @xmath47 and @xmath52 satisfy the equivalence @xmath464 iff @xmath465 for all _ trees _ @xmath45 .",
    "the characterization below is a generalization of this idea of distinguishing trees from forests .",
    "we call a context a _ tree - context _ if it is nonempty and has one node that is the ancestor of all other nodes , including the hole .    in the presence of the , the algebraic situation is more complicated as well : testability of a forest language @xmath5 is not determined by the syntactic forest algebra alone . to obtain an algebraic characterization of this class of languages ,",
    "it is necessary to look at the _ syntactic morphism _ @xmath466 that maps each @xmath467 to its @xmath138-class , and not just the the image of this morphism .",
    "( we can be considerably more precise about this : the distinction is that the testable languages do not form a variety of languages in the sense described by eilenberg  @xcite .",
    "in particular , this family of languages lacks the crucial property of being closed under inverse images of morphisms between free forest algebras ; this fails if the morphism maps some generator @xmath468 to the empty context , or to a context of the form @xmath469 where @xmath47 is a context and @xmath21 is a nonempty forest .",
    "however testable languages satisfy all the other properties of varieties of languages and in particular they are closed under inverse images of homomorphisms that are `` tree - preserving '' , i.e. , the image of @xmath468 is a tree - context @xmath47 for all @xmath18 .",
    "varieties of forest languages are discussed in  @xcite . )",
    "we extend the relation to elements of a forest algebra @xmath95 in the presence of a morphism @xmath129 as follows : we write @xmath470 if there are contexts @xmath471 that are mapped to @xmath173 and @xmath172 respectively by the morphism @xmath136 .",
    "there is a subtle difference here with the definition of @xmath177 defined in section  [ sec : notation ] : the @xmath472 relation on @xmath96 depends on the morphism @xmath136 ! similarly we define the notion of @xmath473 for @xmath474 .",
    "the elements of @xmath96 that are images under the morphism @xmath136 of a tree - context are called tree - context - types . similarly , the elements of @xmath97 that are images of a tree are called tree - types ( it is possible for an element to be an image of both a tree and a non - tree , but it is still called a tree - type here ) .",
    "note that the notions of tree - type and of tree - context - type are relative to @xmath136 .",
    "[ thm : main - lca ] a forest language @xmath5 is testable if and only if its syntactic algebra and syntactic morphism satisfy the following identities : @xmath475 whenever @xmath319 is a tree - type or empty , and @xmath476 are tree - context - types , and @xmath477    because of the finiteness of the syntactic forest algebra @xmath146 one can effectively decide whether an element of one of these monoids is the image of a tree - context or of a tree .",
    "whether or not @xmath476 or @xmath478 holds can be decided in polynomial time using an algorithm as in corollary  [ cor : decidable ] based on the following equivalent definition of @xmath472 : let @xmath95 be a forest algebra and @xmath136 a surjective morphism from @xmath479 .",
    "let then @xmath188 be the smallest relation on @xmath96 that satisfies the following rules , for all @xmath480 : @xmath481    [ lemma : equivalent - def - cca ] for any finite @xmath95 and surjective morphism @xmath136 , the relations @xmath188 and @xmath472 are the same .",
    "we first show the inclusion of @xmath188 in @xmath472 . a simple induction on the number of steps used to derive @xmath192 , produces contexts @xmath471 with @xmath174 and @xmath175 .",
    "moreover @xmath47 ( @xmath52 ) is a tree - context whenever @xmath259 ( @xmath173 ) is a tree - context - type .",
    "the surjectivity of @xmath136 is necessary for starting the induction in the case @xmath193 .    for the inclusion of @xmath472 in @xmath188",
    ", we show that @xmath198 holds for all contexts @xmath471 .",
    "the proof is by induction on the size of @xmath47 :    @xmath199    if @xmath47 is the empty context , then the result follows thanks to the first rule in the definition of @xmath188 .",
    "if @xmath200 then from @xmath482 it follows that @xmath202 for some contexts @xmath203 and using the first and second rule in the definition of @xmath188 we get that @xmath483 , @xmath484 , and @xmath485 . hence using the third rule in the definition of @xmath188",
    "we get the desired result by composition .    if there is a decomposition @xmath486 where @xmath422 are contexts , then from @xmath487 there must be a decomposition @xmath488 with @xmath489 and @xmath490 . by induction",
    "we get that @xmath212 and @xmath213 .",
    "applying the second rule to the latter we get that @xmath491 .",
    "we can now apply the third rule to derive @xmath492 .",
    "if there is a decomposition @xmath493 where @xmath422 are non empty contexts and @xmath207 is of the form @xmath494 , then from @xmath487 there must be a decomposition @xmath209 with @xmath489 and @xmath495 and where @xmath496 is of the form @xmath497 .",
    "we conclude by induction and using the fourth rule in the definition of @xmath188 .",
    "the remaining case is when @xmath498 ( or @xmath499 ) where @xmath45 is a tree of the form @xmath500 for some context @xmath219 .",
    "then from @xmath487 we have @xmath501 for some contexts @xmath502 , with @xmath503 . by induction",
    "we have @xmath504 . using the second rule",
    "we get @xmath505 . using the last rule",
    "we get @xmath506 . by the first rule we have @xmath483 .",
    "we conclude using the fourth rule .",
    "this implies that theorem  [ thm : main - lca ] yields a decidable characterization of the testable languages .",
    "it is decidable if a regular forest language is testable .",
    "the proof of theorem  [ thm : main - lca ] follows the same outline as that of the proof of theorem  [ thm : main ] , but the details are somewhat complicated .",
    "the proof that  ( [ eq : lca - absorb ] ) and  ( [ eq : lca - forest - absorb ] ) are necessary is the same as section  [ sec : corr - equat ] .",
    "the only difference is that instead of fact  [ fact : descendant - obvious ] , we use the following .",
    "[ fact : lca - descendant - obvious ] if @xmath251 is any context , @xmath471 are tree - contexts , and @xmath45 is a tree or empty , then @xmath507 .",
    "we now turn to the completeness proof in theorem  [ thm : main - lca ] .",
    "the proof is very similar to the one of the previous section , with some subtle differences .    as before",
    ", we fix a language @xmath5 whose syntactic forest tree algebra @xmath95 satisfies all the identities of theorem  [ thm : main - lca ] .",
    "we write @xmath136 for the syntactic morphism .",
    "we now write @xmath270 if the two forests @xmath271 have the same of size @xmath64 . likewise for contexts .",
    "the main step is to show the following proposition .",
    "[ prop : remover - lca ] for @xmath64 sufficiently large , if @xmath45 is a tree or empty , then @xmath508 entails @xmath277 .",
    "theorem  [ thm : main - lca ] follows from the above proposition in the same way as theorem  [ thm : main ] follows from proposition  [ lemma : remover ] in the previous section .",
    "the reason why we assume that @xmath45 is either a tree or empty is because when @xmath21 is an of @xmath280 , then @xmath21 can be obtained from @xmath280 by iterating one of the following two operations : removing a leaf , or removing a node which has only one child . hence during the pumping argument yielding theorem  [ thm : main - lca ] from proposition  [ prop",
    ": remover - lca ] it is enough to preserve the type only for these operations .",
    "we thus concentrate on showing proposition  [ prop : remover - lca ] .",
    "we will now redefine the concept of fractal for our new , setting .",
    "the key change is in the concept of a @xmath318-decomposition .",
    "we change the notion of @xmath509 being a @xmath318-decomposition of @xmath21 as follows : all conditions of the old definition hold , but new conditions are added .",
    "first we require that @xmath316 $ ] be a piece of @xmath21 , in particular this implies that if two elements of @xmath134 have a in @xmath21 then this is also in @xmath134 .",
    "moreover either @xmath33 has no descendants in @xmath134 ; or there is a minimal element of @xmath134 that has @xmath33 as a proper ancestor . in other words ,",
    "the part of @xmath316 $ ] that corresponds to @xmath319 is either empty , or is a tree .",
    "in particular , @xmath510 $ ] is a piece of @xmath316 $ ] ; which is the key property required below . from now on , when referring to a @xmath318-decomposition , we use the new definition .",
    "in particular in the concept of a fractal @xmath511 inside @xmath21 we now have that for each @xmath243 , @xmath512 is a @xmath318-decomposition of @xmath21 in the new sense .",
    "the proof of the following lemma is exactly the same as its counterpart in section  [ sec : compl - equat ] ( lemma  [ lemma - fractal ] ) and is therefore omitted .",
    "let @xmath254 .",
    "for @xmath64 sufficiently large , if @xmath45 is a tree or empty , then @xmath276 entails the existence of a fractal of length @xmath257 inside @xmath324 .    a fractal @xmath513 inside @xmath21 is called _",
    "_ if @xmath21 can be decomposed as @xmath334 ( or @xmath335 ) such that @xmath514 and such that either :    @xmath199    each @xmath289 is a tree context whose root node belongs to @xmath515 .",
    "each @xmath289 is a context of the form @xmath516 , with @xmath517 a forest .",
    "[ lemma : lca - decompose ] let @xmath254 . for @xmath64",
    "sufficiently large , if there is a fractal of length @xmath64 inside @xmath324 , then there is a fractal of length @xmath257 inside @xmath324 .",
    "the proof is essentially the same as for the counter part in section  [ sec : compl - equat ] ( lemma  [ lemma : decompose ] ) ; only this time we need to be more careful to satisfy the more stringent requirements in a fractal .",
    "let @xmath518 .",
    "using the same reasoning as in the proof of lemma  [ lemma : decompose ] , if @xmath64 is large enough then we may extract a subfractal of length @xmath235 where either :    @xmath199    all the nodes @xmath519 have the same . in this case",
    ", we can extract a subfractal , where each context is of the form @xmath516 .",
    "the set @xmath520 contains a chain @xmath521 , such that for each @xmath522 , the set @xmath523 contains at least one of the node @xmath337 .",
    "( there is a second case , where the nodes @xmath524 are ordered the other way : with @xmath525 an ancestor of @xmath526 .",
    "this case is treated analogously . ) in particular , @xmath526 is the of @xmath337 and any of the nodes @xmath527 .",
    "since @xmath528 contains both @xmath337 and @xmath529 , each node @xmath526 belongs to the set @xmath528 .",
    "as we may have @xmath530 , the desired fractal is obtained as follows : we use @xmath531 as the fractal ( recall that @xmath518 ) ; while the decomposition @xmath532 is chosen so that @xmath289 has its root in @xmath533 , and its hole in @xmath534 .    recall the definition of @xmath372 and @xmath375 as the image under @xmath136 of the context obtained from @xmath376 by restricting @xmath21 to @xmath374 and @xmath377 , respectively .",
    "note that because of the new definition of fractals we have : @xmath535 @xmath536    the definition of monochromaticity is the same as in the previous section and ramsey s theorem gives .",
    "if there is a fractal of sufficiently large size inside @xmath324 , then there is a monochromatic fractal of size @xmath537 inside @xmath324 .",
    "we will now take a monochromatic fractal , and conclude by showing that @xmath277 .",
    "[ lemma : mono - vertical - gca ] if there is a monochromatic fractal of size @xmath538 inside @xmath324 , then @xmath369 .",
    "fix a monochromatic fractal of size @xmath539 and let @xmath540 .",
    "since @xmath399 is a @xmath318-decomposition , the statement of the lemma follows once we show that @xmath136 assigns the same type to the forest @xmath400 $ ] and @xmath401 $ ] .",
    "recall that the type of the forest @xmath400 $ ] can be decomposed as follows ( the case where @xmath541 is treated similarly by duality ) .",
    "@xmath542 ) = \\alpha(q[x_k ] ) \\cdot    u_{01k } \\cdot u_{12k } \\cdot u_{23k } \\cdots u_{(k-1)kk } \\cdot \\alpha(q_m[x_k]s'[x_k])\\end{aligned}\\ ] ] the type of @xmath401 $ ] is decomposed the same way , only @xmath403 is replaced by @xmath404 .",
    "let @xmath543s'[x_k])$ ] and notice that if @xmath544 is a tree - context then @xmath319 is a tree - type .",
    "therefore , the lemma will follow if @xmath545 since the fractal is monochromatic , and since @xmath395 , the above becomes @xmath546    by  ( [ eq : lca - prop - decompose1 ] ) and monochromaticity , we have @xmath547 we now have two cases .",
    "if all the @xmath289 are tree - contexts , we conclude using identity  ( [ eq : lca - absorb ] ) which can be applied because of  , and the fact that @xmath319 is then a tree - type and  ( [ eq : lca - prop - decompose2 ] ) .",
    "if all the @xmath289 are contexts of the form @xmath548 , we conclude from   using identity  ( [ eq : lca - forest - absorb ] ) .      in this section ,",
    "we give a set of identities that is equivalent to the one used in theorem  [ thm : main - lca ] .",
    "the rationale is the same as in proposition  [ prop : other - eq ] : we want to avoid the use of @xmath549 in the identities .",
    "[ prop : other - set - lca ] the conditions on the syntactic morphism stated in theorem  [ thm : main - lca ] are equivalent to the following equalities :    @xmath550    whenever @xmath319 is a tree - type or empty , and @xmath551 whenever @xmath259 and @xmath173 are tree - context - types , and @xmath552 whenever @xmath259 is a tree - context - type or empty and @xmath553 are tree - types or empty .    the rest of section  [ sec : an - equivalent - set - gca ] is devoted to showing the above proposition .",
    "it is immediate to see that identity  ( [ eq : lca - absorb ] ) implies identity  ( [ eq : lca - j - trivial-2 ] ) and that identity  ( [ eq : lca - absorb ] ) implies identity  ( [ eq : new - simpler ] ) .",
    "we now show that identities  ( [ eq : lca - absorb ] ) and  ( [ eq : lca - forest - absorb ] ) imply identity  ( [ eq : lca - j - trivial-1 ] ) .",
    "let @xmath259 and @xmath173 be two context - types and @xmath319 be a tree - type .",
    "we want to show that @xmath554 .",
    "we consider several cases .",
    "@xmath199    in the first case we assume that @xmath555 for some tree - context - type @xmath556 . in that case",
    "we have : @xmath557 notice now that @xmath558 and that @xmath559 .",
    "as @xmath556 is a tree - context - type , all the context - types involved are tree - context - types and we can use identity  ( [ eq : lca - absorb ] ) twice and replace @xmath560 by @xmath561 .",
    "this yields : @xmath562 and we have @xmath563 by idempotency , this yields the desired result : @xmath564    the second case , in which we assume that @xmath565 for some tree - context - type @xmath566 is treated similarly .",
    "@xmath567 therefore , @xmath568    notice now that @xmath569 and that @xmath570 .",
    "as @xmath571 is a tree - context - type , all the context - types involved are tree - context - types and we can use identity  ( [ eq : lca - absorb ] ) twice and replace @xmath571 by @xmath572 .",
    "this yields : @xmath573 and we have @xmath574    when none of the above cases works , we must have @xmath575 and @xmath576 . in that case",
    "we have @xmath577 , and we conclude using identity  ( [ eq : lca - forest - absorb ] ) as @xmath578 and @xmath579 .",
    "we now consider the converse implication in proposition  [ prop : other - set - lca ] .",
    "assume that identities  ( [ eq : lca - j - trivial-1])-([eq : new - simpler ] ) hold .",
    "we show that identities  ( [ eq : lca - absorb ] ) and  ( [ eq : lca - forest - absorb ] ) are satisfied .",
    "we first show the following lemma :    [ lemma - hard ] if @xmath259 is a tree - context - type , @xmath580 are ( not necessarily tree ) context - types with @xmath581 , and @xmath553 are either tree - types or empty , then the following identity holds @xmath582    note that the identity  ( [ eq : lca - forest - absorb ] ) is a direct consequence of the above , by taking @xmath583 to be the empty context , and @xmath553 to be the empty tree .",
    "we will also use the above lemma to show  ( [ eq : lca - absorb ] ) , but this will require some more work .",
    "the proof is by induction on the number of steps used to derive @xmath584 .",
    "@xmath199    consider first the case when @xmath585 can be decomposed as @xmath586 two applications of the induction assumption give us for all tree - type or empty @xmath587 : @xmath588 as @xmath259 is a tree - context - type we can iterate on   and then apply   in order to derive : @xmath589 as @xmath259 is a tree - context - type , we can apply again   in the reverse direction in order to derive the desired result .",
    "consider now the case when @xmath585 can be decomposed as @xmath590 with @xmath591 a tree - context - type or empty .",
    "we first use the induction assumption to get    @xmath592    by applying the identity  ( [ eq : new - simpler ] ) , we get for all tree - type or empty @xmath587 :    @xmath593    note that it is important here that @xmath594 is either a tree - context - type or empty . finally , we apply once again the induction assumption to get @xmath595 as @xmath259 is a tree - context type , we can first iterate on  , then iterate on   and finally applying   in order to get : @xmath596 because @xmath259 is a tree - context - type we can now apply   and   in reverse to eliminate the inner products and obtain the desired result .    finally , consider the case when @xmath585 can be decomposed as @xmath597 in this case , the identity becomes : @xmath598 where @xmath599 .",
    "the result now follows by induction assumption with @xmath600 in place of @xmath585 .",
    "we now claim that all cases have been considered .",
    "assume first that either @xmath601 or @xmath172 consists of several trees .",
    "then , by the definition of @xmath472 , @xmath601 and @xmath172 can be decomposed into smaller forests and we conclude using the first bullet .",
    "we can thus assume that both @xmath172 and @xmath601 are trees .",
    "if @xmath601 contains a node between its root and its hole then , by definition of @xmath472 , we can decompose @xmath172 and @xmath601 and apply the second bullet .",
    "similarly we can transform @xmath172 using the first bullet until the third bullet can be applied .",
    "we now derive the first part of identity  ( [ eq : lca - absorb ] ) .",
    "let @xmath259 , @xmath173 be tree - context - types such that @xmath476 , and let @xmath319 be a tree - type .",
    "we show by induction on @xmath173 that @xmath602 . if @xmath565 where both @xmath603 and @xmath571 are tree - context - types then we consider @xmath571 first and @xmath603 next : @xmath604 it is important here that @xmath605 is a tree - type .",
    "therefore it is enough to consider the case where @xmath173 is of the form @xmath606 for some letter @xmath18 and some forest - type @xmath128 . in the sequel",
    "we write @xmath18 instead of @xmath313 in order to improve readability . from @xmath607",
    "we get @xmath608 where @xmath609 and @xmath556 are tree - context - types and @xmath610 .",
    "then we have from identity  ( [ eq : lca - j - trivial-1 ] ) for any tree - type @xmath319 : @xmath611 and therefore , as @xmath612 is a tree - type we get for any tree - type @xmath319 : @xmath613 iterating on   we get : @xmath614 it will therefore be enough to show @xmath615 for @xmath610 .",
    "this , however , is a consequence of  ( [ eq : hard - won - lemma ] ) .",
    "the second part of identity  ( [ eq : lca - absorb ] ) , @xmath616 , is shown the same way using identity  ( [ eq : lca - j - trivial-2 ] ) instead of identity  ( [ eq : lca - j - trivial-1 ] ) and building on   below instead of  .",
    "if @xmath259 is a tree - context - type , @xmath580 are ( not necessarily tree ) context - types with @xmath581 , and @xmath553 are either tree - types or empty , then the following identity holds @xmath617    identical to the proof of lemma  [ lemma - hard ] , applying the other side of identity  ( [ eq : new - simpler ] ) .",
    "in this section we show that the techniques we developed in the previous sections are fairly robust and can be adapted to many situations .",
    "we describe some of them .      here",
    "we treat the relatively simple case of languages defined by @xmath0 sentences ( rather than boolean combinations of such formulas ) .",
    "we will prove :    [ sigma_1_decidable ] it is decidable whether a given regular forest language @xmath5 is definable by a @xmath80 sentence .",
    "we will show how to do this using the syntactic forest algebra and syntactic morphism , although this could be carried out just as well using an automaton model .",
    "the argument we give is based on an idea of pin  @xcite concerning ordered monoids .",
    "let @xmath133 be a regular forest language , and let @xmath618 be its syntactic morphism .",
    "we set @xmath619 note that @xmath620 for @xmath621 we define @xmath622 if for all @xmath623 @xmath624 implies @xmath625 further , for @xmath626 we define @xmath627 if for all @xmath628 @xmath629    the relations @xmath630 and @xmath631 are partial orders on @xmath632 and @xmath633 respectively .",
    "these orders are compatible with the algebra operations in the sense that whenever @xmath634 @xmath635 and @xmath636 we have @xmath637 @xmath638    this is straightforward from the definitions : transitivity and reflexivity of @xmath630 are obvious . to prove antisymmetry , suppose @xmath639 and @xmath640 let @xmath641 with @xmath642 let @xmath643 and set @xmath644",
    "if @xmath645 then @xmath646 so @xmath647 and thus @xmath648 likewise @xmath649 implies @xmath650 so @xmath651 and thus @xmath652    transitivity and reflexivity of @xmath631 are likewise trivial , and antisymmetry follows from the antisymmetry of @xmath630 and the faithfulness of the action of @xmath232 on @xmath653    for the multiplicative properties , let @xmath654 be as in the statement of the proposition . if @xmath655 then @xmath656 ( since @xmath657 ) and thus @xmath658 ( since @xmath659 ) .",
    "thus @xmath660 similarly @xmath661 implies @xmath662 ( since @xmath663 ) and thus @xmath664 ( since @xmath665 ) so @xmath666    let @xmath133 be a regular forest language .",
    "the following are equivalent :    @xmath199    @xmath5 is definable by a @xmath80 formula .",
    "for all contexts @xmath47 , @xmath52 and forests @xmath667 @xmath668    for all @xmath623 @xmath669    the first condition implies the second , because inserting new nodes in a forest does not change the @xmath6 or @xmath38 relation among the already existing nodes .    to show that the second condition implies the first",
    ", we use a pumping argument : let @xmath670 there exists @xmath671 such that any forest @xmath21 with at least @xmath282 nodes has a factorization @xmath672 for some forest @xmath667 nonempty contexts @xmath289 . in particular , there is a factorization @xmath673 with @xmath674 thus a forest belongs to @xmath5 if and only if it is obtained by successive insertion of nodes starting with a forest in @xmath5 of size less than @xmath675 we can write a @xmath0 sentence @xmath73 that describes all the relations among nodes of the forests of size less than @xmath282 that belong to @xmath12 and thus this sentence defines @xmath137    to show the equivalence of the second and third conditions , suppose the second condition holds .",
    "we need to show @xmath676 for all @xmath120 this says that for every forest @xmath21 and every context @xmath677 @xmath678 implies @xmath679 which follows from the second condition .",
    "conversely , suppose the third condition holds , and that @xmath680 are contexts and @xmath45 a forest with @xmath681 then @xmath682 by the multiplicative properties of the partial order , @xmath683 and thus @xmath684    theorem  [ sigma_1_decidable ] is an immediate corollary , since one can effectively compute the order @xmath631 given the syntactic algebra and syntactic morphism of @xmath137      in this section we consider forest languages that are commutative , _",
    "closed under rearranging siblings .",
    "a forest @xmath685 is called a _ reordering _ of a forest @xmath45 if it is obtained from @xmath45 by rearranging the order of siblings .",
    "in other words , reordering is the least equivalence relation on forests that identifies all pairs of forests of the form @xmath686 and @xmath687 .",
    "a forest language is called _ commutative _ if it is closed under reordering . in other words ,",
    "a forest language is _ commutative _ if and only if its syntactic forest algebra satisfies the identity @xmath688    we say a forest @xmath21 is a _ commutative piece _ of @xmath45 , if @xmath21 is a piece of some reordering of @xmath45 .",
    "a forest language @xmath5 is called _ commutative - piecewise testable _ if for some @xmath272 , membership of @xmath45 in @xmath5 depends only on the set of commutative pieces of @xmath45 that have no more than @xmath64 nodes .",
    "this definition also has a counterpart in logic , by removing the forest - order from the signature .",
    "the following proposition is immediate :    a forest language is commutative - piecewise testable iff it is definable by a boolean combination of @xmath689 formulas .",
    "if a language is commutative - piecewise testable , then it is clearly commutative and piecewise testable ( in the more powerful , noncommutative , sense ) .",
    "below we show that the converse implication is also true :    [ thm : commutative ] a forest language is commutative - piecewise testable if and only if it is commutative and piecewise testable .",
    "as piecewise testability is decidable , by corollary  [ cor : decidable ] , and commutativity is obviously decidable , the theorem above implies decidability :    it is decidable if a regular forest language is commutative - piecewise testable .",
    "theorem  [ thm : commutative ] follows quite easily from :    [ lemma - commutative ] let @xmath272 . for @xmath257",
    "sufficiently large , if two forests have the same commutative pieces of size at most @xmath257 , then they can be both reordered so that the resulting forests have the same pieces of size at most @xmath64 .    to see this , assume",
    "@xmath5 is a commutative and piecewise testable forest language .",
    "we need to show that there is a @xmath257 such that if @xmath45 and @xmath21 have the same commutative pieces of size @xmath257 then @xmath690 iff @xmath678 . as @xmath5 is piecewise testable",
    "there exists an @xmath64 such that whenever @xmath21 and @xmath45 have the same pieces of size no more than @xmath64 then @xmath690 iff @xmath678 .",
    "let @xmath257 be the number given by lemma  [ lemma - commutative ] for that @xmath64 .",
    "assume now that @xmath21 and @xmath45 have the same commutative pieces of size @xmath257 .",
    "by lemma  [ lemma - commutative ] they can be reordered into respectively @xmath280 and @xmath685 such that @xmath280 and @xmath685 have the same pieces of size @xmath64 .",
    "hence @xmath691 iff @xmath692 . but",
    "as @xmath5 is commutative this yields @xmath678 iff @xmath690 as desired .",
    "let @xmath693 be the set of pieces of @xmath21 that have size at most @xmath64 .",
    "as in lemma  [ lemma : eilenberg ] , there is some @xmath257 such that any forest @xmath21 has a piece @xmath694 of size at most @xmath257 with @xmath695 .",
    "let now @xmath696 be two forests with the same commutative pieces of size @xmath257 . for @xmath697 , consider the families @xmath698 to prove the lemma , we need to show that the families @xmath699 and @xmath700 share a common element . to this end , we show that for any @xmath701 , there is some @xmath702 with @xmath703 , and vice versa ; in particular , the families share the same maximal elements .",
    "let then @xmath704 . by the choice of @xmath257 , the forest @xmath705 has a piece @xmath45 of size at most @xmath257 with @xmath706 .",
    "therefore @xmath45 is a commutative piece of @xmath707 of size @xmath257 . by assumption , the forest @xmath45 is also a commutative piece of @xmath708 and therefore a piece of some reordering @xmath709 of @xmath708 .",
    "hence @xmath710 .",
    "similarly we can define the notion of commutative - and commutative - testable forest language . using the same arguments as above",
    "we can prove :    a forest language is commutative - testable iff it is definable by a boolean combination of @xmath711 formulas .",
    "[ thm : commutative - cca ] a forest language is commutative - testable if and only if it is commutative and testable .",
    "it is decidable if a regular forest language is commutative - testable .",
    "our previous results were provided decidable characterizations for _ forest _ languages , and in fact the algebraic theory used here works best when forests , rather than trees , are treated as the fundamental object .",
    "traditionally , though , interest has focused on trees rather than forests .",
    "thus we want to give a decidable characterization of the piecewise testable tree languages or , equivalently , the sets of _ trees _ that are definable by boolean combinations of @xmath0 sentences .    for certain logics , like first - order logic over the descendant relation , or first - order logic over successor , one can write a sentence that says `` this forest is a tree '' , and thus there is no need to treat tree and forest languages separately . for piecewise testability",
    ", we need to do something more , since the set of all trees over a finite alphabet @xmath16is not definable by a boolean combination of @xmath0 sentences over any of the predicates mentioned in this paper .",
    "we define a _ tree piecewise testable language _ over a finite alphabet @xmath16to be the intersection of a piecewise testable forest language with the set of all trees over @xmath16 .",
    "in other words this is the set of languages definable by a boolean combination of @xmath80 formulas when we interpret these formulas in trees .",
    "this is preferable to defining a piecewise testable tree language to be a tree language that is piecewise testable ( as a forest language ) , since the latter definition would only define tree languages that are either finite or contain only chains ( no branching ) .",
    "moreover it would not correspond to the tree languages definable by a boolean combination of @xmath80 formulas .",
    "the cases when the pieces are assumed to be commutative and/or take into account are defined analogously .",
    "we will obtain our decidability result by a general method for translating algebraic characterizations of classes of forest languages to characterizations of the corresponding classes of tree languages .",
    "this method will apply to all the cases we considered earlier : piecewise testable languages , testable languages , and their commutative counterparts .    first ,",
    "suppose @xmath712 is a surjective forest algebra morphism .",
    "recall that we denote by @xmath122 the set of all forests of @xmath16 . based on @xmath136",
    ", we define an equivalence relation on @xmath122 : we write @xmath713 if for all contexts @xmath47 such that @xmath48 and @xmath331 are both trees ( this happens if @xmath47 is a tree - context or if @xmath47 is the empty context and both @xmath45 and @xmath21 are trees ) we have @xmath714 .",
    "notice that if @xmath21 and @xmath45 are such that @xmath715 then @xmath713 and that if @xmath21 and @xmath45 are both trees then @xmath716 implies @xmath715 ( take @xmath717 in the definition of @xmath718 ) .",
    "it is clear that if @xmath713 then for any context @xmath719 @xmath720 thus @xmath718 defines a forest algebra congruence on @xmath127 let @xmath721 be the projection morphism onto the quotient by this congruence .",
    "we call @xmath722 the _ tree reduction _ of @xmath121 from the remark above it follows that if @xmath45 and @xmath21 are both trees then @xmath715 iff @xmath723 .",
    "let @xmath724 be a family of forest languages over @xmath16 .",
    "we say that a set @xmath725 of surjective forest algebra morphisms with domain @xmath132 _ characterizes @xmath724 _ if a forest language @xmath5 belongs to @xmath724 if and only if @xmath5 is recognized by some morphism in @xmath726 .",
    "we will further assume that @xmath726 is closed in the following sense : suppose @xmath727 belongs to @xmath728 and @xmath729 is a morphism onto a finite forest algebra .",
    "then @xmath730 belongs to @xmath731    [ thm : forests - to - trees ] let @xmath724 and @xmath726 be as above , and let @xmath133 be a set of trees .",
    "then there is a forest language @xmath732 such that @xmath5 consists of all the trees in @xmath282 if and only if the tree reduction of the syntactic morphism @xmath147 of @xmath5 belongs to @xmath731    let @xmath5 be a tree language , @xmath147 be its syntactic morphism and let @xmath733 be its tree reduction .",
    "assume first that there is a forest language @xmath282 such that @xmath5 consists of all the trees in @xmath282 .",
    "let @xmath734 be the syntactic morphism of @xmath282 . by definition ,",
    "fix @xmath736 and let @xmath737 be forests such that @xmath738 .",
    "we show that @xmath739 .",
    "suppose this is not the case .",
    "then there exists a context @xmath47 such that @xmath48 and @xmath331 are both trees but @xmath740 . by definition of @xmath147",
    "this means that there exists a context @xmath52 such that @xmath741 but @xmath742 .",
    "from @xmath741 we know that @xmath743 is a tree , hence , as @xmath331 is a tree , @xmath744 must also be a tree . by hypothesis",
    "this implies @xmath745 but @xmath746 , contradicting @xmath747 .",
    "since @xmath748 acts faithfully on @xmath749 it follows that for any contexts @xmath47 and @xmath719 @xmath750 implies @xmath751 thus @xmath752 for some morphism @xmath753 sending @xmath754 to @xmath755 . by hypothesis on @xmath726",
    "this implies that @xmath756 .",
    "conversely , suppose that @xmath757 belongs to @xmath726 .",
    "let @xmath758 and set @xmath759 . from the hypothesis it follows that @xmath760 .",
    "assume that @xmath45 is a tree such that @xmath761 . by definition of @xmath134",
    ", there is a tree @xmath678 such that @xmath739 .",
    "but as @xmath757 is the tree reduction of @xmath147 , we have @xmath739 implies @xmath762 and therefore @xmath690 .",
    "hence @xmath5 is the set of trees of @xmath282 .    as a result",
    "we have :    it is decidable if a regular tree language is tree ( commutative ) ( cca-)piecewise testable .",
    "we only give the proof for the piecewise testable case .",
    "the other cases are handled similarly .",
    "let @xmath724 be the family of piecewise testable forest languages over @xmath16 , and let @xmath726 be the family of morphisms from @xmath132 onto finite forest algebras that satisfy the identities of theorem  [ thm : main ] .",
    "notice that from proposition  [ prop : other - eq ] it follows that if @xmath763 then @xmath764 for all onto morphism @xmath295 .",
    "hence @xmath724 and @xmath726 satisfy the hypothesis of theorem  [ thm : forests - to - trees ] .",
    "consequently , a regular tree language @xmath5 is tree piecewise testable if and only if the tree reduction of @xmath147 belongs to @xmath731 it remains to show that we can effectively compute the image of the tree reduction given @xmath147 .",
    "consider @xmath765 and notice that all the forests in @xmath766 agree on @xmath757 .",
    "hence the procedure amounts to deciding which pairs of elements of the syntactic forest algebra are identified under the reduction , which we can do as long as we know which elements are images under @xmath147 of trees .",
    "it is easy to see that if an element of @xmath632 is the image of a tree , then it is the image of a tree of depth at most @xmath231 in which each node has at most @xmath767 children , so we can effectively decide this as well",
    ".      we could also consider other natural predicates over forests .",
    "recall for instance the definition of _ horizontal - order _ with @xmath768 expresses the fact that @xmath33 is a sibling of @xmath34 occurring strictly before @xmath34 in the forest - order .",
    "correspondingly we say that @xmath21 is a horizontal - piece of @xmath45 , denoted @xmath769 , if there is an injective mapping from nodes of @xmath21 to nodes of @xmath45 that preserve the horizontal - order and the ancestor relationship .",
    "an equivalent definition is that the piece relation is the reflexive transitive closure of the relation @xmath770 from this notion of horizontal - piece we derive the notion of horizontal - piecewise testability as expected and the very same proofs as in section  [ section - descendant ] yield :    a forest language is horizontal - piecewise testable iff it is definable by a boolean combination of @xmath771 formulas .    a forest language is horizontal - piecewise testable if and only if its syntactic algebra satisfies the identity @xmath772 for all @xmath228 such that @xmath773    this implies decidability of horizontal - piecewise testability and it would be interesting to see what would be the corresponding equivalent set of identities that does not make use of @xmath774 , in the spirit of proposition  [ prop : other - eq ]",
    ".    a straightforward adaptation of section  [ section - cca ] would also give a decidable characterization of definability by a boolean combination of @xmath775 .",
    "simon s theorem on @xmath1-trivial monoids has emerged as one of the fundamental results in the algebraic theory of automata on words .",
    "the principal contribution of the present paper has been to show that the use of forest algebras leads to a natural generalization of this theorem to trees and forests . in proving this generalization",
    "we have introduced a number of new techniques that we believe will prove useful in the continuing development of the algebraic theory of tree automata .",
    "let us briefly indicate a few directions for further research .",
    "there is a purely algebraic formulation of simon s theorem , stating that every finite @xmath1-trivial monoid @xmath8 is the quotient of a finite monoid @xmath387 that admits a partial order compatible with the multiplication in @xmath387 and in which the identity is the maximum element .",
    "our new results have a similar formulation : every finite forest algebra satisfying the identities of section 4 is the quotient of an algebra that admits compatible partial orders on both its horizontal and vertical components .",
    "in fact , straubing and thrien  @xcite have proved this order property of finite @xmath1-trivial monoids directly , yielding a quite different proof of simon s theorem .",
    "it would be interesting to know whether such an argument is also possible for forest algebras .",
    "in the word case , the boolean combinations of @xmath0-definable languages form the first level of hierarchy whose union is the first - order definable languages .",
    "little is known about the higher levels of this hierarchy , apart from the fact that it is strict .",
    "indeed , the problem of effectively characterizing the languages definable by boolean combinations of @xmath776-sentences has been open for many years .",
    "in contrast , the first - order definable languages themselves constitute one of the first classes for which an effective algebraic characterization was given : these are exactly the languages whose syntactic monoids are aperiodic .",
    "( mcnaughton and papert  @xcite . ) the corresponding problem for trees and forests , however , remains open : we possess non - effective algebraic characterizations for the forest languages definable by first - order sentences over the ancestor relation , and for the related subclasses ctl and ctl * ( see bojaczyk , _ et .",
    "@xcite ) , but the problem of finding effective tests for membership of a language in any of these classes remains one of the greatest challenges in this work .",
    "h.  comon , m.  dauchet , r.  gilleron , f.  jacquemard , d.  lugiez , c.  l \" oding , s.  tison , and m.  tommasi .",
    "tree automata techniques and applications .",
    "available on : http://tata.gforge.inria.fr/. release 12 october 2007 ."
  ],
  "abstract_text": [
    "<S> this paper presents a decidable characterization of tree languages that can be defined by a boolean combination of @xmath0 sentences . </S>",
    "<S> this is a tree extension of the simon theorem , which says that a string language can be defined by a boolean combination of @xmath0 sentences if and only if its syntactic monoid is @xmath1-trivial . </S>"
  ]
}