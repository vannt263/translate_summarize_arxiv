{
  "article_text": [
    "in recent years , embedded systems ( es ) , cyber - physical systems ( cps ) and internet - of - things ( iot ) devices , have percolated into many aspects of daily life , such as : households , offices , buildings , factories and vehicles .",
    "this trend of  smart - ification \" of everything that was previously analog ( or at least not connected ) brings many obvious benefits .",
    "however , it also expands the attack surface and turns these newly computerized gadgets into natural and attractive targets .",
    "remote attestation ( ra ) is the process whereby a trusted entity called  verifier \" securely probes internal state of a remote and untrusted hardware platform , called `` prover . ''",
    "ra can be used to establish a static or dynamic root of trust in es , cps and iot devices .",
    "also , ra can be used as a foundation for constructing more specialized security services , e.g. , software updates , verifiable deletion and memory resetting .",
    "there are three main classes of ra designs : _ hardware - based _ , _ software - based _ , and _ hybrid _ ( blending hardware and software ) .",
    "each class has its own advantages and limitations .",
    "this paper introduces _ the first _ hybrid ra design  called   based upon formally verified components to provide memory isolation and protection guarantees .",
    "our main rationale is that designing ra techniques based upon such components increases confidence in security of such designs and their implementations . of course",
    ", ideally , one would formally prove security of the entirety of an ra system , as opposed to proving security separately for each component and then proving that its composition is secure .",
    "however , we believe that this is not yet possible given the state - of - the - art in ( automated ) formal verification and synthesis of hardware and software .",
    "one recent prominent example illustrating difficulty of correctly designing and implementing security primitives ( especially , those blending software and hardware ) is the trustzone - based qualcomm secure execution environment ( qsee ) kernel vulnerability and exploit reported in cve-2015 - 6639 @xcite .",
    "arm trustzone @xcite is a popular system - on - chip ( soc ) and a cpu system - wide approach to security , it is adopted in billions of processors on various platforms .",
    "cve-2015 - 6639 enables privilege escalation and allows execution of code in the trustzone kernel which can then be used to achieve undesired outcomes and expose keying material .",
    "this vulnerability was used to break android s full disk encryption ( fde ) scheme by recovering the master keys @xcite .",
    "our intention with this example is to demonstrate difficulty of getting both the design and the implementation right , as well as a motivation to use formally verified building blocks , which ( we hope ) will yield more secure ra techniques . to this end",
    ", our ra design uses the formally verified  microkernel to obtain memory isolation and access control .",
    "such features have been previously attained with hardware in designs such as @xcite and @xcite .",
    "using  requires fewer hardware modifications to the underlying microprocessor and provides an automated formal proof of isolation guarantees of the implementation of the microkernel .",
    "_ to the best of our knowledge , this is the first attempt to design and implement ra using a formally verified microkernel . _",
    "the main goal of this paper is to investigate a previously unexplored segment of the design space of hybrid ra schemes , specifically , techniques that incorporate formally verified and proven ( using automated methods ) components , such as the  microkernel . beyond using  in our design",
    ", our implementation is also based on the formally verified executable of ; that executable is guaranteed to adhere to the formally verified and proven design .",
    "another important goal , motivation and feature of our design is the expanded scope of efficient hybrid ra techniques .",
    "while applicability of prominent prior results ( particularly , smart  @xcite and trustlite  @xcite ) is limited to very simple single - process low - end devices , we target more capable devices that can run multiple processes and threads .",
    "we believe that this paper represents an important and necessary step towards building efficient hybrid ra techniques upon solid and verified foundations .",
    "admittedly , we do not verify our entire design and prove its security using formal methods .",
    "however , we achieve the next best thing by taking advantage of already - verified components and carefully arguing security of the overall design , considering results on systematic analysis of features required for securely realizing hybrid ra @xcite . to achieve our goals",
    "we make two main contributions : ( 1 ) design of    the first hybrid ra technique based on the formally verified  microkernel which provides memory isolation and access control guarantees , ( 2 ) implementations of   on two commercially available development boards ( sabre lite and odroid - xu4 ) and their extensive analysis via experiments to demonstrate practicality of the proposed design .",
    "we show that  can attest @xmath0 mb of memory in less than @xmath1ms when using speck  @xcite as the underlying block - cipher to compute a cryptographic checksum over the memory to be attested .",
    "_ * organization * _ : section [ related - work ] overviews related work , followed by section [ goals - assumptions ] which presents our goals and assumptions .",
    "the design of  is presented in section [ designs ] and its security analysis in section [ security ] .",
    "implementation issues and performance assessment are discussed in sections [ impl ] and [ evaluation ] .",
    "prior work in remote attestation ( ra ) can be divided into three approaches : hardware - based , software - based , and hybrid .    [ [ hardware - based - remote - attestation ] ] hardware - based remote attestation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the hardware - based approach typically relies on the security provided by a trusted platform module ( tpm ) @xcite . a tpm is a secure co - processor designed to protect cryptographic keys , and utilize them to encrypt or digitally sign data .",
    "a tpm can also produce a summary ( e.g. , hash ) of hardware and software configurations in the system .",
    "a typical tpm also contains platform configuration registers ( pcr ) that can be used as a secure storage of such a configuration summary .",
    "the values in pcrs can then be used as an evidence of attestation by accumulating an unforgeable chain of values of the system s state since the last reset .",
    "a tpm eventually signs these values with an attestation key along with a random challenge , provided by a verifier , and submits the computed result to the verifier .",
    "gasmi et al .",
    "@xcite presents how to link this evidence to secure channel end - points .",
    "[ [ software - based - remote - attestation ] ] software - based remote attestation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    despite resisting all but physical attacks , the hardware - based approach is not suitable for embedded devices due to its additional software complexity and expense . therefore , many software - only ra approaches have been proposed , specifically for embedded devices .",
    "pioneer @xcite is among the first to study ra without relying on any secure co - processor or cpu - architecture extensions .",
    "the main idea behind pioneer is to create a special checksum function with run - time side - effects ( e.g. , status registers ) for attestation",
    ". any malicious emulation of said checksum function can be detected through additional timing overhead incurred from the absence of those side - effects .",
    "security of this approach became questionable after several attacks on such schemes ( i.e. , @xcite ) were demonstrated .",
    "[ [ hybrid - remote - attestation ] ] hybrid remote attestation + + + + + + + + + + + + + + + + + + + + + + + + +    the main shortcoming of the software - based approach is that it makes strong assumptions about adversarial capabilities , which may be unsatisfied in practical networked settings @xcite .",
    "thus , several hybrid software - hardware co - designs have been proposed to overcome this limitation .",
    "smart @xcite presents a hybrid approach for ra with minimal hardware modifications to existing mcus .",
    "in addition to having uninterruptable attestation code and attestation keys resided in rom , this architecture utilizes a hard - wired memory protection unit ( mpu ) to restrict access to secret keys to only smart code .",
    "the attestation is performed inside rom - resident attestation code by computing a cryptographic checksum over a memory region and returning the value to the verifier .",
    "trustlite @xcite extends @xcite to enable ra while supporting an interrupt handling in a secure place .",
    "in addition to the above work designing ra schemes , @xcite provides a systematic treatment of ra by presenting a precise definition of the desired service and proceeding to its systematic deconstruction into necessary and sufficient ( security ) properties .",
    "these properties are then mapped into a minimal collection of hardware and software components that results in secure ra .",
    "we build on the analysis in @xcite and utilize these properties and components ( which are described in section [ goals - assumptions ] ) and show how to instantiate them in new ways to develop our new hybrid ra design , .",
    "this section presents an overview of  and the rationale behind its design , discusses the common remote attestation ( ra ) security objective and features , and the adversary model .      our main objective is to explore a new segment of the design space for ra schemes .",
    "our hybrid ra design    requires very little in terms of secure hardware and builds upon the formally verified  microkernel .",
    "as shown in section [ impl ] , hardware support needed by  is readily available on commercial off - the - shelf development boards and processors , e.g. , sabre lite and odroid - xu4 boards .",
    "the rationale behind our design is that  offers certain guarantees ( mainly process isolation and access control to memory and resources ) that provide ra features that were previously feasible only using hardware components . in particular , what was earlier attained using additional mcu controls and read - only memory ( rom ) in the smart  @xcite and trustlite  @xcite architectures can now be instantiated using capability controls in .    to motivate and justify the design of",
    ", we start from the work by francillon , et al .",
    "@xcite . it provides a systematic treatment of ra by developing a semi - formal definition of ra as a distinct security service , and systematically deconstructing it into a necessary and sufficient security objective , from which specific properties are derived .",
    "these properties are then mapped into a collection of hardware and software components that results in an overall secure ra design .",
    "below , we summarize the security objective in ra and its derived security properties . in sections [ designs ] and [ impl ]",
    "we show how the security objective and each property are satisfied in  design and instantiated in two concrete prototypes based on the sabre lite and odroid - xu4 boards .      according to @xcite ,",
    "the ra security objective is to allow a ( remote ) prover ( @xmath2 ) to create an unforgeable authentication token , that convinces a verifier ( @xmath3 ) that the former is in some well - defined ( expected ) state .",
    "whereas , if @xmath2 has been compromised and its state has been modified , the authentication token must reflect this .",
    "@xcite also describes a combination of platform properties that achieve aforementioned security objective .",
    "the goal of the analysis in @xcite is to obtain a set of properties that are both necessary and sufficient for secure ra .",
    "the security objective is examined and the properties needed to attain it are identified .",
    "the conclusion is that the following properties collectively represent the minimal and necessary set to achieve secure ra on any platform .",
    "* _ exclusive access to attestation key ( @xmath4 ) : _ the attestation process ( ) must be the only one with access to @xmath4 .",
    "this is the most difficult property to impose on embedded ( especially , low - end and mid - range ) devices .",
    "as argued in @xcite , this property is unachievable without some hardware support on low - end devices .",
    "if the underlying processor supports multiple privilege modes and a full - blown separation of memory for each process , one could use a privileged process to handle all computations that involve the key .",
    "however , low - end and medium - end processors generally do not offer such `` luxury '' features . * _ no leaks : _ no information related to ( or derived from ) @xmath4  must be accessible after the execution of  completes . to achieve this , all intermediate values that depend on the key  except the final attestation token to be returned to @xmath3  must be securely erased , when they are no longer needed .",
    "this is again applicable to very low - end devices , with none or minimal operating system ( os ) support and assuming that memory is shared between processes .",
    "however , if the underlying hardware and/or software ( i.e. , os ) guarantees that each process memory is inaccessible by any other process , then this property is trivially satisfied . *",
    "_ immutability : _ to ensure that the attestation executable ( ) can not be modified , smart @xcite and the design in @xcite place it in rom , which is available on most , even low - end , platforms .",
    "rom is certainly one relatively inexpensive way to enforce s code immutability . however , owing to s features ,  in  is resident in , and executed from , ram . *",
    "_ uninterruptability : _ execution of  must be uninterruptible .",
    "this is necessary to ensure that malware does not obtain the key ( or some function thereof ) by interrupting  while any key - related values remain in registers or other accessible locations . as discussed later ,  achieves this property by assuring that it runs with the highest possible priority under . *",
    "_ controlled invocation ( aka atomicity ) : _  must only be invocable from its first instruction and must exit only at one of its legitimate last ( exit ) instruction .",
    "this is motivated by the need to prevent code - reuse attacks .",
    "@xcite has one additional property of _ secure reset _ when someone attempts to start the attestation executable ( ) from the middle .",
    "we argue that a complete secure reset is not needed if controlled invocation is enforced .",
    "all that is needed in that case is to raise an exception as long as the memory space of  is protected and integrity of executable is guaranteed .",
    "based on the recent taxonomy in @xcite , adversaries in the ra context can be categorized as follows :    * _ remote adversaries : _ exploit vulnerabilities in a prover s software to inject ( over the network ) malware onto it . *",
    "_ local adversaries : _ locate sufficiently near in order to eavesdrop on , and manipulate , the prover s communication channel(s ) . * _ physical adversaries : _ have full ( local ) physical access to the prover and its hardware and can perform physical attacks , e.g. , side - channel attacks to obtain keys , physically extract memory values , and modify the states of various hardware components .",
    "similar to prior hybrid ra designs ,  aims to protect against remote and local adversaries , while physical adversaries are out - of - scope .",
    "we note that , at least in a single - prover setting , protection against physical attacks can be attained by encasing the cpu in tamper - resistant coating and employing standard techniques to prevent side - channel key leakage .",
    "these include : anomaly detection , internal power regulators and additional metal layers for tamper detection .",
    "we consider @xmath2 to be a ( possibly ) unattended remote hardware platform running multiple processes on top of .",
    "once @xmath2 boots up and runs in steady state , the adversary ( @xmath5 ) might exercise complete control over all application software ( including code and data ) before and after execution of . as physical attacks",
    "are out of scope , @xmath5 can not induce hardware faults or retrieve a stored @xmath4  using side channels .",
    "@xmath5 also has no means of interrupting execution of  or the  code when invoked ( how this is ensured will be demonstrated later ) . finally , recall that @xmath2 and @xmath3 must share at least one secret ( attestation ) key @xmath6 .",
    "this key can be pre - loaded onto @xmath2 at installation time ; it is stored as part of  binaries .",
    "we do not address the details of this procedure .",
    "we first overview  and discuss how it can be used in   to realize previously identified ra properties .",
    "we then describe the sequence of operations in .",
    "is a member of the l4 microkernel family , specifically designed for high - assurance applications by providing isolation and memory protection between different processes .",
    "these properties are mathematically guaranteed by a full - code level functional correctness proof , using automated tools",
    ". a further correctness proof of the c code translation is presented in @xcite , thus extending functional correctness properties to the binary level without needing a trusted compiler .",
    "therefore , behavior of the  binary strictly adheres to , and is fully captured by , the abstract specifications .",
    "similar to other operating systems ,  divides the virtual memory into two separated address spaces : _ kernel - space _ and _ user - space_. the kernel - space is reserved for the execution of the  microkernel while the application software is run in user - space . by design , and adhering to the nature of microkernels ,",
    "the  microkernel provides minimal functionalities to user - space applications : thread , inter - process communication ( ipc ) , virtual memory , capability - based access control and interrupt control .",
    "the  microkernel leaves the implementations of other traditional operating system functions  such as device drivers and file systems  to user - space .",
    "figure [ sel4-example ] ( borrowed from @xcite ) shows an example of  instantiation with two threads  sender a and receiver b  that communicate via an _ endpoint _ ep . each thread has a _ thread control block _",
    "( tcb ) that stores its context , including : stack pointer , program counter , register values , as well as pointers to _ virtual - address space _ ( vspace ) and _ capability space _",
    "( cspace ) .",
    "vspace represents available memory regions that the  microkernel allocated to each thread .",
    "the root of vspace represents a _ page directory _ ( pd ) , which contains _ page table _",
    "( pt ) objects .",
    "_ frame _ object representing a region of physical memory resides in a pt .",
    "each thread also has its own kernel managed cspace used to store a _",
    "capability node _ ( cnode ) and _ capabilities_. cnode is a table of slots , where each slot represents either a capability or another cnode .",
    "a capability is an unforgeable token representing an access control authorization of each kernel object or component .",
    "a thread can not directly access or modify a capability since cspace is managed by , and stored inside , the kernel .",
    "instead , a thread can invoke an operation on a kernel object by providing a pointer to a capability that has sufficient authority for that object to the kernel .",
    "for example , sender a in figure [ sel4-example ] needs a write capability of ep for sending a message , while receiver b needs a read capability to receive a message .",
    "besides read and write , _ grant _ is another access right in , available only for an endpoint object .",
    "given possession of a grant capability for an endpoint , any capability from the possessor can be transferred across that endpoint .",
    "for instance , if a in figure [ sel4-example ] has grant access to ep , it can issue one of its capabilities , say a frame , to b via ep . also , capabilities can be statically issued during a thread s initialization by the _",
    "initial process_. the initial process is the first executable user - space process loaded into working memory ( i.e. , ram ) after the   microkernel is loaded .",
    "this special process then forks all other processes .",
    "section [ subsec : sop ] describes the role , the details and the capabilities of the initial process in  design .",
    "s main  claim to fame \" is in being the first formally verified general - purpose operating system .",
    "formal verification of the  microkernel is performed by interactive , machine - assisted and machine - checked proof using a theorem prover isabelle / hol .",
    "overall functional correctness is obtained through a _ refinement",
    "_ proof technique , which demonstrates that the binary of   refines an abstract specification through three layers of refinement .",
    "consequently ( under some reasonable assumptions listed in appendix [ appdx : sel4_assump ] ) the  binary is fully captured by the abstract specifications . in particular ,",
    "two important feature derived from s abstract specifications , are that : * the kernel never crashes*. another one is that : * every kernel api call always terminates and returns to user - space*. comprehensive details of s formal verification can be found in @xcite .",
    "another  feature very relevant to our work is : * correctness of access control enforcement * derived from functional correctness proof of . @xcite and @xcite introduce formal definitions of the access control model and information flow in  at the abstract specifications .",
    "they demonstrate the refinement proof from these modified abstract specifications to the c implementation using isabelle / hol theorem prover , which is later linked to the binary level ( by the same theorem prover ) . as a result ,",
    "three properties are guaranteed by the access control enforcement proof : ( 1 ) _ authority confinement _ , ( 2 ) _ integrity _ and ( 3 ) _",
    "confidentiality_. authority confinement means that authority propagates correctly with respect to its capability . for example , a thread with a read - only capability for an object can only read , and not write to , that object .",
    "integrity implies that system state can not be modified without explicit authorization .",
    "for instance , a read capability should not modify internal system state , while write capability should only modify an object associated with that capability .",
    "finally , confidentiality means that an object can not be read or inferred without a read capability .",
    "thus , the proof indicates that access control in , once specified at the binary level , is correctly enforced as long as the  kernel is active .",
    "we now show how s access control enforcement property satisfies required ra features .",
    "lccc    [ 3]*security property & [ 3]*smart @xcite & [ 3]*trustlite @xcite & [ 3 ] * +   + exclusive access to @xmath4 & hw ( mod . data bus ) & sw ( programmed mpu ) & sw ( ) +   + no leaks & sw ( cqual and deputy ) & hw ( cpu exception engine ) & sw ( ) +   + immutability & hw ( rom ) & hw ( rom ) and sw ( programmed mpu ) & hw ( rom ) and sw ( ) +   + uninterruptability & sw ( interrupt disabled ) & hw ( cpu exception engine ) & sw ( ) +   + controlled invocation & hw ( rom ) & hw ( rom ) & sw ( ) +      we now describe access control configuration of  user - space that achieves most required properties for secure ra , as described in section [ goals - assumptions ] .",
    "we examine each feature and identify the corresponding access control configuration . unlike previous hybrid designs ,  pushes almost all of these required features into software , as long as the  microkernel boots correctly .",
    "( a comparison with smart and trustlite is in table [ table : features ] . )    [ [ exclusive - access - to - mathcal - k ] ] exclusive access to @xmath4 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    directly translated to an access control configuration .",
    "similar to previous hybrid approaches , @xmath4  can be hard - coded into the  at production time .",
    "thus ,  needs to be configured to be accessible only to .",
    "[ [ no - leaks ] ] no leaks + + + + + + + +    achieved by the separation of virtual address space .",
    "specifically , the virtual memory used for @xmath4-related computation needs to be configured to be accessible to only .    [ [ immutability ] ] immutability + + + + + + + + + + + +    achieved using combination of verifiable boot and runtime isolation guarantee from . at runtime ,  must be immutable , which can be guaranteed by restricting the access control to the executable to only .",
    "however , this is not enough to assure immutability of  executable because  can be modified after loaded into ram but before executed .",
    "hence , a verifiable boot of is required .",
    "[ [ uninterruptability ] ] uninterruptability + + + + + + + + + + + + + + + + + +    satisfied by setting the scheduling priority of  higher than other processes since the formal proof of  scheduling mechanism guarantees that a lower priority process can not preempt the execution of a higher priority process .",
    "in addition ,  guarantees that , once set , the scheduling priority in  can not be increased at runtime ( but possible to decrease the priority value ) .",
    "note that this feature implies  needs to be the initial user - space process since the  microkernel always assigns the highest priority to the initial process .",
    "[ [ controlled - invocation ] ] controlled invocation + + + + + + + + + + + + + + + + + + + + +    achieved by the isolation of process execution . in particular , tcb of",
    "can not be accessed or manipulated by other processes .    with these features , we conclude that the access control configuration of  user - space needs to ( at least ) include the following :    *  has exclusive access to ; this also includes @xmath4  residing in .",
    "( recall that  is the attestation * process * , while  is the executable that actually performs attestation . )",
    "*  has exclusive access to its tcb .",
    "*  has exclusive access to its vspace .",
    "even though this access control configuration can be enforced at the binary code level , this assumption is based on that  is loaded into ram correctly .",
    "however , this can be exploited by an adversary by tricking the boot - loader to boot his malicious  microkernel instead of the formally verified version and insert a new configuration violating above access controls .",
    "thus , the hardware signature check of the microkernel code is required at boot time .",
    "the similar argument can also be made for  code . as a result",
    ", additional integrity check of  code needs to be performed by  before executing .      in order to achieve all security properties described above ,  requires the following four components .    [ [ read - only - memory ] ] read - only memory + + + + + + + + + + + + + + + +    region primarily storing immutable data ( e.g. hash of public keys or signature of software ) required for secure boot of the  microkernel .",
    "[ [ mcu - access - control - emulation ] ] mcu access control emulation + + + + + + + + + + + + + + + + + + + + + + + + + + + +    high - assurance software framework capable of emulating mcu access controls to attestation key @xmath4 . at present ,  is the only formally verified and mathematically proven microkernel capable of this task .",
    "[ [ attestation - algorithm ] ] attestation algorithm + + + + + + + + + + + + + + + + + + + + +    software residing in  and serving two main purposes : authenticating an attestation request , and performing attestation on memory regions .",
    "[ [ real - time - clock ] ] real - time clock + + + + + + + + + + + + + + +    loosely synchronized ( with @xmath7 ) real - time clock for detecting replayed , reordered and delayed requests . if @xmath8  does not have a clock , a secure counter can replace a real - time clock with a sacrifice of the delayed message detection .          the sequence of operations in , shown in figure [ sop ] , has three steps : boot , setup , and attestation .",
    "[ [ step-1-boot - process ] ] step 1 : boot process + + + + + + + + + + + + + + + + + + + +    upon a boot , @xmath8  first executes a rom - resident boot - loader .",
    "the boot - loader verifies authenticity and integrity of the  microkernel binary . assuming this verification succeeds , the boot - loader loads all executables , including kernel and user - space , into ram and hands over control to the  microkernel .",
    "further details of secure boot in our prototype can be found in section [ impl ] .",
    "[ [ step-2-setup ] ] step 2 :  setup + + + + + + + + + + + + + +    the first task in this step is to have the  microkernel setting up the user - space and then starting  as the initial user - space process .",
    "once the initialization inside the kernel is over , the  microkernel gathers capabilities for all available memory - mapped locations and assigns them to .",
    "the  kernel also performs an authenticity and integrity check of  to make sure that it has not been modified . after successful authentication , the  microkernel passes control to",
    ".    with full control over the system ,  starts the rest of user - space with a lower scheduling priority and distributes capabilities that do not violate the configuration specified earlier . after completing configuration of memory capabilities and starting the rest of the user - space ,  initializes the network interface and waits for an attestation request .",
    "[ [ step-3-attestation ] ] step 3 : attestation + + + + + + + + + + + + + + + + + + +    an attestation request , sent by a verifier , consists of 4 parameters : ( 1 ) @xmath9 reflecting @xmath8 s time when the request was generated , ( 2 ) target process @xmath10 , ( 3 ) its memory range @xmath11 $ ] that needs to be attested , and ( 4 ) cryptographic checksum @xmath12 of the entire attestation request .    similar to smart  @xcite , the cryptographic checksum function used in attestation is implemented as a message authentication code ( mac ) , to ensure authenticity and integrity of attestation protocol messages .    upon receiving an attestation request  checks whether @xmath9 is within an acceptable range of the @xmath8 s real - time clock before performing any cryptographic operation ; this is in order to mitigate potential dos attacks .",
    "if @xmath9 is not fresh ,  ignores the request and returns to the waiting state . otherwise , it verifies @xmath12 .",
    "if this fails ,  also abandons the request and returns to the waiting state .",
    "once the attestation request is authenticated ,  computes a cryptographic checksum of the memory region [ @xmath13 , @xmath14 of process @xmath10 .",
    "finally ,  returns the output to @xmath7 .",
    "the pseudo - code of this process is shown in algorithm [ alg : mod_smart ] .",
    "to demonstrate feasibility and assess practicality of , we implement two prototypes of it on two commercially available hardware platforms : odroid - xu4 @xcite and sabre lite @xcite .",
    "we focus here more on the sabre lite implementation due to the lack of an  compatible networking ( e.g. , ethernet ) driver and a programmable rom in current odroid - xu4 boards .",
    "section [ evaluation ] presents a detailed performance evaluation of the  implementation .",
    "our prototype is implemented on top of version 1.3 of the  microkernel  @xcite .",
    "the complete implementation , including helper libraries and the networking stack , consists of @xmath15 lines of c code ( see table [ loc - table ] for a more detailed breakdown ) .",
    "the overall size of executable is @xmath16 kb whereas the base  microkernel size is @xmath17 kb .",
    "excluding all helper libraries , the implementation of  is just @xmath18 lines of c code . in the user - space , we base our c code on following libraries : sel4utils , sel4vka and sel4vspace ; these libraries provide the abstraction of processes , memory management and virtual space respectively . in our prototypes ,",
    "is the initial process in the user - space and receives capabilities to all memory locations not used by .",
    "other processes in user - space are spawned by this .",
    "we also ensure that access control of those processes does not conflict with what we specified in section [ designs ] .",
    "the details of this access control implementation are described below in this section .",
    "the basic c function calls are implemented in muslc library .",
    "sel4bench library is used to evaluate timing and performance of our  implementation . for a timer driver ,",
    "we rely on its implementation in sel4platsupport .",
    "all source code for these helper libraries can be found in @xcite and these libraries contribute around @xmath19% of the code base in our implementation .",
    "we use an open - source implementation of a network stack and an ethernet driver in the user - space @xcite .",
    "we argue that this component , even though not formally verified , should not affect security objective of  as long as an io - mmu is used to restrict direct memory access ( dma ) of an ethernet driver .",
    "the worst case that can happen from not formally verified network stack is symmetrical denial - of - service , which is out of scope of .          here",
    ", we describe how we integrate an existing secure boot feature ( in sabre lite ) with our  implementation .",
    "[ [ secure - boot - in - sabre - lite ] ] secure boot in sabre lite + + + + + + + + + + + + + + + + + + + + + + + + +    nxp provides a secure boot feature for sabre lite boards , called high assurance boot ( hab ) @xcite .",
    "hab is implemented based on a digital signature scheme with public- and private - keys . a private - key",
    "is required to generate a signature of the software image during manufacturing whereas a public - key is used by rom apis for decrypting and verifying the software signature at boot time . a public - key and a signature",
    "are attached to the end of software image , which is pre - installed into a flash medium during manufacturing .",
    "the digest of a public - key is fused into a one - time programmable rom in order to ensure the authenticity of the public - key and the booting software image . at boot time , the rom boot - loader first loads the software image into ram and then verifies an attached public - key by comparing it with the reference hash value in rom .",
    "it then authenticates the software image through the attached signature and the verified public - key .",
    "execution of this image is allowed only if signature verification succeeds . without a private - key",
    ", an adversary can not forge a legitimate digital signature and thus is unable to insert and boot his malicious image .",
    "[ [ secure - boot - of ] ] secure boot of + + + + + + + + + + + + + + +    hab can be utilized to ensure that the  microkernel is the first program initialized after the rom boot - loader .",
    "therefore , the entire  microkernel binary code can be covered when computing the digital signature by hab during manufacturing .",
    "moreover , the  microkernel needs to be assured that it gives control of the user - space to the verified .",
    "thus , the microkernel has to perform an integrity check of   before launching it . as a result",
    ", a hash of   needs to be included in the  microkernel s binaries during production time and be validated upon starting the initial process .    with this procedure",
    ", a chain of trust is established in the remote attestation system in .",
    "this implies that no other programs , except the   microkernel can be started by the rom boot - loader and consequently only  is the certified initial process in the user - space , which achieve the goal of secure boot of remote attestation system .",
    "figure [ sb - seq ] illustrates the secure boot of  in sabre lite prototype .",
    "here we describe how the access control configuration specified in section [ designs ] is implemented in our  prototype .",
    "our goal is to show that in the implementation of  no other user - space processes , except , can have any kind of access to : ( 1 ) the binary executable code ( including @xmath4 ) , ( 2 ) the virtual address space of , and ( 3 ) the tcb of . to provide those access restrictions in the user - space ,",
    "we make sure that we do not assign capabilities associated to those memory regions to other user - space processes .",
    "recall that  as the initial process contains all capabilities to every memory location not used by the  microkernel . and there are two ways for  to issue capabilities : dynamically transfer via endpoint with grant access right or statically assign during bootstrapping a new process .    in our implementation",
    ",  does not create any endpoint with grant access , which disallows any capability of  to transfer to a new process after created .",
    "thus , the only way that capabilities can be assigned to a new process is before that process is spawned .",
    "when creating a new process ,  assigns only minimal amount of capabilities required to operate that process , e.g. in our prototype , only the cspace root node and fault endpoint ( used for receiving ipcs when this thread faults ) capabilities are assigned to any newly created process .",
    "limited to only those capabilities , any other process can not access the binary executable code as well as existing virtual memory and tcb of .    moreover , during bootstrapping the new process ,   creates a new pd object serving as the root of vspace in the new process .",
    "this is to ensure that any new process virtual address space is initially empty and does not overlap with the existing virtual memory of . without any further dynamic capability distribution , this guarantees that other processes can not access any memory page being used by .",
    "sample code for configuring a new process in our prototype is provided in appendix [ appdx : new_process_code ] .",
    "traditionally , in previous hybrid designs , a prover device requires a special hardware - controlled memory location for securely storing @xmath6 and protecting it from software attacks .",
    "however , in , it is possible to store @xmath6 in a normal memory location ( e.g. flash ) due to the formally verified access control and isolation properties of .",
    "moreover , since @xmath6 is stored in a writable memory , its update can easily happen without any secure hardware involvement .",
    "thus , in our prototypes , @xmath6 is hard - coded at production time and stored in the same region as .",
    "besides @xmath6 ,  contains another key , @xmath20 , used for verifying an authenticity of an attestation request .",
    "@xmath20 can be a separate key and pre - stored next to @xmath4  during a production time ; or , @xmath20 can be derived from @xmath6 through a key derivation function ( kdf ) at runtime as well .",
    "recall ( section [ designs ] ) that a timestamp generated by a loosely synchronous real - time clock is required for ensuring freshness of attestation requests .",
    "there is currently no implementation of drivers for real - time clock in .",
    "we generate a pseudo - timestamp by a counter , whose driver is provided by sel4platsupport , and a timestamp of the first validated request , as follows : when a device first wakes up and securely start .",
    "promptly loads a timestamp , @xmath21 , that was previously saved in a separated location of flash medium before the last reset .",
    "when the first attestation request arrives ,  checks its attached timestamp , @xmath22 , whether it is greater than @xmath21 and proceeds to @xmath23 if that is the case .",
    "after the assurance of the validated request ,  keeps track of @xmath22 and start a counter . at any time afterwards , a timestamp can be constructed by combining the current counter value with @xmath22 .",
    "in addition ,  periodically generates and saves this timestamp value into flash medium for the next reboot s usage .",
    "0.3        0.3        0.3        0.3        0.3     in this section , we ( informally ) demonstrate how hydra satisfies the minimal set of requirements to realize secure ra ( described in section [ goals - assumptions ] ) .",
    "the following are key features ensured in the design and implementation of :    \\(1 ) the  microkernel is the first executable that is loaded in a -based system upon boot / initialization .",
    "correctness of this step is guaranteed by a rom integrity check at boot time , e.g. , hab in the sabre lite case .",
    "\\(2 ) the attestation process (  )",
    ".  is what is called  initial process \" in figure [ img_layout ] and it contains   executable as a component . ] is the first user - space process that is loaded into memory and is bootstrapped by .",
    "this is also guaranteed using a software integrity check step performed by  before spawning the initial process .",
    "\\(3 )  then starts with the highest scheduling priority and never decreases its own priority value .",
    "this can be guaranteed by ensuring the code of  does not contain any system calls to decrease its priority .",
    "\\(4 ) any other subsequent process that is loaded on top of the  microkernel is spawned by @xmath24 and does not receive the highest scheduling priority .",
    "this can be ensured by inspecting the  code and ensuring that all invocations of other processes are with a lower priority value .",
    "once a process is loaded with a certain priority ,  prevents it from increasing its priority value ; this is formally verified and guaranteed in the  implementation .",
    "\\(5 ) the software executable and @xmath4  can only be mapped into the address space of .",
    "this is guaranteed by ensuring that in the  code no other process on initialization ( performed in  ) receives the capabilities to access said memory ranges .",
    "\\(6 ) virtual memory used by  can not be used by any other process ; this includes any memory used for any computation touching the key , or related to other values computed using the key .",
    "this is formally verified and guaranteed in the  implementation .",
    "\\(7 ) other processes can not control or infer execution of  ( protected by exclusive capability to tcb s ) .",
    "\\(8 ) access control properties , i.e. , authority confinement , integrity and confidentiality , in s binary are mathematically guaranteed by its formal verification .",
    "+ given the above features , the security properties in section [ goals - assumptions ] are satisfied because :    * exclusive access to @xmath4 : * ( 5 ) , ( 6 ) and ( 8) guarantee that only  can have access to @xmath4 .    *",
    "no leaks : * ( 6 ) and ( 8) ensures that intermediate values created by key - related computation inside  can not be leaked to or learned by other processes .    * immutability : * ( 1 ) and ( 2 ) implies that  is initialized into the correct expected known initial states and that the correct binary executable is securely loaded into ram .",
    "( 5 ) also prevents other processes from modifying that executable .    * uninterruptability : * ( 3 ) and ( 4 ) guarantees that other processes , always having a lower priority value compared to , can not interrupt the execution of .    *",
    "controlled invocation : * ( 7 ) ensures that the execution of  can not be manipulated by other applications .",
    "we present here performance evaluation of  using the sabre lite prototype .",
    "( results of   on odroid - xu4 are in appendix [ appdx : odroid_perf ] ) .",
    "we conduct experiments to assess speed of , and overhead involved in , performing attestation using different types of keyed message authentication code ( mac ) functions , on various numbers of user - space processes and sizes of memory regions to be attested .",
    "we obtain the fastest performance using the speck mac ;  can attest @xmath0 mb in less than @xmath1msec in that case .",
    "[ [ breakdown - of - attestation - runtime ] ] breakdown of attestation runtime + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    recall from section [ designs ] , that the attestation algorithm ( algorithm [ alg : mod_smart ] ) is composed of three operations .",
    "@xmath23 ( lines 3 to 9 ) is responsible for verifying an attestation request and whether it has been recently generated by an authorized verifier .",
    "@xmath25 ( line 11 ) maps memory regions from a target process to s address space and returns a pointer to the mapped memory .",
    "@xmath26 ( lines 13 to 20 ) computes a cryptographic checksum ( using @xmath4 ) on the memory regions .    as shown in table [ smart - time ]",
    ", the runtime of @xmath26 contributes the highest amount of the overall  runtime :  84% of total time for attesting 1 mb of memory and  90% for attesting 10 kb of memory on sabre lite ; whereas @xmath25 and @xmath23 together require less than 20% of the overall time .",
    "[ [ performance - of - retrievemem - in ] ] performance of @xmath25 in + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    another important factor affecting the performance of  is the runtime of @xmath25 : the time  takes to map the attested memory regions to its own virtual address space .",
    "as expected , figure [ retrieve_mem ] illustrates the memory mapping runtime in  is linear in terms of mapped memory size .",
    "in addition , we compare the runtime of @xmath25 and @xmath26 on larger memory sizes .",
    "figure [ retr_mac_ratio ] illustrates that the runtime ratio of @xmath25 to various implementations of @xmath26 is always less than 20% .",
    "this confirms that retrieving memory and mapping it to the address space account for only a small fraction of the total attestation time in .",
    "this illustrates that whatever overhead  introduces when enforcing access control on memory is not significant and does not render   impractical .",
    "[ [ performance - of - macmem - in ] ] performance of @xmath26 in + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    since @xmath26 is the biggest contributor to the runtime of our implementations , we explore various types of ( keyed ) cryptographic checksums and their performance on top of .",
    "we compare the performance of five different mac functions , namely , cbc - aes @xcite , hmac - sha-256 @xcite , simon and speck @xcite , and blake2s @xcite , on 1 mb of data in the user - space of . the performance results in figure [ macfn ] illustrate that the runtime of mac based on speck-64 - 128 and blake2s in  are similar ; and they are at least 33% faster than other mac functions when running on sabre lite .    [ [ performance - of - macmem - vs - memory - sizes ] ] performance of @xmath26 vs memory sizes + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    another factor that affects @xmath26 s performance is the size of memory regions to be attested .",
    "we experiment by creating another process in the user - space and perform attestation on various sizes ( ranging from 1 mb to 10 mb ) of memory regions inside that process . as expected , the results of this experiment , illustrated in figure [ partsize ] , indicate that @xmath26 performance is linear as a function of the attested memory sizes .",
    "this experiment also illustrates feasibility of performing attestation of 10 mb of memory on top of  in  using a speck - based mac in less than half a second .",
    "[ [ performance - on - macmem - vs - numbers - of - processes ] ] performance on @xmath26 vs numbers of processes + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this experiment answers the following question : how would an increase in number of processes affect the performance of ?",
    "to answer it , we have the initial process spawn additional user - space processes ( from 2 to 20 extra processes ) and , then , perform @xmath26 on 100 kb memory data in one of those processes .",
    "to ensure fair scheduling of every process , we set priority of all processes ( including the initial process ) to the maximum priority .",
    "the result from figure [ numpart ] indicates that the performance of @xmath26 is reasonably linear as a function of the number of processes on sabre lite .",
    "this paper presents the first hybrid remote attestation design , , that leverages the formally verified  microkernel to instantiate memory and process isolation , and enforce access control to memory and other resources ; such isolation and access control have been ensured through hardware in previous designs .",
    "we implement  on two commodity hardware platforms and demonstrate feasibility and practicality of hybrid ra schemes that significantly improve security in contemporary embedded and cyber - physical systems , and that can work on commodity hardware and require no modification to it while providing security guarantees that can be assured using automated formal methods .    1",
    "cm    this material is based on research sponsored by the department of homeland security ( dhs ) science and technology directorate , cyber security division ( dhs s&t / csd ) baa hshqdc-14-r - b00016 , and the government of united kingdom of great britain and the government of canada via contract number d15pc00223 .",
    "the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements , either expressed or implied , of the department of homeland security , the u.s .",
    "government , or the government of united kingdom of great britain and the government of canada",
    "we also evaluate performance of  in odroid - xu4 @ 2.1 ghz . despite not having an ethernet driver , we evaluate the core component of : @xmath26 .",
    "unlike the results in section [ evaluation ] , blake2s - based mac achieves the fastest performance for attesting 10 mb on odroid - xu4 platform .    [",
    "[ mac - performance - in - linux - vs - in ] ] mac performance in linux vs in + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    figure [ macfn_odroid ] illustrates the performance comparison of various keyed mac functions on odroid - xu4 hardware platform when running on ubuntu 15.10 and .",
    "the result emphasizes the feasibility of ra in  since the runtime of -based ra can be as fast as that of ra running on top of widely prominent linux operating system .    [",
    "[ mac - performance - on - odroix - xu4 ] ] mac performance on odroix - xu4 + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the result in section [ evaluation ] and the one from above demonstrate that speck- and blake2s - based macs have the fastest attestation runtime in .",
    "we conduct additional experiments on those two mac functions in odroid - xu4 platform .",
    "figure [ num_part_odroid ] asserts the linear relationship between number of processes and @xmath26 runtime .",
    "in addition , the mac runtime , shown in figure [ part_size_odroid ] , is also linear in memory sizes to be attested .",
    "lastly , runtime of the blake2s - based mac function achieves less than 200 milliseconds for attesting 10 mb of memory regions in odroid - xu4",
    "s functional correctness proof is based on the following assumptions :    * * assembly * - it assumes the correctness of arm assembly code mainly for entry to and exit from the kernel and direct hardware accesses . * * hardware * - it assumes hardware operates according to its specification and has not been tampered with . * * hardware management * - it assumes the correctness of the underlying hardware management , including a translation look - aside buffer ( tlb ) and cache - flushing operations . *",
    "* boot code * - it assumes the correctness of code that boots the  microkernel into memory . * * direct memory access ( dma ) * - it assumes dma is disabled or trusted .",
    "* * side - channels * - it assumes there is no timing side - channels .",
    "in our implementation ,  creates a new empty process with the default configuration below :      int sel4utils_configure_process_custom(sel4utils_process_t * process , vka_t * vka , vspace_t * spawner_vspace , sel4utils_process_config_t config ) {      int error ;      sel4utils_alloc_data_t * data = null ;      memset(process , 0 , sizeof(sel4utils_process_t ) ) ;      sel4_capdata_t cspace_root_data = sel4_capdata_guard_new(0 , sel4_wordbits - config.one_level_cspace_size_bits ) ;            / * create a cspace and copy its cap to the new process * /      process->own_cspace = config.create_cspace ;      if ( create_cspace(vka , config.one_level_cspace_size_bits , process , cspace_root_data ) ! = 0 ) {          goto error ;      }                / * create the thread * /      error = sel4utils_configure_thread(vka , spawner_vspace , & process->vspace , sel4utils_endpoint_slot , config.priority , process->cspace.cptr , cspace_root_data , & process->thread ) ;                          sel4_capdata_t null_cap_data = { { 0 } } ;      error = sel4_tcb_configure(res->tcb.cptr , config.fault_endpoint , config.priority , config.cspace , config.cspace_root_data , vspace_get_root(alloc ) , null_cap_data , res->ipc_buffer_addr , res->ipc_buffer ) ;"
  ],
  "abstract_text": [
    "<S> remote attestation ( ra ) allows a trusted entity ( _ verifier _ ) to securely measure internal state of a remote untrusted hardware platform ( _ prover _ ) . </S>",
    "<S> ra can be used to establish a static or dynamic root of trust in embedded and cyber - physical systems . </S>",
    "<S> it can also be used as a building block for other security services and primitives , such as software updates and patches , verifiable deletion and memory resetting . </S>",
    "<S> there are three major classes of ra designs : _ hardware - based _ , _ software - based _ , and _ hybrid _ , each with its own set of benefits and drawbacks .    </S>",
    "<S> this paper presents the first hybrid ra design  called   that builds upon formally verified software components that ensure memory isolation and protection , as well as enforce access control to memory and other resources </S>",
    "<S> .  obtains these properties by using the formally verified  microkernel . </S>",
    "<S> ( until now , this was only attainable with purely hardware - based designs . ) </S>",
    "<S> using  requires fewer hardware modifications to the underlying microprocessor . building upon a formally verified software component increases confidence in security of the overall design of  and its implementation . </S>",
    "<S> we instantiate  on two commodity hardware platforms and assess the performance and overhead of performing ra on such platforms via experimentation ; we show that  can attest @xmath0 mb of memory in less than @xmath1msec when using a speck - based message authentication code ( mac ) to compute a cryptographic checksum over the memory to be attested . </S>"
  ]
}