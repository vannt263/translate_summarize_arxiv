{
  "article_text": [
    "= -1 querying inconsistent ontologies is an intriguing new problem that gives rise to a flourishing research activity in the description logic ( dl ) and existential rules community .",
    "consistent query answering , first developed for relational databases @xcite and then generalized as the ar and iar semantics for several dls @xcite , is the most widely recognized semantics for inconsistency - tolerant query answering .",
    "these two traditional semantics are based upon the notion of _ repair _ , defined as an inclusion - maximal subset of the abox consistent with the tbox .",
    "@xcite studied query answering under weight - based ar semantics for dl @xmath0 .",
    "@xcite studied variants of ar and iar semantics for dl - lite@xmath1 obtained by replacing classical repairs with various preferred repairs .",
    "existential rules ( also known as datalog@xmath2 ) are set to play a central role in the context of query answering and information extraction for the semantic web .",
    "@xcite studied the data complexity and combined complexity of ar semantics under the main decidable classes of existential rules enriched with negative constraints .",
    "= -1 however , observe that some rules might be unreliable if they are extracted from ontology learning or written by unskillful knowledge engineer @xcite .",
    "@xcite proposed a tableau - like algorithm which yields exptime as upper bound for finding maximally concept - satisfiable terminologies represented in @xmath3 .",
    "@xcite provided solutions on repairing unsatisfiable concepts in a consistent owl ontology .",
    "furthermore , usually there exist preferences between rules , and rules with negation are often considered less preferred than rules without negation .",
    "@xcite proposed that the original axioms must be preserved in the knowledge base under certain conditions and requires changing the underlying logics for repair .",
    "@xcite proposed that when new facts are added that contradict to the ontology , it is often desirable to revise the ontology according to the added data",
    ". therefore , this motivates us to consider another repair that selects maximal components of the existential rules .",
    "we illustrate the motivation via the following example .",
    "[ example:1 ] let @xmath4 be a database and let @xmath5 be the following rule set expressing that each bat can fly and has at least one cave to live in ; and if one creature lives in cave then it is a trogloxene ; and if we do not know one mammal can fly then it can not fly ; if one creature can fly then it is a bird ; additionally a bird can not be a trogloxene at the same time ; similarly a bird can not be a mammal meanwhile .",
    "@xmath6 clearly @xmath7 is inconsistent under stable model semantics .",
    "we assume @xmath8 is more reliable ( or preferred ) than @xmath9",
    ". then we can delete @xmath10 and @xmath11 , or @xmath12 in @xmath13 to restore the consistency , and get inclusion - maximal preferred consistent rule sets _ w.r.t .",
    "_ @xmath14 :     +    @xmath15 ,  @xmath16    = -1 we will focus on the case where the database is reliable but rules are not . our main goal is to present a framework of handling inconsistent existential rules under stable model semantics .",
    "we define a notion called _ rule repairs _ to select maximal components of the rules , the philosophy behind that is to trust the rules as many as possible .",
    "our second goal is to perform an in - depth analysis of the data and combined complexity of inconsistency - tolerant query answering under rule repair semantics .",
    "let us recall some previous work on existential rules under stable model semantics .",
    "@xcite presented r - acyclic and r - stratified normal rule sets each of which always admits at most one finite stable models .",
    "@xcite implicitly showed that the r - acyclicity is enough to capture all negation - free rule sets with finite stable models .",
    "@xcite proved the decidability of query answering under stable model semantics for guarded existential rules .",
    "@xcite extended the stickiness notion to normal rule sets and showed that it assures the decidability for well - founded semantics rather than stable model semantics .",
    "we will focus on r - acyclic rule sets with r - stratified or full negations and guarded existential rules with stratified or full negations .",
    "= -1 our main contributions are briefly summarized as follows .",
    "we define rule repair semantics to handle inconsistent existential rules under stable model semantics .",
    "we consider rule repairs _",
    "_ inclusion - maximal subset or cardinality , and that with preference .",
    "we obtain a ( nearly ) complete picture of the data and combined complexity of inconsistency - tolerant query answering under rule repair semantics ( table 1 ) .",
    "surprisingly , for r - acyclic existential rules with r - stratified or guarded existential rules with stratified negations , both the data complexity and combined complexity of query answering under the rule repair semantics remain the same as that under the conventional query answering semantics .",
    "interestingly , the data complexity based upon weak - acyclic or guarded existential rules with stratified negation is ptime - complete .",
    "this leads us to propose several approaches to handle the rule repair semantics by calling answer set programming ( asp ) solvers .",
    "an experimental evaluation shows that these approaches have good scalability of query answering rule repairs on realistic cases .",
    "we consider a standard first - order language .",
    "we use @xmath17 to denote the variables appearing in an expression @xmath18 .",
    "[ [ databases . ] ] databases .",
    "+ + + + + + + + + +    we assume an infinite set @xmath19 of _ ( data ) constants _ , an infinite set @xmath20 of _ ( labeled ) nulls _ ( used as fresh skolem terms ) , and an infinite set @xmath21 of _",
    "variables_. a _ term _ @xmath22 is a constant , a null , or a variable .",
    "we denote by @xmath23 a sequence of variables @xmath24 with @xmath25 .",
    "an _ atom _",
    "@xmath26 has the form @xmath27 , where @xmath28 is an @xmath29-ary relation symbol , and @xmath30 are terms .",
    "a conjunction of atoms is often identified with the set of all its atoms .",
    "we assume a _ relational schema _",
    "@xmath31 , which is a finite set of relation symbols .",
    "an _ instance _ @xmath32 is a ( possibly infinite ) set of facts @xmath33 , i.e. , atoms without involving variables , where @xmath34 is a tuple of constants and nulls .",
    "a _ database _ @xmath14 over a relational schema @xmath31 is a finite instance with relation symbols from @xmath31 and with arguments only from @xmath19 ( i.e. , without involving nulls ) .",
    "[ [ normal - logic - programs - and - stable - models . ] ] normal logic programs and stable models .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each _ normal ( logic ) program _ is a finite set of _ nlp rules _ of the form @xmath35 where @xmath36 are atoms and @xmath37 . given a rule @xmath38 of the above form ,",
    "let @xmath39 , let @xmath40 , and let @xmath41 .",
    "let @xmath42 be a normal program .",
    "the _ herbrand universe _ and _ herbrand base _ of @xmath42 are denoted by @xmath43 and @xmath44 , respectively .",
    "a variable - free rule @xmath45 is called an _ instance _ of some rule @xmath46 if there is a substitution @xmath47 such that @xmath48 .",
    "let @xmath49 , the _ grounding _ of @xmath42 , be the set of all instances of @xmath38 for all @xmath46 .",
    "the _ gelfond - lifschitz reduct _ of a normal program @xmath42 _ w.r.t . _",
    "a set @xmath50 , denoted @xmath51 , is the ( possibly infinite ) ground positive program obtained from @xmath49 by    * deleting every rule @xmath38 such that @xmath52 , and * deleting all negative literals from each remaining rule .",
    "= -1 a subset @xmath53 of @xmath44 is called a _ stable model _ of @xmath42 if it is the least model of @xmath54 . for more about stable model semantics ,",
    "refer to @xcite .",
    "[ [ normal - existential - rules . ] ] normal existential rules .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    every _ normal ( existential ) rule _ is a first - order sentence of the form @xmath55 , where @xmath56 is a conjunction of _ literals _ , i.e. , atoms or negated atoms ( of the form @xmath57 where @xmath26 is atomic ) , @xmath58 is a conjunction of atoms , and each universally quantified variable appears in at least one positive conjunct of @xmath56 . in the above normal rule , @xmath56 is called its _ body _ , and @xmath58 its _",
    "head_. a normal rule is called a _ constraint _ if its head is the  false \" @xmath59 . for simplicity ,",
    "when writing a rule , we often omit the universal quantifiers ; by a _ normal rule set _ , we always mean a finite number of normal existential rules .",
    "let @xmath38 be a normal rule @xmath60 .",
    "for each variable @xmath61 , we introduce an @xmath29-ary fresh function symbol @xmath62 where @xmath63 .",
    "the _ skolemization _ of @xmath38 , denoted @xmath64 , is the rule obtained from @xmath38 by substituting @xmath65 for @xmath61 , followed by substituting  @xmath66 \" for @xmath67 .",
    "let @xmath5 be a normal rule set .",
    "we define @xmath68 to be the set of rules",
    "@xmath64 for all @xmath69 .",
    "clearly , @xmath68 can be regarded as a normal program in an obvious way .",
    "given any database @xmath14 , an instance is called a _ stable model _ of @xmath70 if it is a stable model of @xmath71 .",
    "a normal rule @xmath38 is called _ guarded _ if there is a positive conjunct in the body of @xmath38 that contains all the universally quantified variable of @xmath38 , and a normal rule set is called _ guarded _ if every rule in it is guarded .",
    "a normal rule set @xmath5 is _ stratified _ if there is a function @xmath72 that maps relation symbols to integers such that for all @xmath69 :    * for all relation symbols @xmath28 occurring in the head and @xmath73 positively occurring in the body , @xmath74 , and * for all relation symbols @xmath28 occurring in the head and @xmath73 negatively occurring in the body , @xmath75 .",
    "sometimes , the negations that occur in a stratified normal rule set are called _ stratified negations _ , and those in a non - stratified normal rule set are called _",
    "full negations_.    let @xmath76 and @xmath77 be two normal rules , and let @xmath78 ( resp .",
    ", @xmath79 and @xmath80 ) be the set of atoms positively ( resp .",
    ", negatively and positively ) occurring in the body ( resp . , body and head ) of @xmath81 .",
    "_ w.l.o.g .",
    "_ , assume that no variable occurs in both @xmath76 and @xmath77 .",
    "rule @xmath77 _ positively relies _ on @xmath76 , written @xmath82 , if there exist a database @xmath14 and a substitution @xmath83 such that @xmath84 , @xmath85 , @xmath86 , @xmath87 , @xmath88 and @xmath89 .",
    "rule @xmath77 _ negatively relies _ on @xmath76 , written @xmath90 , if there exist a database @xmath14 and a substitution @xmath83 such that @xmath84 , @xmath85 , @xmath91 , @xmath92 and @xmath93 . a normal rule set @xmath94 is called _",
    "r - acyclic _ if there is no cycle of positive reliances @xmath95 that involves a rule with an existential quantifier , and @xmath94 is called _",
    "r - stratified _ if there is a partition @xmath96 of @xmath94 such that , for every two normal rule sets @xmath97 and rules @xmath98 and @xmath99 , if @xmath82 then @xmath100 and if @xmath90 then @xmath101 .    [ [ classical - boolean - query - answering . ] ] classical boolean query answering .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a _ normal boolean conjunctive query ( nbcq ) _",
    "@xmath102 is an existentially closed conjunction of atoms and negated atoms involving no null .",
    "let @xmath103 ( respectively . ,",
    "@xmath104 ) be the set of atoms positively ( respectively .",
    ", negatively ) occurring in @xmath102 .",
    "an nbcq is called _ safe _ if every variable in an atom from @xmath104 has at least one occurrence in @xmath103 ; it is _ covered _",
    "if for every atom @xmath26 in @xmath104 , there is an atom in @xmath103 that contains all arguments of @xmath26 .    given a database @xmath14 and an nbcq @xmath102 ,",
    "we write @xmath105 if there exists an assignment @xmath106 ( that is , a function that maps each variable to a variable - free term ) such that @xmath107 and @xmath108 .",
    "furthermore , given a database @xmath14 , a normal rule set @xmath5 and an nbcq @xmath102 , we write @xmath109 if , for each stable model @xmath53 of @xmath70 , we have that @xmath110 .",
    "[ [ complexity - classes . ] ] complexity classes .",
    "+ + + + + + + + + + + + + + + + + + +    we assume that the reader is familiar with the complexity theory . given a unary function @xmath111 on natural numbers , by @xmath112 ( @xmath113 , respectively ) we mean the class of languages decidable in time @xmath114 by a deterministic ( nondeterministic , respectively ) turing machine .",
    "besides the well - known complexity classes such as @xmath115 and @xmath116 , we will also use several unusual classes as follows . by notation",
    "@xmath117-@xmath118 we mean the class of all languages decidable in exponential time by a deterministic turing machine with an oracle for some @xmath119-complete problem .",
    "the boolean hierarchy ( @xmath120 ) is defined as follows : @xmath121 is @xmath122 ; for @xmath123 , @xmath124 ( @xmath125 ) is the class of languages each of which is the intersection ( union , respectively ) of a language in @xmath126 ( @xmath124 , respectively ) and a language in @xmath127 ( @xmath122 , respectively ) ; @xmath120 is then the union of @xmath128 for all @xmath129 .",
    "note that @xmath130 , the class for _ difference polynomial time _ , is exactly the class @xmath131 ; @xmath124 is actually the class of languages each of which is the union of @xmath132 languages in @xmath130 ; and @xmath120 is closed under complement .",
    "it was shown by  @xcite that a collapse of the boolean hierarchy implies a collapse of the polynomial hierarchy ; thus it seems impossible to find a @xmath120-complete problem .",
    "= -1 in this section , we propose several semantics to handle inconsistency in ontological knowledge base .",
    "different from many existing works , we will focus on the case where the database is reliable but rules are not .",
    "similar to the data repair semantics , see @xcite , our inconsistency - tolerant semantics will rely on a notion called _ rule repairs_.    to define rule repairs , we arm every rule set with a preference .",
    "such rule sets are called preference - based ontologies .    each _ preference - based ontology _ is an ordered pair @xmath133 , where @xmath5 is a normal rule set , and @xmath134 is a preorder ( i.e. , a reflexive and transitive binary relation ) on @xmath135 ( i.e. , the power set of @xmath5 ) .",
    "we call @xmath134 a _ preference_.    now , we are in the position to define rule repairs .",
    "let @xmath136 be a preference - based ontology @xmath133 and @xmath14 a database .",
    "a subset @xmath73 of @xmath5 is called a _ ( preferred rule ) repair of @xmath5 _ w.r.t . _",
    "@xmath134 and @xmath14 _ ( or simply a repair _ w.r.t .",
    "_ @xmath134 if @xmath5 and @xmath14 are clear from the context ) if @xmath137 has at least one stable model , and for all subsets @xmath138 of @xmath5 with @xmath139 ( i.e. , @xmath140 but @xmath141 ) , @xmath142 has no stable model .",
    "= -1 intuitively , a preferred rule repair is a maximal component of the rule set which is consistent with the current database .",
    "the philosophy behind it is to trust the rules as many as possible .",
    "note that the number of repairs are normally more than one . to avoid a choice among them",
    ", we follow the spirit of  certain \" query answering .",
    "the semantics is then as follows .",
    "let @xmath136 be a preference - based ontology @xmath133 where @xmath5 is a normal rule set , and let @xmath14 be a database and @xmath102 an nbcq .",
    "then we write @xmath143 if , for all preferred rule repairs @xmath73 of @xmath5 _ w.r.t . _ @xmath134 and @xmath14 , we have @xmath144 .",
    "the following proposition shows us that our semantics for inconsistency - tolerant query answering will coincide with the classical semantics for query answering if the ontological knowledge base is consistent , which is clearly important .",
    "let @xmath136 be a preference - based ontology @xmath145 and let @xmath14 be a database . if @xmath146 has a stable model , then @xmath147 iff @xmath148 for any nbcq @xmath102 .    with the above definitions , we then have a framework to define semantics for rule - based inconsistency - tolerant query answering . to define concrete semantics , we need to find preferences which will be useful in real - world applications .",
    "besides the preference based on the set inclusion @xmath149 , similar to @xcite , we will consider other four kinds of preferences over subsets , which were first proposed by @xcite to study logic - based abduction .",
    "[ [ cardinality - leq . ] ] cardinality ( @xmath150 ) .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    given any @xmath151 , we write @xmath152 if @xmath153 .",
    "the intuition of using this preference is that we always prefer the rule set with the maximum number of rules which are most likely to be correct .",
    "[ [ priority - levels - subseteq_p - leq_p . ] ] priority levels ( @xmath154 , @xmath155 ) .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    every _ prioritization _ @xmath94 of @xmath5 is a tuple @xmath156 where @xmath157 is a partition of @xmath5 . given a _",
    "@xmath158 of @xmath5 , the preferences @xmath154 and @xmath155 can be defined as follows :    * prioritized set inclusion ( @xmath159 ) : given @xmath151 , we write @xmath160 if @xmath161 for every @xmath162 , or there is some @xmath162 such that @xmath163 and for all @xmath164 , @xmath165 .",
    "* prioritized cardinality ( @xmath166 ) : given @xmath151 , we write @xmath167 if @xmath168 for every @xmath162 , or there is some @xmath162 such that @xmath169 @xmath170 @xmath171 and for all @xmath164 , @xmath172 .",
    "[ [ weights - leq_w . ] ] weights ( @xmath173 ) .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a _ weight assignment _ is a function @xmath174 . given two sets @xmath151 and a weight assignment @xmath175 , we write @xmath176 if @xmath177 .    in the rest of this paper , we will fix @xmath94 as a prioritization and @xmath175 as a weight assignment unless otherwise noted .",
    "[ example [ example:1 ] continued ] let @xmath5 and @xmath14 be the same as in example [ example:1 ]",
    ". then the repairs _ w.r.t . _",
    "@xmath149 and @xmath14 are :     +    @xmath178 ,  @xmath179 + @xmath180 ,  @xmath181 + @xmath182     + the repairs _ w.r.t . _ @xmath150 and @xmath14 include : +    @xmath15 ,  @xmath183",
    ".     + let @xmath184 where @xmath185 are the same as in example [ example:1 ] .",
    "then the repairs _ w.r.t .",
    "_ @xmath159 and @xmath14 are shown in example [ example:1 ] , and the repairs _ w.r.t . _",
    "@xmath155 and @xmath14 are : +    @xmath15 .",
    "+ let @xmath175 be the weight assignment that maps each rule to its index .",
    "then the only repair _ w.r.t .",
    "_ @xmath173 and @xmath14 is : +    @xmath183 .",
    "+    let @xmath186 be query ",
    "_ mammal(a ) _ \" and @xmath187 be query  _ bird(a ) _ \" , then we have @xmath188 and @xmath189 , but @xmath190 and @xmath191 .",
    "we find that repairs under @xmath159 , @xmath150 , @xmath192 , and @xmath193 are the subset of the inclusion - maximal repairs .",
    "the repairs under @xmath159 , @xmath150 , @xmath192 , @xmath193 are the subset of the repairs under @xmath149 .",
    "let @xmath73 be the set of repairs under @xmath149 , @xmath194 be the set of repairs under @xmath159 , we prove that @xmath195 .",
    "suppose for contradiction that @xmath196 , then there exists a repair @xmath28 , @xmath197 and @xmath198",
    ". because the repairs in @xmath73 are inclusion - maximal , we have @xmath199 for some @xmath200 .",
    "it is clear that @xmath201 , then @xmath28 is not a @xmath159 repair which contradict our assumption .",
    "the rest semantics can be proved similarly .",
    "in this section , we study the data and combined complexity for query entailment under our rule repair semantics . in particular , we focus on the following decision problems :    * * data complexity * : fixing a preference - based ontology @xmath136 and an nbcq @xmath102 , given any database @xmath14 as input , deciding whether @xmath143 . *",
    "* combined complexity * : given any preference - based ontology @xmath136 , any nbcq @xmath102 and any database @xmath14 as input , deciding whether @xmath143 .",
    "to measure the size of input , we fix a natural way to represent a database @xmath14 , a normal rule set @xmath5 , an nbcq @xmath102 , a prioritization @xmath94 and a weight assigning function @xmath175 , and let @xmath202 denote the sizes of @xmath203 , respectively , _ w.r.t . _ the fixed representing approach . given a preference - based ontology @xmath204 , we define @xmath205 by properly representing , we can have that @xmath206 .",
    "the following result is obvious .",
    "[ prop : cmplx_compare ] let @xmath136 be a preference - based ontology @xmath145 , where @xmath207 .",
    "then , given any subsets @xmath151 , deciding whether @xmath139 is in @xmath208 .",
    "now , let us consider the complexity of query answering for r - acyclic and r - stratified rule sets under our semantics .",
    "[ thm : cmplx_wa_stra ] let @xmath136 be a preference - based ontology @xmath133 , where @xmath5 is r - acyclic and r - stratified , and @xmath209 @xmath210 .",
    "given a database @xmath14 and a safe nbcq @xmath102 , deciding whether @xmath211 is ptime - complete for data complexity , and @xmath212-complete for combined complexity .",
    "let @xmath14 be a database and @xmath102 be a safe nbcq . by the definition of semantics , it is easy to verify that the problem of deciding whether @xmath211 can be solved by alg .",
    "[ alg : pqa ] .",
    "first , we consider the data complexity . in alg .",
    "[ alg : pqa ] , let us fix a preference - based ontology @xmath204 as defined in this theorem , fix a safe nbcq @xmath102 , and let @xmath14 be the only input . as @xmath5 is r - acyclic and r - stratified , by theorem 5 in  @xcite , it is clear that the body of the second loop ( the inside one ) in alg .",
    "[ alg : pqa ] is computable in @xmath213 _ w.r.t .",
    "_ @xmath14 .",
    "( note that the existence of stable models can be reduced to the query answering problem in a routine way . )",
    "since the second loop will be repeated a constant times , and by proposition  [ prop : cmplx_compare ] the loop condition can be checked in a constant time .",
    "( note that the rule set @xmath5 is fixed now . )",
    "thus , the second loop can be computed in @xmath213 _ w.r.t . _",
    "the size of @xmath14 . by a similar argument",
    ", we can show that alg .",
    "[ alg : pqa ] can be implemented in @xmath213 _ w.r.t .",
    "_ @xmath14 .",
    "this then completes the proof of membership .",
    "the hardness follows from the @xmath213-hardness of datalog for data complexity , see , e.g. ,  @xcite .",
    "next , we prove the combined complexity . again , first address the membership .",
    "let @xmath29 be the number of rules in @xmath5 .",
    "clearly , the body of the second loop will be repeated at most @xmath214 times . by theorem 9 in  @xcite , it is computable in @xmath215 . by proposition  [ prop : cmplx_compare ] , it is also clear that the loop condition can be checked in @xmath208 .",
    "so , the second loop is computable in @xmath216 since @xmath217 . by a similar evaluation , we know that the algorithm is implementable in @xmath216 .",
    "thus , the combined complexity is in @xmath212 . and the hardness follows from the @xmath212-hardness of query answering of the r - acyclic language  @xcite and the fact that @xmath109 iff @xmath218 , where @xmath219 is @xmath220 and @xmath221 a fresh 0-ary relational symbol .",
    "[ thm : cmplx_wa_full ] let @xmath136 be a preference - based ontology @xmath133 , where @xmath5 is r - acyclic with full negations and @xmath222 @xmath223 . then , given a database @xmath14 and a safe nbcq @xmath102 , deciding whether @xmath211 is in bh for data complexity and in @xmath117-@xmath212 for combined complexity .",
    "we first prove the data complexity .",
    "to do this , we need to define some notations .",
    "let @xmath31 be the schema of @xmath5 .",
    "given any subset @xmath224 of @xmath5 , let @xmath225 be the set of all @xmath31-databases @xmath14 such that    1 .",
    "@xmath226 has at least one stable model , and 2 .",
    "@xmath227 does not hold , and 3 .   for all @xmath228 with @xmath229",
    ", @xmath230 has no stable model .",
    "let @xmath231 denote the union of @xmath225 for all subsets @xmath224 of @xmath5 . by the definition of the rule repair semantics , it is easy to see that @xmath211 iff there is no @xmath232 such that @xmath233 , iff @xmath14 does not belong to @xmath231 . thus , if the following claim is true , by the definition of @xmath120 we then have the desired result .",
    "notice that the complexity class @xmath120 is closed under complement .    given any subset @xmath224 of @xmath5 ,",
    "it is in dp ( _ w.r.t . _",
    "the size of input database @xmath14 ) to determine whether @xmath233 .",
    "now , it remains to show the claim .",
    "fix a subset @xmath232 .",
    "let @xmath234 denote the set of all @xmath31-databases such that conditions 1 and 2 hold , and let @xmath235 denote the set of all @xmath31-databases such that the condition 3 holds . according to theorem 2 in  @xcite ,",
    "@xmath234 is in @xmath122 and @xmath235 in @xmath127 .",
    "( note that , as @xmath5 and @xmath224 are fixed , the number of subsets @xmath236 is independent on the size of input database ; thus @xmath235 should be in @xmath127 . ) by definition , @xmath237 is in @xmath130 .",
    "this proves the data complexity .",
    "next , we show the combined complexity .",
    "it is clear that @xmath143 holds iff there does not exist @xmath238 such that    1 .",
    "@xmath137 has at least one stable model , and 2 .",
    "@xmath144 does not hold , and 3 .   for all @xmath239 with @xmath139",
    ", @xmath142 has no stable models .    by theorem 2 in  @xcite and an analysis similar to that in theorem  [ thm : cmplx_wa_stra ] ( for combined complexity ) , it is not difficult to see that , fixing @xmath238 , both conditions 1 and 2 are in @xmath240 , and condition 3 is in @xmath119 . for",
    " there does not exist @xmath238 \" , we can simply enumerate all subsets @xmath73 , which can be done in @xmath241 times .",
    "therefore , query answering under the mentioned semantics must be in @xmath117-@xmath212 for combined complexity , which is as desired .",
    "now let us focus on guarded rules .",
    "the proof of the following is similar to that of theorem  [ thm : cmplx_wa_stra ] , but employs the complexity results in  @xcite .",
    "the only thing we should be careful about is the constraints .",
    "[ thm : cmplx_grd_stra ] let @xmath136 be a preference - based ontology @xmath133 , where @xmath5 is guarded and stratified , and @xmath242 @xmath243 .",
    "given a database @xmath14 and a covered nbcq @xmath102 , deciding whether @xmath211 is ptime - complete for data complexity , and @xmath212-complete for combined complexity .",
    "for guarded rules with full negations , we have some results as below , where the proof for data complexity is similar to that in theorem  [ thm : cmplx_wa_full ] , and the proof for combined complexity is similar to that in theorem  [ thm : cmplx_wa_stra ] .",
    "both results rely on the corresponding complexity results in  @xcite .",
    "[ thm : cmplx_grd_full ] let @xmath136 be a preference - based ontology @xmath133 , where @xmath5 is guarded , and @xmath244 . then , given a database @xmath14 and a covered nbcq @xmath102 , deciding whether @xmath211 is in bh for data complexity and @xmath212-complete for combined complexity",
    "finally , we conclude the results of this section as follows :    [ table:1 ]    . the data and combined complexity of boolean query answering over normal rule sets under preference - based semantics for 5 types of preferred rule repairs , including @xmath149 , @xmath150 , @xmath154 , @xmath155 , and @xmath173 . here , ",
    "ra \" means  r - acyclic rule sets \" ,  g \" means ",
    "guarded rule sets \" ,  rs \" means  with r - stratified negations \" ,  stra \" means  with stratified negations \" , and  full \" means  with full negations \" . [ cols=\"^,^,^\",options=\"header \" , ]",
    "to demonstrate the effectiveness , we have implemented a prototype system for query answering of r - acyclic rule languages under the rule - repair semantics _ w.r.t .",
    "_ @xmath150 , @xmath154 , @xmath155 and @xmath173 , by calling a state - of - the - art asp solver .      to improve the efficiency , we adopt particular algorithm for each rule - repair semantics .",
    "the algorithms are all based on breadth - first search .",
    "finding rule repairs _",
    "_ @xmath149 uses the basic process illustrated in alg .",
    "[ alg : pqa ] , and exponential checking will be conducted during the process . for rule repairs _ w.r.t .",
    "_ @xmath150 , though it works better than @xmath149 for the reason that there is no need to search the rest levels once it finds consistent sets . as for rule repairs _ w.r.t . _",
    "@xmath154 , we design an algorithm which iterates over the rules from low to high prioritization",
    ". once finding consistent results in the rules with lower prioritization , the searching stops .",
    "it s known that @xmath155 can be translated into @xmath173 , but not vice versa . as for @xmath173 ,",
    "we search by deleting rules from the lowest weight to the greatest .    as a whole",
    ", the algorithms for situations with prioritization or weights will be much more efficient if the rule set satisfies the following two conditions :    * the size of rules with lower prioritization ( less weights ) is very small , even though the whole rule set is large ; * the rule set can be consistent by only deleting rules with lower prioritization ( less weights ) .",
    "these conditions can be easily found in real applications because incorrectness are mostly caused by the rules newly added and the amount of these rules is normally small .",
    "we developed a prototype system qaier ( query answering with inconsistent existential rules ) in c++ .",
    "qaier can answer queries with inconsistent r - acyclic rule sets .",
    "when it needs to check the existence of stable models , qaier invokes an asp solver clingo-4.4.0 .",
    "http://sourceforge.net/projects/potassco/files/clingo/ ] .",
    "& + @xmath245  & @xmath246 & @xmath247 & @xmath248 & @xmath249 & @xmath250 & @xmath251 & + @xmath252  & @xmath246 & @xmath253 &  & @xmath254 & @xmath255 & @xmath256 & + @xmath257  & @xmath258 & @xmath253 &  & @xmath259 & @xmath260 & @xmath261 & + @xmath262  & @xmath263 & @xmath253 &  &  & @xmath264 & @xmath265 & + @xmath266  & @xmath267 & @xmath253 &  &  & @xmath268 & @xmath269 & + @xmath270  & @xmath271 & @xmath247 &  &  & @xmath272 & @xmath273 & + @xmath274  & @xmath271 & @xmath253 &  &  & @xmath275 & @xmath276 & + @xmath277  & @xmath278 & @xmath247 &  &  & @xmath279 & @xmath280 & + @xmath281  & @xmath278 & @xmath253 &  &  & @xmath282 & @xmath283 & + @xmath284  & @xmath285 & @xmath247 &  &  & @xmath286 & @xmath287 & + @xmath288  & @xmath285 & @xmath253 &  &  &  &  & + @xmath289  & @xmath290 & @xmath247 &  &  &  & @xmath291 & + @xmath292  & @xmath290 & @xmath253 &  &  &  &  & +     & + @xmath293  & @xmath294 & @xmath247 & @xmath295 & @xmath296 & @xmath297 & @xmath298 & + @xmath299  & @xmath294 & @xmath300 & @xmath301 & @xmath302 & @xmath303 & @xmath304 & + @xmath305  & @xmath294 & @xmath306 & @xmath307 & @xmath308&@xmath309 & @xmath310 & + @xmath311  & @xmath312 & @xmath247 & @xmath313 & @xmath314 & @xmath315 & @xmath316 & + @xmath317  & @xmath312 & @xmath300 & @xmath318 & @xmath319 & @xmath320 & @xmath321 & + @xmath322  & @xmath312 & @xmath306 & @xmath323 & @xmath324 & @xmath325 & @xmath326 & + @xmath327  & @xmath328 & @xmath247 &  &  & @xmath329 & @xmath330 & + @xmath331  & @xmath328 & @xmath300 &  &  &  &  & +    [ [ benchmarks ] ] benchmarks + + + + + + + + + +    to estimate the performance of qaier in a view of data complexity , we use the modified lubm .",
    "http://swat.cse.lehigh.edu/projects/lubm/ ] as a benchmark .",
    "because lubm is not r - acyclic , we modified lubm by changing atoms and deleting rules to make sure that modified lubm is r - acyclic .",
    "we use hermit .",
    "http://www.hermit-reasoner.com/ ] to transform the modified lubm ontology into dl - clauses , and replace at - least number restrictions in head atoms with existential quantification , then get 127 rules .",
    "next we add default negations or constraints , and introduce the prioritization and weight under rule repair semantics . considering that the number of default negations or constraints would not be very large ,",
    "we introduce 9 - 11 for each instance .",
    "the introduced prioritization or weight depends on the reliability of the rules .",
    "we use the eudg.http://www.informatik.uni-bremen.de/@xmath332clu/combined/ ] to generate a database .",
    "by @xmath333 ( table 2 ) we mean that the instance involves @xmath224 thousands facts and @xmath236 unreliable rules .",
    "for the performance in the view of combined complexity , we use the modified chebi @xcite as a benchmark . by @xmath334 ( table 3 ) we mean that the instance involves @xmath224 molecules and chemical classes and @xmath236 unreliable rules .",
    "[ [ experimental - results ] ] experimental results + + + + + + + + + + + + + + + + + + + +    table 2 ( table 3 , respectively ) , @xmath335 , and @xmath336 means the number of facts in database , default negations and constraints , and rules respectively . ] shows the data ( combined , respectively ) complexity performance among rule repairs scale up , when @xmath337 and @xmath335 ( @xmath336 and @xmath335 , respectively ) grow .",
    "@xmath338 , @xmath339 , @xmath340 , @xmath341 , or @xmath342 records the queries answering time .",
    "each instance is computed three times and taken the average . because qaier computes all the stable models , the sizes or the types of queries are not the important issues .",
    "clearly , rule repairs _ w.r.t . _ @xmath159 , @xmath192 , and @xmath193 have better performances than those of @xmath149 and @xmath150 , which is due to the few number of unreliable rules .",
    "this condition can be easily found in realistic cases because most of the rules are reliable , while the latest learned rules considered unreliable are few .",
    "= -1 in terms of changing the rule set / tbox for repair , @xcite proposed an algorithm running in exptime that finds maximally concept - satisfiable terminologies in @xmath3 .",
    "@xcite showed that probabilistic description logics can be used to resolve conflicts and receive a consistent knowledge base from which inferences can be drawn again .",
    "also @xcite proposed model - based revision operators for terminologies in dl , and @xcite introduced a model - theoretic approach to ontology revision . in order to address uncertainty arising from inconsistency",
    ", @xcite extended the datalog@xmath343 language with probabilistic uncertainty based on markov logic networks .",
    "more generally , several works have focused on reasoning with inconsistent ontologies , see @xcite and references therein .",
    "surprisingly , this paper shows that for r - acyclic existential rules with r - stratified or guarded existential rules with stratified negations both the data complexity and combined complexity of query answering under the rule repair semantics do not increase .",
    "= -2 we have developed a general framework to handle inconsistent existential rules with default negations . within this framework , we analyzed the data and combined complexity of inconsistency - tolerant query answering under rule repair semantics .",
    "we proposed approaches simulating queries answering under rule repairs with calling asp solvers and developed a prototype system called qaier .",
    "our experiments show that qaier can scale up to large databases under rule repairs in practice .",
    "future work will focus on identifying first order rewritable classes under rule repair semantics .",
    "= -1 we thank the reviewers for their comments and suggestions for improving the paper .",
    "the authors would like to thank yongmei liu and her research group for their helpful and informative discussions .",
    "hai wan s research was in part supported by the national natural science foundation of china under grant 61573386 , natural science foundation of guangdong province of china under grant s2012010009836 , and guangzhou science and technology project ( no .",
    "2013j4100058 ) .",
    "alviano , m. , and pieris , a. 2015 .",
    "default negation for non - guarded existential rules . in _ proceedings of the 34th acm symposium on principles of database systems , pods 2015 , melbourne , australia ,",
    "may 31 - june 4 , 2015 _ , 7990 .",
    "arenas , m. ; bertossi , l.  e. ; and chomicki , j. 1999 .",
    "consistent query answers in inconsistent databases . in _ proceedings of the eighteenth acm sigact - sigmod - sigart symposium on principles of database systems ,",
    "may 31 - june 2 , 1999 , philadelphia , pennsylvania , usa _ , 6879 .",
    "bienvenu , m. ; bourgaux , c. ; and goasdou , f. 2014 . querying inconsistent description logic knowledge bases under preferred repair semantics . in _ proceedings of the twenty - eighth aaai conference on artificial intelligence , july 27 -31 , 2014 , qubec city , qubec , canada .",
    "_ , 9961002 .",
    "gelfond , m. , and lifschitz , v. 1988 .",
    "the stable model semantics for logic programming . in _ proceedings of the fifth international conference and symposium logic programming , seattle ,",
    "washington , august 15 - 19 , 1988 ( 2 volumes ) _ , 10701080 .",
    "gottlob , g. ; hernich , a. ; kupke , c. ; and lukasiewicz , t. 2014 .",
    "stable model semantics for guarded existential rules and description logics . in _ proceedings of the fourteenth international conference principles of knowledge representation and reasoning , kr 2014 , vienna , austria ,",
    "july 20 - 24 , 2014 _",
    ", 258267 .",
    "haase , p. ; van harmelen , f. ; huang , z. ; stuckenschmidt , h. ; and sure , y. 2005 .",
    "a framework for handling inconsistency in changing ontologies . in _ proceedings of the semantic web - iswc 2005 , 4th international semantic web conference , iswc 2005 , ireland , november 6 - 10 , 2005 _ , 353367 .",
    "huang , z. ; van harmelen , f. ; and ten teije , a. 2005 .",
    "reasoning with inconsistent ontologies . in _ proceedings of the nineteenth international joint conference on artificial intelligence , ijcai 2005 , edinburgh , scotland , uk , july 30-august 5 , 2005 _ , 454459 .",
    "kalyanpur , a. ; parsia , b. ; sirin , e. ; and grau , b.  c. 2006 .",
    "repairing unsatisfiable concepts in owl ontologies . in _ proceedings of the semantic web : research and applications , 3rd european semantic web conference , eswc 2006 , budva , montenegro , june 11 - 14 , 2006 , _ , 170184 .",
    "lembo , d. ; lenzerini , m. ; rosati , r. ; ruzzi , m. ; and savo , d.  f. 2010 .",
    "inconsistency - tolerant semantics for description logics . in _ proceedings of web reasoning and rule systems - fourth international conference , rr 2010 , bressanone / brixen , italy , september 22 - 24 , 2010 . _ , 103117 .",
    "lukasiewicz , t. ; martinez , m.  v. ; pieris , a. ; and simari , g.  i. 2015 . from classical to consistent query answering under existential rules . in _ proceedings of the twenty - ninth aaai conference on artificial intelligence ,",
    "january 25 - 30 , 2015 , austin , usa . _    lukasiewicz , t. ; martinez , m.  v. ; and simari , g.  i. 2012 .",
    "inconsistency handling in datalog+/- ontologies . in _ proceedings of 20th european conference on artificial intelligence .",
    "ecai 2012 including prestigious applications of artificial intelligence ( pais-2012 ) system demonstrations track , montpellier , france , august 27 - 31 , 2012 _ , 558563 .",
    "lukasiewicz , t. ; martinez , m.  v. ; and simari , g.  i. 2013 .",
    "complexity of inconsistency - tolerant query answering in datalog+/- . in _",
    "informal proceedings of the 26th international workshop on description logics , ulm , germany , july 23 - 26 , 2013 _ , 488500 .",
    "magka , d. ; krtzsch , m. ; and horrocks , i. 2013 .",
    "computing stable models for nonmonotonic existential rules . in _ proceedings of the 23rd international joint conference on artificial intelligence , ijcai 2013 , beijing , china ,",
    "august 3 - 9 , 2013 _",
    ", 10311038 .",
    "meyer , t.  a. ; lee , k. ; booth , r. ; and pan , j.  z. 2006 . finding maximally satisfiable terminologies for the description logic alc . in _ proceedings of the twenty - first national conference on artificial intelligence and the eighteenth innovative applications of artificial intelligence conference , july 16 - 20 , 2006 , boston , massachusetts , usa _ , 269274 .    qi , g. , and du , j. 2009 .",
    "model - based revision operators for terminologies in description logics . in _ proceedings of the 21st international joint conference on artificial intelligence ijcai 2009 , pasadena , california , usa , july 11 - 17 , 2009 _",
    ", 891897 .",
    "scharrenbach , t. ; grtter , r. ; waldvogel , b. ; and bernstein , a. 2010 . structure preserving tbox repair using defaults . in _ proceedings of the 23rd international workshop on description logics ( dl 2010 ) , waterloo , ontario , canada , may 4 - 7 , 2010 _ , 384395 .",
    "wang , z. ; wang , k. ; qi , g. ; zhuang , z. ; and li , y. 2014 .",
    "instance - driven tbox revision in dl - lite . in",
    "_ informal proceedings of the 27th international workshop on description logics , vienna , austria , july 17 - 20 , 2014 .",
    "_ , 734745 .",
    "zhang , h. ; zhang , y. ; and you , j .- h .",
    "existential rule languages with finite chase : complexity and expressiveness . in _ proceedings of the twenty - ninth aaai conference on artificial intelligence ,",
    "january 25 - 30 , 2015 , austin , texas , usa . _"
  ],
  "abstract_text": [
    "<S> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ = -1 traditional inconsistency - tolerent query answering in ontology - based data access relies on selecting maximal components of an abox / database which are consistent with the ontology </S>",
    "<S> . however , some rules in ontologies might be unreliable if they are extracted from ontology learning or written by unskillful knowledge engineers . </S>",
    "<S> in this paper we present a framework of handling inconsistent existential rules under stable model semantics , which is defined by a notion called rule repairs to select maximal components of the existential rules . </S>",
    "<S> surprisingly , for r - acyclic existential rules with r - stratified or guarded existential rules with stratified negations , both the data complexity and combined complexity of query answering under the rule repair semantics remain the same as that under the conventional query answering semantics . </S>",
    "<S> this leads us to propose several approaches to handle the rule repair semantics by calling answer set programming solvers . </S>",
    "<S> an experimental evaluation shows that these approaches have good scalability of query answering under rule repairs on realistic cases . _ </S>",
    "<S> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </S>",
    "<S> _ _ </S>"
  ]
}