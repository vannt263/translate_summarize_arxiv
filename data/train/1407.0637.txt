{
  "article_text": [
    "broadcasting a message from a source node to every other node of a network is one of the most basic communication primitives .",
    "since this operation should be performed by making use of a both sparse and fast infrastructure , the natural solution is to root at the source node a _",
    "shortest - path tree _ ( spt ) of the underlying graph",
    ". however , the spt , as any tree - based network topology , is highly sensitive to a link / node malfunctioning , which will unavoidably cause the disconnection of a subset of nodes from the source .    to be readily prepared to react to any possible ( transient ) failure in a spt , one has then to enrich the tree by adding to it a set of edges selected from the underlying graph , so that the resulting structure will be 2-edge / vertex - connected w.r.t .",
    "the source .",
    "thus , after an edge / vertex failure , these edges will be used to build up the alternative paths emanating from the root , each one of them in replacement of a corresponding original shortest path which was affected by the failure . however , if these paths are constrained to be _",
    ", then it can be easily seen that for a non - negatively real weighted and undirected graph @xmath7 of @xmath0 nodes and @xmath8 edges , this may require as much as @xmath9 additional edges , also in the case in which @xmath10 . in other words , the set - up costs of the strengthened network may become unaffordable .",
    "thus , a reasonable compromise is that of building a _ sparse _ and _ fault - tolerant _ structure which _ accurately approximates _ the shortest paths from the source , i.e. , that contains paths which are longer than the corresponding shortest paths by at most a multiplicative _ stretch _ factor , for any possible edge / vertex failure .",
    "the aim of this paper is to show that very efficient structures of this sort do actually exist .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    let @xmath11 denote a distinguished source vertex of a non - negatively real weighted and undirected graph @xmath12 .",
    "we say that a spanning subgraph @xmath13 of @xmath7 is an _ edge - fault - tolerant @xmath14-approximate spt _ ( in short , @xmath14-easpt ) , with @xmath15 , if it satisfies the following condition : for each edge @xmath16 , all the distances from @xmath11 in the subgraph @xmath17 are @xmath14-stretched w.r.t .",
    "the corresponding distances in @xmath18 .",
    "vertex failures _ are considered , then the easpt is correspondingly called vaspt .",
    "our work is inspired by the paper of parter and peleg @xcite , which were concerned with the same problem but on _ unweighted _ graphs ( and so they were focusing on the construction of an _ edge - fault - tolerant @xmath14-approximate breadth - first search tree _ ( in short , @xmath14-eabfs ) . in that paper",
    "the authors present a @xmath19-eabfs having at most @xmath20 edges .",
    "rooted at the source node , but , as we will point out in more detail later , a @xmath19-easpt of size at most @xmath21 ( and then , _ a fortiori _ , a @xmath19-eabfs of the same size ) , can actually be obtained as a by - product of the results given in @xcite .",
    "] moreover , the authors also present a set of lower and upper bounds to the size of @xmath6-eabfs , i.e. , edge - fault - tolerant structures for which the length of a path is stretched by at most a factor of @xmath14 plus an additive term of @xmath22 . finally , assuming at most @xmath23 edge failures",
    "can take place , they show the existence of a @xmath24-eabfs of size @xmath25 .",
    "on the other hand , if one wants to have an _ exact _ edge - fault - tolerant spt ( say espt ) , then as we said before this may require @xmath26 edges .",
    "this is now in contrast with the unweighted case , where it can be shown the existence ( see @xcite ) of an _ edge / vertex - fault - tolerant bfs _",
    "( say ebfs / vbfs ) of size @xmath27 , where @xmath28 denotes the eccentricity of @xmath11 in @xmath7 . in the same paper",
    ", the authors also exhibit a corresponding lower bound of @xmath29 for the size of a ebfs .",
    "moreover , they also treat the _ multisource _",
    "case , i.e. , that in which we look for a structure which incorporates an ebfs rooted at each vertex of a set @xmath30 . for this , they show the existence of a solution of size @xmath31 , which is tight . finally , the authors provide an @xmath32-approximation algorithm for constructing an optimal ( in terms of size ) ebfs ( also for the multisource case ) , and they show this is tight .",
    "as far as the vertex - failure problem is concerned , in @xcite the authors study the related problem of computing _ distance sensitivity oracles _ ( dso ) structures .",
    "designing an efficient dso means to compute , with a _ low _ preprocessing time , a _",
    "compact _ data structure which is functional to _ quickly _ answer to some distance query following a component failure .",
    "classically , dso cope with single edge / vertex failures , and they have to answer to a point - to - point post - failure ( approximate ) distance query , or they have to report a point - to - point replacement short(est ) path .",
    "in particular , in @xcite the vertex - failure case w.r.t . a spt is analyzed , and the authors compute in @xmath33 time a dso of size @xmath5 , that returns a 3-stretched replacement path in time proportional to the path s size . as the authors specify in the paper , this dso can be used to build a @xmath19-vaspt of size @xmath5 , and a @xmath3-vabfs of size @xmath34 .",
    "actually , we point out that the latter structure can be easily sparsified so as to obtain a @xmath3-eabfs of size @xmath35 : in fact , its @xmath5 size term is associated with an auxiliary substructure that , in the case of edge failures , can be made of linear size .",
    "this result is of independent interest , since it qualifies itself as the best current solution for the eabfs problem .",
    "[ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + +    our main result is the construction in polynomial time of a @xmath3-vaspt of size @xmath2 , for any @xmath1 .",
    "this substantially improves on the @xmath19-vaspt of size @xmath5 given in @xcite . to obtain our result",
    ", we perform a careful selection of edges that will be added to an initial spt .",
    "the somewhat surprising outcome of our approach is that if we accept to have slightly stretched fault - tolerant paths , then we can drastically reduce the @xmath26 size of the structure that we would have to pay for having fault - tolerant _ shortest _ paths ! actually , the analysis of the stretch factor and of the structure s size induced by our algorithm is quite involved .",
    "thus , for clarity of presentation , we give our result in two steps : first , we show an approach to build a @xmath3-easpt of size @xmath2 , then we outline how this approach can be extended to the vertex - failure case .",
    "furthermore , we also focus on the unweighted case , and we exhibit an interesting connection between a fault - tolerant bfs and an _ @xmath6-spanner_. an @xmath6-spanner of a graph @xmath7 is a spanning subgraph @xmath13 of @xmath7 such that _ all _ the intra - node distances in @xmath13 are stretched by at most a multiplicative factor of @xmath14 and an additive term of @xmath22 w.r.t . the corresponding distances in @xmath7 .",
    "we show how an ordinary @xmath6-spanner of size @xmath36 can be used to build in polynomial time an @xmath6-eabfs and an @xmath6-vabfs of size @xmath37 and @xmath38 , respectively . as a consequence ,",
    "the eabfs problem is easier than the corresponding ( non fault - tolerant ) spanner problem , and we regard this as an interesting hardness characterization .",
    "notice also that for all the significant values of @xmath14 and @xmath22 , the size of an @xmath6-spanner is @xmath39 , which essentially means that the vabfs problem is easier than the corresponding spanner problem as well .",
    "this bridge between the two problems is useful for building sparse @xmath40-vabfs structures by making use of the vast literature on additive @xmath40-spanners .",
    "for instance , the @xmath41-spanner of size @xmath42 given in @xcite , and the @xmath43-spanner of size @xmath44 given in @xcite , can be used to build corresponding vertex - fault - tolerant structures . another interesting implication arises for the multisource eabfs problem . indeed , given a set of multiple sources @xmath30 , the @xmath6-spanner of size @xmath45 can be used to build a multisource @xmath6-eabfs of size @xmath46 .",
    "this allows to improve , for @xmath47 , the multisource @xmath41-eabfs of size @xmath48 given in @xcite : indeed , it suffices to plug - in in our method the @xmath41-spanner of size @xmath42 given in @xcite .",
    "[ [ other - related - results . ] ] other related results .",
    "+ + + + + + + + + + + + + + + + + + + + + +    besides fault - tolerant ( approximate ) spt and bfs , there is a large body of literature on fault - tolerant short(est ) paths in graphs .",
    "a natural counterpart of the structures considered in this paper , as we have seen before , are the dso . for recent achievements on dso",
    ", we refer the reader to @xcite , and more in particular to @xcite , where single - source distances are considered .",
    "another setting which is very close in spirit to ours is that of _ fault - tolerant spanners_. in @xcite , for weighted graphs and any integer @xmath49 , the authors present a @xmath50-spanner resilient to @xmath51 vertex ( resp . , edge ) failures of size @xmath52 ( resp . , @xmath53 ) .",
    "this was later improved through a randomized construction in @xcite . on the other hand , for the unweighted case ,",
    "in @xcite the authors present a general result for building a @xmath54-spanner resilient to @xmath51 edge failures , by unioning an ordinary @xmath40-spanner with a fault - tolerant @xmath55-spanner resilient against up to @xmath51 edge faults .",
    "finally , we mention that in @xcite it was introduced the resembling concept of _ resilient spanners _ , i.e. , spanners such that whenever any edge in @xmath7 fails , then the relative distance increases in the spanner are very close to those in @xmath7 , and it was shown how to build a resilient spanner by augmenting an ordinary spanner .",
    "we start by introducing our notation . for the sake of brevity , we give it for the case of edge failures , but it can be naturally extended to the node failure case .    given a non - negatively real weighted , undirected , and 2-edge - connected graph @xmath7",
    ", we will denote by @xmath56 or @xmath57 the weight of the edge @xmath58 .",
    "we also define @xmath59 .",
    "given an edge @xmath60 , we denote by @xmath61 or @xmath62 ( resp . , @xmath63 or @xmath64 ) the graph obtained from @xmath7 by removing ( resp .",
    ", adding ) the edge @xmath65 .",
    "similarly , for a set @xmath66 of edges , @xmath67 ( resp . , @xmath68 ) will denote the graph obtained from @xmath7 by removing ( resp . , adding ) the edges in @xmath66 .",
    "we will call @xmath69 a shortest path between two vertices @xmath70 , @xmath71 its ( weighted ) length , and @xmath72 a spt of @xmath7 rooted at @xmath11 .",
    "whenever the graph @xmath7 and/or the vertex @xmath11 are clear from the context , we might omit them , i.e. , we will write @xmath73 and @xmath74 instead of @xmath75 and @xmath76 , respectively . when considering an edge @xmath77 of an spt we will assume @xmath78 and @xmath79 to be the closest and the furthest endpoints from @xmath11 , respectively .",
    "given an edge @xmath16 , we define @xmath80 , @xmath81 and @xmath82 to be , respectively , a shortest path between @xmath78 and @xmath79 , its length , and a spt in the graph @xmath18 .",
    "moreover , if @xmath83 is a path from @xmath78 to @xmath79 and @xmath84 is a path from @xmath79 to @xmath85 , with @xmath86 , we will denote by @xmath87 the path from @xmath78 to @xmath85 obtained by concatenating @xmath83 and @xmath84 .",
    "given @xmath7 , a vertex @xmath88 , and an edge @xmath89 , we denote by @xmath90 and @xmath91 the partition of @xmath92 induced by the two connected components of @xmath93 , such that @xmath90 contains @xmath11 and @xmath94 , and @xmath91 contains @xmath95 .",
    "then , @xmath96 will denote the _ cutset _ of @xmath65 , i.e. , the set of edges crossing the cut @xmath97 .    for the sake of simplicity we consider only edge weights that are strictly positive .",
    "however our entire analysis also extends to non - negative weights . throughout the rest of the paper",
    "we will assume that , when multiple shortest paths exist , ties will be broken in a consistent manner .",
    "in particular we fix a spt @xmath98 of @xmath7 and , given a graph @xmath99 and @xmath100 , whenever we compute the path @xmath101 and ties arise , we will prefer the edges in @xmath102 .",
    "we will also assume that if we are considering a shortest path @xmath101 between @xmath78 and @xmath79 passing through vertices @xmath103 and @xmath104 , then @xmath105 .",
    "@xmath107 compute a 3-`easpt ` of size @xmath4 using the algorithm in sect .",
    "3.1.1 of @xcite .",
    "@xmath13    first , we give a high - level description of our algorithm for computing a @xmath106-`easpt ` ( see algorithm  [ alg:1_epsilon_ftspt ] ) .",
    "we build our structure , say @xmath13 , by starting from an spt @xmath108 rooted at @xmath11 which is suitably augmented with at most @xmath109 edges in order to make it become a @xmath19-`easpt ` .",
    "then , we enrich @xmath13 incrementally by considering the tree edge failures in preorder , and by checking the disconnected vertices . when an edge @xmath65 fails and a vertex @xmath110 happens to be too stretched in @xmath111 w.r.t .",
    "its distance from @xmath11 in @xmath18 , we add a suitable subset of edges to @xmath13 , selected from the new shortest path to @xmath110 .",
    "this is done so that we not only adjust the distance of @xmath110 , but we also improve the stretch factor of a _ subset _ of its predecessors .",
    "this is exactly the key for the efficiency of our method , since altogether , up to a logarithmic factor , we maintain constant in an amortized sense the ratio between the size of the set of added edges and the overall distance improvement .",
    "let us now provide a detailed description of our algorithm . to build the initial @xmath19-`easpt",
    "` , it augments @xmath108 by making use of a _ swap algorithm _ devised in @xcite .",
    "more precisely , in that paper the authors were concerned with the problem of reconnecting in a best possible way ( w.r.t . to a set of distance criteria ) the two subtrees of an spt undergoing an edge failure , through a careful selection of a _ swap edge _ ,",
    "i.e. , an edge with an endvertex in each of the two subtrees . in particular",
    ", they show that if we select as a swap edge for @xmath60  with @xmath94 closer to the source @xmath11 than @xmath95  the edge that lies on a shortest path in @xmath18 from @xmath11 to @xmath95 , then the distances from the source towards all the disconnected vertices is stretched at most by a factor of 3 .",
    "therefore , a @xmath19-easpt of size at most @xmath21 can be obtained by simply adding to a spt rooted at @xmath11 a such swap edge for each corresponding tree edge , and interestingly this improves the @xmath19-easpt of size at most @xmath20 provided in @xcite",
    ".    then , our algorithm works in @xmath109 _ phases _ , where each phase considers an edge of @xmath108 w.r.t . to a fixed preorder of the edges ,",
    "say @xmath112 . in the @xmath113-th phase ,",
    "the algorithm considers the failure of @xmath114 , and when a vertex @xmath110 happens to be too stretched in @xmath13 w.r.t .",
    "@xmath115 , then we say that @xmath110 is _ bad _ for @xmath114 and we add a suitable subset @xmath116 of edges to @xmath13 .",
    "these edges are selected from @xmath117 and they always include the last edge of @xmath117 . we now show that this suffices to prove the correctness of the algorithm :    [ lemma:1_epsilon_ftspt_correctness ] the structure @xmath13 returned by the algorithm is a @xmath106-`easpt ` .",
    "let @xmath118 be the structure built by the algorithm just before a bad vertex @xmath110 for an edge @xmath114 is considered .",
    "assume by induction that , for every vertex @xmath85 in @xmath119 already considered in phase @xmath113 , we have @xmath120 .",
    "let @xmath121 be the last edge of @xmath117 and recall that @xmath51 is always added to @xmath118 .",
    "hence we have : @xmath122    it remains to describe the edge selection process and to analyze the size of our final structure .",
    "let @xmath123 be the initial @xmath19-`easpt ` structure .",
    "let us fix the failed edge @xmath60 and a single bad vertex @xmath110 for @xmath65 .",
    "we call @xmath124 the structure built by the algorithm just before @xmath110 is considered .",
    "let @xmath125 be the unique edge in @xmath126 .",
    "consider the subpath of @xmath127 going from @xmath78 to @xmath110 and let @xmath128 be its vertices , in order .",
    "we consider the set @xmath129 , we name its vertices @xmath130 with @xmath131 , in order and we let @xmath132 ( see figure  [ fig : tree_edge ] ) . we define @xmath133 .",
    "it follows from the definitions and from lemma  [ lemma:1_epsilon_ftspt_correctness ] that we have @xmath134 , @xmath135 for @xmath136 and @xmath137 .",
    "think of the edges in @xmath138 as being directed towards @xmath110 for a moment . in the following",
    "we will describe how to select the set @xmath116 of edges used by the algorithm .",
    "in particular , we will select @xmath139 edges entering into the last @xmath140 vertices in @xmath141 .",
    "this choice of @xmath116 will ensure that the overall decrease of the values @xmath142 in @xmath143 will be at least @xmath144 where @xmath145 denotes the @xmath0-th",
    "_ harmonic number_.     when a bad vertex @xmath110 for the failing edge @xmath65 is considered .",
    "bold edges belong to @xmath123 while the black path is @xmath127 . ]",
    "we exploit the fact that , after adding the set @xmath116 , each `` new value '' @xmath142 with @xmath146 , will not be larger than @xmath147 as we will show in the following .",
    "consider the sequence @xmath148 where @xmath149 .",
    "notice that the sequence is monotonically increasing from @xmath150 to @xmath151 .",
    "let @xmath152 be the largest index such that @xmath153 .",
    "notice that @xmath154 always exists as @xmath155 and that @xmath156 .",
    "we set @xmath157 so that the set @xmath116 is defined accordingly .",
    "let @xmath158 be the set of vertices for which an incoming edges has been added in @xmath116 .",
    "for every vertex @xmath159 we define the following path in @xmath143 : @xmath160 .",
    "notice that @xmath161 is entirely contained in @xmath143 .",
    "we define @xmath162 , and note that @xmath163 is an upper bound to the stretch of @xmath85 in @xmath143 .",
    "[ lemma : alpha_order ] for @xmath164 , @xmath165 .    by definition of @xmath154",
    ", we have @xmath166 .",
    "now we prove @xmath167 : @xmath168    we now lower - bound the overall decrease of the values @xmath163 s w.r.t . the corresponding @xmath142 s by using the following inequalities : @xmath169    where in the last but one step we used the well - known equality that for every @xmath170 , @xmath171 .",
    "the above selection procedure is repeated by the algorithm for every failed edge @xmath114 and for every corresponding bad vertex .",
    "we now focus on the @xmath113-th phase of the algorithm .",
    "let @xmath172 be the union of all the sets @xmath173 used when considering the bad vertices of the phase @xmath113 .",
    "moreover let @xmath174 and notice that @xmath175 . for a vertex @xmath176 ,",
    "let @xmath177 be the _",
    "path @xmath178 built by the algorithm , as defined above .",
    "let @xmath179 ( resp . ,",
    "@xmath180 ) be the structure built by the algorithm at the end ( resp . ,",
    "start ) of the phase @xmath113 and let @xmath181 be the number of new edges added during the phase @xmath113 . by summing over all the bad vertices for edge @xmath114 , we have :    [ lemma : stretch_decrease ] @xmath182 .",
    "now , let us define a function @xmath183 for every @xmath184 : @xmath185    the proofs of next three lemmas are postponed to the full version of the paper .",
    "[ lemma : stretch_bound ] for every @xmath176 we have @xmath186 .",
    "[ lemma : phi_ub ] for @xmath187 , @xmath188 .",
    "[ lemma : path_improves ] for @xmath176 , @xmath189 .",
    "we now prove the following :    [ lemma : stretch_delta ] @xmath190 .",
    "by lemmas  [ lemma : stretch_decrease][lemma : path_improves ] , and since the initial structure @xmath123 is a @xmath19-`easpt ` , we have : @xmath191    we now define a global potential function @xmath192 : @xmath193 for @xmath194 . notice that we trivially have @xmath195 .",
    "the structure @xmath13 returned by the algorithm is a @xmath106-`easpt ` of size @xmath196 .",
    "the fact that @xmath13 is a @xmath106-`easpt ` follows from lemma  [ lemma:1_epsilon_ftspt_correctness ] . concerning the size of @xmath13 ,",
    "since @xmath123 contains @xmath4 edges , we only focus on bounding the number @xmath197 of edges in @xmath198 . using lemma  [ lemma : stretch_delta ]",
    ", we can write : @xmath199    unfolding the previous recurrence relation we obtain : @xmath200 which we finally solve for @xmath201 to get @xmath202 .",
    "in this section we extend our previous @xmath106-`easpt ` structure to deal with vertex failures . in order to do",
    "so we will build a different subgraph @xmath123 having suitable properties that we will describe .",
    "then we will use the natural extension of algorithm  [ alg:1_epsilon_ftspt ] where we consider ( in preorder ) vertex failures instead of edge failures .",
    "we now describe the construction of @xmath123 and then argue how the previous analysis can be adapted to show the same bound on the size of @xmath13 .",
    "the structure @xmath123 is initially equal to @xmath108 and it is augmented by using a technique similar to the one shown in @xcite : the spt @xmath108 of @xmath7 is suitably decomposed into ancestor - leaf vertex - disjoint paths .",
    "then , for each path , an approximate structure is built .",
    "this structure will provide approximate distances towards any vertex of the graph when any vertex along the path fails .",
    "the union of @xmath108 with all those structures will form @xmath123 .    fix a path @xmath84 of the previous decomposition starting from a vertex @xmath203 , and",
    "let @xmath204 be the subtree of @xmath108 rooted at @xmath203 .",
    "moreover , let @xmath205 be a failing vertex , and let @xmath95 be the next vertex in @xmath84 .",
    "is not a leaf , as otherwise @xmath206 is already a spt of @xmath207 . ]",
    "we partition the vertices of the forest @xmath206 into three sets : ( i ) the _ up set _",
    "@xmath173 containing all the vertices of the tree rooted at @xmath11 , ( ii ) the _ down set _",
    "@xmath208 containing all the vertices of the tree rooted at @xmath95 , and ( iii ) the _ others set _",
    "@xmath209 containing all the remaining vertices ( see figure  [ fig : tree_vertex ] ) .     when a bad vertex @xmath110 for the failing vertex @xmath94 is considered .",
    "bold edges belong to @xmath123 while the black path is @xmath210 .",
    "notice that all @xmath211s belong to the down set @xmath208 . ]",
    "we want to select a set of edges to add to @xmath13 . in order to do so ,",
    "we construct a spt @xmath212 of @xmath207 and we imagine that its edges are directed towards the leaves .",
    "we select all the edges of @xmath213 that do not lead to a vertex in @xmath208 , plus the unique edge of @xmath214 that crosses the cut induced by the sets @xmath215 and @xmath208 .",
    "notice that @xmath206 contains all the paths in @xmath212 towards the vertices in @xmath173 , and that each vertex has at most one incoming edge in @xmath212 .",
    "this implies that the number of selected edges is at most @xmath216 .",
    "the above procedure is repeated for all the failing vertices of @xmath84 , in order . as the sets @xmath209 associated with the different vertices are disjoint we have that , while processing @xmath84 , at most @xmath217 edges are selected .",
    "we use the path decomposition described in @xcite that can be recursively defined as follows : given a tree , we select a path @xmath84 from the root to a leaf such that the removal of @xmath84 splits the tree into a forest where the size of each subtree is at most half the size of the original tree . we than proceed recursively on each subtree . using this approach ,",
    "the size of the entire structure @xmath123 can be shown to be @xmath5 @xcite .",
    "we now prove some useful properties of the structure @xmath123 .",
    "first of all , observe that , by construction and similarly to the edge - failure case , we immediately have :    [ lemma : vertex_stretch ] consider a failed vertex @xmath94 and another vertex @xmath218 .",
    "we have : ( i ) @xmath219 , and ( ii ) for @xmath220 , it holds @xmath221 .",
    "moreover , we also have the following ( proof postponed to the full version of the paper ) :    [ lemma : bad_vertices_down ] consider a failed vertex @xmath94 . during the execution of the vertex - version of algorithm  [ alg:1_epsilon_ftspt ] , every bad vertex @xmath110 for @xmath94 will be in @xmath208 .    at this point ,",
    "the same analysis given for the case of edge failures can be retraced for vertex failures as well .",
    "we point out that lemma  [ lemma : bad_vertices_down ] ensures that every bad every for @xmath94 is in the same subtree as @xmath95 . also notice that all the vertices @xmath211 s are , by definition , in the same subtree as well ( see figure  [ fig : tree_vertex ] ) .",
    "the above , combined with lemma  [ lemma : vertex_stretch ] ( i ) , is needed by the proof of lemma  [ lemma : stretch_bound ] , while lemma  [ lemma : vertex_stretch ] ( ii ) is used in the proof of lemma  [ lemma : stretch_delta ] .",
    "hence we have :    the vertex - version of algorithm  [ alg:1_epsilon_ftspt ] computes a @xmath106-`vaspt ` of size @xmath196 .",
    "in this section we turn our attention to the unweighted case , and we provide two polynomial - time algorithms that augment an @xmath6-spanner of @xmath7 so to obtain an @xmath6-`eabfs`/`vabfs ` .",
    "we present the algorithm for the vertex - failure case and show how it can be adapted to the edge - failure case .",
    "the algorithm first augments the structure @xmath123 computed so as explained in section  [ section : vaspt ] and then adds its edges to the @xmath6-spanner of @xmath7 .",
    "the structure @xmath123 is augmented as follows .",
    "the vertices of the bfs of @xmath7 rooted at @xmath11 are visited in preorder .",
    "let @xmath94 be the vertex visited by the algorithm and let @xmath208 be the set of vertices of the tree defined so as explained in section  [ section : vaspt ] w.r.t the path decomposition computed for @xmath123 .",
    "for every @xmath223 , the algorithm checks whether @xmath224 contains no vertex of @xmath225 and @xmath226 .",
    "if this is the case , then the algorithm augments @xmath123 with the edge of @xmath224 incident to @xmath110 .",
    "[ fact : node_failure_bfs ] for every vertex @xmath94 and every vertex @xmath227 such that @xmath210 contains a vertex in @xmath208 , let @xmath78 and @xmath79 be the first and last vertex of @xmath210 that belong to @xmath208 , respectively .",
    "we have @xmath228 and @xmath229 .",
    "[ th : from_spanner_towards_vabfs ] given an unweighted graph @xmath7 with @xmath0 vertices and @xmath8 edges , a source vertex @xmath88 , and an @xmath222-spanner for @xmath7 of size @xmath36 , the algorithm computes an @xmath222-`vabfs ` w.r.t .",
    "@xmath11 of size @xmath230 .",
    "now , we adapt the algorithm to prove a similar result for the @xmath6-`eabfs ` .",
    "the algorithm first augments a bfs tree @xmath108 of @xmath7 rooted at @xmath11 and then adds its edges to the @xmath6-spanner of @xmath7 .",
    "the tree @xmath108 is augmented by visiting its edges in preorder .",
    "let @xmath65 be the edge visited by the algorithm .",
    "for every @xmath231 , the algorithm checks whether @xmath232 contains no vertex of @xmath233 and @xmath234 .",
    "if this is the case , then the algorithm augments @xmath108 with the edge of @xmath232 incident to @xmath110 . in the full version of the paper",
    "it will be shown that the proof of theorem  [ th : from_spanner_towards_vabfs ] can be adapted to prove the following :    given an unweighted graph @xmath7 with @xmath0 vertices and @xmath8 edges , a source vertex @xmath88 , and an @xmath222-spanner for @xmath7 of size @xmath45 , the algorithm computes an @xmath222-`eabfs ` w.r.t . @xmath11 of size less than or equal to @xmath235 .",
    "g. ausiello , p.g .",
    "franciosa , g.f .",
    "italiano , and a. ribichini , on resilient graph spanners , _ proc . of the 21st european symp . on algorithms ( esa13 )",
    "_ , vol . 8125 of lecture notes in computer science , springer , 8596 , 2013 .",
    "g. braunschvig , s. chechik , and d. peleg , fault tolerant additive spanners , _ proc .",
    "of the 38th workshop on graph - theoretic concepts in computer science ( wg12 ) _ , vol .",
    "7551 of lecture notes in computer science , springer , 206214 , 2012 .",
    "s. chechik , m. langberg , d. peleg , and l. roditty , @xmath51-sensitivity distance oracles and routing schemes , _ proc .",
    "of the 18th european symp . on algorithms ( esa10 )",
    "6942 of lecture notes in computer science , springer , 8496 , 2010 .",
    "f. grandoni and v. vassilevska williams , improved distance sensitivity oracles via fast single - source replacement paths , _ proc . of the 53rd annual ieee symp . on foundations of computer science ( focs12 ) _ , 748757 , 2012 ."
  ],
  "abstract_text": [
    "<S> the resiliency of a network is its ability to remain _ effectively _ functioning also when any of its nodes or links fails . however , to reduce operational and set - up costs , </S>",
    "<S> a network should be small in size , and this conflicts with the requirement of being resilient . in this paper </S>",
    "<S> we address this trade - off for the prominent case of the _ broadcasting _ routing scheme , and we build efficient ( i.e. , sparse and fast ) _ fault - tolerant approximate shortest - path trees _ , for both the edge and vertex _ single - failure _ case . in particular , for an @xmath0-vertex non - negatively weighted graph , and for any constant @xmath1 , we design two structures of size @xmath2 which guarantee @xmath3-stretched paths from the selected source also in the presence of an edge / vertex failure . </S>",
    "<S> this favorably compares with the currently best known solutions , which are for the edge - failure case of size @xmath4 and stretch factor 3 , and for the vertex - failure case of size @xmath5 and stretch factor 3 . </S>",
    "<S> moreover , we also focus on the unweighted case , and we prove that an ordinary @xmath6-spanner can be slightly augmented in order to build efficient fault - tolerant approximate _ breadth - first - search trees_. </S>"
  ]
}