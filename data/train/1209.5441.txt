{
  "article_text": [
    "in this paper we study the _ predecessor problem _ on a _ static _ set @xmath3 of binary strings of length @xmath6 .",
    "it is known from recent results  @xcite that structures _ ` a la _ van emde boas ( e.g. , y - fast tries  @xcite ) using time @xmath8 are optimal among those using linear space .",
    "the lower bound proved in  @xcite has actually several cases , another one is realised , for instance , in exponential trees  @xcite .",
    "a very comprehensive discussion of the literature can be found in mihai ptracu s thesis  @xcite .",
    "albeit the match between upper and lower bounds settles up the problem in the worst case , there is a lot of space for improvement in two directions : first of all , if access to the original set @xmath3 ( as a sorted array ) is available , it is in principle possible to devise an index using _ sublinear _ additional space and still answer predecessor queries in optimal time ; second , one might try to improve upon the lower bound by making access time dependent on the structure of @xmath3 or on some property relating the query string @xmath1 to the set @xmath3 .    in this paper , we describe sublinear indices that provide significant improvements over previous bounds . ] . given a set @xmath3 ,",
    "we denote with @xmath0 and @xmath2 the predecessor and successor in @xmath3 of a query string @xmath1 , and let @xmath9 and @xmath10 .",
    "note that @xmath11 is small when @xmath1 is close to some element of @xmath3 , whereas @xmath12 is small when @xmath1 is far from at least one of @xmath7 . finally , let @xmath13 and @xmath14 be the maximum and minimum distance , respectively , between two consecutive elements of @xmath3 .    1 .",
    "we match the static worst - case search time @xmath15 of  @xcite , which was obtained using space @xmath16 , but our index requires just @xmath5 additional space ( and thus overall linear space ) .",
    "we improve exponentially over _ interval - biased search trees _",
    "@xcite , answering predecessor queries in time .",
    "our proofs are correct even replacing @xmath17 with @xmath18 , but the difference is immaterial as @xmath19 , and we like the duality with the previous bound better . ]",
    "@xmath20 , again using just @xmath5 additional bits of space .",
    "we improve exponentially over _ interpolation search _",
    "@xcite , answering predecessor queries in time @xmath21 , always using just @xmath5 additional bits of space .",
    "4 .   finally , with slightly more ( but still sublinear ) space we can exploit a _ finger _ @xmath22 to speed up our second result to @xmath23 , which is in some cases better than the bound reported in  @xcite , and improves exponentially over interval - biased search trees , which need time @xmath24  @xcite .",
    "we remark that combining the first two results we show that predecessor search can be performed in time @xmath25 using @xmath5 bits of additional space .",
    "our results are obtained starting from a refined version of _ fat binary search in a z - fast trie _",
    "@xcite in which the initial search interval can be specified under suitable conditions , confirming the intuition that fat binary search can be used as a very versatile building block for data structures .",
    "we use von neumann s definition and notation for natural numbers , and identify @xmath26 , so @xmath27 and @xmath28 is the set of all binary strings . if @xmath1 is a string , @xmath1 juxtaposed with an interval is the substring of @xmath1 with those indices ( starting from 0 ) .",
    "thus , for instance , @xmath29 is the substring of @xmath1 starting at position @xmath30 ( inclusive ) and ending at position @xmath31 ( exclusive )",
    ". we will write @xmath32 $ ] for @xmath33 $ ] .",
    "the symbol @xmath34 denotes prefix order , and @xmath35 is its strict version . given a prefix @xmath36 ,",
    "we denote with @xmath37 and @xmath38 the strings in @xmath39 that come before and after @xmath36 in lexicographical order ; in case they do not exist , we assume by convention that the expressions have value @xmath40 . all logarithms in this paper are binary and we postulate that @xmath41 whenever @xmath42 .    given a set @xmath3 of @xmath4 binary strings of length @xmath6 , we let @xmath43 where @xmath44 is the lexicographic order .",
    "predecessor / successor _ query is given by a string @xmath1 , and the answer is @xmath7 . in this paper , for the sake of simplicity we shall actually concentrate on predecessor search only , also because our algorithms actually return the _ rank _ of the predecessor in @xmath3 , and thus are in principle more informative ( e.g. , the successor can be immediately computed adding one to the returned index ) .",
    "we assume to be able to store a constant - time @xmath45-bit function on @xmath4 keys using @xmath46 bits for some constant @xmath47 : the function may return arbitrary values outside of its domain ( for practical implementations see  @xcite ) .",
    "we work in the standard ram model with a word of length @xmath6 , allowing multiplications , and adopt the full randomness assumption .",
    "note , however , that the dependence on multiplication and full randomness is only due to the need to store functions succinctly ; for the rest , our algorithms do not depend on them .",
    "we start by defining some basic notation for compacted tries .",
    "consider the compacted trie  @xcite associated with a prefix - free set of strings , this section provides results for arbitrary sets of prefix - free strings whose length is @xmath48 .",
    "] @xmath49 .",
    "( above ) a compacted trie , the related names , and the function @xmath50 of the associated z - fast trie .",
    "the skip interval for @xmath51 is @xmath52 $ ] .",
    "dashed lines show the end of the handles of internal nodes . ]    given a node @xmath51 of the trie ( see figure  [ fig : ztrie ] ) :    * the _ extent _ of @xmath51 , denoted by @xmath53 , is the longest common prefix of the strings represented by the external nodes that are descendants of @xmath51 ( extents of internal nodes are called _ internal extents _ ) ; * the _ compacted path _ of @xmath51 , denoted by @xmath54 , is the string labelling @xmath51 ; * the _ name _ of @xmath51 is the extent of @xmath51 deprived of its suffix @xmath54 . *",
    "the _ skip interval _ of @xmath51 is @xmath55 $ ] for the root , and @xmath56 $ ] for all other nodes .",
    "given a string @xmath1 , we let @xmath57 be the exit node of @xmath1 , that is , the only node @xmath51 such that @xmath58 is a prefix of @xmath1 and either @xmath59 or @xmath53 is not a prefix of @xmath1 .",
    "we recall a key definition from  @xcite :    [ def : twofattest ] the _ 2-fattest number _ of an interval @xmath60 of positive integers is the unique integer in @xmath60 that is divisible by the largest power of two , or equivalently , that has the largest number of trailing zeroes in its binary representation .",
    "the _ handle _",
    "@xmath61 of a node @xmath51 is the prefix of @xmath53 whose length is 2-fattest number in the skip interval of @xmath51 ( see figure  [ fig : ztrie ] ) .",
    "if the skip interval is empty ( which can only happen at the root ) we define the handle to be the empty string .",
    "we remark that if @xmath62 is 2-fattest in @xmath60 , it is also 2-fattest in every subinterval of @xmath60 that still contains @xmath62 .    given a prefix - free set @xmath49 , the _ z - fast trie on @xmath3 _ is a function @xmath50 mapping @xmath63 , for each internal node @xmath51 of the compacted trie associated with @xmath3 , and any other string to an arbitrary internal extent .",
    "the most important property of @xmath50 is that it makes us able to find very quickly the name of the exit node of a string @xmath1 using a fat binary search ( algorithm  [ algo : query ] ) .",
    "the basic idea is that of locating the longest internal extent @xmath64 that is a proper prefix of @xmath1 : the name of @xmath57 is then @xmath65 .",
    "the algorithm narrows down an initial search interval by splitting it on its 2-fattest number ( rather than on its midpoint ) . the version reported here ( which builds upon  @xcite ) has two main features : very weak requirements on @xmath50 , and the possibility of starting the search on a small interval .",
    "the latter feature will be the key in obtaining our main results .",
    "* input : * a nonempty string @xmath66 , an integer @xmath67 such that @xmath68 or @xmath69 is an internal extent of the compacted trie on @xmath3 , and an integer @xmath70 larger than the length of the longest internal extent of the compacted trie on @xmath3 that is a proper prefix of @xmath1 .",
    "* output : * the name of @xmath57    = = = = =     +    @xmath71     +    @xmath72 the 2-fattest number in @xmath60     +    @xmath73     +    @xmath74 @xmath75  move from @xmath60 to @xmath76     +    @xmath77  move from @xmath60 to @xmath78     +     +    @xmath79 @xmath80     +    @xmath81    [ lem : correctness ] let @xmath82 and @xmath83 ,  @xmath84 , @xmath85 ,  @xmath86 be the internal extents of the compacted trie that are _ proper _ prefixes of @xmath1 , ordered by increasing length .",
    "let @xmath60 be the interval maintained by algorithm  [ algo : query ] . before and after each iteration the following invariants are satisfied :    1 .",
    "[ enu : lema ] @xmath87 for some @xmath88 ; 2 .",
    "[ enu : lemb ] @xmath89 .",
    "thus , at the end of the loop , @xmath90 .",
    "( [ enu : lema ] ) the fact that @xmath87 for some @xmath88 is true at the beginning , and when @xmath30 is reassigned ( say , @xmath91 ) it remains true : indeed , since @xmath64 is an internal extent , @xmath92 and @xmath93 , @xmath94 for some @xmath95 .",
    "( [ enu : lemb ] ) by ( [ enu : lema ] ) , @xmath30 is always the length of some @xmath96 , so @xmath97 at the beginning , and then it can only decrease ; thus , @xmath60 contains the concatenation of some contiguous skip intervals of the proper ancestors of @xmath57 up to the skip interval of @xmath57 ( which may or may not be partially included itself ) .",
    "now , assume by contradiction that when we update @xmath31 there is a node @xmath51 with extent @xmath53 which is a proper prefix of @xmath1 of length @xmath62 or greater .",
    "since @xmath62 is 2-fattest in @xmath60 , it would be 2-fattest in the skip interval of @xmath51 ( as the latter is contained in @xmath60 ) , so @xmath98 would be the handle of @xmath51 , and @xmath50 would have returned @xmath53 , which satisfies @xmath99 and @xmath100 , contradicting the fact that we are updating @xmath31 .",
    "we conclude that the invariant @xmath101 is preserved .    ' '' ''    [ thm : correctnessfbs ] algorithm  [ algo : query ] completes in at most @xmath102 iterations , returning the name of @xmath57 .",
    "we first prove the bound on the number of iterations .",
    "note that given an interval @xmath103 in which there is at most one multiple of @xmath104 , the two subintervals @xmath105 and @xmath106 , where @xmath62 is the 2-fattest number in @xmath103 , contain both at most one multiple of @xmath107 ( if one of the intervals contained two such multiples , there would be a multiple of @xmath104 inbetween , contradicting our assumption ) ; this observation is _ a fortiori _ true if we further shorten the intervals .",
    "thus , we can not split on a 2-fattest number more than @xmath108 times , because at that point the condition implies that the interval has length at most one .",
    "but clearly an interval of length @xmath109 contains at most one multiple of @xmath110 , which shows that the algorithm iterates no more than @xmath102 times .    finally , if @xmath111 then @xmath112 is the name of @xmath57 . otherwise , @xmath57 is the root ( hence the special case in algorithm  1 ) .    ' '' ''    note that finding the 2-fattest number in an interval requires the computation of the most significant bit$ ] is @xmath113 .",
    "] , but alternatively starting from the interval @xmath114 $ ] one can set @xmath115 ( this can be computed trivially in time @xmath116 ) and then check , for decreasing @xmath108 , whether @xmath117 : when the test is satisfied , there is exactly one multiple of @xmath104 in the interval , namely @xmath118 , which is also 2-fattest .",
    "this property is preserved by splitting on @xmath62 and possibly further shortening the resulting interval ( see the first part of the proof of theorem  [ thm : correctnessfbs ] ) , so we can just continue decreasing @xmath108 and testing , which requires still no more than @xmath119 iterations .",
    "a z - fast trie ( i.e. , the function @xmath50 defining it ) can be implemented in different ways ; in particular , for the purpose of this paper , we show that if constant - time access to the elements of @xmath3 in sorted order is available , then the function @xmath50 describing a z - fast trie can be implemented using additional @xmath5 bits .",
    "we will use the notation @xmath120 $ ] ( @xmath121 ) for the @xmath108-th element of @xmath3 .",
    "we need two key components :    1 .",
    "a constant - time function @xmath122 mapping the handles to the length of the name of the node they are associated with ( i.e. , @xmath123 for every internal node @xmath51 ) ; 2 .",
    "a _ range locator_a data structure that , given the name of a node @xmath58 , returns the interval of keys that are prefixed by @xmath58 ; more precisely , it returns the smallest ( @xmath124 ) and largest index ( @xmath125 , respectively ) in @xmath3 of the set of strings prefixed by @xmath58 .    the function @xmath122 can be implemented in constant time using @xmath5 bits , and there are constant - time range locators using @xmath5 bits  @xcite .",
    "now , to compute @xmath126 for a given handle @xmath127 , we consider the candidate node name @xmath128 and return the longest common prefix of @xmath129 $ ] and @xmath130 $ ] .",
    "if @xmath127 is actually a handle , the whole procedure clearly succeeds and we obtain the required information ; otherwise , we will be returning some unpredictable internal extent ( unless @xmath131 , but this case can be easily fixed ) . summing up ,",
    "[ th : zfast ] if access to the set @xmath3 is available , the z - fast trie can be implemented in constant time using additional @xmath5 bits of space .",
    "this function enjoys the additional property that , no matter which the input , it will always return an extent .",
    "we also notice that using the same data it is also easy to implement a function that returns a node extent given a node name :    let @xmath36 be a node name .",
    "then @xmath132 ( the extent of the node named @xmath36 ) can be computed in constant time as the longest common prefix of @xmath129 $ ] and @xmath130)$ ] .",
    "given a set @xmath133 , we want to be able to check in constant time and little space that a prefix @xmath36 either belongs to @xmath134 , or is not a prefix of a string in @xmath3 .",
    "assume that we have a function @xmath62 defined on @xmath134 and returning , for each @xmath135 , the length of the name of the exit node of @xmath36 .",
    "our key observation is that a range locator , combined with access to the array @xmath3 , can be used to `` patch '' @xmath62 so that it returns a special value @xmath40 outside of @xmath136 :    [ th : pref ] let @xmath137 and @xmath138 be a constant - time function mapping @xmath135 to @xmath139 . if access to the set @xmath3 is available , using an additional constant - time range locator we can extend @xmath62 to a constant - time function @xmath140 such that @xmath141 for all @xmath142 , and @xmath143 for all @xmath144 .    to compute @xmath145 for a @xmath146 we proceed as follows :    1 .",
    "we compute the candidate length @xmath147 of the name of @xmath148 ; 2 .",
    "if @xmath149 and @xmath150 we return @xmath151 , otherwise we return @xmath40 .    clearly ,",
    "if @xmath135 , by definition @xmath152 , and we compute correctly the extent of @xmath148 , so we return @xmath153 . on the other hand ,",
    "if @xmath154 it can not be the prefix of an element of @xmath3 , so in the last step we certainly return @xmath40 .    ' '' ''",
    "our purpose is now to combine theorem  [ th : zfast ] and  [ th : pref ] to answer efficiently predecessor queries in a way that depends on the distance between the query string and its predecessor and successor .",
    "first of all , it is clear that we can easily compute the index of the predecessor of a string if its exit node is known ( e.g. , by fat binary search ) :    ( @xmath155 , @xmath156 ) given a string @xmath1 and the length @xmath109 of the name of @xmath57 , we define the constant - time function @xmath157 as follows :    * if @xmath158 , or if the first bit of @xmath1 at which @xmath1 and @xmath159 differ is a @xmath160 , the index of the predecessor of @xmath1 is @xmath161 ( we use the convention that @xmath162 is returned if no predecessor exists ) ; * otherwise , the index of the predecessor of @xmath1 is @xmath163 .",
    "we denote with @xmath164 the predecessor index computed by running algorithm  [ algo : query ] ( with inputs @xmath1 , @xmath30 and @xmath31 ) to obtain the name of @xmath57 and then invoking @xmath155 .",
    "we remark that the definition above implies that predecessor search ( by means of @xmath165 ) is possible in time @xmath8 using an index of @xmath5 bits .",
    "the rest of this section is devoted at making the computation of the predecessor of @xmath1 more efficient by storing selected prefixes of strings in @xmath3 to reduce significantly the initial search interval of algorithm  [ algo : query ] ( i.e. , to increase the parameter @xmath30 ) .",
    "it turns out that this pre - computation phase does dramatically reduce the number of steps required , making them depend on the distance between the query string @xmath1 and its predecessors and successors .",
    "more precisely , for a given set @xmath3 and a string @xmath1 , let us define @xmath166 if only @xmath0 ( equivalently for @xmath2 ) is defined , we let @xmath167 .",
    "we call @xmath11 ( respectively , @xmath17 ) the _ short distance _",
    "( _ long distance _ ) between @xmath1 and @xmath3 .",
    "we will devise two distinct predecessor algorithms whose performance depend on the short and on the long distance between the query string and the queried set @xmath3 : both algorithms use the setup described in theorem  [ th : pref ] but with a different choice of the function @xmath168 .    before proceeding with the presentation of the algorithms",
    ", it is worth observing the following lemmata :    [ lemma : hitpref ] let @xmath1 be a string , @xmath169 and @xmath170 .",
    "then either @xmath36 or @xmath37 or @xmath38 belong to @xmath136 .",
    "suppose that neither @xmath36 nor @xmath37 nor @xmath38 belong to @xmath136 ; there are @xmath171 strings prefixed by @xmath36 ( @xmath1 being one of them ) , and the same is true of @xmath38 and @xmath37 .",
    "so , the element @xmath172 that minimises @xmath173 ( that will be one of @xmath0 or @xmath2 ) is such that @xmath174 .",
    "hence @xmath175 , so @xmath176 , contradicting the hypothesis .    ' '' ''    [ lemma : shortinprefs ] let @xmath1 be a string ; if @xmath36 is a prefix of @xmath1 such that @xmath177 and @xmath178 , then @xmath1 is either smaller or larger than all the elements of @xmath3 that have @xmath36 as prefix .",
    "suppose that there is some prefix @xmath179 of @xmath1 longer than @xmath180 and that there are two elements of @xmath3 having @xmath36 as prefix and that are smaller and larger than @xmath1 , respectively ; in particular , @xmath36 is also a prefix of @xmath2 and @xmath0 .",
    "since @xmath36 is the prefix of less than @xmath181 strings , @xmath182 ; but @xmath183 , so we have a contradiction .    ' '' ''      our first improvement allows for the computation time to depend on short distances , using techniques inspired by  @xcite .",
    "to this aim , let us consider the following set of prefixes : @xmath184 to store the function @xmath168 needed by theorem  [ th : pref ] , we define a subset of @xmath134 : @xmath185 in other words , for every node we take the shortest string in @xmath134 that sits between the name and the extent of the node ( if any ) .",
    "we can map every element @xmath186 to @xmath187 in space @xmath5 as @xmath188 .",
    "then , we map every @xmath135 to smallest @xmath108 such that @xmath189 .",
    "this map takes @xmath190 bits . to compute @xmath151 , we first compute the index @xmath108 using the second map , and then query the first map using @xmath191 .    algorithm  [ algo : pred - short ] probes prefixes of decreasing lengths in the set @xmath192 .",
    "more precisely , at each step we will probe a prefix @xmath36 of length @xmath193 of the query string @xmath1 ; if this probe fails , then @xmath37 and finally @xmath38 are probed ( if they exist ) .",
    "if we succeed in the first case , we have found a valid prefix of @xmath1 in the trie , and we can proceed with a fat binary search .",
    "otherwise , no element is prefixed by @xmath1 , and if by any chance an element is prefixed by @xmath38 or @xmath37 we can easily locate its predecessor .",
    "* input : * a nonempty string @xmath194    * output : * the index @xmath108 such that @xmath120=x^-$ ]    = = = = =     +    @xmath195     +    @xmath196     +    @xmath197     +    @xmath198     +    @xmath199     +    @xmath200     +    @xmath93 @xmath201  we found a long extent     +    @xmath157  we exit at the node of name @xmath202     +     +    @xmath203     +    @xmath199 @xmath204  @xmath0 is the predecessor of @xmath37     +    @xmath205     +    @xmath199 @xmath206  @xmath0 is the successor of @xmath38     +     +    @xmath165  standard search ( we found no prefix long enough )    more precisely , it turns out that :    algorithm  [ algo : pred - short ] returns the predecessor of @xmath1 in time @xmath15 , and requires an index of @xmath207 bits of space ( in addition to the space needed to store the elements of @xmath3 ) .",
    "first we show that the algorithm is correct .",
    "if we exit at the first return instruction , @xmath64 is a valid extent and a prefix of @xmath1 , so we start correctly a fat binary search . at the second return instruction we know the @xmath202 is the name node @xmath51 , but the extent of @xmath51 is not a prefix of @xmath1 , so @xmath1 exits exactly at @xmath51 , and again we return the correct answer . if @xmath37 is a valid prefix of some element of @xmath3 , but @xmath36 is not , then the predecessor of @xmath36 is the predecessor of the least element prefixed by @xmath37 , which we return ( analogously for @xmath38 ) .    by lemma  [ lemma : hitpref ] , we will hit a prefix in our set @xmath134 as soon as @xmath208 , that is , @xmath209 . if @xmath108 is the smallest integer satisfying the latter condition , then @xmath210 , so @xmath211 , which guarantees that the fat binary search , which starts from an extent of length at least @xmath212 , will complete in time @xmath213 ( see theorem  [ thm : correctnessfbs ] ) .",
    "if we exit from the loop , it means that @xmath209 implies @xmath214 , hence @xmath215 , so the last fat binary search ( that takes @xmath8 steps to complete ) is still within our time bounds .    ' '' ''      we now discuss algorithm  [ algo : pred - long ] , whose running time depends on long distances .",
    "let @xmath134 be the set obtained by `` cutting '' every internal extent @xmath53 to the length of the smallest power of @xmath216 ( if any ) in the skip interval of @xmath51 ; more precisely : @xmath217 \\text { and $ k$ is the smallest possible}\\,\\}.\\ ] ] where @xmath51 ranges over all nodes .",
    "since this time we have at most one prefix per node , @xmath218 , so the function @xmath62 required by theorem  [ th : pref ] can be stored in @xmath5 bits .",
    "algorithm  [ algo : pred - long ] keeps track of the length @xmath30 of an internal extent that is known to be a prefix of @xmath1 . at each step",
    ", we try to find another extent by probing a prefix of @xmath1 whose length is the smallest power of two larger than @xmath30 .",
    "because of the way the set @xmath134 has been built , we can miss the longest prefix length at most by a factor of two .",
    "[ thm : pred - long ] algorithm  [ algo : pred - long ] returns the predecessor of an input string @xmath1 in time @xmath20 , and requires an index of @xmath219 bits of space ( in addition to the space needed to store the elements of @xmath3 ) .",
    "first we show that the algorithm is correct .",
    "it can be easily seen that at each step @xmath30 is either 0 or the length of an internal extent that is a prefix of @xmath1 . moreover , if there is an internal extent of length at least @xmath220 that is a prefix of @xmath1 , then @xmath221 , so we if we exit at the first return instruction , the fat binary search completes correctly .",
    "if @xmath222 , we know that @xmath202 is the name of a node @xmath51 ( because @xmath223 is a union of consecutive skip intervals , and the smallest power of two in such @xmath223 is a fortiori the smallest power of two in a skip interval ) : if @xmath1 is smaller than the smallest leaf under @xmath51 ( or larger than the largest such leaf ) , we immediately know the predecessor and can safely return with a correct value .",
    "the return instruction at the exit of the loop is trivially correct .",
    "observe that when @xmath224 either the string @xmath225 will not be in @xmath136 ( because of lemma  [ lemma : shortinprefs ] ) and thus @xmath226 , or @xmath1 will be larger ( or smaller ) than every element of @xmath3 prefixed by @xmath202 , which will cause the loop to be interrupted at one of the last two if instructions .",
    "since @xmath220 gets at least doubled at each iteration , this condition will take place in at most @xmath227 iterations ; moreover , @xmath228 ( because there is always a power of 2 in the interval @xmath229 $ ] ) , so the fat binary search in the first return will take no more than @xmath230 . if the loop exits naturally , then there is a prefix of @xmath1 belonging to @xmath136 and longer than @xmath231 , hence @xmath232 and the fat binary search at the end of the loop will end within the prescribed time bounds .    ' '' ''    * input : * a nonempty string @xmath194    * output : * the index @xmath108 such that @xmath120=x^-$ ]    = = = = =     +    @xmath233     +    @xmath234     +    @xmath235     +    @xmath236     +    @xmath237 @xmath238  we obtained the longest possible prefix     +    @xmath239     +    @xmath129\\geq x$ ] @xmath240     +    @xmath130<x$ ] @xmath241     +    @xmath242  this is a valid extent     +     +    @xmath243    finally , we can combine our improvements for short and long distances , obtaining an algorithm that is efficient when the input @xmath1 is either very close to or very far from @xmath0 or @xmath2 :    it is possible to compute the predecessor of a string @xmath1 in a set @xmath3 in time @xmath25 , using an index that requires @xmath219 bits of space ( in addition to the space needed to store the elements of @xmath3 ) .",
    "we can apply theorem  [ thm : pred - long ] to improve exponentially over the bound described in  @xcite , which gives an algorithm whose running time depends on the largest and smallest distance between the elements of @xmath3 .",
    "more precisely , let @xmath13 and @xmath14 be , respectively , the largest and smallest distance between two consecutive elements of @xmath3 .",
    "[ cor : deltadelta ] using an index of @xmath5 bits , it is possible to answer predecessor queries in time @xmath21 .",
    "see the appendix .",
    "we conclude with a generalisation of long - distance search that builds on previous results  @xcite . using @xmath244 bits ( for any @xmath245 )",
    "it is possible to answer _ weak prefix search _ queries in constant time .",
    "a weak prefix search query takes a prefix @xmath36 and returns the leftmost and rightmost index of elements of @xmath3 that are prefixed by @xmath36 ; if no such element exists , the results are unpredictable ( hence the `` weak '' qualifier ) , but a single access to the set @xmath3 is sufficient to rule out this case and always get a correct result .",
    "thus , we will be able to compute @xmath246 , @xmath247 and @xmath248 on arbitrary elements of @xmath136 in constant time . as a consequence ,",
    "also @xmath157 can be extended so to return a correct value for every @xmath109 such that @xmath249 .",
    "the basic idea of algorithm  [ algo : finger ] is that of using a _ finger _",
    "@xmath22 to locate quickly an extent @xmath64 that is a prefix of @xmath1 with the guarantee that @xmath250 .",
    "the extent is then used to accelerate an algorithm essentially identical algorithm  [ algo : pred - long ] , but applied to a reduced universe ( the strings starting with @xmath64 ) ; the running time thus becomes @xmath251 .    *",
    "input : * a nonempty string @xmath194 and a @xmath22 such that @xmath252    * output : * the index @xmath108 such that @xmath120=x^-$ ]    = = = = =     +    @xmath253     +    @xmath254     +    @xmath255 @xmath256  @xmath257     +    @xmath258 @xmath157  @xmath1 exits between @xmath259 and @xmath64     +    @xmath233  now @xmath93 and @xmath250     +    @xmath260     +    @xmath261     +    @xmath262     +    @xmath263 @xmath264     +    @xmath129\\geq x$ ] @xmath240     +    @xmath130<x$ ] @xmath241     +    @xmath265  this is a valid extent     +     +    @xmath266    [ th : finger ] algorithm  [ algo : finger ] returns the predecessor of an input string @xmath1 given a finger @xmath22 , with @xmath252 , in time @xmath23 using an index of @xmath244 bits of space , for any @xmath245 ( in addition to the space needed to store the elements of @xmath3 ) .",
    "see the appendix .",
    "10 [ 1]`#1 `    andersson , a. , thorup , m. : dynamic ordered sets with exponential search trees .",
    "j. assoc .",
    "54(3 ) , 140 ( 2007 )    belazzougui , d. , boldi , p. , pagh , r. , vigna , s. : monotone minimal perfect hashing : searching a sorted table with @xmath267 accesses . in : soda 09 .",
    "acm press ( 2009 )    belazzougui , d. , boldi , p. , pagh , r. , vigna , s. : theory and practise of monotone minimal perfect hashing . in : alenex 2009 .",
    "132144 . siam ( 2009 )    belazzougui , d. , boldi , p. , pagh , r. , vigna , s. : fast prefix search in little space , with applications . in : de",
    "berg , m. , meyer , u. ( eds . ) algorithms - esa 2010 .",
    "lecture notes in computer science , vol . 6346 , pp .",
    "427438 . springer ( 2010 )    belazzougui , d. , boldi , p. , vigna , s. : dynamic z - fast tries . in : chvez , e. , lonardi , s. ( eds . ) spire 2010 .",
    "lecture notes in computer science , vol . 6393 , pp .",
    "springer ( 2010 )    bille , p. , landau , g.m . ,",
    "raman , r. , sadakane , k. , satti , s.r . , weimann , o. : random access to grammar compressed strings . in : soda  11 ( 2011 )    bose , p. , doueb , k. , dujmovic , v. , howat , j. , morin , p. : fast local searches and updates in bounded universes . in : cccg2010 .",
    "pp . 261264 ( 2010 )    demaine , e.d . ,",
    "jones , t.r .",
    ", ptracu , m. : interpolation search for non - independent data . in : munro , j.i .",
    "( ed . ) soda  04 .",
    "529530 ( 2004 )    knuth , d.e .",
    ": the art of computer programming . addison  wesley ( 1973 )    ptracu , m. : lower bound techniques for data structures . ph.d .",
    "thesis , massachusetts institute of technology , dept . of electrical engineering and computer science ( 2008 )",
    "ptracu , m. , thorup , m. : time - space trade - offs for predecessor search . in : stoc  06 .",
    "acm press ( 2006 )    ptracu , m. , thorup , m. : randomization does not help searching predecessors . in : soda 07 .",
    "siam , philadelphia , pa , usa ( 2007 )    willard , d.e . :",
    "log - logarithmic worst - case range queries are possible in space @xmath268 .",
    "inform .  process .",
    "17(2 ) , 8184 ( 1983 )",
    "( of corollary  [ cor : deltadelta ] ) we use a standard `` universe reduction '' argument , splitting the universe @xmath269 by grouping strings sharing the most significant @xmath270 bits .",
    "each subuniverse @xmath271 has size @xmath272 , and we let @xmath273 . using a constant - time prefix - sum data structure",
    "we keep track of the rank in @xmath3 of the smallest element of @xmath274 , and we build the indices that are necessary for algorithm  [ algo : pred - long ] for each @xmath274 ( seen as a set of strings of length @xmath275 ) .",
    "thus , we can answer a query @xmath1 in time @xmath276 , where @xmath271 is the subuniverse containing @xmath1 .",
    "now note that @xmath277 , and that @xmath278 ( unless @xmath1 the smallest or the largest element of @xmath274 , but this case can be dealt with in constant time ) .",
    "the bound follows immediately .",
    "( of theorem  [ th : finger ] ) first we show that the algorithm is correct .",
    "if we exit at the first return instruction , @xmath259 is not in @xmath136 , which implies that @xmath0 is prefixed by @xmath279 , and thus the output is correct . if we exit at the second return instruction , @xmath1 exits at the same node as @xmath280 .",
    "otherwise , @xmath64 is an extent that is a proper prefix of @xmath1 , and the remaining part of the algorithm is exactly algorithm  [ algo : pred - long ] applied to the set of strings of @xmath3 that are prefixed by @xmath64 , with @xmath64 removed ( the algorithm is slightly simplified by the fact that we can test membership to @xmath136 and compute extents for every prefix ) .",
    "correctness is thus immediate .",
    "all operations are constant time , except for the last loop .",
    "note that as soon as @xmath281 the loop ends or a prefix of @xmath1 is found ( as in the proof of algorithm  [ algo : pred - long ] ) , and this requires no more than @xmath282 iterations ; moreover , @xmath228 ( because there is always a power of 2 in the interval @xmath229 $ ] ) , so the fat binary search in the first return will take no more than @xmath283 . if the loop exits naturally , then there is a prefix @xmath284 of @xmath1 belonging to @xmath136 and longer than @xmath285 , hence by lemma  [ lemma : shortinprefs ] , @xmath286 ; the fat binary search at the end takes time latexmath:[$o(\\log ( w-(a+|e|)))=o(\\log ( w-|e'|))=o(\\log ( w/2 -"
  ],
  "abstract_text": [
    "<S> a _ predecessor ( successor ) search _ finds the largest element @xmath0 smaller than the input string @xmath1 ( the smallest element @xmath2 larger than or equal to @xmath1 , respectively ) out of a given set @xmath3 ; in this paper , we consider the static case ( i.e. , @xmath3 is fixed and does not change over time ) and assume that the @xmath4 elements of @xmath3 are available for inspection . </S>",
    "<S> we present a number of algorithms that , with a small additional index ( usually of @xmath5 bits , where @xmath6 is the string length ) , can answer predecessor / successor queries quickly and with time bounds that depend on different kinds of _ distance _ , improving significantly several results that appeared in the recent literature . </S>",
    "<S> intuitively , our first result has a running time that depends on the distance between @xmath1 and @xmath7 : it is especially efficient when the input @xmath1 is either very close to or very far from @xmath0 or @xmath2 ; our second result depends on some global notion of distance in the set @xmath3 , and is fast when the elements of @xmath3 are more or less equally spaced in the universe ; finally , for our third result we rely on a _ finger _ </S>",
    "<S> ( i.e. , an element of @xmath3 ) to improve upon the first one ; its running time depends on the distance between the input and the finger . </S>"
  ]
}