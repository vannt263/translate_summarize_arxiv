{
  "article_text": [
    "program comprehension is an essential part of software evolution and software maintenance : software that is not comprehended can not be changed @xcite .    among the earliest results",
    "are the two classic theories of program comprehension , called _ top - down _ and _ bottom - up _ theories @xcite .",
    "bottom - up theory : consider that understanding a program is obtained from source code reading and then mentally chunking or grouping the statements or control structures into higher abstract level , i.e. from bottom up .",
    "such information is further aggregated until high - level abstraction of the program is obtained .",
    "chunks are described as code fragments in programs .",
    "available literature shows chunks to be used during the bottom - up approach of software comprehension .",
    "chunks vary in size .",
    "several chunks can be combined into larger chunks @xcite . on the other hand ,",
    "the top - down approach starts the comprehension process with a hypothesis concerning a high - level abstraction , which then will be further refined , leading to a hierarchical comprehension structure .",
    "the understanding of the program is developed from the confirmation or refutation of hypotheses .",
    "an important task in program comprehension is to understand where and how the relevant concepts are located in the code .",
    "concept location is the starting point for the desired program change .",
    "concept location means a process where we assume that programmer understands the concept of the program domain , but does not know where is it located within the code .",
    "all domain concepts should map onto one or more fragments of the code .",
    "in other words , process of concept location is the process that finds that code - fragment @xcite .",
    "developers who are new to a project know little about the identifiers or comments in the source code , but it is likely that they have some knowledge about the problem domain of the software . in this paper , we present a new way of program comprehension that is based on naming of identifiers . when trying to understand the source code of a software system , developers usually start by locating familiar concepts in the source code .",
    "keyword search is one of the most popular methods for this kind of task , but the success is strictly tied to the quality of the user queries and the words used to construct the identifiers and comments .",
    "we present a way how to create a domain vocabulary automatically as a result of source code analysis .",
    "we classify the parts of speech and measure their occurrence in the source code .",
    "domain level knowledge is important when programmers attempt to understand a program .",
    "programmer inspects source code structure that is directed by identifiers .",
    "the quality and the `` orthogonality '' of the identifiers in the source code affects the time of program comprehension .",
    "next kinds of quality could be measured :    1 .",
    "percentage of _ fullword _ identifiers , 2 .",
    "percentage of _ abbreviations _ and _ unrecognized _ identifiers , 3 .",
    "percentage of _ domain terms _ identified in the application .",
    "percentage of full word identifiers is very important in the case of absence of documentation .",
    "the first two qualities could be derived directly from the source code toward common vocabulary .",
    "we do nt need any additional domain data source to get relevant results .",
    "the third quality is not derived directly .",
    "we need to make measurements in order to obtain domain vocabulary .",
    "usually we do nt have domain terms of the analysed software product .",
    "the question is : _ how can we create the vocabulary of terms for a particular domain ? _ in this paper we propose a way to derive it automatically .",
    "nowadays , the companies are affected by employee fluctuation , especially in the it sector .",
    "each company has ongoing projects in the phase of developing or maintenance .",
    "new developer participating in the project has to understand project to solve the assigned task .",
    "domain terms are usually in the specification .",
    "the transition from specification to implementation is bound usually to the transformation of terms .",
    "for example , if the specification contains word * car * , that word could be changed to word * vehicle * in the implementation phase . in spite of the fact that the word * vehicle * is a hypernym of the word * car * , we can not find the word `` vehicle '' by brute force through searching by keywords .",
    "that is the reason for looking for some statistical evidence that car is a vehicle .",
    "it means that there exists `` gap '' in the meanings between the words used in specification and implementation .",
    "our goal is to eliminate partly `` this kind '' of gap .",
    "developers of new software products may put another question : _ what kind of parts of speech is usually used for a particular category of identifiers ? _ we can measure it directly from the source code .",
    "we can also find , if the rules are domain specific or generally applicable .",
    "full word identifiers provide better comprehension then single letters or abbreviations @xcite .",
    "it is the reason why we want to provide a tool for measurement of this aspect of program quality .",
    "we use the wordnet database of words to identify the potential domain terms .",
    "we apply our tool to well - known open - source projects .",
    "they belong to two domains : domain of application servers and domain of web frameworks .",
    "each project consists of a set of source code files .",
    "we examine every source file separately . based on information",
    "we have got by source files analysis we make measurements for the whole project .",
    "our measurements follow the scheme shown on the fig . [",
    "fig : architecture ] .    1 .",
    "first , we parse every source file using java compiler .",
    "we build a tree structure of nodes .",
    "each node belongs to one of the next types : _ class _ , _ method _ , _ method parameter _ or _",
    "class variable_. then we process the names of each identified node .",
    "name processing consists of splitting the name according to common naming conventions .",
    "for example , `` setvalue '' is split into `` set '' and  value \" words .",
    "after then we put all identified words into a table .",
    "2 .   as a second step",
    ", we produce statistics for the source file .",
    "we examine which word belongs to class variable , method parameter , method or class and also we try to assign part of speech to the words .",
    "after source files analysis mentioned in previous steps we produce statistics for the whole project : we build a set of words containing all words used in the source files , and also we build a set of words used in the variables ( class variables and method parameters ) , methods and classes .",
    "the set of words used in project will represent the software vocabulary for the particular project .",
    "the software domain vocabulary represents the intersection of all software vocabularies of all software products of the same domain .",
    "not all identified words are suitable candidates for the inclusion into software domain vocabulary .",
    "it is expected to apply filters in a process of source code analysis .",
    "so , the reason behind filtering is to eliminate terms that are irrelevant regarding the domain . as a final result",
    "we obtain a set of words ordered by occurrence .",
    "we obtain domain vocabulary as well as potential domain vocabulary ( words are not identified in all measured software products ) .",
    "as was mentioned in the previous section , the categorization in accordance to the parts of speech is expected in the experiment .",
    "it induces another problem : one word can belong to more parts of speech ( e.g. `` good '' is adjective as well as noun ) .",
    "wordnet provides help in disambiguation and classification of words .",
    "wordnet provides a database of the most used words in the parts of speech .",
    "as was mentioned earlier , we have developed a tool to measure results in the graph , tabular and textual form .",
    "the tool s input is the project s source code . to present it we decide to inspect software products of two application domains :    * java ee application server , * web framework .",
    "we have selected next java ee application servers :    * jonas 4.10.3 ( http://jonas.ow2.org/ ) , * jboss 5.0.1.ga ( http://www.jboss.org/jbossas ) , * glassfish server v2.1 ( https://glassfish.dev.java.net/ ) .    and web frameworks :    * google web toolkit 1.5.3 ( gwt ) ( http://code.google.com/intl/sk/webtoolkit/ ) , * echo2 v2.1 ( http://echo.nextapp.com/site/echo2 ) , * tapestry 5.0.18 ( http://tapestry.apache.org/ ) .",
    ".the number of recognized domain - terms for application servers and web frameworks [ cols=\"<,<,<,<,<,<,<\",options=\"header \" , ]",
    "within the next step we locate concepts encoded in keywords of the product .",
    "we use again wordnet for searching keywords .",
    "programmers knows only the domain the software product it belongs to .",
    "they do not need to use exact words used in source code .",
    "we present here an example of concept location .",
    "lets suppose that somebody wants to change the algorithm for determining the parts of speech in our program .",
    "s / he needs to locate the concept of determining the parts of speech in the source code of the examined program .",
    "it is known that programmers and maintainers use different words to describe essentially the same or similar concepts @xcite .",
    "therefore the use of full - text search for concept location is very limited .",
    "we will try to find concepts based on semantic search .",
    "in our example we assume that a concept is the identifier of a method or a class .",
    "we want to find a fragment in the source code where the parts of speech are located .",
    "we will try to find this code fragment based on this key - phrase : `` _ _ find word form _ _ '' . for every keyword in our key - phrase we will make a database of related words ",
    "words that are in some semantic relationship to the keyword",
    ". then , we will try to locate code fragment in our source code , where at least 1 occurrence for every keyword is found .",
    "this process is shown on the fig .",
    "[ fig : location ] .",
    "however we are not looking only for the keywords itself , but also for semantically related words . in our example , as a result we find a method with this definition :    ....    public string gettype(string word ) {      //method source code    } ....        we found the three keywords in this method definition based on these semantic relations :    1 .",
    "_ find  get _ : `` get '' is a hypernym of `` find '' .",
    "we found the word `` get '' in the method name .",
    "_ word _ : we found the term `` word '' itself in the parameter name .",
    "form  type _ : `` type '' is a hyponym of `` form '' .",
    "we found the word `` type '' in the method name .",
    "we can see on this example that we could not locate this concept easily using fulltext search , but we can locate it using search based on semantic relations .",
    "* the study of software vocabularies . * this study is focused on three research questions : ( 1 ) to what degree relate terms found in the source code to a particular domain ? ; ( 2 ) which is the preponderant source of domain terms : identifiers or comments ? ; and ( 3 ) to what degree are domain terms shared between several systems from the same domain ? within the studied software , we found that in average : 42% of the domain terms were used in the source code ; 23% of the domain terms used in the source code are present in comments only , whereas only 11% in the identifiers alone , and there is a 63% agreement in the use of domain terms between any two software systems .",
    "they manually selected the most common concepts , based on several books and online sources .",
    "they chose 135 domain concepts .",
    "from the same resources , for each of these concepts one or more terms and standard abbreviations that describe the concept were manually selected and included in the domain vocabulary @xcite .",
    "_ our aim was to define the domain vocabulary automatically .",
    "results from the experiments will be used to build domain vocabularies for other domains too .",
    "these vocabularies support more detailed automatic classification of software products .",
    "our next experiments will include inspection of comments in the source code .",
    "this stream of research is strongly promoted by _",
    "@xcite .    * concept location .",
    "* one of the experiments in the area of mapping between source code and conceptualizations shared as ontology has been published in @xcite .",
    "the programs regard themselves as knowledge bases built on the programs identifiers and their relations implied by the programming language .",
    "this approach extracts concepts from code by mapping the identifiers and the relations between them to ontology . as a result",
    ", they explicitly link the sources with the semantics contained in ontology .",
    "this approach is demonstrated using on the one hand the relations within java programs generated by the type and the module systems and on the other hand the wordnet ontology .",
    "_ we are locating concepts by keywords specified by programmers .",
    "concept location is based on searching names in the identifiers that are in some relation to the specified keywords .",
    "this approach supports easier understanding of higher - level abstractions within the inspected application .",
    "we will work further on the concept visualization as well as on concept location refinement issues . _",
    "we can conclude the experiment results briefly as follows :    * in general , the most used parts of speech for all inspected element types are nouns ( 57% ) . * application servers as well as gwt use a lot of not recognized words due to different identifiers . *",
    "the most number of recognized words is used in tapestry ( 80% ) and echo2 ( 86% ) web frameworks .",
    "we can assume that the source code of both products could be well understandable .",
    "* from the comprehension point of view the application servers are more complex than web frameworks . * in spite of application servers complexity , they are using more common domain terms .",
    "application server domain vocabulary consists of other well - known terms like : `` context '' , `` session '' , `` service '' , and so on .",
    "* concept location gives us opportunity to find source code fragments more efficiently and with better results than using classical keyword search .",
    "this work was supported by vega grant no .",
    "1/4073/07 - aspect - oriented evolution of complex software system and by apvv grant no . sk - cz-0095 - 07 - cooperation in design and implementation of language systems .",
    "l. http://hornad.fei.tuke.sk/kpi/person/samuelis/dcicard.php[samuelis ] , notes on the emerging science of software evolution , in : _ handbook of research on modern systems analysis and design technologies and applications _",
    ", hershey : information science reference , 2008 , pp . 161167 .    l. http://hornad.fei.tuke.sk/kpi/person/samuelis/dcicard.php[samuelis ] , cs .",
    "http://hornad.fei.tuke.sk/kpi/person/szabo/dcicard.php[szab ] , on the role of the incrementality principle in software evolution , _ egyptian comput .",
    "j. _ , * 29 , * 2 ( 2007 ) 107112 .",
    "http://hornad.fei.tuke.sk/kpi/person/szabo/dcicard.php[szab ] , l. http://hornad.fei.tuke.sk/kpi/person/samuelis/dcicard.php[samuelis ] , notes on the software evolution within test plans , _ acta electrotechnica et inform .",
    "_ , * 8 , * 2 ( 2008 ) 5663 .        b. l. vinz , l. h. etzkorn , improving program comprehension by combining code understanding with comment understanding , http://www.elsevier.com/wps/find/journaldescription.cws_home/525448/description#description[_knowledge-based syst . _ ] , * 21 , * 8 ( 2008 ) 813825 ."
  ],
  "abstract_text": [
    "<S> developers express the meaning of the domain ideas in specifically selected identifiers and comments that form the target implemented code . </S>",
    "<S> software maintenance requires knowledge and understanding of the encoded ideas . </S>",
    "<S> this paper presents a way how to create automatically domain vocabulary . </S>",
    "<S> knowledge of domain vocabulary supports the comprehension of a specific domain for later code maintenance or evolution . </S>",
    "<S> we present experiments conducted in two selected domains : application servers and web frameworks . </S>",
    "<S> knowledge of domain terms enables easy localization of chunks of code that belong to a certain term . </S>",
    "<S> we consider these chunks of code as `` concepts '' and their placement in the code as `` concept location '' . </S>",
    "<S> application developers may also benefit from the obtained domain terms . </S>",
    "<S> these terms are parts of speech that characterize a certain concept . </S>",
    "<S> concepts are encoded in `` classes '' ( oo paradigm ) and the obtained vocabulary of terms supports the selection and the comprehension of the class appropriate identifiers . </S>",
    "<S> we measured the following software products with our tool : jboss , jonas , glassfish , tapestry , google web toolkit and echo2 . </S>"
  ]
}