{
  "article_text": [
    "in order to introduce the problem we analyze in the paper , let us start with some motivating examples .    in high frequency trading",
    ", an automatic agent decides the next action to be performed as sending or canceling a buy / sell order , on the basis of some market variables as well as private variables ( e.g. , stock price , traded volume , volatility , order books distributions as well as complex relations among these variables ) .",
    "for instance in @xcite the trading strategy is learned in the form of a discrete function , described as a table , that has to be evaluated whenever a new scenario is faced and an action ( sell / buy ) has to be taken .",
    "the rows of the table represent the possible scenarios of the market and the columns represent the variables taken into account by the agent to distinguish among the different scenarios . for each scenario",
    ", there is an associated action .",
    "every time an action need to be taken , the agent can identify the scenario by computing the value of each single variable and proceed with the associated action .",
    "however , recomputing all the variable every time might be very expensive . by taking into account the structure of the function / table together with information on the probability distribution on the scenarios of the market and also the fact that some variables are more expensive ( or time consuming ) to calculate than others , the algorithm could limit itself to recalculate only some variables whose values determine the action to be taken .",
    "such an approach can significantly speed up the evaluation of the function .",
    "since market conditions change on a millisecond basis , being able to react very quickly to a new scenario is the key to a profitable strategy .    in a classical bayesian active learning problem ,",
    "the task is to select the right hypothesis from a possibly very large set @xmath1 each @xmath2 is a mapping from a set @xmath3 called the query / test space to the set ( of labels ) @xmath4 it is assumed that the functions in @xmath5 are unique , i.e. , for each pair of them there is at least one point in @xmath3 where they differ .",
    "there is one function @xmath6 which provides the correct labeling of the space @xmath3 and the task is to identify it through queries / tests .",
    "a query / test coincides with an element @xmath7 and the result is the value @xmath8 each test @xmath9 has an associated cost @xmath10 that must be paid in order to acquire the response @xmath11 since the process of labeling an example may be expensive either in terms of time or money ( e.g. annotating a document ) . the goal is to identify the correct hypothesis spending as little as possible .",
    "for instance , in automatic diagnosis , @xmath12 represents the set of possible diagnoses and @xmath13 the set of symptoms or medical tests , with @xmath14 being the exact diagnosis that has to be achieved by reducing the cost of the examinations .    in @xcite , a more general variant of the problem",
    "was considered where rather than the diagnosis it is important to identify the therapy ( e.g. , for cases of poisoning it is important to quickly understand which antidote to administer rather than identifying the exact poisoning ) .",
    "this problem can be modeled by defining a partition @xmath15 on @xmath12 with each class of @xmath15 representing the subset of diagnoses which requires the same therapy .",
    "the problem is then how to identify the class of the exact @xmath14 rather than @xmath14 itself .",
    "this model has also been studied by golovin et al .",
    "@xcite to tackle the problem of erroneous tests responses in bayesian active learning .",
    "the above examples can all be cast into the following general problem . + * the discrete function evaluation problem * ( dfep ) .",
    "an instance of the problem is defined by a quintuple @xmath16 where @xmath17 is a set of objects , @xmath18 is a partition of @xmath19 into @xmath20 classes , @xmath21 is a set of tests , @xmath22 is a probability distribution on @xmath23 and @xmath24 is a cost function assigning to each test @xmath25 a cost @xmath26 a test @xmath27 , when applied to an object @xmath28 , incurs a cost @xmath29 and outputs a number @xmath30 in the set @xmath31 .",
    "it is assumed that the set of tests is complete , in the sense that for any distinct @xmath32 there exists a test @xmath25 such that @xmath33 the goal is to define a testing procedure which uses tests from @xmath21 and minimizes the testing cost ( in expectation and/or in the worst case ) for identifying the class of an unknown object @xmath34 chosen according to the distribution @xmath35    the dfep can be rephrased in terms of minimizing the cost of evaluating a discrete function that maps points ( corresponding to objects ) from some finite subset of @xmath36 into values ( corresponding to classes ) , where an object @xmath37 corresponds to the point @xmath38 obtained by applying each test of @xmath21 to @xmath39 .",
    "this perspective motivates the name we chose for the problem .",
    "however , for the sake of uniformity with more recent work @xcite we employ the definition of the problem in terms of objects / tests / classes . +",
    "* decision tree optimization . * any testing procedure can be represented by a _ decision tree _ , which is a tree where every internal node is associated with a test and every leaf is associated with a set of objects that belong to the same class .",
    "more formally , a decision tree @xmath40 for @xmath41 is a leaf associated with class @xmath42 if every object of @xmath19 belongs to the same class @xmath42 .",
    "otherwise , the root @xmath43 of @xmath40 is associated with some test @xmath44 and the children of @xmath43 are decision trees for the sets @xmath45 , where @xmath46 , for @xmath47 , is the subset of @xmath19 that outputs @xmath42 for test @xmath25 .    given a decision tree @xmath40 , rooted at @xmath43 , we can identify the class of an unknown object @xmath34 by following a path from @xmath43 to a leaf as follows : first , we ask for the result of the test associated with @xmath43 when performed on @xmath34 ; then , we follow the branch of @xmath43 associated with the result of the test to reach a child @xmath48 of @xmath43 ; next , we apply the same steps recursively for the decision tree rooted at @xmath48 .",
    "the procedure ends when a leaf is reached , which determines the class of @xmath34 .",
    "we define @xmath49 as the sum of the tests cost on the root - to - leaf path from the root of @xmath40 to the leaf associated with object @xmath39 .",
    "then , the _ worst testing cost _ and the _ expected testing cost _ of @xmath40 are , respectively , defined as    @xmath50    @xmath51    figure [ fig : decisiontree0 ] shows an instance of the dfep and a decision tree for it .",
    "the tree has worst testing cost @xmath52 and expected testing cost @xmath53 .    ,",
    "@xmath54 and @xmath55 .",
    "letters and numbers in the leaves indicate , respectively , classes and objects . , title=\"fig:\",width=415 ] [ fig : decisiontree0 ]    -0.3 in    * our results . *",
    "our main result is an algorithm that builds a decision tree whose expected testing cost and worst testing cost are at most @xmath56 times the minimum possible expected testing cost and the minimum possible worst testing cost , respectively .",
    "in other words , the decision tree built by our algorithm achieves simultaneously the best possible approximation achievable with respect to both the expected testing cost and the worst testing cost .",
    "in fact , for the special case where each object defines a distinct class  known as the _ identification problem_ both the minimization of the expected testing cost and the minimization of the worst testing cost do not admit a sub - logarithmic approximation unless @xmath57 as shown in @xcite and in @xcite , respectively .",
    "in addition , in section [ sec : inapprox ] , we show that the same inapproximability results holds in general for the case of exactly @xmath20 classes for any @xmath58    it should be noted that in general there are instances for which the decision tree that minimizes the expected testing cost has worst testing cost much larger than that achieved by the decision tree with minimum worst testing cost . also there are instances where the converse happens .",
    "therefore , it is reasonable to ask whether it is possible to construct decision trees that are efficient with respect to both performance criteria .",
    "this might be important in practical applications where only an estimate of the probability distribution is available which is not very accurate .",
    "also , in medical applications like the one depicted in @xcite , very high cost ( or equivalently significantly time consuming therapy identification ) might have disastrous / deadly consequences . in such cases , besides being able to minimize the expected testing cost , it is important to guarantee that the worst testing cost also is not large ( compared with the optimal worst testing cost ) .    with respect to the minimization of the expected testing cost , our result improves upon the previous @xmath59 approximation shown in @xcite and @xcite , where @xmath60 is the minimum positive probability among the objects in @xmath19 . from the result in these papers",
    "an @xmath56 approximation could be attained only for the particular case of uniform costs via a technique used in @xcite .    from a high - level perspective",
    ", our method closely follows the one used by gupta _",
    "@xcite for obtaining the @xmath56 approximation for the expected testing cost in the identification problem .",
    "both constructions of the decision tree consist of building a path ( backbone ) that splits the input instance into smaller ones , for which decision trees are recursively constructed and attached as children of the nodes in the path .    a closer look , however , reveals that our algorithm is much simpler than the one presented in @xcite .",
    "first , it is more transparently linked to the structure of the problem , which remained somehow hidden in @xcite where the result was obtained via an involved mapping from adaptive tsp .",
    "second , our algorithm avoids expensive computational steps as the sviridenko procedure @xcite and some non - intuitive / redundant steps that are used to select the tests for the backbone of the tree .",
    "in fact , we believe that providing an algorithm that is much simpler to implement and an alternative proof of the result in @xcite is an additional contribution of this paper .",
    "* state of the art . *",
    "the dfep has been recently studied under the names of class equivalence problem @xcite and group identification problem @xcite and long before it had been described in the excellent survey by moret @xcite .",
    "both @xcite and @xcite give @xmath61 approximation algorithms for the version of the dfep where the expected testing cost has to be minimized and both the probabilities and the testing costs are non - uniform .",
    "in addition , when the testing costs are uniform both algorithms can be converted into a @xmath62 approximation algorithm via kosaraju approach @xcite .",
    "the algorithm in @xcite is more general because it addresses multiway tests rather than binary ones .",
    "for the minimization of the worst testing cost , moshkov has studied the problem in the general case of multiway tests and non - uniform costs and provided an @xmath56-approximation in @xcite . in the same paper",
    "it is also proved that no @xmath63-approximation algorithm is possible under standard the complexity assumption @xmath64 the minimization of the worst testing cost is also investigated in @xcite under the framework of covering and learning .    the particular case of the dfep where each object belongs to a different class  known as the _ identification problem_has been more extensively investigated @xcite . both the minimization of the worst and the expected testing cost do not admit a sublogarithmic approximation unless @xmath65 as proved by @xcite and @xcite . for the expected testing cost , in the variant with multiway tests , non uniform probabilities and non uniform testing costs , an @xmath66 approximation is given by guillory and blimes in @xcite .",
    "@xcite improved this result to @xmath56 employing new techniques not relying on the generalized binary search ( gbs)the basis of all the previous strategies .",
    "an @xmath56 approximation algorithm for the minimization of the worst testing cost for the identification problem has been given by arkin et .",
    "@xcite for binary tests and uniform cost and by hanneke @xcite for case with mutiway tests and non - uniform testing costs .    in the case of boolean functions",
    ", the dfep is also known as stochastic boolean function evaluation ( sbfe ) , where the distribution over the possible assignments is a product distribution defined by assuming that variable @xmath67 has a given probability @xmath68 of being one independently of the value of the other variables .",
    "another difference with respect to the dfep as it is presented here , is that in stochastic boolean function evaluation the common assumption is that the complete set of associations between the assignments of the variables and the value of the function is provided , directly or via a representation of the function , e.g. , in terms of its dnf or cnf .",
    "the present definition of dfep considers the more general problem where only a sample of the boolean function is given and from this we want to construct a decision tree with minimum expected costs and that exactly fits the sample .    results on the exact solution of the sbfe for different classes of boolean functions can be found in the survey paper @xcite . in a recent paper deshpande et al .",
    "@xcite , provide a @xmath69-approximation algorithm for evaluating boolean linear threshold formulas and an @xmath70 approximation algorithm for the evaluation of cdnf formulas , where @xmath71 and @xmath72 is the number of clauses of the input cnf and @xmath72 is the number of terms of the input dnf .",
    "the same result had been previously obtained by kaplan et al .",
    "@xcite for the case of monotone formulas and uniform distribution ( in a slightly different setting ) .",
    "both algorithms of @xcite are based on reducing the problem to stochastic submodular set cover introduced by golovin and krause @xcite and providing a new algorithm for this latter problem .",
    "other special cases of the dfep like the evaluation of and/or trees ( a.k.a .",
    "read - once formulas ) and the evaluation of game trees ( a central task in the design of game procedures ) are discussed in @xcite . in @xcite ,",
    "charikar _ et al .",
    "_ considered discrete function evaluation from the perspective of competitive analysis ; results in this alternative setting are also given in @xcite .",
    "given an instance @xmath73 of the dfep , we will denote by @xmath74 ( @xmath75 ) the expected testing cost ( worst testing cost ) of a decision tree with minimum possible expected testing cost ( worst testing cost ) over the instance @xmath76 when the instance @xmath77 is clear from the context , we will also use the notation @xmath78 ( @xmath79 ) for the above quantity , referring only to the set of objects involved .",
    "we use @xmath60 to denote the smallest non - zero probability among the objects in @xmath19 .",
    "let @xmath80 be an instance of dfep and let @xmath81 be a subset of @xmath19 .",
    "in addition , let @xmath82 and @xmath83 be , respectively , the restrictions of @xmath84 and @xmath24 to the set @xmath81 .",
    "our first observation is that every decision tree @xmath40 for @xmath41 is also a decision tree for the instance @xmath85 .",
    "the following proposition immediately follows .",
    "[ prop : subadditivity ] let @xmath86 be an instance of the dfep and let @xmath81 be a subset of @xmath19 . then , @xmath87 and @xmath88 where @xmath89 is the restriction of @xmath77 to @xmath81 .",
    "one of the measures of progress of our strategy is expressed in terms of the number of pairs of objects belonging to different classes which are present in the set of objects satisfying the tests already performed .",
    "the following definition formalizes this concept of pairs for a given set of objects .",
    "let @xmath90 be an instance of the dfep and @xmath91 we say that two objects @xmath92 constitute a pair of @xmath93 if they both belong to @xmath93 but come from different classes .",
    "we denote by @xmath94 the number of pairs of @xmath95 in formulae , we have @xmath96 where for @xmath97 and @xmath98 @xmath99 denotes the number of objects in @xmath100 belonging to class @xmath101    as an example , for the set of objects @xmath19 in figure [ fig : decisiontree0 ] we have @xmath102 and the following set of pairs @xmath103    we will use @xmath34 to denote the initially unknown object whose class we want to identify .",
    "let @xmath104 be a sequence of tests applied to identify the class of @xmath34 ( it corresponds to a path in the decision tree ) and let @xmath93 be the set of objects that agree with the outcomes of all tests in @xmath104 .",
    "if @xmath105 , then all objects in @xmath93 belong to the same class , which must coincide with the class of the selected object @xmath34 .",
    "hence , @xmath105 indicates the identification of the class of the object @xmath106 notice that @xmath34 might still be unknown when the condition @xmath105 is reached .    for each test @xmath27 and for each @xmath107",
    ", let @xmath108 be the set of objects for which the outcome of test @xmath25 is @xmath109 for a test @xmath110 the outcome resulting in the largest number of pairs is of special interest for our strategy .",
    "we denote with @xmath111 the set among @xmath112 such that @xmath113 ( ties are broken arbitrarily ) .",
    "we denote with @xmath114 the set of objects not included in @xmath115 i.e. , we define @xmath116 . whenever @xmath19 is clear from the context we use @xmath117 instead of @xmath114 .",
    "given a set of objects @xmath19 , each test produces a tripartition of the pairs in @xmath19 : the ones with both objects in @xmath118 those with both objects in @xmath111 and those with one object in @xmath117 and one object in @xmath119 we say that the pairs in @xmath117 are _ kept _ by @xmath25 and the pairs with one object from @xmath117 and one object from @xmath111 are _ separated _ by @xmath120 we also say that a pair is _ covered _ by the test @xmath25 if it is either kept or separated by @xmath120 analogously , we say that a test @xmath25 covers an object @xmath39 if @xmath121 .    for any set of objects @xmath122",
    "the probability of @xmath123 is @xmath124",
    "in this section , we describe our algorithm dectree and analyze its performance",
    ". the concept of the separation cost of a sequence of tests will turn useful for defining and analyzing our algorithm .    *",
    "the separation cost of a sequence of tests . * given an instance @xmath73 of the dfep , for a sequence of tests @xmath125 we define the separation cost of @xmath104 in the instance @xmath126 denoted by @xmath127 as follows : fix an object @xmath128 if there exists @xmath129 such that @xmath130 then we set @xmath131 if @xmath132 for each @xmath133",
    "then we set @xmath134 let @xmath135 denote the _ cost of separating @xmath9 in the instance @xmath77 by means of the sequence _",
    "@xmath136 then , the _ separation cost of @xmath104 _ ( in the instance @xmath77 ) is defined by @xmath137    in addition , we define @xmath138 as the total cost of the sequence @xmath104 , i.e. , @xmath139    * lower bounds on the cost of an optimal decision tree for the dfep . *",
    "we denote by @xmath140 the minimum separation cost in @xmath77 attainable by a sequence of tests in @xmath21 which covers all the pairs in @xmath19 and @xmath141 as the minimum total cost attainable by a sequence of tests in @xmath21 which covers all the pairs in @xmath142    the following theorem shows lower bounds on both the expected testing cost and the worst case testing cost of any instance @xmath73 of the dfep .",
    "[ theo : lowerbound ] for any instance @xmath73 of the defp , it holds that @xmath143 and @xmath144    let @xmath40 be a decision tree for the instance @xmath77 .",
    "let @xmath145 be the nodes in the root - to - leaf path in @xmath40 such that for each @xmath146 the node @xmath147 is on the branch stemming from @xmath148 which is associated with @xmath149 , and the leaf node @xmath150 is the child of @xmath151 associated with the objects in @xmath152    let @xmath153 .",
    "abusing notation let us now denote with @xmath147 the test associated with the node @xmath147 so that @xmath154 is a sequence of tests .",
    "in particular , @xmath104 is the sequence of tests performed according to the strategy defined by @xmath40 when the object @xmath34 whose class we want to identify , is such that @xmath155 holds for each test @xmath25 performed in the sequence .",
    "notice that , by construction , @xmath104 is a sequence of tests covering all pairs of @xmath19 .    _ claim .",
    "_ for each object @xmath39 it holds that @xmath156    if for each @xmath157 we have that @xmath158 then it holds that @xmath159 conversely , let @xmath147 be the first test in @xmath104 for which @xmath160 therefore , we have that @xmath161 is a prefix of the root to leaf path followed when @xmath39 is the object chosen .",
    "it follows that @xmath162 the claim is proved .    in order to prove the first statement of the theorem , we let @xmath40 be a decision tree which achieves the minimum possible expected cost , i.e. , @xmath163 then",
    ", we have    @xmath164    in order to prove the second statement of the theorem , we let @xmath40 be a decision tree which achieves the minimum possible worst testing cost , i.e. , @xmath165 let @xmath28 be such that , for each @xmath166 it holds that @xmath167 then , by the above claim it follows that @xmath168 using ( [ eq : totcost - worstcase ] ) , we have    @xmath169    the proof is complete",
    ".    the following subadditivity property will be useful .",
    "[ prop : subadditivity ] let @xmath170 be a partition of the object set @xmath142 we have @xmath171 and @xmath172 , where @xmath173 and @xmath174 are , respectively , the minimum expected testing cost and the worst case testing cost when the set of objects is @xmath175    * the optimization of submodular functions of sets of tests . *",
    "[ sec : submodularotimization ] let @xmath176 be an instance of the dfep .",
    "a set function @xmath177 is submodular non - decreasing if for every @xmath178 and every @xmath179 , it holds that @xmath180 ( submodularity ) and @xmath181 ( non - decreasing ) .",
    "it is easy to verify that the functions @xmath182 @xmath183 are non - negative non - decreasing submodular set functions . in words",
    ", @xmath184 is the function mapping a set of tests @xmath185 into the number of pairs covered by the tests in @xmath185 .",
    "the function @xmath186 , instead , maps a set of tests @xmath185 into the probability of the set of objects covered by the tests in @xmath185 .",
    "let @xmath187 be a positive integer .",
    "consider the following optimization problem defined over a non - negative , non - decreasing , sub modular function @xmath188 : @xmath189    in @xcite , wolsey studied the solution to the problem @xmath190 provided by algorithm [ greedy - wolsey ] below , called the adapted greedy heuristic .",
    "( @xmath191 )     [ line : one ] [ line : two ] [ line : three ]    [ line : four ]    [ line : five ]    [ line : six ]    the following theorem summarizes results from @xcite[theorems 2 and 3 ] .",
    "@xcite [ theo : wolsey ] let @xmath192 be the solution of the problem @xmath190 and @xmath193 be the set returned by algorithm [ greedy - wolsey ] .",
    "moreover , let @xmath194 be the base of the natural logarithm and @xmath195 be the solution of @xmath196 then we have that @xmath197 .",
    "moreover , if there exists @xmath198 such @xmath199 for each @xmath27 and @xmath198 divides @xmath200 then we have @xmath201    [ cor : wolsey ] let @xmath202 be the sequence of all the tests selected by adapted - greedy , i.e. , the concatenation of the two possible outputs in line 7 .",
    "then , we have that the total cost of the tests in @xmath104 is at most @xmath203 and @xmath204    our algorithm for building a decision tree will employ this greedy heuristic for finding approximate solutions to the optimization problem @xmath190 over the submodular set functions @xmath184 and @xmath186 defined in ( [ eq : problemp ] ) .",
    "we will show that algorithm [ algo : main ] attains a logarithmic approximation for dfep .",
    "the algorithm consists of 4 blocks .",
    "the first block ( lines 1 - 2 ) is the basis of the recursion , which returns a leaf if all objects belong to the same class @xmath205 . if @xmath206 , we have that @xmath207 and the algorithm returns a tree that consists of a root and two leaves , one for each object , where the root is associated with the cheapest test that separates these two objects .",
    "clearly , this tree is optimal for both the expected testing cost and the worst testing cost .    the second block ( line 3 ) calls procedure findbudget to define the budget @xmath187 allowed for the tests selected in the third and fourth blocks .",
    "findbudget finds the smallest @xmath187 such that adapted - greedy(@xmath208 ) returns a set of tests @xmath185 covering at least @xmath209 pairs .",
    "( @xmath210 )    [ b1start ] [ b1end ] [ line : budget ] [ b2start ] [ b3-start ] [ line : main - opt1 - 1 ] [ line : main - ui1 ] [ line : main - call-1 ] [ b3-end ] [ b4-start ] [ line : main - greedy2 ] [ line : main - ui2 ] [ line : main - call-2 ] [ b4-end ] [ line : main - call-3 ]    ( @xmath211 )    the third ( lines 4 - 10 ) and the fourth ( lines 11 - 17 ) blocks are responsible for the construction of the backbone of the decision tree ( see fig .",
    "2 ) as well as to call dectree recursively to construct the decision trees that are children of the nodes in the backbone .",
    "the third block ( the * while * loop in lines 4 - 10 ) constructs the first part of the backbone ( sequence @xmath212 in fig .",
    "2 ) by iteratively selecting the test that covers the maximum uncovered mass probability per unit of testing cost ( line 5 ) .",
    "the selected test @xmath213 induces a partition @xmath214 on the set of objects @xmath215 , which contains the objects that have not been covered yet . in lines 7 and 8 ,",
    "the procedure is recursively called for each set of this partition but for the one that is contained in the subset @xmath216 . with reference to figure 2",
    ", these calls will build the subtrees rooted at nodes not in @xmath212 which are children of some node in @xmath212 .",
    "similarly , the fourth block ( the * repeat - until * loop ) constructs the second part of the backbone ( sequence @xmath217 in fig .",
    "2 ) by iteratively selecting the test that covers the maximum number of uncovered pairs per unit of testing cost ( line 12 ) . the line [ line : main - call-3 ] is responsible for building a decision tree for the objects that are not covered by the tests in the backbone .",
    "we shall note that both the third and the fourth block of the algorithm are based on the adapted greedy heuristic of algorithm [ greedy - wolsey ] .",
    "in fact , @xmath218 in line [ line : main - opt1 - 1 ] ( third block ) corresponds to @xmath219 in algorithm [ greedy - wolsey ] because , right before the selection of the @xmath71-th test , @xmath100 is the set of tests @xmath220 and @xmath221 .",
    "thus , @xmath222 and @xmath223 so that @xmath224    a similar argument shows that @xmath225 in line [ line : main - greedy2 ] ( fourth block ) corresponds to @xmath226 in algorithm [ greedy - wolsey ] .",
    "these connections will allow us to apply both theorem [ theo : wolsey ] and corollary [ cor : wolsey ] to analyze the cost and the coverage of these sequences .",
    "while in the lowest - right gray subtree it is at most @xmath227 ( see the proof of theorem [ theo : main]).,title=\"fig:\",width=302 ] [ fig : decisiontree ]    -0.1 in    let @xmath228 denote the sequence of tests obtained by concatenating the tests selected in the * while * loop and in the * repeat - until * loop of the execution of dectree over instance @xmath76 we delay to the next section the proof of the following key result .",
    "[ theo : key ] let @xmath195 be the solution of @xmath229 and @xmath230 there exists a constant @xmath231 such that for any instance @xmath73 of the dfep , the sequence @xmath228 covers at least @xmath232 pairs , and it holds that @xmath233 and @xmath234    applying theorem [ theo : key ] to each recursive call of dectree we can prove the following theorem about the approximation guaranteed by our algorithm both in terms of worst testing cost and expected testing cost .",
    "[ theo : main ] for any instance @xmath235 of the dfep , the algorithm dectree outputs a decision tree with expected testing cost at most @xmath236 and with worst testing cost at most @xmath237 .",
    "for any instance @xmath126 let @xmath238 be the decision tree produced by the algorithm dectree .",
    "first , we prove an approximation for the expected testing cost .",
    "let @xmath239 be such that @xmath240 , where @xmath241 is the constant given in the statement of theorem [ theo : key ] .",
    "let us assume by induction that the algorithm guarantees approximation @xmath242 , for the expected testing cost , for every instance @xmath243 on a set of objects @xmath93 with @xmath244    let @xmath245 be the set of instances on which the algorithm @xmath246 is recursively called in lines 8,15 and 18 .",
    "we have that @xmath247    the first equality follows by the recursive way the algorithm dectree builds the decision tree .",
    "inequality ( [ 3 ] ) follows from ( [ 1 ] ) by the subadditivity property ( proposition [ prop : subadditivity ] ) and simple algebraic manipulations .",
    "the inequality in ( [ 3 - 1 ] ) follows by theorem [ theo : key ] together with theorem [ theo : lowerbound ] yielding @xmath248 the inequality ( [ 4 ] ) follows by induction ( we are using @xmath249 to denote the number of pairs of instance @xmath243 ) .    to prove that the inequality in ( [ 6 ] ) holds we have to argue that every instance @xmath250 has at most @xmath251 pairs .",
    "let @xmath252 as in the lines 8 and 15 .",
    "first we show that the number of pairs of @xmath253 is at most @xmath254 .",
    "we have @xmath255 and @xmath216 is the set with the maximum number of pairs in the partition @xmath256 , induced by @xmath213 on the set @xmath19 .",
    "it follows that @xmath257 now it remains to show that the instance @xmath243 , recursively called , in line 18 has at most @xmath227 pairs .",
    "this is true because the number of pairs of @xmath243 is equal to the number of pairs not covered by @xmath228 which is bounded by @xmath258 by theorem [ theo : key ] .",
    "now , we prove an approximation for the worst testing cost of the tree @xmath238 .",
    "let @xmath259 be such that @xmath260 .",
    "let us assume by induction that the worst testing cost of @xmath261 is at most @xmath262 for every instance @xmath243 on a set of objects @xmath93 with @xmath263 we have that @xmath264    inequality ( [ 8 ] ) follows from the subadditivity property ( proposition [ prop : subadditivity ] ) for the worst testing cost .",
    "the inequality ( [ 9 ] ) follows by theorem [ theo : lowerbound ] .",
    "the inequality ( [ 10 ] ) follows from theorem [ theo : key ] , the induction hypothesis ( we are using @xmath249 to denote the number of pairs of instance @xmath243 ) and from the fact mentioned above that every instance in @xmath245 has at most @xmath265 pairs .    since @xmath266 it follows that the algorithm provides an @xmath56 approximation for both the expected testing cost and the worst testing cost .",
    "the previous theorem shows that algorithm dectree provides simultaneously logarithmic approximation for the minimization of expected testing cost and worst testing cost .",
    "we would like to remark that this is an interesting feature of our algorithm . in this respect ,",
    "let us consider the following instance of the dfep : let @xmath267 ; @xmath268 , for @xmath269 and @xmath270 ; the set of tests is in one to one correspondence with the set of all binary strings of length @xmath271 so that the test corresponding to a binary string @xmath272 outputs @xmath273 for object @xmath274 if and only if the @xmath42th bit of @xmath272 is 0(1 ) .",
    "moreover , all tests have unitary costs .",
    "this instance is also an instance of the problem of constructing an optimal prefix coding binary tree , which can be solved by the huffman s",
    "algorithm @xcite .",
    "let @xmath275 and @xmath276 be , respectively , the decision trees with minimum expected cost and minimum worst testing cost for this example . using huffman s algorithm , it is not difficult to verify that @xmath277 and @xmath278 .",
    "in addition , we have that @xmath279 .",
    "this example shows that the minimization of the expected testing cost may result in high worst testing cost and vice versa the minimization of the worst testing cost may result in high expected testing cost .",
    "clearly , in real situations presenting such a dichotomy , the ability of our algorithm to optimize simultaneously both measures of cost might provide a significant gain over strategies only guaranteeing competitiveness with respect to one measure .",
    "we now return to the proof of theorem [ theo : key ] for which will go through three lemmas .",
    "[ lemma : length ] for any instance @xmath73 of the dfep , the value @xmath187 returned by the procedure findbudget@xmath280 satisfies @xmath281 .",
    "let us consider the problem @xmath190 in equation ( [ eq : problemp ] ) with the function @xmath184 that measures the number of pairs covered by a set of tests .",
    "let @xmath282 be the number of pairs covered by the solution constructed with adapted - greedy when the budget  the righthand side of equation ( [ eq : problemp])is @xmath9 . by construction",
    ", findbudget finds the smallest @xmath187 such that @xmath283 .",
    "let @xmath284 be a sequence that covers all pairs in @xmath19 and that satisfies @xmath285 .",
    "arguing by contradiction we can show that @xmath286 suppose that this was not the case , then @xmath284 would be the sequence which covers @xmath287 pairs using a sequence of tests of total cost not larger than some @xmath288 by theorem 2 , the procedure adapted - greedy provides an @xmath289-approximation of the maximum number of pairs covered with a given budget .",
    "therefore , when run with budget @xmath290 adapted - greedy is guaranteed to produce a sequence of total cost @xmath291 which covers at least @xmath209 pairs . however , by the minimality of @xmath187 it follows that such a sequence does not exist .",
    "since this contradiction follows by the hypothesis @xmath292 it must hold that @xmath293 as desired .",
    "given an instance @xmath126 for a sequence of tests @xmath294 and a real @xmath295 , let @xmath296 be the separation cost of @xmath104 when every non - covered object is charged @xmath297 , that is , @xmath298    the proofs of the following technical lemma is deferred to the appendix .",
    "[ lemma : key2 ] let @xmath212 be the sequence obtained by concatenating the tests selected in the * while * loop of algorithm [ algo : main ] . then",
    ", @xmath299 and @xmath300 where @xmath301 is a positive constant and @xmath187 is the budget calculated at line 3 .",
    "[ lemma : key3 ] the sequence @xmath228 covers at least @xmath302 pairs and it holds that @xmath303    the sequence @xmath228 can be decomposed into the sequences @xmath212 and @xmath217 , that are constructed , respectively , in the * while * and * repeat - until * loop of the algorithm dectree ( see also fig .",
    "it follows from the definition of @xmath187 that there is a sequence of tests , say @xmath104 , of total cost not larger than @xmath187 that covers at least @xmath209 pairs for instance @xmath77 .",
    "let @xmath304 be the number of pairs of instance @xmath77 covered by the sequence @xmath212 .",
    "thus , the tests in @xmath104 , that do not belong to @xmath212 , cover at least @xmath305 pairs in the set @xmath306 of objects not covered by @xmath212 .",
    "the sequence @xmath217 coincides with the concatenation of the two possible outputs of the procedure adapted - greedy(@xmath307 ( algorithm 1 ) , when it is executed on the instance defined by : the objects in @xmath215 ( those not covered by @xmath212 ) ; the tests that are not in @xmath308 the submodular set function @xmath309 and bound @xmath310 by corollary [ cor : wolsey ] , we have that @xmath311 and @xmath217 covers at least @xmath312 uncovered pairs .    therefore , since @xmath313 altogether",
    ", we have that @xmath228 covers at least @xmath314 pairs and @xmath303    the proof of theorem [ theo : key ] will now follow by combining the previous three lemmas .",
    "* proof of theorem [ theo : key ] .",
    "* first , it follows from lemma [ lemma : key3 ] that @xmath228 covers at least @xmath302 pairs .    to prove that @xmath315",
    ", we decompose @xmath228 into @xmath316 and @xmath317 , the sequences of tests selected in the * while * and in the * repeat - until * loop of algorithm [ algo : main ] , respectively .    for @xmath318 ,",
    "let @xmath319 .",
    "in addition , let @xmath320 be the set of objects which are not covered by the tests in @xmath321 thus , @xmath322 where the last inequality follows from lemma [ lemma : key2 ] .",
    "it remains to show that @xmath323 .",
    "this inequality holds because lemma [ lemma : key3 ] assures that @xmath324 and lemma [ lemma : length ] assures that @xmath325 .",
    "the proof is complete .",
    "let @xmath326 be a set of @xmath271 elements and @xmath327 be a family of subsets of @xmath215 .",
    "the minimum set cover problem asks for a family @xmath328 of minimum cardinality such that @xmath329 .",
    "it is known that no sub logarithmic approximation is achievable for the minimum set cover problem under the standard assumption that @xmath330 more precisely , by the result of raz and safra @xcite it follows that there exists a constant @xmath331 such that no @xmath332-approximation algorithm for the minimum set cover problem exists unless @xmath333 @xcite .",
    "we will show that an @xmath334 approximation algorithm for the minimization of the expected testing cost dfep with exact @xmath335 classes for @xmath336 , implies that the same approximation can be achieved for the minimum set cover problem .",
    "this implies that one can not expect to obtain a sublogarithmic approximation for the dfep unless @xmath65 .",
    "the reduction we present can also be used to show the same inapproximability result for the minimization of the worst testing cost version of the dfep .",
    "given an instance @xmath337 for the minimum set cover problem as defined above , we construct an instance @xmath338 for the dfep as follows : the set of objects is @xmath339 .",
    "the family of classes @xmath340 is defined as follows : all the objects of @xmath215 belong to class @xmath341 while the object @xmath342 , for @xmath343 , belongs to class @xmath344 . notice that @xmath345 and the objects of @xmath215 belong to the same class . in order to define the set of tests @xmath346",
    "we proceed as follows : for each set @xmath347 we create a test @xmath348 such that @xmath348 has value @xmath349 for the objects in @xmath350 and value 1 for the remaining objects .",
    "in addition , we create a test @xmath351 which has value @xmath349 for objects in @xmath215 and value @xmath352 for object @xmath342 ( @xmath353 ) . for our later purposes ,",
    "we notice here that the test @xmath351 can not distinguish between @xmath345 and the elements in @xmath215 .",
    "each test has cost 1 , i.e. , the cost assignment * c * is given by @xmath354 for each @xmath355 finally , we set the probability of @xmath356 to be equal to @xmath357 and the probability of the other objects equal to @xmath358 , for some fixed @xmath359    let @xmath360 be the decision tree with minimum expected testing cost for @xmath361 and let @xmath362 be a minimum set cover for instance @xmath363 , where @xmath364 .",
    "we first argue that @xmath365 .",
    "in fact , we can construct a decision tree @xmath40 by putting the test @xmath366 associated with @xmath367 in the root of the tree , then the test @xmath368 associated with @xmath369 as the child of @xmath366 and so on . notice that , for @xmath370 we have that @xmath371 has two children , one is @xmath372 and the other is a leaf mapping to the class @xmath373 as for @xmath374 one of its children in again a leaf mapping to @xmath341 , the other child is set to the test @xmath351 , whose children are all leaves .",
    "the expected testing cost of @xmath40 can be upper bounded by @xmath375 since we have @xmath376 for any @xmath377 and @xmath378 for any @xmath379 .    on the other hand ,",
    "let @xmath40 be a decision tree for @xmath361 and let @xmath380 be the path from the root of @xmath40 to the leaf where the object @xmath356 lies .",
    "it is easy to realize that the subsets associated with the tests on this path cover all the elements in @xmath215in fact these tests separate @xmath356 from all the other objects from @xmath381 let @xmath382 be the solution to the set cover problem provided by the sets associated with the tests on the path @xmath383 we have that @xmath384    now assume that there is an algorithm that for any instance @xmath73 of the dfep can guarantee a solution with approximation @xmath385 for some @xmath386 therefore , given an instance @xmath337 for set cover we can use this algorithm on the transformed instance @xmath361 defined above , where @xmath387 we obtain a decision tree @xmath40 for @xmath361 such that @xmath388 where we upper bound @xmath389 and @xmath390    from @xmath40 , as seen above we can construct a solution @xmath382 for the set cover problem such that @xmath391 hence , it would follow that @xmath382 is an approximate solution for the set cover instance satisfying : @xmath392 which by the result of @xcite is not possible unless @xmath393    the same construction can be used for analyzing the case of the worst testing cost , in which case we have that ( [ inapprox:1 ] ) becomes @xmath394 and ( [ inapprox:2 ] ) becomes @xmath395 leading to the inapproximability of the dfep w.r.t .",
    "the worst testing cost within a factor of @xmath396 for any @xmath397 notice that an analogous result regarding the worst testing cost had been previously shown by moshkov @xcite based on the result of feige @xcite .",
    "thus , we have the following theorem    [ theo : inappr ] both the minimization of the worst case and the expected case of the dfep do nt admit an @xmath63 approximation unless @xmath398",
    "we presented a new algorithm for the discrete function evaluation problem , a generalization of the classical bayesian active learning also studied under the names of equivalence class determination problem @xcite and group based active query selection problem of @xcite .",
    "our algorithm builds a decision tree which asymptotically matches simultaneously for the expected and the worst testing cost the best possible approximation achievable under standard complexity assumptions @xmath330 this way , we close the gap left open by the previous @xmath59 approximation for the expected cost shown in@xcite and @xcite , where @xmath60 is the minimum positive probability among the objects in @xmath19 and in addition we show that this can be done with an algorithm that guarantees the best possible approximation also with respect to the worst testing cost .    with regards to the broader context of learning , given a set of samples labeled according to an unknown function , a standard task in machine learning is to find a good approximation of the labeling function ( hypothesis ) . in order to guarantee that the hypothesis chosen has some generalization power w.r.t .  to the set of samples",
    ", we should avoid overfitting .",
    "when the learning is performed via decision tree induction this implies that we shall not have leaves associated with a small number of samples so that we end up with a decision tree that have leaves associated with more than one label .",
    "there are many strategies available in the literature to induce such a tree .    in the problem considered in this paper",
    "our aim is to over - fit the data because the function is known a priori and we are interested in obtaining a decision tree that allows us to identify the label of a new sample with the minimum possible cost ( time / money ) .",
    "the theoretical results we obtain for the `` fitting '' problem should be generalizable to the problem of approximating the function . to this aim",
    "we could employ the framework of covering and learning from @xcite along the following lines : we would interrupt the recursive process in algorithm 2 through which we construct the tree as soon as we reach a certain level of learning ( fitting ) w.r.t .",
    "the set of labeled samples .",
    "then , it remains to show that our decision tree is at logarithmic factor of the optimal one for that level of learning .",
    "this is an interesting direction for future research .",
    "30 adler , m. and heeringa , b. approximating optimal binary decision trees .",
    "approx / random 08 , pp .   19 , 2008 .",
    "allen , s.r . , hellerstein , l. , kletenik , d , and nlyurt , t. evaluation of dnf formulas .",
    "in _ proc .  of isaim 2014_.    arkin , e.  m. , meijer , h. , mitchell , j.s.b . , rappaport , d. and skiena , s.s .",
    "decision trees for geometric models . in _ proc . of scg 93",
    "_ , pp .   369378 , 1993 .",
    "bellala , g. , bhavnani , s.  k. , and scott , c. group - based active query selection for rapid diagnosis in time - critical situations .",
    "_ ieee trs .",
    "theor . _ , 580 ( 1):0 459478 , 2012 .",
    "chakaravarthy , v.  t. , pandit , v. , roy , s. , awasthi , p. , and mohania , m. decision trees for entity identification : approximation algorithms and hardness results . in _ proc .",
    "pods 07 _ , pp .   5362 , 2007 .",
    "chakaravarthy , v.  t. , pandit , v. , roy , s. , and sabharwal , y. approximating decision trees with multiway branches . in _ proc .",
    "icalp 09 _ , pp .   210221 , 2009 .",
    "charikar , m. , fagin , r. , guruswami , v. , kleinberg , j.  m. , raghavan , p. , and sahai , a. query strategies for priced information . _ journal of computer and system sciences _ , 640 ( 4):0 785819 , 2002 .",
    "cicalese , f. and laber , e.  s. on the competitive ratio of evaluating priced functions .",
    "_ j. acm _ , 580 ( 3):0 9 , 2011 .    cicalese , f. , jacobs , t. , laber , e. , and molinaro , m. on greedy algorithms for decision trees . in _ proc . of isaac10 _ , 2010 .",
    "cormen , t.  h. , leiserson , c.  e. , rivest , r.  l. , and stein , c. _ introduction to algorithms_. mit press , cambridge , ma , 2001 .",
    "dasgupta , s. analysis of a greedy active learning strategy . in _ nips04 _ , 2004 .",
    "deshpande , a. , hellerstein , l. , and kletenik , d .. approximation algorithms for stochastic boolean function evaluation and stochastic submodular set cover . in _ proc .  of soda",
    "2014 _ , pp .  14531467 , 2014 .    a threshold of @xmath399 for approximating set cover",
    "_ journal of acm _ 45 ( 1998 ) 634652 .",
    "garey , m. optimal binary identification procedures .",
    "_ siam journal on applied mathematics _",
    ", 23(2):173186 , 1972 .",
    "golovin , d. , krause , a. , and ray , d. near - optimal bayesian active learning with noisy observations . in _ proc . of nips10",
    "_ , pp . 766774 , 2010 .",
    "golovin , d. , krause , a .. adaptive submodularity : theory and applications in active learning and stochastic optimization",
    ". _ journal of artificial intelligence research _ , vol .",
    "42 , pages 427 - 486 , 2011 .",
    "greiner , r. , howard , r. , jankowska , m. , and malloy , m. finding optimal satisfiscing strategies for and - or trees .",
    "_ artificial intelligence _ , 1700 ( 1):0 1958 , 2005 .",
    "guillory , a. and bilmes , j. average - case active learning with costs . in _ proc . of alt09",
    "_ , pp .",
    "141155 , 2009 .    guillory , a. and bilmes , j. interactive submodular set cover . in _ proc .",
    "icml10 _ , pp .   415422 .",
    "guillory , a. and bilmes , j. simultaneous learning and covering with adversarial noise .",
    "_ icml11 _ , pp .",
    "gupta , a. , nagarajan , v. , and ravi , r. approximation algorithms for optimal decision trees and adaptive tsp problems . in _ proc .",
    "icalp10 _ , pp .   690701 , 2010 .",
    "hanneke , s. the cost complexity of interactive learning .",
    "_ unpublished _ , 2006 .",
    "hyafil , l. and rivest , r.  l. constructing optimal binary decision trees is np - complete . _",
    "inf . process .",
    "_ , 50 ( 1):0 1517 , 1976 .",
    "kaplan , h. , kushilevitz , e. , and mansour , y .. learning with attribute costs . in _ proc .",
    "of stoc 2005 _ , pp .   356365 , 2005 .",
    "kosaraju , s.  rao , przytycka , teresa  m. , and borgstrom , ryan  s. on an optimal split tree problem . in _ proc . of wads",
    "99 _ , pp .   157168 , 1999 .",
    "laber , e.  s. and nogueira , l.  t. on the hardness of the minimum height decision tree problem . _",
    "discrete appl .",
    "_ , 144:0 209212 , 2004 .",
    "larmore , l.  l. and hirschberg , d.  s. a fast algorithm for optimal length - limited huffman codes .",
    "_ jacm : journal of the acm _ , 37 , 1990 .",
    "ecision trees and diagrams .",
    "_ acm computing surveys _ , pp .",
    "593623 , 1982 .",
    "moshkov , j.m .",
    "approximate algorithm for minimization of decision tree depth . in _ proc .  of 9th intl .",
    "conf .  on rough sets , fuzzy sets , data mining , and granular computing _ , pp .  611 - 614 , 2003 .",
    "moshkov , j.m .",
    "greedy algorithm with weights for decision tree construction .",
    ", 104 : 285292 , 2010 .",
    "nemhauser , g. , wolsey , l. , and fisher , m.  l. an analysis of approximations for maximizing submodular set functions - i .",
    "_ math . programming _ , 14:0 265294 , 1978 .",
    "nevmyvaka , y. , feng , y. , and kearns , m .. reinforcement learning for optimized trade execution . in _ proc . of icml06",
    "_ , pp .",
    "673680 , 2006 .    and",
    "safra , s .. a sub - constant error - probability low - degree test , and sub - constant error - probability pcp characterization of np . ,",
    "acm , 1997 , pp .",
    "475484 .",
    "saks , m.  e. and wigderson , a. probabilistic boolean decision trees and the complexity of evaluating game trees . in _ proc . of focs86",
    "_ , pp .   2938 , 1986 .",
    "sviridenko , m. a note on maximizing a submodular set function subject to a knapsack constraint .",
    "_ operations research letters _ , 320 ( 1):0 41  43 , 2004 .",
    "tarsi , m. optimal search on some game trees .",
    "_ journal of the acm _ , 300 ( 3):0 389396 , july 1983 .",
    "nlyurt , t. sequential testing of complex systems : a review .",
    ", 142(1 - 3):189205 , 2004 .",
    "wolsey , l. maximising real - valued submodular functions .",
    "_ math . of operation research _ , 7(3):410425 , 1982 .",
    "* lemma [ lemma : key2 ] . * _ let @xmath212 be the sequence obtained by concatenating the tests selected in the * while * loop of algorithm 2 .",
    "then , @xmath299 and @xmath300 where @xmath301 is a positive constant and @xmath187 is the budget calculated at line [ line : budget ] . _",
    "clearly , the algorithm 2 in the * while * loop constructs a sequence @xmath212 such that @xmath400    in order to prove the second inequality in the statement of the lemma , it will be convenient to perform the analysis in terms of a variant of our problem which is explicitly defined with respect to the separation cost of a sequence of tests .",
    "we call this new problem the _ pair separation problem _ ( psp ) : the input to the psp , as in the dfep , is a 5-uple @xmath401 , where @xmath17 is a set of objects , @xmath18 is a partition of @xmath19 into @xmath20 classes , @xmath402 is a family of subsets of @xmath19 , @xmath22 is a probability distribution on @xmath23 and @xmath24 is a cost function assigning to each @xmath403 a cost @xmath404 the only difference between the input of these problems is that the set of tests @xmath21 in the input of dfep is replaced with a family @xmath3 of subsets of @xmath19 .",
    "we say that @xmath403 covers an object @xmath39 iff @xmath405 .",
    "moreover , we say that @xmath403 covers a pair of objects @xmath406 if at least one of the conditions hold : ( i ) @xmath405 or ( ii ) @xmath407 .",
    "we say that a pair @xmath406 is covered by a sequence of tests if some test in the sequence covers @xmath406 .",
    "the separation cost of a sequence @xmath408 in the instance @xmath409 of psp is given by :    @xmath410    the _ pair separation problem _ consists of finding a sequence of subsets of @xmath3 with minimum separation cost , @xmath411 , among those sequences that cover all pairs in @xmath19 .",
    "an instance @xmath235 of the dfep induces an instance @xmath412 of the psp where @xmath413 and for every test @xmath27 we have a corresponding subset @xmath414 such that @xmath415 .",
    "thus , in our discussion we will use the term test @xmath416 to refer to a subset @xmath417 . in the body of this paper",
    "we implicitly work with the instance of the psp induced by the input instance of the dfep .",
    "it is easy to realize that @xmath418 .",
    "in addition , @xmath419 where @xmath420 is the sequence obtained from @xmath212 when every @xmath421 is replaced with @xmath422 .",
    "thus , in order to establish the lemma it suffices to prove that @xmath423    it is useful to observe that @xmath420 is equal to the sequence @xmath424 returned by procedure greedypsp in algorithm [ alg : appendix ] when it is executed on the instance @xmath425 .",
    "this algorithm corresponds to lines 4,5,9 and 10 of the while loop of algorithm [ algo : main ] . in algorithm",
    "[ alg : appendix ] , the greedy criteria consists of choosing the test @xmath416 that maximizes the ratio @xmath426 this is equivalent to the maximization of @xmath427 defining the greedy choice in algorithm [ algo : main ] .",
    "( @xmath428 : instance of psp , @xmath187:budget ) )    ( * )    [ alg : appendix ]    the proof consists of the following steps :    1 .",
    "we construct an instance @xmath429 of the psp from @xmath409 2 .",
    "we prove that the optimal separation cost for @xmath243 is no larger than the optimal one for @xmath409 , that is , @xmath430 .",
    "we prove that separation cost @xmath431 of any sequence of tests @xmath432 returned by the above pseudo - code on the instance @xmath433 is at a constant factor of @xmath434 , that is , @xmath431 is @xmath435 .",
    "we prove that there exists a sequence of tests @xmath436 possibly returned by greedypsp when executed on the instance @xmath437 such that @xmath438 .    by chaining these inequalities ,",
    "we conclude that @xmath439 is @xmath440 the steps ( ii ) , ( iii ) and ( iv ) are proved in claims 1,2 and 3 , respectively .",
    "we start with the construction of instance @xmath243 .",
    "_ construction of instance @xmath243 .",
    "_ for every test @xmath403 , we define @xmath441 .    the instance @xmath442 is constructed from @xmath443 as follows .",
    "let @xmath444 . for each @xmath445",
    "we add @xmath446 objects to @xmath81 , each of them with probability @xmath447 and with class equal to that of @xmath39 .",
    "if an object @xmath448 is added to set @xmath81 due to @xmath39 , we say that @xmath448 is generated from @xmath39 .    for every test @xmath403",
    "we add @xmath449 tests to the set @xmath450 , each of them with cost @xmath451 .",
    "if a test @xmath452 is added to set @xmath450 due to @xmath416 , we say that @xmath452 is generated from @xmath416 .",
    "it remains to define to which subset of @xmath81 each test @xmath453 corresponds to . if @xmath454 then @xmath455 for every @xmath448 generated from @xmath39 and every @xmath452 generated from @xmath416 .",
    "let @xmath456 be the set of tests that contains the object @xmath28 .",
    "note that the number of tuples @xmath457 , where @xmath458 is a test generated from @xmath459 is @xmath460 .",
    "thus , we create a one to one correspondence between these tuples and the numbers in the set @xmath461 . for a test @xmath462 , generated from @xmath463 , let @xmath464 be the set of numbers that correspond to the tuples that includes @xmath465 .",
    "note that @xmath466 in addition , we associate each object @xmath467 , generated from @xmath39 , with a number @xmath468 in a balanced way so that each number in @xmath469 is associated with @xmath470 objects .",
    "thus , a test @xmath462 , generated from @xmath463 , covers an object @xmath448 generated from @xmath39 if and only if @xmath471 .",
    "for the instance @xmath243 we have the following useful properties :    * if @xmath472 covers object @xmath28 then each test @xmath473 , generated from @xmath416 , covers exactly @xmath474 objects generated from @xmath39 .",
    "moreover , each object generated from @xmath39 is covered by exactly one test generated from @xmath416 .",
    "* if a set of tests @xmath475 covers all pairs of @xmath243 then the set @xmath476 all tests generated from @xmath416 belong to @xmath477 covers all pairs of @xmath409 .",
    "property ( a ) holds because a test @xmath465 generated by @xmath416 is associated with @xmath478 numbers in @xmath469 and to each number in @xmath469 we have @xmath479 objects associated with .    to see that property ( b )",
    "holds , let us assume that @xmath480 covers all pairs of the instance @xmath243 and @xmath93 does not cover a pair @xmath481 .",
    "let @xmath482 and @xmath483 be the set of tests that covers @xmath484 and @xmath485 , respectively .",
    "the fact that @xmath93 does not cover @xmath481 implies that @xmath486 so that for each @xmath487 , there is a test @xmath488 , generated from @xmath489 , that does not belong to @xmath480 .",
    "similarly , for each @xmath490 , there is a test @xmath491 , generated from @xmath492 , that does not belong to @xmath480 .",
    "let @xmath493 be an object , generated from @xmath484 , that is mapped , via function @xmath494 , into the number in @xmath495 that corresponds to the tuple @xmath496 .",
    "moreover , let @xmath497 be an object , generated from @xmath485 , that is mapped , via function @xmath494 , into the number in @xmath498 that corresponds to the tuple @xmath499 .",
    "the pair @xmath500 is not covered by @xmath480 , which is a contradiction .    * claim 1 . * the optimal separation cost for @xmath243 is no larger than the optimal separation cost for @xmath501 i.e. , @xmath502    given a sequence @xmath503 for @xmath409 that covers all @xmath287 pairs we can obtain a sequence @xmath504 for @xmath243 by replacing each test @xmath505 with the @xmath506 tests in @xmath450 that were generated from @xmath507 , each of which has cost @xmath508 it is easy to see that @xmath504 covers all the pairs in @xmath243 and the separation cost of @xmath504 is not larger than that of @xmath509 .",
    "this establishes our claim .",
    "now let @xmath432 be a sequence of tests returned by procedure greedypsp in algorithm [ alg : appendix ] when it is executed on the instance @xmath433 .",
    "* claim 2 . *",
    "the separation cost of the sequence @xmath432 is at most a constant factor of that of @xmath510 , which is the sequence of tests with minimum separation cost among all sequences of tests covering all the pairs , for the instance @xmath511 i.e. , @xmath512 for some constant @xmath513    let @xmath514 ( resp .",
    "@xmath515 ) be the sum of the probabilities of the objects covered by the first @xmath516 tests in @xmath432 ( resp .",
    "@xmath517 ) .",
    "in particular , we have @xmath518 in addition , let @xmath123 be the sum of the probabilities of all objects in @xmath81 . notice that , with the above notation , we can rewrite the separation cost of the sequence @xmath519 as @xmath520    let @xmath521 be such that @xmath522 , where @xmath187 is the budget in the statement of the lemma . for @xmath523 , let @xmath524 and @xmath525 .",
    "furthermore , let @xmath526}$ ] be the sum of the probabilities of the objects covered by the first @xmath527 tests of @xmath432 .",
    "in formulae , @xmath526 } = p \\left ( \\bigcup_{k=1}^{i_j } x'_k \\right).$ ] analogously , let @xmath526}_*$ ] be the sum of the probabilities of the objects covered by the first @xmath528 tests in @xmath529 in formulae , @xmath526 } _ * = p\\left(\\bigcup_{k=1}^{i^*_j } x^*_k \\right).$ ] for the sake of definiteness , we set @xmath530 and @xmath531 } = p^{[-1]}_*=0 $ ]    then , we have    @xmath532 } )    \\leq \\sum_{j=0}^{\\ell-1 } 2^{j } ( q - p^{[j-1 ] } ) \\\\ & \\leq & q+ \\sum_{j=1}^{\\ell-1 } 2^{j } ( q - p^{[j-1 ] } )   \\leq q+ \\sum_{j=0}^{\\ell-2 } 2^{j+1 } ( q - p^{[j]}),\\end{aligned}\\ ] ]    where the first inequality holds because @xmath533 and the second one holds because @xmath534}= p_{i_{j-1 } } $ ] for @xmath535 .",
    "we now devise a lower bound on the separation cost of @xmath529 for this , we first note that the length @xmath536 of @xmath517 is at least @xmath537 , for otherwise the property ( b ) of instance @xmath243 would guarantee the existence of a sequence of tests of total cost smaller than @xmath187 that covers all pairs for instance @xmath409 ( and for the instance @xmath77 of the dfep as well ) , which contradicts lemma [ lemma : length ] .",
    "therefore , we can lower bound the the separation cost of the sequence @xmath517 as follows :    @xmath538 } ) \\geq   \\frac{3q}{4 } + \\frac{1}{2 } \\sum_{j=1}^{\\ell-1 } 2^{j } ( q - p_*^{[j ] } )    \\label{eq:27may2}\\end{aligned}\\ ] ]    the inequality in ( [ eq:27may1 ] ) follows from ( [ eq:27may0 ] ) by considering in the summation on the right hand side of ( [ eq:27may1 ] ) only the first @xmath539 tests .    the term @xmath540 in the first inequality ( [ eq:27may2 ] ) is the contribution of the first two tests of the sequence @xmath517 to the separation cost . to prove that @xmath541 in the last inequality , we note that that @xmath542 because the probability covered by the first test @xmath543 of sequence @xmath544 is @xmath545 , where @xmath416 is the test that generates @xmath543 . in the last inequality we used the fact that @xmath546 for all @xmath403",
    "let @xmath547 be the set of objects covered by the sequence of tests @xmath548 , which is the prefix of length @xmath71 of the sequence of tests @xmath432 .",
    "we shall note that for @xmath549 , the subsequence @xmath550 of @xmath432 coincides with the sequence of tests constructed through the execution of adapted - greedy over the instance ( @xmath551 ) , where    * @xmath552 is a set of tests , all of them with cost @xmath553 * the function @xmath186 maps a set of tests into the probability of the objects in @xmath554 that are covered by the tests in the set ; * @xmath555    since the set @xmath556 is a feasible solution for this instance , it follows from theorem 2 that @xmath557 , where @xmath558 by setting @xmath559 and @xmath560 we get that @xmath561 } - p^{[j-1 ] } \\geq \\hat{\\alpha } ( p_*^{[j-1 ] } - p^{[j-1]}).\\ ] ]    it follows that @xmath562 } \\leq \\hat{\\alpha}(q - p_*^{[j-1 ] } ) + ( 1-\\hat{\\alpha } ) ( q - p^{[j-1]}).\\ ] ] thus , setting @xmath563}),\\ ] ] which is the upper bound we derived on the separation cost of the sequence @xmath432 , we have    @xmath564})\\\\ & \\leq &   q + \\hat{\\alpha } \\sum_{j=0}^{\\ell-2 } 2^{j+1 } ( q - p_*^{[j-1 ] } ) + ( 1-\\hat{\\alpha } ) \\sum_{j=0}^{\\ell-2 } 2^{j+1 } ( q - p^{[j-1]})\\\\ & = &   q + 2\\hat{\\alpha}q + \\hat{\\alpha}\\sum_{j=1}^{\\ell-2 } 2^{j+1 } ( q - p_*^{[j-1 ] } ) + 2(1-\\hat{\\alpha})q +   ( 1-\\hat{\\alpha } ) \\sum_{j=1}^{\\ell-2 } 2^{j+1 } ( q - p^{[j-1]})\\\\ & = &   q + 2 q +   2\\hat{\\alpha }   \\sum_{j=0}^{\\ell-3 } 2^{j+1 } ( q - p_*^{[j ] } ) + 2 ( 1-\\hat{\\alpha } )   \\sum_{j=0}^{\\ell-3 } 2^{j+1 } ( q - p^{[j]})\\\\ & \\leq & q + 2 q + 4 \\hat{\\alpha } q   +   2\\hat{\\alpha }   \\sum_{j=1}^{\\ell-3 } 2^{j+1 } ( q - p_*^{[j ] } ) + 2 ( 1-\\hat{\\alpha } )   \\sum_{j=0}^{\\ell-3 } 2^{j+1 } ( q - p^{[j]})\\\\ & = & ( 1 - 2(1-\\hat{\\alpha})+2 + 4\\hat{\\alpha } ) q +    4\\hat{\\alpha }   \\sum_{j=1}^{\\ell-3 } 2^{j } ( q - p_*^{[j ] } )   + 2(1-\\hat{\\alpha})\\left(q + \\sum_{j=0}^{\\ell-3 } 2^{j+1 } ( q - p^{[j]})\\right)\\\\ & \\leq & ( 1 + 6 \\hat{\\alpha } ) q +    4\\hat{\\alpha }   \\sum_{j=1}^{\\ell-1 } 2^{j } ( q - p_*^{[j ] } )   + 2(1-\\hat{\\alpha})u\\\\ & \\leq & ( 8\\hat{\\alpha}+4/3 )   \\ , sepcost(i ' , { \\bf x}^ * ) +   2(1-\\hat{\\alpha } ) u,\\end{aligned}\\ ] ]    where the last inequality follows from equation [ eq:27may2 ] .",
    "thus , we obtain @xmath565    for the last claim let @xmath420 be the sequence obtained by greedypsp ( algorithm [ alg : appendix ] ) when it is executed on instance @xmath425 .",
    "* claim 3 .",
    "* there exists an execution of procedure greedypsp ( algorithm [ alg : appendix ] ) on instance @xmath433 which returns a sequence @xmath436 satisfying @xmath438 .",
    "let @xmath566 be the @xmath42-th test of sequence @xmath420 and let @xmath567 be the first test of @xmath568 that is not the test which maximizes @xmath569 among all the tests in @xmath3 in line ( * ) of algorithm [ alg : appendix ] .",
    "note that @xmath567 is chosen by algorithm [ alg : appendix ] rather than @xmath570 , the test which maximizes @xmath571 , because @xmath570 has cost larger than remaining budget @xmath572 .",
    "the case where @xmath567 does not exist is easier to handle and will be discussed at the end of the proof . because @xmath573 is a prefix of @xmath420",
    "we have @xmath574 thus , to establish the claim it suffices to show that @xmath575 where @xmath436 is a possible output of greedypsp ( algorithm [ alg : appendix ] ) on instance @xmath576    for @xmath577 , let @xmath578 } =   \\langle z^{[j]}_1 , \\dots , z^{[j]}_{n(x_j^a)}\\rangle$ ] be a sequence of tests defined by some permutation of the @xmath579 tests in @xmath450 , generated from @xmath580    let @xmath572 and @xmath581 } =   \\langle z^{[r+1]}_1 , \\dots , z^{[r+1]}_{2z}\\rangle$ ] be a sequence of @xmath582 of the @xmath583 tests in @xmath450 , generated from @xmath584 the proof of the following proposition is deferred to section [ app : prop ] .    [ prop : claim3-apendix ] let @xmath585 } \\ , { \\bf z}^{[2]}\\ , \\dots \\ , { \\bf z}^{[r ] } \\ , { \\bf z}^{[r+1]}$ ] be the sequence obtained by the juxtaposition of the sequences @xmath586 } , \\dots , { \\bf z}^{[r+1]}.$ ] then , for @xmath436 the following conditions hold :    * for each @xmath587 and @xmath588 , it holds that @xmath589}_{\\kappa } \\cap z^{[j]}_{\\kappa ' } = \\emptyset\\ ] ] * for each @xmath587 and each test @xmath123 in @xmath590 with @xmath416 being the test in @xmath3 from which @xmath123 is generated , it holds that @xmath591}_{\\kappa ' } ) } { c(q ) }   = \\frac{p(x - \\bigcup_{i=1}^{j-1 } x^a_{i})}{c(x)}\\ ] ] * @xmath436 is a feasible output for greedypsp ( algorithm [ alg : appendix ] ) on instance @xmath576    first note that the sequence @xmath436 has length @xmath203 and total cost @xmath187 .",
    "this is easily verified by recalling that : ( i ) each test in the sequence @xmath436 has cost @xmath451 ; ( ii ) for each @xmath592 the subsequence @xmath578}$ ] has length @xmath593 hence @xmath594 } ) =   n(x^a_j)/2 = c(x^a_j)$ ] ; ( iii ) the subsequence @xmath581}$ ] has length @xmath595}|)$ ] hence @xmath596 } ) = z = b - \\sum_{j=1}^r totcost(i ' , { \\bf z}^{[j]})$ ] .",
    "let @xmath597 , and for @xmath592 let @xmath598 . by the observations in the previous paragraph",
    ", we also have @xmath599}\\,\\dots \\ , { \\bf z}^{[j ] } > ) = \\sum_{i=1}^j \\sum_{\\kappa = 1}^{n(x^a_i ) } c(z_{\\kappa}^{[i]}).$ ]    by grouping objects which incur the same cost in @xmath600 we can write @xmath601 as follows @xmath602      now , we notice that for each @xmath587 and @xmath608 the set of objects covered by @xmath609}_{\\kappa}$ ] and not covered by the previous tests are @xmath610 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right ) =   z_{\\kappa}^{[j ] } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right)\\ ] ] where the equality follows because by proposition [ prop : claim3-apendix ] ( i ) we have that @xmath605 } \\cap \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right ) = \\emptyset.$ ]    moreover , by proposition [ prop : claim3-apendix ] ( ii ) we have that @xmath611 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right)\\right ) =   \\frac{p\\left(x^a_j - \\bigcup_{i=1}^{j-1 } x^a_i \\right)}{n(x^a_j)}.\\ ] ] finally , the set @xmath612}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa=1}^{2z } z^{[r+1]}_{\\kappa } \\right)\\ ] ] that appears in the third term of the righthand side of ( [ eq:24 ] ) can be spilt into the objects covered by the tests generated from @xmath570 and the remaining ones . by using arguments similar to those employed above one can realize that the objects covered by the tests generated from @xmath570 are exactly those generated by the objects in @xmath613 that are not covered by the tests in @xmath614}_{\\kappa } \\right)$ ] .",
    "thus , their contribution to @xmath615 is @xmath616 . on the other hand ,",
    "the contribution to @xmath615 of the remaining objects is @xmath617    therefore , we can rewrite ( [ eq:24 ] ) as follows    @xmath618    via simple algebraic manipulation on the first term in the right hand side of ( [ eq:25 ] ) we have that @xmath619 and , analogously , for the second term in the right hand side of ( [ eq:25 ] ) we have @xmath620    hence , we have    @xmath621    finally , we observe that @xmath622 and @xmath623 then , the sum of the second and third term in the right hand side of ( [ eq:26 ] ) can be lower bounded with @xmath624 and we get    @xmath625    putting together ( [ eq:27 ] ) and ( [ eq : sep_b - x ] ) we have the desired result    @xmath626    it remains to argue about the case where @xmath567 does not exist , which means that all tests that maximize the greedy criteria in algorithm [ alg : appendix ] have cost smaller than the current budget @xmath187 . in this case ,",
    "the analysis becomes simpler and be easily handled in the same way as above .",
    "in fact , the only difference is that the last term in ( [ eq : sep_b - x ] ) disappears , as well as all the terms referring to @xmath570 and @xmath581}.$ ]    the lemma follows from the correctness of the three claims .",
    "* proposition [ prop : claim3-apendix ] . *    _ let @xmath585 } \\ , { \\bf z}^{[2]}\\ , \\dots \\ , { \\bf z}^{[r ] } \\ , { \\bf z}^{[r+1]}$ ] be the sequence obtained by the juxtaposition of the sequences @xmath586 } , \\dots , { \\bf z}^{[r+1]}.$ ] then , for @xmath436 the following conditions hold : _    * for each @xmath587 and @xmath588",
    ", it holds that @xmath589}_{\\kappa } \\cap z^{[j]}_{\\kappa ' } = \\emptyset\\ ] ] * for each @xmath587 and each test @xmath123 in @xmath590 with @xmath416 being the test in @xmath3 from which @xmath123 is generated , it holds that @xmath591}_{\\kappa ' } ) } { c(q ) }   = \\frac{p(x - \\bigcup_{i=1}^{j-1 } x^a_{i})}{c(x)}\\ ] ] * @xmath436 is a feasible output for greedypsp ( algorithm [ alg : appendix ] ) on instance @xmath576      in order to prove ( ii ) , we observe that , from the definition of the sequences @xmath627}$ ] ( @xmath628 ) , it follows that the elements of @xmath629}_{\\kappa'}$ ] are all the elements in @xmath81 which are generated from @xmath630 therefore , the elements of @xmath631 are precisely the elements of @xmath123 which are generated from @xmath632    for each @xmath633 there are precisely @xmath634 elements in @xmath123 that are generated from @xmath39 , and each one of them has probability @xmath635 hence we have @xmath636}_{\\kappa ' } \\right ) } { c(q ) } = \\frac{1}{c(q)}\\sum_{s \\in x - \\bigcup_{i=1}^{j-1 } x^a_i } \\frac{n}{n(x)}\\frac{p(s)}{n } = \\frac{1}{c(q ) n(x ) } \\sum_{s \\in x - \\bigcup_{i=1}^{j-1 } x^a_i } p(s),\\ ] ] from which we have ( ii ) , since @xmath637      _ claim . _ for each @xmath638 and @xmath639 we have that @xmath640 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right)\\right)}{c(z_{\\kappa}^{[j ] } ) }   \\geq   \\frac{p\\left(q - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right)\\right)}{c(q)}\\ ] ] for any @xmath641    this claim says that , for each @xmath587 and @xmath642 if @xmath436 has been constructed up to the test preceding @xmath605}$ ] then with respect to the tests already chosen , the test @xmath605}$ ] satisfies the greedy criterium of procedure greedypsp .",
    "this implies that @xmath436 is a feasible output for greedypsp , as desired .",
    "_ proof of the claim .",
    "_ let @xmath185 be the quantity on the right hand side of ( [ eq : z - greedy ] ) , and @xmath416 be the test in @xmath3 from which @xmath123 is generated .",
    "then we have @xmath643}_{\\kappa ' } \\right)\\right ) } { c(q ) }   \\label{ineq : greedy - z-1}\\\\ & = & \\frac{p(x - \\bigcup_{i=1}^{j-1 } x^a_{i})}{c(x ) } \\label{ineq : greedy - z-2 } \\\\ &",
    "\\leq &   \\frac{p\\left(z_{\\kappa}^{[j ] } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   \\right)}{c(z_{\\kappa}^{[j ] } ) } \\label{ineq : greedy - z-3}\\\\ & = &   \\frac{p\\left(z_{\\kappa}^{[j ] } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right)\\right)}{c(z_{\\kappa}^{[j ] } ) }   \\label{ineq : greedy - z-4}\\end{aligned}\\ ] ]    inequality ( [ ineq : greedy - z-1 ] ) holds since the set whose probability is considered at the numerator of the right hand side of ( [ ineq : greedy - z-1 ] ) is a superset of the set whose probability is considered at the numerator of the right hand side of ( [ eq : z - greedy ] ) .",
    "@xmath647 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   \\right)}{c(z_{\\kappa}^{[j]})}\\ ] ] and the last equality follows from property ( ii ) of the proposition under analysis .    if @xmath644 we have that , by definition is the test in @xmath3 which maximizes the greedy criterium , but is not chosen because it exceeds the available budget ] of @xmath570 and the sequence @xmath581},$ ] it holds that @xmath648 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   \\right)}{c(z_{\\kappa}^{[j]})}\\ ] ] where the last equality follows from property ( ii ) above .",
    "finally , ( [ ineq : greedy - z-4 ] ) follows from ( [ ineq : greedy - z-3 ] ) because of property ( i ) above , from which we have that @xmath605 } \\cap \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right ) = \\emptyset$ ] hence , + @xmath649 } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right )   - \\left ( \\bigcup_{\\kappa'=1}^{\\kappa-1 } z^{[j]}_{\\kappa ' } \\right)\\right ) =   p\\left(z_{\\kappa}^{[j ] } - \\left(\\bigcup_{i=1}^{j-1 } \\bigcup_{\\kappa'=1}^{n(x^a_i ) } z^{[i]}_{\\kappa ' } \\right)\\right).$ ]"
  ],
  "abstract_text": [
    "<S> in several applications of automatic diagnosis and active learning a central problem is the evaluation of a discrete function by adaptively querying the values of its variables until the values read uniquely determine the value of the function . </S>",
    "<S> in general , the process of reading the value of a variable might involve some cost , computational or even a fee to be paid for the experiment required for obtaining the value . </S>",
    "<S> this cost should be taken into account when deciding the next variable to read . </S>",
    "<S> the goal is to design a strategy for evaluating the function incurring little cost ( in the worst case or in expectation according to a prior distribution on the possible variables assignments ) .    </S>",
    "<S> our algorithm builds a strategy ( decision tree ) which attains a logarithmic approximation simultaneously for the expected and worst cost spent . </S>",
    "<S> this is best possible under the assumption that @xmath0 .    0.3 in </S>"
  ]
}