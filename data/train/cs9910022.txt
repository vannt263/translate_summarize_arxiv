{
  "article_text": [
    "several methods of regular approximation of context - free languages have been proposed in the literature . for some ,",
    "the regular language is a superset of the context - free language , and for others it is a subset . we have implemented a large number of methods , and where needed we refined them with an analysis of the grammar .",
    "we also propose a number of new methods .",
    "the analysis is based on a sufficient condition for context - free grammars to generate regular languages . for an arbitrary grammar , this analysis identifies sets of rules that need to be processed in a special way in order to obtain a regular language .",
    "the nature of this processing differs for the respective approximation methods . for other parts of the grammar ,",
    "no special treatment is needed and the grammar rules are translated to states and transitions of a finite automaton without affecting the language .",
    "few of the published articles on regular approximation have discussed the application in practice . in particular , little attention has been given to the following two questions .",
    "first , what happens when a context - free grammar grows in size ? what is then the increase of the sizes of the intermediate results and the obtained minimal deterministic automaton ?",
    "second , how `` precise '' are the approximations ? that is , how much larger than the original context - free language",
    "is the language obtained by a superset approximation , and how much smaller is the language obtained by a subset approximation ? ( how we measure the `` sizes '' of languages in a practical setting will become clear in the sequel . )    some considerations with regard to theoretical upper bounds on the sizes of the intermediate results and the finite automata have already been discussed by . in this article",
    "we will try to answer the above two questions in a practical setting , using practical linguistic grammars and sentences taken from a spoken - language corpus .",
    "the structure of this paper is as follows . in section  [ prel ]",
    "we recall some standard definitions from language theory .",
    "section  [ trees ] investigates a sufficient condition for a context - free grammar to generate a regular language .",
    "we also present the construction of a finite automaton from such a grammar .    in section  [ approx ]",
    ", we discuss several methods to approximate the language generated by a grammar if the sufficient condition mentioned above is not satisfied .",
    "these methods can be enhanced by a grammar transformation presented in section  [ increase ] .",
    "section  [ compare ] compares the respective methods , which leads to conclusions in section  [ conclude ] .",
    "throughout this paper we use standard formal language notation ( see e.g.  ) . in this section",
    "we recall some basic definitions .    a * context - free grammar * @xmath0 is a @xmath1-tuple @xmath2 , where @xmath3 and @xmath4 are two finite disjoint sets of terminals and nonterminals , respectively",
    ", @xmath5 is the start symbol , and @xmath6 is a finite set of rules .",
    "each rule has the form @xmath7 with @xmath8 and @xmath9 , where @xmath10 denotes @xmath11 .",
    "the relation @xmath12 on @xmath13 is extended to a relation on @xmath14 as usual .",
    "the transitive and reflexive closure of @xmath12 is denoted by @xmath15 .",
    "the language * generated * by @xmath0 is given by the set @xmath16 . by definition ,",
    "such a set is a * context - free * language . by * reduction * of a grammar we mean the elimination from @xmath6 of all rules @xmath17 such that @xmath18 does not hold for any @xmath19 and @xmath20 .",
    "we generally use symbols @xmath21 to range over @xmath22 , symbols @xmath23 to range over @xmath24 , symbols @xmath25 to range over @xmath26 , symbols @xmath27 to range over @xmath28 , and symbols @xmath29 to range over @xmath30 .",
    "we write @xmath31 to denote the empty string .    a rule of the form @xmath32",
    "is called a * unit * rule . a ( nondeterministic ) * finite automaton",
    "* @xmath33 is a 5-tuple @xmath34 , where @xmath35 is a finite set of * states * , of which @xmath36 is the * initial * state and those in @xmath37 are the * final * states , @xmath3 is the input alphabet , and the * transition relation * @xmath38 is a finite subset of @xmath39 .",
    "we define a * configuration * to be an element of @xmath40 .",
    "we define the binary relation @xmath41 between configurations as : @xmath42 if and only if @xmath43 . the transitive and reflexive closure of @xmath41",
    "is denoted by @xmath44 .",
    "some input @xmath45 is * recognized * if @xmath46 , for some @xmath47 .",
    "the language * accepted * by @xmath33 is defined to be the set of all strings @xmath45 that are recognized . by definition , a language accepted by a finite automaton",
    "is called a * regular * language .",
    "we define a * spine * in a parse tree to be a path that runs from the root down to some leaf .",
    "our main interest in spines lies in the sequences of grammar symbols at nodes bordering on spines .",
    "a simple example is the set of parse trees such as the one in figure  [ pal ] , for a grammar of palindromes .",
    "it is intuitively clear that the language is not regular : the grammar symbols to the left of the spine from the root to @xmath31 `` communicate '' with those to the right of the spine .",
    "more precisely , the prefix of the input up to the point where it meets the final node @xmath31 of the spine determines the suffix after that point , in a way that an unbounded quantity of symbols from the prefix need to be taken into account .    a formal explanation for why the grammar may not generate a regular language relies on the following definition @xcite :    a grammar is * self - embedding * if there is some @xmath48 such that @xmath49 , for some @xmath50 and @xmath51",
    ".    if a grammar is not self - embedding , this means that when a section of a spine in a parse tree repeats itself , then either no grammar symbols occur to the left of that section of the spine , or no grammar symbols occur to the right .",
    "this prevents the `` unbounded communication '' between the two sides of the spine exemplified by the palindrome grammar .",
    "we now prove that grammars that are not self - embedding generate regular languages .",
    "for an arbitrary grammar , we define the set of * recursive * nonterminals as : @xmath52\\}\\ ] ] we determine the partition @xmath53 of @xmath54 consisting of subsets @xmath55 , for some @xmath56 , of * mutually recursive * nonterminals :    @xmath57 + @xmath58 + @xmath59\\mbox { and }   \\forall i , j[i\\neq j \\rightarrow n_i \\cap n_j=\\emptyset]$ ] + @xmath60\\ \\",
    "\\leftrightarrow \\ \\   \\exists",
    "\\alpha_1,\\beta_1,\\alpha_2,\\beta_2[a { { \\rightarrow}^{*}}\\alpha_1 b\\beta_1   \\wedge b { { \\rightarrow}^{*}}\\alpha_2 a \\beta_2 ] , \\mbox { for all } a , b\\in \\overline{n } $ ]    we now define the function @xmath61 from @xmath53 to the set @xmath62 . for @xmath63 : @xmath64{rclcrcr } { \\mbox{\\it recursive\\/}}(n_i ) & = & { \\mbox{\\it left\\/ } } , & { \\it if } & \\neg{\\mbox{\\it leftgenerating\\/}}(n_i)&\\wedge&{\\mbox{\\it rightgenerating\\/}}(n_i ) \\\\                  & = & { \\mbox{\\it right\\/ } } , & { \\it if } & { \\mbox{\\it leftgenerating\\/}}(n_i)&\\wedge&\\neg{\\mbox{\\it rightgenerating\\/}}(n_i ) \\\\                  & = & { \\mbox{\\it self\\/ } } , & { \\it if } & { \\mbox{\\it leftgenerating\\/}}(n_i)&\\wedge&{\\mbox{\\it rightgenerating\\/}}(n_i ) \\\\                  & = & { \\mbox{\\it cyclic\\/ } } , & { \\it if } & \\neg{\\mbox{\\it leftgenerating\\/}}(n_i)&\\wedge&\\neg{\\mbox{\\it rightgenerating\\/}}(n_i ) \\end{array}\\ ] ] where @xmath65 \\\\ { \\mbox{\\it rightgenerating\\/}}(n_i ) & = & \\exists ( a { \\rightarrow}\\alpha b \\beta)\\in p [ a\\in n_i \\wedge b\\in n_i \\wedge \\beta\\neq{\\epsilon}]\\end{aligned}\\ ] ] when @xmath66 , @xmath67 consists of only left - recursive nonterminals , which does not mean it can not also contain right - recursive nonterminals , but in that case right recursion amounts to application of unit rules . when @xmath68 , it is _ only _ such unit rules that take part in the recursion .    that @xmath69 , for some @xmath70 , is a sufficient and necessary condition for the grammar to be self - embedding",
    ". therefore , we have to prove that if @xmath71 , for all @xmath70 , then the grammar generates a regular language .",
    "our proof differs from an existing proof @xcite in that it is fully constructive : figure  [ tofs ] presents an algorithm for creating a finite automaton that accepts the language generated by the grammar .",
    "@xmath35 = @xmath72,@xmath36 = , @xmath73 = , @xmath74 = @xmath75 ; + @xmath76 .",
    "+   + @xmath77 : +  = @xmath78 + @xmath38 = @xmath79 + @xmath80 , @xmath81 + @xmath38 = @xmath82 + @xmath83 , @xmath84 , @xmath85 @xmath86 + = @xmath87 = ; + @xmath88 ; + @xmath89 + = @xmath90 = @xmath91 ;   ( * @xmath91 must consist of a single nonterminal * ) + * there exists * @xmath70 * such that * @xmath92 + = @xmath93 @xmath94 =  ; + @xmath95 = + = @xmath96 @xmath97 + @xmath98 + ; + = @xmath99 +   @xmath100 + @xmath101 + ; + @xmath38 = @xmath102 + = ( * @xmath95 @xmath103 @xmath104 * ) + @xmath96 @xmath105 + @xmath106 + ; + = @xmath107 +   @xmath100 + @xmath108 + ; + @xmath38 = @xmath109 +   + = @xmath110 @xmath111   ( * @xmath90 is not recursive * ) +   +   + .",
    "+   + @xmath112 : + create some object @xmath87 such that @xmath113 ; + @xmath35 = @xmath114 ; + @xmath87 + .",
    "the process is initiated at the start symbol , and from there the process descends the grammar in all ways until terminals are encountered , and then transitions are created labelled with those terminals . descending the grammar is straightforward in the case of rules of which the left - hand side is not a recursive nonterminal : the subautomata found recursively for members in the right - hand side will be connected . in the case of recursive nonterminals ,",
    "the process depends on whether the nonterminals in the corresponding set from @xmath53 are mutually left - recursive or right - recursive ; if they are both , which means they are cyclic , then either subprocess can be applied ; in the code in figure  [ tofs ] cyclic and right - recursive subsets @xmath67 are treated uniformly .",
    "we discuss the case that the nonterminals are left - recursive .",
    "one new state is created for each nonterminal in the set .",
    "the transitions that are created for terminals and nonterminals not in @xmath67 are connected in a way that is reminiscent of the construction of left - corner parsers @xcite , and specifically of one construction that focuses on sets of mutually recursive nonterminals ( * ? ? ?",
    "* section  5.8 ) .",
    "an example is given in figure  [ fsa ] .",
    "four states have been labelled according to the names they are given in procedure @xmath115 .",
    "there are two states that are labelled @xmath94 .",
    "this can be explained by the fact that nonterminal @xmath116 can be reached by descending the grammar from @xmath117 in two essentially distinct ways .",
    "@xmath118       @xmath119 + @xmath120 + @xmath121 + @xmath122 +     +    the code in figure  [ tofs ] differs from the actual implementation in that sometimes for a nonterminal a separate finite automaton is constructed , viz .   for those nonterminals that occur as @xmath90 in the code .",
    "a transition in such a subautomaton may be labelled by another nonterminal @xmath116 , which then represents the subautomaton corresponding to @xmath116 .",
    "the resulting representation is similar to extended context - free grammars @xcite , with the exception that in our case recursion can not occur , by virtue of the construction .",
    "the representation for the running example is indicated by figure  [ mac ] , which shows two subautomata , labelled @xmath117 and @xmath116 .",
    "the one labelled @xmath117 is the automaton on the top level , and contains two transitions labelled @xmath116 , which refer to the other subautomaton .",
    "note that this representation is more compact than the one from figure  [ fsa ] , since the transitions that are involved in representing the sublanguage of strings generated by nonterminal @xmath116 are included only once .",
    "the compact representation consisting of subautomata can be turned into a single finite automaton by substituting subautomata @xmath90 for transitions labelled @xmath90 in other automata .",
    "this comes down to regular substitution in the sense of .",
    "the advantage of this way of obtaining a finite automaton over a direct construction of a nondeterministic automaton is that subautomata may be determinized and minimized before they are substituted into larger subautomata . since in many cases determinized and minimized automata are much smaller",
    ", this process avoids much of the combinatorial explosion that takes place upon naive construction of a single nondeterministic finite automaton .",
    "assume we have a list of subautomata @xmath123 that is ordered from lower level to higher level automata ; i.e.   if an automaton @xmath124 occurs as label of a transition of automaton @xmath125 , then @xmath126 ; @xmath127 must be the start symbol @xmath117 .",
    "this order is a natural result of the way that subautomata are constructed during our depth - first traversal of the grammar , which is actually * postorder * in the sense that a subautomaton is output after all subautomata occurring at its transitions have been output .",
    "our implementation constructs a minimal deterministic automaton by repeating the following for @xmath128 :    1 .",
    "make a copy of @xmath124 .",
    "determinize and minimize the copy .",
    "if it has fewer transitions labelled by nonterminals than the original , then replace @xmath124 by its copy .",
    "2 .   replace each transition in @xmath124 of the form @xmath129 by ( a copy of ) automaton @xmath130 in a straightforward way .",
    "this means that new @xmath31-transitions connect @xmath87 to the start state of @xmath130 and the final states of @xmath130 to @xmath131 .",
    "3 .   again",
    "determinize and minimize @xmath124 and store it for later reference .",
    "the automaton obtained for @xmath127 after step  3 is the desired result .",
    "this section describes a number of methods for approximating a context - free grammar by means of a finite automaton .",
    "some published methods did not mention self - embedding explicitly as potential source of non - regularity of the language , and suggested that approximations should be applied globally for the complete grammar . where this is the case ,",
    "we adapt the method so that it is more selective and deals with self - embedding locally .",
    "the approximations are integrated into the construction of the finite automaton from the grammar , which was described in the previous section .",
    "a separate incarnation of the approximation process is activated upon finding a nonterminal @xmath90 such that @xmath92 and @xmath132 , for some @xmath70 .",
    "this incarnation then only pertains to the set of rules of the form @xmath133 , where @xmath93 . in other words ,",
    "nonterminals not in @xmath67 are treated by this incarnation of the approximation process as if they were terminals .",
    "the following approximation was proposed by .",
    "the presentation here however differs substantially from the earlier publication , which treated the approximation process entirely on the level of context - free grammars : a self - embedding grammar was transformed in such a way that it was no longer self - embedding .",
    "a finite automata was then obtained from the grammar by the algorithm discussed above .",
    "the presentation here is based on recursive transition networks ( rtns ) @xcite .",
    "we can see a context - free grammar as an rtn as follows .",
    "we introduce two states @xmath134 and @xmath135 for each nonterminal @xmath90 , and @xmath136 states @xmath137 for each rule @xmath138 .",
    "the states for a rule @xmath138 are connected with each other and to the states for the left - hand side @xmath90 by one transition @xmath139 , a transition @xmath140 for each @xmath70 such that @xmath141 , and one transition @xmath142 .",
    "( actually , some epsilon transitions are avoided in our implementation , but we will not be concerned with such optimizations here . )    in this way , we obtain a finite automaton with initial state @xmath134 and final state @xmath135 for each nonterminal @xmath90 and its defining rules @xmath138 .",
    "this automaton can be seen as one component of the rtn .",
    "the complete rtn is obtained by the collection of all such finite automata for different nonterminals .",
    "an approximation now results if we join all the components in one big automaton , and if we approximate the usual mechanism of recursion by replacing each transition @xmath143 by two transitions @xmath144 and @xmath145 .",
    "the construction is illustrated in figure  [ rtn ] .    in terms of the original grammar ,",
    "this approximation can be informally explained as follows .",
    "suppose we have three rules @xmath146 , @xmath147 , and @xmath17 .",
    "top - down left - to - right parsing would proceed for example by recognizing @xmath91 in the first rule ; it would then descend into rule @xmath17 , and recognize @xmath148 ; it would then return to the first rule and subsequently process @xmath149 . in the approximation however , the finite automaton `` forgets '' which rule it came from when it starts to recognize @xmath148 , so that it may subsequently recognize @xmath150 in the second rule .",
    "for the sake of presentational convenience , the above describes a construction working on the complete grammar .",
    "however , our implementation applies the construction separately for each nonterminal in a set @xmath67 such that @xmath132 , which leads to a separate subautomaton of the compact representation ( section  [ trees ] ) .    see for a variant of this approximation that constructs finite transducers rather than finite automata .",
    "we have further implemented a parameterized version of the rtn approximation .",
    "a state of the nondeterministic automaton is now also associated to a list @xmath151 of length @xmath152 strictly smaller than a number @xmath153 , which is the parameter to the method .",
    "this list represents a history of rule positions that were encountered in the computation leading to the present state .",
    "more precisely , we define an * item * to be an object of the form @xmath154 $ ] , where @xmath155 is a rule from the grammar .",
    "these are the same objects as the `` dotted '' productions from .",
    "the dot indicates a position in the right - hand side .",
    "the unparameterized rtn method had one state @xmath156 for each item @xmath157 , and two states @xmath134 and @xmath158 for each nonterminal @xmath90 .",
    "the parameterized rtn method has one state @xmath159 for each item @xmath157 and each list of items @xmath151 that represents a valid history for reaching @xmath157 , and two states @xmath160 and @xmath161 for each nonterminal @xmath90 and each list of items @xmath151 that represents a valid history for reaching @xmath90 .",
    "such a valid history is defined to be a list @xmath151 with @xmath162 that represents a series of positions in rules that could have been invoked before reaching @xmath157 or @xmath90 , respectively .",
    "more precisely , if we set @xmath163 , then each @xmath164 ( @xmath165 ) should be of the form @xmath166 $ ] and for @xmath167 we should have @xmath168 .",
    "furthermore , for a state @xmath159 with @xmath169 $ ] we demand @xmath170 if @xmath171 . for a state @xmath160",
    "we demand @xmath170 if @xmath171 .",
    "( strictly speaking , states @xmath160 and @xmath159 , with @xmath172 and @xmath173 $ ] , will only be needed if @xmath174 is the start symbol in the case @xmath175 , or if @xmath90 is the start symbol in the case @xmath176 . )",
    "the transitions of the automaton that pertain to terminals in right - hand sides of rules are very similar to those in the case of the unparameterized method : for a state @xmath159 with @xmath157 of the form @xmath177 $ ] , we create a transition @xmath178 , with @xmath179 $ ] .",
    "similarly , we create epsilon transitions that connect left - hand sides and right - hand sides of rules : for each state @xmath160 there is a transition @xmath180 for each item @xmath181 $ ] , for some @xmath91 , and for each state of the form @xmath182 , with @xmath183 $ ] , there is a transition @xmath184 .    for transitions that pertain to nonterminals in the right - hand sides of rules , we need to manipulate the histories . for a state @xmath159 with @xmath157 of the form @xmath185",
    "$ ] , we create two epsilon transitions .",
    "one is @xmath186 , where @xmath187 is defined to be @xmath188 if @xmath189 , and to be the first @xmath190 items of @xmath188 otherwise .",
    "informally , we extend the history by the item @xmath157 representing the rule position that we have just come from , but the oldest information in the history is discarded if the history becomes too long .",
    "the second transition is @xmath191 , with @xmath192 $ ] .",
    "if the start symbol is @xmath117 , the initial state is @xmath193 and the final state is @xmath194 ( after the symbol @xmath117 in the subscripts we find an empty lists of items ) .",
    "note that the parameterized method with @xmath195 concurs with the unparameterized method , since the lists of items then remain empty .",
    "an example with parameter @xmath196 is given in figure  [ param ] .",
    "for the unparameterized method , each @xmath197 $ ] corresponded to one state ( figure  [ rtn ] ) . since reaching",
    "@xmath90 can have three different histories of length shorter than 2 ( the empty history , since @xmath90 is start symbol ; the history of coming from the rule position given by item @xmath198 $ ] ; and , the history of coming from the rule position given by item @xmath199 $ ] ) , in figure  [ param ] we now have three states of the form @xmath159 for each @xmath197 $ ] , as well as three states of the form @xmath160 and @xmath161",
    ".    the higher we choose @xmath153 , the more precise the approximation is , since the histories allow the automaton to simulate part of the mechanism of recursion from the original grammar , and the maximum length of the histories corresponds to the number of levels of recursion that can be simulated accurately .",
    "we rephrase the method by as follows .",
    "first , we construct the approximating finite automaton according to the unparameterized rtn method above .",
    "then an additional mechanism is introduced that ensures for each rule @xmath138 separately that the list of visits to the states @xmath137 satisfies some reasonable criteria : a visit to @xmath200 , with @xmath201 , should be followed by one to @xmath202 or @xmath203 .",
    "the latter option amounts to a nested incarnation of the rule .",
    "there is a complementary condition for what should precede a visit to @xmath200 , with @xmath204 .",
    "since only pairs of consecutive visits to states from the set @xmath205 are considered , finite - state techniques suffice to implement such conditions .",
    "this can be realized by attaching histories to the states as in the case of the parameterized rtn method above , but now each history is a set rather than a list , and can contain at most one item @xmath154 $ ] for each rule @xmath155 . as reported by and confirmed by our own experiments , the nondeterministic finite automata resulting from this method may be quite large , even for small grammars .",
    "the explanation is that the number of such histories is exponential in the number of rules .",
    "we have refined the method with respect to the original publication by applying the construction separately for each nonterminal in a set @xmath67 such that @xmath132 .",
    "putting restrictions on spines is another way to obtain a regular language .",
    "several methods can be defined .",
    "the first method we present investigates spines in a very detailed way .",
    "it eliminates from the language only those sentences for which a subderivation is required of the form @xmath206 , for some @xmath207 and @xmath208 .",
    "the motivation is that such sentences do not occur frequently in practice , since these subderivations make it difficult for people to comprehend them @xcite .",
    "their exclusion will therefore not lead to much loss of coverage of typical sentences , especially for simple application domains .",
    "we express the method in terms of a grammar transformation in figure  [ expo.alg ] .",
    "the effect of this transformation is that a nonterminal @xmath90 is tagged with a set of pairs @xmath209 , where @xmath116 is a nonterminal occurring higher in the spine ; for given @xmath116 , at most one such pair @xmath209 can be contained in the set .",
    "the set @xmath210 may contain the element @xmath211 to indicate that something to the left of the part of the spine from @xmath116 to @xmath90 was generated .",
    "similarly , @xmath212 indicates that something to the right was generated .",
    "if @xmath213 , then we have obtained a derivation @xmath214 , for some @xmath207 and @xmath208 , and further occurrences of @xmath116 below @xmath90 should be blocked in order to avoid a derivation with self - embedding .    ' '' ''    we are given a grammar @xmath215 .",
    "the following is to be performed for each set @xmath216 such that @xmath132 .    1 .   for each @xmath92 and each @xmath217 ,",
    "add the following nonterminal to @xmath4 .",
    "* @xmath218 .",
    "2 .   for each @xmath92 , add the following rule to @xmath6 .",
    "* @xmath219 .",
    "3 .   for each @xmath220",
    "such that @xmath221 and no symbols from @xmath222 are members of @xmath67 , and each @xmath74 such that @xmath223 , add the following rule to @xmath6 . *",
    "@xmath224 , where , for @xmath225 , * * @xmath226 ; * * @xmath227 if @xmath228 $ ] , and @xmath229 otherwise ; * * @xmath230 if @xmath231 , and @xmath232 otherwise ; * * @xmath233 if @xmath234 , and @xmath235 otherwise .",
    "4 .   remove from @xmath6 the old rules of the form @xmath236 , where @xmath92 .",
    "reduce the grammar .    ' '' ''",
    "an example is given in figure  [ seblock ] .",
    "the original grammar is implicit in the depicted parse tree on the left , and contains at least the rules @xmath237 , @xmath238 , @xmath239 and @xmath240 .",
    "this grammar is self - embedding , since we have a subderivation @xmath241 .",
    "we explain how @xmath242 is obtained from @xmath243 in the rule @xmath244 .",
    "we first construct @xmath245 from @xmath246 by adding @xmath247 , since no other pair of the form @xmath248 was already present .",
    "to the left of the occurrence of @xmath116 in the original rule @xmath238 we find a non - empty string @xmath249 .",
    "this means that we have to add @xmath211 to all second components of pairs in @xmath250 , which gives us @xmath251 .",
    "@xmath252 f_a & = & \\{(s,\\{r\\})\\ }",
    "\\\\[0.6 cm ] f_b & = & \\{(s,\\{l , r\\}),(a,\\{l\\})\\ } \\\\[0.6 cm ] f_c & = & \\{(s,\\{l , r\\}),(a,\\{l\\}),(b,\\emptyset)\\ } \\\\[0.6 cm ] f_s ' & = & \\{(s,\\{l , r\\}),(a,\\{l\\}),(b,\\emptyset),(c,\\emptyset)\\ } \\\\[.5cm]\\end{aligned}\\ ] ]    in the transformed grammar , the lower occurrence of @xmath117 in the tree is tagged with the set @xmath253 .",
    "the meaning is that higher up in the spine , we will find the nonterminals @xmath117 , @xmath90 , @xmath116 and @xmath254 .",
    "the pair @xmath255 indicates that since we saw @xmath90 on the spine , something to the left has been generated , viz .",
    "the pair @xmath256 indicates that nothing either to the left or to the right has been generated since we saw @xmath116 .",
    "the pair @xmath257 indicates that both to the left and to the right something has been generated ( viz .",
    "@xmath249 on the left and @xmath258 on the right ) .",
    "since this indicates that an offending subderivation @xmath259 has been found , further completion of the parse tree is blocked : the transformed grammar will not have any rules with left - hand side @xmath260 .",
    "in fact , after the grammar is reduced , any parse tree that is constructed can not even contain any longer a node labelled by @xmath260 , or _",
    "any _ nodes with labels of the form @xmath261 such that @xmath262 .",
    "one could generalize this approximation in such a way that not all self - embedding is blocked , but only self - embedding occurring , say , twice in a row , in the sense of a subderivation of the form @xmath263 .",
    "we will not do so here , because already for the basic case above , the transformed grammar can be huge due to the high number of nonterminals of the form @xmath261 that may result ; the number of such nonterminals is exponential in the size of @xmath67 .",
    "we therefore present , in figure  [ expo3.alg ] , an alternative approximation that has a lower complexity . by parameter @xmath153",
    ", it restricts the number of rules along a spine that may generate something to the left and to the right .",
    "we do however not restrict pure left recursion and pure right recursion . between two occurrences of an arbitrary rule , we allow left recursion followed by right recursion ( which leads to tag @xmath264 followed by tag @xmath265 ) , or right recursion followed by left recursion ( which leads to tag @xmath211 followed by tag @xmath266 ) .    ' '' ''    we are given a grammar @xmath215 .",
    "the following is to be performed for each set @xmath216 such that @xmath132 .",
    "the value @xmath153 stands for the maximum number of unconstrained rules along a spine , possibly alternated with a series of left - recursive rules followed by a series of right - recursive rules , or vice versa .    1 .   for each @xmath92 , each @xmath267 , and each @xmath73 such that @xmath268 , add the following nonterminals to @xmath4 .",
    "* @xmath269 .",
    "2 .   for each @xmath92 , add the following rule to @xmath6 .",
    "* @xmath270 .",
    "3 .   for each @xmath92 and @xmath73",
    "such that @xmath271 , add the following rules to @xmath6 . * @xmath272 .",
    "* @xmath273 .",
    "* @xmath274 .",
    ". * @xmath276 . *",
    "4 .   for each @xmath278",
    "such that @xmath279 and no symbols from @xmath91 are members of @xmath67 , each @xmath73 such that @xmath268 , and each @xmath280 , add the following rule to @xmath6 .",
    "* @xmath281 .",
    "5 .   for each @xmath282",
    "such that @xmath279 and no symbols from @xmath91 are members of @xmath67 , each @xmath73 such that @xmath268 , and each @xmath283 , add the following rule to @xmath6 . *",
    ". 6 .   for each @xmath220 such that @xmath221 and no symbols from @xmath222 are members of @xmath67 , and each @xmath73 such that @xmath268 , add the following rule to @xmath6 , provided @xmath285 .",
    "* @xmath286 . 7 .",
    "remove from @xmath6 the old rules of the form @xmath236 , where @xmath92 .",
    "reduce the grammar .    ' '' ''    [ expo3.alg ]    an example is given in figure  [ block ] . as before ,",
    "the rules of the grammar are implicit in the depicted parse tree . at the top of the derivation we find @xmath117 . in the transformed grammar",
    ", we first have to apply @xmath287 .",
    "the derivation starts with a rule @xmath237 , which generates a string ( viz .",
    "@xmath258 ) to the right of a nonterminal ( viz .",
    "@xmath90 ) .",
    "before we can apply zero or more of such rules , we first have to apply a unit rule @xmath288 in the transformed grammar . for zero or more rules that subsequently generate something on the left , such as @xmath238",
    ", we have to obtain a superscript containing _ rl _ , and in the example this is done by applying @xmath289 .",
    "now we are finished with pure left recursion and pure right recursion , and apply @xmath290 .",
    "this allows us to apply one unconstrained rule , which appears in the transformed grammar as @xmath291 .",
    "now the counter @xmath73 has been increased from @xmath292 at the start of the subderivation to @xmath293 at the end .",
    "depending on the value @xmath153 that we choose , we can not build derivations by repeating subderivation @xmath294 an unlimited number of times : at some point the counter will exceed @xmath153 .",
    "if we choose @xmath295 , then already the derivation at figure  [ block ]  ( b ) is not possible anymore , since no nonterminal in the transformed grammar would contain 1 in its superscript .",
    "because of the demonstrated increase of the counter @xmath73 , this transformation is guaranteed to remove self - embedding from the grammar .",
    "however , it is not as selective as the transformation we saw before , in the sense that it may also block subderivations that are not of the form @xmath49 .",
    "consider for example the subderivation from figure  [ block ] , but replacing the lower occurrence of @xmath117 by any other nonterminal @xmath254 that is mutually recursive with @xmath117 , @xmath90 and @xmath116 .",
    "such a subderivation @xmath296 would also be blocked by choosing @xmath295 . in general , increasing @xmath153 allows more of such derivations that are not of the form @xmath49 but also allows more derivations that are of that form .",
    "the reason for considering this transformation rather than any other that eliminates self - embedding is purely pragmatic : of the many variants we have tried that yield non - trivial subset approximations , this transformation has the lowest complexity in terms of the sizes of intermediate structures and of the resulting finite automata .    in the actual implementation",
    ", we have integrated the grammar transformation and the construction of the finite automaton , which avoids re - analysis of the grammar to determine the partition of mutually recursive nonterminals after transformation .",
    "this integration makes use for example of the fact that for fixed @xmath67 and fixed @xmath73 , the set of nonterminals of the form @xmath297 , with @xmath92 , is ( potentially ) mutually right - recursive .",
    "a set of such nonterminals can therefore be treated as the corresponding case from figure  [ tofs ] , assuming the value _",
    "right_.    the full formulation of the integrated grammar transformation and construction of the finite automaton is rather long and is therefore not given here . a very similar formulation , for another grammar transformation ,",
    "is given by .",
    "the distinction between context - free languages and regular languages can be seen in terms of the distinction between pushdown automata and finite automata .",
    "pushdown automata maintain a stack that is potentially unbounded in height , which allows more complex languages to be recognized than in the case of finite automata .",
    "regular approximation can be achieved by restricting the height of the stack , as we will see in section  [ approx : jo ] , or by ignoring the distinction between several stacks when they become too high .",
    "more specifically , the method proposed by first constructs an lr automaton , which is a special case of a pushdown automaton .",
    "then , stacks that may be constructed in the course of recognition of a string are computed one by one .",
    "however , stacks that contain two occurrences of a stack symbol are identified with the shorter stack that results by removing the part of the stack between the two occurrences , including one of the two occurrences .",
    "this process defines a congruence relation on stacks , with a finite number of congruence classes .",
    "this congruence relation directly defines a finite automaton : each class is translated to a unique state of the nondeterministic finite automaton , shift actions are translated to transitions labelled with terminals , and reduce actions are translated to epsilon transitions .",
    "the method has a high complexity .",
    "first , construction of an lr automaton , of which the size is exponential in the size of the grammar , may be a prohibitively expensive task @xcite .",
    "this is however only a fraction of the effort needed to compute the congruence classes , of which the number is in turn exponential in the size of the lr automaton .",
    "if the resulting nondeterministic automaton is determinized , we obtain a third source of exponential behaviour . the time and space complexity of the method",
    "are thereby bounded by a triple exponential function in the size of the grammar .",
    "this theoretical analysis seems to be in keeping with the high costs of applying this method in practice , as will be shown later in this article .",
    "as proposed by , our implementation applies the approximation separately for each nonterminal occurring in a set @xmath67 that reveals self - embedding .    a different superset approximation based on lr automata",
    "was proposed by and rediscovered by . each individual stack symbol",
    "is now translated to one state of the nondeterministic finite automaton .",
    "it can be argued theoretically that this approximation differs from the unparameterized rtn approximation from section  [ approx : ned ] only under certain conditions that are not likely to occur very often in practice .",
    "this consideration is confirmed by our experiments to be discussed later .",
    "our implementation differs from the original algorithm in that the approximation is applied separately for each nonterminal in a set @xmath67 that reveals self - embedding .",
    "a generalization of this method was suggested by . for a fixed number @xmath298",
    "we investigate sequences of @xmath153 top - most elements of stacks that may arise in the lr automaton , and we translate these to states of the finite automaton .",
    "more precisely , we define another congruence relation on stacks , such that we have one congruence class for each sequence of @xmath153 stack symbols and this class contains all stacks that have that sequence as @xmath153 top - most elements ; we have a separate class for each stack that contains less than @xmath153 elements .",
    "as before , each congruence class is translated to one state of the nondeterministic finite automaton .",
    "note that the case @xmath195 is equivalent to the approximation by .",
    "if we replace the lr automaton by a certain type of automaton that performs top - down recognition , then the method by amounts to the parameterized rtn method from section  [ approx : ned ] ; note that the histories from section  [ approx : ned ] in fact function as stacks , the items being the stack symbols .      by restricting the height of the stack of a pushdown automaton , one obstructs recognition of a set of strings in the context - free language , and therefore a subset approximation results .",
    "this idea was proposed by , and , and was rediscovered by and recently by . since the latest publication in this area is more explicit in its presentation , we will base our treatment on this , instead of going to the historical roots of the method .",
    "one first constructs a modified left - corner recognizer from the grammar , in the form of a pushdown automaton .",
    "the stack height is bounded by a low number ; claims a suitable number would be 5 .",
    "the motivation for using the left - corner strategy is that this bound may not affect the language in case the grammar is not self - embedding , and thereby the approximation may be exact .",
    "the reason for this is that the height of the stack maintained by a left - corner parser is already bounded by a constant in the absence of self - embedding .",
    "our own implementation is more refined than the published algorithms mentioned above , in that it defines a separate left - corner recognizer for each nonterminal @xmath90 such that @xmath92 and @xmath132 , some @xmath70 . in the construction for one such recognizer ,",
    "nonterminals that do not belong to @xmath67 are treated as terminals , as in all other methods discussed here .",
    "an approximation from can be explained as follows .",
    "define the set of all terminals reachable from nonterminal @xmath90 to be @xmath299\\}$ ] .",
    "we now approximate the set of strings derivable from @xmath90 by @xmath300 , which is the set of strings consisting of terminals from @xmath301 .",
    "our implementation is slightly more sophisticated by taking @xmath301 to be @xmath302\\}$ ] , for each @xmath90 such that @xmath92 and @xmath132 , for some @xmath70 .",
    "i.e.  each @xmath303 is a terminal , or a nonterminal not in the same set @xmath67 as @xmath90 , but immediately reachable from set @xmath67 , through @xmath93 .",
    "this method can be generalized , inspired by , who derive @xmath4-gram probabilities from stochastic context - free grammars . by ignoring the probabilities ,",
    "each @xmath304 gives rise to a superset approximation that can be described as follows .",
    "the set of strings derivable from a nonterminal @xmath90 is approximated by the set of strings @xmath305 such that    * for each substring @xmath306 ( @xmath307 ) we have @xmath308 , for some @xmath309 and @xmath310 , * for each prefix @xmath311 ( @xmath312 ) such that @xmath313 we have @xmath314 , for some @xmath310 , and * for each suffix @xmath315 ( @xmath312 ) such that @xmath316 we have @xmath317 , for some @xmath309 .",
    "( again , the algorithms that we actually implemented are more refined and take into account the sets @xmath67 . )    the approximation from can be seen as the case @xmath318 , which will henceforth be called the unigram method .",
    "we have also experimented with the cases @xmath319 and @xmath320 , which will be called the bigram and trigram methods .",
    "the methods of approximation described above take as input the parts of the grammar that pertain to self - embedding .",
    "it is only for those parts that the language is affected .",
    "this leads us to a way to increase the precision : before applying any of the above methods of regular approximation , we first transform the grammar .",
    "this grammar transformation copies grammar rules containing recursive nonterminals and , in the copies , it replaces these nonterminals by new non - recursive nonterminals .",
    "the new rules take over part of the roles of the old rules , but since the new rules do not contain recursion and therefore do not pertain to self - embedding , they remain unaffected by the approximation process .",
    "consider for example the palindrome grammar from figure  [ pal ] .",
    "the rtn method will yield a rather crude approximation , viz.the language @xmath321 .",
    "we transform this grammar in order to keep the approximation process away from the first three levels of recursion .",
    "we achieve this by introducing three new nonterminals @xmath322 $ ] , @xmath323 $ ] and @xmath324 $ ] , and by adding modified copies of the original grammar rules , so that we obtain : @xmath325 & { \\rightarrow } & a\\ s[2]\\ a\\ \\ |\\",
    "\\ b\\ s[2]\\ b",
    "\\ \\ |\\ \\ { \\epsilon}\\\\ s[2 ] & { \\rightarrow } & a\\ s[3]\\ a\\ \\ |\\ \\ b\\ s[3]\\ b \\",
    "\\ |\\ \\ { \\epsilon}\\\\ s[3 ] & { \\rightarrow } & a\\ s\\ a\\ \\ |\\ \\ b\\ s\\ b \\ \\ |\\ \\ { \\epsilon}\\\\ s & { \\rightarrow } & a\\ s\\ a\\ \\ |\\",
    "\\ \\ |\\ \\ { \\epsilon}\\end{array}\\ ] ] the new start symbol is @xmath322 $ ] .",
    "the new grammar generates the same language as before , but the approximation process leaves unaffected the nonterminals @xmath322 $ ] , @xmath323 $ ] and @xmath324 $ ] and the rules defining them , since these nonterminals are not recursive .",
    "these nonterminals amount to the upper three levels of the parse trees , and therefore the effect of the approximation on the language is limited to lower levels .",
    "if we apply the rtn method then we obtain the language that consists of ( grammatical ) palindromes of the form @xmath326 , where @xmath327 , plus ( possibly ungrammatical ) strings of the form @xmath328 , where @xmath329 and @xmath330 .",
    "( @xmath331 indicates the mirror image of @xmath309 . )    the grammar transformation in its full generality is given by the following , which is to be applied for fixed integer @xmath332 , which is a parameter of the transformation , and for each @xmath67 such that @xmath132 .",
    "for each nonterminal @xmath92 we introduce @xmath333 new nonterminals @xmath334,\\ldots , a[j]$ ] . for each @xmath138 in @xmath6 such that @xmath92 , and @xmath335 such that @xmath336 , we add @xmath337{\\rightarrow}x_1'\\cdots x_m'$ ] to @xmath6 , where for @xmath338 : @xmath339 , \\mbox { if } x_k \\in n_i \\wedge h <",
    "j \\\\       & = & x_k , \\mbox { otherwise } \\end{aligned}\\ ] ] further , we replace all rules @xmath138 such that @xmath340 by @xmath341 , where for @xmath338 : @xmath342 , \\mbox { if } x_k \\in n_i \\\\       & = & x_k , \\mbox { otherwise } \\end{aligned}\\ ] ] if the start symbol @xmath117 was in @xmath67 , we let @xmath322 $ ] be the new start symbol .",
    "a second transformation , which shares some characteristics with the one above , was presented by .",
    "one of the earliest papers suggesting such transformations as a way to increase the precision of approximation is due to , who however only discuss examples ; no general algorithms were defined .",
    "in this section we investigate empirically how the respective approximation methods behave on grammars of different sizes and how much the approximated languages differ from the original context - free languages .",
    "this last question is difficult to answer in a precise way .",
    "both an original context - free language and an approximating regular language generally consist of an infinite number of strings , and the number of strings that are introduced in a superset approximation or that are excluded in a subset approximation may also be infinite .",
    "this makes it difficult to attach numbers to the `` quality '' of approximations .",
    "we have opted for a pragmatic approach which does not require investigation of the entire infinite languages of the grammar and the finite automata , but that looks at a certain finite set of strings that we have taken from a corpus , as discussed below . for this finite set of strings we measure",
    "the percentage that overlaps with the investigated languages .    for the experiments we have taken context - free grammars for german , generated automatically from an hpsg and a spoken - language corpus of 332 sentences .",
    "this corpus consists of sentences possessing grammatical phenomena of interest , manually selected from a larger corpus of actual dialogues .",
    "an hpsg parser was applied on these sentences , and a form of context - free backbone was selected from the first derivation that was found .",
    "( to take the first derivation is as good as any other strategy , given that we have at present no mechanisms for relative ranking of derivations . )",
    "the label occurring at a node together with the sequence of labels at the daughter nodes was then taken to be a context - free rule .",
    "the collection of such rules for the complete corpus forms a context - free grammar . due to the incremental nature of this construction of the grammar",
    ", we can consider the subgrammars obtained after processing the first @xmath343 sentences , where @xmath344 .",
    "see figure  [ corgra ] ( left ) for the relation between @xmath343 and the number of rules of the grammar .",
    "the construction is such that rules have at most two members in the right - hand side .    as input",
    "we consider a set of 1000 sentences , obtained independently from the 332 sentences mentioned above .",
    "these 1000 sentences were found by having a speech recognizer provide a single hypothesis for each utterance , where utterances come from actual dialogues .",
    "figure  [ corgra ] ( right ) shows how many sentences of different lengths the corpus contains , up to length 30 . above length 25 , this number quickly declines , but still a fair quantity of longer strings can be found , e.g.  11 strings of a length between 51 and 60 words . in most cases",
    "however such long strings are in fact composed of a number of shorter sentences .",
    "each of the 1000 sentences were input in their entirety to the automata , although in practical spoken - language systems , often one is not interested in grammaticality of complete utterances , but one tries to find substrings that form certain phrases bearing information relevant to the understanding of the utterance .",
    "we will however not be concerned here with the exact way such recognition of substrings could be realized by means of finite automata , since this is outside the scope of the present paper .    for the respective methods of approximation we measured the size of the compact representation of the nondeterministic automaton , the number of states and the number of transitions of the minimal deterministic automaton , and the percentage of sentences that were recognized , in comparison to the percentage of grammatical sentences . for the compact representation , we counted the number of lines , which is roughly the sum of the numbers of transitions from all subautomata , not considering about three additional lines per subautomaton for overhead .",
    "we have investigated the size of the compact representation because it is reasonably implementation independent , barring optimizations of the approximation algorithms themselves that affect the sizes of the subautomata . where we show that for some method there is a sharp increase in the size of the compact representation for a small increase in the size of the grammar ,",
    "this gives us a strong indication how difficult it would be to apply the method to much larger grammars .",
    "note that the size of the compact representation is a ( very ) rough indication as to how much effort is involved in determinization , minimization , and substituting the subautomata into each other . for determinization and minimization of automata",
    ", we have applied programs from the fsm library described by .",
    "this library is considered to be competitive with respect to other tools for processing of finite - state machines , and when the programs can not determinize or minimize in reasonable time and space some subautomata constructed by a particular method of approximation , then this can be regarded to be an indication of the impracticality of the method .",
    "we were not able to compute the compact representation for all the methods and all the grammars .",
    "quite problematic proved to be the refined rtn approximation from section  [ approx : gr ] .",
    "we were not able to compute the compact representation for any of the automatically obtained grammars in our collection that were self - embedding .",
    "we therefore eliminated individual rules by hand starting from the smallest self - embedding grammar in our collection , eventually finding grammars small enough to be handled by this method .",
    "the results are given in table  [ ge : numbers ] .",
    "note that the size of the compact representation increases significantly for each additional grammar rule .",
    "the sizes of the finite automata , after determinization and minimization , remain relatively small .",
    "[ ge : numbers ]    [ cols=\">,>,>,>\",options=\"header \" , ]     since no grammars of interest could be handled by them , the above two methods will be further left out of consideration . in the sequel",
    ", we refer to the unparameterized and parameterized approximations based on rtns ( section  [ approx : ned ] ) as and respectively , for @xmath345 ; to the subset approximation from figure  [ expo3.alg ] as ` sub@xmath153 , ' for @xmath346 ; and to the second and third methods from section  [ approx : pw ] , which were based on lr parsing following and , as ` lr ' and ` lr@xmath153 , ' respectively , for @xmath345 .",
    "we refer to the subset approximation based on left - corner parsing from section  [ approx : jo ] as ` lc@xmath153 , ' for the maximal stack height of @xmath347 ; and to the methods discussed in section  [ approx : ngram ] as ` unigram , ' ` bigram ' and ` trigram . '",
    "we first discuss the compact representation of the nondeterministic automata .",
    "in figure  [ sizecomp ] we use two different scales to be able to represent the large variety of values .    for the method",
    "sub@xmath153 , the compact representation is of purely theoretical interest for grammars larger than 156 rules in the case of sub1 , for those larger than 62 rules in the case of sub2 , and for those larger than 35 rules in the case of sub3 , since the minimal deterministic automata could thereafter no longer be computed with a reasonable bound on resources ; we stopped the processes after they had consumed over 400 megabytes . for lc3 , lc4 , rtn3 ,",
    "lr2 and lr3 , this was also the case for grammars larger than 139 , 62 , 156 , 217 and 156 rules , respectively .",
    "the sizes of the compact representation seem to grow moderately for lr and bigram , in the upper panel , yet the sizes are much larger than those for rtn and unigram , which are indicated in the lower panel .",
    "the numbers of states for the respective methods are given in figure  [ nrstates ] , again using two very different scales .",
    "as in the case of the grammars , the terminals of our finite automata are parts of speech rather than words .",
    "this means that in general there will be nondeterminism during application of an automaton on an input sentence due to lexical ambiguity .",
    "this nondeterminism can be handled efficiently using tabular techniques provided the number of states is not too high .",
    "this consideration favours methods which produce low numbers of states , such as trigram , lr , rtn , bigram and unigram .",
    "note that the numbers of states for lr and rtn differ only very little .",
    "in fact , for some of the smallest and for some of the largest grammars in our collection , the resulting automata were identical .",
    "remark however that the intermediate results for lr ( figure  [ sizecomp ] ) are much larger .",
    "it should therefore be concluded that the `` sophistication '' of lr parsing is here merely a source of needless inefficiency .",
    "the numbers of transitions for the respective methods are given in figure  [ nrtrans ] .",
    "again note the different scales used in the two panels .",
    "the numbers of transitions roughly correspond to the storage requirements for the automata .",
    "it can be seen that again trigram , lr , rtn , bigram and unigram perform well .",
    "the precision of the respective approximations is measured in terms of the percentages of sentences in the corpus that are recognized by the automata , in comparison to the percentage of sentences that are generated by the grammar , as presented by figure  [ filt ] .",
    "the lower panel represents an enlargement of a section from the upper panel .",
    "methods that could only be applied for the smaller grammars are only presented in the lower panel ; lc4 and sub2 have been omitted entirely .",
    "the curve labelled g represents the percentage of sentences that are generated by the grammar .",
    "note that since all approximation methods compute either supersets or subsets , it can not occur that a particular automaton both recognizes some ungrammatical sentences and rejects some grammatical sentences .",
    "unigram and bigram recognize very high percentages of ungrammatical sentences .",
    "much better results were obtained for rtn .",
    "the curve for lr would not be distinguishable from that for rtn in the figure , and is therefore omitted .",
    "( for only two of the investigated grammars was there any difference , the largest difference occurring for grammar size 217 , where 34.1 versus 34.5 percent of sentences were recognized in the cases of lr and rtn , respectively . )",
    "trigram remains very close to rtn ( and lr ) ; for some grammars a lower percentage is recognized , for others a higher percentage is recognized .",
    "lr2 seems to improve slightly over rtn and trigram , but only for small grammars is data available , due to the difficulty of applying the method to larger grammars .",
    "a more substantial improvement is found for rtn2 .",
    "even smaller percentages are recognized by lr3 and rtn3 , but again , only for small grammars is data available .",
    "the subset approximations lc3 and sub1 remain very close to g , but also here only data for small grammars is available , since these two methods could not be applied on larger grammars .",
    "although application of lc2 on larger grammars required relatively few resources , the approximation is very crude : only a small percentage of the grammatical sentences are recognized .",
    "we also performed experiments with the grammar transformation from section  [ increase ] , in combination with the rtn method .",
    "we found that for increasing @xmath333 , the intermediate automata soon became too large to be determinized and minimized , with a bound on the memory consumption of 400 megabytes .",
    "the sizes of the automata that we were able to compute are given in figure  [ rtnexp ] . ` rtn+@xmath333 , ' for @xmath348 , represents the ( unparameterized ) rtn method in combination with the grammar transformation with parameter @xmath333 .",
    "this is not to be confused with the parameterized ` rtn@xmath153 ' method .",
    "figure  [ rtnexpacc ] indicates the number of sentences in the corpus that are recognized by an automaton divided by the number of sentences in the corpus that are generated by the grammar . for comparison ,",
    "the figure also includes curves for rtn@xmath153 , where @xmath345 ( cf .",
    "figure  [ filt ] ) .",
    "we see that @xmath349 has little effect . for @xmath350 , however , the approximating",
    "language becomes substantially smaller than that in the case of rtn , but at the expense of large automata .",
    "in particular , if we compare the sizes of the automata for rtn+@xmath333 in figure  [ rtnexp ] with those for rtn@xmath153 in figures  [ nrstates ] and  [ nrtrans ] , then figure  [ rtnexpacc ] suggests the large sizes of the automata for rtn+@xmath333 are not compensated adequately by a reduction of the percentage of sentences that are recognized .",
    "rtn@xmath153 seems therefore preferable over rtn+@xmath333 .",
    "if we apply the finite automata with the intention of filtering out incorrect sentences , for example from the output from a speech recognizer , then it is allowed that a certain percentage of ungrammatical input is recognized , since this merely makes filtering less effective , but does not affect the functionality of the system as a whole , provided we assume that the grammar specifies exactly the set of sentences that can be successfully handled by a subsequent phase of processing .",
    "also allowed is that `` pathological '' grammatical sentences are rejected that seldom occur in practice ; an example are sentences requiring multiple levels of self - embedding .    of the methods we considered that may lead to rejection of grammatical sentences , i.e.  the subset approximations",
    ", none seems of much practical value .",
    "the most serious problem is the complexity of the construction of automata from the compact representation for large grammars .",
    "since the tools we used for obtaining the minimal deterministic automata are considered to be of high quality , it is doubtful that alternative implementations could succeed on much larger grammars , also considering the sharp increases in the sizes of the automata for small increases in the size of the grammar .",
    "only lc2 could be applied with relatively few resources , but this is a very crude approximation , which leads to rejection of many more sentences than just those requiring self - embedding .    similarly , some of the superset approximations are not applicable to large grammars because of the high costs of obtaining the minimal deterministic automata .",
    "some others provide rather large languages , and therefore do not allow very effective filtering of ungrammatical input .",
    "one method however seems to be excellently suited for large grammars , viz .  the rtn method ; into consideration come the unparameterized version and the parameterized version with @xmath196 . in both cases ,",
    "the size of the automaton grows moderately in the grammar size . for the unparameterized version ,",
    "also the compact representation grows moderately .",
    "furthermore , the percentage of recognized sentences remains close to the percentage of grammatical sentences .",
    "it seems therefore that , under the conditions of our experiments , this method is the most suitable regular approximation that is presently available .",
    "this paper could not have been written without the wonderful help of hans - ulrich krieger , who created the series of grammars that are used in the experiments .",
    "i also owe to him many thanks for countless discussions and for allowing me to pursue this work .",
    "i am very grateful to the anonymous referees for their inspiring suggestions .",
    "grimley  evans , edmund .",
    "1997 . approximating context - free grammars with a finite - state calculus . in _ proceedings of the 35th annual meeting _ ,",
    "pages 452459 , madrid , spain .",
    "association for computational linguistics .",
    "johnson , mark .",
    "finite - state approximation of constraint - based grammars using left - corner grammar transforms . in _ proceedings of the 36th annual meeting and 17th international conference on computational linguistics _ , volume  1 , pages 619623 , montreal , quebec , canada .",
    "association for computational linguistics .",
    "langendoen , d.  terence and yedidyah langsam .",
    "1987 . on the design of finite transducers for parsing phrase - structure languages . in alexis manaster - ramer , editor , _ mathematics of language_. john",
    "benjamins publishing company , amsterdam , pages 191235 .",
    "mohri , mehryar and fernando  c.n . pereira .",
    "dynamic compilation of weighted context - free grammars . in _ proceedings of the 36th annual meeting and 17th international conference on computational linguistics _ , volume  2 , pages 891897 , montreal , quebec , canada .",
    "association for computational linguistics .",
    "mohri , mehryar , fernando  c.n .",
    "pereira , and michael riley .",
    "1998 . a rational design for a weighted finite - state transducer library . in _ proceedings of the second international workshop on implementing automata _ ,",
    "volume 1436 of _ lecture notes in computer science _ , pages 144158 .",
    "springer - verlag .",
    "nederhof , mark - jan . 1998 .",
    "context - free parsing through regular approximation . in _ proceedings of the international workshop on finite state methods in natural language processing _ , pages 1324 , ankara , turkey .",
    "nederhof , mark - jan and giorgio satta .",
    "efficient tabular lr parsing . in _ proceedings of the 34th annual meeting _ , pages 239246 , santa cruz , california , usa . association for computational linguistics .",
    "pereira , fernando  c.n . and rebecca  n. wright . 1997",
    ". finite - state approximation of phrase - structure grammars . in emmanuel roche and yves schabes , editors , _ finite - state language processing_. mit press , pages 149173 .",
    "stolcke , andreas and jonathan segal .",
    "precise @xmath4-gram probabilities from stochastic context - free grammars . in _ proceedings of the 32nd annual meeting _ , pages 7479 , las cruces , new mexico , usa .",
    "association for computational linguistics ."
  ],
  "abstract_text": [
    "<S> several methods are discussed that construct a finite automaton given a context - free grammar , including both methods that lead to subsets and those that lead to supersets of the original context - free language . </S>",
    "<S> some of these methods of * regular approximation * are new , and some others are presented here in a more refined form with respect to existing literature . </S>",
    "<S> practical experiments with the different methods of regular approximation are performed for spoken - language input : hypotheses from a speech recognizer are filtered through a finite automaton . </S>"
  ]
}