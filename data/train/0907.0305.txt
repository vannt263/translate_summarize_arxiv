{
  "article_text": [
    "the computational task of detecting maximum weight matchings is one of the most fundamental problems in discrete optimization , attracting plenty of attention from the operations research , computer science , and mathematics communities .",
    "( for a wealth of references on matching problems see  @xcite . ) in such settings , we are given an undirected graph @xmath2 whose edges are associated with non - negative weights specified by @xmath3 .",
    "a set of edges @xmath4 is a _ matching _ if no two of the edges share a common vertex , that is , the degree of any vertex in @xmath5 is at most @xmath6 .",
    "the weight @xmath7 of a matching @xmath8 is defined as the combined weight of its edges , i.e. , @xmath9 .",
    "the objective is to compute a matching of maximum weight .",
    "we study this problem in two related computational models : the _ semi - streaming _ model and the _ preemptive online _ model .",
    "[ [ the - semi - streaming - model . ] ] the semi - streaming model .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    even though these settings appear to be rather simple as first glance , it is worth noting that matching problems have an abundance of flavors , usually depending on how the input is specified . in this paper , we investigate weighted matchings in the _ semi - streaming _ model , was first suggested by muthukrishnan  @xcite .",
    "specifically , a _ graph stream _ is a sequence @xmath10 of distinct edges , where @xmath10 is an arbitrary permutation of @xmath11 .",
    "when an algorithm is processing the stream , edges are revealed sequentially , one at a time . letting @xmath12 and",
    "@xmath13 a graph algorithm uses , the time @xmath14 it requires to process each edge , and the number of passes @xmath15 it makes over the input stream .",
    "the main restriction is that the space @xmath16 is limited to @xmath17 bits of memory .",
    "we refer the reader to a number of recent papers  @xcite and to the references therein for a detailed literature review .",
    "[ [ online - graph - problems . ] ] online graph problems .",
    "+ + + + + + + + + + + + + + + + + + + + + +    unlike the semi - streaming model , in online problems the size of the underlying graph is not known in advance .",
    "the online matching problem has previously been modeled as follows .",
    "edges are presented one by one to the algorithm , along with their weight .",
    "once an edge is presented , we must make an irrevocable decision , whether to accept it or not .",
    "an edge may be accepted only if its addition to the set of previously accepted edges forms a feasible matching .",
    "in other words , an algorithm must keep a matching at all times , and its final output consists of all edges which were ever accepted . in this model , it is easy to verify that the competitive ratio of any ( deterministic or randomized ) algorithm exceeds any function of the number of vertices , meaning that no competitive algorithm exists .",
    "however , if all weights are equal , a greedy approach which accepts an edge whenever possible , has a competitive ratio of @xmath18 , which is best possible for deterministic algorithms @xcite .",
    "similarly to other online settings ( such as call control problems @xcite ) , a preemptive model can be defined , allowing us to remove a previously accepted edge from the current matching at any point in time ; this event is called _",
    "preemption_. nevertheless , an edge which was either rejected or preempted can not be inserted to the matching later on .",
    "we point out that other types of online matching problems were studied as well @xcite .    [ [ comparison - between - the - models . ] ] comparison between the models .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    both semi - streaming algorithms and online algorithms perform a single pass over the input . however , unlike semi - streaming algorithms , online algorithms are allowed to concurrently utilize memory for two different purposes .",
    "the first purpose is obviously to maintain the current solution , which must always be a feasible matching , implying that the memory size of this nature is bounded by the maximal size of a matching .",
    "the second purpose is to keep track of arbitrary information regarding the past , without any concrete bound on the size of memory used .",
    "therefore , in theory , online algorithms are allowed to use much larger memory than is allowed in the semi - streaming model . moreover , although this possibility is rarely used , online algorithms may perform exponential time computations whenever a new piece of input is revealed . on the other hand , a semi - streaming algorithm may re - insert an edge the current solution , even if it has been temporarily removed , as long as this edge was kept in memory .",
    "this extra power is not allowed for online ( preemptive ) algorithms , making them inferior in this sense in comparison to their semi - streaming counterparts .",
    "[ [ previous - work . ] ] previous work .",
    "+ + + + + + + + + + + + + +    feigenbaum et al .",
    "@xcite were the first to study matching problems under similar assumptions .",
    "their main results in this context were a semi - streaming algorithm that computes a @xmath19-approximation in @xmath20 passes for maximum cardinality matching in bipartite graphs , as well as a one - pass @xmath21-approximation for maximum weighted matching in arbitrary graphs .",
    "later on , mcgregor  @xcite improved on these findings , to obtain performance guarantees of @xmath22 and @xmath23 for the maximum cardinality and maximum weight versions , respectively , being able to handle arbitrary graphs with only a constant number of passes ( depending on @xmath24 ) .",
    "in addition , mcgregor  @xcite tweaked the one - pass algorithm of feigenbaum et al .  into achieving a ratio of @xmath25 .",
    "finally , zelke  @xcite has recently attained an improved approximation factor of @xmath26 , which stands as the currently best one - pass algorithm .",
    "note that the @xmath21-approximation algorithm in  @xcite and the @xmath25-approximation algorithm in  @xcite are preemptive online algorithms . on the other hand ,",
    "the algorithm of zelke  @xcite uses the notion of shadow - edges , which may be re - inserted into the matching , and hence it is not an online algorithm .",
    "[ [ main - result - i . ] ] main result i. + + + + + + + + + + + + + +    the first contribution of this paper is to improve on the above - mentioned results , by devising a deterministic one - pass algorithm in the semi - streaming model , whose performance guarantee is @xmath27 . in a nutshell ,",
    "our approach is based on partitioning the edge set into @xmath28 weight classes , and computing a separate maximal matching for each such class in online fashion , using @xmath17 memory bits overall .",
    "the crux lies in proving that the union of these matchings contains a single matching whose weight compares favorably to the optimal one .",
    "the specifics of this algorithm are presented in section  [ sec : app ] .",
    "[ [ main - result - ii . ] ] main result ii .",
    "+ + + + + + + + + + + + + + +    our second contribution is motivated by the relation between semi - streaming algorithms and _ preemptive _ online algorithms , which must maintain a feasible matching at any point in time . to our knowledge",
    ", there are currently no lower bounds on the competitive ratio that can be achieved by incorporating preemption .",
    "thus , we also provide a lower bound of @xmath1 on the performance guarantee of any such deterministic algorithm . as a result , we show that improved one pass algorithms for this problem must store more than just a matching in memory .",
    "further details are provided in section  [ sec : lower_bound ] .",
    "this section is devoted to obtaining main result i , that is , an improved one - pass algorithm for the weighted matching problem in the semi - streaming model .",
    "we begin by presenting a simple deterministic algorithm with a performance guarantee of @xmath29 .",
    "we then show how to randomize its parameters , still within the semi - streaming framework , and obtain an expected approximation ratio of @xmath30 .",
    "finally , we de - randomize the algorithm by showing how to emulate the required randomness using multiple copies ( constant number ) of the deterministic algorithm , while paying an additional additive factor of at most @xmath31 , for any fixed @xmath32 .      [",
    "[ preliminaries . ] ] preliminaries .",
    "+ + + + + + + + + + + + + +    we maintain the maximum weight of any edge @xmath33 seen so far in the input stream .",
    "clearly , the maximum weight matching of the edges seen so far has weight in the interval @xmath34 $ ] . note that if we disregard all edges with weight at most @xmath35 , the weight of the maximum weight matching in the resulting instance decreases by an additive term of at most @xmath36 .",
    "our algorithm has a parameter @xmath37 , and a value @xmath38 .",
    "we define weight classes of edges in the following way . for every @xmath39",
    ", we let the class @xmath40 be the collection of edges whose weight is in the interval @xmath41 .",
    "we note that by our initial assumption , the weight of each edge is in the interval @xmath42 $ ] , and we say that a weight class @xmath40 is _ under consideration _ if its weight interval @xmath41 intersects @xmath42 $ ] .",
    "the number of classes which are under consideration at any point in time is @xmath43 .",
    "[ [ the - algorithm . ] ] the algorithm .",
    "+ + + + + + + + + + + + + +    our algorithm simply maintains the list of classes under consideration and maintains a maximal ( unweighted ) matching for each such class .",
    "in other words , when the value of @xmath33 changes , we delete from the memory some of these matchings , corresponding to the classes which stop being under consideration . note that to maintain a maximal matching in a given subgraph , we only need to check if the two endpoints of the new edge are not covered by existing edges of the matching .    to conclude , for every new edge @xmath44 we proceed as follows .",
    "we first check if @xmath45 is greater than the current value of @xmath33 .",
    "if so , we update @xmath33 and the list of weight classes under consideration accordingly .",
    "then , we find the weight class of @xmath45 , and try to extend its corresponding matching , i.e. , @xmath46 will be added to this matching if it remains a matching after doing so .",
    "note that at each point the content of the memory is the value @xmath33 and a collection of @xmath43 matchings , consisting of @xmath47 edges overall .",
    "therefore , our algorithm indeed falls in the semi - streaming model .    at the conclusion of the input sequence ,",
    "we need to return a single matching rather than a collection of matchings . to this end",
    ", we could compute a maximum weighted matching of the edges in the current memory .",
    "however , for the specific purposes of our analysis , we use the following faster algorithm .",
    "we sort the edges in memory in decreasing order of weight classes , such that the edges in @xmath40 appear before those in @xmath48 , for every @xmath49 . using this sorted list of edges ,",
    "we apply a greedy algorithm for selecting a maximal matching , in which the current edge is added to this matching if it remains a matching after doing so .",
    "then , the post - processing time needed is linear in the size of the memory used , that is , @xmath47 .",
    "this concludes the presentation of the algorithm and its implementation as a semi - streaming algorithm .",
    "[ [ analysis . ] ] analysis .",
    "+ + + + + + + + +    for purposes of analysis , we round down the weight of each edge @xmath46 such that @xmath50 to be @xmath51 . this way",
    ", we obtain _ rounded _ edge weights .",
    "now fix an optimal solution @xmath52 and denote by @xmath52 its weight , and by @xmath53 its rounded weight .",
    "the next claim immediately follows from the definition of @xmath40 .",
    "@xmath54 .    as an intermediate step ,",
    "we analyze an improved algorithm which keeps all weight classes .",
    "that is , for each @xmath49 , we use @xmath55 to denote the maximal matching of class @xmath40 at the end of the input , and denote by @xmath8 the solution obtained by this algorithm , if we would have applied it .",
    "similarly , we denote by @xmath56 the set of edges in @xmath52 which belong to @xmath40 . for every @xmath49",
    ", we define the set of vertices @xmath57 , associated with @xmath40 , to be the set of endpoints of edges in @xmath55 that are not associated with higher weight classes : @xmath58 for a vertex @xmath59 , we define its associated weight to be @xmath60 . for vertices which do not belong to any @xmath57",
    ", we let their associated weight be zero . we next bound the total associated weight of all the vertices .",
    "the total associated weight of all the vertices is at most @xmath61 .    consider a vertex @xmath62 and let @xmath63 be the edge in @xmath55 adjacent to @xmath64 .",
    "if @xmath65 then we charge the weight associated with @xmath64 to the edge @xmath63 .",
    "thus , an edge @xmath66 is charged at most twice from vertices associated with its own weight class . otherwise , if @xmath67 then there must be some other edge @xmath68 , for some @xmath69 , that prevented us from adding @xmath63 to @xmath8 , in which case we charge the weight associated with @xmath64 to @xmath46 .",
    "notice that @xmath70 , for otherwise , @xmath64 would not be associated with @xmath40 .",
    "thus , the edge @xmath71 must be of the form @xmath72 and can only be charged twice from vertices in weight class @xmath49 , once through @xmath73 and once through @xmath74 .    to bound the ratio between @xmath7 and the total associated weight of the vertices , it suffices to bound the ratio between the weight of an edge @xmath75 and the total associated weight of the vertices which are charged to @xmath46 .",
    "assume that @xmath76 , then there are at most two vertices which are charged to @xmath46 and class @xmath49 for all @xmath77 , and no vertex is associated to @xmath46 and class @xmath49 for @xmath78 .",
    "hence , the total associated weight of these vertices is at most @xmath79 and the claim follows since @xmath80 .",
    "it remains to bound @xmath53 with respect to the total associated weight .",
    "@xmath53 is at most the total weight associated with all vertices .",
    "it suffices to show that for every edge @xmath81 the maximum of the associated weights of @xmath74 and @xmath82 is at least the rounded weight of @xmath46 .",
    "suppose that this claim does not hold , then @xmath74 and @xmath82 are not covered by @xmath55 , as otherwise their associated weight would be at least @xmath51 .",
    "hence , when the algorithm considered @xmath46 , we would have added @xmath46 to @xmath55 , contradicting our assumption that @xmath74 and @xmath82 are not covered by @xmath55 .",
    "using the above sequence of lemmas , and recalling that we lose another @xmath31 in the approximation ratio due to disregarding edges of weight at most @xmath35 , we obtain the following inequality : @xmath83 therefore , we establish the following theorem .    [ simple_det_theorem ] our simple deterministic algorithm has an approximation ratio of @xmath84 .",
    "this ratio can be optimized to @xmath85 by picking @xmath86 .",
    "the next example demonstrates that the analysis leading to theorem [ simple_det_theorem ] is tight .",
    "let @xmath87 be some large enough integer and @xmath32 be sufficiently small .",
    "consider the instance depicted in figure  [ fig : tight - example-8 ] , where @xmath88 consists of a single edge @xmath89 with weight @xmath90 .",
    "for every @xmath91 , the matching @xmath92 consists of exactly two edges @xmath93 and @xmath94 each of weight @xmath95 , and @xmath56 consists of two edges @xmath96 and @xmath97 each of weight @xmath98 .",
    "in addition , there are two edges @xmath99 and @xmath100 whose weight is @xmath101 .",
    "it is easy to see that each @xmath55 is indeed maximal in its own weight class .",
    "given these matchings , our greedy selection rule will output a single edge @xmath89 with total weight @xmath90 ( notice that computing a maximum weight matching in @xmath102 does not help when @xmath103 ) .",
    "moreover , the value of the optimal solution matches our upper bound up to an additive @xmath104 term .",
    "= [ label distance=2pt , fill , inner sep=1.25pt ] = [ fill = white , inner sep=3pt ]    ( 2,2 ) node[label = below:@xmath74 ] ( x ) ",
    "node[weight ] @xmath90 + ( 1,0 ) node[label = below:@xmath82 ] ( y ) ;    //in 1/0/1,3/k-1/k ( 0 , ) node[label = above:@xmath107  node[weight ] @xmath108 ( 1 , ) node[label = above:@xmath109  node[weight ] @xmath110 ( x ) ; ( y ) ",
    "node[weight ] @xmath110 ( 4 , ) node[label = above:@xmath111  node[weight ] @xmath108 ( 5 , ) node[label = above:@xmath112 ; ; ( 0.5,1.75 )  ( 0.5,2.25 ) ; ( 4.5,1.75 )  ( 4.5,2.25 ) ; ( x ) ",
    "node[weight ] @xmath113 + ( 0.2,1.3 ) node[label = above:@xmath114 ; ( y ) ",
    "node[weight ] @xmath113 + ( -0.2,1.3 ) node[label = above:@xmath115 ;      in what follows , we analyze a randomized variant of the deterministic algorithm which was presented in the previous subsection . in general",
    ", this variant sets the value of @xmath116 to be @xmath117 where @xmath118 is a random variable .",
    "this method is commonly referred to as _",
    "randomized geometric grouping_.    formally , let @xmath118 be a continuous random variable which is uniformly distributed on the interval @xmath119 .",
    "we define the weight class @xmath120 , and run the algorithm as in the previous subsection .",
    "note that this algorithm uses only the partition of the edges into classes and not the precise values of their weights .",
    "in addition , we denote by @xmath121 the resulting matching obtained by the algorithm , and by @xmath122 the total associated weight of the vertices , where for a vertex @xmath59 we define its associated weight to be @xmath123 ( i.e. , the minimal value in the interval @xmath124 ) .",
    "we also denote by @xmath125 the value of @xmath53 for this particular @xmath118 .    for any fixed value of @xmath118 , inequality ( [ eq1 ] )",
    "immediately implies @xmath126 note that @xmath125 and @xmath127 are random variables , such that for each realization of @xmath118 the above inequality holds .",
    "hence , this inequality holds also for their expected values .",
    "that is , we have established the following lemma where @xmath128}$ ] represents expectation with respect to the random variable @xmath118 .",
    "[ lem2prime ] @xmath129 } \\leq ( { 2\\gamma\\over \\gamma-1 } + { \\varepsilon})\\cdot { \\mathrm{e } _ { \\delta } [ w(m(\\delta ) ) ] } $ ] .",
    "we next lower bound @xmath52 in terms of @xmath129}$ ] .",
    "[ lem:3prime ] @xmath130 } \\geq { \\mbox{\\textsc{opt}}}$ ] .",
    "we will show the corresponding inequality for each edge @xmath131 .",
    "we denote by @xmath132 the rounded weight of @xmath46 for a specific value of @xmath118 .",
    "then , it suffices to show that @xmath133 } \\geq w(e)$ ] .",
    "let @xmath134 be an integer , and let @xmath135 be the value that satisfies @xmath136 .",
    "then , for @xmath137 , @xmath138 , and for @xmath139 , @xmath140 , thus the expected rounded weight of @xmath46 over the choices of @xmath118 is @xmath141 } = \\int_0^\\alpha \\gamma^{p+\\delta}d\\delta+\\int_\\alpha^1 \\gamma^{p-1+\\delta}d\\delta={1\\over \\ln \\gamma}\\cdot \\left ( \\gamma^p(\\gamma^\\alpha-1)+\\gamma^{p-1}(\\gamma-\\gamma^\\alpha)\\right)=w(e)\\cdot \\left(1-\\frac 1{\\gamma}\\right){1\\over \\ln \\gamma},\\ ] ] and the claim follows .    combining the above two lemmas",
    "we obtain that the expected weight of the resulting solution is at least @xmath142 .",
    "this approximation ratio is optimized for @xmath143 , where it is roughly @xmath144 .",
    "hence , we have established the following theorem .",
    "the randomized algorithm has an approximation ratio of roughly @xmath145 .",
    "prior to presenting our de - randomization , we slightly modify the randomized algorithm of the previous subsection . in this variation , instead of picking @xmath118 uniformly at random from the interval @xmath119 we pick @xmath146 uniformly at random from the discrete set @xmath147 .",
    "we apply the same method as in the previous section where we replace @xmath118 by @xmath146 .",
    "then , using lemma [ lem2prime ] , we obtain @xmath148 } \\leq ( { 2\\gamma\\over \\gamma-1 } + { \\varepsilon})\\cdot { \\mathrm{e } _ { \\delta ' } [ w(m(\\delta ' ) ) ] } $ ] .",
    "to extend lemma [ lem:3prime ] to this new setting , we note that @xmath146 can be obtained by first picking @xmath118 and then rounding it down to the largest number in @xmath149 which is at most @xmath118 . in this way , we couple the distributions of @xmath118 and @xmath146 .",
    "now consider the rounded weight of an edge @xmath46 in @xmath52 in the two distinct values of @xmath118 and @xmath146 .",
    "the ratio between the two rounded weight is at most @xmath150 .",
    "therefore , we establish that @xmath151 } \\geq { \\mbox{\\textsc{opt}}}$ ] .",
    "therefore , the resulting approximation ratio of the new variation is @xmath152 . by settinf @xmath153 to be large enough ( picking @xmath154 is enough ) , the resulting approximation ratio is bounded by @xmath155 .    de - randomizing the new variation in the semi - streaming model is straightforward .",
    "we simply run in parallel all @xmath153 possible outcomes of the algorithm , one for each possible value of @xmath146 , and pick the best solution among the @xmath153 solutions we obtained . since @xmath153 is a constant ( for fixed values of @xmath31 ) , the resulting algorithm is still a semi - streaming algorithm whose performance guarantee is @xmath156 . by scaling @xmath31 prior to applying the algorithm , we establish the following result .    for any fixed @xmath32 ,",
    "there is a deterministic one - pass semi - streaming @xmath157-approximation algorithm for the weighted matching problem .",
    "this algorithm processes each input edge in constant time and required @xmath158 time at the end of the input to compute the final output .",
    "in this section , we established the following theorem .",
    "let @xmath162 for some @xmath163 and assume that a deterministic online algorithm achieves a competitive ratio of at most @xmath164 .",
    "we construct an input graph iteratively , and show that after a finite number of steps , the competitive ratio is violated .    in the construction of the input ,",
    "all edge weights come from two weight sequences .",
    "the main weight sequence is @xmath165 , and an additional weight function is @xmath166 .",
    "these sequences are defined as follows :      the first sequence is defined for @xmath171 only as long as @xmath172 .",
    "as soon as @xmath173 , the sequence stops with @xmath174 , and the length of the sequence @xmath175 is @xmath176 .",
    "we later show that such a value @xmath87 must exist .",
    "let @xmath177 ( and @xmath178 ) .      by definition , since @xmath179 , if @xmath173 , then @xmath180 holds as well .",
    "note that @xmath181 for all @xmath182 , by definition , since @xmath183 , but @xmath184 .",
    "in addition , we have the following : @xmath185 this equality holds for @xmath186 since @xmath187 where the first equality holds by definition of @xmath188 , the second equality holds by definition of @xmath189 , and the third one by simple algebra .",
    "in addition , @xmath190 the last equality holds for @xmath191 since @xmath192 where the first equality holds by definition of @xmath188 , the second by definition of @xmath189 , the third by simple algebra , the fourth by definition of @xmath193 and @xmath194 , and the last one by definition of @xmath195 .      to better understand our construction",
    ", we advice the reader to consult figure  [ fig : preemptive - lowerbound ] .",
    "the input is created in @xmath196 steps . in the initial step ,",
    "two edges @xmath197 and @xmath198 , each of weight @xmath199 , are introduced .",
    "assume that after both edges have arrived , the online algorithm holds the edge @xmath197 .",
    "all future edges either have endpoints which are new vertices , or in the set @xmath200 ( i.e. , they do not contain @xmath201 as an endpoint ) .",
    "an optimal solution keeps @xmath198 .",
    "node[round ] @xmath206 ; + + ( 0,-2 ) node[vertex , label = below:@xmath201 ] ( b1 )  + + ( 0,1 )",
    "node[vertex , label = above:@xmath204 ( x1 )  + + ( 1,0 ) node[vertex , label = above : ] ( a1 ) ; ( a1 )  + ( 0,-1 )",
    "node[vertex , label = below:@xmath207 ; ( a1 ) + ( 1,0 ) node[vertex , label = above:@xmath208 ( a2 ) ; ( a1 )  ( a2 ) ;    node[round ] @xmath209 ; + + ( 0,-2 ) node[vertex , label = below:@xmath201 ] ( b1 )  + + ( 0,1 )",
    "node[vertex , label = above:@xmath204 ( x1 )  + + ( 1,0 ) node[vertex , label = above : ] ( a1 ) ; ( a1 )  + ( 0,-1 )",
    "node[vertex , label = below:@xmath207 ; ( a1 )  + ( 1,0 )",
    "node[vertex , label = above : ] ( a2 ) ; ( a2 ) ",
    "+ ( 0,-1 ) node[vertex , label = below:@xmath210 ; ( a2 )  + ( 1,0 ) node[vertex , label = above:@xmath211 ( a3 ) ; ( a2 ) + ( 2,0 ) node[vertex , label = above:@xmath212 ( c3 ) ; ( a1 ) edge [ decorate , bend right ] ( c3 ) ;    node[round ] @xmath213 ; + + ( 0,-2 ) node[vertex , label = below:@xmath201 ] ( b1 )  + + ( 0,1 ) node[vertex , label = above:@xmath204 ( x1 )  + + ( 1,0 ) node[vertex , label = above : ] ( a1 ) ; ( a1 )  + ( 0,-1 ) node[vertex , label = below:@xmath207 ; ( a1 )  + ( 1,0 ) node[vertex , label = above : ] ( a2 ) ; ( a2 ) ",
    "+ ( 0,-1 ) node[vertex , label = below:@xmath210 ; ( a2 )  + ( 1,0 ) node[vertex , label = above:@xmath211 ( a3 ) ; ( a2 ) + ( 2,0 ) node[vertex , label = above : ] ( c3 ) ; ( a1 ) edge [ bend right ] ( c3 ) ; ( c3 ) ",
    "+ ( 0,-1 ) node[vertex , label = below:@xmath214 ; ( c3 )  + ( 1,0 )",
    "node[vertex , label = above:@xmath215 ( a4 ) ; ( a2 ) + ( 4,0 ) node[vertex , label = above:@xmath216 ( c4 ) ; ( a1 ) edge [ decorate , bend right ] ( c4 ) ;    node[round ] @xmath217 ; + + ( 0,-2 ) node[vertex , label = below:@xmath201 ] ( b1 )  + + ( 0,1 ) node[vertex , label = above:@xmath204 ( x1 )  + + ( 1,0 ) node[vertex , label = above : ] ( a1 ) ; ( a1 ) ",
    "+ ( 0,-1 ) node[vertex , label = below:@xmath207 ; ( a1 )  + ( 1,0 ) node[vertex , label = above : ] ( a2 ) ; ( a2 )  + ( 0,-1 ) node[vertex , label = below:@xmath210 ; ( a2 )  + ( 1,0 )",
    "node[vertex , label = above:@xmath211 ( a3 ) ; ( a2 ) + ( 2,0 ) node[vertex , label = above : ] ( c3 ) ; ( a1 ) edge [ bend right ] ( c3 ) ; ( c3 )  + ( 0,-1 ) node[vertex , label = below:@xmath214 ; ( c3 )  + ( 1,0 ) node[vertex , label = above:@xmath215 ( a4 ) ; ( a2 ) + ( 4,0 ) node[vertex , label = above : ] ( c4 ) ; ( a1 ) edge [ bend right ] ( c4 ) ; ( c4 )  + ( 0,-1 ) node[vertex , label = below:@xmath218 ; ( c4 ) + ( 1,0 ) node[vertex , label = above:@xmath219 ( a5 ) ; ( a5 ) edge [ decorate ] ( c4 ) ;      every future step can be of two distinct types , which will be described later on . among the edges introduced below",
    ", vertices called @xmath220 denote endpoints which occur each on a single edge .",
    "after step @xmath49 , the following invariants are maintained .",
    "the algorithm keeps a single edge denoted by @xmath221 . if @xmath202 , then @xmath222 . if @xmath223 , then this edge can be one of two edges , @xmath224 or @xmath225 . if @xmath222 , then its weight is @xmath175 , and an optimal solution has one edge of each weight @xmath226 .",
    "no future edges will have common endpoints with these @xmath49 edges , except , possibly , with the endpoint @xmath227 of the edge of weight @xmath175 ( the edge of this weight which this optimal solution keeps is always @xmath228 ) .",
    "otherwise , @xmath229 , and its weight is @xmath195 , in which case an optimal solution can have edges of weights @xmath230 , except for one weight @xmath231 for some @xmath232 . this index @xmath233 is used in the definition of the next step , and the properties of the current step .",
    "in addition to these @xmath234 edges , the optimal solution also has the edge @xmath225 .",
    "future edges will have endpoints which are new vertices , or in the set @xmath235 . in the last case",
    ", the vertex @xmath236 is equal to the vertex @xmath237 .",
    "the invariants clearly hold after the first step .",
    "we next define all other steps and show that the invariants hold for each option .      if @xmath239 , the last step consists of an edge of weight @xmath240 .",
    "let @xmath241 , if @xmath242 and otherwise @xmath243 .",
    "the new edge is @xmath244 , where @xmath245 is a new vertex .",
    "this edge has a common endpoint with the edge that the algorithm has .",
    "in fact , the algorithm has an edge of weight at least @xmath246 , and thus we assume that it does not preempt it . if the algorithm has an edge of weight @xmath247 , the edge @xmath244 does not have @xmath227 as an endpoint , so adding the new edge to the optimal solution does not require the removal of any edges , and the profit of the optimal solution is @xmath248 . if the algorithm has an edge of weight @xmath249 , the new edge is @xmath250 .",
    "we replace the edge @xmath251 of the optimal solution by the new edge .",
    "in addition , the edge @xmath252 ( where @xmath233 is the index such that the optimal solution before the modification of the current step does not have an edge of weight @xmath231 ) is added to the optimal solution , since the endpoint @xmath253 became free , and the endpoint @xmath220 only has degree 1 . the profit of the optimal solution is @xmath248 again .",
    "recall that @xmath254 , and hence the algorithm earns ( in both cases ) at most @xmath247 .",
    "note also that the optimal solution has value of @xmath248 and if @xmath255 then we can drop the edge of this weight from the optimal solution and get a solution of value @xmath256 .",
    "therefore , we will use @xmath256 as a lower bound on the value of the optimal solution in this case .",
    "thus we will show later that @xmath257 .",
    "[ [ input - construction - step - boldsymboli1-for - boldsymboli1n . ] ] input construction , step @xmath258 , for @xmath259 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we next show how to construct the edges of step @xmath260 , for the case @xmath261 .",
    "we introduce two new edges of weight @xmath189 .",
    "let @xmath262 , if @xmath222 and otherwise @xmath263 .",
    "the new edges are @xmath264 , and @xmath265 , where @xmath266 and @xmath267 are new vertices .",
    "both these edges have a common endpoint with the edge that the algorithm has , and the algorithm can either preempt the edge it has , in which case we assume ( without loss of generality ) that it now has @xmath265 , or else it keeps the previous edge . if the algorithm keeps the previous edge ,",
    "let @xmath268 , if @xmath222 and otherwise @xmath269 . in this case",
    "a third edge , @xmath270 , which has a weight of @xmath188 , is introduced .",
    "the vertex @xmath271 is new .",
    "there are four cases to consider . in the first case , if the algorithm replaces the edge @xmath224 with the edge @xmath272 , then an optimal solution can add the edge @xmath264 to its edges , since the endpoint @xmath267 is new , and the endpoint @xmath273 was introduced in the previous step , in which the optimal solution obtained the edge @xmath228 .    if the algorithm replaces the edge @xmath225 with the edge @xmath274 , an optimal solution can remove the edge @xmath225 from its solution and add the two edges @xmath275 and @xmath276 ( where @xmath233 is the index such that the optimal solution before the modification of the current step does not have an edge of weight @xmath231 ) .",
    "this is possible since the endpoints @xmath267 and @xmath220 do not have other edges , and the endpoints @xmath277 and @xmath236 become free .    in the last two cases , the invariants hold . for the remaining two cases",
    "note that if @xmath278 or @xmath279 and the algorithm has a single edge of weight @xmath195 or @xmath175 , respectively , then the optimal solution is strictly positive and the value of the algorithm is non - positive , and hence the resulting approximation ratio in this case is unbounded .",
    "hence , we can assume without loss of generality that if the algorithm has a single edge at the end of step @xmath49 , then its weight is strictly positive .",
    "if the algorithm does not replace the edge @xmath224 with the edge @xmath272 , we show that it must replace it with the edge @xmath280 .",
    "assume that this is not the case .",
    "then the profit of the algorithm is @xmath175 and the optimal solution can omit its edge @xmath228 and add the edges @xmath281 and @xmath282 ( since all these endpoints are introduced in steps @xmath49 and @xmath260 , except for @xmath227 , which becomes free ) .",
    "thus the profit of the optimal algorithm is @xmath283 , while the profit of the online algorithm is @xmath284 .",
    "thus , the algorithm must switch to the edge @xmath265 , and the structure of the optimal solution is according to the invariants .",
    "if the algorithm does not replace the edge @xmath225 with the edge @xmath274 , we show that it must replace it with the edge @xmath285 .",
    "assume that this is not the case .",
    "then the profit of the algorithm is @xmath195 and the optimal solution can omit its edge @xmath225 and add the edges @xmath286 and @xmath287 ( since @xmath277 and @xmath236 become free , and the other two endpoints are introduced in step @xmath260 ) .",
    "thus the profit of the optimal algorithm is @xmath288 , where @xmath289 and @xmath290 , since @xmath291 as @xmath292 , we get that the optimal profit is at least @xmath293 , while the profit of the online algorithm is @xmath294 .",
    "thus , the algorithm must switch to the edge @xmath265 , and the structure of the optimal solution is according to the invariants .",
    "we next define a recursive formula for @xmath295 . by the definition of the sequence @xmath175",
    ", we have @xmath296 we first use this recurrence to show that if @xmath297 then @xmath298 . to see this note that by assumption @xmath299 , hence using the recurrence formula we conclude that @xmath300 that is , @xmath301 which is equivalent to @xmath302 , so @xmath303 , and we conclude that @xmath304 , as we argued .",
    "therefore , it remains to show that there is a value of @xmath196 such that @xmath305 .",
    "to establish this claim , it suffices to show that there is a value of @xmath233 for which @xmath306 ( since @xmath307 ) . to prove this last claim",
    ", we will show that there is a value of @xmath87 such that @xmath308 . finally , to show the existence of such @xmath87",
    ", we will solve the linear homogeneous recurrence formula , and use the explicit form of @xmath309 to show that there is a value of @xmath87 such that @xmath308 .    to solve the recurrence formula ( [ rec ] ) ,",
    "we guess solutions of the form @xmath310 for all @xmath87 , and get the following quadratic equation for @xmath74 : @xmath311we solve this quadratic equation and get its solutions @xmath312 note that using @xmath313 , and recalling that @xmath160 is the unique real solution of the equation @xmath161 , we conclude that @xmath314 and hence the two solutions are complex numbers whose imaginary parts are not zero . since we got two distinct solutions of @xmath74 , it is known that the recurrence formula ( [ rec ] ) is solved by a formula of the form @xmath315 where @xmath316 and @xmath317 are constants .",
    "we find the value of @xmath316 and @xmath317 using the conditions @xmath178 and @xmath318 .",
    "so we get the following set of two equations : @xmath319 ( corresponding to @xmath178 ) , and @xmath320 ( corresponding to @xmath318 ) . from the first equation",
    "we conclude that @xmath321 , and using this we obtain @xmath322 .",
    "hence , the closed form solution of @xmath323 for values of @xmath324 is as follows .",
    "@xmath325 we use the notation @xmath326 , and let @xmath327 . as noted above @xmath314 , and hence @xmath328 is a real number .",
    "we also define @xmath329 and @xmath330 such that @xmath331 , and also @xmath332 , then we get the following formula for @xmath323 .",
    "@xmath333 note that @xmath334 for all @xmath233 , and hence to show that the sequence @xmath335 changes its sign as we required , it suffices to show that the sequence @xmath336 changes its sign , but this last claim holds because @xmath337 ( as the solutions @xmath338 and @xmath339 are not real numbers ) .",
    "hence , the claim follows .",
    "n.  bansal , n.  buchbinder , a.  gupta , and j.  naor .",
    "an @xmath340-competitive algorithm for metric bipartite matching . in _ proceedings of the 15th annual european symposium on algorithms _ , pages 522533 , 2007 ."
  ],
  "abstract_text": [
    "<S> we study the maximum weight matching problem in the semi - streaming model , and improve on the currently best one - pass algorithm due to zelke ( proc .  </S>",
    "<S> stacs  08 , pages 669680 ) by devising a deterministic approach whose performance guarantee is @xmath0 . in addition , we study _ preemptive _ online algorithms , a sub - class of one - pass algorithms where we are only allowed to maintain a feasible matching in memory at any point in time . </S>",
    "<S> all known results prior to zelke s belong to this sub - class . </S>",
    "<S> we provide a lower bound of @xmath1 on the competitive ratio of any such deterministic algorithm , and hence show that future improvements will have to store in memory a set of edges which is not necessarily a feasible matching . </S>"
  ]
}