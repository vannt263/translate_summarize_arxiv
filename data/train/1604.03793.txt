{
  "article_text": [
    "hordesat  @xcite is a modular massively parallel sat solver which allows the integration of any sequential cdcl - based sat solver in its core .",
    "this enables the transfer of advancements in cdcl sat solving to a parallel setting .",
    "experiments showed that hordesat can achieve superlinear average speedup on hard benchmarks .",
    "the logic of quantified boolean formulas ( qbfs ) extends sat by explicit quantification of propositional variables .",
    "problems in complexity classes beyond np , particularly pspace - complete problems in domains like , e.g. , formal verification , reactive synthesis , or planning , can naturally be encoded as qbfs .",
    "qbf solvers based on qcdcl , the qbf - specific variant of cdcl , apply techniques similar to cdcl sat solvers . thanks to this fact , it is possible to replace the sat solver in the core of hordesat by _ any _ qcdcl qbf solver .",
    "thereby , it is not necessary to change the framework of hordesat which controls the sharing of learned information and the execution of the core solver instances .",
    "we integrated the latest public version 5.0 of the qcdcl - based solver depqbf  @xcite in hordesat to obtain the massively parallel qbf solver hordeqbf .",
    "we present the implementation of hordeqbf , which is not tailored towards the use of depqbf as a core solver , and evaluate its scalability on a computer cluster with 1024 processor cores .",
    "experiments using the application benchmarks of the 2014 qbf gallery show that hordeqbf achieves superlinear average and median speedup for hard instances .",
    "we consider closed qbfs @xmath0 in _ prenex cnf ( pcnf ) _ consisting of a quantifier - free cnf @xmath1 over a set @xmath2 of variables and a _ quantifier prefix _ @xmath3 in which @xmath4 and @xmath5 .",
    "qbf solving with clause and cube learning ( _ qcdcl _ )  @xcite , also called _ constraint learning _ , is a generalization of _ conflict - driven clause learning ( cdcl ) _ for sat .",
    "the variables in a pcnf @xmath6 are assigned by _ decision making _ , _ unit propagation _ , and _ pure literal detection_. assignments by decision making have to follow the prefix ordering from left to right . if a clause is falsified under the current assignment @xmath7 , then a _ learned clause _",
    "@xmath8 is derived from @xmath6 by _ q - resolution _",
    "@xcite and added conjunctively to @xmath6 .",
    "if all clauses are satisfied under @xmath7 , then a _ learned cube _ is constructed from @xmath7 and added disjunctively to @xmath6 .",
    "learned cubes may also be derived by _ term resolution _",
    "@xcite , a variant of q - resolution applied to previously learned cubes . after a new clause or cube",
    "has been learned , assignments are retracted during _",
    "backtracking_. qcdcl terminates if and only if the _ empty clause ( resp .",
    "cube ) _ is derived during learning , indicating that @xmath6 is unsatisfiable ( resp .",
    "satisfiable ) .",
    "approaches to parallel qbf solving are based on shared and distributed memory architectures .",
    "pqsolve  @xcite is an early parallel dpll  @xcite solver without knowledge sharing .",
    "it comes with a dynamic master / slave framework implemented using the message passing interface ( mpi )  @xcite .",
    "search space is partitioned among master and slaves by variable assignments .",
    "qmiraxt  @xcite is a multithreaded qcdcl solver with search space partitioning .",
    "paqube  @xcite is an mpi - based parallel variant of the qcdcl solver qube  @xcite .",
    "clause and cube sharing in paqube can be adapted dynamically at run time .",
    "search space is partitioned like in the sat solver psato based on _ guiding paths _",
    "@xcite . the mpi - based solver mpidepqbf  @xcite implements a master / worker architecture without knowledge sharing .",
    "a worker consists of an instance of the qcdcl solver depqbf  @xcite .",
    "the master balances the workload by generating subproblems defined by variable assignments ( assumptions ) , which are solved by the workers .",
    "parallel solving approaches have also been presented for quantified csps  @xcite and non - pcnf  qbfs  @xcite .",
    "hordeqbf is a parallel portfolio solver with clause and cube sharing .",
    "whereas sequential portfolio solvers like aqme  @xcite include different qbf solvers , hordeqbf integrates instances of the same qcdcl solver ( i.e. , depqbf ) . unlike mpidepqbf , hordeqbf",
    "does not rely on search space partitioning .",
    "instead , the parallel instances of depqbf are diversified by different parameter settings .",
    "hordesat is a portfolio sat solver with clause sharing  @xcite .",
    "it can be viewed as a multithreaded program running several instances of a sequential sat solver and communicating via mpi with other instances of the same program .",
    "the parallelization framework has three main tasks : to ensure that the core solvers are diversified , to handle the clause exchange , and to stop all the solvers when one of them has solved the problem . to communicate with the core solvers it uses an api which is described in detail in the hordesat paper  @xcite .",
    "since the hordeqbf interface is identical , we only briefly list the most relevant methods :    this method tells the core solver to diversify its settings .",
    "the specifics of diversification are left to the solver . the description for depqbf is given in the following section .",
    "this method is used to import learned clauses ( and cubes ) received from other solvers of the portfolio .",
    "this method sets a callback class that will process the clauses ( and cubes ) shared by this solver .",
    "in parallel qcdcl - based qbf solving , learned cubes may be shared among the solver instances in addition to learned clauses . although hordesat does not provide api functions dedicated to cube sharing , its available api readily supports it .",
    "we describe the integration of the qcdcl - based qbf solver depqbf in hordeqbf , which applies to any qcdcl - based qbf solver .",
    "we rely on version 5.0 of depqbf which comes with a dynamic variant of _ blocked clause elimination ( qbce ) _",
    "@xcite for advanced cube learning .",
    "qbce allows to eliminate redundant clauses from a pcnf  @xcite .",
    "dynamic qbce is applied frequently during the solving process .",
    "if all clauses in the pcnf are satisfied under the current assignment or removed by qbce , then a cube is learned .",
    "depqbf features a sophisticated analysis of variable dependencies in a pcnf  @xcite to relax the linear ordering of variables in the prefix . for the experiments in this paper , however , we disabled dependency analysis for both hordeqbf and the sequential variant of depqbf since the use of dependency information causes run time overhead ( during clause / cube learning ) in addition to overhead already caused by dynamic blocked clause elimination ( qbce ) @xcite .",
    "we modified depqbf as follows to integrate it in hordeqbf",
    ". learned constraints are exported to the master process right after they have been learned .",
    "the master does not distinguish between learned clauses and cubes but treats them as sorted lists of literals .",
    "we add special marker literals to learned clauses and cubes to distinguish between them at the time when the master provides the workers with sets of shared learned constraints .    in depqbf",
    "we check whether shared constraints are available for import after a restart has been carried out . to this end , we modified the restart policy of depqbf to always backtrack to decision level zero .",
    "this is different from the original restart policy of depqbf  @xcite , where the solver backtracks to higher decision levels depending on the current assignment . after a restart ,",
    "available shared constraints are imported , the watched data structures are updated , and qcdcl continues by propagating unit literals resulting from imported constraints .",
    "every instance of depqbf receives a random seed from the master and diversifies the solving process as follows .",
    "the values of variables in the _ assignment cache _",
    "@xcite are initialized at random . in general ,",
    "decision variables are assigned to the cached value ( if any ) .",
    "the assignment cache is updated with values assigned by unit propagation and pure literal detection . as an effect of random initialization ,",
    "the first value assigned to a decision variable is always a random value .",
    "parameters of _ variable activity scaling _ are set at random .",
    "depqbf implements variable activities similar to minisat  @xcite . additionally , the amount ( percentage ) of learned constraints that are removed periodically is initialized at random .",
    "depqbf stores learned clauses and cubes in separate lists with certain capacities . if a list has been filled during learning then less frequently used constraints are removed and the capacity of the list is increased .",
    "depqbf implements a _ nested restart scheme _ similar to picosat  @xcite , the parameters of which are randomly selected .",
    "variants of _ dynamic qbce _",
    "@xcite are enabled at random , including switching off dynamic qbce at all , or applying qbce only as a preprocessing or inprocessing step .",
    "finally , applications of _ long - distance resolution _",
    "@xcite , an extension of traditional q - resolution  @xcite used to derive learned constraints , are toggled at random .",
    "to examine our portfolio - based parallel qbf solver hordeqbf we performed experiments using all the 735 benchmark problems from the application track of the 2014 qbf gallery @xcite .",
    "we compared hordeqbf with depqbf , which is the qbf solver in the core of hordeqbf .",
    ".the speedup of hordeqbf configurations relative to depqbf .",
    "the second column is the number of instances solved by hordeqbf , the third is the number of instances solved by both depqbf ( in 50000s ) and the hordeqbf ( in 900s ) .",
    "the following six columns contain the average , total , and median speedups for either all the instances solved by hordeqbf or only big instances ( solved after 10@xmath9#cores seconds by depqbf ) .",
    "the last column is the parallel efficiency ( median speedup/#cores ) .",
    "[ cols= \" > , > , > , > , > , > , > , > , > , > \" , ]     # cores seconds by depqbf  the data corresponding to columns  79 of table  [ tab - speedup ] ) .",
    "]    the experiments were run on a cluster with nodes having two octa - core 2.6 ghz intel xeon e5 - 2670 processors ( sandy bridge ) and 64 gb of main memory .",
    "each node has 16 cores and we used 64 nodes which amounts in the total of 1024 cores .",
    "the nodes communicate using an infiniband 4x qdr interconnect and use the suse linux enterprise server 11 ( x86_64 ) ( patch level  3 ) operating system .",
    "hordeqbf was compiled using the icpc compiler version 15.0.2 .",
    "the complete source code and detailed experimental results are available at http://baldur.iti.kit.edu / hordesat/.    we ran experiments using 2 , 4 ,  , 64 cluster nodes . on each node we ran four processes with four threads each , which amounts to 16 core solver ( depqbf ) instances per node .",
    "the results are summarized in figure  [ fig_cact ] using cactus plots .",
    "we can observe that increasing the number of cores is beneficial for both sat and unsat instances since the number of solved instances steadily increases and runtimes are reduced .",
    "however , it is not easy to see from a cactus plot whether the additional performance is a reasonable return on the invested hardware resources . therefore we include table  [ tab - speedup ] in order to quantify the overall scalability of hordeqbf .",
    "we compute speedups for all the instances solved by the parallel solver .",
    "we ran depqbf with a time limit @xmath10 and for the instances it did not solve we use the runtime of @xmath11 in speedup calculation .",
    "the parallel configurations have a time limit of @xmath12 .",
    "columns 4 , 5 , and 6 of table  [ tab - speedup ] show the average , total ( sum of sequential runtimes divided by the sum of parallel runtimes ) and median speedup values respectively . while the average and total speedup values are high , the median speedup is below one .",
    "nevertheless , these figures treat hordeqbf unfairly since the majority of the benchmarks is easy ( solvable under a minute by depqbf ) and it makes no sense to use large computer clusters to solve them . in parallel computing , it is usual to analyze the performance on many processors using _",
    "weak scaling _ where one increases the amount of work involved in the considered instances proportionally to the number of processors . therefore in columns 79 we restrict ourselves to `` big instances ''  where depqbf needs at least 10@xmath9(the number of cores used by hordeqbf ) seconds to solve them .",
    "the average , total and median speedup values get significantly larger and in fact we obtain highly superlinear average and median speedups .",
    "figure  [ fig_speedup ] shows the distribution of speedups for these instances , it also reveals how many instances ( x - axis ) qualify as `` big instances '' .",
    "we showed that qbf solving can be successfully parallelized using the same techniques as for massively parallel sat solving .",
    "our parallel qbf solver hordeqbf achieved superlinear total and median speedups for hard instances , i.e. , instances where parallelization makes sense .    as future work",
    "it would be interesting to consider further variants of q - resolution systems  @xcite ( apart from traditional  @xcite and long - distance resolution  @xcite ) as a means of diversification in hordeqbf , which would amount to a combination of qbf proof systems with different power .",
    "further , it may be promising to equip hordeqbf with search space partitioning as in                  feldmann , r. , monien , b. , schamberger , s. : a distributed algorithm to evaluate quantified boolean formulae . in : proc . of the 17th nat .",
    "conference on artificial intelligence ( aaai 2000 ) .",
    "aaai ( 2000 )"
  ],
  "abstract_text": [
    "<S> the recently developed massively parallel satisfiability ( sat ) solver hordesat was designed in a modular way to allow the integration of any sequential cdcl - based sat solver in its core . </S>",
    "<S> we integrated the qcdcl - based quantified boolean formula ( qbf ) solver depqbf in hordesat to obtain a massively parallel qbf solver  hordeqbf . in this paper </S>",
    "<S> we describe the details of this integration and report on results of the experimental evaluation of hordeqbf s performance . </S>",
    "<S> hordeqbf achieves superlinear average and median speedup on the hard application instances of the 2014 qbf gallery . </S>"
  ]
}