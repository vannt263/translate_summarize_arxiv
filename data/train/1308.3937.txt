{
  "article_text": [
    "( ben - gurion equi - propagation encoder ) is a tool which applies to encode finite domain constraint models to cnf .",
    "was first introduced in  @xcite and is further described in @xcite . during the encoding process ,  performs optimizations based on equi - propagation  @xcite and partial evaluation to improve the quality of the target cnf .",
    "is implemented in ( swi ) prolog and can be applied in conjunction with any sat solver .",
    "it can be downloaded from  @xcite where one can also find examples of its use .",
    "this version of  is configured to apply the cryptominisat solver @xcite through a prolog interface @xcite .",
    "cryptominisat offers direct support for ` xor ` clauses , and  can be configured to take advantage of this feature .",
    "a main design choice of  is that integer variables are represented in the unary order - encoding ( see , e.g.  @xcite ) which has many nice properties when applied to small finite domains . in the _ order - encoding _ , an integer variable @xmath0 in the domain",
    "@xmath1 $ ] is represented by a bit vector @xmath2 $ ] .",
    "each bit @xmath3 is interpreted as @xmath4 implying that @xmath0 is a monotonic non - increasing boolean sequence .",
    "for example , the value 3 in the interval @xmath5 $ ] is represented in 5 bits as @xmath6 $ ] .",
    "it is well - known that the order - encoding facilitates the propagation of bounds .",
    "consider an integer variable @xmath2 $ ] with values in the interval @xmath7 $ ] . to restrict @xmath0 to take values in the range @xmath8 $ ] ( for @xmath9 ) , it is sufficient to assign @xmath10 and @xmath11 ( if @xmath12 ) .",
    "the variables @xmath13 and @xmath14 for @xmath15 and @xmath16 are then determined @xmath17 and @xmath18 , respectively , by _",
    "unit propagation_. for example , given @xmath19 $ ] , assigning @xmath20 and @xmath21 propagates to give @xmath22 $ ] , signifying that @xmath23 .",
    "we observe an additional property of the order - encoding for @xmath2 $ ] : its ability to specify that a variable can not take a specific value @xmath24 in its domain by equating two variables : @xmath25 .",
    "this indicates that the order - encoding is well - suited not only to propagate lower and upper bounds , but also to represent integer variables with an arbitrary , finite set , domain .",
    "for example , given @xmath19 $ ] , equating @xmath26 imposes that @xmath27 .",
    "likewise @xmath28 and @xmath29 impose that @xmath30 and @xmath31 . applying these equalities to @xmath0 gives , @xmath32 $ ] ( note the repeated literals ) , signifying that @xmath33 .",
    "the order - encoding has many additional nice features that can be exploited to simplify constraints and their encodings to cnf .",
    "to illustrate one , consider a constraint of the form @xmath34 where ` a ` and ` b ` are integer values in the range between 0 and 5 represented in the order - encoding . at the bit level ( in the order encoding )",
    "we have : @xmath35}$ ] and @xmath36}$ ] .",
    "the constraint is satisfied precisely when @xmath37}$ ] .",
    "equi - propagation derives the equations @xmath38 and instead of encoding the constraint to cnf , we apply the substitution indicated by @xmath39 , and remove the constraint which is a tautology given @xmath39 .",
    "is a constraint modeling language similar to the subset of flatzinc  @xcite relevant for finite domain constraint problems .",
    "the full language is presented in table [ tab : beesyntax ] .",
    "boolean constants `` @xmath17 '' and `` @xmath18 '' are viewed as ( integer ) values `` 1 '' and `` 0 '' .",
    "constraints are represented as ( a list of ) prolog terms .",
    "boolean and integer variables are represented as prolog variables and may be instantiated when simplifying constraints . in table",
    "[ tab : beesyntax ] , @xmath40 and @xmath41 ( possibly with subscripts ) denote a boolean literal and a vector of literals , @xmath42 ( possibly with subscript ) denotes an integer variable , and @xmath43 ( possibly with subscript ) denotes an integer constant . on the right column of the table",
    "are brief explanations regarding the constraints .",
    "the table introduces 26 constraint templates .",
    "constraints ( 1 - 2 ) are about variable declarations : booleans and integers . constraint ( 3 ) expresses a boolean as an integer value",
    ". constraints ( 4 - 8 ) are about boolean ( and reified boolean ) statements .",
    "the special cases of constraint ( 5 ) for @xmath44)}$ ] and @xmath45)}$ ] facilitate the specification of clauses and of ` xor ` clauses ( supported directly in the cryptominisat solver  @xcite ) .",
    "constraint ( 8) specifies that sorting a bit pair @xmath46}$ ] ( decreasing order ) results in the pair @xmath47}$ ] .",
    "this is a basic building block for the construction of sorting networks @xcite used to encode cardinality ( linear boolean ) constraints during compilation as described in  @xcite and  @xcite",
    ". constraints ( 9 - 14 ) are about integer relations and operations . constraints ( 15 - 20 ) are about linear ( boolean , pseudo boolean , and integer ) operations . constraints ( 21 - 26 ) are about lexical orderings of boolean and integer arrays .",
    "rlll + ( 1)&@xmath48 & & declare boolean ` x ` + ( 2)&@xmath49 & & declare integer ` i ` , @xmath50 + ( 3 ) & @xmath51 & & @xmath52 +     + ( 4 ) & @xmath53  or   @xmath54 & @xmath55 & @xmath56  or   @xmath57 + ( 5 ) & @xmath58)}$ ] & @xmath55 & @xmath59 + ( 6 ) & @xmath60,~x)}$ ] & @xmath55 & @xmath61 + ( 7 ) & @xmath62 & @xmath55 & @xmath63 + ( 8)&@xmath64 & @xmath55 & @xmath65)=[x_3,x_4]}$ ] +     +   + ( 9 ) & @xmath66 & @xmath55 & @xmath67 + ( 10 ) & @xmath68 & @xmath55 & @xmath69 + ( 11 ) & @xmath70)}$ ] & & @xmath71 + ( 12)&@xmath72 & @xmath55 & @xmath73 + ( 13)&@xmath74 & @xmath55 & @xmath75 + ( 14)&@xmath76,~i)}$ ] & @xmath55 & @xmath77 +     + ( 15 ) & @xmath78,~i)}$ ] & @xmath55 & @xmath79 + ( 16)&@xmath80,[x_1,\\ldots , x_n],~i)}$ ] & @xmath55 & @xmath81 + ( 17)&@xmath82,c,~i)}$ ] & @xmath55 & @xmath83 + ( 18)&@xmath84,~i)}$ ] & @xmath55 & @xmath85 + ( 19)&@xmath86,[i_1,\\ldots , i_n],~i)}$ ] & @xmath55 & @xmath87 + ( 20)&@xmath88,c,~i)}$ ] & @xmath55 & @xmath89 +     +    ( 21 ) & @xmath90 & @xmath55 & @xmath91 ( lex order ) + ( 22 ) & @xmath92 & @xmath55 & @xmath93 ( lex order ) + ( 23 ) & @xmath94 & @xmath55 & @xmath95 + ( 24 ) & @xmath96 & @xmath55 & @xmath97 + ( 25 ) & @xmath98 & @xmath55 & @xmath99 ( lex order ) + ( 26 ) & @xmath100 & @xmath55 & @xmath101 ( lex order ) +    the compilation of a constraint model to a cnf using  goes through three phases : * ( 1 ) *  unary bit - blasting : integer variables ( and constants ) are represented as bit vectors in the order - encoding . *",
    "( 2 ) *  constraint simplification : three types of actions are applied : equi - propagation , partial evaluation , and decomposition of constraints .",
    "simplification is applied repeatedly until no rule is applicable . * ( 3 ) *  cnf encoding : the best suited encoding technique is applied to the simplified constraints .",
    "bit - blasting is implemented through prolog unification .",
    "each declaration of the form @xmath49 triggers a unification @xmath102}$ ] . to ease presentation",
    "we assume that integer variables are represented in a positive interval starting from  @xmath103 but there is no such limitation in practice (  supports also negative integers )",
    ".  applies ad - hoc equi - propagators .",
    "each constraint is associated with a set of ad - hoc rules .",
    "the novelty is that the approach is not based on cnf , as in previous works ( for example @xcite , @xcite , @xcite , and @xcite ) , but rather driven by the bit blasted constraints that are to be encoded to cnf .",
    "for example , figure  [ fig : rules2 ] illustrates the rules for the ` int_plus `  constraint .",
    "r72 mm      + & then propagate + @xmath4 , @xmath104 & @xmath105 + @xmath106 , @xmath107 & @xmath108 + @xmath109 , @xmath110 & @xmath111 + @xmath112 , @xmath113 & @xmath114 + @xmath115 & @xmath116 + @xmath117 & @xmath118 +    for an integer @xmath119 , we write : @xmath4 to denote the equation @xmath120 , @xmath106 to denote the equation @xmath121 , @xmath122 to denote the equation @xmath123 , and @xmath115 to denote the pair of equations @xmath124 .",
    "we view @xmath119 as if padded with sentinel cells such that all cells `` to the left of '' @xmath125 take value 1 and all cells `` to the right of '' @xmath126 take the value 0 .",
    "this facilitates the specification of the `` end cases '' in the formalism .",
    "the first four rules of figure  [ fig : rules2 ] capture the standard propagation behavior for interval arithmetic .",
    "the last two rules apply when one of the integers in the relation is a constant .",
    "there are symmetric cases when replacing the role of @xmath0 and @xmath127 .",
    "when an equality of the form @xmath128 ( between a variable and a literal or a constant ) is detected , then equi - propagation is implemented by unifying @xmath0 and @xmath129 and applies to all occurrences of @xmath0 thus propagating to other constraints involving @xmath0 .",
    "decomposition is about replacing complex constraints ( for example about arrays ) with simpler constraints ( for example about array elements ) .",
    "consider , for instance , the constraint @xmath130 .",
    "it is decomposed to a list of @xmath131 constraints applying a straightforward divide and conquer recursive definition . at the base case ,",
    "if ` as=[a ] ` then the constraint is replaced by a constraint of the form ` int_eq(a , sum ) ` which equates the bits of @xmath132 and @xmath133 , or if @xmath134}$ ] then it is replaced by @xmath135 . in the general case ` as ` is split into two halves , then constraints are generated to sum these halves , and then an additional @xmath131 constraint is introduced to sum the two sums .",
    "cnf encoding is the last phase in the compilation of a constraint model .",
    "each of the remaining simplified ( bit - blasted ) constraints is encoded directly to a cnf .",
    "these encodings are standard and similar to those applied in various tools such as sugar  @xcite .",
    "cardinality constraints take the form @xmath136 where the @xmath3 are boolean literals , @xmath137 is a constant , and the relation @xmath138 might be any of @xmath139 . there is a wide body of research on the encoding of cardinality to cnf .",
    "we focus on those using sorting networks .",
    "for example , the presentations in @xcite , @xcite , and @xcite describe the use of odd - even sorting networks to encode pseudo boolean and cardinality constraints to boolean formula .",
    "we observe that for applications of this type , it suffices to apply `` selection networks ''  @xcite rather than sorting networks .",
    "selection networks apply to select the @xmath137 largest elements from @xmath140 inputs . in  @xcite",
    ", knuth shows a simple construction of a selection network with @xmath141 size whereas , the corresponding sorting network is of size @xmath142 .",
    "totalizers  @xcite are similar to sorting networks except that the merger for two sorted sequences involves a direct encoding with @xmath143 clauses instead of @xmath144 clauses .",
    "totalizers have been shown to give better encodings when cardinality constraints are not excessively large .",
    "enables the user to select encodings based on sorting networks , totalizers or a hybrid approach which is further detailed below .",
    "consider the constraint @xmath145 in a context where @xmath146 is a list of @xmath140 boolean literals and integer variable @xmath147 defined as @xmath148",
    ".  applies a divide and conquer strategy . if @xmath149 , the constraint is trivial and satisfied by unifying @xmath150 .",
    "if @xmath151 and @xmath134}$ ] then @xmath152}$ ] and the constraint is decomposed to @xmath153 . in the general case , where @xmath154 , the constraint is decomposed as follows where @xmath155 and @xmath156 are a partitioning of @xmath146 such that @xmath157 , @xmath158 , and @xmath159 : @xmath160 this decomposition process continues as long as there remain @xmath161 and when it terminates the model contains only ` comparator ` and ` int_plus ` constraints .",
    "the interesting discussion is with regards to the @xmath131 constraints where  offers two options and depending on this choice the original ` bool_array_sum_eq ` constraint then takes the form either of a sorting network  @xcite or of a totalizer  @xcite .",
    "so , consider a constraint @xmath162 where @xmath163}$ ] , @xmath164}$ ] and @xmath165}$ ] represent integer variables in the order encoding .",
    "a unary adder leads to a direct encoding of the sum of two unary numbers .",
    "it involves @xmath143 clauses where @xmath140 is the size of the inputs and as a circuit it has `` depth '' 1 .",
    "the encoding introduces the following clauses where @xmath166 and @xmath167 : @xmath168 an alternative encoding for @xmath162 is obtained by means of a recursive decomposition based on the so called odd - even merger from batcher s construction  @xcite .",
    "it leads to an encoding with @xmath169 clauses where @xmath140 is the size of the inputs and as a circuit it has `` depth '' @xmath170 .",
    "the decomposition is as follows ( ignoring the base cases ) where @xmath171 , @xmath172 , @xmath173 and @xmath174 are partitions of @xmath132 and @xmath175 to their odd and even positioned elements , @xmath176 , @xmath177 are new unary variables defined with the appropriate domains , and where @xmath178 signifies a set of comparator constraints and is defined as @xmath179 : @xmath180 in addition to the encodings based on unary adders ( direct ) and mergers ( recursive decomposition ) ,  offers a combination of the two which we call `` hybrid '' .",
    "the intuition is simple : in the hybrid approach we perform recursive decomposition as for odd - even mergers , but only so long as the resulting cnf is predetermined to be smaller than the corresponding unary adder .",
    "so , it is just like a merger except that the base case is a unary adder . before each decomposition of @xmath131 ,",
    "evaluates the benefit ( in terms of cnf size ) of decomposing the constraint as a merger and takes the smaller of the two .",
    "figure  [ fig : size ] depicts the size of cnf encodings for the constraint @xmath162 where @xmath181 .",
    "the left graph illustrates the number of clauses in the three encodings .",
    "the unary adder has fewest number of clauses for inputs of size 7 or less .",
    "the hybrid encoding is always just slightly smaller than the merger .",
    "each time a merger is decomposed to an adder it is just about of the same number of clauses . in contrast , in the right graph we see that the encoding never introduces fresh variables , and as the size of the input increases so does the benefit of the hybrid approach in number of added variables .",
    "now let us consider the constraint @xmath182 where @xmath146 is a list of @xmath140 boolean literals and @xmath137 is a constant .",
    "assume as before that @xmath155 and @xmath156 are a partitioning of @xmath146 such that @xmath157 , @xmath158 , and @xmath159 .",
    "a naive decomposition might proceed as follows:@xmath183      { \\ext@arrow 0359\\rightarrowfill@{}{\\mathtt{decompose } } }      \\fbox{$\\begin{array}{ll }      \\mathtt{new\\_int(y,0,n)},\\\\      \\mathtt{new\\_int(t_1,0,n_1)},~ & \\mathtt{bool\\_array\\_sum\\_eq(as_1,t_1)},\\\\      \\mathtt{new\\_int(t_2,0,n_2)},~ & \\mathtt{bool\\_array\\_sum\\_eq(as_2,t_2)},\\\\      \\mathtt{int\\_plus(t_1,t_2,y ) } , &      \\mathtt{int\\_leq(y , k ) }    \\end{array}$ } \\end{array}\\ ] ] but we can do better . in  we decompose @xmath182 as follows : @xmath184 this is correct because the constraint @xmath185 defines @xmath186 and so we have @xmath187 this encoding is preferable because the @xmath185 constraint is encoded with 0 clauses ( due to equi - propagation ) and the @xmath188 constraint in @xmath189 clauses .",
    "whereas in the naive version the @xmath190 is encoded in @xmath191 or @xmath143 ( sorting network or direct ) and the @xmath192 is encoded with 0 clauses .",
    "equi - propagation is about inferring boolean equalities , @xmath193 , implied from a given cnf formula @xmath194 where @xmath195 is a boolean variable and @xmath196 a boolean constant or literal .",
    "complete equi - propagation ( cep ) is about inferring all such equalities .",
    "equi - propagation in  is based on ad - hoc rules and thus incomplete .",
    "however ,  allows the user to specify , for given sets of constraints in a model , that cep is to be applied ( instead of ad - hoc equi - propagation ) .",
    "cep generalizes the notion of a backbone @xcite .",
    "the backbone of a cnf , @xmath194 , is the set of literals that are true in all models of @xmath194 , thus corresponding to the subset of equations , @xmath197 obtained from cep where @xmath198 is a boolean constant .",
    "backbones prove useful in applications of sat such as model enumeration , minimal model computation , prime implicant computation , and also in applications which involve optimization ( see for example , @xcite ) . assigning values to backbone variables",
    "reduces the size of the search space while maintaining the meaning of the original formula . in exactly the same way",
    ", cep identifies additional variables that can be removed from a formula , to reduce the search space , by equating pairs of literals , as in @xmath199 or @xmath200 .",
    "backbones are often computed by iterating with a sat solver . in  @xcite ,",
    "the authors describe and evaluate several such algorithms and present an improved algorithm .",
    "this algorithm involves exactly one unsatisfiable call to the sat solver and at most @xmath201 satisfiable calls , where @xmath140 is the number of variables in @xmath194 and @xmath202 the size of its backbone .",
    "it is straightforward to apply an algorithm that computes the backbone of a cnf , @xmath194 , to perform cep ( to detect also equations between literals ) . enumerating the variables of @xmath194 as @xmath203 .",
    "one simply defines @xmath204 introducing @xmath205 fresh variables @xmath206 .",
    "if @xmath206 is in the backbone of @xmath207 then @xmath208 is implied by @xmath194 , and if @xmath209 is in the backbone then @xmath210 is implied .",
    "a major obstacle is that computing the backbone of @xmath194 is at least as hard as testing for the satisfiability of @xmath194 itself .",
    "hence , for , the importance of the assumption that @xmath194 is only a small fragment of the cnf of interest .",
    "another obstacle is that the application of cep for @xmath194 with @xmath140 variables involves computing the backbone for @xmath207 which has @xmath205 variables .",
    "the cep algorithm applied in  is basically the same as that proposed for computing backbones in  @xcite extending @xmath194 to @xmath207 as prescribed by equation ( [ eq : cep ] ) .",
    "we prove that iterated sat solving for cep using @xmath207 involves at most @xmath211 satisfiable sat tests , and exactly one unsatisfiable test , in spite of the fact that @xmath207 involves a quadratic number of fresh variables .",
    "we first describe the algorithm applied to compute the backbone of a given formula @xmath194 , which we assume is satisfiable .",
    "the algorithm maintains a table indicating for each variable @xmath195 in @xmath194 for which values of @xmath195 , @xmath194 can be satisfied : @xmath17 , @xmath18 , or both .",
    "the algorithm is initialized by calling the sat solver with @xmath212 and initializing the table with the information relevant to each variable : if the solution for @xmath213 assigns a value to @xmath195 then that value is tabled for @xmath195 . if it assigns no value to @xmath195 then both values are tabled for @xmath195 .",
    "the algorithm iterates incrementally . for each step",
    "@xmath214 we add a single clause @xmath215 ( detailed below ) and reinvoke the same solver instance , maintaining the learned data of the solver .",
    "this process terminates with a single unsatisfiable invocation . in words :",
    "the clause @xmath215 can be seen as asking the solver if it is possible to flip the value for any of the variables for which we have so far seen only a single value .",
    "more formally , at each step of the algorithm , @xmath215 is defined as follows : for each variable @xmath195 , if the table indicates a single value @xmath216 for @xmath195 then @xmath215 includes @xmath217 .",
    "otherwise , if the table indicates two values for @xmath195 then there is no corresponding literal in @xmath215 .",
    "the sat solver is then called with @xmath218 .",
    "if this call is satisfiable then the table is updated to record new values for variables ( there must be at least one new value in the table ) and we iterate .",
    "otherwise , the algorithm terminates and the variables remaining with single entries in the table are the backbone of @xmath194 .",
    "[ example : cep1 ]    figure  [ fig ] where we assume given a formula , @xmath194 , which has models as indicated below illustrates the backbone algorithm .",
    "the first two iterations of the algorithm provide the models , @xmath219 and @xmath220 .",
    "the next iteration illustrates that @xmath194 has no model which satisfies @xmath194 and flips the values of @xmath125 ( to false ) or of @xmath221 ( to true ) .",
    "we conclude that @xmath125 and @xmath221 are the backbone variables of @xmath194 .",
    "now consider the case where in addition to the backbone we wish to derive also equations between literals which hold in all models of @xmath194 .",
    "the cep algorithm for @xmath194 is as follows : ( 1 )  enhance @xmath194 to @xmath207 as specified in equation  [ eq : cep ] , and ( 2 ) apply backbone computation to @xmath207 . if @xmath222 then @xmath223 and if @xmath224 then @xmath225 . as an optimization , it is possible to focus in the first two iterations only on the variables of @xmath194 .",
    "[ example : cep2 ]    consider the same formula @xmath194 as in example  [ example : cep1 ] .",
    "this time , in the third iteration we ask to either flip the value for one of @xmath226 or for one of @xmath227 and there is such a model , @xmath228 .",
    "this is illustrated as figure  [ fig ]    [ thm : cep ] let @xmath194 be a cnf , @xmath0 a set of @xmath140 variables , and @xmath229 the sequence of assignments encountered by the cep algorithm for @xmath194 and @xmath0 .",
    "then , @xmath230 .    before presenting a proof of theorem  [ thm : cep ]",
    "we introduce some terminology .",
    "assume a set of boolean variables @xmath0 and a sequence @xmath229 of models .",
    "denote @xmath231 and let @xmath232 . if @xmath233 for all @xmath234 or if @xmath235 for all @xmath234 , then we say that @xmath236 _ determines _ the equation @xmath199 .",
    "otherwise , we say that @xmath236 _ disqualifies _",
    "@xmath199 , intuitively meaning that @xmath236 disqualifies @xmath199 from being determined .",
    "more formally , @xmath236 _ determines _",
    "@xmath199 if and only if @xmath237 or @xmath238 , and otherwise @xmath236 _ disqualifies _ @xmath199 .",
    "the cep algorithm for a formula @xmath194 and set of @xmath140 variables @xmath0 applies so that each iteration results in a satisfying assignment for @xmath194 which disqualifies at least one additional equation between elements of @xmath239 .",
    "although there are a quadratic number of equations to be considered , we prove that the cep algorithm terminates after at most @xmath211 iterations .",
    "( of theorem  [ thm : cep ] ) for each value @xmath240 , @xmath241 induces a partitioning , @xmath242 of @xmath239 to disjoint and non - empty sets , defined such that for each @xmath232 , @xmath195 and @xmath243 are in the same partition @xmath244 if and only if @xmath245 determines the equation @xmath199 .",
    "so , if @xmath246 then the equation @xmath199 takes the same value in all assignments of @xmath245 . the partitioning is well defined because if in all assignments of @xmath245 both @xmath199 takes the same value and @xmath247 takes the same value , then clearly also @xmath248 takes the same value , implying that @xmath249 are in the same partition of @xmath242 .",
    "finally , note that each iteration @xmath250 of the cep algorithm disqualifies at least one equation @xmath199 that was determined by @xmath251 .",
    "this implies that at least one partition of @xmath252 is split into two smaller ( non - empty ) partitions of @xmath253 .",
    "as there are a total of @xmath211 elements in @xmath239 , there can be at most @xmath211 iterations to the algorithm .",
    "[ example : cep3 ]    consider the same formula @xmath194 as in examples  [ example : cep1 ] and  [ example : cep2 ]",
    ". figure  [ fig ] illustrates the run of the algorithm in terms of the partitioning @xmath254 from the proof of theorem  [ thm : cep ] .",
    "we illustrate the impact of cep with an application where the goal is to find the largest number of edges in a simple graph with @xmath140 nodes such that any cycle ( length ) is larger than 4 . the graph is represented as a boolean adjacency matrix @xmath255 and there are two types of constraints : ( 1 )  constraints about cycles in the graph : @xmath256+a[j , k]+a[k , i ] < 3 $ ] , and @xmath257+a[j , k]+a[k , l ] + a[l , i ] < 4 $ ] ; and ( 2 )  constraints about symmetries : in addition to the obvious @xmath258\\equiv a[j , i ] \\mbox{~~ and~~",
    "} a[i , i]\\equiv{\\mathit{false}})$ ] , we constrain the rows of the adjacency matrix to be sorted lexicographically ( justified in  @xcite ) , and we impose lower and upper bounds on the degrees of the graph nodes as described in  @xcite .",
    "table  [ table : cep ] illustrates results , running  with and without cep .",
    "here , we focus on finding a graph with the prescribed number of graph nodes with the known maximal number of edges ( all instances are satisfiable ) , and cep is applied to the set of clauses derived from the symmetry constraints ( 2 ) detailed above .",
    "the table indicates the number of nodes , and for each cep choice : the compilation time , the number of clauses and variables , and the subsequent sat solving time .",
    "the table indicates that cep increases the compilation time ( within reason ) , reduces the cnf size ( considerably ) , and ( for the most ) improves sat solving time.experiments are performed on a single core of an intel(r ) core(tm ) i5 - 2400 3.10ghz cpu with 4 gb memory under linux ( ubuntu lucid , kernel 2.6.32 - 24-generic ) . ]",
    ".search for graphs with no cycles of size 4 or less ( comp .",
    "& solve times in sec . )",
    "[ cols=\"^ , > , > , > , > , > , > , > , > , > \" , ]     [ [ squaring ] ] * squaring :  * + + + + + + + + + + + + +    consider the special case of multiplication @xmath259 specifying that @xmath260 where we introduce two additional optimizations .",
    "first , consider the variables @xmath261 introduced in equation  [ eq : sq ] , we have @xmath262 and hence equi - propagation applies to remove the redundant variables .",
    "the result of this is illustrated in figure  [ fig : square ] . in figure",
    "[ fig : square ] we reorder the bits in the columns , as if , letting the bits drop down to the baseline .",
    "second , consider the `` columns '' in the @xmath263,c)}$ ] constraint .",
    "each variable of the form @xmath264 with @xmath265 in a column occurs twice .",
    "so , both can be removed and one inserted back in the column to the left .",
    "this is illustrated in figure  [ fig : square ] where we highlight the move of the two @xmath266 instances .",
    "these optimizations reduce the size of the cnf and are applied both in the binary and in the unary encodings .    to evaluate the encoding of @xmath267 for the special case when @xmath268 , we consider the application of to model and solve the number partitioning problem , also known as ` csplib 049 ` .",
    "here , one should finding a partition of numbers @xmath269 into two sets @xmath255 and @xmath270 such that : @xmath255 and @xmath270 have the same cardinality , the sum of numbers in @xmath255 equals the sum of numbers in @xmath270 , and the sum of the squares of the numbers in @xmath255 equals the sum of the squares of the numbers in @xmath270 .",
    "figure [ fig : comparenumpartition ] depicts our results .",
    "we consider four settings .",
    "the first two are the binary and unary approaches described above where buckets of bits of the same binary weight are summed using full adders or sorting networks respectively . in the other two settings ,",
    "we apply complete equi - propagation per individual constraint ( on binary numbers ) , on top of the ad - hoc rules implemented in .",
    "figure  [ fig : comparenumpartition ] illustrates the size of the encodings ( number of cnf variables ) for each of the four settings in terms of the instance size .",
    "the two top curves coincide and correspond to the unary encodings which create slightly larger cnfs .",
    "however note that the unary core of  with its ad - hoc ( and more efficient ) implementation of equi - propagation , detects all of the available equi - propagation .",
    "there is no need to apply cep .",
    "the bottom two curves correspond to the binary encodings and illustrate that cep detects further optimizations beyond what is detected using .",
    "figure  [ fig : comparenumpartition ] details the sat solving times .",
    "here we ignore the compilation times ( which are high when using cep ) and focus on the quality of the obtained cnf .",
    "the graph indicates a clear advantage to the unary approach ( where cep is not even required ) .",
    "the average solving time using the unary approach approach ( without cep ) is 270 ( sec ) vs 1503 ( sec ) using the binary approach ( with cep ) .",
    "this is in spite of the fact that unary approach involves larger cnf sizes .",
    "figures  [ fig : comparenumpartition ] and further detail the effect of cep in the binary and unary encodings depicting the numbers of clauses and of variables reduced by cep in both techniques .",
    "the smaller this number , the more equi - propagation performed ad - hoc by . in both graphs the lower curve corresponds to the encodings based on the unary core indicating that this is the one of better quality .",
    "see footnote [ [ machine ] ] for details on machine .",
    "we have detailed two features of  not described in previous publications .",
    "these concern the hybrid approach to encode cardinality constraints and the procedure for applying complete equi - propagation .",
    "we have also described our approach to enhance the unary kernel of  for binary numbers .",
    "our approach is to rely as much as possible on the implementation of equi - propagation on unary numbers to build the task of equi - propagation for binary numbers .",
    "we have illustrated the power of this approach when encoding binary number multiplication .",
    "the extension of  for binary numbers is ongoing and still requires a thorough experimentation to evaluate its design .",
    "r.  asn , r.  nieuwenhuis , a.  oliveras , and e.  rodrguez - carbonell .",
    "cardinality networks and their applications .",
    "in o.  kullmann , editor , _ sat _ , volume 5584 of _ lecture notes in computer science _ , pages 167180 .",
    "springer , 2009 .",
    "k.  e. batcher .",
    "sorting networks and their applications . in _",
    "afips spring joint computing conference _ , volume  32 of _ afips conference proceedings _ , pages 307314 , atlantic city , nj , usa , 1968 .",
    "thomson book company , washington d.c .",
    "m.  codish , y.  fekete , c.  fuhs , and p.  schneider - kamp .",
    "optimal base encodings for pseudo - boolean constraints . in p.",
    "a. abdulla and k.  r.  m. leino , editors , _ tacas _ , volume 6605 of _ lecture notes in computer science _ , pages 189204 .",
    "springer , 2011 .          j.  m. crawford and a.  b. baker .",
    "experimental results on the application of satisfiability algorithms to scheduling problems . in b.",
    "hayes - roth and r.  e. korf , editors , _ aaai _ , volume  2 , pages 10921097 , seattle , wa , usa , 1994 .",
    "aaai press / the mit press .",
    "n.  en and a.  biere .",
    "effective preprocessing in sat through variable and clause elimination . in f.  bacchus and t.  walsh , editors , _ sat _ , volume 3569 of _ lecture notes in computer science _ , pages 6175 .",
    "springer , 2005 .",
    "m.  heule , m.  jrvisalo , and a.  biere .",
    "efficient cnf simplification based on binary implication graphs . in k.",
    "a. sakallah and l.  simon , editors , _ sat _ , volume 6695 of _ lecture notes in computer science _ , pages 201215 .",
    "springer , 2011 .",
    "n.  manthey .",
    "coprocessor 2.0 - a flexible cnf simplifier - ( tool presentation ) . in a.",
    "cimatti and r.  sebastiani , editors , _ sat _ , volume 7317 of _ lecture notes in computer science _ , pages 436441 .",
    "springer , 2012 .",
    "j.  marques - silva , m.  janota , and i.  lynce . on computing backbones of propositional theories .",
    "in h.  coelho , r.  studer , and m.  wooldridge , editors , _ ecai _ , volume 215 of _ frontiers in artificial intelligence and applications _ , pages 1520 .",
    "ios press , 2010 .",
    "extended version : http://sat.inesc - id.pt/~mikolas / bb - aicom - preprint.pdf .",
    "n.  nethercote , p.  j. stuckey , r.  becket , s.  brand , g.  j. duck , and g.  tack .",
    "minizinc : towards a standard cp modeling language . in c.",
    "bessiere , editor , _ cp2007 _ ,",
    "volume 4741 of _ lecture notes in computer science _ , pages 529543 , providence , ri , usa , 2007 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> is a compiler which facilitates solving finite domain constraints by encoding them to cnf and applying an underlying sat solver . in  constraints </S>",
    "<S> are modeled as boolean functions which propagate information about equalities between boolean literals . </S>",
    "<S> this information is then applied to simplify the cnf encoding of the constraints . </S>",
    "<S> we term this process _ </S>",
    "<S> equi - propagation_. a key factor is that considering only a small fragment of a constraint model at one time enables to apply stronger , and even complete reasoning to detect equivalent literals in that fragment . </S>",
    "<S> once detected , equivalences propagate to simplify the entire constraint model and facilitate further reasoning on other fragments .  </S>",
    "<S> is described in several recent papers : @xcite , @xcite and @xcite . in this paper , after a quick review of , we elaborate on two undocumented details of the implementation : the hybrid encoding of cardinality constraints and complete equi - propagation . </S>",
    "<S> we then describe on - going work aimed to extend  to consider binary representation of numbers .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}