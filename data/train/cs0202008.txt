{
  "article_text": [
    "peer - to - peer systems are self - organizing distributed systems where participating nodes both provide and receive services from each other in a cooperative effort to prevent any one node or set of nodes from being overloaded .",
    "peer - to - peer systems have recently gained much attention , primarily because of the great number of features they offer applications that are built on top of them .",
    "these features include : scalability , availability , fault tolerance , decentralized administration , and anonymity .",
    "along with these features has come an array of technical challenges . in particular , over the past year , there has been much focus on the fundamental indexing and routing problem inherent in all peer - to - peer systems : given the name of an object of interest , how do you locate the object within the peer - to - peer network in a well - defined , structured manner that avoids flooding the network @xcite ?    as a performance enhancement , the designers of these systems suggest caching index entries with expiration times at intermediate nodes that lie on the path taken by a search query .",
    "intermediate caches are desirable because they balance query load for an item across multiple nodes , reduce latency , and alleviate hot spots .",
    "however , little attention has been given to how to maintain these intermediate caches .",
    "this problem is interesting because the peer - to - peer model assumes the index will change constantly .",
    "this constant change stems from several factors : peer nodes continuously join and leave the network , content is continuously added to and deleted from the network , and replicas of existing content are continuously added to alleviate bandwidth congestion at nodes holding the content .    in this paper we propose a new comprehensive architecture for controlled update propagation ( cup ) in peer - to - peer networks that asynchronously builds caches of index entries while answering search queries .",
    "it then propagates updates of index entries to maintain these caches .",
    "the basic idea is that every node in the peer - to - peer network maintains two logical channels per neighbor : a query channel and an update channel .",
    "the query channel is used to forward search queries for items of interest to the neighbor that is closest to the authority node for those items .",
    "the update channel is used to forward query responses ( first - time updates ) asynchronously to a neighbor and to update index entries that are cached at the neighbor .",
    "queries for an item travel `` up '' the query channels of nodes along the path toward the authority node for that item .",
    "updates travel `` down '' the update channels along the reverse path taken by a query .",
    "figure  [ fig : logicalchannels ] shows this process .     and",
    "@xmath0 are authority nodes .",
    "@xmath1 , @xmath2 , @xmath3 , and @xmath4 are the four logical channels between nodes @xmath5 and @xmath6 .",
    "a query arriving at node @xmath6 for an item for which @xmath7 is the authority is pushed onto query channel @xmath1 to @xmath5 . if @xmath5 has a cached entry for the item , it returns it through @xmath3 .",
    "otherwise , it forwards the query towards @xmath7 .",
    "any update originating from @xmath7 flows downstream to @xmath5 which may forward it onto @xmath6 through @xmath3 .",
    "the analogous process holds for queries at @xmath5 for items for which @xmath0 is the authority.,height=264 ]    the advantages of the query channel are twofold .",
    "first , if a node receives two or more queries for an item for which it does not have a fresh response , the node pushes only one instance of the query for that item up its query channel .",
    "this approach can have significant savings in traffic , because bursts of requests for an item are coalesced into a single request .",
    "second , using a single query channel solves the `` open connection '' problem suffered by some peer - to - peer systems .",
    "each time a query arrives at a node which does not have a cached response , the node opens one or more connections to neighboring nodes and must maintain those connections open until the response returns through them .",
    "the asynchronous nature of the query channel relieves nodes from having to maintain many open connections since all responses return through the update channel . through simple bookkeeping ( setting an interest bit )",
    "the node registers the interest of its neighbors so it knows which of its neighbors to push the query response to when the answer arrives .",
    "the cascaded propagation of updates from authority nodes down the reverse paths of search queries has many advantages .",
    "first , updates extend the lifetime of cached entries allowing intermediate nodes to continue serving queries from their caches without having to push queries up their channels explicitly .",
    "it has been shown that up to fifty percent of content hits at caches are instances where the content is valid but stale and therefore can not be used to serve queries without first being re - validated @xcite .",
    "these occurrences are called _ freshness misses_. second , a node that proactively pushes updates to interested neighbors reduces its load of queries generated by those neighbors .",
    "the cost of pushing the update down is recovered by the first query for the same item following the update .",
    "third , the further down an update gets pushed , the shorter the distance subsequent queries need to travel to reach a fresh cached answer . as a result",
    ", query response latency is reduced .",
    "finally , updates can help prevent errors .",
    "for example , an update to invalidate an index entry prevents a node from answering queries using the entry before it expires .    in cup",
    ", nodes decide individually when to receive updates .",
    "a node only receives updates for an item if the node has registered interest in that item .",
    "furthermore , each node uses its own incentive - based policy to determine when to cut off its incoming supply of updates for an item . this way the propagation of updates is controlled and",
    "does not flood the network .",
    "similarly , nodes decide individually when to propagate updates to interested neighbors .",
    "this is useful because a node may not always be able or willing to forward updates to interested neighbors .",
    "in fact , a node s ability or willingness to propagate updates may vary with its workload .",
    "cup addresses this by introducing an adaptive mechanism each node uses to regulate the rate of updates it propagates downstream .",
    "a salient feature of cup is that even if a node s capacity to push updates becomes zero , nodes dependent on the node for updates fall back with no overhead to the case of standard caching with expiration .",
    "when compared with standard caching , under unfavorable conditions , cup reduces the average miss latency by as much as a factor of three . under favorable conditions",
    ", cup reduces the average miss latency by more than a factor of ten .",
    "cup overhead is more than compensated for by its savings in cache misses .",
    "in fact , the `` investment '' return per update pushed in saved misses grows substantially with increasing network size and query rates",
    ". the cost of saved misses can be one to two orders of magnitude higher than the cost of updates pushed .",
    "we demonstrate that the performance of cup depends highly on the policy a node uses to cut off its incoming updates .",
    "we find that the cut - off policy should adapt to the node s query workload and we present probabilistic and log based methods for doing so . finally , we show that cup continues to outperform standard caching even when update propagation is reduced by either node capacity or network conditions .",
    "the rest of the paper is organized as follows : section  [ architecture ] describes in detail the design of the cup architecture .",
    "section  [ evaluation ] describes the cost model we use to evaluate cup and presents experimental evidence of the benefits of cup .",
    "section  [ relatedwork ] discusses related work and section  [ conclusions ] concludes the paper .",
    "first , we provide some background terminology we use throughout the paper and very briefly describe how peer - to - peer networks for which cup is appropriate perform their indexing and lookup operations . then we describe the components of the cup protocol",
    ".      the following terms will be useful for the remainder of the paper :    _ node _ : this is a node in the peer - to - peer network .",
    "each node periodically exchanges `` keep - alive '' messages with its neighbors to confirm their existence and to trigger recovery mechanisms should one of the neighbors fail .",
    "every node also maintains two logical channels ( connections ) for each neighbor : the query channel and the update channel .",
    "the query channel is used by the node to push queries to its neighbor .",
    "the update channel is used by the node to push updates that are of interest to the neighbor .",
    "_ global index _",
    ": the most important operation in a peer - to - peer network is that of locating content . as in @xcite",
    "we assume a hashing scheme that maps keys ( names of content files or keywords ) onto a virtual coordinate space using a uniform hash function that evenly distributes the keys to the space .",
    "the coordinate space serves as a global index that stores index entries which are _",
    "( key , value ) _ pairs .",
    "the value in an index entry is a pointer ( typically an ip address ) to the location of a replica that stores the content file associated with the entry s key .",
    "there can be several index entries for the same key , one for each replica of the content .",
    "_ authority node _ : each node",
    "n in the peer - to - peer system is dynamically allocated a subspace of the coordinate space ( i.e. , a partition of the global index ) and all index entries mapped into its subspace are owned by n. we refer to n as the authority node of these entries .",
    "_ replicas _ of content whose key corresponds to an authority node n send birth messages to n to announce they are willing to serve the content . depending on",
    "the application supported , replicas might periodically send refresh messages to indicate they are still serving a piece of content .",
    "they might also send deletion messages that explicitly indicate they are no longer serving the content .",
    "these deletion messages trigger the authority node to delete the corresponding index entry from its local index directory",
    ".    _ search query _ : a search query posted at a node n is a request to locate a replica for key k. the response to such a search query is a set of index entries that point to replicas that serve the content associated with k.    _ query path for key k _ :",
    "this is the path a search query for key _ k _ takes .",
    "each hop on the query path is in the direction of the authority node that owns _",
    "k_. if an intermediate node on this path has fresh entries cached , the path ends at the intermediate node ; otherwise the path ends at the authority node .    _",
    "reverse query path for key k _ :",
    "this path is the reverse of the query path defined above .",
    "_ local index directory _",
    ": this is the subset of global index entries owned by a node .",
    "_ cached index entries _ :",
    "this is the set of index entries cached by a node",
    "n in the process of passing up queries and propagating down updates for keys for which n is not the authority .",
    "the set of cached index entries and the local index directory are disjoint sets .",
    "_ lifetime of index entries _",
    ": we assume that each index entry cached at a node has associated with it a lifetime and a timestamp indicating the time at which the lifetime was set . when the difference between the current time and the timestamp is greater than the lifetime field , the entry has expired and can not be used to answer queries .",
    "an index entry is considered fresh until it expires .",
    "we assume that anytime a node issues a query for key _",
    "k _ , the query will be routed along a well - defined structured path with a bounded number of hops from the querying node to the authority node for _ k_. the routing mechanism is designed so that each node on the path hashes _ k _ using the same hash function to deterministically choose which of its neighbors will serve as the next hop .",
    "examples of peer - to - peer systems that provide this type of structured location and routing mechanism include content - addressable networks ( cans ) @xcite , chord @xcite , pastry @xcite and tapestry @xcite .",
    "cup can be used in the context of any of these systems .      at each node",
    ", index entries are grouped together by key .",
    "for each key k , the node stores a flag that indicates whether the node is waiting to receive an update for k for the first time and an interest bit vector .",
    "each bit in the vector corresponds to a neighbor and is set or clear depending on whether that neighbor is or is not interested in receiving updates for k.    each node tracks the popularity or request frequency of each non - local key k for which it receives queries .",
    "the popularity measure for a key k can be the number of queries for k a node receives between arrivals of consecutive updates for k or a rate of queries of a larger moving window . on an update arrival for k , a node uses its popularity measure to re - evaluate whether it is beneficial to continue caching and receiving updates for k. we elaborate on this cut - off decision in section  [ cutoffpolicies ] .",
    "node bookkeeping in cup involves no network overhead . with increasing cpu speeds and memory sizes ,",
    "this bookkeeping is negligible when we consider the reduction in query latency achieved .",
    "we classify updates into four categories : first - time updates , deletes , refreshes , and appends .",
    "deletes , refreshes , and appends originate from the replicas of a piece of content and are directed toward the authority node that owns the index entries for that content .",
    "first - time updates are query responses that travel down the reverse query path .",
    "deletes are directives to remove a cached index entry .",
    "deletes can be triggered by two events : 1 ) a replica sends a message indicating it no longer serves a piece of content to the authority node that owns the index entry pointing to that replica .",
    "2 ) the authority node notices a replica has stopped sending `` keep - alive '' messages and assumes the replica has failed . in either case ,",
    "the authority node deletes the corresponding index entry from its local index directory and propagates the delete to interested neighbors .",
    "refreshes are keep - alive messages that extend the lifetimes of index entries .",
    "refreshes that arrive at a cache do not result in errors as deletes do , but help prevent freshness misses .    finally , appends are directives to add index entries for new replicas of content .",
    "these updates help alleviate the demand for content from the existing set of replicas since they add to the number of replicas from which clients can download content .      upon receipt of a query for a key _",
    "k _ , there are three basic cases to consider . in each of the cases",
    ", the node updates its popularity measure for _ k_. the node also sets the appropriate bit in the interest bit vector for _ k _ if the query originates from a neighbor .",
    "otherwise , if the query is from a local client , the node maintains the connection until it can return a fresh answer to the client . to simplify the protocol description we use the phrase ``",
    "push the query '' to indicate that a node pushes a query upstream toward the authority node .",
    "we use the phrase `` push the update '' to indicate that a node pushes an update downstream in the direction of the reverse query path .",
    "* case 1 : fresh entries for key k are cached . * the node uses its cached entries for _ k _ to push the response as a first - time update to the querying neighbor or local client .",
    "* case 2 : key k is not in cache . *",
    "the node adds _ k _ to its cache and marks it with a _ pending - first - update _ flag .",
    "the purpose of the _ pending - first - update _ flag is to coalesce bursts of queries for the same key into one query . a subsequent query for _ k _ from a neighbor or a local client will save the node from pushing another instance of the query for _",
    "* case 3 : all cached entries for key k have expired .",
    "* the node must obtain the fresh index entries for _ k_.",
    "if the _ pending - first - update _ flag is set , the node does not need to push the query ; otherwise , the node sets the flag and pushes the query .",
    "a key feature of cup is that a node does not forward an update for _ k _ to its neighbors unless those neighbors have registered interest in _",
    "k_. therefore , with some light bookkeeping , we prevent unwanted updates from wasting network bandwidth .    upon receipt of an update for key _",
    "k _ there are three cases to consider .",
    "* case 1 : pending - first - update flag is set .",
    "* this means that the update is a first - time update carrying a set of index entries in response to a query .",
    "the node stores the index entries in its cache , clears the _ pending - first - update _ flag , and pushes the update to neighbors whose interest bits are set and to local client connections open at the node .    * case 2 : pending - first - update flag is clear . *",
    "if all the interest bits for _ k _ are clear , the node decides whether it wants to continue receiving updates for _ k_. the node bases its decision on _ k _ s popularity measure .",
    "each node uses its own policy for deciding whether the popularity of a key is high enough to warrant receiving further updates for it .",
    "if the node decides _ k _",
    "s popularity is too low , it pushes a _ clear - bit _ control message to the neighbor from whom it received the update .",
    "the _ clear - bit _ message indicates that the neighbor s interest bit for this node should be cleared .",
    "otherwise , if the popularity is high or some interest bits are set , the node applies the update to its cache and pushes the update to the neighbors whose bits are set .",
    "note that a greedy or selfish node can choose not to push updates for a key k to interested neighbors .",
    "this forces downstream nodes to fall back to standard caching for k. however , by choosing to cut off downstream propagation , a node runs the risk of receiving subsequent queries from its neighbors .",
    "handling each of these queries is twice the cost of propagating an update downward because the node has to receive the query from the downstream neighbor and then push the response as an update .",
    "therefore , although each node is free to stop pushing updates at any time it is in its best interest to push updates for which there are interested neighbors .",
    "* case 3 : incoming update has expired . * this could occur when the network path has long delays and the update does not arrive in time .",
    "the node does not apply the update and does not push it downstream .",
    "a _ clear - bit _ control message is pushed by a node to indicate to its neighbor that it is no longer interested in updates for a particular key from that neighbor .",
    "when a node receives a _ clear - bit _ message for key k , it clears the interest bit for the neighbor from which the message was sent .",
    "if the node s popularity measure for k is low and all of its interest bits are clear , the node also pushes a _ clear - bit _ message for k. this propagation of _ clear - bit _ messages toward the authority node for k continues until a node is reached where the popularity of k is high or where at least one interest bit is set .    _ clear - bit _ messages can be piggy - backed onto queries or updates intended for the neighbor , or if there are no pending queries or updates , they can be pushed separately .      ideally every node would propagate all updates to interested neighbors to save itself from having to handle future downstream misses .",
    "however , from time to time , nodes are likely to be limited in their capacity to push updates downstream .",
    "therefore , we introduce an adaptive control mechanism that a node uses to regulate the rate of pushed updates .",
    "we assume each node n has a capacity u for pushing updates that varies with n s workload , network bandwidth , and/or network connectivity .",
    "n divides u among its outgoing update channels such that each channel gets a share that is proportional to the length of its queue .",
    "this allocation maintains the queues roughly equally sized .",
    "the queues are guaranteed to be bounded by the expiration times of the entries in the queues .",
    "so even if a node has its update channels completely shut down for a long period , all entries will expire and be removed from the queues .    under a limited capacity and",
    "while updates are waiting in the queues , each node can re - order the updates in its outgoing update channels by pushing ahead updates that are likely to have greater impact on query latency reduction , on query accuracy , or on the load balancing of content demand across replicas . during the re - ordering any expired updates",
    "are eliminated .",
    "the strategy for re - ordering depends on the application .",
    "for example , in an application where query latency and accuracy are of the most importance , one can push updates in the following order : first - time updates , deletes , refreshes , and appends . in an application subject to flash crowds that query for a particular item",
    ", appends might be given higher priority over the other updates .",
    "this would help distribute the load faster across the entire set of replicas .",
    "a node can also re - order refreshes and appends so that entries that are closer to expiring are given higher priority .",
    "such entries are more likely to cause freshness misses which in turn trigger a new query search .",
    "so it is advantageous to try to catch this in time by pushing these first .",
    "the peer - to - peer model assumes that participating nodes will continuously join and leave the network .",
    "cup must be able to handle both node arrivals and departures seamlessly .",
    "* arrivals . *",
    "when a new node n enters the peer - to - peer network , it becomes the authority node for a portion of the index entries owned by an existing node m. n , m , and all surrounding affected nodes ( old neighbors of m ) update the bookkeeping structures they maintain for indexing and routing purposes . to support cup , the issues at hand are updating the interest bit vectors of the affected nodes and deciding",
    "what to do with the index entries stored at m.    depending on the indexing mechanism used , the cardinality of the bit vectors of the affected nodes may change .",
    "that is , bit vectors may expand or contract as some nodes may now have more or fewer neighbors than before n s arrival . since all nodes already need to track who their neighbors are as part of the routing mechanism , updating the cardinality of the interest bit vectors to reflect n s arrival is straightforward .",
    "for example , nodes that now have both n and m as neighbors have to increase their bit vectors by one element to include n. the affected nodes also need to modify the mappings from bit i d to neighbor ip address in their bit vectors . for example , if a node that previously had m as its neighbor now has n as its neighbor , the node must make the bit i d that pointed to m now point to n.    to deal with its stored index entries , m could simply not hand over any of its entries to n. this would cause entries at some of m s previous neighbors to expire and subsequent queries from those nodes will restart update propagations from n. alternatively , m could give a copy of its stored index entries to n. both n and m would then go through each entry and patch its bit vector . this way",
    "nodes that previously depended on m for updates of particular keys could continue to receive updates from either m or n but not both .",
    "* departures .",
    "* node departures can be either graceful ( planned ) or ungraceful ( due to sudden failure of a node ) . in either case",
    "the index mechanism in place dictates that a neighboring node m take over the departing node n s portion of the global index . to support cup ,",
    "the interest bit vectors of all affected nodes must be patched to reflect n s departure .",
    "if n leaves gracefully , n can choose not to hand over to m its index entries .",
    "any entries at surrounding nodes that were dependent on n to be updated will simply expire and subsequent queries will restart update propagations . again , alternatively n may give m its set of entries .",
    "m must then merge its own set of index entries with n s , by eliminating duplicate entries and patching the interest bit vectors as necessary .",
    "if n s departure is not planned , there can be no hand over of entries and all entries in the affected neighboring nodes will expire as in standard caching .    note that the transfer of entries can be coincided with the transfer of information that is already occurring as part of the routing mechanism in the peer - to - peer network , and therefore does not add extra network overhead .",
    "also the bit vector patching is a local operation that affects only each individual node .",
    "therefore even in cases where a node s neighborhood changes often , the effect on the overall performance of cup is limited to that node s neighborhood ( see section 3.7 ) .",
    "figure  [ fig : cuptrees ] shows a snapshot of cup in progress in a network of seven nodes .",
    "the left hand side of each node shows the set of keys for which the node is the authority .",
    "the right hand side shows the set of keys for which the node has cached index entries as a result of handling queries .",
    "for example , node a owns k3 and has cached entries for k1 and k5 .    for each key",
    ", the authority node that owns the key is the root of a cup tree .",
    "the branches of the cup tree are formed by the paths traveled by queries from other nodes in the network .",
    "for example , one path in the tree rooted at a is \\{f , d , c , a}.    updates originate at the root ( authority node ) of a cup tree and travel downstream to interested nodes .",
    "queries travel upstream toward the root .",
    "the goal of cup is to extend the benefits of standard caching based on expiration times .",
    "there are two key performance questions to address .",
    "first , by how much does cup reduce the average cost per query ?",
    "second , how much overhead does cup incur in providing this reduction ?",
    "we first present the cost model based on economic incentive used by each node to determine when to cut off the propagation of updates for a particular key .",
    "we give a simple analysis of how the cost per query is reduced ( or eliminated ) through cup .",
    "we then describe our experimental results comparing the performance of cup with that of standard caching .",
    "consider an authority node a that owns key k and consider the tree generated by issuing a query for k from every node in the peer - to - peer network .",
    "the resulting tree , rooted at a , is the _ virtual query spanning tree _ for k , v(a , k ) , and contains all possible query paths for k. the _ real query tree _ for k , r(a , k ) is a subtree of v(a , k ) also rooted at a and contains all paths generated by real queries . the exact structure of r(a , k ) depends on the actual workload of queries for k. the entire workload of queries for all keys results in a collection of criss - crossing real query trees with overlapping branches .",
    "we first consider the case of standard caching at the intermediate nodes along the query path for key k. consider a node n that is at distance d from a in v(a , k ) .",
    "we define the cost per query for k at n as the number of hops in the peer - to - peer network that must be traversed to return an answer to n. when a query for k is posted at n for the first time , it travels toward a looking for the response . if none of the nodes between n and a have a fresh response cached , the cost of the query at n is @xmath8 : d hops to reach a and d hops for the response to travel down the reverse query path as a first - time update .",
    "if there is a node on the query path with a fresh answer cached , the cost is less than @xmath9 .",
    "subsequent queries for k at n that occur within the lifetime of the entries now cached at",
    "n have a cost of zero . as a result , caching at intermediate nodes has the benefits of balancing query load for k across multiple nodes and lowering average latency per query .",
    "we can gauge the performance of cup by calculating the percentage of updates cup propagates that are `` justified '' .",
    "we precisely define what a justified update is below , but simply put , an update is justified if it recovers the overhead it incurs , i.e. , if its cost is recovered by a subsequent query .",
    "an unjustified update is therefore overhead that is not recovered ( wasted ) .",
    "updates for popular keys are likely to be justified more often than updates for less popular keys .",
    "a refresh update is justified if a query arrives sometime between the previous expiration of the cached entry and the new expiration time supplied by the refresh update .",
    "an append update is justified if at least one query arrives between the time the append is performed and the time of its expiration .",
    "a first - time update is always justified because it carries a query s response toward the node that originally issues the query .",
    "a deletion update is considered justified if at least one query arrives between the time the deletion is performed and the expiration time of the entry to be deleted .    for each update ,",
    "let @xmath10 be the critical time interval described above during which a query must arrive in order for the update to be justified .",
    "( for first - time updates @xmath11 ) .",
    "consider a node n at distance d from a in r(a , k ) .",
    "an update propagated down to n is justified if at least one query q is posted within @xmath10 time units at any of the nodes of the virtual subtree v(n , k ) .",
    "note that an update is justified if q arrives at the virtual tree v(n , k ) , _ not _ the real query tree r(n , k ) because q can be posted anywhere in v(n , k ) .    given the distribution of query arrivals at each node in the tree v(n , k ) , we can find the probability that the update at n is justified by calculating the probability that a query will arrive at some node in v(n , k ) .",
    "assume that queries for k arrive at each node @xmath12 in v(n , k ) according to a poisson process with parameter @xmath13 .",
    "then it follows that queries for k arrive at v(n , k ) according to a poisson process with parameter @xmath14 equal to the sum of all @xmath15 . therefore , the probability that a query for k will arrive within @xmath10 time units is @xmath16 and equals the probability that the update pushed to n is justified .",
    "the closer to the authority n is , the higher the @xmath14 and thus the higher the probability for an update pushed to n to be justified . for @xmath17 query arrival per second and",
    "@xmath18 seconds , the probability that an update arriving at n is justified is 99 percent .",
    "the benefit of a justified update goes beyond recovery of its cost . for each hop",
    "an update is pushed down , exactly one hop is saved since without the propagation , a subsequent query arriving within @xmath10 time units would have to travel one hop up and one hop down .",
    "this halves the number of hops traveled which reduces query response latency , and at the same time provides enough benefit margin for more aggressive cup strategies .",
    "for example , a more aggressive strategy would be to push some updates even if they are not justified .",
    "as long as the number of justified updates is at least fifty percent the total number of updates pushed , the overall update overhead is completely recovered .",
    "if the percentage of justified updates is less than fifty percent , then the overhead will not be fully recovered but query latency will be further reduced . therefore ,",
    "if network load is not the prime concern , an `` all - out '' push strategy achieves minimum latency .",
    "one of the challenges in evaluating this work is the unavailability of real data traces of completely decentralized peer - to - peer networks such as those assumed by cup .",
    "the reason for this is that such systems @xcite are not yet in widespread use to make collecting traces feasible .",
    "therefore , in the evaluation of cup we choose simulation parameters that range from unfavorable to favorable conditions for cup in order to show the spectrum of performance and how it compares to standard caching under the same conditions .",
    "for example , low query rates do not favor cup because updates are less likely to be justified since there may not be enough subsequent queries to recover the cost of the updates .",
    "on the other hand , queries for keys that become suddenly hot not only justify the propagation overhead , but also enjoy a significant reduction in latency .    for our experiments",
    ", we simulated a two - dimensional `` bare - bones '' content - addressable network ( can ) @xcite using the stanford narses simulator @xcite .",
    "the simulation takes as input the number of nodes in the overlay peer - to - peer network , the number of keys owned per node , the distribution of queries for keys , the distribution of query inter - arrival times , the number of replicas per key , and the lifetime of replicas in the system .",
    "we ran experiments for n = @xmath19 nodes where k ranged from 3 to 12 .",
    "simulation time was 22000 seconds , with 3000 seconds of querying time .",
    "we present results for experiments with replica lifetime of 300 seconds to reflect the dynamic nature of peer - to - peer networks where nodes might only serve content for short periods of time .",
    "for all experiments , refreshes of index entries occur at expiration .",
    "query arrivals were generated according to a poisson process .",
    "nodes were randomly selected to post the queries .",
    "we present five experiments .",
    "first we compare the performance and overhead of cup against standard caching where cup propagates updates without any concern for whether the updates are justified . in this experiment ,",
    "we vary the level in the cup tree to which updates are propagated .",
    "we use this experiment to establish the level that provides the maximum benefit and then use the performance results at this level as a benchmark for comparison in later experiments .",
    "second , we compare the effect on cup performance of different incentive - based cut - off policies and compare the performance of these policies to that of the benchmark .",
    "third , using the best cut - off policy of the previous experiment , we study how cup performs as we vary the size of the network .",
    "fourth , we study the effect on performance of increasing the number of replicas corresponding to a key .",
    "finally , we study the effect of limiting the outgoing update capacities of nodes .      in this set of experiments we compare standard caching with a version of cup that propagates updates down the real query tree of a key regardless of whether or not the updates are justified .",
    "we use this information to determine a maximal performance baseline .",
    "we determine the reduction in misses achieved by cup and the overhead cup incurs to achieve this reduction .",
    "we define _ miss cost _ as the total number of hops incurred by all misses , i.e. freshness and first - time misses .",
    "we define the cup overhead as the total number of hops traveled by all updates sent downstream plus the total number of hops traveled by all clear - bit messages upstream .",
    "( we assume clear - bit messages are not piggybacked onto updates .",
    "this somewhat inflates the overhead measure . )",
    "we define _ total cost _ as the sum of the _ miss cost _ and any overhead hops incurred .",
    "note that in standard caching , the _ total cost _ is equal to the _ miss cost_.    figures  [ fig : pushlevq1,10 ] and [ fig : pushlevq100,1000 ] plot cup s total cost and miss cost versus the push level for a network of @xmath20 nodes .",
    "a push level of @xmath21 means that updates are propagated to all nodes that have queried for the key and that are at most @xmath21 hops from the authority node .",
    "a push level of @xmath22 corresponds to the case of standard caching , since all updates from the authority node ( the root of the cup tree ) are immediately squelched and not forwarded on . for this set of experiments",
    ", query arrivals were generated according to a poisson process with average rate @xmath23 of 1 , 10 , 100 , and 1000 queries per second at the network .",
    "the figures show that as the push level increases , cup significantly reduces the miss cost when compared with standard caching and does so with little overhead as shown by the displacement of each pair of curves .    in figure",
    "[ fig : pushlevq1,10 ] , for @xmath24 query per second , the total cost incurred by cup decreases and reaches a minimum at around push level 20 , after which it slightly increases .",
    "this turning point is the level beyond which the overhead cost of updates is not recoverable . for @xmath25 queries per second ,",
    "a similar turning point occurs at around push level 25 . in figure",
    "[ fig : pushlevq100,1000 ] the minimum total cost occurs at push level 25 and tapers off for both @xmath26 and @xmath27 queries per second . for low query arrival rates ,",
    "the turning point occurs at lower push levels .",
    "for example , for @xmath28 queries per second , the turning point occurs at push level 15 .",
    "these results show that there is no specific optimal push level at which cup achieves the minimum total cost across all workloads .",
    "if there were , then the simplest strategy for cup would be to have updates be propagated to that optimal push level .",
    "in fact , we have found that in addition to the query workload , the optimal push level is affected by the number of nodes in the network and the rate at which updates are generated , both of which change dynamically .    in the absence of an optimal push level , each node needs a policy for determining when to stop receiving updates .",
    "we next examine some cut - off policies .              on receiving an update for a key , each node determines whether or not there is incentive to continue receiving updates or to cut off updates by pushing up a clear - bit message .",
    "we base the incentive on the _ popularity _ of the key at the node .",
    "the more popular a key is , the more incentive there is to receive updates for that key . for a key k ,",
    "the popularity is the number of queries a node has received for k since the last update for k arrived at the node .",
    "we examine two types of thresholds against which to test a key s popularity when making the cut - off decision : probability - based and log - based .",
    "a probability - based threshold uses the distance of a node n from the authority node a to approximate the probability that an update pushed to n is justified . per our cost model of section 3.2 ,",
    "the further n is from a , the less likely an update at n will be justified .",
    "we examine two such thresholds , a linear one and a logarithmic one . with a linear threshold ,",
    "if an update for key k arrives at a node at distance @xmath29 and the node has received at least @xmath30 queries for k since the last update , then k is considered popular and the node continues to receive updates for k. otherwise , the node cuts off its intake of updates for k by pushing up a clear - bit message .",
    "the logarithmic popularity threshold is similar .",
    "a key k is popular if the node has received @xmath31 queries since the last update .",
    "the logarithmic threshold is more lenient than the linear in that it increases at a slower rate as we move away from the root .",
    "a log - based threshold is one that is based on the recent history of the last _ n _ update arrivals at the node . if within _",
    "n _ updates , the node has not received any queries , then the key is not popular and the node pushes up a clear - bit message .",
    "a specific example of a log - based policy is the second - chance policy . in this policy , @xmath32 .",
    "when an update arrives , if no queries have arrived since the last update , the policy gives the key a `` second chance '' and does not push a clear - bit message immediately . if at the next update arrival the node has still not received any queries for k , then it pushes a clear - bit message .",
    "the philosophy behind this policy is that pushing these two updates down from the parent node costs two hops .",
    "if a query arrives in the interval between these two updates , then it will recover the cost of pushing them down , since a query miss would incur two hops , one up and one down .",
    "[ cols= \" < , > , > , > , > \" , ]     the last column of table  [ tab : replicas ] shows the total cost when each replica refresh is sent as a separate update . when compared to the 55905 hops of total cost for standard caching from table  [ tab : policies2 ] , we observe that the total cost of cup will eventually overtake that of standard caching as we increase the number of replicas .",
    "in fact this occurs at eight replicas where the total cost is 57430 . while these results may seem to imply that a handful of replicas is enough for good cup performance , for some applications , having many more replicas in the network is necessary even if they run the risk of unrecoverable additional cup overhead .",
    "for example , having multiple replicas of content helps to balance the demand for that content across many nodes and reduces latency .",
    "one may view pushing updates for multiple replicas as an example of an aggressive cup policy we refer to in section  [ costmodel ] . at 100 replicas ,",
    "the total cost is about 10 times that of standard caching .",
    "cup pays the price of extra overhead but achieves a miss cost that is about 13.5 percent that of standard caching .",
    "therefore , at the cost of extra network load , both query latency is reduced and the demand for content is balanced across a greater number of nodes .",
    "if however network load is a concern , there are a couple of techniques an authority node can use to reduce the overhead of cup when there are many replicas in the network .",
    "first , rather than push all replica refreshes , the authority node can selectively choose to propagate a subset of the replica refreshes and suppress others .",
    "this allows the authority node to reduce update overhead as well as balance demand for content across the replicas .",
    "another alternative would be to aggregate replica refreshes .",
    "when a refresh arrives for one replica , the authority node waits a threshold amount of time for other updates for the same key to arrive .",
    "it then batches all updates that arrive within that time and propagates them together as one update .",
    "this threshold would be a function of the lifetime of a replica and could be dynamically adjusted with the number of replicas in the system .",
    "we are experimenting with different kinds of threshold functions .",
    "our experiments thus far show that cup clearly outperforms standard caching under conditions where all nodes have full outgoing capacity .",
    "a node with full outgoing capacity is a node that can and does propagate all updates for which there are interested neighbors . in reality ,",
    "an individual node s outgoing capacity will vary with its workload , network connectivity , and willingness to propagate updates . in this section",
    "we study the effect on cup performance of reducing the outgoing update capacity of nodes .",
    "we present two experiments run on a network of 1024 nodes . in the first experiment , called `` up - and - down '' , after a five minute warm up period , we randomly select twenty percent of the nodes to reduce their capacity to a fraction of their full capacity .",
    "these nodes operate at reduced capacity for ten minutes after which they return to full capacity .",
    "after another five minutes for stabilization , we randomly select another set of nodes and reduce their capacity for ten minutes .",
    "we proceed this way for the entire 3000 seconds during which queries are posted , so capacity loss occurs three times during the simulation . in the second experiment , called `` once - down - always - down '' , after the initial five minute warmup period ,",
    "the randomly selected nodes reduce and remain at reduced capacity for the remainder of the experiment .    figure  [ fig : capacityq1 ] shows the total cost incurred by cup versus reduced capacity @xmath33 for both up - and - down and once - down - always - down configurations .",
    "a reduced capacity @xmath34 means a node is only pushing out one - fourth the updates it receives .",
    "the figure also shows the total cost for standard caching as a horizontal line for comparison .",
    "the @xmath23 rate is 1 query per second .",
    "figure [ fig : capacityq1000 ] shows the same for @xmath23= 1000 which is especially interesting because cup has bigger wins with higher query rates since more updates are justified than with lower query rates . therefore , with high query rates cup has more to lose if updates do not get propagated .    note that even when the capacity of one fifth of the nodes is reduced to zero percent and these nodes do not propagate updates , cup outperforms standard caching for both query rates .",
    "the total cost incurred by cup is about half that of standard caching for one query per second for both configurations . for 1000 queries per second ,",
    "the total cost of cup is 0.56 and 0.77 that of standard caching for `` up - and - down '' and `` once - down - always - down '' respectively .",
    "a key observation from these experiments is that cup s performance degrades gracefully as @xmath33 decreases .",
    "this is because the reduction in propagation saves any overhead that would have occurred otherwise .",
    "the important point here is that even if nodes can only push out a fraction of updates to interested neighbors , cup still extends the benefits of standard caching . clearly though , cup achieves its full potential when all nodes have maximum propagation capacity .",
    "some peer - to - peer systems suffer from what we call the `` open - connection '' problem . every time a peer node receives a query for which it does not have an answer cached",
    ", it asks one ( e.g. , freenet @xcite ) or more ( e.g. , gnutella @xcite ) neighbors the same query by opening a connection and forwarding the query through that connection .",
    "the node keeps the connection open until the answer is returned through it . for every query on every item for which the node does not have a cached answer",
    ", the connection is maintained until the answer comes back .",
    "this results in excessive overhead for the node because it must maintain the state of many open connections . cup avoids this overhead by asynchronously pushing responses as first - time updates and by coalescing queries for the same item into one query .",
    "chord @xcite and cfs @xcite suggest alternatives to making the query response travel down the reverse query path back to the query issuer .",
    "chord suggests iterative searches where the query issuer contacts each node on the query path one - by - one for the item of interest until one of the nodes is found to have the item .",
    "cfs suggests that the query be forwarded from node to node until a node is found to have the item .",
    "this node then directly sends the query response back to the issuer .",
    "both of these approaches help avoid some of the long latencies that may occur as the query response traverses the reverse query path .",
    "cup is advantageous regardless of whether the response is delivered directly to the issuer or through the reverse query path .",
    "however , to make this work for direct response delivery , cup must not coalesce queries for the same item at a node into one query since each query would need to explicitly carry the return address information of the query issuer .    all of the above systems ( gnutella , freenet , chord , and cfs ) enable caching at the nodes along the query path .",
    "they do not focus on how to maintain entries once they have been cached .",
    "cached items are removed when they expire and refetched on subsequent queries .",
    "for very popular items this can lead to higher average response time since subsequent bursts of queries must wait for the response to travel up and ( possibly ) down the query path .",
    "cup can avoid this problem by refreshing or updating cached items for which there is interest before they expire .",
    "consistent hashing work by karger et al .",
    "@xcite looks at relieving hot spots at origin web servers by caching at intermediate caches between client caches and origin servers .",
    "requests for items originate at the leaf clients of a conceptual tree and travel up through intermediate caches toward the origin server at the root of the tree .",
    "this work uses a model slightly different from the peer - to - peer model .",
    "their model and analysis assume requests are made only at leaf clients and that intermediate caches do not store an item until it has been requested some threshold number of times .",
    "also , this work does not focus on maintaining cache freshness .",
    "update propagations in cup form trees very similar to the application - level multicast trees built by scribe @xcite .",
    "scribe is a publish - subscribe infrastructure built on top of pastry @xcite .",
    "scribe creates a multicast tree rooted at the rendez - vous point of each multicast group .",
    "publishers send a message to the rendez - vous point which then transmits the message to the entire group by sending it down the multicast tree .",
    "the multicast tree is formed by joining the pastry routes from each subscriber node to the rendez - vous point .",
    "scribe could apply the ideas cup introduces to provide update propagation for cache maintenance in pastry .",
    "cohen and kaplan study the effect that aging through cascaded caches has on the miss rates of web client caches @xcite . for each object",
    "an intermediate cache refreshes its copy of the object when its age exceeds a fraction _ v _ of the lifetime duration .",
    "the intermediate cache does not push this refresh to the client ; instead , the client waits until its own copy has expired at which point it fetches the intermediate cache s copy with the remaining lifetime .",
    "for some sequences of requests at the client cache and some _ v _",
    "s , the client cache can suffer from a higher miss rate than if the intermediate cache only refreshed on expiration .",
    "their model assumes zero communication delay .",
    "a cup tree could be viewed as a series of cascaded caches in that each node depends on the previous node in the tree for updates to an index entry .",
    "the key difference is that in cup , refreshes are pushed down the entire tree of interested nodes .",
    "therefore , barring communication delays , whenever a parent cache gets a refresh so does the interested child node . in such situations ,",
    "the miss rate at the child node actually improves .",
    "in this paper we propose cup : controlled update propagation for cache maintenance .",
    "cup query channels coalesce bursts of queries for the same item into a single query .",
    "cup update channels refresh intermediate caches and reduce the average query latency by over a factor of ten in favorable conditions , and as much as a factor of three in unfavorable conditions . through light book - keeping , cup controls and confines propagations so that only updates that are likely to be justified are propagated .",
    "in fact , when only half the number of updates propagated are justified , cup s overhead is completely recovered .",
    "finally , even when a large percentage of nodes can not propagate updates ( due to limited capacity ) , cup continues to outperform standard caching with expiration .",
    "this research is supported by the stanford networking reseach center , and by darpa ( contract n66001 - 00-c-8015 ) ."
  ],
  "abstract_text": [
    "<S> recently the problem of indexing and locating content in peer - to - peer networks has received much attention . </S>",
    "<S> previous work suggests caching index entries at intermediate nodes that lie on the paths taken by search queries , but until now there has been little focus on how to maintain these intermediate caches . </S>",
    "<S> this paper proposes cup , a new comprehensive architecture for controlled update propagation in peer - to - peer networks . </S>",
    "<S> cup asynchronously builds caches of index entries while answering search queries . </S>",
    "<S> it then propagates updates of index entries to maintain these caches . under unfavorable conditions , when compared with standard caching based on expiration times </S>",
    "<S> , cup reduces the average miss latency by as much as a factor of three . under favorable conditions </S>",
    "<S> , cup can reduce the average miss latency by more than a factor of ten .    </S>",
    "<S> cup refreshes intermediate caches , reduces query latency , and reduces network load by coalescing bursts of queries for the same item . </S>",
    "<S> cup controls and confines propagation to updates whose cost is likely to be recovered by subsequent queries . </S>",
    "<S> cup gives peer - to - peer nodes the flexibility to use their own incentive - based policies to determine when to receive and when to propagate updates . </S>",
    "<S> finally , the small propagation overhead incurred by cup is more than compensated for by its savings in cache misses . </S>"
  ]
}