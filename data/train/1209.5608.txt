{
  "article_text": [
    "the dynamic graph connectivity problem is perhaps the most fundamental dynamic graph problem and has received considerable attention from the algorithms community for decades .",
    "the goal is to build an efficient data structure that supports one or more of the following operations in a dynamic graph @xmath5 :    * ` connected`@xmath6 : determines whether vertices @xmath7 and @xmath8 are connected in @xmath5 , * ` insert`@xmath6 : inserts edge @xmath6 in @xmath5 , * ` delete`@xmath6 : deletes edge @xmath6 from @xmath5 .",
    "the fully - dynamic graph connectivity problem supports all three operations , whereas the simpler decremental and incremental variants do not support ` insert ` and ` delete ` , respectively . in the following ,",
    "we refer to both ` insert ` and ` delete ` as update operations .",
    "the first non - trivial data structure for fully - dynamic graph connectivity is due to frederickson  @xcite who showed how to support updates in @xmath9 time and connectivity queries in @xmath10 time , where @xmath11 is the number of edges of the graph . using a general sparsification technique , eppstein , galil , italiano , and nissenzweig  @xcite improved update time to @xmath12 , where @xmath2 is the number of vertices . both of these data structures are deterministic and the time bounds are worst - case .",
    "henzinger and king  @xcite significantly improved update time to @xmath13 with only a small increase in query time to @xmath1 .",
    "however , their bounds are randomized expected and update time is amortized . using a clever sampling technique ,",
    "henzinger and thorup  @xcite shaved off a factor of @xmath14 in the update time .",
    "a simple and elegant deterministic data structure with the same bounds as in  @xcite was given by holm , de lichtenberg , and thorup  @xcite .",
    "its space requirement was later improved to linear by thorup  @xcite who also gave a randomized data structure with a faster update time of @xmath15 and marginally slower query time of @xmath16 .",
    "a general cell - prove lower bound of @xmath17 for fully - dynamic graph connectivity was provided by ptracu and demaine  @xcite .",
    "hence , the data structures above are near - optimal .",
    "as shown by tarjan  @xcite , incremental connectivity is the union - find problem which can be solved in @xmath18 time over @xmath11 updates .",
    "thorup  @xcite gave an @xmath19 bound for decremental connectivity if the initial graph has @xmath20 edges .",
    "he also gave an @xmath10 bound if the initial graph is dense .",
    "our contribution is a deterministic data structure that improves the update time of the deterministic data structures in  @xcite by a factor of @xmath21 .",
    "we use several ingredients of thorup  @xcite , including his structural forest ( which we refer to as a cluster forest ) as well as lazy local trees and shortcuts both of which we modify to suit our needs .",
    "we also introduce an additional system of shortcuts that allows us to more quickly walk up trees of the cluster forest .",
    "together , these changes and additions give an order @xmath21 speed - up in the update time .",
    "table  [ tab : datastructs ] summarizes the results for fully - dynamic graph connectivity .",
    "[ cols=\"^,^,^,^\",options=\"header \" , ]     our paper is organized as follows . in section  [ sec : defsnot ] , we introduce basic definitions and notation .",
    "section  [ sec : simpledatastruct ] gives a simple data structure with @xmath3 update time and @xmath19 query time .",
    "it is essentially the deterministic data structure of thorup  @xcite but a slightly more minimalistic variant that does not need to maintain spanning trees of connected components . in section  [ sec : improveddatastruct ] , we add two systems of shortcuts to our data structure that together improve both update and query time by a factor of @xmath21 . the simplification given in section  [ sec : simpledatastruct ] is not important in order to get our improvement in section  [ sec :",
    "improveddatastruct ] ; indeed , our result can easily be extended to maintain a spanning forest .",
    "however , we believe that our approach gives a slightly cleaner analysis and it should give a small improvement in practice .",
    "for instance , thorup s data structure needs to maintain two types of bitmaps for edges , one for tree edges and one for non - tree edges whereas our data structure only needs to maintain one type ; see section  [ subsec : searchingedges ] for details .",
    "finally , we give some concluding remarks in section  [ sec : conclrem ] .",
    "let @xmath22 denote the base @xmath23 logarithm .",
    "we assume the same model of computation as in  @xcite , i.e. , a pointer machine with words ( bitmaps ) containing at least @xmath24 bits and with the following standard @xmath4 instructions : addition , subtraction , bitwise and , or , and not , and bit shifts .",
    "our data structure also needs to perform division @xmath25 and multiplication @xmath26 which are _ not _ @xmath4 instructions . to handle this",
    ", we assume that @xmath27 is a power of @xmath23 so that a bit shift operation can be used instead ; we can always round @xmath27 to the nearest such value and the constant multiplicative error introduced will not affect correctness or running time . for a bitmap @xmath11 ,",
    "we denote by @xmath28 $ ] the @xmath29th bit of @xmath11 , @xmath30 .",
    "we let @xmath5 denote the input graph and it is assumed to contain no edges initially . to distinguish between vertices of @xmath5 and other vertices ( such as those in trees of our data structure ) , we refer to the latter as nodes . for a path @xmath31 and nodes @xmath32 , @xmath33 $ ] is the subpath of @xmath31 between @xmath34 and @xmath35 . we abbreviate balanced binary search tree as bbst and depth - first search as dfs",
    "we first give a simplified version of our data structure which is no better than the deterministic data structures in  @xcite and  @xcite .",
    "in fact , it has a slower query time of @xmath19 . in section  [ sec : improveddatastruct ]",
    ", we shall speed up both query and update time by a factor of @xmath21 .",
    "as in  @xcite , we assign to each edge @xmath36 of @xmath5 a _ level _",
    "@xmath37 between @xmath38 and @xmath39 and for @xmath40 , we denote by @xmath41 the subgraph of @xmath5 induced by edges @xmath36 with @xmath42 .",
    "we refer to the connected components of @xmath41 as _ level @xmath29 clusters _ or just _",
    "clusters_. the following invariant will be maintained by our data structure :    invariant : : :    for each @xmath29 , any level @xmath29 cluster spans at    most @xmath43 vertices .",
    "the _ cluster forest _ of @xmath5 is a forest @xmath44 of rooted trees where each node @xmath7 corresponds to a cluster @xmath45 .",
    "the _ level _",
    "@xmath46 of @xmath7 is its depth in @xmath44 ( between @xmath38 and @xmath47 ) and a level @xmath29 node corresponds to a level @xmath29 cluster . in particular , roots of @xmath44",
    "correspond to level @xmath38 clusters and hence to the connected components of @xmath48 . by the invariant",
    ", each leaf of @xmath44 corresponds to a vertex of @xmath5 ; we often identify the two and our data structure keeps bidirected pointers between them .",
    "a node @xmath7 at a level @xmath49 has as children the level @xmath50 nodes @xmath8 such that @xmath51 .",
    "our data structure will maintain , for each node @xmath7 of @xmath44 , an integer @xmath52 denoting the number of leaves in the subtree of @xmath44 rooted at @xmath7 .",
    "in other words , @xmath52 is the number of vertices of @xmath5 spanned by @xmath45 .",
    "this completes the description of the cluster forest .",
    "given @xmath44 , we can determine whether two vertices @xmath7 and @xmath8 are connected in @xmath5 in @xmath19 time as follows . traverse paths from @xmath7 and @xmath8 to roots @xmath53 and @xmath54 of trees of @xmath44 containing @xmath7 and @xmath8 , respectively .",
    "then @xmath7 and @xmath8 are connected iff @xmath55 .",
    "we need to maintain @xmath44 as @xmath5 changes .",
    "first we describe how to update @xmath44 after an operation ` insert`@xmath6 .",
    "we initialize @xmath56 . letting @xmath53 and",
    "@xmath54 be defined as above , if @xmath55 , no update of @xmath44 is required since @xmath7 and @xmath8 were already connected in @xmath57 .",
    "if @xmath58 , we update @xmath44 by _ merging @xmath53 and @xmath54 into @xmath53 _ , meaning that @xmath53 inherits the children of @xmath54 , @xmath59 is increased by @xmath60 , and @xmath54 is deleted .",
    "this update corresponds to merging @xmath61 and @xmath62 .",
    "thus @xmath44 is correctly updated and the invariant still holds .",
    "now consider the update ` delete`@xmath6 .",
    "let @xmath63 and let @xmath64 and @xmath65 be the level @xmath50 clusters containing @xmath7 and @xmath8 , respectively .",
    "assume that @xmath66 since otherwise , the connectivity in @xmath41 is not affected ( there is a @xmath67-path in @xmath68 connecting @xmath7 and @xmath8 ) .",
    "let @xmath69 be the multigraph with level @xmath50 clusters as vertices and with level @xmath29-edges of @xmath5 as edges ( so an edge of @xmath69 connects two vertices if that edge connects the corresponding level @xmath50 clusters in @xmath41 ) .",
    "our algorithm will not actually keep @xmath69 but it will help to simplify the description in this subsection .",
    "we now execute two standard search procedures ( say , dfs ) in @xmath69 , one , @xmath70 , starting from vertex @xmath64 and another , @xmath71 , starting from @xmath65 .",
    "the two procedures are executed in `` parallel '' by alternating between the two , i.e. , one unit of time is spent on @xmath70 , then one unit on @xmath71 , then one unit on @xmath70 , and so on .",
    "we terminate both procedures as soon as we are in one of the following two cases ( which must happen at some point ) :    1 .",
    "a vertex of @xmath69 is explored by both procedures , 2 .",
    "one of the procedures has no more edges to explore and we are not in case @xmath72 .    in the following ,",
    "we show how to deal with these two cases .",
    "[ [ case-1 ] ] case @xmath72 : + + + + + + + + + + + + + + + + + + + + +    let @xmath73 be the vertex ( level @xmath50 cluster ) of @xmath69 explored by both procedures .",
    "assume w.l.o.g .",
    "that @xmath71 was the last to explore @xmath73 .",
    "let @xmath74 be the set of level @xmath50 clusters explored by @xmath70 and let @xmath75 be the set of level @xmath50 clusters explored by @xmath71 , excluding @xmath73 .",
    "if we let @xmath76 and @xmath77 then since @xmath78 , we have @xmath79 by our invariant and thus @xmath80 .",
    "assume first that @xmath81 .",
    "then we can increase the level of every edge explored by @xmath70 from @xmath29 to @xmath82 without violating the invariant . to see this , note that the level updates correspond to merging clusters of @xmath74 into one level @xmath50 cluster spanning @xmath83 vertices .",
    "the idea is that the search performed by @xmath70 is paid for by these level increases . as @xmath71 spent the same amount of time as @xmath70 ( up to an additive @xmath10 term )",
    ", the level increases also pay for the search by @xmath71 .",
    "we need to update cluster forest @xmath44 accordingly . when increasing the level of an edge @xmath36 from @xmath29 to @xmath82 , we identify the level @xmath50-ancestors @xmath34 and @xmath35 of the endpoints of @xmath36",
    ". clusters @xmath84 and @xmath85 need to be merged and we do this by merging @xmath34 and @xmath35 into @xmath35 and updating @xmath86 . as we will see later , this update can also be paid for by the level increase of @xmath36 .",
    "note that the procedures have found a replacement path in @xmath41 for deleted edge @xmath6 so no further updates are required in @xmath44 , and we terminate .",
    "we assumed above that @xmath81 .",
    "we do exactly the same for clusters in @xmath75 when @xmath87 except that we do not increase the level of the last edge explored by @xmath71 as it connects to a cluster in @xmath74 .",
    "if this was the only edge explored , there are no edges to pay for it but in this case we have found a replacement path for edge @xmath6 and the ` delete`@xmath6-operation can pay .",
    "[ [ case-2 ] ] case @xmath23 : + + + + + + + + + + + + + + + + + + + + +    now assume that one of the procedures , say @xmath70 , explores all edges in the connected component of @xmath69 containing @xmath64 and that we are not in case @xmath72 .",
    "let us assume that @xmath83 ; if not , we fully explore the connected component of @xmath69 containing @xmath65 and update @xmath88 which will be at most @xmath89 by our invariant ; the description below then applies if we swap the roles of @xmath7 and @xmath8 .",
    "we can conclude that no replacement path for @xmath6 exists in @xmath41 .",
    "all edges explored by @xmath70 have their level increased to @xmath82 and we update @xmath44 accordingly by merging all level @xmath50 nodes explored by @xmath70 into one , @xmath90 , and setting @xmath91 to the sum of @xmath92 for nodes @xmath93 explored by @xmath70 .",
    "these level increases pay for the two searches .",
    "since @xmath64 and the component of @xmath69 containing @xmath65 are no longer connected in @xmath41 , we further update @xmath44 as follows : let @xmath94 be the parent of @xmath90 in @xmath44 .",
    "we remove @xmath90 as a child of @xmath94 , decrease @xmath95 by @xmath91 , add @xmath90 as a child of a new level @xmath29 node @xmath96 , set @xmath97 , and add @xmath96 as a child of the parent of @xmath94 .",
    "this correctly updates @xmath44 and the invariant is maintained .",
    "if @xmath98 , it may still be possible to reconnect @xmath7 and @xmath8 in @xmath99 for some @xmath100 .",
    "we thus execute the above algorithm recursively with @xmath101 , @xmath102 , and @xmath103 .",
    "should we end up in case @xmath23 with @xmath104 , no replacement path in @xmath5 between @xmath7 and @xmath8 could be found .",
    "then @xmath96 becomes a new root of @xmath44 and we terminate .",
    "we now extend our data structure to allow the search procedures to explore edges and vertices of multigraph @xmath69 in a more efficient way .",
    "first we shall convert @xmath44 into a forest of binary trees by adding _ local trees _ as in  @xcite .",
    "let @xmath7 be a non - leaf node of @xmath44 .",
    "we form a binary tree @xmath105 with @xmath7 as root and with the children of @xmath7 as leaves as follows .",
    "first assign a _",
    "@xmath106 to each child @xmath8 of @xmath7 .",
    "initially , each such @xmath8 is regarded as a tree consisting just of @xmath8 . while there are trees @xmath107 and @xmath108 whose roots @xmath109 and @xmath110 have the same rank , we pair them by attaching @xmath109 and @xmath110 to a new root @xmath111 with @xmath112 .",
    "we end up with at most @xmath14 trees @xmath113 , called _ rank trees _ , whose roots @xmath114 have pairwise distinct ranks : @xmath115 .",
    "we connect the rank trees into a single _ local tree _",
    "@xmath105 rooted at @xmath7 by adding a _ rank path _",
    "@xmath116 down from @xmath117 and connecting @xmath118 as a child to @xmath119 for @xmath120 and @xmath121 as a child to @xmath122 .",
    "we define @xmath123 .",
    "the edges in @xmath44 from @xmath7 to its children are replaced by local tree @xmath105 ; let @xmath124 be @xmath44 after all local trees have been added . as shown by thorup , for a child @xmath8 of a node @xmath7 in @xmath44 ,",
    "the depth of @xmath8 in @xmath105 is at most @xmath125 .",
    "since any leaf of @xmath44 has depth at most @xmath39 , a telescoping sums argument implies that any leaf of @xmath124 has depth @xmath19 .",
    "refer to nodes of @xmath124 that are also nodes of @xmath44 as _ @xmath44-nodes_. our data structure will maintain @xmath124 as well as @xmath52 for each @xmath44-node @xmath7 and @xmath126 for each node @xmath127 .",
    "we shall use @xmath124 to search for edges in @xmath69 . to facilitate this",
    ", we associate a bitmap @xmath128 with each node @xmath7 of @xmath124 where @xmath129 = 1 $ ] iff a level @xmath29-edge is incident to a leaf of the subtree of @xmath124 rooted at @xmath7 .",
    "can be regarded as the bitwise or of his two bitmaps . ]",
    "we can use these bitmaps to search for the edges of @xmath69 .",
    "consider one of the search procedures , say @xmath70 , described above . at any point in the search , a set of vertices of @xmath69",
    "have been explored and these correspond to level @xmath50 nodes in @xmath124 that we mark as explored . with the bitmaps ,",
    "we identify unexplored descendant leaves of marked nodes in @xmath124 that are incident to level @xmath29-edges and hence to edges of @xmath69 that should be explored by @xmath70 . at each leaf",
    ", we have all incident edges grouped according to their level .",
    "a bbst is kept which allows us to get down to a particular group in @xmath130 time . when a level @xmath29-edge @xmath131 is explored in the direction from @xmath34 to @xmath35 ,",
    "we determine the endpoint in @xmath69 corresponding to @xmath35 by moving up from leaf @xmath35 to the ancestor level @xmath50 node in @xmath124 .",
    "finally , we mark this level @xmath50 node as explored .",
    "since @xmath124 has @xmath19 height , we can execute @xmath70 in @xmath19 time per edge explored .",
    "we now describe how to maintain @xmath124 as @xmath44 is updated .",
    "let us consider the update in @xmath44 of merging nodes @xmath7 and @xmath8 into @xmath7 . in @xmath124 ,",
    "this is done by first removing the rank paths in @xmath105 and @xmath132 , leaving at most @xmath14 rank trees of distinct ranks for each of the nodes @xmath7 and @xmath8 .",
    "we may assume that rank trees are kept in two lists sorted by the ranks of their roots and we merge the two lists into one and start pairing up trees whose roots have the same rank , in the same way as above .",
    "we connect their roots with a new rank path , thereby creating the new @xmath105 and we identify its root with @xmath7 .",
    "total time for a merge is @xmath19 .",
    "we also need to update @xmath124 when a child @xmath35 in @xmath44 is added to or removed from a node @xmath34 ( we need this when failing to find a replacement path at some level ) .",
    "if @xmath35 is to be added , we can regard it as a trivial rank tree that should be added to @xmath133 .",
    "this can be done in @xmath19 time using the same approach as for merging .",
    "if @xmath35 is to be removed , we first remove the rank path of @xmath133 and identify the rank tree @xmath134 containing @xmath35 .",
    "we delete the path from @xmath35 to the root of @xmath134 , thereby partitioning this rank tree into @xmath19 smaller rank trees , sorted by ranks .",
    "we pair up rank trees as described above and add a new rank path to form the updated @xmath133 .",
    "all of this can be done in @xmath19 time .",
    "finally , we need to update integers @xmath52 for @xmath44-nodes @xmath7 as well as the @xmath135-bitmaps .",
    "the former is done exactly as in sections  [ subsec : insertion ] and  [ subsec : deletion ] so let us focus on the bitmaps .",
    "if a level @xmath29-edge @xmath36 is removed , we do the following for each of its endpoints @xmath34 . in the leaf @xmath34 of @xmath124",
    ", we check in @xmath136 time if @xmath36 was the only level @xmath29-edge incident to @xmath34 .",
    "if so , we set @xmath137\\leftarrow 0 $ ] and we move up @xmath124 , updating the bitmap of the current node as the bitwise or of its children .",
    "since @xmath124 has @xmath19 height , only @xmath19 bitmaps need to be updated .",
    "similarly , if @xmath36 is added , we set @xmath137\\leftarrow 1 $ ] and update bitmaps for ancestors in the same way . for nodes of @xmath124 whose children change , we also update their bitmaps bottom up by taking the bitwise or of their children .",
    "only @xmath19 nodes are affected in @xmath124 after an update in @xmath44 so total time is @xmath19 .",
    "this completes the description of the first version of our data structure .",
    "correctness follows since the data structure is a simple variation of that of thorup where spanning trees of clusters are not kept ; rather , our search procedures certify that a spanning tree exists for an explored component and this suffices to maintain the cluster forest . from the analysis above",
    ", our data structure handles updates in @xmath3 amortized time and queries in @xmath19 time . in the next section ,",
    "we speed up both bounds by a factor of @xmath21 .",
    "in this section , we give our improved data structure . before going into details ,",
    "let us highlight the main differences between this structure and that of the previous section .",
    "one ingredient is to add shortcuts to @xmath124 .",
    "each shortcut skips @xmath136 nodes and this will allow our search procedures to walk up trees of @xmath124 in @xmath1 time per traversal when identifying visited nodes of a multigraph @xmath69 . adding these shortcuts essentially corresponds to turning the forest @xmath124 of binary trees into one consisting of trees with a branching factor of order @xmath14 , and reducing the height of the trees to order @xmath138 .",
    "furthermore , we will modify @xmath124 by using _",
    "lazy _ local trees similar to those of thorup  @xcite instead of the local trees presented in the previous section .",
    "this is done to maintain @xmath124 more efficiently during changes .",
    "unfortunately , thorup s lazy local trees increase the height of @xmath124 to @xmath139 so our shortcuts will not give any speed - up over the data structure in the previous section .",
    "instead , we shall use a slightly more complicated type of lazy local tree which has the properties we need while keeping the height of @xmath124 bounded by @xmath19 .",
    "the idea is to partition the children of each node of @xmath44 into so called heavy children and light children and construct the lazy local tree only for the light children and the local tree of the previous section for the heavy children .",
    "balancing this in the right way will ensure a logarithmic depth of trees while still getting the speed - up from lazy local trees .",
    "finally , we will need another system of shortcuts for quickly identifying edges to be explored by the search procedures ; thorup uses a similar system but it does not fit into our framework as our lazy local trees are different from his . as shown in lemma",
    "[ lem : iterator ] in section  [ subsec : iterator ] , with these shortcuts , the search procedures can visit edges in only @xmath1 time per edge plus an additive @xmath19 if we are in case @xmath72 in section  [ subsec : deletion ] ; note that the latter can be paid for by the ` delete ` operation since a replacement path for the deleted edge has been found . in section  [ subsec :",
    "indshortcuts ] , we define these shortcuts and in section  [ subsec : iterator ] , we give an algorithm that uses these shortcuts to explore level @xmath29-edges ; we refer to it as a _ level @xmath29-iterator _ or just _",
    "iterator_.      thorup  @xcite introduced lazy local trees and showed how they can be maintained more efficiently than the local trees in section  [ subsec : localtrees ] .",
    "let @xmath7 be a non - leaf node of @xmath44 and let @xmath140 be the set of children of @xmath7 .",
    "to form the lazy local tree of @xmath7 , @xmath140 is divided into groups each of size at most @xmath141 , where @xmath142 is a constant that we may pick as large as we like . the nodes in each group are kept in a bbst ordered by @xmath143-values .",
    "one of these trees is the _ buffer tree _ while the others are the _ bottom trees_. the root of a bottom tree has rank equal to the maximum rank of its leaves .",
    "these bottom trees are paired up to form at most @xmath14 rank trees , as described in section  [ subsec : localtrees ] .",
    "the roots of the rank trees together with the root of the buffer tree are leaves of a bbst called the _ top tree _ where leaves are ordered according to rank ( and the root of the buffer tree is regarded as , say , the smallest element ) .",
    "together , these trees form the lazy local tree of @xmath7 which is rooted at the root of the top tree .",
    "note that bottom , buffer , and top trees have polylogarithmic size only .",
    "it is ensured by the data structure of thorup that for each bottom tree @xmath144 , new leaves are never added to @xmath144 and ranks of leaves in @xmath144 are not changed .",
    "this will also hold for our data structure .",
    "we shall use these lazy local trees to improve update time to @xmath0 .",
    "however , it is easy to see that due to the bbsts in lazy local trees , if we form @xmath124 with these trees , the depth of @xmath124 becomes @xmath139 .",
    "if we use the same approach as in the previous section , we thus increase query and update time by a factor of @xmath21 . adding shortcuts",
    "to @xmath124 will avoid this slowdown but this gives a data structure with the same bounds as in the previous section .    to handle this",
    ", we introduce a new type of lazy local trees .",
    "let @xmath7 be a non - leaf node of @xmath44 .",
    "a child @xmath8 of @xmath7 in @xmath44 is said to be _ heavy _ if @xmath145 and otherwise it is _ light _ ; here @xmath146 is a constant that we may pick as small as we like .",
    "our lazy local tree @xmath105 of @xmath7 is illustrated in figure  [ fig : lazylocaltree ] .",
    "it is rooted at @xmath7 and has two children .",
    "one child is the root of a tree @xmath147 having the heavy children of @xmath7 as leaves and the other child is the root of a tree @xmath148 having the light children of @xmath7 as leaves ( to simplify the description , we assume that @xmath7 has both light and heavy children ; if there were no light ( resp .",
    "heavy ) children , we would simply identify @xmath105 with @xmath147 ( resp .",
    "@xmath148 ) ) .",
    "we call @xmath147 the _ heavy tree _ ( of @xmath7 ) and it is defined as the local tree from the previous section over the heavy children of @xmath7 ; note that its size is asymptotically bounded by the number of heavy children of @xmath7 which is at most @xmath149 .",
    "the tree @xmath148 is called the _ light tree _ ( of @xmath7 ) and it is thorup s lazy local tree for the set of light children of @xmath7 .",
    "the following lemma shows that when @xmath124 is formed from @xmath44 by inserting these lazy local trees , the height of trees in @xmath124 is only a constant factor larger than that in section  [ sec : simpledatastruct ] .",
    "[ lem : heightcl ] the height of @xmath124 ( with lazy local trees ) is @xmath19 .    let @xmath7 be a non - leaf node in @xmath44 and let @xmath8 be one of its children , also in @xmath44 .",
    "if @xmath8 is a heavy child of @xmath7 then @xmath150 so its depth in @xmath105 is at most @xmath125 .",
    "now assume that @xmath8 is a light child of @xmath7",
    ". then @xmath8 belongs to either a bottom tree or the buffer tree of @xmath105 . in the latter case ,",
    "the depth of @xmath8 in @xmath105 is @xmath136 . in the former case ,",
    "let @xmath144 be the bottom tree containing @xmath8 and let @xmath90 be a leaf of @xmath144 maximizing @xmath91 . by definition ,",
    "the root of @xmath144 has rank @xmath151 .",
    "hence the depth of @xmath8 in @xmath105 is at most @xmath152 .",
    "this is @xmath153 as @xmath154 implies @xmath155 .",
    "it follows that in both cases , @xmath8 has depth @xmath156 in @xmath105 .",
    "the height of @xmath44 is at most @xmath14 so by a telescoping sums argument , @xmath124 has height @xmath19 , as desired .",
    "now , let us describe how to maintain lazy local trees of @xmath124 corresponding to changes in @xmath44 . for technical reasons ,",
    "we assign ranks to rank path nodes in heavy trees by @xmath157 for @xmath120 , where @xmath119 and @xmath118 are defined as in section  [ subsec : localtrees ] . in the following , _ rank nodes _ are nodes that are assigned a rank .",
    "note that every node of @xmath124 is a rank node except non - leaf nodes of a buffer or top tree and nodes of a bottom tree @xmath144 that are neither leaves nor the root of @xmath144 .",
    "we need to maintain lazy local trees when merging @xmath44-nodes and when adding and removing children from @xmath44-nodes .",
    "we start with merging .",
    "consider two @xmath44-nodes @xmath7 and @xmath8 that are to be merged into @xmath7 .",
    "denote by @xmath158 the updated @xmath7 after the merge .",
    "note that every heavy child of @xmath158 must be a heavy child of either @xmath7 or @xmath8 .",
    "hence , we can form @xmath159 by traversing every leaf @xmath90 of @xmath147 and @xmath160 and adding it as a leaf of @xmath159 iff @xmath161 .",
    "total time for this is @xmath162 .",
    "forming @xmath163 is done as in  @xcite .",
    "the two buffer trees are merged in time bounded by the smaller of the two trees .",
    "if the number of leaves of the merged buffer tree exceeds @xmath164 , it is turned into a bottom tree for @xmath158 , leaving an empty buffer tree .",
    "the root of the new bottom tree is paired up with other rank nodes , if needed .",
    "we can pay for all buffer tree merges by giving a node @xmath165 credits when it switches from not belonging to belonging to a buffer tree : every time it is moved to another buffer tree , we spend @xmath136 time for the node and the size of the buffer tree containing the node grows by a factor of at least @xmath23 ; hence the node is moved at most @xmath136 times before either being deleted or being moved to a bottom tree .",
    "we propose a different approach for merging top trees than that of thorup ; we feel ours is simpler as it avoids keeping a special bitmap associated with each top tree node .",
    "assume w.l.o.g .",
    "that the top tree @xmath166 in @xmath148 is no bigger than the top tree @xmath167 in @xmath168 . for each leaf of @xmath166 we binary search for a leaf with the same rank in @xmath167 in @xmath136 time . while there are roots with equal ranks , we pair them up as before , finally obtaining the top tree for @xmath169 .",
    "the time for this is @xmath170 plus time bounded by the number of new rank nodes created .",
    "below we will show how the creation of rank nodes are paid for when they are deleted . with an amortized analysis similar to that above for buffer trees",
    ", we can pay for all top tree updates if we assign @xmath165 credits to a node when it switches from not appearing to appearing as a leaf in a top tree , and if we borrow @xmath165 credits whenever we delete a leaf of a top tree ( thereby borrowing from a new rank node ) and distribute these borrowed credits evenly among the remaining leaves .    since @xmath171",
    ", we may have some leaves @xmath172 with @xmath173 and hence @xmath90 should belong to @xmath163 .",
    "all such nodes are added to the buffer tree ; as before , this tree is turned into a bottom tree if it gets more than @xmath164 leaves .",
    "total time for this is @xmath174 ( plus time bounded by the number of new rank nodes created ) since at most @xmath175 nodes need to be moved from @xmath176 .",
    "finally , let @xmath94 be the parent of @xmath7 and @xmath8 in @xmath44 ; below we will add shortcuts that allow us to identify @xmath94 from @xmath7 ( equivalently from @xmath8 ) in @xmath1 time ( lemma  [ lem : shortcut ] ) .",
    "we remove @xmath7 and @xmath8 as leaves of @xmath177 and then we add @xmath158 as a leaf of @xmath178 if @xmath179 and otherwise we add @xmath158 as leaf of the buffer tree in @xmath180 .",
    "this takes @xmath136 time since both the buffer tree and @xmath178 have poly - logarithmic size and their roots have depth @xmath136 in @xmath177 .",
    "consider removing a @xmath44-node child @xmath8 of a @xmath44-node @xmath7 and adding it as a child of a new @xmath44-node @xmath90 which is added as a child of the parent @xmath44-node @xmath94 of @xmath7 .",
    "we first focus on removing @xmath8 and we let @xmath158 denote @xmath7 after this update",
    ".    assume first that @xmath150 .",
    "after removing @xmath8 from @xmath147 , we have @xmath181 and hence some nodes may need to be moved from @xmath148 to @xmath147 in order to form @xmath182 . identifying such nodes in the buffer tree of @xmath148 can be done in @xmath136 time per node .",
    "now suppose @xmath90 is a leaf of a bottom tree @xmath144 that needs to be moved to @xmath147 .",
    "let @xmath35 be the root of @xmath144 and let @xmath34 be the leaf of the top tree of @xmath148 having @xmath35 as descendant . since @xmath183 and since ranks are strictly decreasing on the path from @xmath34 to @xmath35 , @xmath35 has depth at most @xmath184 in the subtree of @xmath148 rooted at @xmath34 .",
    "a dfs from @xmath34 identifies all bottom tree roots with at most this depth in @xmath185 time ; let @xmath186 be the set of leaves in these bottom trees that need to be moved to @xmath147 .",
    "using binary search in the @xmath185 bottom trees , we identify @xmath186 and move it to @xmath147 in time @xmath187 .",
    "since all rank leaves of the top tree of @xmath148 have distinct ranks , there are only @xmath136 choices for @xmath34 . also , the maximum number of leaves to be moved is bounded by the number of leaves of @xmath159 which is at most @xmath149 .",
    "total time is thus @xmath188 .",
    "we may also need to move @xmath7 in @xmath177 . if @xmath7 belongs to a bottom tree in @xmath180 , we move it to the buffer tree as we do not allow ranks of leaves in bottom trees to change",
    ". we also move @xmath7 to the buffer tree if @xmath189 and @xmath190 .",
    "as we saw for merge , the time for this is @xmath1 .    as in  @xcite",
    ", we need to do more global updates whenever removing a leaf from a bottom tree @xmath144 of @xmath148 reduces the maximum rank of leaves in @xmath144 and hence the rank of the root @xmath35 of @xmath144 .",
    "we use a similar approach and amortized analysis as thorup here : first , delete all rank nodes from @xmath35 to the ancestor leaf @xmath34 of the top tree of @xmath148 .",
    "then pair nodes of equal rank as before . for the amortized analysis",
    ", we can assume that the graph @xmath5 ends with no edges so all rank nodes end up being deleted and we can amortize creation of rank nodes in @xmath148 over deletion of rank nodes in @xmath148 . a rank node is only deleted when a bottom tree root has its rank reduced .",
    "since a rank is at most @xmath14 , a particular bottom tree can have its root rank reduced at most @xmath14 times ( nodes are never added to a bottom tree and ranks of bottom tree leaves do not change ) so in total it gives rise to at most @xmath191 rank node deletions for that bottom tree .",
    "but since a bottom tree starts out with @xmath192 leaves that will all be deleted eventually , we can amortize each rank node deletion over @xmath193 deletions of bottom tree leaves .",
    "when removing child @xmath8 , we delete at most @xmath149 leaves from bottom trees of @xmath148 in order to form @xmath182 so we can amortize each rank node deletion over @xmath194 deletions of children in @xmath44 . hence if we pick constant @xmath195 , we can afford to pay for rank node deletions and also to pay for the @xmath165 credits that may have been borrowed from a rank node during a merge .    it remains to consider the case @xmath196 .",
    "above we showed how to efficiently remove up to order @xmath149 leaves from @xmath148 so clearly the single leaf @xmath8 can also be removed efficiently .",
    "we then move additional leaves from @xmath148 to @xmath147 and move @xmath7 to @xmath178 or to the buffer tree of @xmath180 , as above .",
    "now consider adding @xmath8 as a child of @xmath90 and @xmath90 as a child of @xmath94 .",
    "the former is trivial as @xmath90 has no children before adding @xmath8 . if @xmath197 , we add @xmath90 to @xmath178 and otherwise we add it to the buffer tree of @xmath180 . given @xmath94 , total time for this is @xmath136 .      in order to get our @xmath21 speed - up for updates and queries ,",
    "we need to be able to traverse @xmath124 faster .",
    "thorup  @xcite introduced a system of shortcuts for quickly identifying certain edges incident to clusters .",
    "this will not suffice in our approach since for our search procedures , we also need to move quickly from a leaf of @xmath124 to its ancestor level @xmath29 node in order to identify the associated level @xmath29 cluster , for some @xmath29 .",
    "we therefore introduce a different system of shortcuts in the following . to avoid skipping past a level @xmath29 node with these shortcuts , our data structure associates , for each node of a heavy tree @xmath147 , the level @xmath46 of @xmath7 .",
    "we can easily extend the data structure for lazy local trees to maintain these values within the same time bound since @xmath147 has only size @xmath185 .",
    "let us color each node of @xmath124 either white or black .",
    "for the coloring below , we define a _ black - induced child _ of a node @xmath198 to be a black descendant @xmath8 of @xmath7 such that all interior nodes on the path from @xmath7 to @xmath8 in @xmath124 are white . if @xmath7 is black , we add a shortcut between @xmath7 and each of its black - induced children .",
    "the shortcut is directed to @xmath7 , allowing us to move quickly up in @xmath124 .",
    "the black - induced parent of a node is defined similarly .",
    "note that the shortcuts ( with directions reversed ) form a forest of rooted trees over the black nodes .",
    "now , let us define the coloring of nodes of @xmath124 .",
    "the following nodes are colored black :    1 .",
    "every @xmath44-node @xmath7 with @xmath199 for some integer @xmath29 , 2 .",
    "every rank node @xmath7 having a parent rank node @xmath8 in @xmath124 such that @xmath200 for some integer @xmath29 , 3 .",
    "every leaf of @xmath124 and of every buffer , bottom , and top tree , and 4 .",
    "every node of a buffer , bottom , and top tree whose depth in that tree is divisible by @xmath201 ( in particular , every root of such a tree is black ) .",
    "a black node is of _ type _",
    "@xmath72 , @xmath23 , @xmath202 , and/or @xmath203 , depending on these four cases .",
    "all other nodes are colored white . for performance reasons",
    ", we shall only maintain @xmath135-bitmaps for black nodes .",
    "lemma  [ lem : shortcut ] below shows that these shortcuts give a @xmath21 speed - up when moving up a tree of @xmath124 . we first need the following result .",
    "[ lem : rankscl ] ranks are non - decreasing along any simple leaf - to - root path in @xmath124 .",
    "between any two consecutive @xmath44-nodes on such a path , there are at most two pairs of nodes of equal rank",
    ".    the first part of the lemma will follow if we can show that ranks are non - decreasing along any simple leaf - to-@xmath7 path @xmath31 in a lazy local tree @xmath105 .",
    "this is clearly the case for leaves in @xmath147 . a leaf @xmath8 in @xmath148 either belongs to a bottom or buffer tree @xmath107 .",
    "assume the former since otherwise , @xmath7 and @xmath8 are the only rank nodes on the @xmath8-to-@xmath7 path @xmath31 and since both are @xmath44-nodes , @xmath204 .",
    "only the first node @xmath8 and last node @xmath109 of subpath @xmath205 = t\\cap p$ ] are rank nodes . since @xmath109 is the root of @xmath107 ,",
    "it has maximum rank among leaves in @xmath107 so @xmath206 .",
    "let @xmath207 be the leaf of the top tree of @xmath105 belonging to @xmath31 .",
    "all nodes on @xmath208 $ ] belong to a rank tree so ranks are increasing along this subpath . for the subpath",
    "@xmath209 $ ] , only @xmath207 and @xmath7 are rank nodes .",
    "let @xmath140 be the set of leaves of @xmath148 formed by picking one of maximum rank from each bottom tree descending from @xmath207",
    ". then @xmath210 .",
    "this shows the first part of the lemma .",
    "for the second part , let @xmath7 and @xmath8 be @xmath44-nodes where @xmath8 is a child of @xmath7 .",
    "assume first that @xmath8 is a leaf of @xmath147 .",
    "ranks are strictly increasing on the path from @xmath8 to the root @xmath109 of the rank tree containing @xmath8 .",
    "ranks are also strictly increasing along the rank path in @xmath147 .",
    "hence , there are at most two pairs of equal rank nodes in @xmath124 between @xmath7 and @xmath8 , namely @xmath109 and its parent and the root of @xmath147 and @xmath7 .",
    "now consider the case where @xmath8 is a leaf of @xmath148 and again assume it belongs to a bottom tree @xmath144 . let @xmath109 be the root of @xmath144 and let @xmath207 be the leaf of the top tree which is an ancestor of @xmath8 .",
    "then again , since ranks are strictly increasing along any leaf - to - root path in a rank tree , there can be at most two equal - rank pairs between @xmath7 and @xmath8 , namely @xmath211 and @xmath212 .",
    "this completes the proof .",
    "[ lem : shortcut ] given @xmath124 with shortcuts , given a level @xmath29 , and given a @xmath44-node of @xmath124 with an ancestor level @xmath29 node , we can identify this ancestor in @xmath1 time .",
    "let @xmath8 be the given node . to identify the ancestor level @xmath29 node @xmath7 of @xmath8 , we start by traversing the @xmath8-to - root path of the tree in @xmath124 containing @xmath8 and we stop if we reach @xmath7 or a black node . since @xmath8 is a @xmath44-node and since light trees have black leaves , all nodes visited are rank nodes .",
    "lemma  [ lem : rankscl ] then implies that we visit at most @xmath136 nodes before stopping .",
    "hence , the traversal takes @xmath136 time .",
    "assume that we reach a black node @xmath213 as we are done if we reach @xmath7 .    from @xmath213",
    "we traverse shortcuts until we get to the lowest - depth black node @xmath214 having @xmath7 as ancestor .",
    "finally we traverse the @xmath214-to - root path in @xmath124 until we reach @xmath7 .",
    "the latter takes @xmath136 time by an argument similar to the above .",
    "next we show that there are @xmath1 shortcuts between @xmath213 and @xmath214 .",
    "since @xmath44 has logarithmic height , there are only @xmath1 shortcut endpoints of type @xmath72 .",
    "lemma  [ lem : rankscl ] implies the same bound for shortcut endpoints of type @xmath23 .",
    "if a shortcut ends at a type @xmath202 node @xmath35 which is a leaf of a buffer or bottom tree , it means that we enter a light tree @xmath169 .",
    "we encounter only one additional type @xmath202 node in @xmath169 , namely a leaf of a top tree .",
    "since @xmath215 we have @xmath216 and since a rank is at most @xmath14 , lemma  [ lem : rankscl ] implies that we encounter no more than @xmath1 type @xmath202 nodes between @xmath213 and @xmath214 . finally , this bound on the number of type @xmath202 nodes and lemma  [ lem : heightcl ] give the same asymptotic bound on the number of type @xmath203 nodes .",
    "what remains is to describe how to avoid jumping past @xmath7 when traversing the shortcuts .",
    "let @xmath217 be the shortcut that jumps past @xmath7 , if any .",
    "since leaves of light trees are black , @xmath218 must belong to some heavy tree @xmath219 .",
    "if @xmath214 belongs to a light tree , it must belong to the root of the top tree in @xmath148 since that root is black .",
    "we can avoid this case as follows : whenever we reach the root of a top tree , its parent is a @xmath44-node and we compare its level with @xmath29 to determine whether we should continue with the shortcuts .",
    "now , consider the case where @xmath214 belongs to a heavy tree @xmath220 .",
    "recalling that for every node of a heavy tree @xmath221 we keep the level @xmath222 of @xmath90 , we can check that @xmath223 to detect that @xmath34 is the last node that we should visit with shortcuts .",
    "this completes the proof .",
    "lemma  [ lem : shortcut ] allows us to speed up part of our search procedure , namely identifying the endpoints ( level @xmath50 clusters ) of an edge in a multigraph @xmath69 from the endpoints of the corresponding edge in @xmath5 ; we can do this in @xmath1 time per endpoint .",
    "we also need a faster iterator for level @xmath29-edges incident to explored level @xmath50 clusters .",
    "we focus on this in the following .",
    "define an _",
    "@xmath29-induced forest @xmath224 _ as in  @xcite : its @xmath29-induced leaves are the leaves of @xmath124 with an incident level @xmath29-edge .",
    "its @xmath29-induced roots are the level @xmath50 nodes of @xmath124 having descendant @xmath29-induced leaves .",
    "its @xmath29-induced branch nodes are the nodes of @xmath124 with both children have descending @xmath29-induced leaves .",
    "the @xmath29-induced parent of an @xmath29-induced node is its nearest @xmath29-induced ancestor .",
    "this defines @xmath224 .",
    "a straightforward level @xmath29-iterator performs a dfs in a tree of @xmath224 .",
    "however , maintaining the edges of @xmath224 will be too expensive . instead",
    ", we introduce a new system of shortcuts in @xmath124 that will allow the dfs to move between any two incident @xmath29-induced nodes of @xmath224 in @xmath1 time .",
    "since a tree of @xmath224 is binary , the number of branch nodes of @xmath107 is bounded by the number of leaves of @xmath107 , so this will give a level @xmath29-iterator with @xmath1 amortized time per level @xmath29-edge . in the following ,",
    "we define the new shortcuts .",
    "refer to the following types of nodes of @xmath124 as _ special _ :    1 .",
    "every @xmath44-node @xmath7 with @xmath225 for some integer @xmath29 , 2 .",
    "every leaf of @xmath124 , and 3 .",
    "every rank node @xmath7 of a light tree with @xmath226 for some integer @xmath29 .    note that every special node is black .",
    "also note that we defined type @xmath202 special nodes using equality rather than inequality as for type @xmath23 black nodes .",
    "this suffices since ranks increase by @xmath72 as we move up rank nodes of a light tree ; this is not the case in heavy trees where ranks can increase by larger values along a rank path . for a special node @xmath7 ,",
    "_ special child _ of @xmath7 to be a descendant special node @xmath8 such that all nodes between @xmath7 and @xmath8 are not special .",
    "special parents are defined similarly . for any level @xmath29 ,",
    "if there is a unique special child @xmath8 of @xmath7 for which @xmath227 = 1 $ ] , we add a shortcut ( bidirected pointer ) between @xmath7 and @xmath8 . to distinguish these shortcuts from those of section  [ subsec : shortcutting ] , we refer to the former as _ @xmath29-induced shortcuts _ or just _ induced shortcuts _ and the latter as _ standard @xmath29-shortcuts _ or just _",
    "standard shortcuts_. observe that for all @xmath29-induced shortcuts @xmath131 , where @xmath35 is a special child of @xmath34 , there is an edge in @xmath224 from @xmath34 or an ancestor of @xmath34 to @xmath35 or a descendant of @xmath35 .",
    "for each special node @xmath7 , we keep a bbst with a leaf for each @xmath29 containing the @xmath29-induced shortcuts to a special child and/or parent ( if they exist ) .",
    "now let us present the level @xmath29-iterator .",
    "it starts at the root @xmath8 of a tree in @xmath224 , i.e. , @xmath8 is a level @xmath50 node of @xmath124 .",
    "it performs a dfs of the subtree of @xmath124 rooted at @xmath8 with the following modification : if it visits a black node @xmath90 for which @xmath228 = 0 $ ] , it backtracks ; if it visits a special node @xmath93 with an @xmath29-induced shortcut to a special child , it visits this special child instead of the children of @xmath93 in @xmath124 .",
    "when it reaches a leaf @xmath207 of @xmath124 , it identifies the group of incident level @xmath29-edges with a binary search in the bbst associated with @xmath207 and then iterates over these edges .",
    "this completes the description of the level @xmath29-iterator .",
    "lemma  [ lem : iterator ] below shows the performance of the level @xmath29-iterator . to prove it , we need two additional lemmas .    [ lem : whitetree ] any node of @xmath124 has only @xmath229 black - induced children .",
    "let @xmath7 be a node of @xmath124 .",
    "if @xmath7 is a non - leaf node of a bottom , buffer , or top tree , the lemma follows from the definition of type @xmath202 and @xmath203 black nodes . otherwise , @xmath7 is a rank node . for any black - induced child @xmath8 of @xmath7 ,",
    "lemma  [ lem : rankscl ] and the definition of type @xmath72 and @xmath23 black nodes imply that @xmath8 has depth at most @xmath230 in the subtree of @xmath124 rooted at @xmath7 .",
    "as @xmath124 is binary , the lemma follows .",
    "[ lem : specialdist ] for any @xmath29-induced shortcut @xmath131 , the simple @xmath34-to-@xmath35 path in @xmath124 has length @xmath231 .",
    "let @xmath31 be the simple @xmath34-to-@xmath35 path in @xmath124 .",
    "clearly , @xmath31 contains only @xmath232 @xmath44-nodes .",
    "let @xmath233 be a subpath of @xmath31 containing no @xmath44-nodes .",
    "then @xmath233 is either contained in a heavy or a light tree . in the former case , @xmath234 . in the latter case ,",
    "we encounter at most @xmath136 nodes of buffer , bottom , and top trees on @xmath233 . since consecutive rank nodes of @xmath233 differ in rank by exactly @xmath72 ( as they all belong to a light tree and hence to a rank tree ) , we encounter at most @xmath232 rank nodes on @xmath233 so @xmath235 .",
    "[ lem : iterator ] the level @xmath29-iterator above traverses a tree in @xmath224 with @xmath236 leaves in @xmath237 time .",
    "the time to visit the first @xmath238 leaves is @xmath239 .",
    "correctness follows easily from the definition of @xmath135-bitmaps , @xmath29-induced shortcuts , and bbsts associated with leaves of @xmath124 so let us focus on the time bound to traverse a @xmath236-leaf tree @xmath107 in @xmath224 .",
    "let @xmath240 be the tree in @xmath124 obtained by replacing each edge @xmath241 with the corresponding simple path @xmath31 in @xmath124 between @xmath34 and @xmath35 . by lemmas  [ lem : heightcl ] and  [ lem : rankscl ]",
    ", there can only be @xmath242 special nodes on such a path @xmath31 . hence",
    ", since @xmath107 has no degree @xmath23-vertices , the total number of special nodes and hence @xmath29-induced shortcuts traversed by the level @xmath29-iterator in @xmath240 is @xmath243 .",
    "for each special node visited , @xmath136 time is spent on binary search to find the next @xmath29-induced shortcut , if it exists . hence , the total time spent on visiting special nodes and traversing @xmath29-induced shortcuts is @xmath237 .",
    "we will now show that the number of additional nodes visited by the dfs is @xmath244 . since only constant time is spent for each such node",
    ", this will show the first part of the lemma .",
    "first we bound the number of visited nodes of @xmath240 which are not special .",
    "let @xmath131 and @xmath31 be as above . if we traverse @xmath31 from @xmath34 then it follows from lemma  [ lem : specialdist ] that after at most @xmath231 nodes , we will reach either @xmath35 or a special node @xmath245 . similarly ,",
    "if we traverse @xmath31 from @xmath35 then after at most @xmath231 nodes , we will reach either @xmath34 or a special node @xmath246 .",
    "if @xmath245 and @xmath246 exist then all nodes visited by the dfs on @xmath247 $ ] are special nodes connected by @xmath29-induced shortcuts .",
    "summing over all such paths @xmath31 , it follows that the total number of nodes visited on @xmath240 which are not special is @xmath248 .",
    "finally , let us bound the number of nodes of @xmath124 visited by the dfs which are not on @xmath240 .",
    "consider a visited node @xmath249 and let @xmath250 be a visited node such that @xmath7 is the nearest ancestor of @xmath8 belonging to @xmath240 .",
    "note that there is no @xmath29-induced shortcut from @xmath7 to a special child since then the dfs would have traversed this shortcut instead of the children of @xmath7 in @xmath124 . in particular , there are only @xmath248 choices for @xmath7 .",
    "furthermore , all interior nodes on the simple path from @xmath7 to @xmath8 in @xmath124 are white since any black node @xmath90 would have @xmath228 = 0 $ ] ( as @xmath251 ) , meaning that the dfs would have backtracked before reaching @xmath8 . by lemma  [ lem : whitetree ] , there are only @xmath229 choices for @xmath8 for each @xmath7 . hence , the total number of nodes visited which are not on @xmath240 is @xmath244 .",
    "this shows the first part of the lemma .    for the second part ,",
    "consider a partially grown dfs tree @xmath108 which has visited @xmath238 leaves .",
    "for every node of @xmath108 having two children , at least one of the two subtrees rooted at the children is fully explored .",
    "hence , @xmath108 consists of a path @xmath31 from the root of @xmath107 to a leaf of @xmath107 with fully explored subtrees attached to @xmath31 . the same argument as above shows that the total time to explore these subtrees is @xmath252 . by lemma  [ lem : heightcl ]",
    ", it takes @xmath19 time to explore @xmath31 ( the number of special nodes on @xmath31 is @xmath242 so we only spend a total of @xmath1 time on binary searches for these nodes ) .",
    "it follows from lemma  [ lem : iterator ] that the level @xmath29-iterator spends @xmath1 amortized time per edge visited plus additional @xmath19 time if a replacement path was found ( if such a path is not found , an entire tree in @xmath224 is traversed ) .",
    "the @xmath1 amortized time per edge is paid for by the increase in the level of the edge and the @xmath19 time is paid for by the deletion of an edge in @xmath5 since at most one replacement path is found for such an edge .    it remains to describe how colors , shortcuts ( standard and induced ) and @xmath135-bitmaps are maintained when @xmath44 ( and hence @xmath124 ) is updated and when edges of @xmath5 are added / removed or change level .",
    "first we deal with changes to @xmath44 .",
    "the following lemma will prove useful .",
    "[ lem : incidentinducedshortcuts ] given @xmath135-bitmaps of black nodes and given a special node @xmath7 , we can find the induced shortcuts between @xmath7 and its special parent ( if any ) in @xmath19 time .",
    "for any @xmath29 , we can find the @xmath29-induced shortcut from @xmath7 to a special child or determine that no such shortcut exists in @xmath253 time .",
    "we first walk up @xmath124 from @xmath7 to identify its special parent @xmath94 . by lemma  [ lem : specialdist ]",
    ", this takes @xmath231 time .",
    "then we perform a dfs in the subtree of @xmath124 rooted at @xmath94 and backtrack if we encounter @xmath7 or a black node which is not an ancestor of @xmath7 .",
    "if any such black node is encountered for which the @xmath29th bit of its @xmath135-bitmap is @xmath72 then we know that there should not be an @xmath29-induced shortcut between @xmath7 and @xmath94 .",
    "otherwise there should be iff @xmath129 = 1 $ ] .",
    "let @xmath11 be the bitmap obtained by taking the bitwise or of the @xmath135-bitmaps of visited black nodes not on the @xmath7-to-@xmath94 path .",
    "by lemmas  [ lem : whitetree ] and  [ lem : specialdist ] , finding @xmath11 takes @xmath253 time .",
    "now , there is an @xmath29-induced shortcut between @xmath7 and @xmath94 iff @xmath28 = 0 $ ] and @xmath129 = 1 $ ] .",
    "hence , all induced shortcuts between @xmath7 and @xmath94 can be found in @xmath19 time .    to find the @xmath29-induced shortcut ( if any ) to a special child of @xmath7",
    ", we make a dfs from @xmath7 which backtracks when reaching a black node .",
    "suppose exactly one visited black node @xmath90 has @xmath228 = 1 $ ] ( otherwise , there is no @xmath29-induced shortcut ) .",
    "if @xmath90 is special , we have identified the @xmath29-induced shortcut @xmath254 . otherwise , we recurse on @xmath90 . as",
    "above , total time for this is @xmath253 .",
    "let us now describe how shortcuts and @xmath135-bitmaps are maintained after structural changes to @xmath124 .",
    "it follows from lemma  [ lem : whitetree ] that for each update to @xmath124 , we can update colors , standard shortcuts and @xmath135-bitmaps in @xmath229 time . from the results in section  [ subsec :",
    "maintainlazy ] , this will not affect the overall time bound ( if we pick constant @xmath142 sufficiently large ) . in the following , we thus only consider updating induced shortcuts .",
    "we shall restrict our attention to structural changes caused by a ` delete`-operation as ` insert ` corresponds to merging two clusters ( or none ) , a type of update that needs to be supported during a ` delete ` .    recall that after a ` delete`-operation , @xmath44 is updated as follows : some children of a node @xmath7 are removed and merged into a single node ; this node is either added as a child of @xmath7 ( if a replacement path was found ) or it is added as a child of a new node @xmath158 which is added as a child of the parent @xmath94 of @xmath7 and the process is repeated recursively on @xmath94 ( if a replacement path was not found ) .",
    "we observe that all @xmath44-nodes whose children are updated are contained in two leaf - to - root paths in @xmath44 after the ` delete`-operation has been executed .",
    "there are two types of induced shortcuts that need to be updated , those incident to a type @xmath72 special node and those descending from a type @xmath202 special node and not ascending from a type @xmath72 special node ( see definitions of types in section  [ subsec : indshortcuts ] ) .",
    "below we show how to update the latter .    for the former , it follows from the above that we only need to focus on type @xmath72 special nodes on a leaf - to - root path @xmath31 in @xmath124 ( there are two paths but they are handled in the same manner ) .",
    "let @xmath255 be the sequence of special nodes as we move up @xmath31 during the ` delete`-operation ( some of them may be new or merged nodes and hence do not exist before the ` delete`-operation ) . by lemma  [ lem : incidentinducedshortcuts ] , we can find all induced shortcuts descending from @xmath256 in @xmath257 time . when we reach @xmath258 , @xmath259 , we compute induced shortcuts between @xmath260 and @xmath258 . by lemma  [ lem : incidentinducedshortcuts ]",
    ", this takes @xmath139 time ( including binary searches in the bbsts of @xmath260 and @xmath258 ) for a total of @xmath0 over all @xmath261 which the ` delete`-operation can pay for .",
    "we also compute induced shortcuts descending from @xmath258 for those @xmath29 for which @xmath262 = 1 $ ] and @xmath263 = 0 $ ] .",
    "total time over all @xmath261 is @xmath257 since if @xmath262 = 1 $ ] then @xmath264 = 1 $ ] for all @xmath265 , implying that the second part of lemma  [ lem : incidentinducedshortcuts ] is applied at most once for each @xmath29 .",
    "note that all @xmath29-induced shortcuts from @xmath258 to a special child which have not been identified by the second part of lemma  [ lem : incidentinducedshortcuts ] must have @xmath262 = \\edge(u_{j-1})[i ] = 1 $ ] and hence must connect @xmath258 to @xmath260 which we have computed above .",
    "hence , we correctly compute all induced shortcuts incident to special nodes on @xmath31 and we do so within the desired time bound .",
    "now we show how to maintain induced shortcuts descending from a type @xmath202 special node @xmath94 and not ascending from a type @xmath72 special node .",
    "we may assume that @xmath94 is not on one of the leaf - to - root paths considered above .",
    "then the only structural changes to @xmath124 that may require such shortcuts to be updated are    1 .",
    "a type @xmath202 special node is created or deleted , or 2 .",
    "a leaf is removed from a bottom tree in the light tree containing @xmath94 .",
    "a type @xmath202 special node can pay any polylogarithmic amount when it is created / deleted so consider updating induced shortcuts descending from @xmath94 when a leaf @xmath7 is removed from a bottom tree @xmath144 in the light tree @xmath169 containing @xmath94 . to handle this case , we will assume that each rank node of @xmath169 has @xmath138 credits for each @xmath29 for which it is an @xmath29-induced branch node . to see that this assumption can be made ,",
    "first observe that when a buffer tree is turned into a bottom tree , it can pay any polylogarithmic amount if we pick @xmath142 sufficiently big .",
    "this is also the case when a new rank node of @xmath169 is created / deleted . since we never add but only remove leaves from bottom trees , the only other way a rank node of @xmath169 can become an @xmath29-induced branch node is if some edge of @xmath5 has its level increased to @xmath29 .",
    "such an edge can only contribute with two @xmath29-induced branch nodes to @xmath224 ( one for each of its endpoints ) so we may add @xmath138 credits to the two new @xmath29-induced branch nodes which the level increase can pay for .",
    "this shows the desired .",
    "let @xmath266 be the bitmap where @xmath267 = 1 $ ] iff there is an @xmath29-induced branch node @xmath268 on the path from @xmath7 to @xmath94 . by lemmas  [ lem : whitetree ] and  [ lem : specialdist ]",
    ", we can form @xmath266 in @xmath253 time which the removal of @xmath7 from @xmath144 can pay for .",
    "for each @xmath29 for which @xmath267 = 1 $ ] , the removal of @xmath7 may require us to compute an @xmath29-induced shortcut descending from @xmath94 .",
    "since a branch node is removed in the process , we can spend its credits to pay for applying lemma  [ lem : incidentinducedshortcuts ] to find this shortcut .",
    "we can binary search for each of the @xmath236 @xmath72-entries of @xmath266 in @xmath269 time ; for instance , to determine whether the lower half of @xmath266 has any @xmath72-bits , we can take the bitwise and of @xmath266 and a precomputed bitmap having @xmath72-bits in the lower half and @xmath38-bits in the upper half .",
    "the and is @xmath72 iff there are @xmath72-bits in the lower half of @xmath266 .",
    "now consider an @xmath29 for which @xmath267 = 0 $ ] .",
    "we may assume that a bitmap @xmath270 associated with @xmath94 is maintained where @xmath271 = 1 $ ] iff @xmath94 has a @xmath261-induced shortcut to a special child .",
    "if @xmath129 = 0 $ ] or @xmath272 = 0 $ ] , nothing needs to be done for @xmath29 so assume @xmath129 = 1 $ ] and @xmath272 = 1 $ ]",
    ". then we delete the @xmath29-induced shortcut descending from @xmath94 .",
    "if there is an @xmath29-induced shortcut from @xmath94 to its special parent @xmath96 , we remove it too and recurse on @xmath96 ; the recursion stops when we reach a special node @xmath273 without an @xmath29-induced shortcut to its special parent @xmath274 .",
    "each induced shortcut can be removed in @xmath136 time using binary search in the associated bbsts . by adding @xmath21 credits to an induced shortcut when it is created",
    ", we can pay for all deletions of induced shortcuts .",
    "if @xmath274 is a rank node of @xmath169 , we may need to add an @xmath29-induced shortcut from @xmath274 to a special child .",
    "this can only happen if an @xmath29-induced branch node between @xmath273 and @xmath274 disappears and as above , we can spend its credits to pay for finding this shortcut .      above we dealt with updates of shortcuts due to structural changes in @xmath124 .",
    "we now handle updates when leaves of @xmath224 appear or disappear due to edge level changes .",
    "[ [ edge - deletions ] ] edge deletions : + + + + + + + + + + + + + + +    when a level @xmath29-edge @xmath36 is deleted ( possibly due to its level being increased to @xmath82 ) , @xmath129 $ ] might change from @xmath72 to @xmath38 for one of its endpoints @xmath7 which will then no longer be an @xmath29-induced leaf of @xmath224 . we describe how to update other @xmath135-bitmaps accordingly and remove some of the @xmath29-induced shortcuts .",
    "the following is done for @xmath7 .",
    "if there are still level @xmath29-edges incident to @xmath7 then no updates are needed .",
    "otherwise , all @xmath29-induced shortcuts on the simple path in @xmath124 from @xmath7 to its @xmath29-induced parent @xmath94 should be removed . since @xmath7 is a leaf of @xmath124",
    ", it is a special node .",
    "we traverse @xmath29-induced shortcuts from @xmath7 to ancestors until we reach a special node @xmath8 without an @xmath29-induced shortcut to an ancestor . since @xmath7 is the only @xmath29-induced leaf below @xmath8",
    ", we delete all shortcuts traversed .",
    "we also set @xmath227 \\leftarrow 0 $ ] for all black nodes @xmath8 between @xmath7 and @xmath8 ( including @xmath8 ) in @xmath1 time by traversing standard @xmath29-shortcuts between @xmath7 and @xmath8 .",
    "we then traverse black nodes up from @xmath8 in @xmath124 and stop if we find a special node @xmath90 .",
    "whenever we visit a black node @xmath35 , we perform a dfs in the subtree of @xmath124 rooted at @xmath35 , backtracking at descending black nodes . if each black node @xmath246 visited below @xmath35 has @xmath275 = 0 $ ] , @xmath7 was the only leaf of @xmath124 below @xmath35 with an incident level @xmath29-edge so we set @xmath276\\leftarrow 0 $ ] and proceed up to the next black node .",
    "conversely , if some black node @xmath246 visited below @xmath35 has @xmath275 = 1 $ ] , @xmath94 must be below @xmath35 and no more bitmaps need to be updated .",
    "having updated the bitmaps and removed all @xmath29-induced shortcuts below @xmath8 , we need to check if an @xmath29-induced shortcut should be added from @xmath90 to one of its descendants . by lemma  [ lem : incidentinducedshortcuts ]",
    ", this takes @xmath253 time which can be paid for by the deletion of @xmath36 ; here we can also afford to add @xmath21 credits to the shortcut if it was added .    [ [ edge - insertions ] ] edge insertions + + + + + + + + + + + + + + +    now suppose a level @xmath29-edge @xmath36 is inserted .",
    "to update @xmath135-bitmaps and add new @xmath29-induced shortcuts , we do the following for each endpoint @xmath7 of @xmath36 . if other level @xmath29-edges are incident to @xmath7 then nothing needs to be done as @xmath7 is already a leaf of @xmath224 so assume otherwise .",
    "inserting @xmath36 corresponds to updating @xmath224 by adding a new edge @xmath277 , where @xmath94 is the @xmath29-induced parent of @xmath7 .",
    "hence , we need to add @xmath29-induced shortcuts between @xmath7 and @xmath94 .",
    "suppose @xmath7 has an ancestor black node @xmath8 such that @xmath227 = 1 $ ] .",
    "we traverse standard shortcuts up from @xmath7 and stop when we identify the first such @xmath8 .",
    "let @xmath255 be the ordered ( possibly empty ) sequence of special nodes visited from @xmath7 to @xmath8 .",
    "since @xmath8 already has a descending leaf incident to a level @xmath29-edge and @xmath278 does not , @xmath94 must be on the @xmath278-to-@xmath8 path in @xmath124 .",
    "hence , the new @xmath29-induced shortcuts to be added are @xmath279 .",
    "we also set to @xmath72 the @xmath29th bit of the @xmath135-bitmaps of all black nodes visited . by lemmas  [ lem : heightcl ] and  [ lem : rankscl ] ,",
    "all of this can be done in @xmath1 time and we can also afford to add @xmath21 credits to each of the @xmath242 new @xmath29-induced shortcuts .",
    "we assumed that a node @xmath8 with @xmath227 = 1 $ ] was encountered .",
    "if this is not the case , it means that @xmath7 should not be added to an existing tree in @xmath224 .",
    "rather , a new tree should be formed consisting of a single edge @xmath277 , where @xmath94 is the level @xmath50-ancestor of @xmath7 in @xmath124 .",
    "clearly , the corresponding @xmath29-induced shortcuts can be added and @xmath135-bitmaps updated within the same @xmath1 time bound .",
    "we can now conclude with the following theorem .",
    "there is a deterministic data structure for fully dynamic graph connectivity which supports edge insertions / deletions in @xmath0 amortized time per update and connectivity queries in @xmath1 worst case time , where @xmath2 is the number of vertices of the graph .",
    "we gave a deterministic data structure for fully - dynamic graph connectivity that achieves an amortized update time of @xmath0 and a worst - case query time of @xmath1 , where @xmath2 is the number of vertices of the graph .",
    "this improves the update time of holm , de lichtenberg , and thorup  @xcite and thorup  @xcite by a factor of @xmath21 .",
    "we believe our improvement may extend to fully - dynamic minimum spanning tree , @xmath23-edge , and/or biconnectivity .",
    "there is still a small gap between upper and lower bounds .",
    "for instance , for @xmath1 query time ,  @xcite gives an @xmath280 cell - probe lower bound for updates for constant @xmath146 .",
    "simultaneously getting @xmath19 update and query time and improving the @xmath12 worst - case update bound in  @xcite remain the main open problems for fully - dynamic graph connectivity .",
    "99 d. eppstein , z. galil , g. f. italiano , and a. nissenzweig .",
    "sparsification - a technique for speeding up dynamic graph algorithms .",
    "j. acm , @xmath281(@xmath282):@xmath283@xmath284 , @xmath285 .",
    "see also focs@xmath286 .",
    "g. n. frederickson .",
    "data structures for on - line updating of minimum spanning trees , with applications .",
    "siam j. comput . ,",
    "@xmath287(@xmath203):@xmath288@xmath289 , @xmath290 .",
    "see also stoc@xmath291 .",
    "m. r. henzinger and v. king . randomized dynamic graph algorithms with polylogarithmic time per operation .",
    "twenty - seventh annual acm symposium on theory of computing ( stoc ) , @xmath292 , pp .",
    "m. r. henzinger and m. thorup . sampling to provide or to bound : with applications to fully dynamic graph algorithms .",
    "random structures and algorithms , @xmath295(@xmath203):@xmath296@xmath297 , @xmath285 .",
    "see also icalp@xmath298 .",
    "j. holm , k. de lichtenberg , and m. thorup .",
    "poly - logarithmic deterministic fully - dynamic algorithms for connectivity , minimum spanning tree , 2-edge , and biconnectivity .",
    "j. acm , @xmath299(@xmath203 ) : @xmath300@xmath301 , 2001 .",
    "see also stoc@xmath302 .",
    "m. ptracu and e. demaine .",
    "logarithmic lower bounds in the cell - probe model .",
    "siam j. comput . ,",
    "@xmath303(@xmath203 ) : @xmath304",
    ". special issue @xmath305th acm symposium on theory of computing ( stoc @xmath306 ) .",
    "d. sleator and r. e. tarjan . a data structure for dynamic trees .",
    "j. comput .",
    "syst . sc . ,",
    "@xmath307(@xmath202):@xmath308@xmath309 , @xmath310 .",
    "see also stoc@xmath311 .",
    "r. e. tarjan .",
    "efficiency of a good but not linear set union algorithms .",
    "j. acm , @xmath312:@xmath313@xmath314 , @xmath315 .",
    "m. thorup .",
    "decremental dynamic connectivity .",
    "@xmath316th soda , pp .",
    "@xmath317@xmath318 , @xmath285 .",
    "m. thorup . near - optimal fully - dynamic graph connectivity .",
    "thirty - second annual acm symposium on theory of computing ( stoc ) , 2000 , pp . @xmath319@xmath320 ."
  ],
  "abstract_text": [
    "<S> we give new deterministic bounds for fully - dynamic graph connectivity . </S>",
    "<S> our data structure supports updates ( edge insertions / deletions ) in @xmath0 amortized time and connectivity queries in @xmath1 worst - case time , where @xmath2 is the number of vertices of the graph . </S>",
    "<S> this improves the deterministic data structures of holm , de lichtenberg , and thorup ( stoc 1998 , j.acm 2001 ) and thorup ( stoc 2000 ) which both have @xmath3 amortized update time and @xmath1 worst - case query time . </S>",
    "<S> our model of computation is the same as that of thorup , i.e. , a pointer machine with standard @xmath4 instructions . </S>"
  ]
}