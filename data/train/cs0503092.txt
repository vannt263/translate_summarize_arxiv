{
  "article_text": [
    "the notion of _ preference _ is common in various contexts involving decision or choice .",
    "classical utility theory @xcite views preferences as _ binary relations_. a similar view has recently been espoused in database research @xcite , where preference relations are used in formulating _",
    "preference queries_. in ai , various approaches to compact specification of preferences have been explored @xcite .",
    "the semantics underlying such approaches typically relies on preference relations between worlds",
    ".    however , user preferences are rarely static @xcite .",
    "a database user may be disappointed by the result of a preference query and decide to revise the preferences in the query .",
    "in fact , a user may start with a partial or vague concept of her preferences , and subsequently refine that concept .",
    "an agent may learn more about its task domain and consequently revise its preferences .",
    "thus , it is natural to study _ preference revision _ , as we do in the present paper .",
    "preference revision shares some of the principles , namely minimal change and primacy of new information , with classical belief revision @xcite .",
    "however , its basic setting is different . in belief revision ,",
    "propositional theories are revised with propositional formulas , yielding new theories . in preference revision ,",
    "binary preference relations are revised with other preference relations , yielding new preference relations .",
    "preference relations are single , finitely representable ( though possibly infinite ) first - order structures , satisfying order axioms .",
    "we distinguish between _ monotonic _ and _ nonmonotonic _ preference revision . in the former ,",
    "the original preference relation is fully incorporated into the revised one . in the latter ,",
    "the original preference relation may conflict with the revising relation , leading to the necessity of retracting some of the original preferences .",
    "we focus on two special cases : _ refinement _ in which both the original and the revising relation are preserved , and _ overriding revision _ in which the revising relation may override the original one .",
    "we adopt the notion of minimal change based on symmetric difference between sets of tuples .",
    "the challenges are : ( 1 ) to guarantee that suitable order properties , for example the axioms of strict partial orders , are preserved by the revisions , and ( 2 ) to obtain unique revisions .",
    "strict partial orders ( and weak orders ) , apart from being intuitive , enjoy a number of attractive properties in the context of preference queries , as explained later in the paper .",
    "so it is desirable for revisions to preserve such orders .",
    "the uniqueness property is also important from the user s point of view , as the user typically desires to obtain a single revised preference relation .",
    "the presence of multiple revision candidates necessitates some form of aggregation of or choice among the candidates .",
    "fortunately , in the cases studied in this paper there exist least revisions preserving the appropriate order axioms , and thus uniqueness is obtained automatically .",
    "we adopt the preference query framework of @xcite ( a similar model was described in @xcite ) , in which preference relations between tuples are defined by logical formulas . @xcite",
    "proposed a new relational algebra operator called _ winnow _ that selects from its argument relation the _ most preferred tuples _ according to the given preference relation .",
    "[ ex : car ] consider the relation @xmath0 and the following preference relation @xmath1 between _ car _ tuples :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ within each make , prefer a more recent car .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    which can be defined as follows : @xmath2 the winnow operator @xmath3 returns for every make the most recent car available .",
    "consider the instance @xmath4 of @xmath5 in figure [ fig : car ] .",
    "the set of tuples @xmath6 is shown in figure [ fig : winnow ] .    [ cols=\"<,<,<\",options=\"header \" , ]     [ ex : car:1 ] example [ ex : car ] provides a motivation for studying preference revision . seeing the result of the query @xmath6",
    ", a user may realize that the preference relation @xmath1 is not quite what she had in mind .",
    "the result of the query may contain some unexpected or unwanted tuples , for example @xmath7 .",
    "thus the preference relation needs to be modified , for example by refining it with the following preference relation @xmath8 : @xmath9 the resulting refinement will contain both @xmath1 and @xmath8 .",
    "the tuple @xmath7 is now dominated by @xmath10 and will not be returned to the user .    in the terminology used in research on preference reasoning in ai @xcite",
    ", a relational database instance corresponds to the set of _ feasible outcomes _ and the winnow operator picks the undominated ( best ) outcomes from this set , according to the given preferences .",
    "a preference setting can be affected by a change in preferences or a modification of the set of possible outcomes . in this research ,",
    "we address the former problem ; the latter one , database update , has been extensively studied in database research . moreover , we limit ourselves to preference revisions in which new preference information is combined , perhaps nonmonotonically , with the old one .",
    "we assume that the domains of preferences do not change in revisions .",
    "we are working in the context of the relational model of data .",
    "relation schemas consist of finite sets of attributes . for concreteness , we consider two infinite domains : @xmath11 ( uninterpreted constants , for readability shown as strings ) and @xmath12 ( rational numbers ) , but our results , except where explicitly indicated , hold also for finite domains .",
    "we assume that database instances are finite sets of tuples .",
    "additionally , we have the standard built - in predicates .      we adopt here the framework of @xcite .",
    "[ def : prefrel ] given a relation schema @xmath13 such that @xmath14 , @xmath15 , is the domain ( either @xmath11 or @xmath12 ) of the attribute @xmath16 , a relation @xmath17 is a _ preference relation over @xmath18 _ if it is a subset of @xmath19 .",
    "although we assume that database instances are finite , in the presence of infinite domains preference relations can be infinite",
    ".    typical properties of a preference relation @xmath17 include :    * _ irreflexivity _ : @xmath20 * _ transitivity _ : @xmath21 * _ negative transitivity _ : @xmath22 * _ connectivity _ : @xmath23 * _ strict partial order ( spo ) _ if @xmath17 is irreflexive and transitive ; * _ weak order _ if @xmath17 is a negatively transitive spo ; * _ total order _ if @xmath17 is a connected spo .",
    "[ def : prefformula ] a _ preference formula ( pf ) _",
    "@xmath24 is a first - order formula defining a preference relation @xmath25 in the standard sense , namely @xmath26 an _ intrinsic preference formula ( ipf ) _ is a preference formula that uses only built - in predicates .    by using the notation @xmath25 for a preference relation ,",
    "we assume that there is an underlying pf @xmath27 .",
    "occasionally , we will limit our attention to ipfs consisting of the following two kinds of atomic formulas ( assuming we have two kinds of variables : @xmath11-variables and @xmath12-variables ) :    * _ equality constraints _ : @xmath28 , @xmath29 , @xmath30 , or @xmath31 , where @xmath32 and @xmath33 are @xmath11-variables , and @xmath34 is an uninterpreted constant ; * _ rational - order constraints _ :",
    "@xmath35 or @xmath36 , where @xmath32 and @xmath33 are @xmath12-variables , and @xmath34 is a rational number .",
    "an ipf whose all atomic formulas are equality ( resp .",
    "rational - order ) constraints will be called an _ equality _ ( resp . _ rational - order _ ) ipf . clearly , ipfs are a special case of general constraints @xcite , and define _ fixed _ , although possibly infinite , relations .",
    "every preference relation @xmath17 generates an indifference relation @xmath37 : two tuples @xmath38 and @xmath10 are _ indifferent _ ( @xmath39 ) if neither is preferred to the other one , i.e. , @xmath40 and @xmath41 . we will denote by @xmath42 the indifference relation generated by @xmath25 .",
    "composite preference relations are defined from simpler ones using logical connectives .",
    "we focus on two basic ways of composing preference relations :    * _ union _ :",
    "@xmath43 * _ prioritized composition _",
    "( where @xmath44 is the indifference relation generated by @xmath45 ) : @xmath46    we also consider transitive closure :    [ def : transitive ] the _ transitive closure _ of a preference relation @xmath17 over a relation schema @xmath18 is a preference relation @xmath47 over @xmath18 defined as : @xmath48 where : @xmath49      we define now an algebraic operator that picks from a given relation the set of the _ most preferred tuples _ , according to a given preference relation .",
    "[ def : winnow]@xcite if @xmath18 is a relation schema and @xmath17 a preference relation over @xmath18 , then the _ winnow operator _ is written as @xmath50 , and for every instance @xmath51 of @xmath18 : @xmath52    if a preference relation is defined using a pf @xmath27 , we write simply @xmath53 instead of @xmath54 . a _ preference query _ is a relational algebra query containing at least one occurrence of the winnow operator .      the basic setting is as follows : we have a preference relation @xmath17 and revise it with a _ revising _ preference relation @xmath55 to obtain a _ revised _ preference relation @xmath56 .",
    "we also call @xmath56 a _ revision _ of @xmath17",
    ". we limit ourselves to preference relations over the same schema .",
    "the revisions are characterized by a number of different parameters :    * _ axiom preservation _ : what order axioms are preserved in @xmath56 ; * _ content preservation _ : what preference relations are preserved in @xmath56 ; * _ ordering _ ( of revisions ) .",
    "a revision @xmath56 of @xmath57 with @xmath58 is :    * a _ transitive ( resp .",
    "spo , a weak order ) _ revision if @xmath56 is transitive ( resp .",
    "an spo , a weak order ) ; * a _ monotonic _ revision if @xmath59 ; * a _ refinement _ revision ( _ refinement _ for short ) if ; * an _ overriding _ revision if @xmath60 .",
    "a refinement is monotonic .",
    "an overriding revision does not have to be monotonic because it may fail to preserve @xmath17 .",
    "we order revisions using the symmetric difference ( @xmath61 ) .",
    "[ ref : closeness ] assume @xmath45 and @xmath62 are two revisions of a preference relation @xmath17 with a preference relation @xmath55 .",
    "we say that @xmath45 is _ closer _ than @xmath62 to @xmath17 if @xmath63 .    a _ minimal ( resp .",
    "least ) _ revision of @xmath57 with @xmath55 is a revision that is minimal ( resp .",
    "least ) in the closeness order among all revisions of @xmath57 with @xmath55 .",
    "similarly , we talk about least transitive refinements ( or overriding revisions ) , least spo ( or weak order ) refinements or overriding revisions etc .",
    "it is easy to see that if we consider only refinements or overriding revisions of a fixed preference relation , closeness reduces to set containment .",
    "consider the preference relation @xmath64 representing the preference order @xmath65 , and the following revision of @xmath17 , @xmath66 .",
    "the revision @xmath45 is the least spo overriding revision of @xmath67 with @xmath68 .",
    "it achieves the effect of swapping @xmath69 and @xmath70 in the preference order .    to further describe the behavior of revisions , we define _",
    "preference conflicts_.    a _ conflict _ between a preference relation @xmath57 and a preference relation @xmath58 is a pair @xmath71 such that and .",
    "a _ hidden conflict _ between @xmath57 and @xmath58 is a pair @xmath71 such that @xmath72 and there exist @xmath73 , @xmath74 , such that @xmath75 and @xmath76 .",
    "a hidden conflict is a conflict ( if @xmath17 is an spo ) but not necessarily vice versa .    if @xmath77 and @xmath78 , then @xmath79 is a conflict which is not hidden .",
    "if we add @xmath80 and @xmath81 to @xmath17 , then the conflict is also a hidden conflict ( @xmath82 ) .",
    "if we further add @xmath83 or @xmath84 to @xmath55 , then the conflict is not hidden anymore .    in this paper , we focus on refinement and overriding revisions because in our opinion they capture two basic ways of revising preferences .",
    "a refinement does not retract any preferences or resolve conflicts : it only adds new preferences necessitated by order properties .",
    "so for a refinement to satisfy spo properties , all conflicts need to be avoided .",
    "an overriding revision , on the other hand , can override some of the original preferences if they conflict with the new ones .",
    "overriding can deal with conflicts which are not hidden and solves all of them in the same fashion : it gives higher priority to new preference information ( i.e. , @xmath55 ) .",
    "both refinement and overriding revisions preserve the revising relation @xmath55 .",
    "we now characterize those combinations of @xmath17 and @xmath55 that avoid all ( or only hidden ) conflicts .",
    "[ def : compat ] a preference relation @xmath17 is _ compatible _ ( resp .",
    "_ semi - compatible _ ) with a preference relation @xmath55 if there are no conflicts ( resp",
    ". no hidden conflicts ) between @xmath17 and @xmath55 .",
    "compatibility is symmetric and implies semi - compatibility for spos .",
    "semi - compatibility is not necessarily symmetric .",
    "examples [ ex : car ] and [ ex : car:1 ] show a pair of compatible relations .",
    "the compatibility of @xmath17 and @xmath55 _ does not require _ the acyclicity of @xmath85 or that one of the following hold : @xmath86 , @xmath87 , or @xmath88 .",
    "for the former , consider @xmath89 and @xmath90 .",
    "for the latter , consider @xmath64 and @xmath91 .",
    "all the properties listed above , including both variants of compatibility , are decidable for equality or rational order ipfs . for example , semi - compatibility is expressed by the condition @xmath92 where @xmath93 is the inverse of the preference relation @xmath17 .",
    "we prove now a number of results that characterize refinement and overriding revisions of of preference relations .",
    "the results are of the form :    _ given that the original preference relation @xmath17 and the revising relation @xmath55 satisfy certain order axioms , what kind of order axioms does the revision @xmath56 satisfy ? _    to capture minimal change of preferences , we typically study _ least _ revisions . the revision setting helps to overcome the limitations of _ preference composition _",
    "@xcite where it is shown that common classes of orders ( spos , weak orders ) are often not closed w.r.t . basic preference composition operators like union or prioritized composition . in the results that follow , we obtain closure under least revisions thanks to ( 1 ) restricting @xmath17 and @xmath55 , and ( 2 ) guaranteeing transitivity by explicitly applying transitive closure where necessary .",
    "[ lem : equiv ] for compatible @xmath17 and @xmath55 , @xmath94    [ lem : basic ] the preference relation @xmath95 ( resp .",
    "@xmath96 ) is contained in every refinement ( resp .",
    "overriding revision ) of @xmath57 with @xmath55 and is , therefore , the least refinement ( resp .",
    "least overriding revision ) of @xmath57 with @xmath55 .",
    "[ lem : tc ] the preference relation @xmath97 ( resp .",
    "@xmath98 ) is contained in every transitive refinement ( resp .",
    "every overriding revision ) of @xmath57 with @xmath55 and is , therefore , the least transitive refinement ( resp . least transitive overriding revision ) of @xmath57 with @xmath55 .",
    "spos have several important properties from the user s point of view , and thus their preservation is desirable .",
    "for instance , all the preference relations defined in @xcite and the language preference sql @xcite are spos . moreover ,",
    "if @xmath17 is an spo , then the winnow @xmath99 is nonempty if ( a finite ) @xmath51 is nonempty .",
    "also , the fundamental algorithms for computing winnow require that the preference relation be an spo @xcite .    in order to obtain the least spo revisions",
    ", we have to make sure that @xmath97 and @xmath100 are irreflexive ( they are transitive by definition ) .",
    "an spo has the _ single - chain property _ ( scp ) if it has at most one maximal chain ( maximal totally - ordered subset ) having at least two elements .",
    "such a chain is called a _",
    "superchain_.    the superchain in the above definition does not have to exhaust all the elements of the domain , so an order having scp does not have to be total or even weak .    [",
    "th : spo : union ] for every compatible preference relations @xmath17 and @xmath55 such that both are spos and at least one has scp , the preference relation @xmath101 is the least spo refinement of @xmath57 with @xmath55 .",
    "( sketch ) assume @xmath17 has scp .",
    "if @xmath101 is not irreflexive , then @xmath95 has a cycle .",
    "consider such cycle of minimum length .",
    "it consists of alternating @xmath55- and @xmath17-edges ( otherwise it can be shortened ) .",
    "if there is more than one @xmath17-edge in the cycle , then one of the assumptions is violated .",
    "so the cycle consists of two edges : @xmath72 and @xmath102 .",
    "but this is a conflict violating compatibility .",
    "[ ex : car:3 ] consider again the preference relation @xmath1 : @xmath2 suppose that the new preference information is captured as @xmath103 which is a single - chain spo : @xmath104 then @xmath105 is defined as the spo @xmath106 : @xmath107    one can find examples where scp or the compatibility of @xmath17 and @xmath55 is violated , and a cycle in @xmath95 is obtained .    for dealing with overriding revisions compatibility can be replaced by a less restrictive condition , _ semi - compatibility _ , because prioritized composition already provides a way of resolving some conflicts .",
    "[ th : spo : priority ] for every preference relations @xmath17 and @xmath55 such that both are spos , @xmath55 has scp and @xmath17 is semi - compatible with @xmath55 , the preference relation @xmath98 is the least spo overriding revision of @xmath57 with @xmath55 .",
    "( sketch ) we assume that @xmath98 is not irreflexive and consider a cycle of minimum length in @xmath96 . this cycle has to consist of an edge @xmath72 and a number of @xmath17-edges @xmath108 such that @xmath109 .",
    "( here we can not shorten sequences of consecutive @xmath17-edges because @xmath17 is not necessarily preserved in @xmath96 . )",
    "we have that @xmath110 .",
    "thus @xmath71 is a hidden conflict violating the semi - compatibility of @xmath17 with @xmath55 .",
    "again , violating any of the conditions of theorem [ th : spo : priority ] may lead to a situation in which no spo overriding revision exists .",
    "[ prop : terminate ] for the preference relations defined using equality or rational order ipfs , the computation of and terminates .",
    "the computation of transitive closure is done in a completely database - independent way using constraint datalog techniques @xcite .",
    "[ ex : car:4 ] consider examples [ ex : car ] and [ ex : car:3 ] .",
    "we can infer that @xmath111 because @xmath112 @xmath113 and @xmath114 the tuples @xmath115 and @xmath116 are _ not _ in the database .",
    "weak partial orders are practically important because they capture the situation where the domain can be decomposed into layers such that the layers are totally ordered and all the elements in one layer are mutually indifferent .",
    "this is the case , for example , if the preference relation can be represented using a numeric utility function .",
    "if the preference relation is a weak order , a particularly efficient ( essentially single pass ) algorithm for computing winnow is applicable @xcite .",
    "we first consider combinations of spos and weak orders .",
    "[ th : spo : weak ] for every compatible preference relations @xmath17 and @xmath55 such that one is an spo and the other a weak order , the preference relation @xmath117 is the least spo refinement of @xmath57 with @xmath55 .    in the context of overriding revisions ,",
    "the requirement of compatibility becomes unnecessary .",
    "[ th : spo : weak : priority ] for every preference relations @xmath55 and @xmath17 such that @xmath55 is a weak order and @xmath17 an spo , the preference relation @xmath96 is the least spo overriding revision of @xmath57 with @xmath55 .",
    "we consider now combinations of weak orders .",
    "[ th : weak : weak ] for every compatible weak order preference relations @xmath17 and @xmath55 , @xmath117 is the least weak order refinement of @xmath57 with @xmath55 .",
    "again , for overriding revisions , we can relax the compatibility assumption .",
    "this immediately follows from the fact that weak orders are closed with respect to prioritized composition @xcite .",
    "[ prop : weak : weak : priority ] for every weak order preference relations @xmath17 and @xmath55 , the preference relation @xmath96 is the least weak order overriding revision of @xmath57 with @xmath58 .",
    "a basic notion in utility theory is that of _ representability _ of preference relations using numeric utility functions :    [ def : represent ] a real - valued function @xmath118 over a schema @xmath18 _ represents _ a preference relation @xmath17 over @xmath18 iff @xmath119.\\ ] ]    being a weak order is a necessary condition for the existence of a numeric representation for a preference relation .",
    "however , it is not sufficient for uncountable orders @xcite .",
    "it is natural to ask whether the existence of numeric representations for the preference relations @xmath17 and @xmath55 implies the existence of such a representation for the least refinement @xmath120 .",
    "this is indeed the case .",
    "[ th : utility ] assume that @xmath17 and @xmath121 are weak order preference relations such that    1 .",
    "@xmath17 and @xmath121 are compatible , 2 .",
    "@xmath17 can be represented using a real - valued function @xmath118 , 3 .",
    "@xmath121 can be represented using a real - valued function @xmath122 .",
    "then @xmath123 is a weak order preference relation that can be represented using any real - valued function @xmath124 such that for all @xmath32 , @xmath125 where @xmath126 .",
    "surprisingly , the compatibility requirement can not in general be replaced by semi - compatibility if we replace @xmath127 by @xmath128 in theorem [ th : utility ] .",
    "this follows from the fact that the lexicographic composition of one - dimensional standard orders over @xmath129 is not representable using a utility function @xcite .",
    "thus , preservation of _ representability _ is possible only under compatibility , in which case @xmath130 ( lemma [ lem : equiv ] ) and the revision is monotonic .",
    "it is an open question whether representability can be preserved under nonmonotonic revisions .",
    "we conclude this section by showing a general scenario in which the refinement of weak orders occurs in a natural way .",
    "assume that we have a numeric utility function @xmath118 representing a ( weak order ) preference relation @xmath17 .",
    "the indifference relation @xmath37 generated by @xmath17 is defined as : @xmath131",
    "suppose that the user discovers that @xmath37 is too coarse and needs to be further refined .",
    "this may occur , for example , when @xmath32 and @xmath33 are tuples and the function @xmath118 takes into account only some of their components .",
    "another function @xmath132 may be defined to take into account other components of @xmath32 and @xmath33 ( such components are called _ hidden attributes",
    "_ @xcite ) .",
    "the revising preference relation @xmath55 is now : @xmath133 it is easy to see that @xmath55 is an spo compatible with @xmath17 but not necessarily a weak order .",
    "therefore , by theorem [ th : spo : weak ] the preference relation @xmath134 is the least spo refinement of @xmath17 with @xmath55 .",
    "if none of the results described so far implies that the least transitive refinement of @xmath17 with @xmath55 is an spo , then this condition can often be explicitly checked .",
    "specifically , one has to : ( 1 ) compute the transitive closure @xmath97 , and ( 2 ) check whether the obtained relation is irreflexive .    from proposition [ prop :",
    "terminate ] , it follows that for equality and rational order ipfs the computation of @xmath97 yields some finite ipf @xmath24",
    ". then the second step reduces to checking whether @xmath135 is unsatisfiable , which is a decidable problem for equality and rational order ipfs .",
    "[ ex : car:2 ] consider examples [ ex : car ] and [ ex : car:1 ] .",
    "neither of the preference relations @xmath1 and @xmath8 is a weak order or has scp .",
    "therefore , the results established earlier in this paper do not apply .",
    "the preference relation @xmath136 is defined as follows : @xmath137 the preference relation @xmath138 is irreflexive .",
    "it also properly contains @xmath139 , because @xmath140 but @xmath141 and @xmath142 .",
    "the query @xmath143 evaluated in the instance @xmath4 ( figure [ fig : car ] ) returns only the tuple @xmath38 .",
    "similar considerations apply to overriding revisions and weak orders .",
    "consider the scenario in which we iterate monotonic preference revision to obtain a sequence of preference relations @xmath144 such that each is an spo and @xmath145 .",
    "( recall that refinement is monotonic but overriding revision not necessarily so . )",
    "assume that those relations are used to extract the best tuples from a fixed relation instance @xmath51 .",
    "such evaluation provides feedback to the user about the quality of the given preference relation and may be helpful in constructing its subsequent refinements .    in this scenario ,",
    "the sequence of query results is : @xmath146    proposition [ prop : contain ] below implies that the sequence @xmath147 is decreasing : @xmath148 and that it can be computed incrementally : @xmath149 to compute @xmath150 , there is no need to look at the tuples in nor to recompute winnow from scratch .",
    "the sets of tuples @xmath151 are likely to have much smaller cardinality than @xmath152 .",
    "@xcite[prop : contain ] if @xmath153 and @xmath154 are preference relations over a relation schema @xmath18 and , then for all instances @xmath51 of @xmath18 :    * @xmath155 * @xmath156 if @xmath45 and @xmath62 are spos .",
    "cp - nets @xcite are an influential recent formalism for reasoning with conditional preference statements under _ ceteris paribus _ semantics ( such semantics is also adopted in other work @xcite ) . we conjecture that cp - nets can be expressed in the framework of preference relations of @xcite , used in the present paper , by making the semantics explicit",
    ". if the conjecture is true , the results of the present paper will be relevant to revision of cp - nets .",
    "the cp - net where @xmath69 and @xmath70 are boolean variables , captures the following preferences : ( 1 ) prefer @xmath69 to @xmath157 , all else being equal ; ( 2 ) if @xmath69 , prefer @xmath70 to @xmath158 ; ( 3 ) if @xmath157 , prefer @xmath158 to @xmath70 .",
    "we construct a preference relation @xmath159 between worlds , i.e. , boolean valuations of @xmath69 and @xmath70 : @xmath160 finally , the semantics of the cp - net is fully captured as the transitive closure @xmath161 .",
    "such closure can be computed using constraint datalog with boolean constraints @xcite .",
    "cp - nets and related formalisms can not express preference relations over infinite domains which are essential in database applications .",
    "@xcite formulates different scenarios of preference revision and does not contain any formal framework .",
    "@xcite describes minimal change revision of _ rational _ preference relations between propositional formulas .",
    "we are not aware of any work on revising infinite preference relations .",
    "we have presented a general framework for revising preference relations and established a number of order axiom preservation results for specific classes of revisions . in the future",
    ", we plan to consider more general classes of revisions and databases with restricted domains , e.g. , boolean .",
    "another direction is the design of a _ revision language _ in which different parameters of preference revision can be explicitly specified by the user .",
    "connections to _ iterated belief revision _",
    "@xcite should also be explored .",
    "grdenfors , p. , and rott , h. 1995 . .",
    "in gabbay , d.  m. ; hogger , c , j. ; and robinson , j.  a. , eds . , _ handbook of logic in artificial intelligence and logic programming _ , volume  4 .",
    "oxford university press ."
  ],
  "abstract_text": [
    "<S> we study here preference revision , considering both the _ monotonic _ case where the original preferences are preserved and the _ nonmonotonic _ case where the new preferences may override the original ones . </S>",
    "<S> we use a relational framework in which preferences are represented using binary relations ( not necessarily finite ) . </S>",
    "<S> we identify several classes of revisions that preserve order axioms , for example the axioms of strict partial or weak orders . </S>",
    "<S> we consider applications of our results to preference querying in relational databases . </S>"
  ]
}