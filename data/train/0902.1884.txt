{
  "article_text": [
    "dynamic scheduling is the preferred method for solving load imbalance problems with shared memory parallelization .",
    "the openmp standard provides the ` dynamic ` and ` guided ` schedulings for worksharing loops , and the ` task ` construct for task - based parallelism .",
    "if the additional overhead for dynamic scheduling is negligible for the application at hand , these approaches are ideal on uma ( uniform memory access ) systems like the now outdated single - core multi - socket smp nodes , or multi - core chips with `` isotropic '' caches , i.e.  where each cache level is either exclusive to one core or shared among all cores on a chip .    if , however , data access locality is important for performance and scalability , dynamic scheduling of any kind is usually ruled out .",
    "the most prominent example are memory - bound applications on ccnuma - type systems : even if memory pages are carefully placed into the numa domains by parallel first - touch initialization , peak memory bandwidth can not be reached if cores access the numa domains in a random manner , although this is still far better than serial initialization if there are no other choices .    as a simple benchmark we choose a 3d six - point jacobi solver with constant coefficients as recently studied extensively by datta et al .",
    "the site update function , @xmath0~,\\end{aligned}\\ ] ] is evaluated for each lattice site in a 3d loop nest , and the memory layout is chosen so that @xmath1 is the fast index . each site update ( in",
    "the following called `` lup '' ) incurs seven loads and one store , of which , at large problem sizes , one load and one store cause main memory traffic if suitable spatial blocking is applied .",
    "this leads to a code balance of 3 bytes per flop ( assuming that non - temporal stores are not used so that a store miss causes a cache line read for ownership ) , so the code is clearly memory - bound on all current cache - based architectures . in what follows we use a problem size of @xmath2 sites ( @xmath33.25gib of memory for double precision variables ) and a block size of 600@xmath410@xmath410 ( @xmath5@xmath4@xmath6@xmath4@xmath7 ) sites , unless otherwise noted .",
    "the update loop nest iterates over all blocks in turn , and standard worksharing loop parallelization is done over the outer ( @xmath8-blocking ) loop ( initialization is performed via the identical scheme ) :    .... # pragma omp parallel for schedule(runtime )    for(int kb=0 ; kb < number_of_k_blocks ; + + kb ) {      for(int jb=0 ; jb < number_of_j_blocks ; + + jb ) {        for(int ib=0 ; ib < number_of_i_blocks ; + + ib ) {          jacobi_sweep_block(ib , jb , kb ) ;    } } } ....    note that with the standard ` i ` block size equal to the extent of the lattice in that direction ( which is required to make best use of the hardware prefetching capabilities on the processors used ) , ` number_of_i_blocks ` is equal to one .",
    "the ` jacobi_sweep_block ( ) ` function performs one jacobi sweep , i.e.  one update per lattice site , over all sites in the block determined by its parameters . in case of dynamic loop scheduling , parallel first - touch initialization is done via a ` static,1 ` ( round robin ) loop schedule , whereas plain ` static ` scheduling is used otherwise .",
    "[ fig : umavsnuma ] illustrates the impact of dynamic scheduling on the solver s scalability for two benchmark systems :    * `` dunnington '' is an ea intel uma server system ( `` caneland '' chipset ) with four six - core intel xeon 7460 processor chips at 2.66ghz .",
    "data for this system is included for illustrative purposes . *",
    "`` opteron '' is an hp dl585 g5 ccnuma server with four locality domains ( lds ) , one per socket , and four dual - core amd opteron 8220 se processor chips at 2.8ghz .",
    "the processors are connected via hypertransport 1.0ghz links ( 4gb / s per direction ) .",
    "both systems ran current linux kernels , and the intel c++ compiler , version 11.0.074 was used for all benchmarks .",
    "as we are mostly interested in scalability data , detailed performance characteristics for the platforms under consideration are omitted .",
    "one should note , however , that there is significant optimization potential in stencil codes like the one we use here .",
    "the block size we have chosen is close to optimal from a data transfer perspective @xcite , and the performance data obtained is in line with stream copy scalability on the same systems . in all cases ,",
    "the number of threads per socket was chosen so that the local memory bus could be saturated , which happens to be the case for two threads on both platforms .",
    "core - thread affinity was enforced by overloading the ` pthread_create ( ) ` call and using ` sched_setaffinity ( ) ` in turn for each newly created thread , skipping the openmp shepherd thread(s ) .",
    "peformance in million lattice site updates per second ( mlup / s ) versus number of sockets for an openmp parallel 6-point stencil solver on a uma ( solid bars ) and a ccnuma ( hatched bars ) system , using standard worksharing loop parallelization(see text for details ) .",
    "`` parinit '' denotes parallel first - touch data initialization .",
    "the `` ld0 '' data set was obtained by forcing all memory pages to reside in locality domain 0.,scaledwidth=75.0% ]    parallel efficiency @xmath9 versus number of sockets for the same data sets as in fig .",
    "[ fig : umavsnuma].,scaledwidth=75.0% ]    the performance results and parallel efficiency numbers in figs .",
    "[ fig : umavsnuma ] and [ fig : umavsnuma - e ] show that dynamic scheduling has negligible impact on the uma system for the chosen problem and block sizes , although one may of course expect a noticeable performance hit if openmp startup and scheduling overhead become dominant with small data sets and block sizes . if static scheduling and proper parallel initialization are employed , the ccnuma system shows similar characteristics as the uma node ( bandwidth scalability with four sockets is not ideal for current opteron - based systems because of protocol overhead ) .",
    "dynamic scheduling , however , has a catastrophic effect on parallel efficiency as remote accesses and contention on the hypertransport network dominate performance .",
    "moreover , there is a noticeable statistical performance variation because access patterns vary from sweep to sweep .",
    "nevertheless , due to the round - robin page placement as described above , there is still some parallelism available .",
    "if we force all memory pages to be mapped in the first locality domain ( ld0 ) , all parallelism is lost and performance is limited by the single - domain memory bandwidth , which is already saturated with the two local threads .",
    "execution is hence serialized .",
    "in contrast to standard worksharing loop parallelization , tasking in openmp requires to split the problem into a number of work `` packages '' , called _ tasks _ , each of which must be submitted to an internal pool by the ` omp task ` directive . for the jacobi solver we define one task to be a single block of the size specified above .",
    "this is in contrast to loop worksharing where one parallelized outer loop iteration consisted of all blocks with the same ` kb ` coordinate .",
    "using the ` collapse ` clause on the parallel loop nest would correct this discrepancy , but there is no further insight gained .",
    "the tasks are produced ( submitted ) by a single thread and consumed by all threads and in a 3d loop nest :    .... # pragma omp parallel {    # pragma omp single    {      for(int kb=0 ; kb < number_of_k_blocks ; + + kb ) {        for(int jb=0 ; jb < number_of_j_blocks ; + + jb ) {           for(int ib=0 ; ib < number_of_i_blocks ; + + ib )   {            # pragma omp task              jacobi_sweep_block(ib , jb , kb ) ;      } } }    } } ....    submitting the tasks in parallel is possible but did not make any difference in the parameter ranges considered here ( but see below for the impact of submission order ) .",
    "there is still a choice as to how first - touch initialization should be performed , so we compare ` static ` and ` static,1 ` scheduling for loop initialization .",
    ".[tab : tvsq]performance of the jacobi solver in mlup / s on 8 threads of the opteron ( ccnuma ) platform with two different schedulings for the block initialization loop ( rows ) , comparing standard tasking and tasking with locality queues , and the two possible choices for the submit loop nest order . [ cols=\"<,^,^,^,^ \" , ]     table [ tab : tvsq ] shows performance results ( columns labeled `` tasking '' ) on the ccnuma platform , using eight threads and two different loop orderings for the submission loop . with static initialization and the standard ` kji ` loop order as shown above , performance is roughly equal to the results obtained in the previous section with ld0 enforcement ( `` opteron static ld0 '' data in figs .  [ fig : umavsnuma ] and [ fig : umavsnuma - e ] ) , i.e.   execution is serialized .",
    "performance is slightly improved to roughly the 4-thread dynamic scheduling level ( `` opteron dynamic parinit '' data for two sockets in fig .  [ fig : umavsnuma ] ) by choosing the ` jki ` loop order for submission .",
    "going to ` static,1 ` initialization , the 8-thread dynamic scheduling performance can be matched .",
    "the large impact of submit and initialization orders can be explained by assuming that there is only a limited number of `` queued '' , i.e.unprocessed tasks allowed at any time . in the course of executing the submission loop",
    ", this limit is reached very quickly and the submitting thread is used for processing tasks for some time . from our measurements ,",
    "the limit is equal to 257 tasks with the compiler used .",
    "one ` ib`-`jb ` layer of our grid comprises 60 tasks ( with the chosen problem and block sizes ) , and 60 layers are available , which amounts to 3600 tasks in total . with static scheduling , one block of 257 consecutive tasks is usually associated with a single locality domain ( rarely two ) , hence the serialization of memory access .",
    "choosing ` static,1 ` scheduling for initialization , each consecutive layer is placed into a different locality domain , but 257 tasks comprise only slightly more than four layers . assuming that the order of execution for tasks resembles ` static,1 ` loop workshare scheduling because each thread is served a task in turn , the number of lds to be accessed in parallel is limited ( although it is hard to predict the actual level of parallelism ) . finally , by choosing the ` jki ` submission loop order , consecutive tasks cycle through locality domains , and parallelism is as expected from dynamic loop scheduling .",
    "the statistical variation is surprisingly small , however .",
    "these observations document that it is nontrivial to employ tasking on ccnuma systems and reach at least the performance level of standard dynamic loop scheduling . in the next section",
    "we will demonstrate how task scheduling under locality constraints can be optimized by substituting part of the openmp scheduler by user program logic .",
    "each task , which equals one lattice block ( or tile ) in our case , is associated with a c++ object ( of type ` blockobject ` ) and equipped with an integer locality variable which denotes the locality domain it was placed in upon initialization .",
    "the submission loop now takes the following form :    .... # pragma omp parallel {    # pragma omp single    {      for(int kb=0 ; kb < number_of_k_blocks ; + + kb ) {        for(int jb=0 ; jb < number_of_j_blocks ; + + jb ) {           for(int ib=0 ; ib < number_of_i_blocks ; + + ib )   {            blockobject p(kb , jb , ib ) ;",
    "queues[p.locality()].enqueue(p ) ;            # pragma omp task              process_block_from_queue(queues ) ;      } } }    } } ....    the ` queues ` object is basically a ` std::vector < > ` of ` std::queue < > ` objects , each associated with one locality domain , and each protected from concurrent access with an openmp lock .",
    "calling the ` enqueue ( ) ` method of a queue appends a block object to it .",
    "as shown above , blocks are sorted into those _ locality queues _ according to their respective locality variables .",
    "one openmp task , executed by the ` process_block_from_queue ( ) ` function , now consists of two parts :    1 .   figuring out which ld the executing thread belongs to 2 .",
    "dequeuing the oldest waiting block in the locality queue belonging to this domain and calling ` jacobi_sweep_block ( ) ` for it    if the local queue of a thread is empty , other queues are tried in a spin loop until a block is found :    .... void process_block_from_queue(localityqueues & queues ) {    // ...    bool found = false ;    blockobject p ;    int ld = ld_id[omp_get_thread_num ( ) ] ;    while ( ! found ) {      found = queues[ld].dequeue(p ) ;      if ( ! found ) {        ld = ( ld + 1 ) % num_of_lds ;      }    }    jacobi_sweep_block(p.ib , p.jb , p.kb ) ; } ....    the global ` ld_id ` vector must be preset with a correct thread - to - ld mapping .",
    "enqueuing and dequeuing blocks from a queue is made thread - safe by protecting the queue with an openmp lock .",
    "note that scanning other queues if a thread s local queue is empty gives load balancing priority over strict access locality , which may or may not be desirable depending on the application .",
    "the team of threads in one locality domain shares one queue , so scheduling is purely dynamic in that case .",
    "there is actually a `` race condition '' with the described scheme because it is possible that some task executes a block just queued before the corresponding task is actually submitted .",
    "this is however not a problem because the number of submitted tasks is always equal to the number of queued blocks , and no task will ever be left waiting for new blocks forever .",
    "table [ tab : tvsq ] shows performance results for eight threads with four locality queues under the columns labeled `` tasking + queues '' . for ` static ` initialization and the ` kji ` submission order , the limited overall number of waiting tasks has the same consequences as with plain tasking ( see sect .",
    "[ sec : tasking ] ) . in this case",
    ", although the queuing mechanism is in effect , a single queue holds most of the tasks at any point in time .",
    "all threads are served from this queue and thus execute in a single ld . however , using the alternate ` jki ` submission order or ` static,1 ` initialization , all queues are fed in parallel and threads can be served tasks from their local queue .",
    "performance then comes close to static scheduling within a 10% margin ( see fig .  [",
    "fig : umavsnuma ] ) .",
    "one should note that a similar effect could have been achieved with nested parallelism , using one thread per ld in the outer parallel region and several threads ( one per core ) in the nested region .",
    "however , we believe our approach to be more powerful and easier to apply if properly wrapped into c++ logic that takes care of affinity and work distribution . moreover , the thread pooling strategies employed by many current compilers inhibit sensible affinity mechanisms when using nested openmp constructs .",
    "we have demonstrated how locality queues can be employed to optimize parallel memory access on ccnuma systems when openmp tasking is used .",
    "locality queues substitute the uncontrolled , dynamic task scheduling by a static and a dynamic part .",
    "the latter is mostly restricted to the cores in one numa domain , providing full dynamic load balancing on the ld level .",
    "scheduling between domains is static , but load balancing can be given priority over strictly local access .",
    "the larger the number of threads per ld , the more dynamic the task distribution , so our scheme will get more interesting in view of future many - core processors .    using locality queues to optimize real applications on ccnuma systems",
    "is under investigation , as well as a study of possible additional overhead of the method for `` small '' tasks .",
    "the same methodology may also be applied for optimizing ` parallel_while ` constructs in intel threading building blocks ( tbb , @xcite ) .",
    "further potentials , not restricted to ccnuma architectures , may be found in the possibility to implement temporal blocking ( doing more than one time step on a block to reduce pressure on the memory subsystem @xcite ) by associating one locality queue to a number of cores that share a cache level . as an advantage over static temporal blocking , no frequent global barriers would be required .",
    "xx k.  datta , m.  murphy , v.  volkov , s.  williams , j.  carter , l.  oliker , d.  patterson , j.  shalf , and k.  yelick : stencil computation optimization and autotuning on state - of - the - art multicore architectures .",
    "proceedings of sc08 , austin , tx , nov .  1521 , 2008 . h.  stengel : c++ programming techniques for high performance computing on systems with non - uniform memory access using openmp .",
    "diploma thesis , university of applied sciences nuremberg , 2007 ( in german ) .",
    "j.  reinders : intel threading building blocks .",
    "oreilly , 2007 .",
    "t. zeiser , g. wellein , a. nitsure , k. iglberger , u. rde and g. hager : introducing a parallel cache oblivious blocking approach for the lattice boltzmann method .",
    "progress in computational fluid dynamics , an int .",
    "j. vol . 8 , no.1/2/3/4 ( 2008 ) 179188 ."
  ],
  "abstract_text": [
    "<S> task parallelism as employed by the openmp ` task ` construct , although ideal for tackling irregular problems or typical producer / consumer schemes , bears some potential for performance bottlenecks if locality of data access is important , which is typically the case for memory - bound code on ccnuma systems . </S>",
    "<S> we present a programming technique which ameliorates adverse effects of dynamic task distribution by sorting tasks into locality queues , each of which is preferably processed by threads that belong to the same locality domain . </S>",
    "<S> dynamic scheduling is fully preserved inside each domain , and is preferred over possible load imbalance even if non - local access is required . </S>",
    "<S> the effectiveness of the approach is demonstrated using a blocked six - point stencil solver as a toy model . </S>"
  ]
}