{
  "article_text": [
    "in @xcite , floess et al . studied the juntas using the quantum bernstein - vazirani algorithm , and they proved that using the bernstein - vazirani circuit to a boolean function @xmath2 that has nothing to do with a variable @xmath3 would always obtain the output @xmath7 with @xmath8 . in this paper",
    ", we will generalize it to the result that the number of ones in each position @xmath6 of the outputs relates to the influence of @xmath3 on @xmath0 , and our result will contain the one in @xcite .    during the last thirty years , there were a lot of researches about the influences of variables on boolean functions . in @xcite , the authors transformed randomized algorithms to the processors of flipping the coin . in order that a single processor does not control the global bit , it must have a boolean function that every variable has a little influence .",
    "hatami @xcite pointed out that the influence of a variable on a boolean function appears in various contexts such as probability theory , computer science and statistical physics , and boolean functions with small total influences are in close touch with threshold phenomenon . in @xcite , kahn et al . introduced harmonic analysis methods on boolean functions for the first time , proved a so called kkl inequality to give a lower bound on total influences .",
    "the kkl inequality now is usually used to estimate some bounds @xcite .",
    "similar to @xcite , our algorithms will be based on the bernstein - vazirani algorithm @xcite , which has the same circuit as the deutsch - jozsa algorithm @xcite . and based on cavity qed , some schemes have been proposed to realize deutsch - jozsa algorithm @xcite .    in this paper",
    ", we begin with some preliminaries .",
    "next , we give a theorem about the influence of a variable of a boolean function and the gains after running the bernstein - vazirani algorithm . based on this",
    ", we propose a quantum approximation algorithm to evaluate the influence , and finally we exploit the above result to the learning of juntas .",
    "* definition 1*let @xmath9 be a boolean function , @xmath10 $ ] , @xmath11 , and all the coordinates of @xmath12 are @xmath5 except the @xmath6th one . for any event @xmath13",
    ", @xmath14 denotes the probability of @xmath13 happening . for any set @xmath15",
    ", @xmath16 denotes the cardinality of @xmath15 . _",
    "the influence of a variable @xmath3 on the function @xmath0 _ is defined as @xmath17=\\frac{|\\{x|f(x\\oplus \\alpha^i)\\neq f(x)\\}|}{2^n},\\ ] ] where @xmath18 denotes bitwise exclusive - or .    *",
    "definition 2*for any boolean function @xmath0 , we define the _",
    "walsh transform _ of it by @xmath19 where @xmath20 .      for any boolean function @xmath0 ,",
    "define the @xmath21 gate as @xmath22 where @xmath23 , @xmath24 , and the addition is modulo 2 .",
    "applying @xmath1 hadamard gates to @xmath25 obtains @xmath26    now , begin with the initial state @xmath27 , do the following @xmath28 discarding the last qubit . if @xmath29 , @xmath30 , we just get @xmath31 , and if we measure in the computational basis , we will get @xmath32 . if @xmath33 is not a linear function , from and , the output is actually @xmath34 this time if we measure in the computational basis , we will get @xmath4 with probability @xmath35",
    ". we will always use @xmath36 to denote the result after running the bernstein - vazirani algorithm in this paper .      if @xmath37 are independent random variables and @xmath38 then for @xmath39 @xmath40 where @xmath41 is the expected value of the random variable @xmath42 .",
    "* theorem 1*for any boolean function @xmath0 , @xmath43    kahn et al . and",
    "odonnell have given an expression between the influence of a variable on a boolean function @xmath0 and the fourier transform of @xmath0 in @xcite and @xcite , where the fourier transform of @xmath0 is @xmath44 .",
    "we changed it a little so that we could use the bernstein - vazirani algorithm to evaluate the influence .",
    "+ _ proof _ ( we ll use a method similar to @xcite and @xcite to complete the proof . )",
    "first , let @xmath45 @xmath46 eq .",
    "is substituted in eq .",
    ", @xmath47 therefore , @xmath48 thus , we can have @xmath49 on the other hand , @xmath50 and from and , we have @xmath51 in addition , by parseval s relation , we have @xmath52 combining and , we can obtain @xmath53 by definition 1 we have @xmath54 , henceforth @xmath55    from theorem 1 , we immediately have the following .    * theorem 2*using the bernstein - vazirani circuit once to a boolean function @xmath0 , the probability of find the one in a position @xmath6 ( i.e. @xmath56 ) is identical to the influence of @xmath3 on @xmath0 .",
    "specially , if @xmath0 is independent of @xmath3 , we will always find @xmath8 ; if @xmath57 , we will always find @xmath56 .",
    "+ _ proof _ according to , if we measure in the computational basis , we will get @xmath4 with probability @xmath35 .",
    "so the probability we get @xmath56 is @xmath58 where the second equal comes from .",
    "meanwhile , the probability we get @xmath8 is @xmath59 specially , if @xmath0 is independent of @xmath3 , i.e. @xmath60 , then by and , @xmath61 and @xmath62 .",
    "consequently , we can not get @xmath4 with @xmath56 , we will always find @xmath4 with @xmath8 .",
    "if @xmath57 , by and , the probability we get @xmath56 is 1 , we will always find @xmath4 with @xmath56 .    * remark * _ _ theorems 1 and 2 _ _ conclude _ theorems 3.1 and 3.2 _ in @xcite as a special case . in other words ,",
    "_ theorems 1 and 2 _ generalize _ theorems 3.1 and 3.2 _ in @xcite separately .",
    "now , we will give our algorithm .",
    "given an oracle to a boolean function @xmath0 , our algorithm will run in polynomial times , and output the approximate value of @xmath63 for every @xmath64 $ ] .",
    "* algorithm 1 *    1.run the bernstein - vazirani circuit for the function @xmath0 @xmath65 ( @xmath65 is a positive integer independent of @xmath1 ) times .",
    "let @xmath66 be the outputs .",
    "2.for any fixed @xmath67 $ ] , count the total number of ones in @xmath68 , and denote it by @xmath69 .",
    "3.compute @xmath70 and output it .",
    "then by _ theorem 2 _ , @xmath71 where @xmath72 is an abbreviation for be approximately equal to . and the total influence of all variables on @xmath0 is @xmath73 from this we can know some properties about influence , such as which variables have influences more than 0 , whether every variable has a little influence or not , whether the total influence is small or not , and so on .      what is the error scope of @xmath63 that we just compute through the above method ?",
    "in other words , what s the distance of @xmath74 and @xmath63 ?    * theorem 3*@xmath75 , we have @xmath76 _ proof _ for any @xmath67 $ ] , let @xmath77 be a random variables such that @xmath78 where @xmath79 is the @xmath6th coordinate of the @xmath4 measured .",
    "then by the theorem 2 , @xmath80=i_f(i).\\ ] ] running the bernstein - vazirani algorithm @xmath65 times corresponds to @xmath65 independent identical distributed random variables @xmath81 , @xmath82 $ ] . by the hoeffding s inequality , @xmath83 from the second step of the algorithm , we know @xmath84 , i.e. holds .",
    "* theorem 4*running the algorithm 1 can give a list of variables which satisfies    1.any variable @xmath3 on the list has the influence @xmath85 ;    2.the probability of any variable @xmath3 with @xmath86 appearing on the list is at least @xmath87 ( where @xmath88 is a constant ) .",
    "+ _ proof _ run the algorithm 1 , if @xmath89 , then output @xmath3 .",
    "this gives a list of @xmath3 , we will show the list satisfies the conditions 1 and 2 .    by _ theorem 2 _ ,",
    "if @xmath60 , we will find @xmath90 , @xmath3 can not be on the list .",
    "so it must be @xmath85 for every @xmath3 on the list .    for @xmath86 , when we run the bernstein - vazirani algorithm once ,",
    "the probability of getting @xmath56 is at least @xmath91 , so the probability of getting @xmath8 is at most @xmath92 .",
    "therefore , the probability of always getting @xmath8 in step 1 is at most @xmath93 so the probability of getting @xmath89 in step 2 is at least @xmath94      in the classical probabilistic turing model , if we want to evaluate @xmath63 for arbitrary @xmath67 $ ] , we should randomly choose a set @xmath95 , and then compute @xmath96 to get a rough estimate , since by _ definition 1 _ , @xmath97 .",
    "we define a random variable @xmath98 , @xmath99 suppose @xmath100 , then similarly to _ theorem 3 _ , we can get @xmath101 from the above , we can see that for any fixed @xmath67 $ ] , the classical algorithm can obtain the same accuracy degree as the quantum algorithm .",
    "however , running the quantum algorithm 1 can get the influences of all variables on the function , while the classical algorithm can only get one of it .",
    "so our quantum algorithm gains an @xmath102 times speedup over the classical one .",
    "recall that a junta is a boolean function that only depend on at most @xmath103 out of @xmath1 variables , where @xmath104 . from _",
    "theorem 2 _ , the probability of finding the one in the algorithm is only relevant to the influence of the variable , which is entirely unrelated to @xmath103 and @xmath1 .",
    "so we can use the above quantum algorithm to learn juntas . in @xcite , floess et al . examined the quadratic and cubic functions , and gave deterministic quantum algorithms for these functions .",
    "they expected to devise probabilistic quantum algorithms .",
    "now , we will complete this work based on the above results of _ theorems 2 and 3_. before doing this , we need the following lemma .",
    "* lemma 1*if @xmath33 is of the form @xmath105),\\ ] ] then @xmath106,\\\\ 0 & i\\in[n]-[r ] .",
    "\\end{cases}\\ ] ] _ proof _ for @xmath67-[r]$ ] , from , the expression of @xmath0 does not contain @xmath3 for such @xmath6 , so @xmath107 for all @xmath108 , by _ definition 1 _ , @xmath60 .",
    "obviously @xmath109 if and only if one of them is 0 , the other is 1 .",
    "from , we have @xmath110 if and only if @xmath111 for all @xmath112 $ ] .",
    "so @xmath109 if and only if @xmath112 $ ] and @xmath113 for @xmath114-\\{i\\}$ ] .",
    "the number of @xmath108 with @xmath113 , @xmath114-\\{i\\}$ ] is @xmath115 , the total number of @xmath108 is @xmath116 , so by _ definition 1 _ the influence of @xmath3 on the function @xmath0 is @xmath117    from the proof we can see that the similar conclusion holds for any product of @xmath118 variables . specially ,",
    "if a variable @xmath3 only appears in linear term , then @xmath57 . if a variable @xmath3 only appears in quadratic term , then @xmath119 . if a variable @xmath3 only appears in cubic term , then @xmath120",
    "now we give our probabilistic quantum algorithms .",
    "suppose @xmath0 is a boolean function that is composed of linear and quadratic terms and each variable appears in at most one term .",
    "our assignment is to find the variables in linear terms and those in quadratic terms .",
    "* algorithm 2 *    we apply the bernstein - vazirani circuit to @xmath0 @xmath121 ( @xmath121 is an integer , and @xmath122 ) times , if we always get @xmath123 in a position @xmath6 , then @xmath3 will be declared to be in linear term .",
    "if we get some @xmath123 and some @xmath5 in a position @xmath124 , then @xmath125 will be declared to be in quadratic term .",
    "if we always get @xmath5 in a position @xmath103 , then @xmath126 will be declared to be not in the expression of @xmath0 .",
    "now let us see the success probability of algorithm 2 .",
    "if @xmath3 is in linear term , from _ lemma 1 _ , @xmath57 , so by _ theorem 2 _ , the probability we get @xmath56 is 1 , we will always find @xmath56 .",
    "when @xmath3 is in quadratic term , from _ lemma 1 _ , @xmath119 , running the bernstein - vazirani algorithm once , the probability of getting @xmath56 ( @xmath8 ) is @xmath127 , so in algorithm 2 , the probability of getting @xmath56 ( @xmath8 ) @xmath121 times is @xmath128    from this we can see that when we declare @xmath3 to be in linear term , @xmath3 may be in quadratic term with a probability @xmath129 , the error probability is exponentially small .",
    "if @xmath126 is declared to be not in the expression of @xmath0 , but in fact @xmath126 will be probably in quadratic term , the probability that this happens is @xmath129 .",
    "if we declare @xmath125 to be in quadratic term , in fact it will be .",
    "but @xmath125 is in fact in quadratic term , the probability that we make a mistake ( i.e. we think it is in linear term or not in the expression of @xmath0 ) is @xmath130    from the above , we can see that all of these error probabilities are exponentially small .",
    "this time we still suppose @xmath0 is a boolean function and each variable appears in at most one term .",
    "the difference is that there are cubic terms in the expression of @xmath0 besides some linear and quadratic terms .",
    "our aim is to determine the variables in linear , quadratic and cubic terms .",
    "* algorithm 3 *    we still just apply the bernstein - vazirani circuit to @xmath0 @xmath131(@xmath131 is a integer independent of @xmath1 and @xmath132 ) times .",
    "if we always get ones in a position @xmath6 , then @xmath3 will be declared to be in linear term . if we find @xmath133 ones in a position @xmath124 ( where @xmath134",
    ", @xmath135 is a real number and @xmath136 , we may set @xmath137 ) , then @xmath125 will be declared to be in quadratic term .",
    "if we find @xmath138 ones in a position @xmath139 ( where @xmath140 , @xmath137 ) , then @xmath141 will be declared to be in cubic term .",
    "if we always get @xmath5 in a position @xmath103 , then @xmath126 will be declared to be not in the expression of @xmath0 .",
    "the analysis of algorithm 3 will be more complicated than that of algorithm 2 .",
    "we give a less precise evaluation .",
    "if a variable @xmath142 is in quadratic ( cubic ) term , from lemma 1 , @xmath143 , similarly to , by hoeffding s inequality , we have @xmath144 @xmath145 therefore , we will draw a conclusion that @xmath142 is in quadratic ( cubic ) term with a probability no less than @xmath146 .",
    "the number approximate to 1 exponentially with the increase of @xmath131 .",
    "the analysis of linear terms is more like that about algorithm 2 .    in conclusion",
    ", we can use the generalized bernstein - vazirani quantum for learning some simple functions , such as quadratic , cubic , quartic and maybe higher degree functions .",
    "the running time of the algorithm is independent of @xmath1 , just relate to the influence of the variable . compare with the deterministic quantum algorithm for the cubic function proposed by floess et al . in @xcite , our probabilistic algorithm shows @xmath102 times speedup .",
    "we have presented a quantum approximation algorithm to compute the influence of every variable on the boolean functions . in general , for @xmath1 variables function , our algorithm is @xmath102 times faster than the classical one . moreover , based on this , we give probabilistic quantum algorithms for learning some special functions with simple forms .",
    "the running time of our algorithms rely on the forms of the functions , but do not on the total variables of them .",
    "so our probabilistic quantum algorithm for cubic functions gives @xmath102 times speedup over the deterministic quantum algorithm presented in @xcite . to this end",
    ", we use a similar method to that in @xcite , but compare with that , the problem investigated here is different from that one , the methods in this paper are less complex than that one . we can also use the grover - like operator to amplify the amplitude such as @xcite , but this can not bring forth new ideas in the technique .",
    "we expect that the methods in this paper will be helpful for some other questions .",
    "this work was supported by the national natural science foundation of china under grant no.61173157 .",
    "00 d.floess , e.andersson , and m. hillery , quantum algorithms for testing and learning boolean functions , math .",
    "comp . science ( 2013 ) , vol.23 , pp.386 - 398 .",
    "m.ben-or and n.linial , collective coin flipping , randomness and computation(s.micali ed.)academic press , new york , 1989 , pp.91 - 115 .",
    "h.hatami , a structure theorem for boolean functions with small total influences , annals of mathematics , 176(1 ) , pp.509 - 533,2012 .",
    "v3 [ math.co ] 12 nov 2011 .",
    "j.kahn , g.kalai and n. linial , the influence of variables on boolean functions , proc.29th focs,1988 , pp.68 - 80 .",
    "r.d.wolf , a brief introduction to fourier analysis on the boolean cube , tcgs 1(2008 ) , pp.1 - 20 http : theoryofcomputing.org d.gavinsky , j.kempe , i.kerenidis , r.raz and r.d.wolf , exponential separation for one - way quantum communication complexity , with applications to cryptograph , siam j.comput .",
    "38(5):1695 - 1708(2008 ) .",
    "arxiv : quant - ph/0611209 v3 e.bernstein and u.vazirani , quantum complexity theory .",
    "proceedings of the 25th annual acm symposium on theory of computing , acm press , new york , 1993 , pp.11 - 20 .",
    "r. cleve , a. ekert , c. macchiavello and m. mosca , quantum algorithms revisited , proc .",
    "a 1998 454 , pp.339 - 354 .",
    "s. dasgupta , a. biswas , and g. s. agarwal . implementing deutsch - jozsa algorithm using light shifts and atomic ensembles , phys .",
    "a 71 012333 ( 2005 ) h. f. wang , s. zhang .",
    "implementation of n - qubit deutsch - jozsa algorithm using resonant interaction in cavity qed .",
    "b. 2008 , 17(4 ) : 1165 - 1173 m. hillery and e. anderson , quantum tests for the linearity and permutation invariance of boolean functions , phys .",
    "a 84 , 062326 ( 2011 ) .",
    "w.hoeffding , probability inequalities for sums of bounded random variables , american statistical association journal , march 1963 , pp.13 - 30 .",
    "r.odonnell , some topics in analysis of boolean functions , stoc08 , may 17 - 20,2008 , victoria , british columbia , canada , invited paper . h.w.li and l.yang , quantum algorithm for the finding of boolean function s linear structures , arxiv:1404.0611[quant - ph ] 2 apr 2014 ."
  ],
  "abstract_text": [
    "<S> we investigate the influences of variables on a boolean function @xmath0 based on the quantum bernstein - vazirani algorithm . a previous paper ( floess et al . in math . </S>",
    "<S> struct . in comp . </S>",
    "<S> science 23 : 386 , 2013 ) has proved that if a @xmath1-variable boolean function @xmath2 does not depend on an input variable @xmath3 , using the bernstein - vazirani circuit to @xmath0 will always obtain an output @xmath4 that has a @xmath5 in the @xmath6th position . </S>",
    "<S> we generalize this result and show that after one time running the algorithm , the probability of getting a 1 in each position @xmath6 is equal to the dependence degree of @xmath0 on the variable @xmath3 , i.e. the influence of @xmath3 on @xmath0 . on this foundation , we give an approximation algorithm to evaluate the influence of any variable on a boolean function . </S>",
    "<S> next , as an application , we use it to study the boolean functions with juntas , and construct probabilistic quantum algorithms to learn certain boolean functions . compared with the deterministic algorithms given by floess et al . </S>",
    "<S> , our probabilistic algorithms are faster .    </S>",
    "<S> bernstein - vazirani algorithm , quantum algorithm , influence of boolean function </S>"
  ]
}