{
  "article_text": [
    "one very promising method for rostering and other domains is to specify constraints via grammars or automata that accept some language .",
    "we can specify constraints in this way on , for instance , the number of consecutive night shifts or the number of days off in each 7 day period . with the  constraint @xcite , we specify the acceptable assignments to a sequence of variables by a deterministic finite automaton . one limitation of this approach is that the automaton may need to be large .",
    "for example , there are regular languages which can only be defined by an automaton with an exponential number of states .",
    "researchers have therefore looked higher up the chomsky hierarchy .",
    "in particular , the  constraint @xcite permits us to specify constraints using any context - free grammar . in this paper",
    ", we consider a further generalization to the weighted  constraint .",
    "this can model over - constrained problems and problems with preferences .",
    "in a context - free grammar , rules have a left - hand side with just one non - terminal , and a right - hand side consisting of terminals and non - terminals .",
    "any context - free grammar can be written in chomsky form in which the right - hand size of a rule is just one terminal or two non - terminals .",
    "the weighted @xmath2)$ ] constraint holds iff an assignment @xmath3 forms a string belonging to the grammar @xmath4 and the minimal weight of a derivation of @xmath3 less than or equal to @xmath5 .",
    "the matrix @xmath6 defines weights of productions in the grammar @xmath4 .",
    "the weight of a derivation is the sum of production weights used in the derivation .",
    "the  constraint is domain consistent iff for each variable , every value in its domain can be extended to an assignment satisfying the constraint .",
    "we give a propagator for the @xmath7 constraint based on an extension of the @xmath8 parser to probabilistic grammars @xcite .",
    "we assume that @xmath4 is in chomsky normal form and with a single start non - terminal @xmath9 .",
    "the algorithm has two stages . in the first",
    ", we construct a dynamic programing table @xmath10 $ ] where an element @xmath11 of @xmath10 $ ] is a potential non - terminal that generates a substring @xmath12 $ ] .",
    "we compute a lower bound @xmath13 $ ] on the minimal weight of a derivation from @xmath11 . in the second stage , we move from @xmath14 $ ] to the bottom of table @xmath15 . for an element @xmath11 of @xmath10 $ ] , we compute an upper bound @xmath16 $ ] on the maximal weight of a derivation from @xmath11 of a substring @xmath12 $ ] .",
    "we mark the element @xmath11 iff @xmath13 \\leq u[i , j , a]$ ] .",
    "the pseudo - code is presented in algorithm  [ a : wcyk ] .",
    "lines [ a : s_init_ul][a : e_init_ul ] initialize @xmath17 and @xmath18 .",
    "lines [ a : s_up][a : e_up ] compute the first stage , whilst lines [ a : s_down][a : e_down ] compute the second stage . finally , we prune inconsistent values in lines [ a : s_prune][a : e_prune ] .",
    "algorithm  [ a : wcyk ] enforces domain consistency in @xmath19 time .",
    "as an alternative to this monolithic propagator , we propose a simple decomposition with which we can also enforce domain consistency .",
    "a decomposition has several advantages .",
    "for example , it is easy to add to any constraint solver . as a second example",
    ", decomposition gives an efficient incremental propagator , and opens the door to advanced techniques like nogood learning and watched literals .",
    "the idea of the decomposition is to introduce arithmetic constraints to compute @xmath17 and @xmath18 . given the table @xmath15 obtained by algorithm  [ a : wcyk ] , we construct the corresponding @xmath20 directed acyclic graph ( dag ) as in  @xcite .",
    "we label an @xmath21 node by @xmath22 , and an @xmath23 node by @xmath24 .",
    "we denote the parents of a node @xmath25 as @xmath26 and the children as @xmath27 . for each node",
    "two integer variables are introduced to compute @xmath17 and @xmath18 . for an @xmath21-node @xmath25 ,",
    "these are @xmath28 and @xmath29 , whilst for an @xmath23-node @xmath25 , these are @xmath30 , @xmath31 .",
    "for each @xmath23 node @xmath32 we post a constraint to connect @xmath25 to its children @xmath27 : @xmath33 \\label{e : and_sum}\\end{gathered}\\ ] ] for each @xmath21 node @xmath34 we post constraints to connect @xmath25 to its children @xmath27 :    @xmath35    for each @xmath21 node @xmath34 we post a set of constraints to connect @xmath25 to its parents @xmath26 and siblings : @xmath36\\ } \\label{e : or_prt_max } ,   \\end{gathered}\\ ] ] where @xmath37 or @xmath38 , @xmath39 is the parent of @xmath40 and @xmath41 .    finally , we introduce constraints to prune @xmath42 . for each leaf of the dag that is an @xmath21 node @xmath43",
    ", we introduce : @xmath44    as the maximal weight of a derivation is less than or equal to @xmath5 we post : @xmath45    bounds propagation will set the lower bound of @xmath46 to the minimal weight of a derivation from @xmath11 , and the upper bound on @xmath47 to the maximum weight of a derivation from @xmath11 .",
    "we forbid branching on variables @xmath48 and @xmath49 as branching on @xmath48 would change the weights matrix @xmath6 and branching on @xmath49 would add additional restrictions to the weight of a derivation .",
    "bounds propagation on this decomposition enforces domain consistency on the  constraint .",
    "if we invoke constraints in the decomposition in the same order as we compute the table @xmath15 , this takes @xmath1 time . for simpler grammars , propagation is faster .",
    "for instance , as in the unweighted case , it takes just @xmath50 time on a regular grammar .",
    "we can speed up propagation by recognizing when constraints are entailed .",
    "if @xmath28 @xmath51 @xmath52 holds for an @xmath21 node @xmath25 then constraints   and   are entailed .",
    "if @xmath53 holds for an @xmath23 node @xmath25 then constraints   and   are entailed . to model entailment we augmented each of these constraints in such a way that if @xmath54 or @xmath30 @xmath51 @xmath31 hold then corresponding constraints are not invoked by the solver",
    "we can use the  constraint to encode a soft version of @xmath0 constraint which is useful for modelling over - constrained problems . the soft @xmath55)$ ] constraint holds iff the string @xmath56 $ ] is at most distance @xmath5 from a string in @xmath4 .",
    "we consider both hamming and edit distances .",
    "we encode the soft @xmath55)$ ] constraint as a weighted @xmath57)$ ] constraint . for hamming distance , for each production @xmath58",
    ", we introduce additional unit weight productions to simulate substitution : @xmath59 = 1| a \\rightarrow a \\in g , a \\rightarrow b \\notin g ,   b \\in \\sigma   \\}\\end{gathered}\\ ] ] existing productions have zero weight . for edit distance",
    ", we introduce additional productions to simulate substitution , insertion and deletion : @xmath60 = 1| a \\rightarrow a \\in g , a \\rightarrow b \\notin g ,   b \\in \\sigma \\}\\cup",
    "\\\\          \\{a \\rightarrow \\varepsilon , w[a \\rightarrow   \\varepsilon ] = 1|   a \\in \\sigma\\}\\cup\\\\      \\{a \\rightarrow",
    "aa , w[a \\rightarrow   aa ] = 1|   a \\in \\sigma\\}\\cup   \\\\      \\{a \\rightarrow   aa , w[a \\rightarrow   aa ] = 1|   a \\in \\sigma\\}\\end{gathered}\\ ] ] to handle @xmath61 productions we modify alg .",
    "[ a : wcyk ] so loops in lines  , run from @xmath62 to @xmath63 .",
    "we evaluated these propagation methods on shift - scheduling benchmarks  @xcite .",
    "a personal schedule is subject to various regulation rules , e.g. a full - time employee has to have a one - hour lunch .",
    "this rules are encoded into a context - free grammar augmented with restrictions on productions  @xcite .",
    "a schedule for an employee has @xmath64 slots represented by @xmath65 variables . in each slot",
    ", an employee can work on an activity ( @xmath66 ) , take a break ( @xmath67 ) , lunch ( @xmath17 ) or rest ( @xmath68 ) .",
    "these rules are represented by the following grammar : @xmath69 where functions @xmath70 are restrictions on productions and @xmath71 is a function that returns @xmath72 if the business is opened at @xmath73th slot and @xmath62 otherwise . to model labour demand for a slot",
    "we introduce boolean variables @xmath74 , equal to @xmath72 if @xmath63th employee performs activity @xmath75 at @xmath73th time slot . for each time slot @xmath73 and activity @xmath75",
    "we post a constraint @xmath76 , where @xmath77 is the number of employees .",
    "the goal is to minimize the number of slots in which employees worked .",
    "we used gecode 2.0.1 for our experiments and ran them on an intel xeon @xmath78ghz with @xmath79 gb of ram . in the first set of experiments",
    ", we used the weighted @xmath80 , @xmath81 with zero weights .",
    "our monolithic propagator gave similar results to the unweighted  propagator from @xcite .",
    "decompositions were slower than decompositions of the unweighted   constraint as the former uses integers instead of booleans . in the second set of experiments , we assigned weight @xmath72 to activity productions , like @xmath82 , and post an additional cost function @xmath83 that is minimized .",
    "@xmath83 is the number of slots in which employees worked .",
    "results are presented in table[t : t1 ] .",
    "we improved on the best solution found in the first model in @xmath79 benchmarks and proved optimality in one .",
    "the decomposition of the weighted @xmath0 constraint was slightly slower than the monolithic propagator , while entailment improved performance in most cases .    .[t :",
    "t1 ] all benchmarks have one - hour time limit .",
    "@xmath84 is the number of activities,@xmath77 is the number of employees , @xmath85 shows the total number of slots in which employees worked in the best solution , @xmath86 is the time to find the best solution , @xmath87 is the number of backtracks to find the best solution , @xmath88 is the number of backtracks in one hour , @xmath89 shows if optimality is proved , @xmath90 shows if a lower cost solution is found by the second model [ cols=\"^,^,^,^,^,^,^,^,^,^,^,^,^,^,^,^,^ \" , ]      marie - claude cote , gendron bernard , quimper claude - guy , and rousseau louis - martin .",
    "formal languages for integer programming modeling of shift scheduling problems . ,",
    "center for research on transportation , montreal , 2007 ."
  ],
  "abstract_text": [
    "<S> we introduce the weighted @xmath0 constraint and propose a propagation algorithm that enforces domain consistency in @xmath1 time . </S>",
    "<S> we show that this algorithm can be decomposed into a set of primitive arithmetic constraints without hindering propagation . </S>"
  ]
}