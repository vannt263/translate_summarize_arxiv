{
  "article_text": [
    "functional logic programming @xcite joins in a single paradigm the features of functional programming with those of logic programming .",
    "logic programming contributes logic variables that are seamlessly integrated in functional computations by narrowing .",
    "the usefulness and elegance of programming with narrowing is presented in @xcite . at the semantics level",
    "free variables are equivalent to _ non - deterministic functions _",
    "@xcite , i.e. , functions that for some arguments may return any one of many results .",
    "thus , at the implementation level variables can be replaced by non - deterministic functions when non - deterministic functions appear simpler , more convenient and/or more efficient to implement @xcite .",
    "this paper focuses on a graph transformation recently proposed for the implementation of non - determinism of this kind .",
    "this transformation is intended to ensure the completeness of computations without cloning too eagerly a large portion of the context of a non - deterministic step .",
    "the hope is that steps following the transformation will create conditions that make cloning the not yet cloned portion of the context unnecessary .",
    "non - determinism is certainly the most characterizing and appealing feature of functional logic programming .",
    "it enables encoding potentially difficult problems into relatively simpler programs .",
    "for example , consider the problem of abstracting the dependencies among the elements of a set such as the functions of a program or the widgets of a graphical user interface . in abstractions of this kind , _ component parts _ `` build '' _ composite objects_. a non - deterministic function , , defines which objects are dependent on each part .",
    "the syntax is curry  @xcite .",
    "@xmath0 - 35pt    -.0em    a part can build many objects , e.g. : part builds objects and .",
    "likewise , an object can be built from several parts , e.g. : object is built by parts and .",
    "many - to - many relationships , such as that between objects and parts just sketched , are difficult to abstract and to manipulate in deterministic languages . however , in a functional logic setting , the non - deterministic function is straightforward to define and is sufficient for all other basic functions of the abstraction .",
    "for example , a function that non - deterministically computes a part of an object is simply defined by :    @xmath1 - 35pt    -.0em    where is defined using a _ functional pattern _ @xcite .",
    "the set of all the parts of an object is computed by , the implicitly defined _ set function _",
    "@xcite of .",
    "the simplicity of design and ease of coding offered by functional logic languages through non - determinism do not come for free .",
    "the burden unloaded from the programmer is placed on the execution .",
    "all the alternatives of a non - deterministic choice must be explored to some degree to ensure that no result of a computation goes missing .",
    "doing this efficiently is a subject of active research .",
    "below , we summarize the state of the art .",
    "there are three main approaches to the execution of non - deterministic steps in a functional logic program . a fourth approach , called _",
    "pull - tabbing _",
    "@xcite , still underdeveloped , is the subject of this paper .",
    "pull - tabbing offers some appealing characteristics missing from the other approaches .",
    "we borrow from @xcite a simple example to present the existing approaches and understand their characteristics :    @xmath2 - 35pt    -.0em    we want to evaluate the expression    @xmath3 - 35pt    -.0em    we recall that ` ' is a library function , called _ choice _ , that returns either of its arguments , i.e. , it is defined by the rules :    @xmath4 - 35pt    -.0em    and that the clause introduces a _ shared _ expression .",
    "every occurrence of in ( [ value ] ) has the same value throughout the entire computation according to the _ call - time choice _ semantics  @xcite .",
    "by contrast , in each occurrence of is evaluated independently of the other .",
    "[ fig : sharing ] highlights the difference between these two expressions when they are depicted as graphs .",
    "@1@c=5pt@r=12pt@m=1pt & @-[dl ] @-[dr ] + @-[dr ] & & @-[dl ] + &    @1@c=5pt@r=12pt@m=1pt & @-[dl ] @-[dr ] + @-[d ] & & @-[d ] + & &    a _ context _ is an expression with a distinguished symbol called _ hole _ denoted ` @xmath5 $ ] ' .",
    "if @xmath6 is a context , @xmath7 $ ] is the expression obtained by replacing the hole in @xmath6 with @xmath8 .",
    "e.g. , the expression in ( [ value ] ) can be written as @xmath9 $ ] , in which @xmath6 is .",
    "the context @xmath5 $ ] is called _ empty _ context . an expression rooted by a node @xmath10 labeled by the choice symbol",
    "is informally referred to as _ a choice _ and each argument of the choice symbol , or successor of @xmath10 ,",
    "is referred to as a choice s _",
    "_ backtracking _ is the most traditional approach to non - deterministic computations in functional logic programming . evaluating a choice in some context , say @xmath11 $ ] , consists in selecting either alternative of the choice , e.g. , @xmath12 ( the criterion for selecting the alternative is not relevant to our discussion ) , replacing the choice with the selected alternative , which gives @xmath13 $ ] , and continuing the computation . in typical interpreters ,",
    "if and when the computation of @xmath13 $ ] completes , the result is consumed , e.g. , printed , and the user is given the option to either terminate the execution or compute @xmath14 $ ] .",
    "backtracking is well - understood and relatively simple to implement .",
    "it is employed in successful languages such as prolog @xcite and in language implementations such as pakcs  @xcite and @xmath15 @xcite .",
    "the major objection to backtracking is its incompleteness .",
    "if the computation of @xmath13 $ ] does not terminate , no result of @xmath14 $ ] is ever obtained .",
    "+ _ copying _ ( or _ cloning _ ) is an approach that fixes the inherent incompleteness of backtracking . evaluating a choice in some context , say @xmath11 $ ] , consists in evaluating simultaneously ( e.g. , by interleaving steps ) and independently both @xmath13 $ ] and @xmath14 $ ] . in typical interpreters ,",
    "if and when the computation of either completes , the result is consumed , e.g. , printed , and the user is given the option to either terminate the execution or continue with the computation of the other .",
    "copying is simpler than backtracking and it is used in some experimental implementations of functional logic languages @xcite .",
    "the major objection to copying is the significant investment of time and memory made when a non - deterministic step is executed .",
    "if an alternative of a choice eventually fails , cloning the context may have been largely useless . for a contrived example , notice that in an arbitrarily large context is cloned when the choice is evaluated , but for one alternative this context is almost immediately discarded .",
    "+ _ bubbling _ is an approach proposed to avoid the drawbacks of backtracking and copying @xcite .",
    "bubbling is similar to copying , in that it clones a portion of the context of a choice to concurrently compute all its alternatives , but the portion of cloned context is typically smaller than the entire context .",
    "we recall that in a rooted graph @xmath16 , a node @xmath17 is a",
    "_ dominator _ of a node @xmath10 , _ proper _ when @xmath18 , iff every path from the root of @xmath16 to @xmath10 contains @xmath17 .",
    "an expression @xmath11 $ ] can be seen as @xmath19 $ ] in which the root of @xmath20 is a dominator of the hole .",
    "a trivial case arises when @xmath21 $ ] and @xmath22 .",
    "evaluating a choice in some context , say @xmath11 $ ] , distinguishes whether or not @xmath6 is empty . if @xmath6 is the empty context , @xmath12 and @xmath23 are evaluated simultaneously and independently , as in copying , but there is no context to clone . otherwise , the evaluation consists in finding @xmath24 and @xmath20 such that @xmath11=c_1[c_2[u?v]]$ ] and the root of @xmath20 is a proper dominator of the choice , and evaluating @xmath25?c_2[v]]$ ] .",
    "when @xmath24 is the empty context , then bubbling is exactly as copying .",
    "otherwise a smaller context , i.e. , @xmath20 instead of @xmath6 , is cloned .",
    "bubbling intends to reduce cloning in hopes that some alternative of a choice will quickly fail .",
    "r2.45 in       an objection to bubbling is the cost of finding a choice s immediate dominator and the risk of paying this cost repeatedly for the same choice .",
    "this cost entails traversing a possibly - large portion of the choice s context .",
    "traversing the context is more efficient than cloning it , since cloning requires node construction in addition to the traversal , but it is still unappealing , since the cost of a non - deterministic step is not predictable and it may grow with the size of an expression .",
    "_ pull - tabbing _ , which is at the core of our work , was first sketched in @xcite .",
    "the name `` pull - tab '' originates from the metaphor of pulling the tab of a zipper . for an expression ,",
    "a choice is a tab and a choice s spine is a zipper . as the tab / choice is pulled up , the zipper / spine opens into two equal strands each of which has a different alternative of the choice at the end .    evaluating a choice in some context , say @xmath11 $ ] , distinguishes whether or not @xmath6 is empty .",
    "if @xmath6 is empty , @xmath12 and @xmath23 are evaluated simultaneously and independently , as in copying and bubbling , without any context to clone .",
    "otherwise , the expression to evaluate is of the form @xmath26 $ ] , for some symbol @xmath27 ( for ease of presentation we assume that @xmath27 is unary , but there are no restrictions on its arity ) and some context @xmath6 .",
    "pull - tabbing transforms the expression into @xmath28 $ ] . without some caution ,",
    "this transformation is unsound .",
    "unsoundness may occur when some choice has two predecessors , as in our running example .",
    "the choice will be pulled up along two paths creating _ two pairs _ of strands that eventually must be pair - wise combined together .",
    "some combinations will contain mutually exclusive alternatives , i.e. , subexpressions impossible to obtain in languages such as curry and @xmath15 that adopt the call - time choice semantics .",
    "[ fig : pull - tab ] presents an example of this situation .",
    "we will show that the soundness is recovered if the left and right alternative of a choice are _ not _ combined in the same expression . to this aim",
    ", we attach an identifier to each choice of an expression .",
    "we preserve this identifier when a choice is pulled up .",
    "if eventually the choice is reduced to either of its alternatives every other choice with the same identifier must be reduced to the same alternative .",
    "a very similar idea in a rather different setting is proposed in @xcite .",
    "a pull - tab step clones a single node , a predecessor of the choice being pulled up . if the choice is pulled all the way up to the root of an expression , the choice s entire spine is cloned .",
    "but if an alternative of the choice fails before the choice reaches the root , further cloning of the choice s context becomes unnecessary .",
    "we define a term graph in the customary way  @xcite , but extend the decorations of nodes with choice identifiers .",
    "[ def : expression ] let @xmath29 be a _ signature _ , @xmath30 a countable set of _ variables _ , @xmath31 a countable set of _ nodes _ , @xmath32 a countable set of _ choice identifiers_. a _ ( rooted ) _ _ graph _ over @xmath33 is a 5-tuple @xmath34 @xmath35 such that :    1 .",
    "@xmath36 is the set of nodes of @xmath16 ; 2 .",
    "@xmath37 is the _ labeling _ function mapping each node of @xmath16 to a signature symbol or a variable ; 3 .",
    "@xmath38 is the _ successor _ function mapping each node of @xmath16 to a possibly empty string of nodes of @xmath16 such that if @xmath39 , where @xmath40 , and ( for the following condition , we assume that a variable has arity zero ) @xmath41 , then there exist @xmath42 in @xmath43 such that @xmath44 ; 4 .",
    "@xmath45 is a subset of nodes of @xmath16 called the _ roots _ of @xmath16 ; 5 .",
    "@xmath46 is a partial function mapping nodes labeled by the choice symbol to a choice identifier ; 6 .   if @xmath47 and @xmath48 and @xmath49 , then @xmath50 , i.e. , every variable of @xmath16 labels one and only one node of @xmath16 ; and 7 .   for each @xmath51 , either @xmath52 or there is a path from @xmath53 to @xmath10 where @xmath54 , i.e. , every node of @xmath16 is reachable from some root of @xmath16 .",
    "a graph @xmath16 is called a _ term ( graph ) _ , or more simply an _ expression _ , if @xmath55 is a singleton .",
    "typically we will use `` expression '' when talking about programs and `` graph '' when making formal claims .",
    "choice identifiers play a role in computations .",
    "thus , we will explicitly define the @xmath56 mapping only after formally defining the notion of computation .",
    "term graphs can be seen , e.g. , in figs .",
    "[ fig : sharing ] and [ fig : bubbling ] .",
    "every choice node of every graph of fig .",
    "[ fig : pull - tab ] would be decorated with the same choice identifier .",
    "choice identifiers are arbitrary and only compared for equality .",
    "node names are arbitrary and irrelevant to most purposes and are typically omitted .",
    "however , some definitions and proofs of our claims need to explicitly refer to some nodes of a graph . for this purpose",
    ", we adopt the _ linear notation for graphs _ ( * ? ? ?",
    "* def .  4 ) .",
    "with this convention , the left graph of fig .",
    "[ fig : sharing ] is denoted , where the node names are the italicized identifiers starting with ` @xmath10 ' .",
    "we also make the convention that names of nodes that do not need to be referenced can be omitted , hence .",
    "the latter is conceptually identical to ( [ value ] ) . in the linear notation for graphs ,",
    "infix operators are applied in prefix notation , e.g. , see lemma  [ invariance - by - pull - tab ] .",
    "this practice eases understanding the correspondence between a node identifier and the label of that node .",
    "the definition of graph rewriting @xcite is more laborious than , although conceptually very similar to , that of term rewriting @xcite .",
    "sections 2 and 3 of @xcite formalize key concepts of graph rewriting such as _ replacement _ , _ matching _ , _ homomorphism _ , _ rewrite rule _",
    ", _ redex _ , and _ step _ in a form ideal for our discussion .",
    "therefore , we adopt entirely these definitions , including their notations , and only discuss the manipulation of choice identifiers , since they are absent from @xcite .",
    "we now formalize the class of rewrite systems that we consider in this paper .",
    "a _ program _ is a rewrite system in a class called _ limited overlapping inductively sequential _ , abbreviated _",
    "lois_. in _ lois _ systems , the rules are left - linear and constructor - based @xcite .",
    "the left - hand sides of the rules are organized in a hierarchical structure called a _ definitional tree _ @xcite that guides the evaluation strategy @xcite . in _",
    "systems , there is a single operation whose rules left - hand sides overlap . this operation is called _ choice _ , is denoted by the infix binary operation `` '' , and is defined by the rules of ( [ binary - choice - rules ] ) .",
    "_ lois _ systems have been investigated in some depth .",
    "below we highlight informally the key results that justify our choice of _ lois _ systems .    1 .",
    "any _ lois _ system admits a complete , sound and optimal evaluation strategy @xcite .",
    "any constructor - based conditional rewrite system is semantically equivalent to a _",
    "system @xcite .",
    "any _ narrowing _ computation in a _",
    "system is semantically equivalent to a _ rewriting _ computation in another similar _ lois _ system @xcite .    for the above reasons , _ lois _ systems are an ideal core language for functional logic programs . informally summarizing , _",
    "lois _ systems are general enough to perform any functional logic computation @xcite and powerful enough to compute by simple rewriting @xcite and without wasting steps @xcite .      in our setting ,",
    "a _ computation _ of @xmath57 is a sequence @xmath58[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } e_1 {    \\mbox{$\\rlap{\\raisebox{.15ex}[0pt][0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } \\ldots$ ] such that @xmath59[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } e_{i+1}$ ] is a _ step _",
    ", i.e. , is either one of two graph transformations : a rewrite , denoted by `` @xmath60 '' , or a pull - tab , denoted by `` @xmath61[0pt]{\\tiny$\\xi$}}}$ ] '' .",
    "rewrite _ is the replacement in a graph of an instance of a rewrite rule left - hand side ( the _ redex _ ) with the corresponding instance of the rule right - hand side ( the _ replacement _ ) .",
    "the pull - tab transformation is formally defined in the next section . in principle , we do not exclude choice reductions , i.e. , non - deterministic steps , but in practice we limit them to the root of an expression .",
    "the reason is that reducing a choice makes an irrevocable commitment to one of its alternatives .",
    "pull - tab steps are equivalent to non - deterministic steps in the sense , formally stated and proved in the next section , that they produce all and only the same results , but without any irrevocable commitment",
    ".    a computation can be finite or infinite .",
    "a computation is _ successful _ or it _ succeeds _ iff its last element is a _",
    "value _ , i.e. , a constructor normal form . a computation is a _ failure _ or it _ fails _ iff its last element is a normal form with some node labeled by an operation symbol . in non - deterministic programs , such as those considered in this paper ,",
    "the same expression may have both successful computations and failures .",
    "each expression of a computation is also referred to as a _ state _ of the computation .",
    "a strategy determines which step(s ) of an expression to execute .",
    "essential properties of a strategy , such as to succeed whenever possible , will be recalled in sec .",
    "[ sec : correctness ] .      as described in section [ computations ] , a computation is a sequence of expressions such that each expression of the sequence , except the first one , is obtained from the preceding expression by either of two transformations .",
    "one transformation is an ordinary _ redex replacement_. we defer to ( * ? ? ?",
    "23 ) the precise formulation of this transformation and to the next section the handling of decorations by this transformation .",
    "the second transformation is defined below .",
    "[ def : pull - tab ] let @xmath16 be an expression , @xmath10 a node of @xmath16 , referred to as the _ target _ , not labeled by the choice symbol and @xmath62 the successors of @xmath10 in @xmath16 .",
    "let @xmath63 be an index in @xmath64 such that @xmath65 , referred to as the _ source _ , is labeled by the choice symbol and let @xmath66 and @xmath67 be the successors of @xmath65 in @xmath16 .",
    "let @xmath68 , for @xmath69 , be the graph whose root is a fresh node @xmath70 with the same label as @xmath10 and successors @xmath71 .",
    "let @xmath72 .",
    "the _ pull - tab _ of @xmath16 with source @xmath65 and target @xmath10 is @xmath73 $ ] and we write @xmath74[0pt]{\\tiny$\\xi$}}}\\ , g[n \\leftarrow g']$ ] .    fig .",
    "[ fig : pull - tab ] depicts the result of a pull - tab step . for a trivial textual example",
    ", @xmath75 is the pull - tab of @xmath76 .",
    "the definition excludes targets labeled by the choice symbol .",
    "these targets are not a problem for the pull - tab transformation , but would complicate , without any benefit , our treatment .",
    "a pull - tab step is conceptually very similar to an ordinary step  in a graph a ( sub)graph is replaced .",
    "the difference with respect to a rewrite step is that the replacement is not constructed by a rewrite rule , but according to def .",
    "[ def : pull - tab ] .",
    "it seems very natural for pull - tab steps too to call _ redex _ the ( sub)graph being replaced .",
    "term and graph rewriting are similar formalisms that for many problems are able to model the expressions manipulated by functional logic programs .",
    "not surprisingly , expressions are terms in term rewriting and graphs in graph rewriting .",
    "a significant difference between these formalisms is the identification of a subexpression of an expression .",
    "term rewriting uses positions , i.e. , paths in a tree , whereas graph rewriting uses nodes .",
    "nodes are used for defining both rewrite rules and expressions to evaluate .",
    "nodes are `` placed in service '' ( 1 ) to define rewrite rules , ( 2 ) when an expression , called _ top - level _ , is defined or created for the purpose of a computation , and ( 3 ) to define or construct the replacement used in a step .",
    "we agree that any node is placed in service _ only once _ ,",
    "i.e. , the same node is never allocated to distinct top - level expressions and/or replacements .",
    "however , the same node may be found in distinct graphs related by a step , since a step makes a localized change in a graph .",
    "these stipulations are formalized by the following principle , which is a consequence of placing nodes in service _ only once_.    [ persistence ] let @xmath77 and @xmath78 be graphs .",
    "if @xmath10 is a node in @xmath79 , then there exists a graph @xmath16 such that @xmath80[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } \\,$}}g_1 $ ] and @xmath80[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } \\,$}}g_2 $ ] .      to support pull - tabbing and ensure its correctness we attach additional information to an expression .",
    "this additional information is formalized as a decoration of a node similar to other decorations present in graph , e.g. , label and successors . in this section ,",
    "we rigorously define the function that maps nodes to choice identifiers .",
    "[ decorations ] let @xmath81[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } g_1 {    \\mbox{$\\rlap{\\raisebox{.15ex}[0pt][0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } \\ldots$ ] be a computation .",
    "we define the @xmath82 mapping , for each element @xmath83 of @xmath84 , by induction on @xmath63 , as follows : @xmath82 takes a node of @xmath83 labeled by the choice symbol and produces the node s choice identifier .",
    "base case : @xmath85 .",
    "@xmath86 , where @xmath10 is in @xmath87 and is labeled by the choice symbol , is an arbitrary element of @xmath32 , provided that @xmath88 is one - to - one . ind .",
    "case : @xmath89 . by the induction hypothesis ,",
    "@xmath90 is defined for any choice node . in the step @xmath91[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } g_i$ ] , whether rewrite or pull - tab , a subexpression of @xmath92 rooted by a node @xmath93 is replaced by an expression rooted by a node @xmath94 .",
    "let @xmath10 be a node of @xmath83 .    1 .",
    "if @xmath10 is a node of @xmath92 labeled by the choice symbol , then @xmath95 .",
    "+ 2 .   otherwise ,",
    "if @xmath96 an ordinary rewrite and @xmath10 is labeled by the choice symbol , then @xmath97 , for an arbitrary @xmath98 provided that @xmath99 for all @xmath100 and all @xmath101 and @xmath102 for @xmath103 i.e. , @xmath104 is fresh .",
    "+ 3 .   otherwise ,",
    "if @xmath105[0pt]{\\tiny$\\xi$}}}\\ , g_i$ ] a pull - tab and @xmath106 , then @xmath107 , where @xmath108 is the source node of the pull - tab .",
    "the above definition is articulated , but conceptually simple .",
    "below , we give an informal account of it . in a typical step @xmath109[0pt]{\\kern.95ex\\tiny$\\xi$}}\\to\\,$ } } g'$ ] , most nodes of @xmath16 end up in @xmath110 .",
    "the choice identifier , for choices , of these nodes remains the same . in a rewrite ,",
    "some nodes are created .",
    "any choice node created in the step gets a fresh choice identifier . in a pull - tab , informally speaking , the source ( a choice ) `` moves '' and the target ( not a choice ) `` splits . ''",
    "the choice identifier `` moves '' with its source .",
    "split nodes have no choice identifier .",
    "each node in the `` universe '' of nodes @xmath31 may belong to several graphs . in  @xcite , and accordingly in our extension ( see defs .  [",
    "def : expression ] and [ decorations ] ) , the function mapping a node to a decoration depends on each graph to which the node belongs .",
    "it turns out that some decorations of a node , e.g. , the label , are _ immutable _ , i.e. , the function mapping a node to such decorations does not depend on any graph .",
    "we prove the immutability claim for our extension , the choice identifier .",
    "obviously , there is no notion of time when one discusses expressions and considers the decorations of a node .",
    "hence immutable decorations `` are set '' with the nodes . in practice , these decorations `` become known '' when a node is `` placed in service '' for the purpose of a computation or is created by a step .    in view of this result , we drop the subscript from @xmath56 since this practice simplifies the notation and attests a fundamental invariant .",
    "pull - tab steps may produce an expression with distinct choices with the same choice identifier .",
    "the same identifier tells us that to some extent these redexes are the `` same '' .",
    "therefore , when a computation replaces one such redex with the left , resp .",
    "right , alternative , every other `` same '' redex should be replaced with the left , resp .",
    "right , alternative , too .",
    "if this does not happen , the computation is unacceptable . the notion of consistency of computations introduced",
    "next abstracts this idea .",
    "[ def : consistent ] a rewrite step that replaces a redex rooted by a node @xmath10 labeled by the choice symbol is called a _",
    "choice step_. a computation @xmath84 is _ consistent _ iff for all @xmath98 , there exists an @xmath63 such that every choice step of @xmath84 at a node identified by @xmath104 applies rule @xmath111 of `` '' defined in _ ( [ binary - choice - rules])_.",
    "a _ strategy _ determines which step(s ) of an expression to execute . a strategy is usually defined as a function that takes an expression @xmath57 and returns a set @xmath112 of steps of this expression or , equivalently , the reducts of @xmath57 according to the steps of @xmath112",
    ". we will not define any specific strategy .",
    "a major contribution of our work is showing that the correctness of pull - tabbing is strategy - independent .",
    "the classic definition of correctness of a strategy @xmath113 is stated as the ability to produce for any expression @xmath57 ( in the domain of the strategy ) all and only the results that would be produced by rewriting @xmath57 . ``",
    "all and only '' leads to the following notions .",
    "+ _ soundness : _ if @xmath114 is a computation of @xmath57 in which each step is according to @xmath113 and @xmath23 is a value ( constructor normal form ) , then @xmath115 .",
    "+ _ completeness : _ if @xmath115 , where @xmath23 is a value ( constructor normal form ) , then there exists a computation @xmath114 in which each step is according to @xmath113 . + in the definitions of soundness and completeness proposed above , the same expression is evaluated both according to @xmath113 and by rewriting .",
    "this is adequate with some conventions . rewriting",
    "is not concerned with choice identifiers .",
    "this decoration can be simply ignored in rewriting computations . in particular , in rewriting ( as opposed to rewriting and pull - tabbing ) a computation is always consistent . in graph rewriting , _ equality of graphs _ is modulo a renaming of nodes .",
    "a precise definition of this concept is in ( * ? ? ?",
    "2.5 ) .    typically , the proof of soundness is trivial for strategies that execute only rewrite steps , but our strategy executes also pull - tab steps , hence it creates expressions that can not be produced by rewriting .",
    "indeed , some of these expressions will have to be discarded to ensure the soundness .",
    "the proof of correctness of pull - tabbing is non - trivial and relies on two additional concepts , _ representation _ and _ invariance _ , which are presented in following sections .",
    "r1.8 in    [ fig : parallel - moves ]    proofs of properties of a computation are often accomplished by `` rearranging '' the computation s steps in some convenient order . a fundamental result in rewriting , known as the parallel moves lemma @xcite , shows that in orthogonal systems the steps of a computation can be rearranged at will",
    ". a slightly weaker form of this result carries over to _",
    "lois _ systems . a pictorial representation of this result is provided in fig .",
    "the symbol `` @xmath116 '' denotes the reflexive closure of the rewrite relation .",
    "the notation `` @xmath117 '' , where @xmath10 is a node and @xmath53 is a rule , denotes either equality or a rewrite step at node @xmath10 with rule @xmath53 .",
    "a characteristic of pull - tabbing , similar to bubbling and copying , is that the completeness of computations is obtained by avoiding or delaying a commitment to either alternative of a choice . in pull - tabbing ,",
    "similar to bubbling , _ both _ the alternatives of a choice are kept or `` represented '' in a _",
    "single _ expression throughout a good part of a computation .",
    "the proof of the correctness of pull - tabbing is obtained by reasoning about this concept , which we formalize below .",
    "[ representation ] we define a mapping @xmath118 that takes an expression @xmath16 and returns a set @xmath119 called the _ represented set of @xmath16 _ as follows .",
    "let @xmath16 be an expression .",
    "an expression @xmath57 is in @xmath119 iff there exists a consistent computation @xmath120 modulo a renaming of nodes that makes all and only the choice steps of @xmath16 .    in other words , we select either alternative for every choice of an expression . for choices with the same identifier , we select the same alternative . since distinct choice steps occur at distinct nodes , by lemma [ parallel - moves ] the order in which the choice steps are executed to produce any member of the represented set is irrelevant .",
    "therefore , the notion of represented set is _",
    "well defined_. the notion of represented set of @xmath16 is a simple syntactic abstraction not to be confused with the notion of set of values of an expression @xmath16  @xcite , which is a semantic abstraction fairly more complicated .",
    "the proof of correctness of pull - tabbing is based on two results that informally speaking establish that the notion of represented set is invariant both by pull - tab steps and by non - choice steps .",
    "we combine the previous lemmas into computations of any length .",
    "theorem [ correctness ] suggests to apply both non - choice and pull - tab steps to an expression .",
    "choices pulled up to the root are reduced consistently and without context cloning . of course ,",
    "by the time a choice is reduced , all its spines have been cloned  similar to bubbling and copying .",
    "a better option , available to pull - tabbing only , is discussed in the next section .",
    "the pull - tab transformation is meant to be used in conjunction with some evaluation strategy .",
    "we showed that pull - tabbing is not tied to any particular strategy .",
    "however , the strategy should be pull - tab - aware in that : ( 1 ) a choice should be evaluated ( to a head normal form ) only when it is _ needed _ @xcite , ( 2 ) a choice in a root position is reduced ( consistently ) , whereas in a non - root position is pulled , and ( 3 ) before pulling a choice , one of the choice s alternatives should be a head - normal form .",
    "the formalization of such a strategy would take us well beyond the scope of this paper .    in",
    "well - designed , non - deterministic programs , either or both alternatives of most ( but not all ) choices should fail @xcite . under the assumption that a choice is evaluated to a head normal form only when it is _ needed _",
    "@xcite , if an alternative of the choice fails , the choice is no longer non - deterministic  the failing alternative can not produce a value .",
    "thus , the choice can be reduced to the other alternative without loss of completeness and without context cloning .",
    "this is where pull - tabbing is advantageous over copying and bubbling  any portion of a choice s context not yet cloned when an alternative fails no longer needs to be cloned . of course",
    ", the implementation must still identify the choice , and choice s single remaining strand as either left or right , to ensure consistency .",
    "we investigated pull - tabbing , an approach to non - deterministic computations in functional logic programming .",
    "section [ approaches ] recalls copying and bubbling , the competitors of pull - tabbing . here",
    ", we briefly highlight the key differences between these approaches .",
    "pull - tabbing ensures the completeness of computations in the sense that no alternative of a choice is left behind until all the results of some other alternative have been produced .",
    "similar to every approach with this property , it must clone portions of the context of a choice .",
    "in contrast to copying and bubbling , it clones the context of a choice in minimal increments with the intent and the possibility of stopping cloning the context as soon as an alternative of the choice fails .",
    "the idea of identifying choices to avoid combining in some expression the left and right alternatives of the same choice appears in @xcite .",
    "the idea is developed in the framework of a natural semantics for the translation of ( flat ) curry programs into haskell .",
    "a proof of the correctness of this idea will appear in @xcite which also addresses the similarities between the natural semantics and graph rewriting .",
    "this discussion , although informal , is enlightening .",
    "we formally defined the pull - tab transformation , characterized the class of programs for which the transformation is intended , extended the computations in these programs to include the transformation , proved the correctness of these extended computations , and described the condition that reduces context cloning .",
    "in contrast to its competitors , in pull - tabbing any step is a simple and localized graph transformation .",
    "this fact should ease executing the steps in parallel .",
    "future work , aims at defining a pull - tab - aware parallel strategy and implementing it to measure the effectiveness of pull - tabbing .    ,",
    "antoy , s. , fischer , s. , and reck , f. 2010 . the pull - tab transformation . in _ proceedinsg of the third international workshop on graph computation models_. enschede ,",
    "the netherlands , 127133 .",
    "available at http://gcm-events.org/gcm2010/pages/gcm2010-preproceedings.pdf .",
    "optimal non - deterministic functional logic computations . in _ proceedings of the sixth international conference on algebraic and logic programming ( alp97)_. springer lncs 1298 , southampton , uk , 1630 .          ,",
    "brown , d. , and chiang , s. 2006 .",
    "lazy context cloning for non - deterministic graph rewriting . in _ proc .",
    "of the 3rd international workshop on term graph rewriting , termgraph06_. vienna , austria , 6170 .",
    ". set functions for functional logic programming . in _ proceedings of the 11th acm sigplan international conference on principles and practice of declarative programming ( ppdp 2009)_. lisbon , portugal , 7382 .      , hanus , m. , liu , j. , and tolmach , a. 2005 . a virtual machine for functional logic computations . in _ proc .",
    "of the 16th international workshop on implementation and application of functional languages ( ifl 2004)_. springer lncs 3474 , lubeck , germany , 108125 .",
    "\\2007 . on a tighter integration of functional and logic programming . in _",
    "aplas07 : proceedings of the 5th asian conference on programming languages and systems_. springer - verlag , berlin , heidelberg , 122138 .        \\1997 .",
    "on constructor - based graph rewriting systems .",
    "tech . rep .",
    "985-i , imag .",
    "available at ftp://ftp.imag.fr / pub / labo - leibniz / old - archives / pmp / c - graph - rewriting.p% s.gz[ftp://ftp.imag.fr / pub / labo - leibniz / old - archives / pmp / c - graph - rewriting.p% s.gz ] .",
    ", rodrguez - hortal , j. , and snchez - hernndez , j. 2007 . a simple rewrite notion for call - time choice semantics . in _ ppdp 07 : proceedings of the 9th acm sigplan international conference on principles and practice of declarative programming_. acm , new york , ny , usa , 197208 .",
    ", rodrguez - hortal , j. , and snchez - hernndez , j. 2008 . rewriting and call - time choice : the ho case . in _ proc . of the 9th international symposium on functional and logic programming ( flops 2008)_. springer lncs 4989 , 147162 .        ,",
    "antoy , s. , and nita , m. 2004 .",
    "implementing functional logic languages using multiple threads and stores . in _ proc .",
    "of the 2004 international conference on functional programming ( icfp)_. acm , snowbird , utah , usa , 90102 ."
  ],
  "abstract_text": [
    "<S> pull - tabbing is an evaluation approach for functional logic computations , based on a graph transformation recently proposed , which avoids making irrevocable non - deterministic choices that would jeopardize the completeness of computations . </S>",
    "<S> in contrast to other approaches with this property , it does not require an upfront cloning of a possibly large portion of the choice s context . </S>",
    "<S> we formally define the pull - tab transformation , characterize the class of programs for which the transformation is intended , extend the computations in these programs to include the transformation , and prove the correctness of the extended computations .    functional logic programming , non - determinism , graph rewriting </S>",
    "<S> , pull - tabbing     to 0pt -4.5 in to 0pt draft we d mar 30 17:21:24 pdt 2011 </S>"
  ]
}