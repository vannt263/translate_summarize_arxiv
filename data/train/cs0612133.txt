{
  "article_text": [
    "we are given a random variable @xmath0 with outcomes in a set of @xmath1 of source words with associated probabilities @xmath2 with @xmath3 , and a code word subset of @xmath4 , the set of finite binary strings .",
    "let @xmath5 denote the _ length _ ( number of bits ) in @xmath6 .",
    "let @xmath7 .",
    "the _ optimal source coding problem _ is to find a 1:1 mapping @xmath8 , satisfying @xmath9 is not a proper prefix of @xmath10 for every pair @xmath11 , such that @xmath12 is minimal among all such mappings .",
    "codes satisfying the prefix condition are called _ prefix codes _ or _",
    "instantaneous codes_.    this problem is solved theoretically up to 1 bit by shannon s noiseless coding theorem @xcite , and exactly and practically by a well - known greedy algorithm due to huffman  @xcite , which for @xmath13 source words runs in @xmath14 steps , or @xmath15 steps if the @xmath16 s are not sorted in advance .",
    "if @xmath17 achieves the desired minimum , then denote @xmath18 .",
    "we study the far more general question of length restrictions on the individual code words , possibly different for each code word .",
    "this problem has not been considered before .",
    "the primary problem in this setting is the problem with equality lengths restrictions , where we want to find the minimal expected code - word length under the restriction of individually prescribed code - word lengths for a subset of the code words .",
    "apart from being a natural question it is practically motivated by the desire to save some part of the code tree for future code words , or restrict the lengths of the code words for certain source words to particular values .",
    "for example , in micro - processor design we may want to reserve code - word lengths for future extensions of the instruction set .",
    "no polynomial time algorithm was known for this problem .",
    "initially , we suspected it to be np - hard . here , we show an @xmath19 dynamic programming algorithm .",
    "this method allows us to solve an integer programming problem that may be of independent interest .",
    "the key idea is that among the optimal solutions , some necessarily exhibit structure that makes the problem tractable .",
    "this enables us to develop an algorithm that finds those solutions among the many possible solutions that otherwise exhibit no such structure .",
    "formally , we are given _ length restrictions _",
    "@xmath20 , where the @xmath21 s are positive integer values , or the _ dummy _ @xmath22 , and we require that the coding mapping @xmath23 satisfies @xmath24 for every @xmath25 with @xmath26 .",
    "for example the length restrictions @xmath27 mean that we have to set @xmath28 and @xmath29 , say @xmath30 and @xmath31 .",
    "then , for the remaining @xmath32 s the coding mapping @xmath23 can use only code words that start with @xmath33 .",
    "we assume that the length restrictions satisfy below , the kraft s inequality @xcite , @xmath34 where we take @xmath35 for @xmath36 , since otherwise there does not exist a prefix code as required .",
    "* related work : * in @xcite a variant of this question is studied by bounding the maximal code - word length , which results in a certain redundancy ( non - optimality ) of the resulting codes . in @xcite both",
    "the maximal code - word length and minimal code - word length are prescribed .",
    "shannon s noiseless coding theorem @xcite states that if @xmath37 is the entropy of the source , then @xmath38 .",
    "the standard proof exhibits the shannon - fano code achieving this optimum by encoding @xmath32 by a code word @xmath9 of length @xmath39 ( @xmath25 ) . ignoring the upper rounding to integer values for the moment",
    ", we see that @xmath40 for a code that codes @xmath32 by a code word of length @xmath41 .",
    "this suggests the following approach .",
    "suppose we are given length restrictions @xmath42 .",
    "let @xmath43 be the set of equality length restrictions , and let @xmath44 be the minimal expected code - word length under these restrictions given the probabilities .",
    "similar to shannon s noiseless coding theorem , we aim to bound the minimal expected code - word length under equality restrictions below by an entropy equivalent @xmath45 where @xmath46 corresponds to the best possible coding with real - valued code - word lengths",
    ". define @xmath47 if we define @xmath48 s also for the @xmath32 s with @xmath49 such that @xmath50 , then altogether we obtain a new probability assignment @xmath48 for every @xmath32 ( @xmath25 ) , which has a corresponding shannon - fano code with code lengths @xmath51 for the @xmath32 s .",
    "moreover , with respect to the probabilities induced by the original random variable @xmath0 , and simultaneously respecting the length restrictions , the minimum expected code word length of such a @xmath52-based shannon - fano code is obtained by a partition of @xmath53 into @xmath48 s ( @xmath49 ) such that @xmath54 is minimized .",
    "clearly , the part @xmath55 can not be improved .",
    "thus we need to minimize @xmath56 over all partitions of @xmath57 into @xmath48 s .",
    "the partition that reaches the minimum @xmath58 does not change by linear scaling of the @xmath16 s .",
    "hence we can argue as follows .",
    "consider @xmath59 such that @xmath60 is the entropy of the set of probabilities @xmath61 .",
    "denote @xmath62 and define @xmath63 then , both @xmath58 and @xmath60 with the @xmath64 ( @xmath49 ) reaches their minimum for this partition of @xmath65 .",
    "[ lem.1 ] assume the above notation with with @xmath66 determined as above .",
    "the minimal expected prefix code length under given length restrictions is achieved by encoding @xmath32 with code length @xmath67 for all @xmath49 .",
    "let us compare the optimal expected code length under length constraints with the unconstrained case .",
    "the difference in code length is @xmath68 the kulback - leibler divergence @xmath69 between the @xmath70-distribution and the @xmath52-distribution @xcite .",
    "the kl - divergence is always nonnegative , and is 0 only if @xmath71 for all @xmath25 . for the optimum @xmath52-distribution determined in lemma  [ lem.1 ] for the index set @xmath72 we can compute it explicitly : @xmath73    [ lem.2 ] given a random source @xmath0 with probabilities @xmath2 ( @xmath25 ) , length restrictions @xmath20 and with @xmath66 determined as above .",
    "then , the minimum expected constrained code length is @xmath74 which equals the minimal expected unconstrained code word length @xmath75 only when @xmath76 for all @xmath25 .",
    "thus , the redundancy induced by the equality length restrictions is @xmath77 note that , just like in the unconstrained case we can find a prefix code with code word lengths @xmath78 , showing that the minimal expected integer prefix - code word length is in between the entropy @xmath79 and @xmath80 , the same holds for the constrained case .",
    "there , we constructed a new set of probabilities with entropy @xmath46 , and for this set of probabilities the minimal expected integer prefix - code word length is in between the entropy @xmath46 and @xmath81 by the usual argument .",
    "let us look at an example with probabilities @xmath82 and length restrictions @xmath83 .",
    "the entropy @xmath84 bits , and the , non - unique , huffman code , without the length restrictions , is @xmath85 , which shows the minimal integer code - word length of @xmath86 bits , which is @xmath87 bits above the noninteger lower bound @xmath79 .",
    "the redundancy excess induced by the equality length restrictions is @xmath88 bits , which shows that the integer minimal average code - word length @xmath44 is in between @xmath89 bits and @xmath90 bits .",
    "the actual optimal equality restricted code , given by algorithm a below , is @xmath91 with @xmath92 , which is @xmath93 bits above the noninteger lower bound @xmath46 .",
    "above we have ignored the fact that real shannon - fano codes have code - word length @xmath94 rather than @xmath95 .",
    "this is the reason that @xmath38 in the unconstrained case , leaving a slack of 1 bit for the minimal expected code word length .",
    "the huffman code is an on - line method to obtain a code achieving @xmath96 .",
    "gallager @xcite has proved an upper bound on the redundancy of a huffman code , @xmath97 of @xmath98 $ ] which is approximately @xmath99 , where @xmath100 is the probability of the least likely source message .",
    "this is slightly improved in @xcite .",
    "our task below is to find a huffman - like method to achieve the minimal expected code - word length @xmath44 in the length - constrained setting .",
    "our goal is to come as close to the optimum in lemmas  [ lem.1 ] , [ lem.2 ] as is possible .",
    "input is the set of source words @xmath101 with probabilities @xmath102 and length restrictions @xmath103 that should be satisfied by the target prefix code @xmath23 in the sense that @xmath104 for all @xmath105 except for the @xmath106 s with @xmath36 for which @xmath106 s there are no code word length restrictions .",
    "let @xmath107 , @xmath108 , and @xmath109 .",
    "denote @xmath110 for convenience in notation , assume that the source words @xmath101 are indexed such that @xmath111 with @xmath112 .",
    "if @xmath113 for some @xmath106 we set @xmath114 ; @xmath115 ; @xmath116 ; @xmath117 .",
    "we repeat this process until there are no equal lengths left , and finish with @xmath118 with @xmath119 s the resulting lengths .",
    "that is , we just iteratively merge two nodes which are at the same level in the tree .",
    "therefore , the problem is reduced to considering a code tree with forbidden code - word lengths @xmath119 ( @xmath120 , the largest forbidden length @xmath121 leading to a forbidden node with a free sibling node at the end of a path at the same length from the root .",
    "that is , a code word tree with a single available free node at each level @xmath122 , satisfying @xmath123 and @xmath124 ( @xmath125 ) .",
    "each @xmath122 corresponds to a path of length @xmath122 leading from the root to a node @xmath126 corresponding to a code - word prefix that is as yet unused .",
    "we call such a node ( and the path leading to it or the corresponding code - word prefix ) a _",
    "free stub_. denote the set of levels of these free stubs @xmath126 by @xmath127 , and let @xmath128 . without loss of generality ,",
    "@xmath129 with @xmath130 .",
    "we now have to the find a code - word tree using only the free stubs , such that the expected code - word length is minimized .",
    "we can do this in the straightforward manner , dividing the probabilities in @xmath131 among the @xmath132 free stubs , and computing the minimal expected code - word length tree for the probabilities for every stub for each of those divisions , and determining the division giving the least expected code - word length .",
    "we can use huffman s construction since it does nt depend on the probabilities summing to 1 .",
    "there are @xmath133 possible divisions , so this process involves computing @xmath133 huffman trees  exponentially many unless @xmath134 which is the unrestricted common huffman case .",
    "let @xmath135 denote the number of edges in a path from the leaf node labeled by @xmath70 to the root .",
    "so @xmath136 .",
    "then , if a tree is optimal ( has least expected code - word length ) , then @xmath137 since otherwise the expected code - word length can be decreased by interchanging @xmath70 and @xmath52 .",
    "if @xmath138 is a prefix - code word tree for the source words under the given length restrictions , then the subtree @xmath139 is the subtree of @xmath138 with the free stub @xmath140 as its root ( @xmath141 ) .",
    "suppose the contrary : for every optimal tree @xmath138 , there are @xmath145 with @xmath70 in @xmath139 and @xmath52 in @xmath144 for some @xmath142 .",
    "fix any such @xmath138 . by ,",
    "let @xmath147 be the subtree with root at @xmath148 containing the leaf @xmath70 .",
    "then we can interchange @xmath52 and @xmath147 without changing the expected code - word length represented by the tree .",
    "this idea leads to the following sorting procedure : repeat until impossible : find a least level probability , and if there are more than one of them a largest one , that violates the condition in the lemma , and interchange with a subtree as above .",
    "since no probability changes level the expected code - word length stays invariant . in each operation a least level violating probability moves to a lower indexed subtree , and the subtree it is interchanged with does not introduce new violating probabilities at that level .",
    "the transformation is iteratively made from the top to the bottom of the tree .",
    "this process must terminate with an overall tree satisfying the lemma , since there are only a given number of probabilities and indexed subtrees .",
    "for ease of notation we now assume that the source words @xmath149 are indexed such that the unrestricted source words are indexed @xmath150 with probabilities @xmath151 .",
    "the fact that we just have to look for a partition of the ordered list of probabilities into @xmath132 segments , rather than considering every choice of @xmath132 subsets of the set of probabilities , considerably reduces the running time to find an optimal prefix code .",
    "consider the ordered list @xmath152 .",
    "partition it into @xmath132 contiguous segments , possibly empty , which gives @xmath153 partitions .",
    "we can reduce this number by noting that in an optimal tree the free stubs are at different heights , and therefore each of them must have a tree of at least two elements until they have empty trees from some level down .",
    "otherwise the tree is not optimal since it can be improved by rearranging the probabilities .",
    "therefore , we can restrict attention to partitions into @xmath154 segements , which contain at least two elements . there are at most @xmath155 such partitions . for each choice , for each set of probabilities corresponding to a @xmath106th segment construct the huffman tree and attach it to the @xmath106th free stub , and compute the expected code - word length for that choice .",
    "a tree associated with the least expected codeword length is an optimal tree .",
    "thus , we have to construct at most @xmath155 huffman trees , which is polynomial in @xmath156 for fixed @xmath132 , and also polynomial in @xmath156 for either @xmath132 or @xmath157 bounded by a constant .      from each partition of @xmath158 into @xmath159 segments ( possibly empty ) consisting of probabilities @xmath160 for the @xmath161th segment , we can construct trees @xmath162 with @xmath163 having the probabilities of @xmath160 as the leaves , and free stub @xmath164 as the root .",
    "clearly , if @xmath138 is an overall tree with minimum expected code - word length , then each subtree with the free stub @xmath164 as root considered in isolation , achieves minimal expected code - word length over the probabilities involved .",
    "we want to find the optimal partition with a minimum amount of work .",
    "note that , from some @xmath165 on , every subtree @xmath163 with @xmath166 may be empty .    for every tree @xmath138 , not necessarily",
    "optimal , let @xmath167 denote the expected code - word length for the probabilities in @xmath131 according to tree @xmath138 .",
    "define @xmath168 $ ] to be the _ minimal _ expected code - word length of the leaves of a tree",
    "@xmath169 $ ] constructed from probabilities @xmath170 ( @xmath171 ) and with a singlefold path from the root of @xmath138 to the free stub node @xmath164 , and subsequently branching out to encode the source words ( probabilities ) concerned .",
    "then , @xmath172 = \\sum_{i \\leq r \\leq j } p_r ( h_k+l(p_r))\\ ] ] each probability @xmath173 labeling a leaf at the end of a path of length @xmath174 from the root of @xmath138 , the first part of length @xmath175 to the free stub @xmath164 , and the second part of length @xmath176 from @xmath164 to the leaf concerned . for a partition of the probability index sequence @xmath177 into @xmath132 ( possibly empty ) contiguous segments",
    "@xmath178 $ ] ( @xmath179 ) , inducing subtrees @xmath180 $ ] using free stubs @xmath175 accounting for expected code - word length @xmath181 $ ] , we obtain a total expected code - word length for the overall tree @xmath138 of @xmath182.\\ ] ] let us now consider the expected code word length of a tree @xmath183 which consists of tree @xmath138 with a subset of subtrees @xmath163 removed and the corresponding probabilities from the overall probability set @xmath131 . removing subtree @xmath163 is equivalent to removing the corresponding free stub @xmath164 , and turning it into a length restriction .",
    "let @xmath138 , @xmath131 and @xmath183 be defined as above .",
    "let @xmath138 has minimal total code - word length for @xmath131 then the total code - word length of every @xmath183 as above can not be improved by another partition of the probabilities involved among its subtrees .",
    "( _ if _ ) if we could improve the total code word length of @xmath138 by a redistribution of probabilities among the subtrees attached to the free stubs then some @xmath183 would not have minimal total code - word length before this redistribution .",
    "( _ only if _ ) if we could improve the total code - word length of any @xmath183 by redistribution of the probabilities among its subtrees attached to the free stubs involved , then we could also do this in the overall tree @xmath138 and improve its overall total code - word length , contradicting minimality .",
    "this suggests a way to construct an optimal @xmath138 by examining every @xmath161-partition corresponding to a candidate set of @xmath161 subtrees ( for @xmath184 ) , of every initial segment @xmath185 of the probability sequence ( for @xmath186 ) .",
    "the minimal expected code - word length tree for the @xmath161th partition element is attached to the @xmath161th free stub .",
    "the crucial observation is that by corollary  [ cor.seqopt1 ] the minimal total code word length for probabilities @xmath187 using free stub levels @xmath188 is reached for a binary split in the ordered probabilities and free stubs involved , consisting of the minimal total code - word length solution for probabilities @xmath189 using stub levels @xmath190 and probabilities @xmath191 using free stub level @xmath192 . computing the optimal minimum code - word lengths of initial probability segments and initial free stub level segments in increasing order , this way we find each successive optimum by using previously computed optima .",
    "this type of computation of a global optimum is called dynamic programming . the following algorithm",
    "a gives the precise computation . at termination of the algorithm ,",
    "the array @xmath193 $ ] will contain the minimal expected code word length of a tree @xmath194 $ ] using the largest @xmath195 ( @xmath196 ) probabilities @xmath197 , optimally divided into subtrees attached to the least level @xmath161 ( @xmath198 ) free stubs .",
    "thus , @xmath194 $ ] contains subtrees @xmath199 $ ] ( @xmath200 , @xmath201 ) each such subtree with @xmath202 as the root ( @xmath200 ) .",
    "thus , on termination @xmath203 $ ] contains the minimal expected code - word length of the desired optimal tree @xmath138 with subtrees @xmath204 with @xmath205 rooted at the root of @xmath138 and using free stubs @xmath206 , respectively .",
    "( note , @xmath205 consists of the previously defined subtree @xmath163 , rooted at free stub @xmath164 , plus the path from @xmath164 to the root of @xmath138 . )",
    "we can reconstruct these subtrees , and hence the desired code words , from the values of the array @xmath207 on termination .",
    "denote @xmath208 , @xmath209 , @xmath210 ( @xmath211 ) , and @xmath212 . then , @xmath213 $ ] and @xmath214 $ ] equals the expected code - word length of the source words encoded in subtrees @xmath215 ( @xmath179 ) .",
    "thus , the array values of @xmath207 give the desired partition of the ordered probability sequence @xmath152 , and we can trivially construct the tree @xmath138 and the code - words achieving minimal expected code - word length by huffman s construction on the subtrees .      *",
    "input : * given @xmath13 source words with ordered probabilities and equality length restrictions , first check whether is satisfied with @xmath216 , otherwise return `` impossible '' and quit .",
    "compute free stub levels @xmath217 .",
    "probabilities @xmath152 as above .",
    "* step 1 : * = compute = @xmath168 $ ] = as in , = for all @xmath218 and @xmath161 ( @xmath219 , @xmath179 ) .",
    "+ set @xmath220 : = h[1,j,1]$ ] ( @xmath221 ) .",
    "+ @xmath222 * do * + @xmath223 * do * + @xmath193 : = \\min_{i : 1 \\leq",
    "i \\leq j }   \\ { f[i , k-1 ] $ ] @xmath224 \\}$ ] ; + @xmath225 : = i_0 $ ] , with @xmath226 the least @xmath106 achieving the minimum +          the complexity of computing the @xmath217 and @xmath158 is @xmath227 .",
    "step 1 of the algorithm takes @xmath228 steps .",
    "first , compute for every @xmath218 the quantities @xmath229 : = \\sum_{i = r}^j l(p_r)$ ] , @xmath230 : = \\sum_{i = r}^j p_r l(_r)$ ] .",
    "there are @xmath231 such quantities and each computation takes @xmath232 steps .",
    "second , for every @xmath161 compute @xmath168 = l[i , j]+h_k p[i , j]$ ] .",
    "there are @xmath132 such quantities and each computation takes @xmath233 steps .",
    "step 2 of the algorithm takes @xmath232 steps .",
    "step 3 of the algorithm involves a outer loop of length @xmath234 , an inner loop of length @xmath156 , and inside the nesting the determining of the minimum of @xmath235 possibilities ; overall @xmath236 steps .",
    "the running time of the algorithm is therefore @xmath237 steps . since @xmath238 this shows the stated running time ."
  ],
  "abstract_text": [
    "<S> we study the new problem of huffman - like codes subject to individual restrictions on the code - word lengths of a subset of the source words . these are prefix codes with minimal expected code - word length for a random source where additionally the code - word lengths of a subset of the source words is prescribed , possibly differently for every such source word . </S>",
    "<S> based on a structural analysis of properties of optimal solutions , we construct an efficient dynamic programming algorithm for this problem , and for an integer programming problem that may be of independent interest . </S>"
  ]
}