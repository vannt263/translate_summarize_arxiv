{
  "article_text": [
    "multiple - choice tests are a common way of testing someone s knowledge , and in italy they are usually employed , among the many possible fields of application , during the admission tests for _ numerus clausus _",
    "university courses like medicine @xcite .",
    "this led to the foundation of many small enterprises that have the sole business of training students for getting a good rank by compiling those tests in the best possible way .    in order to cope with the necessity of",
    "automate the correction process for large numbers of hand - compiled multiple - choice tests , the junior enterprise of catania ( ject ) @xcite - the non profit students association to whom the two authors belong to - developed ject - omr , the system described in this article .    optical mark recognition ( omr )",
    "is a process for the detection and recognition of marks written on paper , that is often employed for the recognition of the answers checked in multiple - choice tests @xcite @xcite .",
    "the ject - omr system takes as input a digital image containing the scan of a paper test compiled by a student , and returns as output a vector containing , for each question , the answer that the student selected by tracing a cross in the chosen square , the blank squares and ( if any ) symbols with special meanings ( like the ones described in section  [ subsec : cancel ] ) .",
    "moreover , the system also returns the values of the barcodes present in the test , so that the it can be contextualized without manual intervention simply by interacting with the existing databases .",
    "the programming language used for the implementation of ject - omr is python @xcite , and the heart of the system is the gamera framework for documents analysis and recognition @xcite , that proved to be a valuable tool in various image analysis contexts @xcite @xcite and gave us a nice set of building blocks for our system .",
    "the article is structured as following .",
    "the structure of the tests processed by the system is explained in section  [ sec : test - structure ] .",
    "section  [ sec : diagram ] describes the system by analyzing its components and section  [ sec : performance ] presents the results of an accuracy test .",
    "there are two kinds of tests that ject - omr can analyze , that from now on will be called _",
    "kind a _ and _ kind b_.    the two models share the number of columns of multiple - choice questions ( 4 ) and the presence of two barcodes .    here",
    "are the main differences between the two kinds of document :    * * number of questions per column : * the system expects a document composed by four columns of questions and a given number of questions per column : the number of questions for each column changes from kind a to kind b ; * * size of the elements in the paper test : * ject - omr works with fixed - resolution images , and as described in section  [ subsec : segmentation ] it uses a fixed set of dimensions for each kind of document for the segmentation of the image into its different components . * * ways of canceling answers : * the system lets the user cancel already given answers , and , as described in section  [ subsec : cancel ] , the answers can be canceled in two different ways , one for each kind of test .",
    "figure  [ fig : doc - structure ] shows an annotated example document .",
    "the figure shows in light gray an example document with the highlighted regions found by the system , and in black there are some annotations that explains the structure of the document .",
    "of course the annotations point out only some elements of a given class ( e.g. : only few recognized marked answers are pointed out ) .",
    "annotated example document ]",
    "in this section the system will be described , and its basic blocks will be analyzed in detail .",
    "figure  [ fig : block - diagram ] shows the block diagram of the system .",
    "[ sec : diagram ]     block diagram of the recognition system ]      the pre - processing phase consists in a set of operations that make the scanned image more suitable for the further phases .",
    "the first operation performed to the image is the conversion to gray scale ; then the image is converted into black and white format using the global otsu thresholding method @xcite , which is gamera s default binarization method .",
    "next the system does a compensation of rotation effects induced by the scanning operation .",
    "the rotation is estimated and then it is corrected by rotating the image in the opposite direction by the same angle .",
    "the rotation correction is performed using a projection profile based algorithm built into gamera .    in this phase",
    "it is clear that using the gamera framework is a good choice , because it offers abstractions that allow the programmer to concentrate on the problem domain .",
    "for example , the operations described above are done by as little code as shown in listing  [ lst : pre - processing ] .    ....",
    "image = image.to_greyscale ( )      image = image.otsu_threshold ( )      angle = image.rotation_angle_projections(-15 , 15)[0 ]      image = image.rotate(angle , 0 ) ....    finally , the system finds the upper left black square , marked as _ origin _ in figure  [ fig : doc - structure ] , by performing a connected component analysis and finding the glyph whose coordinates ( ` offset_x ` and ` offset_y ` ) are the nearest to the point @xmath0 .",
    "those coordinates are called the _ origin _ of the test , and are used as the reference point for any subsequent elaboration .",
    "after the pre - processing phase , ject - omr extracts from the image the regions containing the barcodes and the compiled questions , using empirically determined dimensions relative to the origin of the test .",
    "the dimensions are expressed in pixels as the scanning resolution of the input images is fixed .",
    "figure  [ fig : doc - structure ] shows some of the regions identified in this phase .",
    "the four regions that contain the questions are the four columns that will be processed by the algorithm described in section  [ subsec : answer - recognition ] .    as explained in section  [ sec : test - structure ] , the two kinds of test are structurally slightly different .",
    "this means that the program uses two different sets of dimensions , one for each kind of test .",
    "each column of questions is split into equal - height rows , that are analyzed one by one .",
    "each row is an image region that represents a question , from which the chosen answer ( if any ) is extracted .",
    "figure  [ fig : question-42 ] shows an example row .",
    "example row ]    here is how the answer classification algorithm works .",
    "first of all , the image is split into connected components , that are sorted according to horizontal position , from left to right .",
    "if there are no errors , the system finds 5 components relative to the 5 squares available for choosing the answer , of which one might be checked .",
    "if the analysis returns a number of component different than 5 , the analysis is revised and repeated : using an adaptive algorithm , that changes the thresholds until it does not find an acceptable number of components , the system classifies each glyph using two features : the number of black pixels ( ` black_area ` , natively available in gamera ) and the squareness ( computed as ` abs(num_rows - num_columns ) ` ) .",
    "once the glyphs corresponding to squares are found , they are analyzed in order to classify them as _ chosen _ squares or _",
    "empty _ squares .",
    "gamera provides a statistical knn classifier , but for this specific problem a simple heuristic approach based on threshold values was sufficient .",
    "the features used in this classification are the number of black pixels and the number of holes inside the image .",
    "if a square was marked by the student , and thus must be classified as _ chosen _ , the number of holes ( white regions surrounded by black regions ) will be bigger than if the square were not marked .",
    "this can be clearly seen in figure  [ fig : question-42 ] , where the fourth square would labeled by the system as _ chosen _ and the other four as _",
    "empty_.    the condition used to classify each square was found empirically , and it is composed by 3 sub - conditions :    1 .",
    "threshold on holeness 2 .",
    "threshold on black_area 3 .",
    "combined threshold over the weighted sum of holeness and black_area    using this algorithm , the system analyzes each row and extracts a 5-elements vector where the @xmath1-th position in 1 if the corresponding square is _ chosen _ , and 0 if it is _",
    "empty_.    the output of this phase is a @xmath2 matrix , where @xmath3 is the number of questions in the test .      when the student is compiling the test , he can undo his actions by canceling his answers in the following ways : if the test is of kind a , the student can cancel an answer by making the selected square completely black ; if the test is of kind b , the student can mark the circle that is drawn to the left of the question , and the system will not consider the answer that the student selected .",
    "the circle used in the kind b is simply the leftmost glyph in the row , and it is recognized as full or empty using the ` black_area ` feature .",
    "figure  [ fig : canceled ] shows an example of each of the two cancellation methods .",
    "examples of canceled questions ( top : kind a ; bottom : kind b ) ]      the barcodes recognized by the system are discrete two - width barcodes that encode binary strings .",
    "the information is encoded only in the bars and not in the spaces , differently from many higher - density barcodes like interleaved 2 of 5 and code 128 .",
    "the binary string is 26 bits wide , and contains 2 start bits ( the first two , both holding the value 1 ) and two end bits ( holding respectively the values 1 and 0 ) .",
    "the bits from 3 to 22 contain the binary representation of the number encoded in the barcode .",
    "the bits 23 and 24 contain the parity of the number of ones and zeros used for the representation of the number .",
    "this format was used because the software that prints the paper tests recognized by ject - omr uses it , so the system must be able to understand it .    the rest of this section describes how the barcode recognition algorithm works .",
    "each region containing a barcode is first processed by the rotation correction algorithm described in section  [ subsec : preprocessing ] , because the recognition algorithm requires that the barcode lines are vertical .",
    "the algorithm is executed for each barcode because some of them are not printed directly into the test , but are applied by the student using a sticker .",
    "this means that usually they will not be parallel to the rest of the test , and that they could need another adjustment in order to be suitable for the recognition .",
    "next , the region is vertically split in 5 sub - regions , each of them is analyzed by the same recognition algorithm .",
    "this algorithm does as its first step a connected component analysis , and sorts the resulting glyphs by horizontal position .",
    "next the algorithm measures the @xmath4-extension of each glyph . if its value is higher than a given threshold , the glyph represents the value 1 , otherwise it represents a 0 .    from each sub - region",
    "the algorithm computes a number in binary form , that is then converted to decimal and compared to the values obtained from the other sub - regions .",
    "the algorithm returns the number that is obtained from the highest number of sub - regions .",
    "this implies that if the barcode is slightly damaged it can be read regardless of the damage .",
    "sometimes it happens that the system can not perform its tasks because of some unknown error , maybe because of low - quality scans or unexpected pen strokes made by the students .",
    "when error conditions , like more or less than five squares in a row , are detected by the system , it adds the number of the question being analyzed to a list of rows that could not be processed , and shows to the user a simple graphical user interface ( gui ) for error correction .",
    "the gui was written using wxpython @xcite , the python bindings of the cross - platform user interface toolkit wxwidgets , and shows to the user an image of the scanned test where the results of the elaboration are marked using different colors for the different regions of the image , and lets him correct manually the recognition errors detected earlier by the system .",
    "in order to evaluate the performance of the system , we measured its accuracy in two crucial tasks : the recognition of squares related to answers in multiple - choice questions and the recognition of barcodes .",
    "the results of the accuracy tests are shown in table  [ tab : results ] .",
    ".results of the performance evaluation [ cols=\"<,^,^,^\",options=\"header \" , ]",
    "this work presented ject - omr , a recognition system for multiple - choice tests based on the gamera framework .",
    "the results of the tests show that the application is quite mature , and it has been used for more than two years by a small enterprise whose mission is to prepare students for multiple - choice tests used in the admission test of numerus clausus university courses .",
    "although the recognition approach based on fixed thresholds proved to work fairly well , in future we might evaluate a recognition algorithm based on the knn classifier built into gamera , as it would probably be easier to use and more robust to unforeseen usage conditions or marks .",
    "any other future work will probably be done for improving the usability of the error correction gui and for the implementation of new features as the italian education ministry changes the mechanism of the test for numerus clausus courses .",
    "h.  kubo , h ,  ohashi , m.  tamamura , t.  kowata , i.  kaneko : _ shared questionnaire system for school community management .",
    "_ international symposium on applications and the internet workshops , pp .  439 - 445 ( 2004 )"
  ],
  "abstract_text": [
    "<S> this article describes ject - omr , a system that analyzes digital images representing scans of multiple - choice tests compiled by students . </S>",
    "<S> the system performs a structural analysis of the document in order to get the chosen answer for each question , and it also contains a bar - code decoder , used for the identification of additional information encoded in the document . </S>",
    "<S> ject - omr was implemented using the python programming language , and leverages the power of the gamera framework in order to accomplish its task . </S>",
    "<S> the system exhibits an accuracy of over 99% in the recognition of marked and non - marked squares representing answers , thus making it suitable for real world applications . </S>"
  ]
}