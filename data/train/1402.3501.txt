{
  "article_text": [
    "triangular matrix factorization is a main building block in computational linear algebra .    driven by a large range of applications in computational sciences ,",
    "parallel numerical dense lu factorization has been intensively studied since several decades which results in software of great maturity ( e.g. , linpack is used for benchmarking the efficiency of the top 500 supercomputers  @xcite ) .",
    "more recently , efficient sequential exact linear algebra routines were developed  @xcite .",
    "they are used in algebraic cryptanalysis , computational number theory , or integer linear programming and they benefit from the experience in numerical linear algebra . in particular , a key point there is to embed the finite field elements in integers stored as floating point numbers , and then rely on the efficiency of the floating point matrix multiplication ` dgemm ` of the blas .",
    "the conversion back to the finite field , done by costly modular reductions , is delayed as much as possible .",
    "hence a natural ingredient in the design of efficient dense linear algebra routines is the use of block algorithms that result in gathering arithmetic operations in matrix - matrix multiplications .",
    "those can take full advantage of vector instructions and has a high computation per memory access rate , allowing to fully overlap the data accesses by computations and hence delivers peak performance efficiency .    in order to exploit the power of multi - core and many - core architectures",
    ", we now investigate the parallelization of the finite field linear algebra routines .",
    "we report in this paper the conclusions of our experience in parallelizing exact lu decomposition for shared memory parallel computers .",
    "we try to emphasize which specificities of exact computation domains led us to use different approaches than that of numerical linear algebra .    in short",
    ", we will illustrate that numerical and exact lu factorization mainly differ in the following aspects :    * the pivoting strategies , * the cost of the arithmetic ( of scalars and matrices ) , * the treatment of rank deficiencies .",
    "those have a direct impact on the shape and granularity of the block decomposition of the matrix used in the computation .    [",
    "[ types - of - block - algorithms . ] ] types of block algorithms .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    several schemes are used to design block linear algebra algorithms : the splitting can occur on one dimension only , producing row or column slabs  @xcite , or both dimensions , producing tiles  @xcite . note that , here , we denote by tiles a partition of the matrix into sub - matrices in the mathematical sense regardless what the underlying data storage is .",
    "algorithms processing blocks can be either iterative or recursive .",
    "figure  [ fig : blockalg ] summarizes some of the various existing block splitting obtained by combining these two aspects .",
    "most numerical dense gaussian elimination algorithms , like in @xcite , use tiled iterative block algorithms . in  @xcite the classic tiled iterative algorithm",
    "is combined with a slab recursive one for the panel elimination . over exact domains ,",
    "recursive algorithms are preferred to benefit from fast matrix arithmetic ( see below ) .",
    "slab recursive exact algorithms can be found in  @xcite and references therein and  @xcite presents a tiled recursive algorithm .",
    "[ [ the - granularity ] ] the granularity + + + + + + + + + + + + + + +    is the block dimension ( or the dimension of the smallest blocks in recursive splittings )",
    ". matrices with dimensions below this threshold are treated by a base - case variant ( often referred to as the panel factorization ) .",
    "it is an important parameter for optimizing efficiency : a finer grain allows more flexibility in the scheduling when running numerous cores , but it also challenges the efficiency of the scheduler and can increase the bus traffic .    [ [ the - cost - of - the - arithmetic . ] ] the cost of the arithmetic .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    in numerical linear algebra , the cost of arithmetic operations is more or less associative : with dimensions above a rather low threshold ( typically a few hundreds ) , sequential matrix multiplication of the blas reaches the peak efficiency of the processor .",
    "hence the granularity has very little impact on the efficiency of a block algorithm run in sequential . on the contrary , over a finite field",
    ", a small granularity can imply a larger number of costly modular reductions , as we will show in section  [ sec : modcount ] .",
    "moreover , numerical stability is not an issue over a finite field , and asymptotically fast matrix multiplication algorithms , like winograd s variant of strassen algorithm  @xcite can be used on top of the blas .",
    "their speed - up increases with matrix dimension .",
    "the cost of sequential matrix multiplication over finite field is therefore not associative : a larger granularity delivers better sequential efficiency .",
    "[ [ pivoting - strategies - and - rank - deficiencies . ] ] pivoting strategies and rank deficiencies .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in dense numerical linear algebra , pivoting is used to ensure good numerical stability and good data locality  @xcite . in the context of dense _ exact _ linear algebra ,",
    "stability is no longer an issue . instead",
    ", only certain pivoting strategies will reveal the echelon form or , equivalently , the rank profile of the matrix  @xcite .",
    "this is a key invariant used in many applications using exact gaussian elimination , such as grbner basis computations  @xcite and computational number theory  @xcite .    over exact domains",
    ", the rank deficiency of some blocks also leads to unpredictable dimensions of the tiles or slabs , as will be illustrated in section  [ sec : rankdef ] .",
    "this makes the block splitting necessarily dynamic contrarily to the case of numerical lu factorization where all panel blocks usually have full rank and the splitting is done statically according to a granularity parameter .",
    "consequently the design of a parallel exact matrix factorization necessarily differs from the numerical algorithms as follows :    * granularity should be as large as possible , to reduce modular reductions and benefit from fast matrix multiplication ; * algorithms should preferably be recursive , to group arithmetic operations in matrix products as large as possible .",
    "* block splitting and pivoting strategies must preserve and reveal the rank profile of the matrix    it also implies several requirements on the parallel run - time being used :    * the block splitting has to be dynamically computed ; * the computing load for each task is not known in advance ( some panel blocks may have high rank deficiency ) , making the tasks very heterogeneous .",
    "this motivated us to look into parallel execution runtimes using tasks with work - stealing based scheduling .",
    "all experiments have been conducted on a 32 cores intel xeon e5 - 4620 2.2ghz ( sandy bridge ) with l3 cache(16384 kb ) .",
    "the numerical blas is atlas v3.11.4 , lapack v3.4.2 and plasma v2.5.0 .",
    "we used x - kaapi-2.1 version with last git commit : xkaapi_2.1 - 30-g263c19c638788249 .",
    "the gcc compiler version used is gcc 4.8.2 that supports openmp 3.1 .",
    "we introduce in section  [ sec : prelim ] the algorithmic building blocks on which our algorithms will rely and the parallel programming models and runtimes that we used in our experiments . in order to handle each problem separately , we focus in section  [ sec : fullrank ] on the simpler case where no rank deficiency occur . in particular section  [ sec : modcount ] presents detailed analysis of the number of modular reductions required by various block algorithms including the tiled and slab recursive , the left - looking , right - looking and crout variants of the tiled iterative algorithm .",
    "lastly section  [ sec : rankdef ] deals with elimination with rank deficiencies .",
    "we there present and compare new slab iterative , tiled iterative and tiled recursive parallel algorithms that preserve rank profiles .",
    "we then show that the latter can match state of the art numerical routines , even when taking rank deficiencies into account .",
    "all block algorithms that we will describe rely on four type of operations that we denote using the blas / lapack naming convention :    ` gemm ` : : :    general matrix multiplication , computing    @xmath0 , ` trsm ` : : :    solving upper / lower triang . syst . with matrix",
    "right / left h.s    @xmath1 . `",
    "laswp ` : : :    permuting rows or columns by sequence of swaps . `",
    "getrf ` : : :    computing @xmath2 , @xmath3 and @xmath4    stored in place of @xmath5 , s.t . @xmath6 .",
    "a first prefix letter ` d ` or ` f ` is specifies if the routine works over double precision floating point numbers or finite field coefficients and an optional prefix ` p ` stands for parallel implementation .",
    "our implementations use the sequential routines of the ` fflas - ffpack`library  @xcite . there ,",
    "the elements of a finite @xmath7 for a prime @xmath8 of size about 20 bits are integers stored in a double precision floating point number .",
    "the sequential ` fgemm`routine combines recursive steps of winograd s algorithm calls to numerical blas ` dgemm`and reductions modulo @xmath8 when necessary .",
    "the ` ftrsm`and ` fgetrf`routines use block recursive algorithms to reduce most arithmetic operations to ` fgemm ` .",
    "more precisely ` fgetrf`is either done by a slab recursive algorithm  @xcite or a tile recursive algorithm  @xcite .",
    "we base our implementation on the task based parallel features of openmp standard .",
    "this is motivated by the use of recursive algorithms where tasks are mandatory .",
    "now in tile iterative algorithms , loop with tasks happen to perform at least as good as parallel loops .    `",
    "libgomp`is the gnu implementation of the openmp api for multi - platform shared - memory parallel programming in c / c++ and fortran .",
    "alternatively , we also used ` libkomp `  @xcite , an optimized version of ` libgomp ` , based on the ` xkaapi`runtime , that reduces the overhead of the openmp directives and handles more efficiently threads creation , synchronization and management . in the experiments of the next sections",
    ", we will compare efficiency of the same code linked against each of these two libraries .      in the iterative block algorithms , all matrix product tasks are sequential , on the contrary the recursive block algorithms must call parallel matrix products `",
    "pfgemm ` , which we describe here .",
    "operation ` pfgemm`is of the form @xmath9 .    in order to split the computation into independent tasks , only the row dimension of @xmath5 and the column dimension of @xmath10 only are split .",
    "the granularity of the split can be chosen in two different ways : either as a fixed value , or by a ratio of the input dimension ( e.g. the total number of cores ) .",
    "we chose the second option that maximizes the size of the blocks while ensuring a large enough number tasks to for the computing ressources .",
    "all our experiments showed that this option performs better than the first one .",
    "when used as a subroutine in a parallel factorization , it will create more tasks than the number of available cores , but this heuristic happen to be a good compromise in terms of efficiency .",
    "figure  [ fig : pfgemmtime ] shows the computation time on 32 cores of various matrix multiplications : the numerical ` dgemm`implementation of ` plasma - quark ` , the implementation of ` pfgemm`of ` fflas - ffpack`using openmp tasks , linked against the ` libkomp`library .",
    "this implementation is run over the finite field @xmath11 or over field of real double floating point numbers , with or without fast strassen - winograd s matrix product .",
    "one first notices that most routine perform very similarly .",
    "more precisely , ` plasma - quark``dgemm`is faster on small matrices but the effect of strassen - winograd s algorithm makes ` pfgemm`faster on larger matrices , even on the finite field where additional modular reductions occur .",
    "+    in terms of speed - up , the ` pfgemm`reaches a factor of approximately 27 ( using 32 cores ) whereas the numerical ` dgemm`of ` plasma - quark`reaches a factor of 29 , but this is mostly reflect the fact that ` dgemm`has a less efficient sequential reference timing since it does not use strassen - winograd s algorithm .",
    "similarly , other basic routines used in the recursive block algorithms , such as ` ftrsm`(solving matrix triangular systems ) and ` flaswp`(permuting rows or columns ) , have been parallelized by splitting a dimension into a constant number of blocks ( typically the number of cores ) .",
    "in this section , we make the assumption that no rank deficiency occur during the elimination of any of the diagonal block .",
    "this hypothesis is satisfied by matrices with generic rank profile ( i.e. having all their leading principal minor non zero ) .",
    "this assumption allows us to focus on the problem of reducing the modular reduction count .      when computing over finite field , it is of paramount importance to reduce the number of modular reductions in the course of linear algebra algorithms .",
    "the classical technique is to accumulate several multiplications before reducing , namely replacing @xmath12 with @xmath13 while keeping the result exact .",
    "if @xmath14 and @xmath15 are integers between @xmath16 and @xmath17 this is possible with integer or floating point units if the result does not overflow , or in other words if @xmath18 , see , e.g. , @xcite for more details .",
    "this induces a splitting of matrices in blocks of size the largest @xmath19 satisfying the latter condition .",
    "now the use of block algorithms in parallel , introduces a second blocking parameter that interferes in the number of reductions",
    ". we will therefore compare the number of modular reductions of three variants of the tile iterative algorithm ( left - looking , right - looking and crout , see  @xcite ) , the slab recursive algorithm of  @xcite , and the tile recursive algorithm of  @xcite .",
    "for the sake of simplicity , we will always assume that the block dimensions in the parallel algorithms are always below @xmath19 .",
    "in other words operations are done with full delayed reduction for a single multiplication and any number of additions : operations of the form @xmath20 are reduced modulo @xmath8 only once at the end of the addition , but @xmath21 requires two reductions .",
    "for instance , with this model , the number of reductions required by a classic multiplication of matrices of size @xmath22 by @xmath23 is simply : @xmath24 . from (",
    "* theorem  3 ) , this extends also for triangular solving @xmath25 to @xmath26 : with unit diagonal , @xmath27 ( actually the computation of the lowest row of the solution requires no modulo as it is just a division by @xmath28 , we will therefore rather use @xmath29 ) and @xmath30 ( with the previous refinement for @xmath31 , this also reduces to @xmath32 ) .",
    "table  [ tab : blockvariants ] sketches the different shapes of the associated routine calls in the main loop of each variant .",
    "ccc left looking & crout & right looking +    ` utrsm`((i-1)k,(i-1)k , k ) ` gemm`(n-(i-1)k,(i-1)k , k ) ` pluq`(k , k ) ` trsm`(k , k , n - ik )    &    ` gemm`(n-(i-1)k,(i-1)k , k ) ` gemm`(k,(i-1)k , n - ik ) ` pluq`(k , k ) ` utrsm`(k , k , n - ik ) ` trsm`(k , k , n - ik )    &    ` pluq`(k , k ) ` utrsm`(k , k , n - ik ) ` trsm`(k , k , n - ik ) ` gemm`(n - ik , k , n - ik )     +    then the number of modular reductions required for these different lu factorization strategies is given in table  [ tab : modcount ] .",
    ".counting modular reductions in full rank block lu factorization of an @xmath33 matrix modulo @xmath8 when @xmath34 , for a block size of @xmath35 dividing @xmath36 . [ cols=\"^,<,^ \" , ]          in figure  [ fig : moduloblocklu ] we compare the tiled iterative variants with the tiled recursive algorithm .",
    "the latter uses as a base case an iterative crout algorithm too which performs fewer modular operations ,    the tiled recursive algorithm performs better than all other tiled iterative versions .",
    "this can be explained by a finer and more adaptive granularity and a better locality .",
    "the left looking variant performs poorly for it uses an expensive sequential ` trsm`task . although crout and right - looking variant perform about the same number of matrix products , those of an iteration of the right - looking variant are independent , contrarily to those of the crout variant , which explains a better performance despite a larger number of modular reductions .",
    "figure  [ fig : doubleblocklu ] shows the performance without modular reductions , of the tiled recursive parallel implementation on full rank matrices compared to ` plasma - quark ` .",
    "the best block size for the latter library was determined by hand for each matrix size .",
    "the two possible data - storage for ` plasma - quark`are used : the collection of tiles or the row - major data - storage .",
    "our tiled recursive parallel pluq implementation without modular reductions behaves better than the ` plasma - quark``getrf_tile ` .",
    "this is mainly due to the bi - dimensional cutting which allows for a faster panel elimination , parallel ` trsm`computations , more balanced ` gemm`computations and some use of strassen - winograd s algorithm .",
    "this explains why performance join again on more than 24 cores : the size of the sequential blocks get below the threshold where this algorithm speeds up computations ( typically 2400 on this machine ) .",
    "we now consider the general case of matrices with arbitrary rank profile , that can lead to rank deficiencies in the panel eliminations .",
    "algorithms computing the row rank profile ( or equivalently the column echelon form ) used to share a common pivoting strategy :    to search for pivots in a row - major fashion and consider the next row only if no non - zero pivot was found ( see  @xcite and references therein ) .",
    "such an iterative algorithm can be translated into a slab recursive algorithm splitting the row dimension in halves ( as implemented in sequential in  @xcite ) or into a slab iterative algorithm .",
    "more recently , we presented in  @xcite a more flexible pivoting strategy that results in a tile recursive algorithm , cutting both dimensions simultaneously .",
    "as a by product , both row and column rank profiles are also computed simultaneously .",
    "[ [ a - slab - iterative - algorithm . ] ] a slab iterative algorithm .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    in the slab iterative algorithm shown in figure  [ fig : tilecup ] , each panel factorization has to be run by a sequential algorithm .",
    "this sequential task is costly and therefore imposes a choice of a fine granularity , which , as we saw , on the other hand implies more modular reductions and a lesser speed - up of strassen - winograd s algorithm .",
    "another difficulty is the fact that the starting column position of each panel is determined by the rank of the blocks computed so far .",
    "it can only be determined dynamically upon the execution .",
    "this implies in particular that no data - storage by tiles , that fit the tiles of the algorithm is possible here .",
    "moreover , the workload of each block operation may strongly vary , depending on the rank of the corresponding slab .",
    "such heterogeneous tasks lead us to opt for work - stealing based runtimes instead of static thread management .",
    "[ [ tiled - iterative - elimination . ] ] tiled iterative elimination .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    in order to speed - up the panel computation , we can split it into column tiles .",
    "thanks to the pivoting strategy of  @xcite , it is still possible to recover the rank profiles afterwards . now with this splitting , the operations remain more local and updates can be parallelized .",
    "this approach shares similarities with the recursive computation of the panel described in  @xcite .",
    "figure  [ fig : panel - pluq ] illustrates this tile iterative factorization obtained by the combination of a row - slab iterative algorithm , and a column - slab iterative panel factorization .",
    "this optimization used in the computation of the slab factorization improved the computation speed by a factor of 2 , to achieve a speed - up of 6.5 on 32 cores with ` libkomp ` .",
    "[ [ tiled - recursive - elimination . ] ] tiled recursive elimination .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +",
    "lastly , the tile recursive algorithm described in  @xcite can be run in parallel using recursive tasks and the ` pfgemm ` , ` ftrsm`and ` flaswp`routines .",
    "contrarily to most recursive factorization algorithms , the recursive splitting is done in four quadrants",
    ".    it has the interesting feature that if the tile top - left tile is rank deficient , then the elmination of the bottom - left and top - right tiles can be parallelized .",
    "figure  [ fig : pluq - gflops ] shows performance obtained for the tiled recursive and the tiled iterative factorization .",
    "both versions are tested using ` libgomp`and ` libkomp`libraries .",
    "the input ` s16k ` is a @xmath37 matrix with low rank deficiency ( rank is 15500 ) .",
    "linearly independant rows and columns of the generated matrix are uniformly distributed on the dimension .     with rank @xmath38,title=\"fig : \" ] +    the implementation with openmp of the tiled recursive lu maintained high efficiency in the case of rank deficient matrices .",
    "it attained a speed - up of 13.6 on 32 cores . besides the fact that it benefits from strassen - winograd implementation",
    ", it is adapted to minimize memory accesses and optimize data placement .",
    "using ` libkomp`instead of ` libgomp`library and numactl , for round and robin interleave memory placement , that helps reducing dependency on bus speed , we manage to obtain peak performance for our tiled recursive lu factorization .",
    "we analyzed five different algorithms for the computation of gaussian elimination over a finite field .",
    "the granularity surely optimizes the parallelization of these algorithms but at the cost of more modular operations .",
    "algorithm optimizing modular reductions are unfortunately not the most efficient in parallel .",
    "the best compromise is obtained with our recursive tiled algorithm that performs best in both aspects .",
    "our future work focuses on two main issues .",
    "first , the use of specific allocators that can be used for a better mapping of data in memory and reduce distant accesses .",
    "second , parallel programming frameworks for multicore processors @xcite could be more effective than binding threads on each numa node .",
    "dataflow based dependencies , like when using openmp 4.0 directives , can ensure more parallelism for recursive implementation using ` libkomp`@xcite library ."
  ],
  "abstract_text": [
    "<S> we propose efficient parallel algorithms and implementations on shared memory architectures of lu factorization over a finite field . compared to the corresponding numerical routines , we have identified three main difficulties specific to linear algebra over finite fields . </S>",
    "<S> first , the arithmetic complexity could be dominated by modular reductions . </S>",
    "<S> therefore , it is mandatory to delay as much as possible these reductions while mixing fine - grain parallelizations of tiled iterative and recursive algorithms . </S>",
    "<S> second , fast linear algebra variants , e.g. , using strassen - winograd algorithm , never suffer from instability and can thus be widely used in cascade with the classical algorithms . there , trade - offs are to be made between size of blocks well suited to those fast variants or to load and communication balancing . </S>",
    "<S> third , many applications over finite fields require the rank profile of the matrix ( quite often rank deficient ) rather than the solution to a linear system . </S>",
    "<S> it is thus important to design parallel algorithms that preserve and compute this rank profile . moreover , as the rank profile is only discovered during the algorithm , block size has then to be dynamic . </S>",
    "<S> we propose and compare several block decomposition : tile iterative with left - looking , right - looking and crout variants , slab and tile recursive .    </S>",
    "<S> experiments demonstrate that the tile recursive variant performs better and matches the performance of reference numerical software when no rank deficiency occur . </S>",
    "<S> furthermore , even in the most heterogeneous case , namely when all pivot blocks are rank deficient , we show that it is possbile to maintain a high efficiency . </S>"
  ]
}