{
  "article_text": [
    "the cluster - update algorithm introduced for simulations of the potts model by swendsen and wang in 1987 @xcite has been a spectacular success , reducing the effect of critical slowing down by many orders of magnitude for the system sizes typically considered in computer simulation studies .",
    "a number of generalizations , including an algorithm for continuous - spin systems and the single - cluster variant @xcite as well as more general frameworks for cluster updates @xcite , have been suggested following the initial work of ref .",
    "the single bond update introduced by sweeny @xcite several years before swendsen s and wang s work is considerably less well known .",
    "this is mostly due to difficulties in its efficient implementation in a computer code , which is significantly more involved than for the swendsen - wang algorithm . in deciding about switching the state of a given bond from inactive to active or _ vice versa _ , one must know the consequences of the move for the connectivity properties of the ensemble of clusters , i.e. , whether two previously disjoint clusters will become connected or an existing cluster is broken up by the move or , instead , the number of clusters will stay unaffected .",
    "if implemented naively , these connectivity queries require a number of steps which is asymptotically close to proportional to the number of spins , such that the resulting _ computational critical slowing down _ outweighs the benefit of the reduced autocorrelation times of the updating scheme .",
    "even though it was recently shown that the decorrelation effect of the single - bond approach is asymptotically _ stronger _ than that of the swendsen - wang approach @xcite , this strength can only be played once the computational critical slowing down is brought under control . here",
    ", we use a poly - logarithmic dynamic connectivity algorithm as recently suggested in the computer science literature @xcite to perform bond insertion and removal operations as well as connectivity checks in run - times only logarithmically growing with system size , thus removing the problem of algorithmic slowing down . as the mechanism as well as",
    "the underlying data structures for these methods are not widely known in the statistical physics community , we here use the opportunity to present a detailed description of the approach . for the convenience of the reader",
    ", we also provide a python class implementing these codes , which can be used for simulations of the random - cluster model or rather easily adapted to different problems where dynamic connectivity information is required .",
    "we consider the random - cluster model ( rcm ) @xcite which is a generalization of the bond percolation problem introducing a correlation between sites and bonds .",
    "it is linked to the @xmath0-state potts model through the fortuin - kasteleyn transformation @xcite , generalizing the potts model to arbitrary real @xmath1 .",
    "special cases include regular , uncorrelated bond percolation ( @xmath2 ) as well as the ising model ( @xmath3 ) . to define the rcm , consider a graph @xmath4 with vertex set @xmath5 , ( @xmath6 ) , and edge set @xmath7 , ( @xmath8 ) .",
    "we associate an occupation variable @xmath9 with every edge @xmath10 .",
    "we say that @xmath11 is _ active _ if @xmath12 and _ inactive _ otherwise .",
    "the state space @xmath13 of the rcm corresponds to the space of all ( spanning is spanning if it contains all vertices of @xmath14 . ] ) sub - graphs , @xmath15 a configuration is thus represented as @xmath16\\in\\omega$ ] and corresponds uniquely to a sub - graph @xmath17 with @xmath18 the probability associated with a configuration @xmath19 is given by the rcm probability density function ( pdf ) @xmath20q^{k(\\vec{\\omega } ) } ,      \\label{eq : rcm_pmf}\\\\      z(p , q ) & \\equiv & \\sum_{\\vec{\\omega}\\in\\omega } \\left[\\prod_{e\\in e}p^{\\omega(e)}(1-p)^{1-\\omega(e)}\\right]q^{k(\\vec{\\omega } ) }      \\label{eq : rcm_pmf_2},\\end{aligned}\\ ] ] where @xmath21 is the number of connected components ( clusters ) and @xmath22 denotes the rcm partition function .",
    "more generally , as a function of the parameters @xmath23 $ ] , the density of active edges , and @xmath24 , the cluster number weight , these expressions define a family of pdfs .",
    "it is worthwhile to mention a number of limiting cases . for @xmath25 eq .",
    "( [ eq : rcm_pmf ] ) factorizes and corresponds to independent bond percolation with @xmath26 . in the limit of @xmath27 with fixed ratio @xmath28",
    ", on the other hand , it corresponds to bond percolation with local probability @xmath29 and the condition of cycle - free graphs .",
    "taking @xmath30 or in the limit of @xmath27 and @xmath31 constant for @xmath32 we obtain the ensemble of uniform spanning trees for connected @xmath14 . naturally , in the latter two limits every edge in a configuration is a bridge .",
    "sweeny s algorithm @xcite is a local bond updating algorithm directly implementing the configurational weight ( [ eq : rcm_pmf ] ) .",
    "we first consider its formulation for the limiting case @xmath33 of independent bond percolation .",
    "for an update move , randomly choose an edge @xmath10 with uniform probability and propose a flip of its state from inactive to active or _",
    "vice versa_. move acceptance can be implemented with any scheme satisfying detailed balance , for instance the metropolis acceptance ratio @xmath34 where @xmath35 and @xmath36 for insertions and deletions of edges , respectively .",
    "this dynamical process is described by the following master equation : @xmath37 where @xmath38 ensures proper normalization of @xmath39 , given the normalization of @xmath40 .",
    "the metropolis transition rates are then given by @xmath41      \\label{eq : loc_transr}.\\end{aligned}\\ ] ] eq .",
    "( [ eq : glob_transr ] ) expresses the uniform random selection of an edge and the corresponding edge dependent transition rate @xmath42 is defined in eq .",
    "( [ eq : loc_transr ] ) .",
    "the product of kronecker deltas ensures the single - bond update mechanism , i.e. , that only one edge per step is changed . from here , generalization to arbitrary @xmath24 is straightforward , leading to a modified transition rate @xmath43 .",
    "\\label{eq : transr_rcm}\\end{aligned}\\ ] ] we note that this metropolis update is more efficient than a heat - bath variant for any value of @xmath0 apart from @xmath2 , where both rules coincide . clearly , for @xmath44",
    ", to compute the acceptance probability @xmath42 of a given trial move one must find @xmath45 , the change in connected components ( clusters ) induced by the move .",
    "this quantity , equivalent to the question of whether the edge @xmath11 is a _ bridge _",
    ", is highly non - local . determining it involves deciding whether there exists at least one alternative path of active edges connecting the incident vertices @xmath46 and @xmath47 that does not cross @xmath48 .",
    "the dynamic connectivity problem is the task of performing efficient connectivity queries to decide whether two vertices @xmath46 and @xmath47 are in the same ( @xmath49 ) or different ( @xmath50 ) connected components for a dynamically evolving graph , i.e. , mixing connectivity queries with edge deletions and insertions . for a static graph",
    ", such information can be acquired in asymptotically constant time after a single decomposition , for instance using the hoshen - kopelman algorithm @xcite . under a sequence of edge insertions ( but no deletions ) , it is still possible to perform all operations , insertions and connectivity queries , in practically constant time using a so - called union - and - find ( uf ) data structure combined with path - compression and tree - balance heuristics @xcite . this fact has been used to implement a very efficient algorithm for the ( uncorrelated ) percolation problem @xcite .",
    "an implementation of sweeny s algorithm , however , requires insertions as well as deletions to ensure balance .",
    "hence , we need to be able to remove edges without the need to rebuild the data structure from scratch .",
    ".asymptotic run - time scaling at criticality of the elementary operations of insertion or deletion of internal or external edges , respectively , using sequential breadth - first search ( sbfs ) , interleaved bfs ( ibfs ) , union - and - find ( uf ) or the fully dynamic connectivity algorithm ( dc ) as a function of the linear system size @xmath51 . [ cols= \" < , < , < , < , < \" , ]     this goal can be reached using a number of different techniques .",
    "building on the favorable behavior of the uf method under edge insertions and connectivity queries , the data structure can be updated under the removal of an external edge ( bridge ) by performing breadth - first searches ( bfss ) through the components connected to the two ends @xmath46 and @xmath47 of the edge @xmath52 .",
    "alternatively , one might try to do without any underlying data structure , answering each connectivity query through a separate graph search in breadth - first manner . in both cases ,",
    "the process can be considerably sped up by replacing the bfss by _ interleaved _ traversals alternating between vertices on the two sides of the initial edge and terminating the process as soon as one of the two searches comes to an end @xcite .",
    "as , at criticality of the model , the sizes of the two cluster fragments in case of a bridge bond turn out to be very uneven on average , this seemingly innocent trick leads to dramatic run - time improvements @xcite .",
    "the asymptotic run - time behavior of insertion and deletion steps for internal and external edges and the algorithms based on bfs or uf data structures is summarized in table [ tab : scaling ] for the case of simulations on the square lattice of edge length @xmath51 .",
    "we expect the same bounds with the corresponding exponents to hold for general critical hypercubic lattices . here",
    ", @xmath53 denotes the finite - size scaling exponent of the susceptibility and @xmath54 is a geometric exponent related to the two - arm crossing behavior of clusters @xcite .",
    "we note that @xmath55 for @xmath56 in two dimensions .",
    "asymptotically , it is the most expensive operation which dominates the run - time of the algorithm and , as a consequence , it turns out that ( for the square lattice ) a simple bfs with interleaving is more efficient than the approach based on union - and - find , cf .  table [ tab : scaling ] .    in any case , the implementations discussed so far feature a computational effort for a sweep of bond updates that scales faster than linearly with the system size , thus entailing some computational critical slowing down .",
    "it is found in ref .",
    "@xcite that for most choices of @xmath0 , this effect appears to asymptotically destroy any advantage of a faster decorrelation of configurations by the sweeny algorithm as compared to the swendsen - wang method .",
    "an alternative technique based on more complicated data structures allows to perform any mix of edge insertions , deletions and connectivity queries in _ poly - logarithmic _ run - time per operation @xcite .",
    "poly - logarithmic here denotes polynomials of powers of the logarithm of the independent variable , e.g. , system size @xmath51 , of the form @xmath57 here the base of the logarithm is not important and changes only the coefficients . in the following all logarithms are with respect to base @xmath58 .",
    "given the observation of generally faster decorrelation of configurations by the sweeny algorithm in the sense of smaller dynamical critical exponents @xcite , the use of such ( genuinely ) dynamic connectivity algorithms ( dc ) allows for an asymptotically more efficient simulation of the critical random - cluster model @xcite . in the following ,",
    "we discuss the basic ideas and some details of the algorithm employed here .",
    "the dc algorithm is based on the observation that for a given sub - graph @xmath59 it is possible to construct a spanning forest @xmath60 which is defined by the following properties :    * @xmath61 in @xmath60 if and only if @xmath61 in @xmath59 * there exists exactly one path for every pair @xmath46 , @xmath47 with @xmath61    in other words a spanning forest of a graph associates a spanning tree to every component , an example is given in fig .",
    "[ spanning_graph_0 ] ( solid lines only ) .",
    "one advantage of @xmath60 is that it has fewer edges than @xmath62 , but represents the same connectivity information .",
    "for the sub - graph @xmath62 , the distinction of _ tree edges _ @xmath63 and _ non - tree edges _",
    "@xmath64 allows for a cheap determination of @xmath45 . for the case of deleting an edge in @xmath65",
    "we know that there is an alternative path connecting the adjacent vertices , namely the path in @xmath60 , so this edge was part of a cycle and we conclude @xmath66 .",
    "if we insert an edge whose adjacent vertices are already connected in @xmath60 then we come to the same conclusion .",
    "if , on the other hand , we want to insert a tree edge , i.e. , an edge with adjacent vertices @xmath46 , @xmath47 not yet connected , we observe that because @xmath46 and @xmath47 belong to separate spanning trees before the insertion of @xmath11 , the new spanning subgraph obtained by linking @xmath46 and @xmath47 via @xmath11 is still a spanning tree .",
    "hence the only modification on the spanning forest for the insertion of a tree edge is the amalgamation of two trees .",
    "this can be done in @xmath67 steps by using the following idea of ref .",
    "@xcite which also supports the deletion of bridges . for a given component @xmath68 in @xmath59",
    "we transform the corresponding tree @xmath69 in @xmath60 into a directed circuit by replacing every edge @xmath70 by two directed edges ( arcs ) @xmath71 $ ] and @xmath72 $ ] and every vertex by a loop @xmath73 $ ] .",
    "figure [ circuit_mapping ] illustrates how to translate edge insertions or deletions into / from the spanning forest to modifications on the directed circuits . deleting an edge from a tree",
    "splits it into two trees .",
    "the directed circuit therefore splits into two circuits corresponding to the two trees . when inserting a tree edge , i.e.",
    ", merging two trees , we join the circuit by the two arcs , corresponding to @xmath11 , at the vertices incident to @xmath11 .    by storing",
    "the directed circuits for every component in so called euler tour sequences ( ets ) , @xcite , all necessary manipulations on the directed circuits can be done in @xmath67 operations if we store each ets in a separate balanced search tree such as , for instance , a red - black , avl , or b tree @xcite .",
    "alternatively one can use self - adjusting binary search trees , so called splay trees @xcite . in this case",
    "the bound is amortized , i.e. , averaged over the complete sequence of operations . due to a somewhat simpler implementation and the fact that a monte carlo simulation usually consists of millions of operations in random order naturally leading to amortization , we concentrated on the splay - tree approach .",
    "based on the ets representation we can translate connectivity queries into checking the underlying search tree roots for equivalence .",
    "an in - depth discussion of the exact manipulations on the representing ets is beyond the scope of this article and we refer the interested reader to the literature @xcite .",
    "here we restrict ourselves to considering the deletion of a bridge as an example .",
    "the initial graph is the one illustrated in the left panel of fig .",
    "[ circuit_mapping ] .",
    "one corresponding ets sequence of the linearized directed cycle in the right panel of fig .",
    "[ circuit_mapping ] is the following : @xmath74\\rightarrow[1,2]\\rightarrow[2,2]\\rightarrow[2,4]\\rightarrow[4,4]\\rightarrow[4,3]\\rightarrow[3,3]\\rightarrow[3,4]\\rightarrow[4,2]\\rightarrow[2,1 ] .",
    "\\label{eq : sequence}\\ ] ] suppose now that we delete edge @xmath75 from the tree ( cf .  the dashed line in fig .  [ circuit_mapping ] ) .",
    "this will result in a split of the component @xmath76 into two parts @xmath77 and @xmath78 . in this case",
    "the deletion of edge @xmath75 translates into a cut of the original sequence @xmath79 at the two arcs @xmath80 $ ] and @xmath81 $ ] .",
    "the sequence @xmath82 of arcs between these two edges corresponds to @xmath83 and the concatenation of the remaining sequences without the two arcs corresponding to @xmath75 results in @xmath84 representing @xmath85 : @xmath86\\rightarrow[1,2]\\rightarrow[2,2]\\rightarrow[2,1 ] , \\label{eq : et_1}\\\\      \\mathcal{e}_{2 } & =   & [ 4,4]\\rightarrow[4,3]\\rightarrow[3,3]\\rightarrow[3,4 ] .",
    "\\label{eq : et_2}\\end{aligned}\\ ] ] in summary , we see that by mapping every component in @xmath59 to a tree in @xmath60 and every such tree to a directed circuit which we store in an ets we are able to perform edge insertions / deletions into / from @xmath87 as well as connectivity queries with an amortised @xmath67 computational effort .",
    "the remaining operation not implemented efficiently by the provisions discussed so far is the deletion of edges from @xmath60 which are not bridges , i.e. , for which a replacement edge exists outside of the spanning forest .",
    "the dc algorithm first executes the tree splitting as in the case of a bridge deletion . additionally , however , it checks for a reconnecting edge in the set of non - tree edges .",
    "if such an edge is found , it concludes @xmath66 and merges the two temporary trees as indicated above by using the located non - tree edge , which hence now becomes a tree edge . if , on the other hand , no re - connecting edge is found , no additional work is necessary as the initially considered edge is a bridge . to speed up the search for replacement edges ,",
    "we limit it to the smaller of the two parts @xmath85 and @xmath83 as all potential replacement edges must be incident to both components . to allow for efficient searches for non - tree edges incident to a given component using the ets representation ,",
    "the search - tree data structures are augmented such that the loop arc for every vertex stores an adjacency list of non - tree edges ( vertices ) incident to it .",
    "further , every node in the underlying search tree representing the ets carries a flag indicating if any non - tree edge is available in the sub - tree [ which is a sub - tree of the search tree and not of @xmath60 ] .",
    "this allows for a search of replacement edges using the euler tour and ensures that any non - tree edge can be accessed in @xmath67 time .",
    "it turns out that exploiting this observation is , in general , beneficial but not sufficient to ensure the amortized time complexity bound indicated for the dc algorithm in general .",
    "suppose that the graph consists of a giant homogeneous component with @xmath89 and @xmath90 and the edge deletion results , temporarily setting aside the question of possible replacement edges , in two trees with @xmath91 and @xmath92 incident edges , respectively , where @xmath93 .",
    "then the computational effort caused by scanning all possible non - tree edges is clearly @xmath94 . in amortizing onto the insertions",
    "performed to build up this component , every such non - tree edge carries a weight of @xmath67 . if this case occurs sufficiently frequently , it will be impossible to bound the amortized cost per operation .",
    "this problem is ultimately solved in the dc algorithm by the introduction of an edge hierarchy .",
    "the intuitive idea is to use the expense of a replacement edge search following a deletion to reduce the cost of future operations on this edge .",
    "this is done in such a way as to separate dense from sparse clusters and more central edges from those in the periphery of clusters . by amortizing the cost of non - tree edge scans and level increases over edge insertions it follows that one can reduce the run - time for graph manipulations to an amortized",
    "@xmath95 and @xmath67 for connectivity queries @xcite .",
    "each time an incident non - tree edge is checked and found unsuitable for reconnecting the previously split cluster we promote it to be in a higher level . if we do this many times for a dense component we will be able to find incident non - tree edges very quickly in a higher level .",
    "these ideas are achieved in the dc algorithm by associating a level function to each @xmath10 , @xmath96 based on this level function , one then constructs sub - graphs @xmath97 with the property @xmath98 this induces a hierarchy of sub - graphs : @xmath99 as described above , for every sub - graph we construct a spanning forest @xmath100 . clearly the same hierarchy holds for the family of spanning forests . in other words",
    "the edges in level @xmath101 connect components / trees of level @xmath102 .",
    "if an edge has to be inserted into @xmath59 , then it is associated to a level @xmath103 and hence it is in @xmath104 . to achieve an efficient search for replacement edges ,",
    "the algorithm adapts the level of edges after deletions of tree edges in a way which preserves the following two invariants @xcite :    1 .",
    "the maximal number of vertices in a component in level @xmath102 is @xmath105 .",
    "2 .   any possible replacement edge for a previously deleted edge @xmath11 with level @xmath106 has level @xmath107 .",
    "trivially , both invariants are fulfilled when all edges have level 0 .",
    "we now have to specify how exactly the idea of keeping important edges at low levels and unimportant ones at higher levels is implemented . to do this , suppose we deleted an edge from @xmath108 , i.e. , at level @xmath102 , and temporarily have @xmath109 where ( say ) @xmath110 is the smaller of the two , i.e.",
    ", it has less vertices . because of invariant ( i ) it follows that we are allowed to move the tree @xmath110 ( which is now at most half the size of @xmath111 ) to level @xmath112 by increasing the level of all tree edges of @xmath110 by one .",
    "after that we start to search for a replacement edge in the set of non - tree edges stored in the ets of @xmath110 in level @xmath102 where it also remains because of the fact that @xmath113 .",
    "for every scanned non - tree edge we have two options :    * it does not reconnect @xmath110 and @xmath114 and has therefore both ends incident to @xmath110 . in this case",
    ", we increase the level of this edge @xmath115 .",
    "this implements the idea of moving unimportant edges in `` dense '' components to higher levels . *",
    "it does reconnect and hence we re - insert it at level @xmath116 .",
    "if we have not found a replacement edge at level @xmath102 we continue at level @xmath101 .",
    "the search terminates after unsuccessfully completing the search at level @xmath116 or when a replacement edge was found . in the first case it follows @xmath117 whereas in the second case",
    "@xmath68 remains unchanged .",
    "implementing this replacement - edge search following any tree - edge deletion introduces an upward flow of edges in the hierarchy of graphs and the level of an edge in the current graph never decreases . focusing on a single edge",
    ", we see that it is sequentially moved into levels of smaller cluster size and hence the cost of future operations on this edge is reduced . taking this into account it follows that the insertion of an edge has a cost of @xmath67 for inserting at level @xmath116 plus it also `` carries '' the cost of all possible @xmath67 level increases with cost of @xmath67 each resulting in @xmath118 amortized per insertion .",
    "deletions on the other hand imply a split of cost @xmath67 in @xmath67 levels . in case of an existing replacement edge another contribution of @xmath67 caused by an insertion at level 0",
    "the contribution of moving tree edges to higher levels and searching for replacement edges ( moving non - tree edges up ) is already paid for by the sequence of previous insertions ( amortization ) .",
    "the only missing contribution is the @xmath67 effort for obtaining the next replacement edge in an ets . in total",
    ", deletions hence have an amortized computational cost of @xmath95 .",
    "we tested the performance of the current dc implementation in the context of sweeny s algorithm in comparison to the simpler approaches based on breadth - first search and union - and - find strategies . while the algorithm discussed here",
    "allows all operations to be performed in poly - logarithmic time , due to the complicated data structures the constants are relatively large .",
    "our results show consistency with the poly - logarithmic run - time bounds derived .",
    "it appears , however , that very large system sizes are required to clearly see the superior asymptotic performance of the dc algorithm as compared to the bfs and uf implementations .",
    "for details see the more elaborate discussion in ref .  @xcite . as an example , fig .",
    "[ fig : fig_dc_run_times ] shows the average run - time per edge operation as a function of the system size for three different choices of parameters .",
    "average run - time for sweeny s algorithm for the rcm for different values of @xmath0 at the critical point @xmath119 on the 2d square lattice with periodic boundary conditions . ]",
    "apart from run - time considerations , the implementation has a rather significant space complexity .",
    "since we maintain @xmath67 overlapping forests over the @xmath120 vertices , the space complexity is @xmath121 .",
    "a heuristic suggested in ref .",
    "@xcite to decrease memory consumption is a truncation of higher edge levels as these are , for the inputs or graphs considered in our application , sparsely populated .",
    "we checked the impact on our implementation by comparing run - times and memory consumptions for a truncation @xmath122 .",
    "we did not see any significant change in the run - time . on the other hand we observed a reduction of almost a factor of two in the memory consumption .",
    "this conforms to our observation that during the course of a simulation almost no edges reached levels beyond @xmath123 for system sizes @xmath124 where the actual maximal level according to eq .",
    "( [ eq : levels ] ) is @xmath125 .    likewise , a number of further optimizations or heuristics are conceivable to improve the typical run - time behavior .",
    "this includes a sampling of nearby edges when looking for a replacement edge before actually descending into the edge level hierarchy @xcite .",
    "a number of such heuristics and experimental comparisons of fully and partially dynamics connectivity algorithms has been discussed in the recent literature , see refs .",
    "a full exploration of these possibilities towards an optimal implementation of the dc class of algorithms for the purpose of the sweeny update is beyond the scope of the current article and forms a promising direction for future extensions of the present work .",
    "we provide a python class @xcite encompassing four different implementations of sweeny s algorithm based on :    * sequential breadth - first searches ( sbfs ) * interleaved breadth - first searches ( ibfs ) * union - and - find with interleaved breadth - first searches ( uf ) *",
    "poly - logarithmic dynamic connectivities as discussed here ( dc )    the package is built on top of a c library and it is therefore possible to use the library in a stand - alone compiled binary . the necessary source code is also provided . for more details see the related project documentation @xcite .",
    "the source code is published under the mit license @xcite . here",
    "we give a basic usage example , which simulates the rcm with @xmath3 ( the ising model ) at @xmath126 , using an equilibration time of @xmath127 sweeps , a simulation length of @xmath128 sweeps , and random number seed @xmath129 using the dc implementation :    .... from sweeny import sweeny sy = sweeny(q=2.,l=64,beta = np.log(1 .",
    "+ np.sqrt(2.)),coupl=1 . ,",
    "cutoff=1000,tslength=10000,rngseed=1234567,impl='dc ' ) sy.simulate ( ) ....    in order to extract an estimate , say , of the binder cumulant @xmath130 we need to retrieve the time series for @xmath131 and @xmath132 ,    ....",
    "sec_cs_moment= sy.ts_sec_cs_moment four_cs_moment = sy.ts_four_cs_moment sec_cs_moment * = sec_cs_moment binder_cummulant = four_cs_moment.mean()/sec_cs_moment.mean ( ) ....    once an instance of the sweeny class is created , it is easy to switch the algorithm and parameters as follows :    .... sy.init_sim(q=1.3,l=64,beta=np.log(1.+np.sqrt(1.3.)),coupl=1 . ,",
    "cutoff=5000,tslength=50000,rngseed=7434,impl='ibfs ' ) ....",
    "we have shown how to implement sweeny s algorithm using a poly - logarithmic dynamic connectivity method and we described the related algorithmic aspects in some detail . we hope that the availability of the source code and detailed explanations help to bridge the gap between the computer science literature on the topic of dynamic connectivity problems and the physics literature related to mc simulations of the rcm , specifically in the regime @xmath133 .    the availability of an efficient dynamic connectivity algorithm opens up a number of opportunities for further research .",
    "this includes studies of the tricritical value @xmath134 where the phase transition of the random - cluster model becomes discontinuous for dimensions @xmath135 @xcite as well as the nature of the ferromagnetic - paramagnetic transition for @xmath27 and @xmath136 @xcite .",
    "e.m.e . would like to thank p.  mac carron for carefully reading the manuscript .",
    "10 url # 1#1urlprefix[2][]#2 swendsen r  h and wang j  s 1987 _ phys .",
    "lett . _ * 58 * 8688"
  ],
  "abstract_text": [
    "<S> we review sweeny s algorithm for monte carlo simulations of the random cluster model . </S>",
    "<S> straightforward implementations suffer from the problem of computational critical slowing down , where the computational effort per edge operation scales with a power of the system size . by using a tailored dynamic connectivity algorithm we are able to perform all operations with a poly - logarithmic computational effort . </S>",
    "<S> this approach is shown to be efficient in keeping online connectivity information and is of use for a number of applications also beyond cluster - update simulations , for instance in monitoring droplet shape transitions . as the handling of the relevant data structures is non - trivial </S>",
    "<S> , we provide a python module with a full implementation for future reference . </S>"
  ]
}