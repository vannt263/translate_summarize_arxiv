{
  "article_text": [
    "the goal of this paper is to shed some light on the connection between min - sum algorithm ( msa ) decoding and the formulation of decoding as a linear program . in particular , we address the problem of bounding the performance of linear programming ( lp ) decoding with respect to word error rate .",
    "the bounds reflect similar analytic bounds for msa decoding of low - density parity - check ( ldpc ) codes due to wiberg  @xcite and establish the existence of an snr threshold for lp decoding .",
    "while highly efficient and structured computer - based evaluation techniques , such as density evolution ( see e.g.  @xcite ) , provide excellent bounds on the performance of iterative decoding techniques , to the best of our knowledge , the best analytic performance bound in the case of msa decoding is still the bound given by wiberg in his thesis based on the weight distribution of a tree - like neighborhood of a vertex in a graph .",
    "a similar bound was also derived by lentmaier et al .",
    "we derive the equivalent bound for lp decoding of regular ldpc codes .",
    "in this paper we are interested in binary ldpc codes where a binary ldpc code @xmath0 of length @xmath1 is defined as the null - space of a sparse binary parity - check matrix @xmath2 , i.e.  @xmath3 . in particular , we focus on the case of regular codes : an ldpc code @xmath0 is called @xmath4-regular if each column of @xmath2 has hamming weight @xmath5 and each row has hamming weight @xmath6 .",
    "the rate of a @xmath4-regular code is lower bounded by @xmath7 . to an @xmath8 parity - check matrix @xmath2",
    "we can naturally associate a bipartite graph , the so - called tanner graph @xmath9 .",
    "this graph contains two classes of nodes : variable nodes @xmath10 and check nodes @xmath11 .",
    "both variable nodes and check nodes are identified with subsets of the integers .",
    "variable nodes are denoted as @xmath12 and check nodes are denoted as @xmath13 .",
    "whenever we want to express that an integer belongs to the set of variable nodes we write @xmath14 ; similarly , when an integer belongs to the set of check nodes we write @xmath15 .",
    "the tanner graph @xmath9 contains an edge @xmath16 between node @xmath14 and @xmath17 if and only if the entry @xmath18 is non - zero .",
    "the set of neighbors of a node @xmath19 is denoted as @xmath20 ; similarly , the set of neighbors of a node @xmath17 is denoted as @xmath21 . in the following",
    ", @xmath22 will be the set of edges in the tanner graph @xmath9 .",
    "the convex hull of a set @xmath23 is denoted by @xmath24 .",
    "if @xmath25 is a subset of @xmath26 then @xmath24 denotes the convex hull of the set @xmath25 after @xmath25 has been canonically embedded in @xmath27 .",
    "the inner product between vectors @xmath28 and @xmath29 is denoted as @xmath30 .",
    "finally , we define the set of all binary vectors of length @xmath6 and even weight as @xmath31 .    in the rest of this paper",
    "we assume that the all - zeros word was transmitted  an assumption without any essential loss of generality because we only consider binary linear codes that are used for data transmission over a binary - input output - symmetric channel .",
    "given a received vector @xmath32 we define the vector @xmath33 of log - likelihood ratios by @xmath34",
    "maximum likelihood ( ml ) decoding may be cast as a linear program once we have translated the problem into @xmath35 . to this end",
    "we embed the code into @xmath35 by straightforward identification of @xmath36 with @xmath37 .",
    "in other words , a code @xmath0 is identified with a subset of @xmath38 .",
    "this description is usually not practical since the polytope @xmath39 is typically very hard to describe by hyperplanes ( or as a convex combination of points ) . given a parity - check matrix @xmath2 , the linear program is relaxed to  @xcite    here , @xmath40 is the so - called fundamental polytope  @xcite which is defined as @xmath41 where @xmath42 where @xmath43 is the @xmath44-th row of @xmath2 .",
    "since @xmath45 is always a feasible point , i.e. @xmath46 holds , zero is an upper bound on the value of the lp in lp decoding .",
    "in fact , we can turn this statement around by saying that whenever the value of the linear program equals zero then the all - zeros codeword will be among the solutions to the lp .",
    "thus , motivated by the assumption that the all - zeros codeword was transmitted , we focus our attention on showing that , under suitable conditions , the value of the lp is zero which implies that the all - zeros codeword will be found as a solution . for simplicity",
    "we only consider channels where the channel output is a continuous random variable . in this case",
    "a zero value of the lp implies that the zero word is the unique solution with probability one .",
    "the main idea now is to show that the value of the dual linear program is zero .",
    "this technique , dubbed `` dual witness '' by feldman et al . in @xcite will then imply the correct decoding .",
    "first , however , we need to establish the dual linear program . to this end , for each @xmath47 , we associate the variable @xmath48 with the edge between variable node @xmath49 and check node @xmath44 in the tanner graph @xmath9 . in other words , we have a variable @xmath48 if and only if the entry @xmath18 is non - zero . for each @xmath17",
    "we define the vector @xmath50 that collects all the variables @xmath51 . also , for each @xmath17 , we associate the variable @xmath52 with the check node @xmath44 .",
    "we have is an inequality ( @xmath53 ) .",
    "however , there always exists a maximizing assignment of dual variables that satisfies this conditions with equality . ]",
    "the dual program has a number of nice interpretations .",
    "any @xmath52 is bounded from above by zero and can only equal zero if the vector @xmath50 has minimal correlation with the all - zeros codeword .",
    "would have to be replaced by the corresponding code . ]",
    "thus the dual program will only get a zero value if we find an assignment to @xmath48 such that the local all - zeros words are among the `` best '' words for all @xmath44 .",
    "we are constraint in setting the @xmath48-values by the second equality constraint .",
    "while msa decoding is not the focus of interest in this paper , it turns out that the msa lies at the core of the proof technique that we will use .",
    "the msa is an algorithm that is being run until a predetermined criterion is reached . with each edge in the graph",
    "we associate two messages : one message is going towards the check - node and one is directed towards the variable node .",
    "let the two messages be denoted by @xmath54 and @xmath55 , respectively , where , as in the case of the single variable @xmath48 in the section above , variables are only defined if the entry @xmath18 is non - zero .",
    "the update rules of msa are then    rather than the quantity @xmath55 we will consider its negative value .",
    "moreover , we keep track of the messages that were sent by message numbers in the superscript .",
    "thus we modify the msa update equations as    clearly , the sign change leaves the algorithmic update steps essentially unchanged .",
    "( note that e.g. when all @xmath56 are non - negative then all @xmath57 will be non - positive . ) still , we may e.g.  write @xmath58 which more closely reflects the structure of the dual program above .",
    "we will need the notion of a computation tree ( ct )  @xcite .",
    "we can distinguish two types of cts , rooted either at a variable node or at a check node .",
    "our cts will be rooted at check nodes which is more natural when dealing with the dual program .",
    "a ct of depth @xmath59 consists of all nodes in the universal cover of the tanner graph that are reachable in @xmath60 steps .",
    "in particular , we will most of the time assume that the leaves in the ct are variable nodes .",
    "assume we have run the msa for @xmath59 iterations , corresponding to a ct of depth @xmath59 . for the moment",
    "let us also assume that the underlying graph has girth larger than @xmath61 . based on the iterations of the msa and fixed ct root node",
    "@xmath62 we can assign values to the dual variables in the following way .",
    "was assign values to @xmath48 according to the distance of the edge @xmath16 to the root node of the ct .",
    "so , if @xmath16 is at distance @xmath63 from the root node @xmath64 then @xmath48 is assigned the value @xmath65 and if @xmath16 is at distance @xmath66 from the root node @xmath64 then @xmath48 is assigned the value @xmath67 . to the root @xmath64",
    "is larger than @xmath68 then @xmath69 .",
    "] let us denote this assignment to variables @xmath48 as @xmath70 indicates that the assignment is based on the ct rooted at node @xmath64 . ] .",
    "note that the assignment @xmath71 does not satisfy the constraints of the dual linear program , i.e. itself it is not dual feasible .",
    "in particular , any edge of distance more than @xmath68 from the root is assigned the value @xmath72 and hence at any variable node @xmath49 at distance more than @xmath68 from the root we do not satisfy the constraint @xmath73 unless @xmath74 happens to be @xmath72 .",
    "however , we have the following lemma",
    ".      for each @xmath62 let an assignment @xmath71 be given based on @xmath59 iterations of the msa .",
    "the sum @xmath75 is a multiple of a dual feasible point .",
    "more precisely , for the number @xmath76^{(\\ell-1)}$ ] the vector @xmath77 is a dual feasible point .",
    "each variable node @xmath19 is part of @xmath78^{(\\ell-1)}$ ] cts for different root nodes @xmath64 and so one can verify that we must have @xmath79^{(\\ell-1)}\\lambda_i$ ] . using the abbreviation @xmath80^{\\ell-1}$ ]",
    "we see that @xmath77 is a dual feasible point .",
    "the above lemma gives a structured way to derive dual feasible points for lp decoding from the messages passed during the operation of the msa .",
    "however , these points are not very good since the overall assignment @xmath81 is again dominated by the leaves of the ct with all the pertaining problems .",
    "the problem becomes obvious when we write out the assignment @xmath81 as a function of the msa messages directly .",
    "if we perform @xmath59 steps of iterative decoding , for any edge @xmath47 we can write @xmath82 written in form of a telescoping sum we get @xmath83 while the above sums show that the dual feasible point can be easily computed alongside the msa recursions it also shows the problem that messages @xmath84 and @xmath85 are weighted exponentially more for small values of @xmath86 .    we will have to attenuate the influence of the leaves in the cts in order to make interesting statements",
    "to this end , let @xmath87 be a vector with positive entries of length @xmath59 and let a generalized assignment @xmath88 to dual variables be derived from @xmath71 by multiplying the message on each edge at distance @xmath63 or @xmath66 by @xmath89 .",
    "is said to be at distance one from @xmath44 ; @xmath90 is set to one . ] in other words , values assigned to edges at distance three or four from the root node are multiplied with @xmath91 , values at distance five and six are multiplied with @xmath92 etc .",
    "again we can form the multiple of a dual feasible point as is shown in the next lemma .",
    "each variable node @xmath19 is part of @xmath78^{(\\ell-1)}$ ] cts for different root nodes @xmath64 . because all edges incident to a variable node are attenuated in the same way",
    ", one can verify that we must have @xmath94^{(\\ell-1)}\\lambda_i$ ] . using the abbreviation @xmath95^{\\ell-1}$ ]",
    "we see that @xmath77 is a dual feasible point .",
    "optimizing the vector @xmath87 gives us some freedom and we want to choose the vector @xmath87 appropriately .",
    "first we have to learn more about the dual feasible point that we construct in this way . while we kept the feasibility of an assignment @xmath96 by identically scaling the values @xmath48 that are adjacent to a variable node in a ct , we scale values @xmath48 that are adjacent to check nodes differently . given a vector @xmath87 , the dual feasible point may be easily computed together with the messages of the msa . to this end",
    "define a vector @xmath97 with components @xmath98 .",
    "writing again the dual variable @xmath99 as functions of @xmath84 and @xmath85 we get @xmath100 written in form of a telescoping sum we obtain @xmath101        let @xmath104 and fix some @xmath17 . assume the msa yields messages where @xmath84 is positive for all @xmath105 for some @xmath86 .",
    "the inner product @xmath106 is non - negative for all @xmath107 , in particular it is positive for all @xmath108 .",
    "are given by @xmath21 . ]",
    "recall that @xmath85 is negative for all @xmath47 ( this is in line with the modification of the msa ) .",
    "one can easily verify the following fact about the vector containing @xmath109 for all @xmath105 : there is only one negative entry and the absolute value of this entry matches the absolute value of the smallest positive entry .",
    "the statement follows .    with the choice of @xmath110 , which results in @xmath111 , we get the following expression for the dual feasible point @xmath112 or @xmath113 we are still in a situation where @xmath114 is weighted by a factor that grows exponentially fast in @xmath59 .",
    "however , we note that , once the msa has converged , @xmath84 also grows exponentially fast in @xmath86 and this offsets , to some extend , the exponential weighing of @xmath114 . in order to exploit this fact more systematically we initialize the msa s check to variable messages @xmath115 , @xmath47 , with @xmath116 , where @xmath117 is a large enough positive number . with this initialization",
    "we can guarantee ( for @xmath118 ) for all @xmath47 that the value of @xmath84 is strictly positive .. ] thus we can apply lemma  [ lemma : inner : product:1 ] .",
    "it remains to offset the choice @xmath115 with @xmath119 .    to this end",
    "we consider a ct of depth @xmath59 rooted at check node @xmath64 .",
    "consider the event @xmath120 that the all - zeros word on this ct is more likely than any word that corresponds to a local nonzero word assigned to the root node .. is defined on the ct without the change in initialization ]      let @xmath118 and assume the event @xmath120 is true .",
    "moreover , assume that we initialize the msa with check to variable messages @xmath121 , @xmath47 , for a large enough number @xmath117 .",
    "the inner product @xmath122 is non - negative for all @xmath107 , in particular it is non - negative for all @xmath108 .",
    "we exploit the fact that summaries sent by the msa can be identified with cost differences of log - likelihood ratios .",
    "consider a message @xmath123 on edge @xmath124 .",
    "this message may be written as @xmath125 for some @xmath126 .",
    "since the msa propagates cost summaries along edges , we can interpret @xmath126 as the summary of the cost due to the @xmath74 inside the subtree that emerges along the edge @xmath124 .",
    "similarly , @xmath127 is the cost contributed by the leaf nodes of this sub - tree .",
    "here we use the fact that the minimal codeword which accounts for a one - assignment in edge @xmath124 contains exactly @xmath128 leaf nodes with a one - assignment .",
    "but then the vector @xmath129 equals the vector @xmath130 .",
    "the event @xmath120 is true only if the inner product @xmath131 is positive for all @xmath132 .",
    "hence event @xmath120 implies the claim of the lemma .",
    "let @xmath133 be the averaged assignment to the dual variables obtained from the msa messages with @xmath115 set to @xmath116 .",
    "lemmas  [ lemma : inner : product:1 ] and  [ lemma : assignment:3 ] imply that the sum , @xmath134 has a non - negative value for any @xmath107 , and , in particular , the value equals zero for @xmath135 .",
    "it follows that @xmath136 in the dual lp can be chosen as zero .    for each check",
    "node @xmath44 for which event @xmath137 is true we can be sure that the correlation of any codeword in @xmath31 with @xmath138 is non - negative . if we can be sure that the event @xmath137 is true for all check nodes we would , thus , have exhibited a dual witness for the optimality of the all - zeros codeword .",
    "we have to estimate the probability of the event @xmath137 and set it in relation to the number of checks in the graph @xmath9 . in order to estimate the latter",
    "we employ a result by gallager @xcite that guarantees the existence of @xmath4-regular graphs in which we can conduct @xmath59 steps of msa decoding without closing any cycles provided that @xmath59 satisfies @xmath139 where the term @xmath140 in this expression is independent of @xmath141 .",
    "finally , we can estimate the probability of the event @xmath137 from the known weight distribution of the code on the ct provided the underlying graph has girth at least @xmath61 .",
    "the minimal codewords have weight @xmath142 and there are a total of @xmath143 minimal - tree codewords . based on a union bound",
    "we thus get an expression @xmath144 which means that @xmath145 decreases doubly exponentially in @xmath59 if the bhattacharyya parameter @xmath146 satisfies @xmath147 .",
    "let a sequence of @xmath4-regular ldpc codes be given that satisfies equation . under lp decoding this sequence achieves an arbitrarily small probability of error on any memoryless channel for which the bhattacharyya parameter @xmath146 satisfies @xmath148 .",
    "for such a channel the word error probability @xmath149 decreases as @xmath150 for some positive parameters @xmath151 and @xmath152 .",
    "most of the proof is contained in the arguments leading up to the theorem . in order to see the explicit form of the word error rate we employ a union bound for the @xmath153 check nodes combining and .",
    "we find that the word error rate is bounded by @xmath154 where @xmath140 does not depend on @xmath141 .",
    "the statement of the theorem is obtained by simplifying this expression .",
    "we conclude this paper with an intriguing observation concerning the awgn channel . in @xcite",
    "it is proved that no @xmath4-regular ldpc code can achieve an error probability behavior better than @xmath155 for constants @xmath156 and @xmath157 that are independent on @xmath141 .",
    "the result of the theorem thus shows that there exist sequences of ldpc codes whose error probability behavior under lp decoding is boxed in as a function of @xmath141 between : @xmath158              m.  lentmaier , d.  v. truhachev , d.  j. costello , jr .",
    ", and k.  zigangirov , `` on the block error probability of iteratively decoded ldpc codes , '' in _",
    "5th itg conference on source and channel coding _",
    ", ( erlangen , germany ) , jan .",
    "14 - 16 2004 .",
    "j.  feldman , _ decoding error - correcting codes via linear programming_. phd thesis , massachusetts institute of technology , cambridge , ma , 2003 .",
    "available online under ` http://www.columbia.edu/ ` ` ~jf2189/pubs.html ` .",
    "r.  koetter and p.  o. vontobel , `` graph covers and iterative decoding of finite - length codes , '' in _ proc .",
    "3rd intern .",
    "symp .  on turbo codes and related topics",
    "_ , ( brest , france ) , pp .  7582 , sept .",
    "15 2003 .",
    "o. vontobel and r.  koetter , `` graph - cover decoding and finite - length analysis of message - passing iterative decoding of ldpc codes , '' _ submitted to ieee trans .  inform .",
    "theory , available online under ` http:// ` ` www.arxiv.org/abs/cs.it/0512078`_ , dec .",
    "j.  feldman , t.  malkin , c.  stein , r.  a. servedio , and m.  j. wainwright , `` lp decoding corrects a constant fraction of errors , '' in _ proc .",
    "ieee intern .",
    "symp .  on inform .",
    "theory _ , ( chicago , il , usa ) , p.  68 , june 27july 2 2004 ."
  ],
  "abstract_text": [
    "<S> in his thesis , wiberg showed the existence of thresholds for families of regular low - density parity - check codes under min - sum algorithm decoding . </S>",
    "<S> he also derived analytic bounds on these thresholds . in this paper , we formulate similar results for linear programming decoding of regular low - density parity - check codes . </S>"
  ]
}