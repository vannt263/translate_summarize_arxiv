{
  "article_text": [
    "in @xmath0 numerical relativity , one often wishes to locate the black hole(s ) in a ( spacelike ) slice . as discussed by refs .",
    ", a black hole is rigorously defined in terms of its event horizon , the boundary of future null infinity s causal past .",
    "although the event horizon has , in the words of hawking and ellis ( ref .",
    "@xcite ) , `` a number of nice properties '' , it s defined in an inherently _ acausal _ manner : it can only be determined if the entire future development of the slice is known .",
    "( as discussed by refs .",
    "@xcite , in practice the event horizon may be located to good accuracy given only the usual numerically generated approximate development to a nearly stationary state , but the fundamental acausality remains . )    in contrast , an apparent horizon , also known as a marginally outer trapped surface , is defined ( refs .",
    "@xcite ) locally in time , within a single slice , as a closed 2-surface whose outgoing null geodesics have zero expansion .",
    "an apparent horizon is slicing - dependent : if we define a `` world tube '' by taking the union of the apparent horizon(s ) in each slice of a slicing , this world tube will vary from one slicing to another . in a stationary spacetime event and apparent horizons",
    "coincide , although this generally is nt the case in dynamic spacetimes .",
    "however , given certain technical assumptions , the existence of an apparent horizon in a slice implies the existence of an event horizon , and thus by definition a black hole , containing the apparent horizon .",
    "( unfortunately , the converse does nt always hold . notably , wald and iyer ( ref .",
    "@xcite ) have constructed a family of angularly anisotropic slices in schwarzschild spacetime which approach arbitrarily close to @xmath15 yet contain no apparent horizons . )",
    "there is thus considerable interest in numerical algorithms to find apparent horizons in numerically computed slices , both as diagnostic tools for locating black holes and studying their behavior ( see , for example , refs .",
    "@xcite ) , and for use `` on the fly '' during numerical evolutions to help in choosing the coordinates and `` steering '' the numerical evolution ( refs .  ) .",
    "this latter context makes particularly strong demands on a horizon - finding algorithm : because the computed horizon position is used in the coordinate conditions , the horizon must be located quite accurately to ensure that spurious finite difference instabilities do nt develop in the time evolution .",
    "furthermore , the horizon must be re - located at each time step of the evolution , so the horizon - finding algorithm should be as efficient as possible . finally , when evolving multiple - black - hole spacetimes in this manner it s desirable to have a means of detecting the appearance of a new outermost apparent horizon surrounding two black holes which are about to merge .",
    "we discuss this last problem further in section  [ sect - finding - outermost - apparent - horizons ] .    in this paper we give a detailed discussion of the apparent - horizon - finding algorithm .",
    "this algorithm poses the apparent horizon equation as a nonlinear elliptic ( boundary - value ) pde on angular - coordinate space for the horizon shape function @xmath2 , finite differences this pde , and uses some variant of newton s method to solve the resulting set of simultaneous nonlinear algebraic equations for the values of @xmath8 at the angular - coordinate grid points .",
    "this algorithm is suitable for both axisymmetric and fully - general spacetimes , and we discuss both cases . as explained in section  [ sect - notation ] , we assume a locally polar spherical topology for the coordinates and finite differencing , though we make no assumptions about the basis used in taking tensor components .",
    "our notation generally follows that of misner , thorne , and wheeler ( ref .",
    "@xcite ) , with @xmath16 units and a @xmath17 spacetime metric signature .",
    "we assume the usual einstein summation convention for repeated indices regardless of their tensor character , and we use the penrose abstract - index notation , as described by ( for example ) ref .",
    "we use the standard @xmath0 formalism of arnowitt , deser , and misner ( ref .",
    "@xcite ) ( see refs .   for recent reviews ) .",
    "we assume that a specific spacetime and @xmath0 ( spacelike ) slice are given , and all our discussions take place within this slice .",
    "we use the term to refer to the ( an ) apparent horizon in this slice .",
    "we often refer to various sets in the slice as being 1 , 2 , or 3-dimensional , meaning the number of _ spatial _ dimensions  the time coordinate is never included in the dimensionality count . for example",
    ", we refer to the horizon itself as 2-dimensional .",
    "we assume that the spatial coordinates @xmath18 are such that in some neighborhood of the horizon , surfaces of constant @xmath19 are topologically nested 2-spheres with @xmath19 increasing outward , and we refer to @xmath19 as a coordinate and @xmath20 and @xmath21 as coordinates . for pedagogical convenience ( only ) , we take @xmath20 and @xmath21 to be the usual polar spherical coordinates , so that if spacetime is axisymmetric ( spherically symmetric ) , @xmath21 is ( @xmath20 and @xmath21 are ) the symmetry coordinate(s ) . however , we make no assumptions about the detailed form of the coordinates , i.e.  we allow all components of the 3-metric to be nonzero .    we emphasize that although our assumptions about the local topology of @xmath19 are fundamental , our assumptions about the angular coordinates are for pedagogical convenience only , and could easily be eliminated .",
    "in particular , all our discussions carry over unchanged to multiple black hole spacetimes , using ( for example ) either conformal - mapping equipotential coordinates ( ref .",
    "@xcite ) or multiple - coordinate - patch coordinate systems ( ref .",
    "@xcite ) .",
    "we use @xmath22 for spatial ( 3- ) indices , and @xmath23 for indices ranging over the angular coordinates only .",
    "@xmath24 denotes the 3-metric in the slice , @xmath25 its determinant , and @xmath26 the associated 3-covariant derivative operator .",
    "@xmath27 denotes the 3-extrinsic curvature of the slice , and @xmath28 its trace .",
    "we use @xmath29 to denote the 2-dimensional space of angular coordinates @xmath30 .",
    "we sometimes need to distinguish between field variables defined on @xmath29 or on the ( 2-dimensional ) horizon , and field variables defined on a 3-dimensional neighborhood @xmath31 of the horizon .",
    "this distinction is often clear from context , but where ambiguity might arise we use prefixes @xmath32 and @xmath33 respectively , as in @xmath34 and @xmath35 .",
    "we use italic roman letters @xmath36 , @xmath8 , etc .",
    ", to denote _ continuum _ coordinates , functions , differential operators , and other quantities .",
    "we use sans serif roman letters @xmath37 , @xmath38 , etc .",
    ", to denote grid functions , and small capital roman indices @xmath39 , @xmath40 , and @xmath41 to index grid points .",
    "we use subscript grid - point indices to denote the evaluation of a continuum or grid function at a particular grid point , as in @xmath42 or @xmath43 .",
    "we use @xmath44 $ ] to denote the jacobian matrix of the grid function @xmath45 , as defined by , and @xmath46 to denote the product of two such jacobians or that of a jacobian and a grid function .",
    "we use @xmath47 $ ] to denote the linearization of the differential operator @xmath48 about the point @xmath49 .",
    "we use @xmath50 as a generic finite difference molecule and @xmath51 as a generic index for molecule coefficients .",
    "we write @xmath52 to mean that @xmath50 has a nonzero coefficient at position @xmath51 . temporarily taking @xmath53 to denote some particular",
    "coordinate component of @xmath51 , we refer to @xmath54 as the of @xmath50 , and to the number of distinct @xmath53 values with @xmath52 as the or of @xmath50 .",
    "( for example , the usual symmetric 2nd  order 3-point molecules for 1st  and 2nd  derivatives both have radius  1 and diameter  3 . )",
    "we often refer to a molecule as itself being a discrete operator , the actual application to a grid function being implicit .    given a grid function @xmath55 and a set of points @xmath56 in its domain",
    ", we use @xmath57 to mean an interpolation of the values @xmath58 to the point @xmath59 and @xmath60 to mean the derivative of the same interpolant at this point .",
    "more precisely , taking @xmath61 to be a smooth interpolating function ( typically a lagrange polynomial ) such that @xmath62 for each @xmath63 , @xmath57 denotes @xmath64 and @xmath60 denotes @xmath65 .",
    "as discussed by ( for example ) ref .",
    "@xcite , an apparent horizon satisfies the equation @xmath66 where @xmath67 is the outward - pointing unit normal to the horizon , all the field variables are evaluated on the horizon surface , and where for future use we define the @xmath68 as the left hand side of  .",
    "( notice that in order for the 3-divergence @xmath69 to be meaningful , @xmath67 must be ( smoothly ) continued off the horizon , and extended to a field @xmath70 in some 3-dimensional neighborhood of the horizon .",
    "the off - horizon continuation is non - unique , but it s easy to see that this does nt affect @xmath36 on the horizon . )    to solve the apparent horizon equation  , we begin by assuming that the horizon and coordinates are such that each radial coordinate line @xmath71 intersects the horizon in exactly one point . in other words , we assume that the horizon s coordinate shape is a , defined by minkowski as `` a region in @xmath72-dimensional euclidean space containing the origin and whose surface , as seen from the origin , exhibits only one point in any direction '' ( ref .",
    "@xcite ) . given this assumption , we can parameterize the horizon s shape by @xmath2 for some single - valued @xmath8 defined on the 2-dimensional domain @xmath29 of angular coordinates @xmath30 .",
    "equivalently , we may write the horizon s shape as @xmath73 , where the scalar function @xmath74 , defined on some 3-dimensional neighborhood @xmath31 of the horizon , satisfies @xmath73 if and only if @xmath2 , and we take @xmath74 to increase outward . in practice",
    "we take @xmath75 .",
    "we define the non - unit outward - pointing normal ( field ) to the horizon by @xmath76 i.e.  by    [ eqn - s - d(h ) ] @xmath77    and the outward - pointing unit normal ( field ) to the horizon by @xmath78 henceforth we drop the @xmath33 prefixes on @xmath79 and @xmath70 .",
    "substituting into the apparent horizon equation  , we see that the horizon function @xmath3 depends on the ( angular ) 2nd derivatives of @xmath8 .",
    "in fact , the apparent horizon equation   is a 2nd  order elliptic ( boundary - value ) pde for @xmath8 on the domain of angular coordinates @xmath29 .",
    "the apparent horizon equation   must therefore be augmented with suitable boundary conditions to define a ( locally ) unique solution .",
    "these are easily obtained by requiring the horizon s 3-dimensional shape to be smooth across the artificial boundaries @xmath80 , @xmath81 , @xmath82 , and @xmath83 .",
    "we now survey various algorithms for solving the apparent horizon equation  . ref .",
    "@xcite reviews much of the previous work on this topic .",
    "in spherical symmetry , the apparent horizon equation   degenerates into a 1-dimensional nonlinear algebraic equation for the horizon radius @xmath8 .",
    "this is easily solved by zero - finding on the horizon function @xmath3 .",
    "this technique has been used by a number of authors , for example refs .  .",
    "( see also ref .",
    "@xcite for an interesting analytical study giving necessary and sufficient conditions for apparent horizons to form in non - vacuum spherically symmetric spacetimes . )    in an axisymmetric spacetime , the angular - coordinate space @xmath29 is effectively 1-dimensional , so the apparent horizon equation   reduces to a nonlinear 2-point boundary value ( ode ) problem for the function @xmath84 , which may be solved either with a shooting method , or with one of the more general methods described below .",
    "shooting methods have been used by a number of authors , for example refs .  .",
    "the remaining apparent - horizon - finding algorithms we discuss are all applicable to either axisymmetric spacetimes ( 2-dimensional codes ) or fully general spacetimes ( 3-dimensional codes ) .",
    "tod ( ref .",
    "@xcite ) has proposed an interesting pair of methods for finding apparent horizons .",
    "bernstein ( ref .",
    "@xcite ) has tested these methods in several axisymmetric spacetimes , and reports favorable results .",
    "unfortunately , the theoretical justification for these methods convergence is only valid in time - symmetric ( @xmath85 ) slices .",
    "the next two algorithms we discuss are both based on a pseudospectral expansion of the horizon shape function @xmath86 in some complete set of basis functions ( typically spherical harmonics or symmetric trace - free tensors ) , using some finite number of the expansion coefficients @xmath87 to parameterize of the horizon shape .",
    "one algorithm rewrites the apparent horizon equation @xmath88 as @xmath89 , then uses a general - purpose function - minimization routine to search @xmath87-space for a minimum of @xmath90 .",
    "this algorithm has been used by refs .",
    "@xcite in axisymmetric spacetimes , and more recently by ref .",
    "@xcite in fully general spacetimes .",
    "alternatively , nakamura , oohara , and kojima ( refs .  ) have suggested a functional iteration method for directly solving the apparent horizon equation @xmath88 for the expansion coefficients @xmath87 , and have used it in a number of fully general spacetimes .",
    "kemball and bishop ( ref .",
    "@xcite ) have suggested and tested several modifications of this latter algorithm to improve its convergence properties .",
    "the final algorithm we discuss , and the main subject of this paper , poses the apparent horizon equation @xmath91 as a nonlinear elliptic ( boundary - value ) pde for @xmath8 on the angular - coordinate space @xmath29 .",
    "finite differencing this pde on an angular - coordinate grid @xmath92 gives a set of simultaneous nonlinear algebraic equations for the unknown values @xmath93 , which are then solved by some variant of newton s method .",
    "this algorithm ( we continue to use this term even if a modification of newton s method is actually used ) has been used in axisymmetric spacetimes by a number of authors , for example refs .  , and is also applicable in fully general spacetimes when the coordinates have a ( locally ) polar spherical topology .",
    "huq ( ref .",
    "@xcite ) has extended this algorithm to fully general spacetimes with cartesian - topology coordinates and finite differencing , and much of our discussion remains applicable to his extension .",
    "the newtons - method algorithm has three main parts : the computation of the discrete horizon function @xmath4 , the computation of the discrete horizon function s jacobian matrix @xmath94 $ ] , and the solution of the simultaneous nonlinear algebraic equations @xmath5 .",
    "we now discuss these in more detail .",
    "in this section we discuss the details of the computation of the discrete horizon function @xmath4 .",
    "more precisely , first fix an angular - coordinate grid @xmath92 . then , given a @xmath2 , which need not actually be an apparent horizon , we define @xmath95 to be the discretization of @xmath86 to the angular - coordinate grid , and we consider the computation of @xmath4 on the discretized trial horizon surface , i.e.  at the points @xmath96 .",
    "the apparent horizon equation defines @xmath68 in terms of the field variables and their spatial derivatives on the trial horizon surface .",
    "however , these are typically known only at the ( 3-dimensional ) grid points of the underlying @xmath0 code of which the horizon finder is a part .",
    "we therefore extend @xmath34 to some ( 3-dimensional ) neighborhood @xmath31 of the trial horizon surface , i.e.  we define an extended horizon function @xmath35 on @xmath31 , @xmath97 to compute @xmath98 on the ( discretized ) trial horizon surface , we first compute @xmath99 on the underlying @xmath0 code s ( 3-dimensional ) grid points in @xmath31 , then radially interpolate these @xmath100 values to the trial - horizon - surface position to obtain @xmath98 ,    [ eqn-2h(3h ) ] @xmath101 or equivalently @xmath102    where @xmath39 is an angular grid - point index and the @xmath103 subscript denotes that the interpolation is done independently at each angular coordinate along the radial coordinate line @xmath104 . in practice",
    "any reasonable interpolation method should work well here : refs .",
    "report satisfactory results using a spline interpolant ; in this work we use a lagrange ( polynomial ) interpolant centered on the trial - horizon - surface position , also with satisfactory results . neglecting the interpolation error , we can also write   in the form @xmath105    we consider two basic types of methods for computing the extended horizon function @xmath99 :    * a computation method uses two sequential numerical finite differencing stages , first explicitly computing @xmath106 and/or @xmath107 by numerically finite differencing @xmath38 , then computing @xmath100 by numerically finite differencing @xmath106 or @xmath107 . *",
    "a computation method uses only a single numerical ( 2nd ) finite differencing stage , computing @xmath100 directly in terms of @xmath38 s 1st  and 2nd angular derivatives .    figure  [ fig - h(h)-methods ] illustrates this .    to derive the detailed equations for these methods , we substitute and into : @xmath108 where the subexpressions @xmath109 , @xmath110 , @xmath111 , and @xmath112 are given by    [ eqn - abcd(s - d ) ] @xmath113",
    "\\\\ b    & = &    ( \\partial_i g^{ij } ) s_j          + g^{ij } \\partial_i s_j          + ( \\partial_i \\ln \\sqrt{g } ) ( g^{ij } s_j )                                      \\\\ c    & = &    k^{ij } s_i s_j                                      \\\\ d    & = &    g^{ij } s_i s_j                      \\ , \\text { , } % text punctuation                                      % % % \\\\\\end{aligned}\\ ] ]    i.e.    [ eqn - abcd(h ) ] @xmath114                                      \\\\ b    & = &    \\bigl [          \\partial_i g^{ir } - ( \\partial_i g^{iu } ) \\partial_u h          \\bigr ]          - g^{uv } \\partial_{uv } h          + ( \\partial_i \\ln \\sqrt{g } ) ( g^{ir } - g^{iu } \\partial_u h )                                      \\\\ c    & = &    k^{rr }          - 2 k^{ru } \\partial_u h          + k^{uv } ( \\partial_u h ) ( \\partial_v h )                                      \\\\ d    & = &    g^{rr }          - 2 g^{ru } \\partial_u h          + g^{uv } ( \\partial_u h ) ( \\partial_v h )                      \\ , \\text{. } % text punctuation                                      % % % \\\\\\end{aligned}\\ ] ]    comparing the 1-stage and 2-stage methods , the 2-stage methods equations are somewhat simpler , so these methods are somewhat easier to implement and somewhat cheaper ( faster ) to compute .",
    "however , for a proper comparison the cost of computing the horizon function must be considered in conjunction with the cost of computing the horizon function s jacobian .",
    "compared to the 1-stage method , the 2-stage methods double the effective radius of the net @xmath4 finite differencing molecules , and thus have 2(4 )  times as many nonzero off - diagonal jacobian elements for a 2(3)-dimensional code . in practice",
    "the cost of computing these extra jacobian elements for the 2-stage methods more than outweighs the slight cost saving in evaluating the horizon function .",
    "we discuss the relative costs of the different methods further in section  [ sect - methods - comparison ] .",
    "in this section we discuss the details of the computation of the jacobian matrix @xmath94 $ ] of the horizon function @xmath4 on a given trial horizon surface .",
    "we consider first the case of a generic function @xmath116 in @xmath117  dimensions , finite differenced using @xmath118-point molecules .",
    "we define the jacobian matrix of the discrete @xmath115 function by    [ eqn - jac[p(q ) ] ] @xmath119_{\\i\\j } = \\frac{\\partial \\p_\\i}{\\partial \\q_\\j }                      \\ , \\text { , } % text punctuation\\ ] ] or equivalently by the requirement that @xmath120_\\i      = \\jac[\\p(\\q)]_{\\i\\j } \\cdot \\delta \\q_\\j\\ ] ]    for any infinitesimal perturbation @xmath121 of @xmath122 .",
    "we assume that @xmath123 is actually a _ local _ grid function of @xmath122 , so the jacobian matrix is sparse .",
    "( for example , this would preclude the nonlocal 4th  order methods described by refs .",
    "we assume that by exploiting the locality of the discrete @xmath115 function , any single @xmath124 can be computed in @xmath125 time , independent of the grid size .",
    "we consider two general methods for computing the jacobian matrix @xmath44 $ ] .",
    "the first of these is the method .",
    "this involves numerically perturbing @xmath122 and examining the resulting perturbation in @xmath115 , @xmath119_{\\i\\j } \\approx      \\left [ \\frac{\\p(\\q + \\mu \\e^{(\\j ) } ) - \\p(\\q)}{\\mu } \\right]_\\i                      \\ , \\text { , } % text punctuation                          \\label{eqn - jac[p(q)]-np}\\ ] ] where @xmath126 is a kronecker - delta vector defined by @xmath127_\\i      = \\left\\ {        \\begin{array}{l@{\\quad}l }        1 & \\text{if $ \\i = \\j$ }    \\\\        0 & \\text{otherwise }   % % % \\\\",
    "\\end{array }        \\right .                      \\ ,",
    "\\text { , } % text punctuation\\ ] ] and @xmath128 is a `` small '' perturbation amplitude .",
    "this computation of the jacobian proceeds by columns : for each @xmath40 , @xmath129 is perturbed , and the resulting perturbation in @xmath115 gives the @xmath40th column of the jacobian matrix .    the perturbation amplitude @xmath128 should be chosen to balance the truncation error of the one - sided finite difference approximation against the numerical loss of significance caused by subtracting the nearly equal quantities @xmath130 and @xmath115 .",
    "@xcite discuss the choice of @xmath128 , and conclude that if @xmath115 can be evaluated with an accuracy of @xmath131 , then @xmath132 `` seems to work the best '' . in practice",
    "the choice of @xmath128 is nt very critical for horizon finding .",
    "values of @xmath133 to @xmath134 seem to work well , and the inaccuracies in the jacobian matrix resulting from these values of @xmath128 do nt seem to be a significant problem .",
    "this method of computing jacobians requires no knowledge of the @xmath115 function s internal structure .",
    "in particular , the @xmath115 function may involve arbitrary nonlinear computations , including multiple sequential stages of finite differencing and/or interpolation .",
    "this method is thus directly applicable to the @xmath98 computation .    assuming that @xmath115 is already known , computing @xmath44 $ ] by numerical perturbation requires a total of @xmath135 @xmath124 evaluations at each grid point , i.e.  it requires a perturbed-@xmath124 evaluation for each nonzero jacobian element .",
    "an alternate method of computing the jacobian matrix @xmath44 $ ] is by .",
    "this method makes explicit use of the finite differencing scheme used to compute the discrete @xmath115 function .",
    "suppose first that the continuum @xmath116 function is a position - dependent local _ linear _ differential operator , discretely approximated by a position - dependent local finite difference molecule @xmath50 , @xmath136 differentiating this , we have @xmath119_{\\i\\j } \\equiv \\frac{\\partial \\p_\\i}{\\partial \\q_\\j }      = \\left\\ {        \\begin{array}{l@{\\quad}l }        \\mm(\\i)_{\\j-\\i }    & \\text{if $ \\j-\\i \\in \\mm(\\i)$ } \\\\        0          & \\text{otherwise }       % % % \\\\",
    "\\end{array }        \\right .                      \\ , \\text { , } % text punctuation                          \\label{eqn - jac[p(q)]-from - mol}\\ ]",
    "] so that the molecule coefficients at each grid point give the corresponding row of the jacobian matrix .    more generally , suppose @xmath137 is a position - dependent local nonlinear algebraic function of @xmath49 and some finite number of @xmath49 s derivatives , say @xmath138    logically , the jacobian matrix @xmath44 $ ] is defined ( by ) in terms of the linearization of the discrete ( finite differenced ) @xmath115 function .",
    "however , as illustrated in figure  [ fig - linearize - vs - fd ] , if the discretization ( the finite differencing scheme ) commutes with the linearization , we can instead compute the jacobian by first linearizing the continuum @xmath116 function , then finite differencing this ( continuum ) linearized function .",
    "( this method of computing the jacobian is essentially just the `` jacobian part '' of the newton - kantorovich algorithm for solving nonlinear elliptic pdes . )    that is , we first linearize the continuum @xmath116 function , @xmath139 we then view the linearized function @xmath140 as a linear differential operator , and discretely approximate it by the position - dependent finite difference molecule @xmath141 where @xmath142 is the identity molecule and @xmath143 and @xmath144 are finite difference molecules discretely approximating @xmath145 and @xmath146 respectively .",
    "finally , we apply to the molecule @xmath50 defined by to obtain the desired jacobian matrix @xmath44 $ ] .    in practice ,",
    "there s no need to explicitly form the molecule @xmath50  the jacobian matrix elements can easily be assembled directly from the known @xmath142 , @xmath143 , and @xmath144 molecule coefficients and the @xmath147 , @xmath148 , and @xmath149 .",
    "once these coefficients are known , the assembly of the actual jacobian matrix elements is very cheap , requiring only a few arithmetic operations per matrix element to evaluate and  .",
    "the main cost of computing a jacobian matrix by symbolic differentiation is thus the computation of the jacobian coefficients themselves .",
    "depending on the functional form of the @xmath116 function , there may be anywhere from 1 to 10 coefficients , although in practice these often have many common subexpressions .",
    "in other words , where the numerical perturbation method requires a @xmath124 evaluation per nonzero jacobian _ element _ , the symbolic differentiation method requires the computation of `` a few '' jacobian - coefficient subexpressions per jacobian _",
    "row_. more precisely , suppose the computation of all the jacobian coefficients at a single grid point is @xmath150 times as costly as a @xmath124 evaluation .",
    "then the symbolic differentiation method is approximately @xmath151 times more efficient than the numerical perturbation method .",
    "we now consider the detailed semantics of the horizon function jacobian .",
    "we define the jacobian of @xmath152 , @xmath94 \\equiv \\jac[\\two \\h(\\h)]$ ] , by    [ eqn - jac[2h(h ) ] ] @xmath153_{\\i\\j } = \\frac{d \\ , \\two \\h_\\i}{d \\h_\\j }                      \\ , \\text { , } % text punctuation\\ ] ] ( where @xmath39 and @xmath40 are angular grid - point indices ) , or equivalently by the requirement that @xmath154_\\i      = \\jac[\\two \\h(\\h)]_{\\i\\j } \\cdot \\delta \\h_\\j\\ ] ]    for any infinitesimal perturbation @xmath155 . here",
    "@xmath39 and @xmath40 are both angular ( 2-dimensional ) grid - point indices .",
    "notice that this definition uses the _ total _ derivative @xmath156 .",
    "this is because @xmath98 is defined to always be evaluated _ at the position @xmath157 of the trial horizon surface _",
    ", so the jacobian @xmath158 $ ] must take into account not only the direct change in @xmath159 at a fixed position due to a perturbation in @xmath38 , but also the implicit change in @xmath159 caused by the field - variable coefficients in @xmath159 being evaluated at a perturbed position @xmath157 .",
    "it s also useful to consider the jacobian @xmath160 $ ] of the extended horizon function @xmath99 , which we define analogously by    [ eqn - jac[3h(h ) ] ] @xmath161_{\\i\\j } = \\frac{\\partial \\ , \\three \\h_\\i}{\\partial \\h_\\j }                      \\ , \\text { , } % text punctuation\\ ] ] or equivalently by the requirement that @xmath162_\\i      = \\jac[\\three \\h(\\h)]_{\\i\\j } \\cdot \\delta \\h_\\j\\ ] ]    for any infinitesimal perturbation @xmath155 . here",
    "@xmath39 is a 3-dimensional grid - point index for @xmath100 , while @xmath40 is an ( angular ) 2-dimensional grid - point index for @xmath38 .",
    "in contrast to @xmath158 $ ] , this definition uses the _ partial _ derivative @xmath163 .",
    "this is because we take @xmath99 to be evaluated at a fixed position ( a grid point in the neighborhood @xmath31 of the trial horizon surface ) _ which does nt change with perturbations in @xmath38 _ , so @xmath160 $ ] need only take into account the direct change in @xmath100 at a fixed position due to a perturbation in @xmath38 .",
    "@xmath160 $ ] thus has much simpler semantics than @xmath158 $ ] .",
    "we have found @xmath160 $ ] very useful , both as an intermediate variable in the computation of @xmath158 $ ] ( described in the next section ) , and also conceptually , as an aid to _ thinking _ about the jacobians .",
    "table  [ tab - methods - comparison ] ( discussed further in section  [ sect - methods - comparison ] ) summarizes all the jacobian - computation methods in this paper , which we now describe in detail .",
    "we tag each method with a shorthand , which gives the method s basic properties : whether it computes @xmath158 $ ] directly or computes @xmath160 $ ] as an intermediate step , whether it uses symbolic differentiation or numerical perturbation , and whether it uses a 1-stage or a 2-stage horizon function computation .",
    "the simplest methods for computing @xmath158 $ ] are the ones , which work directly with @xmath98 in angular - coordinate space , without computing @xmath160 $ ] as an intermediate step .",
    "since @xmath98 is nt given by a simple molecule operation of the form , symbolic differentiation is nt directly applicable here .",
    "however , numerical perturbation in angular - coordinate space is applicable , using either a 1-stage or a 2-stage method to compute @xmath98 .",
    "we refer to the resulting jacobian computation methods as the and methods respectively .",
    "our remaining methods for computing @xmath158 $ ] are all ones , which first explicitly compute @xmath160 $ ] , then compute @xmath158 $ ] from this in the manner described below .",
    "if @xmath99 is computed using the 1-stage method , i.e.  via and  , then either numerical perturbation or symbolic differentiation may be used to compute @xmath160 $ ] .",
    "we refer to these as the and methods respectively .",
    "the symbolic - differentiation jacobian coefficients for the 3d.sd.1s method are tabulated in appendix  [ app - sd - jac - coeffs ] .",
    "alternatively , if @xmath99 is computed using a 2-stage method , then @xmath160 $ ] may be computed either by the simple numerical perturbation of @xmath99 ( the method ) , or by separately computing the jacobians of the individual stages and matrix - multiplying them together . for the latter case",
    ", either numerical perturbation or symbolic differentiation may be used to compute the individual - stage jacobians , giving the and methods respectively .",
    "the symbolic - differentiation jacobian coefficients for the 3d.sd2.2s method are tabulated in appendix  [ app - sd - jac - coeffs ] .    for any of the 3-dimensional methods ,",
    "once @xmath160 $ ] is known , we compute @xmath158 $ ] as follows : @xmath164_{\\i\\j }      & \\equiv &          \\frac{d \\ , \\two \\h_\\i}{d \\h_\\j }                                      \\\\      & = &    \\frac{d \\ , \\two \\h(\\theta_\\i , \\phi_\\i ) }               { d \\h(\\theta_\\j , \\phi_\\j ) }                                      \\\\      & = &    \\frac{d \\ ,                \\three \\h(r=\\h(\\theta_\\i,\\phi_\\i ) , \\theta_\\i , \\phi_\\i ) }               { d \\h(\\theta_\\j , \\phi_\\j ) }          \\qquad          \\text{(by~\\eqref{eqn-2h(3h)-no - interp } ) }                                      \\\\      & = &    \\left .          \\frac{\\partial \\ , \\three \\h(r , \\theta_\\i , \\phi_\\i ) }               { \\partial \\h(\\theta_\\j , \\phi_\\j ) }          \\right|_{r = \\h(\\theta_\\i , \\phi_\\i ) }          +          \\left .",
    "\\frac{\\partial \\ , \\three \\h(r , \\theta_\\i , \\phi_\\i ) }               { r }          \\right|_{r = \\h(\\theta_\\i , \\phi_\\i ) }                                      \\\\      & = &    \\interp \\bigl (              \\jac[\\three \\h(\\h)]_{{\\langle r\\i \\rangle } \\j } ,              r = \\h_\\i              \\bigr )          +          \\interp ' \\bigl (               \\three \\h_{\\langle r\\i \\rangle } , r = \\h_\\i               \\bigr )                      \\ , \\text { , } % text punctuation                      \\label{eqn - jac[2h(h)]-from - jac[3h(h ) ] }                                      % % % \\\\\\end{aligned}\\ ] ] where the @xmath103 subscripts in denote that the interpolations are done along the radial line @xmath104 , analogously to , and where we neglect the interpolation errors in  .",
    "notice that the @xmath165 term in   may be computed very cheaply using the same @xmath100 data values used in computing @xmath159 , cf .  .",
    "( the number of @xmath100 data points used in the radial interpolation at each angular grid position will probably have to be increased by one to retain the same order of accuracy in the @xmath165 term in as in the @xmath166 term . )",
    "it s thus easy to compute @xmath158 $ ] once @xmath160 $ ] is known .",
    "table  [ tab - methods - comparison ] summarizes all the horizon - function and jacobian computation methods described in sections  [ sect - horizon - function ] and  [ sect - computing - horizon - function - jacobian ] .",
    "the table also shows which jacobian matrices the methods use , the methods measured relative cpu times in our axisymmetric - spacetime ( 2-dimensional ) code ( discussed further in appendix  [ app - code - details ] ) , and our estimates of the methods approximate implementation effort ( programming complexity ) .",
    "as can be seen from the table , for our implementation the 3d.sd.1s method is by far the most efficient of the jacobian computation methods , being about a factor of @xmath167 faster than any of the numerical perturbation methods .",
    "in fact , the computation of the jacobian @xmath158 $ ] by the 3d.sd.1s method is only @xmath168@xmath169 times more expensive than the simple evaluation of the horizon function @xmath98 .",
    "the relative performance of the different methods will of course vary considerably from one implementation to another , and especially between axisymmetric - spacetime ( 2-dimensional ) and fully - general - spacetime ( 3-dimensional ) codes .",
    "however , counting the number of operations needed for each method shows that the 3d.sd.1s method should remain the fastest for any reasonable implementation .",
    "( we omit details of the counting in view of their length and lack of general interest . )",
    "notably , the 3d.sd.1s method s relative advantage over the other methods should be approximately a factor of the molecule diameter _",
    "larger _ for fully - general - spacetime ( 3-dimensional ) codes than for axisymmetric - spacetime ( 2-dimensional ) codes such as ours .",
    "considering now the implementation efforts required by the various methods , in general we find that these depend more on which jacobian matrices are involved than on how the jacobians are computed : the 2-dimensional methods , involving only @xmath158 $ ] , are the easiest to implement , while the 3-dimensional methods involving ( only ) @xmath158 $ ] and @xmath160 $ ] are somewhat harder to implement .",
    "the 3-dimensional methods involving the individual - stage jacobians @xmath170 $ ] , @xmath171 $ ] , @xmath172 $ ] , and/or @xmath173 $ ] are considerably more difficult to implement , due to these jacobians more complicated sparsity patterns .",
    "all the jacobian matrices are highly sparse , and for reasonable efficiency it s essential to exploit this sparsity in their storage and computation .",
    "we have done this in our code , and our cpu - time measurements and implementation - effort estimates all reflect this .",
    "we briefly describe our sparse - jacobian storage scheme in appendix  [ app - sparse - jacobian - storage ] .",
    "this scheme is very efficient , but its programming is a significant fraction of the overall jacobian implementation effort , especially for the individual - stage jacobians .    comparing numerical perturbation and symbolic differentiation methods , we had previously suggested ( ref .",
    "@xcite ) that symbolic - differentiation jacobian computations would be very difficult to implement , necessarily requiring substantial support from a ( computer ) symbolic computation system .",
    "several colleagues have expressed similar opinions to us .",
    "we had also previous suggested ( ref .",
    "@xcite ) that due to the structure of the @xmath3 function , a jacobian - coefficient formalism of the type described in sections  [ sect - symbolic - differentiation ] and  [ sect - computing - horizon - function - jacobian ] would not be valid for the horizon function , so symbolic differentiation methods would require explicitly differentiating the finite difference equations .",
    "these suggestions have proven to be incorrect : using the jacobian - coefficient formalism described in sections  [ sect - symbolic - differentiation ] and  [ sect - computing - horizon - function - jacobian ] , only the continuum equations need be differentiated , and this is easily done by hand .",
    "more generally , using this formalism we find the actual programming of the symbolic differentiation methods to be only moderately more difficult than that of the numerical perturbation methods .",
    "some of the jacobian coefficients tabulated in appendix  [ app - sd - jac - coeffs ] are fairly complicated , but no more so than many other computations in @xmath0 numerical relativity .    in order to be confident of the correctness of any of the jacobian - computation methods except the simple 2-dimensional numerical perturbation ones ,",
    "we feel that it s highly desirable to program an independent method ( which may be programmed for simplicity at the expense of efficiency ) and make an end - to - end comparison of the resulting jacobian matrices .",
    "( we have successfully done this for each of the jacobian matrices computed by each of the methods listed in table  [ tab - methods - comparison ] , and our implementation - effort estimates there include doing this . ) if , and only if , the jacobians agree to within the expected truncation error of the numerical - perturbation jacobian approximation  , then we can have a high degree of confidence that both calculations are correct . if they disagree",
    ", then we find the detailed pattern of which matrix elements differ to be a very useful debugging aid .",
    "summarizing our comparisons , then , we find that the best jacobian computation method is clearly the 3d.sd.1s one .",
    "it s much more efficient than any of the other methods , and still quite easy to implement .",
    "before continuing our discussion of newtons - method horizon finding , in this section we digress to consider the convergence of finite differencing computations to the continuum limit .    as has been forcefully emphasized by choptuik ( refs .",
    "@xcite ) , a careful comparison of a finite differencing code s numerical results at different grid resolutions can yield very stringent tests of the code s numerical performance and correctness .",
    "in particular , such can yield reliable numerical estimates of a code s _ external _ errors , i.e.  of the deviation of the code s results from those that would be obtained by exactly solving the continuum equations . with",
    ", and only with , such estimates available , we can safely draw inferences about solutions of the continuum equations from the code s ( finite - resolution ) numerical results .    to apply this technique in the horizon - finding context ,",
    "suppose first that the ( a ) true ( continuum ) apparent horizon position @xmath174 is known .",
    "for a convergence test in this case , we run the horizon finder twice , using a 1:2 ratio of grid resolutions . as discussed in detail by ref .",
    "@xcite , if the code s numerical errors are dominated by truncation errors from @xmath72th  order finite differencing , the numerically computed horizon positions @xmath38 must satisfy    [ eqn - h(dx : dx/2 ) ] @xmath175      & = &    h^\\ast + ( \\delta x)^n f + o((\\delta x)^{n+2 } )                          \\label{eqn - h(dx : dx/2)-dx }                                      \\\\ \\h[\\delta x / 2 ]      & = &    h^\\ast + ( \\delta x / 2)^n f + o((\\delta x)^{n+2 } )                          \\label{eqn - h(dx : dx/2)-dx/2 }                                      % % % \\\\\\end{aligned}\\ ] ]    at each grid point , where @xmath176 $ ] denotes the numerically computed horizon position using grid resolution @xmath177 , and @xmath55 is an @xmath125 smooth function depending on various high order derivatives of @xmath174 and the field variables , but _ not _ on the grid resolution .",
    "( we re assuming centered finite differencing here in writing the higher order terms as @xmath178 , otherwise they would only be @xmath179 . ) neglecting the higher order terms , i.e.  in the limit of small @xmath177 , we can eliminate @xmath55 to obtain a direct relationship between the code s errors at the two resolutions , @xmath180 - h^\\ast}{\\h[\\delta x ] - h^\\ast }      = \\frac{1}{2^n }                      \\ , \\text { , } % text punctuation                          \\label{eqn - conv - test - dx : dx/2}\\ ] ] which must hold at each grid point common to the two grids .    to test how well any particular set of ( finite - resolution ) numerical results",
    "satisfies this convergence criterion , we plot a scatterplot of the high - resolution errors @xmath181 - h^\\ast$ ] against the low - resolution errors @xmath176 - h^\\ast$ ] at the grid points common to the two grids . if , and given the arguments of ref .",
    "@xcite , in practice _ only _ if , the error expansions   are valid with the higher order error terms negligible , i.e.  if and only if the errors are indeed dominated by the expected @xmath72th  order finite difference truncation errors , then all the points in the scatterplot will fall on a line through the origin with slope @xmath182 .",
    "now suppose the true ( continuum ) apparent horizon position @xmath174 is unknown .",
    "for a convergence test in this case , we run the horizon finder three times , using a 1:2:4 ratio of grid resolutions .",
    "analogously to the 2-grid case , we now have    [ eqn - h(dx : dx/2:dx/4 ) ] @xmath175      & = &    h^\\ast + ( \\delta x)^n f + o((\\delta x)^{n+2 } )                                      \\\\ \\h[\\delta x / 2 ]      & = &    h^\\ast + ( \\delta x / 2)^n f + o((\\delta x)^{n+2 } )                                      \\\\ \\h[\\delta x / 4 ]      & = &    h^\\ast + ( \\delta x / 4)^n f + o((\\delta x)^{n+2 } )                      \\ , \\text { , } % text punctuation                                      % % % \\\\\\end{aligned}\\ ] ]    at each grid point , with @xmath55 again independent of the grid resolution . again neglecting the higher order terms , we can eliminate both @xmath55 and @xmath174 to obtain the convergence criterion @xmath180 - \\h[\\delta x / 4]}{\\h[\\delta x ] - \\h[\\delta x / 2 ] }      = \\frac{1}{2^n }                      \\label{eqn - conv - test - dx : dx/2:dx/4}\\ ] ] which must hold at each grid point common to the three grids .",
    "we test this criterion using a scatterplot technique analogous to that for the 2-grid criterion  .",
    "we emphasize that for a 3-grid convergence test of this type , the true continuum solution @xmath174 need not be known .",
    "in fact , nothing in the derivation actually requires @xmath174 to be the true continuum horizon position  it need only be the true continuum solution to some continuum equation such that the truncation error formulas hold .",
    "we make use of this latter case in sections  [ sect - newton - kantorovich - method ] and  [ sect - global - conv - hsf - errors ] to apply 3-grid convergence tests to intermediate newton iterates ( trial horizon surfaces ) of our horizon finder .    for both the 2-grid and the 3-grid convergence test , we find that the _ pointwise _ nature of the scatterplot comparison makes it significantly more useful than a simple comparison of gridwise norms . in particular",
    ", the scatterplot comparison clearly shows convergence problems which may occur only in a small subset of the grid points ( for example near a boundary ) , which would be `` washed out '' in a comparison of gridwise norms .    notice also that the parameter @xmath72 , the order of the convergence , is ( should be ) known in advance from the form of the finite differencing scheme .",
    "thus the slope-@xmath182 line with which the scatterplot points are compared is nt fitted to the data points , but is rather an a  priori prediction with _ no _ adjustable parameters .",
    "convergence tests of this type are thus a very strong test of the validity of the finite differencing scheme and the error expansions or  .",
    "returning to our specific discussion of horizon finding , we now discuss the details of using newton s method or a variant to solve the simultaneous nonlinear algebraic equations @xmath5 .",
    "the basic newtons - method algorithm is well known : at each iteration , we first linearize the discrete @xmath4 function about the current approximate solution @xmath183 , @xmath184 \\cdot \\delta \\h        + o(\\|\\delta \\h\\|^2 )                      \\ , \\text { , } % text punctuation                          \\label{eqn - h(h)-linearized}\\ ] ] where @xmath155 now denotes a finite perturbation in @xmath38 , and where @xmath185 $ ] denotes the jacobian matrix @xmath94 $ ] evaluated at the point @xmath186 .",
    "we then neglect the higher order ( nonlinear ) terms and solve for the perturbation @xmath187 such that @xmath188 .",
    "this gives the simultaneous linear algebraic equations @xmath189",
    "\\cdot \\delta \\h^{(k ) } = - \\h(\\h^{(k ) } )                          \\label{eqn - newton - delta - h}\\ ] ] to be solved for @xmath187 .",
    "finally , we update the approximate solution via @xmath190 and repeat the iteration until some convergence criterion is satisfied .",
    "notice that here we re using the word `` convergence '' in a very different sense from that of section  [ sect - convergence - tests ]  here it refers to the of the newton iterates @xmath183 to the exact solution @xmath191 of the discrete equations , whereas there it refers to the of a finite difference computation result @xmath176 $ ] to its continuum limit @xmath174 as the grid resolution is increased .",
    "once the current solution estimate @xmath183 is reasonably close to @xmath191 , i.e.  in practice once the trial horizon surface is reasonably close to the ( an ) apparent horizon , newton s method converges extremely rapidly .",
    "in particular , once the linear approximation in is approximately valid , newton s method roughly squares the relative error @xmath192 at each iteration , and can thus bring the error down to a negligible value in only a few ( more ) iterations .",
    "( this rapid convergence depends critically on the mutual consistency of the horizon function and jacobian matrix used in the computation , and is thus a useful diagnostic for monitoring the jacobian s correctness . ) ( for a detailed discussion of newton s method , including precise formulations and proofs of these statements , see , for example , ref .",
    "@xcite . )",
    "however , if the initial guess @xmath193 for the horizon position , or more generally any newton iterate ( trial horizon surface ) @xmath183 , differs sufficiently from @xmath191 so that the linear approximation in is nt approximately valid , then newton s method may converge poorly , or fail to converge at all .",
    "unfortunately , as discussed in section  [ sect - global - conv - hsf - errors ] , for certain types of initial guesses newton s method fails to converge unless the initial guess is very close to the exact solution of the finite difference equations .",
    "there s an extensive numerical analysis literature on more robust algorithms for solving nonlinear algebraic equations , for example refs .  .",
    "we have found ref .",
    "@xcite to be a particularly useful introduction to this topic .    for horizon",
    "finding , the jacobian matrix s size is the number of angular grid points on the horizon surface .",
    "this is generally large enough that it s important for the nonlinear - algebraic - equations solver to support treating the jacobian as either a band matrix ( for axisymmetric - spacetime codes ) or a fully general sparse matrix ( for fully - general - spacetime codes ) .",
    "it s also desirable for the nonlinear - algebraic - equation solver to permit explicit bounds on the solution vector , so as to ensure the trial horizon surfaces never fall outside the radial extent of the code s main 3-dimensional grid .",
    "unfortunately , these requirements rule out many nonlinear - algebraic - equation software packages .    for the sake of expediency , in the present work we chose to write our own implementation of a relatively simple modified - newton algorithm , the algorithm described by refs .",
    "however , a much better long - term solution would be to use an extant nonlinear - algebraic - equations code embodying high - quality implementations of more sophisticated algorithms , such as the giant code described by refs .",
    "we would expect newtons - method horizon - finding codes using such software to be considerably more robust and efficient than our present code .",
    "the modified - newton algorithm used in this work , the line - search algorithm of refs .",
    "@xcite , is identical to the basic newtons - method algorithm , except that the newtons - method update is modified to @xmath194 , where @xmath195 $ ] is chosen at each iteration by an inner iteration to ensure that @xmath196 decreases monotonically .",
    "show that such a choice of @xmath197 is always possible , and describe an efficient algorithm for it .",
    "sufficiently close to the solution @xmath191 , this algorithm always chooses @xmath198 , and so takes the same steps as newton s method .",
    "the overall modified - newton algorithm thus retains the extremely rapid convergence of newton s method once the linear approximation in is good .",
    "the line - search algorithm described by refs .   always begins by trying the basic newton step @xmath198 . for horizon",
    "finding , we have slightly modified the algorithm to decrease the starting value of @xmath197 if necessary to ensure that @xmath199 lies within the radial extent of our code s main ( 3-dimensional ) numerical grid at each angular grid coordinate .",
    "our implementation of the algorithm also enforces an upper bound ( typically 10% ) on the relative change @xmath200 in any component of @xmath183 in a single outer iteration .",
    "however , it s not clear whether or not this latter restriction is a good idea : although it makes the algorithm more robust when the @xmath4 function is highly nonlinear , it may slow the algorithm s convergence when the @xmath4 function is only weakly nonlinear and the error in the initial guess is large .",
    "we give an example of this latter behavior in section  [ sect - accuracy ] .",
    "we have described the newtons - method algorithm , and the more robust modified versions of it , in terms of solving the discrete @xmath5 equations .",
    "however , these algorithms can also be interpreted directly in terms of solving the continuum @xmath91 equations .",
    "this method , and its relationship to the discrete newton s method , are discussed in detail by ref .",
    "@xcite .",
    "for the newton - kantorovich algorithm , at each iteration , we first linearize the continuum differential operator @xmath3 about the current continuum approximate solution @xmath201 , @xmath202 ( \\delta h ) + o(\\|\\delta h\\|^2 )                      \\ , \\text { , } % text punctuation                      \\label{eqn - continuum - h(h)-linearized}\\ ] ] where @xmath203 is now a finite perturbation in @xmath8 , and where the linear differential operator @xmath204 $ ] is now the linearization of the differential operator @xmath3 about the point @xmath205 .",
    "we then neglect the higher order ( nonlinear ) terms and solve for the perturbation @xmath206 such that @xmath207 .",
    "this gives the linear differential equation @xmath208(\\delta h^{(k ) } ) = - h(h^{(k ) } )                      \\label{eqn - newton - kantorovich - dh}\\ ] ] to be solved for @xmath206 .",
    "finally , we update the approximate solution via @xmath209 and repeat the iteration until some convergence criterion is satisfied .",
    "now suppose we discretely approximate this continuum newton - kantorovich algorithm by finite differencing the iteration equation .",
    "if the finite differencing and the linearization commute in the manner discussed in section  [ sect - symbolic - differentiation ] , then _ this finite - difference approximation to the newton - kantorovich algorithm is in fact identical to the discrete newtons - method algorithm applied to the ( discrete ) @xmath5 equations obtained by finite differencing the continuum @xmath91 equation_. ( in a simpler context , our jacobian - coefficient formalism described in section  [ sect - symbolic - differentiation ] essentially just exploits the `` jacobian part '' of this identity . )    therefore , when using the discrete newton s method to solve the @xmath5 equations , we can equivalently view each newton iterate ( trial horizon surface ) @xmath210 $ ] as being a finite difference approximation to the corresponding continuum newton - kantorovich iterate ( trial horizon surface ) @xmath201 . as the grid resolution is increased , each newton iterate @xmath210 $ ] should therefore show proper finite - difference - convergence _ regardless of the iteration - convergence or iteration - divergence of the newton or newton - kantorovich iteration itself_.    moreover , once we verify the individual newton iterates finite - differencing - convergence ( with a 3-grid convergence test ) , we can safely extrapolate the iteration - convergence or iteration - divergence of this discrete iteration to that of the continuum newton - kantorovich algorithm applied to the ( continuum ) @xmath91 equations . in other words , by this procedure we can ascribe the iteration - convergence or iteration - divergence of newton s method to inherent properties of the continuum @xmath91 equations , as opposed to ( say ) a finite differencing artifact .",
    "we make use of this in section  [ sect - global - conv - hsf - errors ] .",
    "we now consider the global convergence behavior of the newtons - method horizon finding algorithm .",
    "that is , how close must the initial guess @xmath193 be to the ( an ) exact solution @xmath191 of the finite difference equations in order for the iterates ( trial horizon surfaces ) @xmath183 to converge to @xmath191 ?",
    "in other words , how large is the algorithm s radius of convergence ?      to gain a general picture of the qualitative behavior of @xmath3 and its implications for newtons - method horizon",
    "finding , it s useful to consider schwarzschild spacetime .",
    "we use the eddington - finkelstein slicing , where the time coordinate is defined by requiring @xmath211 to be an ingoing null coordinate .",
    "( these slices are nt maximal : @xmath28 is nonzero and spatially variable throughout the slices . )    taking the black hole to be of dimensionless unit mass , the ( only ) apparent horizon in such a slice is the coordinate sphere @xmath212 . more generally , a straightforward calculation gives @xmath213 for spherical trial horizon surfaces with coordinate radius @xmath19 .",
    "figure  [ fig - schw - h ] shows @xmath214 for these surfaces . as expected , @xmath215 for the horizon @xmath212 .",
    "however , notice that @xmath36 reaches a maximum value at @xmath216 , and in particular that for @xmath217 , @xmath218 and @xmath219 .",
    "because of this , almost any algorithm  including newton s method and its variants  which tries to solve @xmath220 using only local information about @xmath214 , and which maintains the spherical symmetry , will diverge towards infinity when started from within this region , or if any intermediate iterate ( trial horizon surface ) ever enters it .    in fact , we expect broadly similar behavior for @xmath36 in any black hole spacetime : given an asymptotically flat slice containing an apparent horizon or horizons , consider any 1-parameter family of topologically 2-spherical nested trial horizon surfaces starting at the outermost apparent horizon and extending outward towards the 2-sphere at spatial infinity .",
    "@xmath215 for the horizon and for the 2-sphere at spatial infinity , so @xmath90 must attain a maximum for some finite trial horizon surface somewhere between these two surfaces .",
    "we thus expect the same general behavior as in the schwarzschild - slice case , i.e.  divergence to infinity if the initial guess or any intermediate iterate ( trial horizon surface ) lies outside the maximum-@xmath90 surface .",
    "this argument is nt completely rigorous , since the algorithm could move inward in an angularly anisotropic manner , but this seems unlikely .",
    "fortunately , in practice this is nt a problem : the black hole area theorem places an upper bound on the size of an apparent horizon , and this lets us avoid overly - large initial guesses , or restart the newton iteration if any intermediate iterate ( trial horizon surface ) is too large .      assuming the initial guess is close enough to the horizon for the divergence - to - infinity phenomenon not to occur , we find the global convergence behavior of newton s method to depend critically on the angular spatial frequency spectrum of the initial",
    "error @xmath221 : if the error has only low - spatial - frequency components ( in a sense to be clarified below ) , then newton s method has a large radius of convergence , i.e.  it will converge even for a rather inaccurate initial guess .",
    "however , _ if the error has significant high - spatial - frequency components , then we find that newton s method has a very small radius of convergence , i.e.  it often fails to converge even when the error @xmath221 is very small_.    this behavior is _ not _ an artifact of insufficient resolution in the finite difference grid .",
    "rather , it appears to be caused by a strong nonlinearity in the continuum @xmath3 function for high - spatial - frequency components in @xmath8 . in this context there",
    "s no sharp demarcation between `` low '' and `` high '' spatial frequencies , but in practice we use the terms to refer to angular fourier components varying as ( say ) @xmath6 with @xmath222 and @xmath7 respectively .      as an example of this behavior ,",
    "consider kerr spacetime with dimensionless angular momentum @xmath223 .",
    "we use the kerr slicing , where the time coordinate is defined by requiring @xmath211 to be an ingoing null coordinate .",
    "( these slices generalize the eddington - finkelstein slices of schwarzschild spacetime , and are similarly nonmaximal , with @xmath28 nonzero and spatially variable throughout the slices . )",
    "taking the black hole to be of dimensionless unit mass , the ( only ) apparent horizon in such a slice is the coordinate sphere @xmath224 .",
    "for this example we consider two different initial guesses for the horizon position : one containing only low - spatial - frequency errors , @xmath225 , and one containing significant high - spatial - frequency errors , @xmath226 .",
    "notice that both initial guesses are quite close to the actual horizon shape , differing from it by slightly less than 5% .",
    "we use a finite difference grid with @xmath227 , which is ample to resolve all the trial horizon surfaces occurring in the example .",
    "figure   shows the behavior of newton s method for the low - spatial - frequency - error initial guess .",
    "as can be seen , here newton s method converges without difficulty .",
    "figure   shows the behavior of newton s method for the high - spatial - frequency - error initial guess . here",
    "newton s method fails to converge : the successive iterates ( trial horizon surfaces ) @xmath183 move farther and farther away the horizon , and rapidly become more and more nonspherical .",
    "figure   shows the behavior of the modified newton s method for this same high - spatial - frequency - error initial guess .",
    "although the first iteration still moves the trial horizon surface somewhat inward from the horizon , the nonsphericity damps rapidly , and the successive iterates ( trial horizon surfaces ) quickly converge to the horizon .",
    "notice that all the intermediate iterates ( trial horizon surfaces ) in this example are well - resolved by the finite difference grid . to verify",
    "that insufficient grid resolution is nt a factor in the behavior of the horizon finder here , we have rerun all three parts of this example with several higher grid resolutions , obtaining results essentially identical to those plotted here .",
    "more quantitatively , following our discussion of the newton - kantorovich method in section  [ sect - newton - kantorovich - method ] , we have made 3-grid convergence tests of each intermediate iterate ( trial horizon surface ) in this example .",
    "for example , figure  [ fig - kerr - hp10-newton - conv ] shows a 3-grid convergence test for the newton iterate ( trial horizon surface ) @xmath228 plotted in figure  , using grids with resolutions @xmath229:@xmath230:@xmath231 . notice that despite the iteration - divergence of the newton iteration , this iterate shows excellent 4th  order finite - difference - convergence .",
    "the other newton and modified - newton iterates ( trial horizon surfaces ) in our example all similarly show excellent 4th  order finite - difference - convergence .",
    "we conclude that the iteration - divergence of newton s method seen in figure  , is in fact an inherent property of the continuum newton - kantorovich algorithm for this initial guess and slice .",
    "looking at the internal structure of this algorithm , we see that its only approximation is the linearization of the continuum @xmath3 function in , so the algorithm s iteration - divergence must ( can only ) be due to nonlinearity in the continuum @xmath3 function .      to investigate how general the poor convergence of newton s method seen in this example is , and to what extent",
    "it also occurs for the modified newton s method , we have made a monte carlo numerical survey of both algorithms behavior over a range of different initial - guess - error spatial frequency spectra .",
    "for this survey we first fix a particular horizon - finding algorithm .",
    "suppose we are given a slice containing an apparent horizon at the continuum position @xmath174 , and consider running the horizon finder with the generic perturbed initial guess @xmath232 for some set of initial - guess - error fourier coefficients @xmath233 .",
    "( here we include only even-@xmath234 cosine terms in @xmath20 so as to preserve axisymmetry and equatorial reflection symmetry , which our code requires . )    for each value of @xmath235 we define the horizon finder s in @xmath233-space to be the set of coefficients @xmath233 for which the horizon finder converges ( we presume to the correct solution ) .",
    "for example , the convergence region will in practice always include the origin in @xmath233-space , since there @xmath236 , so the initial guess differs from the exact solution of the discrete @xmath5 equations only by the small @xmath4 finite differencing error .",
    "we define @xmath237 to be the ( hyper)volume of the convergence region . as described in detail in appendix  [ app - hps - details ] , we estimate @xmath237 by monte carlo sampling in @xmath233-space .",
    "given @xmath237 , we then define the @xmath238         { \\displaystyle \\frac{v_m}{v_{m-2 } } }              & \\text{if $ m \\geq 2 $ }   % % % \\\\         \\end{array }         \\right .                      \\ , \\text { , } % text punctuation                                      % % % \\\\\\",
    "] ] so that @xmath239 measures the average radius of convergence of the horizon finder in the @xmath240 dimension .",
    "we have carried out such a horizon - perturbation survey for the same kerr slices of the unit - mass spin-@xmath241 kerr spacetime used in the previous example , for both the newton and the modified - newton algorithms , for @xmath242 , @xmath169 , @xmath243 ,  , @xmath244 .",
    "figure  [ fig - kerr - hps ] shows the resulting volume ratios . although the precise values are somewhat dependent on the details of our implementation and on the test setup ( in particular on the position of the inner grid boundary , which is at @xmath245 for these tests ) , the relative trends in the data should be fairly generic .",
    "these tests use a grid with @xmath227 , which is adequate to resolve all the perturbed trial horizon surfaces .    as can be seen from the figure ,",
    "the modified - newton algorithm is clearly superior to the newton algorithm , increasing the radius of convergence by a factor of @xmath169@xmath246 at high spatial frequencies .",
    "however , both algorithms radia of convergence still fall rapidly with increasing spatial frequency , approximately as @xmath247 , although the rate is slightly slower for the modified - newton than for the newton algorithm .",
    "the radius of convergence of newton s method falls below  0.1 ( @xmath248  of the horizon radius ) by  @xmath249 , and the data suggest that the radius of convergence of the modified - newton method would be similarly small by  @xmath250 .    since the grid resolution is adequate , we again conclude that the small radius of convergence of newton s method must be due to a strong high - spatial - frequency nonlinearity in the continuum @xmath3 function .",
    "our horizon - perturbation survey covers only a single axisymmetric initial slice and generic axisymmetric perturbations of the initial guess , but it seems unlikely that the nonlinearity would diminish for more general cases .",
    "huq ( ref .",
    "@xcite ) has made limited tests with nonaxisymmetric spacetimes and high - spatial - frequency perturbations , and has found ( poor ) convergence of newton s method similar to our results .",
    "although we write the continuum horizon function as @xmath251 , it s more accurate to write this as @xmath252 , since @xmath36 also depends on the slice s field variables and their spatial derivatives . examining the functional form of the @xmath253 function in   and",
    ", we see that @xmath36 depends on the @xmath254 components in a manner broadly similar to its dependence on @xmath8 .",
    "we thus conjecture that the @xmath253 function may exhibit strong high - spatial - frequency nonlinearity in the field variables , in particular in the @xmath254 components , similar to its nonlinear dependence on @xmath8 .",
    "if this is the case , then high - spatial - frequency variations in the field variables , such as would be caused by high - frequency gravitational radiation , might well impair the convergence of newton s method in a manner similar to high - spatial - frequency perturbations in @xmath8 .",
    "further investigation of this possibility , either by analytical study of the nonlinear structure of the @xmath253 function , or by numerical investigations , would be very interesting . fortunately",
    ", however , those ( few ) dynamic black hole spacetimes which have been explicitly computed thus far ( for example ref .",
    "@xcite ) seem to contain mainly low - frequency gravitational radiation .",
    "in general , how serious a problem is the poor high - spatial - frequency convergence of newton s method ? given a sufficiently good initial guess , newton s method still converges very rapidly ( quadratically ) , so the key question is , how good is the initial guess in practice ?",
    "two cases seem to be of particular importance : if the horizon finder is being used to update a horizon s position at each time step of a time evolution , then the previous time step s horizon position probably provides a sufficiently good initial guess for newton s method to converge well .",
    "in contrast , if the horizon finder is being used on initial data , or in a time evolution where there is no nearby horizon in the previous time step , then significant initial - guess errors can be expected , and newton s method may converge poorly .",
    "we now consider the accuracy of the newtons - method horizon finding algorithm . that is , assuming the newton or modified - newton iteration converges , how close is the horizon finder s final numerically computed horizon position to the ( a ) true continuum horizon position @xmath174 ?",
    "the horizon finder computes newton or modified - newton iterates ( trial horizon surfaces ) @xmath183 for @xmath255 , @xmath256 , @xmath169 ,  , until some convergence criterion is satisfied , say at @xmath257 .",
    "because of the extremely rapid convergence of the newton and modified - newton iterations once the error is sufficiently small ( cf .  section  [ sect - newtons - method ] ) , there s little extra cost in using a very strict convergence criterion , i.e.  in solving the discrete @xmath5 equations to very high accuracy . in our horizon finder",
    "we typically require @xmath258 .",
    "we denote the exact solution of the discrete @xmath5 equations by @xmath191 . given that @xmath259 is reasonably small , then from standard matrix - perturbation theory ( see , for example , refs .",
    "@xcite ) , @xmath260 , where @xmath261 is the condition number of the ( presumably nonsingular ) jacobian matrix @xmath94 $ ] at the horizon position .",
    "if we take the convergence tolerance to be strict enough for @xmath262 to be negligible , then the overall accuracy of the horizon finder , i.e.  the external error @xmath263 in the computed horizon position , is thus limited only by the closeness with which the discrete @xmath5 equations approximate the continuum @xmath91 equations , i.e.  by the accuracy of the @xmath4 finite differencing .",
    "this potential for very high accuracy is one of the main advantages of the newtons - method horizon - finding algorithm .    for an example of the accuracy attainable in practice",
    ", we again consider the kerr slices of the unit - mass spin-@xmath241 kerr spacetime .",
    "however , to make the horizon deviate from a coordinate sphere and hence be a more significant test case for our horizon finder , we apply the spatial coordinate transformation    [ eqn - w4kerr - coord - xform ] @xmath264 to the slice , where the parameters are given by @xmath265    as shown in figure  , in the transformed coordinates this gives a strongly non - spherical `` peanut - shaped '' horizon , similar in shape to those around a pair of coalescing black holes .",
    "we have run our horizon finder on this slice , using the warped - coordinate coordinate sphere @xmath266 as an initial guess and a grid resolution of @xmath227 .",
    "we used the modified - newton algorithm , which converged to the horizon without difficulty .",
    "( the convergence took 9  iterations , but would have taken only 6  iterations in the absence of our 10% restriction on the relative change in any component of @xmath38 in a single outer iteration , cf .",
    "section  [ sect - modifications - of - newtons - method ] . )",
    "figure   shows the initial guess and the final numerically computed horizon position .",
    "figure   shows the results of a 2-grid convergence test of the final numerically computed horizon position for this example , using grids with resolutions @xmath227:@xmath230 .",
    "as can be seen , the numerically computed solution shows excellent 4th  order convergence .",
    "moreover , the numerically computed horizon positions are very accurate , with @xmath267 for a grid resolution of @xmath13",
    ". errors of this magnitude are typical of what we find for newtons - method horizon finding using 4th  order finite differencing , so long as the grid adequately resolves the horizon shape .",
    "the main focus of this paper is on locally finding apparent horizons , i.e.  on finding an apparent horizon in a neighborhood of the initial guess . however , there s a related global problem of some interest which has heretofore attracted little attention , that of finding or recognizing the _ outermost _ apparent horizon in a slice .",
    "( by the outermost apparent horizon we mean the problem of determining whether or not a given apparent horizon is in fact the outermost one in a slice . )    these global problems are of particular interest when apparent horizons are used to set the inner boundary of a black - hole - excluding grid in the numerical evolution of a multiple - black - hole spacetime , as discussed by refs .  . in this context",
    ", we can use the appearance of a new outermost apparent horizon surrounding the previously - outermost apparent horizons around two black holes as a diagnostic that the black holes have collided and coalesced into a single ( distorted ) black hole . as suggested by ref .",
    "@xcite , we can then generate a new numerical grid and attach it to the new outermost apparent horizon , and continue the evolution on the exterior of the new ( distored ) black hole .",
    "so far as we know , no reliable algorithms are known for finding or recognizing outermost apparent horizons in nonspherical spacetimes .",
    "( for spherical spacetimes , a 1-dimensional search on @xmath214 suffices . )",
    "if started with a very large 2-sphere as the initial guess , the curvature flow method might well converge to the outermost horizon in the slice , but as mentioned in section  [ sect - algorithms - survey ] , the theoretical justification for this method s convergence is only valid in time - symmetric ( @xmath85 ) slices .    for the remaining local - horizon - finding algorithms surveyed in section  [ sect - algorithms - survey ] , including the newtons - method one , we know of no better method for locating or recognizing outermost horizons than trying the local - horizon - finder with a number of different initial guesses near the suspected position of an outermost horizon .",
    "if this method succeeds it locates a horizon , but there s still no assurance that this horizon is the outermost one in the slice .",
    "moreover , if all the local - horizon - finding trials fail , this may mean that there s no horizon in the vicinity of the initial guesses , or it may only mean that a horizon is present nearby but the method failed to converge to it .",
    "it s also not clear how many local - horizon - finding trials should be made , nor just how their initial guesses should be chosen .",
    "this is clearly not a satisfactory algorithm .",
    "further research to develop reliable algorithms for finding or recognizing outermost apparent horizons in generic ( nonspherical , nonmaximal ) slices would be very useful .",
    "we find newton s method to be an excellent horizon - finding algorithm : it handles fully generic slices , it s fairly easy to implement , it s very efficient , it s generally robust in its convergence , and it s very accurate .",
    "these properties are all well known , and newton s method is widely used for horizon finding . in this paper",
    "we focus on two key aspects of this algorithm : the computation of the jacobian matrix , and the algorithm s global convergence behavior .",
    "traditionally , the newtons - method jacobian matrix is computed by a numerical perturbation technique . in this paper",
    "we present a much more efficient `` symbolic differentiation '' technique .",
    "conceptually , this entails differentiating the actual finite difference equations used to compute the discrete horizon function @xmath4 .",
    "however , provided the finite differencing scheme commutes with linearization , the computation can instead be done by first differentiating the continuum horizon function @xmath3 , then finite differencing .",
    "( this is essentially just the `` jacobian part '' of the newton - kantorovich method for solving nonlinear pdes . )    in our axisymmetric - spacetime ( 2-dimensional ) numerical code , this method is about a factor of  @xmath167 faster than than any other jacobian computation method .",
    "in fact , the jacobian computation using this method is only @xmath168@xmath169 times more expensive than the simple evaluation of @xmath4 .",
    "we expect the symbolic differentiation method s relative advantage over other jacobian computation methods to be roughly similar for other axisymmetric - spacetime ( 2-dimensional ) codes , and an additional factor of @xmath268@xmath167 larger for fully - general - spacetime ( 3-dimensional ) codes .",
    "we had previously suggested ( ref .",
    "@xcite ) that symbolic - differentiation jacobian computations would be quite difficult , necessarily requiring substantial support from a ( computer ) symbolic computation system .",
    "several colleagues have expressed similar opinions to us . however , this turns out not to be the case : we computed all the symbolic - differentiation jacobian coefficients for our horizon finder by hand in only a few few pages of algebra .",
    "some of the coefficients are fairly complicated , but no more so than many other computations in @xmath0 numerical relativity .",
    "we find the actual programming of the symbolic differentiation jacobian computation to be only moderately more difficult than that of a numerical perturbation computation . in order to be confident of the correctness of a symbolic differentiation jacobian computation",
    ", we feel that it s highly desirable to program an independent numerical perturbation method and make an end - to - end comparison of the resulting jacobian matrices .",
    "the comparison jacobian computation may be programmed for simplicity at the expense of efficiency , so it need nt add much to the overall symbolic - differentiation implementation effort .    turning now to the convergence behavior of newton s method , we find that so long as the error in the initial guess ( its deviation from the true horizon position ) contains only low - spatial - frequency components , a newtons - method horizon finder has a large ( good ) radius of convergence , i.e.  it converges even for rather inaccurate initial guesses .",
    "however , if the error in the initial guess contains significant high - spatial - frequency components , then we find that newton s method has a small ( poor ) radius of convergence , i.e.  it may fail to converge even when the initial guess is quite close to the true horizon position . in this context there s no sharp demarcation between `` low '' and `` high '' spatial frequencies , but in practice we use the terms to refer to angular fourier components varying as ( say ) @xmath6 with @xmath222 and @xmath7 respectively .    using a monte carlo survey of initial - guess - error fourier - coefficient space , we find that the radius of convergence for newton s method falls rapidly with increasing spatial frequency , approximately as @xmath9 .",
    "a simple `` line - search '' modification of newton s method roughly doubles the horizon finder s radius of convergence , and slightly slows the rate of decline with spatial frequency . using a robust nonlinear - algebraic - equations code to solve the discrete @xmath5 equations would probably give some further improvement , but we doubt that it would change the overall trend .    using quantitative convergence tests ,",
    "we demonstrate that the poor high - spatial - frequency convergence behavior of newton s method is _ not _ an artifact of insufficient resolution in the finite difference grid .",
    "rather , it appears to be inherent in the ( a ) strong nonlinearity of the continuum @xmath3 function for high - spatial - frequency components in @xmath8 .",
    "we conjecture that @xmath36 may be similarly nonlinear in its high - spatial - frequency dependence on the inverse - metric components .",
    "if so , then the presence of high - frequency gravitational radiation might well also impair the convergence of newton s method , and possibly other horizon - finding methods as well .",
    "further investigation of this possibility would be very interesting .",
    "fortunately , if the horizon finder is being used to update a horizon s position at each time step of a time evolution , then the previous time step s horizon position probably provides a sufficiently good initial guess for newton s method to converge well .    provided it converges , the newtons - method algorithm for horizon finding is potentially very accurate , in practice limited only by the accuracy of the @xmath4 finite differencing scheme . using 4th  order finite differencing",
    ", we demonstrate that the error in the numerically computed horizon position , i.e.  the deviation of @xmath38 from the true continuum horizon position , shows the expected @xmath10 scaling with grid resolution @xmath11 , and is typically @xmath12 for a grid resolution of @xmath13 .",
    "finally , we have argued that considerable further research is needed to develop algorithms for finding or recognizing the _ outermost _ apparent horizon in a slice .",
    "this is an important problem for the numerical evolution of multiple - black - hole spacetimes with the black holes excluded from the numerical evolution , but so far as we know no reliable algorithms are known for it except in spherical symmetry .",
    "we thank m.  huq for numerous useful conversations on horizon finding , and for helpful comments on various drafts of this paper .",
    "we thank d.  bernstein for communicating unpublished research notes on the curvature - flow method to us .",
    "we thank w.  g.  unruh and the university of british columbia physics department for their hospitality and the use of their research facilities .",
    "we thank j.  wolfgang for major assistance in setting up computer facilities , and g.  rodgers for financial support .",
    "in this appendix we tabulate all the nonzero symbolic - differentiation jacobian coefficients for @xmath269 and its subfunctions .",
    "these are used in the 3d.sd.1s and 3d.sd2.2s jacobian - computation methods .",
    "all the coefficients are obtained by straightforward , if somewhat tedious , linearizations in the manner of  , starting from the defining equations noted .    for @xmath269 , starting from   and  , the coefficients are    @xmath270            \\partial_{uv } h                              \\nonumber    \\\\      &    &    \\quad          { }          + \\thalf            g^{ix } \\bigl [               \\partial_i g^{rr }               - 2 ( \\partial_i g^{ru } ) \\partial_u h               + ( \\partial_i g^{uv } ) ( \\partial_u h ) ( \\partial_v h )               \\bigr ]                              \\nonumber    \\\\      &    &    \\quad          { }          + ( g^{ir } - g^{iu } \\partial_u h )            \\bigl [            \\partial_i g^{xr } - ( \\partial_i g^{xv } ) \\partial_v h            \\bigr ]                                      \\\\ \\frac{\\partial b}{\\partial ( \\partial_x h ) }      & = &    { }          - \\partial_i g^{ix }          - ( \\partial_i \\ln \\sqrt{g } ) g^{ix }                                      \\\\ \\frac{\\partial c}{\\partial ( \\partial_x h ) }      & = &    { }          - 2 ( k^{xr } - k^{xu } \\partial_u h )                                      \\\\ \\frac{\\partial d}{\\partial ( \\partial_x h ) }      & = &    { }          - 2 ( g^{xr } - g^{xu } \\partial_u h )                                      \\\\",
    "\\frac{\\partial a}{\\partial ( \\partial_{xy } h ) }      & = &    ( g^{xr } - g^{xu } \\partial_u h ) ( g^{yr } - g^{yu } \\partial_u h )                                      \\\\ \\frac{\\partial b}{\\partial ( \\partial_{xy } h ) }      & = &    - g^{xy }                      \\ , \\text{. } % text punctuation                                      % % % \\\\\\end{aligned}\\ ] ]    for @xmath271 , starting from  , the coefficients are @xmath272    for @xmath273 , starting from  , the coefficients are @xmath274}\\end{aligned}\\ ] ]    for @xmath275 , starting from  , the coefficients are @xmath276    for @xmath277 , starting from   and  , the coefficients are    @xmath278            \\partial_i s_j                              \\nonumber    \\\\      &    &    \\quad          { }          - \\thalf g^{ix } \\bigl [ ( \\partial_i g^{kl } ) s_k s_l \\bigr ]          - ( g^{ij } s_j ) \\bigl [ ( \\partial_i g^{xk } ) s_k \\bigr ]                                      \\\\ \\frac{\\partial b}{\\partial s_x }      & = &    { }          - \\partial_i g^{ix }          + ( \\partial_i \\ln \\sqrt{g } ) g^{ix }                                      \\\\ \\frac{\\partial c}{\\partial s_x }      & = &    { }          2 k^{xi } s_i                                      \\\\",
    "\\frac{\\partial d}{\\partial s_x }      & = &    { }          2 g^{xi } s_i                                      \\\\ \\frac{\\partial a}{\\partial ( \\partial_x s_y ) }      & = &    - ( g^{xk } s_k ) ( g^{yl } s_l )                                      \\\\",
    "\\frac{\\partial b}{\\partial ( \\partial_x s_y ) }      & = &    g^{xy }                      \\ , \\text{. } % text punctuation                                      % % % \\\\\\end{aligned}\\ ] ]    for @xmath279 , starting from  , the coefficients are    @xmath280",
    "in this appendix we outline those details of our horizon - finding code relevant to the remainder of this paper .",
    "our horizon finder implements all the horizon - function and jacobian - computation methods discussed in this paper , as summarized in table  [ tab - methods - comparison ] .",
    "it s part of a larger @xmath0 code under development , designed to time - evolve an asymptotically flat axisymmetric vacuum spacetime containing a single black hole present in the initial data .",
    "the black hole is excluded from the numerical grid in the manner described by refs .  .",
    "the code uses 4th  order centered finite differencing ( 5-point molecules ) for finite differencing , on a 2-dimensional polar - spherical - coordinate grid .",
    "( the code also assumes equatorial reflection symmetry , but this is merely for convenience and could easily be changed . )",
    "the code uses a `` pde compiler '' to automatically generate all the finite differencing and other grid - computation code , including that for the horizon function and jacobian computations , from a high - level tensor - differential - operator specification of the @xmath0 equations .",
    "the entire code is freely available on request from the author , and may be modified and/or redistributed under the terms of the gnu public license .",
    "the code should be easily portable to any modern computing platform .",
    "it s mainly written in ansi  c ( about 30k  lines ) and the maple symbolic - computation language ( about 9k  lines for the pde compiler itself , and about 6k  lines for the @xmath0 equations ) , together with about 1k  lines of awk .",
    "the code for the horizon finder itself is about 6k  lines of c and 2k  lines of maple , but a large part of this is due to its supporting many different combinations of finite differencing schemes and horizon - function and jacobian computation methods .",
    "we estimate that an implementation supporting only a single differencing scheme and horizon - function and jacobian computation method , supplemented by a not - optimized - for - efficiency independent jacobian computation for debugging purposes ( cf .",
    "section  [ sect - methods - comparison ] ) , would be a factor of @xmath281 smaller .",
    "the code takes the metric , extrinsic curvature , and other @xmath0 field tensors to be algebraically fully general , i.e.  it permits all their coordinate components to be nonzero . to avoid @xmath282  axis",
    "coordinate singularities , the code uses a hybrid of polar spherical and cartesian coordinates as a tensor basis . as discussed in detail by ref .",
    "@xcite , for the subset of the slice containing the code s ( 2-dimensional ) grid , this hybrid coordinate system combines the convenient topology of polar spherical coordinates with the singularity - free nature of cartesian coordinates .    for present purposes ,",
    "the key consequence of this @xmath282-axis - handling method is that in this work we ve made no effort to avoid expressions which would be singular on the @xmath282  axis if polar spherical coordinates were used as a tensor basis .",
    "we havent investigated this case in detail , but we suspect such singularities would be widespread .",
    "as mentioned in section  [ sect - methods - comparison ] , all the jacobian matrices involved in horizon finding are highly sparse , and for reasonable efficiency this sparsity _ must _ be exploited in storing and computing the jacobians . in this appendix",
    "we briefly describe our sparse - jacobian storage scheme .",
    "this scheme stores the jacobian by rows , and is applicable to all of the jacobian matrices which arise in our horizon - finding algorithm .",
    "we consider first the storage of @xmath158 $ ] .",
    "which elements in a specified row  @xmath39 of this jacobian are nonzero ? from the basic definition  , we see that the nonzero elements  @xmath40 are precisely those where @xmath283 depends on @xmath284 , i.e.  those for which @xmath284 enters into the computation of @xmath283 .",
    "that is , for a 1(2)-stage @xmath99 computation , the nonzero - jacobian  @xmath40 values are precisely those within 1(2 )  molecule radia of @xmath39 .",
    "this makes it easy to store the jacobian : for each grid point @xmath39 , we simply store a molecule - sized ( twice - molecule - sized ) array of jacobian elements .    in practice , for an axisymmetric - spacetime ( 2-dimensional ) code , where @xmath39 and  @xmath40 are both 1-dimensional ( @xmath20 ) grid indices and the jacobian is a band matrix , we would store the jacobian as a 2-dimensional array with indices @xmath39 and  @xmath285 . for a fully - general - spacetime ( 3-dimensional ) code , where @xmath39 and  @xmath40 are",
    "both 2-dimensional ( @xmath20 and @xmath21 ) grid indices , we would store the jacobian as a 4-dimensional array with indices @xmath286 , @xmath287 , @xmath288 , and @xmath289 , where we temporarily use subscripts for coordinate components , and where for pedagogical simplicity we ignore the artificial grid boundaries at @xmath290 and @xmath291 .    a similar storage scheme may be used for more complicated jacobians .",
    "for example , consider the storage of @xmath160 $ ] . here",
    "@xmath39  is a 3-dimensional grid point index for @xmath100 , while @xmath40  is a 2-dimensional grid point index for @xmath38 . for a 1(2)-stage @xmath99 computation ,",
    "the nonzero jacobian elements in a specified jacobian row  @xmath39 are now precisely those  @xmath40 within 1(2 )  angular molecule radia of the angular components of  @xmath39 .",
    "thus for an axisymmetric - spacetime ( 2-dimensional ) code we would store this jacobian as a 3-dimensional array with indices @xmath292 , @xmath286 , and @xmath288 , while for a fully - general - spacetime ( 3-dimensional ) code we would store the jacobian as a 5-dimensional array with indices @xmath293 , @xmath287 , @xmath288 , and @xmath289 .",
    "notice that with this storage scheme the jacobian s structure , i.e.  the location of its nonzero elements , is stored implicitly .",
    "this makes this scheme considerably more efficient in both space and time than generic `` sparse matrix '' storage schemes ( for example those of refs .",
    "@xcite ) , which invariably require the storage of large integer or pointer arrays to record a sparse matrix s structure .",
    "in this appendix we describe our monte carlo horizon - perturbation survey ( cf .  section  [ sect - global - conv - hsf - errors ] ) in more detail . given the maximum initial - guess - error spatial frequency @xmath235 , the goal of the survey procedure is to estimate @xmath237 , the ( hyper)volume in @xmath233-space of the horizon finder s convergence region .    to do this ,",
    "we first start from the origin in @xmath233-space , and search outwards along each @xmath294 axis until we find coefficients for which the horizon finder fails to converge .",
    "this gives the intersection of the @xmath294 coordinate axes with the boundary of the convergence region .",
    "we then construct a sequence of nested hypercubes ( strictly speaking , hyper - parallelepipeds ) @xmath295 , @xmath296 , @xmath297 ,  in @xmath233-space , starting with @xmath295 just containing the @xmath294-coordinate - axis boundaries of the convergence region , and expanding outwards .",
    "we use the obvious monte carlo sampling algorithm to estimate the volume of the convergence region contained within the first hypercube @xmath295 , and then within the differences @xmath298 of the succeeding hypercubes .",
    "we continue this process until one of the differences contains no convergence - region volume .",
    "we include one additional hypercube in the sequence after this , typically larger than the previous one in each dimension , to provide a safety margin against missing disconnected `` islands '' or fractal zones near the boundary of the convergence region .",
    "( these are quite plausible ; recall that the ( fractal ) julia set is just the convergence region of a simple newtons - method iteration . ) finally , we compute an estimate for @xmath237 by simply adding the convergence - region - volume estimates for @xmath295 and each @xmath298 .    unfortunately , as @xmath235 and hence the dimensionality of @xmath233-space increases , we find that the fraction of the hypercubes and hypercube differences occupied by the convergence region decreases rapidly , so a very large number of horizon - finding trials is needed to obtain a reasonable statistical accuracy for @xmath237 .",
    "( for example , the @xmath299 points in figure  [ fig - kerr - hps ] required 15,000 trials each . ) it s this effect which ultimately limits the maximum value of @xmath235 attainable in practice by a survey of this type .                                                                                                                                            .",
    "this table summarizes the various methods for computing the horizon function @xmath98 and its jacobian @xmath158 $ ] .",
    "the `` codes '' are shorthand labels for referring to the various methods .",
    "the relative cpu times are as measured for our implementation ( described in appendix  [ app - code - details ] ) , and are per angular grid point , normalized relative to the 1-stage @xmath98 computation .",
    "the notation means whichever of @xmath106 and/or @xmath107 is appropriate , depending on the precise 2-stage method used to compute the horizon function .",
    "[ cols=\"<,<,<,<,<,^ , < \" , ]"
  ],
  "abstract_text": [
    "<S> we review various algorithms for finding apparent horizons in @xmath0 numerical relativity . </S>",
    "<S> we then focus on one particular algorithm , in which we pose the apparent horizon equation @xmath1 as a nonlinear elliptic ( boundary - value ) pde on angular - coordinate space for the horizon shape function @xmath2 , finite difference this pde , and use newton s method or a variant to solve the finite difference equations .    </S>",
    "<S> we describe a method for computing the jacobian matrix of the finite differenced @xmath3 function @xmath4 by symbolically differentiating the finite difference equations , giving the jacobian elements directly in terms of the finite difference molecule coefficients used in computing @xmath4 . assuming the finite differencing scheme commutes with linearization </S>",
    "<S> , we show how the jacobian elements may be computed by first linearizing the continuum @xmath3 equations , then finite differencing the linearized continuum equations . </S>",
    "<S> ( this is essentially just the `` jacobian part '' of the newton - kantorovich method for solving nonlinear pdes . ) </S>",
    "<S> we tabulate the resulting jacobian coefficients for a number of different @xmath4 and jacobian computation schemes .    </S>",
    "<S> we find this symbolic differentiation method of computing the @xmath4 jacobian to be _ much _ more efficient than the usual numerical - perturbation method , and also much easier to implement than is commonly thought .    </S>",
    "<S> when solving the discrete @xmath5 equations , we find that newton s method generally shows robust convergence . </S>",
    "<S> however , we find that it has a small ( poor ) radius of convergence if the initial guess for the horizon position contains significant high - spatial - frequency error components , i.e.  angular fourier components varying as ( say ) @xmath6 with @xmath7 . </S>",
    "<S> ( such components occur naturally if spacetime contains significant amounts of high - frequency gravitational radiation . ) </S>",
    "<S> we show that this poor convergence behavior is _ not _ an artifact of insufficient resolution in the finite difference grid ; rather , it appears to be caused by a strong nonlinearity in the continuum @xmath3 function for high - spatial - frequency error components in @xmath8 . </S>",
    "<S> we find that a simple `` line search '' modification of newton s method roughly doubles the horizon finder s radius of convergence , but both the unmodified and modified methods radia of convergence still fall rapidly with increasing spatial frequency , approximately as @xmath9 . </S>",
    "<S> further research is needed to explore more robust numerical algorithms for solving the @xmath5 equations .    </S>",
    "<S> provided it converges , the newtons - method algorithm for horizon finding is potentially very accurate , in practice limited only by the accuracy of the @xmath4 finite differencing scheme . using 4th  order finite differencing </S>",
    "<S> , we demonstrate that the error in the numerically computed horizon position shows the expected @xmath10 scaling with grid resolution @xmath11 , and is typically @xmath12 for a grid resolution of @xmath13 .    </S>",
    "<S> finally , we briefly discuss the global problem of finding or recognizing the _ outermost _ apparent horizon in a slice . </S>",
    "<S> we argue that this is an important problem , and that no reliable algorithms currently exist for it except in spherical symmetry .    # </S>",
    "<S> 1to 0em # 1``#1 '' # 1#2 h p # 1_#1 _ # 1_#1 _ # 1_#1 _ # 1_#1 _ # 1_#1 _ # 1eq .  </S>",
    "<S> @xmath14 # 1eqs .  </S>",
    "<S> @xmath14 # 1@xmath14 </S>"
  ]
}