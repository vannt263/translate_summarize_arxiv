{
  "article_text": [
    "the toolbox is made to be used with the following approach : +   + declare an initial state , let it evolve through a quantum optical circuit involving linear optics ( lo ) and measurements and finally ask various questions about the structure , entanglement , and properties of the final state . +   + the toolbox intends to do so providing : +   + a ) a framework in which to declare , manipulate and characterize quantum states of light ( finite number of modes , and finite dimensional ) .",
    "+   + b ) procedures that implement linear operations or whole linear optics circuits on our states such as :    * beam splitters ( bs ) * phase shifters ( ps ) .",
    "* arbitrary unitary transformations of the modes .",
    "\\c ) procedures that implement arbitrary measurements ( both projective or generalized positive operator valued measures ( povm ) ) .",
    "+   + d ) procedures to determine probabilities and expected values for projective measurements and povm measurements .",
    "+   + e ) procedures to trace out measured or inaccessible modes .",
    "+   + f ) procedures to calculate different entanglement measures such as :    * entropy of entanglement * partial trace , norm @xmath1 negativity , logarithmic negativity    \\g ) access to properties such as the mean energy of given states .",
    "+   + h ) extract and display lists of coefficients along with their indexes like : @xmath2 @xmath3 +   + h ) tools to easily plot states and density matrices .",
    "some previous knowledge about _ maple _ from maplesoft@xmath0 is required to use this tool . however , the brief `` take a tour of _ maple _ '' should suffice to get started .",
    "this toolbox works with maple 9.5 , maple 10 and maple 11 .      * procedures * : formally , in maple , a procedure definition is a valid expression that can be assigned to a name .",
    "the procedures we will use can be thought of as a set of `` rules '' that generally receive one or more inputs and return one or more outputs .",
    "we will write them in typewriter face .",
    "for example the procedure ` ishermitian`(m ) evaluates if a matrix * m * describing a density matrix is hermitian .",
    "a dictionary with all the procedures involved in * quantavo * can be found in the appendix .",
    "+   + * modules * : modules are repositories of procedures . by loading a module we can use its procedures in the maple worksheet . for example * quantavo * is the module containing the procedures we will use .",
    "+   + * objects * : the objects in which we will encode our quantum states will be written in bold face",
    ". these will include * vec , mat , matcol * and * poly * and will be introduced later .",
    "+   + * d and k * : throughout the manual , ` @xmath4 ' will stand for the number of modes and ` @xmath5 ' for the dimension of each mode . if considering the photon number degree of freedom , then ` @xmath6 ' will be the maximum number of photons in any mode .",
    "it is important to keep track of the value of these two global variables throughout the worksheet as they play an important role in the labelling of the optical modes and translation procedures .",
    "these variables can always be updated and displayed with the procedure : ` findknd`(state ) .",
    "all necessary files can be found at , + http://www.imperial.ac.uk/quantuminformation/research/downloads    1 .",
    "uncompress the file * quantavo.zip*. 2 .",
    "save the folder quantavo to a given directory .",
    "it should contain the files * quantavo.mpl * and * quantavo_example_worksheet.mw*. 3 .",
    "one can start opening the worksheet * quantavo_example_worksheet.mw*. 4 .   to use the module in a new worksheet execute the following commands : +   +   +   + it should return a list of all the procedures available : +   + 5 .",
    "you are ready to use !",
    "+    note that you may also save the module to your maple library . to do so , visit the maple help on ` module ` , ` savelibname ` and ` savelib ` .",
    "to run one has to load the following modules :    * * linearalgebra * ( linear algebra package from maplesoft@xmath0 built in _ maple _ )",
    "* * quantavo * ( general toolbox )    additionally , if we want to plot our states we will also need the module    * * geom3d * ( geometry package from maplesoft@xmath0 built in _ maple _ ) * * plots * ( plotting package from maplesoft@xmath0 built in _ maple _ )      when quantum optical states have a few modes and live in high dimensions , the matrices or vectors describing them very soon become intractable . to mitigate this difficulty , the procedures from * quantavo * store and manipulate only the non - zero elements in the description of our states .",
    "our main objects will be 2 column and 3 column matrices .",
    "two column objects will describe vectors in hilbert space of the form : @xmath7 where all indices `` @xmath8 '' range from @xmath9 .",
    "pure state vectors will be encoded in 2 column matrices that we will call _ trimmed vectors _ containing only non - zero entries .",
    "they will only contain non - zero entries .",
    "these objects will be named as a short vector : `` * * vec * * '' and will have the following appearance :    @xmath10\\\\\\noalign{\\medskip}\\lambda&[1,1,0 ] \\\\\\noalign{\\medskip}{\\lambda}^{2}&[2,2,0]\\\\\\noalign{\\medskip}{\\lambda } ^{3}&[3,3,0]\\end { array } \\right]\\ ] ]    for each row , the second column will be a list with the number of photons in each mode , this way [ 0,1,2 ] stands for @xmath11 .",
    "the first column will contain the coefficient associated with this ket .",
    "the whole will describe the linear supperposition of all these kets with their coefficients , therefore the above @xmath12 describes the unnormalized quantum state : @xmath13 +   +      two objects will be used to display density matrices .",
    "the first one is a square matrix , with as little zero entries as possible .",
    "this matrix will be called `` * * mat * * '' and will have for the above state the following form :    @xmath14&[1,1,0]&[2,2,0]&[3,3,0 ] \\\\\\noalign{\\medskip}[0,0,0]&1&\\bar{\\lambda } &    \\bar{\\lambda}^{2 } & \\bar{\\lambda}^{3 } \\\\\\noalign{\\medskip}[1,1,0]&\\lambda&\\lambda\\,\\bar{\\lambda } & \\lambda\\ ,   \\bar{\\lambda}^{2}&\\lambda\\ , \\bar{\\lambda}^{3}\\\\\\noalign{\\medskip}[2,2,0]&{\\lambda}^{2 } & { \\lambda}^{2}\\bar{\\lambda } & { \\lambda}^{2 }    \\bar{\\lambda }    ^{2}&{\\lambda } ^{2 } \\bar{\\lambda}^{3 } \\\\\\noalign{\\medskip}[3,3,0]&{\\lambda}^{3}&{\\lambda}^{3}\\bar{\\lambda }   & { \\lambda}^{3 } \\bar{\\lambda}^{2}&{\\lambda}^{3 }   \\bar{\\lambda}^{3}\\end { array } \\right]\\ ] ] +   + another object that can also describe a density matrix will be a 3 column matrix , or trimmed density matrix .",
    "it will be named as a short column matrix : `` * * matcol * * '' .",
    "the second column will be a list with the number of photons in each mode of the ket .",
    "this way , [ 0,1 ] in the 2nd column describes @xmath15 .",
    "the third column will be a list with the number of photons in each mode of the bra ; therefore [ 2,1 ] in the 3rd column describes @xmath16 .",
    "finally the first column will have the coefficient associated with this @xmath17ket@xmath18bra@xmath17 .",
    "the whole will describe the non zero elements of the density matrix .",
    "as an example consider the above state which will be :    @xmath19&[0,0,0]\\\\\\noalign{\\medskip } \\bar{\\lambda } & [ 0,0,0]&[1,1,0]\\\\\\noalign{\\medskip }   \\bar{\\lambda}^{2}&[0,0,0]&[2,2,0]\\\\\\noalign{\\medskip }    \\bar{\\lambda}^{3}&[0,0,0]&[3,3,0]\\\\\\noalign{\\medskip }   \\lambda&[1,1,0]&[0,0,0]\\\\\\noalign{\\medskip }   \\lambda\\,\\bar{\\lambda } & [ 1,1,0]&[1,1,0]\\\\\\noalign{\\medskip}\\lambda\\ ,   \\bar{\\lambda}^{2}&[1,1,0]&[2,2,0]\\\\\\noalign{\\medskip } \\lambda\\ , \\bar{\\lambda}^{3}&[1,1,0]&[3,3,0]\\\\\\noalign{\\medskip } { \\lambda}^{2}&[2,2,0]&[0,0,0]\\\\\\noalign{\\medskip}{\\lambda}^{2}\\bar{\\lambda }   & [ 2,2,0]&[1,1,0]\\\\\\noalign{\\medskip}{\\lambda}^ { 2 }   \\bar{\\lambda}^{2}&[2,2,0 ] & [ 2,2,0]\\\\\\noalign{\\medskip}{\\lambda}^{2 }   \\bar{\\lambda } ^{3}&[2,2,0]&[3,3,0 ] \\\\\\noalign{\\medskip}{\\lambda}^{3}&[3,3,0]&[0,0,0]\\\\\\noalign{\\medskip } { \\lambda}^{3}\\bar{\\lambda } & [ 3,3,0]&[1,1,0 ] \\\\\\noalign{\\medskip}{\\lambda}^{3 }   \\bar{\\lambda}^{2}&[3,3,0]&[2,2,0]\\\\\\noalign{\\medskip } { \\lambda}^{3 }   \\bar { \\lambda } ^{3}&[3,3,0]&[3,3,0]\\end { array } \\right]\\ ] ]    summarising , we will use mainly 3 objects : * vec * , * mat * and * matcol*. +   + a fourth object less commonly used is a polynomial representation of the state .",
    "it is a polynomial in the mode operators that define the state .",
    "a general state would then be : @xmath20 and its description as a * poly * object : @xmath21 ( note that the commutation relations are not taken care of in * poly * objects ) .",
    "* quantavo * contains various procedures that allow problems to be formulated as follows :    1 .",
    "declare the initial state .",
    "2 .   apply different transformations to it ( beam splitter , phase shifter , arbitrary unitary , ... ) .",
    "measure certain modes ( and trace out the inaccessible ones ) , find out probabilities .",
    "4 .   ask different questions about the properties of the state : display , plot , evaluate certain measures of entanglement , etc ..    additionally , the order in which we use these procedures can be changed and the questions in item ( 4 ) can be formulated at any intermediate time .",
    "in addition , more states can be tensored or added at later times .",
    "finally there are procedures to interconvert * mat * , * vec * , * matcol * and * poly*. let us then give a more detailed description of these four basic steps .",
    "there are different ways to declare a state , all depending on its characteristics . +   + * pure states * +   + for pure states of known functional form .",
    "that is , if we have a state of the form : @xmath22and we know explicitly @xmath23 we may use the following structure : +   + declare the number of modes `` @xmath4 '' , the maximum number of photons `` @xmath5 '' , and make a loop to declare the elements .",
    "for example : +   +   + there are now @xmath24 elements to be specified .",
    "+   +   +   + where @xmath25 is the function in eq.([pure ] ) .",
    "we may use the procedure ` deltak`(i , j ) if we need a kronecker delta in our definition . executing",
    "the above loop will declare a matrix * v * of size @xmath26 that has hopefully many zero entries .",
    "to get rid of the zero entries and convert this object into a * vec * object ( or trimmed vector ) we will use the procedure ` trim ` : +   +   +   + another way to proceed is to declare the object * vec * directly with an appropriate function .",
    "consider as an example the state : @xmath27 in this case it is easy to declare the object * vec * directly as : +   +   + however this is not allways the case and if we have a pure state with no known @xmath23 , but we know which non - zero elements it contains , we can declare its elements one by one or declare the * vec * matrix at once .",
    "for example to declare @xmath28 we can use : +   +   +   + or +   +   +   + or +   +   + adding ` statenormalize(v ) ` for normalization .",
    "+   + a special family of pure states are readily available in quantavo : +   + * squeezed vacuum * : + for a truncated , unnormalized , pure single mode squeezed vacuum state @xmath29 type : +   +   +   + for a truncated , unnormalized , pure two mode squeezed vacuum state + @xmath30 type : +   +   +   + these states are given without normalization , since for finite @xmath5 , @xmath31 does nt normalize them .",
    "calculations and displays are easier this way .",
    "+   + * coherent states * : + for a truncated single mode coherent state @xmath32 type : +   +   +   + the analytical normalization is rather lengthy so it is left unnormalized .",
    "normalization can be done at a later time with ` statenormalize ` .",
    "+   + it is also possible to tensor some vacuum modes to our state . the procedure ` tensorvac`(@xmath12 , s ) effectively does the following transformation : @xmath33 when applied either to a * vec * , * mat * or * matcol * ( see appendix for more details )",
    ". +   +   +   + * tensor product * : + the procedure ` tensorproduct`(a , @xmath34 , b , @xmath35 ) will make the tensor product between modes [ @xmath34 ] of state a and modes [ @xmath35 ] of state b. so for example , +   +   + will result in the following * vec * object , @xmath38\\\\\\noalign{\\medskip}\\alpha&[1,1 ] \\\\\\noalign{\\medskip}1/2\\,{\\alpha}^{2}\\sqrt { 2}&[2,1 ] \\\\\\noalign{\\medskip}1/6\\,{\\alpha}^{3}\\sqrt { 6}&[3,1]\\end { array }   \\right]\\ ] ]    * mixed states * + the generalized states ( either pure or mixed ) we are interested in can be written as : @xmath39 where @xmath40 and @xmath41 stand for @xmath42 and @xmath43 respectively .",
    "the density matrix for these states is @xmath44 dimensional which is in general too large for the computer to handle .",
    "we will therefore describe these states using * mat * , * matcol * or * poly*. objects .",
    "+   + two main strategies can be used to declare our states :    1 .",
    "if our starting state is pure and will become mixed later , we can declare a pure * vec * object and then convert it into a * mat * or * matcol * when needed . all procedures to convert are named in the intuitive way : `` ` object2object ` '' . this way to convert * vec * into * mat",
    "* we have the procedure ` vec2mat ` , to convert * mat * into * matcol * , ` mat2matcol ` and so on for all objects and conversions .",
    "therefore , once our pure state vector * v * has been declared we can do the following : +   +   + or +   + 2 .",
    "if our starting state is mixed to begin with , we can declare our initial state as the object * mat * or * matcol*. to do so , if we know the functional form of @xmath45 in eq.([mixed ] ) then we may directly declare our state .",
    "for example to declare the state : @xmath46 we could use : + or + or yet again , meaning @xmath47 \\left [ c.c .",
    "\\right]$ ]    the basic conclusion is that there is no single way of declaring our state and that depending on its structure we have to find a clever way of declaring it . as a general guideline",
    ", small states without an obvious functional structure can be declared giving all elements .",
    "medium sized pure states can be declared using a clever loop , ` trimmed ' and transformed to * vec * , * mat * or * matcol*. +   + it is worth noting that when using the built - in declaration procedures such as ` squeezedvac ` , ` coherentstate ` , ` tensorvac ` , ` vac ` , or the inter - converting ones like ` mat2matcol ` , ` mat2poly ` , ` vec2mat ` , etc , the values of @xmath4 and @xmath5 are automatically updated .",
    "however , if the states are declared from scratch , the values of @xmath4 and @xmath5 should be explicitly declared . applying to our state",
    "@xmath48 the procedure ` findknd`(@xmath48 ) can help troubleshoot by reevaluating the value of these global variables .",
    "* beam splitter * +   + we can apply a beam splitter to a * vec * or * matcol * state * v * with the ` bs ` procedure : +   +    where i , j specify which modes the beam splitter acts on .",
    "it is therefore essential to carefully label the modes of our quantum optical circuit .",
    "this will effectively do the following mode transformation :    @xmath49     +   + leaving ` @xmath50 ' and ` @xmath51 ' as unevaluated variables .",
    "if we want to use different reflectivities and transmittivities for our beam splitter ( variables or numbers ) we may use ` mybs ` and input ` @xmath52 ' and ` @xmath53 ' as follows : +   +   + for the mixed state object * matcol * we may use the same procedures and the effective transformation will be :    @xmath54    further details about its use can be found in the example in section ( [ example ] ) +   + * phase shifter * +   + the phase shifter procedure ( ps ) can be used with mixed and pure states : +   + the input * vec*/*matcol * means that either * vec * or * matcol * objects can be given as inputs .",
    "this procedure makes the effective transformation : @xmath55 +   + * build unitary * +   + if we wish to construct a unitary matrix that transforms the modes of light and describes a given linear optics ( lo ) circuit we may use the procedure ` buildunitary ` .",
    "together with ` unitaryevolution ` it will evolve the state through a given lo circuit . to build a unitary consisting of beam splitters ( bs ) and phase shifters ( ps ) we will do the following : +   +   +   + this will create a matrix * u * of dimension @xmath56 ,",
    "that later will transform the @xmath4 modes .",
    "the list that is ` buildunitary ` s input must have a precise format .",
    "it must be a list of lists .",
    "for example : list:=[[1,2,t , r],[3,phi],[3,4,q ] ] ; + means that first a bs with transmitivity @xmath57 and reflectivity @xmath58 will be applied to modes 1 and 2 , then a ps will be applied to mode 3 and finally a bs with transmitivity @xmath59 and reflectivity @xmath60 will be the last operation .",
    "if we have 4 modes , this will build the matrix @xmath61 +   + in general , in our list of lists , lists with 4 elements , like [ i , j , t , r ] build bs transformations between modes i and j , lists with 3 elements like [ i , j , t ] build bs transformations for modes @xmath62 and @xmath63 such that @xmath64 , and lists with two elements like [ i , @xmath65 build ps transformations on mode i. +   + * unitaryevolution * +   + whether we have just built a unitary matrix with ` buildunitary ` or we have a @xmath56 arbitrary unitary matrix to transform our modes @xmath66 , we can use this procedure as follows : +   +   +   + where u is the unitary matrix of dimension @xmath56 and our state is described by a * vec * or a * matcol * object .",
    "this will effectively implement the mode transformation :    @xmath67 @xmath68      0.55 cm * the * ` project ` * procedure * : +   + if we wish to know the state after a projective measurement we may use the procedure ` project ` . depending on the inputs we give to the procedure it will do a projective measurement and",
    "return a density matrix ( * matcol * ) or state vector ( * vec * ) .",
    "below is a description of its different uses :    1 .",
    "if given ( * vec@xmath69 * , list , * vec@xmath70 * ) and say * vec@xmath69 * and * vec@xmath70 * describe respectively @xmath71 and @xmath72 , ` project`(*vec@xmath69 * , list , * vec@xmath70 * ) returns the * vec * ( in principle unnormalized ) corresponding to the expresion : @xmath73 as an example consider list=[2,3 ] meaning that we want to measure modes two an three .",
    "the * vec * object that corresponds to the projector @xmath74 must therefore have kets with 2 modes .",
    "+   + for example , if @xmath72 is + @xmath75\\ ] ] + and @xmath71 is + @xmath76\\ ] ] + then , +   +   + will return : @xmath77\\ ] ] 2 .",
    "if given ( * matcol 1 * , list , * vec 2 * ) and say * matcol 1 * and * vec 2 * describe @xmath78 and @xmath72 then it will return the * matcol * object : @xmath79 + so for example , taking the same ` v2 ` as above and the kraus operator ( or projector ) : + @xmath80&[1,1]\\\\\\noalign{\\medskip}1&[0,0]&[0 , 0]\\end { array } \\right]\\ ] ] + then , +   +   + will return the state : @xmath81&[0,0,0,0]\\\\\\noalign{\\medskip } \\bar{x }   & [ 0,0,0,0]&[1,1,0,0 ] \\\\\\noalign{\\medskip}x&[1,1,0,0]&[0,0,0,0]\\\\\\noalign{\\medskip}x\\bar { x }   & [ 1,1,0,0]&[1,1,0,0]\\end { array } \\right]\\ ] ] which is the density matrix corresponding to : @xmath82\\\\\\noalign{\\medskip}x&[1,1,0,0 ] \\end { array } \\right]\\ ] ] +   + 3 .",
    "if given ( * vec 1 * , list , * matcol 2 * ) and say * vec 1 * , * matcol 2 * describe @xmath71 and @xmath48 respectively , then it will build @xmath74 and return the * matcol * object corresponding to : @xmath83 +   + 4 .",
    "if given ( * matcol 1 * , list , * matcol 2 * ) and say * matcol 1 * and * matcol 2 * describe @xmath78 and @xmath48 respectively , then it will return : @xmath84    ( see further down for povm measurements ) +   + in a nutshell : +   +    [ cols=\"<,^ , < \" , ]",
    "+ & & +     +   +   +   + ready made states are : @xmath85",
    "-1.8 cm    clc & & + ` linear optics ` : & & ` measurements ` + & & + & & + @xmath86)\\\\   \\texttt{unitaryevolution}(u,\\mathbf{vec}/\\mathbf{matcol})\\\\ \\end{array}$ ] & & @xmath87 , \\mathbf{vec}/\\mathbf{matcol } ) \\\\ \\texttt{probability}(\\mathbf{vec}/\\mathbf{matcol } , [ list ] \\mathbf{vec}/\\mathbf{matcol})\\\\ \\texttt{traceout}(\\mathbf{mat}/\\mathbf{matcol } , \\mathrm{i})\\\\ \\texttt{povmresult}(\\mathbf{matcol},[list ] , \\mathbf{vec}/\\mathbf{matcol})\\\\ \\texttt{apd}\\left(\\{0,1\\ } , r , d+1 \\right)\\\\ \\end{array}$ ] + & & +   +   + & & + ` display ` & & ` algebraic operations ` + & & + & & + @xmath88 & & @xmath89 + & & +     +   + & & + ` state properties : ` & & ` entanglement & energy ` + & & + & & + @xmath90 & & @xmath91 + & & +     +   +   +   +    a     +   +    ` apd`(*0/1,r , n * )    : + 0.5 cm [ input : ( @xmath92 , r @xmath93 $ ] , positive integer ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    b     +   +    ` bs`(*vec / matcol , @xmath62 , @xmath63 * )    : + 0.5 cm [ input : ( matrix , integer , integer ) , output : matrix , calls : quantavo , linearalgebra , poly2matcol , matcol2poly , matcolbs , vecbs ]     +   +    ` buildunitary`(*list of lists * )    : + 0.5 cm [ input : list , output : matrix , calls : quantavo , linearalgebra ]     +   +    c     +   +    ` coherentstate`(*m , d,@xmath94 * )    : + 0.5 cm [ input : ( whole number , whole number ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    d     +   +    ` dp`(*matrix , matrix * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` deltak`(*i , j * )    : + 0.5 cm [ input : ( string or number , string or number ) , output : 0,1 , unevaluated string , calls : quantavo ]     +   +    ` dbra`(*list * )    : + 0.5 cm [ input : list , output : @xmath95 string@xmath17 , calls : quantavo ]    .",
    "+   +    ` dbraket`(*list , list * )    : + 0.5 cm [ input : ( list , list ) , output : @xmath17string@xmath18 string@xmath17 , calls : quantavo ]     +   +    ` dket`(*list * )    : + 0.5 cm [ input : list , output : @xmath17 string@xmath96 , calls : quantavo ]     +   +    ` dstate`(*vec / mat / matcol * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    e     +   +    ` energy`(*vec / matcol * )    : + 0.5 cm [ input : matrix , output : number or analytic expression , calls : quantavo , linearalgebra ]     +   +    ` entropy`(*vec / matcol * )    : + 0.5 cm [ input : matrix , output : number or analytic expression , calls : quantavo , linearalgebra ]     +   +    ` evalstate`(*vec / matcol * )    : + 0.5 cm [ input : matrix , output : number or analytic expression , calls : quantavo , linearalgebra ]     +   +    f     +   +    ` findknd`(*vec / matcol / mat * )    : + 0.5 cm [ input : matrix , output : ( k , d ) , calls : quantavo , linearalgebra ]    findknd +   +    i     +   +    ` identitystate`(*nr of photons , nr of modes * )    : + 0.5 cm [ input : ( integer , integer ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` indexstate`(*vec / matcol * )    : + 0.5 cm [ input : 3 column matrix , output : 3 column matrix , calls : quantavo , linearalgebra ]     +   +    ` ishermitian`(*matcol / mat * )    : + 0.5 cm [ input : matrix , output : 0 or 1 and printed answer , calls : quantavo , linearalgebra ]     +   +    ` isnormalized`(*vec / matcol / mat * )    : + 0.5 cm [ input : matrix , output : printed answer , calls : quantavo , linearalgebra ]",
    "+   +    l     +   +    ` lognegativity`(*vec / matcol / mat * )    : + 0.5 cm [ input : matrix , output : expression or number , calls : quantavo , negativity ]     +   +    m     +   +    ` matcol2mat`(*matcol * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra , statesort ]     +   +    ` matcol2poly`(*matcol * )    : + 0.5 cm [ input : matrix , output : polynomial , calls : quantavo , linearalgebra ]     +   +    ` mat2matcol`(*mat * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra , trim ]     +   +    ` mat2poly`(*mat * )    : + 0.5 cm [ input : matrix , output : polynomial , calls : quantavo , linearalgebra ]     +   +    ` modesmatcol`(*matcol with numbers * )    : + 0.5 cm [ input : 3 column matrix , output : 3 column matrix , calls : quantavo , linearalgebra ]     +   +    ` mybs`(*matcol / vec , @xmath62 , @xmath63 , t , r * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra , poly2matcol , matcol2poly , mymatcolbs , myvecbs ]     +   +    n     +   +    ` negativity`(*vec / matcol / mat * )    : + 0.5 cm [ input : matrix , output : expression or number , calls : quantavo , linearalgebra , statepartialtranspose ]     +   +    p     +   +   +    ` plotstate`(*vec / matcol / mat , w , h * )    : + 0.5 cm [ input : ( matrix , width , height ) , output :  , calls : plots , geom3d , quantavo , linearalgebra ]     +   +   +    ` poly2matcol`(*poly * )    : + 0.5 cm [ input : polynomial , output : matrix , calls : quantavo , linearalgebra ]     +   +   +    ` poly2vec`(*poly * )    : + 0.5 cm [ input : polynomial , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` povmresult`(*matcol , list , vec / matcol * )    : + 0.5 cm [ input : matrix , list , matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` probability`(*vec / matcol , list , vec / matcol * )    : + 0.5 cm [ input : ( matrix , list , matrix ) , output : expression or number , calls : quantavo , linearalgebra , statetrace , statenormalize , vec2matcol ]     +   +    ` project`(*vec / matcol , list , vec / matcol * )    : + 0.5 cm [ input : ( matrix , list matrix ) , output : matrix , calls : quantavo , statecomplexconjugate , linearalgebra , vec2matcol ]     +   +    ` ps`(*vec / matcol , j , @xmath97 * )    : + 0.5 cm [ input : ( matrix , whole number , symbol or number ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    s     +   +    ` squeezedvac`(*m , d,@xmath98 * )    : + 0.5 cm [ input : ( whole number , whole number , string or number ) , output : 2 column matrix , calls : quantavo , linearalgebra ]     +   +    ` stateapprox`(*vec / matcol , list , n * )    : + 0.5 cm [ input : ( matrix , list , integer ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` statecomplexconjugate`(*matcol / mat * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` statemultiply`(*number / matcol , matcol / vec * )    : + 0.5 cm [ input : ( string / matrix , matrix ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` statesort`(*vec / matcol * )    : + 0.5 cm [ input : matrix , output : matrix , calls : quantavo , linearalgebra , tribullesmatcol , tribullesvec ]     +   +    ` statetrace`(*mat / matcol * )    : + 0.5 cm [ input : matrix , output : real number or symbolic expression , calls : quantavo , linearalgebra ]     +   +    ` statenorm`(*vec * )    : + 0.5 cm [ input : matrix , output : number or expression , calls : quantavo , linearalgebra ]     +   +    ` statenormalize`(*vec / matcol / mat * )    : + 0.5 cm [ input : matrix , output : matrix and printed answer , calls : quantavo , linearalgebra , isnormalized , littletrace ]     +   +    ` statepartialtranspose`(*vec / matcol / mat , s * )    : + 0.5 cm [ input : ( matrix , 1 or 2 ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    t     +   +    ` tensorproduct`(*vec / matcol , list , vec / matcol , list * )    : + 0.5 cm [ input : matrix , list , matrix , list , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` tensorvac`(*vec / matcol / mat , m * )    : + 0.5 cm [ input : ( matrix , whole number ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` traceout`(*matcol , i * )    : + 0.5 cm [ input : ( matrix , whole number ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` trim`(*vector / vec / matcol * )    : + 0.5 cm [ input : vector / matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    u     +   +    ` unitaryevolution`(*unitary matrix , vec / matcol * )    : + 0.5 cm [ input : ( matrix , matrix ) , output : matrix , calls : quantavo , linearalgebra ]     +   +    v     +   +    ` vac`(*nr . of modes * )    : + 0.5 cm [ input : positive natural number , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` vec2mat`(*vec * )    : + 0.5 cm [ input : 2 column matrix , output : matrix , calls : quantavo , linearalgebra ]     +   +    ` vec2matcol`(*vec * )    : + 0.5 cm [ input : 2 column matrix , output : 3 column matrix , calls : quantavo , linearalgebra ]     +   +    ` vec2poly`(*vec * )    : + 0.5 cm [ input : 2 column matrix , output : polynomial , calls : linearalgebra , quantavo ]     +   +    ` vectormodes`(*i * )    : + 0.5 cm [ input : integer , output : list , calls : quantavo ]     +   +    ` vectorrow`(*indi , d * )    : + 0.5 cm [ input : ( list , d ) , output : whole number , calls : quantavo ]     +   + quantavo also uses the local procedures : +   + multiplymatcol , multiplymatcolvec , tribullesmatcol , tribullesvec , vectormodes , vectorrow , indexvec , modesvec , vecbs , myvecbs , matcolbs , mymatcolbs , projectvecvec , projectmatcol , dvec , dmat , dmatcol , barra , histo ;",
    "copyright ( c ) 2008 alvaro feito boirac .",
    "+   + this is the module quantavo , a toolbox for quantum optics calculations that can be used in maple@xmath0 ( waterloo maple inc . ) +   + it is released under the gnu general public license v3 which can be obtained at http://www.gnu.org/licenses/gpl.html . please acknowledge its use if used to establish results for a published work .",
    "if you make any improvements or find any bugs the author will be thankful if you can let him know .",
    "+ * disclaimer * : this module is distributed in the hope that it will be useful , but without any warranty , without even the implied warranty of merchantability or fitness for a particular purpose .",
    "+   + the author can be contacted at ab1805@imperial.ac.uk"
  ],
  "abstract_text": [
    "<S> this manual describes the basic objectives , functionalities and uses of the toolbox for _ maple _ ( maplesoft@xmath0 ) called . </S>",
    "<S> it is intended to facilitate calculations both symbolically and numerically related to quantum optics . in particular the evolution , measurement and entanglement properties of quantum states in the fock basis can be simulated with it . </S>",
    "<S> it is provided to the community as a free open source module .    </S>"
  ]
}