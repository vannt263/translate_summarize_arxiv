{
  "article_text": [
    "polyhedra have been widely applied in program analysis @xcite particularly for reasoning about logic and constraint logic programs . in this context polyhedra",
    "have been used in binding - time analysis @xcite , cdr - coded list analysis @xcite , argument - size analysis @xcite , time - complexity analysis @xcite , high - precision groundness analysis @xcite , type analysis @xcite , termination checking @xcite and termination inference @xcite .",
    "all these techniques use polyhedra to describe relevant properties of the program and manipulate polyhedra using operations that include projection , emptiness checking , inclusion testing for polyhedra , intersection of polyhedra ( meet ) and the convex hull ( join ) . the classic approach to polyhedral analysis @xcite uses two representations : ( i ) frames and rays and ( ii ) systems of ( non - strict ) linear inequalities and employs the chernikova algorithm to convert between them @xcite .",
    "the rationale for this dual representation is that the convex hull can be computed straightforwardly with frames and rays whereas intersection is more simply computed over systems of linear inequalities .",
    "a simpler tactic that has been widely adopted in the analysis of logic programs is to use only the linear inequality representation and compute the convex hull by adapting @xcite a relaxation technique proposed in @xcite .",
    "the elegance of this approach is that it enables the convex hull to be computed without recourse to a dual representation : the problem is recast as a projection problem that can be subcontracted to standard linear constraint solving machinery with minimal coding effort .",
    "moreover , the performance is acceptable for many applications .",
    "in fact this technique has been widely applied in the analysis of logic programs @xcite .",
    "the next section outlines the method and the following section , an example implementation .",
    "the final section presents the concluding discussion .",
    "consider two arbitrary polyhedra , @xmath0 and @xmath1 , represented in standard form : @xmath2 such that @xmath3 and @xmath4 so that the problem is non - trivial .",
    "note that @xmath5 are non - strict and therefore @xmath6 and @xmath7 are both closed .",
    "the problem in essence is to compute the smallest polyhedron that includes @xmath0 and @xmath1 .",
    "interestingly , the convex hull of @xmath8 is not necessarily closed as is illustrated in the following example .",
    "[ example - closure ] consider the 2-dimensional polyhedra @xmath6 and @xmath7 defined by :    @xmath9 \\right . \\ ! \\vec{x } \\leq \\left [ \\begin{array}{@{}r@ { } } 0 \\\\ 0 \\\\ 1 \\\\ -1 \\\\ \\end{array } \\right ] \\right\\ } \\quad p_2 = \\left\\ { \\vec{x } \\in \\real^2 \\left| \\left [ \\begin{array}{@{}rr@ { } } 1 & -1 \\\\ -1 & 1 \\\\ -1 & 0 \\\\ \\end{array } \\right ] \\right . \\ ! \\vec{x } \\leq \\left [ \\begin{array}{@{}r@ { } } 0 \\\\ 0 \\\\ 0 \\\\ \\end{array } \\right ] \\right\\}\\ ] ]    observe that @xmath10 is a point whereas @xmath11 is a half - line .",
    "note too that @xmath6 and @xmath7 are closed whereas the convex hull of @xmath8 excludes the points @xmath12 and hence is not closed ( see the diagram below ) .",
    "c@c@c    ( 6,5.25)(-1,-1.25 )    ( 0,0)(1,0)4 ( 0,0.125)(1,0)4(0,-1).25    ( 0,0)(0,1)4 ( -0.125,0)(0,1)4(1,0).25    ( 0,-.25)(0,0)[t]0 ( 1,-.25)(0,0)[t]1 ( 2,-.25)(0,0)[t]2 ( 3,-.25)(0,0)[t]3 ( 4,-.25)(0,0)[t]@xmath13    ( -.25,0)(0,0)[r]0 ( -.25,1)(0,0)[r]1 ( -.25,2)(0,0)[r]2 ( -.25,3)(0,0)[r]3 ( -.25,4)(0,0)[r]@xmath14    ( 0 , 1 )    ( 0,-0.03)(1,1)4 ( 0,0.0)(1,1)4 ( 0,0.03)(1,1)4    ( 2,-1)(0,0)[t]@xmath6 and @xmath7    &    ( 4,5.25)(0,-1.25 )    ( 0,0)(1,0)4 ( 0,0.125)(1,0)4(0,-1).25    ( 0,0)(0,1)4 ( -0.125,0)(0,1)4(1,0).25    ( 0,-.25)(0,0)[t]0 ( 1,-.25)(0,0)[t]1 ( 2,-.25)(0,0)[t]2 ( 3,-.25)(0,0)[t]3 ( 4,-.25)(0,0)[t]@xmath13    ( -.25,0)(0,0)[r]0 ( -.25,1)(0,0)[r]1 ( -.25,2)(0,0)[r]2 ( -.25,3)(0,0)[r]3 ( -.25,4)(0,0)[r]@xmath14    ( 0 , 1 )    ( 0,-0.03)(1,1)3.5 ( 0,0.00)(1,1)3.5 ( 0,0.03)(1,1)3.5    ( 0.00,0.0)(0,1)1 ( -0.03,0.0)(0,1)1 ( 0.03,0.0)(0,1)1    ( 0,0)(0.1,0.1)35(0,1)1    ( 2,-1)(0,0)[t]convex hull of @xmath8    &    ( 10,5.25)(-4,-1.25 )    ( 0,0)(1,0)4 ( 0,0.125)(1,0)4(0,-1).25    ( 0,0)(0,1)4 ( -0.125,0)(0,1)4(1,0).25    ( 0,-.25)(0,0)[t]0 ( 1,-.25)(0,0)[t]1 ( 2,-.25)(0,0)[t]2 ( 3,-.25)(0,0)[t]3 ( 4,-.25)(0,0)[t]@xmath13    ( -.25,0)(0,0)[r]0 ( -.25,1)(0,0)[r]1 ( -.25,2)(0,0)[r]2 ( -.25,3)(0,0)[r]3 ( -.25,4)(0,0)[r]@xmath14    ( 0,0.97)(1,1)3.5 ( 0,-0.03)(1,1)3.5 ( -0.03,0.0)(0,1)1    ( 0.0,1.00)(1,1)3.5 ( 0.0,0.00)(1,1)3.5 ( 0.00,0.0)(0,1)1    ( 0.0,1.03)(1,1)3.5 ( 0.0,0.03)(1,1)3.5 ( 0.03,0.0)(0,1)1    ( 0,0)(0.1,0.1)35(0,1)1    ( 2,-1)(0,0)[t]closure of convex hull of @xmath8    since the convex hull of @xmath8 is not necessarily closed , the convex hull can not always be represented by a system of non - strict linear inequalities ; in order to overcome this problem , the closure of the convex hull of @xmath8 is computed . the starting point for our construction is the convex hull of @xmath15 that is given by : @xmath16    to avoid the non - linearity @xmath17 the system can be reformulated ( relaxed ) by putting @xmath18 and @xmath19 so that @xmath20 and @xmath21 to define :    @xmath22 observe that @xmath23 . moreover , unlike @xmath24 , @xmath25 is expressed in terms of a system of linear inequalities .",
    "note too that @xmath25 is closed since the projection of a system of non - strict linear inequalities is closed .",
    "in fact the following proposition asserts that @xmath25 coincides with the closure of the convex hull of @xmath8 .",
    "[ prop ] @xmath25 is the closure of the convex hull of @xmath6 and @xmath7 .",
    "the proof uses the concept of a recession cone .",
    "the recession cone of a polyhedron @xmath26 , denoted @xmath27 , is defined by : @xmath28 .",
    "the intuition is that @xmath29 includes a vector @xmath30 whenever @xmath26 includes all the half - lines in the direction of @xmath30 that start in @xmath26 .",
    "suppose @xmath31 theorem 19.6 of @xcite states that the closure of the convex hull of @xmath8 is the set @xmath32 intuitively , @xmath33 is @xmath7 extended in the directions of half - lines contained within @xmath6 .",
    "let @xmath34 , then @xmath35 if and only if @xmath36 for all @xmath37 which holds if and only if @xmath38 @xcite[pp 62 ] . therefore @xmath39 and similarly @xmath40 furthermore ,",
    "@xmath41 = @xmath42 @xmath43 observe that @xmath44 coincides with the sets ( i ) @xmath33 , ( ii ) @xmath45 and ( iii ) @xmath41 when ( i ) @xmath46 and @xmath47 , ( ii ) @xmath48 and @xmath49 and ( iii ) @xmath50 and @xmath51 respectively .",
    "therefore @xmath25 is the closure of the convex hull .",
    "this result leads to an algorithm for computing the closure of the convex hull : construct the systems @xmath21 by scaling the constant vectors @xmath52 by @xmath53 , add the constraints @xmath20 , @xmath54 and @xmath55 , then eliminate variables other than @xmath56 using projection to obtain @xmath25 in terms of @xmath56 .",
    "hence the closure of the convex hull can be computed without recourse to another representation .",
    "this is illustrated below .",
    "[ abstract - example ] returning to example  [ example - closure ] , consider the systems @xmath5 :    @xmath57    adding @xmath58 @xmath54 and @xmath55 leads to the following system : @xmath59 eliminating the variables @xmath60 and @xmath53 leads to the solution : @xmath61 theorem 19.6 of @xcite , which is used in the proof , asserts that @xmath25 includes @xmath62 and therefore includes the points @xmath63 , and hence ensures closure .",
    "note that calculating @xmath25 without the inequalities @xmath64 and @xmath65  the relaxation advocated in @xcite for computing convex hull  gives @xmath66 which is incorrect .",
    "this section shows how closure of the convex hull can be implemented elegantly using a linear solver in particular the clp(@xmath67 ) library @xcite .",
    "the behaviour of a predicate is described with the aid of modes , that is , + indicates an argument that should be instantiated to a non - variable term when the predicate is called ; - indicates an argument that should be uninstantiated ; and ? indicates an argument that may or may not be instantiated @xcite .",
    "closed polyhedra will be represented by lists ( conjunctions ) of linear constraints of the form @xmath68 @xmath68 where expressions take the form @xmath68",
    "@xmath69 @xmath68 @xmath68 @xmath68 @xmath68 and @xmath69 is a rational number and @xmath13 is a variable .",
    "a convenient representation for a closed polyhedron is a ( non - ground ) list of constraints .",
    "this representation is interpreted with respect to a totally ordered ( finite ) set of variables .",
    "the ordering governs the mapping of each variable to its specific dimension . in practise ,",
    "the ordering on variables is itself represented by the position of each variable within a list .",
    "specifically , if @xmath70 is a list of linear constraints @xmath71 $ ] and @xmath72 is a list of variables @xmath73 $ ] , then the represented polyhedron is @xmath74 . note that although the order of variables in @xmath72 is significant , the order of the constraints in @xmath70 is not .",
    "finally , let @xmath75 denote the set of variables occurring in the syntactic object @xmath76 .",
    "[ ex : p1p2 ] the polyhedron @xmath6 from example [ abstract - example ] can be represented by the lists @xmath77 , @xmath78 $ ] and @xmath79 $ ] , that is , @xmath80 .",
    "moreover , @xmath81 where @xmath82 , @xmath83 $ ] or alternatively @xmath84 $ ] .",
    "hence the dimension of @xmath85 is defined by the length of the list @xmath72 rather than the number of variables in @xmath70 .",
    "projection is central to computing the convex hull .",
    "the desire , therefore , is to construct a predicate project(+xs,+cxs ,-",
    "projectcxs ) that is true when for a given list of dimensions xs and a given list of constraints cxs , projectcxs is the projection of cxs onto xs .",
    "the specification of such a predicate is given below .",
    "preconditions : : :    * ` xs ` is a closed list with distinct variables as elements ,    * ` cxs ` is a closed list of linear constraints ,    * ` cxs ` is satisfiable .",
    "postconditions : : :    * ` xs ` is a closed list with distinct variables as elements ,    * ` projectcxs ` is a closed list of linear constraints ,    * @xmath86 ,    * @xmath87 .",
    "such a predicate can be constructed by adding the given constraints to the store and then invoking the projection facility provided in the clp(@xmath67 ) library , that is , the predicate dump(+target , -newvars , -codedanswer ) @xcite . quoting from the manual : `` [ dump ] reflects the constraints on the target variables into a term , where target and newvars are lists of variables of equal length and codedanswer is the term representation of the projection of constraints onto the target variables where the target variables are replaced by the corresponding variables from newvars '' .",
    "this leads to the following implementation of project :    ....      : - use_module(library(clpq ) ) .",
    "project(xs , cxs , projectcxs ) : -          tell_cs(cxs ) ,          dump(xs , vs , projectcxs ) , xs = vs.        tell_cs ( [ ] ) .      tell_cs([c|cs ] ) : - { c } , tell_cs(cs ) . ....    for example , the query ` project([x , z ] , [ x < y , y < z ] , projectcs ) ` will correctly bind ` cs ` to ` [ x - z<0 ] ` .",
    "however , correctness of this predicate is compromised by existing constraints in the store .",
    "for instance , the compound query ` { x = z + 1 } , project([x , z ] , [ x < y , y < z ] , projectcs ) ` will fail because constraints posted within tell_cs interact with those already in the store .    to insulate the constraints posted in tell_cs , both the variables xs and the constraints cxs need to be renamed . renaming is trivial with the builtin ` copy_term ` but care must be taken to ensure that xs and cxs are renamed consistently , that is that variable sharing in xs and cxs is preserved in the copies . however , in sicstus prolog copy_term(term , cpy ) copies any constraints in the store that involve variables in term .",
    "for example , the query \\{x = y } , copy_term(x = y+1 , cpy ) will bind cpy to _",
    "a=_b+1 where _ a and _ b are fresh variables .",
    "it will also copy the constraint x = y by posting the new constraint _",
    "a = _ b to the store . to nullify this effect ,",
    "copy_term is called within the scope of call_residue .",
    "the call call_residue(copy_term(x = y+1 , cpy ) , residue ) residuates any new constraint into residue instead of posting it to the store , thereby copying the term without copying any constraint . whether residuation is required depends on the particular prolog system",
    "this leads to the following ( sicstus prolog specific ) revision :    ....      project(xs , cxs , projectcxs ) : -          call_residue(copy_term(xs - cxs , cpyxs - cpycxs ) , _ ) ,          tell_cs(cpycxs ) ,          dump(cpyxs , vs , projectcxs ) , xs = vs. ....    using this revision , the query ` { x = z + 1 } , project([x , z ] , [ x < y , y < z ] , projectcs ) ` will succeed binding projectcs to .",
    "however , adding z = 5 to the list of constraints induces an error .",
    "the problem is that posting the constraints binds ` z ` to 5 so that ` dump ` is called with its first argument instantiated to a list that contains a non - variable term .",
    "a pre - processing predicate prepare_dump is therefore introduced to ensure that dump is called correctly .",
    "the following revision to ` project ` , in effect , extends the facility provided by dump to capture constraints over both uninstantiated and instantiated variables :    ....      project(xs , cxs , projectcxs ) : -          call_residue(copy_term(xs - cxs , cpyxs - cpycxs ) , _ ) ,          tell_cs(cpycxs ) ,          prepare_dump(cpyxs , xs , zs , dumpcxs , projectcxs ) ,          dump(zs , vs , dumpcxs ) , xs = vs.        prepare_dump ( [ ] , [ ] , [ ] , cs , cs )",
    ".      prepare_dump([x|xs ] , ysin , zsout , csin , csout ) : -          ( ground(x ) - >              ysin   = [ y|ys ] ,              zsout = [ _ |zs ] ,              csout = [ y = x|cs ]          ;              ysin   = [ _ |ys ] ,              zsout = [ x|zs ] ,              csout = cs          ) ,          prepare_dump(xs , ys , zs , csin , cs ) . ....    the literal ` prepare_dump(+xs , + ys , -zs , ?",
    "csin , -csout ) ` is true for a given list xs which contains either variables or numbers ( or a mixture of the two ) and a given list ys which contains only variables , if    * zs is the list obtained by substituting the non - variable terms of xs with fresh variables and * csout is an open ended list of equality constraints with csin at its end that contains one equality constraint for each number in xs .",
    "each constraint equates a numeric element of xs with the element of ys that is in the same list position .",
    "the call ` prepare_dump([x1 , 1 , x3 , 2 ] , [ a , b , c , d ] , zs , csin , csout ) ` , for instance , will bind ` zs ` to and ` csout ` to .",
    "the predicate ensures that dump is called with its first argument bound to a list of free variables even when the list xs includes numbers . in the clp(@xmath88 )",
    "library , numbers coincide with rationals which are represented as compound ( ground ) terms of the form rat(@xmath69 , @xmath89 ) where @xmath69 and @xmath89 are integers .",
    "the ground(x ) test effectively checks whether x is instantiated to a number ; the test number(x ) is inappropriate since it would always fail .",
    "consider again example [ ex : p1p2 ] .",
    "the second representation of @xmath7 can be simplified by using projection as follows :    ....    projectcs = [ y>=0,x = y ] ? ; no ....    the system ` cs ` is expressed over 3 variables and therefore defines a 3 dimensional space .",
    "intuitively , the projection onto is the shadow cast by @xmath90}}}}$ ] onto the 2 dimensional space over x and y. the projection projectcs in fact defines a half - line confined to the first quadrant since , by rearranging cs , it follows that @xmath90 } } } } = \\ { \\langle x , y , z \\rangle \\in",
    "\\real^3 \\mid x = y \\wedge 0 \\leq y \\wedge z=0 \\}$ ] .      the specification for the main predicate ` convex_hull(+xs , + cxs , + ys",
    ", + cys , -zs , -czs ) ` , and then its code , is given below .",
    "preconditions : : :    * ` xs ` is a closed list with distinct variables as elements and    likewise for ` ys ` ,    * ` xs ` and ` ys ` have the same length ,    * @xmath91 ,    * ` cxs ` and ` cys ` are closed lists of linear constraints ,    * ` cxs ` and ` cys ` are both satisfiable ,    * @xmath92 and    @xmath93 .",
    "postconditions : : :    * ` xs ` , ` ys ` and ` zs ` are closed lists with distinct variables as    elements ,    * ` zs ` is the same length as both ` xs ` and ` ys ` ,    * ` czs ` is a closed list of linear constraints ,    * @xmath94 and    @xmath95 ,    * @xmath96 is the closure of    the convex hull of    @xmath97 .    ....",
    "convex_hull(xs , cxs , ys , cys , zs , czs ) : -          scale(cxs , sig1 , [ ] , c1s ) ,          scale(cys , sig2 , c1s , c2s ) ,          add_vect(xs , ys , zs , c2s , c3s ) ,          project(zs , [ sig1 > = 0 , sig2 > = 0 , sig1+sig2 = 1|c3s ] , czs ) .",
    "scale ( [ ] , _ , cs , cs ) .",
    "scale([c1|c1s ] , sig , c2s , c3s ) : -          c1 = .. [ relop , a1 , b1 ] ,          c2 = .. [ relop , a2 , b2 ] ,          mul_exp(a1 , sig , a2 ) ,          mul_exp(b1 , sig , b2 ) ,          scale(c1s , sig , [ c2|c2s ] , c3s ) .",
    "mul_exp(e1 , sigma , e2 ) : - once(mulexp(e1 , sigma , e2 ) ) .",
    "mulexp (   x ,    _ ,      x ) : - var(x ) .",
    "mulexp(n*x ,    _ ,    n*x ) : - ground(n ) , var(x ) .",
    "mulexp ( -x , sig ,     -y ) : - mulexp(x , sig , y ) .",
    "mulexp(a+b , sig ,    c+d ) : - mulexp(a , sig , c ) , mulexp(b , sig , d ) .",
    "mulexp(a - b , sig ,    c - d ) : - mulexp(a , sig , c ) , mulexp(b , sig , d ) .",
    "mulexp (   n , sig , n*sig ) : - ground(n ) .",
    "add_vect ( [ ] , [ ] , [ ] , cs , cs ) .",
    "add_vect([u|us ] , [ v|vs ] , [ w|ws ] , c1s , c2s ) : -          add_vect(us , vs , ws , [ w = u+v|c1s ] , c2s ) .",
    "....    the predicate mulexp(?e1 , ?",
    "sigma , -e2 ) scales the numeric constants that occur within e1 by the variable sigma , providing they are not coefficients of variables , to obtain the expression e2 .",
    "note that sigma is a variable and the expression e1 may be a variable , hence both e1 and sigma have mode ? rather than + .",
    "since a non - ground representation is employed for expressions , the test var(x ) is used to determine whether the expression is a variable .",
    "as before , the test ground(n ) detects numeric constants  rational numbers  which are the only type of subexpressions that are ground .",
    "observe that mulexp can return more than one solution , for example , mulexp(x , sig , e2 ) generates ; ; , etc as solutions .",
    "thus the pruning operator once is applied within mul_exp(?e1 , ?",
    "sigma , -e2 ) to prevent erroneous solutions .",
    "the predicate scale(+c1s , ?",
    "c2s , -c3s ) scales each constraint within the list c1s by the variable sigma .",
    "each constraint consists of a binary operator and two expressions , and scaling is applied to the numeric constants in each expression as specified by mul_exp .",
    "for example , scale([x+2 > = 1+y , y = z ] , sigma , tail , scaledcs ) binds scaledcs to .",
    "note that ` scale ` finesses the problem of putting ` cxs ` and ` cys ` into the standard form before applying scaling .",
    "in standard form , is but scaling constants on both sides of the relational operator preserves equivalence in that is equivalent to .",
    "the use of a difference list avoids an unnecessary call to append in the body of convex_hull .",
    "the predicate add_vect(+us , + vs , -ws , ?",
    "c1s , -c2s ) operates on the lists us = [ u@xmath98 , @xmath99 , u@xmath100 and vs = [ v@xmath98 , @xmath99 , v@xmath100 which correspond to the vectors @xmath101 and @xmath102 ( as introduced in section  [ sect - method ] ) .",
    "the argument ws is instantiated to another list of variables , which corresponds with @xmath56 .",
    "the predicate creates the system of equalities corresponding to the system @xmath103 .",
    "the scaled constraints output by the two calls to scale are passed to add_vect via its accumulator and thereby combined with the system of equalities .",
    "for example , the call add_vect([x1,y1 ] , [ x2 , y2 ] , ws , tail , cs ) returns the bindings cs = [ _ a = y1+y2,_b = x1+x2|tail ] and ws = [ _ b,_a ] .",
    "the predicate convex_hull(xs , cxs , ys , cys , zs , czs ) takes , as input , two lists of constraints ( cxs and cys ) and their corresponding lists of variables ( xs and ys ) and produces as output a single list of constraints czs over the variables zs that represents the closure of the convex hull of the two input polyhedra . if xs and ys are not variable disjoint , then the pre - requisite can be satisfied by appropriately renaming variables . specifically , the variables xs and constraints cxs can be renamed with copy_term(xs - cxs , cpyxs - cpycxs ) and the call convex_hull(xs , cxs , ys , cys , zs , czs ) replaced with convex_hull(cpyxs , cpycxs , ys , cys , zs , czs ) .",
    "since the integrity of the constraint store is preserved by project and since project is the only source of interaction with the store , then it follows that ` convex_hull ` also does not side - effect any existing constraints .",
    "the following is an illustrative example .",
    "running this code on the data of example [ abstract - example ] gives :    ....    s = [ _ a>=0,_a-_b>=-1,_a-_b=<0 ] , v = [ _ a,_b ] ? ; no ....    c@c    ( 12,12)(-6,-6 ) ( -1,-1)(0,0)[t]@xmath6 ( 1,1)(0,0)[b]@xmath7    ( -6,0)(1,0)12 ( -6,-0.125)(2,0)6(0,1).25 ( -4,-0.25)(0,0)[t]-1 ( 4,-0.25)(0,0)[t]1 ( 6,-0.25)(0,0)[t]@xmath13    ( 0,-6)(0,1)12 ( -0.125,-6)(0,2)6(1,0).25 ( -.25,-4)(0,0)[r]-1 ( -.25,4)(0,0)[r]1 ( -.25,6)(0,0)[r]@xmath14    ( 0,4)(1,-1)4 ( 0,-4)(-1,1)4    ( -4,0)(1,0)8 ( 0,4)(0,-1)8    &    ( 12,12)(-6,-6 )    ( -1,-1)(0,0)[t]@xmath104 ( 1,1)(0,0)[b]@xmath105    ( -6,-3)(2,1)12 ( -6,-2.875)(2,1)6(0,-1).25 ( -4,-2.25)(0,0)[t]-1 ( 4,1.75)(0,0)[t]1 ( 6,2.75)(0,0)[t]@xmath13    ( 0,-6)(0,1)12 ( -0.125,-6)(0,2)6(1,0).25 ( -.25,-4)(0,0)[r]-1 ( -.25,4)(0,0)[r]1 ( -.25,6)(0,0)[r]@xmath14    ( -6,3)(2,-1)12 ( -6,2.875)(2,-1)6(0,1).25 ( -4,1.75)(0,0)[t]-1 ( 4,-2.25)(0,0)[t]1 ( 6,-3.25)(0,0)[t]@xmath106    ( 0,4)(2,-1)4    ( 0,4)(2,-3)4    ( 0,-4)(-2,1)4    ( -4,2)(0,-1)4 ( 4,2)(0,-1)4    ( 0,0)(0,1)4 ( 0,0)(2,-1)4 ( 0,0)(-2,1)4 ( 0,0)(0,-1)4    ( 0,0)(-2,-1)4    ( 0,0)(0.2,0.1)20    ( -4,2)(0.1,-0.15)40     +    ( 12,12)(-6,-6 )    ( -6,0)(1,0)12 ( -6,-0.125)(2,0)6(0,1).25 ( -4,-0.25)(0,0)[t]-1 ( 4,-0.25)(0,0)[t]1 ( 6,-0.25)(0,0)[t]@xmath13    ( 0,-6)(0,1)12 ( -0.125,-6)(0,2)6(1,0).25 ( -.25,-4)(0,0)[r]-1 ( -.25,4)(0,0)[r]1 ( -.25,6)(0,0)[r]@xmath14    ( 0,4)(1,-1)4 ( 0,4)(-1,-1)4 ( 0,-4)(1,1)4 ( 0,-4)(-1,1)4    &    ( 12,12)(-6,-6 )    ( -6,-3)(2,1)12 ( -6,-2.875)(2,1)6(0,-1).25 ( -4,-2.25)(0,0)[t]-1 ( 4,1.75)(0,0)[t]1 ( 6,2.75)(0,0)[t]@xmath13    ( 0,-6)(0,1)12 ( -0.125,-6)(0,2)6(1,0).25 ( -.25,-4)(0,0)[r]-1 ( -.25,4)(0,0)[r]1 ( -.25,6)(0,0)[r]@xmath14    ( -6,3)(2,-1)12 ( -6,2.875)(2,-1)6(0,1).25 ( -4,1.75)(0,0)[t]-1 ( 4,-2.25)(0,0)[t]1 ( 6,-3.25)(0,0)[t]@xmath106    ( 0,4)(2,-1)4 ( 0,4)(-2,-1)4    ( 0,4)(2,-3)4 ( 0,4)(-2,-3)4    ( 0,-4)(2,1)4 ( 0,-4)(-2,1)4    ( -4,2)(0,-1)4 ( 4,2)(0,-1)4    ( -4,-2)(1,0)8    ( -4,2)(0.2,0)40 ( -4,2)(0.1,-0.15)40 ( 4,2)(-0.1,-0.15)40",
    "this section discusses the method proposed in the paper , comparing it with related techniques .",
    "the chernikova method is exponential in the worst - case @xcite and the fourier - motzkin method , like all projection techniques over linear inequalities @xcite , is also exponential .",
    "the exponential behaviour of both methods stems from the same source : the possibly exponential relationship between the number of vertices and the number of half - spaces that define a polyhedron .",
    "in fact the problem of calculating the closure of the convex hull of two polyhedra is also exponential even for bounded polyhedra ( polytopes ) .",
    "this can be demonstrated by considering the so - called cross polytope in @xmath69-dimensions which is the polyhedron with the vertex set @xmath107 .",
    "the cross polytope can be defined by no less than @xmath108 inequalities yet can arise as the convex hull of two polyhedra both of which can be defined with @xmath109 inequalities .",
    "specifically consider the @xmath69-dimensional polyhedra @xmath110 because @xmath6 and @xmath7 are polytopes , they can be expressed in terms of their vertices : @xmath111 since @xmath112 is convexly spanned by @xmath113 and @xmath114 , it follows that @xmath115 , @xmath116 , @xmath99 , @xmath117 which is the @xmath69-dimensional cross polytope .",
    "the 2 and 3 dimensional cases are denoted in figure  [ figure - hello ] by ( i ) @xmath6 and @xmath7 and ( ii ) @xmath104 and @xmath105 respectively for which the cross polytopes are a solid square and an octahedron .",
    "hence the problem of calculating the closure of the convex hull is intrinsically exponential irrespective of the algorithm employed .",
    "cxs = [ -1 = < x1+x2+x3+x4 , x1 = < 0 , x2 = < 0 , x3 = < 0 , x4 = < 0 ] ,       cys = [ y1+y2+y3+y4 = < 1 , 0 = < y1 , 0 = < y2 , 0 = < y3 , 0 = < y4 ] ,       convex_hull(xs , cxs , ys , cys , zs , czs ) ,       zs = [ a , b , c , d ] .    czs = [ a - b+c+d>=-1 , a+b - c - d=<1 , a+b+c+d>=-1 , a - b - c - d=<1 ,         a - b - c+d>=-1 , a+b+c - d=<1 , a+b - c+d>=-1 , a - b+c - d=<1 ,         a - b+c - d>=-1 , a+b - c+d=<1 , a+b+c - d>=-1 , a - b - c+d=<1 ,         a - b - c - d>=-1 , a+b+c+d=<1 , a+b - c - d>=-1 , a - b+c+d=<1 ] ? ;        despite the scaling problems that are inherent to any convex hull algorithm , in practise the technique proposed in this paper has been widely applied in logic programming @xcite , mostly to satisfaction .",
    "for example , in the context of inferring termination conditions for logic programs this method is feasible since it accounts for 42% of this first pass of the analysis and the first pass itself constitutes only 23% of the total analysis time @xcite .",
    "whether the approach presented in this paper is applicable depends on the application context .",
    "when only standard domain operations are required and performance is not an issue , this method has much to commend it .",
    "however , when the application has to additionally reason , say , about integral points @xcite or parameterised polyhedra @xcite then specialised polyhedral libraries are required .",
    "further , if performance is important , then recourse should be made to a polyhedral library , since a state - of - the - art implementation employing the chernikova algorithm @xcite , will outperform the approach presented here .",
    "we have presented a prolog program for computing convex hulls using linear solver machinery . as holzbaur s library",
    "is also available for ciao prolog , eclipse , xsb and yap prolog , the technique can be easily adapted to these systems .",
    "the method is a reasonable compromise between conciseness , clarity and efficiency and variants of this program have now been widely deployed .          ,",
    "ricci , e. , zaffanella , e. , and hill , p.  m. 2002 .",
    "possibly not closed convex polyhedra and the parma polyhedra library . in _ static analysis symposium _ , m.  v. hermenegildo and g.  puebla , eds .",
    "lecture notes in computer science , vol . 2477 .",
    "springer - verlag , 213229 .",
    "see also http://www.cs.unipr.it / ppl/.    \\1996 . inferring argument size relationships with clp(@xmath118 ) .",
    "in _ logic - based program synthesis and transformation ( selected papers ) _ , j.  p. gallagher , ed .",
    "lecture notes in computer science , vol .",
    "springer - verlag , 204223 .    , lassez , c. , and lassez , j .- l . 2000 .",
    "qualitative theorem proving in linear constraints . in _ international symposium on artificial intelligence and mathematics_. long version to appear in the annals of mathematics and artificial intelligence .    , genaim , s. , sondergaard , h. , and stuckey , p. 2001 . higher - precision groundness analysis . in _",
    "international conference on logic programming _ , p.  codognet , ed .",
    "lecture notes in computer science , vol . 2237 .",
    "springer - verlag , 135149 .",
    "\\2001 . inferring termination conditions for logic programs using backwards analysis . in _ international conference on logic for programming , artificial intelligence and reasoning _ ,",
    "r.  nieuwenhuis and a.  voronkov , eds .",
    "lecture notes in artificial intelligence , vol . 2250 .",
    "springer - verlag , 681690 .",
    "\\2001 . applying static analysis techniques for inferring termination conditions of logic programs . in _",
    "static analysis symposium _ , p.  cousot , ed .",
    "lecture notes in computer science , vol . 2126 .",
    "springer - verlag , 93110 .",
    "binding - time annotations without binding - time analysis . in _ international conference on logic for programming , artificial intelligence and reasoning _",
    ", r.  nieuwenhuis and a.  voronkov , eds .",
    "lecture notes in artificial intelligence , vol . 2250 .",
    "springer - verlag , 707722 ."
  ],
  "abstract_text": [
    "<S> a programming tactic involving polyhedra is reported that has been widely applied in the polyhedral analysis of ( constraint ) logic programs . </S>",
    "<S> the method enables the computations of convex hulls that are required for polyhedral analysis to be coded with linear constraint solving machinery that is available in many prolog systems .    </S>",
    "<S> * keywords * : convex hull , polyhedra , abstract interpretation , linear constraints .    </S>",
    "<S> [ section ] [ section ] [ section ] [ section ] [ section ] [ section ] </S>"
  ]
}