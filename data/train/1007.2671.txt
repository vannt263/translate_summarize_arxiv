{
  "article_text": [
    "with xml  @xcite being the de facto standard for business and web data representation and exchange , storage and querying of large xml data collections is recognized as an important and challenging research problem .",
    "a number of xml databases  @xcite have been developed to serve as a solution to this problem .",
    "while xml databases can employ various storage models , such as relational model or native xml tree model , they support standard xml query languages , called xpath and xquery . in general , an xml query specifies which nodes in an xml tree need to be retrieved .",
    "once an xml tree is stored into an xml database , a query over this tree usually requires two steps : ( 1 )  finding the specified nodes , if any , in the xml tree and ( 2 )  reconstructing and returning xml subtrees rooted at found nodes as a query result .",
    "the second step is called xml subtree reconstruction  @xcite and may have a significant impact on query response time .",
    "one approach to minimize xml subtree reconstruction time is to cache xml subtrees rooted at frequently accessed nodes as illustrated in the following example .",
    "consider an xml tree in figure  [ fig : xmltree ] that describes a sample bookstore inventory .",
    "the tree nodes correspond to xml elements , e.g. , _ bookstore _ and _ book _ , and data values , e.g. , _",
    "`` arthur '' _ and _ `` bernstein '' _ , and the edges represent parent - child relationships among nodes , e.g. , all the _ book _ elements are children of _ bookstore_. in addition , each element node is assigned a unique identifier that is shown next to the node in the figure . as an example , in figure  [ fig : relation ] , we show how this xml tree can be stored into a single table in an rdbms using the edge approach  @xcite .",
    "the edge table @xmath8 stores each xml element as a separate tuple that includes the element i d , i d of its parent , element name , and element data content .",
    "a sample query over this xml tree that retrieves books with title `` database systems '' can be expressed in xpath as :    = = = = = = +   +    this query can be translated into relational algebra or sql over the edge table to retrieve ids of the _ book _ elements that satisfy the condition :    = = = = = = + @xmath9 + @xmath10 + @xmath11 + @xmath12 + @xmath13 + @xmath14 +    where @xmath15 , @xmath16 , and @xmath17 are aliases of table @xmath8 .",
    "for the edge table in figure  [ fig : relation ] , the relational algebra query returns i d `` 2 '' , that uniquely identifies the first _ book _ element in the tree .",
    "however , to retrieve useful information about the book , the query evaluator must further retrieve all the descendants of the _ book _ node and reconstruct their parent - child relationships into an xml subtree rooted at this node ; this requires additional self - joins of the edge table and a reconstruction algorithm , such as the one proposed in  @xcite . instead , to avoid expensive xml subtree reconstruction",
    ", the subtree can be explicitly stored in the database as an xml reconstruction view ( see figure  [ fig : view ] ) .",
    "this materialized view can be used for the above xpath query or any other query that needs to reconstruct and return the _ book _ node ( with i d `` 2 '' ) or its descendant .    in this work",
    ", we study the problem of selecting xml reconstruction views to materialize : given a set of xml elements @xmath18 from an xml database , their access frequencies @xmath19 ( aka workload ) , a set of ancestor - descendant relationships @xmath20 among these elements , and a storage capacity @xmath21 , find a set of elements @xmath22 from @xmath18 , whose xml subtrees should be materialized as reconstruction views , such that their combined size is no larger than @xmath21 . to our best knowledge",
    ", our solution to this problem is the first one proposed in the literature .",
    "our main contributions and the paper organization are as follows . in section  [ sec : rw ] , we discuss related work . in section  [ sec : problem ] , we formally define the xml reconstruction view selection problem . in sections  [ sec :",
    "complexity ] and [ sec : fptas ] , we prove that the problem is np - hard and describe a fully polynomial - time approximation scheme ( fptas ) for the problem .",
    "we conclude the paper and list future work directions in section  [ sec : conclude ] .",
    "we studied the xml subtree reconstruction problem in the context of a relational storage of xml documents in  @xcite , where several algorithms have been proposed . given an xml element returned by an xml query , our algorithms retrieve all its descendants from a database and reconstruct their relationships into an xml subtree that is returned as the query result . to our best knowledge , there have been no previous work on materializing reconstruction views or xml reconstruction view selection .",
    "materialized views  @xcite have been successfully used for query optimization in xml databases .",
    "these research works rewrite an xml query , such that it can be answered either using only available materialized views , if possible , or accessing both the database and materialized views .",
    "view maintenance in xml databases has been studied in @xcite .",
    "there have been only one recent work  @xcite on materialized view selection in the context of xml databases . in  @xcite",
    ", the problem is defined as : find views over xml data , given xml databases , storage space , and a set of queries , such that the combined view size does not exceed the storage space .",
    "the proposed solution produces minimal xml views as candidates for the given query workload , organizes them into a graph , and uses two view selection strategies to choose views to materialize .",
    "this approach makes an assumption that views are used to answer xml queries completely ( not partially ) without accessing an underlying xml database .",
    "the xml reconstruction view problem studied in our work focuses on a different aspect of xml query processing : it finds views to materialize based on how frequently an xml element needs to be reconstructed .",
    "however , xml reconstruction views can be complimentarily used for query answering , if desired .",
    "finally , the materialized view selection problem have been extensively studied in data warehouses  @xcite and distributed databases  @xcite .",
    "these research results are hardly applicable to xml tree structures and in particular to subtree reconstruction , which is not required for data warehouses or relational databases .",
    "in this section , we formally define the xml reconstruction view selection problem addressed in our work",
    ".    * problem formulation . * given @xmath23 xml elements , @xmath24 , and an ancestor - descendant relationship @xmath20 over @xmath18 such that if @xmath25 , then @xmath26 is an ancestor of @xmath27 , let @xmath28 be the access cost of accessing unmaterialized @xmath27 , and let @xmath29 be the access cost of accessing materialized @xmath27 .",
    "we have @xmath30 since reconstruction of @xmath27 takes time .",
    "we use @xmath31 to denote the memory capacity required to store a materialized xml element , @xmath32 and @xmath33 for any @xmath34 . given a workload that is characterized by @xmath35 representing the access frequency of @xmath27 .",
    "the _ xml reconstruction view selection problem _ is to select a set of elements @xmath22 from @xmath18 to be materialized to minimize the total access cost    @xmath36 under the disk capacity constraint    @xmath37    where @xmath38 if @xmath39 or for some ancestor @xmath26 of @xmath27 , @xmath40 , otherwise @xmath41 .",
    "@xmath21 denotes the available memory capacity , @xmath42 .",
    "next , let @xmath43 means the cost saving by materialization , then one can show that function @xmath44 is minimized if and only if the following function @xmath45 is maximized    @xmath46 under the disk capacity constraint    @xmath37    where @xmath47 represents all the materialized xml elements and their descendant elements in @xmath18 , it is defined as @xmath48 .",
    "in this section , we prove that the xml reconstruction view selection problem is np - hard .",
    "first , the maximization problem is changed into the equivalent decision problem .",
    "* equivalent decision problem . * given @xmath18 , @xmath20 , @xmath31 , @xmath19 , @xmath49 and @xmath21 as defined in section  [ sec : problem ] , let @xmath50 denotes the cost saving goal , @xmath51 .",
    "is there a subset @xmath52 such that    @xmath53 and    @xmath54 @xmath47 represents all the materialized xml elements and their descendant elements in @xmath18 , it is defined as @xmath48 .    in order to study this problem in a convenient model",
    ", we have the following simplified version .",
    "the input is a tree @xmath0 , in which every node @xmath1 has a size @xmath2 and profit @xmath3 , and the size limitation @xmath4 .",
    "the target is to find a subset of subtrees rooted at nodes @xmath55 such that @xmath6 , and @xmath7 is maximal .",
    "furthermore , there is no overlap between any two subtrees selected in the solution .",
    "we prove that the decision problem of the xml reconstruction view selection is an np - hard . a polynomial time reduction from _ knapsack _",
    "@xcite to it is constructed .",
    "[ theoremnpcomplete ] the decision problem of the xml reconstruction view selection is np - complete .    it is straightforward to verify that the problem is in np . restrict the problem to the well - known np - complete problem _ knapsack",
    "_  @xcite by allowing only problem instances in which :    assume that a knapsack problem has input @xmath56 , and parameters @xmath50 and @xmath4 .",
    "we need to determine a subset @xmath57 such that @xmath58 and @xmath59 .",
    "build a binary tree @xmath0 with exactly leaves .",
    "let leaf @xmath1 have profit @xmath3 and size @xmath2 .",
    "furthermore , each internal node , which is not leaf , has size @xmath60 and profit @xmath60 .",
    "clearly , any solution can not contain any internal due to the size limitation .",
    "we can only select a subset of leaves .",
    "this is equivalent to the knapsack problem .",
    "finally , we state the np - hardness of the xml reconstruction view selection problem .",
    "the xml reconstruction view selection problem is np - hard .",
    "it follows from theorem  [ theoremnpcomplete ] , since the equivalent decision problem is np - complete .",
    "we assume that each parameter is an integer .",
    "the input is @xmath23 xml elements , @xmath61 which will be represented by an @xmath20 tree @xmath62 , where each edge in @xmath62 shows a relationship between a pair of parent and child nodes .",
    "we have a divide and conquer approach to develop a fully approximation scheme .",
    "given an @xmath20 tree @xmath62 with root @xmath63 , it has subtrees @xmath64 derived from the children @xmath65 of @xmath63 .",
    "we find a set of approximate solutions among @xmath66 and another set of approximate solutions among @xmath67 .",
    "we merge the two sets of approximate solutions to obtain the solution for the union of subtrees @xmath64 .",
    "add one more solution that is derived by selecting the root @xmath63 of @xmath62 .",
    "group those solutions into parts such that each part contains all solutions @xmath68 with similar @xmath69 .",
    "prune those solution by selecting the one from each part with the least size .",
    "this can reduce the number of solution to be bounded by a polynomial .",
    "we will use a list @xmath68 to represent the selection of elements from @xmath18 .    for a list of elements @xmath68 , define @xmath70 , and @xmath71 .",
    "define @xmath72 be the largest product of the node degrees along a path from root to a leaf in the @xmath20 tree @xmath62 .",
    "assume that @xmath73 is a small constant with @xmath74 .",
    "we need an @xmath75 approximation .",
    "we maintain a list of solutions @xmath76 , where @xmath77 is a list of elements in @xmath18 .",
    "let @xmath78 with @xmath79 .",
    "let @xmath80 and @xmath81 .",
    "partition the interval @xmath82 $ ] into @xmath83 such that @xmath84 $ ] and @xmath85 $ ] with @xmath86 for @xmath87 , and @xmath88 $ ] , where @xmath89 .    two lists @xmath77 and",
    "@xmath90 , are in the same region if there exist @xmath91 such that both @xmath92 and @xmath93 are @xmath94 .    for two lists of partial solutions",
    "@xmath95 and @xmath96 , their link @xmath97 .    * prune * ( @xmath98 )    input : @xmath98 is a list of partial solutions @xmath99 ;    partition @xmath98 into parts @xmath100 such that two lists @xmath77 and @xmath90 are in the same part if @xmath77 and @xmath90 are in the same region .",
    "for each @xmath101 , select @xmath90 such that @xmath102 is the least among all @xmath90 in @xmath101 ;    * end of prune *    * merge * ( @xmath103 )    input : @xmath104 and @xmath105 are two lists of solutions .",
    "let @xmath106 ;    for each @xmath107 and each @xmath108    append their link @xmath109 to @xmath98 ;    return @xmath98 ;    * end of merge *    * union * ( @xmath110 )    input : @xmath111 are lists of solutions .    if @xmath112 then return @xmath104 ;    return prune(merge(union@xmath113 ,    union@xmath114 ;    * end of union *    * sketch * ( @xmath62 )    input : @xmath62 is a set of @xmath23 elements according to their @xmath20 .    if @xmath62 only contains one element @xmath27 , return the list @xmath115 with two solutions .",
    "partition the list @xmath62 into subtrees @xmath64 according to its @xmath116 children .",
    "let @xmath117 be the list that only contains solution @xmath62 .    for @xmath118 to @xmath116 let @xmath119=sketch(@xmath120 )",
    ";    return union@xmath121 ;    * end of sketch *    for a list of elements @xmath68 and an @xmath20 tree @xmath62 , @xmath122 $ ] is the list of elements in both @xmath68 and @xmath62 .",
    "if @xmath64 are disjoint subtrees of an @xmath20 tree , @xmath123 $ ] is @xmath124\\circ \\cdots \\circ p[j_k]$ ] .    in order to make it convenient",
    ", we make the tree @xmath62 normalized by adding some useless nodes @xmath27 with @xmath125 .",
    "the size of tree is at most doubled after normalization . in the rest of the section , we always assume @xmath62 is normalized .",
    "[ lemma - union ] assume that @xmath119 is a list of solutions for the problem with @xmath20 tree @xmath120 for @xmath126 .",
    "let @xmath127 for @xmath126",
    ". then there exists @xmath128union(@xmath111 ) such that @xmath129 and @xmath130 .",
    "we prove by induction .",
    "it is trivial when @xmath112 .",
    "assume that the lemma is true for cases less than @xmath116 .",
    "let @xmath131 @xmath132 union@xmath113 and @xmath133 @xmath132 union@xmath134 .    assume that @xmath131 contains @xmath135 such that @xmath136 and @xmath137 .",
    "assume that @xmath133 contains @xmath138 such that @xmath139)$ ] and @xmath140 .",
    "let @xmath141 .",
    "let @xmath142 be the solution in the same region with @xmath143 and has the least @xmath144 .",
    "therefore ,    @xmath145    since @xmath146 and @xmath147 , we also have    @xmath148    [ lemma-1 ] assume that @xmath68 is an arbitrary solution for the problem with @xmath20 tree @xmath62 .",
    "for @xmath98@xmath132sketch(@xmath62 ) , there exists a solution @xmath149 in the list @xmath98 such that @xmath150 and @xmath151 .",
    "we prove by induction .",
    "the basis at @xmath152 is trivial .",
    "we assume that the claim is true for all @xmath153 .",
    "now assume that @xmath154 and @xmath62 has @xmath116 children which induce @xmath116 subtrees @xmath64 .",
    "let @xmath155 $ ] for @xmath126 . by our hypothesis , for each @xmath1 with @xmath156",
    ", there exists @xmath157 such that @xmath158)$ ] and @xmath159))$ ] .",
    "let @xmath22@xmath132union@xmath160 .",
    "by lemma  [ lemma - union ] , there exists @xmath161 such that    @xmath162)\\\\   & \\le & f^{\\log \\chi(j)}\\lambda(p[j_1,\\cdots , j_{k}])\\\\ & = & f^{\\log \\chi(j)}\\lambda(p).\\end{aligned}\\ ] ]    and @xmath163)\\\\   & = & \\mu(p ) .",
    "\\end{aligned}\\ ] ]    [ time - lemma ] assume that @xmath164 .",
    "then the computational time for sketch(@xmath62 ) is @xmath165 , where @xmath166 is the number of nodes in @xmath62 .",
    "the number of intervals is @xmath167 .",
    "therefore the list of each @xmath119@xmath132prune(@xmath120 ) is of length @xmath168 .",
    "let @xmath169 be the time for union@xmath170 .",
    "it satisfies the recursion @xmath171 .",
    "this brings solution @xmath172 .",
    "let @xmath173 be the computational time for prune(@xmath62 )",
    ".    denote @xmath174 to be the number of edges in @xmath62 .",
    "we prove by induction that @xmath175 for some constant @xmath176 .",
    "we select constant @xmath177 enough so that merging two lists takes @xmath178 steps .",
    "we have that @xmath179    we now complete the common procedure . before we give the fptas for our problems , we first give the following lemma which facilitates our proof for fptas .",
    "one can refer the algorithm book @xcite for its proof .",
    "[ basic - lemma ] ( 1)for @xmath180 , @xmath181 .",
    "( 2)for real @xmath182 , @xmath183 .",
    "* algorithm *    approximate(@xmath62 , @xmath73 )    input : @xmath62 is an @xmath20 tree with elements @xmath184 and @xmath73 is a small constant with @xmath185 ;    let @xmath186sketch@xmath187 ;    select @xmath77 from the list @xmath98 that @xmath77 has the optimal cost ;    * end of the algorithm *    [ main - theorem ] for any instance of @xmath62 of an @xmath20 tree with @xmath23 elements , there exists an @xmath188 time approximation scheme , where @xmath189 .",
    "assume that @xmath68 is the optimal solution for input @xmath62 .",
    "let @xmath98@xmath132prune(@xmath62 ) . by lemma  [ lemma-1 ]",
    ", we have @xmath190 that satisfies the condition of lemma  [ lemma-1 ] .",
    "@xmath191    furthermore , @xmath192 .",
    "the computational time follows from lemma  [ time - lemma ] .",
    "it is easy to see that @xmath193 .",
    "we have the following corollary .",
    "for any instance of @xmath62 of an @xmath20 tree with @xmath23 elements , there exists an @xmath194 time approximation scheme , where @xmath195 .",
    "in this section , we show an approximation scheme for the problem with an input of multiple trees .",
    "the input is a series of trees @xmath64 .",
    "for any instance of @xmath62 of an @xmath20 tree with @xmath23 elements , there exists an @xmath196 time approximation scheme , where @xmath197 and @xmath198 is a tree via connecting all @xmath64 into a single tree under a common root @xmath199 .",
    "build a new tree with a new node @xmath199 such that @xmath64 are the subtrees under @xmath199 .",
    "apply the algorithm in in theorem  [ main - theorem ] .",
    "in this work , we studied the problem of xml reconstruction view selection that promises to improve query evaluation in xml databases .",
    "we were first to formally define this problem : given a set of xml elements @xmath18 from an xml database , their access frequencies @xmath19 ( aka workload ) , a set of ancestor - descendant relationships @xmath20 among these elements , and a storage capacity @xmath21 , find a set of elements @xmath22 from @xmath18 , whose xml subtrees should be materialized as reconstruction views , such that their combined size is no larger than @xmath21 .",
    "next , we showed that the xml reconstruction view selection problem is np - hard . finally , we proposed a fully polynomial - time approximation scheme ( fptas ) that can be used to solve the problem in practice .",
    "future work for our research includes two main directions : ( 1 )  an extension of the proposed solution to support multiple xml trees and ( 2 )  an implementation and performance study of our framework in an existing xml database ."
  ],
  "abstract_text": [
    "<S> query evaluation in an xml database requires reconstructing xml subtrees rooted at nodes found by an xml query . </S>",
    "<S> since xml subtree reconstruction can be expensive , one approach to improve query response time is to use reconstruction views - materialized xml subtrees of an xml document , whose nodes are frequently accessed by xml queries . for this approach to be efficient , the principal requirement is a framework for view selection . in this work , </S>",
    "<S> we are the first to formalize and study the problem of xml reconstruction view selection . </S>",
    "<S> the input is a tree @xmath0 , in which every node @xmath1 has a size @xmath2 and profit @xmath3 , and the size limitation @xmath4 . </S>",
    "<S> the target is to find a subset of subtrees rooted at nodes @xmath5 respectively such that @xmath6 , and @xmath7 is maximal . </S>",
    "<S> furthermore , there is no overlap between any two subtrees selected in the solution . </S>",
    "<S> we prove that this problem is np - hard and present a fully polynomial - time approximation scheme ( fptas ) as a solution . </S>"
  ]
}