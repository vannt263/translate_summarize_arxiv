{
  "article_text": [
    "during the last years the interest in the design of exact exponential time algorithms has grown significantly .",
    "several nice surveys have been written on this subject . in",
    "woeginger s first survey @xcite , he presents the major techniques used to design exact exponential time algorithms .",
    "we also refer the reader to the survey of fomin et al .",
    "@xcite discussing some more recent techniques for the design and the analysis of exponential time algorithms .",
    "in particular , they discuss measure & conquer and lower bounds .    in a graph @xmath1 , a subset of vertices @xmath7 is _ independent _ if no two vertices of @xmath8 share an edge , and @xmath8 is _ dominating _ if every vertex from @xmath9 has at least one neighbor in @xmath8 . in the maximum independent set problem ( mis ) , the input is a graph and the task is to find a largest independent set in this graph . in the minimum dominating set problem ( mds ) , the input is a graph and the task is to find a smallest dominating set in this graph",
    ". a natural and well studied combination of these two problems asks for a subset of vertices of minimum cardinality that is both independent and dominating .",
    "this problem is called minimum independent dominating set ( mids ) .",
    "it is also known as minimum maximal independent set , since every independent dominating setis a maximal independent set . whereas there has been a lot of work on misand mdsin the field of exact algorithms , the best known exact algorithm for mids   prior to our work ",
    "trivially enumerates all maximal independent sets .",
    "* known results . *",
    "the misproblem was among the first problems shown to be np - hard @xcite .",
    "it is known that a maximum independent set of a graph on @xmath10 vertices can be computed in @xmath4 time by combining a result due to moon and moser , who showed in 1965 that the number of maximal independent sets of a graph is upper bounded by @xmath11 @xcite ( see also @xcite ) , and a result due to johnson , yannakakis and papadimitriou , providing in @xcite a polynomial delay algorithm to generate all maximal independent sets .",
    "moreover many exact algorithms for this problem have been published , starting in 1977 by an @xmath12 algorithm by tarjan and trojanowski @xcite . to date , the fastest known exponential space algorithms for mishave been designed by robson . his algorithm from 1986",
    "@xcite has running time @xmath13 and his unpublished computer - generated algorithm from 2001 @xcite has running time @xmath14 . among the currently leading polynomial space algorithms , there is a very simple algorithm with running time @xmath15 by fomin et al .",
    "@xcite from 2006 , an @xmath16 time algorithm by kneis et al .",
    "@xcite from 2009 , and a very recent @xmath17 time algorithm by bourgeois et al .",
    "@xcite .",
    "the mdsproblem is also well known to be np - hard @xcite . until 2004 ,",
    "the only known exact exponential time algorithm to solve mdsasked for trivially enumerating the @xmath18 subsets of vertices .",
    "the year 2004 saw a particular interest in providing some faster algorithms for solving this problem . indeed , three papers with exact algorithms for mdswere published . in @xcite fomin",
    "present an @xmath19 time algorithm , in @xcite randerath and schiermeyer establish an @xmath20 time algorithm and grandoni @xcite obtains an @xmath21 time algorithm .    in 2005",
    ", fomin et al .",
    "@xcite use the measure & conquer approach to obtain an algorithm with running time @xmath22 and using polynomial space . by applying a memorization technique",
    "they show that this running time can be reduced to @xmath23 when allowing exponential space usage .",
    "van rooij and bodlaender @xcite further improved the polynomial - space algorithm to @xmath24 and the exponential - space algorithm to @xmath25 . by now , the fastest published algorithm is due to van rooij et al . in @xcite ,",
    "they provide a @xmath26 time needing exponential space to solve the more general counting version of mds , i.e. the problem of computing the number of distinct minimum dominating sets .",
    "it is known that a minimum independent dominating set(a mids , for short ) can be found in polynomial time for several graph classes like interval graphs @xcite , chordal graphs @xcite , cocomparability graphs @xcite and at - free graphs @xcite , whereas the problem remains np - complete for bipartite graphs @xcite and comparability graphs @xcite . concerning approximation results ,",
    "halldrsson proved in @xcite that there is no constant @xmath27 such that midscan be approximated within a factor of @xmath28 in polynomial time , assuming @xmath29 . the same inapproximation result even holds for circle graphs and bipartite graphs  @xcite .",
    "the problem has also been considered in parameterized approximability .",
    "downey et al .",
    "@xcite have shown that it is @xmath30$]-hard to approximate @xmath31-independent dominating set with a factor @xmath32 , for any computable function @xmath33 .",
    "in other words , unless @xmath30=fpt$ ] , there is no algorithm with running time @xmath34 ( where @xmath35 is any computable function independent of @xmath10 ) which either asserts that there is no independent dominating setof size at most @xmath31 for a given graph @xmath3 , or otherwise asserts that there is one of size at most @xmath32 , for any computable function @xmath33 .",
    "the first exponential time algorithm for midshas been observed by randerath and schiermeyer @xcite .",
    "they use the result due to moon and moser @xcite as explained previously and an algorithm enumerating all the maximal independent sets to obtain an @xmath4 time algorithm for mids . in 2006 , an earlier conference version of this paper claimed an @xmath36 time algorithm @xcite .",
    "however , a flaw concerning the main reduction rule was discovered by the authors and is repaired in the present paper .",
    "very recently , bourgeois et al .",
    "@xcite proposed a branch - and - reduce @xmath37 time algorithm , reusing several of the ideas introduced in @xcite .    * our results . * in this paper we present an @xmath5 time algorithm for solving midsusing the measure & conquer approach to analyze its running time .",
    "as the bottleneck of the algorithm in @xcite are the vertices of degree two , we develop several methods to handle them more efficiently such as marking some vertices and a reduction described in subsection [ sec : cliques ] to a constraint satisfaction problem .",
    "combined with some elaborated branching rules , this enables us to lower bound shrewdly the progress made by the algorithm at each branching step , and thus to obtain a polynomial - space algorithm with running time @xmath5 .",
    "furthermore , we obtain a very close lower bound of @xmath6 on the running time of our algorithm , which is very rare for non trivial exponential time algorithms .",
    "this paper is organized as follows . in section 2",
    ", we introduce the necessary concepts and definitions .",
    "section 3 presents the algorithm for mids .",
    "we prove its correctness and an upper bound on its worst - case running time in section 4 . in section 5 , we establish a lower bound on its worst - case running time , which is very close to the upper bound and we conclude with section 6 .",
    "let @xmath1 be an undirected and simple graph . for a vertex @xmath38",
    "we denote by @xmath39 the neighborhood of @xmath40 and by @xmath41=n(v)\\cup \\{v\\}$ ] the closed neighborhood of @xmath40 .",
    "the degree @xmath42 of @xmath40 is the cardinality of @xmath39 . for a given subset of vertices @xmath7",
    ", @xmath43 $ ] denotes the subgraph of @xmath3 induced by @xmath8 , @xmath44 denotes the set of neighbors in @xmath9 of vertices in @xmath8 and @xmath45 = n(s ) \\cup s$ ] .",
    "we also define @xmath46 as @xmath47 , @xmath48 $ ] as @xmath41 \\cap s$ ] , and @xmath49 ( called the @xmath8-_degree _ of @xmath40 ) as the cardinality of @xmath46 . in the same way , given two subsets of vertices @xmath7 and @xmath50",
    ", we define @xmath51 .",
    "a _ clique _ is a set @xmath52 of pairwise adjacent vertices .",
    "a graph @xmath1 is _ bipartite _ if @xmath53 admits a partition into two independent sets .",
    "a bipartite graph @xmath1 is _ complete bipartite _ if every vertex of one independent set is adjacent to every vertex of the other independent set .",
    "a _ connected component _ of a graph is a maximal subset of vertices inducing a connected subgraph .    in a branch - and - reduce algorithm ,",
    "a solution for the current problem instance is computed by recursing on smaller subinstances such that an optimal solution , if one exists , is computed for at least one subinstance .",
    "if the algorithm considers only one subinstance in a given case , we speak of a reduction rule , otherwise of a branching rule .    consider a vertex @xmath54 of degree two with two non adjacent neighbors @xmath55 and @xmath56 . in such a case",
    ", a branch - and - reduce algorithm will typically branch into three subcases when considering @xmath57 : either @xmath57 , or @xmath55 , or @xmath56 are in the solution set . in the third branch",
    ", one can consider that @xmath55 is not in the solution set as the second branch considers all solution sets containing @xmath55 . in order to memorize that @xmath55 is not in the solution set but still needs to be dominated , we mark @xmath55 .    a _ marked graph _",
    "@xmath58 is a triple where @xmath59 denotes the set of vertices of @xmath3 and @xmath60 denotes the set of edges of @xmath3 .",
    "the vertices in @xmath61 are called _ free vertices _ and the ones in @xmath62 _ marked vertices_.    [ defidsmarked ] given a marked graph @xmath58 , an independent dominating set@xmath0 of @xmath3 is a subset of free vertices such that @xmath0 is an independent dominating setof the graph @xmath63 .    it is possible that such an independent dominating setdoes not exist in a marked graph , for example if some marked vertex has no free neighbor .",
    "finally , we introduce the notion of an _ induced marked subgraph_.    given a marked graph @xmath58 and two subsets @xmath64 , an _ induced marked subgraph _",
    "@xmath65 $ ] is the marked graph @xmath66 where @xmath67 are the edges of @xmath3 with both end points in @xmath68 .",
    "notions like neighborhood and degree in a marked graph @xmath69 are the same as in the corresponding simple graph @xmath70 .",
    "in this section we present an algorithm solving midson marked graphs , assuming that no marked vertex has @xmath61-degree larger than @xmath71 .    from the previous definitions it follows that a subset @xmath72 is a midsof a graph @xmath73 if and only if @xmath0 is a midsof the marked graph @xmath74 .",
    "hence the algorithm of this section is able to solve the problem on simple graphs as well .",
    "also due to the definitions , edges incident to two marked vertices are irrelevant ; throughout this paper we assume that there are no such edges .    given a marked graph @xmath58 ,",
    "consider the graph @xmath75 $ ] induced by its free vertices . in the following subsection we consider the special case when @xmath75 $ ] is a disjoint union of cliques with some additional properties .",
    "assume in this subsection that the graph @xmath75 $ ] is a disjoint union of cliques such that :    * each clique has size at most @xmath71 , and * each marked vertex has at most @xmath71 free neighbors .",
    "we will transform this instance @xmath58 of midsinto an instance @xmath76 of the constraint satisfaction problem ( csp ) .",
    "let us briefly recall some definitions about csp .",
    "given a finite set @xmath77 of @xmath10 variables over domains @xmath78 , @xmath79 , and a set @xmath80 of @xmath81 constraints , cspasks for an assignment of values to the variables , such that each variable is assigned a value from its domain , satisfying all the constraints .",
    "formally , @xmath82-cspis defined as follows :    input : : :    @xmath76 where @xmath83    is a finite set of variables over domains @xmath78 of    cardinality at most @xmath84 , @xmath85 ,    and @xmath86 is a set of constraints .",
    "each constraint @xmath87 is a couple    @xmath88 where    @xmath89 is    a @xmath90-tuple of variables , with @xmath91 , and    @xmath92 is a set of @xmath90-tuples of values over    @xmath93 .",
    "question : : :    is there a function @xmath94 assigning to each variable    @xmath95 , @xmath79 , a value of    @xmath78 such that for each constraint @xmath96 ,    @xmath97 ,    @xmath98 ?    given a marked graph @xmath58 fulfilling the previous conditions",
    ", we describe the construction of a @xmath99-cspinstance .",
    "we label the cliques @xmath100 of @xmath75 $ ] respectively by @xmath101 . for each clique @xmath102 , @xmath103 , label its vertices from @xmath104 to @xmath105 . for each variable @xmath106 , @xmath107",
    ", we define its domain as @xmath108 .",
    "let @xmath109 be a marked vertex and let @xmath110 be the free neighbors of @xmath111 .",
    "thus , @xmath112 . let @xmath113 be the @xmath90-tuple of variables corresponding respectively to the cliques containing @xmath110 .",
    "let @xmath92 be the set of all @xmath90-tuples @xmath114 over @xmath93 such that for at least one @xmath115 , @xmath116 , the value of @xmath117 is @xmath118 and @xmath119 is an edge of the graph .    finally , each marked vertex @xmath111 leads to a constraint @xmath88 of the set @xmath80 .",
    "due to the conditions on the given marked graph , the size of the domain of each variable is at most @xmath71 and the number of variables involved in each constraint is at most @xmath71 .",
    "we now use the following theorem of angelsmark @xcite showing that it is possible to restrict our attention to @xmath120-csp .",
    "if there exists a deterministic @xmath121 time algorithm for solving @xmath122-csp , then for all @xmath123 , there exists a deterministic @xmath124 time algorithm for solving @xmath82-csp , for any @xmath125 .",
    "the constructive proof of this theorem shows how to transform a @xmath82-cspinstance on @xmath10 variables into a set of @xmath122-cspinstances on at most @xmath10 variables each , such that the @xmath82-cspinstance has a solution if and only if at least one of the @xmath122-cspinstances has a solution .",
    "the number of @xmath122-cspinstances of this construction is bounded by @xmath126 , where @xmath127 is the number of variables with domain size @xmath128 in the @xmath82-cspinstance and @xmath125 can be taken arbitrarily small .",
    "we use this construction to transform our @xmath99-cspinstance into a set of @xmath129 @xmath120-cspinstances , where @xmath130 is the number of cliques of size @xmath128 in @xmath75 $ ] .",
    "then , it is not hard to see that there exists a midsfor @xmath3 if and only if at least one of the @xmath120-cspinstances has an assignment of the variables which satisfies all the constraints of this cspinstance . given a satisfying assignment @xmath94 to such a cspinstance , the set @xmath131 is a solution to midsfor @xmath3 .",
    "we obtain the following theorem .",
    "let @xmath132 , @xmath133 and @xmath134 be the number of variables ( i.e. the number of cliques of @xmath75 $ ] ) with domain size ( resp . of size )",
    "@xmath135 , @xmath136 and @xmath71 , respectively .",
    "the corresponding cspinstance can be solved in time @xmath137 where @xmath121 is the running time needed to solve a @xmath120-cspinstance on @xmath10 variables , for any @xmath125 .",
    "the theorem can be combined with the following result of moser and scheder @xcite providing an algorithm for solving @xmath120-csp .",
    "[ thm : mosers10 ] any @xmath120-cspinstance can be solved deterministically in time @xmath138 , for any @xmath125 .",
    "[ cor : csp ] let @xmath58 be a marked graph such that @xmath75 $ ] is a disjoint union of cliques of size at most @xmath71 , and each marked vertex has @xmath61-degree at most 4 .",
    "let @xmath130 , @xmath139 , be the number of free vertices with @xmath128 free neighbors in @xmath3 ( thus @xmath75 $ ] has @xmath130 cliques of size @xmath140 ) .",
    "a mids , if one exists , can be computed in time @xmath141 or it can be decided within the same running time that the marked graph has no mids , for any @xmath125 .",
    "we remark that the procedure of corollary [ cor : csp ] will not be a bottleneck in the final running time analysis of our algorithm , even if we use the @xmath142 by dantsin et al .",
    "@xcite to solve @xmath120-cspinstances instead of theorem [ thm : mosers10 ] .      in this subsection , we give algorithm * ids * computing the size of a midsof a marked graph .",
    "although the number of branching rules is quite large it is fairly simple to check that the algorithm computes the size of a mids(if one exists ) .",
    "it is also not difficult to transform * ids * into an algorithm that actually outputs a mids . in the next section",
    "we prove the correctness and give a detailed analysis of the running time of algorithm * ids*.    once it has selected a vertex @xmath57 , the algorithm makes recursive calls ( that is , it branches ) on subinstances of the marked graph .",
    "there are different ways the algorithm branches and we give the most common ones now .",
    "let @xmath143 denote the free neighbors of @xmath57 , ordered by increasing @xmath61-degree .",
    "the branching procedure @xmath144 explores all possibilities that @xmath57 or a free neighbor of @xmath57 is in the solution set .",
    "it returns @xmath145 } \\ { \\mathbf{ids}(g[f\\setminus n[v],m\\setminus n(v ) ] ) \\}.\\end{aligned}\\ ] ] the branching procedure @xmath146 additionally makes sure that the free neighbors of @xmath57 are considered by increasing @xmath61-degree and when considering the possibility that @xmath147 is in the solution set , it marks all vertices @xmath148 , @xmath149",
    ". it returns @xmath150,m\\setminus",
    "n(u)]);\\\\            \\min_{i=1 .. d_f(u ) } \\begin{cases}\\mathbf{ids}(g[f\\setminus ( n[v_i ] \\cup \\{v_1,\\ldots ,",
    "v_{i-1}\\}),\\\\            \\quad\\quad\\quad ( m\\cup \\{v_1,\\ldots , v_{i-1}\\})\\setminus n(v_i ) ] ) .",
    "\\end{cases }          \\end{cases}\\end{aligned}\\ ] ] finally , the branching procedure @xmath151 considers the two possibilities where @xmath57 is in the solution set or where @xmath57 is not in the solution set .",
    "in the recursive call corresponding to the second possibility , @xmath57 is marked . the procedure returns @xmath152,m\\setminus",
    "n(u)]);\\\\            \\mathbf{ids}(g[f\\setminus \\{u\\ } , m\\cup \\{u\\ } ] ) .",
    "\\end{cases}\\end{aligned}\\ ] ]     * algorithm ids(@xmath3 ) + *    the branching procedure @xmath153 is favored over @xmath154 if @xmath154 would create marked vertices of degree at least @xmath155 .",
    "thus , starting with a graph where all the marked vertices have @xmath61-degree at most @xmath71 , algorithm * ids * will keep this invariant .",
    "this property allows us to use the procedure described in the previous subsection whenever the graph induced by its free vertices is a collection of cliques of size at most @xmath71 .",
    "the correctness and running time analysis of * ids * are described in the next section .",
    "in our analysis , we assign so - called weights to free vertices .",
    "free vertices having only marked neighbors can be handled without branching .",
    "hence , it is an advantage when the @xmath61-degree of a vertex decreases .",
    "the weights of the free vertices will therefore depend on their @xmath61-degree .",
    "let @xmath127 denote the number of free vertices having @xmath61-degree @xmath128 .",
    "for the running time analysis we consider the following measure of the size of @xmath3 : @xmath156 with the weights @xmath157 $ ] . in order to simplify the running time analysis",
    ", we make the following assumptions :    * @xmath158 , * @xmath159 for @xmath160 , * @xmath161 , and * @xmath162 where @xmath163 .",
    "[ upperbound ] algorithm * ids * solves midsin time @xmath5 .",
    "an instance @xmath164 is _ atomic _ if algorithm * ids * does not make a recursive call on input @xmath164 .",
    "let @xmath165 $ ] denote the maximum number of atomic subinstances recursively processed to compute a solution for an instance of size @xmath31 .",
    "as the time spent in each call of * ids * , excluding the time spent by the corresponding recursive calls , is polynomial , except for case ( 4 ) , it is sufficient to show that for a valid choice of the weights , @xmath165=o({1.35684}^k)$ ] , and that the time spent in case ( 4 ) does not exceed @xmath165 $ ] .",
    "each recursive call made by the algorithm is on an instance with at least one edge fewer , which means that the running time of * ids * can be upper bounded by a polynomial factor of @xmath165 $ ] .",
    "moreover , as no reduction or branching rule increases @xmath31 , @xmath165 $ ] can be bounded by analyzing recurrences based on the measure of the created subinstances in those cases where the algorithm makes at least @xmath135 recursive calls .",
    "we will analyze these cases one by one .",
    "* case ( 1 ) * a marked vertex that has no free neighbor can not be dominated .",
    "thus , such an instance has no independent dominating set .",
    "* case ( 2 ) * in this case , @xmath75 $ ] is a disjoint union of cliques and @xmath57 is a vertex from a clique of size @xmath166 in @xmath75 $ ] .",
    "the branching @xmath144 creates @xmath167 subinstances whose measure is bounded by @xmath168 .",
    "the corresponding recurrence relation is @xmath169 \\leq \\ell p[k- \\ell w_3 ] .",
    "$ ] for @xmath166 , the tightest of these recurrences is when @xmath170 : @xmath171 \\leq 6 p[k- 6 w_3].\\ ] ]    * case ( 3 ) * in this case , @xmath75 $ ] is a disjoint union of cliques and @xmath57 is a vertex from a clique of size @xmath155 in @xmath75 $ ] .",
    "the branching @xmath151 creates @xmath135 subinstances whose measure is bounded by @xmath172 and @xmath173 , respectively .",
    "note that the marked vertex which is created in the second branch has @xmath61-degree @xmath71 .",
    "the corresponding recurrence is @xmath171 \\leq p[k- 5 w_3 ] + p[k- w_3].\\ ] ]    * case ( 4 ) * the graph induced by the free vertices is a disjoint union of cliques of size no more than @xmath71 .",
    "corollary  [ cor : csp ] is applied on the remaining marked graph and we note that the number @xmath127 of vertices of @xmath61-degree @xmath128 , @xmath139 , in this graph is no more than @xmath174 , @xmath175 and @xmath176 with @xmath177 .    * case ( 5 ) * a marked vertex @xmath57 with exactly one free neighbor @xmath40 must be dominated by @xmath40 .",
    "thus , @xmath40 is added to the midsand all its neighbors are deleted .    *",
    "case ( 6 ) * if there is a subset @xmath178 of free vertices such that @xmath179 $ ] induces a complete bipartite graph and no vertex of @xmath178 is adjacent to a free vertex outside @xmath178 , then the algorithm branches into two subcases .",
    "let @xmath180 and @xmath181 be the two maximal independent sets of @xmath179 $ ] . then a midscontains either @xmath180 or @xmath181 . in both cases we delete @xmath178 and the marked neighbors of either @xmath180 or @xmath181 .",
    "the smallest possible subset @xmath178 satisfying the conditions of this case is a @xmath182 , that is a path on three vertices , as @xmath183 . note that all smaller complete bipartite graphs are cliques and will be handled by case ( 4 ) .",
    "since we only count the number of free vertices , we obtain the following recurrence : @xmath171 \\leq 2p[k-2w_1-w_2].\\ ] ] it is clear that any complete bipartite component with more than three vertices would lead to a better recurrence .",
    "* case ( 7 ) * if there is a subset @xmath80 of three free vertices which form a clique and exactly one vertex @xmath184 has free neighbors outside @xmath80 , the algorithm either includes @xmath40 in the solution set or it excludes this vertex . in the first branch , all the neighbors of @xmath40 are deleted ( including @xmath80 ) . in the second branch , note that @xmath40 is not marked . indeed , @xmath40",
    "s @xmath61-degree might be too high to be marked , and @xmath40 s neighborhood contains a clique component in @xmath75 $ ] of which one vertex is in every independent dominating setof the resulting marked graph , making the marking of @xmath40 superfluous .",
    "we distinguish two cases based on the number of free neighbors of some free vertex @xmath185 .    1 .",
    "vertex @xmath57 has one free neighbor . in the first branch ,",
    "all of @xmath41 $ ] are deleted , and in the second branch , @xmath40 is removed , @xmath57 s @xmath61-degree decreases to @xmath186 , and the @xmath61-degree of both vertices in @xmath187 decreases to @xmath188 .",
    "this gives the recurrence : @xmath171 \\leq p[k - w_1 - 2w_2-w_3]+p[k+w_1 - 2w_2-w_3].\\ ] ] 2 .",
    "vertex @xmath57 has @xmath61-degree at least @xmath135 .",
    "then we obtain the recurrence : @xmath171 \\leq p[k-3w_2-w_3]+p[k+2w_1 - 2w_2-w_3].\\ ] ]    * case ( 8) * if there is a free vertex @xmath57 such that @xmath189 , a midseither includes @xmath57 or its free neighbor @xmath55 .",
    "vertex @xmath55 can not have @xmath61-degree one because this would contradict the first choice criterion ( a ) of @xmath57 .",
    "for the analysis , we consider two cases :    1 .   @xmath190 .",
    "let @xmath191 denote the other free neighbor of @xmath55 .",
    "note that @xmath192 as this would have been handled by case ( 6 ) .",
    "we consider again two subcases : 1 .",
    "when @xmath57 is chosen in the independent dominating set , @xmath57 and @xmath55 are deleted and the degree of @xmath191 decreases to one .",
    "when @xmath55 is chosen in the independent dominating set , @xmath194 and @xmath191 are deleted from the marked graph .",
    "so , we obtain the following recurrence for this case : @xmath171 \\leq p[k-2w_2 ] + p[k - w_1 - 2w_2].\\ ] ] 2 .   @xmath195 .",
    "vertices @xmath57 and @xmath55 are deleted in the first branch , and @xmath57 , @xmath55 and @xmath191 are deleted in the second branch .",
    "the recurrence for this subcase is : @xmath171 \\leq p[k - w_1-w_2 ] + p[k - w_1-w_2-w_3].\\label{rec : tight1}\\ ] ] 2 .",
    "at least one free neighbor of @xmath55 has @xmath61-degree at least 2 , otherwise case ( 6 ) would apply .",
    "therefore the recurrence for this subcase is : @xmath171 \\leq p[k - w_1-w_3 ] + p[k-2w_1-w_2-w_3].\\ ] ]    * case ( 9 ) * if there is a free vertex @xmath57 such that @xmath197 and @xmath57 has a neighbor of @xmath61-degree at most @xmath71 ( as the neighbors @xmath198 of @xmath57 are ordered by increasing @xmath61-degree , @xmath55 has @xmath61-degree at most @xmath71 ) , the algorithm uses @xmath146 to branch into three subcases .",
    "either @xmath57 belongs to the mids , or @xmath55 is taken in the mids , or @xmath55 is marked and @xmath56 is taken in the mids .",
    "we distinguish three cases :    1 .",
    "@xmath199 . in this case , due to the choice of the vertex @xmath57 by the algorithm , all free vertices of this connected component @xmath200 in @xmath75 $ ] have @xmath61-degree 2 .",
    "@xmath200 can not be a @xmath201 ( a cycle on 4 vertices ) as this is a complete bipartite graph and would have been handled by case ( 6 ) . in the branches",
    "where @xmath57 or @xmath55 belong to the mids , the three free vertices in @xmath202 $ ] or @xmath203 $ ] are deleted and two of their neighbors ( @xmath200 is a cycle on at least @xmath155 vertices ) have their @xmath61-degree reduced from @xmath135 to @xmath188 . in the branch where @xmath55 is marked and @xmath56 is added to the mids , @xmath204 $ ] is deleted and by case ( 5 ) , the other neighbor @xmath191 of @xmath55 is added to the mids , resulting in the deletion of @xmath205 $ ] as well . in total , at least @xmath155 free vertices of @xmath61-degree @xmath135 are deleted in the third branch .",
    "thus , we have the recurrence @xmath171 \\leq 2 p[k+2w_1 - 5w_2 ] + p[k-5w_2]\\ ] ] for this case .",
    "2 .   @xmath206 .",
    "the vertices @xmath55 and @xmath56 are not adjacent , otherwise case ( 7 ) would apply . in the last branch , @xmath55 is marked and @xmath56 is added to the solution . if @xmath55 and @xmath56 have a common neighbor besides @xmath57 , then the last branch is atomic because case ( 1 ) applies as no vertex can dominate @xmath55 .",
    "otherwise , the reduction rule of case ( 5 ) applies in the last branch and the other neighbor @xmath207 is added to the solution as well .",
    "thus , we have the recurrence @xmath171 \\leq p[k-2w_2-w_3 ] + p[k-3w_2 ] + p[k-5w_2-w_3].\\ ] ] 3 .",
    "we distinguish between two cases depending on whether there is an edge between @xmath55 and @xmath56",
    "@xmath55 and @xmath56 are not adjacent .",
    "branching on @xmath57 , @xmath55 and @xmath56 leads to the following recurrence : @xmath171 \\leq p[k - w_2 - 2w_3]+p[k-3w_2-w_3]+p[k-3w_2 - 2w_3].\\ ] ] 2 .",
    "@xmath55 and @xmath56 are adjacent .",
    "we distinguish two subcases depending on whether there is a degree-@xmath135 vertex in @xmath209 . 1 .",
    "there is a degree-@xmath135 vertex in @xmath209 .",
    "then , @xmath171 \\leq p[k+w_1 - 2w_2 - 2w_3]+2p[k-2w_2 - 2w_3].\\ ] ] 2 .",
    "no vertex in @xmath209 has degree @xmath135 .",
    "then , @xmath171 \\leq p[k - w_2 - 2w_3]+2p[k - w_2 - 3w_3].\\label{rec : tight2}\\ ] ]    * case ( 10 ) * if there is a free vertex @xmath57 such that @xmath197 and none of the above cases apply , then @xmath55 and @xmath56 have degree at least @xmath155 and the algorithm branches into the three subinstances of @xmath144 : either @xmath210 or @xmath56 belongs to the mids , leading to the recurrence @xmath171 \\leq p[k - w_2 - 2w_3]+2p[k-5w_2-w_3].\\ ] ]    * case ( 11 ) * if all neighbors of @xmath57 have degree @xmath136 , then the connected component in @xmath75 $ ] containing @xmath57 is @xmath136-regular due to the selection criteria of @xmath57 . as ( by criterion ( a ) )",
    "this component is not a clique , @xmath211 is not empty .",
    "thus , there exists some @xmath212 $ ] such that @xmath213 $ ] has at most one edge .",
    "this means that there are at least @xmath71 edges with one endpoint in @xmath214 and the other endpoint in @xmath215 . if @xmath216 , the recurrence corresponding to the branching @xmath217 is @xmath171 \\leq p[k+2w_1 - 6w_3]+p[k+3w_2 - 4w_3],\\ ] ] if @xmath218 it is @xmath171 \\leq p[k+4w_2 - 8w_3]+p[k+3w_2 - 4w_3],\\label{rec : tight3}\\ ] ] and if @xmath219 it is a mixture of the above two recurrences and is majorized by one or the other .",
    "* case ( 12 ) * if @xmath57 has a neighbor @xmath40 of @xmath61-degree @xmath71 , then the algorithm uses the branching procedure @xmath217 .",
    "if @xmath40 is taken in the mids , @xmath155 vertices of degree at least @xmath136 are removed from the instance .",
    "if @xmath40 is marked , the @xmath61-degree of @xmath57 decreases from @xmath136 to @xmath135 .",
    "the corresponding recurrence is @xmath171 \\leq p[k-5w_3]+p[k+w_2 - 2w_3].\\ ] ]    * case ( 13 ) * if @xmath57 has a neighbor @xmath40 of @xmath61-degree @xmath155 , then the algorithm either takes @xmath57 in the mids , or @xmath40 , or it marks both @xmath57 and @xmath40 ( note that @xmath40 will have @xmath61-degree 4 ) .",
    "the recurrence corresponding to this case is @xmath171 \\leq p[k-4w_3]+p[k-6w_3]+p[k-2w_3].\\label{rec : tight4}\\ ] ]    * case ( 14 ) * in this case , @xmath220 $ ] is a clique and @xmath221 is the only vertex from this clique that has free neighbors outside @xmath220 $ ] .",
    "the algorithm either takes @xmath221 in the midsor deletes it .",
    "note that @xmath222 includes a clique and that any midsof @xmath223 $ ] contains one vertex from this clique , which makes the marking of @xmath221 superfluous .",
    "@xmath171 \\leq p[k-7w_3]+p[k+3w_2 - 4w_3 ] . \\ ] ]    * case ( 15 ) * we distinguish two cases based on the neighborhood of @xmath221 .    1",
    ".   @xmath221 is adjacent to @xmath55 and @xmath56 .",
    "then , @xmath55 is not adjacent to @xmath56 , otherwise case ( 14 ) would apply . in the second branch ,",
    "@xmath56 s @xmath61-degree drops to @xmath188 and in the third branch , @xmath55 s neighbor in @xmath211 is also selected by case ( 5 ) .",
    "this gives the recurrence @xmath171",
    "\\leq p[k-4w_3]+p[k+w_1 - 5w_3]+p[k-5w_3]+p[k-7w_3].\\ ] ] 2 .",
    "@xmath221 is not adjacent to @xmath55 or to @xmath56 . in the last branch ,",
    "@xmath224 vertices are deleted and one vertex is marked , giving @xmath171 \\leq 3p[k-4w_3]+p[k-8w_3].\\ ] ]    * case ( 16 ) * in this case , @xmath57 has at least two neighbors of degree at least @xmath225 .",
    "the recurrence corresponding to the branching @xmath144 is @xmath171 \\leq 2p[k-4w_3]+2p[k-7w_3].\\ ] ]    * case ( 17 ) * if @xmath57 has degree @xmath71 , the algorithm branches along @xmath151 , giving the recurrence @xmath171",
    "\\leq p[k-5w_3]+p[k - w_3].\\ ] ]    * case ( 18 ) * if @xmath57 has degree @xmath226 , the algorithm branches along @xmath144 .",
    "the corresponding recurrence is @xmath165 \\leq ( \\ell+1 ) p[k-(\\ell+1)w_3]$ ] , the tightest of which is obtained for @xmath227 : @xmath171 \\leq 6p[k-6w_3].\\ ] ]    finally the values of weights are computed with a convex optimization program @xcite ( see also @xcite ) to minimize the bound on the running time . using the values @xmath228 and @xmath229 for the weights , one can easily verify that @xmath165=o({1.35684}^k)$ ] .",
    "in particular by this choice of the weights , the running - time required by corollary  [ cor : csp ] to solve the cspinstance whenever case ( 2 ) is applied is no more than @xmath230 ( it would be bounded by @xmath231 if we used the algorithm of dantsin et al .",
    "@xcite for solving ( 2,4)-csp ) .",
    "thus , algorithm * ids * solves midsin time @xmath5 .",
    "the tight recurrences of the latter proof ( i.e. the worst case recurrences ) are ( [ rec : tight1 ] ) , ( [ rec : tight2 ] ) , ( [ rec : tight3 ] ) , and ( [ rec : tight4 ] ) .",
    "in order to analyze the progress of the algorithm during the computation of a mids , we used a non standard measure . in this way we have been able to determine an upper bound on the size of the subinstances recursively processed by the algorithm , and",
    "consequently we obtained an upper bound on the worst case running time of algorithm * ids*. however the use of another measure or a different method of analysis could perhaps provide a `` better upper bound '' without changing the algorithm but only improving the analysis .",
    "how far is the given upper bound of theorem  [ upperbound ] from the best upper bound we can hope to obtain ? in this section , we establish a lower bound on the worst case running time of our algorithm .",
    "this lower bound gives a really good estimation on the precision of the analysis .",
    "for example , in @xcite ( see also @xcite ) fomin et al .",
    "obtain a @xmath22 time algorithm for solving the dominating set problem and they exhibit a construction of a family of graphs giving a lower bound of @xmath232 for its running time .",
    "they say that the upper bound of many exponential time algorithms is likely to be overestimated only due to the choice of the measure for the analysis of the running time , and they note the gap between their upper and lower bound for their algorithm .",
    "however , for our algorithm we have the following result :    [ lowerbound ] algorithm * ids * solves midsin time @xmath6 .    to prove theorem  [ lowerbound ] on the lower bound of the worst - case running time of algorithm * ids * , consider the graph @xmath233 ( see fig .",
    "[ lbgraph ] ) defined by :    * @xmath234 , * @xmath235 .",
    "we denote by @xmath236 the marked graph corresponding to the graph @xmath237 .",
    "graph @xmath238    for a marked graph @xmath58 we define @xmath239 and @xmath240 as the set of free vertices with smallest @xmath61-degree .",
    "we denote the highest @xmath61-degree of the free neighbors of the vertices in @xmath241 by @xmath242 .",
    "let @xmath243 be the set of candidate vertices that * ids * can choose in case ( 9 ) . w.l.o.g .",
    "suppose that when @xmath244 and * ids * would apply case ( 9 ) , it chooses the vertex with smallest index ( e.g. if @xmath245 , the algorithm would choose @xmath246 ) .    [ lblemma1 ] let @xmath247 be the input of algorithm * ids*. suppose that * ids * only applies case ( 9 ) in each recursive call ( with respect to the previous rule for choosing a vertex ) .",
    "then , in each call of * ids * where the remaining input graph has more than four vertices , one of the following two properties is fulfilled :    1 .",
    "@xmath248 for a certain @xmath31 , @xmath249 , and a.   the set of vertices @xmath250 has been deleted from the input graph , and b.   all vertices in @xmath251 remain free in the input graph .",
    "2 .   @xmath252 for a certain @xmath31 , @xmath249 , and a.   the set of vertices @xmath253 has been deleted from the input graph , and b.   all vertices in @xmath254 remain free in the input graph .",
    "we prove this result by induction .",
    "it is not hard to see that @xmath255 for @xmath247 and that property ( 1 ) is verified .",
    "suppose now that property ( 1 ) is fulfilled .",
    "then there exists an integer @xmath31 , @xmath256 , such that @xmath248 . since",
    "* ids * applies case ( 9 ) respecting the rule for choosing the vertex in @xmath257 , the algorithm chooses vertex @xmath258 .",
    "then we branch on three subinstances :    1 .",
    "take @xmath258 in the midsand remove @xmath259 $ ] .",
    "thus , the remaining free vertices are @xmath260 whereas all other vertices are removed .",
    "moreover for this remaining subinstance , we obtain @xmath261 .",
    "so , property ( 2 ) is verified .",
    "( note also that @xmath262 \\cap \\bigcup_{k\\leq i\\leq l } \\{u_i , v_i\\}| = 3 $ ] . ) 2 .",
    "take @xmath263 in the midsand remove @xmath264 $ ] : @xmath265 is the set of the remaining free vertices and all other vertices are removed . for the remaining subinstance we obtain @xmath266 and property ( 1 ) is verified .",
    "( note also that @xmath267 \\cap \\bigcup_{k\\leq i\\leq l } \\{u_i , v_i\\}| = 4 $ ] . ) 3 .",
    "take @xmath268 in the midsand remove @xmath269 $ ] .",
    "thus , the remaining free vertices are @xmath270 and all other vertices are removed .",
    "for this remaining subinstance we obtain @xmath271 and property ( 2 ) is verified .",
    "( note also that @xmath272 \\cap \\bigcup_{k\\leq i\\leq l } \\{u_i , v_i\\}| = 5 $ ] . )    if we suppose now that property ( 2 ) is fulfilled , branching on a vertex @xmath263 gives us the same kind of subproblems .",
    "now , we prove that , on input @xmath273 , algorithm * ids * applies case ( 9 ) as long as the remaining graph has `` enough '' vertices .    given the graph @xmath247 as input , as long as the remaining graph has more than four vertices , algorithm * ids * applies case ( 9 ) in each recursive call .",
    "we prove this result also by induction .",
    "first , when the input of the algorithm is the graph @xmath247 , it is clear that none of cases ( 1 ) to ( 8) can be applied .",
    "so , case ( 9 ) is applied since @xmath274 according to lemma  [ lblemma1 ] .",
    "consider now a graph obtained from @xmath247 by repeatedly branching using case ( 9 ) . by lemma  [ lblemma1 ]",
    ", the remaining graph has no marked vertices ( this excludes that cases ( 1 ) and ( 5 ) are applied ) .",
    "it has no clique component induced by the set of free vertices since the graph is connected and there is no edge between @xmath275 and @xmath276 ( this excludes cases ( 2)(4 ) ) .",
    "the free vertices do not induce a bipartite graph since @xmath277 induces a @xmath278 ( this excludes case ( 6 ) ) .",
    "there is no clique @xmath80 such that only one vertex of @xmath80 has neighbors outside @xmath80 : the largest induced clique in the remaining graph has size 3 and each of these cliques has at least two vertices having some neighbors outside the clique ( this excludes case ( 7 ) ) . also , according to lemma  [ lblemma1 ] , the remaining graph has no vertex of degree 1 ( this excludes case ( 8) ) and @xmath274 .",
    "consequently , the algorithm applies case ( 9 ) .",
    "a part of the search tree ]    figure [ lbsearchtree ] gives a part of the search tree illustrating the fact that our algorithm recursively branches on three subinstances with respect to case ( 9 ) .",
    "consider the graph @xmath247 and the search tree which results from branching using case ( 9 ) until @xmath31 vertices , @xmath279 , have been removed from the given input graph @xmath247 ( @xmath247 has @xmath280 vertices ) .",
    "denote by @xmath281 $ ] the number of leaves in this search tree .",
    "it is not hard to see that this leads to the following recurrence ( see the notes in the proof of lemma [ lblemma1 ] ) : @xmath282 = l[k-3 ] + l[k-4 ] + l[k-5]\\ ] ] and therefore @xmath281 \\geq 1.3247^{k}$ ] .",
    "consequently , the maximum number of leaves that a search tree for * ids * can contain , given an input graph on @xmath10 vertices , is @xmath6 .",
    "in this paper we presented a non trivial algorithm solving the minimum independent dominating set problem . using a non standard measure on the size of the considered graph",
    ", we proved that our algorithm achieves a running time of @xmath5 .",
    "moreover we showed that @xmath6 is a lower bound on the running time of this algorithm by exhibiting a family of graphs for which our algorithm has a high running time .",
    "a natural question here is : is it is possible to obtain a better upper bound on the running time of the presented algorithm by considering another measure or using other techniques . or is it possible that this upper bound is tight ?",
    "dantsin  e. , a.  goerdt , e.a .",
    "hirsch , r.  kannan , j.m .",
    "kleinberg , c.h .",
    "papadimitriou , p.  raghavan , and u.  schning , a deterministic ( 2 - 2/(k+1))n algorithm for k - sat based on local search , _ theoretical computer science _ , * 289 * , ( 2002 ) , pp ."
  ],
  "abstract_text": [
    "<S> an independent dominating set@xmath0 of a graph @xmath1 is a subset of vertices such that every vertex in @xmath2 has at least one neighbor in @xmath0 and @xmath0 is an independent set , i.e. no two vertices of @xmath0 are adjacent in @xmath3 . finding a minimum independent dominating setin </S>",
    "<S> a graph is an np - hard problem . whereas it is hard to cope with this problem using parameterized and approximation algorithms </S>",
    "<S> , there is a simple exact @xmath4-time algorithm solving the problem by enumerating all maximal independent sets . in this paper </S>",
    "<S> we improve the latter result , providing the first non trivial algorithm computing a minimum independent dominating setof a graph in time @xmath5 . </S>",
    "<S> furthermore , we give a lower bound of @xmath6 on the worst - case running time of this algorithm , showing that the running time analysis is almost tight . </S>"
  ]
}