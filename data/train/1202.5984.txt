{
  "article_text": [
    "in recent years the functional renormalization group ( frg ) has been successfully applied to a wide variety of nonperturbative problems such as critical phenomena , fermionic systems , gauge theories , supersymmetry and quantum gravity , see @xcite for reviews .",
    "although these systems are very different in their physical nature , the flow equations always have a similar structure .",
    "the aim of the frg is to calculate the generating functionals of 1pi correlation functions from which the dynamics of the theory can be inferred .",
    "the core ingredient is the scale dependent effective action denoted by @xmath0 with the rg scale @xmath1 .",
    "it interpolates between a microscopic description through the classical action at some uv scale @xmath2 and a macroscopic description at low energy scales @xmath3 through the full quantum effective action .",
    "the rg scale @xmath1 serves as an infrared regulator suppressing all fluctuations with momentum smaller than @xmath1 .",
    "thus , for @xmath3 all fluctuations are taken into account and we have obtained a full solution of the quantum theory .",
    "the flow of the scale dependent effective action is governed by the wetterich equation @xcite @xmath4 , \\label{eq : lpa1}\\ ] ] with @xmath5 being the second functional derivative of the effective action .",
    "the momentum - dependent regulator function @xmath6 in eq .",
    "( [ eq : lpa1 ] ) establishes the ir suppression of modes below @xmath1 . in the general case ,",
    "three properties of the regulator @xmath7 are essential : ( i ) @xmath8 which implements the ir regularization , ( ii ) @xmath9 which guarantees that the regulator vanishes for @xmath10 , ( iii ) @xmath11 which serves to fix the theory at the classical action in the uv .",
    "different functional forms of @xmath6 correspond to different rg trajectories manifesting the rg scheme dependence , but the end point @xmath12 remains invariant .    solving the partial nonlinear differential equation head on is impossible in most cases .",
    "thus approximations for the effective action have to be introduced resulting in a system of coupled differential equations .",
    "recently , a mathematica extension which is able to derive dyson - schwinger equations and functional renormalization group equations was published @xcite . however , solving these systems beyond the most simple approximations is a numerical challenge .",
    "for some systems , e.g. supersymmetric quantum mechanics @xcite and the two dimensional @xmath13 wess - zumino model @xcite , the coefficient function of the highest derivative can become singular .",
    "this implies that solving the differential equations numerically has to be done with great care .",
    "if the equations are solved exactly , the singularity is never reached but rather the flow is repelled if it comes close to the singularity . a numerical solution has to take this behavior into account .    including a full momentum dependence has become more important over the last few years .",
    "this leads to a much higher numerical effort for the solution of the flow equations .",
    "full momentum dependence of propagators and vertices has previously been treated successfully in the literature @xcite .",
    "this article presents a numerical toolbox called flowpy for the solution of a broad class of partial differential equations that are encountered in the study of the functional renormalization group equations .",
    "specifically , flowpy supports full momentum dependence of the flowing function , systems of coupled differential equations , and also implicit specification of the @xmath1-derivative ( as they are encountered in the flow equation for a field dependent wave function ) .",
    "this paper is organized as follows : in sec .",
    "[ sec : numericalsetup ] we describe the numerical setup for flowpy . in sec .",
    "[ sec : usingflowpy ] to sec .",
    "[ sec : fileformat ] we describe how flowpy is used , which parameters it takes and how they are specified . in sec .",
    "[ sec : examples ] we discuss both simple and typical examples of differential equations in the study of the functional renormalization group .",
    "we give detailed examples for python scripts that demonstrate how flowpy can be used in practice .",
    "our aim is to demonstrate how flowpy is used , thus we just take flow equations from the literature without any derivation . as flowpy is a general solver for partial differential equations we will denote the flow functions with @xmath14 most of the time , unless we consider some special physical system .",
    "the main design choices when building a framework for renormalization group flows are about how to support a reasonably large class of interesting problems while keeping code complexity manageable .",
    "one of the most challenging aspects of functional renormalization group problems is that the rate of change of the flow function  @xmath14 can , for each value of the scale parameter  @xmath1 and at each point  @xmath15 , receive contributions from all other points  @xmath16 .",
    "hence , we are dealing with non - local partial integro - differential equations , or coupled systems of such equations , which may furthermore contain higher derivatives with respect to the coordinate  @xmath15 , and potentially be given in implicit form only .",
    "conceptually , a numerical approach to problems of this nature involves numerical ode solving ( after discretization of the @xmath15  range , as discussed below ) , numerical interpolation , numerical integration , as well as numerical differentiation .",
    "while an advanced numerical approach to such problems would perhaps develop a sophisticated combined ( adaptive ) discretization scheme that handles these different aspects in an unified fashion , here we contend ourselves with combining functionality from readily available libraries ( specifically , functions from odepack@xcite , fitpack@xcite , and quadpack@xcite ) to solve the first three of the aforementioned tasks . rather than working with these libraries directly ,",
    "we use wrappers available in scientific python  @xcite , as the flexibility provided by the python programming language is very helpful for addressing some subtle aspects of the task .",
    "the flowpy package s objective is to numerically solve equations ( resp .",
    "equation systems ) of this type through discretization of the @xmath15-range with @xmath15 denoting for example a field variable or a momentum . choosing a number of support points  @xmath17 , a pde for  @xmath14 of the form @xmath18\\ ] ] ( where @xmath19 is some functional ) gets turned into a set of coupled odes of the form @xmath20 $ ] with @xmath21 and @xmath22 being the vector @xmath23 etc .. if the functional  @xmath19 involves integration over the position parameter ( as it often does ) , the computational effort needed to evaluate the right hand side once ( in order to numerically integrate the ode ) will grow quadratically with the number of support points . at the time of the first release of flowpy , choosing the number of support points @xmath24 somewhere between  20 and  100 and using a geometric distribution for the @xmath25 seems an appropriate choice for many problems",
    ".    an earlier prototype of flowpy , which was used to do the calculations underlying  @xcite , was only concerned with performing the ode integrations after @xmath15-discretization and required writing low level c code to specify the right hand side of the flow equation .",
    "it was soon found that this was a fairly tedious procedure that in particular needed some quite specific computing expertise beyond what may reasonably be expected from physicists wanting to solve rg flow equations .",
    "for this reason , the version of flowpy described here was extended with an equation parser and code generator that automatically translates flow equation specifications to machine code and then loads this for fast execution .",
    "this ` equation compiler ' is now the largest component of the flowpy package .",
    "a similar program package to automate the calculations of dyson - schwinger equations was presented in @xcite .",
    "flowpy needs the following packages to be pre - installed :    * python ( 2.@xmath15 with @xmath26 ) * scientific python ( scipy ) * the ` numpy ' package for specialized numerical arrays * the ` python - simpleparse ' parser generator package * a c compiler such as gcc ( the default compiler used by flowpy ) , as well as the python library header files ( especially ` python.h ` ) .",
    "if the python extension packages are installed into a location not normally searched by python , the environment variable ` pythonpath ` must be configured to include the installation - specific python extension module path ( e.g. ` $ home / lib / python2.7/site - packages ` ) .",
    "the source code that accompanies this article can be downloaded either together with the arxiv preprint source from    http://arxiv.org/e-print/1202.5984 ,    or through the ` ancilliary files ' link on arxiv .",
    "the distribution contains the flowpy code , a html documentation , license and installation information , and some examples .",
    "python header files are required by flowpy as it will use the c  compiler to translate user - specified equations to a compiled python extension module .",
    "this flowpy - generated c module refers to a number of low - level python definitions .",
    "on linux systems , these header files usually come in a package named ` python2.7-dev ` or similar .",
    "if these packages are installed and python is configured correctly , running ` python tests.py ` in a console in the project folder performs a test . if it is successful the output is similar to :    .... ...... ------------------------- ran 6 tests in 26.568s    ok    ....    users are strongly advised to perform this check in order to ensure flowpy has been installed and set up correctly before using it .",
    "a complete example showing basic use of flowpy is provided in the file ` demo.py ` .",
    "this shows how to compute a renormalization group flow from  @xmath27 to @xmath28 with  @xmath29 intermediate @xmath1-steps in geometric distribution for the flow equation @xmath30    the ` demo.py ` python code is shown in listing  [ fig : demopy ] .    when defining flow problems that involve double integration , it might make sense to check whether changing the order in which integrations are specified ( and hence performed ) makes a difference with respect to performance .",
    "depending on the nature of the problem , this can  in the present version of flowpy  have a major impact .    .... # demo.py from flowpy import grange , flowproblem , make_flow_logger , make_lhs_iterator      # note : triple - quote \" \" \" bounds multi - line python strings eqns= \" \" \" d / dk f(k , x ) =   integral[d q from 0 to k , d phi from -pi to pi ]    w(cminus(x^2-k^2,q , phi),cplus(x^2-k^2,q , phi))*(1 - 0.1*d / dk f(k , x ) ) ;     flowstart f(k , x)=1 ;    # = = = helper functions = = =    cminus(p1,p2,alpha ) = p1 ^ 2+p2 ^ 2 - 1*p1*p2*cos(alpha ) ; cplus(p1,p2,alpha ) = p1 ^ 2+p2 ^ 2 + 1*p1*p2*cos(alpha ) ;    w(a , b)=a*b/(p0 ^ 2+a^2+b^2 ) ;    # = = = constants = = = pi = 3.141592653587983 ; p0 = 2.0e5 ; \" \" \"    xs_plus = grange(0.1,100,7 ) # geometrically subdivided interval xs=[-xj for xj in xs_plus]+[0.0]+xs_plus # x - discretization    fp = flowproblem(\"demo_problem \" , # problem / project name                 xs ,              # position discretization                 equations = eqns , # the equations                 # perform 20 k - steps geometrically distributed                 # between 10 ^ 5 and 10^(-3 ) :                 ks = grange(1e5,1e-3,20 ) ,                 # log flow data to file :                 log_state = make_flow_logger(\"demo_problem.flow \" ) ,                 #                 # for implicit flow equations that involve                 # the lhs expression ( here d / dk f(k , x ) )                 # on the rhs : how to handle iterative determination                 # of a self - consistent rhs value :                 #                 decide_iterate = make_lhs_iterator(loops=0 ) ,                 #                 # --- discretization parameters below ---                 #                 # step size for higher - order numerical differentiation :                 eps_diff=1e-4 , # this also is the default .",
    "diff_ord=4 , # this also is the default .",
    "interpolation_kind=4 , # 4th order interp ( also default ) .",
    "verbose=2 , # verbose=0 turns off extra flow debug messages                 )    fp.flow ( )    # after this , data will be in the file \" demo_problem.flow \" .",
    "....    the flowpy package provides the ` flowproblem ` class as well as some auxiliary functions such as ` grange ` ( to produce a geometric distribution of numbers in a given range ) and ` linrange ` ( to produce an arithmetic distribution of numbers in a given range ) , ` make_flow_logger ` ( to produce an object that can be used as ` log_state ` parameter to the ` flowproblem ` constructor function ) and ` make_lhs_iterator ` ( to produce a decision function that can be used as ` decide_iterate ` parameter )",
    ". the only relevant method of the flow problem class is the ` obj.flow ( ) ` method that executes the solution of the problem .    in order to solve the flow equation , a ` flowproblem ` object",
    "is created .",
    "the default values for parameters are given in the following :    .... flowpy.flowproblem(problem_name ,                   xs ,                    equations ,                   ks = grange(1e5,1e-3,20 ) ,                   log_state = none ,                   eps_diff=1e-4 ,                   diff_ord=4 ,                   interpolation_kind=4 ,                    decide_iterate = make_lhs_iterator(eps_abs=1e-8 ) ,                   verbose=0 ,                    ) ....    the mandatory parameters to ` flowpy.flowproblem ( ) ` are :    [ cols= \" < , < \" , ]      as an example of a field dependent flow equation we consider supersymmetric quantum mechanics .",
    "this model describes an anharmonic oscillator coupled in a supersymmetric way to fermions .",
    "the flow equation is derived for the superpotential @xmath31 which enters in the scalar potential as @xmath32 .",
    "the flow equation for the superpotential reads @xcite : @xmath33 a python script to solve this equation is given in listing  [ fig : fielddependent ] .    .... # susy_qm.py import flowpy       susy_qm_eqns= \" \" \"      d / dk v(k , phi)=-v''(k , phi)/4/(v'(k , phi)+k)^2 ; flowstart v(k , phi ) = 1+m*phi+g*phi^2+a*phi^3 ;    # = = = parameters = = = m=1 ; g=0 ; a=1 ; \" \" \"    # change n_start and n_end to change the phi range n_start=-2    n_end=2 n_steps=10 # increase the number of sampling points to improve the resolution       xs = flowpy.linrange(n_start , n_end , n_steps )    logger = flowpy.make_flow_logger(filename=\"susy_qm.flow \" ) fp = flowpy.flowproblem(\"flowpy_susy_qm \" ,                    xs = xs ,                    equations = susy_qm_eqns ,                    log_state = logger ,                    decide_iterate = flowpy.make_lhs_iterator(loops=0 ) ,                    verbose=2 ,                    )    fp.flow ( ) ....    the solution to the flow equation is shown in fig .",
    "[ fig : susyqm ] .",
    "note that this picture was done with a resolution of ` n_step=40 ` .",
    "the results are consistent with those obtained with the ` ndsolve ` routine with mathematica 7 in @xcite .      as an example for a system of two coupled flow equations we consider supersymmetric quantum mechanics with field dependent wave function renormalization .",
    "as in the previous section , the flow equations with a field dependent wave function renormalization are discussed in @xcite .",
    "they read @xmath34 where we have introduced the abbreviations @xmath35 the python script to solve these equations is given in listing  [ fig : coupledde ] .",
    "the solutions are shown in fig  [ fig : susyqmwavefunction ] .",
    "this picture was created with ` n_steps=40 ` .",
    ", _ right panel : _ field dependent wave function [ fig : susyqmwavefunction],title=\"fig : \" ] , _ right panel : _ field dependent wave function [ fig : susyqmwavefunction],title=\"fig : \" ]    .... # susy_qm_wavefunction.py    import flowpy     susy_eqns= \" \" \" d / dk v(k , phi)=-v''(k , phi)*(z(k , phi)^2 + 2*k*z(k , phi)*d / dk z(k , phi ) )          /4/(v'(k , phi)+k*z(k , phi)^2)^2 ; d / dk z(k , phi)=(z(k , phi)+2*k*d / dk z(k , phi ) )          /4/(v'(k , phi)+k*z(k , phi)^2)^2          * ( 4*z'(k , phi)*v''(k , phi)/(v'(k , phi)+k*z(k , phi)^2 )              -z''(k , phi)*z(k , phi)-z'(k , phi)*z'(k , phi )              -3*z(k , phi)^2*v''(k , phi)^2/4/(v'(k , phi )                  + k*z(k , phi)^2)^2 ) ;    flowstart v(k , phi ) = e+m*phi+g*phi^2+a*phi^3 ; flowstart z(k , phi ) = 1 ;    # = = = = parameters = = = = e=1.0 ; m=1.0 ; g=0.1 ; a=1.0 ; \" \" \"        # change n_start and n_end to change the phi_range n_start=-2    n_end=2 n_steps=10 # increase this variable to improve the resolution    xs = flowpy.linrange(n_start , n_end , n_steps )    logger = flowpy.make_flow_logger(filename=\"susy_qm_wavefunction.flow \" )    fp = flowpy.flowproblem(\"flowpy_susy_qm_wavefunction \" ,                    xs = xs ,                    equations = susy_eqns ,                    log_state = logger ,                    decide_iterate = flowpy.make_lhs_iterator(loops=0 ) ,                    verbose=2 ,                    ) fp.flow ( ) ....      flowpy can also solve flow equations with full momentum dependence .",
    "in this example we calculate the momentum dependent wave - function renormalization for the supersymmetric @xmath36 wess - zumino model in two dimensions .",
    "this model is thoroughly discussed in @xcite where the flow equation is derived .",
    "the flow equation read @xmath37 where we have introduced the abbreviation @xmath38 @xmath39 and @xmath40 denote two dimensional vectors , whereas @xmath41 and @xmath42 respectively .",
    "a python script to solve this equation with @xmath43 and @xmath44 is given in listing  [ fig : demowavefunction ] .",
    "note that due to the complex structure of the flow equation this script takes a long time to calculate the wave function even with a very low resolution of five sampling points .",
    "the result is shown in fig .",
    "[ fig : wesszuminowavefunction ] .",
    "the calculation was done with ` n_steps=30 ` .    ....",
    "# momentum_dependent_wavefunction.py import flowpy import math    wavefunction_eqns= \" \" \" d / dk z(k , p ) =   integral[d phi from -pi to pi ,            d q from 0 to k ]            ( -16*g^2)/4/pi^2*(k*z(k , q)+m)*z(k , q)*z(k , cminus(p , q , phi ) )            * ( 1+k*d / dk z(k , q))/(q*q*z(k , q)*z(k , q)+(k*z(k , q)+m)*(k*z(k , q)+m ) )            /(cminus(p , q , phi)*cminus(p , q , phi)*z(k , cminus(p , q , phi ) )            * z(k , cminus(p , q , phi))+(k*z(k , cminus(p , q , phi))+m )            * ( k*z(k , cminus(p , q , phi))+m ) )            /(q*q*z(k , q)*z(k , q)+(k*z(k , q)+m)*(k*z(k , q)+m))^2 ;      flowstart z(k , p ) = 1 ;    # = = = helper functions = = =    cminus(p1,p2,alpha ) = p1 ^ 2+p2 ^ 2 - 2*p1*p2*cos(alpha ) ;    # = = = parameters = = = m = 1.0 ; g=0.3 ; pi=3.141592653589793 ; \" \" \"    # change n_start and n_end to change the p_range n_start=-20    n_end=10 n_steps=5 # increase this number of sampling points to improve the resolution    # logarithmic - equidistant distribution of the momentum : qs_log = flowpy.linrange(n_start , n_end , n_steps ) qs=[-math.exp(q ) for q in qs_log]+[0.0]+[math.exp(q ) for q in qs_log ]    # specifing the logfile : logger = flowpy.make_flow_logger(filename=\"momentum_dependent_wavefunction.flow \" )     # solving the flow equation : fp = flowpy.flowproblem(\"flowpy_wavefunction \" ,                    xs = qs ,                    equations = wavefunction_eqns ,                    log_state = logger ,                    decide_iterate = flowpy.make_lhs_iterator(loops=0 ) ,                    verbose=2 )    fp.flow ( ) ....      in some situations , one would want to perform a number of renormalization group flow calculations that differ only in the choice of some parameters . while this can be achieved in a reasonably straightforward way with flowpy via python scripting",
    ", the flowpy package contains a few extra definitions to make this process more convenient for the user , which are explained by means of an example in listing  [ fig : parametric ] .    .... # parametric.py from flowpy import flowproblem , flowparams , make_lhs_iterator,\\       grange , make_flow_logger    runs_todo=[flowparams(mu = val_mu , t = val_t )               for val_mu in [ 1.0,1.5,2.0,2.5 ]               for val_t in [ 0.1,0.2,0.5,1.0 ] ]    xs=[float(n ) for n in range(11 ) ]    for params in runs_todo :      f = flowproblem(\"mu_t \" ,                    xs = xs ,                    equations= \" \" \"                    d / dk f(k , p ) = -t ;                    flowstart f(k , p ) = mu ;                    \" \" \" + params.defs ( ) ,                    ks = grange(110,10,5 ) ,                    decide_iterate = make_lhs_iterator(loops=0 ) ,                    log_state = make_flow_logger(\\                        params.subs_short(\"flow__mu=${mu}_t=${t}__.flow \" ) ) ,                    verbose=2 )      f.flow ( ) ....    the key concept here is the ` flowparams ` `` flowpy parameters '' object .",
    "this represents a collection of parameter choices that can easily be mapped to strings in various contexts , e.g. to generate systematic output filenames .",
    "a ` flowparams ` object is created by specifying explicitly all `` parameter name = numerical value '' associations in a function call of the form    .... params = flowparams(mu=1.5 , alpha=3.0 , t=0.5 ) ....    a potentially relevant limitation is that special keywords in the python programming language ( such as e.g. ` def ` , ` raise ` , ` lambda ` , ` else ` , etc . )",
    "can not be chosen as parameter names .",
    "( there is a way to avoid this problem in python by using a different function call form , should this really turn out to be a problem . )",
    "if ` params ` is a flowpy parameter object , e.g. defined as in the example in listings  [ fig : parametric ] , then ` params.defs ( ) ` will produce a string containing valid flowpy constant definitions that introduce these parameters .",
    "one would typically want to append this to the ( parameter - dependent ) flow equation definitions by using python `` string addition '' as shown in the example .",
    "another useful snippet is ` params.subs_short(pattern ) ` which will regard ` pattern ` as a template string on which parameter substitution has to be performed according to the rules of python s ` string.template ` class , i.e. ` $ { xyz } ` will be substituted by the pretty - printed numerical value of the parameter ` xyz ` .",
    "( detailed rules can be found in the python documentation of the ` string.template ` mechanism . )",
    "one may want to use this to automatically generate filenames , as shown in the example .",
    "a very useful python feature one might want to employ in such situations is special syntax available to define lists from cartesian products . in python",
    ", one can e.g. write    ....   [ ( x , y ) for x in range(1,5 ) for y in range(1,x ) ] ....    to obtain the list    .... [ ( 2 , 1 ) , ( 3 , 1 ) , ( 3 , 2 ) , ( 4 , 1 ) , ( 4 , 2 ) , ( 4 , 3 ) ] ....    this syntax , which is an adoption of a very similar feature that probably was first made popular through the haskell programming language , can be used to concisely specify fairly complex constructions , such as    .... from fractions import gcd [ ( x , y , x*y ) for x in range(5 ) for y in range(5 ) if gcd(x , y)==1 ] ....    which gives the list    .... [ ( 0 , 1 , 0 ) ,   ( 1 , 0 , 0 ) ,   ( 1 , 1 , 1 ) ,   ( 1 , 2 , 2 ) ,   ( 1 , 3 , 3 ) ,   ( 1 , 4 , 4 ) ,   ( 2 , 1 , 2 ) ,   ( 2 , 3 , 6 ) ,   ( 3 , 1 , 3 ) ,   ( 3 , 2 , 6 ) ,   ( 3 , 4 , 12 ) ,   ( 4 , 1 , 4 ) ,   ( 4 , 3 , 12 ) ] ....    users of flowpy might find the basic form of this construct useful to define cartesian products of parameter choices , as in the example provided in this section .    evidently , if the approach shown here is used to perform  @xmath45 different numerical renormalization group flow calculations , then  @xmath45 different machine code files will be produced automatically by flowpy and loaded into python . although this process could be improved conceptually , this would presumably be only worthwhile for @xmath46 .",
    "this is unlikely to be relevant for typical applications , as problems of typical complexity are expected to be partitioned into collections of @xmath47 before being submitted to a computing cluster anyway . when performing multiple flowpy calculations on a cluster",
    ", one should ensure that each cluster job chooses a different name when defining a flowproblem .",
    "otherwise , this may result in accidental unintended sharing of the directory used to produce machine code , and some calculations may fail or , even worse , end up using a wrong set of parameters and equations . typically , an unique job  i d will be taken from the program s argument list , from environment variables , or generated semi - randomly using the time and process i d .",
    "python makes this information available via the ` sys.argv ` variable containing program arguments ( the ` sys ` module has to be imported first ) , the ` os.getenv ( ) ` function that behaves like the corresponding c library function , the ` time.time ( ) ` and related functions , and the ` random ` module .",
    "in its present form , the flowpy package has a number of limitations .",
    "none of these are actually fundamental ",
    "they all could be overcome with some dedicated effort on the side of the flowpy authors .",
    "concerning the question how relevant these are , and where to focus further development effort on , the authors seek input from the renormalization group flow community .",
    "present limitations are :    * flowpy assumes every flow function to depend on precisely one extra parameter beyond the scale parameter  @xmath1 .",
    "* the right - hand side of flow functions may involve zero to two integrals , and the integration boundaries may only depend on left - hand side parameters , i.e. the inner integration boundary can not depend on the value of the outer integration parameter .",
    "also , term notation presently requires integral specifications to follow the equals sign directly , i.e. all extra factors must be pulled under the integral .",
    "expressions such as @xmath48 ( with @xmath49  a numerical constant ) hence must be re - written as @xmath50 .",
    "* currently boundary conditions in the @xmath15 direction are fixed to the classical values of the effective potential .",
    "however , more flexible boundary conditions that can be specified by the user might be more appropriate for some problems . *",
    "the range of special functions made available to the user so far is fairly limited .",
    "* error reporting could be improved to make it easier to find typos in the specification of the flow equations .",
    "* flowpy suffers from some minor bugs in the default parser definitions inherited from ` python - simpleparse ` .",
    "in particular , a number such as `` 5e-3 ` ' is not a valid constant  this must be given as `` 5.0e-3 ` ' instead . *",
    "this version of flowpy does not support parallelization .",
    "however , re - introducing mpi support is planned .",
    "* there are many opportunities to make flowpy more efficient by improving its internal design .",
    "this , however , will require substantial low level changes .",
    "in this paper we present the numerical toolbox flowpy which is able to solve many typical partial differential equations encountered in studies of the functional renormalization group .",
    "we hope that it will prove to be useful in the application of functional renormalization group techniques and that it will facilitate these studies in providing a powerful numerical tool to solve the differential equations .",
    "we plan to include mpi support in the next version of flowpy .",
    "additionally it is planned to make the boundary conditions in the field variable more flexible such that it will be possible to use e.g. the first loop approximation .",
    "also there is a lot of room for improvement in the performance of the parser . here",
    "we present the first version of flowpy and we have planned to release updates in the future . the intention of this paper is to make flowpy available to a wider audience .",
    "thus we are grateful for suggestions how to improve flowpy .",
    "the authors would like to thank j.  braun , h.  gies and a.  wipf for helpful discussions and valuable comments on the manuscript .",
    "also , the authors would like to thank max albert for helping with the effort to port flowpy to the mac os x platform .",
    "part of this work was supported by the german science foundation ( dfg ) under grk 1523 and the studienstiftung des deutschen volkes e.v ."
  ],
  "abstract_text": [
    "<S> flowpy is a numerical toolbox for the solution of partial differential equations encountered in functional renormalization group equations . </S>",
    "<S> this toolbox compiles flow equations to fast machine code and is able to handle coupled systems of flow equations with full momentum dependence , which furthermore may be given implicitly . </S>"
  ]
}