{
  "article_text": [
    "the _ byzantine agreement problem _ , introduced in 1980 by pease , shostak , and lamport @xcite , has emerged as one of the most fundamental problems in distributed computing .",
    "the problem is easy to describe : each process has an input value ; the goal is for all processes to agree on a consensus value that is an input value of one of the processes .",
    "the challenge lies in reaching agreement despite the presence of faulty processes .",
    "many variants of the problem have been studied .",
    "after three decades of extensive research , tight bounds have been obtained for almost all of the variants , with one significant exception : _ asynchronous byzantine agreement _ , where communication channels between processes have unbounded delay ( although messages are guaranteed to arrive eventually ) , and the faulty processes are malicious in an arbitrary way ( though nonfaulty processes have secure private channels ) .    an execution of a byzantine agreement protocol is _ nonterminating _ if some nonfaulty process does not output a value .",
    "the celebrated result of fischer , lynch , and paterson @xcite shows that any protocol that never reaches disagreement ( i.e. , has no executions where two nonfaulty processes output different values ) must have some nonterminating executions . for a protocol that never reaches disagreement ,",
    "the best we can hope for is that the set of nonterminating executions has probability 0 .",
    "we say such protocols are _ almost - surely terminating_. ben - or @xcite showed that almost - surely terminating asynchronous byzantine agreement can be achieved as long as @xmath3 , where @xmath0 is the number of processes in the system and @xmath1 is a bound on the number of faulty processes . however , his protocol required an expected number of rounds that is exponential in @xmath0 .",
    "this started a lengthy sequence of research on asynchronous byzantine agreement ; see , for example , @xcite .",
    "it is well known that byzantine agreement for @xmath0 processes can not be reached if @xmath4 @xcite .",
    "therefore the best resilience one can hope for is @xmath2 .",
    "we will call such protocols _ optimally resilient_. bracha @xcite provides an almost - surely terminating protocol that is optimally resilient .",
    "however his protocol does not scale well with the size of the system , since , like ben - or s , the expected number of messages and rounds is exponential in @xmath0 .",
    "feldman and micali @xcite provide a byzantine agreement protocol for the synchronous model with optimal resilience and constant expected running time .",
    "they extend their result to the asynchronous model , where they provide a polynomial - time algorithm that almost - surely terminates , but does not have optimal resilience ; their protocol requires that @xmath5 .",
    "canetti and rabin @xcite provide a protocol that is optimally resilient @xmath6 and polynomially efficient .",
    "their result uses ideas from rabin and ben - or @xcite on verifiable secret sharing ( vss ) in synchronous systems equipped with a broadcast channel .",
    "the techniques of @xcite have an inherent nonzero probability of failure ; as a result , in the asynchronous implementation of @xcite , the protocol is not almost - surely terminating .",
    "indeed , in @xcite , the authors explicitly highlighted the problem of finding a protocol that simultaneously achieves optimal resilience , almost - sure termination , and polynomial efficiency .",
    "up to now , despite repeated efforts , this has not been done .",
    "the main result of this paper is to provide such a protocol .",
    "pretty much all protocols following bracha s @xcite used his idea of reducing the problem of byzantine agreement to that of implementing a shared coin .",
    "we do that as well .",
    "we obtain a shared coin using an approach that goes back to feldman and micali @xcite , who essentially reduce the problem of efficiently implementing a shared coin to that of efficiently implementing vss . roughly speaking",
    ", the secrets in vss are used to generate a shared coin .",
    "we refer the reader to canetti s thesis @xcite ( chapters 4 and 5 ) for a comprehensive account of the rather complex reduction from vss to byzantine agreement in the asynchronous model",
    ".    the protocol of canetti and rabin  @xcite also uses the reduction from verifiable secret sharing to byzantine agreement .",
    "the only reason that their protocol is not almost - surely terminating is that they use a protocol that they call asynchronous verifiable secret sharing ( avss ) , which has a small ( but nonzero ) probability of not terminating .",
    "our protocol has essentially the same structure as the canetti - rabin protocol .",
    "indeed , it uses the same reduction from avss to byzantine agreement as in @xcite , except that the use of avss is replaced by a variant of avss that we call _ shunning ( asynchronous ) verifiable secret sharing _ ( ) . which is guaranteed to terminate almost - surely .    to explain the properties of",
    ", we first review the properties of standard vss ( verifiable secret sharing ) .",
    "vss involves a dealer who has a value to share , which we think of as the dealer s secret .",
    "it has two key properties , known as _ validity _ and _ binding_. informally , the validity property guarantees that , if the dealer is nonfaulty , then all nonfaulty processes will reconstruct the dealer s value ; the binding property guarantees that a faulty dealer must commit to a value during what is called the _ share phase _ of the protocol .",
    "our scheme has weaker validity and binding properties .",
    "specifically , we require that in each invocation where the validity or binding properties do not hold , at least one nonfaulty process ignores at least one new faulty process from that invocation on .",
    "the key observation is that this limits the adversary to breaking the validity and binding properties at most a polynomial number of times .",
    "the protocol uses a weaker protocol called _ moderated weak shunning ( asynchronous ) vss _ ( ) .",
    "the protocol is a variant of vss with a dealer and an additional entity called a _",
    "moderator_. in the dealer has some input value @xmath7 and the moderator has some input value @xmath8 .",
    "the nonfaluty moderator s task is to enforce during the share phase that the value that the dealer shares is @xmath8 ( hence @xmath9 if both are nonfaulty ) .",
    "the initials mws characterize how differs from standard vss :    * moderated*. a faulty dealer must commit to the value of the nonfaulty moderator in order to complete the share protocol .",
    "( katz and koo @xcite use a moderator for vss in a somewhat similar way . )",
    "* weak*. as in _ weak vss _",
    "@xcite , the binding property of vss is weakened so that each process reconstructs either the committed value or a default value ( denoted @xmath10 ) .",
    "* shunning*. like , it is possible that neither validity nor the weaker binding property hold , but in that case at least one nonfaulty process ignores at least one new faulty process from this stage on .    as in the vss scheme used in @xcite ,",
    "the scheme starts with a dealer who shares a degree-@xmath1 bivariate polynomial @xmath11 such that @xmath12 is the secret .",
    "each process @xmath13 gets @xmath14 values of each of the polynomials @xmath15 and @xmath16 , which is enough to reconstruct them , since they both have degree @xmath1 .",
    "then , roughly speaking , each pair @xmath17 of processes uses to commit to @xmath18 and @xmath19 .",
    "this ensures that if either @xmath13 or @xmath20 is nonfaulty then the reconstructed values of the protocol will be either @xmath10 or the required values ( @xmath18 , @xmath19 ) .",
    "we then use this fact to prove the properties of the protocol .",
    "the key property of the protocol is its use of a fault - detection mechanism .",
    "the mechanism has the property that a nonfaulty process might not explicitly know it has detected a faulty process .",
    "the only guarantee is that it will act as if it has detected a faulty process , by ignoring all messages from the detected process for the rest of the protocol .",
    "this behavior is somewhat reminiscent of the failure detector @xmath21 @xcite in the sense that a nonfaulty process might reach a state of permanently suspecting a faulty process without being explicitly aware of this fact .",
    "since the details of the protocol are somewhat technical , we refer the reader to for a high - level description .",
    "the rest of this paper is organized as follows . in section",
    "[ sec : properties ] , we state the properties of and . in section",
    "[ sec : mwfd - avss ] , we provide an implementation of and prove that it has the required properties . in section  [ sec : fd - avss ] , we do the same for , using as a subroutine . a description of bracha s _ reliable broadcast _ protocol , which we use as a subroutine , is given in the appendix .",
    "as we mentioned above , in , if either the binding property or the validity property does not hold , then a new faulty process is ignored in all future invocations by some nonfaulty process . to implement this",
    ", each process needs to keep track of the processes it knows to be faulty .",
    "thus , the scheme actually has two components : a _ detection and message management protocol _ ( protocol ) and a _ vss protocol_. each process uses its protocol to decide which messages to discard , which to ignore for now , and which to act on , and to keep track of the processes it knows to be faulty .",
    "the protocol is invoked when the scheme is initialized , and then runs indefinitely and concurrently with all the invocations of the vss protocols .",
    "the vss protocol may be invoked a number of times while the scheme runs , and several invocations may be running concurrently . the vss protocol is composed of a pair of protocols @xmath22 ( for _ share _ ) and @xmath23 ( for _ reconstruct _ ) .",
    "these protocols are called separately ; @xmath23 is never called unless @xmath22 completes , but @xmath23 may not be called at all even if @xmath22 completes .",
    "we associate with each vss invocation a unique session identifier @xmath24 that is composed of a counter @xmath25 and the dealer s identifier @xmath13 .",
    "we tag all events of that invocation with its session identifier , so that it is always clear which invocation of the vss protocol an event belongs to .",
    "we say that a vss invocation has _ completed for process @xmath20 _ if process @xmath20 completed the reconstruct associated with that session . given a process @xmath20 and two vss invocations with session identifiers @xmath24 and @xmath26",
    ", we write @xmath27 if process @xmath20 completes the invocation of the vss @xmath24 before process @xmath20 begins the invocation of the vss @xmath26 .    as we said in the introduction ,",
    "our vss scheme is _",
    "shunning_. process @xmath13 may start shunning @xmath20 well before @xmath13 is sure that @xmath20 is faulty ; indeed , @xmath13 may shun @xmath20 without ever knowing that @xmath20 is faulty .",
    "process @xmath20 is _ shunned _ by process @xmath13 starting in session @xmath28 of ( resp .",
    ", ) if process @xmath13 does not ignore some message from @xmath20 during session @xmath28 , but ignores or discards all messages from @xmath20 associated with every session @xmath29 of ( resp .",
    ", ) such that @xmath30 .",
    "each vss invocation has one process @xmath31 designated as the _ dealer _ ; the dealer has some input value @xmath7 . for ease of exposition",
    ", we do not include the session identifier in our description of the properties of the vss protocol when they are clear from the context , although we do include them in the description of the protocols .",
    "each vss invocation must satisfy the following properties ( in runs with at most @xmath1 faulty processes ) ; we call these the _ _ properties",
    ".    * validity of termination*. if a nonfaulty dealer initiates protocol @xmath22 , then each nonfaulty process will eventually complete protocol @xmath22 .    *",
    "termination*. if a nonfaulty process completes protocol @xmath22 , then all nonfaulty processes will eventually complete protocol @xmath22 .",
    "moreover , if all nonfaulty processes begin protocol @xmath23 , then all nonfaulty processes will eventually complete protocol @xmath23 ( note , however , that if only some but not all nonfaulty processes begin protocol @xmath23 , then there is no termination requirement ) .",
    "* binding*. once the first nonfaulty process completes an invocation of @xmath22 with session i d @xmath32 , there is a value @xmath33 such that either    the output of each nonfaulty process that completes protocol @xmath23 is @xmath33 ; or    there exists a nonfaulty process @xmath13 and a faulty process @xmath20 such that @xmath20 is shunned by @xmath13 starting in session @xmath32 .    *",
    "validity*. if the dealer is nonfaulty , then either    the output of each nonfaulty process that completes protocol @xmath23 is @xmath7 ; or    there exists a nonfaulty process @xmath13 and a faulty process @xmath20 such that @xmath20 is shunned by @xmath13 starting in session @xmath32 .    * hiding*. if the dealer is nonfaulty and no nonfaulty process invokes protocol @xmath23 , then the faulty processes learn nothing about the dealer s value      in order to implement the vss protocol , we use a weaker protocol called _ moderated weak shunning ( asynchronous ) vss _ ( ) . just as vss , the protocol is composed of a share protocol @xmath34 and a reconstruction protocol @xmath35 . as in weak vss , we weaken the binding property so that each nonfaulty process reconstructs either @xmath33 or @xmath10 .",
    "but now , in addition to having one process @xmath31 designated as the dealer , there is an additional process designated as the _ moderator_.",
    "both the dealer and the moderator have ( possibly different ) input values , denoted @xmath7 and @xmath8 , respectively .",
    "each invocation must satisfy termination and validity , just like vss , and the following variants of the properties of vss ( in runs with at most @xmath1 faulty processes ) ; we call these the _ _ properties .",
    "* moderated validity of termination*. if a nonfaulty dealer initiates protocol @xmath34 , the moderator is nonfaulty , and @xmath9 , then each nonfaulty process will eventually complete protocol @xmath34 .    *",
    "weak and moderated binding*. once the first nonfaulty process completes an invocation of protocol @xmath34 with session i d @xmath32 , there is a value @xmath33 ( possibly @xmath10 ) such that    if the moderator is nonfaulty , then @xmath36 .",
    "in addition , either    the output of each nonfaulty process that completes protocol @xmath35 is either @xmath33 or @xmath10 ; or    there exists a nonfaulty process @xmath13 and a faulty process @xmath20 such that @xmath20 is shunned by @xmath13 starting in session @xmath32 .    * moderated hiding*. if the dealer and moderator are nonfaulty and no nonfaulty process invokes protocol @xmath35 , then the faulty processes learn nothing about the dealer s value .",
    "it might seem surprising that in the second condition of validity and ( weak and moderated ) binding , we talk about shunning rather than just saying that a faulty process is detected .",
    "the reason is that , as we show in example  [ xam : shunning ] ( after we give the implementation of the protocol ) , it is possible that two nonfaulty processes will complete an invocation of the protocol with different values without ( explicitly ) detecting a new faulty process ; however , in that case , at least one of them will shun a faulty process that was not shunned before .",
    "in this section , we provide an implementation of and . we start with a high - level description of both .",
    "both protocols use the reliable broadcast protocol ( rb ) of bracha @xcite .",
    "rb guarantees that messages are indeed broadcast ; if a nonfaulty sender sends a message @xmath37 , then all nonfaulty processes eventually receive @xmath37 , and nothing else .",
    "( the properties of rb are stated carefully in the appendix , where , for completeness , an implementation is provided . )",
    "we assume that the dealer creates @xmath38 degree-@xmath1 polynomials @xmath39 over some finite field @xmath40 with @xmath41 such that @xmath42 is the secret ( i.e. , @xmath43 ) and @xmath44 .",
    "then the dealer shares the polynomials @xmath45 and also gives each process @xmath20 the polynomial @xmath46 .",
    "we can think of process @xmath20 as a potential `` monitor '' for @xmath46 .",
    "the dealer shares the polynomial @xmath46 by sending each process @xmath47 the value @xmath48 .",
    "this means that , if the dealer is correct , any @xmath14 nonfaulty processes can reconstruct @xmath46 .",
    "in addition , the dealer sends @xmath49 to the moderator .",
    "each process @xmath47 that receives @xmath48 sends this value to @xmath20 and broadcasts a confirmation . in this case",
    ", we can think of process @xmath47 as a `` confirmer '' for @xmath48 .",
    "when @xmath20 receives confirmations and values that agree with the polynomial @xmath46 sent by the dealer from at least @xmath50 processes , @xmath20 becomes a `` monitor '' for @xmath46 , sends @xmath51 to the moderator , and broadcasts the set @xmath52 of at least @xmath50 confirmers whose value it accepted .",
    "intuitively , each monitor @xmath20 is responsible for validating the value of one point on the polynomial @xmath49 , namely , @xmath53 .",
    "when the moderator receives at least @xmath50 values all of which agree with the polynomial @xmath49 from different monitors and receives confirmations from their associated @xmath52 sets , then the moderator broadcasts the set of @xmath50 monitors indexes it accepted .",
    "the dealer broadcasts a confirmation when it learns that the moderator , its monitors , and their confirmers have acted in a nonfaulty manner .",
    "this allows nonfaulty processes to know which confirmers they need to wait for in order to complete their execution of the share protocol .    in the reconstruct phase ,",
    "processes send their values using the rb protocol .",
    "if the dealer is nonfaulty , then it can check the values sent by all processes and detect faulty processes . if the dealer is faulty , then there are at least @xmath14 nonfaulty monitors @xmath54 that can monitor their polynomial @xmath55 .",
    "if they do not detect problems with their confirmers , then the weak binding property must hold .",
    "we now explain how processes shun other processes if a problem is detected .",
    "before a process @xmath13 `` sees '' a message in the protocol ( or the protocol that we present later ) , the message is filtered by the dmm protocol .",
    "the @xmath56 protocol decides whether to discard the message , ignore it for now , or pass it on for action . in order to do this",
    ", @xmath56 must maintain a number of data structures .",
    "first , it maintains the partial order @xmath57 on sessions described above , where @xmath58 if @xmath13 started the share protocol of vss session @xmath59 after completing the reconstruct protocol of vss session @xmath60 .",
    "in addition , the @xmath56 protocol uses a variable @xmath61 that represents a set of processes .",
    "intuitively , the processes in @xmath61 are ones known by @xmath13 to be faulty . any message sent by a process @xmath62",
    "is discarded by @xmath13 . to decide which messages",
    "to ignore for now and which to pass on for action , @xmath56 maintains two arrays .",
    "the first array , denoted @xmath63 , consists of tuples in @xmath64 . intuitively , @xmath65 if @xmath13 is expecting to receive a broadcast sent by @xmath20 using rb saying @xmath66 as part of a vss session @xmath24 ( thus , this is a session for which @xmath13 is the dealer ) .",
    "the second array , denoted @xmath67 , consists of tuples in @xmath68 . intuitively , @xmath69 if @xmath13 is expecting to receive a message broadcast by @xmath20 ( using rb ) saying @xmath70 as part of vss session @xmath71 . both @xmath63 and @xmath67 are initially empty .",
    "we will explain how tuples are added to @xmath63 and @xmath67 when we describe the protocol .",
    "process @xmath13 ignores ( that is , saves but does not act on ) all messages from process @xmath20 that are part of a session @xmath72 such that either @xmath73 and @xmath74 or @xmath75 and @xmath76 .",
    "that is , newer messages from @xmath20 are ignored by @xmath13 if @xmath13 is expecting to receive something from @xmath20 that it has not yet received . when a message that @xmath13 expects to hear from @xmath20 that is associated with either with @xmath73 or with @xmath75 , then the relevant tuple is removed from @xmath63 or @xmath67",
    ". once there are no messages that @xmath13 expects to hear from @xmath20 from a session that precedes @xmath72 , then the @xmath56 protocol enables the protocol to act on messages from session @xmath72 .",
    "finally , process @xmath20 is added to @xmath61 if a message is received from @xmath20 that is inconsistent with what is expected according to a tuple in @xmath63 or @xmath67 .",
    "for example , if @xmath73 and @xmath13 receives a message as part of session @xmath24 from @xmath20 saying @xmath77 , with @xmath78 , then @xmath20 is added to @xmath61 , and messages sent by @xmath20 in all sessions @xmath72 such that @xmath79 will be discarded by @xmath13 .",
    "we now show how to implement .",
    "we start with the share protocol @xmath80 .",
    "we assume that the field @xmath40 being used is common knowledge and @xmath41 . in the @xmath34 protocol ( and a number of our later protocols )",
    ", we have variables that are tagged by the session i d @xmath32 . if the session i d is clear from context , we omit it .      1 .",
    "if a dealer @xmath13 wants to invoke @xmath34 with a secret @xmath7 it first updates @xmath25 to @xmath81 and then selects @xmath38 random degree-@xmath1 polynomials @xmath82 over field @xmath40 such that @xmath83 and @xmath44 for all @xmath84 .",
    "it sends each process @xmath20 a message @xmath85 .",
    "in addition , it sends each process @xmath54 a message @xmath86 ( note that this allows @xmath54 to compute @xmath55 , so we sometimes say `` @xmath54 receives @xmath55 '' in this message ) , and sends the moderator yet another message , @xmath87 ( so that the moderator can compute @xmath49 ) .",
    "if process @xmath20 receives values @xmath88 and polynomial @xmath89 from a dealer @xmath13 in session @xmath24 , then , for each process @xmath54 , @xmath20 sends @xmath90 to @xmath54 .",
    "( note that @xmath91 is supposed to be @xmath92 , but if the dealer is faulty , it may not be .",
    "we continue to use the notation @xmath93 and @xmath91 to denote the polynomials and values actually received . )",
    "it also broadcasts @xmath94 to all processes using rb .",
    "3 .   if process @xmath20 receives @xmath95 and @xmath94 from process @xmath54 , receives @xmath96 from the dealer @xmath13 , and @xmath97 , it adds @xmath98 to @xmath99 .",
    "intuitively , the message @xmath97 provides confirmation to @xmath20 that the dealer sent @xmath100 to both @xmath20 and @xmath54 .",
    "the fact that @xmath20 adds @xmath101 to @xmath99 means that @xmath20 expects @xmath54 to confirm publicly ( using rb ) that indeed it received @xmath102 from the dealer @xmath13 , which is what @xmath54 told @xmath20 privately .",
    "4 .   let @xmath103 .",
    "if @xmath104 , then @xmath20 sends @xmath105 to all processes using rb , it also sends @xmath106 to the moderator .",
    "intuitively , if @xmath107 , then @xmath20 has gotten as much confirmation as it can expect to get that the dealer @xmath13 correctly shared the polynomial @xmath46 . by broadcasting @xmath52 , it is broadcasting the set of processes from which it expects to hear public confirmation of this fact . by sending @xmath108 to the moderator",
    ", @xmath20 is giving the moderator a share of the information that the moderator needs for computing the secret .",
    "if the moderator receives @xmath109 from the dealer , @xmath110 and @xmath111 from process @xmath20 , and @xmath94 message from all processes @xmath112 , @xmath113 , and @xmath114 , the moderator adds @xmath20 to the set @xmath115 , which is initialized to @xmath116 . intuitively , if the values that the moderator receives from @xmath20 are compatible with the values the moderator received from the dealer , and the dealer s values are compatible with the moderator s value @xmath8 , then the moderator adds @xmath20 for the session @xmath24 to @xmath117 . 6 .",
    "if @xmath118 , the moderator sends @xmath119 to all processes using rb . 7 .",
    "if the dealer @xmath13 receives @xmath120 from the moderator , receives @xmath111 from each process @xmath121 , and receives @xmath94 from each process @xmath112 such that @xmath122 , then it adds @xmath123 to @xmath63 for all @xmath124 and @xmath112 , and sends @xmath125 using rb .",
    "note that if the moderator is nonfaulty and it sends these messages to the dealer , then it really did receive @xmath111 from each process @xmath121 and @xmath94 from each process @xmath54 in @xmath126 , and these messages were sent using rb .",
    "thus , the dealer will eventually receive all these messages too and , if nonfaulty , will broadcast the @xmath127 message .",
    "if process @xmath20 receives @xmath120 from the moderator and @xmath128 then @xmath20 removes from @xmath99 all entries of the form @xmath129 that are associated with session @xmath24 . intuitively , since @xmath130 for session @xmath24 , we do not care about the values of @xmath46 for this session .",
    "if process @xmath20 receives an @xmath125 message from the dealer , @xmath120 from the moderator , @xmath131 from each process @xmath132 , and @xmath94 from each @xmath133 such that @xmath134 , it completes this invocation of the share protocol @xmath34 .      1 .",
    "if process @xmath135 for @xmath132 , then @xmath20 broadcasts @xmath136 using rb , where @xmath137 is what @xmath20 received from the dealer at step 2 of @xmath34 .",
    "2 .   process @xmath20 initializes @xmath138 to @xmath116 for each process @xmath54 for which it has received a set @xmath139",
    ". if @xmath20 receives a message @xmath140 from process @xmath47 at step 1 , and @xmath133 , then @xmath20 adds @xmath141 to @xmath142 .",
    "intuitively , @xmath141 should be the point @xmath143 on the polynomial @xmath144 .",
    "3 .   if @xmath145 , then @xmath20 finds the unique degree @xmath1 polynomial @xmath146 that interpolates the points in @xmath147 .",
    "4 .   after computing @xmath146 for all @xmath148",
    ", @xmath20 tries to interpolate a polynomial @xmath149 such that @xmath150 for all @xmath132 .",
    "if @xmath149 exists , @xmath20 outputs @xmath151 ; otherwise , @xmath20 outputs @xmath10 .",
    "we now describe the implementation of @xmath56 .",
    "* protocol @xmath56 *    initialize an empty set of processes @xmath61 , an empty array @xmath63 consisting of tuples in @xmath152 , and an empty array @xmath67 consisting of tuples in @xmath153 . as we said earlier , intuitively , @xmath65 if @xmath13 is expecting to receive a broadcast sent by @xmath20 using rb saying @xmath66 as part of vss session @xmath24 and @xmath69 if @xmath13 is expecting to receive a message broadcast by @xmath20 using rb saying @xmath70 as part of vss session @xmath71 .    if @xmath154 and a broadcast message @xmath155 is received then    if @xmath156 , then remove @xmath157 from @xmath63 ;    otherwise , add @xmath20 to @xmath61 .",
    "( see line 7 of protocol @xmath34 for the condition that causes a tuple @xmath158 to be added to @xmath63 . )    if @xmath69 and a broadcast message @xmath159 is received , then    if @xmath156 then remove @xmath160 from @xmath67 ;    otherwise , add @xmath20 to @xmath61 .",
    "( see line 3 of protocol @xmath34 for the condition that causes a tuple @xmath161 to be added to @xmath67 . )",
    "if a message sent from @xmath20 is received and @xmath62 , then discard the message .    if a message with session identifier @xmath26 sent from @xmath162",
    "is received , then delay this message if there is a tuple @xmath154 such that @xmath163 or a tuple @xmath69 such that @xmath164 .",
    "if there is no such tuple in @xmath63 or @xmath67 ( or after all such tuples have been removed ) , then forward the message to the vss invocation of session @xmath26 .",
    "we now show that the protocol satisfies the properties . to do this , we first must establish two key properties of the protocol .",
    "[ lem : dmm ] if @xmath13 is nonfaulty , then @xmath56 satisfies the following two properties :    if @xmath62 , then @xmath20 is a faulty process ;    if @xmath20 is nonfaulty , @xmath65 ( resp . , @xmath69 ) , and all nonfaulty processes complete session @xmath24 ( resp .",
    "@xmath28 ) , then eventually @xmath165 is removed from @xmath63 ( resp .",
    ", @xmath160 is removed from @xmath67 ) .    for part ( a ) ,",
    "note that the only reason that @xmath13 adds @xmath20 to @xmath61 is if @xmath154 ( resp . , @xmath69 ) and",
    "the protocol detects that process @xmath20 sent a message @xmath166 ( resp . ,",
    "@xmath167 ) using rb such that @xmath168 ( resp . , @xmath169 ) .",
    "if @xmath20 is nonfaulty then @xmath170 ( resp . , @xmath171 ) , hence @xmath13 would not add @xmath20 to @xmath61 if @xmath20 is nonfaulty .",
    "part ( b ) follows from the observation that if @xmath172 or @xmath69 , then the tuple was added during the share phase .",
    "if @xmath173 and session @xmath24 completed , then it must be the case that @xmath174 and @xmath175 . since @xmath20 is nonfaulty",
    ", then the message required to remove the tuple from @xmath63 will be sent using rb by @xmath20 during the reconstruct phase , and will eventually be received by @xmath13 . if @xmath69 then there are two cases .",
    "if this entry was removed in line 8 of protocol @xmath34 , then we are done .",
    "otherwise , since session @xmath28 completed , it must be the case that @xmath176 and @xmath177 .",
    "hence the message required to remove the tuple from @xmath67 will be sent using rb by @xmath20 during the reconstruct phase , and will eventually be received by @xmath13 .",
    "we now prove that all the properties hold .",
    "[ lem : mwdavss ] the protocol satisfies the + properties .",
    "we consider the properties in turn .    *",
    "moderated validity of termination*. if the dealer and the moderator are nonfaulty and @xmath9 then , for all nonfaulty processes @xmath20 and @xmath54 , eventually @xmath178 will be in @xmath179 .",
    "hence , eventually @xmath180 will be at least @xmath50 .",
    "thus , eventually @xmath54 will complete step 4 of the share protocol .",
    "( for future reference , note that although the first @xmath50 elements of @xmath139 may not all be nonfaulty , at least @xmath14 of the elements of @xmath139 will be nonfaulty . ) moreover , since @xmath181 only if @xmath182 sent an @xmath94 message using rb , eventually the moderator will receive an @xmath94 message from all @xmath183 .",
    "thus , if @xmath54 is nonfaulty , a nonfaulty moderator will eventually add @xmath54 to @xmath117 in step 5 of the share protocol . since there are @xmath50 nonfaulty processes , eventually we must have @xmath184 , so the moderator completes step 6 of the share protocol .",
    "we already gave the intuition that a nonfaulty dealer will then broadcast @xmath127 at step 7 .",
    "thus , all nonfaulty processes will eventually complete protocol @xmath34 .    *",
    "termination*. if a nonfaulty process @xmath20 completes protocol @xmath34 , then , since all the messages that caused @xmath20 to complete the protocol are sent using rb , it follows that all nonfaulty processes eventually complete @xmath34 .",
    "the fact that they all complete @xmath35 follows since , as observed above , the set @xmath139 for each @xmath185 contains at least @xmath14 nonfaulty processes , each of which eventually sends its value in step 1 of @xmath35 .",
    "thus , each nonfaulty process outputs either some value in @xmath40 or @xmath10 at step 3 of @xmath35 .",
    "* validity*. suppose that the dealer @xmath13 is nonfaulty .",
    "there are two cases . if some faulty process @xmath20 such that @xmath186 sends a message @xmath187 at step 1 of @xmath35 such that @xmath188",
    ", then @xmath13 did not ignore some message from @xmath20 during session @xmath24 , @xmath189 will never be removed from @xmath63 , and eventually @xmath20 will be added to @xmath61 by line 2 in the @xmath56 protocol .",
    "hence , @xmath20 is shunned by @xmath13 starting in session @xmath24 .",
    "thus , if no process is shunned by @xmath13 for the first time in @xmath24 , it must be the case that , for each process @xmath132 , all the values broadcast by processes in @xmath190 agree with @xmath55 .",
    "since there will eventually be at least @xmath14 values broadcast from processes in @xmath190 , all nonfaulty processes will interpolate @xmath55 for all @xmath134 , and subsequently will interpolate @xmath49 and the secret @xmath7 .    *",
    "weak and moderated binding*. if the dealer is nonfaulty , it follows from validity that weak binding holds , taking @xmath191 .",
    "so suppose that the dealer @xmath13 is faulty .",
    "if there is a faulty process @xmath20 such that @xmath192 for a nonfaulty process @xmath54 and @xmath20 sends a message @xmath193 in step 1 of @xmath35 such that @xmath188 . in this case",
    "@xmath54 did not ignore a message from @xmath20 during session @xmath24 , @xmath194 will never be removed from @xmath179 , and eventually @xmath20 will be added to @xmath195 by line 3 in the @xmath196 protocol .",
    "hence , @xmath20 is shunned by @xmath54 starting in session @xmath24 , so weak and moderated binding holds . on the other hand , if , for each nonfaulty process @xmath132 , all the values broadcast by processes in @xmath190 are what they were expected to be then , at the time that the first nonfaulty process completes protocol @xmath34 , the set @xmath197 is fixed .",
    "let @xmath198 be the set of nonfaulty processes in @xmath197 . for each @xmath199 , the value @xmath200",
    "is also fixed .",
    "if there exists a degree-@xmath1 polynomial @xmath201 that interpolates the points in @xmath202 , then let @xmath203 ; otherwise , let @xmath204 .",
    "we claim that each nonfaulty process will output either @xmath33 or @xmath10 at the reconstruct phase .",
    "this is true since all nonfaulty processes will interpolate @xmath205 for all @xmath132 correctly . since @xmath206 , the values @xmath207",
    "determine a polynomial @xmath201 .",
    "if all remaining values @xmath208 obtained from the polynomials @xmath146 for @xmath209 agree with @xmath201 , then @xmath33 is output ; otherwise , @xmath10 is output .",
    "it easily follows from step 5 of @xmath34 that if the moderator is nonfaulty , then the values @xmath207 can be interpolated only by a polynomial @xmath201 such that @xmath210 is the moderator s value @xmath8 ; that is , @xmath211 .",
    "* moderated hiding*. if the dealer and moderator are nonfaulty then , as long as no nonfaulty process has invoked protocol @xmath23 , the combined view of any @xmath1 faulty processes is distributed independently of the value of the shared secret , @xmath7 .",
    "this follows since the dealer uses random degree-@xmath1 polynomials , so no set of size @xmath1 learns any information .",
    "as promised , we now show that it is possible that two nonfaulty processes will complete an invocation of with different values without detecting a new faulty process .",
    "[ xam : shunning ]    let @xmath212 and @xmath213 .",
    "consider an invocation of the protocol with processes @xmath214 , @xmath215 , @xmath216 , and @xmath217 , where @xmath215 is the dealer and @xmath214 is the moderator .",
    "suppose that , in the share protocol @xmath34 , process @xmath217 is delayed .",
    "hence , processes @xmath214 , @xmath215 , and @xmath216 hear only from each other before completing the share protocol .",
    "thus , @xmath218 .",
    "now suppose that in the reconstruct protocol @xmath35 , process @xmath216 hears the values sent by @xmath215 according to line 1 of @xmath35 before hearing from @xmath214 or @xmath217 .",
    "since it clearly hears from itself as well , @xmath219 , @xmath220 , and @xmath221 will each have two points ",
    "one from @xmath215 and one from @xmath216 . since @xmath222 in this case",
    ", it follows from step 3 that @xmath216 will then find the unique degree 1 polynomials @xmath223 , @xmath224 , and @xmath225 that interpolate the points in @xmath219 , @xmath220 , and @xmath221 , respectively .",
    "if @xmath226 , @xmath227 , and @xmath228 are collinear , and @xmath149 is the polynomial that interpolates them , then @xmath216 outputs @xmath151 .",
    "if @xmath215 is faulty , then by choosing the values it sends appropriately , @xmath215 can make @xmath151 an arbitrary element of @xmath40 .",
    "now if @xmath214 hears from @xmath216 before hearing from @xmath215 or @xmath217 , @xmath214 will also output a value , which may be different from @xmath216 s .    of course , to get @xmath216 to output a value different from @xmath214 s , @xmath215 must send a value @xmath229 that is different from the one that @xmath214 expects to hear .",
    "once @xmath214 gets this value , it will realize that @xmath215 is faulty , and add @xmath215 to its set @xmath230 . however , this may happen after both @xmath215 and @xmath216 have completed the invocation of .",
    "notice that this argument relies on the fact that processes use rb to send their values .",
    "in this section , we show how to implement , and then prove that our implementation satisfies the properties .",
    "the difficulties of doing this are illustrated by example  [ xam : shunning ] : it is possible that two nonfaulty processes output different values in an invocation @xmath24 of the protocol .",
    "of course , by the weak binding property , this can happen only if a new faulty process is eventually detected ( and is shunned in all invocations that follow @xmath24 ) .",
    "nevertheless , this detection can come after all processes have completed @xmath24 .",
    "thus , we must show that the inconsistency can not cause problems .      1 .",
    "if a dealer @xmath13 wants to invoke @xmath22 with a secret @xmath7 , it first updates @xmath25 to @xmath81 , initializes sets of processes @xmath231 and @xmath232 , @xmath233 , to @xmath116 and chooses a random degree-@xmath1 bivariate polynomial @xmath11 over the field @xmath40 such that @xmath234 has the form @xmath235 , we simply set @xmath236 and choose the remaining coefficients at random from @xmath40 .",
    "of course , the same ideas apply to choosing a random univariate polynomial @xmath49 such that @xmath43 .",
    "] let @xmath237 and let @xmath238 , for @xmath239 .",
    "dealer @xmath13 sends each process @xmath20 the message @xmath240 ( so @xmath20 can reconstruct @xmath241 and @xmath242 ) .",
    "2 .   if a process @xmath20 receives @xmath241 and @xmath242 from dealer @xmath13 for a session @xmath24 , then for each process @xmath243 , process @xmath20 participates in four invocations of protocol @xmath34 : 3 .   as a dealer with secret @xmath244 and moderator @xmath54 ( who should also have value @xmath244 if @xmath13 and @xmath54 are nonfaulty ) ; 4 .   as a dealer with secret @xmath245 and moderator @xmath54 ( who should also have value @xmath245 if @xmath13 and @xmath54 are nonfaulty ) ; 5 .   as a moderator with secret @xmath244 and dealer @xmath54 ( who should also have value @xmath244 if @xmath13 and @xmath54 are nonfaulty ) ; and 6 .   as a moderator with secret @xmath245 and dealer @xmath54 ( who should also have value @xmath245 if @xmath13 and @xmath54 are nonfaulty ) . 7",
    ".   the dealer @xmath13 adds @xmath20 to the set @xmath246 and @xmath54 to the set @xmath232 if the dealer completes all four invocations of the share part of @xmath34 with @xmath20 and @xmath54 playing the roles of dealer and moderator .",
    "the dealer @xmath13 adds @xmath20 to the set @xmath231 if @xmath247 .",
    "if @xmath248 , the dealer sends @xmath249 using rb . 10 . when process @xmath54 receives @xmath250 from the dealer and completes all four @xmath34 protocols for each pair",
    "@xmath251 such that @xmath252 and @xmath253 , then it completes this invocation of @xmath22 .      1 .",
    "each process @xmath20 initializes the set @xmath254 to @xmath116 and invokes the reconstruct protocol @xmath35 for each of the four invocations of for each pair @xmath255 such that @xmath256 and @xmath257 .",
    "after the four reconstruct protocols associated with @xmath47 and @xmath54 are complete , @xmath20 sets @xmath258 to the reconstructed output value for the entry @xmath259 where @xmath260 was the dealer in the protocol ( so that @xmath260 is either @xmath47 or @xmath54 ) .",
    "2 .   for each @xmath261 , process @xmath20 adds @xmath47 to @xmath254 if * there exists @xmath262 such that @xmath263 or @xmath264 are @xmath10 ; or * there do not exist degree-@xmath1 polynomials that interpolate @xmath265 or @xmath266 .",
    "+ intuitively , @xmath254 consists of those processes that @xmath20 ignores in invocation @xmath24 .",
    "3 .   for each @xmath267 , process @xmath20 computes the degree-@xmath1 polynomials @xmath268 and @xmath269 that interpolate @xmath270 and @xmath271 . if there exist @xmath272 such that @xmath273 , then @xmath20 outputs @xmath10 . otherwise , if there is a unique degree-@xmath1 bivariate polynomial @xmath149 such that for all @xmath274 , @xmath275 , then @xmath20 outputs @xmath276 ; otherwise , @xmath20 outputs @xmath10 .",
    "this completes the description of the protocol .",
    "[ lem : d - avss ] the protocol satisfies the properties .    for any session @xmath24 ,",
    "if @xmath277 are nonfaulty processes , then all messages sent from @xmath47 to @xmath20 will eventually not be ignored .",
    "this is true since , if @xmath278 , then @xmath20 completed all @xmath35 invocations associated with @xmath24 . from the way we use in @xmath23",
    ", all processes will also invoke all @xmath35 sessions associated with @xmath24 .",
    "hence from the termination property of and , it follows that all messages that @xmath20 expects @xmath47 to send in session @xmath26 will eventually be received .",
    "we now go through properties in turn .",
    "* validity of termination*. if the dealer is nonfaulty , then for any two nonfaulty processes @xmath47 and @xmath54 , eventually all four invocations of @xmath279 will complete .",
    "so eventually the set @xmath280 will be of size at least @xmath50 for each nonfaulty @xmath54 , the set @xmath281 will eventually contain at least @xmath50 elements , and all four @xmath34 invocations for each @xmath282 and @xmath283 will complete . by the properties of rb , all processes will eventually receive the sets @xmath281 and @xmath284 and , by the termination property of , for each @xmath282 and @xmath283 , all processes will eventually complete all four invocations of @xmath279 .",
    "hence , all nonfaulty processes will complete protocol @xmath22 .    *",
    "termination*. if a nonfaulty process completes protocol @xmath22 , then it follows from the termination property of the protocol and the reliable broadcast properties that all nonfaulty processes complete @xmath22 .",
    "the fact that they all complete @xmath23 follows from the termination property of the protocol .    * validity*. suppose that the dealer @xmath13 is nonfaulty in an invocation of @xmath22 with session i d @xmath24 .",
    "there are two cases . if a faulty process @xmath20 is first shunned by a nonfaulty process @xmath54 in some invocation with session @xmath26 that is part of the invocation with session i d @xmath24 , then , because @xmath54 started @xmath24 before starting @xmath26 and @xmath54 completes @xmath26 before completing @xmath24 , @xmath20 is also first shunned by @xmath54 starting in session @xmath24 of . on the other hand ,",
    "if no faulty process is shunned starting in session @xmath24 , then all invocations of must satisfy the first clause of the validity and weak and moderated binding properties .",
    "it follows from ( the first clause of ) the validity property that if @xmath256 is nonfaulty , then for all @xmath262 , it must be the case that @xmath285 and @xmath286 ( since @xmath47 acts as the dealer in computing these values , @xmath54 acts as the moderator and the values themselves are correct , since they were received from @xmath13 ) .",
    "thus , it follows that @xmath287 .",
    "similarly , it follows from ( the first clause of ) the weak and moderated binding property that , for all @xmath288 and @xmath262 , if either @xmath54 or @xmath47 are nonfaulty , then it must be the case that @xmath289 and @xmath290 are each either @xmath291 or @xmath10 , and that @xmath292 and @xmath293 are each either @xmath294 or @xmath10 .",
    "( here we use the fact that the nonfaulty process either @xmath47 or @xmath54is acting as either dealer or moderator in the invocations of during which these values are computed . )",
    "thus , even if @xmath54 is faulty , if @xmath295 , then we must have @xmath296 for all nonfaulty @xmath261 .",
    "it follows that , in step 3 of @xmath23 , @xmath20 correctly reconstructs @xmath297 and @xmath298 for all @xmath299 .",
    "thus , the polynomial @xmath149 computed by @xmath20 will be @xmath49 , and @xmath20 will output @xmath12 .    *",
    "binding*. if the dealer is nonfaulty , it follows from validity that binding holds , taking @xmath191 .",
    "if the dealer is faulty , there are again two cases .",
    "if a faulty process @xmath20 is shunned by a nonfaulty process @xmath54 in some invocation with session @xmath300 that is part of the invocation session @xmath24 , then , as argued in the proof of validity , @xmath20 is also first shunned by @xmath54 in invocation @xmath24 . on the other hand ,",
    "if no faulty process is shunned starting in session @xmath24 , then all invocations of must satisfy the first clause of the validity and moderated weak binding properties .",
    "consider the time that the first nonfaulty process completes protocol @xmath22 . at this time",
    ", the set @xmath281 is fixed .",
    "let @xmath301 be the set of nonfaulty processes in @xmath281 .",
    "since @xmath302 , we must have that @xmath303 .",
    "if there is a unique degree-@xmath1 bivariate polynomial @xmath304 induced by the entries @xmath305 for all @xmath306 and @xmath283 , then set @xmath307 ; otherwise , set @xmath204 .",
    "we claim that each nonfaulty process will output @xmath33 at the reconstruct phase . as in the proof of the validity property for",
    ", it follows from ( the first clause of ) the validity property for that if @xmath256 is nonfaulty , then for all nonfaulty @xmath262 , we have that @xmath308 and @xmath309 , where @xmath310 and @xmath311 are the polynomials sent by @xmath13 to @xmath47 .",
    "thus , @xmath287 . hence ,",
    "if @xmath204 , then all nonfaulty processes will output @xmath10 .",
    "moreover , if @xmath312 , then , as in the proof of validity for , by the weak and moderated binding property , and from the fact that @xmath206 , for all @xmath313 , it must be the case that @xmath298 and @xmath297 agree with @xmath149 .",
    "therefore @xmath20 will interpolate @xmath149 and output @xmath33 .    *",
    "hiding*. if the dealer is nonfaulty and no nonfaulty process has invoked protocol @xmath23 , then the combined view of any @xmath1 processes is distributed independently of the dealer s value @xmath7 , because every polynomial @xmath242 and @xmath241 has degree @xmath1 , and no process learns more than @xmath1 values of these polynomials .",
    "this completes the construction of the protocol .",
    "we now briefly sketch how , using ideas from canetti and rabin @xcite , we can use to construct the required asynchronous byzantine agreement protocol .",
    "once we have , we can get an almost - surely terminating polynomial protocol for byzantine agreement with optimal resilience , following the ideas outlined in canetti s @xcite thesis .",
    "we proceed in two steps .",
    "the first step is to get a common coin .",
    "canetti and rabin showed that , given @xmath314 , an avss protocol that terminates with probability @xmath315 could be used to construct a protocol cc that gives a common coin and terminates with probability @xmath315 .",
    "we use to get a _ shunning common coin _ ( scc ) protocol .",
    "let @xmath316 be a protocol where each party has a random input and a binary output .",
    "as in , we tag each invocation of @xmath316 with a unique session identifier @xmath25 .",
    "we say that @xmath316 is a _ shunning , terminating , @xmath1-resilient common coin protocol _",
    "( scc protocol ) if the following properties , called the _ scc properties _ , hold ( in runs with at most @xmath1 faulty processes in some session tagged @xmath25 ):    1 .",
    "* termination*. all nonfaulty processes terminate",
    "correctness*. for every invocation either * for each @xmath317 , with probability at least @xmath318 , all nonfaulty processes output @xmath319 ; or * there exists a nonfaulty process @xmath13 and a faulty process @xmath20 such that @xmath20 is shunned by @xmath13 starting in session @xmath25 .    for @xmath2 there exists a shunning , terminating , @xmath1-resilient common coin protocol .",
    "the protocol to implement scc is exactly the protocol in figure 59 in @xcite , except that we replace the avss protocol with our .",
    "the proof that this protocol satisfies the scc properties follows from lemmas 5.275.31 in @xcite , together with the observation that if a process is shunned starting at a invocation whose reconstruct protocol competes before the scc protocol invocation completes , then this process is shunned starting at this scc protocol invocation .",
    "the second step is to use the common coin protocol to get the byzantine agreement protocol .",
    "canetti and rabin use their common coin protocol cc that terminates with probability @xmath315 to get a byzantine agreement protocol that terminates with probability @xmath315 .",
    "we replace the use of cc by scc to get an almost - surely terminating protocol .",
    "the key observation is that in the protocol of figure 5 - 11 in @xcite , if a nonfaulty process @xmath20 participates in rounds @xmath33 and @xmath320 ( and hence , in our setting , it participles in the scc protocol with session identifiers @xmath33 and @xmath320 ) , and @xmath321 , then it must be the case that @xmath322 .",
    "therefore , there can be at most @xmath323 rounds @xmath33 such that a nonfaulty process @xmath13 shuns a faulty process @xmath20 starting in round @xmath33 . hence , there are at most @xmath324 rounds where the scc protocol does not succeed . in all the remaining rounds , the first clause of the scc correctness property holds , so we essentially have a common coin that is sufficiently strong for byzantine agreement .",
    "it therefore follows from lemma 5.38 and 5.29 of @xcite that the expected running time of the protocol is @xmath324 .",
    "thus we have the following result .",
    "there is an almost - surly terminating , polynomial protocol for asynchronous byzantine agreement protocol with optimal resilience .",
    "we have shown how to use to give a protocol for asynchronous byzantine agreement that has optimal resilience , almost - surely terminates , and is polynomially efficient .",
    "our protocol has implications for asynchronous secure multiparty computation ( asmpc ) of certain functionalities . in the full paper",
    "we define a family of functionalities for which the use of gives a protocol for asmpc that has optimal resilience , terminates almost surely , and has perfect security ( the ideal and real worlds are statistically indistinguishable ) .",
    "perhaps the major open question remaining is whether there exists an asynchronous byzantine agreement protocol with optimal resilience and constant expected running time .",
    "a protocol @xmath325 with a distinguished dealer holding input @xmath7 is a @xmath1-tolerant _ weak reliable broadcast protocol _ if the following holds for every execution with at most @xmath1 faulty processes :    1 .",
    "* weak termination*. if the dealer is nonfaulty , then every nonfaulty process will eventually complete protocol @xmath325 .",
    "* correctness*. 1 .",
    "if a nonfaulty process completes protocol @xmath325 , then once the first nonfaulty process completes the protocol there is a value @xmath33 such that each nonfaulty process that completes protocol @xmath325 accepts @xmath33 ; 2 .   if the dealer is nonfaulty , then each nonfaulty process that completes protocol @xmath325 accepts @xmath7 .",
    "this protocol , which we call wrb , is essentially dolev s @xcite _ crusader agreement_. it uses two types of messages ; _ type 1 messages _ have the form @xmath326 and _ type 2 messages _ have the form @xmath327 .",
    "wrb proceeds as follows :    1 .",
    "the dealer sends @xmath328 to all processes .",
    "if process @xmath13 receives a type 1 message @xmath326 from the dealer and it never sent a type 2 message , then process @xmath13 sends @xmath327 to all processes .",
    "if process @xmath13 receives @xmath50 distinct type 2 messages @xmath327 , all with value @xmath33 , then it accepts the value @xmath33 .",
    "if the dealer is nonfaulty , then it is immediate that every nonfaulty process will send @xmath329 , and thus will accept @xmath7 ( since there are at most @xmath1 faulty processes , by assumption ) .",
    "moreover , if the dealer is nonfaulty , the only type 2 message sent by a nonfaulty process is @xmath329 , so no nonfaulty process will receive more than @xmath1 type 2 messages @xmath327 with @xmath330 . to see that wrb satisfies the correctness property ,",
    "suppose , by way of contradiction , that one nonfaulty process @xmath13 accepts @xmath33 and another nonfaulty process @xmath20 accepts @xmath320 , with @xmath331 .",
    "then @xmath13 must have received @xmath50 type 2 messages with value @xmath33 and @xmath20 must have received @xmath50 type 2 messages with value @xmath320 .",
    "thus , at least @xmath332 processes must have sent a type 2 message to both @xmath13 and @xmath20 .",
    "at least one of these processes must be nonfaulty .",
    "but the protocol ensures that a nonfaulty process will send only one type 2 message .",
    "this gives us the desired contradiction .",
    "a protocol @xmath325 with a distinguished dealer holding input @xmath7 is a @xmath1-tolerant _ reliable broadcast protocol _ if the weak termination and correctness properties of the weak reliable broadcast holds , and in addition , the following property holds :    1 .",
    "* termination*. for every execution with at most @xmath1 faulty processes , if some nonfaulty process completes protocol @xmath325 then all nonfaulty processes will eventually complete protocol @xmath325 .",
    "this protocol , which we call rb , is essentially bracha s _ echo broadcast_. it uses wrb as a subroutine .",
    "in addition to type 1 and type 2 messages , it uses _ type 3 _ messages , which have the form @xmath333 .",
    "rb proceeds as follows :    1 .",
    "the dealer sends @xmath328 to all processes using weak reliable broadcast ( wrb ) .",
    "if process @xmath13 accepts message @xmath33 from the dealer using wrb , then process @xmath13 sends @xmath333 to all processes .",
    "3 .   if process @xmath13 receives at least @xmath14 distinct type 3 messages with the same value @xmath33 , then process @xmath13 sends @xmath333 to all processes .",
    "if process @xmath13 receives at least @xmath50 distinct type 3 messages with the same value @xmath33 , then it accepts the value @xmath33 .    to see that rb is correct ,",
    "first observe that , from the correctness property of wrb , it follows that it can not be the case that two type 3 message with different values are sent by nonfaulty processes at step 2 .",
    "moreover , if a nonfaulty process sends a type 3 message at step 3 , it must be because it got a type 3 message from a nonfaulty process .",
    "it easily follows that all the type 3 messages sent by nonfaulty processes at either step 2 or step 3 have the same value . if the dealer is nonfaulty , then it is easy to see that all nonfaulty processes terminate and accept value @xmath7 , as in wrb . to see that termination holds for rb ,",
    "suppose that a nonfaulty process completes the protocol .",
    "it thus must have received @xmath50 type 3 messages with the same value @xmath33 .",
    "each other nonfaulty process will eventually have received at least @xmath332 of these messages , and so will send a type 3 message by step 3 , if it has not already done so by step 2 . as we argued above , all the type 3 messages sent by nonfaulty processes must have the same value .",
    "thus , each nonfaulty process will end up receiving @xmath50 type 3 messages with value @xmath33 .",
    "finally , part ( b ) of correctness follows easily from our observation above that all the type 3 messages sent by nonfaulty processes have the same value @xmath33 .",
    "j.  katz and c .- y . koo . on expected constant - round protocols for byzantine agreement . in cynthia dwork , editor , _ crypto _ , volume 4117 of _ lecture notes in computer science _ , pages 445462 .",
    "springer , 2006 ."
  ],
  "abstract_text": [
    "<S> consider an asynchronous system with private channels and @xmath0 processes , up to @xmath1 of which may be faulty . </S>",
    "<S> we settle a longstanding open question by providing a byzantine agreement protocol that simultaneously achieves three properties :    1 .   _ </S>",
    "<S> ( optimal ) resilience _ : it works as long as @xmath2 ; 2 .   _ </S>",
    "<S> ( almost - sure ) termination _ : with probability one , all nonfaulty processes terminate ; 3 .   _ </S>",
    "<S> ( polynomial ) efficiency _ : the expected computation time , memory consumption , message size , and number of messages sent are all polynomial in @xmath0 .    </S>",
    "<S> earlier protocols have achieved only two of these three properties . </S>",
    "<S> in particular , the protocol of bracha is not polynomially efficient , the protocol of feldman and micali is not optimally resilient , and the protocol of canetti and rabin does not have almost - sure termination . </S>",
    "<S> our protocol utilizes a new primitive called _ shunning ( asynchronous ) verifiable secret sharing _ ( svss ) , which ensures , roughly speaking , that either a secret is successfully shared or a new faulty process is ignored from this point onwards by some nonfaulty process .    </S>",
    "<S> f.0 [ theory of computation ] : general . </S>"
  ]
}