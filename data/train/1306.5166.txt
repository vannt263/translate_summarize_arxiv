{
  "article_text": [
    "let @xmath4 be any two functions .",
    "we will employ the following notations throughout , all of which are quite standard :    \\(i ) @xmath5 means that @xmath6 .",
    "\\(ii ) @xmath7 means that @xmath8 .",
    "\\(iii ) @xmath9 means that @xmath10 .",
    "\\(iv ) @xmath11 means that @xmath12 .",
    "\\(v ) @xmath13 means that @xmath14 .",
    "\\(vi ) @xmath15 means that both @xmath11 and @xmath14 hold .",
    "\\(vii ) @xmath16 means that @xmath17 .",
    "+ now suppose instead that @xmath18 are two sequences of random variables .",
    "we write @xmath5 if , for all @xmath19 and @xmath0 sufficiently large , @xmath20 similarly , we write @xmath7 if , for all @xmath21 and @xmath0 sufficiently large , @xmath22 we will employ the standard phrase `` asymptotically almost surely ( a.a.s . ) '' when considering a sequence of events @xmath23 such that @xmath24 as @xmath25 .",
    "we use the notation @xmath26 to denote `` @xmath0 sufficiently large '' .    finally ,",
    "if @xmath27 is a point in @xmath28 and @xmath29 , we denote by @xmath30 the open ball of radius @xmath31 about @xmath27 .",
    "one day while performing the mathematical equivalent of sitting at a bar , drinking beer and philosophising - that is , browsing the day s listings on arxiv.org - one of the three authors was somehow reminded of a classic scene from the movie terminator 2 @xcite . at one point toward the end of the film ,",
    "the evil terminator becomes liquified after an explosion .",
    "blobs of liquid metal are scattered on the ground and he appears to have been `` terminated '' .",
    "however , as if guided by some mysterious superior intelligence , the blobs suddenly start moving toward one another , eventually merging and reforming the intact terminator , who then sets off on the rampage again . +    at the time , we were completely unaware of the extensive literature on the subject of _ rendezvous problems_. the movie scene got us thinking , and the results presented in this article are the result of those thoughts . only afterwards ,",
    "when we circulated a draft paper to a colleague who is an expert in computational geometry , were we alerted to the existing literature .",
    "having examined the latter , it seems to us that the kind of multi - agent rendezvous problem we ended up considering has two important differences from what is studied in the literature .",
    "firstly , we imagined that agents which could see each other could also , in principle , communicate and thus exchange information .",
    "our agents are thus more anthropomorphised than the robots normally imagined .",
    "secondly , we took a `` probabilist s approach '' , and sought randomised algorithms which would work well , for generic configurations of agents , and in the limit as both the number and the spatial distribution of agents tended to infinity .",
    "these facts probably render our approach of less practical significance , though we will try to convince the reader that it is , at the very least , still an interesting thought - experiment and involves some elegant mathematics .",
    "+    rendezvous problems ( rps ) originated in work of steven alpern , who considered the problem faced by two people who are placed randomly in a known , bounded search region in @xmath28 and move about at unit speed to find each other in the least expected time .",
    "alpern originally imagined that there were a finite number of possible meeting points , but later formalised the continuous version of the problem , and even generalised it to other compact metric spaces @xcite .",
    "a variety of models have been proposed in the case of an arbitrary number of agents , which are then usually thought of as autonomous robots , rather than fully - fledged humans .",
    "an elegant , and classical model , makes the following assumptions : +   + _ rp-1 : _ each robot is idealised as a mobile point in @xmath28 .",
    "rendezvous means the merging of all the robots at a single point .",
    "the robots are assumed to be identical .",
    "+ _ rp-2 : _ the robots can move at constant speed .",
    "+ _ rp-3 : _ there is some fixed constant @xmath29 such that , at all times , each robot can only see those others which are within a distance @xmath31 of itself . for a given configuration of point robots ,",
    "this gives rise to a geometric graph @xmath32 whose vertices are the points , and where an edge is placed between any two points at distance at most @xmath31 from each other . usually @xmath32 is called the _ visibility graph _ corresponding to the point configuration .",
    "any two points connected by an edge we shall refer to as _ neighbors_. + _ rp-4 : _ the initial configuration is such that the visibility graph is connected . however , the robots have no a priori knowledge that they all lie within some specific region of @xmath28 .",
    "this is in contrast to alpern s original formulation , where the search region was known consists entirely of isolated vertices and there is no a priori knowledge of a search region .",
    "for example , the points could perform independent brownian motions , and since , as is well - known ( see @xcite for example ) , the trajectory of a brownian motion in @xmath28 is almost surely dense , any finite number of points will most surely be able to merge in this manner .",
    "however , as is also well - known , the expected running time for this procedure will always be infinite , even in the case of two points whose initial separation is any positive constant greater than the visibility range @xmath31 .",
    "also note that the procedure will not work at all in higher dimensions , as brownian motions are then no longer almost surely dense . ] .",
    "+ _ rp-5 : _ robots do not communicate explicitly with each other , even when they are neighbors .",
    "each robot is equipped with a sensor which allows it to determine the exact locations of all its neighbors at any instant .",
    "this is the only input it has from its neighbors when deciding how to move .",
    "+    under these assumptions , one seeks a deterministic algorithm which guarantees merging .",
    "it is natural to seek an algorithm where the actions of the robots are _",
    "synchronised_. what this means is that the algorithm should consist of _ rounds_. in each round , every robot notes the locations of its neighbors , performs some computation and determines a point to which it then moves , in a straight line , from its current location .",
    "all the robots execute these tasks before the next round begins .",
    "the classical solution to this problem was provided by ando , suzuki and yamashita @xcite , see also @xcite , whose algorithm utilises a well - known concept in computational geometry . let @xmath33 be a positive integer and let @xmath34 be a set of @xmath33 points in the plane , say @xmath35 , where @xmath36 . for each point @xmath37 ,",
    "let @xmath38    where @xmath39 denotes euclidean distance .",
    "there is a unique point @xmath40 at which the function @xmath41 attains its minimum value , namely the center of the unique closed disc of minimum radius which includes all the points of @xmath34 .",
    "the point @xmath42 is called the _",
    "center of the smallest enclosing circle ( csec ) _ , with respect to the points in @xmath34 . in each round of the asy - algorithm ,",
    "a robot moves in the direction of the csec of the points in its viewing range ( including itself ) , but not necessarily to exactly the csec because one must ensure that the visibility graph remains connected .",
    "indeed , the main technical challenge for the algorithm is to specify how to satisfy this constraint .",
    "note that , in the last round before merging , all the robots must be visible to one another and then they all compute the same csec and move to it . by definition of the csec , and given rp-2 , this is the optimal solution to the multi - agent rendezvous problem when there is global visibility .",
    "we found a number of papers which investigated the time complexity of the asy and similar rendezvous algorithms , see for example @xcite and @xcite .",
    "two things struck us about these analyses .",
    "firstly , the complexity is defined in terms of the number of rounds . the time taken to execute computations within each round",
    "is not considered .",
    "secondly , the analyses tend to focus on worst - case scenarios , in other words , the primary goal is to obtain an upper bound for the number of rounds which is valid for any connected visibility graph . hence the bounds tend to be expressed in terms of the number of robots . a remark on page 2221 of @xcite hints that , if one begins by assuming that the robots are confined to some fixed bounded region in @xmath28 , then for `` generic '' initial configurations , the size and shape of the region may be what really determine the time complexity rather than the number of points .",
    "this viewpoint means abandoning rp-4 , of course , though note that it is less restrictive than in alpern s original formulation , since one is not assuming that the initial search region is known to the agents , only that such a bounded region exists .",
    "we have not seen any paper which follows up on this idea , however .",
    "+    as already stated , we began thinking about rendezvous - type problems well before we became aware of the existing literature on the subject .",
    "with hindsight , the point of view we took addresses the two issues raised above about existing time - complexity analyses .",
    "however , to do so and yet obtain the result we were looking for , we had to abandon rp-5 , and allow our robots certain abilities to communicate with their neighbors .",
    "furthermore , we had to foucs on asymptotic results and randomised rather than fully deterministic algorithms .",
    "we now describe our viewpoint .",
    "the simplest kind of closed , bounded region in @xmath28 is a disc , so suppose the points are initially confined to a disc of radius @xmath0 .",
    "the disc radius is our primary parameter , and we will be interested in asymptotic results , hence in letting @xmath25 .",
    "we are also interested in `` generic '' configurations , so we imagine that each point is placed uniformly at random in the disc , and independently of all other points .",
    "it is well - known - see @xcite for example - that if the number @xmath43 of points satisfies @xmath44 , then the visibility graph will a.a.s .",
    "be connected , whereas if @xmath45 , then it will a.a.s .",
    "be disconnected .",
    "so we suppose the former holds .",
    "if we run the asy - algorithm , then in the last step each robot will have to compute the csec for some set of @xmath43 points in the plane .",
    "trivially , any procedure for doing this will require time @xmath46 to execute .",
    "hence , if we include this time in our analysis , we have a trivial lower bound of @xmath1 for the time to rendezvous .",
    "taking all the rounds of the procedure into account will make things even worse , though perhaps not significantly since    \\(a ) during earlier rounds , each robot will have far fewer than @xmath43 neighbors , hence most of the computations are done only towards the end . since the average density of points is @xmath47 initially , and a robot moves distance @xmath48 per round , what we can be certain of is that the extra contribution to the running time coming from earlier rounds is @xmath49 .",
    "\\(b ) it is a classical result that computation of a csec can indeed be solved in time linear in the number of points .",
    "megiddo @xcite was the first to describe a deterministic linear - time algorithm .",
    "later , welzl @xcite developed an alternative procedure which is considered the state - of - the - art solution .",
    "his algorithm is probabilistic , with expected linear running time , but it is much simpler to describe and to implement that megiddo s .    to repeat , given that the initial visibility graph @xmath32 is a generic , connected geometric graph inside a disc of radius @xmath0 , the actual running time of the asy - algorithm under conditions rp 1 - 5 above is @xmath50 .",
    "on the other hand , if the points somehow `` knew '' where to rendezvous , then rp-2 means they could do so in time @xmath2 .",
    "the goal of our study was to find a probabilistic algorithm which a.a.s . led to rendezvous in time @xmath2 .",
    "it seems clear , though we have not proven it rigorously ( see section [ sect : discuss ] ) , that this is impossible under rp-5 .",
    "so we are forced to allow some kinds of communication between points , which is perhaps a more radical departure from the classical multi - agent rendezvous problem than some a priori assumption about the geometry of the point configuration .",
    "part of the goal then becomes to find an algorithm which contains as simple and as few as possible assumptions about how neighboring points can communicate .",
    "this is admittedly a subjective requirement , but as long as we can make all assumptions precise we will at least have a well - defined mathematical problem . there is also a conceptual problem with , say , the asy - algorithm as @xmath51 , namely that each robot would need unlimited capacity to store the results of the computation of a csec .",
    "we will thus also have a preference for algorithms which overcome this problem .    section [ sect : heart ]",
    "is the heart of the paper .",
    "having formalised our assumptions about how points can communicate we will prove our main result , theorem [ thm : main ] .",
    "informally , it asserts that there is a randomised rendezvous algorithm which a.a.s .",
    "runs in time @xmath2 provided the initial configuration of points is not _ too _ dense .",
    "significantly , our algorithm consists of two main steps , the first and more difficult of which involves the choice of a _ leader _ amongst the points .",
    "indeed , it may make more sense to think of our algorithm as being for this purpose , rather than for the purpose of rendezvous",
    ". we will have a lot more to say about this matter in section [ sect : discuss ] , which contains a critical analysis of our alternative assumptions , plus suggestions for further developing the ideas of this paper .",
    "a sceptical reader may choose to only skim through section [ sect : heart ] , ignoring detailed proofs , before reading section [ sect : discuss ] .",
    "we start with two lemmas which will be used in the proof of the main theorem below .    [",
    "lem : graph ] let @xmath52 be an increasing function .",
    "for each @xmath53 suppose @xmath54 points are placed uniformly and independently in the interior of a disc @xmath55 in @xmath28 of radius @xmath0 .",
    "let @xmath56 be the geometric graph whose vertices are these points , and with an edge between any two points the euclidean distance between whom is at most one .",
    "set @xmath57 , the average density of points in the disc .",
    "there is an absolute constant @xmath58 such that , if @xmath59 , then a.a.s .",
    "\\(i ) the degree of every vertex in @xmath32 lies between @xmath60 and @xmath61 ,    \\(ii ) the graph diameter of @xmath32 is at most @xmath62 .",
    "there is a rich literature on random geometric graphs - see @xcite - and the above statements certainly follow from well - known ( stronger ) ones .",
    "we sketch proofs here for the sake of completeness .",
    "choose @xmath0 and let @xmath27 be any point in @xmath55 .",
    "the number of vertices of @xmath63 which are at distance less than one from @xmath27 is distributed as bin@xmath64 , where @xmath65 is the area of @xmath66 . hence @xmath67 $ ] , depending on",
    "how close @xmath27 is to the boundary of @xmath55 .",
    "it follows that the probability that the degree of any particular vertex of @xmath63 lies outside the interval @xmath68 $ ] is at most @xmath69 , for some absolute constant @xmath70 .",
    "thus ( i ) follows by a simple union bound .",
    "indeed , note that ( i ) holds if we replace the factors @xmath71 and @xmath72 by any constants less than @xmath73 and greater than @xmath74 respectively .    to prove ( ii ) ,",
    "consider two vertices @xmath27 and @xmath75 in @xmath63 .",
    "no matter where they are located in @xmath55 , we can connect them by a piecewise rectangular tube of width @xmath71 and of length at most @xmath76 ( see figure 1 ) .",
    "we can divide this tube into square sections of side - length @xmath71 and observe that any two vertices located in adjacent sections are joined by an edge in @xmath63 . hence ,",
    "if no section of the tube is empty , then the graph distance from @xmath27 to @xmath75 is at most @xmath62 .",
    "the probability that any section is completely empty of vertices is at most @xmath77 for some absolute constant @xmath78 .",
    "the claim of part ( ii ) follows by some simple union bounds .",
    "[ fig : ini ]    [ lem : read ] let @xmath53 and let @xmath79 be a positive integer such that @xmath80 as @xmath25 .",
    "suppose @xmath0 binary strings @xmath81 , each of length @xmath33 , are generated independently and uniformly at random .",
    "consider a fixed string @xmath82 .",
    "suppose it compares itself with each other string @xmath83 , @xmath84 , by reading each string bit - by - bit from left to right until it encounters a bit where the string differs from itself ( if @xmath85 then the whole of @xmath83 is read ) .",
    "let @xmath86 be the total number of bits read by @xmath82 and let @xmath87",
    ". then @xmath88 .",
    "@xmath89 , where @xmath90 is the number of bits of @xmath83 that are read by @xmath82 .",
    "we have @xmath91 = \\sum_{t=1}^{k } t \\cdot 2^{-t } \\sim 2 , \\\\",
    "\\mathbb{e}[x_{ij}^{2 } ] = \\sum_{t=1}^{k } t^2 \\cdot 2^{-t } \\sim 6.\\end{aligned}\\ ] ] hence @xmath92 \\sim 2n$ ] and since , for a fixed @xmath93 , the @xmath90 are independent , var@xmath94 also .",
    "it follows from the central limit theorem that , for any @xmath29 , there exists @xmath95 such that @xmath96 .",
    "the lemma then follows from a union bound .    in order to be able to prove a rigorous mathematical result , theorem [ thm : main ] below",
    ", we need to specify precisely our assumptions about the capabilities of the points that are tasked with merging .",
    "a reader may variously complain that the following list of 11 assumptions is either too long , too ad hoc or dubious from the point of view of physics .",
    "we accept such criticisms as valid , but nevertheless think the thought experiment we are engaged in is worth pursuing , for two reasons . on the one hand , we think our result is _ mathematically _ interesting since , as will become clear from the proof of theorem [ thm : main ] , our algorithm very much relies on the geometry of the point configuration . on the other hand , none of our 11 assumptions seems completely ridiculous from an anthropomorphic standpoint , that is , if we imagine our `` points '' as being closer to intelligent human agents rather than much more primitive robots .",
    "the fact that our algorithm involves choosing a leader gives greater justification for this anthropomorphic viewpoint .",
    "one suggestion to a potential reader is to skip the list of assumptions and go directly to theorem [ thm : main ] and its proof , returning to the list only if one encounters anything in our algorithm that seems completely implausible .",
    "otherwise , we shall return to this discussion in section [ sect : discuss ] .",
    "+    henceforth , we assume a fixed choice of length and time units .",
    "all implicit constant factors in the following list , and indeed throughout the remainder of section [ sect : heart ] , are positive and absolute .",
    "we consider the first five assumptions to be minimal requirements if we wish to adhere to the spirit of the classical multi - agent rp , as expressed by rp 1 - 5 , but allow local communication in principle .",
    "+   + _ assumption 1:_[ass : one ] each point can move at speed at most one . that this constant is the same for all points corresponds , intuitively , to the assumption that all the points are identical , and in particular have the same `` mass '' .",
    "consequently , we could further assume that if , at some stage of the merging process , two points became stuck together , then this new `` heavier point '' could subsequently only move at some maximum speed less than one .",
    "however , since in our algorithm a leader is first chosen and then all the other points move to it , this last issue is not relevant .",
    "see questions [ quest : twostep ] and [ quest : intermediate ] below , however .",
    "+   + _ assumption 2 : _ each point can only directly communicate ( by transmission or reception of electromagnetic or chemical signals , say , though the precise details do nt matter ) with other points that are within a distance one of itself . as in section",
    "[ sect : intro ] , two points which can communicate directly will be called neighbors . henceforth , what was referred to in section [ sect : intro ] as the visibility graph will now be called the _ communication graph_. +   + _ assumption 3 : _ all signals travel at a fixed speed , which we can think of as being determined by the laws of physics ( and maybe chemistry ) .",
    "+   + _ assumption 4 : _ if a point broadcasts a signal , then any neighbor which receives it can locate , in time @xmath48 , the exact point source of the broadcast .",
    "+   + _ assumption 5 : _ each point is _ immortal _ in the sense that it can carry on the various activities desired of it at the same constant rate indefinitely .",
    "note that this assumption is necessary to even make sense of any asymptotic result in which the diameter of the initial configuration tends to infinity .",
    "here it is natural to think of the points as representing biological agents , who can `` eat '' to replenish their energy stores .",
    "+    our next two assumptions regard the types of signals that a point can broadcast and how they are processed .",
    "we assume there are two types of signals .",
    "+   + _ assumption 6 : _ each point can broadcast simoultaneously to all its neighbors .",
    "there are a bounded , if perhaps large , number of such signals , which we will think of as being different _",
    "colors_. any color signal can be generated , turned off or recognised in time @xmath48 .",
    "in addition , we assume that every point can both _ isolate _ and _ filter _ received color signals . by isolating we mean that , if a point is receiving signals in the same color from multiple sources , then it can identify and locate individual sources at a rate of @xmath97 sites per time unit . by filtering we mean that , if some set @xmath98 of colors are presently being broadcast amongst a point s neighbors , but it is only interested in some subset @xmath99 of colors , then in time @xmath48 it can `` put on an appropriate pair of goggles '' and henceforth scan only for colors in @xmath99 , and not be disturbed in any way by interference from colors in @xmath100 .",
    "+   + _ assumption 7 : _ each point can also generate single bits and send them to individual neighbors .",
    "a bit can be generated , an individual neighbor identified , and the bit sent to the neighbor all in time @xmath48 .",
    "the receiving point can process the bit and ( see assumption 4 ) identify its exact source in time @xmath48 .",
    "[ rem : sixpower ] assumption 6 , together with the last sentence of assumption 11 below , is a powerful tool . to get a feeling for this ,",
    "suppose all the points are initially inside an unspecified disc of diameter one , so we have global visibility but no universal point of reference",
    ". then , for @xmath43 points , a.a.s . they could rendezvous in time @xmath101 .",
    "for example , suppose each point is red by default .",
    "each point can start generating random bits , and turn blue as soon as it generates a zero .",
    "if , at some step , all the remaining red points turn blue , then these `` last men standing '' go back to red and try again .",
    "it is clear that , almost surely , within @xmath101 rounds there will be a time at which exactly one point is red .",
    "this point then becomes the _",
    "leader_. since it is visible to all other points , they can all merge at its location . by comparison ,",
    "if we only assumed rp 1 - 5 , then the computation of a csec would require time @xmath46 , and that is only if we ignore the problem of storage capacity .    finally",
    ", we make explicit four additional assumptions which our algorithm will exploit .",
    "they concern the abilities of the points to perform certain tasks or manouevers .",
    "note that assumption 9 will only be used to deal with the fact that each point has a finite storage capacity - see remark [ rem : storage ] below .",
    "+   + _ assumption 8 : _ if one point receives a color signal from another and then the sender , after waiting time @xmath48 so that the receiver locates it , starts to move while still transmitting the color , then the receiver can _ track _ its movements in real time , and hence follow it if necessary in such a way that the vector separation between the two points remains constant .",
    "if the sender remains stationary , then the receiver can move toward it in a straight line at speed one .",
    "+   + _ assumption 9 : _ given three points @xmath102 , @xmath103 , @xmath104 which are pairwise mutual neighbors , @xmath102 can _ point out _ @xmath104 to @xmath103 and @xmath103 can process this information , all within time @xmath48 .",
    "we can imagine the actual `` pointing '' being done by , for example , @xmath102 shining a laser at @xmath104 .",
    "a more `` low - tech '' solution would be for @xmath102 to walk toward @xmath104 , do a little dance around it and then walk back to where it came from .",
    "this would work given assumption 8 , and also assuming each point can leave a _ beacon _",
    "( which transmits a color reserved for beacons ) , so that it can return to its exact starting point after a walk within a radius of one .",
    "+   + _ assumption 10 : _ given any fixed @xmath105 $ ] , a point can _ sweep _ its @xmath31-neighborhood in such a way that it identifies the individual points in it at a rate of @xmath97 points per time unit and does not miss any points .",
    "in fact , our algorithm will only require this capacity for some finite number of predetermined values of @xmath31 , namely @xmath106 , where @xmath107 is an absolute constant that will appear in the proof of theorem [ thm : main ] . note that , what we re assuming here is more than just the ability to determine , in time @xmath48 , whether an identified neighbor is within a distance @xmath31 or not .",
    "rather , we are assuming that all neighbors at distance greater than @xmath31 can be blotted out as the scan is performed , perhaps by tuning a receiver so that it blocks out signals which are weaker than a certain threshold .",
    "we re also assuming that a point can physically perform a sweep , for example by rotating on an axis .",
    "+   + _ assumption 11 : _ following on from the previous assumption , given a point @xmath27 , a value of @xmath31 and any ninety - degree sector of @xmath30 , the point can determine in time @xmath48 whether that sector is empty of neighbors or not . also , given a color , it can determine in time @xmath48 whether or not anyone inside @xmath30 is currently broadcasting that color .",
    "+    this completes our list of asssumptions .",
    "one thing that might strike the reader as surprising is that we do not require the points to possess clocks , for example for the purpose of synchronising their actions .",
    "in fact , as we shall see , our algorithm only requires a very rudimentary synchronisation which can be achieved without perfect clocks , given the above assumptions .",
    "we are ready to state our main result .",
    "[ thm : main ] there is a randomised algorithm @xmath108 for which the following holds : there are absolute positive constants @xmath109 such that , if @xmath52 is a function satisfying @xmath110 then , under assumptions 1 - 11 above , if @xmath54 points are placed uniformly and independently at random in the interior of a closed disc @xmath111 of radius @xmath0 in @xmath28 and proceed to execute the algorithm @xmath108 , they will a.a.s .",
    "merge in time at most @xmath112 .    throughout the proof",
    "there will appear a sequence of absolute , positive constants which will be denoted by @xmath113 , for @xmath114 .",
    "some of these constants will be related to one another , as well as to the constants @xmath115 , @xmath116 appearing in the statement of the theorem .",
    "we will not bother with making these dependencies explicit , however .",
    "as in lemma [ lem : graph ] we will denote the average point density by @xmath117 , i.e. : @xmath118 .",
    "we will denote the boundary of the disc @xmath55 by @xmath119 .",
    "our algorithm @xmath108 will consist of two main steps : +   + step 1 : choose a _",
    "leader_. + step 2 : everyone move to the leader s location .",
    "+    more precisely , the idea is that , in step 1 , the @xmath54 points should perform a sequence of operations at the end of which , a.a.s .",
    "exactly one point will be in possession of information which identifies it as `` leader '' , whereas every other point will possess information which allows them to rule themselves out as leader .",
    "in fact , step 2 can begin once one point believes itself to be the leader , the crucial thing being that a.a.s .",
    "no other point will subsequently reach the same conclusion and muddy the waters .",
    "step 1 is the trickier part of the algorithm and we will go into the details below .    in step 2 ,",
    "the leader signals its identity to all its neighbors by broadcasting the color red , this being the color reserved specifically for the signal `` i am the leader '' ( see assumption 6 ) .",
    "once a point receives a red signal and identifies its source , it broadcasts red in turn to all its neighbors and then moves towards the location from which it received the signal . if it received a red signal from multiple sources , it chooses one of these at random and follows it .",
    "our various assumptions ( in particular , assumption 8) guarantee that step 2 will result in all @xmath54 points merging at the leader s location in time @xmath2 , if and only if the original red broadcast reaches all @xmath54 points in time @xmath2 .",
    "it follows from lemma [ lem : graph](ii ) that this will a.a.s .",
    "be the case , provided @xmath120 for a sufficiently large @xmath121 .",
    "note , in particular , that step 2 works for arbitrarily dense configurations of points , the upper bound on @xmath54 in theorem [ thm : main ] is not needed . +    it thus remains to describe the implementation of step 1 .",
    "there are two crucial ingredients and both rely on the upper bound @xmath122 .",
    "the first ingredient is that , if @xmath122 then , by lemma [ lem : graph](i ) , a.a.s .",
    "every point has @xmath123 neighbors .",
    "thus , by assumption 10 , every point can count its neighbors in time @xmath123 .",
    "there is one subtlety here , however .",
    "recall from section [ sect : intro ] that we prefer to think of each point as possessing a finite memory capacity .",
    "hence , for @xmath26 , it will in general not be able to store internally the result of a count of its neighbors .",
    "we ll present our solution to this problem further down , but it makes our algorithm a good deal more clunky than it would be otherwise .",
    "see also remark [ rem : storage ] .",
    "the second crucial ingredient is that the `` boundary '' of the communication graph will a.a.s .",
    "contain @xmath2 points .",
    "we need a precise definition :    [ def : boundary ] let @xmath32 be the communication graph of a collection of points distributed in a disc .",
    "let @xmath124 be one of these points .",
    "if @xmath124 has a set of neighbors @xmath125 such that , setting @xmath126 ,    \\(i ) @xmath127 and @xmath128 are also neighbors , for each @xmath129 ,    \\(ii ) reading clockwise , @xmath125 are the vertices of a simple polygon in the plane which encloses @xmath124 , + then @xmath124 is said to be a _ non - boundary point _ of @xmath32 . if no such set of neighbors of @xmath124 exists , we say it is a _ boundary point _ of @xmath32 .",
    "we denote by @xmath130 the set of boundary points of @xmath32 .",
    "[ clm : boundsize ] suppose @xmath54 satisfies the assumptions of theorem [ thm : main ] .",
    "then    \\(i ) there are absolute positive constants @xmath131 such that , a.a.s . ,",
    "@xmath132 .",
    "\\(ii ) a.a.s .",
    "every point in @xmath130 is at distance at most @xmath133 from @xmath119 , where @xmath134 is another absolute constant .",
    "_ proof of claim .",
    "_ these kinds of statements may also follow from `` well - known facts '' about geometric graphs , but we choose to give complete proofs .",
    "for a given @xmath0 , let @xmath135 denote the closed disc with the same center as @xmath55 , but of radius @xmath136 .",
    "set @xmath137 and , for each @xmath138 , let @xmath139 .",
    "let @xmath27 be a point of @xmath55 , and let @xmath140 denote its distance from @xmath119 .",
    "let @xmath141 denote the center of @xmath55 and let @xmath142 be the chord through @xmath27 which is perpendicular to the line through @xmath141 and @xmath27 ( see figure 2 on page 10 ) .",
    "it is easy to check that @xmath143 , for @xmath138 , whenever @xmath144 and @xmath26 .",
    "[ fig : ini ]    first consider points in @xmath145 .",
    "the total number of such points in the configuration is distributed as bin@xmath146 , where @xmath65 is the area of @xmath145 , hence @xmath147 .",
    "it follows that a.a.s .",
    "the number of such points is @xmath123 , and hence that @xmath148 also .",
    "next consider a point @xmath27 in the configuration at distance @xmath144 from @xmath119 .",
    "if @xmath27 is to lie in @xmath130 , then at least one of the regions @xmath149 , @xmath150 , in figure 3 on page 11 must be empty . by a simple union bound ,",
    "the probability of this is at most @xmath151 , for some @xmath152 . part ( ii ) of the claim",
    "now follows .",
    "note that this immediatetely implies in turn the lower bound in part ( i ) , since @xmath130 must be connected , as an induced subgraph of @xmath32 .",
    "for the upper bound in part ( i ) , let us consider the random variable @xmath153 which is the number of points in the configuration at distance @xmath144 from @xmath119 for which at least one of the four regions in figure 3 is empty . by definition , @xmath153 stochastically dominates @xmath154 , so it suffices to prove that @xmath155 . for the first moment we immediately have an upper bound @xmath156",
    "\\leq c_{12 } \\lambda_n \\int_{0}^{n } 2\\pi ( n - r ) e^{-c_{10 } \\lambda_n r } \\ ; dr \\leq c_{13 } n.\\ ] ]     [ fig : ini ]    we will now show that var@xmath157 , which will suffice to complete the proof .",
    "we can write @xmath158 , a sum of indicator variables , one for each of the @xmath54 points in the configuration .",
    "let @xmath159 denote the event for which @xmath160 , that is , dist@xmath161 and at least one of the four regions in figure 3 is empty .",
    "there are @xmath162 pairs of distinct points @xmath163 , so it suffices to prove that , for any pair of points , @xmath164 first of all , let us define three auxiliary events @xmath165 , @xmath166 . let @xmath167 be the event that the euclidean distance between @xmath27 and @xmath75 is at least two .",
    "let @xmath168 be the event that at least one of @xmath27 and @xmath75 is at least @xmath169 from @xmath119 .",
    "finally , let @xmath170 be the complement of @xmath171 . a priori",
    ", we can decompose the left - hand side of ( [ eq : small ] ) as + @xmath172 +   \\mathbb{p}(a_{{\\mbox{\\boldmath $ { p } $ } } } \\wedge a_{{\\mbox{\\boldmath $ { q } $ } } } | \\mathcal{w}_2 ) \\cdot   \\mathbb{p}(\\mathcal{w}_2 ) +   \\mathbb{p}(a_{{\\mbox{\\boldmath $ { p } $ } } } \\wedge a_{{\\mbox{\\boldmath $ { q } $ } } } | \\mathcal{w}_3 ) \\cdot   \\mathbb{p}(\\mathcal{w}_3).\\ ] ]",
    "the main idea here is that , if @xmath167 occurs , then the events @xmath159 and @xmath173 are almost negatively correlated . intuitively , if say @xmath159 occurs , what we then know is that at least one of the four regions in figure 3 , for the point @xmath27 , is empty . in other words , we just know that some region of @xmath55 is empty , which must make it less likely that any disjoint region is also empty .",
    "since @xmath75 is at distance greater than two from @xmath27 , each of its four associated regions is disjoint from the corresponding regions for @xmath27 .",
    "there is one small flaw with this reasoning , namely the knowledge that @xmath75 is far away from @xmath27 slightly increases the probability of the event @xmath159 to begin with , and vice versa .",
    "namely , we have already ruled out @xmath75 as a close neighbor of @xmath27 , and hence when calculating the probability of @xmath159 we can imagine starting with a configuration of @xmath174 rather than @xmath54 points . in summary , @xmath175 where @xmath176 is the same event as @xmath159 , but calculated with respect to an intitial configuration of @xmath174 points ( and similarly for @xmath75 ) . clearly , @xmath177 where @xmath65 is area of any of the four regions in figure 3 , hence @xmath178 .",
    "hence , @xmath179 but recall that @xmath167 is the event that the distance between @xmath27 and @xmath75 is at least two , so clearly @xmath180 ( the right constant is @xmath72 rather than @xmath181 because we have to consider points close to @xmath182 ) .",
    "it follows that the first square - bracketed term in ( [ eq : decomp ] ) will be negative for all @xmath26 , and it just remains to bound the positive contributions coming from @xmath168 or @xmath170 .",
    "the definition of @xmath168 immediately implies , however , by the same argument used to obtain part ( ii ) of the claim , that it contributes negligibly .",
    "hence , it remains to show that @xmath183 but @xmath170 occurs if and only if @xmath27 is placed in a strip of width @xmath184 inside the disc boundary and then @xmath75 is subsequently also placed inside this strip and at distance @xmath48 from @xmath75 . since the points are placed independently and uniformly at random , @xmath185 this already suffices to prove that var@xmath186 and hence to prove part ( i ) of the claim .",
    "to get rid of another @xmath187 factor , it suffices to show that @xmath188 , and hence to show that @xmath189 , conditioned on the assumption that @xmath27 is at distance at most @xmath190 from the disc boundary .",
    "but there are a.a.s . on the order of @xmath191 points in this annulus and",
    "we already know that there are a.a.s .",
    "order @xmath0 points in @xmath130 , so we are done .",
    "+    we now return to the description of step 1 , which we break down into three substeps : +   + _ step 1a : _ each point performs , in time @xmath48 , some tests in an attempt to rule out that it belongs to @xmath130 .",
    "if all these tests fail , then it turns blue to signal `` i believe i might belong to @xmath130 '' .",
    "the idea here is that each point does something very similar to checking the four regions as in figure 3 , and turns blue if and only if at least one of those four regions is empty .",
    "a point can not test exactly this condition , since it does not know where the centre @xmath141 of the disc is .",
    "however it can , for example , fix some large number @xmath192 , rotate a half turn and , at equal intervals of @xmath193 , scan the four quadrants in its @xmath73-neighborhood , as seen from its current orientation . each time it scans",
    ", it just wants to decide if each of the four quadrants is empty or not , and assumption 11 implies that this can be done in time @xmath48 . hence all @xmath192 tests can be performed in time @xmath194 .",
    "it is clear that , for a sufficiently large but now fixed @xmath192 , the set of blue points will have the properties identified in claim [ clm : boundsize ] , that is , there will at least @xmath195 and a.a.s . at most @xmath196 blue points .",
    "furthermore , for @xmath197 , the blue points will a.a.s .",
    "all lie within distance @xmath198 , say , of the disc boundary .",
    "as preparation for steps 1b and 1c , the points which do not turn blue also have to make a choice :    \\(a ) turn green if you can see at least one blue point at distance at most @xmath199 from yourself .",
    "since @xmath107 is an absolute constant , this can be incorporated into the algorithm .",
    "\\(b ) turn yellow if you see no blue point at distance less than @xmath199 , but you do see a blue point at distance less than @xmath73 ,    \\(c ) if you see no blue point at distance less than @xmath73 , do nothing . + there is an issue of synchronisation here , but since there is an absolute constant time in which every point can decide whether to turn blue or not , we can also ensure that every point has decided blue / not blue before the choices ( a)-(c ) are made , without needing perfectly reliable clocks .",
    "assumptions 10 and 11 also guarantee that the latter choices can all be made within an absolute constant time .",
    "hence step 1a runs in an absolute constant time .",
    "+    to complete step 1 , the idea is that the leader should come from among the points which are blue after step 1a . since there are a.a.s .",
    "@xmath200 such points , if each of them were to generate at least @xmath201 random bits , independent of all the others , then for @xmath202 , a.a.s .",
    "there would be a unique point which generates the largest binary number .",
    "there are basically three problems to be solved in order to turn this into an algorithm :    \\(i ) how do the blue points know how many bits to generate ?",
    "\\(ii ) how do they store the bits ?",
    "\\(iii ) how do they check their numbers against those generated by all other blue points ? + step 1b will deal with ( i ) and ( ii ) , whereas step 1c will deal with ( iii ) .",
    "as already mentioned , problem ( ii ) could be ignored if we allowed each point to possess unlimited memory , and to overcome this is where the algorithm becomes most technical .",
    "+   + _ step 1b : _ each blue point scans all its green neighbors .",
    "lemma [ lem : graph ] implies that , for @xmath197 , a.a.s",
    ". every blue point will scan at least @xmath203 ( say ) and at most @xmath123 green neighbors .",
    "as explained in assumption 10 , a blue point can actually scan its surroundings in such a way that it does nt miss any green points and identifies them at a rate of @xmath97 points per second , and hence can complete the scan in time @xmath123 .",
    "now , since the total number of blue points is @xmath204 , and @xmath107 is an _ absolute _ constant , if every blue point generated as many random bits as it had green neighbors , then a.a.s .",
    "there would be a unique largest binary number , provided @xmath115 is sufficiently large .",
    "each time a green point is scanned , the blue scanner generates a random bit .",
    "these bits now need to be stored somewhere , and since their number a.a.s .",
    "goes to infinity , we can not assume the blue point stores them in its own internal memory .",
    "this is where the yellow points enter the picture .",
    "a blue point will choose points amongst its yellow neighbors to store two copies of the random number it generates , which we call the s - copy ( s for `` stationary '' ) and the m - copy ( m for `` mobile '' ) .",
    "the reason for two copies and for our curious terminology will become clear in step 1c . for present purposes , the basic idea is that , each time a green point is scanned then a random bit is generated and two yellow points selected to store it . each selected yellow point receives two bits , the first is the random bit generated by blue , the second determines whether it belongs to the s - copy or the m - copy ( say 0 for s and 1 for m ) .",
    "as soon as a point accepts a storage request then it turns purple , to indicate that it is no longer available for such requests .",
    "thus each storage point belongs unambiguously to either the s- or the m - copy of a unique number .",
    "there is one more issue to deal with , namely the bits of ( a copy of ) a blue chief s number must be stored in such a way that they form an unambiguous binary number , which can be `` read from left to right '' unambiguously in step 1c .",
    "this is achieved as follows . the first time a blue point generates a random bit and finds two yellow points to store it",
    ", it also signals to them that they are its _ headmen_. the s - headman turns brown and the w - headman turns orange .",
    "the headmen now also reposition themselves so that    \\(i ) each remains within distance @xmath73 of its blue _ chief _    \\(ii ) the line segment from the headman to the chief is approximately at right angles to the boundary of the disc and directed outwards from the disc    \\(iii ) the w - headman is to the right of the s - headman , seen from the center of the disc .",
    "+ since all the points in question are a.a.s . within distance @xmath205 of the disc boundary",
    ", they can make good estimates of the various directions involved and , together with assumptions 8 and 9 in particular , it is clear that they can reposition themselves so as to satisfy ( i)-(iii ) in time @xmath48 .",
    "their blue chief tracks their movements ( assumption 8) and so is aware of their exact resting locations .",
    "now it is time to scan the second green neighbor , generate the second random bit and select two yellow points to store it . as well as storing their respective bits , these two hitherto yellow ( and now purple points ) now walk toward their chief and reposition themselves somewhere on the line segment between their chief and the appropriate headman . using assumptions 8 - 9 , this manoeuvre can be successfully accomplished in time @xmath48 .",
    "once in position , these points take over the role of headman , whereas the previous headmen turn new colors to indicate that they are now _ tailmen_. in subsequent steps , the selected storage points reposition themselves somehere on the line segment between their chief and the current appropriate headman .",
    "once they have done so , they take over the role of headman , and the previous headmen turn some neutral color to indicate that they are now _",
    "middlemen_.    there is one final subtlety .",
    "since the total number of blue points is @xmath204 , on average any yellow point will be able to see no more than @xmath206 blue points .",
    "putting it another way , on average no more than @xmath206 blue points will be competing for the services of any yellow point as storage space .",
    "since the total number of yellow points will be close to @xmath207 times the total number of green ones , on average there will be enough storage space to go round .",
    "however , we do not see how to rule out the possibility that there may locally be much denser clusters of blue points .",
    "a priori , it follows from claim [ clm : boundsize ] that up to @xmath208 blue points may be visible from any yellow point . in that case , it can happen that a blue point runs out of storage space before it has scanned all its green neighbors .",
    "if that is the case , we shall let the blue point `` drop out of contention '' , i.e. : it abandons the generation of its random number",
    ". it then turns pink to indicate that it is out of contention for leadership , and this information is relayed to all the current members of its s- and w - strings , who subsequently revert to white ( we let this be the default color of a point that is nt doing anything ) . note that , because the points in these strings lie on a straight line from their chief , they can not receive signals from the latter directly , so information has to be relayed along the string .",
    "this can still be accomplished in time @xmath123 , however .",
    "+   + _ step 1c : _ once a blue point has completed step 1b , and if it has not turned pink , it signals to the headman of its m - string to `` start walking '' .",
    "the idea here is that the m - string will now walk around the boundary of the disc such that the interior of the disc is on its right .",
    "the headman leads the way and the other points in the string follow ( see assumption 8) .",
    "as it walks , it must follow the trail of blue and pink points , and for each blue point it must consult the s - copy of that point s number and compare it with its own .",
    "the two numbers are compared bit - by - bit ( we specify the exact protocol below ) and the comparison is aborted once a bit is found where the two numbers differ .",
    "if the s - number has a 1 in this position , the m - headman immediately decides that its chief is out of contention for leadership .",
    "it stops walking once it returns to its starting point , which it recognises by the fact that the s - string it just read is identical to its own ( it knows when it s finished reading a string since it recognises a tailman by the particular color reserved for tailmen ) .",
    "if it returns without having encountered any s - number greater than its own , it signals to its chief that it is leader .",
    "the following considerations ensure that this procedure a.a.s",
    ". achieves what we want .",
    "firstly , because of claim [ clm : boundsize ] , a.a.s .",
    "all the chiefs are located very close to the disc boundary and hence a wandering headman can make sure it does nt miss any blue or pink points while keeping the interior of the disc on its right . secondly , the lower bound on @xmath54 ensures that a.a.s .",
    "exactly one chief will be declared leader , provided @xmath197 .",
    "note that it does nt matter if some chiefs already dropped out by turning pink in step 1b , since there will a.a.s .",
    "be @xmath209 of them left in the game .",
    "thirdly , by lemma [ lem : read ] , a.a.s .",
    "each m - string will complete its walk in time @xmath2 , provided it does not does not waste any time `` queueing '' .",
    "this is the only subtle issue here .",
    "since an m - string may read anything from one to @xmath210 bits of an s - string , there may be many m - strings reading the same s - string simoultaneously . to avoid queues developing",
    ", we need to have an appropriate reading protocol .",
    "one solution is to have the m - headman read the s - bits one by one : it is no problem for it to follow the trail of s - bits , since they lie in a straight line .",
    "alternatively , each s - bit could keep a laser shining on its successor to point it out , see assumption 9 .",
    "simoultaneously , the m - headman requests bits from its own string to compare with .",
    "imagine that each point in the string maintains two copies of its bit , one of which is permanent and the other in short - term memory .",
    "the headman requests bits from the first middleman .",
    "whenever a middleman receives a request for a bit , it empties the contents of its short - term memory and then requests the contents of the short - term memory of the next point along the string . in this way",
    ", bits can be passed along the m - string to the headman at a rate of @xmath97 bits per time unit , who can then compare them one - by - one with the trail of s - bits .",
    "this protocol ensures that the s - strings are completely `` passive '' and hence can be read simoultaneously by arbitrarily many m - headmen without any queues developing .    one final comment : in steps 1b and 1c we have not bothered about trying to synchronise the activities of different actors .",
    "i think it is clear that this is not a problem . a.a.s .",
    "steps 1b and 1c will , as described , lead to one chief identifying itself as leader in time @xmath2 .",
    "once it does so , it can initiate step 2 by turning red .",
    "note that , during step 1 , some points in the configuration will have changed their locations .",
    "however , a.a.s .",
    "all these points were initially within distance @xmath205 of the disc boundary and hence their movements will not affect the connectedness of the communication graph . hence , a.a.s .",
    "step 2 will subsequently still succeed and the whole algorithm terminate in time @xmath2 .",
    "[ rem : on3 ] the above algorithm would also work if @xmath211 and the constant @xmath212 were somehow known in advance .",
    "when @xmath213 , then the blue points will generate @xmath200 random bits , but this is not a problem .",
    "if @xmath212 is not specified , then the difficulty is rather that the constant we denoted @xmath107 will now depend on @xmath212 , since it depends on the size of @xmath130 via @xmath214 and @xmath215 .",
    "in fact , it is only the size of @xmath216 that is problematic , as this will now be @xmath217 , whereas we can see from ( [ eq : expect ] ) that @xmath218 will a.a.s .",
    "remain bounded by an absolute constant times @xmath0 .    as explained in the proof ,",
    "the constant @xmath107 determines the amount of competition , on average , for yellow storage space . to be sure",
    "there is enough storage space to go round on average , the ratio of yellow to green points must be sufficiently large , in other words the search radius for green points must be sufficiently small , depending on @xmath212 .",
    "we do not see how to get around this problem .",
    "amusingly , though , if the points somehow knew that their average density was @xmath200 , then they would realise that generating @xmath200 random bits is extremely wasteful , since it would suffice with @xmath219 bits .",
    "the issue of whether there is a better alternative than counting neighbors for the task of estimating how many random bits need to be generated by a blue point will be taken up in question [ quest : estdiam ] below .",
    "[ rem : storage ] if we allowed each point to possess unlimited storage capacity , then the description of steps 1b and 1c could be simplified considerably",
    ". there would be no need for the colors grren and yellow .",
    "each blue point could just count all its neighbors , generate one random bit per neighbor and store the entire binary number .",
    "it could then choose a headman from amongst its neighbors and write a copy of the number to the headman s memory .",
    "the headman would then walk around the boundary , comparing its number with that stored in each blue point .",
    "it would a.a.s .",
    "know it has returned to its own blue chief when it reads a number equal to its own .",
    "the fact that our algorithm does not utilise unlimited storage capacity per point seems important , however .",
    "another interesting observation is that the kinds of computations done in steps 1b and 1c are very primitive , basically only counting and comparing strings .",
    "of course , the sophistication of the procedure lies in the execution of `` higher - level '' tasks such as scanning , pointing and following .",
    "these are the kinds of abilities a sceptical reader might object to .",
    "in this section , whenever we formulate a precise question it should be understood that the 11 assumptions made in section [ sect : heart ] are valid .",
    "however , just as important an issue going forward is whether there are algorithms which work just as well under some weaker set of assumptions about how points can interact .",
    "this should be kept in mind at all times .",
    "+    for the task of merging at a single point to be strictly meaningful , one must assume from the outset that one is dealing with point particles which are capable of locating other point particles with infinite precision .",
    "this is true in both the classical multi - agent rendezvous setting ( rp-5 ) and in ours ( assumption 4 in section [ sect : heart ] ) .",
    "the points are idealisations and each particle has , in `` reality '' a fixed , if small size . in this paper , we have considered `` generic '' configurations of points in a disc of radius @xmath0 in @xmath28 . in order to ensure that the communication graph would be a.a.s .",
    "connected , it was required that the average density of particles be @xmath220 , hence goes to infinity with @xmath0 .",
    "what this implies is that , once the idealisation of point particles is removed , then generic configurations of particles will a.a.s .",
    "not be connected and rp-4 fails .",
    "this seems like a serious obstacle to making practical sense of the whole project of studying rendezvous for generic configurations of agents .",
    "so , if you did nt already consider theorem [ thm : main ] just an intellectual curiosity , then that seems even more apparent now .",
    "however , it is not clear that all is in vain , especially if one is satisfied with a randomised algorithm that a.a.s",
    ". succeeds , rather than a fully deterministic procedure .",
    "suppose the average point density is @xmath221 , this obviously being the most `` realistic '' setting , from what we have just said . almost surely , there will be isolated points in this regime , but there will also be large connected components , so an isolated point does not necessarily need to perform a brownian motion in order to make contact with other points , something which ( as stated earlier ) would on average take an infinite time to succeed .",
    "this leads to our first and most important question :    [ quest : theta - one - uni ] _ in the notation of theorem [ thm : main ] , suppose @xmath222 . does there exist a randomised merging algorithm which a.a.s .",
    "runs in finite time and , if so , how quickly as a function of @xmath0 ?",
    "in particular , consider these issues when @xmath223 .",
    "the same questions can be asked in the classical setting , i.e. : assuming rp 1 - 5 , at least as long as we ignore the problem of storage capacity . _",
    "[ quest : theta - one - connect ] _ same question as above , but conditioned on the initial communication graph being chosen uniformly at random from among all connected such graphs on @xmath54 nodes .",
    "even more `` realistically '' , one could condition on the graph being connected and the number of points per unit area being bounded .",
    "once one accepts that each particle has a finite size , a second obvious conclusion is that , in reality , rendezvous means that all the particles come to occupy some sufficiently small region of the plane , rather than merge at a single point robots to have rendezvoued once they were all inside a disc of radius @xmath224 . ] .",
    "an intermediate step , which is more mathematically appealing , is to retain the assumption of point particles but redefine the rendezvous condition in this way , and see if it leads to a significant reduction in the run - times of algorithms . in theorem",
    "[ thm : main ] , the run - time is already linear in @xmath0 , so relaxing the definition of rendezvous can not improve performance significantly , at least as long as we want some non - trivial convergence of the particle swarm , that is to a disc of radius @xmath123 . we think this emphasises the fact that our algorithm is really a procedure for choosing a _ leader _ , rather than for merging . our algorithm for choosing a leader can in turn be broken down into two main steps . in the first step ,",
    "the graph boundary @xmath130 is identified approximately . in the second step , the points which think they might be in @xmath130 assign representatives to walk around the disc boundary comparing randomly generated binary strings .",
    "this second step seems much more contrived than the first .",
    "in addition , the eventual merging will take place at the leader s location , which is a.a.s .",
    "very close to the disc boundary .",
    "in contrast , classical merging procedures involve some kind of repeated `` averaging '' , which means that , for a generic configuration of points in a disc , those closer to the boundary will gradually move inwards , and the eventual merging will take place somewhere close to the center of the disc .      [",
    "quest : twostep ] _ in the setting of section 2 , is there a linear - time algorithm which does not have the two - step character of ours , in which first a leader is chosen and then all the points move to its location ? _    on the other hand , we can seek alternative linear - time algorithms after relaxing the definition of rendezvous so that the points are only required to come sufficiently close together . since part of the problem is to specify exactly how close , we will not formulate a precise question , though at the very least , they should all be required to move inside some disc of radius @xmath123 . in this relaxation",
    "it is also natural to seek an algorithm which involves less sohpisticated communication between agents than that allowed by the assumptions of section [ sect : heart ] .",
    "some communication is probably still necessary , however .",
    "if we consider the asy - algorithm , for example , and again ignore storage issues , it was already noted in section [ sect : intro ] that the time taken to execute any non - trivial convergence is @xmath49 . indeed , extending a comment made in section [ sect : intro ] , we conjecture that the same is true of any algorithm which assumes rp 1 - 5 .",
    "it would also be interesting to determine the actual ( expected ) rate of convergence for such algorithms , for example asy , for generic connected configurations . as already mentioned in section [ sect : intro ] , we are not aware of any rigorous treatment of this problem in the literature . +    if , instead of questioning either the assumptions made in section [ sect : heart ] or the philosophy of considering generic configurations , we accept these principles , then there are still many unanswered questions",
    ". what jumps out immediately is the upper bound on @xmath54 assumed in theorem [ thm : main ] .",
    "this played two crucial roles :      \\(ii ) it implied that each point a.a.s .",
    "had @xmath2 neighbors , indeed @xmath123 neighbors , though see also remark [ rem : on3 ] .",
    "thus , by counting its neighbors , a blue point had a way to estimate how many random bits it needed to generate .",
    "+    first consider ( i ) .",
    "here it is obviously crucial that the points are distributed in a disc , that is , a bounded region of @xmath28 with a `` nice '' boundary .",
    "this leads us to our next two questions .",
    "the first is a bit vague :    [ quest : lebmeas ] _ for which sequences @xmath225 of lebesgue measurable compact regions in @xmath28 , satisfying area@xmath226 as @xmath25 , does an analogue of theorem [ thm : main ] hold ?",
    "the analogue we have in mind here is that @xmath54 points are distributed uniformly and independently in @xmath227 , where @xmath54 grows sufficiently fast so that the communication graph is a.a.s",
    ". connected , but not so fast that any point is likely to have more than @xmath2 neighbors .",
    "_    an alternative track , which we find more appealing , is to consider the multi - agent rendezvous problem on a compact 2-dimensional manifold without boundary .",
    "the simplest question , to which we have no answer , is the following :    [ quest : sphere ] _ let @xmath228 denote the @xmath72-sphere in @xmath229 of radius @xmath0",
    ". suppose @xmath54 points are distributed uniformly and independently on @xmath228 , where @xmath54 satisfies the same conditions as in theorem [ thm : main ] .",
    "under assumptions 1 - 11 , does there exist a merging algorithm which a.a.s",
    ". runs successfully in time @xmath2 ?",
    "_    we have not seen the latter question asked even in the classical setting , where rp 1 - 5 are assumed .",
    "perhaps this is just our ignorance , or perhaps it is because , if one thinks of a sphere as representing the earth , then a compass provides a universal point of reference and rendezvous can trivially be accomplished in time linear in the diameter .",
    "there are two further things to note about the problem on a @xmath72-sphere :    \\(a ) a brownian motion confined to @xmath228 will a.a.s .",
    "arrive within distance one of any point in finite time .",
    "hence there is certainly _ some _ merging procedure on @xmath228 which a.a.s .",
    "runs in finite time . for example",
    ", two points could merge once they see each other , with a point choosing a neighbor at random to merge with if it has more than one .",
    "once points become isolated they could perform a brownian walk .",
    "the expected running time of even this rather stupid algorithm is unclear to us , however , especially in light of assumption 1 in section [ sect : heart ] .",
    "\\(b ) something close to question [ quest : sphere ] arises if we try to extend our algorithm to higher dimensions .",
    "consider an initial configuration of points inside a ball in @xmath229 .",
    "step 1a of our procedure would identify a subset of blue points close to the boundary of the ball , hence close to a @xmath72-sphere .",
    "we are not quite left with question [ quest : sphere ] , since these points can also move through the interior of the ball now .",
    "however , these observations suggest that a different approach may also be necesary in higher dimensions . +      [",
    "quest : denser ] _ can theorem [ thm : main ] be extended to even denser configurations of points ?",
    "in other words , is there a linear - time merging algorithm on the disc which succeeds even when the average point density is super - linear ? _",
    "an additional observation here is that the method for generating random numbers described in step 1b of our algorithm is very inefficient when @xmath230 since , as long as @xmath54 grows polynomially in @xmath0 , it would suffice for each blue point to generate @xmath219 bits , whereas in fact each blue point generates on the order of @xmath231 bits .",
    "an alternative procedure we considered is to have the blue points estimate @xmath0 , the diameter of the disc .",
    "we considered a specific , and rather complicated , signalling procedure , whereby the blue points send signals to their neighbors which are relayed inwards in such a manner that , a.a.s .",
    ", the signals bounce back only once they have reached very close to the center of the disc .",
    "the details are not important as we could not prove that our procedure worked , but we can state another question :    [ quest : estdiam ] _ as an alternative to step 1b , is there a procedure by which the blue points can estimate the diameter @xmath0 of the disc , up to an absolute multiplicative factor say , a.a.s . in time",
    "@xmath2 ? _    we conclude with a couple more questions which seem interesting , though are perhaps less important .",
    "one striking aspect of our `` choose a leader then move to it '' algorithm is that all the points merge at one place .",
    "this is also true of classical rendezvous procedures .",
    "noting also assumption 1 , we can ask    [ quest : intermediate ] _ in the setting of section 2 , is there a linear - time algorithm which includes merging of groups of points at intermediate steps and at different locations , rather than all having all the points merge only at the end at a single location ? _        beyond the discussion above , several other possible lines of investigation present themselves naturally , though they take us into even less well - defined territory . for example , one might consider initial configurations of points which are not uniform i.i.d . ultimately , one can question the various assumptions listed in section [ sect : heart ] , and try to formulate an interesting problem under some other set of assumptions .",
    "last but not least , in the setting of section [ sect : heart ] , is there a really simple linear - time algorithm which we have completely missed , which would render most of this manuscript unnecessary ?",
    "h. ando , y. oasa , i. suzuki and m. yamashita , _ distributed memoryless point convergence algotirhm for mobile robots with limited visibility _ , ieee trans .",
    "robotics automation * 15 * ( 1999 ) , no.5 , 818828 .",
    "h. ando , y. suzuki and m. yamashita , _ formation and agreement problems for synchronous mobile robots with limited visibility _ , in : proceedings of the 1995 ieee international symposium on intelligent control ( isic 1995 ) , pp .",
    "453460 .",
    "b. degener , b. kempkes , t. langner , f. meyer auf der heide , p. pietrzyk and r. wattenhofer , _ a tight runtime bound for synchronous gathering of autonomous robots with limited visibility _ , in : proceedings of the 23rd acm symposium on parallellism in algorithms and architectures ( spaa 11 ) , pp . 139148 ( 2011 ) .",
    "s. martinez , f. bullo , j. cortes and e. frazzoli , _ on synchronous robotic networks - part ii : time complexity of rendezvous deployment algorithms _ , ieee trans .",
    "control * 52 * ( 2007 ) , no.12 , 22142226 ."
  ],
  "abstract_text": [
    "<S> the classical multi - agent rendezvous problem asks for a deterministic algorithm by which @xmath0 points scattered in a plane can move about at constant speed and merge at a single point , assuming each point can use only the locations of the others it sees when making decisions and that the visibility graph as a whole is connected . in time </S>",
    "<S> complexity analyses of such algorithms , only the number of rounds of computation required are usually considered , not the amount of computation done per round . in this paper , we consider @xmath1 points distributed independently and uniformly at random in a disc of radius @xmath0 and , assuming each point can not only see but also , in principle , communicate with others within unit distance , seek a randomised merging algorithm which asymptotically almost surely ( a.a.s . ) runs in time @xmath2 , in other words in time linear in the radius of the disc rather than in the number of points . under a precise set of assumptions concerning the communication capabilities of neighboring points , we describe an algorithm which a.a.s . </S>",
    "<S> runs in time @xmath2 provided the number of points is @xmath3 . </S>",
    "<S> several questions are posed for future work . </S>"
  ]
}