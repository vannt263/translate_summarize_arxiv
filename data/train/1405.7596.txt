{
  "article_text": [
    "communication complexity is a tool which has been proven successful in proving lower bounds in wide range of areas . since its inception in @xcite ( where it was used as a measure of amount of communication which has to be performed between two separate groups of processors in order to compute certain functions ) it has been a field of constant research with an increase of scientific interest in the recent years .",
    "being defined as a very general problem of multiple parties trying to collaboratively compute an outcome of a function using as small amount of inter - communication as possible , the notion was being used for examining properties of bounds on complexity of streaming algorithms ( consult @xcite ) , circuit complexity ( for instance @xcite ) , lower bounds on data structure performance ( such as @xcite ) and much more .",
    "great , short introduction to communication complexity can be found in @xcite whereas a definite treatment of the topic together with many application examples on application is contained in @xcite .",
    "+ in the general multiparty setting we have players @xmath3 sharing the input @xmath4 . the goal is to compute value @xmath5 for a particular function @xmath6 , with the _ complexity _ being defined as a minimal number of bits they have to communicate among themselves to do so . two most common models according to which information is shared between players are    * * number - in - hand * ( @xmath7 ) in which player @xmath8 knows only @xmath9 * * number - on - the - forehead * ( @xmath10 ) where player @xmath8 knows all @xmath11 for @xmath12 ( @xmath9 is written on his forehead ) .",
    "we focus on the @xmath10 model , which was introduced by chandra , furst and lipton in @xcite .",
    "one of the reasons for conducting research on @xmath10 multiparty model is the fact that obtaining a _ strong _ communication complexity lower bound for a particular function @xmath6 would cause its non - membership in complexity class * @xmath13 * ( informally - functions computed by boolean cicruits of constant depth and polynomial size where set of possible gates include the _ modulo counter _ for some fixed constant ) .",
    "details of this exposition can be found for instance in @xcite . + pointer - jumping problem is considered as a good candidate for this task . in this",
    "case inputs @xmath14 are essentially functions and players want to collaborate in computing the result of convoluting them .",
    "we will describe the problem more precisely together with the current state of research in following sections .",
    "it is worth noting that in the @xmath10 model players share _ * almost * _ all the information contained in the input .",
    "this means that it should be very hard to prove lower bounds in such model .",
    "another reason for considering the pointer - jumping problem is its generality - one may see the address shifting , multiplication and many others as a special case of this function .",
    "in this work we concentrate on the classical , boolean version of pointer jumping problem ( @xmath0 ) .",
    "the problem is build on top of the graph @xmath15 being a directed graph with @xmath16 layers of vertices . the first layer , 0 , consists of just one vertex @xmath17 .",
    "each of the consecutive @xmath18 layers ( numbered @xmath19 ) contains exactly @xmath20 vertices .",
    "the last layer consists of two vertices labeled @xmath21 and @xmath22 .",
    "these labels denote the possible outcome of the problem . in graph @xmath15 each vertex from layer @xmath8 is connectected with a directed edge with each vertex from layer @xmath23 .",
    "the input to @xmath0 problem is a graph @xmath24 being a subgraph of @xmath15 ( on the same set of vertices ) where each vertex apart from layer @xmath25 has _",
    "outcome , or the solution of the problem , is the label of the vertex in the layer @xmath25 ( which is @xmath21 or @xmath22 ) which is obtained by following the directed path starting from vertex @xmath17 ( layer @xmath21 ) through all the layers of @xmath24 .",
    "consider @xmath25 players numbered @xmath26 sitting in a circle and having a blackboard .",
    "for each @xmath8 , player @xmath27 has the set of edges comming from layer @xmath28 to @xmath8 written on his forehead .",
    "this means that each of players knows all the edges of the graph apart from those assigned to him .",
    "computation in this model is being held in a following way : players communicate in a fixed order @xmath29 . each of the players , based on the information communicated by previous players , as well as information he can observe ( data writted on foreheads of all other players ) outputs some bits and writes them on the blackboard . the last player , namely @xmath30 outputs only one bit @xmath21 or @xmath22 being the outcome of his computation .",
    "the outcome is supposed to be the result of pointer jumping process on the graph @xmath24 .",
    "figure 1.1 shows the sample instantiation of pointer - jumping problem with a graph @xmath31 .",
    "we have @xmath32 players , each of them stores edges marked by respective dotted rectangles .",
    "following black dots we find out that @xmath33 should output @xmath22 as the outcome of computation .",
    "problem ]    when defining a playing protocol @xmath34 , and denoting strings of bits outputed by consecutive players by @xmath35 we may define a _",
    "total communication cost _ of protocol @xmath34 as @xmath36 the total number of bits output by all players",
    ". we may be also interested in _ maximal communication cost _ which is @xmath37    we are mainly interested in communication complexity of a problem ( and not a particular protocol ) , which we may define as @xmath38 i analogous was we define the maximal communication complexity .",
    "we consider only deterministic protocols , namely we require the protocol @xmath34 to be always correct when computing the solution . +",
    "* remark*. the simplest protocol for solving @xmath0 has total cost @xmath39 .",
    "indeed , the player @xmath40 just outputs all the values written on the forehead of @xmath30 ( which is a string of n - bits ) .",
    "now , player @xmath30 can follow the pointer up to layer @xmath18 , and then apply information output by @xmath40 to compute the final answer .",
    "this shows that @xmath41 + * remark*. it is worth noticing that the order in which players speak out is crucial . in any other case",
    "one may come up with a protocol of total cost @xmath42 . indeed ,",
    "if the order differs from @xmath43 then there exist indices @xmath44 such that @xmath45 speaks before @xmath8 .",
    "the protocol involves only players @xmath45 and @xmath8 :    1 .",
    "@xmath46 : follows the pointers up to layer @xmath47 .",
    "outputs the index of the resulting vertex , which takes @xmath48 bits 2 .",
    "@xmath27 : as @xmath44 he can just follow the pointers from the vertex outputted by @xmath46 up to the last layer",
    "let s start with a simple case @xmath49 .",
    "it is easy to show that @xmath50 .",
    "indeed , otherwise one can easily construct to different pairs of inputs @xmath51 and @xmath52 such that @xmath53 but both for @xmath54 as well as for @xmath55 @xmath56 outputs the same value .",
    "@xmath57 seeing in both cases exacltly the same data has to output the same final value of @xmath6 which is a contradiction .",
    "problem gets much more complex for @xmath58 . + as disscussed in the previous section , proving a _ strong _ lower bounds on communication complexity for @xmath0 would result in proving @xmath59 . precisely speaking we have the following    if there exist constants @xmath60 such that for multiparty total communication complexity in @xmath10 model for * @xmath61 * we have @xmath62 then @xmath59 .    for more details",
    "please consult @xcite or @xcite .",
    "as for now such lower bound is not known .",
    "in fact , the best known lower bound for @xmath0 comes from viola and widgerson @xcite and states    [ theo : lower ] @xmath63 .",
    "in particular @xmath64 .    note that this result ,",
    "even though it is the best currently known lower bound , provides non - trivial result only for small values of @xmath25 , in particular for @xmath65 the resulting bound is already trivial . on the other side for a long time time following",
    "conjecture was open    there exists nondecreasing function @xmath66 such that for all @xmath25 , @xmath67    looking at the hard lower bound for @xmath68 as well as some weaker versions of communication model ( where such statement is true ) one could claim that the conjecture should hold also for a full @xmath10 model .",
    "however , pudlak , rodl and sgall in @xcite by considering a problem @xmath69 ( which is a subcase of @xmath0 where functions given to players @xmath70 are all permutations ) showed a tricky protocol proving a sublinear bound    [ theo : perm ] @xmath71    this result has been extended by brody and chakrabarti in @xcite to the full @xmath0 problem :    [ theo : sublinear ] @xmath72 and in particular @xmath73    the theorem clearly falsifies the _ linear lower bound _ conjecture .",
    "these are the first and by far best upper bounds for the @xmath0 problem .",
    "proving better complexity bounds of pointer jumping and narrowing the current gap seems to be a deep and difficult problem .",
    "thus , different simplified versions of @xmath0 are actively being considered in hope for much stronger bounds and as motivating examples for research of original problem :    * restricting the set of functions which can be provided as an input for the player * restricing the @xmath10 model of communication    we describe such kind of modifications in following sections .",
    "first simplified variant has been already described in the previous section and involves restricting functions owned by players @xmath74 to permutations . in this variant ,",
    "a sublinear protocol was given ( theorem [ theo : perm ] ) which motivated brody and chakrabati to develop a sublinear protocol for general @xmath75 problem ( and uses the @xmath76 protocol as a black box ) + another simplified problem is @xmath77 which imposes a tree structure on the graph @xmath78 . in this setting ,",
    "the underlying graph is a @xmath25-height tree where each vertex from layer @xmath21 through @xmath79 has @xmath80 children laying in the next layer and vertices from layer @xmath18 have two children , namely @xmath21 and @xmath22 .",
    "one can easily see , that such tree is in fact a subgraph of regular @xmath78 used in a general @xmath81 model .",
    "indeed , every layer contains not more than @xmath20 vertices ( layer @xmath79 contains exactly @xmath20 vertices ) .",
    "interestingly , the lower bound coming from the theorem is actually a lower bound for @xmath77 , so that viola and widgerson show theorem [ theo : lower ] in an even stronger setting    @xmath82    remarkably , such a lower bound for @xmath77 is also the best known lower bound for @xmath0 which suggest that it can be significantly improved . on the other hand , due to the fact of such big restrictions imposed on structure of functions ,",
    "one may easily show that    @xmath83    which implies that the bounds are tight in this particular case .",
    "indeed , it is enough for @xmath57 to output the result of following the pointers from every vertex of layer @xmath22 .",
    "as there are only @xmath84 vertices in this layer , such number of bits is enough for player @xmath30 to correctly produce the answer .",
    "+ another version of @xmath0 being considered is @xmath85 , a version of @xmath0 in which the last layer consists of @xmath20 vertices ( and not of @xmath86 as in the case of @xmath0 ) so that the output is a number @xmath87 rather than binary .",
    "for this version , the trivial protocol has complexity @xmath88 .",
    "damn , jukna and sgall in @xcite proposed a simple protocol with complexity @xmath89 for @xmath85 where @xmath90 means the @xmath25-th iterated logarithm .",
    "unfortunately their protocols shows no nontrivial bounds for @xmath81 .",
    "due to the difficulty of improving lower and upper bounds for general @xmath10 models , different restricted models with restrictions are being considered .",
    "restricting the communication model makes the bound range easier to prove and provides additional techniques and ideas potentially leading to succesfull attacks to general @xmath10 model .",
    "we discuss three different models in this section together with respective results .",
    "+ * conservative protocol * + here we require that a player @xmath27 can see all the layers ahead of him but only a _ composition _ of layers behind him . to be precise , if by @xmath91 we denote a edges from layer @xmath47 to @xmath45 ( which is in fact a function ) then player @xmath27 can see all the functions @xmath92 but * only * a composition of previous functions , namely @xmath93 .",
    "intuitively , @xmath27 knows the result of following the pointers of all previous layers up to level @xmath28 , but can not see the way this result has been obtained .",
    "+ conservative protocols were introduces by damn , jukna and sgall in @xcite while noticing that the protocol for @xmath85 is in fact conservative . restricting protocols in such way",
    ", one can prove much stronger bounds on complexity , as shown in @xcite :    in a conservative model @xmath94    which shows that such restrictions lead to almost linear lower bounds .",
    "+ * myopic protocol * + protocol designed by damn , jukna and sgall possess another important property .",
    "@xmath27 can see only edges from layer @xmath8 to @xmath23 .",
    "such protocol is called _ myopic _ due to the described property . formally , using the functional notation described above , @xmath27 can produce the ouput based on ( apart from the information coming from previous players ) functions @xmath95 .",
    "the model has been introduced in @xcite .",
    "j. brody in @xcite proved following theorem    in conservative setting for @xmath0 some player must communicate @xmath96 bits and there exists protocol achieving this bound .",
    "moreover , players have to communicate at least @xmath20 bits in total .",
    "in other words @xmath97 and @xmath98 .    * collapsing protocol * + another very interesting restriction imposed on the protocol is essentialy reverting the _ conservative _ model .",
    "this time we allow player @xmath27 to know all the previous layers , but restrict his view of the layers in front of him to its composition .",
    "namely , @xmath27 sees @xmath99 as well as @xmath100 .",
    "such restriction seems to be particularly interesting mostly due to the sublinear protocol from theorem [ theo : sublinear ] .",
    "in fact , deeper look at the protocol ( exposition of which can be found in appendix ) shows that during communication , _ every _ player apart from @xmath56 behaves in a _ collapsing _ way - he sees only the composition of layers in front of him .",
    "+ the following question seems natural : _ is the fact that one of players is noncollapsing a necessary condition for obtaining sublinear upper bound?_. brody and chakrabati in @xcite prove that , indeed , this is the case .",
    "we have the following    in a collapsing protocol for @xmath0 there exists a player communicating at least @xmath101 bits .",
    "in other words @xmath102 .    thorem shows that even one noncollapsing protocol makes a fundamental difference in complexity .",
    "obtained lower bound is still lower than obvious upper bound @xmath20 .",
    "the gap has been closed by liang in @xcite where the following is shown    [ theo : coll ] there exists a collapsing protocol for @xmath0 where each player communicates at most @xmath103 bits which matches the lower bound up to an additive constant .",
    "liang s protocol does nt however say anything about the bound on _ total _ complexity of the problem .",
    "in fact , total complexity of liang s protocol is @xmath104 which is worse then obvious upper bound of @xmath20 .",
    "theorem [ theo : coll ] shows us of course @xmath105 liang in his paper posed an open question : _ is the lower bound on * total * communication complexity achievable ? _",
    "+ in this work we provide a proof providing * negative * answer to this question .",
    "we will show that a trivial protocol of complexity @xmath20 is the best we can achieve in terms of total communication complexity .",
    "main contribution of this paper is resolving the open problem stated in liang s paper @xcite .",
    "we show the following theorem    [ theo : main ] for a * collapsing * protocol the total communication complexity of @xmath0 is bounded by @xmath106    the proven lower bound shows that there are no collapsing protocols achieving better total complexity ( up to a small additive constant ) than the trivial one .",
    "this way we close the previously known gap ( @xmath107 ) between upper and lower bound of total communication complexity of @xmath0 in a collapsing model . +",
    "this section is devoted to proving theorem [ theo : main ] .",
    "we will use some techniques developed in @xmath108 , when proving the lower maximum complexity bound in collapsing setting .",
    "we will formally define @xmath0 problem here . by @xmath109 $ ]",
    "we denote set @xmath110 and for a string @xmath111 , by @xmath112 we denote its i - th element .",
    "formally the input of @xmath0 problem is a tuple @xmath113 , where @xmath114 $ ] , @xmath115^{[n]}$ ] for @xmath116 and @xmath117 .",
    "note that @xmath111 can be seen both as a function @xmath109 \\to \\{0,1\\}$ ] ( which allows us to use functional notation ) and as a @xmath20-element string of @xmath118 ( thus we may write @xmath112 ) .",
    "formally    @xmath119 \\times \\left ( [ n]^{[n ] } \\right ) ^{k-2 } \\times \\{0,1\\}^n \\to \\{0 , 1\\}\\ ] ]    where @xmath0 itself can be defined recursively in a formal manner @xmath120 in other words , @xmath121 .",
    "intuitively , we have already described what a playing protocol is what does it mean that a protocol is _",
    "collapsing_. here we describe it in a purely formal way .",
    "a protocol will be called collapsing it there exist functions @xmath122 ( rules according to which players are producing outputs ) @xmath123 \\times \\left ( [ n]^{[n ] } \\right ) ^{i-2 } \\times \\{0,1\\}^n \\to \\{0,1\\}^{t_i } \\nonumber\\end{aligned}\\ ] ] such that for any input @xmath124 we can define @xmath125 such that @xmath126 .    in such setting @xmath127",
    "are messages outputed by consecutive players and @xmath128      we will prove our theorem by contradiction .",
    "namely , after assuming that players send out in total less than @xmath2 bits , we will construct a _ fooling set _",
    ", pair of inputs @xmath129 and @xmath130 which are indistinguishable for all the players ( all of them will have to output the same bits in both cases ) but the result of @xmath0 functions on those inputs do nt match .    to start with , we need lemmas showing that for a function outputing only a certain amount of bits there must exist pair of elements ( having some property ) that the function can not distinguish .",
    "let @xmath131 .",
    "we will say that @xmath132 iff for every index @xmath133 we have @xmath134 and there exists index @xmath45 for which @xmath135 .",
    "[ stw : chain]let @xmath136 $ ] .",
    "( one may also look at it as a function @xmath6 outputing @xmath137 bits of information ) .",
    "then there exists @xmath131 such that @xmath132 and @xmath138 .",
    "* suppose on the contrary that we have a function @xmath139 $ ] such that for every @xmath132 we have @xmath140 .",
    "let us consider the following chain of elements .",
    "@xmath141 such that @xmath9 is a string consisting of @xmath8-zeroes followed by @xmath142-ones .",
    "formally , @xmath143 for @xmath144 and @xmath145 for @xmath146 .",
    "it is easy to notice that for each @xmath44 we have also @xmath147 ( it is a proper chain in the meaning of partial order created by `` @xmath148 '' ) .",
    "this means that our function ( based on the assumption ) has to take different values for different elements of the chain .",
    "as the sequence consists of @xmath149 elements , the function has to take at least @xmath149 different values . contradiction .",
    "@xmath150    * remark . *",
    "it is worth noticing that for @xmath151 the previous statement does not hold .",
    "indeed , consider a function counting number of ones in a string @xmath152 clearly , this function outputs @xmath153 bits of information ( as the values range from @xmath21 to @xmath20 ) , but for each @xmath132 we have @xmath154 .",
    "+    @xcite for strings @xmath131 and @xmath155 , define the sets @xmath156 : ( x^{(j ) } , x^{(j ) } ) = ( a , b)\\}\\ ] ] a pair of strings @xmath157 is * crossing pair * if for all @xmath158 , @xmath159    [ stw : crossing ] ( proof in @xcite ) let @xmath160 where @xmath161 .",
    "then there exists a crossing pair of elements @xmath162 such that @xmath138 .",
    "lemmas [ stw : chain ] and [ stw : crossing ] show that when the output of function @xmath6 is small enough , then one can find pair of elements @xmath163 such that @xmath132 ( or respectively @xmath164 - crossing ) such that @xmath138 , which means that @xmath6 can not distinguish them .",
    "let us also use a following definition simplifying notation :    @xcite a string @xmath117 is said to be consistent with @xmath165 if in prototol @xmath34 , for all @xmath166 , @xmath167 sends the message @xmath168 on seeing input @xmath169 and previous messages @xmath170 .",
    "our proof is using the idea of finding a _ fooling pair _ of strings , which we define as    pair of strings @xmath164 , @xmath131 we will call a @xmath45-fooling pair , if there exists @xmath165 such that both @xmath111 and @xmath171 are @xmath165-consistent and @xmath172 .    of course , proving existence of @xmath173-fooling pair shows that @xmath34 is not a valid protocol .",
    "indeed , in that case the player @xmath30 will see exactly the same information for both @xmath111 , and @xmath171 , thus he has to produce the same answer , which contradicts the definition of @xmath164 . we will now show a series of statements allowing for iterative construction of _ fooling pairs_.    [ stw : push ] for a given protocol @xmath34 , if there is a @xmath164 , @xmath45-fooling pair , such that @xmath132 then if @xmath174 sends less than @xmath2 bits , then there exists a @xmath175 , ( j+1)-fooling pair .    *",
    "* let us take @xmath165",
    "that @xmath164 is consistent with .",
    "we will now construct @xmath175 and @xmath176 such that @xmath175 is @xmath177-fooling and is consistent with @xmath178 .",
    "player @xmath174 ( after seeing all the previous messages and information ) sends less than @xmath2 bits , this means that there exist strings @xmath179 such that @xmath180 and @xmath181 are indistinguishable by bits output by @xmath174 .",
    "last condition means that there exists index @xmath182 such that @xmath183 and @xmath184 ( in the opposite case we just swap @xmath185 ) .",
    "we now want to construct mapping @xmath186 satisfying @xmath187 and @xmath188 .",
    "our assumption @xmath132 shows that @xmath189 whereas @xmath190 .",
    "thus we may define our function @xmath191 one may easily notice that @xmath186 satisfies our conditions and setting @xmath192 as an output of player @xmath174 upon his information , we obtained a pair @xmath175 which is @xmath177-consistent . indeed , choosing @xmath181 to be undistinguishable by @xmath174 based on his information , we guarantee what @xmath192 is the same for both of those strings",
    ".    @xmath150    [ stw : crosspush ] for a given protocol @xmath34 ,",
    "if there is a @xmath164 , @xmath45-fooling pair , then if @xmath174 sends less than @xmath193 bits , then there exists a @xmath175 , ( j+1)-fooling pair such that @xmath194 .",
    "* schema of the proof is similar to the one in lemma [ stw : push ] .",
    "we are interestied in constructing @xmath176 as well as a crossing pair @xmath195 such that @xmath196 is consistent with @xmath178 .",
    "as we know , @xmath174 sends ( after seeing all other information ) less than @xmath197 bits which means that ( according to lemma [ stw : crossing ] ) one can construct a crossing pair @xmath175 which is undistinguishable by bits output by @xmath174 .",
    "such property gives us nonemptiness of sets @xmath198 .",
    "thus , after choosing a representant from each of those sets ( respectively @xmath199 ) we may define @xmath186 in a following way @xmath200 this way , again we have constructed a valid function @xmath186 for which @xmath187 and @xmath201 and the way we have chosen @xmath185 guarantees that @xmath192 match in both cases .",
    "@xmath150    in a way analogous to previous lemma we may prove the following    [ stw : chainpush ] for a given protocol @xmath34 , if there is a @xmath164 , @xmath45-fooling pair and @xmath202 , then if @xmath174 sends less than @xmath203 bits , then there exists a @xmath175 , ( j+1)-fooling pair such that @xmath204 .    * proof .",
    "* analogous to proofs of lemmas [ stw : push ] and [ stw : crosspush ]    @xmath150    * proof of theorem [ theo : main ] * + let us assume existence of protocol @xmath34 of cost @xmath205 .",
    "we will consider two cases .",
    "+ * case1 : @xmath206 * .",
    "of course we have also @xmath207 ( due to our assumption ) .",
    "this means that there exist a @xmath164 , 1-fooling pair .",
    "indeed it is enough to take two strings @xmath140 on which @xmath56 outputs the same value .",
    "such pair must exist as @xmath56 outputs less than @xmath20 bits .",
    "@xmath140 gives us the existence of index @xmath45 such that @xmath208 .",
    "it is now enough to take @xmath209 .",
    "@xmath210 is the message produced by @xmath56 , which ( due to our construction ) is the same both for @xmath111 and @xmath171 .",
    "if each of players @xmath74 sends less than @xmath211 bits , then using lemma [ stw : crosspush ] multiple times we are able to consecutively generate pairs @xmath157",
    "@xmath212 for @xmath213 , ending up with a @xmath214 , @xmath173 - fooling pair , which contradicts validity of the protocol .",
    "+ thus , there must exist player @xmath27 for @xmath116 which outputs more than @xmath215 bits .",
    "together with player @xmath56 , this gives us already total complexity @xmath216 .",
    "+ * case2 : @xmath217 * .",
    "this time , we can use lemma [ stw : chain ] to begin our construction . indeed , from lemma [",
    "stw : chain ] we obtain a pair of strings @xmath132 on which @xmath56 produces the same output .",
    "now setting @xmath218 such that @xmath219 , and @xmath210 as the message produced by @xmath56 , we obtain a @xmath164 , @xmath22-fooling pair .",
    "+ based on our assumption on total cost of protol , we will prove inductively the following statement + * statement * _ for every @xmath220 , @xmath27 outputs less than @xmath221 bits and there exists a @xmath222 , @xmath8-fooling pair for which @xmath223_. + we know that the statement is true for @xmath224 .",
    "knowing that it is true for all @xmath225 we will prove it for @xmath226 ( where @xmath227 ) .",
    "assume that player @xmath46 outputs less than @xmath228 bits and there is a @xmath229 , @xmath45-fooling pair such that @xmath230 .",
    "our assumption on total complexity gives us that @xmath174 outputs less than @xmath231 bits .",
    "using lemma [ stw : push ] we receive a @xmath232 , @xmath177 - fooling pair .",
    "if we now assume that each of players @xmath233 outputs less than @xmath197 bits , then using lemma [ stw : crosspush ] multiple times , we will be able to construct pairs @xmath234 which are respectively @xmath235-fooling .",
    "this would contradict the validity of the protocol ( nonexistence of @xmath173-fooling pairs ) .",
    "this means that at least one of @xmath233 outputs at least @xmath197 .",
    "this , on the other hand , implies that @xmath174 outputs less than @xmath236 bits ( according to our assumption on total complexity ) .",
    "using lemma [ stw : chainpush ] we obtain also a @xmath237 , @xmath177-fooling pair for which @xmath238 and thus prove our _ statement_. + the _ statement _ shows us that @xmath239 outputs less than @xmath236 bits and there exists a @xmath240 , @xmath241-fooling pair such that @xmath242 .",
    "due to the total complexity assumptions , player @xmath40 has to output less than @xmath2 bits .",
    "this , however , according to lemma [ stw : push ] implies existence of @xmath243 , @xmath173-fooling pair which , as we know , contradicts validity of protocol and gives a contradiction proving the main theorem .",
    "we have proven that there are no collapsing protocols achieving a total communication complexity for @xmath0 ( in @xmath10 model ) better than a trivial one ( up to an additive constant ) .",
    "this closes the gap between lower bound of @xmath215 and the upped bound and at the same time answers the open problem posed in work of liang , @xcite .",
    "+ main open problems remain showing that @xmath59 through finding lower bounds with high number of players ( @xmath65 ) .",
    "another challenging problem is tightening the lower and upper bounds in the general @xmath0 problem where the the gap between @xmath244 versus @xmath245 is still very big . + we believe that showing tight bounds for protocols with additional restrictions can push the development of general protocols for @xmath0 further allowing for resolving two very challenging problems in this area ."
  ],
  "abstract_text": [
    "<S> this paper focuses on bounding the total communication complexity of collapsing protocols for multiparty pointer jumping problem ( @xmath0 ) . </S>",
    "<S> brody and chakrabati in @xcite proved that in such setting one of the players must communicate at least @xmath1 bits . </S>",
    "<S> liang in @xcite has shown protocol matching this lower bound on maximum complexity . </S>",
    "<S> his protocol , however , was behaving worse than the trivial one in terms of total complexity ( number of bits sent by all players ) . he conjectured that achieving total complexity better then the trivial one is impossible . in this paper </S>",
    "<S> we prove this conjecture . </S>",
    "<S> namely , we show that for a collapsing protocol for @xmath0 , the total communication complexity is at least @xmath2 which closes the gap between lower and upper bound for total complexity of @xmath0 in collapsing setting . </S>"
  ]
}