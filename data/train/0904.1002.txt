{
  "article_text": [
    "in the paper `` optimally competitive list batching '' @xcite we give results regarding online batching problems .",
    "for one problem  the online list s - batch problem , where all the jobs have processing time 1 and we seek to minimize the sum of the completion times of the jobs  we have used a computer program to obtain some of our results .",
    "the purpose of this document to make this program publicly available .",
    "the program is printed in section [ sec : program ] .",
    "it is also available for download from www.egr.unlv.edu/@xmath1bein/pubs/verifylowerbound.java in ascii format .",
    "the reader should consult the full paper @xcite or the earlier conference version @xcite , but in the interest of self - containedness , we briefly define the problem in section [ sec : introduction ] and repeat the results in section [ sec : results ] .",
    "a _ batching problem _ is a scheduling problem where a set of jobs @xmath2 with processing times @xmath3 must be scheduled on a single machine , and where @xmath4 must be partitioned into _ batches _ @xmath5 .",
    "all jobs in the same batch are run jointly and each job s completion time is defined to be the completion time of its batch .",
    "we assume that when a batch is scheduled it requires a setup time @xmath6 . in an _ s - batch _ [ sequential ] problem the _ length _ of a batch , _",
    "i.e. _ , the time required to process the batch , is the sum of the processing times of its member jobs .",
    "the goal is to find a schedule that minimizes the _ sum of completion times _",
    "@xmath7 , where @xmath8 denotes the completion time of @xmath9 in a given schedule .",
    "given a sequence of jobs , a batching algorithm must assign every job @xmath9 to a batch . more formally , a feasible solution is an assignment of each job @xmath9 to the @xmath10 batch , @xmath11 . in this paper",
    ", we consider the _ list _ version of the problem , where the given order of the jobs must be respected , _",
    "i.e. _ , @xmath12 if @xmath13 .    an _ online _",
    "algorithm for a list batching problem must choose each @xmath14 before receiving @xmath15 , _",
    "i.e. _ , each job must be scheduled before a new job is seen , and even before knowing whether @xmath9 is the last job . after receiving @xmath9 ,",
    "an algorithm has only two choices , namely whether to assign @xmath9 to the same batch as @xmath16 or not . throughout this paper",
    ", we will use the phrase ",
    "@xmath17 batches at step @xmath18 \" to mean that algorithm @xmath17 decides that @xmath9 is the first job of a new batch , _",
    "i.e. _ @xmath19 .",
    "we use the phrase  current batch \" to denote the batch to which the last job was assigned .",
    "then , when @xmath9 is received , @xmath17 must decide whether to add @xmath9 to the current batch , or ",
    "close \" the current batch and assign @xmath9 to a new batch .",
    "online algorithms are analyzed in terms of _ competitiveness _ , a measure of the performance that compares the decision made online with the optimal offline solution for the same problem .",
    "we say that an algorithm @xmath17 is _",
    "@xmath20-competitive _ if , for any sequence of jobs @xmath21 , @xmath17 finds a schedule whose cost is at most @xmath22 , where @xmath23 is the minimum cost of any schedule for that input sequence .",
    "in our papers @xcite we give a solution for the offline problem .",
    "we define a function @xmath26 $ ] for @xmath27 , as follows . for @xmath28 for some @xmath29 and some @xmath30 , then @xmath31 = \\frac{m(m+1)(m+2)(3m+5)}{24 } + k(n+m - k+1 ) + \\frac{k(k+1)}{2}.\\ ] ]    [ thm : optcost is f ] for @xmath32 $ ] , @xmath33 $ ] for all @xmath27 . furthermore , if @xmath34 for some @xmath29 and some @xmath30 , the optimal size of the first batch is + @xmath35 +    for the online problem we define the following algorithm in @xcite .",
    "define @xmath36 to be the online algorithm which batches after jobs : 2 , 5 , 9 , 13 , 18 , 23 , 29 , 35 , 41 , 48 , 54 , 61 , 68 , 76 , 84 , 91 , 100 , 108 , 117 , 126 , 135 , 145 , 156 , 167 , 179 , 192 , 206 , 221 , 238 , 257 , 278 , 302 , 329 , 361 , 397 , 439 , 488 , 545 , 612 , 690 , 781 , 888 , 1013 , 1159 , 1329 , 1528 , 1760 , and 2000 + 40@xmath18 for all @xmath37 .",
    "[ thm : identical 619 583 ] @xmath36 is @xmath0-competitive , and no online algorithm for the list s - batch problem restricted to unit job sizes has competitiveness smaller than @xmath0 .",
    "consider the algorithm @xmath36 described above .",
    "verifying that @xmath36 maintains a cost ratio of at most @xmath0 for all job sequences with less than 2000 jobs is done by the java program in section [ sec : program ] .",
    "consider now sequences with more than 2000 jobs .",
    "then the contribution of job @xmath38 to the optimal cost is at least @xmath39 .",
    "for @xmath36 the contribution of this job @xmath18 consists of the setup times prior to job @xmath40 plus the setup times later , plus the number jobs @xmath18 as well the the subsequent jobs in the same batch .",
    "this amount is no more than @xmath41 , because 39 is the maximum number of additional jobs in this batch .",
    "thus the for the ratio of cost we obtain @xmath42    the contribution of the first 2000 jobs to the optimal cost is larger than a contribution in a short sequence ( with 2000 jobs or less ) because the size of the optimal batches increase with the number of jobs .",
    "therefore @xmath36 is @xmath0-competitive .",
    "we now turn to the verification of the lower bound .",
    "any online algorithm for list batching restricted to unit jobs is described by a sequence of decisions : should the @xmath43 job be the first job in a new batch ?",
    "thus any such online algorithm can be represented as a path in a decision tree where a node at level @xmath18 has two children : one representing the choice not to batch prior to job @xmath18 and one representing making job @xmath18 the first job in a new batch .",
    "we note that the algorithm never batches upon the arrival of the first job .",
    "we have verified that any path from the root to a node with depth @xmath44 in this decision tree must encounter a node at which the ratio of online cost to offline cost is at least @xmath0 ; and thus we have established that lower bound .",
    "verification was done using our computer program .",
    "interestingly , the lower bound verification program requires consideration of only the portion of the decision tree to depth 100 . that is ,",
    "if the decision tree is truncated at any level less than 100 , the lower bound is not obtained .",
    "what this means is that , if an online algorithm is informed in advance that there will be at most 99 jobs , it can achieve a competitiveness less than @xmath0 .    given that there are exponentially many paths from the root to a node at depth @xmath44 , two notes on efficiency are appropriate here .",
    "first , if a node is encountered where the ratio of costs is greater than or equal to @xmath0 then no further descendants need to be checked .",
    "this alone brings the calculation described above to manageable levels .",
    "second , given two nodes @xmath45 and @xmath46 which have not been pruned by the previous procedure , if the online cost at @xmath45 is less or equal to the online cost at @xmath46 and both have done their most recent batching at the same point then descendants of @xmath46 need not be considered .",
    "this follows because the cost on any sequence of choices leading from @xmath46 is greater or equal to the same cost on @xmath45 .",
    "we illustrate the preceding ideas with the diagram of figure [ fig : decision ] .",
    "level @xmath18 contains all possible decisions after @xmath18 jobs have arrived .",
    "the symbolic gantt chart next to every decision node show the schedule the algorithm constructs at that node . in the gantt charts",
    "black squares denote setup times , while white squares are used to denote jobs .",
    "the cost of the algorithm is written into the node .",
    "note that we can prune at level 3 because @xmath47 . also note that descendants of node @xmath46 need not be considered .",
    "the program is compiled with javac , version 1.6.0_10 .               public static void main(string [ ] args ) {        int count = 0 ;         int [ ] opt = calculateopt ( ) ;         int [ ] suggested = { 0,2,5,9,13,18,23,29,35,41,48,54,61,68,76,84,91,100,108,117 ,                           126,135,145,156,167,179,192,206,221,238,257,278,302,329,361 ,                           397,439,488,545,612,690,781,888,1013,1159,1329,1528,1760,2000 } ;        linkedlist < partialcandidate > candidates = new linkedlist < partialcandidate > ( ) ;        partialcandidate pc ;            / * while there are candidates remaining , remove the first .",
    "if it has reached the           maximum number of jobs that should be considered , print out the solution and            add one to the count .",
    "if the candidate   has not reached the maximum number of            jobs , check whether            1 ) has a cost ratio strictly smaller than 619/583     and           2 ) it does not have a just as good candidate already in the list .           if both are true , then add both of its children to the list of candidates .",
    "* /          while ( candidates.size ( ) ! = 0 ) {           pc = candidates.remove ( ) ;           if ( pc.gethowfar ( ) > howfar ) {              count++ ;              system.out.println(pc ) ;           }           else if ( 583*pc.evalcost ( ) < 619*opt[pc.gethowfar ( ) ] ) {              if(!existjustasgood(pc , candidates ) ) {                 candidates.add(new partialcandidate(pc , false ) ) ;                 candidates.add(new partialcandidate(pc , true ) ) ;              }           }        }        system.out.print(count + \" candidates achieve a cost ratio strictly smaller \" ) ;        system.out.println(\"than 619/583 on all sequences no longer than \" + howfar ) ;          // verify that the suggested candidate succeeds up to 2000 jobs        boolean success = true ;        int value = 0 , j=0 ;        for ( int i=1 ; i<2000 ; i++ ) {           value + = ( i - suggested[j]-1)+i+j+1 ;           if ( i==suggested[j+1 ] )              j++ ;           if ( 583*value > 638*opt[i ] )              success = false ;        }        system.out.println(\"the suggested candidate is a success up to 2000 jobs ? \"",
    "+ success ) ;     }       // uses theorem 1 to calculate the offline optimum costs     private static int [ ] calculateopt ( ) {        int n , m=0 , howmany=2001 ;        int [ ] answer = new int[howmany ] ;        answer[0 ] = 0 ;        for ( n=0;n < howmany-1;n++ ) {           if ( 2*n<(m+2)*(m+1 ) )              answer[n+1]=answer[n]+n+m+2 ;           else {              m++ ;              answer[n+1]=answer[n]+n+m+2 ;           }        }        return answer ;     }           / * checks to see if the list already has a candidate which has gotten as far ,        has no greater cost , uses no more set ups , and has the most recent set up         at the same location ,       * /     private static boolean existjustasgood(partialcandidate pc ,                                 linkedlist < partialcandidate > ll ) {        partialcandidate jagc ;        listiterator < partialcandidate >",
    "i = ll.listiterator(0 ) ;        while ( i.hasnext ( ) ) {           jagc = i.next ( ) ;           if (               jagc.gethowfar ( ) = = pc.gethowfar ( ) & &               jagc.evalcost ( ) < = pc.evalcost ( ) & &               jagc.getsetups().size ( ) < = pc.getsetups().size ( ) & &               jagc.getsetups().lastelement().equals(pc.getsetups().lastelement ( ) )              )              return true ;        }        return false ;     } }     / * an algorithm for the unit job batching problem can be specified by     where the set up times occur ( or equivalently where it batches ) .",
    "a      partial candidate is an incompletely specified algorithm .",
    "a partial      candidate has a list ( stored in setups ) which specifies where the      set up times occur only for sequences of up to a certain length ( ie     the depth in the tree - stored in howfar ) .",
    "* /             / * given a partial candidate create a new partial candidate which        is defined for sequences one job longer . determine whether to        add an additional set up at this point based upon the value of        batch .      * /     public partialcandidate(partialcandidate pc , boolean batch ) {        vector < integer > prevsetups = pc.getsetups ( ) ;        int prevhowfar = pc.gethowfar ( ) ;           // calculate cost of the partial candidate on a sequence of howfar jobs .",
    "public int evalcost ( ) {        int value=0 ;        for ( int i=1 ; i < setups.size ( ) ; i++ )            value + = ( i+setups.get(i))*(setups.get(i)-setups.get(i-1 ) ) ;        value + = ( setups.size()+howfar)*(howfar-setups.get(setups.size()-1 ) ) ;        return value ;     }       // used to print out the partial candidate     public string tostring ( ) {        string str= \" \" ;        for ( int i=0 ; i < setups.size ( ) ; i++ )           str + = setups.get(i)+ \" \" ;        str + = \" cost \" + evalcost ( ) ;        return str ;     }              w.  bein , l.  epstein , j.  noga , and l.  larmore . optimally competitive list batching . in _ proceedings of the 9th scandinavian workshop on algorithm theory , lncs 3111 _ , pages 7789 . springer verlag , 2004 ."
  ],
  "abstract_text": [
    "<S> we consider the online list s - batch problem , where all the jobs have processing time 1 and we seek to minimize the sum of the completion times of the jobs . </S>",
    "<S> we give a java program which is used to verify that the competitiveness of this problem is @xmath0 .    </S>",
    "<S> _ keywords : _ design of algorithms ; online algorithms ; batching ; tcp acknowledgment . </S>"
  ]
}