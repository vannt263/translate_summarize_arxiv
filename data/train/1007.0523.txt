{
  "article_text": [
    "modern _ real - time systems _ have incurred tremendous challenges to verification engineers .",
    "the reason is that a model process running in a modern real - time system can be built with support from many server processes in the environment .",
    "moreover , the model may also have to respond to requests from several user processes .",
    "the fulfillment of a computation relies not only on the functional correctness of the model , but also on the reactions from the servers and the clients .",
    "for example , a company may submit a task of dna sequencing to a server .",
    "the server then develops a computing budget and decomposes the task into several subtasks ( e.g. , snp finding , alignments ) .",
    "then the server may relegate the subtasks to several other servers .",
    "the decompositions of subtasks may then go on and on .",
    "if the task is to be completed , not only the server for the root task needs to function correctly , but also all the servers for the subtasks have to fulfill their assignments .",
    "thus , to verify the function of the root server , it is only reasonable and practical to assume that all the other supporting servers work correctly .    in many industrial projects",
    ", the specification can be given in the concept of state - transition diagrams ( or tables ) .",
    "in such a context , _ simulation - checking _ is an appropriate framework for verifying that a model conforms to the behavior of a specification @xcite .",
    "intuitively , the specification simulates the model if every timed step of the model can be matched by the specification at the same time .",
    "@xmath0 [ exmp.intro ] in figure  [ fig.ms_ne ] , we have the state - transition diagrams of two _ timed automatas _ ( _ ta _ )",
    "@xcite .",
    "( 0,0 )    # 1#2#3#4#5 @font    ( 5195,3861)(664,-3289 ) ( 976,-361)(0,0)[lb ] ( 1501 , 89)(0,0)[lb ] ( 1501,239)(0,0)[lb ] ( 1501,389)(0,0)[lb ] ( 2926,-811)(0,0)[lb ] ( 5176,-361)(0,0)[lb ] ( 4726,164)(0,0)[lb ] ( 4726,314)(0,0)[lb ] ( 2926,-961)(0,0)[lb ] ( 901,-1261)(0,0)[lb ] ( 2926,-2761)(0,0)[lb ] ( 1501,-1861)(0,0)[lb ] ( 1501,-1711)(0,0)[lb ] ( 2926,-2911)(0,0)[lb ] ( 901,-3211)(0,0)[lb ] ( 976,-2311)(0,0)[lb ] ( 3451,-436)(0,0)[lb ] ( 3376,-2161)(0,0)[lb ] ( 3451,-2386)(0,0)[lb ] ( 3376,-211)(0,0)[lb ]    the one in figure  [ fig.ms_ne](a ) is for a model @xmath1 while the one in figure  [ fig.ms_ne](b ) is for a specification @xmath2 .",
    "we use ovals for the _ control locations _ of the tas while arcs for the transition rules . in each oval , we label the invariance condition that must be satisfied in the location . for example , in location @xmath3 , @xmath1 can stay for at most 20 time units . by each transition rule , we stack its synchronization event , triggering condition ( guard ) , and actions . for convenience ,",
    "tautology triggering conditions and nil actions are omitted .",
    "an event starting with a ` ? ' represents a _ receiving event _ while one with a ` ! ' represents a _ sending event_. for example , for the transition from location @xmath4 to @xmath5 , @xmath1 must send out an event request , be in a state satisfying @xmath6 , and reset clock @xmath7 to zero .",
    "the specification in figure  [ fig.ms_ne](b ) does not simulate the model in figure  [ fig.ms_ne](a ) since event !",
    "end of @xmath1 can not be matched by any event of @xmath2 .",
    "moreover @xmath2 can neither receive a ?",
    "serve event 15 time units after issuing a ! request event while @xmath1 can",
    ".    however , the concept of simulation described in the last paragraph can be too restrictive in practice .",
    "developers of a project usually can not make too much assumption on the environment .",
    "the deadline constraints @xmath8 and @xmath9 can be too restrictive and hurt the extensibility of the model in the future .",
    "another approach in this regard is using _ fairness assumptions _",
    "for example , for the model and specification processes in figure  [ fig.ms_ne ] , we may want to check whether @xmath2 simulates @xmath1 under the fairness assumption that the environment functions reasonably .",
    "such an assumption can be captured with the fairness assumption that _ there will always be infinitely many occurrences of event serve_. under this assumption , the @xmath2 in figure  [ fig.ms_ne](b ) actually simulates the @xmath1 in figure  [ fig.ms_ne](a ) .    in this work",
    ", we propose the _ simulation _ with fairness assumptions for the processes in a dense - time setting .",
    "in such a setting , the model and the specification are both",
    "_ generalized bch timed automatas _ ( _ gbta _ ) @xcite with communication channels and dense - time behaviors .",
    "we want to check whether the specification gbta can simulate the model gbta with multiple fairness assumptions . following the approach of @xcite",
    ", we allow for the requirement and analysis of both strong and weak fairness assumptions .",
    "a _ strong fairness _",
    "assumption intuitively means something will happen infinite many times . a _ weak fairness _",
    "assumption means something will hold true eventually forever . for convenience ,",
    "we use two consecutive sets of formulas for fairness assumptions , the former for the strong fairness assumptions while the latter for the weak fairness assumptions .",
    "@xmath0[exmp.intro.fstate ] for the system in figure  [ fig.ms_ne ] , we may have the following fairness assumptions .",
    "@xmath10    the fairness assumptions in the above say that a valid computation of the system must satisfy the following two conditions .",
    "_ for the strong fairness assumption of _ @xmath11 : for every @xmath12 , there exists a @xmath13 with @xmath14 such that in the computation at time @xmath15 , the model process is in location @xmath5 .",
    "this in fact says that the model must enter location @xmath5 infinitely many times along any valid computation .",
    "_ for the weak fairness assumption of _ @xmath16 : there exists a @xmath12 such that for every @xmath13 with @xmath14 , the model process is in either locations @xmath4 or @xmath5 .",
    "this in fact says that the model will stabilize in locations @xmath4 and @xmath5 .",
    "the two types of fairness assumption complement with each other and could be handy in making reasonable assumptions .",
    "furthermore , we also allow for both state formulas and event formulas @xcite in the description of fairness assumptions .",
    "state formulas are boolean combinations of atomic statements of location names and state variables . for convenience ,",
    "we use index @xmath17 for the model and index @xmath18 for the specification .",
    "event formulas are then constructed with a precondition , a event name with a process index , and a post - condition in sequence .",
    "@xmath0[exmp.intro.fevent ] for the system in figure  [ fig.ms_ne ] , we may write the following strong event fairness assumption .    @xmath19    the event specification of @xmath20 means there is an event serve received by process 1 .",
    "the precondition for the event is @xmath5 while the post - condition is @xmath21 .",
    "the strong fairness assumption says that there should be infinite many events serve received by process 1 in location @xmath5",
    ".    in general , an event specification can be either a receiving or a sending event .",
    "such event formulas can be useful in making succinct specifications . without such event formulas",
    ", we may have to use auxiliary state variables to distinguish those states immediately before ( or after ) an event from others .",
    "such auxiliary variables usually unnecessarily exacerbate the state space explosion problem .",
    "one goal of our work is to develop a simulation - checking algorithm based on symbolic model - checking technology for dense - time systems @xcite . to achieve this , we focus on a special class of simulations with the restriction of at most one fairness assumption for the specification . for convenience",
    ", we call this class the _ usf _ ( _ unit - specification - fairness _ )",
    "_ simulations_. then we propose a symbolic algorithm for this special class of simulations . to our knowledge , this is the first such algorithm for gbtas . also unlike the fair simulation @xcite checking algorithm based on ranking function in the literature ,",
    "our algorithm is based on symbolic logic formulas manipulation , which has been proven useful in symbolic model checking @xcite .",
    "thus , our algorithm style can be interesting in itself .",
    "we also present a technique for the efficient simulation checking of concurrent systems by taking advantage of the common environment of a model and a specification . to apply the simulation checking algorithms mentioned in the above and in the literature @xcite , we need first construct a product automata of the environment @xmath22 and the model @xmath1 , in symbols @xmath23 .",
    "then we construct a product of @xmath22 and the specification @xmath2 , in symbols @xmath24 .",
    "then we check if @xmath24 simulates @xmath23 . as a result ,",
    "such algorithms incur duplicate recording of the state information of @xmath22 while manipulating representations for the simulation of @xmath23 by @xmath24 .",
    "moreover , different transitions in @xmath22 with the same observable events can also be matched in the simulation - checking .",
    "such matching is not only counter - intuitive in simulation against the same environment , but also incur explosion in the enumeration of matched transitions between @xmath23 and @xmath24 .",
    "our technique is embodied with the definition of a new simulation relation against a common environment .",
    "we have implemented this technique and experimented with benchmarks with and without fairness assumptions .",
    "we have the following presentation plan .",
    "section  [ sec.relwork ] is for related work .",
    "section  [ sec.prel ] reviews our system models @xcite .",
    "sections  [ sec.simf ] presents our simulation for dense - time systems with fairness assumptions .",
    "section  [ sec.usf.neg.char ] presents a characterization of the simulation when the specification is a bchi ta .",
    "section  [ sec.simf.alg ] presents our simulation checking algorithm based on the characterization derived in section  [ sec.usf.neg.char ] .",
    "section  [ sec.sim.env ] presents the simulation against a common environment and techniques for performance verification in this context .",
    "sections  [ sec.imp ] and [ sec.exp ] respectively report our implementation and experiment .",
    "section  [ sec.conc ] is the conclusion .",
    "cerans showed that the bisimulation - checking problem of timed processes is decidable @xcite .",
    "tairan et al showed that the simulation - checking problem of dense - time automatas ( tas ) @xcite is in exptime @xcite .",
    "weise and lenzkes reported an algorithm based on zones for timed bisimulation checking @xcite .",
    "cassez et al presented an algorithm for the reachability games of tas with controllable and uncontrollable actions @xcite .",
    "henzinger et al presented an algorithm that computes the time - abstract simulation that does not preserve timed properties @xcite .",
    "nakata also discussed how to do symbolic bisimulation checking with integer - time labeled transition systems @xcite .",
    "beyer has implemented a refinement - checking algorithm for tas with integer - time semantics @xcite .",
    "lin and wang presented a sound proof system for the bisimulation equivalence of tas with dense - time semantics @xcite .",
    "aceto et al discussed how to construct such a modal logic formula that completely characterizes a ta @xcite .",
    "larsen presented a similar theoretical framework for bisimulation in an environment for untimed systems @xcite .",
    "however no implementation that takes advantage of the common environment information for verification performance has been reported .",
    "proposals for extending simulation with fair states have been discussed in @xcite .",
    "our simulation game of gbtas stems from henzinger et al s framework of fair simulation @xcite .",
    "techniques for simulation checking of gbas were also discussed in @xcite .",
    "we have the following notations .",
    "@xmath25 is the set of real numbers .",
    "@xmath26 is the set of non - negative reals .",
    "@xmath27 is the set of nonnegative integers .",
    "also ` iff ' is  if and only if",
    ". \" given a set @xmath28 of atomic propositions and a set @xmath29 of clocks , we use @xmath30 as the set of all boolean combinations of logic atoms of the forms @xmath31 and @xmath32 , where @xmath33 , @xmath34 , ` @xmath35'@xmath36 , and @xmath37 .",
    "an element in @xmath30 is called a _ state - predicate_.      a ta@xcite is structured as a directed graph whose nodes are _ modes ( control locations ) _ and whose arcs are _",
    "transitions_. please see figure  [ fig.ms_ne ] for examples .",
    "a ta must always satisfy its _",
    "invariance condition_. each transition is labeled with events , a _ triggering condition _ , and a set of clocks to be reset during the transitions .",
    "at any moment , a ta can stay in only one _",
    "mode_. if a ta executes a transition , then the triggering condition must be satisfied . in between transitions , all clocks in a",
    "ta increase their readings at a uniform rate .",
    "a ta @xmath38 is a tuple @xmath39 .",
    "@xmath40 is a finite set of modes ( locations ) .",
    "@xmath28 is a finite set of propositions .",
    "@xmath29 is a finite set of clocks .",
    "@xmath41 is the initial condition .",
    "@xmath42 is the invariance condition for each mode .",
    "@xmath43 is the set of process transitions .",
    "@xmath44 is a finite set of events .",
    "@xmath45 is a mapping that defines the events at each transition . @xmath46 and",
    "@xmath47 respectively define the triggering condition and the clock set to reset of each transition .    without loss of generality , we assume that for all @xmath48 with @xmath49 , @xmath50 is a contradiction .",
    "we also assume that there is a null transition @xmath51 that does nothing at any location .",
    "that is , the null transition transits from a location to the location itself .",
    "moreover , @xmath52 , @xmath53 , and @xmath54 .    given a ta @xmath55 , for convenience , we let @xmath56 , @xmath57 , @xmath58 , @xmath59 , @xmath60 , @xmath61 , @xmath62 , @xmath63 , @xmath64 , and @xmath65 . also , for convenience , we let @xmath66 be the _ invariance predicate _ of @xmath38 .",
    "@xmath0 [ exmp.tas ] we have already seen examples of tas in figure  [ fig.ms_ne ] . for the ta in figure  [ fig.ms_ne](a ) ,",
    "the attributes are listed in table  [ tab.ms_ne.a.attr ] .",
    "@xmath67 \\\\   e_{{\\cal m } } & = &   \\{(\\mbox{\\tt idle}_1,\\mbox{\\tt wait}_1 ) ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt idle}_1 ) , ( \\mbox{\\tt wait}_1,\\mbox{\\tt stop}_1)\\ } \\\\   \\sigma_{{\\cal m } } & = &   \\{\\mbox{\\tt request},\\mbox{\\tt serve},\\mbox{\\tt end}\\ } \\\\",
    "\\epsilon_{{\\cal m } } & = &   [ ( \\mbox{\\tt idle}_1,\\mbox{\\tt wait}_1)\\mapsto\\{!\\mbox{\\tt request}\\ } ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt idle}_1)\\mapsto\\{?\\mbox{\\tt serve}\\ } ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt stop}_1)\\mapsto\\{!\\mbox{\\tt end}\\ } ] \\\\",
    "\\tau_{{\\cal m } } & = &   [ ( \\mbox{\\tt idle}_1,\\mbox{\\tt wait}_1)\\mapsto x_1>5 ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt idle}_1)\\mapsto { \\mbox{\\em true } } ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt stop}_1)\\mapsto x_1>10 ] \\\\   \\pi_{{\\cal m } } & = &   [ ( \\mbox{\\tt idle}_1,\\mbox{\\tt wait}_1)\\mapsto \\{x_1\\ } ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt idle}_1)\\mapsto \\{x_1\\ } ,   ( \\mbox{\\tt wait}_1,\\mbox{\\tt stop}_1)\\mapsto \\emptyset ] \\\\   \\end{array}$ ] + @xmath68 $ ] denotes a ( partial or total ) function @xmath69 with @xmath70",
    ".    a _ valuation _ of a set is a mapping from the set to another set .",
    "given an @xmath71 and a valuation @xmath72 of @xmath73 , we say @xmath72 _ satisfies _ @xmath74 , in symbols @xmath75 , iff @xmath74 is evaluated @xmath21 when the variables in @xmath74 are interpreted according to @xmath72 .",
    "suppose we are given a ta @xmath38 .",
    "a _ state _",
    "@xmath72 of @xmath38 is a valuation of @xmath76 with the following constraints .    for each @xmath77 , @xmath78 .",
    "there exists a @xmath79 such that @xmath80 and for all @xmath81 , @xmath82 .",
    "given a @xmath79 , if @xmath83 , we denote @xmath31 as @xmath84 .",
    "for each @xmath85 , @xmath86 .",
    "in addition , we require that @xmath87 .",
    "we let @xmath88 denote the set of states of @xmath38 .",
    "note that we define a state as a mapping instead of as a pair of control locations and a real mapping as in @xcite .",
    "this is for the convenience of presentation when latter we want to discuss the state - pairs in simulation relations .    for any state @xmath72 and real number @xmath12",
    ", @xmath89 is a state identical to @xmath72 except that for every clock @xmath85 , @xmath90 .",
    "also given a process transition @xmath91 , we use @xmath92 to denote the destination state from @xmath72 through the execution of @xmath93 .",
    "formally , if @xmath94 , then @xmath92 is a new state that is identical to @xmath72 except that the following constraints are true .",
    "@xmath95 and @xmath96 .    for every clock @xmath97 , @xmath98 .    for every clock @xmath99 , @xmath100 .    given a @xmath101 and a transition @xmath93",
    ", we write @xmath102 iff @xmath103 , @xmath104 , @xmath105 , and for each @xmath106 $ ] , @xmath107 . for convenience",
    ", we use @xmath108 $ ] to denote such a @xmath109 with @xmath102 .    a _ run _ of a ta",
    "@xmath38 is an infinite sequence of state - transition - time triples @xmath110 with the following restrictions .",
    "* non - zeno requirement : * @xmath111 is a non - decreasing and divergent real - number sequence .",
    "that is , @xmath112 and @xmath113 .    for all @xmath114 , either @xmath115 or @xmath116{10mm}{0.5pt}\\!\\!\\!\\longrightarrow } } } \\nu_{k+1}$ ] .",
    "a _ run prefix _ is a finite prefix of a run .",
    "a run prefix or a run @xmath117 of @xmath38 is _ initial _",
    "iff @xmath118 .",
    "suppose we are given a ta @xmath119 .",
    "an _ event - predicate _ is of the form @xmath120 . here",
    "@xmath121 and @xmath122 are two state - predicates in @xmath123 respectively for the precondition and the post - condition of the event .",
    "@xmath124 is an event name .",
    "event - predicate ",
    "@xmath120 \" specifies the observation of event @xmath125 with precondition @xmath121 and post - condition @xmath122 .",
    "in this work , we allow _ fairness assumptions _ either as state - predicates or as event - predicates .",
    "a state fairness assumption is in @xmath123 .",
    "an event fairness assumption is an event - predicate of @xmath119 .",
    "given two sets @xmath126 and @xmath127 of fairness assumptions , @xmath128 denotes a _ multi - fairness assumption _ ( _ mf - assumption _ ) for @xmath119 .",
    "all elements in @xmath126 are called _ strong fairness assumptions _ while all in @xmath127 are called _ weak fairness assumptions_. a run @xmath129 of @xmath119 satisfies @xmath128 iff the following constraints hold .    for every state - predicate @xmath130 ,",
    "there are infinitely many @xmath131 s such that for some @xmath132 $ ] , @xmath133 .    for every event - predicate @xmath120 in @xmath126",
    ", there are infinitely many @xmath131 s such that @xmath134 , @xmath135 , and @xmath136 .    for every state - predicate @xmath137 ,",
    "there is a @xmath131 such that for every @xmath138 and @xmath139 $ ] , @xmath140 .    for every event - predicate @xmath120 in @xmath127 ,",
    "there is a @xmath131 such that for every @xmath138 , if @xmath134 and @xmath135 , then @xmath136 .    given a ta @xmath119 and a state @xmath141 , we let @xmath142 denote the set of runs of @xmath119 from @xmath72 satisfying @xmath128 .",
    "the following definition shows how to formally model real - time systems with fairness assumptions .",
    "[ def.gbcta ] a _ generalized bchi ta _",
    "( _ gbta _ ) is a pair @xmath143 with a ta @xmath119 and an mf - assumption @xmath128 . if @xmath144 , the pair is also called a _ bchi ta _",
    "( _ bta _ ) .",
    "@xmath0 [ exmp.ctas ] for the model @xmath1 in figure  [ fig.ms_ne](a ) , we may have a gbta    @xmath145    that assumes @xmath1 should stay in location @xmath5 infinitely many times and event @xmath146 should be received by @xmath1 infinitely many times with post - condition @xmath4 .",
    "we may also have the following gbta    @xmath147    that assumes that @xmath1 should eventually stabilize in location @xmath148 .",
    "suppose we are given two tas @xmath149 .",
    "for any transitions @xmath150 and @xmath151 , @xmath93 and @xmath69 are _ compatible _ iff @xmath152 . that is , the observable events of the two automatas on the two transitions must be nontrivially identical .",
    "for each @xmath150 with @xmath153 , we use @xmath154 to denote the subset of @xmath155 with elements compatible with @xmath93 . for each @xmath156 with @xmath157 , @xmath158 .",
    "also , @xmath159 denotes the subset of @xmath155 with elements @xmath69 such that @xmath160 .    in this section , from now on , we assume the context of two gbtas @xmath161 and @xmath162 respectively for the model and the specification .    given a state @xmath163 of @xmath1 and a state @xmath72 of @xmath2 , we use @xmath164 to denote the state - pair of @xmath163 and @xmath72 .",
    "operationally , @xmath164 can be viewed as @xmath165 , the functional composition of @xmath163 and @xmath72 .",
    "a _ play _ between @xmath1 and @xmath2 is made of two matching runs , one of @xmath1 and the other of @xmath2 .",
    "conceptually , it is a sequence    @xmath166    of triples with the following restrictions .",
    "@xmath167 is a run of @xmath1 . for convenience ,",
    "we denote this run as @xmath168 .",
    "@xmath169 is a run of @xmath2 . for convenience ,",
    "we denote this run as @xmath170 .    for each @xmath171 , @xmath172 .",
    "the play is _ initial _",
    "iff @xmath173 and @xmath174 .",
    "play prefix _ is a finite prefix of a play .",
    "given a play @xmath175 , we let @xmath176 be the prefix represented as the sequence of the first @xmath177 elements of @xmath175 .    given a run ( prefix )    @xmath178    of @xmath1 and a play ( prefix )    @xmath179    between @xmath1 and @xmath2 , we say @xmath175 _ embeds _",
    "@xmath180 iff there is a monotonically increasing integer function @xmath181 such that @xmath182 and for each @xmath114 , @xmath183 , @xmath184 , @xmath185 , and for each @xmath186 , @xmath187 .",
    "notationally , we let @xmath188 denote the embedding relation between @xmath175 and @xmath180",
    ". similarly we can define @xmath189 for the embedding relation between @xmath175 and a run @xmath190 of @xmath2 .",
    "a _ strategy _ in a game tells a ta what to execute at a state - pair in a play that is developing .",
    "specifically , a _ strategy _",
    "@xmath191 for @xmath2 is a mapping from play prefixes of @xmath1 and @xmath2 to event sets of @xmath192 .",
    "symmetrically , we can define strategies for @xmath1 . given a strategy @xmath191 for @xmath2 and a play @xmath193 between @xmath1 and @xmath2",
    ", we say that @xmath175 _ complies _ to @xmath191 iff the following constraints are satisfied .    for each @xmath171 and @xmath194 ,    @xmath195 .    for each @xmath171 and @xmath196 with either @xmath197 or @xmath198 ,    @xmath199",
    "similarly , we can also define the compliance of plays to strategies of @xmath1 . given a state - pair @xmath200 , a run @xmath180 of @xmath1 from @xmath163 , and a strategy @xmath191 of @xmath2 , we let @xmath201 be the play ( prefix ) from @xmath164 with the following restrictions .",
    "@xmath175 complies to @xmath191 .",
    "if @xmath175 is of infinite length , then it embeds @xmath180 .",
    "if @xmath175 is of finite length , then there is a finite prefix @xmath202 of @xmath180 with the following restrictions .",
    "@xmath175 embeds @xmath203 .",
    "any prefix of @xmath180 that supersedes @xmath203 is not embedded by @xmath175 .    note that it may happen that @xmath204 is of only finite length .",
    "this can happen when at the end of the finite play , a player chooses a transition with an event set that the other player ( _ opponent _ ) can not choose a transition to match .",
    "this can also happen when at the end of the finite play , a player can only execute matching transitions with post - condition falling outside the invariance predicate .",
    "[ def.simf ] a _ simulation _ @xmath205 of @xmath161 by @xmath162 is a binary relation @xmath206 such that for every @xmath207 and every run @xmath180 of @xmath1 from @xmath163 that satisfies @xmath208 , there exists a play @xmath175 from @xmath164 such that @xmath175 embeds @xmath180 and @xmath170 satisfies @xmath209 .",
    "we say that @xmath162 simulates @xmath161 , in symbols @xmath210 , if there exists a simulation @xmath205 of @xmath161 by @xmath162 such that for every @xmath211 , there exists a @xmath212 with @xmath207 .",
    "@xmath0 [ exmp.simf ] for the tas in figure  [ fig.ms_ne ] , we have that @xmath213 does not simulate @xmath214 .",
    "also , @xmath215 does not simulate @xmath216 .",
    "however , @xmath213 simulates @xmath217 .",
    "if @xmath162 simulates @xmath161 , then for all initial states @xmath163 and runs @xmath180 of @xmath1 from @xmath163 satisfying @xmath208 , there exists a strategy @xmath191 such that @xmath218 satisfies @xmath209 .",
    "we call such a @xmath191 a _ simulating strategy _ for @xmath180 by @xmath2 .",
    "if @xmath162 does not simulate @xmath161 , then there exists an initial run @xmath180 of @xmath1 such that @xmath180 satisfies @xmath208 and for all initial states @xmath72 and all strategies @xmath191 of @xmath2 , all initial runs of @xmath2 embedded by @xmath218 do not satisfy @xmath209 .",
    "we call such a run @xmath180 a _ refuting run _ of @xmath1 .",
    "a strategy @xmath191 of a ta @xmath2 is _ memory - less _",
    "iff for any two plays @xmath175 and @xmath219 that end at the same triple , @xmath220 .",
    "it is well known that parity games and reachability games all have memory - less winning strategies for either player @xcite .",
    "the following lemma shows that the simulation of gbas may need finite - memory refuting strategies .",
    "[ lemma.simf.memory ] there is a simulation of gbas with a simulation strategy for the specification but without a memory - less simulation strategy for the specification .",
    "+ in figure  [ fig.simf.memory ] , we have the tas of two gbas @xmath221 and @xmath222 .",
    "( 0,0 ) that need memory.,title=\"fig : \" ]    # 1#2#3#4#5 @font    ( 2847,1550)(166,-863 ) ( 1863,-476)(0,0)[lb ] ( 2543,-476)(0,0)[lb ] ( 2471,-47)(0,0)[lb ] ( 2006,-47)(0,0)[lb ] ( 2901,275)(0,0)[lb ] ( 1577,311)(0,0)[lb ] ( 2221,167)(0,0)[lb ] ( 2185,-798)(0,0)[lb ] ( 789,132)(0,0)[lb ] ( 789,-512)(0,0)[lb ] ( 897,-190)(0,0)[lb ] ( 181 , 24)(0,0)[lb ] ( 575,-798)(0,0)[lb ]    suppose we have a state - pair @xmath164 with @xmath223 and @xmath224 . as can be seen , for any memory - less strategy @xmath191 , either transition @xmath225",
    "will always be chosen for any initial play prefix that ends at @xmath164 or transition @xmath226 will always be .",
    "but such plays do not satisfy the strong fairness assumption of @xmath222 and can not be used to fulfill the strong fairness assumptions of @xmath2 .",
    "thus we know there is no memory - less simulation strategy for @xmath222 .    on the other hand",
    ", we can devise a strategy for @xmath2 that chooses @xmath225 and @xmath226 alternately .",
    "it is clear that such a strategy fulfills the strong fairness assumptions of @xmath227 .",
    "in this work , we focus on characterization of the simulation of a model gbta by a specification bta . that is , we restrict that the specification @xmath228 is a bta with @xmath229 .    for convenience , given an mf - assumption @xmath128 and a play @xmath193",
    ", we may also define the satisfaction of @xmath128 by @xmath175 in a way similar to the satisfaction of @xmath128 by runs .    according to definition  [ def.simf ] ,",
    "a state - pair @xmath164 is not in any simulation if there exists a run @xmath180 of @xmath1 from @xmath163 , satisfying @xmath208 , such that for every strategy @xmath191 for @xmath2 and play @xmath175 from @xmath164 complying to @xmath191 and embedding @xmath180 , @xmath175 does not satisfy @xmath209 .",
    "put this description in a structural way , we have the following presentation .",
    "@xmath230    according to the composition of @xmath209 , this can be broken down to cases described with the following four lemmas .",
    "[ lemma.rsim.ss ] in case @xmath231 for a state - predicate @xmath74 , a state - pair @xmath164 is not in any simulation of @xmath232 by @xmath228 iff    @xmath233    is true .",
    "+ according to the argument in the beginning of the subsection , we only have to prove that the following two statements are equivalent in the context that @xmath175 embeds @xmath180 .",
    "@xmath234 .",
    "@xmath235 .",
    "assume that    @xmath193 .",
    "we can prove this equivalence in two directions .",
    "@xmath236 we assume that @xmath234 . according to the definition of strong fairness , we know that there are only finitely many @xmath131 s with a @xmath132 $ ] such that @xmath237 .",
    "we let @xmath238 the maximum of such @xmath131 s .",
    "then it is clear that for every @xmath239 and @xmath139 $ ] , @xmath240 .",
    "this means that @xmath175 satisfies @xmath241 .",
    "then the embedding of @xmath180 by @xmath175 implies that @xmath175 satisfies @xmath242 .",
    "@xmath243 we assume that @xmath244 . then according to the definition of weak fairness , we know that there exists an @xmath238 such that for every @xmath239 and @xmath139 $ ] , @xmath245 . thus it is not true that there are infinitely many @xmath131 s with a @xmath246 $ ] such that @xmath237 .",
    "according to the definition of strong fairness , @xmath234 .    with the proof of the two directions , we know the lemma is proven .    [ lemma.rsim.se ] in case @xmath247 for an event - predicate @xmath120 , a state - pair @xmath164 is not in any simulation of @xmath232 by @xmath228 iff    @xmath248    is true .",
    "+ suppose we are given    @xmath193 .",
    "the proof is similar to the one for lemma  [ lemma.rsim.ss ] except that we need to show that for a @xmath249 , the equivalence between the following two statements .",
    "it is not true that @xmath250 , @xmath251 , and @xmath252 .",
    "if @xmath250 and @xmath251 , then @xmath253 .",
    "this equivalence follows from the semantics of propositional logic . by treating the event - predicate as a state - predicate",
    ", we can prove the lemma as we have proved lemma  [ lemma.rsim.ss ] .",
    "[ lemma.rsim.ws ] in case @xmath254 for a state predicate @xmath74 , a state - pair @xmath164 is not in any simulation of @xmath232 by @xmath228 iff    @xmath255    is true .",
    "+ by replacing @xmath74 with @xmath256 , we can use a proof similar to the one for lemma  [ lemma.rsim.ss ] for this lemma .",
    "[ lemma.rsim.we ] in case @xmath257 for a state predicate @xmath74 , a state - pair @xmath164 is not in any simulation of @xmath232 by @xmath228 iff    @xmath258    is true .",
    "+ by replacing @xmath259 with @xmath260 , we can use a proof similar to the one for lemma  [ lemma.rsim.se ] for this lemma .    for convenience , given two sets @xmath261 and @xmath262 of fairness assumptions ,",
    "we let @xmath263 denote    @xmath264 .    according to lemmas  [ lemma.rsim.ss ] , [ lemma.rsim.se ] , [ lemma.rsim.ws ] , and [ lemma.rsim.we ]",
    ", we conclude with the following lemma .",
    "[ lemma.rsim ] in case @xmath229 , a state - pair @xmath164 is not in any simulation of @xmath232 by @xmath228 iff    @xmath265    is true .    a procedure to construct a formula for states @xmath163 that starts a run of @xmath1 satisfying @xmath208 can be found in @xcite .",
    "lemma  [ lemma.rsim ] suggests that we still need to implement a procedure that constructs formulas for state - pairs that start all plays @xmath175 satisfying the following constraints .",
    "@xmath266    such a play @xmath175 eventually stabilizes into a cycle of state - pairs along which each assumption in @xmath267 is satisfied once and all assumptions in @xmath268 are satisfied throughout the cycle .",
    "the following definition characterizes state - pairs in such a cycle .",
    "[ def.isr ] a state - pair @xmath164 is _ csr _ ( _ cyclically simulation - refuting _ ) with @xmath269 iff for every @xmath270 , there exists a run @xmath180 of @xmath1 with the following two constraints .    for every strategy @xmath191 of @xmath2 with @xmath201 ,",
    "if @xmath175 is of infinite length , then the following four constraints are satisfied .",
    "all state - pairs along @xmath175 satisfy state - predicates in @xmath268 .",
    "all transition - pairs along @xmath175 satisfy event - predicates in @xmath268 .    for every state - predicate @xmath74 in @xmath267",
    ", there is a csr state - pair in @xmath175 satisfying @xmath74 in more than 1 time units from the start of @xmath175 .    for every event - predicate @xmath74 in @xmath267",
    ", there is a transition - pair in @xmath175 satisfying @xmath74 in more than 1 time units from the start of @xmath175 .",
    "there exists a strategy @xmath191 of @xmath2 with an infinitely long @xmath204 .",
    "the 1-time - unit requirement at condition c1c is for making sure that the play is non - zeno .",
    "a state - pair @xmath164 is _ inevitably sr _",
    "( _ isr _ ) with @xmath271 iff there exists a run @xmath180 of @xmath1 from @xmath163 such that for all strategies @xmath191 of @xmath2 , if @xmath204 is infinite , then @xmath204 visits a csr state - pair .",
    "the following lemma is important for our algorithm development .",
    "[ lemma.simf.neg-evidence ] suppose we are given a gbta @xmath1 and a bta @xmath2 .",
    "for any state - pair @xmath272 , the following two statements are equivalent .",
    "@xmath163 starts a run @xmath180 of @xmath1 satisfying @xmath208 and for all plays @xmath175 from @xmath164 embedding @xmath180 , @xmath175 satisfies @xmath269 .",
    "there exist an @xmath273 , a @xmath12 , and a @xmath274 with the following constraints",
    ".    @xmath275 .",
    "@xmath276 starts a run satisfying @xmath208 .",
    "for every @xmath277 and @xmath278 with @xmath279 , @xmath280 is an isr state - pair with @xmath281 .",
    "we prove the lemma in two directions .",
    "@xmath236 we assume that r1 is true .",
    "conditions r2a and r2b are automatically true since @xmath180 must begin with a timed transition step @xmath282 for some @xmath283 , and @xmath274 .    as for condition r2c",
    ", we establish it in the following .",
    "the truth of r1 means that for every strategy @xmath191 of @xmath2 , if @xmath201 embeds @xmath180 , then @xmath175 must satisfy @xmath269 .",
    "this means that there exists a @xmath284 such that for every such infinite @xmath175 , after @xmath285 time units from the start of @xmath175 , all predicates in @xmath268 are satisfied and all predicates in @xmath267 are satisfied infinitely and divergently many times .",
    "if such a @xmath285 does not exist , then we can construct a play that violates @xmath269 and the assumption of r1 .",
    "we claim that all state - pairs @xmath286 happening after @xmath285 time units from the start in all infinite plays are csr state - pairs in definition  [ def.isr ] .",
    "the reasons are the following .",
    "since @xmath286 happens @xmath285 time units after the start of the play , it must satisfy conditions c1a and c1b in definition  [ def.isr ] .",
    "moreover , along every infinite play from @xmath286 , for every predicate @xmath74 in @xmath267 , there are infinitely and divergently many state - pairs or transition - pairs that satisfies @xmath74 .",
    "thus we can find the first state - pair @xmath287 in the tail with the following restrictions .",
    "@xmath287 is at least one time unit from the start of the play .",
    "either @xmath287 satisfies @xmath74 as a state - predicate or the transition - pair right before @xmath287 satisfies @xmath74 as an event - predicate .",
    "this implies that conditions c1c and c1d in definition  [ def.isr ] are satisfied at @xmath287 .",
    "the assumption that leads to the satisfaction of @xmath269 by @xmath175 then implies that there exists such a play .",
    "this implies that condition c2 in definition  [ def.isr ] is satisfied .",
    "the argument in the above establishes that @xmath286 is indeed a csr state - pair .",
    "thus we know that along every infinite play from @xmath280 , we can reach such a @xmath286 .",
    "this implies that @xmath280 is an isr state - pair and condition r2c is satisfied .",
    "thus the lemma is proven in this direction .",
    "@xmath243 we assume that r2 is true .",
    "this implies that there exist an @xmath273 , a @xmath12 , and a @xmath274 with @xmath275 and @xmath276 starting a run satisfying @xmath208 .",
    "there are two cases to analyze .    by letting @xmath180",
    "start with @xmath288 and followed by the tail from @xmath276 that satisfies @xmath208 , we deduce that @xmath163 also starts a run @xmath180 that satisfies @xmath208 .",
    "then for all strategies @xmath191 of @xmath2 with @xmath201 , we can go to an isr state - pair @xmath280 with @xmath269 .",
    "this implies that for all infinite plays from @xmath280 , we can visit a csr state - pair @xmath286 .",
    "then according to the definition of csr state - pairs , for each predicate @xmath289 , we can go from @xmath286 along a play with all state - pairs and transition - pairs satisfying the predicates in @xmath268 .",
    "moreover , the play visits a csr state - pair @xmath287 that either satisfies @xmath74 as a state - predicate or satisfies with the transition - pair immediately before @xmath287 as an event - predicate .",
    "since @xmath287 is also csr , we can then repeat the same argument to fulfill another predicate assumption in @xmath267 . by repeating this procedure for all predicates in @xmath267 infinitely many times",
    ", we can construct every infinite plays from @xmath164 that embeds @xmath180 mentioned in the last item .",
    "this construction then leads to the conclusion that all plays from @xmath164 embedding @xmath180 satisfy @xmath269 .",
    "this completes the proof of this direction .",
    "since both directions of the proof are done , we know the lemma is true .",
    "lemma  [ lemma.simf.neg-evidence ] suggests the development of evaluation algorithm for csr state - pairs for the solution of usf - simulations of gbtas . in the following ,",
    "we explain how to do this .",
    "in this work , we focus on the simulation algorithm for a model gbta by a specification bta . our algorithm is based on the construction of formulas for csr and isr state - pairs . in the following , we assume the context of a model gbta @xmath232 and a specification bta @xmath228 .    in subsection  [ subsec.tck.mck ] , we present some symbolic procedures from model - checking technology of dense - time systems as our basic building blocks . in subsection",
    "[ subsec.timed.inevit ] , we present algorithms for state - pairs that can be forced to a goal in one timed transition step . in subsection  [ subsec.timed.minevit ]",
    ", we use the procedures in subsection  [ subsec.timed.inevit ] to construct a algorithms for state - pairs that can be forced to a goal in zero or more timed transition steps . in subsection",
    "[ subsec.simcheck.alg ] , we present the algorithm for simulation - checking . in subsection",
    "[ subsec.simf.complexity ] , we analyze the complexity of our algorithm .      in this subsection , we adapt procedures for tctl model - checking @xcite for the evaluation of simulation - checking .",
    "given a formula @xmath74 , a run prefix @xmath290 of @xmath1 is called an _ @xmath74-rprefix _ if for every @xmath291 and @xmath139 $ ] , @xmath292 .",
    "similarly , a play prefix @xmath293 of @xmath1 is called an _ @xmath74-pprefix _ if for every @xmath291 and @xmath139 $ ] , @xmath294 .",
    "given a state - pair set @xmath295 , we let @xmath296 . given a ta @xmath2 with @xmath297 and @xmath298 , we let @xmath299 be the following formula .    @xmath300 .",
    "also given a set @xmath301 and a set @xmath302 , we let @xmath303(\\eta)$ ] be the following formula .    @xmath304 .",
    "standard procedures for constructing state - predicates of existentially quantified formulas can be found in @xcite .",
    "given a transition - pair @xmath305 with @xmath306 and @xmath307 , we let @xmath308 be the formula of state - pairs that may go to state - pairs in @xmath74 through the simultaneous execution of @xmath93 and @xmath69 respectively . specifically , @xmath308 is defined as follows .",
    "@xmath309\\left (      \\begin{array}{lll }       \\eta       & \\wedge & \\lambda_{{\\cal m}}(q'_1)\\\\      & \\wedge & \\lambda_{{\\cal s}}(q'_2 )      \\end{array}\\right ) \\end{array}\\right)$ ]    we also need the formulas for the precondition of time - progress to a state - pair satisfying @xmath122 through intermediate state - pairs satisfying @xmath121 . procedures for such formulas can be found in @xcite .",
    "we present the formula , denoted @xmath310 , for the readers convenience in the following .",
    "@xmath311    here @xmath312 represents a formula obtained from @xmath74 by replacing every clock variable @xmath313 in @xmath74 with @xmath314 .",
    "we use adapted tctl formulas @xmath315 in our presentation of the algorithm .",
    "specifically , @xmath315 characterizes those state - pairs @xmath164 with the following restrictions .",
    "@xmath164 starts an @xmath121-pprefix @xmath175 that ends at a state - pair satisfying @xmath122 .",
    "along the @xmath175 mentioned in the above , all the transitions are of the form @xmath316 with @xmath317 .",
    "following the techniques in @xcite , we can construct a formula in @xmath318 that characterizes state - pairs satisfying @xmath315 . specifically , the formula is as follows .",
    "@xmath319    here @xmath320 is the least fixpoint operator and @xmath321 represents the smallest solution to @xmath322 .",
    "another type of formulas that we want to use is for states @xmath163 of @xmath1 that start runs satisfying @xmath208 .",
    "we denote this formula as @xmath323 for convenience .",
    "the construction of this formula can be found in @xcite .",
    "given a set @xmath295 of states ( or state - pairs ) , we use @xmath324 to denote a formula that characterizes @xmath295 . given a formula @xmath74",
    ", we use @xmath325\\!]}$ ] to represent the set of states ( or state - pairs ) that satisfies @xmath74 . given an @xmath273 , a set @xmath127 of event weak fairness assumption , and a @xmath12",
    ", we use @xmath326 to denote the set of state - pairs @xmath164 with the following restrictions .",
    "there is a @xmath327-rprefix    @xmath328,e , t+t_0)$ ]    with the following two restrictions .",
    "@xmath329 $ ] is in @xmath330 and satisfies @xmath323 .    for every @xmath331-pprefix    @xmath332    with    @xmath333 ,    @xmath334 ,    @xmath335 , and    @xmath336 ,    for every event weak fairness assumption",
    "@xmath337 , if @xmath338 and @xmath339 , then @xmath329          \\models\\eta_4 $ ] .",
    "@xmath340 is in @xmath341 .",
    "note that in the just - mentioned @xmath331-pprefix , the strategy of @xmath2 can only use the internal transitions of @xmath2 .",
    "we can use the following tctl formula to help us characterize @xmath326 . given two state - predicates @xmath342 , and a set @xmath127 of event formulas for weak fairness assumption , we let @xmath343 be defined as follows .",
    "@xmath344    here @xmath345 is an auxiliary clock variable not used in @xmath346 .",
    "the conjunction    @xmath347    in the post - condition is used to make sure that no event weak fairness assumptions in @xmath127 is violated .",
    "it is used to eliminate all state - pairs violating an event weak fairness assumption .",
    "the following lemma shows how to use the above formulas to help us evaluating @xmath348 .",
    "[ lemma.nxt.form.ext ] for every @xmath164 , @xmath349 , @xmath350 $ ] , formulas @xmath342 of state - pairs , and a set @xmath127 of event weak fairness assumptions , @xmath351\\!]}{\\bigcirc}^{e\\psi}_t { [ \\![}\\eta_2{]\\!]}$ ] iff    @xmath352 .",
    "we can rewrite condition @xmath353 of @xmath354\\!]}{\\bigcirc}^{e\\psi}_t { [ \\![}\\eta_2{]\\!]}$ ] as follows .",
    "there is no @xmath121-pprefix    @xmath332    with    @xmath333 ,    @xmath334 ,    @xmath335 ,    @xmath336 ,    @xmath355 , and    for every @xmath337 and @xmath356 , @xmath338 , and @xmath357 , it is not true that @xmath358\\models \\neg\\eta_4 $ ] .",
    "it is clear that a state - pair satisfies @xmath359 and @xmath353 if and only if it satisfies @xmath359 and @xmath360 . by renaming @xmath361 as a clock variable @xmath345 and @xmath362 as constant @xmath363",
    ", we can use @xmath364 to represent @xmath365 .",
    "this means that @xmath359 and @xmath360 can be rewritten as @xmath366 and the following two conditions .",
    "there exists an @xmath367-rprefix    @xmath368{8mm}{0.5pt}\\!\\!\\!\\longrightarrow}}],e,{{c^{{\\cal m}}_{{\\cal s}}}})$ ]    with @xmath369{8mm}{0.5pt}\\!\\!\\!\\longrightarrow}}]\\models       \\exists{{\\cal s}}(\\eta_2)\\wedge\\exists{\\box}\\phi_{{\\cal m}}\\psi_{{\\cal m}}$ ] .",
    "there is no @xmath121-pprefix    @xmath293    with @xmath335 , @xmath370 , @xmath333 , @xmath371 , and for every @xmath337 and @xmath356 , @xmath338 , and @xmath357 , it is not true that @xmath372\\models \\neg\\eta_4 $ ] .",
    "@xmath373 means the following .",
    "@xmath374\\!]}\\\\      \\wedge   & \\exists{\\box}\\phi_{{\\cal m}}\\psi_{{\\cal m}}\\end{array}\\right)\\right ) $ ]    @xmath375 means the following .",
    "@xmath376    combining these two formulas together and reduce them with the definition of @xmath343 , we find that @xmath164 must satisfy @xmath377 . thus the lemma is proven .",
    "based on lemma  [ lemma.nxt.form.ext ] , we can define the following notations for those state - pairs that can be forced into either certain destination or a transition of @xmath1 that @xmath2 can not match .",
    "specifically , we let    @xmath378 .    correspondingly , given two formulas @xmath121 and",
    "@xmath122 , we can construct @xmath379 , defined as follows .",
    "@xmath380 .    then according to lemma  [ lemma.nxt.form.ext ]",
    ", we can establish the following lemma .",
    "[ lemma.until.form ] for every @xmath272 , formulas @xmath342 of state - pairs , and set @xmath127 of event weak fairness assumptions , @xmath381\\!]}{\\bigcirc}^\\psi{[\\![}\\eta_2{]\\!]}$ ] iff @xmath382 .",
    "+ we have the following deduction .",
    "@xmath383\\!]}{\\bigcirc}^\\psi{[\\![}\\eta_2{]\\ ! ] } } \\\\   \\equiv   & \\mu\\nu\\in",
    "\\bigcup_{e\\in e_{{\\cal m}},t\\in{{{\\mathbb r}^{\\geq 0 } } } }      \\langle { { \\cal m}}\\rangle d_1{\\bigcirc}^{e\\psi}_t d_2 \\\\ \\equiv   &   \\bigvee_{e\\in e_{{\\cal m}},t\\in{{{\\mathbb r}^{\\geq 0 } } } }      \\mu\\nu\\in\\langle { { \\cal m}}\\rangle d_1{\\bigcirc}^{e\\psi}_t d_2 \\end{array}$ ]    according to lemma  [ lemma.nxt.form.ext ] , this implies the following .",
    "@xmath384    since @xmath343 does not contain variable @xmath365 , the above formulas are equivalent to the following .",
    "@xmath385    since @xmath386 is a tautology , we have the following .",
    "@xmath387    the last step is from the definition of @xmath379 .",
    "thus the lemma is proven .",
    "note that before the fulfillment of @xmath122 , @xmath388 is satisfied with play prefixes with only transitions internal to @xmath2 .      in general , we want to characterize state - pairs from which @xmath1 can force the fulfillment of @xmath122 through zero or more timed transition steps of @xmath1 that do not violate the weak fairness assumptions in @xmath127 .",
    "we denote the set of such state - pairs as @xmath389\\!]}{\\mbox{$\\cal u$}}^\\psi { [ \\![}\\eta_2{]\\!]}$ ] . for convenience ,",
    "given two formulas @xmath342 for sets of state - pairs , we let    @xmath390    here @xmath320 is the least fixpoint operator .",
    "@xmath391 specifies a smallest solution to equation @xmath392 .",
    "the procedure to construct formulas for such least fixpoints can be found in @xcite .",
    "[ lemma.until-star.form ] for every state - pairs @xmath164 and formulas @xmath342 for state - pairs , @xmath351\\!]}{\\mbox{$\\cal u$}}^\\psi { [ \\![}\\eta_2{]\\!]}$ ] iff @xmath393 .   + we can prove this lemma in two directions .",
    "@xmath236 we assume that @xmath394\\!]}{\\mbox{$\\cal u$}}^\\psi { [ \\![}\\eta_2{]\\!]}$ ] is true",
    ". we can prove this by induction on the maximum number @xmath395 of timed transition steps of @xmath1 to reach state - pairs in @xmath396\\!]}$ ] through state - pairs in @xmath397\\!]}$ ] .",
    "in the base case , @xmath398 and @xmath399\\!]}$ ] . then it is clear that @xmath164 also satisfies every formula of the form @xmath400 .",
    "thus , @xmath393 in the base case and the lemma is proven .",
    "now we assume that this direction of the lemma is true for every state - pairs with maximum number no greater than @xmath131 with @xmath249 .",
    "now we have a state - pair @xmath164 with maximum number @xmath177 of timed transition steps to reach state - pairs in @xmath396\\!]}$ ] through state - pairs in @xmath397\\!]}$ ] .",
    "this implies that there exist an @xmath273 and a @xmath101 with    @xmath401\\!]}{\\bigcirc}^{e\\psi}_t \\left(\\langle { { \\cal m}}\\rangle{[\\![}\\eta_1{]\\!]}{\\mbox{$\\cal u$}}^{\\psi } { [ \\![}\\eta_2{]\\!]}\\right)$ ] .",
    "this means that in one timed transition step of @xmath93 and @xmath365 time units by @xmath1 , we end up in a state - pair @xmath280 such that within @xmath131 timed transition of @xmath1 steps through state - pairs in @xmath397\\!]}$ ] , we can go from @xmath280 to state - pairs in @xmath396\\!]}$ ] . according to the inductive hypothesis , we know that @xmath280 satisfies @xmath402 .",
    "together , this implies the following deduction .",
    "@xmath403    according to the definition of least fixpoint , the last step implies @xmath404 . by definition",
    ", this implies that @xmath405 .",
    "thus this direction of the lemma is proven by induction .",
    "@xmath243 we assume that there exist @xmath406 such that @xmath407 , @xmath408 , and for every @xmath409 , @xmath410 .",
    "we prove by induction on @xmath411 $ ] that @xmath412 implies @xmath394\\!]}{\\mbox{$\\cal u$}}^\\psi{[\\![}\\eta_2{]\\!]}$ ] .",
    "the base case is that @xmath413 and @xmath414 .",
    "this implies that @xmath399\\!]}$ ] and @xmath415\\!]}{\\mbox{$\\cal u$}}^\\psi{[\\![}\\eta_2{]\\!]}$ ] .",
    "thus the base case is proven .",
    "now we assume that the lemma in this direction is true for all @xmath416 $ ] .",
    "now we have a @xmath417 .",
    "this means that @xmath418 .",
    "there are two cases to analyze .",
    "the first is @xmath419 and coincides with the base case .",
    "thus the first case is already proven .",
    "the second case is @xmath420 . according to lemma  [ lemma.nxt.form.ext ] ,",
    "this implies that we can force in one timed transition step through state - pairs in @xmath397\\!]}$ ] to state - pairs @xmath280 in @xmath421\\!]}$ ] .",
    "moreover , the inductive hypothesis says that all such @xmath422 . according to the definition of @xmath423",
    ", this implies that @xmath424 .",
    "thus the lemma is proven in this direction .    thus the lemma is proven .",
    "our plan is first to use the procedures in subsections  [ subsec.tck.mck ] , [ subsec.timed.inevit ] , and [ subsec.timed.minevit ] to construct a procedure for evaluating csr state - pairs .",
    "then we use this procedure to evaluate isr state - pairs . for convenience , we denote    @xmath425 .    conceptually , @xmath426 denotes the state - predicates that a play satisfying @xmath427 must stabilize with .",
    "also we let @xmath428 be the set of event - predicates in @xmath268 . for convenience ,",
    "we also let @xmath429 and @xmath430 .",
    "we present a greatest fixpoint characterization , denoted @xmath431 , of the csr state - pairs with an mf - assumption @xmath128 .",
    "a state - pair @xmath164 satisfies @xmath431 if there is a fair run from @xmath163 such that all plays embedding the run from @xmath164 can not be fair for @xmath2 . the characterization follows .",
    "@xmath432 .",
    "here @xmath433 is the greatest fixpoint operator .",
    "@xmath434 is a largest solution @xmath435 to @xmath436 .",
    "the procedure to construct formulas for greatest fixpoints can be found in @xcite .",
    "the following lemma establishes the correctness of the characterization .",
    "[ lemma.mfsf ] a state - pair @xmath164 is csr with @xmath437 iff @xmath438 .",
    "+ following definition  [ def.isr ] , lemma  [ lemma.until-star.form ] , the definition of @xmath426 , and the semantics of greatest fixpoint , @xmath439 is actually a rewriting of the csr definition with logic formulas , the greatest fixpoint procedure , and the @xmath440 procedure .",
    "thus the lemma is proven .",
    "now we use @xmath439 to evaluate isr state - pairs . given a fair run @xmath180 of @xmath1 , there are two classes of isr state - pairs .",
    "the first class contains state - pairs that start no play embedding @xmath180 .",
    "the second class contains state - pairs with a strategy @xmath2 to drive a play to stabilize to csr state - pairs .",
    "the former can be evaluated with the traditional procedures for branching simulation @xcite .",
    "specifically , state - pairs is in the first class can be characterized with the following lemma .",
    "[ lemma.isr.1st ] a state - pair @xmath164 is a first - class isr state - pair iff @xmath441 .",
    "+ @xmath164 is first class iff for all strategies @xmath191 of @xmath2 , @xmath204 is of finite length .",
    "there can only be two causes for the termination of the plays .    along a time progress operation , @xmath1 moves to a valid state while @xmath2 can not .",
    "this is captured by formula @xmath442 .    at a transition",
    "@xmath93 by @xmath1 , no compatible @xmath277 can result in a valid state of @xmath2 .",
    "this is captured by @xmath443 .",
    "if and only if @xmath1 can drive all plays to state - pairs with these two causes , then it is clear all plays are finite in length . thus the lemma is proven .",
    "the state - pairs in the second class can be forced into infinite plays that stabilize in csr state - pairs .",
    "specifically , we have the following lemma .    [ lemma.isr.2nd ]",
    "a state - pair @xmath164 is a second - class isr state - pair iff @xmath444 .",
    "+ this lemma follows from the definition of the second class state - pairs , lemma  [ lemma.until-star.form ] , and lemma  [ lemma.mfsf ] .",
    "combining lemmas  [ lemma.simf.neg-evidence ] , [ lemma.isr.1st ] , and [ lemma.isr.2nd ] , we present the following lemma for the characterization of state - pairs that is in no simulation of a gbta by a bta .",
    "[ lemma.sim.refute ] a state - pair @xmath164 is in no simulation of a gbta @xmath445 by a bta @xmath446 iff @xmath164 satisfies either @xmath447 or @xmath448 .",
    "the complexity of our algorithm relies on the implementation of the basic manipulation procedures of zones . like in @xcite",
    ", we argue that we can implement the formulas as sets of pairs of proposition valuations and regions @xcite .",
    "in such an implementation , basic operations like subsumption , intersection , union , complement , time progression , and variable quantification can all be done in exptime .",
    "[ lemma.bisim.complexity ] proper implementations of the formulation in lemma  [ lemma.sim.refute ] can be done in exptime .",
    "+ according to @xcite , a zone can be implemented as a set of regions .",
    "the number of regions is exponential to the input size of @xmath445 and @xmath446 .",
    "all precondition calculations need at most polynomial numbers of region set operations and can all be done in exptime .",
    "the numbers of iterations of the least and greatest fixpoint procedures are at most the number of regions .",
    "thus , summing everything up , we conclude that our algorithm can be executed in exptime .",
    "in real - world , we may usually want to check whether a system component satisfies its specification .",
    "in such a context , the simulation - checking is carried out against the same behavior of the environment of the component .",
    "such a context can usually make room for verification efficiency if we carefully represent the common environment state information . in this section ,",
    "we extend the simulation defined in section  [ sec.simf ] to simulation of a model by a specification against a common environment .",
    "then we propose a technique to take advantage of the common environment information for simulation - checking efficiency .    in figure",
    "[ fig.mse ] , there are two tas for two environment processes .",
    "( 0,0 )    # 1#2#3#4#5 @font    ( 5195,3561)(664,-3139 ) ( 1501 , 89)(0,0)[lb ] ( 2926,-811)(0,0)[lb ] ( 5176,-361)(0,0)[lb ] ( 3226,-286)(0,0)[lb ] ( 4726 , 89)(0,0)[lb ] ( 1501,239)(0,0)[lb ] ( 901,-1111)(0,0)[lb ] ( 976,-361)(0,0)[lb ] ( 976,-2311)(0,0)[lb ] ( 1501,-1861)(0,0)[lb ] ( 2926,-2761)(0,0)[lb ] ( 5176,-2311)(0,0)[lb ] ( 3226,-2236)(0,0)[lb ] ( 3226,-2386)(0,0)[lb ] ( 4726,-1861)(0,0)[lb ] ( 1501,-1711)(0,0)[lb ] ( 901,-3061)(0,0)[lb ]    note that location comp in figure  [ fig.mse](b ) is labeled with a deadline @xmath449 .",
    "this means that the environment process in figure  [ fig.mse](b ) can only stay in location comp for at most 10 time units .",
    "thus the environment process in figure  [ fig.mse](a ) may deliver late service while the one in figure  [ fig.mse](b ) always deliver service in 10 time units . against the environment described by figure  [ fig.mse](a ) , the @xmath2 in figure  [ fig.ms_ne](b ) does not simulate the @xmath1 in figure  [ fig.ms_ne](a ) since the @xmath1 terminates the computation on late service while the @xmath2 never terminates the computation . in comparison , against figure  [ fig.mse](b )",
    ", the @xmath2 simulates the @xmath1 since the service is always in time .",
    "we use _ ctas _ ( _ communicating timed automata _ ) to model the interaction between an environment and a model ( or a specification ) .",
    "the formal definition is in the following .",
    "[ def.cta ] a cta of two tas @xmath119 and @xmath450 , in symbols @xmath451 , is a ta with the following constraints .",
    "@xmath452 .",
    "@xmath453 .",
    "@xmath454 .",
    "@xmath455 .",
    "@xmath456 .    for each @xmath457 , @xmath458 .    for simplicity , we assume that @xmath459 , @xmath460 , and @xmath461 . moreover , the transitions of a product ta needs to consider the synchronization between the two process tas . specifically , we let @xmath462",
    "for each @xmath463 , one of the following constraints must hold .",
    "@xmath464 represents the autonomous execution of a process ta with a transition without any events . formally speaking ,",
    "this means at least one of @xmath93 and @xmath69 is @xmath51 , i.e. , no operation .",
    "we have the following two cases to explain .    if @xmath465 and @xmath466 , then @xmath150 , @xmath467 , @xmath468 , @xmath469 .    if @xmath470 and @xmath471 , then @xmath151 , @xmath472 , @xmath473 , @xmath474 .",
    "@xmath464 represents the synchronized execution of the two process tas respectively with a receiving event and a sending event of the same type . formally speaking",
    ", this means that there is an @xmath475 with the following restrictions .",
    "either of the following two is true .",
    "@xmath476 , @xmath477 , and @xmath478 .",
    "@xmath479 , @xmath480 , and @xmath481 .",
    "note here we blend the process names and the operations into the name of the new events .",
    "for example , @xmath482 and @xmath483 respectively represent the receiving and the sending of event @xmath125 by process @xmath119 .",
    "@xmath484 .",
    "@xmath485 .",
    "@xmath0 [ exmp.cta ] for the specification @xmath2 in figure  [ fig.ms_ne](b ) and the environment @xmath22 in figure  [ fig.mse](a ) , we have @xmath486 with attributes in table  [ tab.cta.attr ] .",
    "@xmath487 \\\\   e_{{{{\\cal e}}\\times{{\\cal s } } } } & = &   \\{((\\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) ,      ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) ) ,   ( ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) ,     ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2))\\ } \\\\   \\sigma_{{{{\\cal e}}\\times{{\\cal s } } } } & = &   \\{\\mbox{\\tt request},\\mbox{\\tt serve},\\mbox{\\tt end}\\ } \\\\",
    "\\epsilon_{{{{\\cal e}}\\times{{\\cal s } } } } & = &   \\left [ \\begin{array}{l } ( ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) ,      ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) )      \\mapsto\\{!\\mbox{\\tt request}@({{\\cal e } } ) , ?",
    "\\mbox{\\tt request}@({{\\cal s}})\\ } , \\\\ ( ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) ,     ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) )      \\mapsto\\{?\\mbox{\\tt serve}@({{\\cal e } } ) , !",
    "\\mbox{\\tt serve}@({{\\cal s}})\\ } \\end{array}\\right ] \\\\",
    "\\tau_{{{{\\cal e}}\\times{{\\cal s } } } } & = &   \\left [ \\begin{array}{l } ( ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) ,      ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) )      \\mapsto x_2>5 , \\\\ ( ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) ,     ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) )      \\mapsto{\\mbox{\\em true}}\\end{array}\\right ] \\\\",
    "\\pi_{{{{\\cal e}}\\times{{\\cal s } } } } & = &   \\left [ \\begin{array}{l } ( ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) ,      ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) )      \\mapsto\\{x_3\\ } , \\\\ ( ( \\mbox{\\tt process},\\mbox{\\tt wait}_2 ) ,     ( \\mbox{\\tt standby},\\mbox{\\tt idle}_2 ) )      \\mapsto\\{x_2\\ } \\end{array}\\right ] \\end{array}$ ] + @xmath68 $ ] denotes a ( partial or total ) function @xmath69 with @xmath70 .",
    "since a cta is also a ta , we explain how to interpret the notations about tas for ctas . given a state @xmath488 of @xmath119 and a state @xmath163 of @xmath450 ,",
    "@xmath489 is called a state of @xmath490 .",
    "we say a state @xmath489 satisfies a state predicate @xmath491 , in symbols @xmath492 , with the following inductive rules .    for any @xmath493 , @xmath494 iff @xmath495 .    for any @xmath496 , @xmath494 iff @xmath497",
    "for any @xmath498 , @xmath499 iff @xmath500 .    for any @xmath501 , @xmath499 iff @xmath502 .",
    "@xmath503 iff it is not the case that @xmath504 .",
    "@xmath505 iff @xmath504 or @xmath506 .",
    "the state after a transition @xmath464 from a state @xmath489 of cta , denoted @xmath507 , can also be interpreted as @xmath508 .",
    "a timed transition of @xmath365 time units from a state @xmath489 , denoted @xmath509 , can be defined as @xmath510 . in this way",
    ", we can also define the timed transition relation between two states @xmath511 through a transition @xmath464 in @xmath365 time units , denoted as    @xmath512 ,    with the following restrictions .    for all @xmath106 $ ] , @xmath513 .",
    "@xmath514 .",
    "@xmath515 .",
    "then a run of @xmath490 can also be defined as a sequence    @xmath516    with @xmath517{10mm}{0.5pt}\\!\\!\\!\\longrightarrow}}(\\mu_{k+1},\\nu_{k+1})$ ] for all @xmath249 .",
    "given a cta @xmath518 and an mf - assumption @xmath128 of @xmath518 , @xmath519 is called a _ gcbta _ ( _ generalized communicating bta _ ) .",
    "similarly , @xmath519 is a _ cbta _ ( _ communicating bta _ ) if @xmath144 .",
    "[ def.simfe ] * simulation of gcbtas against an environment * a _ simulation _ @xmath520 of a model gcbta @xmath161 by a specification gcbta @xmath162 against an environment gcbta @xmath521 is a binary relation @xmath522 such that for every @xmath523 , the following restrictions are satisfied .",
    "@xmath524 with @xmath525 .",
    "@xmath526 .",
    "@xmath527 .    for every run @xmath180 of @xmath23 from @xmath489 that satisfies @xmath528",
    ", there exists a play @xmath175 from @xmath529 with the following restrictions .",
    "@xmath175 embeds @xmath180 and satisfies @xmath530 .    for every transition",
    "@xmath531 along @xmath175 , @xmath532 .",
    "we say that @xmath162 simulates @xmath161 against environment @xmath521 , in symbols    @xmath533 ,    if there exists a simulation @xmath520 of @xmath161 by @xmath162 against @xmath521 such that for every @xmath534 , there exists an @xmath535 with @xmath536 .",
    "as can be seen , definition  [ def.simfe ] is more restrictive than definition  [ def.simf ] in their presentations .",
    "however , we can prove that they are equivalent .",
    "[ lemma.simfe.eq ] given an environment gcbta @xmath521 , a model gcbta @xmath161 , and a specification gcbta @xmath162 , @xmath537 iff @xmath538 .",
    "+ the backward direction of the proof is straightforward since every simulation against an environment in definition  [ def.simfe ] is also a simulation in definition  [ def.simf ] .",
    "thus we only have to focus on the forward direction of the proof .",
    "we first assume that there is a simulation @xmath205 of @xmath539 by @xmath540 .",
    "we can construct @xmath520 as follows .",
    "@xmath541 .    given an @xmath542 ,",
    "it is apparent that @xmath543 satisfies conditions se1 , se2 , and se3 of definition  [ def.simfe ] .",
    "then for every runs @xmath180 of @xmath23 from @xmath489 satisfying @xmath528 , there exists a play @xmath175 from @xmath529 such that @xmath175 embeds @xmath180 and satisfies @xmath530 .",
    "suppose    @xmath544    this implies the following for all @xmath249 .",
    "@xmath545    then we can construct a sequence @xmath546 as follows .",
    "@xmath547    we have the following two claims to prove the lemma .    @xmath546 is a play of @xmath548 by @xmath549 and embeds @xmath180 .",
    "@xmath546 satisfies @xmath530 .",
    "claim cl1 relies on the validity that for all @xmath249 ,    @xmath550{10mm}{0.5pt}\\!\\!\\!\\longrightarrow } } & ( \\alpha_{k+1},\\mu_{k+1})\\\\ ( \\alpha_k,\\nu_k ) & \\stackrel{t_{k+1}-t_k,(e_k , g_k)}{{\\rule[2pt]{10mm}{0.5pt}\\!\\!\\!\\longrightarrow } } & ( \\alpha_{k+1},\\nu_{k+1 } ) \\end{array}$ ]    these two statements rely on the following three statements .",
    "@xmath551    the validity of the above three then follows from statements @xmath552 , and @xmath553 in the above .",
    "thus we know that @xmath546 is indeed a play of @xmath554 .",
    "furthermore , the validity of statements @xmath555 and @xmath556 implies that @xmath546 indeed embeds @xmath180 .",
    "now we want to prove claim cl2 . for all assumptions in @xmath557 and @xmath558",
    ", they are automatically satisfied since @xmath546 also embeds @xmath180 and @xmath180 satisfies @xmath559 . for a strong fairness assumption @xmath560",
    ", we have the following two cases to analyze .    _",
    "@xmath561 is a state - predicate .",
    "_ we claim that along @xmath546 , for every @xmath562 , there exists an @xmath138 and a @xmath563 $ ] with @xmath564 .",
    "this is true since along @xmath175 , @xmath565 which implies that @xmath566 which in turn implies the claim .    _",
    "@xmath567 is an event - predicate . _",
    "we claim that along @xmath546 , for every @xmath562 , there exists an @xmath138 with @xmath568 , @xmath569 , and @xmath570 .",
    "this is true since along @xmath175 , @xmath571 , @xmath572 , and @xmath573 .",
    "this further implies that @xmath574 , @xmath575 , and @xmath576 . in the end",
    ", this implies the claim .    for a weak fairness assumption @xmath577",
    ", we have the following two cases to analyze .    _",
    "@xmath578 is a state - predicate .",
    "_ we claim that there exists a @xmath562 such that for every @xmath138 and @xmath563 $ ] , @xmath579 .",
    "this is true since along @xmath175 , @xmath580 which implies that @xmath581 which in turn implies the claim .    _",
    "@xmath582 is an event - predicate .",
    "_ we claim that along @xmath546 , there exists a @xmath562 such that for all @xmath138 , if @xmath568 and @xmath583 , then @xmath570 .",
    "this is true since along @xmath175 , if @xmath571 and @xmath584 , then @xmath573 .",
    "this further implies that if @xmath574 and @xmath585 , then @xmath576 . in the end , this implies the claim .",
    "with the proof of claims cl1 and cl2 , thus we conclude that the lemma is proven .    according to lemma  [ lemma.simfe.eq ]",
    ", we can check the classic simulation in definition  [ def.simf ] by checking the one in definition  [ def.simfe ] .",
    "this can be helpful in enhancing the verification performance when the common environment between the model and the specification is non - trivial .",
    "lemma  [ lemma.simfe.eq ] implies that we can use the following techniques to enhance the simulation algorithm against an environment .",
    "based on condition se1 of definition  [ def.simfe ] , we significantly reduce the sizes of the spaces of state - pairs by disregarding state - pairs of the form @xmath529 with @xmath586 .",
    "since the number of different zones representing @xmath587 s can be exponential to the input size , the reduction can result in exponential speed - up .    by mapping variables in @xmath587 in state - pairs @xmath529 , to those in @xmath488",
    ", we actually only have to record one copy of values for each variables in @xmath488 .",
    "since the size of bdd - like diagrams@xcite is exponential to the number of variables , this technique can also significantly reduce the memory usage in representations with bdd - like diagrams .    in evaluating the precondition of state - pairs",
    ", we need to enumerate all the transition pairs of the form @xmath531 with @xmath588 , @xmath589 , and @xmath590 .",
    "if we use the classic simulation , the enumeration is of size @xmath591 .",
    "but with the simulation against a common environment in definition  [ def.simfe ] , the enumeration is of size @xmath592 .",
    "thus significant reduction in time and space complexity can also be achieved with definition  [ def.simfe ] .",
    "we have implemented the techniques proposed in this manuscript in * red * 8 , a model / simulation - checker for ctas and parametric safety analysis for lhas based on crd ( clock - restriction diagram ) @xcite and hrd ( hybrid - restriction diagram ) technology @xcite .",
    "the state - pair spaces are explored in a symbolic on - the - fly style . to our knowledge , there is no other tool that supports fully automatic simulation checking with gbtas .",
    "we used parameterized networks of processes as our benchmarks . for a network of @xmath238 processes , we use integer @xmath17 through @xmath238 to index the processes .",
    "users supply two index lists , the first for the indices of the model processes and the second for indices of the specification processes .",
    "the process indices not in the two lists are treated as indices of the environment processes .",
    "for example , we may have a system of 10 processes .",
    "the following describes a simulation - checking task of process 1 ( the model ) by process 1 ( the specification ) .    ....           1;2 ;   ....    here processes 3 through 10 are the environment processes .    to support convenience in presenting fairness assumptions , we allow parameterized expressions .",
    "for example , in table  [ tab.sim.reqs](a ) , we have a simulation requirement with parameterized strong fairness assumptions .",
    "\\(a ) one simulation requirement +    ' '' ''    .... # ps-1 assume {    strong event { execute@(#ps-1 ) } ;     } ;    # ps assume {     strong true event { execute@(#ps ) } true ;    } ;    assume { |k:2 .. #ps-2 ,     strong true event { execute@(k ) } ;   }   ....    ' '' ''    \\(b )",
    "another simulation requirement +    ' '' ''    .... # ps-1   assume {    strong event { execute@(#ps-1 ) } ;     } ;    # ps   assume {     weak idle@(#ps ) ;    } ;    assume {     |k:2 ..",
    "#ps-2 ,       strong true event { execute@(k ) } ;   }   ....    ' '' ''    here ` # ps ` is a parameter for the number of processes .",
    "thus for a system of 10 processes , process 9 is the model , process 10 is the specification , while the others are the environment .",
    "the last assume statement is for the fairness assumption of the environment .",
    "the specification of event - predicates is in the following form .",
    "type [ @xmath121 ] a [ @xmath122 ]    here type is either ` strong ' or ` weak . '",
    "[ @xmath121 ] and [ @xmath122 ] are respectively the optional precondition and the optional post - condition .",
    "we may also use quantified expressions to present several fairness assumptions together .",
    "for example , in the above ,    ....      assume { |k:2 .. #ps-2 ,         strong true event { execute@(k ) } ;       }   ....    presents the following strong fairness assumptions .    ....",
    "strong true event { execute@(2 ) }     strong true event { execute@(3 ) }             ...          ...     strong true event { execute@(8 ) }   ....",
    "to our knowledge , there is no other tool that supports fully automatic simulation checking with fairness assumptions for tas as ours .",
    "so we only experimented with our algorithms .",
    "we report two experiments .",
    "the first is for timed branching simulation against a common environment without fairness assumptions in subsection  [ subsec.exp.tsim ] . especially , we report the performance enhancement of the simulation in definition  [ def.simfe ] ( without fairness assumption ) over the simulation in definition  [ def.simf ] .",
    "the second experiment is for simulation against a common environment with fairness assumptions in subsection  [ subsec.exp.fsim ] . especially , we use liveness properties in the experiment .",
    "we used the following three parameterized benchmarks from the literature .",
    "_ fischer s timed mutual exclusion algorithm _",
    "@xcite : the algorithm relies on a global lock and a local clock per process to control access to a critical section .",
    "two timing constants used are 10 and 19 .",
    "_ csma / cd_@xcite : this is the ethernet bus arbitration protocol with collision - and - retry . the timing constants used are 26 , 52 , and 808 .",
    "_ timed consumer / producer_@xcite : there is a buffer , some producers , and some consumers .",
    "the producers periodically write data to the buffer if it is empty .",
    "the consumers periodically wipe out data , if any , in the buffer .",
    "the timing constants used are 5 , 10 , 15 , and 20 .    for each benchmark , we use one model process and one specification process .",
    "all the other processes are environment .",
    "also for each benchmark , two versions are used , one with a simulation and one without . for the versions with a simulation , @xmath1 and @xmath2 are identical . for the version without ,",
    "@xmath1 and @xmath2 differ in only one process transition or invariance condition .",
    "for example , for the fischer s benchmark , the difference is that the triggering condition of a transition to the critical section of @xmath2 is mistaken .",
    "the performance data is reported in table  [ tab.perf.tsim ] .",
    "[ cols=\"<,<,^ , > , > , > , > \" , ]      + for each benchmarks , there are a model process , a specification process , and @xmath238 environment processes . `",
    "n / a ' means  not avaiable . \"",
    "+ data collected on a pentium 4 1.7ghz with 380 mb memory running linux ; + s : seconds ; k : kilobytes of memory in data - structure ; m : megabytes of total memory +    as can be seen from the performance data , our techniques show promise for the verification of fulfillment of liveness properties in concurrent computing .",
    "in this work , we investigate the simulation problem of tas with multiple strong and weak fairness assumptions . for the succinct presentation of fairness assumptions , we also allow for event fairness properties .",
    "we then present an algorithm for the usf - simulation of gbtas .",
    "the algorithm is based on symbolic model - checking and simulation - checking techniques and can be of interest by itself .",
    "we then propose a new simulation against a common environment between the model and the specification",
    ". we then present efficiency techniques for this new simulation .",
    "our implementation and experiment shows the promise that our algorithm could be useful in practice in the future .",
    "the work is partially supported by nsc , taiwan , roc under grants nsc 97 - 2221-e-002 - 129-my3 .",
    "+ part of the work appears in the proceedings of formats 2007 , lncs 4763 , springer - verlag@xcite and the proceedings of hscc 2009 , lncs 5469 , springer - verlag @xcite .",
    "f.  wang .",
    "symbolic parametric safety analysis of linear hybrid systems with bdd - like data - structures .",
    ", 31(1):3851 , 2005 .",
    "a preliminary version is in proceedings of 16th cav , 2004 , lncs 3114 , springer - verlag .",
    "f.  wang .",
    "symbolic simulation checking of dense - time automata . in _",
    "5th formats ( international conference on formal modelling and analysis of timed systems ) _ , volume lncs 4763 .",
    "springer - verlag , october 2007 .",
    "f.  wang .",
    "time - progress evaluation for dense - time automata with concave path conditions . in _",
    "atva ( international symposium of automated technology on verification and analysis ) _ , volume lncs 5311 .",
    "springer - verlag , 2008 .",
    "f.  wang , g .- d .",
    "huang , and f.  yu .",
    "tctl inevitability analysis of dense - time systems : from theory to engineering . , 32(7 ) , 2006 . a preliminary version of the work appears in the proceedings of 8th ciaa ( conference on implementation and application of automata ) , july 2003 , santa barbara , ca , usa ; lncs 2759 , springer - verlag ."
  ],
  "abstract_text": [
    "<S> we investigate the simulation problem in of dense - time system . </S>",
    "<S> a specification simulates a model if the specification can match every transition that the model can make at a time point . </S>",
    "<S> we also adapt the approach of emerson and lei and allow for multiple strong and weak fairness assumptions in checking the simulation relation . </S>",
    "<S> furthermore , we allow for fairness assumptions specified as either state - predicates or event - predicates . </S>",
    "<S> we focus on a subclass of the problem with at most one fairness assumption for the specification . </S>",
    "<S> we then present a simulation - checking algorithm for this subclass . </S>",
    "<S> we propose simulation of a model by a specification against a common environment . we present efficient techniques for such simulations to take the common environment into consideration . </S>",
    "<S> our experiment shows that such a consideration can dramatically improve the efficiency of checking simulation . </S>",
    "<S> we also report the performance of our algorithm in checking the liveness properties with fairness assumptions .    </S>",
    "<S> * keywords : * branching simulation , fairness , verification , bchi automatas , concurrent computing , timed automata , algorithms , experiment </S>"
  ]
}