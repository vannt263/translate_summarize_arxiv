{
  "article_text": [
    "parallel service systems have servers of types @xmath7 , customers of types @xmath8 , and bipartite compatibility graph @xmath9 , where @xmath10 if servers of type @xmath4 can serve customers of type @xmath5 .",
    "they model situations in which a large volume of service requests of various types are channelled to a central facility , where they are attended by a large number of agents differentiated by skill .",
    "such situations commonly occur in manufacturing , transportation , service contact centers , health systems , communications , internet data exchange , computing and various other areas of applications .",
    "the queueing model has a general renewal stream of arriving customers with rate @xmath11 , where successive arrivals are of i.i.d types , @xmath5 with probability @xmath12 , and there is a total of @xmath13 servers , @xmath14 of which are of type @xmath4 .",
    "service times are independent , distributed according to general distributions @xmath15 , with mean @xmath16 and service rate @xmath17 .",
    "customers have finite patience , with independent patience time distributions @xmath18 , and a customer abandons if he does not start service by the time his patience is exhausted .",
    "parallel server systems are widely discussed in the literature .",
    "an incomplete list would include an early study @xcite ; applications to manufacturing and supply chain management @xcite , applications to call centers and internet service systems @xcite , attempts to find optimal policies , mainly for small graph systems @xcite , heavy traffic and fluid approximations @xcite , and many server scaling @xcite .",
    "most relevant to our current paper are @xcite .",
    "in assessing such systems there are various objectives that may be of importance , on the customer side they include waiting times and abandonment rates as well as consideration of fairness to customers of various types or priorities for some types . in conflict with those , on the server side there is the objective of maximum utilization of the servers , minimizing their number , and reaching a balanced work division between the various types .",
    "each of these may carry a different weight in different application contexts .",
    "often @xmath11 , @xmath12 and @xmath18 are given , together with some form of quality of service requirements .",
    "all the other parameters of the system can be adjusted to achieve the requirements in an optimal way : one can redesign the bipartite compatibility graph , change the service rates , change the workforce mix , decide on @xmath13 , and decide on the service policy .",
    "it should perhaps be pointed out that changing the service policy may be as hard and costly as adjusting any of the other service parameters . at this level of generality such systems",
    "do not allow a complete analytic analysis , and performance is often evaluated in practice by simulation .",
    "however , any methods for calculating approximate performance measures or supporting design without the need to use simulation should be quite valuable .",
    "it is the aim of this paper to deliver such methods .    in the current paper",
    "we focus on the policy of first come first served ( fcfs ) , where whenever a server is available he will take the longest waiting compatible customer , and assign longest idle server ( alis ) , where whenever a customer arrives he will be assigned to the longest idling compatible server .",
    "we provide a heuristic to calculate performance measures under this policy , when @xmath11 and @xmath13 are large .",
    "fcfs - alis in a parallel service system has several advantages : it attempts to achieve resource pooling @xcite , i.e. all the servers are busy for about the same fraction of time , and it attempts to give all customers the same service level , i.e. global fcfs , equally for all types of customers @xcite .",
    "it is also fair to the servers .",
    "one notable property of fcfs is the following : assume that arriving customers can choose the server they wish to go to , and servers then serve the queueing customers fcfs .",
    "if each arrival has complete information on the schedule of all the servers at his moment of arrival , then to minimize his waiting time he will join the compatible server that has the shortest workload ( jsw ) .",
    "thus jsw is the nash equilibrium of fully informed customers minimizing waiting times . but",
    "this policy of jsw is automatically achieved when customers queue up in a single queue and the servers are using fcfs .",
    "fcfs can then serve as a benchmark , and comparison of the costs under fcfs with other policies will provide an estimate of the price of anarchy . apart",
    "form that , fcfs is easy to implement , as it does not require any calculations or knowledge of system parameters .",
    "it is also sometimes required by law .",
    "finally it is indeed a policy very commonly used in practice . on the minus side ,",
    "fcfs may waste resources by letting servers serve customers for which they are not efficient , and it may cause long delays to customer types that have a limited number of compatible servers . however , some of these shortcomings can be avoided by redesigning the compatibility graph .",
    "unfortunately , analysis of parallel service systems under fcfs is very hard .",
    "foss and chernova @xcite provide an example of a symmetric system with 3 types of customer and 3 servers , and just 2 service distributions with fixed fast and slow service rates , where stability of the system depends on the entire shape of the service time distributions .",
    "the difficulty is in calculating the matching rates @xmath6 , defined as the long term average fraction of customers of type @xmath5 which are processed by servers of types @xmath4 . given the matching rates , one can calculate the total service capacity of the system , as @xmath19 it is the calculation of the matching rates , how many customers of type @xmath5 are served by servers of type @xmath4 under fcfs - alis , which is intractable , and may depend on the entire shape of the service time distributions . matching rates can be calculated for some types of graphs @xcite , and they can also be calculated for general bipartite graphs when arrivals are poisson , service rates depend only on the servers , and services are exponential @xcite , but not otherwise . however",
    ", matching rates can be calculated for the much simpler and very tractable fcfs infinite bipartite matching model @xcite .",
    "it is our observation that when @xmath11 and @xmath13 are large , the matching rates of the general parallel service system under fcfs - alis are approximately those of the fcfs infinite bipartite matching model , which is the basis for our current paper .",
    "we use our ability to calculate matching rates in order to design parallel service systems operating under fcfs - alis .",
    "we consider parallel service systems operating in efficiency driven mode ( ed ) , quality driven mode ( qd ) , and quality and efficiency driven mode ( qed ) @xcite .",
    "our objective in each of these is to design the workforce required to achieve certain service requirements , specifically :    in ed mode , we specify average waiting times for customers , and resulting abandonment rates .    in qd mode , we specify average idle time for the servers ,    in qed mode we specify almost full utilization , no wait or short wait , and no abandonments .    under fcfs - alis",
    "we achieve these pre - specified requirements with complete resource pooling of servers , and balance service levels for all types of customers .",
    "we also present designs where under fcfs - alis the parallel servers are not pooled , and use this to achieve differentiated service levels for the various types of customers , based on pre - specified priority levels .",
    "the rest of the paper is structured as follows . in section [ sec.infinitematching ]",
    "we describe the fcfs infinite bipartite matching model , and the formula for the calculation of matching rates . in section [ sec.manyserver ]",
    "we present our conjecture on the behavior of fcfs - alis parallel service systems under many server scaling , which ties them up with the infinite bipartite matching model . in section [ sec.algorithm ]",
    "we present our design algorithms , based on the calculation of matching rates . finally , in section [ sec.examples ] we present examples in which we calculate designs , and examine the performance under our designs .",
    "we present extensive simulation results , that confirm the validity of our approach for a range of @xmath11 , @xmath13 scales .",
    "this paper is an expansion , generalization , completion and extension of preliminary studies in @xcite . a recent discussion of many server scaling for the `` n '' system appears in @xcite .",
    "we now consider a system with customer types @xmath20 and server types @xmath21 , with a bipartite compatibility graph @xmath2 , and a much simplified stochastic model : we have infinite sequences of customers @xmath22 where @xmath23 and of servers @xmath24 where @xmath25 .",
    "we assume that @xmath26 are drawn according to probabilities @xmath27 and @xmath28 are drawn according to probabilities @xmath29 , and they are all independent . for each realization of the sequences we match customers and servers according to a fcfs policy :",
    "@xmath28 is matched to the earliest compatible @xmath26 in @xmath30 which has not yet been matched to @xmath31 .",
    "the matching process , for given graph @xmath2 , is illustrated in the figure below .",
    "this model is much simpler than a queueing model , since it involves no arrival times , no service times , no busy or idle servers , and since it treats customers and servers in an entirely symmetric way .",
    "this system is studied in @xcite .",
    "it is shown in @xcite that the matching is uniquely determined for any two sequences and that all customers and servers are matched almost surely .",
    "furthermore , the system demonstrates dynamic reversibility , and is associated with a markov chain that has a product form stationary distribution .",
    "the stationary distribution is used to obtain explicit expressions for the matching rates .",
    "we describe the calculation of the matching rates now .",
    "we use the following notations : we let @xmath32 be the set of customer types compatible with server type @xmath4 , and @xmath33 be the set of server types compatible with customer type @xmath5 . for a subset of customer types",
    "@xmath34 we let @xmath35 , and for a subset of server types @xmath36 we let @xmath37 .",
    "we also let @xmath38 be the customer types that can only be served by servers of types in @xmath36 . for subsets",
    "@xmath39 we define @xmath40 , and @xmath41 .    for given @xmath42",
    "we say that there is complete resource pooling in the fcfs infinite bipartite matching system if the following three equivalent conditions hold : @xmath43    let @xmath44 be the ( random ) number of @xmath45 matches between @xmath46 and @xmath47 , in the fcfs infinite bipartite matching of the two sequences .",
    "if complete resource pooling holds , then almost surely @xmath48 which is calculated by @xmath49 where the summation is over @xmath50 , the set of all permutations of the server types @xmath21 , and for each permutation of the servers @xmath51 , the following notation is used : @xmath52 @xmath53 and @xmath54 is the normalizing constant : @xmath55    an easy example of this formula is for the case that @xmath56 and @xmath57 , i.e the bipartite compatibility graph is almost complete , each server can serve all but one of the customer types . in that case ,",
    "complete resource pooling holds if and only if @xmath58 , and the matching rates are : @xmath59 however , for any other bipartite compatibility graph , this formula does not seem to simplify , and we suspect that its calculation is @xmath60 hard .",
    "we have programmed it to be able to calculate it up to @xmath61 , but it will become hard to compute the matching rates for larger number of types .",
    "further research to obtain perhaps easier approximations to @xmath62 may be necessary .",
    "when resource pooling does not hold , it is shown in @xcite that there is a unique decomposition @xmath63 into subsystems @xmath64 , such that @xmath65    a mathematica program to calculate the matching rates for given @xmath42 is available from the authors .",
    "consider a queueing system with a single customer type and a single server type , with arrival rate @xmath11 , and patience distribution @xmath66 , and with @xmath13 servers , each with service rate @xmath67 , so that the traffic intensity is @xmath68 .",
    "many server scaling occurs when we keep @xmath67 and @xmath69 fixed and let both @xmath11 and @xmath13 increase .",
    "note that , to increase @xmath11 , we scale the inter - arrival time distribution , and thus we do not alter its shape . because of abandonments the system will always be stable",
    ". there will be three behavior modes for this system : when @xmath70 the system is in qd ( _ quality driven mode _ ) . in qd mode",
    ", there is always a fraction @xmath71 of idle servers and customers never wait and nobody abandons . when @xmath72 the system is in ed ( _ efficiency driven mode _ ) . in ed mode , servers are always busy , there is always a queue , and a fraction @xmath73 of customers abandons without service .",
    "customers with patience @xmath74 do not get served , and customers with patience @xmath75 receive service after a wait of @xmath76 . when @xmath77 the system is in qed ( _ quality and efficiency driven mode _ ) . in qed mode , servers are busy most of the time and if they idle that is only for a short while , an appreciable fraction of customers do not need to wait , most customers wait a very short time , and very few customers abandon  @xcite .",
    "we now consider the system of parallel skill based servers of section [ sec.introduction ] .",
    "we fix the fractions @xmath12 , @xmath78 , the service time distributions @xmath15 , and the patience distributions @xmath18 .",
    "we use fcfs - alis policy , and we let @xmath11 and @xmath13 increase at the same rate , so that we get into many server scaling",
    ". we can not directly calculate @xmath69 for this system , as it depends on the service policy , and in particular we can not calculate it directly under fcfs - alis , but we will try and approximate it . under many server scaling",
    "we can expect that for favorable choices of parameters , the system will achieve resource pooling , so that customers of different types will have similar waiting times , and servers of different types will have similar workloads and similar idle times . under such conditions ,",
    "the system will again behave in one of the three modes , qd , ed or qed , according to the traffic intensity .",
    "we now make the following conjectures regarding the behavior of the system under many server scaling , when resource pooling holds : we conjecture that the order in which customers will reach the head of the line ( if they did not abandon previously ) will be such that the types of customers will be i.i.d . with some probabilities @xmath12 , approximately .",
    "also we conjecture that the order in which servers will become available at the head of line ( if there is a queue of idle servers ) , will be such that the types of servers will be i.i.d with some probabilities @xmath79 , approximately . under this conjecture",
    ", the matching between customers and servers will be approximately the same as for the fcfs infinite bipartite matching model .",
    "the following three figures illustrate the operation of our system under fcfs - alis in each of the above mentioned three modes :    in ed mode , all the servers are always busy , customers with enough patience wait a time @xmath80 , and when they reach the head of the queue , they match with the next compatible server .",
    "note that customers entering service are still of i.i.d .",
    "types , approximately , but with new probabilities @xmath12 , since they are thinned independently by impatience .        in qd mode",
    ", there is a queue of idle servers , each server , on completing a service , joins the end of this queue .",
    "a server reaches the head of the queue after an idle time @xmath81 , and matches with the first compatible customer .",
    "customers never wait and are of i.i.d .",
    "types with probabilities @xmath12 .        in qed mode , the system alternates infrequently between periods with a queue of customers and periods with a queue of servers .",
    "all servers are almost always busy , customers immediately enter service or wait a short time , and there are only a few abandonments .",
    "the key assumption necessary for the matching rates to be according to the fcfs infinite bipartite matching model is that approximately the sequence of customers entering service has i.i.d .",
    "types and the sequence of servers that become available and that start service has i.i.d .",
    "when there is no resource pooling , the system decomposes into subsystems as in ( [ eqn.decomposition ] ) .",
    "the following figure shows how such a system will behave under our conjecture . here",
    "the system is decomposed into three sub systems , where @xmath82 receives better service than @xmath83 , which receives better service than @xmath84 .",
    "the three illustrations depict behavior under ed ( top figure ) , qd ( middle figure ) , and in the bottom one , @xmath84 is in ed , @xmath83 is in qed and @xmath82 is in qd . in ed mode ,",
    "customers of types @xmath85 wait the longest time , before being served by servers of types @xmath86 .",
    "servers of types @xmath87 skip customers of type @xmath85 and serve customers of type @xmath88 that have a shorter wait , and servers of types @xmath89 skip customers of type @xmath90 and serve customers of type @xmath91 that have the shortest wait . in qd mode , servers of the high priority customers have longer idle periods , and are available for the high priority customers immediately , while servers of lower priority customers have shorter idle times , and are further in the queue , and their customers will skip the high priority servers in the queue , which are incompatible with them . in the mixed mode ,",
    "low priority customers will wait , while high priority customers will have a queue of idle servers ready to serve them .",
    "we specify the quality of service requirements : for qd this means specifying the utilization of the servers , for ed this means specifying the amount of waiting of patient customers , and for qed this means no abandonment and no idling .",
    "we next specify which fraction of the service should be done by each type of server .",
    "this is a design decision , which will not affect quality of service , but it is relevant for the operational costs .",
    "these determine the @xmath92 and @xmath93 for the matching of customers and servers .",
    "we then use the bipartite infinite matching model , formula ( [ eqn.matches ] ) , to obtain the matching rates @xmath6 .",
    "once we have the matching rates , we can calculate the amount of work required from each type of server , and this determines , by little s law , the number of servers that are needed of each type in order to meet the requested service of quality . in the case of differentiated service ,",
    "we decompose the server and customer types into ed , qed and qd subsets .    in the following sections we show how to perform these steps for each of the three regimes , and for the decomposition .",
    "we illustrate the calculations for the examples of section [ sec.examples ] , and demonstrate the effectiveness of the heuristics through simulation .",
    "note that the inter - arrival time distribution and the service time distributions are not required as input for the algorithm , only the arrival rate and the average service times are required .",
    "the distribution of the abandonment time distribution is needed for design in ed mode .",
    "here the traffic intensity is @xmath94 , and customers almost never wait , and therefore even more rarely abandon .",
    "there are almost always some idle servers waiting for customers , and because of alis , servers of different types all have the same idle time distribution .",
    "the quality parameter in this case is the value @xmath81 of the average idle time .",
    "it is a measure of the utilization of the servers .",
    "because there are virtually no abandonments , the patience time distribution is not required as input .",
    "* input : *    compatibility graph @xmath95    arrival rate @xmath11    fractions of customer types @xmath12    mean service times @xmath16     + * requested quality of service parameter : *    mean server idle time after each service @xmath81     + * design parameters : *    fraction of services performed by each server type @xmath79     + * algorithm * : +   + * output : * +    required workforce @xmath14     +      here the traffic intensity is @xmath96 , servers are always busy and customers always need to wait , and a certain fraction will abandon . by fcfs ,",
    "customers of different types all have the same waiting time distribution , and the system demonstrates global fcfs ( this term was coined by talreja and whitt @xcite ) .",
    "the system is stabilized by abandonments , with average waiting time @xmath80 .",
    "this means that approximately a fraction @xmath97 of customers of type @xmath5 will abandon .",
    "the value of @xmath80 is the quality of service parameter here , so that customers with patience less than @xmath80 do not get served , while customers with patience that exceeds @xmath80 get served after a wait of @xmath80 .",
    "since customers are thinned independently by impatience , we need to calculate the total effective arrival rate ( of patient customers ) and we need to adjust the fractions @xmath12 of customer types entering service .     * input : *    compatibility graph @xmath95    arrival rate @xmath11    fractions of customer types @xmath12    patience distributions @xmath98    mean service times @xmath16     + * requested quality of service parameter : *    mean waiting time @xmath80     + * design parameters : *    fraction of services performed by each server type @xmath79     + * algorithm : * +   + * output : * +    required workforce @xmath14     +      given the arrival rates , there is a unique fcfs system that will supply qed service , with servers almost always busy , most customers either do nt wait or wait a short time , and few abandonments .",
    "the calculation of qed design follows the same steps as for qd with @xmath99 and for ed with @xmath100 .",
    "we now consider the case where we would like to give customers graded service levels , from high priority to standard priority to low priority customer types .",
    "we have a partition of customer types @xmath20 into @xmath101 , where customers of types @xmath102 have higher priority than customer of type in @xmath103 , @xmath104 .",
    "customers in class @xmath105 will then have a set of servers @xmath106 , so that each customer type @xmath102 will have at least one compatible server type @xmath107 . in this decomposition to subsystems @xmath108 , we will allow @xmath107 to serve @xmath109 , but will not allow @xmath107 to serve @xmath110 . in other words ,",
    "we redesign the compatibility graph @xmath95 by eliminating all links from @xmath106 to @xmath111 for @xmath112 , but we preserve the links to higher priority customers in @xmath111 for @xmath113 , since when we use fcfs , these links will hardly ever be used , because servers in @xmath106 will be behind all servers in @xmath114 for @xmath113 almost all the time .",
    "the priorities will be translated into quality of service parameters : classes @xmath115 will be served in ed mode with @xmath116 , classes @xmath117 will be served in qd mode , with @xmath118 .",
    "class @xmath119 may be in qed mode .",
    "* input : *    compatibility graph @xmath95    arrival rate @xmath11    fractions of customer types @xmath12    patience distributions @xmath98    mean service times @xmath16     + * requested quality of service parameters : *    partition of customer types by priority into @xmath101    quality of service parameters : @xmath120     + * design parameters : *    choose partition of server types @xmath121    eliminate links from @xmath106 to @xmath111 , for @xmath112    assign fraction of services performed by each server type @xmath79 , within @xmath106     + * algorithm * : +    for subsystem @xmath108 , @xmath122 :    apply appropriate design algorithm for qd or ed to the subsystem     + * output : * +    redesigned compatibility graph @xmath95    required workforce @xmath14     +",
    "in this section we describe three examples , for each of which we have prepared several designs , under several modes of operation , and assuming poisson arrivals using a range of values for @xmath11 .",
    "we have then performed extensive simulation runs on each of these designs .",
    "our purpose in this section is threefold :    * illustrate the implementation of the algorithms ; * examine the validity of the matching rates conjecture ; * evaluate the efficacy of our designs .",
    "the first example system has 3 customer types and 3 server types with an almost complete bipartite compatibility graph .",
    "we have designed operation of this system with complete resource pooling , in ed , qd and qed mode .",
    "the purpose of this example is to assess pooled service designs .",
    "the second example has 5 customer types and 5 server types with a hamiltonian bipartite compatibility graph .",
    "this example is used to assess differentiated service , with the customer types divided into high , standard and low priority customers .",
    "the third example has 6 customer types and 6 server types with a symmetric compatibility graph that has degree 3 for all nodes .",
    "the purpose of considering this example is to examine validity of the matching conjecture in a complex graph .",
    "the designs depend on the service rates for each link , but not on the actual distributions of service times . to examine the validity of the matching conjecture and to assess the efficacy of the designs , we have chosen to simulate service time distributions which are very different , including uniform in a finite range , exponential and pareto .",
    "our main conclusions from the simulations of these examples are :    * the matching rates conjecture seems to be valid under ed , qd and qed mode , for the whole range of @xmath11 values , and under all the different distributions of service times . for small values of @xmath11",
    "the deviations are slightly larger , but this can be partly explained by the fact that the algorithm yields real numbers for @xmath14 , but in the final design rounded integer values are used . * in ed mode , for large values of @xmath11 we get convergence to the exact values of @xmath80 with very small variability in waiting times , and exact abandonment rates . similarly under qd , for large values of @xmath11 we get convergence to the exact values of @xmath81 with very small variability in idle times , and almost all customers are not waiting for service . *",
    "most important , it seems that for small values of @xmath11 , while waiting times in ed mode and idle times in qd mode are quite variable , the average waiting time in ed and the average idle time in qd are almost exactly as designed .",
    "this indicates that our design heuristic may be effective already for a moderate number of servers . *",
    "convergence in the qed mode is not appreciably worse than in the ed or qd modes . *",
    "the system with differentiated service performs as designed . *",
    "the results do not seem to depend on the service time distributions .",
    "we now present the three examples with detailed simulation results .",
    "the reported simulation results for each design have been obtained as the average of 1,000 runs , where each run consists of 1,250,000 customers .",
    "however , the first 250,000 customers have been removed from the results to account for a possible startup effect .      in this example",
    "we investigate pooled service designs .",
    "the system is specified below , where exp@xmath124 denotes the exponential distribution with rate @xmath125 , u@xmath126 is the uniform distribution on the interval @xmath126 and pareto@xmath127 is the pareto distribution @xmath128 for @xmath129 .",
    "there are 3 types of customers and 3 types of servers .",
    "the total arrival rate is parameterized by @xmath11 , the graph and the values of @xmath130 are described in the following figure :        the patience times and service time distribution are given in the tables below .     & @xmath18 + @xmath131 & exp(0.1 ) + @xmath132 & u(0,10 ) + @xmath133 & exp(0.2 ) +     @xmath15 & @xmath131 & @xmath132 & @xmath133 + @xmath134 & pareto(2 , 3 ) & exp(0.125 ) & + @xmath135 & & exp(0.2 ) & u(2 , 6 ) + @xmath136 & pareto(3 , 3 ) & & u(1 , 5 ) +    only the _",
    "mean _ service times are used by the design algorithms .",
    "the full distributions are used in the simulations .",
    "+    in the designs for example 1 we take as service fractions : @xmath137 , @xmath138 , @xmath139 .",
    "+ * ed design : * we specify the average waiting time @xmath140 , corresponding to approximately 25% of the average service times . for the given patience distributions",
    "this entails abandonment rates of approximately 10% for customers of types 1 and 2 , and of 18% for customers of type 3 .",
    "we calculate the effective arrival rates of customers that do get served after a wait of @xmath140 : @xmath141 so @xmath142 and thus the effective arrival rate equals @xmath143 hence , the adjusted values of @xmath144 are : @xmath145",
    "* qd design : * we take an average idle time of @xmath146 .",
    "this corresponds to an utilization of approximately 0.9 . *",
    "qed design : * the unadjusted values of @xmath147 are used .",
    "+ it is readily verified that in all three regimes ( ed , qd and qed ) , conditions ( [ eqn.crp ] ) are satisfied , so complete resource polling holds . from the algorithms",
    "we obtain the _ calculated required workforce _ for the three designs :    [ cols=\"^,^,^,^,^,^,^,^,^,^ \" , ]",
    "in this paper we considered a parallel queueing system with multiple server types and multiple customer types , their compatibility described by a bipartite graph .",
    "this system has a general renewal arrival process , general customer - server dependent service times and operates under fcfs - alis service policy .",
    "as explained in the introduction , this system is relevant in many areas of applications , though at this level of generality , it is analytically intractable . based on our intuitive understanding of how this system behaves under many server scaling and by exploiting exact results for the matching rates in the related fcfs infinite matching model , we proposed heuristic algorithms to calculate service work force levels required to meet quality of service parameters in three modes of operation : ed , qd and qed .    extensive simulation confirmed that the algorithms are accurate and effective : they produce work force levels and , in case of differentiated service , a redesigned compatibility graph that meet targeted quality of service requirements .",
    "moreover , the heuristic algorithms also appeared to work well when the required work force levels are not so large .",
    "as such , these algorithms provide a valuable tool to support decisions on the design of multi - type service systems .",
    "the results suggest that our intuition , and in particular , the matching rates conjecture are correct .",
    "however , a rigorous justification is lacking at this point , and left as a major challenge for future research . a first step towards a rigorous analysis",
    "can be found in @xcite , treating many server scaling for the exponential `` n '' system .",
    "adan , i. j. b. f. , boon , m.a.a . ,",
    "busic , a. , mairesse , j. , weiss , g. ( 2013 ) queues with skill based parallel servers and a fcfs infinite matching model .",
    "_ performance evaluation review _",
    ", 41(3):2224 , 2013 .",
    "bell , s. l. , williams , r. j. ( 2001 ) .",
    "dynamic scheduling of a system with two parallel servers in heavy traffic with resource pooling : asymptotic optimality of a threshold policy . _ the annals of applied probability _ , 11(3 ) , 608 - 649 .",
    "ghamami , s. , ward , a. r. ( 2013 ) .",
    "dynamic scheduling of a two - server parallel server system with complete resource pooling and reneging in heavy traffic : asymptotic optimality of a two - threshold policy .",
    "_ mathematics of operations research _ , 38(4):761 - 824 .",
    "squillante , m. s. , xia , c. h. , yao , d. d. , zhang , l. ( 2001 ) .",
    "threshold - based priority policies for parallel - server systems with affinity scheduling . in american control conference , 2001 .",
    "proceedings of the 2001 4:2992 - 2999 , ieee ."
  ],
  "abstract_text": [
    "<S> we study a parallel service queueing system with servers of types @xmath0 , customers of types @xmath1 , bipartite compatibility graph @xmath2 , where arc @xmath3 indicates that server type @xmath4 can serve customer type @xmath5 , and service policy of first come first served fcfs , assign longest idle server alis . for a general renewal stream of arriving customers and general service time distributions , </S>",
    "<S> the behavior of such systems is very complicated , in particular the calculation of matching rates @xmath6 , the fraction of services of customers of type @xmath5 by servers of type @xmath4 , is intractable . </S>",
    "<S> we suggest through a heuristic argument that if the number of servers becomes large , the matching rates are well approximated by matching rates calculated from the tractable fcfs bipartite infinite matching model . </S>",
    "<S> we present simulation evidence to support this heuristic argument , and show how this can be used to design systems for given performance requirements . </S>"
  ]
}