{
  "article_text": [
    "consistency techniques are widely used for solving finite domain constraint satisfaction problems ( csp ) @xcite .",
    "these techniques have been integrated in logic programming , resulting in finite domain constraint logic programming ( clp ) @xcite . in this paradigm ,",
    "a program typically creates a data structure holding the variables of the csp to be solved , sets up the constraints and uses a labelling technique to assign values to the variables .",
    "the constraint solver uses consistency techniques to prune the search .",
    "this leads to a rather procedural programming style .",
    "moreover , the problem description is not very declarative because the mapping between domain variables and their value has an indirect representation in a term structure .    in this paper",
    ", we compare clp and three computational paradigms allowing problem solving based on more declarative representations .",
    "a common feature of these approaches is that the relation between the csp variables and their values is encoded as a predicate or function relating identifiers of the csp variables with their value .",
    "e.g. in the graph coloring problem , the predicate relates node numbers with colors .",
    "this representation allows for a more natural declarative representation of the problem .",
    "one approach is specification in first order logic .",
    "as pointed out in @xcite , one can represent a csp as a first order logic theory such that ( part of ) its models correspond to the solutions of the csp .",
    "hence first order model generators such as sem @xcite can be used to solve such problems .",
    "the two other approaches use extensions of logic programming .",
    "recently , a logic programming paradigm based on stable model semantics @xcite has emerged .",
    "niemel @xcite proposes it as a constraint programming paradigm , marek and truszczyski @xcite introduce stable logic programming and lifschitz @xcite proposes answer set programming . as described in @xcite , the methodology of these approaches is to encode a computational problem by a logic program such that its stable models represent the solutions .",
    "a number of efficient systems for computing stable models have been developed .",
    "of these , niemel s smodels  @xcite is considered one of the most performant systems .",
    "abduction @xcite uses a similar predicate representation for the relation between the identifiers of csp variables and their value .",
    "this predicate is declared to be open or abducible . constraining this relation to be a solution",
    ", an abductive system will return models of the abducible which are solutions of the csp .",
    "we use some typical csp problems to compare the merits of the various approaches .",
    "one experiment is in graph coloring .",
    "we have compared the representation and the performance of clp with the three other approaches in a sequence of experiments where the size of the graph increases and the number of colors remains constant .",
    "another experiment is the n - queens problem where both the domain size and the number of constraints increases with increasing problem size .",
    "we also report on experiments using clp , stable logic programming and abduction for solving a complex real world scheduling problem .",
    "for each different system , we have tried to use any special features provided by it .    in section [ sec : kr - csp ] we review in more detail the various approaches and systems , focusing mainly on the knowledge representation aspects .",
    "section [ sec : exp ] reports on the experiments and we conclude in section [ sec : concl ]",
    ".    we are not aware of any previous work which compares this wide range of logic based systems for their suitability in solving csp problems .",
    "mackworth @xcite explores the space of possible csp formalizations but assesses neither the quality from point of view of knowledge representation nor the performance of actual systems .",
    "also , approaches based on stable model semantics and abduction are not included in his work .",
    "this paper is an extension and revision of @xcite which focuses more on the formal relations between the declarative specifications of the problems on the different systems .",
    "one more problem which uses aggregate functions is included in the present paper .",
    "so is an additional experiment for finding all solutions of the n - queens problem .",
    "finally , some comments from the authors of the different systems were taken into account .",
    "a _ constraint satisfaction problem _ ( csp ) is usually defined as a finite set of _ constraint variables _ @xmath0 ( the variables of the csp ) , a finite domain @xmath1 of possible values for each variable @xmath2 , and a finite set of _ constraint relations _ @xmath3 where each @xmath4 is a constraint between a subset of the set @xmath5 of variables .",
    "solution _ is an instantiation of the variables of @xmath5 which satisfies all the constraints in @xmath3 .",
    "constraint logic programming ( clp ) @xcite is an extension of logic programming where some of the predicate and function symbols have a fixed interpretation over some subdomain ( e.g. finite trees or real numbers ) .",
    "special purpose constraint solvers are integrated with a logic programming system for efficient reasoning on these symbols .",
    "this results in a very expressive language which can efficiently solve problems in many domains .",
    "van hentenryck @xcite pioneered the work on finite domain constraint logic programming , clp(fd ) , by introducing domain declarations for the logic variables and integrating consistency techniques as part of the sld proof procedure .",
    "a clp(fd ) system supports standard arithmetic relations ( @xmath6 ) and functions ( @xmath7 ) on the natural numbers .",
    "a typical formulation of the n - queens problem is as follows :    queens(n , l)length(l , n ) , domain(l,1,n ) , constrain_all(l ) , labeling(l ) .",
    "constrain_all ( [ ] ) .",
    "constrain_all([xxs ] ) constrain_between(x , xs,1 ) constrain_all(xs ) .",
    "constrain_between(x,[],n ) .",
    "constrain_between(x,[yys],n ) safe(x , y , n ) , n_1 is n+1 , constrain_between(x , ys , n_1).safe(x_1,x_2,d)x_1x_2 , abs(x_1-x_2)d .    executing the query @xmath8",
    "first creates a list @xmath9 with @xmath10 variables where the @xmath11 variable gives the column position of the queen on row @xmath12 .",
    "then the constraints expressed with the @xmath13 predicate are added by using two nested recursive predicates .",
    "such procedural code for setting up constraints and the encoding of the solution in a large data structure results in a rather procedural style which is typical for the clp approach .",
    "the most elegant solution for the n - queens problem is using many sorted first order logic and first order model generation .",
    "systems like finder and sem @xcite are examples .",
    "one can introduce functions ( with the sorts of their domain and range ) and predicates ( with the sorts of their domains and the sort @xmath14 as range ) .",
    "in addition , functions can be restricted to be injective , bijective ,   this allows to express the n - queens problem very concisely as :    d=\\{1 .. n }   pos : dd(bijection )   abs(pos(x_1)-pos(x_2))x_2-x_1 x_1<x_2 .",
    "the first line declares @xmath15 as a sort with interpretation consisting of the set of integers @xmath16 to @xmath10 .",
    "the following line introduces the function @xmath17 as a bijection from @xmath15 to @xmath15 .",
    "hence , the range of the function is a permutation of its domain .",
    "this function represents the column positions of the queens .",
    "the only remaining constraint is that queens have to be on different diagonals .",
    "this is expressed by the formula on the third line using the predefined functions @xmath18 and @xmath19 . due to symmetry , one need only to verify the constraint for pairs of queens @xmath20 such that @xmath21 .",
    "solutions are given by the interpretation of the @xmath17 function in the models of this theory . in principle , this approach is applicable on any csp problem by representing the csp variables by logical constants .",
    "however , in most cases , csp variables are just an encoding of some attribute of a set of first order objects , such as the position of a queen or the color of a node in a graph . in such cases , there is no need to introduce the csp variable .",
    "the attribute can be represented directly as a function or predicate on these objects ( e.g. @xmath22 ) .",
    "as the domains of all sorts are finite , sem first computes the grounding of the theory and then uses backtracking combined with various inference and simplification rules to guide the search for models @xcite .      in @xcite",
    ", niemel proposes logic programming with the stable model semantics @xcite as a constraint logic programming paradigm .",
    "the underlying idea is to represent a problem as a set of rules , each rule being the declarative expression of a piece of knowledge about the problem domain and such that the stable models of the whole program are constrained to be solutions of the problem .",
    "the smodels  system @xcite is an efficient implementation of the stable model semantics .",
    "it works with propositional rules and a special pre - processing program is used for grounding strongly range restricted logic programs .",
    "the implementation combines bottom - up inference with backtracking search and employs powerful pruning methods .",
    "a recent extension of the system @xcite introduces choice rules :    l \\{l_1 , l_2 , ",
    "l_n } u b.    where @xmath23 are literals .",
    "the semantics of such a rule is that if the body @xmath24 is true then at least @xmath25 and at most @xmath26 literals among @xmath27 should be true in a stable model of the program .",
    "following @xcite and @xcite , the program for the n - queens problems can be formulated as :    d(1 .. n ) .",
    "1 \\{pos(x , y):d(y ) } 1 d(x ) . 1 \\{pos(x , y):d(x ) } 1 d(y ) .",
    "d(x_1 ) , d(y_1 ) , d(x_2 ) , d(y_2 ) , pos(x_1,y_1 ) , pos(x_2,y_2 ) , x_1 < x_2 , x_2 - x_1 = abs(y_1 - y_2 ) .",
    "solutions are given by the @xmath28 atoms in the stable models of the program .",
    "the first line defines that @xmath29 is a domain with elements @xmath30 with @xmath10 the size of the board .",
    "the first choice rule is used to define the solution space of the problem by stating that for each @xmath31 in the domain @xmath32 , there exists exactly one @xmath33 such that @xmath34 is true .",
    "the colon notation denotes an expansion of @xmath34 for every value of @xmath33 .",
    "similarly , the second choice rule expresses that there is exactly one queen on each column .",
    "the last rule defines the final constraint of the problem : no two queens on the same diagonal .",
    "again , the `` @xmath35 '' constraints in these rules eliminate instances which are redundant due to symmetry .",
    "the main difference with the first order logic specification is that the mapping between queens and their position is now represented by a predicate . declaring that this predicate represents a bijective function is succinctly expressed by the two choice rules .      _ abductive logic programming _ @xcite extends the logic programming paradigm with abductive reasoning .",
    "an abductive logic program has three components : ( 1 ) a logic program @xmath36 , ( 2 ) a set of predicates @xmath37 called abducibles or open predicates , and ( 3 ) a set of integrity constraints @xmath38 .",
    "the abducibles are predicates not defined in the program .",
    "the task of an abductive system is to find a set @xmath39 of ground abducible atoms such that the integrity constraints are true in the logic program consisting of @xmath40 ; formally : @xmath41 .",
    "kakas and michael proposed an integration of clp and an abductive logic programming system @xcite .",
    "originally , it was defined only for definite programs and integrity constraints and in @xcite it was extended to deal with negation as failure through abduction in a similar way as in @xcite .",
    "one restriction of aclp is that integrity constraints need to be of the form @xmath42 , where @xmath43 is an abducible .",
    "as we will see , this forces sometimes to reformulate some constraints by an additional recursion .",
    "such restrictions are not present in sldnfac @xcite , a more recent integration of an abductive system with clp that is based on the more general abductive procedure sldnfa @xcite .",
    "the sldnfac system uses id - logic @xcite as specification language which is transformed into an abductive logic program by using a lloyd - topor transformation .",
    "the specification of the n - queens problem is :    d(1 .. n ) .",
    "open_function(pos(d , d ) ) .",
    "y_1y_2 x_2-x_1y_2-y_1x_2-x_1y_1-y_2 pos(x_1,y_1 ) pos(x_2,y_2 ) x_1<x_2 .",
    "the first line of the program defines @xmath29 as a domain predicate with the integers @xmath30 as elements ( defining rows and columns ) .",
    "the next line states that the predicate @xmath44 represents an open function in the defined domain .",
    "it is used to represent the column position of a queen in a row .",
    "finally there is a constraint saying that two queens can not be on the same column and diagonal .",
    "this representation is almost identical to the fol specification of section [ sec : modgen ] .",
    "the main difference is that the open function is represented by a predicate .    as mentioned",
    ", aclp does not allow function declarations .",
    "consequently , the fact that @xmath22 predicate represents a function must be expressed by explicit constraints .",
    "a standard way to axiomatize that the abductive predicate @xmath34 should be true for each @xmath31 in the domain @xmath32 is by using the following rule and integrity constraints :    has_pos(x)d(y),pos(x , y ) .",
    "d(x ) , not  has_pos(x ) .    unfortunately",
    ", the integrity constraint does not satisfy the aclp s restriction that at least one positive abductive atom should occur in it .",
    "hence , these axioms have to be reformulated using a recursive program which generates a position for each queen . the specification for the aclp system",
    "is :    a = \\{pos/2 }   problem(n ) nqueens(n , n ) .",
    "nqueens(0,n ) .",
    "nqueens(x , n)x > 0 ,  y  in  1 .. n ,  pos(x , y ) , x_next  is  x-1 ,  nqueens(x_next , n ) .",
    "attack(x_1,y_1,x_2,y_2 ) y_1 = y_2 .",
    "attack(x_1,y_1,x_2,y_2 ) y_1 + x_1 = y_2 + x_2 .",
    "attack(x_1,y_1,x_2,y_2 ) y_1 - x_1 = y_2 - x_2 .",
    "pos(x_1,y_1 ) ,  pos(x_2,y_2 ) ,  x_1 < x_2 ,  attack(x_1,y_1,x_2,y_2 ) .",
    "the @xmath10-queens problem is solved by solutions of the abductive query @xmath45 .",
    "the aclp representation is in the middle of the declarative fol representation and the more procedural clp representation .",
    "the finite domain clp package is the one provided with @xmath46 version 4.2 .    both abductive systems , aclp @xcite and sldnfac , @xcite are meta interpreters written in prolog , running on @xmath46 version 4.2 and making use of its finite domain library . for all these systems ,",
    "a search strategy which first selects variables with the smallest domain which participate in the largest number of constraints was used .",
    "the model generator sem version 1.7 is a fine tuned package written in c. smodels  version 2.25 , the system for computing stable models , is implemented in c++ and the associated program used for grounding is lparse  version 0.99.54 .",
    "all experiments have been done on the same hardware , namely pentium ii .",
    "our first experiment is done with 4-colorable graphs .",
    "we used a graph generator program which is available from address http://web.cs.ualberta.ca/~joe/coloring/generators/generate.html .",
    "we applied the systems in a sequence of experiments with graphs of increasing size and constant number of colors .",
    "we have modified only one parameter of the problem namely the number of vertices .",
    "figure [ fig : gc ] gives the results of solving the problem with the different systems .",
    "both axes are plotted in a logarithmic scale . on the x - axis",
    "we have put the number of vertices . not surprisingly , clp is the fastest system .",
    "the times for smodels  is second best on this problem .",
    "we assume it is in part because of the very concise formulation . using the so called technique of rules with exceptions @xcite",
    ", the two rules needed to describe the space of candidate solutions also encode the constraint that the color is a function of the vertex .",
    "hence there is only one other rule , namely the constraint that two adjacent vertices must have a different color .",
    "the difference with clp is almost two orders of magnitude for the largest problems .",
    "the times reported for smodels  do not include the time for grounding the problem , these times only consist of a small part of the total time .",
    "grounding the problem for 650 nodes takes only 10 seconds , whereas solving the problem takes over 100 seconds .",
    "sldnfac is slightly worse than smodels .",
    "although meta - interpretation overhead tends to increase with problems size , the difference with smodels  grows very slowly .",
    "the model generator sem deteriorates much faster and runs out of memory for the larger problems .",
    "the fact that it grounds the whole theory is a likely explanation .",
    "the difference with smodels  supports the claim that smodels  has better techniques for grounding .",
    "aclp performs substantially worse than sldnfac and also deteriorates faster .",
    "the difference is likely due to the function - specification available in sldnfac .",
    "contrary to aclp , sldnfac exploits the knowledge that the abducible encodes a function to reduce the number of explicitly stored integrity constraints .",
    "figure [ fig : q ] gives the running times for the different systems for finding a first solution .",
    "both axes are plotted on a linear scale . the time consumed",
    "while grounding is again not included in the graph ( for 18 queens , half a second ) .",
    "again , clp gives the best results .",
    "sldnfac is second best and , although meta - interpretation overhead increases with problem size , deteriorates very slowly .",
    "aclp is third , with a small difference , probably due to the lack of the function - specification mentioned in the section above .",
    "the next one is sem .",
    "it runs out of memory for large problems ( it needs about 120 mb for 27 queens ) .",
    "smodels  performs very poorly on this problem , in particular when compared with its performance on the graph coloring problem .",
    "it is well - known that to obtain good results for computing the first solution for the n - queens problem , a good search heuristic is needed , like the first fail principle used by the systems based on clp .",
    "we believe that the bad performance of smodels  is explained by the absence of appropriate heuristics .",
    "this is confirmed by the much better performance of the system in computing all solutions .",
    "figure [ fig : qall ] gives the running times for finding all solutions .",
    "the y - axis is plotted on a logarithmic scale .",
    "the clp , aclp and sldnfac systems are based on the same finite domain constraint solver , so their convergence is not unexpected . indeed , the abductive system generates a constraint problem which is equivalent to the problem generated by the clp program and no backtracking occurs in the abductive system .",
    "hence , its overhead becomes ignorable .",
    "also the sem system converges to the same performance as clp ( but runs out of memory for big problems ) . in this experiment ,",
    "the smodels  system performs much better but is still the slowest system .",
    "a likely reason for this is that the number of propositional variables in the n - queens problem grows quadratically with the problem size , in contrast with the graph coloring problem where the number of variables grows only linearly ( because of a constant number of colors ) .",
    "consequently , the grounding grows faster for this problem .",
    "the clp consistency techniques seem to be much less sensitive to the domain size , and this carries over to the abductive systems which reduce the problem to a clp problem and then use the clp solver to search for the solution .",
    "a belgian electricity company has a number of power plants divided in geographic areas .",
    "each power plant has a number of power generating units , each of which must receive a given number ( usually 1 or 2 ) of preventive maintenances with a fixed duration in the course of one year .",
    "the computational problem is to schedule these maintenances according to some constraints and optimality criteria .",
    "some of the constraints are : some time slots are prohibited for maintenance for some units ; for each power plant , there is an upper limit on the total number of units in maintenance per week for reasons of availability of personnel ; some of the maintenances are fixed in advance ,  the objective of the problem is to find a schedule that maximizes the minimal weekly reserve , which is the sum of the capacity of all units not in maintenance minus the expected weekly peak load .",
    "this is a rather difficult problem in several aspects .",
    "firstly , the specification uses aggregate expressions like cardinality and sum ( e.g. for each area , there is an upper limit to the total capacity for units in maintenance per week ) .",
    "only clp , smodels  and sldnfac support some form of aggregates and only these systems were used in our experiment .",
    "also , the search space is very large , as there are 56 maintenances to be scheduled in 52 weeks which makes about @xmath47 combinations .",
    "the company provided a set of constraints for which the optimal solution was known to have a minimal week reserve of 2100 ( 100% ) .",
    "the three systems found correct schedules but none was able to find this optimal solution .",
    "this application was first considered in a context of a master s thesis @xcite and then reported in @xcite , where a first attempt was done for integrating the sldnfa proof procedure with the clp system rope @xcite .",
    "this early system needed 24 hours to reduce the problem to a constraint store .",
    "later on , in @xcite several different direct encodings in clp of the problem were presented and compared .",
    "recently , @xcite discussed an extension of the sldnfac system with aggregate functions and this problem was used as a benchmark .",
    "the first version of the smodels  system did not support aggregate expressions .",
    "a more recent version of the system added a limited support for rules with a body consisting of a single cardinality or sum constraint @xcite and allowed us to specify the problem .",
    "however , these aggregate constraints can not be used for computing the sum or the cardinality of a set of atoms and we were not able to express the optimization function . by setting increasing lower bounds on the reserve capacity",
    ", branch and bound can be simulated manually .",
    "it should be noted that , because of the very large size of the problem , the specification of the problem in the smodels  system had to be redesigned with special care in order to produce a ground program not exceeding the limits of the system .",
    "table [ tab : tract ] summarizes the results of executing the problem with the different systems .",
    "the first row `` setup '' gives the time used for pre - processing the problem specification .",
    "for the abductive systems , this is the time for reducing the high - level specification to a set of constraints . for the smodels  system",
    "this is the time for grounding the program .",
    "the rest of the rows give the times used by the constraint solver to find a solution with the given quality .",
    "the results for clp are taken from @xcite for a standard encoding of the problem . ] and the program was run under sicstus prolog .",
    "setup & & 45 & 36.4 + 1900 & & 63.2 & 8.07 + 2000 & 7.71 & 62.9 & @xmath488h + 2010 & 25.85 & 63.8 & + 2020 & 43.73 & 62.9 & + 2030 & 57.28 & 63.0 & + 2040 & 71.63 & 261.1 & + 2050 & 26843.50 & 871.3 & +    in the case of sldnfac , it can be seen in table [ tab : tract ] that substantial progress was made . rather than the 24h needed in the earlier version @xcite",
    ", the current sldnfac procedure only needs 45 seconds for reducing the problem and about 15 minutes for finding a solution of level 2050 ( 97.6% ) .",
    "a solution with reserve capacity of 2030 ( 96.5% ) was found in less than two minutes .",
    "note that the timings for a solution with a reserve capacity of 1900 up to 2030 are similar .",
    "this is explained by the fact that in the five cases the same solution with reserve capacity of 2030 was computed .",
    "the small differences in timings are due to noise in the measurements .",
    "strange enough , clp deteriorates when it reaches a solution for a reserve capacity of 2050 whereas the sldnfac solution does not .",
    "this must be due to the fact that the constraint store built by the clp solution differs from the one built by the sldnfac solution .",
    "this is accidental : in general , constraint stores constructed by a hand made clp program are more efficient than the ones computed by sldnfac .",
    "the smodels  system needed 40 seconds for grounding and the best solution we were able to find was 1900 ( 90.5% ) in 8 seconds .",
    "we did not find better solutions in reasonable time .",
    "finite domain clp is widely accepted as an excellent tool for csp solving .",
    "however clp programs have drawbacks from the point of view of knowledge representation . as explained in section [ sec : clp ] , the variables of the csp have to be organized in a data structure and `` procedural '' code is required to create this data structure and to set up the constraints .",
    "this level of indirection increases the conceptual distance between the program and the problem and makes programs less declarative .",
    "recently , several attempts have been made to introduce formalisms allowing more declarative formalizations .",
    "they are based on stable model semantics @xcite and on abduction @xcite .",
    "although these systems have an expressivity beyond what is needed to describe a csp ( they address non - monotonic reasoning while csp solving requires only negation of primitive constraints ) , it is worthwhile to compare these systems with clp which is state of the art for csp solving . because both stable models and abduction express solutions to problems as models of their theory ,",
    "we have also included first order model generators in our study @xcite .",
    "as argued in section [ sec : kr - csp ] , these three approaches are better than clp from knowledge representation point of view , the formalizations are more natural , more readable , conceptually closer to the problem , in short they are more declarative than clp programs .",
    "which one of the three discussed mechanisms is the most declarative is likely a matter of taste and familiarity .",
    "inevitably there is a price to be paid for these higher level descriptions .",
    "none of the `` declarative '' systems experimented with comes close to the performance level of clp .",
    "this result holds although the clp system is not favored by the problem choice",
    ". indeed , in both graph coloring and n - queens problem , all constraints are disequality constraints which are known to give little propagation .",
    "our experiments show that first order model generators do not scale well and run out of memory for large problem instances even though the size of the ground program is smaller compared to smodels .",
    "we think that this is not an inherent limitation of the approach but rather that such systems were written with the goal of fast performance and this is visible in our experiemnts .",
    "in contrast , smodels  runs in linear space wrt the size of the grounding @xcite and was able to solve all problem sizes .",
    "of the two abductive systems , sldnfac supports a substantially richer formalism and is performing slightly better than aclp .",
    "as the two systems follow more or less the same strategy of top - down reduction of integrity constraints and of forwarding the reduced ones to the clp solver and as both are implemented as a prolog meta - interpreter , the difference seems to be mainly due to the support of function specifications .",
    "the fact that the sldnfac meta - interpreter outperforms sem ( a fine tuned c implementation ) on both problems and compares very well with the c++ implementation of smodels  ( it is much better on the n - queens problem while it reaches almost the same performance on the graph coloring problem ) suggest that its overall strategy is the best one of the three systems for csp solving .",
    "also the experiments with the large scheduling problem suggest this : the setup time is acceptable and differences in search time seem to be due to differences in the order of traversing the search space .",
    "while the difference with clp is substantial , a low level implementation or compilation should be able to come close to the performance levels of clp , offering the best of both worlds : declarative problem formulations and efficient execution",
    ". however , sldnfa , the procedure underlying sldnfac , is complex , hence building a direct implementation is a hard task .",
    "we believe the development of such a system is a worthwhile topic for future research .",
    "nikolay pelov , emmanuel de mot and marc denecker are supported by the goa project lp+ .",
    "we want to thank maurice bruynooghe for his contribution on the topic and anonymous referees for their useful comments .",
    "m.  denecker .",
    "extending classical logic with inductive definitions . in j.",
    "lloyd et  al . ,",
    "editors , _ first international conference on computational logic _ , volume 1861 of _ lecture notes in artificial intelligence _ , pages 703717 , london , u.k .",
    ", july 2000 .",
    "springer .",
    "m.  denecker and b.  van  nuffelen .",
    "experiments for integration clp and abduction . in k.",
    "apt , a.  kakas , e.  monfroy , and f.  rossi , editors , _ proceedings of the 1999 ercim / compulog workshop on constraints _ , paphos , cyprus , oct .",
    "university of cyprus .",
    "m.  denecker , h.  vandecasteele , d.  de  schreye , g.  seghers , and t.  bayens .",
    "scheduling by `` abductive execution '' of a classical logic specification . in",
    "_ ercim / compulog workshop on constraints _ , schloss hagenberg , austria , oct.2728 1997 .",
    "k.  eshghi and r.  kowalski .",
    "abduction compared with negation by failure . in g.",
    "levi and m.  martelli , editors , _ proceedings of the sixth international conference on logic programming _ , pages 234254 .",
    "lisbon , portugal , mit press , june 1989 .",
    "m.  gelfond and v.  lifschitz .",
    "the stable model semantics for logic programming . in r.",
    "a. kowalski and k.  a. bowen , editors , _ logic programming , proceedings of the fifth international conference and symposium _ , pages 10701080 , seattle , washington , aug .",
    "1988 . mit press .",
    "a.  c. kakas and a.  michael .",
    "integrating abductive and constraint logic programming . in l.",
    "sterling , editor , _ proceedings of the 12th international conference on logic programming _ , pages 399413 .",
    "tokyo , japan , mit press , 1995 .",
    "v.  w. marek and m.  truszczyski .",
    "stable models and an alternative logic programming paradigm . in k.  r.",
    "apt , v.  w. marek , m.  truszczyski , and d.  s. warren , editors , _ the logic programming paradigm : a 25-year perespective _ , pages 375398 .",
    "springer , 1999 .",
    "i.  niemel and p.  simons .",
    "efficient implementation of the well - founded and stable model semantics . in m.",
    "maher , editor , _ logic programming , proceedings of the 1996 joint international conference and syposium _",
    ", pages 289303 , bonn , germany , sept . 1996 . mit press .",
    "i.  niemel , p.  simons , and t.  soininen .",
    "stable model semantics of weight constraint rules . in m.",
    "gelfond , n.  leone , and g.  pfeifer , editors , _ proceedings of the fifth international conference on logic programming and nonmonotonic reasoning _ , volume 1730 of _ lecture nortes in computer science _ , pages 317331 , el paso , texas , usa , dec .",
    "springer - verlag .",
    "n.  pelov , e.  de  mot , and m.  bruynooghe . a comparison of logic programming approaches for representation and solving of constraint satisfaction problems . in m.",
    "denecker , a.  kakas , and f.  toni , editors , _ 8th international workshop on non - monotonic reasoning , special session on abduction _ , breckenridge , colorado , usa , apr . 2000 .",
    "b.  van  nuffelen and m.  denecker .",
    "problem solving in id - logic with aggregates . in a.",
    "k. mark  denecker , editor , _ eight international workshop on nonmonotonic reasoning , special track on abductive reasoning _ , breckenridge , colorado , usa , 2000 .",
    "workshop associated with kr2000 .",
    "h.  vandecasteele and d.  de  schreye . implementing a finite - domain clp - language on top of prolog : a transformational approach . in f.",
    "pfenning , editor , _ proceedings of logic programming and automated reasoning _ ,",
    "volume 822 of _ lecture notes in artificial intelligence _ , pages 8498 , kiev , ukraine , 1994 .",
    "springer - verlag .",
    "j.  zhang and h.  zhang .",
    "constraint propagation in model generation . in u.",
    "montanari and f.  rossi , editors , _ proc . of 1st international conference on principles and practice of constraint programming _ , volume 976 of _ lecture notes in computer science _",
    ", pages 398414 , france , sept . 1995 ."
  ],
  "abstract_text": [
    "<S> many logic programming based approaches can be used to describe and solve combinatorial search problems . on the one hand </S>",
    "<S> there is constraint logic programming which computes a solution as an answer substitution to a query containing the variables of the constraint satisfaction problem . </S>",
    "<S> on the other hand there are systems based on stable model semantics , abductive systems , and first order logic model generators which compute solutions as models of some theory . </S>",
    "<S> this paper compares these different approaches from the point of view of knowledge representation ( how declarative are the programs ) and from the point of view of performance ( how good are they at solving typical problems ) . </S>"
  ]
}