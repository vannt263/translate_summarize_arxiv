{
  "article_text": [
    "much prior work on resource allocation in cognitive radio networks has focused on the _ dynamic spectrum access _ model @xcite in which the secondary users seek transmission opportunities for their packets on vacant primary channels in frequency , time , or space . under this model ,",
    "the primary users are assumed to be oblivious of the presence of the secondary users and transmit whenever they have data to send .",
    "secondly , a collision model is assumed for the physical layer in which if a secondary user transmits on a busy primary channel , then there is a collision and both packets are lost .",
    "we considered a similar model in our prior work @xcite where the objective was to design an opportunistic scheduling policy for the secondary users that maximizes their throughput utility while providing tight reliability guarantees on the maximum number of collisions suffered by a primary user over _ any _ given time interval .",
    "we note that this formulation does not consider the possibility of any cooperation between the primary and secondary users .",
    "further , it assumes that the secondary user activity does not affect the primary user channel occupancy process .",
    "there is a growing body of work that investigates alternate models for the interaction between the primary and secondary users in a cognitive radio network . in particular ,",
    "the idea of cooperation at the physical layer has been considered from an information - theoretic perspective in many works ( see @xcite and the references therein ) .",
    "these are motivated by the work on the classical interference and relay channels @xcite . the main idea in these works",
    "is that the resources of the secondary user can be utilized to improve the performance of the primary transmissions . in return , the secondary user can obtain more transmission opportunities for its own data when the primary channel is idle .",
    "these works mainly treat the problem from a physical layer / information - theoretic perspective and do not consider upper layer issues such as queueing dynamics , higher priority for primary user , etc .",
    "recent work that addresses some of these issues includes @xcite .",
    "specifically , @xcite considers the scenario where the secondary user acts as a relay for those packets of the primary user that it receives successfully but which are not received by the primary destination .",
    "it derives the stable throughput of the secondary user under this model .",
    "@xcite use a stackelberg game framework to study spectrum leasing strategies in _ cooperative cognitive radio networks _ where the primary users lease a portion of their licensed spectrum to secondary users in return for cooperative relaying .",
    "@xcite study and compare different physical layer strategies for relaying in such cognitive cooperative systems .",
    "an important consequence of this interaction between the primary and secondary users is that the secondary user activity can now potentially influence the primary user channel occupancy process .",
    "however , there has been little work in studying this scenario .",
    "exceptions include the work in @xcite that considers a two - user setting where collisions caused by the opportunistic transmissions of the secondary user result in retransmissions by the primary user .    in this paper , we study the problem of opportunistic cooperation in cognitive networks from a _ network utility maximization _ perspective , specifically taking into account the above mentioned higher - layer aspects . to motivate the problem and illustrate the design issues involved , we first consider a simple network consisting of one primary and one secondary user and their respective access points in sec .",
    "[ section : femto_basic ] . this can model a practical scenario of recent interest , namely a cognitive femtocell @xcite , as discussed in sec .",
    "[ section : femto_basic ] .",
    "we assume that the secondary user can cooperatively transmit with the primary user to increase its transmission success probability . in return , the secondary user can get more opportunities for transmitting its own data when the primary user is idle .",
    "we formulate the problem of maximizing the secondary user throughput subject to time average power constraints in sec .",
    "[ section : femto_objective ] .",
    "unlike most of the prior work on resource allocation in cognitive radio networks , the evolution of the system state for this problem depends on the control actions taken by the secondary user .",
    "here , the system state refers to the channel occupancy state of the primary user . because of this dependence",
    ", this problem becomes a constrained markov decision problem ( mdp ) and the greedy `` drift - plus - penalty '' minimization technique of lyapunov optimization @xcite that we used in @xcite is no longer optimal .",
    "such problems are typically tackled using markov decision theory and dynamic programming @xcite .",
    "for example , @xcite uses these tools to derive structural results on optimal channel access strategies in a similar two - user setting where collisions caused by the opportunistic transmissions of the secondary user cause the primary user to retransmit its packets .",
    "however , this approach requires either extensive knowledge of the dynamics of the underlying network state ( such as state transition probabilities ) or learning based approaches that suffer from large convergence times .    instead , in sec .",
    "[ section : solution ] , we use the recently developed framework of maximizing the _ ratio _ of the expected total reward over the expected length of a renewal frame @xcite to design a control algorithm .",
    "this framework extends the classical lyapunov optimization method @xcite to tackle a more general class of mdp problems where the system evolves over renewals and where the length of a renewal frame can be affected by the control decisions during that period .",
    "the resulting solution has the following structure : rather than minimizing a `` drift - plus - penalty '' term every slot , it minimizes a `` drift - plus - penalty ratio '' over each renewal frame .",
    "this can be achieved by solving a sequence of unconstrained _ stochastic shortest path _ ( ssp )",
    "problems and implementing the solution over every renewal frame .",
    "while solving such ssp problems can be simpler than the original constrained mdp , it may still require knowledge of the dynamics of the underlying network state .",
    "learning based techniques for solving such problems by sampling from the past observations have been considered in @xcite .",
    "however , these may suffer from large convergence times .",
    "remarkably , in sec . [ section : solving ] , we show that for our problem , the `` drift - plus - penalty ratio '' method results in an online control algorithm that _ does not require any knowledge of the network dynamics or explicit learning _ , yet is optimal . in this respect , it is similar to the traditional greedy `` drift - plus - penalty '' minimizing algorithms of @xcite .",
    "we then extend the basic model to incorporate multiple secondary users as well as time - varying channels in sec .",
    "[ section : femto_extensions ] . finally , we present simulation results in sec .",
    "[ section : femto_sim ] .",
    "we consider a network with one primary user ( pu ) , one secondary user ( su ) and their respective base stations ( bs ) .",
    "the primary user is the licensed owner of the channel while the secondary user tries to send its own data opportunistically when the channel is not being used by the primary user .",
    "this model can capture a femtocell scenario where the primary user is a legacy mobile user that communicates with the macro base station over licensed spectrum ( fig .",
    "[ fig : femto ] ) .",
    "the secondary user is the femtocell user that does not have any licensed spectrum of its own and tries to send data opportunistically to the femtocell base station over any vacant licensed spectrum .",
    "similar models of _ cooperative cognitive radio networks _ have been considered in @xcite .",
    "this can also model a single server queueing system with two classes of arrivals where one class has a strictly higher priority over the other class .",
    "we consider a time - slotted model .",
    "we assume that the system operates over a frame - based structure .",
    "specifically , the timeline can be divided into successive non - overlapping frames of duration @xmath0 $ ] slots where @xmath1 represents the frame number ( see fig . [",
    "fig : renewal ] ) .",
    "the start time of frame @xmath2 is denoted by @xmath3 with @xmath4 .",
    "the length of frame @xmath2 is given by @xmath0 { \\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}t_{k+1 } - t_k$ ] .",
    "for each @xmath2 , the frame length @xmath0 $ ] is a random function of the control decisions taken during that frame .",
    "each frame can be further divided into two periods : pu idle and pu busy .",
    "the `` pu idle '' period corresponds to the slots when the primary user does not have any packet to send to its base station and is idle .",
    "the `` pu busy '' period corresponds to the slots when the primary user is transmitting its packets to its base station over the licensed spectrum . as shown in fig .",
    "[ fig : renewal ] , every frame starts with the `` pu idle '' period which is followed by the `` pu busy '' period and ends when the primary user becomes idle again . in the basic model , we assume that the primary user receives new packets every slot according to an i.i.d .",
    "bernoulli arrival process @xmath5 with rate @xmath6 packets / slot .",
    "this means that the length of the `` pu idle '' period of any frame is a geometric random variable with parameter @xmath6 .",
    "however , the length of the `` pu busy '' period depends on the secondary user control decisions as discussed below .    in any slot @xmath7 ,",
    "if the primary user has a non - zero queue backlog , it transmits one packet to its base station .",
    "we assume that the transmission of each packet takes one slot .",
    "if the transmission is successful , the packet is removed from the primary user queue .",
    "however , if the transmission fails , the packet is retained in the queue for future retransmissions .",
    "the secondary user can not transmit its packets when the channel is being used by the primary user .",
    "it can transmit its packets only during the `` pu idle '' period of the frame and must stop its transmission whenever the primary user becomes active again .",
    "however , the secondary user can transmit cooperatively with the primary user in the `` pu busy '' period to increase its transmission success probability .",
    "this has the effect of decreasing the expected length of the `` pu busy '' period . in order to cooperate , the secondary user must allocate its power resources to help relay the primary user packet .",
    "this cooperation can take place in several ways depending on the cooperative protocol being used ( see @xcite for some examples ) . in this simple model , these details",
    "are captured by the resulting probability of successful transmission .",
    "the reason why the secondary user may want to cooperate is because this can potentially increase the number of time slots in the future in which the primary user does not have any data to send as compared to a non - cooperative strategy .",
    "this can create more opportunities for the secondary user to transmit its own packets .",
    "however , note that the trivial strategy of cooperating whenever possible may lead to a scenario where the secondary user does not have enough power for its own data transmission .",
    "thus , the secondary user needs to decide whether it should cooperate or not considering these two opposing factors .",
    "the probability of a successful primary transmission depends on the control actions such as power allocation and cooperative transmission decisions by the secondary user .",
    "this is discussed in detail in the next section . in this model",
    ", we assume that the network controller can not control the primary user actions . however , it can control the secondary user decisions on cooperation and the associated power allocation .",
    "let @xmath8 represent the primary and secondary user queues respectively in slot @xmath7 .",
    "new packets arrive at the secondary user according to an i.i.d .",
    "process @xmath9 of rate @xmath10 packets / slot respectively .",
    "we assume that there exists a finite constant @xmath11 such that @xmath12 for all @xmath7 .",
    "every slot , an admission control decision determines @xmath13 , the number of new packets to admit into the secondary user queue .",
    "further , every slot , depending on whether the primary user is busy or idle , resource allocation decisions are made as follows .",
    "when @xmath14 , this represents the secondary user decision on cooperative transmission and the corresponding power allocation @xmath15 .",
    "when @xmath16 , this corresponds to the secondary user decision on its own transmission and the corresponding power allocation @xmath15 .",
    "we assume that in each slot , the secondary user can choose its power allocation @xmath15 from a set @xmath17 of possible options .",
    "further , this power allocation is subject to a long - term average power constraint @xmath18 and an instantaneous peak power constraint @xmath19 .",
    "for example , @xmath17 may contain only two options @xmath20 which represents `` remain idle '' and `` cooperate / transmit at full power '' . as another example ,",
    "@xmath21 $ ] such that @xmath15 can take any value between @xmath22 and @xmath19 .",
    "suppose the primary user is active in slot @xmath7 and the secondary user allocates power @xmath23 for cooperative transmission .",
    "then the random success / failure outcome of the primary transmission is given by an indicator variable @xmath24 and the success probability is given by @xmath25 .",
    "the function @xmath26 is known to the network controller and is assumed to be non - decreasing in @xmath27 .",
    "however , the value of the random outcome @xmath24 may not be known beforehand .",
    "note that setting @xmath28 corresponds to a non - cooperative transmission and the success probability for this case becomes @xmath29 and we denote this by @xmath30 .",
    "likewise , we denote @xmath31 by @xmath32 .",
    "thus , @xmath33 for all @xmath34 .",
    "we assume that @xmath6 is such that it can be supported even when the secondary user never cooperates , i.e. , @xmath35 .",
    "this means that the primary user queue is stable even if there is no cooperation .",
    "further , for all @xmath2 , the frame length @xmath0 \\geq 1 $ ] and there exist finite constants @xmath36 such that under all control policies , we have : @xmath37\\right\\ } } \\leq t_{max } \\end{aligned}\\ ] ] specifically , @xmath38 can be chosen to be the expected frame length when the secondary user always cooperates with full power while @xmath39 can be chosen to be the expected frame length when the secondary user never cooperates . using little s theorem",
    ", we have that : @xmath40 similarly , we have : @xmath41 using these , we have : @xmath42 finally , there exists a finite constant @xmath43 such that the expectation of the second moment of a frame size , @xmath44\\right\\}}$ ] , satisfies the following for all @xmath2 , regardless of the policy : @xmath45\\right\\ } } \\leq d \\label{eq : second_moment}\\end{aligned}\\ ] ] this follows from the assumption that the primary user queue is stable even if there is no cooperation . in appendix c ,",
    "we exactly compute such a @xmath43 that satisfies ( [ eq : second_moment ] ) .    when the primary user is idle in slot @xmath7 and the secondary user allocates power @xmath23 for its own transmission , it gets a service rate given by @xmath46 .",
    "this can represent the success probability of a secondary transmission with a bernoulli service process .",
    "this can also be used to model more general service processes .",
    "we assume that there exists a finite constant @xmath47 such that @xmath48 for all @xmath49 .",
    "given these control decisions , the primary and secondary user queues evolve as follows : @xmath50 + a_{pu}(t ) \\label{eq : ch4_queues1 } \\\\",
    "q_{su}(t+1 ) = \\max[q_{su}(t ) - \\mu_{su}(p(t ) ) , 0 ] + r_{su}(t ) \\label{eq : ch4_queues2}\\end{aligned}\\ ] ] where @xmath51 .",
    "consider any control algorithm that makes admission control decision @xmath13 and power allocation @xmath23 every slot subject to the constraints described in sec .",
    "[ section : femto_decisions ] .",
    "note that if the primary queue backlog @xmath14 , then this power is used for cooperative transmission with the primary user .",
    "if @xmath16 , then this power is used for the secondary user s own transmission . define the following time - averages under this algorithm : @xmath52 where the expectations above are with respect to the potential randomness of the control algorithm .",
    "assuming for the time being that these limits exist , our goal is to design a joint admission control and power allocation policy that maximizes the throughput of the secondary user subject to its average and peak power constraints and the scheduling constraints imposed by the basic model .",
    "formally , this can be stated as a stochastic optimization problem as follows : @xmath53 it will be useful to define the primary queue backlog @xmath54 as the `` state '' for this control problem .",
    "this is because the state of this queue ( being zero or nonzero ) affects the control options as described before .",
    "note that the control decisions on cooperation affect the dynamics of this queue .",
    "therefore , problem ( [ eq : cmdp ] ) is an instance of a constrained markov decision problem @xcite .",
    "it is well known that in order to obtain an optimal control policy , it is sufficient to consider only the class of stationary , randomized policies that take control actions only as a function of the current system state ( and independent of past history ) .",
    "a general control policy in this class is characterized by a stationary probability distribution over the control action set for each system state .",
    "let @xmath55 denote the optimal value of the objective in ( [ eq : cmdp ] ) .",
    "then using standard results on constrained markov decision problems @xcite , we have the following :    ( optimal stationary , randomized policy ) : there exists a stationary , randomized policy _ stat _ that takes control decisions @xmath56 every slot purely as a ( possibly randomized ) function of the current state @xmath54 while satisfying the constraints @xmath57 for all @xmath7 and provides the following guarantees : @xmath58 where @xmath59 denote the time - averages under this policy . [ lem : femto_one ]    we note that the conventional techniques to solve ( [ eq : cmdp ] ) that are based on dynamic programming @xcite require either extensive knowledge of the system dynamics or learning based approaches that suffer from large convergence times .",
    "motivated by the recently developed extension to the technique of lyapunov optimization in @xcite , we take an different approach to this problem in the next section .",
    "recall that the start of the @xmath60 frame , @xmath3 , is defined as the first slot when the primary user becomes idle after the `` pu busy '' period of the @xmath61 frame .",
    "let @xmath62 denote the secondary user queue backlog at time @xmath3 .",
    "also let @xmath23 be the power expenditure incurred by the secondary user in slot @xmath7 . for notational convenience , in the following we will denote @xmath46 by @xmath63 noting the dependence on @xmath23 is implicit .",
    "then the queueing dynamics of @xmath62 satisfies the following : @xmath64 \\nonumber\\\\ & \\qquad + \\sum_{t = t_k}^{t_{k+1}-1 } r_{su}(t )   \\label{eq : u_su}\\end{aligned}\\ ] ] where @xmath13 denotes the number of new packets admitted in slot @xmath7 and @xmath65 denotes the start of the @xmath66 frame .",
    "the above expression has an inequality because it may be possible to serve the packets admitted in the @xmath60 frame during that frame itself .    in order to meet the time average power constraint",
    ", we make use of a virtual power queue @xmath67 @xcite which evolves over frames as follows : @xmath68 p_{avg } + \\sum_{t = t_k}^{t_{k+1}-1 } p(t ) , 0 ] \\label{eq : x_su}\\end{aligned}\\ ] ] where @xmath0 = t_{k+1 } - t_k$ ] is the length of the @xmath60 frame .",
    "recall that @xmath0 $ ] is a ( random ) function of the control decisions taken during the @xmath60 frame .    in order to construct an optimal dynamic control policy",
    ", we use the technique of @xcite where a ratio of `` drift - plus - penalty '' is maximized over every frame .",
    "specifically , let @xmath69 denote the queueing state of the system at the start of the @xmath60 frame . as a measure of the congestion in the system",
    ", we use a lyapunov function @xmath70 $ ] . define the drift @xmath71 as the conditional expected change in @xmath72 over the frame @xmath2 : @xmath73 then , using ( [ eq : u_su ] ) and ( [ eq : x_su ] )",
    ", we can bound @xmath71 as follows : @xmath74 | \\boldsymbol{q}(t_k)\\right\\ } } \\nonumber\\\\ & \\qquad - x_{su}(t_k ) { \\mathbb{e}\\left\\{t[k ] p_{avg } - \\sum_{t = t_k}^{t_{k+1}-1 } p(t ) | \\boldsymbol{q}(t_k)\\right\\ } } \\label{eq : femto_drift1}\\end{aligned}\\ ] ] where @xmath75 is a finite constant that satisfies the following for all @xmath2 and @xmath76 under any control algorithm : @xmath77 p_{avg } \\big)^2| \\boldsymbol{q}(t_k ) \\bigg\\ }    \\end{aligned}\\ ] ] using the fact that @xmath78 for all @xmath7 , and using the fact ( [ eq : second_moment ] ) , it follows that choosing @xmath75 as follows satisfies the above : @xmath79}{2 }   \\label{eq : femto_b}\\end{aligned}\\ ] ]    adding a penalty term @xmath80 ( where @xmath81 is a control parameter that affects a utility - delay trade - off as shown in theorem [ thm : femto_performance ] ) to both sides and rearranging yields : @xmath82 p_{avg } | \\boldsymbol{q}(t_k)\\right\\ } } \\nonumber\\\\    & - { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{t_{k+1}-1 } \\big(q_{su}(t_k ) \\mu_{su}(t ) - x_{su}(t_k ) p(t ) \\big ) | \\boldsymbol{q}(t_k)\\right\\ } }   \\label{eq : femto_drift2}\\end{aligned}\\ ] ]    minimizing the ratio of an upper bound on the right hand side of the above expression and the expected frame length over all control options leads to the following _ frame - based - drift - plus - penalty - algorithm_. in each frame @xmath1 , do the following :    1 .",
    "_ admission control _ : for all @xmath83 , choose @xmath13 as follows : @xmath84 2 .",
    "_ resource allocation _ : choose a policy that maximizes the following ratio : @xmath85 | \\boldsymbol{q}(t_k)\\right\\ } } } \\label{eq : femto_resource_alloc}\\end{aligned}\\ ] ] + specifically , every slot @xmath7 of the frame , the policy observes the queue values @xmath62 and @xmath67 at the beginning of the frame and selects a secondary user power @xmath23 subject to the constraint @xmath34 and the constraint on transmitting own data vs. cooperation depending on whether slot @xmath7 is in the `` pu idle '' or `` pu busy '' period of the frame .",
    "this is done in such a way that the above frame - based ratio of expectations is maximized . ",
    "recall that the frame size @xmath0 $ ] is influenced by the policy through the success probabilities that are determined by secondary user power selections .",
    "further recall that these success probabilities are different during the `` pu idle '' and `` pu busy '' periods of the frame .",
    "an explicit policy that maximizes this expectation is given in the next section .",
    "_ queue update _ : after implementing this policy , update the queues as in ( [ eq : ch4_queues2 ] ) and ( [ eq : x_su ] ) .    from the above , it can be seen that the admission control part ( [ eq : femto_adm_ctrl ] ) is a simple threshold - based decision that does not require any knowledge of the arrival rates @xmath10 or @xmath6 . in the next section , we present an explicit solution to the maximizing policy for the resource allocation in ( [ eq : femto_resource_alloc ] ) and show that , remarkably , it also does not require knowledge of @xmath10 or @xmath6 and can be computed easily .",
    "we will then analyze the performance of the _ frame - based - drift - plus - penalty - algorithm _ in sec .",
    "[ section : femto_analysis ] .",
    "the policy that maximizes ( [ eq : femto_resource_alloc ] ) uses only two numbers that we call @xmath86 and @xmath87 , defined as follows .",
    "@xmath86 is given by the solution to the following optimization problem : @xmath88 let @xmath89 denote the value of the objective of ( [ eq : p_0_define ] ) under the optimal solution .",
    "then , @xmath87 is given by the solution to the following optimization problem : @xmath90 note that both ( [ eq : p_0_define ] ) and ( [ eq : p_1_define ] ) are simple optimization problems in a single variable and can be solved efficiently . given @xmath86 and @xmath87 , on every slot @xmath7 of frame @xmath2 , the policy that maximizes ( [ eq : femto_resource_alloc ] ) chooses power @xmath23 as follows : @xmath91    that is , the secondary user uses the constant power @xmath86 for its own transmission during the `` pu idle''period of the frame , and uses constant power @xmath87 for cooperative transmission during all slots of the `` pu busy''period of the frame . note that @xmath86 and @xmath87 can be computed easily based on the weights @xmath92 associated with frame @xmath2 , and do not require knowledge of the arrival rates @xmath93 .    our proof that the above decisions maximize ( [ eq : femto_resource_alloc ] ) has the following parts :",
    "first , we show that the decisions that maximize the ratio of expectations in ( [ eq : femto_resource_alloc ] ) are the same as the optimal decisions in an equivalent infinite horizon markov decision problem ( mdp ) .",
    "next , we show that the solution to the infinite horizon mdp uses fixed power @xmath94 for each queue state @xmath95 ( for @xmath96 ) .",
    "then , we show that @xmath94 are the same for all @xmath97 .",
    "finally , we show that the optimal powers @xmath86 and @xmath87 are given as above . the detailed proof is given in the next section .",
    "recall that the _ frame - based - drift - plus - penalty - algorithm _ chooses a policy that maximizes the following ratio over every frame @xmath1 @xmath98 | \\boldsymbol{q}(t_k)\\right\\ } } } \\label{eq : resource_alloc1}\\end{aligned}\\ ] ] subject to the constraints described in sec .",
    "[ section : femto_basic ] .",
    "here we examine how to solve ( [ eq : resource_alloc1 ] ) in detail .",
    "first , define the state @xmath99 in any slot @xmath83 as the value of the primary user queue backlog @xmath54 in that slot .",
    "now let @xmath100 denote the class of stationary , randomized policies where every policy @xmath101 chooses a power allocation @xmath102 in each state @xmath99 according to a stationary distribution .",
    "it can be shown that it is sufficient to only consider policies in @xmath100 to maximize ( [ eq : resource_alloc1 ] ) .",
    "now suppose a policy @xmath101 is implemented on a _ recurrent _ system with fixed @xmath62 and @xmath67 and with the same state dynamics as our model .",
    "note that @xmath103 for all @xmath7 when the state @xmath97 .",
    "then , by basic renewal theory @xcite , we have that maximizing the ratio in ( [ eq : resource_alloc1 ] ) is equivalent to the following optimization problem : @xmath104 where @xmath105 is the resulting steady - state probability of being in state @xmath99 in the recurrent system under the stationary , randomized policy @xmath106 and where the expectations above are with respect to @xmath106 .",
    "note that well - defined steady - state probabilities @xmath105 exist for all @xmath101 because we have assumed that @xmath35 so that even if no cooperation is used , the primary queue is stable and the system is recurrent .",
    "thus , solving ( [ eq : resource_alloc1 ] ) is equivalent to solving the _ unconstrained time average maximization problem _ ( [ eq : femto_time_avg ] ) over the class of stationary , randomized policies .",
    "note that ( [ eq : femto_time_avg ] ) is an infinite horizon markov decision problem ( mdp ) over the state space @xmath107 .",
    "we study this problem in the following .",
    "consider the optimal stationary , randomized policy that maximizes the objective in ( [ eq : femto_time_avg ] ) .",
    "let @xmath108 denote the probability distribution over @xmath17 that is used by this policy to choose a power allocation @xmath94 in state @xmath99 .",
    "let @xmath109 denote the resulting effective probability of successful primary transmission in state @xmath97 .",
    "then we have that @xmath110 where @xmath111 denotes the probability of successful transmission in state @xmath99 when the secondary user spends power @xmath94 in cooperative transmission with the primary user .",
    "since the system is stable and has a well - defined steady - state distribution , we can write down the detail equations for the markov chain that describes the state transitions of the system as follows ( see fig .",
    "[ fig : bd ] ) : @xmath112 where @xmath113 denotes the steady - state probability of being in state @xmath99 under this policy .",
    "summing over all @xmath99 yields : @xmath114 the average power incurred in cooperative transmissions under this policy is given by : @xmath115        now consider an alternate stationary policy that uses the following fixed distribution @xmath116 for choosing control action @xmath117 in all states @xmath97 : @xmath118    let @xmath119 denote the resulting effective probability of a successful primary transmission in any state @xmath97 .",
    "note that this is same for all states by the definition ( [ eq : chi ] ) .",
    "then , we have that : @xmath120 let @xmath121 denote the steady - state probability of being in state @xmath99 under this alternate policy .",
    "note that the system is stable under this alternate policy as well .",
    "thus , using the detail equations for the markov chain that describes the state transitions of the system under this policy yields @xmath122 where we used ( [ eq : eq1_new ] ) in the last step .",
    "this implies that @xmath123 and therefore @xmath124 .",
    "also , the average power incurred in cooperative transmissions under this alternate policy is given by : @xmath125 where we used ( [ eq : eq2_new ] ) in the second last step and @xmath123 in the last step .",
    "thus , if we choose @xmath126 in state @xmath127 and choose @xmath128 as defined in ( [ eq : chi ] ) in all other states , it can be seen that _ the alternate policy achieves the same time average value of the objective ( [ eq : femto_time_avg ] ) as the optimal policy_. this implies that to maximize ( [ eq : femto_time_avg ] ) , it is sufficient to optimize over the class of stationary policies that use the _ same _ distribution for choosing @xmath94 for all states @xmath97 .",
    "denote this class by @xmath129 .",
    "then for all @xmath130 , we have that @xmath131 for all @xmath132 . using this and",
    "the fact that @xmath133 , ( [ eq : femto_time_avg ] ) can be simplified as follows : @xmath134 \\pi_0(r ) \\nonumber\\\\ & - x_{su}(t_k ) { \\mathbb{e}\\left\\{p_1(r)\\right\\ } } ( 1 - \\pi_0(r ) ) \\nonumber \\\\ \\textrm{subject to : } \\ ; & r \\in \\mathcal{r } ' \\label{eq : time_avg2}\\end{aligned}\\ ] ] where @xmath135 is the resulting steady - state probability of being in state @xmath22 and where @xmath136 is the average power incurred in cooperative transmission in state @xmath137 ( same for all states @xmath97 ) .",
    "next , note that the control decisions taken by the secondary user in state @xmath138 do not affect the length of the frame and therefore @xmath135 .",
    "further , the expectations can be removed .",
    "therefore the first term in the problem above can be maximized separately as follows : @xmath139 this is the same as ( [ eq : p_0_define ] ) .",
    "let @xmath86 denote the optimal solution to ( [ eq : time_avg3 ] ) and let @xmath140 denote the value of the objective of ( [ eq : time_avg3 ] ) under the optimal solution .",
    "note that we must have that @xmath141 because the value of the objective when the secondary user chooses @xmath142 ( i.e. , stays idle ) is @xmath22 .",
    "then , ( [ eq : time_avg2 ] ) can be written as : @xmath143 the effective probability of a successful primary transmission in any state @xmath97 is given by @xmath144 . using little s theorem",
    ", we have @xmath145 . using this and rearranging the objective in ( [ eq : time_avg4 ] ) and ignoring the constant terms",
    ", we have the following equivalent problem : @xmath146 it can be shown that it is sufficient to consider only _ deterministic _ power allocations to solve ( [ eq : time_avg5 ] ) ( see , for example , ( * ? ? ? * section 7.3.2 ) ) .",
    "this yields the following problem : @xmath147 this is the same as ( [ eq : p_1_define ] ) .",
    "note that solving this problem does not require knowledge of @xmath6 or @xmath10 and can be solved easily for general power allocation options @xmath17 .",
    "we present an example that admits a particularly simple solution to this problem .",
    "suppose @xmath148 so that the secondary user can either cooperate with full power @xmath19 or not cooperate ( with power expenditure @xmath22 ) with the primary user .",
    "then , the optimal solution to ( [ eq : time_avg6 ] ) can be calculated by comparing the value of its objective for @xmath149 .",
    "this yields the following simple threshold - based rule : @xmath150 we also note that this threshold can be computed without any knowledge of the input rates @xmath151 .    to summarize ,",
    "the overall solution to ( [ eq : femto_resource_alloc ] ) is given by the pair @xmath152 where @xmath86 denotes the power allocation used by the secondary user for its own transmission when the primary user is idle and @xmath87 denotes the power used by the secondary user for cooperative transmission .",
    "note that these values remain fixed for the entire duration of frame @xmath2 .",
    "however , these can change from one frame to another depending on the values of the queues @xmath92 .",
    "the computation of @xmath152 can be carried out using a two - step process as follows :    1 .",
    "first , compute @xmath86 by solving problem ( [ eq : time_avg3 ] ) .",
    "let @xmath153 be the value of the objective of ( [ eq : time_avg3 ] ) under the optimal solution @xmath86 .",
    "2 .   then compute @xmath87 by solving problem ( [ eq : time_avg6 ] ) .",
    "it is interesting to note that in order to implement this algorithm , the secondary user does not require knowledge of the current queue backlog value of the primary user .",
    "rather , it only needs to know the values of its own queues and whether the current slot is in the `` pu idle '' or `` pu busy '' part of the frame .",
    "this is quite different from the conventional solution to the mdp ( [ eq : cmdp ] ) which is typically a different randomized policy for each value of the state ( i.e. , the primary queue backlog ) .",
    "to analyze the performance of the _ frame - based - drift - plus - penalty - algorithm _ , we compare its lyapunov drift with that of the optimal stationary , randomized policy _ stat _ of lemma [ lem : femto_one ] .",
    "first , note that by basic renewal theory @xcite , the performance guarantees provided by _ stat _ hold over every frame @xmath1 .",
    "specifically , let @xmath3 be the start of the @xmath60 frame .",
    "suppose _ stat _ is implemented over this frame .",
    "then the following hold : @xmath154\\right\\ } } \\upsilon^ *   \\label{eq : iid_1 } \\\\ & { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{\\hat{t}_{k+1}-1 } r^{stat}_{su}(t)\\right\\ } } \\leq { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{\\hat{t}_{k+1}-1 } \\mu^{stat}_{su}(t)\\right\\ } }   \\label{eq : iid_2 } \\\\ & { \\mathbb{e}\\left\\ { \\sum_{t = t_k}^{\\hat{t}_{k+1}-1 } p^{stat}_{su}(t)\\right\\ } } \\leq { \\mathbb{e}\\left\\{\\hat{t}[k]\\right\\ } } p_{avg }   \\label{eq : iid_3}\\end{aligned}\\ ] ] where @xmath155 and @xmath156 $ ] denote the start of the @xmath66 frame and the length of the @xmath60 frame , respectively , under the policy _",
    "similarly , @xmath157 denote the resource allocation decisions under _",
    "stat_.    next , we define an alternate control algorithm _ alt",
    "_ that will be useful in analyzing the performance of the _ frame - based - drift - plus - penalty - algorithm_.    _ algorithm alt : _ in each frame @xmath1 , do the following :    1 .",
    "_ admission control _ : for all @xmath83 , choose @xmath13 as follows : @xmath158 2 .",
    "_ resource allocation _ : choose a policy that maximizes the following ratio : @xmath159 | \\boldsymbol{q}(t_k)\\right\\ } } } \\label{eq : resource_alloc_alt}\\end{aligned}\\ ] ] 3 .",
    "_ queue update _ : after implementing this policy , update the queues as in ( [ eq : u_su ] ) , ( [ eq : x_su ] ) .    by comparing with the _ frame - based - drift - plus - penalty - algorithm _ , it can be see that this algorithm differs only in the admission control part while the resource allocation decisions are exactly the same . specifically , under _ alt _ , the queue backlog @xmath62 at the start of the @xmath60 frame is used for making admission control decisions for the entire duration of that frame . however , under the _ frame - based - drift - plus - penalty - algorithm _ , the queue backlog @xmath160 at the start of _ each _ slot is used for making admission control decisions . note",
    "that since the length of the frame depends only on the resource allocation decisions and they are the same under the two algorithms , it follows that implementing them with the same starting backlog @xmath76 yields the same frame lengths .",
    "the following lemma compares the value of the second term in the lyapunov drift bound ( [ eq : femto_drift2 ] ) that corresponds to the admission control decisions under these two algorithms .",
    "let @xmath161 and @xmath162 denote the admission control decisions made by the _ frame - based - drift - plus - penalty - algorithm _ and the _ alt _ algorithm respectively for all @xmath83 .",
    "then we have : @xmath163 where @xmath164 is a constant that does not depend on @xmath165 .",
    "[ lem : adm_ctrl_bound_lem ]    see appendix a.    we are now ready to characterize the performance of the _ frame - based - drift - plus - penalty - algorithm_.    ( performance theorem ) suppose the _ frame - based - drift - plus - penalty - algorithm _ is implemented over all frames @xmath1 with initial condition @xmath166 and with a control parameter @xmath81 .",
    "let @xmath167 denote the resource allocation decisions under this algorithm .",
    "then , we have :    1 .",
    "the secondary user queue backlog @xmath160 is upper bounded for all @xmath7 : @xmath168 2 .",
    "the virtual power queue @xmath67 is mean rate stable , i.e. , @xmath169 further , we have : @xmath170\\right\\ } } } \\leq p_{avg } \\label{eq : x_max3}\\end{aligned}\\ ] ] 3 .",
    "the time - average secondary user throughput ( defined over frames ) satisfies the following bound for all @xmath171 : @xmath172\\right\\ } } }   \\geq   \\upsilon^ * - \\frac{b + c}{v t_{min } }   \\label{eq : femto_utility_bound}\\end{aligned}\\ ] ] where @xmath173}{2}$ ] and @xmath174 .",
    "[ thm : femto_performance ]    theorem [ thm : femto_performance ] shows that the time - average secondary user throughput can be pushed to within @xmath175 of the optimal value with a trade - off in the worst case queue backlog . by little s theorem",
    ", this leads to an @xmath176 utility - delay tradeoff .",
    "part ( 1 ) : we argue by induction .",
    "first , note that ( [ eq : u_max ] ) holds for @xmath177 .",
    "next , suppose @xmath178 for some @xmath179 .",
    "we will show that @xmath180 .",
    "we have two cases .",
    "first , suppose @xmath181 .",
    "then , by ( [ eq : u_su ] ) , the maximum that @xmath160 can increase is @xmath11 so that @xmath182",
    ". next , suppose @xmath183 .",
    "then , the admission control decision ( [ eq : femto_adm_ctrl ] ) chooses @xmath184 .",
    "thus , by ( [ eq : u_su ] ) , we have that @xmath185 for this case as well .",
    "combining these two cases proves the bound ( [ eq : u_max ] ) .    parts ( 2 ) and ( 3 ) : see appendix b.",
    "we consider two extensions to the basic model of sec . [ section : femto_basic ] .",
    "consider the scenario with one primary user as before , but with @xmath186 secondary users .",
    "the primary user channel occupancy process evolves as before where the secondary users can transmit their own data only when the primary user is idle .",
    "however , they may cooperatively transmit with the primary user to increase its transmission success probability . in general",
    ", multiple secondary users may cooperatively transmit with the primary in one timeslot .",
    "however , for simplicity , here we assume that at most one secondary user can take part in a cooperative transmission per slot .",
    "further , we also assume that at most one secondary user can transmit its data when the primary user is idle .",
    "our formulation can be easily extended to this scenario .",
    "let @xmath187 denote the set of power allocation options for secondary user @xmath99 .",
    "suppose each secondary user @xmath99 is subject to average and peak power constraints @xmath188 and @xmath189 respectively .",
    "also , let @xmath190 denote the success probability of the primary transmission when secondary user @xmath99 spends power @xmath27 in cooperative transmission .",
    "now consider the objective of maximizing the sum total throughput of the secondary users subject to each user s average and peak power constraints and the scheduling constraints of the model . in order to apply the `` drift - plus - penalty '' ratio method",
    ", we use the following queues : @xmath191 + \\sum_{t = t_k}^{t_{k+1}-1 } r_{i}(t ) \\label{eq : u_su_i } \\\\   & x_{i}(t_{k+1 } ) = \\max[x_{i}(t_k ) - t[k ] p_{avg , i } + \\sum_{t = t_k}^{t_{k+1}-1 } p_{i}(t ) , 0 ] \\label{eq : x_su_i}\\end{aligned}\\ ] ] where @xmath192 is the queue backlog of secondary user @xmath99 at the beginning of the @xmath60 frame , @xmath193 is the service rate of secondary user @xmath99 in slot @xmath7 , @xmath194 and @xmath195 denote the number of new packets admitted and the power expenditure incurred by the secondary user @xmath99 in slot @xmath7 .",
    "finally , @xmath65 denotes the start of the @xmath66 frame and @xmath0 = t_{k+1 } - t_k$ ] is the length of the @xmath60 frame as before .",
    "let @xmath196 denote the queueing state of the system at the start of the @xmath60 frame . using a lyapunov function @xmath197 $ ] and following the steps in sec .",
    "[ section : solution ] yields the following _ multi - user frame - based - drift - plus - penalty - algorithm_. in each frame @xmath1 , do the following :    1 .",
    "_ admission control _ : for all @xmath83 , for each secondary user @xmath198 , choose @xmath194 as follows : @xmath199 where @xmath200 is the number of new arrivals to secondary user @xmath99 in slot @xmath7 .",
    "resource allocation _ : choose a policy that maximizes the following ratio : @xmath201 | \\boldsymbol{q}(t_k)\\right\\ } } } \\label{eq : resource_alloc_i}\\end{aligned}\\ ] ] 3 .",
    "_ queue update _ : after implementing this policy , update the queues as in ( [ eq : u_su_i ] ) and ( [ eq : x_su_i ] ) .",
    "similar to the basic model , this algorithm can be implemented without any knowledge of the arrival rates @xmath202 or @xmath6 .",
    "further , using the techniques developed in sec .",
    "[ section : solving ] , it can be shown that the solution to ( [ eq : resource_alloc_i ] ) can be computed in two steps as follows .",
    "first , we solve the following problem for each @xmath198 : @xmath203 let @xmath86 denote the optimal solution to ( [ eq : time_avg3_i ] ) achieved by user @xmath204 and let @xmath153 denote the optimal objective value .",
    "this means user @xmath204 transmits on all idle slots of frame @xmath2 with power @xmath86 .",
    "next , to determine the optimal cooperative transmission strategy , we solve the following problem for each @xmath198 : @xmath205 let @xmath87 denote the optimal solution to ( [ eq : time_avg6_i ] ) achieved by user @xmath206 .",
    "this means user @xmath206 cooperatively transmits on all busy slots of frame @xmath2 with power @xmath87 .",
    "next , suppose there is an additional channel fading process @xmath207 that takes values from a finite set @xmath208 in an i.i.d fashion every slot .",
    "we assume that in every slot , @xmath209 = q_s$ ] for all @xmath210 . the success probability with cooperative transmission now is a function of both the power allocation and the fading state in that slot .",
    "specifically , suppose the primary user is active in slot @xmath7 and the secondary user allocates power @xmath23 for cooperative transmission .",
    "also suppose @xmath211 .",
    "then the random success / failure outcome of the primary transmission is given by an indicator variable @xmath212 and the success probability is given by @xmath213 .",
    "the function @xmath214 is known to the network controller for all @xmath210 and is assumed to be non - decreasing in @xmath27 for each @xmath210 . for simplicity , we assume that the secondary user transmission rate @xmath63 depends only on @xmath23 .    by applying the `` drift - plus - penalty '' ratio method to this extended model , we get the following control algorithm .",
    "the admission control remains the same as ( [ eq : femto_adm_ctrl ] ) .",
    "the resource allocation part involves maximizing the ratio in ( [ eq : femto_resource_alloc ] ) .",
    "using the same arguments as before in sec .",
    "[ section : solving ] , it can be shown that maximizing this ratio is equivalent to the following optimization problem : @xmath215 where @xmath216 is the resulting steady - state probability of being in state @xmath217 in the recurrent system under the stationary , randomized policy @xmath106 and where the expectations above are with respect to @xmath106 .",
    "we study this problem in the following .",
    "consider the optimal stationary , randomized policy that maximizes the objective in ( [ eq : time_avg_fading ] ) .",
    "let @xmath218 denote the probability distribution over @xmath17 that is used by this policy to choose a control action @xmath219 in state @xmath217 .",
    "let @xmath220 denote the resulting effective probability of successful primary transmission in state @xmath217 where @xmath97 . since the system is stable under any stationary policy , @xmath221 .",
    "thus , we get : @xmath222 where @xmath223 denotes the steady - state probability of being in state @xmath224 under this policy .",
    "note that the system is stable and has a well - defined steady - state distribution .",
    "the average power incurred in cooperative transmissions under this policy is given by : @xmath225    now consider an alternate stationary policy that , for each @xmath210 , uses the following fixed distribution @xmath226 for choosing control action @xmath227 in all states @xmath217 where @xmath97 : @xmath228 for each @xmath210 ,",
    "let @xmath229 denote the resulting effective probability of a successful primary transmission in any state @xmath217 where @xmath97 under this policy .",
    "note that this is same for all states @xmath217 where @xmath97 by the definition ( [ eq : chi_fading ] ) .",
    "then , we have that : @xmath230 let @xmath231 denote the steady - state probability of being in state @xmath224 under this alternate policy . since the system is stable under any stationary policy , total incoming rate = total outgoing rate .",
    "thus , we get : @xmath232 \\bigg ( \\sum_{k \\geq 1 } \\pi_{k , s } ' \\bigg )     \\label{eq : ipop_fading}\\end{aligned}\\ ] ] where we used ( [ eq : mu_s_fading ] ) in the last step . since @xmath207 is i.i.d . , for any @xmath233 ,",
    "we have that @xmath234 similarly , we have : @xmath235 using this , for any @xmath233 , we have : @xmath236 using this in ( [ eq : ipop_fading ] ) , we have for each @xmath237 : @xmath238 \\frac{\\sum_{k \\geq 1 } \\pi_{k,\\hat{s}}'}{\\sum_{j \\geq 1 } \\pi_{j , \\hat{s } } }    = \\lambda_{pu } \\frac{\\sum_{k \\geq 1 } \\pi_{k,\\hat{s}}'}{\\sum_{j \\geq 1 } \\pi_{j , \\hat{s}}}\\end{aligned}\\ ] ] where we used ( [ eq : eq1_new_fading ] ) in the last step .",
    "this implies that @xmath239 for every @xmath237 and therefore @xmath124 .",
    "also , the average power incurred in cooperative transmissions under this alternate policy is given by : @xmath240 where we used the fact that @xmath241 for all @xmath242 .",
    "thus , if we choose @xmath126 in state @xmath127 and choose @xmath243 as defined in ( [ eq : chi_fading ] ) in all states @xmath217 where @xmath97 , it can be seen that the alternate policy achieves the same time average value of the objective ( [ eq : time_avg_fading ] ) as the optimal policy .",
    "this implies that to maximize ( [ eq : time_avg_fading ] ) , it is sufficient to optimize over the class of stationary policies that , for each @xmath210 , use the _ same _ distribution for choosing @xmath244 for all states @xmath217 where @xmath97 .",
    "denote this class by @xmath129 . using this and",
    "the fact that @xmath245 for all @xmath242 , ( [ eq : time_avg_fading ] ) can be simplified as follows : @xmath246 \\pi_0(r ) \\nonumber\\\\ & - x_{su}(t_k ) \\sum_{s",
    "\\in \\mathcal{s } }   { \\mathbb{e}\\left\\{p_{s}(r)\\right\\ } } ( 1 - \\pi_0(r))q_s \\nonumber \\\\ \\textrm{subject to : } \\ ; & r \\in \\mathcal{r } ' \\label{eq : time_avg2_fading}\\end{aligned}\\ ] ] where @xmath135 is the resulting steady - state probability of being in state @xmath22 and where @xmath247 is the average power incurred in cooperative transmission in any state @xmath224 with @xmath97 .",
    "using the same arguments as before , the solution to ( [ eq : time_avg2_fading ] ) can be obtained in two steps as follows .",
    "we first compute the solution to ( [ eq : time_avg3 ] ) as before . denoting its optimal value by @xmath153 , ( [ eq : time_avg2_fading ] )",
    "can be written as : @xmath248    using little s theorem , we have @xmath249 . using this and rearranging the objective in ( [ eq : time_avg4_fading ] ) and ignoring the constant terms",
    ", we have the following equivalent problem : @xmath250 it can be shown that it is sufficient to consider only _ deterministic _ power allocations to solve ( [ eq : time_avg5_fading ] ) ( see , for example , ( * ? ? ?",
    "* section 7.3.2 ) ) .",
    "this yields the following problem : @xmath251 note that solving this problem does not require knowledge of @xmath6 or @xmath10 and can be solved efficiently for general power allocation options @xmath17 .",
    "in this section , we evaluate the performance of the _ frame - based - drift - plus - penalty - algorithm _ using simulations .",
    "we consider the network model as discussed in sec .",
    "[ section : femto_basic ] with one primary and one secondary user .",
    "the set @xmath17 consists of only two options @xmath252 .",
    "we assume that @xmath253 and @xmath254 .",
    "we set @xmath255 and @xmath256 . for simplicity , we assume that @xmath257 .        in the first set of simulations , we fix the input rates @xmath258 packets / slot . for these parameters",
    ", we can compute the optimal offline solution by linear programming .",
    "this yields the maximum secondary user throughput as @xmath259 packets / slot .",
    "we now simulate the _ frame - based - drift - plus - penalty - algorithm _ for different values of the control parameter @xmath165 over @xmath260 frames . in fig .",
    "[ fig : femto_sim1 ] , we plot the average throughput achieved by the secondary user over this period .",
    "it can be seen that the average throughput increases with @xmath165 and converges to the optimal value @xmath259 packets / slot , with the difference exhibiting a @xmath175 behavior as predicted by theorem [ thm : femto_performance ] . in fig .",
    "[ fig : femto_sim2 ] , we plot the average queue backlog of the secondary user over this period",
    ". it can be see that the average queue backlog grows linearly in @xmath165 , again as predicted by theorem [ thm : femto_performance ] .",
    "also , for all @xmath165 , the average secondary user power consumption over this period was found not to exceed @xmath253 units / slot .    for comparison",
    ", we also simulate three alternate algorithms . in the first algorithm `` no cooperation '' , the secondary user never cooperates with the primary user and only attempts to maximize its throughput over the resulting idle periods .",
    "the secondary user throughput under this algorithm was found to be @xmath261 packets / slot as shown in fig .",
    "[ fig : femto_sim1 ] . note that using little s theorem , the resulting fraction of time the primary user is idle is @xmath262 .",
    "this limits the maximum secondary user throughput under the `` no cooperation '' case to @xmath261 packets / slot .    in the second algorithm",
    ", we consider the `` always cooperate '' case where the secondary user always cooperates with the primary user .",
    "for the example under consideration , this uses up all the secondary user power and thus , the secondary user achieves zero throughput .    in the third algorithm `` counter based policy '' ,",
    "a running average of the total secondary user power consumption so far is maintained . in each slot , the secondary user decides to transmit / cooperate only if this running average is smaller than @xmath18 .",
    "the maximum secondary user throughput under this algorithm was found to be @xmath263 packets / slot .",
    "this demonstrates that simply satisfying the average power constraint is not sufficient to achieve maximum throughput .",
    "for example , it may be the case that under the `` counter based policy '' , the running average condition is usually satisfied when the primary user is busy .",
    "this causes the secondary user to cooperate . however , by the time the primary user next becomes idle , the running average exceeds @xmath18 so that the secondary user does not transmit its own data .",
    "in contrast , the _ frame - based - drift - plus - penalty - algorithm _ is able to find the opportune moments to cooperate / transmit optimally .        in the second set of simulations , we fix the input rate @xmath264 packets / slot , @xmath265 , and",
    "simulate the _ frame - based - drift - plus - penalty - algorithm _ over @xmath260 frames . at the start of the simulation , we set @xmath266 packets / slot .",
    "the values of the other parameters remain the same",
    ". however , during the course of the simulation , we change @xmath6 to @xmath267 packets",
    "/ slot after the first @xmath268 frames and then again to @xmath269 packets / slot after the first @xmath270 frames . in figs .",
    "[ fig : femto_sim3 ] and [ fig : femto_sim4 ] , we plot the running average ( over @xmath271 frames ) of the secondary user throughput and the average power used for cooperation .",
    "these show that the _ frame - based - drift - plus - penalty - algorithm _ automatically adapts to the changes in @xmath6 .",
    "further , it quickly approaches the optimal performance corresponding to the new @xmath6 by adaptively spending more or less power ( as required ) on cooperation .",
    "for example , when @xmath6 reduces to @xmath267 packets / slot after frame number @xmath268 , the fraction of time the primary is idle even with no cooperation is @xmath272 . with @xmath273 ,",
    "there is no need to cooperate anymore .",
    "this is precisely what the _ frame - based - drift - plus - penalty - algorithm _ does as shown in fig .",
    "[ fig : femto_sim4 ] .",
    "similarly , when when @xmath6 increases to @xmath269 packets / slot after frame number @xmath270 , the _ frame - based - drift - plus - penalty - algorithm _ starts to spend more power on cooperative transmissions .",
    "in this paper , we studied the problem of opportunistic cooperation in a cognitive femtocell network .",
    "specifically , we considered the scenario where a secondary user can cooperatively transmit with the primary user to increase its transmission success probability . in return , the secondary user can get more opportunities for transmitting its own data when the primary user is idle .",
    "a key feature of this problem is that here , the evolution of the system state depends on the control actions taken by the secondary user .",
    "this dependence makes it a constrained markov decision problem traditional solutions to which require either extensive knowledge of the system dynamics or learning based approaches that suffer from large convergence times .",
    "however , using the technique of lyaunov optimization , we designed a novel greedy and online control algorithm that overcomes these challenges and is provably optimal .",
    "let @xmath274 denote the queue backlog value under the _ frame - based - drift - plus - penalty - algorithm _ for all @xmath275 . then",
    ", since the admission control decision ( [ eq : femto_adm_ctrl ] ) of the _ frame - based - drift - plus - penalty - algorithm _ minimizes the term @xmath276 for all @xmath160 , we have :    @xmath277    note that we are not implementing the admission control decisions of _ alt _ in the left hand side of the above .",
    "next , we make use of the following sample path relations in ( [ eq : ineq2_new ] ) to prove ( [ eq : adm_ctrl_bound ] ) . for all @xmath275 , the following hold under any control algorithm :",
    "@xmath278 ( [ eq : sample1 ] ) follows by noting that the maximum number of arrivals to the secondary user queue in the interval @xmath279 is at most @xmath280 .",
    "similarly , ( [ eq : sample2 ] ) follows by noting that the maximum number of departures from the secondary user queue in the interval @xmath279 is at most @xmath281 .        using ( [ eq : sample1 ] ) in the left hand side of ( [ eq : ineq2_new ] ) yields : @xmath282 using the fact that @xmath283 and @xmath284(t[k]-1)}{2}$ ] , we get : @xmath285    next , using ( [ eq : sample2 ] ) in the right hand side of ( [ eq : ineq2_new ] ) yields : @xmath286 again using the fact that @xmath287 and @xmath288 ) = \\frac{t[k](t[k]-1)}{2}$ ] , we get : @xmath289    using ( [ eq : ineq1_new ] ) and ( [ eq : ineq3_new ] ) in ( [ eq : ineq2_new ] ) , we have :    @xmath290",
    "we prove parts ( 2 ) and ( 3 ) of theorem [ thm : femto_performance ] using the technique of lyapunov optimization . using ( [ eq : femto_drift2 ] ) , a bound on the lyapunov drift under the _ frame - based - drift - plus - penalty - algorithm _ is given by : @xmath291 p_{avg } | \\boldsymbol{q}(t_k)\\right\\ } } \\nonumber\\\\ & -   { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{t_{k+1}-1 } ( q_{su}(t_k ) \\mu_{su}^{fab}(t ) - x_{su}(t_k ) p_{su}^{fab}(t ) ) | \\boldsymbol{q}(t_k)\\right\\ } } \\label{eq : drift3}\\end{aligned}\\ ] ] using lemma [ lem : adm_ctrl_bound_lem ] , we have that : @xmath292 next , note that under the _ alt _ algorithm , we have : @xmath293 | \\boldsymbol{q}(t_k)\\right\\ } } }   \\\\ & \\leq \\frac{{\\mathbb{e}\\left\\{\\sum_{t = t_k}^{\\hat{t}_{k+1}-1 } ( q_{su}(t_k ) - v ) { r}_{su}^{stat}(t ) | \\boldsymbol{q}(t_k)\\right\\}}}{{\\mathbb{e}\\left\\{\\hat{t}[k ] | \\boldsymbol{q}(t_k)\\right\\}}}\\end{aligned}\\ ] ] to see this , we have two cases :    1 .",
    "@xmath294 : then , @xmath295 for all @xmath296 , so that the left hand side above is @xmath22 while the right hand side is @xmath297 . hence , the inequality follows .",
    "@xmath298 : then , @xmath299 for all @xmath296 , so that the left hand side becomes @xmath300 while the right hand side can not be smaller than @xmath300 .    combining these , we get : @xmath301 | \\boldsymbol{q}(t_k)\\right\\}}}{{\\mathbb{e}\\left\\{\\hat{t}[k ] | \\boldsymbol{q}(t_k)\\right\\ } } }   \\ ] ]    finally , since the resource allocation part of the _ frame - based - drift - plus - penalty - algorithm _ maximizes the ratio in ( [ eq : femto_resource_alloc ] ) , we have : @xmath302 | \\boldsymbol{q}(t_k)\\right\\}}}{{\\mathbb{e}\\left\\{\\hat{t}[k ] | \\boldsymbol{q}(t_k)\\right\\ } } }   \\ ] ]    using these in ( [ eq : drift3 ] ) , we have : @xmath303 | \\boldsymbol{q}(t_k)\\right\\}}}{{\\mathbb{e}\\left\\{\\hat{t}[k ] | \\boldsymbol{q}(t_k)\\right\\ } } } \\nonumber\\\\ & - { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{\\hat{t}_{k+1}-1 } ( q_{su}(t_k){\\mu}_{su}^{stat}(t ) - x_{su}(t_k ) { p}_{su}^{stat}(t ) ) | \\boldsymbol{q}(t_k)\\right\\ } } \\\\ & \\times \\frac{{\\mathbb{e}\\left\\{t[k ] | \\boldsymbol{q}(t_k)\\right\\}}}{{\\mathbb{e}\\left\\{\\hat{t}[k ] | \\boldsymbol{q}(t_k)\\right\\ } } } - x_{su}(t_k ) { \\mathbb{e}\\left\\{t[k ] p_{avg } | \\boldsymbol{q}(t_k)\\right\\ } }      \\ ] ]    using ( [ eq : iid_1])-([eq : iid_3 ] ) in the inequality above , we get : @xmath304 | \\boldsymbol{q}(t_k)\\right\\ } } \\label{eq : drift5}\\end{aligned}\\ ] ]    to prove ( [ eq : x_max1 ] ) , we rearrange ( [ eq : drift5 ] ) to get : @xmath305 | \\boldsymbol{q}(t_k)\\right\\ } } \\\\ &   + v { \\mathbb{e}\\left\\{\\sum_{t = t_k}^{t_{k+1}-1 } r_{su}^{fab}(t ) | \\boldsymbol{q}(t_k)\\right\\ } } \\leq b + c + v t_{max } a_{max}\\end{aligned}\\ ] ] ( [ eq : x_max1 ] ) now follows from theorem 4.1 of @xcite .",
    "since @xmath67 is mean rate stable , ( [ eq : x_max2 ] ) follows from theorem 2.5(b ) of @xcite . to prove ( [ eq : femto_utility_bound ] )",
    ", we take expectations of both sides of ( [ eq : drift5 ] ) to get : @xmath306\\right\\}}\\end{aligned}\\ ] ]    summing over @xmath307 , dividing by @xmath165 , and rearranging yields : @xmath308\\right\\ } } - \\frac{(b + c)k}{v } \\end{aligned}\\ ] ] where we used that fact that @xmath309 and @xmath310 . from this",
    ", we have : @xmath311\\right\\ } } }    & \\geq   \\upsilon^ * - \\frac{(b + c)k}{v \\sum_{k=1}^k { \\mathbb{e}\\left\\{t[k]\\right\\ } } }   \\\\   & \\geq \\upsilon^ * - \\frac{b + c}{v t_{min}}\\end{aligned}\\ ] ] since @xmath312\\right\\ } } \\geq k t_{min}$ ] .",
    "this proves ( [ eq : femto_utility_bound ] ) .",
    "here , we compute a finite @xmath43 that satisfies ( [ eq : second_moment ] ) . first , note that @xmath44\\right\\}}$ ] would be maximum when the secondary user never cooperates .",
    "next , let @xmath313 $ ] and @xmath314 $ ] denote the lengths of the primary user idle and busy periods , respectively , in the @xmath60 frame .",
    "thus , we have @xmath0 = i[k ] + b[k]$ ] .    in the following , we drop",
    "@xmath315 $ ] from the notation for convenience . using the independence of @xmath316 and @xmath75",
    ", we have : @xmath317 we note that @xmath316 is a geometric r.v . with parameter @xmath6 .",
    "thus , @xmath318 and @xmath319 . to calculate @xmath320",
    ", we apply little s theorem to get : @xmath321 this yields @xmath322 . to calculate @xmath323",
    ", we use the observation that changing the service order of packets in the primary queue to preemptive lifo does not change the length of the busy period @xmath75 .",
    "however , with lifo scheduling , @xmath75 now equals the duration that the first packet stays in the queue . next ,",
    "suppose there are @xmath324 packets that interrupt the service of the first packet .",
    "let these be indexed as @xmath325 .",
    "we can relate @xmath75 to the service time @xmath326 of the first packet and the durations for which all these other packets stay in the queue as follows : @xmath327 here , @xmath328 denotes the duration for which packet @xmath99 stays in the queue . using the memoryless property of the i.i.d .",
    "arrival process of the primary packets as well as the i.i.d",
    ". nature of the service times , it follows that all the r.v.s @xmath328 are i.i.d . with",
    "the _ same _ distribution as @xmath75 .",
    "further , they are independent of @xmath324 . squaring ( [ eq : b_k ] ) and taking expectations ,",
    "we get : @xmath329 note that @xmath326 is a geometric r.v . with parameter @xmath30 .",
    "thus @xmath330 and @xmath331 .",
    "also , @xmath332 . using these in ( [ eq : b_squared ] ) , we have : @xmath333 to calculate the last term , we have : @xmath334 note that given @xmath335 , @xmath324 is a binomial r.v . with parameters",
    "thus , we have : @xmath337 \\\\ & = \\sum_{x \\geq 1 } \\big[(x \\lambda_{pu})^2 + x \\lambda_{pu}(1 - \\lambda_{pu})\\big ] ( 1-\\phi_{nc})^{x-1}\\phi_{nc } \\\\ & = \\lambda_{pu}^2   \\sum_{x \\geq 1 } x^2 \\phi_{nc } ( 1 -\\phi_{nc})^{x-1 } \\\\ & + \\lambda_{pu } ( 1 - \\lambda_{pu } ) \\sum_{x \\geq 1 } x \\phi_{nc } ( 1 -\\phi_{nc})^{x-1 } \\\\ & = \\lambda_{pu}^2 \\frac{(2 - \\phi_{nc})}{\\phi_{nc}^2 } + \\lambda_{pu } ( 1 - \\lambda_{pu } ) \\frac{1}{\\phi_{nc}}\\end{aligned}\\ ] ] using this , we have : @xmath338 using this , we have : @xmath339 simplifying this yields : @xmath340                        o. simeone , i. stanojev , s. savazzi , y. bar - ness , u. spagnolini , and r. pickholtz . spectrum leasing to cooperating secondary ad hoc networks . _",
    "ieee jsac special issue on cognitive radio : theory and applications _ , 26(1):203 - 213 , jan .",
    "2008 .",
    "i. krikidis , j. n. laneman , j. thompson , and s. mclaughlin . protocol design and throughput analysis for multi - user cognitive cooperative systems .",
    "_ ieee trans .",
    "wireless commun .",
    "_ , 8(9):4740 - 4751 , sept . 2009 ."
  ],
  "abstract_text": [
    "<S> we investigate opportunistic cooperation between unlicensed secondary users and legacy primary users in a cognitive radio network . </S>",
    "<S> specifically , we consider a model of a cognitive network where a secondary user can cooperatively transmit with the primary user in order to improve the latter s effective transmission rate . in return </S>",
    "<S> , the secondary user gets more opportunities for transmitting its own data when the primary user is idle . </S>",
    "<S> this kind of interaction between the primary and secondary users is different from the traditional _ dynamic spectrum access _ model in which the secondary users try to avoid interfering with the primary users while seeking transmission opportunities on vacant primary channels . in our model , </S>",
    "<S> the secondary users need to balance the desire to cooperate more ( to create more transmission opportunities ) with the need for maintaining sufficient energy levels for their own transmissions . </S>",
    "<S> such a model is applicable in the emerging area of cognitive femtocell networks . </S>",
    "<S> we formulate the problem of maximizing the secondary user throughput subject to a time average power constraint under these settings . </S>",
    "<S> this is a constrained markov decision problem and conventional solution techniques based on dynamic programming require either extensive knowledge of the system dynamics or learning based approaches that suffer from large convergence times . </S>",
    "<S> however , using the technique of lyapunov optimization , we design a novel _ greedy _ and _ online _ control algorithm that overcomes these challenges and is provably optimal .    </S>",
    "<S> resource allocation , opportunistic cooperation , cognitive radio , femtocell networks , optimal control </S>"
  ]
}