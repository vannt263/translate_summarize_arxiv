{
  "article_text": [
    "static eikonal pdes arise in a surprisingly wide range of applications : from robotic path planning , to isotropic optimal control , to isotropic front propagation , to shape - from - shading computations ; see @xcite and references therein for a detailed description . as a result ,",
    "efficient numerical methods for eikonal pdes are of interest to many practitioners and numerical analysts . in this paper",
    "we introduce two hybrid methods intended to blend and combine the best properties of the most popular current approaches ( fast marching and fast sweeping ) .",
    "these methods are built to solve the non - linear boundary value problem , although generalizations to higher dimensional domains are straightforward and similar approaches are applicable to higher - order accurate discretizations on unstructured meshes in @xmath1 and on manifolds . ]",
    "@xmath2    a discretized version of equation is posed at every gridpoint , using upwind divided differences to approximate the partial derivatives of @xmath3 .",
    "the exact form of this discretization is introduced in section [ s : prior_fast ] ; here we simply note that these discretized equations form a system of @xmath4 coupled non - linear equations ( where @xmath4 is the number of gridpoints ) and that the key challenge addressed by many `` fast '' methods is the need to solve this system efficiently .",
    "of course , an iterative approach is certainly a possibility , but its most straightforward and naive implementation typically leads to @xmath5 algorithmic complexity for eikonal pde ( and potentially much worse for its anisotropic generalizations ) .",
    "this is in contrast to the `` fast '' methods , whose worst - case computational complexity is @xmath6 or @xmath7 .",
    "interestingly , most fast eikonal - solvers currently in use are directly related to the fast algorithms developed much earlier to find the shortest paths in directed graphs with non - negative edge - lengths ; see , e.g. , @xcite , @xcite .",
    "two such algorithmic families are particularly prominent : the _ label - setting methods _ , which have the optimal worst - case asymptotic computational complexity , and the _ label - correcting methods _",
    ", whose worst - case asymptotic complexity is not as good , but the practical performance is at times even better than that of label - setting .",
    "we provide a basic overview of both families in section [ ss : intro_graphs ] .",
    "the prior fast eikonal - solvers based on label - setting and label - correcting are reviewed in sections [ ss : fm ] and [ ss : fs]-[ss : correcting_eikonal ] respectively .",
    "the most popular methods from these two categories ( fast marching and fast sweeping ) have been shown to be efficient on a wide range of eikonal equations .",
    "however , each of these methods has its own preferred class of problems , on which it significantly outperforms the other . despite experimental comparisons already conducted in @xcite and @xcite ,",
    "the exact delineation of a preferred problem - set for each method is still a matter of debate .",
    "fast sweeping ( reviewed in section [ ss : fm ] ) is usually more efficient on problems with constant characteristic directions .",
    "but for general functions @xmath8 , its computational cost is clearly impacted by the frequency and magnitude of directional changes of characteristic curves .",
    "fast marching ( reviewed in section [ ss : fm ] ) is generally more efficient on domains with complicated geometry and on problems with characteristic directions frequently changing .",
    "its causal algorithmic structure results in a provably converged solution on explicitly determined parts of the computational domain even before the method terminates  a very useful feature in many applications . moreover ,",
    "its efficiency is much more `` robust '' ; i.e. , its computational cost is much less affected by any changes in functions @xmath9 and @xmath10 or the grid orientation .",
    "but as a result , the fast marching also is not any faster in the simplest cases where @xmath9 is constant on a convex domain and all characteristics are straight lines ",
    "the exact scenario where the fast sweeping is at its most efficient .",
    "the fundamental idea underlying our hybrid two - scale methods is to take advantage of the best features of both marching and sweeping .",
    "suppose the domain is split in a moderate number of cells such that @xmath9 is almost - constant on each of them .",
    "( such cell splitting is possible for any piecewise - smooth @xmath9 . ) on the top scale , a version of fast marching can be used on a coarse grid ( with each gridpoint representing a cell of the fine grid ) .",
    "once the ordering of coarse gridpoints is established , the fast sweeping is applied to individual cells of the fine grid in the same order .",
    "this is the basis of our fast marching - sweeping method ( fmsm ) described in section [ ss : fmsm ] .",
    "unfortunately , the coarse grid ordering captures the information flow through the fine grid cells only approximately : a coarse gridpoint @xmath11 might be `` accepted '' by fast marching before another coarse gridpoint @xmath12 , even if on the fine grid the characteristics cross both from cell @xmath13 to cell @xmath14 and from cell @xmath14 to cell @xmath13 .",
    "the `` one - pass '' nature of fast marching prevents fmsm from acting on such interdependencies between different cells even if they are revealed during the application of fast sweeping to these cells . to remedy this",
    ", we introduce the heap - cell method ( hcm ) described in section [ ss : fhcm ] .",
    "the idea is to allow multiple passes through fine grid cells sorted by the representative `` cell - values '' and updated as a result of cell - level fast sweeping .",
    "we also describe its heuristic version , the fast heap - cell method ( fhcm ) , where the number of cell - level sweeps is determined based on the cell - boundary data .    similarly to fast marching and fast sweeping",
    ", our hcm provably converges to the exact solution of the discretized equations on the fine scale .",
    "in contrast , the even faster fhcm and fmsm usually introduce additional errors .",
    "but based on our extensive numerical experiments ( section [ s : experiments ] ) , these additional errors are small compared to the errors already present due to discretization . the key advantage of all three new methods is their computational efficiency  with properly chosen cell sizes , we can significantly outperform both fast sweeping and fast marching on examples difficult for those methods , while matching their performance on the examples which are the easiest for each of them .",
    "additional performance / accuracy tests can be found in an extended version of this manuscript @xcite .",
    "we conclude by discussing the current limitations of our approach and several directions for future work in section [ s : conclusions ] .",
    "we provide a brief review of common fast methods for the classical shortest / cheapest path problems on graphs .",
    "our exposition follows @xcite and @xcite , but with modifications needed to emphasize the parallels with the numerical methods in sections [ s : prior_fast ] and [ s : our_methods ] .",
    "consider a directed graph with nodes @xmath15 .",
    "let @xmath16 be the set of nodes to which @xmath17 is connected .",
    "we will assume that @xmath18 is an upper bound on outdegrees ; i.e. , @xmath19 we also suppose that all arc - costs @xmath20 are positive and use @xmath21 whenever @xmath22 .",
    "every path terminates upon reaching the specified exit set @xmath23 , with an additional exit - cost @xmath24 for each @xmath25 given any starting node @xmath26 , the goal is to find the cheapest path to the exit starting from @xmath27 .",
    "the _ value function _",
    "@xmath28 is defined to be the optimal path - cost ( minimized over all paths starting from @xmath27 ) . if there exists no path from @xmath27 to @xmath29 , then @xmath30 , but for simplicity we will henceforth assume that @xmath29 is reachable from each @xmath27 and all @xmath31 s are finite .",
    "the optimality principle states that the `` tail '' of every optimal path is also optimal ; hence , @xmath32 this is a coupled system of @xmath4 non - linear equations , but it possesses a nice `` causal '' property : if @xmath33 is the minimizer , then @xmath34 .    in principle , this system could be solved by `` value iterations '' ; this approach is unnecessarily expensive ( and is usually reserved for harder _ stochastic _ shortest path problems ) , but we describe it here for methodological reasons , to emphasize the parallels with `` fast iterative '' numerical methods for eikonal pdes .",
    "an operator @xmath35 is defined on @xmath36 component - wise by applying the right hand side of equation .",
    "clearly , @xmath37 $ ] is a fixed point of @xmath35 and one can , in principle , recover @xmath38 by _ value iterations _ : @xmath39 due to the causality of system , value iterations will converge to @xmath38 regardless of @xmath40 after at most @xmath4 iterations , resulting in @xmath5 computational cost .",
    "( it is easy to show by induction that @xmath41 for every @xmath27 from which there exists an optimal path with at most @xmath42 transitions . )",
    "a gauss - seidel relaxation of this iterative process is a simple practical modification , where the entries of @xmath43 are computed sequentially and the new values are used as soon as they become available : @xmath44 the number of iterations required to converge will now heavily depend on the ordering of the nodes ( though @xmath4 is still the upper bound ) .",
    "we note that , again due to causality of , if the ordering is such that @xmath45 , then only one full iteration will be required ( i.e. , @xmath46 regardless of @xmath40 ) . of course",
    ", @xmath38 is not known in advance and thus such a causal ordering is usually not available a priori ( except in acyclic graphs ) .",
    "if several different node orderings are somehow known to capture likely dependency chains among the nodes , then a reasonable approach would be to perform gauss - seidel iterations alternating through that list of preferred orderings  this might potentially result in a substantial reduction in the number of needed iterations . in section [ ss : fs ]",
    "we explain how such preferred orderings arise from the geometric structure of pde discretizations , but no such information is typically available in problems on graphs . as a result , instead of alternating through a list of predetermined orderings , efficient methods on graphs are based on finding advantageous orderings of nodes _ dynamically_. this is the basis for _ label - correcting _ and _ label - setting _ methods .",
    "a generic label - correcting method is summarized below in algorithm [ alg : generic_lc ] .",
    "initialization : @xmath47 @xmath48 add @xmath27 to the list @xmath49 @xmath50 main loop : remove a node @xmath51 from the list @xmath49 @xmath52 @xmath53 add @xmath27 to the list @xmath49    it is easy to prove that this algorithm always terminates and that upon its termination @xmath54 ; e.g. , see @xcite .",
    "many different label - correcting methods are obtained by using different choices on how to add the nodes to the list @xmath49 and which node to remove ( in the first line inside the while loop ) .",
    "if @xmath49 is implemented as a queue , the node is typically removed from the top of @xmath49 . always adding the nodes at the bottom of @xmath49 yields the _ bellman - ford method _ @xcite .",
    "( this results in a first - in / first - out policy for processing the queue . ) always adding nodes at the top of @xmath49 produces the _ depth - first - search _ method , with the intention of minimizing the memory footprint of @xmath49 . adding nodes at the top if they have already been in @xmath49 before , while adding the `` first - timers '' at the bottom yields _ desopo - pape method _ @xcite .",
    "another interesting version is the so called _ small - labels - first _ ( slf ) method @xcite , where the node is added at the top only if its value is smaller than that of the current top node and at the bottom otherwise .",
    "another variation is _ large - labels - last _ ( lll ) method @xcite , where the top node is removed only if its value is smaller than the current average of the queue ; otherwise it s simply moved to the bottom of the queue instead .",
    "yet another popular approach is called _ thresholding method _ , where @xmath49 is split into two queues , nodes are removed from the first of them only and added to the first or the second queue depending on whether the labels are smaller than some ( dynamically changing ) threshold value @xcite .",
    "we emphasize that the convergence is similarly obtained for all of these methods , their worst - case asymptotic complexity is @xmath5 , but their comparative efficiency for specific problems can be dramatically different .",
    "label - setting algorithms can be viewed as a subclass of the above with an additional property : nodes removed from @xmath49 never need to be re - added later .",
    "dijkstra s classical method @xcite is the most popular in this category and is based on always removing the node with the smallest label of those currently in @xmath49 .",
    "( the fact that this results in no re - entries into the list is yet another consequence of the causality ; the inductive proof is simple ; e.g. , see @xcite . ) the need to find the smallest label entails additional computational costs . a common implementation of @xmath49",
    "using heap - sort data structures will result in @xmath7 overall asymptotic complexity of the method on sparsely connected graphs ( i.e. , provided @xmath18 ) .",
    "another version , due to dial @xcite , implements @xmath49 as a list of `` buckets '' , so that all nodes in the current smallest bucket can be safely removed simultaneously , resulting in the overall asymptotic complexity of @xmath6 . the width of each bucket is usually set to be @xmath55 to ensure that the nodes in the same bucket could not influence or update each other even if they were removed sequentially .",
    "we note that several label - correcting methods were designed to mimic the `` no - re - entry '' property of label - setting , but without using expensive data structures .",
    "( e.g. , compare slf / lll to dijkstra s and thresholding to dial s . ) despite the lower asymptotic complexity of label - setting methods , label - correcting algorithms can be more efficient on many problems . which types of graphs favor which of these algorithms remains largely a matter of debate .",
    "we refer readers to @xcite and references therein for additional details and asynchronous ( parallelizable ) versions of label - correcting algorithms .",
    "static hamilton - jacobi equations frequently arise in exit - time optimal control problems .",
    "the eikonal pde describes an important subset : isotropic time - optimal control problems .",
    "the goal is to drive a system starting from a point @xmath56 to exit the domain as quickly as possible . in this",
    "setting , @xmath57 is the local speed of motion , and @xmath58 is the exit - time penalty charged at the boundary .",
    "we note that more general control problems ( with an exit - set @xmath59 and trajectories constrained to remain inside @xmath60 until reaching @xmath29 ) can be treated similarly by setting @xmath61 on @xmath62 .",
    "the _ value function _",
    "@xmath63 is defined to be the minimum time - to - exit starting from @xmath64 and a formal argument shows that @xmath3 should satisfy the equation .",
    "moreover , characteristics of this pde , coinciding with the gradient lines of @xmath3 , provide the optimal trajectories for moving through the domain .",
    "unfortunately , the equation usually does not have a classical ( smooth ) solution on the entire domain , while weak solutions are not unique .",
    "additional test conditions are used to select among them the unique _ viscosity solution _ , which coincides with the value function of the original control problem @xcite .",
    "a detailed treatment of general optimal control problems in the framework of viscosity solutions can be found in @xcite .",
    "many discretization approaches for the eikonal equation have been extensively studied including first - order and higher - order eulerian discretizations on grids and meshes in @xmath65 and on manifolds @xcite , semi - lagrangian discretizations @xcite , and the related approximations with controlled markov chains @xcite . for the purposes of this paper",
    ", we will focus on the simplest first - order upwind discretization on a uniform cartesian grid @xmath66 ( with gridsize @xmath67 ) on @xmath68 . to simplify the description of algorithms",
    ", we will further assume that both @xmath69 and @xmath29 are naturally discretized on the grid @xmath66 .",
    "our exposition here closely follows @xcite .    to introduce the notation",
    ", we will refer to gridpoints @xmath70 , value function approximations @xmath71 , and the speed @xmath72 .",
    "a popular first - order accurate discretization of is obtained by using upwind finite - differences to approximate partial derivatives : @xmath73 @xmath74 if the values at four surrounding nodes are known , this equation can be solved to recover @xmath75 .",
    "this is best accomplished by computing updates from individual quadrants as follows .",
    "focusing on a single node @xmath76 , we will simplify the notation by using @xmath77 , @xmath78 , and @xmath79 for the values at its four neighbor nodes .",
    "first , suppose that @xmath80 and @xmath81 .",
    "this implies that @xmath82 and the resulting equation yields @xmath83    to compute `` the update from the first quadrant '' , we now suppose that + @xmath84 and @xmath81 .",
    "+ this implies that @xmath82 and @xmath85 .",
    "the resulting quadratic equation is @xmath86 we define `` the update from the first quadrant '' @xmath87 to be the root of the above quadratic satisfying @xmath88 .",
    "if no such root is available , we use the smallest of the `` one - sided '' updates , similar to the previous case ; i.e. , @xmath89 if we similarly define the updates from the remaining three quadrants , it is easy to show that @xmath90 satisfies the original equation .",
    "[ rem : discr_properties ] it is also easy to verify that this discretization is + @xmath91 _ consistent _ , i.e. , suppose both sides of are multiplied by @xmath92 ; if the true solution @xmath63 is smooth , it satisfies the resulting discretized equation up to @xmath93 ; + @xmath91 _ monotone _ , i.e. , @xmath38 is a non - decreasing function of each of its neighboring values ; + @xmath91 _ causal _ , i.e. , @xmath38 depends only on the neighboring values smaller than itself @xcite .",
    "+ the consistency and monotonicity can be used to prove the convergence to the viscosity solution @xmath63 ; see @xcite .    however , since has to hold at every gridpoint @xmath94 , this discretization results in a system of @xmath4 coupled non - linear equations , where @xmath4 is the number of gridpoints in the interior of @xmath60 . in principle",
    ", this system can be solved iteratively ( similarly to the `` value iterations '' process described in ) with or without gauss - seidel relaxation , but a naive implementation of this iterative algorithm would be unnecessarily expensive , since it does not take advantage of the causal properties of the discretization . several competing approaches for solving the discretized system efficiently are reviewed in the following subsections .",
    "the causality property observed above is the basis of dijkstra - like methods for the eikonal pde .",
    "the first such method was introduced by tsitsiklis for isotropic control problems using first - order semi - lagrangian discretizations on uniform cartesian grids @xcite . the fast marching method was introduced by sethian @xcite using first - order upwind - finite differences in the context of isotropic front propagation .",
    "a detailed discussion of similarities and differences of these approaches can be found in @xcite .",
    "sethian and collaborators have later extended the fast marching approach to higher - order discretizations on grids and meshes @xcite , more general anisotropic hamilton - jacobi - bellman pdes @xcite , and quasi - variational inequalities @xcite .",
    "similar methods were also introduced for semi - lagrangian discretizations @xcite . the fast marching method for the eulerian discretization",
    "is summarized below in algorithm [ alg : fmm ] .",
    "initialization : label @xmath76 as @xmath95 and set @xmath96 .",
    "label @xmath76 as @xmath97 and set @xmath98 .",
    "label @xmath76 as @xmath99 and put @xmath76 onto the considered list @xmath49 .",
    "compute a temporary value @xmath100 using the upwinding discretization .",
    "@xmath101 end initialization remove the point @xmath102 with the smallest value from @xmath49 .",
    "compute a temporary value @xmath100 using the upwinding discretization .",
    "@xmath101 label @xmath76 as @xmath99 and add it to @xmath49 .",
    "as explained in section [ ss : intro_graphs ] , the label - setting dijkstra s method can be considered as a special case of the generic label - correcting algorithm , provided the current smallest node in @xmath49 is always selected for removal .",
    "of course , in this case it is more efficient to implement @xmath49 as a binary heap rather than a queue .",
    "the same is also true for the fast marching method , and a detailed description of an efficient implementation of the heap - sort data structure can be found in @xcite .",
    "the re - sorting of @xmath99 nodes upon each update involves up to @xmath103 operations , resulting in the overall computational complexity of @xmath104 .",
    "unfortunately , the discretization is only weakly causal : there exists no @xmath105 such that @xmath106 whenever @xmath107 thus , no safe `` bucket width '' can be defined and dial - like methods are not applicable to the resulting discretized system . in @xcite tsitsiklis introduced a dial - like method for a similar discretization but using an 8-neighbor stencil .",
    "more recently , another dial - related method for the eikonal pde on a uniform grid was introduced in @xcite .",
    "a more general formula for the safe bucket - width to be used in dial - like methods on unstructured acute meshes was derived in @xcite . despite their better computational complexity ,",
    "dial - like methods often perform slower than dijkstra - like methods at least on single processor architectures .",
    "finally , we note another convenient feature of label - setting methods : if the execution of the algorithm is stopped early ( before the list @xmath49 becomes empty ) , all gridpoints previously removed from @xmath49 will already have provably correct values .",
    "this property ( unfortunately not shared by the methods in sections [ ss : fs]-[ss : correcting_eikonal ] ) is very useful in a number of applications : e.g. , when computing a quickest path from a single source to a single target or in problems of image segmentation @xcite .",
    "suppose all gridpoints in @xmath66 are ordered .",
    "we will slightly abuse the notation by using a single subscript ( e.g. , @xmath27 ) to indicate the particular gridpoint s place in that ordering .",
    "the double subscript notation ( e.g. , @xmath76 ) will be still reserved to indicate the physical location of a gridpoint in the two - dimensional grid .",
    "consider discretization and suppose that the solution @xmath38 is known for all the gridpoints .",
    "note that for each @xmath27 , the value @xmath31 will only depend on one or two of the neighboring values ( depending on which quadrant is used for a two - sided update , similar to , and on whether a one - sided update is employed , similar to ) .",
    "this allows us to define a _",
    "dependency digraph _",
    "@xmath108 on the vertices @xmath109 with a link from @xmath27 to @xmath51 indicating that @xmath110 is needed to compute @xmath31 .",
    "the causality of the discretization guarantees that @xmath108 will always be acyclic .",
    "thus , if we were to order the gridpoints respecting this causality ( i.e. , with @xmath111 there is no path in @xmath108 from @xmath51 to @xmath27 ) , then a single gauss - seidel iteration would correctly solve the full system in @xmath6 operations .",
    "however , unless @xmath38 was already computed , the dependency digraph @xmath108 will not be generally known in advance .",
    "thus , basing a gridpoint ordering on it is not a practical option .",
    "instead , one can alternate through a list of several `` likely '' orderings while performing gauss - seidel iterations .",
    "a geometric interpretation of the optimal control problem provides a natural list of likely orderings : if all characteristics point from sw to ne , then ordering the gridpoints bottom - to - top and left - to - right within each row will ensure the convergence in a single iteration ( a `` sw sweep '' ) .",
    "the `` fast sweeping methods '' perform gauss - seidel iterations on the system in alternating directions ( sweeps ) .",
    "let @xmath112 be the number of gridpoints in the @xmath113-direction and @xmath114 be the number in the @xmath115-direction , and @xmath76 will denote a gridpoint in a uniform cartesian grid on @xmath116 for simplicity , we will use the matlab index notation to describe the ordering of gridpoints in each sweep .",
    "there are four alternating sweeping directions : from sw , from se , from ne , and from nw .",
    "for the above described southwest sweep , the gridpoints @xmath76 will be processed in the following order : i=1:1:m , j=1:1:n .",
    "all four orderings are similarly defined in algorithm [ alg : fsm_order ] .",
    "@xmath117 @xmath118 @xmath119 @xmath118 @xmath120 @xmath121 @xmath120 @xmath121 @xmath119    the alternating sweeps are then repeated until convergence .",
    "the resulting algorithm is summarized in [ alg : fsm ] .",
    "initialization : @xmath122 .",
    "main loop : sweepnumber @xmath124 0 changed @xmath124 false determine iorder and jorder based on sweepnumber compute a temporary value @xmath100 using upwinding discretization .",
    "@xmath101 changed @xmath124 true sweepnumber @xmath124 sweepnumber + 1    [ rem : sweep_history ] the idea that alternating the order of gauss - seidel sweeps might speed up the convergence is a centerpiece of many fast algorithms . for euclidean distance computations",
    "it was first used by danielsson in @xcite . in the context of general hjb",
    "pdes it was introduced by boue and dupuis in @xcite for a numerical approximation based on controlled markov chains .",
    "more recently , a number of papers by cheng , kao , osher , qian , tsai , and zhao introduced related fast sweeping methods to speed up the iterative solving of finite - difference discretizations @xcite .",
    "the key challenge for these methods is to find a provable and explicit upper bound on the number of iterations . as of",
    "right now , such a bound is only available for boundary value problems in which characteristics are straight lines .",
    "experimental evidence suggests that these methods can be also very efficient for other problems where the characteristics are `` largely '' straight .",
    "the number of necessary iterations is largely independent of @xmath4 and correlated with the number of times the characteristics `` switch directions '' ( i.e. , change from one directional quadrant to another ) inside @xmath60 .",
    "however , since the quadrants are defined relative to the grid orientation , the number of iterations will generally be grid - dependent .",
    "one frequently encountered argument is that , due to its @xmath6 computational complexity , the fast sweeping is more efficient than the fast marching , whose complexity is @xmath7 .",
    "however , this asymptotic complexity notation hides constant factors  including this not - easily - quantifiable ( and grid - orientation - dependant ) bound on the number of iterations needed in fast sweeping . as a result , whether the @xmath6 asymptotic complexity actually leads to any performance advantage on grids of realistic size is a highly problem - dependent question .",
    "extensive experimental comparisons of marching and sweeping approaches can be found in @xcite . even though such a comparison is not the main focus of the current paper , the performance of both methods",
    "is also tabulated for all examples in section [ s : experiments ] . on the grids we tested , we observe that the fast marching method usually performs better than the fast sweeping when the domain has a complicated geometry ( e.g. , shortest / quickest path computations in a maze ) or if the characteristic directions change often throughout the domain  the latter situation frequently arises in eikonal problems when the speed function @xmath9 is highly inhomogeneous .",
    "we note that the sweeping approach can be in principle useful for a much wider class of problems .",
    "for example , the method introduced in @xcite is applicable to problems with non - convex hamiltonians corresponding to differential games ; however , the amount of required artificial viscosity is strongly problem - dependent and the choice of consistently discretized boundary conditions can be complicated . sweeping algorithms for discontinuous galerkin finite element discretizations of the eikonal pde can be found in @xcite .",
    "the fast sweeping method performs particularly well on problems where the speed function @xmath9 is constant , since in this case the characteristics of the eikonal pde will be straight lines regardless of the boundary conditions .",
    "( e.g. , if @xmath125 , then the quickest path is a straight line to the nearest boundary point . ) as a result ,",
    "the domain consists of 4 subdomains , each with its own characteristic `` quadrant direction '' .",
    "even though these subdomains are generally not known in advance , it is natural to expect fast sweeping to converge in at most 4 iterations ( e.g. , if @xmath76 s characteristic comes from the se , then the same is true for all points immediately to se from @xmath76 ) .",
    "however , on the grid , the dependency graph can be more complicated ",
    "@xmath76 will depend on both its southern and eastern neighbors .",
    "the characteristic directions are changing continuously everywhere , except at the shocks .",
    "so , if @xmath76 is near a shock line , one of its neighbors might be in another subdomain , making additional sweeps occasionally necessary even for such simple problems ; see figure [ fig : more_than_4 ] for an illustration .    nevertheless , when @xmath9 is constant , the fast sweeping is usually more efficient than the fast marching regardless of the boundary conditions  an observation which is the basis for the hybrid methods introduced in the next section .",
    "[ rem : regular_fsm_update ] it might seem that the recomputation of @xmath126 from will generally require solving 4 quadratic equations to compare the updates from all 4 quadrants .",
    "however , the monotonicity property noted in remark [ rem : discr_properties ] guarantees that only one quadrant needs to be considered .",
    "e.g. , if @xmath127 then @xmath128 and the latter is irrelevant even if we are currently sweeping from ne .",
    "thus , the relevant quadrant can be always found by using @xmath129 and @xmath130 .",
    "we note that this shortcut is not directly applicable to discretizations on unstructured meshes nor for more general pdes .",
    "interestingly , alton and mitchell showed that the same shortcut can also be used with cartesian grid discretizations of hamilton - jacobi pdes with grid - aligned anisotropy @xcite .",
    "[ rem : locking_fsm ] one of the problems in this basic version of the fast sweeping method is the fact that the cpu time might be wasted to recompute @xmath126 even if none of @xmath76 s neighbors have changed since the last sweep . to address this , one natural modification is to introduce `` locking flags '' for individual gridpoints and to update the currently unlocked gridpoints only @xcite .",
    "briefly , all gridpoints but those immediately adjacent to @xmath29 start out as locked . when an unlocked gridpoint @xmath76 is processed during a sweep ,",
    "if @xmath75 changes , then all of its larger neighbors are unlocked .",
    "the gridpoint @xmath76 is then itself locked regardless of whether updating @xmath75 resulted in unlocking a neighbor .",
    "the above modification does not change the asymptotic complexity of the method nor the total number of sweeps needed for convergence . nevertheless , the extra time and memory required to maintain and update the locking flags are typically worthwhile since their use allows to decrease the amount of cpu - time wasted on parts of the domain , where the iterative process already produced the correct numerical solutions . in sections [ s : our_methods ] and [ s : experiments ] we will refer to this modified version as locking sweeping method ( lsm ) to distinguish it from the standard implementation of the fsm .",
    "ideas behind many label - correcting algorithms on graphs have also been applied to discretizations of eikonal pdes . here",
    "we aim to briefly highlight some of these connections .",
    "perhaps the first label - correcting methods developed for the eikonal pde were introduced by polymenakos , bertsekas , and tsitsiklis based on the logic of the discrete slf / lll algorithms @xcite . on the other hand ,",
    "bellman - ford is probably the simplest label - correcting approach and it has been recently re - invented by several numerical analysts working with eikonal and more general hamilton - jacobi - bellman pdes @xcite , @xcite , including implementations for massively parallel computer architectures @xcite .",
    "a recent paper by bak , mclaughlin , and renzi @xcite also introduces another `` 2-queues method '' essentially mimicking the logic of thresholding label - correcting algorithms on graphs .",
    "while such algorithms clearly have promise and some numerical comparisons of them with sweeping and marching techniques are already presented in the above references , more careful analysis and testing is required to determine the types of examples on which they are the most efficient .",
    "all of the above methods produce the exact same numerical solutions as fmm and fsm . in contrast , two of the three new methods introduced in section [ s : our_methods ] aim to gain efficiency even if it results in small additional errors .",
    "we know of only one prior numerical method for eikonal pdes with a similar trade - off : in @xcite a dial - like method is used with buckets of unjustified width @xmath131 for a discretization that is not @xmath131-causal .",
    "this introduces additional errors ( analyzed in @xcite ) , but decreases the method s running time .",
    "however , the fundamental idea behind our new two - scale methods is quite different , since we aim to exploit the geometric structure of the speed function .",
    "we present three new hybrid methods based on splitting the domain into a collection of non - overlapping rectangular `` cells '' and running the fast sweeping method on individual cells sequentially .",
    "the motivation for this decomposition is to break the problem into sub - problems , with @xmath9 nearly constant inside each cell .",
    "if the characteristics rarely change their quadrant - directions within a single cell , then a small number of sweeps should be sufficient on that cell .",
    "but to compute the value function correctly within each cell , the correct boundary conditions ( coming from the adjacent cells ) should be already available .",
    "in other words , we need to establish a causality - respecting order for processing the cells .",
    "the fast marching sweeping method ( fmsm ) uses the cell - ordering found by running the fast marching method on a coarser grid , while the heap - cell methods ( hcm and fhcm ) determine the cell - ordering dynamically , based on the value - updates on cell - boundaries .",
    "this algorithm uses a coarse grid and a fine grid .",
    "each `` coarse gridpoint '' is taken to be the center of a cell of `` fine gridpoints '' .",
    "( for simplicity , we will assume that the exit - set @xmath29 is directly representable by coarse gridpoints . )",
    "the fast marching is used on the coarse grid , and the acceptance - order of `` coarse gridpoints '' is recorded .",
    "the fast sweeping is then used on the corresponding cells in the same order .",
    "an additional speed - up is obtained , by running a fixed number of sweeps on each cell , based on the upwind directions determined on the coarse grid . before providing the details of our implementation , we introduce some relevant notation : + @xmath91 @xmath132 , the coarse grid .",
    "+ @xmath91 @xmath133 , the fine grid ( same as the grid used in fmm or fsm ) .",
    "+ @xmath91 @xmath134 , the set of coarse gridpoints discretizing the exit set @xmath29 .",
    "+ @xmath91 @xmath135 , the solution of the discretized equations on the coarse grid .",
    "+ @xmath91 @xmath136 , the temporary label of the coarse gridpoints .",
    "+ @xmath91 @xmath137 , the set of cells , whose centers correspond to coarse gridpoints .",
    "+ @xmath91 @xmath138 , the neighbors of cell @xmath139 ; i.e. , the cells that exist to the north , south , east , and west of @xmath139 . + ( the set @xmath138 may contain less than four elements if @xmath139 is a boundary cell . ) + @xmath91 @xmath140 , the fine grid neighbors of @xmath139 ; i.e. , @xmath141 + @xmath91 @xmath142 , a permutation on the coarse gridpoint indices .",
    "+ @xmath91 @xmath143 , the distance along the @xmath113-direction between two neighboring coarse gridpoint .",
    "+ assume for simplicity that @xmath144 .",
    "+ all the obvious analogs hold for the fine grid ( @xmath145 , etc ) .",
    "since fast marching will be used on the coarse grid only , the heap @xmath49 will contain coarse gridpoints only .",
    "part i : run fmm on @xmath146 ( see algorithm [ alg : fmm ] ) .",
    "build the ordering @xmath147 to reflect the acceptance - order on @xmath146 .",
    "part ii : fine grid initialization : @xmath148 @xmath149 define the fine - grid domain @xmath150 define the boundary condition as @xmath151 on @xmath152 and @xmath153 on @xmath154 perform modified fast sweeping ( see remark [ rem : sweeping_in_fmsm ] ) on @xmath155 using boundary conditions @xmath156 .",
    "[ rem : sweeping_in_fmsm ] the `` modified fast sweeping '' procedure applied to individual cells in the algorithm [ alg : fmsm ] follows the same idea as the fsm described in section [ ss : fs ] .",
    "for all the cells containing parts of @xmath29 ( i.e. , the ones whose centers are accepted _ in the initialization _ of the fmm on the coarse grid ) we use the fsm without any changes .",
    "for all the remaining cells , our implementation has 3 important distinctions from the algorithm [ alg : fsm ] :    1 .",
    "no initialization of the fine gridpoints within @xmath155 is needed since the entire fine grid is pre - initialized in advance .",
    "2 .   instead of looping through different sweeps until convergence , we use at most four sweeps and only in the directions found to be `` upwind '' on the coarse grid . as illustrated by figure [ fig : coarse_sweep_choice ] , the cells in @xmath138 whose centers were accepted prior to @xmath157 determine the sweep directions to be used on @xmath139 .",
    "when computing @xmath158 during the sweeping , we do not employ the procedure described in remark [ rem : regular_fsm_update ] to find the relevant quadrant .",
    "instead , we use `` sweep - directional updates '' ; e.g. , if the current sweeping direction is from the ne , we always use the update based on the northern and eastern neighboring fine gridpoints .",
    "the advantage is that we have already processed both of them within the same sweep .    before discussing the computational cost and accuracy consequences of these implementation choices ,",
    "we illustrate the algorithm on a specific example : a checkerboard domain with the speed function @xmath159 in white and @xmath160 in black checkers , and the exit set is a single point in the center of the domain see figure [ fig : checkers_fmsm ] ) .",
    "this example was considered in detail in @xcite ; the numerical results and the performance of our new methods on the related test problems are described in detail in section [ ss : checkers ] . as explained in remark [ rem : sweeping_in_fmsm].2 , we do not sweep until convergence on each cell ; e.g. , the sweeps for the cell # 1 in figure [ fig : checkers_fmsm ] will be from northwest and southwest , while the cell # 14 will be swept from northeast only .",
    "in @xcite we also illustrate the cell - acceptance order in fmsm for a checkerboard example similar to those in section [ ss : checkers ] .",
    "the resulting algorithm clearly introduces additional numerical errors  in all but the simplest examples , the fmsm s output is not the exact solution of the discretized system on @xmath161 .",
    "we identify three sources of additional errors : the fact that the coarse grid computation does not capture all cell interdependencies , and the two cell - sweeping modifications described in remark [ rem : sweeping_in_fmsm ] . of these ,",
    "the first one is by far the most important .",
    "focusing on the fine grid , we will say that the cell @xmath139 _ depends on _",
    "@xmath162 if there exists a gridpoint @xmath163 such that @xmath164 directly depends on @xmath165 for some gridpoint @xmath166 . in the limit , as @xmath167 , this means that @xmath139 depends on @xmath168 if there is a characteristic going from @xmath168 into @xmath139 ( i.e. , at least a part of @xmath139 s boundary shared with @xmath168 is _ inflow _ ) . for a specific speed function @xmath9 and a fixed cell - decomposition @xmath169 , a causal ordering of the cells need not exist at all .",
    "as shown in figure [ fig : cell_interdep ] , two cells may easily depend on each other .",
    "this situation arises even for problems where @xmath9 is constant on each cell ; see figure [ fig : checkers_computed ] .",
    "moreover , if the cell refinement is performed uniformly , such non - causal interdependencies will be present even as the cell size @xmath170 .",
    "this means that every algorithm processing each cell only once ( or even a fixed number of times ) will unavoidably introduce additional errors at least for some speed functions @xmath9 .",
    "one possible way around this problem is to use the characteristic s vacillations between @xmath139 to @xmath168 to determine the total number of times that these cells should be alternately processed with fsm .",
    "this idea is the basis for heap - cell methods described in the next section .",
    "however , for the fmsm we simply treat these `` approximate cell - causality '' errors as a price to pay for the higher computational efficiency . our numerical experiments with fmsm showed that , as @xmath170 , the effects due to the approximate cell - causality dominate the errors stemming from using a finite ( coarse - grid determined ) number of sweeps .",
    "i.e. , when the cells are sufficiently small , running fsm to convergence does not decrease the additional errors significantly , but does noticeably increase the computational cost .",
    "the computational savings due to our use of `` sweep - directional updates '' are more modest ( we simply avoid the necessity to examine / compare all neighbors of the updated node ) , but the numerical evidence indicates that it introduces only small additional errors and only near the shock lines , where @xmath171 is undefined . since characteristics do not emanate from shocks , the accuracy price of this modification is even more limited if the errors are measured in @xmath172 norm . in section",
    "[ s : experiments ] we show that on most of @xmath161 the cumulative additional errors in fmsm are typically much smaller than the discretization errors , provided @xmath173 is sufficiently small .",
    "the monotonicity property of the discretization ensures that the computed solution @xmath174 will always satisfy @xmath175 .",
    "the numerical evidence suggests that @xmath174 becomes closer to @xmath176 as @xmath173 decreases , though this process is not always monotone .",
    "the computational cost of part i is relatively small as long as @xmath177 however , if @xmath178 and @xmath4 are held constant while @xmath173 decreases , this results in @xmath179 , and the total computational cost of fmsm eventually increases . as of right now , we do not have any method for predicting the optimal @xmath173 for each specific example .",
    "such a criterion would be obviously useful for realistic applications of our hybrid methods , and we hope to address it in the future .",
    "the methods presented in this section also rely on the cell - decomposition @xmath180 , but do not use any coarse - level grid .",
    "thus , @xmath181 and we will omit the superscripts @xmath182 and @xmath183 with the exception of @xmath138 and @xmath140 .",
    "we will also use @xmath173 to denote the distance between the centers of two adjacent square cells . in",
    "what follows , we will also define  cell values \" to represent coarse - level information about cell dependencies . unlike in finite volume literature , here a  cell value \" is not necessarily synonymous with the average of a function over a cell .      to highlight the fundamental idea , we start with a simple `` generic '' version of a label - correcting method on cells .",
    "we maintain a list of cells to be updated , starting with the cells containing the exit set @xmath29 .",
    "while the list is non - empty , we choose a cell to remove from it , `` process '' that cell ( by any convergent eikonal - solver ) , and use the new grid values near the cell boundary to determine which neighboring cells should be added to the list .",
    "the criterion for adding cells to the list is illustrated in figure [ fig : cell_inflow_boundary ] .",
    "all other implementation details are summarized in algorithm [ alg : generic_lc_cells ] .",
    "cell initialization : add @xmath184 to the list @xmath49    fine grid initialization : @xmath185 @xmath50    main loop : remove a cell @xmath183 from the list @xmath49 . define a domain @xmath186 .",
    "define the boundary condition as @xmath187 on @xmath188 and @xmath189 on @xmath190 process @xmath183 by solving the eikonal on @xmath155 using boundary conditions @xmath156 .",
    "@xmath191 add @xmath184 to the list @xmath49 .",
    "it is easy to prove by induction that this method terminates in a finite number of steps ; in theorem [ thm : convergence ] we show that upon its termination @xmath192 on the entire grid @xmath66 , regardless of the specific eikonal - solver employed to process individual cells ( e.g. , fmm , fsm , lsm or any other method producing the exact solution to will do ) .",
    "we emphasize that the fact of convergence also does not depend on the specific selection criteria for the next cell to be removed from @xmath49 .",
    "however , even for a fixed cell - decomposition @xmath169 , the above choices will significantly influence the total number of list removals and the overall computational cost of the algorithm .",
    "one simple strategy is to implement @xmath49 as a queue , adding cells at the bottom and always removing from the top , thus mirroring the logic of bellman - ford algorithm . in practice",
    ", we found the version described in the next subsection to be more efficient .",
    "[ thm : convergence ] the generic cell - based label - correcting method converges to the exact solution of system .    first we describe notation and recall from section [ ss : fs ] the dependency digraph @xmath108 .",
    "@xmath91 we say @xmath51 _ depends on _",
    "@xmath27 if @xmath31 is used to compute @xmath110 ( see discussion of formulas and ) .",
    "@xmath91 @xmath193nodes in @xmath108 on which @xmath64 depends directly@xmath194 . for each node @xmath64 ,",
    "the set @xmath195 will have 0 , 1 , or 2 elements .",
    "if @xmath196 , then @xmath195 is empty .",
    "if a one - sided update was used to compute @xmath197 ( see formula ) , then there is only one element in @xmath195 .",
    "@xmath91 @xmath198 denotes the subgraph of @xmath108 that is reachable from the node @xmath64 .",
    "we define the cell transition distance @xmath199 cell@xmath200dist@xmath201 , + where cell@xmath200dist@xmath202 if both @xmath64 and @xmath27 are in the same cell and @xmath203 otherwise .",
    "note that in general @xmath204 , but in practice @xmath205 is typically much smaller . in the continuous limit @xmath206 is related to the number of times a characteristic that reaches @xmath64 crosses cell boundaries .",
    "@xmath91 @xmath207 .",
    "see figure [ fig : dependency_digraph ] for an illustration of @xmath198 split into @xmath208 .",
    "@xmath91 @xmath209 such that @xmath51 depends on @xmath210 , i.e. , the set of gridpoints in @xmath211 that depend on a gridpoint in a neighboring cell . note that @xmath212 .",
    "@xmath91 @xmath213 such that @xmath51 depends on @xmath210 , i.e. , the set of gridpoints in @xmath211 that influence a gridpoint in a neighboring cell .",
    "@xmath91 @xmath214 denotes any method that exactly solves the eikonal on @xmath155 ( see line 20 of algorithm [ alg : generic_lc_cells ] ) .",
    "recall that by the monotonicity property of the discretization , the temporary labels @xmath215 will always be greater than or equal to @xmath110 throughout algorithm [ alg : generic_lc_cells ] .",
    "moreover , once @xmath215 becomes equal to @xmath110 , this temporary label will not change in any subsequent applications of @xmath214 to the cell @xmath183 containing @xmath51 .",
    "the goal is to show that @xmath216 for all @xmath217 upon the termination of algorithm [ alg : generic_lc_cells ] .",
    "= [ draw , shape = circle , inner sep=0 mm , minimum size = 6 mm ]    \\(a ) at ( 0,3 ) ; ( b ) at ( 1,4.2 ) ; ( c ) at ( 2 , 3.6 ) ; ( d ) at ( 2,4.8 ) ; ( e ) at ( 3,4.2 ) ; ( f ) at ( 5,5 ) ; ( g ) at ( 6,2 ) ; ( h ) at ( 6.5,2.8 ) ; ( i ) at ( 6.5,1 ) ; ( j ) at ( 10,4 ) ; ( k ) at ( 9.5,2 ) ;    \\(q ) at ( 18.5,2.5 ) ; ( l ) at ( 17.5,4 ) ; ( m ) at ( 17,1.5 ) ;    in a , b , c , d , e , f , g , h , i , j , k , l , m , q ( ) circle ( .15 cm ) ;    \\(a ) edge ( b ) ( a ) edge ( g ) ( b ) edge ( c ) ( b ) edge ( d ) ( d ) edge ( e ) ( c ) edge ( e ) ( d ) edge ( f ) ( e ) edge ( f ) ( g ) edge ( h ) ( g ) edge ( i ) ( c ) edge ( j )",
    "( f ) edge ( j ) ( f ) edge ( h ) ( h ) edge ( k ) ( i ) edge ( k ) ;    \\(j ) edge ( 12.5,5 ) ( j ) edge ( 12.5,3 ) ( k ) edge ( 12.5,1 )    ( 15.3,5 ) edge ( l ) ( 15.3,3 ) edge ( l ) ( 15.3,1 ) edge ( m ) ( l ) edge ( q ) ( m ) edge ( q ) ;    ( 2,6 ) node@xmath218 ; ( 6,6 ) node@xmath219 ; ( 10,6 ) node@xmath220 ; ( 18,6 ) node@xmath221 ;    ( 4,6)(4,0 ) ; ( 8,6)(8,0 ) ; ( 12,6)(12,0 ) ; ( 16.5,6)(16.5,0 ) ;    ( 13.3,3 ) circle(.05 cm ) ; ( 13.8,3 ) circle(.05 cm ) ; ( 14.3,3 ) circle(.05 cm ) ;    ( 13.3,5 ) circle(.05 cm ) ; ( 13.8,5 ) circle(.05 cm ) ; ( 14.3,5 ) circle(.05 cm ) ;    ( 13.3,1 ) circle(.05 cm ) ; ( 13.8,1 ) circle(.05 cm ) ; ( 14.3,1 ) circle(.05 cm ) ;    to prove convergence we will use induction on @xmath222 .",
    "first , consider @xmath223 and note that every cell @xmath183 containing some part of @xmath221 is put in @xmath49 at the time of the cell initialization step of the algorithm .",
    "when @xmath183 is removed from @xmath49 and @xmath214 is applied to it , every @xmath224 will obtain its final value @xmath225 because @xmath198 contains no gridpoints in other cells by the definition of @xmath221 .",
    "now suppose all @xmath226 already have @xmath225 for all @xmath227 .",
    "we claim that : 1 ) if a cell @xmath183 contains any @xmath228 such that @xmath229 , then this cell is guaranteed to be in @xmath49 at the point in the algorithm when the last @xmath230 receives its final update .",
    "\\2 ) the next time @xmath214 is applied to @xmath183 , @xmath231 will become equal to @xmath197 for all @xmath232 .    to prove 1 ) , suppose @xmath233 and note that there exist @xmath234 and @xmath235 with @xmath236 for some neighboring cell @xmath237 .",
    "indeed , if each gridpoint @xmath64 @xmath238 @xmath239 were to depend only on those in @xmath218 ( gridpoints within the same cell ) and/or those in @xmath240 for @xmath241 , this would contradict @xmath228 ( it is not possible for @xmath242 ; see figure [ fig : dependency_digraph ] ) . at the time the _ last such _",
    "@xmath27 receives its final update , we will have @xmath243 since @xmath235 .",
    "thus , @xmath183 is added to @xmath49 ( if not already there ) as a result of the add criterion in algorithm [ alg : generic_lc_cells ] .    to prove 2 )",
    ", we simply note that all nodes in @xmath244 will already have correct values at this point .",
    "[ rem : subgraph_lc_algorithm ] we note that the same ideas are certainly applicable to finding shortest paths on graphs .",
    "the algorithm [ alg : generic_lc ] can be similarly modified using a collection of non - overlapping subgraphs instead of cells , but so far we were unable to find any description of this approach in the literature .      to ensure the efficiency of cell - level label - correcting algorithms",
    ", it is important to have the `` influential '' cells ( on which most others depend ) processed as early as possible .",
    "once the algorithm produces correct solution @xmath192 on those cells , they will never enter the list again , and their neighboring cells will have correct boundary conditions at least on a part of their boundary . the same logic can be applied repeatedly by always selecting for removal the most `` influential '' cells currently on the list .",
    "we introduce the concept of `` cell values '' @xmath245 to estimate the likelihood of that cell influencing others ( the smaller is @xmath246 , the more likely is @xmath184 to influence subsequent computations in other cells , and the higher is its priority of removal from the list ) .",
    "in fast marching - sweeping method of section [ ss : fmsm ] , the cell values were essentially defined by running fmm on the coarse grid .",
    "that approach is not very suitable here , since each cell @xmath184 might enter the list more than once and it is important to re - evaluate @xmath246 each time this happens .",
    "instead , we define and update @xmath246 using the boundary values in the adjacent cells , and modify algorithm [ alg : generic_lc_cells ] to use the cell values as follows :    1 .",
    "amend the cell initialization to set @xmath247 2 .   always remove and process the cell with the smallest value currently on the list .",
    "efficient implementation requires maintaining @xmath49 as a heap - sort data structure  hence the name of `` heap - cell method '' ( hcm ) for the resulting algorithm .",
    "3 .   after solving the eikonal on @xmath183 ,",
    "update the cell values for all @xmath248 ( including those already in @xmath49 ) .",
    "let @xmath249 be a unit vector pointing from the center of @xmath183 in the direction of @xmath184 s center and suppose that @xmath27 has the largest current value among the gridpoints inside @xmath183 but adjacent to @xmath184 ; i.e. , @xmath250 .",
    ". then @xmath252    [ rem : cell_value_updates ] we note that , in the original dijkstra s and bellman - ford methods on graphs , a neighboring node s temporary label is updated _ before _ that node is added to @xmath49 . in the heap - cell method , the cell value is also updated before adding that cell to the list , but the grid values within that cell are updated _ after _ it is removed from @xmath49 .",
    "regardless of the method used to compute cell values , they can only provide an estimate of the dependency structure . as explained in section [ ss : fmsm ] , a causal cell - ordering need not exist for a fixed @xmath169 and a general speed functions @xmath9 .",
    "thus , @xmath253 does not exclude the possibility of @xmath184 depending on @xmath139 , and we do not use cell values to decide which neighboring cells to add to the list  this is still done based on the cell boundary data ; see algorithm [ alg : generic_lc_cells ] . as a result ,",
    "the fact of convergence of such cell - level methods does not depend on the particular heuristic used to define cell values .",
    "there are certainly many reasonable alternatives to formula ( e.g. , a more aggressive / optimistic version can instead select @xmath254 on the boundary ; an average value of @xmath9 on @xmath184 could also be used here ; or the distance to travel could be measured from @xmath27 to the center of @xmath184 , etc ) .",
    "empirically , formula results in smaller computational cost than the mentioned alternatives and it was therefore used in our implementation .",
    "[ rem : slf_cells ] the cell - values are useful even if @xmath49 is implemented as a queue and the cells are always removed from the top .",
    "indeed , @xmath246 can still be used to decide whether @xmath184 should be added at the top or at the bottom of @xmath49 .",
    "this is the slf / lll strategy previously used to solve the eikonal pde on the grid - level ( i.e. , without any cells ) by polymenakos , bertsekas , and tsitsiklis @xcite .",
    "we have also implemented this strategy and found it to be fairly good , but on average less efficient than the hcm described above .",
    "( the performance comparison is omitted to save space . )",
    "the intuitive reason is that the slf / lll is based on mimicking the logic of dijkstra s method , but without the expensive heap - sort data structures .",
    "however , when @xmath255 , the cost of maintaining the heap is much smaller than the cost of occasionally removing / processing less influential cells from @xmath49 .    to complete our description of hcm",
    ", we need to specify how the eikonal pde is solved on individual cells .",
    "since the key idea behind our hybrid methods is to take advantage of the good performance of sweeping methods when the speed is more or less constant , we follow the same idea as the fsm described in section [ ss : fs ] , but with the following important distinctions from the basic version of algorithm [ alg : fsm ] :    1 .",
    "no initialization of gridpoint values @xmath256 is needed within @xmath155  indeed , the initialization is carried out on the full grid at the very beginning and if @xmath183 is removed from @xmath49 more than once , the availability of previously computed @xmath256 s might only speed up the convergence on @xmath183 . here",
    "we take advantage of the comparison principle for the eikonal pde : the viscosity solution can not increase anywhere inside the cell in response to decreasing the cell - boundary values .",
    "we use the locking sweeping version described in remark [ rem : locking_fsm ] .",
    "3 .   the standard fsm and lsm loop through the four sweep directions always in the same order . in our implementation of hcm",
    ", we choose a different order for the first four sweeps to ensure that the `` preferred sweep directions '' ( determined for each cell individually ) are used before all others .",
    "for all other sweeps after the first four , we revert to the standard loop defined in algorithm [ alg : fsm_order ] . of course ,",
    "as in the standard fsm , the sweeps only continue as long as grid values keep changing somewhere inside the cell . the procedure for determining preferred sweep directions",
    "is explained in remark [ rem : hcm_preferred_sweeps ] .",
    "[ rem : hcm_preferred_sweeps ] recall that in fmsm , the coarse grid information was used to determine the sweep directions to use on each cell ; see remark [ rem : sweeping_in_fmsm ] and figure [ fig : coarse_sweep_choice ] . similarly , in hcm we use the neighboring cells of @xmath184 that were found to have newly changed @xmath184-inflow boundary since the last time @xmath184 was added to @xmath49 .",
    "we maintain four `` directional flags ''  boolean variables initialized to false and representing all possible preferred sweeping directions  for each cell @xmath184 currently in @xmath49 .",
    "when a neighboring cell @xmath257 is processed / updated and is found to influence @xmath184 , this causes two of @xmath184 s directional flags to be set to true . to illustrate , supposing that @xmath257 is a currently - processed - western - neighbor of @xmath184 ( as in figure [ fig : cell_inflow_boundary ] ) .",
    "if the value of @xmath258 has just changed and @xmath259 , then both relevant preferred direction flags in @xmath184 ( i.e. , both nw and sw ) will be raised .",
    "once @xmath184 is removed from @xmath49 and processed , its directional flags are reset to false .    as explained in section [ sss : fhcm ] , a better procedure for setting these directional flags could be built based on fine - grid information on the cell - boundary . however , we emphasize that the procedure for determining preferred directions will not influence the ultimate output of hcm ( since we will sweep on @xmath184 until convergence every time we remove it from @xmath49 ) , though such preferred directions are usually useful in reducing the number of sweeps needed for convergence .",
    "the performance and accuracy data in section [ s : experiments ] shows that , for sufficiently small @xmath67 and @xmath173 , hcm often outperforms both fmm and fsm on a variety of examples , including those with piecewise continuous speed function @xmath9 .",
    "this is largely due to the fact that the average number of times a cell enters the heap tends to 1 as @xmath170 .",
    "we also implement an accelerated version of hcm by using the following modifications :    1 .",
    "each newly removed cell is processed using at most four iterations ",
    "i.e. , it is only swept once in each of the preferred directions instead of continuing to iterate until convergence .",
    "directional flags in all cells containing parts of @xmath29 are initialized to true .",
    "3 .   to further speed up the process",
    ", we use a `` monotonicity check '' on cell - boundary data to further restrict the preferred sweeping directions . for concreteness ,",
    "assume that @xmath257 and @xmath184 are related as in figure [ fig : cell_inflow_boundary ] .",
    "if the grid values in @xmath260 are monotone non - decreasing from north to south , we set @xmath184 s nw preferred direction flag to true ; if those grid values are monotone non - increasing we flag sw ; otherwise we flag both nw and sw .",
    "( in contrast , both hcm and fmsm are always using two sweeps in this situation ; see figure [ fig : coarse_sweep_choice ] and remark [ rem : hcm_preferred_sweeps ] . )",
    "we note that the set @xmath261 already had to be examined to compute an update to @xmath246 and the above monotonicity check can be performed simultaneously .    the resulting fast heap - cell method ( fhcm )",
    "is significantly faster than hcm , but at the cost of introducing additional errors ( see section [ s : experiments ] ) .",
    "the monotonicity checks result in a considerable increase in performance since , for small enough @xmath173 , most cell boundaries become monotone .",
    "however , generalizing this procedure to higher dimensional cells is less straightforward . for this reason we decided against using monotonicity checks in our implementation of hcm .",
    "fhcm is summarized in algorithm [ alg : fhcm ] .",
    "cell initialization : add @xmath184 to the list @xmath49 ; tag all four sweeping directions of @xmath184 as _ true _ ; assign a cell value @xmath262 ; assign a cell value @xmath263 ;    fine grid initialization : @xmath264 @xmath265    remove cell at the top of @xmath49 ; perform non - directional fast sweeping within the cell according to its directions marked _ true _ , then set all directions to _ false _ and : add the cell @xmath184 containing @xmath266 onto @xmath49 if not already there . update the planned sweeping directions for @xmath184 based on the location of the cell containing @xmath267 ( more about this later ) .",
    "( @xmath268 ) @xmath269    as an illustration , we consider another @xmath270 checkerboard example ( this time with a fast checker in the center ) and show the contents of the heap in figure [ fig : fhcm_progress ] .    here",
    "we take the cells coinciding with checkers ; finer cell - decompositions are numerically tested in section [ ss : checkers ] .",
    "the arrows indicate flagged sweeping directions for each cell , and the smaller font is used to show the current cell values . similarly to dijkstra s method and fmm , the heap data structure is implemented as an array ; the bold numbers represent each cell s index in this array . in the",
    "beginning the central cell is the only one in @xmath49 ; once it is removed , it adds to @xmath49 all four of its neighbors , all of them with the same cell value .",
    "once the first of these ( to the west of the center ) is removed , it adds three more neighbors ( but not the central cell since there are no characteristics passing through the former into the latter ) .",
    "this is similar to the execution path of fmsm , however , with heap - cell methods the cells may generally enter the heap more than once .",
    "thus , additional errors introduced by fhcm are usually smaller than those in fmsm .",
    "the monotonicity checks result in a considerable increase in performance since , for small enough @xmath173 , most cell boundaries become monotone .",
    "however , generalizing this procedure to higher dimensional cells is less straightforward . for this reason we decided against using monotonicity checks in our implementation of hcm .",
    "the resulting fast heap - cell method ( fhcm ) is significantly faster than hcm , but at the cost of introducing additional errors .",
    "not surprisingly , these additional errors are usually much smaller than those in fmsm ( see section [ s : experiments ] ) , since in fhcm the cells are allowed to enter the heap more than once .    in @xcite",
    "we also illustrate the changing cell values , sweeping directions , and positions within the heap - sort data structure under fhcm for a checkerboard example .",
    "[ rem : weberdevirbronsbronskimmelhcm ] to conclude the discussion of our heap - cell methods , we briefly describe a recent algorithm with many similar features , but very different goals and implementation details .",
    "the `` raster scan algorithm on a multi - chart geometry image '' was introduced in @xcite for geodesic distance computations on parametric surfaces .",
    "such surfaces are frequently represented by an atlas of overlapping charts , where each chart has its own parametric representation and grid resolution ( depending on the detail level of the underlying surface ) .",
    "the computational subdomains corresponding to charts are typically large and the `` raster scan algorithm '' ( similar to the traditional fsm with a fixed ordering of sweep directions ) is used to parallelize the computations within each chart .",
    "the heuristically defined chart values are employed to decide which chart will be raster - scanned next .",
    "aside from the difference in heuristic formulas used to compute chart values , in @xcite the emphasis is on providing the most efficient implementation of raster scans on each chart ( particularly for massively parallel architectures ) . the use of several large , parametrization / resolution - defined charts , typically results in complicated chart interdependencies since most chart boundaries are generally both inflow and outflow . moreover , if this method is applied to any eikonal problems beyond the geodesic distance computations , the monotonicity of characteristic directions will generally not hold and a high number of sweeps may be needed on each chart . in contrast , our focus is on reducing the cell interdependencies and on the most efficient cell ordering : when @xmath173 is sufficiently small , most cell boundaries are either completely inflow or outflow , defining a causal relationship among the cells .",
    "relatively small cell sizes also ensure that @xmath9 is approximately constant , the characteristics are approximately straight lines , and only a small number of sweeps is needed on each cell .",
    "finally , the cell orderings are also useful to accelerate the convergence within each cell by altering the sweep - ordering based on the location of upwinding cells ( as in fmsm and hcm ) or based on fine - grid cell - boundary data ( as in fhcm ) .",
    "the hybrid methods introduced here show that causality - respecting domain decompositions can accelerate even serial algorithms on single processor machines .",
    "all examples were computed on a unit square @xmath271 \\times [ 0,1]$ ] domain with zero boundary conditions @xmath272 on the exit set @xmath29 ( defined separately in each case ) . in each example that follows",
    "we have fixed the grid size @xmath273 , and only the cell size @xmath173 is varied . since analytic formulas for viscosity solutions are typically unavailable , we have used the fast marching method on a much finer grid ( of size @xmath274 ) to obtain the `` ground truth '' used to evaluate the errors in all the other methods .",
    "suppose @xmath275 is the absolute value of the error - due - to - discretization at gridpoint @xmath27 ( i.e. , the error produced by fsm or fmm when directly executed on the fine grid ) , and suppose @xmath276 is the absolute value of the error committed by one of the new hybrid methods at the same @xmath27 . define the set @xmath277 and let @xmath278 be the number of elements in it .",
    "( we verified that @xmath279 in all computational experiments . ) to analyze the `` additional errors '' introduced by fmsm and fhcm , we report + @xmath91 the _ maximum error ratio _ defined as @xmath280 , where the maximum is taken over @xmath281 ; + @xmath91 the _ average error ratio _ defined as @xmath282 , where the sum is taken over @xmath281 ; + @xmath91 the _ ratio of maximum errors _ defined as @xmath283 . + @xmath284 is relevant since on parts of the domain where @xmath275 s are very small , additional errors might result in large @xmath285 even if @xmath276 s are quite small compared to the @xmath286 norm of discretization errors . in the ideal scenario , with no additional errors , @xmath287    for the heap - cell algorithms we also report + @xmath91 _ avhr _ , the average number of heap removals per cell , + @xmath91 _ avs _ , the average number of sweeps per cell , and + @xmath91 _ mon % _ , the percentage of times that the `` cell - boundary monotonicity '' check was successful .",
    "+ finally , we report the number of sweeps needed in fsm and lsm for each problem .",
    "[ rem : fair_comparison ] performance analysis of competing numerical methods is an obviously delicate undertaking since the implementation details as well as the choice of test problems might affect the outcome . we have made every effort to select representative examples highlighting advantages and disadvantages of all approaches .",
    "all tests were performed on an amd turion 2ghz dual - core processor with 3 gb ram .",
    "only one core was used to perform all tests .",
    "our c++ implementations were carefully checked for the efficiency of data structures and algorithms , but we did not conduct any additional performance tuning or assembly - level optimizations .",
    "our code was compiled using the g++ compiler version 3.4.2 with compiler options -o0 -finline .",
    "we have also preformed all tests with the full compiler optimization ( i.e. , with -o3 ) ; the results were qualitatively similar , but we opted to report the performance data for the unoptimized version to make the comparison as compiler - independent as possible . for each method ,",
    "all memory allocations ( for grids and heap data structures ) were not timed ; the reported cpu times include the time needed to initialize the relevant data structures and run the corresponding algorithm .",
    "we also note that the speed function @xmath8 was computed by a separate function call whenever needed , rather than precomputed and stored for every gridpoint during initialization . all cpu - times",
    "are reported in seconds for the fast marching ( fmm ) , the standard fast sweeping ( fsm ) , the locking sweeping ( lsm ) , and the three new hybrid methods ( hcm , fhcm , and fmsm ) .",
    "the following examples model optimal motion through a maze with slowly permeable barriers .",
    "speed function @xmath288 is defined by a `` comb maze '' : @xmath159 outside and @xmath289 inside the barriers ; see figure [ fig : comb_maze ] . the exit set consists of the origin : @xmath290 .",
    "the computational cost of sweeping methods is roughly proportional to the number of barriers , while fmm is only minimally influenced by this .",
    "the same good property is inherited by the hybrid methods introduced in this paper .",
    "the first example with 4 barriers uses barrier walls aligned with cell boundaries and all hybrid methods easily outperform the fastest of the previous methods ( lsm ) ; see table [ tab:4_comb ] .",
    ".performance / convergence results for a 4 wall comb maze example . [ cols=\"^,^,^,^,^,^,^\",options=\"header \" , ]     [ tab : sinu_2_gbc ]",
    "we have introduced three new efficient hybrid methods for eikonal equations . using a splitting of the domain into a number of cells ( with the speed function approximately constant on each of them ) ,",
    "our methods employ sweeping methods on individual cells with the order of cell - processing and the direction of sweeps determined by a marching - like procedure on a coarser scale .",
    "such techniques may introduce additional errors to attain higher computational efficiency . of these new methods",
    "fmsm is generally the fastest and somewhat easier to implement , while fhcm introduces smaller additional errors , and hcm is usually the slowest of the three but provably converges to the exact solutions .",
    "the numerical evidence presented in this paper strongly suggests that + @xmath91 when @xmath67 and @xmath173 are sufficiently small , additional errors introduced by fmsm and fhcm are negligible compared to those already present due to discretization ; + @xmath91 for the right @xmath291-combinations , our new hybrid algorithms significantly outperform the prior fast methods ( fmm , fsm , and lsm ) .",
    "+ of course , the rate of change of the speed function @xmath9 determines the suitable size of cells and our methods are particularly efficient for the examples where @xmath9 is piecewise constant .",
    "all of the examples considered here used predetermined uniform cell - sizes . from a practitioner s point of view",
    ", the value of the proposed methods will greatly increase once we develop bounds and estimates for the additional errors in both fmsm and fhcm .",
    "such estimates would be also very useful for the computational costs of all three hybrid methods on a given cell - decomposition .",
    "in the future , we intend to automate the choice of cell - sizes ( based on the speed function and user - specified tolerances for additional errors ) and further relax the requirement that all cells need to be uniform .",
    "a generalization of this approach to cell - subdivision of unstructured meshes will also be valuable .",
    "we expect the extensions of these techniques to higher dimensional problems to be useful for many applications and relatively straight - forward  especially for fmsm and hcm .",
    "a higher dimensional version of the `` cell boundary monotonicity check '' will be needed to extend fhcm .",
    "other obvious directions for future work include extensions to higher - order accurate discretizations and parallelizable cell - level numerical methods for eikonal equations . more generally , we hope that the ideas presented here can serve as a basis for causal domain decomposition and efficient two - scale methods for other static nonlinear pdes , including those arising in anisotropic optimal control and differential games .                                    e. cristiani and m. falcone , _ a characteristics driven fast marching method for the eikonal equation _",
    ", in `` numerical mathematics and advanced applications '' , pp .",
    "695 - 702 , proceedings of enumath 2007 , graz , austria , september 2007 .",
    "m. falcone , _ the minimum time problem and its applications to front propagation _ , in `` motion by mean curvature and related topics '' , proceedings of the international conference at trento , 1992 , walter de gruyter , new york , 1994 .",
    "c. rasch and t. satzger , _",
    "remarks on the @xmath292 implementation of the fast marching method _ , i m a j. numer . anal .",
    "( 2009 ) 29 ( 3 ) : pp .",
    "806 - 813 .",
    "rouy , e. & tourin , a. , _ a viscosity solutions approach to shape - from - shading _ , siam j. num .",
    ", 29 , 3 , pp .",
    "867 - 884 , 1992 .",
    "zhang , s. chen , f. li , h .- k .",
    "zhao and c .- w .",
    "shu , _ uniformly accurate discontinuous galerkin fast sweeping methods for eikonal equations _ , siam j. on sci .",
    ", to appear , 2011 .",
    "zhao , h.k . , _ fast sweeping method for eikonal equations _ , math . comp .",
    ", 74 , pp .",
    "603 - 627 , 2005 ."
  ],
  "abstract_text": [
    "<S> fast marching and fast sweeping are the two most commonly used methods for solving the eikonal equation . </S>",
    "<S> each of these methods performs best on a different set of problems . </S>",
    "<S> fast sweeping , for example , will outperform fast marching on problems where the characteristics are largely straight lines . </S>",
    "<S> fast marching , on the other hand , is usually more efficient than fast sweeping on problems where characteristics frequently change their directions and on domains with complicated geometry . in this paper </S>",
    "<S> we explore the possibility of combining the best features of both of these approaches , by using marching on a coarser scale and sweeping on a finer scale . </S>",
    "<S> we present three new hybrid methods based on this idea and illustrate their properties on several numerical examples with continuous and piecewise - constant speed functions in @xmath0 . </S>"
  ]
}