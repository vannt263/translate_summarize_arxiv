{
  "article_text": [
    "the field of solar system dynamics has a timeline of discoveries that is related to the computational power available ( e.g. , @xcite ) . as computational power",
    "has increased over time , so to has our ability to more accurately simulate incrementally more complex systems via the inclusion of more sophisticated physics or simply a greater number of particles .",
    "the interaction between planets and planetesimals subsequent to formation is a well posed n - body problem but displays remarkable complexity even in the absence of collisions , including resonance capture , planetary migration , and heating and scattering of planetesimals . in this paper",
    "we attempt to more accurately simulate this system in parallel by using the increased computational power and device memory recently made more accessible on video graphics cards .",
    "our code is written for compute unified device architecture ( cuda ) enabled devices .",
    "cuda , implemented on nvidia graphics devices , is a gpgpu ( general - purpose computing on graphics processing units ) architecture that allows a programmer to use c - like programming language with extensions to code algorithms for execution on the graphics processing unit .",
    "it provides a development environment and application programming interfaces ( apis ) for cuda enabled gpus specifically tailored for parallel compute purposes .",
    "it achieves this by exposing the hardware to the developer through a memory management model and thread hierarchy that encourages both constant streaming of data as well as parallelization",
    ". we will discuss porting the code to other parallel computing environments below .",
    "symplectic integrators are useful for planetary system integrations because they preserve an energy ( or hamiltonian ) that is close to the real value , setting a bound on the energy error during long integrations @xcite .",
    "see @xcite for reviews of symplectic integrators .",
    "we have modified the second order symplectic integrators introduced by @xcite , and created an integrator that runs in parallel on a gpu .",
    "we have chosen the democratic heliocentric method @xcite because the force from the central body is separated from the integration of all the remaining particles and the coordinates do not depend on the order of the particles .    following a canonical transformation , in heliocentric coordinates and barycentric momenta @xcite the hamiltonian of the system",
    "can be written @xmath0 where @xmath1 is a linear drift term and @xmath2 is the barycentric momenta of particle @xmath3 .",
    "here @xmath4 is the central particle mass .",
    "the second term @xmath5 is the sum of keplerian hamiltonians for all particles with respect to the central body , @xmath6 where @xmath7 are the heliocentric coordinates and are conjugate to the barycentric momenta . here",
    "@xmath8 is the mass of the @xmath3-th particle and @xmath9 is the gravitational constant .",
    "the interaction term contains all gravitational interaction terms except those to the central body , @xmath10    a second order integrator advances with timestep @xmath11 using evolution operators ( e.g. , @xcite ) @xmath12 the keplerian advance requires order @xmath13 computations but interaction term requires order @xmath14 computations .",
    "however , encounter detection is most naturally done during the keplerian step and requires @xmath15 computations if all particle pairs are searched for close encounters .",
    "if there is no search for close encounters then the keplerian and interaction steps can be switched @xcite reducing the number of computations .",
    "each of the evolution operators above can be evaluated in parallel .",
    "the drift evolution operator requires computation of the sum of the momenta .",
    "we have implemented this using a parallel reduction sum parallel primitive algorithm available with the nvidia cuda software development kit ( sdk ) 1.1 that is similar to the parallel prefix sum ( scan ) algorithm @xcite .    the keplerian step is implemented by computing @xmath16 and @xmath17 functions using the universal differential kepler s equation @xcite so that bound and unbound particles can both be integrated with the same routine ( see appendix ) .",
    "the keplerian evolution step is also done on the gpu with each thread computing the evolution for a separate particle .",
    "kepler s equation is usually solved iteratively until a precision limit is achieved .",
    "however , the laguerre algorithm @xcite ( also see chapter 2 by @xcite ) converges more rapidly than a newton method and moreover converges regardless of the starting approximation .",
    "we have found that the routine converges to the double precision limit ( of order @xmath18 ) in fewer than 6 iterations independent of initial condition .",
    "see the appendix for the procedure .",
    "the interaction terms are computed on the gpu with all @xmath14 force pairs evaluated explicitly in parallel .",
    "the algorithm is based on the algorithm described by @xcite .",
    "this algorithm takes advantage of fast shared memory on board the gpu to simultaneously compute all forces in a @xmath19 tile of particle positions , where @xmath20 is the number of threads chosen for the computation ( typically 128 or 256 ) .",
    "the total energy is evaluated with a kernel explicitly evaluating all @xmath14 pair potential energy terms , similar to that calculating all @xmath14 forces .",
    "after the change to heliocentric / barycentric coordinates , the position of the first coordinate corresponds to the center of mass and center of momentum .",
    "the trajectory of this particle does not need to be integrated .",
    "however , it is convenient to calculate the energy using all pair interactions including the central mass .",
    "the interaction term in the keplerian part of the hamiltonian can be computed at the same times as @xmath21 if @xmath22 is set to zero .",
    "consequently we set @xmath23 at the beginning of the computation .",
    "this is equivalent to working in the center of mass and momentum reference frame . because we would like to be able to quickly check the total energy , we have chosen to keep the first particle corresponding to the center of mass and momentum as the first element in the position and velocity arrays . during computation of",
    "@xmath21 we set @xmath4 to zero so that force terms from the first particle are not computed .",
    "these are already taken into account in the evolution term corresponding to @xmath5 .",
    "the mass is restored during the energy sum computation as all potential energy terms must be calculated explicitly .",
    "the particle positions and velocities are kept on the gpu during the computation and transferred back into host or cpu accessible memory to output data files .",
    "an additional vector of length equal to the number of particles is allocated in global memory on the device to compute the momentum sums used in the drift step computation .",
    "we limit the number of host to device and device to host memory transfers by persistently maintaining position and velocity information for all particles on the device because frequent data transfer between the cpu and gpu will reduce overall performance of the code .",
    "the maximum theoretical throughput of pci - express 2.0 16x bus technology , the interlink between the cpu and gpu on intel processor based motherboards , is 8 gb / s with a significant latency penalty .",
    "this sets an upper limit of the total number of particles to @xmath24 based on several gigabytes of gpu memory , but computation time on a single gpu for this number of particles would make such simulations unrealistic .",
    "while the transfer data rate limitations between the host and device are important , use of global device memory should also be monitored carefully .",
    "depending on memory clock speed , width of the memory interface and memory type , theoretical maximum global memory transfer throughputs are currently @xmath25150 gb / s .",
    "this is the case for the gt200(b ) architecture quadro fx 5800 and geforce gtx280/285 gpus in our cluster , which range from 140 to 160 gb / s respectively . despite enjoying a significantly greater data transfer rate compared to that of the pci - express interlink ,",
    "the latency penalty of device memory is also quite large - from 400 to 800 cycles .",
    "therefore , explicit global memory access should be limited whenever possible . shared memory , which is basically",
    "a user controlled cache that can be accessed by all cores on an individual multiprocessor , can be used to reduce this penalty . as described above , the interaction and energy kernels leverage shared memory and benefit greatly . by streaming information from global memory to shared memory , we are able to hide the latency of global memory , further increasing the computation speed . even when all global memory transactions of a warp issued to a multiprocessor can be coalesced ( executed simultaneously ) , the latency is at least the aforementioned several hundred cycles .",
    "uncoalesced global memory access can be even more costly .",
    "however , it is not always possible to write an algorithm to access shared memory in a sensible manner , and limitations on the amount of shared memory space may force direct global memory access regardless .",
    "this is the case for our gpu implementation of the solver for the universal differential kepler s equation .",
    "though the maximum number of threads on the video cards we used was 512 for gt200 architecture cards and 1024 for gf100 architecture cards , we found that restrictions on the number of available registers on each multiprocessor limited all of the major kernels to 128 or 256 threads per block .",
    "a more detailed review of nvidia gpu hardware and programming techniques can be found in the cuda programming guide .",
    "our first parallel symplectic integrator necessarily ran in single precision @xcite as graphics cards were not until recently capable of carrying out computations in double precision .",
    "our current implementation uses double precision for all vectors allocated on both gpu and cpu .",
    "a corrector has been implemented allowing accelerations to be computed in single precision but using double precision accuracy for the particle separations @xcite .",
    "if we wrote a similar corrector we could run our interaction step in single precision ( but with nearly double precision accuracy ) achieving a potential speed up of a factor of roughly 8 on cuda 1.3 compatible devices .",
    "the newest cuda 2.0 compatible devices have superior double precision capabilities , limiting this potential speed up to a factor of 2 . additionally , it would be more difficult to create a corrector for the keplerian evolution step , consequently the current version of the integrator is exclusively in double precision .",
    "we work in a lengthscale in units of the outermost planet s initial semi - major axis and with a timescale such that @xmath26 where @xmath27 is the mass of the central star . in these units the innermost planet",
    "s orbital period is @xmath28 , however we often describe time in units of the innermost planet s initial orbital period .",
    "symplectic integrators can not reduce the timestep during close encounters without shifting the hamiltonian integrated and destroying the symplectic properties of the integrator ( e.g. , @xcite ) . during a close encounter one of the interaction terms in @xmath21",
    "becomes large compared to the keplerian term , @xmath5 .",
    "consequently , the symplectic integrator described above becomes inaccurate when two massive objects undergo a close approach . to preserve the symplectic nature of the integrator",
    "@xcite used an operator splitting approach and decomposed the potential into a set of functions with increasingly small cutoff radii .",
    "@xcite instead used a transition function which because of its relative simplicity ( and reduced numbers of computations ) we have adopted here .",
    "a transition function can be used to move the strong interaction terms from the interaction hamiltonian to the keplerian one so that the entire hamiltonian is preserved @xcite .",
    "the keplerian hamiltonian becomes @xmath29 and the interaction hamiltonian becomes @xmath30 where @xmath31 and @xmath32 is a transition or change - over function that is zero when the distance between two objects is small and 1 when they are large , thus @xmath33 .",
    "the transition function we use is @xmath34 with @xmath35 the parameter @xmath36 becomes zero at @xmath37 where @xmath38 is a critical radius .",
    "the above transition function is similar to that chosen by @xcite but we use a sine function instead of a polynomial function as sine is computed quickly on graphics card ( estimated at 4 or 5 floating point computations rather than the 8 required for the polynomial function used by @xcite ) .",
    "the numerical integrator used for particles undergoing close approaches also must be reasonably fast as we would like to make it possible for our integrator to integrate as many particles as possible .",
    "consequently we have chosen a 4-th order adaptive step size hermite integrator for particles undergoing close approaches instead of the burlisch - stoer integrator used by @xcite . this integrator forms the heart of many n - body integrators ( e.g. , @xcite ) .",
    "our code follows the algorithm described by @xcite but does not use the ahmad - cohen scheme . while the hermite integrator runs on the cpu , we have implemented the routine to integrate the accelerations and jerks both on the cpu and gpu .",
    "the gpu version is called if the number of particles integrated exceeds a certain value , @xmath39 .",
    "the transition radius @xmath38 was described by @xcite in terms of the mutual hill radius or @xmath48\\ ] ] though @xcite also included a expression that depends on the speed .",
    "one problem with this choice is that the force between particles do nt solely depend on the distance between the particles as they also depend on the distance to the central star .",
    "this implies that the forces are not conservative and makes it more difficult to check the energy conservation of the hermite integrator .",
    "instead we choose a critical radius , @xmath38 , prior to the hermite integration and keep it fixed during the integration .",
    "the critical radius @xmath38 is defined to be a factor @xmath49 times the maximum hill radius of the particles involved in an encounter at the beginning of the hermite integration .",
    "@xmath50 where @xmath51 is the hill radius of particle @xmath3",
    ".    when using the hermite integrator we do not allow the central star to move as we keep the system in heliocentric coordinates .",
    "we have checked that the total energy given by @xmath52 ( equation [ eqn : hpkep ] ) is well conserved by the hermite integrator .",
    "we find that the accuracy is as good as that using the hermite integrator lacking the transition function and is set by the two parameters controlling the timestep choice @xmath53 and @xmath54 ( see section 2.1 and equations 7 , and 9 @xcite ) .",
    "we note that our modified interaction step requires @xmath14 computations and adding in the transition function would substantially add to the number of computations involved in computing accelerations .",
    "we instead make use of the list of particles identified during our encounter identification routine to correct the forces on the particles that are involved in encounters . consequently all interactions are computed and then only those involved in encounters are corrected just before the hermite integrator is called .",
    "our procedure for each time step is as follows :    1 .",
    "do a drift step ( evolving using @xmath55 ; equation [ eqn : hdft ] ) for all particles for timestep @xmath56 on gpu .",
    "2 .   do an interaction step ( evolving using @xmath21 ; equation [ eqn : hint ] ) using all particles and for all interactions and without using the transition function @xmath57 for timestep @xmath56 on gpu .",
    "3 .   do a keplerian step ( evolving using @xmath16 and @xmath17 functions ) for all particles for timestep @xmath11 on the gpu .",
    "note that the ones undergoing close approaches have been inaccurately integrated but will be corrected later .",
    "4 .   use stored positions and velocities ( @xmath58 ) prior and after the keplerian step in global memory on the gpu to identify close encounters on the gpu .",
    "if there are encounters , transfer pair lists onto the cpu and divide the list of particles involved in encounters into non - intersecting sets . calculate the maximum hill radius for particles in each encounter list and use this radius to compute a critical radius @xmath38 for each encounter set .",
    "only if there are encounters are the positions and velocities prior and after the kepstep copied onto the cpu .",
    "5 .   for each encounter",
    "set , subtract interactions that should not have been previously calculated in step # 2 using stored positions and velocities on the cpu .",
    "previously we calculated the interaction step using all interactions .",
    "however we should have weighted them with a transition function @xmath57 ( equation [ eqn : k ] ) .",
    "now that we have a critical radius , @xmath38 , estimated for each encounter list we can correct the interaction step . after interactions weighted by @xmath59 have been subtracted , the interaction step effectively calculated is @xmath60 ( equation [ eqn : hpint ] ) rather than @xmath21 ( equation [ eqn : hint ] ) .",
    "use a modified hermite integrator to integrate close approach sublists for @xmath11 using the stored cpu positions and velocities @xmath61 .",
    ".   for each encounter set , subtract interactions that will be incorrectly calculated by a repeat of the interaction step in step # 9 .",
    "if there have been encounters , copy only particles involved in encounters back into the arrays @xmath62 and @xmath63 on the cpu .",
    "copy the entire arrays on the the gpu .",
    "particles involved in encounters have been integrated using a hermite integrator .",
    "particles not involved in encounters have had keplerian evolution only . 9 .",
    "do an interaction step ( using @xmath21 ) using all particles and for all interactions and without using the transition function @xmath57 for timestep @xmath56 .",
    "do a drift step ( using @xmath55 ) for all particles for timestep @xmath56 .    as we have checked for encounters during every time step we can flag encounters involving more than one planet .",
    "in this case we can choose to do the entire integration step for all particles with the hermite integrator ( but with accelerations and jerks computed on the gpu ) .",
    "as planet / planet encounters are rare this does not need to be done often .",
    "hybrid symplectic integrators such as _ mercury _",
    "@xcite have largest deviations in energy during infrequent planet / planet encounters . by integrating the entire system with a conventional n - body integrator during planet / planet encounters",
    "we can improve the accuracy of the integrator without compromising the long term stability of the symplectic integrator .",
    "close encounter identification is in general an order @xmath14 computation as all particle pairs must be checked every timestep .",
    "this is potentially even more computationally intensive than computing all interactions .",
    "we do this with two sweeps , each one considering fewer particle pairs .",
    "the first sweep is crude , covers all possible particle pairs and so is order @xmath14",
    ". this one should be as fast as possible to minimize its computational intensity .",
    "shared memory is used for particle positions in a tile computation similar to that used to compute all force interactions .",
    "the computation can be done with single precision floating point computations and we can be conservative rather than accurate with encounter identification . for each particle",
    "we compute its escape velocity ( and this is order @xmath13 as it is only done for each particle ) .",
    "a particle pair is counted if the distance between the particles is smaller than the sum of a factor times the mutual hill radius times the distance moved by the first particle moving at its escape velocity during the timestep .",
    "the first kernel call sweeps through all particle pairs but only counts the number of possible interactors .",
    "an array of counts ( one per particle ) is then scanned in parallel using the parallel prefix ( scan ) function @xcite available in the cudpp subroutine library .",
    "cudpp is the cuda data parallel primitives library and is a library of data - parallel algorithm primitives such as parallel prefix - sum , parallel sort and parallel reduction .",
    "the second kernel call then uses the scanned array to address locations to record pair identification numbers identified in the crude sweep . as the number of pairs is identified during the first kernel call memory requirements",
    "can be considered before calling the second kernel call .",
    "a second more rigorous sweep is done on the pairs identified from the first one . for this sweep",
    "we use the particle positions and velocities computed using keplerian evolution at the beginning and end of the timestep .",
    "we use the third order interpolation scheme described in section 4.4 by @xcite to predict the minimum separation during the timestep which we compare to the sum of their hill radii .",
    "pairs which fail this test are marked .",
    "pairs which approach within a factor @xmath64 times times the sum of their hill radii are marked as undergoing a close encounter . using a second scan we repack the list of identified pairs into a smaller array .",
    "after all pairs undergoing encounters have been identified , we sort them into non - intersecting sublists .",
    "this is done on the cpu as we expect the number of pairs now identified is not large .",
    "we note that since we used the escape velocity in our first sweep to identify pairs of particles undergoing encounters , we could miss encounters between particles escaping from the system and other particles .",
    "the number missed we suspect would be small .",
    "the number of pairs identified in the first crude sweep depends on the timestep and the particle density .",
    "we could consider other algorithms for removing possible particle pairs from consideration as long as we keep in mind that the first sweep should remove as many pairs as possible while being as efficient as possible .",
    "we review some parameter definitions    1 .   the timestep @xmath11 . as",
    "the symplectic integrator is second order the error should depend on @xmath65 .",
    "the hill factor @xmath49 is used to define @xmath38 ( equation [ eqn : rcrit ] ) .",
    "this parameter is needed to compute the transition function @xmath57 ( equation [ eqn : k ] ) and so is needed by the hermite integrator and to compute interactions when there are close encounters ( equation [ eqn : hpint ] ) .",
    "this parameter is a distance in hill radii of the most massive particle involved in a close encounter .",
    "3 .   the hill factor @xmath64 .",
    "particle pairs with minimum estimated approach distances within @xmath64 times the the sum of their hill radii are identified as undergoing close approaches .",
    "4 .   the smoothing length , @xmath66 , used in the hermite integrator . as we do not yet take into account actual collisions , this parameter should be small but not zero .",
    "a non - zero smoothing length will prevent extremely small timesteps in the event of a close approach of two point masses .",
    "the parameters setting the accuracy of the hermite integrator @xmath53 , and @xmath54 ( as discussed and defined by @xcite ) .",
    "6 .   the number @xmath39 .",
    "if the number of particles involved in an encounter is larger than this number then the hermite integration is done on the gpu rather than on the cpu .",
    "the chaotic nature of the many - body problem makes it challenging to check the accuracy of any code designed to simulate solar or extrasolar systems .",
    "there is no simple way to generate analytical solutions to a set of initial conditions .",
    "however , it is possible for us to run our integrator through a suite of tests and compare those results to the integrators that form the basis or our code , namely the the hybrid symplectic integrator _ mercury _ by @xcite and the democratic heliocentric modification to mixed variable symplectic integrators @xcite implemented in the _ symba _ package .",
    "one of the most basic tests we ran on the integrator was to check that smaller timesteps ensured greater energy conservation for a given set of initial conditions .",
    "we use the relative energy error as a metric for measuring the conservation of energy in a simulation .",
    "this relative energy error is computed with the formula @xmath67 where @xmath68 is the energy at the beginning of the computation .",
    "indeed , we do observe superior energy conservation with smaller timestep sizes with the error scaling @xmath69 ) as expected as the integrator is second order .",
    "two simple test integrations of 1024 particles and identical initial conditions with timesteps of 0.1 and 0.01 were completed . over 10 timesteps of 0.1",
    "the relative energy error was @xmath70 with a per step average energy error of @xmath71 .",
    "over 100 timesteps of 0.01 the relative energy error was @xmath72 with a per step average energy error of @xmath73 . comparing the average energy error per step for these two test simulations indicates an exact scaling with @xmath65 .",
    "our primary test integration is an integration of a scaled version of the outer solar system .",
    "both @xmath74 and @xmath75 were tested in this manner @xcite .",
    "the simulation consists of the four giant planets in the solar system but with masses increased by a factor of 50 .",
    "previous simulations demonstrate that this configuration is unstable @xcite , although they disagree on the eventual outcome due to the chaotic nature of solar system evolution .",
    "as noted by @xcite , the timestep chosen can have an effect on the eventual outcome even when varied only slightly .",
    "with these facts in mind , we ran a simulation with values as close as possible to those of previous tests . to match the simulation described in section 5.1 by @xcite we used a timestep of @xmath76 where @xmath77 is the initial orbital period of the innermost planet .",
    "we set the hill factor @xmath78 for encounter detection and @xmath79 setting the transition radius , @xmath38 . for initial conditions we used epoch j2000.0 orbital elements for the four giant planets @xcite .",
    "the energy error for this simulation is shown in figure [ fig : enhanced_outer_solar_system ] .",
    "time is given in orbital periods of the innermost planet .",
    "we ran our simulation for the same number of orbital periods as did @xcite in the test shown in their figure 2 .    despite the highly chaotic and unstable nature of this system ,",
    "our integration is remarkably quite similar to that by @xcite ( see their figure 2 ) .",
    "the energy error is bounded , as expected for a symplectic integrator .",
    "the spikes in the energy error are also evident with other integrators ( see figure 2 by @xcite and figure 6 by @xcite ) . a close encounter between jupiter and saturn",
    "is experienced at approximately 200 years into the integration , which causes a jump in the relative energy error . a similar jump in energy",
    "was also seen by @xcite .",
    "our simulation also involved the later ejection of more than one planet .",
    "the energy error of our integration is bounded - typical of a fixed timestep symplectic integrator .",
    "however the sizes of the individual spikes in energy error is larger than those shown in figure 2 by @xcite though it is similar in size to those shown in figure 6 by @xcite .",
    "the spikes in figure 2 by @xcite are of order @xmath80 in fraction error whereas ours are of order @xmath81 .",
    "there are several possible explanations for the worse performance of our integration . during close approaches we are using a hermite integrator rather than the burlisch - stoer used by @xcite .",
    "however we have measured the error across each close approach and find conservation of @xmath82 at a level orders of magnitude below @xmath81 so the choice of integrator for close approaches is unlikely to be the cause .",
    "we have checked our drift and keplerian evolution operators and find they conserve their hamiltonians within the precision of double precision arithmetic .",
    "we find little dependence on energy error in the form of the transition function , or the hill factor @xmath49 setting @xmath38 .",
    "however the hill factor influencing the identification of close encounters , @xmath64 , does affect the energy error . during encounters ,",
    "terms in the interaction hamiltonian ( equation [ eqn : hint ] ) can become large .",
    "however we add these into the interaction term during the interaction evolution .",
    "these terms are then removed subsequently once encounters are identified so that @xmath83 is calculated ( see the discussion in section 2.1 and steps 3 and 7 in section 2.3 ) .",
    "this procedure for removing the incorrectly calculated interaction terms could account for the somewhat poorer performance of our integrator .     from an integration of the outer solar system ( jupiter , saturn , uranus , neptune ) only with masses enhanced by a factor of 50 .",
    "time is in units of the orbital period in years of the innermost planet .",
    "the energy errors are bounded .",
    "this behavior is typical of fixed timestep symplectic integrators .",
    "there is a planet / planet encounter at a time of about 200 years .",
    "eventually planets are ejected .",
    "[ fig : enhanced_outer_solar_system ] ]      for our second integration we compare the relative energy error of the evolution of the outer solar system with much larger timesteps and for a much larger amount of time - similar to the test integration discussed by @xcite and shown in their figure 2 . in this test",
    ", we again use the epoch j2000.0 orbital elements as initial conditions but use a timestep of @xmath84 where @xmath77 is the initial orbital period of the innermost planet .",
    "the timestep used and the total integration time ( @xmath85 yr ) are similar to those values used in @xcite .",
    "the masses of the planets are unchanged from their accepted values . this configuration is known to be stable so we did not expect any close encounters or ejections and a somewhat better relative energy error compared to the last simulation despite the increase in timestep size . as in the previous test ,",
    "we did not observe a relative energy error as good as @xcite ; our accuracy being a factor of a few poorer in terms of both the average energy error as well as the size of the fluctuations in the energy error .",
    "no encounters are present in this simulation suggesting that we have somewhat larger sources of errors in our interaction or keplerian evolution steps than _",
    "symba_. we are not yet sure what is causing this low level of error as these computations have been done in double precision and when tested individually for single timesteps , we have found them accurate .     ]",
    "we find that the energy error is insensitive to the hill factor @xmath49 setting the transition function but is quite sensitive to @xmath64 , the hill factor for encounter detection .",
    "we find the best numerical results for @xmath64 in the range 1 to 4 .",
    "the larger the value of @xmath64 the more encounters are sent to the hermite integrator and the slower the integration .",
    "however if @xmath64 is too small then the difference between the integrated hamiltonian and true one will be large as the interaction terms become large .",
    "in this section we discuss the fraction of runtime spent doing each computation in some sample integrations .",
    "computations that are run on the gpu are called kernels . in tables",
    "[ tab : tab1 ] and [ tab : tab2 ] we list the fraction of gpu time spent in each kernel or group of kernels or doing memory operations for these two different simulations .",
    "we also list the cpu runtime for each kernel which includes the overhead for calling the device function in addition to the runtime on the gpu .",
    "we label the kernels or groups of kernels as follows : interaction ( evolving using @xmath86 ) , keplerian ( evolving using @xmath5 ) , sweeps ( the kernels for finding close encounters ) , drift ( evolving using @xmath55 ) , energy ( evaluating the total energy on the gpu and only done once per data output ) , and hermite ( when the hermite integrator is run on the gpu ) .",
    "also listed is the total time spent doing memory allocation and transfers ( listed under ` memory ' ) .",
    "all other kernels are listed under ` various ' and the computation times are summed .",
    "kernels in the ` various ' category include center of momentum calculations , scans , repacking , etc that are not part of the previous listed kernels .",
    "three sweeps are called , the first two passing over all particle pairs .",
    "the sum of the time spent in all sweeps is shown in the table under sweeps .",
    "the simulations described in table 1 and 2 are identical except in the number of particles in the simulation .",
    "the initial conditions consist of 4 massive planets inside a debris disk which is significantly less massive than the planets and is truncated relatively quickly .",
    "both simulations were run for 1 output of 100 timesteps .",
    "we note that the energy kernel is only called once per output .",
    "the set of initial conditions was chosen so that the system would quickly have close encounters involving two planets and so force the integrator to call the hermite integrator with all particles .",
    "this allowed us to measure the performance of different kernels .",
    "relevant profiler information includes the number of kernel calls made of a particular function , total time to complete all calls of that function on both the cpu and gpu and the percentage of gpu runtime spent running each kernels .",
    "tables 1 and 2 represent a scenario in which collision are frequent and the hermite integrator is called frequently .    profiling for the code",
    "was done with the nvidia cuda visual profiler version 3.0 that is available with the cuda toolkit .",
    "profiling was done on two video cards , the nvidia geforce gtx 285 and the geforce gtx 480 .",
    "tables 1 - 2 only show the times for computations on the gpu alone and cpu overhead + gpu time to call these functions , but do not show the fraction of total computation time on the gpu .",
    "however , using the gpu utilization plot available in the visual profiler , we are able to determine the session level ( an entire integration ) gpu utilization . for @xmath87 particles we achieved a utilization of 93% and for @xmath88 particles a utilization of 85% . for @xmath89 particles , utilization varied dramatically , but never dipped below @xmath2550% .",
    "the overall utilization dropping for higher number of particles may seem counterintuitive , but makes sense in light of the increasing number of particles that are flagged for close approaches and sent to the cpu for integration .",
    "in fact , in certain cases , particularly with low densities or small hill factor identification radii , @xmath89 particle simulations would display very high utilization .",
    "it is important to note that these utilization percentages represent the time that the gpu is not idle - it is not indicative of the actual performance of a particular kernel or the code as a whole .",
    "there are other more useful metrics for individual kernel performance . also , we note that the hermite integrator is the only major routine in the code that is run on the cpu and because of this the host processor speed and quantity of main system memory have little effect on the values given in the tables below .",
    "the effect of the higher cpu speeds is to decrease the total runtime and to effect the gpu utilization values . only in simulations with lower gpu utilization percentages",
    "do the effects of increased processor speed become apparent .",
    "altering main system memory amounts or speeds has no practical effect on our runtime due to the relatively small amount of memory being used - even for @xmath89 particle simulations .",
    "we observed that nearly all of the runtime is dominated by the interaction step , the hermite integrations and the close approach detection kernels labeled `` sweeps '' in the table .",
    "memory operations , the drift and keplerian evolution steps of the symplectic integrator and all of the other various functions on the gpu add up to only a small fraction of the runtime .",
    "this percentage will continue to decrease as the particle number is increased as the interaction step is @xmath15 but the keplerian evolution and drift step are @xmath90 .",
    "the ratio of time spent doing sweeps compared to that in the interaction step may increase with @xmath13 as there may be more encounters when the particle density is higher .",
    "comparing table [ tab : tab1 ] and [ tab : tab2 ] we see that the fraction of time spent in the interaction step is only somewhat larger when the number of particles is larger .",
    "this implies that the fraction of time spent doing operations that are @xmath90 is small even when the number of particles is only 1024 .",
    "examining the timing information from the simulations with 10240 particles we note that on average a single call to the hermite and interaction kernels took about 0.20 and 0.11 seconds respectively .",
    "we also observe that the cpu + gpu runtime are nearly identical to the gpu runtime alone for all major kernels .",
    "it is only with smaller numbers of particles or kernels that are @xmath90 that these values diverge even slightly .    in table [",
    "tab : tab3 ] we show a comparison of simulations with three different particle numbers and identical initial conditions as those given for the first two sets of simulations described in the first two tables .",
    "however , these were evolved for only 10 timesteps instead of 100 before outputting data .",
    "these integrations lack close encounters and so serve to compare sweep , energy and interaction kernels . for simulations with sparse debris disks or low mass objects ,",
    "this third table describes how the gpu runtime will be spent .",
    "clearly , the interaction step , energy calculation and sweeps compose a majority of the runtime . as larger number of timesteps are taken per data out or if we suppress the calculation of the energy , we will reach an asymptotic limit of  85% gpu time spent on interaction step with the remaining  15% of the gpu time spent on the sweeps for encounter detection .",
    "listed by the cuda profiler does not always add up to 100 for reasons of significant figures . ]",
    ".profile for 1024 particles [ tab : tab1 ] [ cols=\"<,<,^,^,^\",options=\"header \" , ]      + this profile shows something akin to the asymptotic limit of simulations which do not have objects experiencing close approaches .",
    "each simulation is of a single output of 10 timesteps on a 285 gtx with the specified number of particles .",
    "we have optimized our code beyond the standard cpu software optimization techniques by using some of the `` best practices '' for gpu programming .",
    "refer to the `` best practices guide  cuda 3.0 '' for an in depth description of low , medium and high priority optimizations .",
    "the most important and most obvious best practice is to run as much of your code on the gpu as possible while simultaneously implementing each kernel to take advantage of as much parallelism as possible . to this end , we have put nearly all of the computations for our integrator on the gpu including all the evolution operators in our symplectic integrator ( drift , keplerian , interaction ) , all collision detection sweeps , the hermite integration routine as well as the energy computation . as shown in the profiling , the execution time of a non - interacting system is dominated by the @xmath15 interaction term ; a kernel with a high degree of arithmetic intensity and minimal memory transfer compared to the number of floating point operations .",
    "some of these routines show small gpu performance benefits over the cpu because of their large size in terms of registers , lack of arithmetic intensity in that they are @xmath90 , and their inability to use shared memory .",
    "however , even these serial routines are executed on the gpu to ensure as few host to gpu or gpu to host memory transfers .",
    "this best practice is very important because it ensures fewer high latency memory transfers between the system memory and global memory on the gpu and again from global memory to the multiprocessors .",
    "the more time that can be spent doing floating point operations rather than memory transfer allows for the greatest gpu speed increases .",
    "other high priority optimizations are to access shared memory over global memory whenever possible and to keep your kernels from having diverging execution paths .",
    "some routines were not or could not be written to use shared memory , but all @xmath15 sweeps and the interaction step leverage this tremendous performance enhancer .",
    "all kernels are written to minimize branching statements to ensure that execution paths do not diverge .",
    "this best practice manifests itself most obviously in the interaction detection and hermite integration kernels .",
    "collision detection was not incorporated in the same function , but rather in a separate kernel . in another example of code design choice",
    ", we over count and do @xmath14 computations in the interaction step instead of @xmath91 since it allows for us to have simpler code that is more easily executed in parallel on the gpu .",
    "medium priority optimizations including use of the fast math library that could potentially effect the accuracy of our code in a negative way are not implemented .",
    "we do use multiples of 32 threads for each block and we are able to attain a 33% occupancy rate for the interaction step , the energy computation and the gpu version of the hermite gravity step as well as a 50% occupancy rate for the first and second sweep steps on a gf100 based gtx 480 .",
    "the concept of occupancy is a complicated one and is explained in more detail in both the `` best practices guide  cuda 3.0 '' guide and the `` cuda programming guide 3.0 '' . at it",
    "s core it s simply a ratio of the number of active warps in a multiprocessor to the maximum number of possible warps the multiprocessor can maintain .",
    "a warp is simply a group of 32 threads to be executed on a multiprocessor . while computing the number of active warps per multiprocessor",
    "involves hardware knowledge beyond this document , and noting that higher occupancy does not necessarily equate to better performance , it is important to maintain a minimum occupancy .",
    "below some value , the latencies involved with launching warps can not be hidden .",
    "the value suggested in the `` best practices guide  cuda 3.0 '' suggest an occupancy of at least 25% be maintained .",
    "as mentioned , we are able to attain this",
    ".    we also attempt to ensure optimal usage of register space per block and to loop unroll functions when it can increase performance .",
    "the number of loop unrolls that can be achieved is determined by examining the numbers of registers used per thread for a given function and multiplying it by the number of threads per block that you wish to issue .",
    "this gives the total number of registers used per multiprocessor - the group of cuda cores that a block is issued to .",
    "this value must be smaller than the number of registers available on the relevant architectures multiprocessor .",
    "increasing the number of loop unrolls in a given kernel can alter the register requirements , so there is a limit to the number of loop unrolls that can be implemented . for reference , the gt200 architecture ( gtx 285 ) and the gf100 architecture ( gtx 480 ) , there are 8 and 32 cuda cores per multiprocessor , 16k and 32k 32-bit registers , and 16 kb and 48 kb per multiprocessor of shared memory respectively .",
    "all relevant hardware numbers including number of threads , multiprocessors , cores per multiprocessor , amount of shared memory , etc .",
    "can be found in the cuda programming guide in appendices a and g. it is possible to artificially restrict a function to use a number of registers that is less than it requires .",
    "however , this forces some values to be stored in local memory ( global memory ) , which , as mentioned previously , carries a very heavy performance penalty in terms of latency . for this reason , it can be detrimental to limit the number of registers per thread below that which is required .",
    "we found that our performance was best with a loop unroll of 4 , a maximum number of registers per thread set to 64 , and 128 threads per block .",
    "the parallel computations used by this code for the most part utilize parallel primitives and so can be ported to other parallel computation platforms with similar parallel primitive libraries .",
    "the energy computation , interaction step and all pairs sweep identification routines essentially utilize the same tiled shared memory algorithm ( described by @xcite .",
    "the drift step and encounter detection use a parallel prefix sum ( see @xcite ) .",
    "there are several areas in which our code could be further optimized . without drastically altering the code",
    "there are some `` low priority '' optimizations such as the use of constant memory for unchanging values like smoothing lengths and the hill factors .",
    "more important hardware level optimizations could include alternate ways to ensure global memory coalescing and prevent shared memory bank conflicts by padding our current data structures or disassembling them entirely and using single arrays of double precision elements to store data .    on a higher level , there are several optimizations that could possible speed up the code significantly .",
    "first , replacing the interaction step which is currently an all - pairs @xmath15 calculation with a gpu enhanced tree integration ( e.g. , @xcite ) could bring a speed increase to the code and allow larger numbers of particles to be simulated .",
    "additionally , the sorting routines ( sweep kernels ) could be optimized to use faster detection methods than the current @xmath15 methods . by implementing a parallel sorting algorithm or simply making our detection routine more intelligent",
    ", we could reduce this part of the runtime . for simulation of many massless but colliding particles ( such as dust particles ) in the vicinity of planets and planetesimals",
    "an improvement in the encounter identification may allow us to integrate many more particles .",
    "a potentially simpler change would be the implementation of double precision in software rather than hardware .",
    "double precision code on nvidia gpu s executes more slowly than single precision , as is often the case in hardware .",
    "depending on the device , this factor can be anywhere from 1/8th to 1/2 the speed and some older cuda capable devices do not support double precision at all . by implementing double precision in software",
    "we would be able to compile our code using 32-bit floating point precision .",
    "this would have the benefit of multiplying the speed of the code you are running by a factor of at least a few and could possibly allow devices not originally capable of supporting the code to run .",
    "additionally , it appears that only gf100 devices in the tesla brand of cards will support full double precision speeds which run at 1/2 the number of double precision flops .",
    "a penalty of  1/8th the number of single precision flops was observed while profiling our code on a gtx 480 .",
    "this was observed indirectly by only noticing a speed increase of  2x on our gf100 based machine for our double precision kernels like the interaction step and the energy computation over our gt200 based gpus . at 1/8th the peak double precision flops ,",
    "the gf100 based gpu should be  2x faster than a gt200 based gpu because it has 2x the number of cores over the gt200 based cards ( ignoring minor execution time differences based on the actual core clock speeds ) .",
    "the gt200 based gpus are known to have a double precision flops peak 1/8th that of the single precision peak . in practice",
    ", it should be noted that the gf100 cards run faster than 2x that of gt200 gpus due to other architectural optimizations between the cards . in particular ,",
    "small kernels which have not been or do not parallelize as well run much faster on the gf100 gpus .",
    "lastly , in addition to our code supporting more devices and running 2x the speed , the code would be easier to optimize to ensure global memory coalescing and to prevent shared memory bank conflicts due to the 4 byte size of single precision floating point .    however , software implementation of double precision has downsides .",
    "notably , it is often difficult to achieve the same precision as double precision floating point when using two single precision floating point values .",
    "additionally , full conversion of the code to use single precision floating point values and redefining basic vector operations would involve extensive reworking of the kernels that could lead to dozens of extra operations in each particular kernel .",
    "it is not obvious that this sort of optimization is entirely suited to the gpu because increasing the number of operations in a kernel can increase register usage - an effect we are trying to avoid for optimization reasons .",
    "finally , simply modifying the distance calculation to be in double precision and computing the rest of the acceleration step in single precision would result in the largest performance benefit with the least amount of coding required but could potentially lose a large amount of precision in our calculations .    due to the previously mentioned register restrictions and the complexity of our code , it is often difficult to achieve high occupancy on the devices we use",
    ". it may be possible to rewrite entire routines in non - obvious ways to reduce the number of maximum registers in use at a given point in time to remedy this problem .",
    "this is only a `` medium priority '' optimization and is probably the most difficult due to the number of ways kernels can be re - written .",
    "this optimization is also hardware dependent and so may not be a worthwhile optimization .",
    "we have described an implementation of a hybrid second order symplectic integrator for planetary system integration that permits close approaches .",
    "it is similar in design to _ symba _ @xcite and _ mercury _ @xcite but is written in cuda and works in parallel on a gpu .",
    "the code is almost as accurate as the older integrators but is faster when many particles are simultaneously integrated .",
    "bounded energy errors are observed during numerical integration of a few test cases implying that our integrator is indeed nearly symplectic .",
    "the code has been written primarily with parallel primitives so that modified versions can be written for other parallel computation platforms .",
    "the current version of the code does not take into account collisions between particles , however we plan to modify future versions so that these can be incorporated into the code .",
    "we also plan to modify the encounter algorithms so that many dust particles can be integrated in the vicinity of planets and planetesimals .",
    "0.1 truein    support for this work was provided by nsf through award ast-0907841 .",
    "we thank richard edgar for the design and initial set up of our gpu cluster .",
    "we thank nvidia for the gift of four quadro fx 5800 and two geforce gtx 280 video cards .",
    "we thank nicholas moore for informative discussions regarding gpu architectural and coding minutiae .",
    "given a particle with position @xmath92 and velocity @xmath93 at time @xmath94 in keplerian orbit , its new position , @xmath95 , and velocity , @xmath96 , at time @xmath97 can be computed @xmath98 in terms of the @xmath16 and @xmath17 functions and their time derivatives , @xmath99 and @xmath100 .",
    "introductory celestial mechanics textbooks often discuss @xmath16 and @xmath17 functions for particles solely in elliptic orbits .",
    "however if a particle in a hyperbolic orbit is advanced using elliptic coordinates , a nan will be computed that can propagate via the interaction steps .",
    "it is desirable to advance particle positions for all possible orbits , including parabolic or hyperbolic ones .",
    "this can be done by computing the @xmath16 and @xmath17 functions with universal variables , as described by @xcite .",
    "the recipe is repeated here as it is useful , but not available in most textbooks .    with @xmath101 and @xmath102 where @xmath103 is the semi - major axis and @xmath104 the initial radius , the @xmath16 and @xmath17 functions and their time derivatives in universal variables",
    "are computed as @xmath105 \\nonumber \\\\",
    "\\dot g & = & 1 - { x^2 \\over r } c(\\alpha x^2)\\end{aligned}\\ ] ] ( see equations 2.38 by @xcite ) . here",
    "the variable @xmath106 solves the universal differential kepler equation @xmath107 ( equation 2.39 @xcite ) .",
    "the @xmath16 and @xmath17 functions must be computed before the time derivatives , @xmath99 and @xmath99 , so that @xmath108 , the radius at time @xmath97 , can be computed . this radius is then used to compute @xmath99 and @xmath100 .",
    "it is convenient to define the function @xmath111 and compute its derivatives @xmath112     + ( 1 - r_0 \\alpha )",
    "x^2 c(\\alpha x^2 )      + r_0 \\nonumber \\\\",
    "f''(x ) & = &     { ( { \\bf r}_0 \\cdot { \\bf v}_0 )   \\over \\sqrt{\\mu } } \\left[1- \\alpha x^2 c(\\alpha x^2 )   \\right ]     + ( 1 - r_0 \\alpha ) x \\left [ 1 - \\alpha x^2 s(\\alpha x^2)\\right ]   \\end{aligned}\\ ] ] ( equation 2.41 , 2.42 and problem 2.17 by @xcite ) .    to solve the universal kepler equation ( equation [ eqn : ukp ] , that can now be written as @xmath113 ) the laguerre algorithm can be computed iteratively @xcite as @xmath114 ( equation 2.43 @xcite ) .",
    "good numerical performance is found with @xmath115 @xcite .",
    "the sign in the denominator is the same as the sign of @xmath116 .",
    "the rate of convergence is cubic and convergence is achieved for any starting value of @xmath106 @xcite . using a starting value @xmath117 we achieved convergence for a wide range of timesteps and orbital parameters to a level of @xmath18 in under 6 iterations .",
    "improved choices for starting values of @xmath106 are discussed by @xcite and @xcite but require more computation than @xmath117 .",
    "morbidelli , a. 2001 , ann .",
    "earth and pl .",
    ", 30 , 89 nyland , l. , harris , m. , & and prins , j. 2008 , chap 31 in gpugems3 , edited by hubert nguyen , 2008 , addison - wesley , upper saddle river , nj , page 677          standish , e.m . , newhall , x. x. , williams , j.g .",
    ", & yeomans , d.k . 1992 ,",
    "orbital ephermerides of the sun , moon , and planets , in _ explanatory supplement to the astronomical almanac _ , ed .",
    "seidelmann ( university science books , mill valley , ca ) ."
  ],
  "abstract_text": [
    "<S> we describe a parallel hybrid symplectic integrator for planetary system integration that runs on a graphics processing unit ( gpu ) . </S>",
    "<S> the integrator identifies close approaches between particles and switches from symplectic to hermite algorithms for particles that require higher resolution integrations . </S>",
    "<S> the integrator is approximately as accurate as other hybrid symplectic integrators but is gpu accelerated .    </S>",
    "<S> celestial mechanics;symplectic integrators;acceleration of particles;cuda;95.10.ce;04.40.-b </S>"
  ]
}