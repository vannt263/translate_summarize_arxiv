{
  "article_text": [
    "global constraints allow users to specify patterns that commonly occur in problems .",
    "one of the oldest and most useful is the constraint @xcite .",
    "this ensures that a set of variables are pairwise different .",
    "global constraints can often be decomposed into more primitive constraints .",
    "for example , the constraint can be decomposed into a clique of binary inequalities .",
    "however , such decompositions usually do not provide a global view and are thus not able to achieve levels of local consistency , such as bound and domain consistency .",
    "considerable effort has therefore been invested in developing efficient propagation algorithms to reason globally about such constraints .",
    "for instance , several different propagation algorithms have been developed for the constraint @xcite . in this paper , we show that several important global constraints including can be decomposed into simple arithmetic constraints whilst still providing a global view since bound consistency can be achieved .",
    "there are many reasons why such decompositions are interesting .",
    "first , it is very surprising that complex propagation algorithms can be simulated by simple decompositions . in many cases ,",
    "we show that reasoning with the decompositions is of similar complexity to existing monolithic propagation algorithms .",
    "second , these decompositions can be easily added to a new solver . for example , we report experiments here using these decompositions in a state of the art pseudo - boolean solver .",
    "we could just as easily use them in an ilp solver .",
    "third , introduced variables in these decompositions give access to the state of the propagator .",
    "sharing of such variables between decompositions can increase propagation .",
    "fourth , these decomposition provide a fresh perspective to propagating global constraints that may be useful .",
    "for instance , our decompositions of the constraint suggest learning nogoods based on small hall intervals .",
    "a constraint satisfaction problem ( csp ) consists of a set of variables , each with a finite domain of values , and a set of constraints specifying allowed combinations of values for some subset of variables .",
    "we use capitals for variables and lower case for values .",
    "we write @xmath0 for the domain of possible values for @xmath1 , @xmath2 for the smallest value in @xmath0 , @xmath3 for the greatest , and @xmath4 for the interval @xmath5 $ ] .",
    "global constraint _ is one in which the number of variables @xmath6 is a parameter .",
    "for instance , the global @xmath7)$ ] constraint ensures that @xmath8 for any @xmath9 @xcite .",
    "we will assume values range over 1 to @xmath10 .",
    "constraint solvers typically use backtracking search to explore the space of partial assignments . after each assignment ,",
    "propagation algorithms prune the search space by enforcing local consistency properties like domain or bound consistency .",
    "a constraint is _ domain consistent _",
    "( _ dc _ ) iff when a variable is assigned any of the values in its domain , there exist compatible values in the domains of all the other variables of the constraint .",
    "such an assignment is called a _ support_.",
    "a constraint is _ bound consistent _",
    "( _ bc _ ) iff when a variable is assigned the minimum or maximum value in its domain , there exist compatible values between the minimum and maximum domain value for all the other variables .",
    "such an assignment is called a _ bound support_. finally , between domain and bound consistency is range consistency .",
    "a constraint is _ range consistent _",
    "( _ rc _ ) iff when a variable is assigned any value in its domain , there exists a bound support .",
    "constraint solvers usually enforce local consistency after each assignment down any branch in the search tree .",
    "for this reason , it is meaningful to compute the total amortised cost of enforcing a local consistency down an entire branch of the search tree so as to capture the incremental cost of propagation .",
    "we will compute complexities in this way .",
    "the constraint is one of the most useful global constraints available to the constraint programmer .",
    "for instance , it can be used to specify that activities sharing the same resource take place at different times . a central concept in propagating the constraint",
    "is the notion of a _ hall interval_. this is an interval of @xmath11 domain values which completely contains the domains of @xmath11 variables .",
    "@xmath12 $ ] is a hall interval iff @xmath13\\}|=b - a+1 $ ] . in any bound support",
    ", the variables whose domains are contained within the hall interval consume all the values in the hall interval , whilst any other variables must find their support outside the hall interval .",
    "consider an constraint over the following variables and values : @xmath14    @xmath15 $ ] is a hall interval of size 1 as the domain of 1 variable , @xmath16 is completely contained within it .",
    "therefore we can remove @xmath15 $ ] from the domains of all the other variables .",
    "this leaves @xmath17 with a domain containing values 2,3,4 .",
    "@xmath18 $ ] is a hall interval of size 2 as it completely contains the domains of 2 variables , @xmath19 and @xmath20 .",
    "we can thus remove @xmath18 $ ] from the domains of @xmath17 and @xmath21 .",
    "this leaves the following range consistent domains : @xmath22 enforcing bound consistency on the same problem does not create holes in domains .",
    "that is , it would leave @xmath21 with the values 2,3,4,5 .    to identify and prune such hall intervals from the domains of other variables ,",
    "leconte has proposed a rc propagator for the constraint @xcite that runs in @xmath23 time .",
    "we now propose a simple decomposition of the constraint which permits us to enforce rc .",
    "the decomposition ensures that no interval can contain more variables than its size .",
    "we introduce @xmath24 new 0/1 variables , @xmath25 to represent whether @xmath26 takes a value in the interval @xmath27 $ ] . for @xmath28 , @xmath29 and @xmath30",
    ", we post the following constraints : @xmath31 \\label{eqn::firstrange } \\label{eqn::secondrange } \\\\    \\sum_{i=1}^n a_{ilu } & \\leq & u - l + 1 \\label{eqn::lastrange}\\end{aligned}\\ ] ] we illustrate this decomposition on our running example .",
    "consider again the last example ( i.e. an constraint on @xmath32 $ ] , @xmath33 $ ] , @xmath34 $ ] , @xmath35 $ ] and @xmath36 $ ] ) .",
    "first take the interval @xmath15 $ ] . since @xmath36 $ ] , ( [ eqn::firstrange ] ) implies @xmath37 .",
    "now from ( [ eqn::lastrange ] ) , @xmath38 .",
    "that is , at most one variable can take a value within this interval .",
    "this means that @xmath39 . using ( [ eqn::firstrange ] ) and @xmath39",
    ", we get @xmath40 $ ] .",
    "since @xmath33 $ ] , this leaves @xmath41 $ ] .",
    "now take the interval @xmath18 $ ] . from ( [ eqn::firstrange ] ) , @xmath42 .",
    "now from ( [ eqn::lastrange ] ) , @xmath43 .",
    "that is , at most 2 variables can take a value within this interval .",
    "this means that @xmath44 . using ( [ eqn::firstrange ] )",
    "we get @xmath45 $ ] , @xmath46 $ ] .",
    "since @xmath41 $ ] and @xmath35 $ ] , this leaves @xmath47 and @xmath48 . local reasoning about the decomposition",
    "has thus made the original constraint range consistent .",
    "we will prove that enforcing dc on the decomposition enforces rc on the original constraint .",
    "we find it surprising that a simple decomposition like this can simulate a complex propagation algorithm like leconte s .",
    "in addition , the overall complexity of reasoning with the decomposition is similar to leconte s propagator .",
    "[ theorem::range ] enforcing dc on constraints ( [ eqn::secondrange ] ) and ( [ eqn::lastrange ] ) enforces rc on the corresponding constraint in @xmath49 down any branch of the search tree .",
    "* proof :  * @xcite provides a necessary and sufficient condition for rc of the constraint : every hall interval should be removed from the domain of variables whose domains are not fully contained within that hall interval .",
    "let @xmath50 $ ] be a hall interval .",
    "that is , @xmath51 where @xmath52\\}$ ] .",
    "constraint ( [ eqn::secondrange ] ) fixes @xmath53 for all @xmath54 .",
    "the inequality ( [ eqn::lastrange ] ) with @xmath55 and @xmath56 becomes tight fixing @xmath57 for all @xmath58 .",
    "constraint ( [ eqn::secondrange ] ) for @xmath59 , @xmath60 , and @xmath61 removes the interval @xmath50 $ ] from the domain of @xmath26 as required for rc .",
    "there are @xmath24 constraints ( [ eqn::secondrange ] ) that can be woken @xmath62 times down the branch of the search tree .",
    "each propagation requires @xmath63 time .",
    "constraints ( [ eqn::secondrange ] ) therefore take @xmath49 down the branch of the search tree to propagate .",
    "there are @xmath64 constraints ( [ eqn::lastrange ] ) that each take @xmath65 time to propagate down the branch of the search tree for a total of @xmath24 time . the total running time is given by @xmath66 .",
    "note that if we use a solver in which we can specify that constraints only wake on reaching a particular bound , we can decrease to @xmath63 the number of times constraints ( [ eqn::secondrange ] ) are woken , which gives a total complexity in @xmath24 .",
    "what about bound consistency of the constraint ? by using a representation that can only prune bounds @xcite , we can give a decomposition that achieves bc in a similar way .",
    "in addition , we can reduce the overall complexity in the case that constraints are woken whenever their bounds change .",
    "we introduce new 0/1 variables , @xmath67 , @xmath68 and replace ( [ eqn::secondrange ] ) by the following constraints : @xmath69    [ theo : alldiffbc ] enforcing bc on constraints ( [ eqn::lastrange ] ) to ( [ eqn::thirdbc ] ) enforces bc on the corresponding constraint in @xmath24 down any branch of the search tree .    * proof :  * we first observe that bc is equivalent to dc on constraints ( [ eqn::lastrange ] ) because @xmath25 are boolean variables .",
    "so , the proof follows that for theorem  [ theorem::range ] except that fixing @xmath70 prunes the bounds of @xmath71 if and only if @xmath72 or @xmath73 , that is , if and only if exactly one bound of the domain of @xmath26 intersects the interval @xmath74 $ ] . only the bounds that do not have a bound support are shrunk .",
    "the complexity reduces as ( [ eqn::secondbc ] ) appears @xmath75 times and is woken @xmath62 times , whilst ( [ eqn::thirdbc ] ) appears @xmath24 times and is woken just @xmath63 time .",
    "a special case of is when we have the same number of values as variables , and the values are ordered consecutively .",
    "a decomposition of just needs to replace ( [ eqn::lastrange ] ) with the following equality where ( as before ) @xmath29 , and @xmath76 : @xmath77 this can increase propagation",
    ". in some cases , dc on constraints ( [ eqn::firstrange ] ) and ( [ eqn::lastrangeequality ] ) will prune values that a rc propagator for would miss .",
    "[ permutation - example ] consider a constraint over the following variables and values : @xmath78 these domains are range consistent .",
    "however , take the interval @xmath79 $ ] . by dc on ( [ eqn::firstrange ] ) , @xmath80 .",
    "now , from ( [ eqn::lastrangeequality ] ) , we have @xmath81 .",
    "thus @xmath82 . by ( [ eqn::firstrange ] ) , this sets @xmath83 . on this particular problem instance , dc on constraints ( [ eqn::firstrange ] ) and ( [ eqn::lastrangeequality ] ) has enforced domain consistency on the original constraint .      a generalization of the constraint is the global cardinality constraint , @xmath84,[l_1,\\ldots , l_m],[u_1,\\ldots , u_m])$ ] .",
    "this ensures that the value @xmath85 occurs between @xmath86 and @xmath87 times in @xmath19 to @xmath88 .",
    "the constraint is useful in resource allocation problems where values represent resources .",
    "for instance , in the car sequencing problem ( prob001 at csplib.org ) , we can post a constraint to ensure that the correct number of cars of each type is put on the assembly line .",
    "we can decompose in a similar way to but with an additional @xmath64 integer variables , @xmath89 to represent the number of variables using values in each interval @xmath27 $ ] .",
    "clearly , @xmath90 $ ] and @xmath91 .",
    "we then post the following constraints for @xmath28 , @xmath29 , @xmath92 : @xmath93 \\label{eqn::firstgcc } \\\\",
    "n_{lu } & = & \\sum_{i=1}^n a_{ilu }     \\label{eqn::bigagcc}\\\\    n_{1u } & = & n_{1k } + n_{(k+1)u } \\label{eqn::gcctriangle } \\label{eqn::lastgcc } \\end{aligned}\\ ] ]    consider a constraint with the following variables and upper and lower bounds on the occurrences of values : @xmath94 enforcing rc removes 1 and 3 from @xmath95 and @xmath16 and leaves the other domains unchanged .",
    "we can derive this from our decomposition . from the lower and upper bounds on the number of occurrences of the values",
    ", we have @xmath96 $ ] except for @xmath97 $ ] and we have @xmath98 , n_{13}\\in [ 2,15]$ ] and @xmath99 $ ] . by ( [ eqn::firstgcc ] ) , @xmath100 . from ( [ eqn::bigagcc ] ) , @xmath101 $ ] .",
    "from @xmath102 we have @xmath103 $ ] ( i.e. , upper bound decreased ) because @xmath104 and @xmath105 $ ] .",
    "similarly , we derive from @xmath106 that @xmath107 $ ] and from @xmath108 that @xmath109 $ ] . from the same constraint , we shrink @xmath110 to @xmath111 $ ] and @xmath112 to @xmath15 $ ]",
    ". finally , @xmath113 shrinks @xmath114 to @xmath15 $ ] . by ( [ eqn::firstgcc ] ) , @xmath115 , so by ( [ eqn::bigagcc ] ) , @xmath116 and @xmath117 . by ( [ eqn::firstgcc ] ) , this removes 1 and 3 from @xmath118 . local reasoning about the decomposition",
    "has made the original constraint range consistent .",
    "we next show that enforcing dc on constraint  ( [ eqn::firstgcc ] ) and bc on constraints ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) enforces rc on the constraint .",
    "[ thm : gcc - bc ] enforcing dc on constraint ( [ eqn::firstgcc ] ) and bc on constraints ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) achieves rc on the corresponding constraint in @xmath49 time down any branch of the search tree .",
    "* proof :  * we use @xmath119 for the number of variables @xmath26 whose range @xmath120 intersects the set @xmath121 of values , and @xmath122 for the number of variables @xmath26 whose range is a subset of @xmath121 .",
    "we first show that if rc fails on the , dc on ( [ eqn::firstgcc ] ) and bc on ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) will fail .",
    "we derive from ( * ? ? ?",
    "* lemmas 1 and 2 ) that rc fails on a if and only if there exists a set of values @xmath121 such that @xmath123 or such that @xmath124 .",
    "suppose first a set @xmath121 such that @xmath125 . the fact that domains are considered as intervals implies that either @xmath126 includes more variable domains than the sum of the upper bounds ( like @xmath121 ) , or the union of the @xmath120 that are included in @xmath121 lets a hole of unused values in @xmath121 , which implies that there exists an interval @xmath27\\subset v$ ] such that @xmath127}>\\sum_{v\\in [ l , u]}u_{v}$ ] .",
    "so , in any case , there exists an interval @xmath27 $ ] in @xmath121 with @xmath127}>\\sum_{v\\in [ l , u]}u_v$ ] . by ( [ eqn::firstgcc ] )",
    "we have @xmath128}$ ] whereas the greatest value in the domain of @xmath89 was set to @xmath129}u_v$ ] .",
    "so bc will fail on @xmath130 .",
    "suppose now that a set @xmath131 is such that @xmath132 .",
    "the total number of values taken by @xmath26 variables being equal to @xmath6 , the number of variables @xmath26 with @xmath120 not intersecting @xmath121 is greater than @xmath133 , that is , @xmath134 } + s^{}_{[v_1 + 1,v_2 - 1 ] }   +   \\ldots + s^{}_{[v_{k}+1,d ] } > n-\\sum_{v_i\\in v}l_{v_i}$ ] .",
    "thanks to ( [ eqn::bigagcc ] ) , we know that for any @xmath135 , @xmath136 } $ ] .",
    "so , @xmath137 . the initial domains of @xmath89 variables also tell us that for every @xmath138 in @xmath121 , @xmath139 .",
    "thus , @xmath140 . successively applying bc on @xmath141 , then on @xmath142 , and so on until @xmath143 will successively increase the minimum of these variables and will lead to a failure on @xmath144 .",
    "we now show that when dc on ( [ eqn::firstgcc ] ) and bc on ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) do not fail , it prunes all values that are pruned when enforcing rc on the constraint .",
    "consider a value @xmath145 for some @xmath146 such that @xmath147 does not have any bound support .",
    "we derive from ( * ? ? ?",
    "* lemmas 1 and 6 ) that a value @xmath147 for a variable @xmath148 does not have a bound support on if and only if there exists a set @xmath149 of values such that either ( i ) @xmath150 , @xmath151 and @xmath152 is not included in @xmath149 , or ( ii ) @xmath153 , @xmath154 and @xmath152 intersects @xmath121 . in case ( i )",
    ", @xmath121 contains @xmath147 and the values it contains will be taken by too many variables if @xmath148 is in it . in case ( ii ) , @xmath121 does not contain @xmath147 and its values will be taken by not enough variables if @xmath148 is not in it .",
    "consider case ( i ) : since dc did not fail on ( [ eqn::firstgcc ] ) , by a similar reasoning as above for detecting failure , we derive that @xmath121 is composed of intervals @xmath27 $ ] such that @xmath127}=\\sum_{w\\in [ l , u]}u_w$ ] .",
    "consider the interval @xmath27 $ ] containing @xmath147 .",
    "the greatest value in the initial domain of @xmath89 was @xmath155}u_w$ ] , which is exactly the number of variables with range included in @xmath27 $ ] without counting @xmath148 because its range is not included in @xmath121 .",
    "thus , ( [ eqn::bigagcc ] ) forces @xmath156 and ( [ eqn::firstgcc ] ) prunes value @xmath147 from @xmath157 because @xmath158 $ ] by assumption .",
    "consider now case ( ii ) : @xmath131 is such that @xmath159 .",
    "the total number of values taken by the @xmath26 variables being equal to @xmath6 , the number of variables @xmath26 with @xmath120 not intersecting @xmath121 is equal to @xmath133 , that is @xmath160 }    + s^{}_{[v_1 + 1,v_2 - 1 ] } + \\ldots + s^{}_{[v_{k+1},d ] } = n-\\sum_{v_i\\in      v}l_{v_i}$ ] .",
    "thanks to ( [ eqn::bigagcc ] ) , we know that for any @xmath135 , @xmath161 } $ ] .",
    "so , @xmath162 . the initial domains of @xmath89 variables also tell us that for every @xmath138 in @xmath121 , @xmath163 .",
    "thus , @xmath164 . successively applying bc on @xmath165 , then on @xmath166 , and so on until @xmath167 will increase all @xmath168 and @xmath169 , to the sum of the minimum values of the variables in the right side of each constraint so that @xmath170 . then , because @xmath171 , bc on @xmath143 will decrease the maximum value of @xmath172 and @xmath173 to their minimum value , bc on @xmath174 will decrease the maximum value of @xmath175 and @xmath176 to their minimum value , and so on until all @xmath177 are forced to the singleton @xmath178 } $ ] . at this point ,",
    "( [ eqn::bigagcc ] ) forces @xmath179 for every variable @xmath180 with range not included in the interval @xmath181 $ ] because that interval is saturated by variables @xmath182 in @xmath183}$ ] , for which @xmath184 . by assumption value @xmath147",
    "is not in @xmath121 , so there exists such an interval @xmath181 $ ] that contains @xmath147 .",
    "furthermore , @xmath152 intersects @xmath121 , so it is not included in @xmath181 $ ] .",
    "therefore , @xmath185 is forced to 0 and ( [ eqn::firstgcc ] ) prunes @xmath147 from @xmath157 .",
    "there are @xmath24 constraints ( [ eqn::firstgcc ] ) that can be woken @xmath62 times down the branch of the search tree in @xmath63 , so a total of @xmath49 down the branch .",
    "there are @xmath64 constraints ( [ eqn::bigagcc ] ) which can be woken @xmath65 times each down the branch for a total cost in @xmath65 time down the branch .",
    "thus a total of @xmath24 .",
    "there are @xmath64 constraints ( [ eqn::gcctriangle ] ) that can be woken @xmath65 times down the branch .",
    "each propagation takes @xmath63 time to execute for a total of @xmath24 time down the branch .",
    "the final complexity down the branch of the search tree is therefore @xmath186 .",
    "what about bound consistency of the constraint ?",
    "as in the case of , by replacing constraints ( [ eqn::firstgcc ] ) by constraints ( [ eqn::secondbc ] ) and ( [ eqn::thirdbc ] ) , the decomposition achieves bc .",
    "[ thm : gcc - bc2 ] enforcing bc on constraints ( [ eqn::secondbc ] ) , ( [ eqn::thirdbc ] ) , ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) achieves bc on the corresponding constraint in @xmath24 time down any branch of the search tree .",
    "* proof :  * the proof follows that for theorem  [ thm : gcc - bc ] except that fixing @xmath70 prunes the bounds of @xmath71 if and only if exactly one bound of the domain of @xmath26 intersects the interval @xmath74 $ ] .",
    "the complexity reduces to @xmath24 as bc on ( [ eqn::secondbc ] ) and ( [ eqn::thirdbc ] ) is in @xmath24 ( see theorem [ theo : alldiffbc ] ) and bc on ( [ eqn::bigagcc ] ) and ( [ eqn::lastgcc ] ) is in @xmath24 ( see theorem [ thm : gcc - bc ] ) .",
    "the best known algorithm for bc on runs in @xmath65 time at each call @xcite and can be awaken @xmath75 times down a branch .",
    "this gives a total of @xmath187 , which is greater than the @xmath24 here when @xmath188 .",
    "our decomposition is also interesting because , as we show in the next section , we can use it to combine together propagators .",
    "many other global constraints that count variables or values can be decomposed in a similar way .",
    "for example , the global constraint @xmath189 , [ y_1 , \\ldots , y_n])$ ] is satisfied if and only if the @xmath190 variables are a permutation of the @xmath26 variables .",
    "a monolithic flow - based propagator for this constraint is given in @xcite .",
    "the following decomposition encodes the constraint where @xmath28 , @xmath29 , @xmath191 and @xmath192 : @xmath193 , &    b_{ilu } = 1 \\iff y_i \\in [ l , u ] \\\\ &   n_{lu } = \\sum_{i=1}^n a_{ilu } , &     n_{lu } = \\sum_{i=1}^n b_{ilu } \\\\ &   n_{1u } = n_{1k } + n_{(k+1)u } & \\end{aligned}\\ ] ]    this decomposition can be obtained by posting decompositions for @xmath194,[o_1,\\ldots , o_m])$ ] and @xmath195,[o_1,\\ldots , o_m])$ ] and eliminating common sub - expressions (  is an extended form of the constraint in which upper and lower bounds on occurrences of values are replaced by integer variables ) .",
    "this is another argument in favor of decompositions since it allows constraints to share `` internal '' state through common intermediate variables .",
    "such sharing can increase propagation .",
    "consider the following example : @xmath196 if we have @xmath197 $ ] for @xmath198 then both @xmath199,[o_1,o_2,o_3,o_4,o_5])$ ] and @xmath200,[o_1,o_2,o_3,o_4,o_5])$ ] are bc .",
    "however , enforcing bc on the decomposition of @xmath201 , [ y_1 , y_2])$ ] removes @xmath202 from the domain of @xmath17 and @xmath203 .",
    "in fact , we conjecture that enforcing bc on this decomposition achieves bc on the constraint itself .",
    "similar decompositions can be given for other global constraints like and .",
    "to test these decompositions , we ran experiments on pseudo - boolean encodings ( pb ) of csps containing and constraints .",
    "we used the minisat+ 1.13 solver on an intel xeon 4 cpu , 2.0 ghz , 4 g ram with a timeout of @xmath204 seconds for each experiment .",
    "our decompositions contain two types of constraints : constraints like ( [ eqn::lastrange ] ) and constraints like ( [ eqn::firstrange ] ) . the constraints is posted directly to the minisat+ solver .",
    "to encode constraints , we use literals @xmath205 for the truth of @xmath206  @xcite , and clauses of the form @xmath207 .",
    "this achieves bound consistency ( theorem [ theo : alldiffbc ] ) .",
    "to increase propagation , we use a direct encoding with literals @xmath208 for the truth of @xmath209 and clauses @xmath210 , @xmath211 $ ] .",
    "the overall consistency achieved is therefore between bc and rc .",
    "we denote this encoding @xmath212 . to explore the impact of small hall intervals , we also tried @xmath213 , a pb encoding with only those constraints ( [ eqn::lastrange ] ) for which @xmath214 .",
    "this detects hall intervals of size at most @xmath215 . finally , we decomposed into a clique of binary inequalities , and used a direct encoding to convert this into sat ( denoted @xmath216 ) .",
    "[ [ pigeon - hole - problems . ] ] pigeon hole problems .",
    "+ + + + + + + + + + + + + + + + + + + + +    table  [ t : t1 ] gives results on pigeon hole problems ( php ) with @xmath6 pigeons and holes .",
    "our decomposition is both faster and gives a smaller search tree compared to the @xmath216 decomposition . on such problems , detecting large hall intervals is essential .    .[t",
    ": t1]php problems .",
    "@xmath217 is time and @xmath218 is the number of backtracks to solve the problem .",
    "[ cols=\"^ , > , < , > , < , > , < , > , < , > , < , > , < \" , ]",
    "the constraint first appeared in the alice constraint programming language @xcite .",
    "regin proposed a dc propagator that runs in @xmath219 time @xcite .",
    "leconte gave a rc propagator based on hall intervals that runs in @xmath220 time @xcite .",
    "puget then developed a bc propagator also based on hall intervals that runs in @xmath221 time @xcite .",
    "this was later improved by melhorn and thiel @xcite and then lopez - ortiz _ et al .",
    "_ @xcite .    the global cardinality constraint ,",
    "was introduced in the charme language @xcite .",
    "regin proposed a dc propagator based on network flow that runs in @xmath220 time @xcite .",
    "katriel and thiel proposed a bc propagator for the constraint @xcite .",
    "_ proved that enforcing dc on the constraint is np - hard @xcite .",
    "they also improved the time complexity to enforce dc and gave the first propagator for enforcing rc on .",
    "many decompositions have been given for a wide range of global constraint .",
    "however , decomposition in general tends to hinder propagation .",
    "for instance , @xcite shows that the decomposition of constraints into binary inequalities hinders propagation . on the other hand , there are global constraints where decompositions have been given that do not hinder propagation .",
    "for example , beldiceanu _ et al .",
    "_ identify conditions under which global constraints specified as automata can be decomposed into signature and transition constraints without hindering propagation @xcite . as a second example",
    ", many global constraints can be decomposed using and which can themselves often be propagated effectively using simple decompositions @xcite . as a third example , decompositions of the and constraints have been given that do not hinder propagation @xcite .",
    "as a fourth example , decompositions of the constraint have been shown to be effective @xcite .",
    "finally , the constraint can be decomposed into ternary constraints without hindering propagation @xcite .",
    "we have shown that some common global constraints like and can be decomposed into simple arithmetic constraints whilst still maintaining a global view that achieves range or bound consistency .",
    "these decompositions are interesting for a number of reasons .",
    "first , we can easily incorporate them into other solvers .",
    "second , the decompositions provide other constraints with access to the state of the propagator .",
    "third , these decompositions provide a fresh perspective on propagation of global constraints .",
    "for instance , our results suggest that it may pay to focus propagation and nogood learning on small hall intervals .",
    "finally , these decompositions raise an important question .",
    "are there propagation algorithms that can not be efficiently simulated using decompositions ? in @xcite , we use circuit complexity to argue that a domain consistency propagator for the constraint can not be simulated using a polynomial sized decomposition .",
    "= -1pt n.  beldiceanu , i.  katriel , and s.  thiel . filtering algorithms for the same constraint . in _",
    "1st int . conf . on integration of ai and or techniques in cp _ , 6579 , 2004 . n.  beldiceanu , i.  katriel , and s.  thiel .",
    "reformulation of global constraints based on constraints checkers filtering algorithms for the same constraint . , 10(4 ) : 339362 , 2005 .      c. bessiere , e. hebrard , b. hnich , z. kiziltan and t. walsh .",
    "the range constraint : algorithms and implementation . in _",
    "conf . on integration of ai and or techniques in cp ( cp - ai - or ) _ , 5973 , 2006 .",
    "a.  oplobedu , j.  marcovitch , and y.  tourbier .",
    ": un langage",
    "industriel de programmation par contraintes , illustre par une application chez renault . in _ 9th int .",
    "workshop on expert systems and their applications _ , 1989 ."
  ],
  "abstract_text": [
    "<S> we show that some common and important global constraints like and can be decomposed into simple arithmetic constraints on which we achieve bound or range consistency , and in some cases even greater pruning . </S>",
    "<S> these decompositions can be easily added to new solvers . </S>",
    "<S> they also provide other constraints with access to the state of the propagator by sharing of variables . </S>",
    "<S> such sharing can be used to improve propagation between constraints . </S>",
    "<S> we report experiments with our decomposition in a pseudo - boolean solver . </S>"
  ]
}