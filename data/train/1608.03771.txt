{
  "article_text": [
    "unification @xcite is an operation to make two logical expressions equal by finding substitutions into variables .",
    "there are numerous applications in computer science , in particular of ( efficient ) first - order unification , for example in automated reasoning , type checking and verification .",
    "unification algorithms are also extended to higher - order calculi with various equivalence relations .",
    "if equality includes @xmath0-conversion and @xmath1-reduction and perhaps also @xmath2-conversion of a ( typed or untyped ) lambda - calculus , then unification procedures are known ( see e.g. @xcite ) , however , the problem is undecidable @xcite .",
    "our motivation comes from syntactical reasoning on higher - order expressions , with equality being alpha - equivalence of expressions , and where a unification algorithm is demanded as a basic service .",
    "nominal unification is the extension of first - order unification with abstractions .",
    "it unifies expressions w.r.t .",
    "alpha - equivalence , and employs permutations as a clean treatment of renamings .",
    "it is known that nominal unification is decidable in exponential time @xcite , where the complexity of the decision problem is polynomial time @xcite .",
    "it can be seen also from a higher - order perspective @xcite , as equivalent to miller s higher - order pattern unification @xcite .",
    "there are efficient algorithms @xcite , formalizations of nominal unification @xcite , formalizations with extensions to commutation properties within expressions @xcite , and generalizations of nominal unification to narrowing @xcite , and to equivariant ( nominal ) unification @xcite .",
    "we are interested in unification w.r.t .",
    "an additional extension with cyclic let . to the best of our knowledge",
    ", there is no nominal unification algorithm for higher - order expressions permitting also general binding structures like a cyclic let .",
    "the motivation and intended application scenario is as follows : constructing syntactic reasoning algorithms for showing properties of program transformations on higher - order expressions in call - by - need functional languages ( see for example @xcite ) that have a letrec - construct ( also called cyclic let ) @xcite as in haskell @xcite , ( see e.g.  @xcite for a discussion on reasoning with more general name binders , and @xcite for a formalization of general binders in isabelle ) .",
    "there may be applications also to coinductive extensions of logic programming @xcite and strict functional languages @xcite .",
    "basically , overlaps of expressions have to be computed ( a variant of critical pairs ) and reduction steps ( under some strategy ) have to be performed . to this end ,",
    "first an expressive higher - order language is required to represent the meta - notation of expressions .",
    "for example , the meta - notation @xmath3 for a beta - reduction is made operational by using unification variables @xmath4 for @xmath5 .",
    "the scoping of @xmath6 and @xmath7 is different , which can be dealt with by nominal techniques .",
    "in fact , a more powerful unification algorithm is required for meta - terms employing recursive letrec - environments .",
    "our main algorithm  is derived from first - order unification and nominal unification : from first - order unification we borrowed the decomposition rules , and the sharing method from martelli - montanari - style unification algorithms @xcite .",
    "the adaptations of decomposition for abstractions and the advantageous use of permutations of atoms is derived from nominal unification algorithms .",
    "decomposing letrec - expression requires an extension by a permutation of the bindings in the environment , where , however , one has to take care of scoping . since in contrast to the basic nominal unification , there are nontrivial fixpoints of permutations ( see example [ example : fixpoints - possible ] ) , novel techniques are required and lead to a surprisingly moderate complexity : a fixed - point shifting rule ( fps ) and a redundancy removing rule ( elimfp ) together bound the number of fixpoint equations @xmath8 ( where @xmath9 is a permutation ) using techniques and results from computations in permutation groups .",
    "the application of these techniques is indispensable ( see example [ example : exponential - fps ] ) for obtaining efficiency .",
    "_ results _ : a nominal letrec unification algorithm which is complete and runs in nondeterministic polynomial time ( theorem [ thm : unification - terminates ] ) .",
    "the nominal letrec unification problem is np - complete ( theorem [ thm : matching - np - hard ] ) .",
    "nominal letrec matching is np - complete ( theorem [ thm : matching - in - np],[thm : matching - np - hard ] ) .",
    "nominal letrec matching for dags is in np and outputs substitutions only ( theorem [ thm : nom - dag - matching ] ) , and a very restricted nominal letrec matching problem is graph - isomorphism hard ( theorem [ thm : matching - gi - hard ] ) .",
    "we define the language @xmath10 ( * l*et*r*ec * l*anguage ) of expressions , which is a lambda calculus extended with a recursive let construct . the notation is consistent with @xcite .",
    "the ( infinite ) set of atoms @xmath11 is a set of ( constant ) symbols @xmath12 denoted also with indices ( the variables in lambda - calculus ) .",
    "there is a set @xmath13 of function symbols with arity @xmath14 .",
    "the syntax of the expressions @xmath15 of @xmath10 is : + @xmath16    we also use tuples , which are written as @xmath17 , and which are treated as functional expressions in the language .",
    "we assume that binding atoms @xmath18 in a letrec - expression @xmath19 are pairwise distinct .",
    "sequences of bindings @xmath20 are abbreviated as @xmath21 .",
    "the _ scope _ of atom @xmath22 in @xmath23 is standard : @xmath22 has scope @xmath15 .",
    "the @xmath24-construct has a special scoping rule : in @xmath25 , every free atom @xmath26 in some @xmath27 or @xmath28 is bound by the environment @xmath29 .",
    "this defines the notion of free atoms @xmath30 , bound atoms @xmath31 in expression @xmath15 , and all atoms @xmath32 in @xmath15 .",
    "for an environment @xmath33 , we define the set of letrec - atoms as @xmath34 .",
    "@xmath22 is fresh for @xmath15 _ iff @xmath35 ( also denoted as @xmath36 ) . as an example",
    ", the expression @xmath37 represents an infinite list @xmath38 , where @xmath39 are expressions .",
    "however , since our language @xmath10 is only a fragment of core calculi @xcite , the reader may find more programming examples there .",
    "we will use mappings on atoms from @xmath11 .",
    "a _ swapping _",
    "@xmath40 is a function that maps an atom @xmath22 to atom @xmath41 , atom @xmath41 to @xmath22 , and is the identity on other atoms .",
    "we will also use finite permutations on atoms from @xmath11 , which are represented as a composition of swappings in the algorithms below .",
    "let @xmath42 .",
    "then every finite permutation can be represented by a composition of at most @xmath43 swappings .",
    "composition @xmath44 and inverses @xmath45 can be immediately computed .",
    "permutations @xmath9 operate on expressions simply by recursing on the structure . for a letrec - expression",
    "this is @xmath46 @xmath47 @xmath48 .",
    "note that permutations also change names of bound atoms .",
    "we will use the following definition of @xmath0-equivalence :    [ def : alpha - equivalence - sim ] the equivalence @xmath49 on expressions @xmath50 is defined as follows :    * @xmath51 . * if @xmath52 for all @xmath53 , then @xmath54 for an @xmath55-ary @xmath56 . * if @xmath57 , then @xmath58 . * if for @xmath59 , @xmath60 , @xmath61 , then @xmath62 . *",
    "@xmath63 iff there is some permutation @xmath64 on @xmath65 , such that @xmath66 .",
    "note that @xmath49 is identical to the equivalence relation generated by @xmath0-equivalence of binding constructs and permutation of bindings in a letrec .",
    "we need fixpoint sets of permutations @xmath9 : we define @xmath67 . in usual nominal unification",
    ", these sets can be characterized by using freshness constraints @xcite . clearly , all these sets and also all finite intersections are nonempty , since at least fresh atoms are elements and since @xmath11 is infinite",
    ". however , in our setting , these sets are nontrivial :    [ example : fixpoints - possible ] the @xmath0-equivalence @xmath68 @xmath49 @xmath69 holds , which means that there are expressions @xmath70 in @xmath10 with @xmath71 and @xmath72 .    in the following",
    "we will use the results on complexity of operations in permutation groups , see @xcite , and @xcite .",
    "we consider a set @xmath73 of distinct objects ( in our case the atoms ) , the symmetric group @xmath74 ( of size @xmath75 ) of permutations of the objects , and consider its elements , subsets and subgroups .",
    "subgroups are always represented by a set of generators . if @xmath76 is a set of elements ( or generators ) , then @xmath77 denotes the generated subgroup .",
    "some facts are :    * permutations can be represented in space linear in @xmath55 . * every subgroup of @xmath74 can be represented by @xmath78 generators .",
    "however , elements in a subgroup may not be representable as a product of polynomially many generators .",
    "the following questions can be answered in polynomial time :    * the element - question : @xmath79 ?",
    ", * the subgroup question : @xmath80 .    however , intersection of groups and set - stabilizer ( i.e. @xmath81 ) are not known to be computable in polynomial time , since those problems are as hard as graph - isomorphism ( see @xcite ) .",
    "as an extension of @xmath10 , there is also a countably infinite set of ( unification ) variables @xmath82 also denoted perhaps using indices .",
    "the syntax of the language @xmath83 ( * l*et*r*ec * l*anguage e*x*tended ) is @xmath84 @xmath85 is the set of variables and @xmath86 is the set of variables @xmath87 occurring in @xmath15 .",
    "the expression @xmath88 for a non - variable @xmath15 means an operation , which is performed by shifting @xmath9 down , using the simplification @xmath89 @xmath90 @xmath91 , apply it to atoms , where only expressions @xmath92 remain , which are called _",
    "suspensions_.    a _ freshness constraint _ in our unification algorithm is of the form @xmath93 , where @xmath15 is an @xmath83-expression , and an _ atomic _ freshness constraint is of the form @xmath94 .",
    "[ def : simplification - freshness ]     @xmath95 @xmath96 @xmath97 @xmath98   + @xmath99       { \\{a{{{\\#}}}({{\\tt letrec}}~a_1.s_1;\\ldots , a_n.s_n~{{\\tt in}}~r)\\ } { \\ensuremath{\\mathaccent\\cdot\\cup}}\\nabla}{\\nabla}$ ] + @xmath100     { \\{a{{{\\#}}}({{\\tt letrec}}~a_1.s_1;\\ldots , a_n.s_n~{{\\tt in}}~r)\\ } { \\ensuremath{\\mathaccent\\cdot\\cup}}\\nabla }        { \\{a{{{\\#}}}s_1,\\ldots a{{{\\#}}}s_n , a{{{\\#}}}r\\ } { \\ensuremath{\\mathaccent\\cdot\\cup}}\\nabla}$ ]   @xmath101    an @xmath83-unification problem is a pair @xmath102 , where @xmath103 is a set of equations @xmath104 , and @xmath105 is a set of freshness constraints .",
    "a _ ( ground ) solution _ of @xmath102 is a substitution @xmath64 ( mapping variables in @xmath106 to ground expressions ) , such that @xmath107 for @xmath108 and for all @xmath109 : @xmath110 holds .",
    "+ the decision problem is whether there is a solution for given @xmath102 .",
    "let @xmath102 be an @xmath83-unification problem .",
    "we consider triples @xmath111 , where @xmath112 is a substitution ( compressed as a dag ) mapping variables to @xmath83-expressions , @xmath113 is a set of freshness constraints , and @xmath114 is a set of fixpoint constraints of the form @xmath115 , where @xmath116 .",
    "a triple @xmath111 is a _ unifier _ of @xmath102 , if ( i ) there exists a ground substitution @xmath64 that solves @xmath117 , i.e. , for every @xmath118 in @xmath113 , @xmath119 is valid , and for every @xmath115 in @xmath114 , @xmath120 ; and ( ii ) for every ground substitution @xmath64 that instantiates all variables in @xmath121 which solves @xmath117 , the ground substitution @xmath122 is a solution of @xmath102 .",
    "a set @xmath123 of unifiers is _ complete _ , if every solution @xmath124 is covered by at least one unifier , i.e. there is some unifier @xmath111 in @xmath123 , and a ground substitution @xmath64 , such that @xmath125 for all @xmath126",
    ".    we will employ nondeterministic rule - based algorithms computing unifiers : there is a clearly indicated subset of disjunctive ( do nt know non - deterministic ) rules .",
    "the _ collecting variant _ of the algorithm runs and collects all solutions from all alternatives of the disjunctive rules .",
    "the _ decision variant _ guesses one possibility and tries to compute a single unifier .    since we want to avoid the exponential size explosion of the robinson - style unification algorithms , keeping the good properties of martelli montanari - style unification algorithms @xcite , but not their notational overhead , we stick to a set of equations as data structure . as a preparation for the algorithm ,",
    "all expressions in equations are exhaustively flattened as follows : @xmath127 plus the equations @xmath128 .",
    "also @xmath129 is replaced by @xmath130 with equation @xmath131 , and @xmath132 is replaced by @xmath133 with the additional equations @xmath134 .",
    "the introduced variables are always fresh ones .",
    "we may denote the resulting set of equations of flattening an equation @xmath135 as @xmath136 .",
    "thus , all expressions in equations are of depth at most 1 , where we do not count the permutation applications in the suspensions .    a dependency ordering on @xmath137 is required : if @xmath138 is in @xmath103 , and @xmath15 is not a variable nor a suspension and @xmath139 , then @xmath140 , let @xmath141 be the transitive closure of @xmath142 .",
    "this ordering is only used , if no standard rules and no failure rules ( see definition [ def : failure - rules ] ) apply , hence there are no cycles",
    ".       operates on a tuple @xmath143 , where @xmath103 is a set of flattened equations @xmath144 , where we assume that @xmath145 is symmetric , @xmath105 contains freshness constraints , @xmath146 represents the already computed substitution as a list of replacements of the form @xmath147 .",
    "initially @xmath146 is empty .",
    "the final state will be reached , i.e. the output , when @xmath103 only contains fixpoint equations of the form @xmath8 that are non - redundant , and the rule ( output ) fires .    in the notation of the rules",
    ", we use @xmath148 $ ] as substitution that replaces @xmath87 by @xmath15 . in the rules",
    ", we may omit @xmath105 or @xmath146 if they are not changed .",
    "we will use a notation `` @xmath149 '' in the consequence part of one rule , perhaps with a set of possibilities , to denote disjunctive ( i.e. do nt know ) nondeterminism . the only nondeterministic rule that requires exploring all alternatives is rule ( 7 ) below .",
    "the other rules can be applied in any order , where it is not necessary to explore alternatives .    [",
    "[ standard-1233-and - decomposition - rules-4567 ] ] standard ( 1,2,3,3 ) and decomposition rules ( 4,5,6,7 ) : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    @xmath150 @xmath151 + ( 3)@xmath152 ,   \\nabla[\\pi{\\cdot}y / x ] , \\theta \\cup \\{x \\mapsto \\pi{\\cdot}y\\}}}}$ ] ( 3)@xmath153 ,   \\nabla[y / x ] , \\theta \\cup \\{x \\mapsto y\\}}}}$ ] + @xmath154 + @xmath155 @xmath156 + @xmath157 + where @xmath64 is a permutation on @xmath65",
    ". +    [ [ main - rules ] ] main rules : + + + + + + + + + + +    the following rules ( mms ) ( martelli - montanari - simulation ) and ( fps ) ( fixpoint - shift ) will always be immediately followed by a decomposition of the resulting set of equations .",
    "@xmath158 ,     if @xmath5 are neither variables + nor suspensions .",
    "+  @xmath159 ,    if @xmath87 is maximal w.r.t .",
    "@xmath160 , @xmath161 , and @xmath15 is neither a variable nor a suspension , and no failure rule ( see below ) is applicable .",
    "+  @xmath162 if @xmath163 +  @xmath164    if @xmath103 only consists + of fixpoint - equations .",
    "we assume that the rule will be applied whenever possible .",
    "note that the two rules ( mms ) and ( fps ) , without further precaution , may cause an exponential blow - up in the number of fixpoint - equations .",
    "the rule ( elimfp ) will limit the number of fixpoint equations by exploiting knowledge on operations on permutation groups .",
    "the rule ( output ) terminates an execution on @xmath165 by outputting a unifier @xmath166 .",
    "note that in any case at least one solution is represented :    the top symbol of an expression is defined as @xmath167 , @xmath168 , @xmath169 , @xmath170 , @xmath171 , @xmath172 .",
    "let @xmath173 .",
    "_ failure rules of _ [ def : failure - rules ]    clash failure : : :    if @xmath174 ,    @xmath175 ,    @xmath176 , but    @xmath177 .",
    "cycle detection : : :    if there are equations    @xmath178 where    @xmath179 , and    @xmath180 occurs in @xmath181 for    @xmath182 and @xmath6 occurs in    @xmath183 .",
    "freshness fail : : :    if there is a freshness constraint @xmath184 .",
    "freshness solution fail : : :    if there is a freshness constraint    @xmath185 , and    @xmath186 .",
    "the computation of @xmath187 can be done in polynomial time by iterating over the solution components .",
    "we illustrate the letrec - rule by a ground example without flattening .",
    "let the equation be : @xmath188 select the identity permutation @xmath64 , which results in : @xmath189 ( the freshness constraint @xmath190 holds ) .",
    "then the application of the @xmath191-rule gives @xmath192 ( the freshness constraint @xmath193 holds ) .",
    "the resulting equation is @xmath194 which obviously holds .",
    "[ example : exponential - fps ] this example shows that fps ( together with the standard and decomposition rules ) may give rise to an exponential number of equations on the size of the original problem .",
    "let there be variables @xmath195 and the equations @xmath196 @xmath197 where @xmath198 are permutations .",
    "we prove that this unification problem may give rise to @xmath199 many equations , if the redundancy rule ( elimfp ) is not there .",
    "+    ll the first step is by ( fps ) : &    @xmath200     +    ll using decomposition and inversion : &    @xmath201    [ cols= \" < , < \" , ]     now it is easy to see that all equations @xmath202 are generated , with @xmath203 where @xmath64 is a composition of a subsequence of @xmath204 , which makes @xmath199 equations .",
    "the permutations are pairwise different using an appropriate choice of @xmath205 and @xmath9 .",
    "the starting equations can be constructed using the decomposition rule of abstractions .",
    "[ thm : unification - terminates ] the decision variant of the algorithm  runs in nondeterministic polynomial time .",
    "its collecting version returns a complete set of at most exponentially many unifiers , every one represented in polynomial space .",
    "note that we assume that the input equations are flattened before applying the rules , which can be performed in polynomial time .",
    "let @xmath206 be the input , and let @xmath207 .",
    "the execution of a single rule can be done in polynomial time depending on the size of the intermediate state , thus we have to show that the size of the intermediate states remains polynomial and that the number of rule applications is at most polynomial .",
    "the termination measure @xmath208 , which is ordered lexicographically , is as follows : @xmath209 is the number of letrec expressions in @xmath103 , @xmath210 is the number of letrec- , @xmath191-symbols , function - symbols and atoms in @xmath103 , @xmath211 is the number of different variables in @xmath103 , @xmath212 is the number of occurrences of variables in @xmath103 , @xmath213 is the number of equations not of the form @xmath214 , and @xmath215 is the number of equations .",
    "since shifting permutations down and simplification of freshness constraints both terminate and do not increase the measures , we only compare states which are normal forms for shifting down permutations and simplifying freshness constraints .",
    "we assume that the algorithm stops if a failure rule is applicable , and that the rules ( mms ) and ( fps ) are immediately followed by a full decomposition of the results ( or failure ) .",
    "now it is easy to check that the rule applications strictly decrease @xmath124 : the rules ( mms ) and ( fps ) together with the subsequent decomposition strictly decrease @xmath216 . since expressions in equations are flat , ( mms ) does not increase the size : @xmath217 is first replaced by @xmath218 , and the latter is decomposed , which due to flattening results only in equations containing variables and suspensions .",
    "thus @xmath210 is reduced by the size of @xmath219 . in the same way ( fps )",
    "strictly decreases @xmath216 .",
    "in addition @xmath210 is at most @xmath220 , since only the letrec - decomposition rule can add @xmath221-constructs .",
    "the number of fixpoint - equations for every variable @xmath87 is at most @xmath222 for some ( fixed ) @xmath223 , since the number of atoms is never increased , and since we assume that is applied whenever possible .",
    "the size of the permutation group is at most @xmath224 , and so the length of proper subset - chains and hence the maximal number of generators of a subgroupp is at most @xmath225 .",
    "note that the redundancy of generators can be tested in polynomial time depending on the number of atoms .",
    "now we prove a ( global ) upper bound on the number @xmath211 of variables : an application of ( 7 ) may increase @xmath211 at most by @xmath226 .",
    "an application of ( fps ) may increase this number at most by @xmath227 , where the worst case occurs when @xmath15 is a letrec - expression . since ( mms ) and ( fps )",
    "can be applied at most @xmath226 times , the number of variables is smaller than @xmath228 .",
    "the other rules strictly decrease @xmath216 , or they do not increase @xmath216 , and strictly decrease @xmath229 and can be performed in polynomial time .    the problematic rule for complexity is ( fps ) , which does not increase @xmath209 and @xmath210 , but may increase @xmath211 , @xmath212 and @xmath215 ( see example [ example : exponential - fps ] ) .",
    "this increase is defeated by the rule ( elimfp ) , which helps to keep the numbers @xmath212 and @xmath215 low .",
    "[ thm : unification - sound - and - complete ] the algorithm   is sound and complete .",
    "soundness of the algorithm holds , by easy arguments for every rule , similar as in @xcite , and since the letrec - rule follows the definition of @xmath49 in def .",
    "[ def : alpha - equivalence - sim ] .",
    "a further argument is that the failure rules are sufficient to detect final states without solutions .",
    "completeness requires more arguments .",
    "the decomposition and standard rules ( with the exception of rule ( 7 ) ) , retain the set of solutions . the same for ( mms ) , ( fps ) , and . the nondeterministic rule ( 7 )",
    "provides all possibilities for potential ground solutions .",
    "moreover , the failure rules are not applicable to states that are solvable .",
    "a final output of  has at least one ground solution as instance : we can instantiate all variables that remain in @xmath230 by a fresh atom",
    ". then all fixpoint equations are satisfied , since the permutations can not change this atom , and since the ( atomic ) freshness constraints hold",
    ". this ground solution can be represented in polynomial space by using @xmath146 , plus an instance @xmath231 for all remaining variables @xmath87 and a fresh atom @xmath22 , and removing all fixpoint equations and freshness constraints .",
    "[ thm : letrec - unification - in - np ] the nominal letrec - unification problem is in @xmath232 .",
    "this follows from theorems [ thm : unification - terminates ] and [ thm : unification - sound - and - complete ] .",
    "reductions in higher order calculi with letrec , in particular on a meta - notation , require a matching algorithm , matching its left hand side to an expression .    consider the ( lbeta)-rule , which is the version of ( beta ) used in call - by - need calculi with sharing @xcite .",
    "@xmath233 an ( lbeta ) step , for example , on @xmath234 is performed by switching to the language @xmath235 and then matching @xmath236 , where @xmath237 is the explicit representation of the binary application operator .",
    "this results in @xmath238 , and the reduction result is the @xmath112-instance of @xmath239 , which is @xmath240 . note that only the sharing power of the recursive environment is used here .",
    "we derive a nominal matching algorithm as a specialization of .",
    "we use nonsymmetric equations written @xmath241 , where @xmath242 is an @xmath83-expression , and @xmath70 does not contain variables .",
    "note that neither freshness constraints nor suspensions are necessary ( and hence no fixpoint equations ) .",
    "we assume that the input is a set of equations of ( plain ) expressions",
    ".    the rules of the algorithm   are : + @xmath243 @xmath244 @xmath245 + @xmath246 if @xmath247 , otherwise fail .",
    "+ @xmath248 + where @xmath64 is a ( mathematical ) permutation on @xmath65 + @xmath249 if @xmath250 , otherwise fail + the test @xmath250 will be performed by the ( nondeterministic ) matching rules .",
    "clash failure : : :    if @xmath174 ,    @xmath251 ,    but @xmath177 .",
    "[ thm : matching - in - np ]   is sound and complete for nominal letrec matching .",
    "it decides nominal letrec matching in nondeterministic polynomial time .",
    "its collecting version returns a finite complete set of an at most exponential number of matching substitutions , which are of at most polynomial size .",
    "this follows by standard arguments .",
    "nominal letrec matching is np - complete .",
    "the problem is in np , which follows from theorem [ thm : matching - in - np ] .",
    "it is also np - hard , which follows from the ( independent ) theorem [ thm : matching - np - hard ] .    a slightly more general situation for matching occurs , when the matching equations @xmath165 are compressed using a dag .",
    "we construct a practically more efficient algorithm  from  as follows .",
    "first we generate @xmath252 from @xmath165 , which only contains ( plain ) flattened expressions by encoding the dag - nodes as variables together with an equation .",
    "an expression is said @xmath165-ground , if it does not reference variables from @xmath165 ( also via equations ) . in order to avoid suspension ( i.e. to have nicer results ) , the decomposition rule for @xmath191-expressions with different binder names is modified as follows :    @xmath253   @xmath254 is @xmath165-ground +    the extra conditions @xmath255 and @xmath165-ground can be tested in polynomial time .",
    "the equations @xmath252 are processed applying  ( with the mentioned modification ) with the guidance that the right - hand sides of match - equations are also right - hand sides of equations in the decomposition rules .",
    "the resulting matching substitutions can be interpreted as the instantiations into the variables of @xmath165 .",
    "since @xmath165 is a matching problem , the result will be free of fixpoint equations , and there will be no freshness constraints in the solution .",
    "thus we have :    [ thm : nom - dag - matching ] the collecting variant of  outputs an at most exponential set of dag - compressed substitutions that is complete and where every unifier is represented in polynomial space .",
    "[ thm : matching - np - hard ] nominal letrec matching ( hence also unification ) is np - hard , for two letrec expressions , where subexpressions are free of letrec .",
    "we encode the np - hard problem of finding a hamiltonian cycle in regular graph @xcite : let @xmath256 be the vertexes of the graph , and @xmath257 be the set of edges .",
    "the first environment part is @xmath258 , and a second environment part @xmath259 consists of bindings @xmath260 for every edge @xmath261 for fresh names @xmath41 .",
    "then let @xmath262 @xmath263 representing the graph .",
    "let the second expression encode the question whether there is a hamiltonian cycle in a regular graph as follows .",
    "the first part of the environment is @xmath264 .",
    "the second part is @xmath265 consisting of @xmath266 , and the third part consisting of a number of ( dummy ) entries of the form @xmath267 , where @xmath41 is always a fresh atom for every binding , and @xmath268 are fresh variables . the number of these dummy entries can be easily computed from the number of nodes and the degree of the graph , and it is less than the size of the graph .",
    "then the matching problem is solvable iff the graph has a hamiltonian cycle .",
    "[ thm : letrec - iunification - np - complete ] the nominal letrec - unification problem is np - complete .",
    "this follows from theorems [ thm : letrec - unification - in - np ] and [ thm : matching - np - hard ] .",
    "we say that an expression @xmath70 _ contains garbage _ , iff there is a subexpression @xmath269 , and the environment @xmath21 can be split into two environments @xmath270 , such that @xmath271 is not trivial , and the atoms from @xmath272 do not occur in @xmath259 nor in @xmath28 .",
    "otherwise , the expression is _ free of garbage_. since @xmath0-equivalence of @xmath10-expressions is graph - isomorphism - complete @xcite , but @xmath0-equivalence of garbage - free @xmath10-expressions is polynomial , it is useful to look for improvements of unification and matching for garbage - free expressions . as a remark : graph - isomorphism is known to have complexity between @xmath273 and @xmath232 ; there are arguments that it is weaker than the class of np - complete problems @xcite .",
    "there is also a claim that it is quasi - polynomial @xcite , which means that it requires less than exponential time .",
    "[ thm : matching - gi - hard ] nominal letrec matching with one occurrence of a single variable and a garbage - free target expression is graph - isomorphism - hard .    let @xmath274 be two graphs .",
    "let @xmath242 be @xmath275 the encoding of a graph @xmath276 where @xmath271 is the encoding as in the proof of theorem [ thm : matching - np - hard ] and the nodes are encoded as @xmath277 .",
    "then the expression @xmath242 is free of garbage .",
    "let the environment @xmath259 be the encoding of @xmath278 in the expression @xmath279 .",
    "then @xmath70 matches @xmath242 iff the graphs are isomorphic .",
    "hence we have @xmath280-hardness .",
    "if there is an isomorphism of @xmath276 and @xmath278 , then it is easy to see that this bijection leads to an equivalence of the environments , and we can instantiate @xmath87 with @xmath281 .",
    "extending the language by variables @xmath282 that may encode partial letrec - environments would lead to a larger coverage of unification problems in reasoning about the semantics of programming languages .",
    "consider as an example a rule ( llet - e ) that merges letrec environments ( see @xcite ) : + @xmath283 .",
    "+ it can be applied to an expression @xmath284 as follows : the left - hand side @xmath285 of the reduction rule matches @xmath286 with the match : @xmath287 , producing the next expression as an instance of the right hand side @xmath288 , which is : @xmath289 .",
    "note that in the application to extended lambda calculi , a bit more care ( i.e. a further condition ) is needed w.r.t .",
    "scoping in order to get valid reduction results in all cases .",
    "we will now also have partial environments as syntactic objects .",
    "the grammar for the extended language @xmath290 ( * l*et*r*ec * l*anguage e*x*tended with * e*nvironments ) is : @xmath291    we define a matching algorithm , where environment variables may occur in left hand sides .",
    "this algorithm needs a more expressive data structure in equations : a letrec with two environment - components , ( i ) a list of bindings that are already fixed in the correspondence to another environment , and ( ii ) an environment that is not yet fixed .",
    "we denote the fixed bindings as a list , which is the first component . in the notation",
    "we assume that the ( non - fixed ) letrec - environment part on the right hand side may be arbitrarily permuted before the rules are applied .",
    "the justification for this special data structure is the scoping in letrec expressions .",
    "note that suspensions do not occur in this algorithm .",
    "[ def : matchalg - env ] the matching algorithm   for expressions where environment variables @xmath282 and expression variables @xmath87 may occur only in the left hand sides of match equations is described below .",
    "the rules are :    @xmath243 @xmath292 @xmath245 + @xmath246  if , @xmath255",
    "@xmath293 + if @xmath294 , otherwise fail .",
    "+ @xmath295 + @xmath296   @xmath297 { { \\ \\unlhd\\ } } [ e_1';\\ldots;e_n']\\ } } { \\gamma { \\ensuremath{\\mathaccent\\cdot\\cup}}\\{e_1 { { \\ \\unlhd\\ } } e_1 ' ; \\ldots ; e_n { { \\ \\unlhd\\ } } e_n'\\}}}}$ ] + @xmath298 @xmath299    testing @xmath144 and @xmath300 is done with high priority using the ( nondeterministic ) matching rules .",
    "clash failure : : :    if @xmath174 ,    @xmath301 ,    but @xmath177 .",
    "after successful execution , the result will be a set of match equations with components @xmath302 , and @xmath303 , which represents a matching substitution .",
    "the algorithm [ def : matchalg - env ] ( ) is sound and complete .",
    "it runs in non - deterministic polynomial time .",
    "the corresponding decision problem is np - complete .",
    "the collecting version of  returns an at most exponentially large , complete set of representations of matching substitutions , where the representations are of at most polynomial size .",
    "the reasoning for soundness , completeness and termination in polynomial time is a variation of previous arguments .",
    "the nonstandard part is fixing the correspondence of environment parts step - by - step and keeping the scoping .",
    "we constructed a nominal letrec unification algorithm , several nominal letrec matching algorithms for variants , which all run in nondeterministic polynomial time .",
    "future research is to investigate extensions with environment variables @xmath282 , and to investigate nominal matching together with equational theories .",
    "jeannin , j.b . ,",
    "kozen , d. , silva , a. : cocaml : programming with coinductive types . tech . rep .",
    "http://hdl.handle.net/1813/30798 , computing and information science , cornell university ( december 2012 ) , fundamenta informaticae , to appear          luks , e.m .",
    ": permutation groups and polynomial - time computation . in : finkelstein , l. ,",
    "kantor , w.m .",
    "groups and computation , proceedings of a dimacs workshop .",
    "dimacs , vol .",
    "dimacs / ams ( 1991 )"
  ],
  "abstract_text": [
    "<S> a sound and complete algorithm for nominal unification of higher - order expressions with a recursive let is described , and shown to run in non - deterministic polynomial time . </S>",
    "<S> we also explore specializations like nominal letrec - matching for plain expressions and for dags and determine the complexity of corresponding unification problems .    </S>",
    "<S> keywords : nominal unification , lambda calculus , higher - order expressions , recursive let , operational semantics </S>"
  ]
}