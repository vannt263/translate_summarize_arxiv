{
  "article_text": [
    "scheduling in wireless networks involves efficiently allocating network resources among competing network users _ in the presence of uncertainties_. these uncertainties may be either due to unexpected events , such as link failures , or due to intricate cross - layer interactions in wireless networks .",
    "for example , the packet arrival rates may be unknown ( e.g. , @xcite , @xcite ) , which depend on upper layer dynamics such as routing and congestion control protocols .",
    "as another example , the wireless channel statistics may be also unknown ( e.g. , @xcite ) , since they depend on complex network events such as channel fading , power control and node mobilities .    in the presence of such uncertain parameters",
    ", it may no longer be optimal to use the static allocation approach ( e.g. , @xcite ) , which produces periodic schedules by solving a static underlying convex optimization problem ( which usually has exponential size ) with estimated uncertain parameters .",
    "in particular , if these uncertain parameters are slowly converging , or time varying , the estimated parameters may fail to track the changes in their true value , which often leads to suboptimal schedules .",
    "further , it may be impractical to estimate the uncertain parameters for large wireless networks , as the number of the parameters may grow fast ( e.g. , exponentially ) with the size of the network . for a simple illustration ,",
    "consider a wireless network with @xmath0 links , such that each link randomly switches on or off after certain random number of time slots .",
    "in such case , a complete specification of the network topology probabilities may require as large as @xmath1 parameters , which quickly becomes impossible to estimate as @xmath0 grows .",
    "on the other hand , online algorithms ( such as @xcite , @xcite , @xcite , @xcite , @xcite ) are more robust to the changes to the uncertain parameters ( such as arrival rates ) , since they use queue length ( which can also be interpreted as prices @xcite , @xcite ) information for scheduling in each time slot .",
    "for example , it has been shown that @xcite such algorithms can achieve network stability even if the `` instantaneous rates '' of the traffic vary arbitrarily inside the network capacity region .",
    "further , compared to the estimation based approach , these online algorithms may be more scalable to the network size , in the sense that the dimension of the queue length vector corresponds to the number of constraints ( such as rate constraint for each link ) , which usually grows slowly , whereas the number of uncertain parameters can grow very fast ( e.g. , exponentially ) .",
    "in this paper we solve a general class of optimal wireless network scheduling problems with uncertain parameters , whose underlying static problem is described by the convex optimization problem in section [ sec_model_formulation ] .",
    "essentially , we require that the structures of the convex objective functions and convex constraint functions are known , except the values of the uncertain parameters .",
    "these parameters will be generated by certain stochastic processes and observed by the network gradually over time slots .",
    "we propose a greedy primal - dual dynamic algorithm ( algorithm [ alg ] in section [ sec_algorithm ] ) to achieve the optimal scheduling asymptotically .",
    "using the novel technique of fluid limits @xcite , optimality can be guaranteed under the assumption that all the network processes generating the uncertain parameters satisfy slln ( see details in section [ sec_model_formulation ] ) .",
    "note that this assumption is quite mild , since we can guarantee optimality _ as long as these processes converge , no matter how slowly the convergence happen_. thus , intuitively , our algorithm can automatically track the convergence of these processes and correct the mistakes which are made within any finite time history .",
    "our algorithm is a generalization of the well - known max - weight algorithm @xcite , which was shown to be throughput optimal for i.i.d arrival processes .",
    "our algorithm is related to , but different from the utility - optimal scheduling algorithm by neely @xcite , which achieves the optimal scheduling by cleverly transforming the problem into optimizing the time - average of the utility ( and constraint ) functions , to which a dual - type algorithm applies .",
    "our algorithm is also different from the primal - dual algorithm by neely @xcite since we use a scaled queue length ( by @xmath2 ) in the scheduling , which corresponds to the approximated gradient .",
    "stolyar @xcite also proposed a primal - dual type scheduling algorithm , and proved its optimality using a fluid limit obtained from a different scaling .",
    "since the fluid scaling in @xcite is taken over different systems , it is hard to relate the optimality in the fluid limits to the one in the original system .",
    "finally , our algorithm can be used as a mac layer solution for the general framework of cross - layer optimization problem ( e.g. , @xcite , @xcite , @xcite , @xcite ) for wireless networks .",
    "the organization of the following sections is as follows : in section [ sec_model_formulation ] we describe the queueing network model as well as the optimization problem , and in section [ sec_algorithm ] we describe the scheduling algorithm .",
    "section [ sec_analysis ] proves the optimality of the algorithm , section [ sec_simulation ] illustrate the algorithm performance in simulation , and finally section [ sec_conclusion ] concludes this paper .",
    "in this section we describe the queueing network and propose the optimization problem .",
    "we first introduce the queueing network model .",
    "we consider the scheduling problem at the medium access ( mac ) layer of a multi - hop wireless network , where the network is modeled as a set of @xmath0 links .",
    "we assume a time - slotted network model , and in each time slot @xmath3 , the network is in one of the following states : @xmath4 .",
    "the network state can be used to model network topology , channel fading , and user mobility , etc .",
    "we further assume that these network states can be measured by the user nodes , which are assumed to be equipped with channel monitoring devices .",
    "we associate each network state @xmath5 with a finite set of resource allocation modes @xmath6 , where each mode @xmath7 corresponds to a configuration of network resource allocation , such as carrier and frequency selection in ofdm systems , spreading codes choice in cdma systems and time slots assignment in tdma systems .",
    "denote @xmath8 as the uncertain parameters , which are generated by the stochastic process @xmath9 , which is a cumulative vector process whose time average converges to @xmath8 .",
    "specifically , the assumptions on @xmath9 are : 1 ) it is subject to slln , i.e. , with probability 1 ( w.p.1 ) , @xmath10 and 2 ) it has uniformly bounded increment in each time slot : @xmath11 where @xmath12 is a finite constant . for specific examples , consider the cumulative network state process @xmath13 : @xmath14 where @xmath15 is the network state at time slot @xmath3 , and @xmath16 is the indicator function , i.e. , @xmath17 and @xmath18 .",
    "thus , slln implies that w.p.1 , @xmath19 as another example , consider the external packet arrival process @xmath20 , which is a @xmath21 vector representing the cumulative external packet arrivals during the first @xmath3 time slots .",
    "similarly , slln implies that w.p.1 , @xmath22 further , we require that the maximum packet arrivals in any time slot are uniformly bounded : @xmath23 where @xmath24 is a finite constant .",
    "we finally describe the queueing system model .",
    "the queuing dynamics of the network is modeled as follows : @xmath25 where @xmath26 is the queue length vector at time slot @xmath3 , and @xmath27 is the @xmath28 routing matrix , such that @xmath29 , and @xmath30 only if link @xmath31 serves as the next hop for link @xmath32 at time slot @xmath3 , as specified by certain routing protocols , otherwise @xmath33 . note that the routing matrix @xmath27 is a function of the network state , and therefore slln implies @xmath34 @xmath35 is a @xmath21 vector representing the cumulative packet departures during the first @xmath3 time slots , which are determined by the resource allocation modes as specified by the scheduler in each time slot .",
    "specifically , at each time slot @xmath3 with network state @xmath36 , if the scheduler chooses a resource allocation mode @xmath37 , there is an associated departure vector @xmath38 , whose each entry @xmath39 corresponds to the number of packets transmitted successfully by link @xmath31 .",
    "note that the choice of resource allocation mode @xmath37 is subject to the constraint that @xmath40 , so that the queue lengths never become negative .",
    "note that this constraint can be easily satisfied in general systems .",
    "for example , if the allocation mode @xmath37 corresponds to independent sets of the interference graph ( see , for example , @xcite ) , one can simply transmit the subset of links with nonempty queues , which are still independent . in a compact form",
    ", we can express the departure process as @xmath41 where @xmath42 is a matrix whose columns are @xmath38 , and @xmath43 is a vector whose each entry @xmath44 corresponds to the number of time slots that resource allocation mode @xmath45 is chosen during the first @xmath3 time slots .",
    "a basic requirement on the scheduler is that it should achieve rate stability @xcite , i.e. , @xmath46 so that the departure rate of each link is equal to the arrival rate , as required by the underlying static optimization problem , which we formulate in the next subsection .      in this section",
    "we introduce the optimization problem , which is implicitly solved by the optimal schedulers .",
    "the problem is as follows : @xmath47 in the above formulation , @xmath48 as a resource allocation vector when the network state is @xmath36 .",
    "that is , each entry @xmath49 is the asymptotic time fraction ( assuming the limit exists for now ) that resource allocation mode @xmath45 is chosen , during the time slots where the network state is @xmath36 .",
    "thus , @xmath48 is subject to the simplex constraint ( [ eqn_simplex_const ] ) .",
    "@xmath50 is a big vector representing the total resource allocation vector as specified by the scheduler .",
    "@xmath51 is a general convex cost function of variable @xmath52 , and @xmath53 is a vector of general convex constraint functions of variable @xmath52 .",
    "the additional parameter @xmath54 represents the uncertain parameters , which is valid under the assumption that the corresponding processes are subject to slln .",
    "finally , we assume that both @xmath51 and @xmath55 are continuously differentiable as functions of variables @xmath56 .",
    "the formulation of is quite general , which can be used to model various applications in the literature .",
    "for example , if we want to minimize the total transmission power , we can choose @xmath57 , and choose the cost function as follows @xmath58 where @xmath59 is the time fraction that the network state is @xmath36 , and @xmath60 is a power vector where each entry @xmath61 corresponds to the power consumption when resource allocation mode @xmath45 is chosen at network state @xmath36 .",
    "thus , the cost function in ( [ eqn_power_cost ] ) can be interpreted as the average power consumption by the scheduler .",
    "note that we can also encode the power constraint into @xmath62 by choosing @xmath57 and then choosing @xmath63 where @xmath64 is a diagonal matrix where each diagonal entry @xmath65 corresponds to the power consumption when resource allocation mode @xmath37 is chosen when the network state is @xmath36 , and @xmath66 is the power constraint vector . in this case , ( [ eqn_power_const ] )",
    "is equivalent to requiring a constraint of @xmath66 on the average transmission power . in order to encode the network stability constraint",
    ", we can choose @xmath67 and then choose @xmath68 thus , ( [ eqn_stab_const ] ) requires that the average external and internal arrivals should be less than the average departures , in which case the network is rate stable .",
    "in this section we will describe the algorithm to solve . as a standard approach in solving constrained convex optimization problems @xcite , we transform into another static `` penalized '' problem , , to which our scheduling algorithm can directly apply . based on this",
    ", we then introduce the scheduling algorithm which solves and , therefore , also solves .      assuming that is strictly feasible , we first change the constraints in ( [ eqn_cvx_const ] ) as follows @xmath69 where @xmath70 is a small scalar , and @xmath71 is a sufficiently large constant such that the inequality and equality constraints are equivalent .",
    "denote @xmath72 as the optimal cost when the constraint is changed to ( [ eqn_equal_const ] ) .",
    "thus , the optimal value of is @xmath73 .",
    "we have the following sensitivity lemma stating that @xmath72 is a good approximation of @xmath73 with sufficiently small @xmath74 .    [ lem_approx_1 ] denote @xmath75 and @xmath76 as two lagrangian multipliers for @xmath73 and @xmath72 , respectively .",
    "we have @xmath77    we next define the transformed problem as follows : @xmath78 where @xmath79 is a large constant to control approximation accuracy , and @xmath80 corresponds to the penalty term , which corresponds to various standard penalty functions @xcite , e.g. , @xmath81 for @xmath82 . in particular , the standard lyapunov drift analysis ( e.g. , @xcite , @xcite , @xcite , @xcite ) corresponds to the case @xmath83 .",
    "denote @xmath84 as a solution of .",
    "we have the following result holds :    [ lem_approx_2 ] @xmath85 .",
    "denote @xmath86 as a solution of with constraint in ( [ eqn_cvx_const ] ) replaced by ( [ eqn_equal_const ] ) .",
    "we have @xmath87 where @xmath88 is because @xmath89 solves , and @xmath90 is because @xmath86 satisfy the constraint ( [ eqn_equal_const ] ) .",
    "thus , the claim holds .    in the following",
    "we will focus on solving , since lemma [ lem_approx_1 ] and lemma [ lem_approx_2 ] guarantee that achieve an objective function value which is arbitrarily close to the optimal in .",
    "we next describe the scheduling algorithm .",
    "the problems and are static . on the other hand ,",
    "the network is dynamic , and must be described by time series .",
    "therefore , before describing the algorithm , we need to define dynamic counterparts of the static variables @xmath91 and @xmath92 .",
    "we first define empirical resource allocation variable @xmath93 i.e. , each entry @xmath94 corresponds to the time fraction that resource allocation mode @xmath95 is chosen during the first @xmath3 time slots , when the network state is @xmath36 .",
    "note that we have @xmath96 thus , @xmath97 can be interpreted as the empirical value of @xmath98 which is defined in .",
    "similarly , we denote the empirical value of the uncertain parameter @xmath8 as @xmath99 i.e. , @xmath100 is formed by directly taking the average of the process @xmath9 .",
    "further , define the empirical value of @xmath92 as @xmath101 where the cumulative process @xmath102 is defined by @xmath103 and @xmath104 is computed by the scheduler in algorithm [ alg ] .",
    "finally , we introduce some notations . denote @xmath105 and @xmath106 as the gradient operator with respect to variables @xmath48 and @xmath92 , respectively .",
    "further , with an abuse of notation , we use the following abbreviated notations : @xmath107    at each time slot @xmath3 with network state @xmath36 , choose allocation mode @xmath45 , where @xmath108    choose variable @xmath109 such that @xmath110 and update variables @xmath111 , @xmath100 and @xmath112 accordingly .",
    "the algorithm is described as in algorithm [ alg ] .",
    "essentially , the algorithm updates the variables @xmath111 and @xmath112 by computing descent directions @xmath113 and @xmath109 in * step 1 * and * step 2 * , respectively , where @xmath113 is an all - zero vector except an one at the @xmath114-th entry .",
    "further note that constraint @xmath115 can be satisfied implicitly with regular cost and penalty functions , i.e. , assuming the cost for transmitting a set of links is always no smaller than that of transmitting any of its subsets .    from the definition of @xmath111 and @xmath112 ,",
    "these processes are naturally updated as follows @xmath116 thus , algorithm [ alg ] can be viewed as a stochastic gradient algorithm for , where the randomness comes from the time varying functions @xmath117 and @xmath118 , which are subject to the changes in uncertain parameters @xmath100 .",
    "the optimization of ( [ eqn_mink ] ) requires tracking the variables @xmath111 and @xmath100 , in general .",
    "however , in applications the structure of the cost function @xmath119 and penalty function @xmath120 often allows a much simpler computation .",
    "for example , in the important case of optimal power scheduling , where the cost function is formulated as ( [ eqn_power_cost ] ) and the constraint is as ( [ eqn_stab_const ] ) with the typical value @xmath83 , we have @xmath121 where @xmath122 is the empirical time fraction of network state @xmath36 .",
    "thus , the optimization in ( [ eqn_mink ] ) essentially only requires the queue length information ( note that @xmath123 becomes an irrelevant scaling factor in the optimization ) .",
    "in particular , if we are only interested in the rate stability , i.e. , setting the objective function as @xmath124 , the optimization in ( [ eqn_mink ] ) is equivalent to @xmath125 which is the same as the max - weight back - pressure algorithm proposed by @xcite .",
    "we finally conclude this section by the following lemma , which formally shows , essentially , the descent property of algorithm [ alg ] .    [ lem_cond_grad ]",
    "the following properties hold for algorithm [ alg ] :    1 .",
    "@xmath113 solves the following problem @xmath126 2 .",
    "@xmath109 solves the following problem @xmath127    thus , the variables @xmath128 computed by algorithm [ alg ] can be interpreted as the points in the feasible region of which achieves the minimum inner product with the corresponding ( stochastic ) gradients .    for 1 ) ,",
    "note that is a linear programming ( lp ) problem over a simplex , and therefore the solution can be obtained at a vertex @xcite with the minimum directional derivative . for 2 ) , note that is an lp over a hypercube , and therefore the solution is obtained at the boundary points .",
    "thus the claim follows by noting that @xmath129 , since @xmath130 is not a function of @xmath92 .",
    "in this section we will prove the optimality of algorithm [ alg ] .",
    "there are two issues to consider : 1 ) we need to show that algorithm [ alg ] achieves the optimality of asymptotically , and 2 ) we need to show that algorithm [ alg ] is feasible for , i.e. , constraint ( [ eqn_cvx_const ] ) can not be violated .",
    "we first briefly introduce fluid limits , which serves as the key technique for the optimality proof .",
    "we extend the domain of all processes to continuous time by linear interpolation , and define the fluid scaling of a function @xmath131 as @xmath132 where @xmath133 can be functions @xmath134 and @xmath135 .",
    "it can be shown that these scaled functions are uniformly lipschitz - continuous .",
    "thus , according to the arzela - ascoli theorem @xcite , any sequence of functions which is indexed by @xmath136 , i.e. , @xmath137 , contains a subsequence @xmath138 which converges uniformly on compact sets to a set of absolutely continuous functions ( and , therefore , differentiable almost everywhere @xcite ) @xmath139 .",
    "define any such limit as a fluid limit .",
    "( note that fluid limits are denoted by a bar . )",
    "we next state some properties of the fluid limits .",
    "the processes in any fluid limit satisfies the following : for any @xmath140 , we have w.p.1 , @xmath141 and the following properties hold w.p.1 : for all @xmath142 @xmath143    ( [ eqn_zt_bound ] ) follows from algorithm [ alg ] , where each @xmath144 is chosen between @xmath74 and @xmath145 .",
    "( [ eqn_y_bar ] ) and ( [ eqn_t_pi ] ) follows directly from the ( functional ) slln .",
    "we next define the resource allocation variables and auxiliary variables in fluid limit as follows ( one can compare with ( [ eqn_x ] ) and ( [ eqn_z ] ) for similarities ) @xmath146 similarly , define the following variables as the counter parts of @xmath113 and @xmath109 in algorithm [ alg ] : @xmath147 we have the following lemma holds , which states that both @xmath148 and @xmath149 are feasible points for .",
    "[ lem_feasible ] for any fluid limit and @xmath140 , we have    1 .   @xmath148 is feasible for : @xmath150 2 .",
    "@xmath149 is also feasible for : @xmath151 3 .",
    "the derivatives of @xmath152 and @xmath153 are @xmath154    for 1 ) , ( [ eqn_zbar_bound ] ) follows from applying ( [ eqn_zt_bound ] ) to the definitions of @xmath153 , and ( [ eqn_xbar_simplex ] ) follows from applying ( [ eqn_t_pi ] ) to the definition of @xmath152 . similarly we can prove 2 ) , by noting that @xmath155 for any @xmath156 and @xmath157 .",
    "3 ) follows from direct calculation .",
    "we are now ready to prove the optimality of algorithm [ alg ] .      for the ease of presentation ,",
    "we use @xmath158 as a short - hand notation ( note that they are the functions in fluid limits ) , with an abuse of notation . we next establish the following key technical lemma , which , essentially , extends the optimality property in lemma [ lem_cond_grad ] to the fluid limits .",
    "[ lem_fluid_grad ] let a fluid limit @xmath159 and @xmath160 be given .",
    "the following properties hold :    1 .",
    "@xmath161 solves the following problem @xmath162 2 .",
    "@xmath163 solves the following problem @xmath164    thus , the optimality in lemma [ lem_cond_grad ] still holds in fluid limits .",
    "we first outline the proof . for 1 ) , since an lp over a simplex , the optimum must correspond to the vertices with the smallest gradient .",
    "thus , it is sufficient to prove that any resource allocation mode @xmath32 will have @xmath165 if there is a @xmath114 such that @xmath166 which follows from the optimality shown in lemma [ lem_cond_grad ] along a convergent subsequence . for 2 ) , we will prove that for any feasible points @xmath167 of ( [ eqn_lp_u ] ) , we have @xmath168 which also follows from the optimality in lemma [ lem_cond_grad ] along a convergent subsequence .",
    "for the clarity of presentation , the proof is moved to the appendix .",
    "based on the above lemma , we are now ready to prove that algorithm [ alg ] achieves the optimal cost in the fluid limit .",
    "[ lem_optimal_cost ] for any fluid limit , we have for all @xmath140 , @xmath169 where @xmath170 .",
    "thus , the optimality is achieved in the fluid limit .",
    "we first outline the proof .",
    "note that it is always true that @xmath171 since @xmath172 are always feasible points of .",
    "thus , the claim holds if we can prove the reverse direction .",
    "this can be done by defining a proper `` lyapunov '' function @xmath173 and show that @xmath174 , by using the properties in lemma [ lem_fluid_grad ] and the convexity of function @xmath175 .    consider the `` lyapunov '' function as in ( [ eqn_lyapunov ] ) in any fluid limit . from lemma [ lem_feasible ]",
    "we know that for any @xmath140 , @xmath172 are feasible for , and therefore we have @xmath176 due to the definition of @xmath177 . on the other hand , @xmath178 where @xmath88 is obtained by substituting the equation in lemma [ lem_feasible ] ,",
    "@xmath90 is from lemma [ lem_fluid_grad ] , i.e. , @xmath161 and @xmath163 are solutions of and , respectively .",
    "@xmath179 is due to the convexity of function @xmath175 , and @xmath180 is because @xmath84 is the solution of , by definition .",
    "thus , we have @xmath181 from which we conclude that @xmath182 .    having established the optimality in the fluid limit , we are now able to prove optimality in the original system .",
    "the following theorem states that algorithm [ alg ] achieves the optimal cost in the original network .",
    "( _ optimal cost_)[the_cost ] in the original network , the following holds w.p.1 : @xmath183    suppose that it is not true .",
    "then there is a sequence @xmath184 such that @xmath185 from the arzela - ascoli theorem @xcite , there is a subsequence @xmath186 which converges to a fluid limit .",
    "lemma [ lem_optimal_cost ] implies @xmath187 where @xmath88 follows from the fact that for all @xmath188 , @xmath189 and that @xmath175 is continuous .",
    "@xmath90 is because of lemma [ lem_optimal_cost ] .",
    "thus , we have a contradiction , and the claim holds .    in the next subsection",
    "we will continue to prove the feasibility result , namely , the limit points of @xmath111 produced by algorithm [ alg ] are indeed feasible for .",
    "note that algorithm [ alg ] is designed to solve .",
    "thus , in order to prove that the scheduler produce feasible points for , we need the following lemma , which connects the objective function value in to the constraint in .",
    "[ lem_opt1 ] the following properties hold for : for large enough @xmath79 , we have @xmath190 for any solution @xmath191 .    for the ease of presentation , we only consider the penalty function as ( [ eqn_penalty_example ] ) , although the proof can be easily extended to general cases .",
    "note that from lemma [ lem_approx_2 ] we have @xmath192 thus , ( [ eqn_equal_const_optimal ] ) holds by choosing sufficiently large @xmath79 .",
    "finally , we conclude this section by the following theorem , which states that the limit points produced by algorithm [ alg ] are always feasible for the original problem .",
    "this , combined with theorem [ the_cost ] , proves the optimality of algorithm [ alg ] for .",
    "( _ feasibility _ ) for sufficiently large @xmath79 , we have @xmath193 for any constraint function @xmath194 in @xmath195 .",
    "suppose that this is not true .",
    "then there exist a sequence @xmath184 such that @xmath196 from arzela - ascoli theorem , there is a subsequence @xmath186 which converges to a fluid limit .",
    "thus , we have @xmath197 where @xmath88 can be argued similarly as in the proof of theorem [ the_cost ] , @xmath90 is because for any @xmath31 and @xmath140 we have @xmath198 , due to algorithm [ alg ] , and @xmath179 is because of the assumption in ( [ eqn_posi_h ] ) . but",
    "according to lemma [ lem_optimal_cost ] , @xmath199 solves , and therefore lemma [ lem_opt1 ] implies that @xmath200 contradiction ! therefore the claim holds .",
    "thus , algorithm [ alg ] produces feasible points for , and achieves a cost which is arbitrarily close to @xmath201 , by properly selecting parameters @xmath79 and @xmath74 .",
    "in this section we verify the performance of algorithm [ alg ] through a simulation in a random wireless network where the network is as shown in fig .[fig_network ] .",
    "there are 7 links in the network , where square nodes denote the transmitters , and round nodes denote the receivers .",
    "we simulate a special case of , the following minimum power scheduling problem , which we denote as : @xmath202 where @xmath66 is a power vector whose each element @xmath203 corresponds to the power consumption when the independent set @xmath204 is chosen . in the simulation",
    "we choose @xmath205 . here",
    ", @xmath206 corresponds to the arrival rate vector , which is assumed to be the only unknown parameter in the network .",
    "thus , ( [ eqn_rate_stab ] ) corresponds to the rate stability constraint .",
    "[ fig_utility ] shows the convergence results of the cost function ( the bottom sub - figure ) with slowly converging sources ( the top sub - figure ) after a simulation of @xmath207 time slots . in the simulation ,",
    "we choose @xmath208 and @xmath209 .",
    "it can be observed from the top sub - figure that our algorithm achieves the optimal cost .",
    "further , by comparing the convergence results of the cost and the arrival processes , we can conclude that algorithm [ alg ] can track the uncertain parameter @xmath206 dynamically . in the simulation , it is further observed that the maximum queue length in the network is around @xmath210 , so that the constraint in ( [ eqn_rate_stab ] ) is clearly satisfied .",
    "in this paper we formulated a general class of scheduling problems in wireless networks with uncertain parameters , subject to the constraint that these parameters can be obtained from the empirical average values of certain stochastic network processes .",
    "we proposed a class of primal - dual type scheduling algorithms , and showed its optimality as well as feasibility using fluid limits .",
    "we first prove 1 ) .",
    "let a sequence of functions @xmath211 be given , which converge to a fluid limit @xmath212 . in the fluid limit ,",
    "suppose that there is time @xmath140 , @xmath188 and resource allocation modes @xmath213 such that @xmath214 where @xmath70 is a small constant .",
    "then , since @xmath215 is a continuous function of variable @xmath3 , there is @xmath216 such that for all @xmath217 , we have @xmath218 further , since @xmath219 is continuous as a function of variables @xmath220 ( and therefore is absolutely continuous when restricted to a compact local region ) , there is an @xmath221 such that @xmath222 implies that @xmath223 for all @xmath217 .",
    "now we define @xmath224 then , the definition of fluid limits implies that there exists @xmath225 and @xmath226 such that for all @xmath227 and @xmath228 , @xmath229 thus , by taking @xmath230 we have @xmath231 for all @xmath232 .",
    "further , by comparing the above definitions of @xmath233 and @xmath234 to that of @xmath235 , @xmath236 and @xmath237 in ( [ eqn_x ] ) , ( [ eqn_y ] ) and ( [ eqn_z ] ) , respectively , we conclude that they are essentially the same , except a difference in time scale , i.e. , @xmath238 .",
    "thus , the following holds in the original system : for any @xmath227 and all @xmath239 , @xmath240 therefore , according to lemma [ lem_cond_grad ] , @xmath241 is never chosen in any time slot during @xmath242 , and we have that @xmath243 is a constant during @xmath244 , from which we conclude that @xmath245",
    ". therefore , @xmath165 following the definition that @xmath246 .",
    "we next prove 2 ) .",
    "let @xmath167 be given as a feasible point of and @xmath70 be given .",
    "since @xmath247 is a continuous function of @xmath3 , there is @xmath248 and @xmath225 such that for @xmath227 and all @xmath249 , the following holds : @xmath250 further , note that lemma [ lem_cond_grad ] implies that for any time slot in @xmath244 , we have @xmath251 thus , applying ( [ eqn_norm_diff ] ) to the above inequality we have @xmath252 for all @xmath239 , where @xmath253 is a proper constant . after summing over @xmath244 and dividing by @xmath254 on both sides , we obtain @xmath255 finally , we let @xmath256 , and noting that @xmath248 can be taken arbitrarily small , we have @xmath257 from which 2 ) holds since @xmath70 is arbitrary .",
    "l. tassiulas and a. ephremides , `` stability properties of constrained queuing systems and scheduling policies for maximum throughput in multihop radio networks , '' _ ieee trans . on automatic control _ , vol .",
    "1936 - 1949 , december 1992 m. j. neely , `` energy optimal control for time varying wireless networks '' , ieee transactions on information theory , vol .",
    "52 , no . 7 , pp . 2915 - 2934 , july 2006 b. hajek and g. sasaki , `` link scheduling in polynomial time , '' ieee trans .",
    "information theory , vol .",
    "34 , sept .",
    "1988 , pp .",
    "910 - 917 l. georgiadis , m. j. neely , l. tassiulas , `` resource allocation and cross - layer control in wireless networks , '' , _ foundations and trends in networking , _ vol . 1 , no",
    ". 1 , pp . 1 - 144 , 2006 .",
    "m. j. neely , `` stochastic network optimization with non - convex utilities and costs , '' _ proc .",
    "information theory and applications workshop ( ita ) _ , feb .",
    "stolyar , `` maximizing queuing network utility subject to stability : greedy primal - dual algorithm,''__queuing systems , _ _ 2005 , vol .",
    "50 , no.4 , pp.401 - 457 a. eryilmaz and r. srikant .",
    "`` joint congestion control , routing and mac for stability and fairness in wireless networks , '' _ ieee journal on selected areas in communications _ , august 2006 , 1514 - 1524 .",
    "a. eryilmaz , and r. srikant , `` fair resource allocation in wireless networks using queue - length based scheduling and congestion control '' , _ ieee / acm trans . on networking _ ,",
    "jan . , 2007 ,",
    "1333 - 1344 . f. p.",
    "kelly , a.k .",
    "maulloo and d.k.h .",
    "tan , `` rate control in communication networks : shadow prices , proportional fairness and stability , '' , _ journal of the operational research society , _ vol .",
    "49 ( 1998 ) , 237 - 252 s. shakkottai and r. srikant , `` network optimization and control , '' foundations and trends in networking , now publishers , 2007 .",
    "d. p. bertsekas , `` nonlinear programming '' , _ athena scientific _ , 2nd edition , 1999 .",
    "j.g . dai and b. prabhakar , `` the throughput of data switches with and without speedup , '' _ proc . of the ieee infocom _ , 2:556 - 564 , march 2000 h. royden , `` real analysis '' , _ prentice hall _",
    ", 3rd edition , 1988 ."
  ],
  "abstract_text": [
    "<S> this paper proposes a dynamic primal - dual type algorithm to solve the optimal scheduling problem in wireless networks subject to uncertain parameters , which are generated by stochastic network processes such as random packet arrivals , channel fading , and node mobilities . </S>",
    "<S> the algorithm is a generalization of the well - known max - weight scheduling algorithm proposed by tassiulas _ </S>",
    "<S> et al . </S>",
    "<S> _ , where only queue length information is used for computing the schedules when the arrival rates are uncertain . </S>",
    "<S> using the technique of fluid limits , sample path convergence of the algorithm to an arbitrarily close to optimal solution is proved , under the assumption that the strong law of large numbers ( slln ) applies to the random processes which generate the uncertain parameters . </S>",
    "<S> the performance of the algorithm is further verified by simulation results . </S>",
    "<S> the method may potentially be applied to other applications where dynamic algorithms for convex problems with uncertain parameters are needed . </S>"
  ]
}