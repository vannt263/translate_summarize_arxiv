{
  "article_text": [
    "managing database inconsistency has received a lot of attention in the past two decades .",
    "inconsistency arises for different reasons and in different applications .",
    "for example , in common applications of big data , information is obtained from imprecise sources ( e.g. , social encyclopedias or social networks ) via imprecise procedures ( e.g. , natural - language processing ) .",
    "it may also arise when integrating conflicting data from different sources ( each of which can be consistent ) .",
    "arenas , bertossi and chomicki  @xcite introduced a principled approach to managing of inconsistency , via the notions of and .",
    "informally , a _ repair _ of an inconsistent database @xmath1 is a consistent database @xmath2 that differs from @xmath1 in a `` minimal '' way , where refers to the . in the case of anti - symmetric integrity constraints ( e.g. , denial constraints and",
    "the special case of functional dependencies ) , such a repair is a ( i.e. , @xmath2 is a consistent subinstance of @xmath1 that is not properly contained in any consistent subinstance of @xmath1 ) .",
    "various computational problems around database repairs have been extensively investigated .",
    "most studied is the problem of computing the _ consistent answers _ of a query @xmath3 on an inconsistent database @xmath1 ; these are the tuples in the intersection @xmath4",
    "hence , in this approach inconsistency is handled at query time by returning the tuples that are guaranteed to be in the result no matter which repair is selected .",
    "another well studied question is that of  @xcite : given instances @xmath1 and @xmath2 , determine whether @xmath2 is a repair of @xmath1 . depending on the type of repairs and the type of integrity constraints , these problems may vary from tractable to highly intractable complexity classes . see  @xcite for an overview of results .    in the above framework ,",
    "all repairs of a given database instance are taken into account , and they are treated on a par with each other .",
    "there are situations , however , in which it is natural to prefer one repair over another  @xcite .",
    "for example , this is the case if one source is regarded to be more reliable than another ( e.g. , enterprise data vs.  internet harvesting , precise vs.  imprecise sensing equipment , etc . ) or if available timestamp information implies that a more recent fact should be preferred over an earlier fact .",
    "recency may be implied not only by timestamps , but also by evolution semantics ; for example , `` divorced '' is likely to be more updated than `` single , '' and similarly is `` sergeant '' compared to `` private . ''",
    "motivated by these considerations , staworko , chomicki and marcinkowski  @xcite introduced the framework of repairs .",
    "the main characteristic of this framework is that it uses a relation between conflicting facts of an inconsistent database to define a notion of repairs .",
    "specifically , the notion of and that of are based on two different notions of the property of one consistent subinstance being preferred to another .",
    "improvements are basically lifting of the priority relation from facts to consistent subinstances ; @xmath2 is an improvement of @xmath5 if @xmath2 contains a fact that is better than all those in @xmath6 ( in the pareto semantics ) , or if for every fact in @xmath6 there exists a better fact in @xmath7 ( in the global semantics ) . in each of the two semantics ,",
    "an is a repair that can not be improved .",
    "a third semantics proposed by staworko et al .",
    "@xcite is that of a repair , which is a globally optimal repair under some extension of the priority relation into a relation . in this paper",
    ", we refer to these preferred repairs as , and , respectively .",
    "fagin et al .",
    "@xcite have built on the concept of preferred repairs ( in conjunction with the framework of  @xcite ) to devise a language for declaring in text information - extraction systems .",
    "they have shown there that preferred repairs capture ad - hoc cleaning operations and strategies of some prominent existing systems for text analytics  @xcite .",
    "staworko et al .",
    "@xcite have proved several results about preferred repairs .",
    "for example , every c - repair is also a g - repair , and every g - repair is also a p - repair .",
    "they also showed that p - repair and c - repair checking are solvable in polynomial time ( under data complexity ) when constraints are given as denial constraints , and that there is a set of functional dependencies ( fds ) for which g - repair checking is conp - complete .",
    "later , fagin et al .",
    "@xcite extended that hardness result to a full dichotomy in complexity over all sets of fds : g - repair checking is solvable in polynomial time whenever the set of fds is equivalent to a single fd or two key constraints per relation ; in every other case , the problem is conp - complete .    while the classic complexity problems studied in the theory of repairs include repair checking and consistent query answering , the presence of repairs gives rise to the , which staworko et al .",
    "@xcite refer to as : determine whether the provided priority relation suffices to clean the database unambiguously , or in other words , decide whether there is exactly one optimal repair .",
    "the problem of repairing uniqueness ( in a different repair semantics ) is also referred to as by fan et al .",
    "@xcite . in this paper",
    ", we study the three variants of this computational problem , under the three optimality semantics pareto , global and completion , and denote them as , and , respectively .",
    "it is known that under each of the three semantics there is always at least one preferred repair , and staworko et al .",
    "@xcite present a polynomial - time algorithm for finding such a repair .",
    "( we recall this algorithm in section  [ sec : categoricity ] . ) hence , the categoricity problem is that of deciding whether the output of this algorithm is the only possible preferred repair . as we explain next , it turns out that each of the three variants of the problem entails quite a unique picture of complexity .    for the problem of p - categoricity ,",
    "we focus on integrity constraints that are fds , and establish the following dichotomy in data complexity , assuming that @xmath8 . for a relational schema with a set @xmath9 of fds :    * if @xmath9 associates ( up to equivalence ) a single fd with every relation symbol , then p - categoricity is solvable in polynomial time . * in , p - categoricity is conp - complete .",
    "for example , with the relation symbol @xmath10 and the fd @xmath11 , p - categoricity is solvable in polynomial time ; but if we add the dependency @xmath12 then it becomes conp - complete .",
    "our proof uses a reduction technique from past dichotomies that involve fds  @xcite , but requires some highly nontrivial additions .",
    "we then turn to investigating c - categoricity , and establish a far more positive picture than the one for p - categoricity .",
    "in particular , the problem is solvable in polynomial time for every set of fds .",
    "in fact , we present an algorithm for solving c - categoricity in polynomial time , assuming that constraints are given as an input  @xcite .",
    "( in particular , we establish polynomial - time data complexity for other types of integrity constraints , such as  @xcite and  @xcite . )",
    "the algorithm is extremely simple , yet its proof of correctness is quite intricate .    finally , we explore g - categoricity , and focus first on fds . we show that in the tractable case of p - categoricity ( equivalence to a single fd per relation ) , g - categoricity is likewise solvable in polynomial time .",
    "for example , @xmath10 with the dependency @xmath11 has polynomial - time g - categoricity .",
    "nevertheless , we prove that if the we add the dependency @xmath13 ( that is , the attribute @xmath14 should have the same value across all tuples ) , then g - categoricity becomes @xmath0-complete .",
    "we do not complete a dichotomy as in p - categoricity , and leave that open for future work .",
    "lastly , we observe that in our proof of @xmath0-hardness , our reduction constructs a non - transitive priority relation , and we ask whether transitivity makes a difference .",
    "the three semantics of repairs remain different in the presence of transitivity . in particular",
    ", we show such a case where there are globally - optimal repairs that are not completion optimal repairs .",
    "nevertheless , quite interestingly , we are able to prove that g - categoricity and c - categoricity are actually if transitivity is assumed .",
    "in particular , we establish that in the presence of transitivity , g - categoricity is solvable in polynomial time , even when constraints are given as a conflict hypergraph .",
    "we now present some general terminology and notation that we use throughout the paper .",
    "a ( ) is a finite set @xmath15 of , each with a designated positive integer as its , denoted @xmath16 .",
    "we assume an infinite set @xmath17 of , used as database values .",
    "an @xmath1 over a signature @xmath15 consists of finite relations @xmath18 , where @xmath19 .",
    "we write @xmath20 to denote the set @xmath21 , and we refer to the members of @xmath20 as of @xmath22 . if @xmath1 is an instance over @xmath23 and @xmath24 is a tuple in @xmath25 , then we say that @xmath26 is a . by a slight abuse of notation , we identify an instance @xmath1 with the set of its facts .",
    "for example , @xmath27 denotes that @xmath26 is a fact of @xmath1 . as another example",
    ", @xmath28 means that @xmath29 for every @xmath19 ; in this case , we say that @xmath2 is of @xmath1 .    in our examples ,",
    "we often name the attributes and refer to them by their names .",
    "for instance , in figure  [ fig : companyceo - instance ] we refer to the relation symbol as @xmath30 where @xmath31 and @xmath32 refer to attributes  1 and  2 , respectively . in the case of generic relation symbols ,",
    "we implicitly name their attributes by capital english letters with the corresponding numeric values ; for instance , we may refer to attributes @xmath33 , @xmath34 and @xmath35 of @xmath36 by @xmath37 , @xmath38 and @xmath14 , respectively .",
    "we stress that attribute names are not part of our formal model , but are rather used for readability .",
    "let @xmath23 be a signature , and @xmath1 an instance over @xmath23 . in this paper",
    "we consider two representation systems for integrity constraints .",
    "the first is and the second is .",
    "let @xmath23 be a signature .",
    "a ( for short ) over @xmath23 is an expression of the form @xmath39 , where @xmath40 is a relation symbol of @xmath23 , and @xmath41 and @xmath42 are subsets of @xmath43 .",
    "when @xmath40 is clear from the context , we may omit it and write simply @xmath44 .",
    "a special case of an fd is a , which is an fd of the form @xmath39 where @xmath45 .",
    "an fd @xmath39 is if @xmath46 ; otherwise , it is .    when we are using the alphabetic attribute notation , we may write @xmath41 and @xmath42 by simply concatenating the attribute symbols .",
    "for example , if we have a relation symbol @xmath36 , then @xmath47 denotes the fd @xmath48 .",
    "an instance @xmath1 over @xmath40 an fd @xmath39 if for every two facts @xmath49 and @xmath50 over @xmath40 , if @xmath49 and @xmath50 agree on ( i.e. , have the same values for ) the attributes of @xmath41 , then they also agree on the attributes of @xmath42 .",
    "we say that @xmath1 satisfies a set @xmath9 of fds if @xmath1 satisfies every fd in @xmath9 ; otherwise , we say that @xmath1 @xmath9 .",
    "two sets @xmath9 and @xmath51 of fds are if for every instance @xmath1 over @xmath23 it holds that @xmath1 satisfies @xmath9 if and only if it satisfies @xmath51 .",
    "for example , for @xmath36 the sets @xmath52 and @xmath53 are equivalent .    in this work , a @xmath54 is a pair @xmath55 , where @xmath23 is a signature and @xmath9 is a set of fds over @xmath23 .",
    "if @xmath56 is a schema and @xmath57 , then we denote by @xmath58 the restriction of @xmath59 to the fds @xmath39 over @xmath40 .",
    "r|c|c| & + & @xmath31 & @xmath32 + @xmath60 & @xmath61 & @xmath62 + @xmath63 & @xmath61 & @xmath64 + @xmath65 & @xmath61 & @xmath66 + @xmath67 & @xmath68 & @xmath64 + @xmath69 & @xmath68 & @xmath62 +    [ example : ceo ] in our first running example , we use the schema @xmath70 , defined as follows .",
    "the signature @xmath23 consists of a single relation @xmath30 , which associates companies with their chief executive officers ( ceo ) .",
    "figure  [ fig : companyceo - instance ] depicts an instance @xmath1 over @xmath23 .",
    "we define @xmath9 as the following set of fds over @xmath23 .",
    "@xmath71 hence , @xmath9 states that in @xmath72 , each company has a single ceo and each ceo manages a single company .",
    "observe that @xmath1 violates @xmath9 .",
    "for example , @xmath61 has three ceos , @xmath68 has two ceos , and each of @xmath62 and @xmath64 is the ceo of two companies .",
    "while fds define integrity logically , at the level of the signature , a  @xcite provides a direct specification of inconsistencies at the instance level , by explicitly stating sets of tuples that can not co - exist . in the case of fds ,",
    "the conflict hypergraph is a graph that has an edge between every two facts that violate an fd .",
    "formally , for an instance @xmath1 over a signature @xmath23 , a @xmath73 ( ) is a hypergraph that has the facts of @xmath1 as its node set .",
    "a subinstance @xmath2 of @xmath1 is with respect to ( w.r.t . )",
    "@xmath73 if @xmath2 is an of @xmath73 ; that is , no hyperedge of @xmath73 is a subset of @xmath2 .",
    "we say that @xmath2 is if @xmath74 is inconsistent for every @xmath75 .",
    "when all the edges of a conflict hypergraph are of size two , we may call it a .    recall",
    "that conflict hypergraphs can represent inconsistencies for various types of integrity constraints , including fds , the more general  @xcite , and the more general  @xcite .",
    "in fact , every constraint that is anti - monotonic ( i.e. , where subsets of consistent sets are always consistent ) can be represented as a conflict hypergraph . in the case of denial constraints , the translation from the logical constraints to the conflict hypergraph can be done in polynomial time under ( i.e. , when the signature and constraints are assumed to be fixed ) .",
    "let @xmath70 be a schema , and let @xmath1 be an instance over @xmath54 . recall that @xmath54 is assumed to have only fds .",
    "we denote by @xmath76 the conflict graph for @xmath1 that has an edge between every two facts that violate some fd of @xmath54 .",
    "note that a subinstance @xmath2 of @xmath1 satisfies @xmath9 if and only if @xmath2 is consistent w.r.t .",
    "@xmath76 . as an example",
    ", the left graph of figure  [ fig : ceo - completions ] depicts the graph @xmath76 for our running example ; for now , the reader should ignore the directions on the edges , and view the graph as an undirected one .",
    "the following example involves a conflict hypergraph that is not a graph .",
    "[ example : followers - instance ] in our second running example , we use the toy scenario where the signature has a single relation symbol @xmath77 , where @xmath78 means that person @xmath79 follows person @xmath80 ( e.g. , in a social network ) .",
    "we have two sets of people : @xmath81 for @xmath82 , and @xmath83 for @xmath84 .",
    "all the facts have the form @xmath85 ; we denote such a fact by @xmath86 .",
    "the instance @xmath1 has the following facts :    @xmath87 , @xmath88 , @xmath89 , @xmath90 , @xmath91 , @xmath92 , @xmath93 , @xmath94 , @xmath95 , @xmath96    the hypergraph @xmath73 for @xmath1 encodes the following rules :    each @xmath81 can follow at most @xmath97 people .",
    "each @xmath83 can be followed by at most @xmath98 people .",
    "specifically , @xmath73 contains the following hyperedges :    @xmath99 , @xmath100 , @xmath101 , + @xmath102 , @xmath103 , @xmath104    @xmath105 , @xmath106 , @xmath107 , @xmath108    an example of a consistent subinstance @xmath2 is @xmath109 the reader can verify that @xmath2 is maximal .",
    "we now recall the framework of preferred repairs by staworko et al .",
    "let @xmath1 be an instance over a signature @xmath23 .",
    "a relation @xmath110 over @xmath1 is an acyclic binary relation over the facts in @xmath1 . by",
    "we mean that @xmath1 does not contain any sequence @xmath111 of facts such that @xmath112 for all @xmath113 and @xmath114 .",
    "if @xmath110 is a priority relation over @xmath1 and @xmath5 is a subinstance of @xmath1 , then @xmath115 denotes the set of tuples @xmath116 such that no @xmath117 satisfies @xmath118 .",
    "an over @xmath23 is a triple @xmath119 , where @xmath1 is an instance over @xmath23 , @xmath73 is a conflict hypergraph for @xmath1 , and @xmath110 a priority relation over @xmath1 with the following property : for every two facts @xmath49 and @xmath50 in @xmath1 , if @xmath120 then @xmath49 and @xmath50 are neighbors in @xmath73 ( that is , @xmath49 and @xmath50 co - occur in some hyperedge ) . , holds as well without this requirement .",
    "we defer to future work the thorough investigation of the impact of relaxing this requirement . ] for example , if @xmath121 ( where all the constraints in @xmath54 are fds ) , then @xmath120 implies that @xmath122 violates at least one fd .",
    "[ example : ceo - priority ] we continue our running company - ceo example .",
    "we define a priority relation @xmath110 by @xmath123 , @xmath124 and @xmath125 .",
    "we denote @xmath110 by corresponding arrows on the left graph of figure  [ fig : ceo - completions ] .",
    "( therefore , some of the edges are directed and some are undirected . ) we then get the inconsistent prioritizing instance @xmath126 over @xmath23 .",
    "observe that the graph does not contain directed cycles , as required from a priority relation .",
    "[ example : followers - priority ] recall that the instance @xmath1 of our followers example is defined in example  [ example : followers - instance ] .",
    "the priority relation @xmath110 is given by @xmath127 if one of the following holds : @xmath128 and @xmath129 , @xmath130 and @xmath131 .",
    "for example , we have @xmath132 and @xmath133 .",
    "but we do not have @xmath134 ( hence , @xmath110 is not transitive ) .",
    "let @xmath119 be an inconsistent prioritizing instance over a signature @xmath23 .",
    "we say that @xmath110 is if for every two facts @xmath49 and @xmath50 in @xmath1 , if @xmath49 and @xmath50 are neighbors then either @xmath120 or @xmath118 .",
    "a priority @xmath135 over @xmath1 is a of @xmath110 ( w.r.t .",
    "@xmath73 ) if @xmath110 is a subset of @xmath135 and @xmath135 is total .",
    "as an example , the middle and right graphs of figure  [ fig : ceo - completions ] are two completions of the priority relation @xmath110 depicted on the left side .",
    "a of @xmath119 is an inconsistent prioritizing instance @xmath136 where @xmath135 is a completion of @xmath110 .",
    "let @xmath137 be an inconsistent prioritizing instance over @xmath23 .",
    "as defined by arenas et al .",
    "@xcite , @xmath2 is a of @xmath138 if @xmath2 is a maximal consistent subinstance of @xmath1 .",
    "staworko et al .",
    "@xcite define three different notions of repairs : , , and .",
    "the first two notions are based on checking whether a repair @xmath2 of @xmath1 can be improved by replacing a set of facts in @xmath2 with a more preferred set of facts from @xmath1 .",
    "they differ by the way they define when one set of facts is considered more preferred than another one .",
    "the last notion is based on the notion of completion .",
    "next we give the formal definitions .",
    "let @xmath119 be an inconsistent prioritizing instance over a signature @xmath23 , and @xmath2 and @xmath139 two distinct consistent subinstances of @xmath1 .",
    "* @xmath2 is a of @xmath139 if there exists a fact @xmath140 such that @xmath141 for all facts @xmath142 .",
    "* @xmath2 is a of @xmath139 if for every fact @xmath142 there exists a fact @xmath140 such that @xmath141 .",
    "that is , @xmath2 is a pareto improvement of @xmath139 if , in order to obtain @xmath2 from @xmath139 , we insert and delete facts , and one of the inserted facts is preferred to all deleted facts . and @xmath2 is a global improvement of @xmath139 if , in order to obtain @xmath2 from @xmath139 , we insert and delete facts , and every deleted fact is preferred to by some inserted fact .",
    "[ example : ceo - improvement ] we continue the company - ceo running example .",
    "we define three consistent subinstances of @xmath1 .",
    "@xmath143 note the following .",
    "first , @xmath144 is a pareto improvement of @xmath145 , since @xmath146 and @xmath147 for every fact in @xmath148 ( where in this case there is only one such an @xmath49 , namely @xmath65 ) .",
    "second , @xmath149 is a global improvement of @xmath144 because @xmath150 and @xmath125 .",
    "( we refer to @xmath151 in later examples . )",
    "we then get the following variants of .",
    "let @xmath138 be an inconsistent prioritizing instance @xmath119 , and let @xmath2 be a consistent subinstance of @xmath1 .",
    "then @xmath2 is a :    * if there is no pareto improvement of @xmath2 . * if there is no global improvement of @xmath2 . * if there exists a completion @xmath152 of @xmath138 such that @xmath2 is a globally - optimal repair of @xmath152 .",
    "we abbreviate `` pareto - optimal repair , '' `` globally - optimal repair , '' and `` completion - optimal repair '' by , and , respectively .",
    "we remark that in the definition of a completion - optimal repair , we could replace `` globally - optimal '' with `` pareto - optimal '' and obtain an equivalent definition  @xcite .",
    "let @xmath137 be an inconsistent prioritizing instance over a signature @xmath23 .",
    "we denote the set of all the repairs , p - repairs , g - repairs and c - repairs of @xmath138 by @xmath153 , @xmath154 , @xmath155 and @xmath156 , respectively .",
    "the following was shown by staworko et al .",
    "@xcite .",
    "dblp : journals / amai / staworkocm12[prop : containments ] for all inconsistent prioritizing instances @xmath138 we have @xmath157 , and moreover , @xmath158    [ example : ceo - repairs ] we continue our company - ceo example .",
    "recall the instances @xmath159 defined in example  [ example : ceo - improvement ] .",
    "we have shown that @xmath145 has a pareto improvement , and therefore , @xmath145 is a p - repair ( although it is a repair in the ordinary sense ) .",
    "the reader can verify that @xmath144 has no pareto improvements , and therefore , it is a p - repair .",
    "but @xmath144 is not a g - repair , since @xmath149 is a global improvement of @xmath144 .",
    "the reader can verify that @xmath151 is a g - repair ( hence , a p - repair ) . finally , observe that @xmath149 is a g - repair w.r.t",
    ".  the left completion of @xmath110 in figure  [ fig : ceo - completions ] ( and also w.r.t .  the right one ) .",
    "hence , @xmath149 is a c - repair ( hence , a g - repair and a p - repair ) . in constrast , observe that @xmath151 has a global improvement ( and a pareto improvement ) in both completions ; but it does not prove that @xmath151 is not a c - repair ( since , conceptually , one needs to consider all possible completions of @xmath110 ) .",
    "[ example : follows - repair ] we now continue the follower example .",
    "the inconsistent prioritizing instance @xmath119 is defined in examples  [ example : followers - instance ] and  [ example : followers - priority ] .",
    "consider the following instance .",
    "@xmath160 the reader can verify that @xmath145 is a c - repair ( e.g. , by completing @xmath110 through the lexicographic order ) .",
    "the subinstance @xmath161 is a repair but not a p - repair , since we can add @xmath87 and remove both @xmath88 and @xmath89 , and thus obtain a pareto improvement .",
    "in this section we define the computational problem of , which is the main problem that we study in this paper .",
    "proposition  [ prop : containments ] states that , under each of the semantics of preferred repairs , at least one such a repair exists . in general , there can be many possible preferred repairs .",
    "the problem of  @xcite is that of testing whether there is one such a repair ; that is , there do not exist two distinct preferred repairs , and therefore , the priority relation contains enough information to clean the inconsistent instance unambiguously .",
    "problems , , and are those of testing whether @xmath162 , @xmath163 and @xmath164 , respectively , given a signature @xmath23 and an inconsistent prioritizing instance @xmath138 over @xmath23 .",
    "as defined , categoricity takes as input both the signature @xmath23 and the inconsistent prioritizing instance @xmath138 , where constraints are represented by a conflict hypergraph .",
    "we also study this problem from the perspective of , where we fix a schema @xmath70 , where @xmath9 is a set of fds . in that case",
    ", the input consists of an instance @xmath1 over @xmath23 and a priority relation @xmath165 over @xmath1 .",
    "the conflict hypergraph is then implicitly assumed to be @xmath76 .",
    "we denote the corresponding variants of the problem by p - categoricity@xmath166 , g - categoricity@xmath166 and c - categoricity@xmath166 , respectively .",
    "[ example : ceo - categoricity ] continuing our company - ceo example , we showed in example  [ example : ceo - repairs ] that there are at least two g - repairs and at least three p - repairs .",
    "hence , a solver for g - categoricity@xmath166 should return false on @xmath167 , and so is a solver for p - categoricity@xmath166 . in contrast",
    ", we will later show that there is precisely one c - repair ( example  [ example : ccat - ceo ] ) ; hence , a solver for c - categoricity@xmath166 should return true on @xmath167 . if , on the other hand , we replaced @xmath110 with any of the completions in figure  [ fig : ceo - completions ] , then there would be precisely one p - repair and one g - repair ( namely , the current single c - repair ) .",
    "this follows from a result of staworko et al .",
    "@xcite , stating that categoricity holds in the case of total priority relations .",
    "we begin with some basic insights into the different variants of the categoricity problem .",
    "we recall an algorithm by staworko et al .",
    "@xcite for greedily constructing a c - repair .",
    "this is the algorithm @xmath168 of figure  [ alg : ccat - opt - alg ] .",
    "the algorithm takes as input an inconsistent prioritizing instance @xmath119 and returns a c - repair @xmath2 .",
    "it begins with an empty @xmath2 , and incrementally inserts tuples to @xmath2 , as follows . in each iteration of lines  36 ,",
    "the algorithm selects a fact @xmath49 from @xmath169 and removes it from @xmath1 .",
    "then , @xmath49 is added to @xmath2 if it does not violate consistency , that is , if @xmath73 does not contain any hyperedge @xmath170 such that @xmath171 .",
    "the specific way of choosing the fact @xmath49 among all those in @xmath169 is ( deliberately ) left unspecified , and hence , different executions may result in different c - repairs . in that sense , the algorithm is nondeterministic .",
    "staworko et al .",
    "@xcite proved that the possible results of these different executions are the c - repairs .",
    "dblp : journals / amai / staworkocm12[thm : cgreedy ]",
    "let @xmath119 be an inconsistent prioritizing instance over @xmath23 .",
    "let @xmath2 be a consistent subinstance of @xmath1 .",
    "then @xmath2 is a c - repair if and only if there exists an execution of @xmath172 that returns @xmath2 .",
    "t[alg : ccat - opt - alg]finding a c - repair  @xcite    findcrep@xmath173 @xmath174 choose a fact @xmath49 in @xmath169 @xmath175 @xmath176 * return * @xmath2    due to theorem  [ thm : cgreedy ] , we often refer to a c - repair as a repair .",
    "this theorem , combined with proposition  [ prop : containments ] , has several implications for us .",
    "first , we can obtain an x - repair ( where x is either p , g or c ) in polynomial time .",
    "hence , if a solver for x - categoricity determines that there is a single x - repair , then we can actually generate that x - repair in polynomial time .",
    "second , c - categoricity is the problem of testing whether @xmath172 returns the same instance @xmath2 on every execution .",
    "moreover , due to proposition  [ prop : containments ] , p - categoricity ( resp .",
    "g - categoricity ) is the problem of testing whether every p - repair ( resp .",
    "g - repair ) is equal to the one that is obtained by some execution of the algorithm .",
    "we consider the application of the algorithm @xmath168 to the instance of our company - ceo example ( where @xmath177 ) .",
    "the following are two different executions .",
    "we denote inclusion in @xmath2 ( i.e. , the condition of line  5 is true ) by plus and exclusion from @xmath2 by minus .",
    "@xmath178 , @xmath179 , @xmath180 , @xmath181 , @xmath182 .",
    "@xmath181 , @xmath182 , @xmath178 , @xmath179 , @xmath180 .",
    "observe that both executions return @xmath183 .",
    "this is in par with the statement in example  [ example : ceo - categoricity ] that in this running example there is a single c - repair .",
    "our goal is to study the complexity of x - categoricity ( where x is g , p and c ) .",
    "this problem is related to that of , namely , given @xmath137 and @xmath2 , determine whether @xmath2 is an x - repair of @xmath138 .",
    "the following is known about this problem .",
    "dblp : journals / amai / staworkocm12,dblp : conf / pods / faginkk15[thm : repairchecking ] the following hold .",
    "* p - repair checking and c - repair checking are solvable in polynomial time ; g - repair checking is in conp  @xcite .",
    "* let @xmath56 be a fixed schema . if @xmath58 is equivalent to either a single fd or two key constraints for every @xmath57 , then g - repair checking is solvable in polynomial time ; otherwise , g - repair checking is conp - complete  @xcite .",
    "recall from proposition  [ prop : containments ] that there is always at least one x - repair .",
    "therefore , given @xmath119 we can solve the problem using a conp algorithm with an oracle to x - repair checking : for all two distinct subinstances @xmath145 and @xmath144 , either @xmath145 or @xmath144 is not an x - repair .",
    "therefore , from theorem  [ thm : repairchecking ] we conclude the following .",
    "[ cor : upperbounds ] the following hold .",
    "* p - categoricity and c - categoricity are in conp .",
    "* for all fixed schemas @xmath56 , g - categoricity@xmath166 is in @xmath0 , and moreover , if @xmath58 is equivalent to either a single fd or two key constraints for every @xmath57 then g - categoricity@xmath166 is in conp .",
    "we stress here that if x - categoricity is solvable in polynomial time , then x - categoricity@xmath166 is solvable in polynomial time for schemas @xmath54 ; this is true since for every fixed schema @xmath54 the hypergraph @xmath76 can be constructed in polynomial time , given @xmath1 .",
    "similarly , if x - categoricity@xmath166 is conp - hard ( resp .",
    "@xmath0-hard ) for @xmath54 , then x - categoricity is conp - hard ( resp .",
    "@xmath0-hard ) .",
    "when we are considering x - categoricity@xmath166 , we assume that all the integrity constraints are fds .",
    "therefore , unlike the general problem of x - categoricity , in x - categoricity@xmath166 conflicting facts always belong to the same relation .",
    "it thus follows that our analysis for x - categoricity@xmath166 can restrict to single - relation schemas .",
    "formally , we have the following .    [ prop : single - relation ] let @xmath56 be a schema and x be one of p , g and c. for each relation @xmath57 , let @xmath184 be the schema @xmath185 .",
    "if x - categoricity@xmath186 is solvable in polynomial time for every @xmath57 , then x - categoricity@xmath166 is solvable in polynomial time .    if x - categoricity@xmath186 is conp - hard ( resp .",
    "@xmath0-hard ) for at least one @xmath57 , then x - categoricity@xmath166 is conp - hard ( resp .",
    "@xmath0-hard ) .",
    "observe that the phenomenon of proposition  [ prop : single - relation ] hold for x - categoricity , since the given conflict hypergraph may include hyperedges that cross relations .    in the following sections we investigate each of the three variants of categoricity : p - categoricity ( section  [ sec : p ] ) , c - categoricity ( section  [ sec : c ] ) and g - categoricity ( section  [ sec : g ] ) .",
    "in this section we prove a dichotomy in the complexity of p - categoricity@xmath166over all schemas @xmath54 ( where @xmath59 consists of fds ) .",
    "this dichotomy states that the only tractable case is where the schema associates a single fd ( which can be trivial ) to each relation symbol , up to equivalence . in all other cases , p - categoricity@xmath166is conp - complete .",
    "formally , we prove the following .",
    "[ thm : pareto ] let @xmath70 be a schema .",
    "the problem p - categoricity@xmath166can be solved in polynomial time if @xmath187 is equivalent to a single fd for every @xmath188 . in every other case ,",
    "p - categoricity@xmath166is conp - complete .",
    "the proof of theorem  [ thm : pareto ] is involved , and we outline it in the rest of this section .",
    "the tractability side is fairly simple ( as we show in the next section ) , and the challenge is in the hardness side . due to proposition [ prop : single - relation ] , it suffices to consider schemas @xmath54 with a single relation .",
    "hence , in the remainder of this section we consider only such schemas @xmath54 .      in this section",
    "we fix a schema @xmath189 , such that @xmath23 consist of a single relational symbol @xmath40 . we will prove that p - categoricity@xmath166is solvable in polynomial time if @xmath59 is a singleton .",
    "we denote the single fd in @xmath59 as @xmath44 .",
    "we fix the input @xmath167 for p - categoricity@xmath166 .    for a fact @xmath190 , we denote by @xmath191 $ ] and @xmath192 $ ] the restriction of the tuple of @xmath49 to the attributes in @xmath41 and @xmath42 , respectively . adopting the terminology of koutris and wijsen  @xcite , a of @xmath1 is a maximal collection of facts of @xmath1 that agree on all the attributes of @xmath41 ( i.e. , facts @xmath49 that have the same @xmath191 $ ] ) .",
    "similarly , a of @xmath1 is a maximal collection of facts that agree on both @xmath41 and @xmath42 . for tuples @xmath193 and @xmath194 constants , we denote by @xmath195 the block of facts @xmath49 with @xmath191={\\mathbf{a}}$ ] , and by @xmath196 the subblock of facts @xmath49 with @xmath191={\\mathbf{a}}$ ] and @xmath192={\\mathbf{b}}$ ] .",
    "consider again the instance @xmath1 of figure  [ fig : companyceo - instance ] , and suppose that @xmath59 consists of only @xmath197 ( i.e. , each company has a single ceo , but a person can be the ceo of several companies ) .",
    "then for @xmath198 and @xmath199 the block @xmath195 is @xmath200 and the subblock @xmath196 is the singleton @xmath201 .",
    "tractability for @xmath54 is based on the following lemma .",
    "[ lemma : key - for - pareto-1fd ]    we then get the following lemma .",
    "[ lemma : single - factorized ]    a polynomial - time algorithm then follows directly from lemma  [ lemma : single - factorized ] and the fact that p - repair checking is solvable in polynomial time ( theorem  [ thm : repairchecking ] ) .",
    "the hardness side of the dichotomy is more involved than its tractability side .",
    "our proof is based on the concept of a  @xcite , which has also been used by fagin et al .",
    "@xcite in the context of g - repair checking .",
    "let @xmath56 and @xmath202 be two schemas .",
    "a from @xmath23 to @xmath203 is a function @xmath204 that maps facts over @xmath23 to facts over @xmath203 .",
    "we naturally extend a mapping @xmath204 to map instances @xmath2 over @xmath23 to instances over @xmath203 by defining @xmath205 to be @xmath206 .",
    "a from @xmath54 to @xmath207 is a mapping @xmath208 from @xmath23 to @xmath203 with the following properties .    1 .",
    "@xmath208 is injective ; that is , for all facts @xmath49 and @xmath50 over @xmath23 , if @xmath209 then @xmath210 .",
    "2 .   @xmath208 preserves consistency and inconsistency ; that is , for every instance @xmath2 over @xmath54 , the instance @xmath211 satisfies @xmath212 if and only if @xmath2 satisfies @xmath59 .",
    "@xmath208 is computable in polynomial time .",
    "let @xmath54 and @xmath207 be two schemas , and let @xmath208 be a fact - wise reduction from @xmath54 to @xmath207 . given an inconsistent instance @xmath1 over @xmath54 and a priority relation @xmath110 over @xmath1 , we denote by @xmath213 the priority relation @xmath214 over @xmath215 where @xmath216 if and only if @xmath120 .",
    "if @xmath138 is the inconsistent prioritizing instance @xmath217 , then we denote by @xmath218 the triple @xmath219 , which is also an inconsistent prioritizing instance .",
    "the usefulness of fact - wise reductions is due to the following proposition , which is straightforward .",
    "let @xmath54 and @xmath207 be two schemas , and suppose that @xmath208 is a fact - wise reduction from @xmath54 to @xmath207 .",
    "let @xmath1 be an inconsistent instance over @xmath54 , @xmath110 a priority relation over @xmath1 , and @xmath138 the inconsistent prioritizing instance @xmath217 .",
    "then there is a bijection between @xmath154 and @xmath220 .",
    "we then conclude the following corollary .",
    "[ cor : fact - wise ] if there is a fact - wise reduction from @xmath54 to @xmath207 , then there is a polynomial - time reduction from p - categoricity@xmath166 to p - categoricity@xmath221 .      in the proof",
    "we consider seven specific schemas .",
    "the importance of these schemas will later become apparent .",
    "we denote these schemas by @xmath222 , for @xmath223 , where each @xmath222 is the schema @xmath224 , and @xmath225 is the singleton @xmath226 .",
    "the specification of the @xmath222 is as follows .",
    "1 .   @xmath227 and @xmath228 2 .",
    "@xmath229 and @xmath230 3 .",
    "@xmath231 and @xmath232 4 .",
    "@xmath233 and @xmath234 5 .",
    "@xmath235 and @xmath236 6 .",
    "@xmath237 and @xmath238 7 .",
    "@xmath239 and @xmath240    ( in the definition of @xmath241 , recall that @xmath242 denotes the fd @xmath243 , meaning that all tuples should have the same value for their first attribute . ) in the proof we use fact - wise reductions from the @xmath222 , as we explain in the next section .",
    "our proof boils down to proving conp - hardness for two specific schemas , namely @xmath244 and @xmath241 , and then using ( known and new ) fact - wise reductions in order to cover all the other schemas .",
    "for @xmath241 the proof is fairly simple . but",
    "hardness for @xmath244 turns out to be quite challenging to prove , and in fact , this part is the hardest in the proof of theorem  [ thm : pareto ] .",
    "note that @xmath244 is the schema of our company - ceo running example ( introduced in example  [ example : ceo ] ) .",
    "[ thm : hardness - specific - pareto ]    the proof ( as well as all the other proofs for the results in this paper ) can be found in the appendix .",
    "the following has been proved by fagin et al .",
    "@xcite .",
    "dblp : conf / pods / faginkk15[lemma :",
    "fw - from - s1 - 6 ] let @xmath56 be a schema such that @xmath23 consists of a single relation symbol .",
    "suppose that @xmath59 is equivalent to neither any single fd nor any pair of keys .",
    "then there is a fact - wise reduction from some @xmath222 to @xmath54 , where @xmath245 .    in the appendix",
    "we prove the following two lemmas , giving additional fact - wise reductions .",
    "[ lemma : fw - from - s0 ]    [ lemma : fw - from - s0-to - s1 - 5 ]    the structure of our fact - wise reductions is depicted in figure  [ fig : pcategoricitystrategy ] .",
    "dashed edges are known fact - wise reductions , while solid edges are novel .",
    "observe that each single - relation schema on the hardness side of theorem  [ thm : pareto ] has an ingoing path from either @xmath244 or @xmath241 , both shown to have conp - hard p - categoricity ( theorem  [ thm : hardness - specific - pareto ] ) .",
    "we now investigate the complexity of c - categoricity .",
    "our main result is that this problem is tractable .",
    "[ thm : c - categoricity - ptime ] the c - categoricity problem is solvable in polynomial time .    in the remainder of this section we establish theorem  [ thm : c - categoricity - ptime ] by presenting a polynomial - time algorithm for solving c - categoricity .",
    "the algorithm is very simple , but its proof of correctness ( given in the appendix ) is intricate .      to present our algorithm ,",
    "some notation is required .",
    "let @xmath119 be an inconsistent prioritizing instance .",
    "the of @xmath110 , denoted @xmath246 , is the priority relation over the facts of @xmath1 where for every two facts @xmath49 and @xmath50 in @xmath1 it holds that @xmath247 if and only if there exists a sequence @xmath248 of facts , where @xmath249 , such that @xmath250 , @xmath251 , and @xmath112 for all @xmath252 .",
    "obviously , @xmath246 is acyclic ( since @xmath110 is acyclic ) .",
    "but unlike @xmath110 , the relation @xmath246 may compare between facts that are not necessarily neighbors in @xmath73 .",
    "let @xmath119 be an inconsistent prioritizing instance , let @xmath5 be a set of facts of @xmath1 , and let @xmath49 be a fact of @xmath1 .",
    "by @xmath253 we denote the fact that @xmath254 for fact @xmath117 .",
    "t[alg : ccat - alg]algorithm for c - categoricity    ccategoricity@xmath173 @xmath255 @xmath174 @xmath256 @xmath257 @xmath258 @xmath259 + @xmath260 @xmath261 * return * true iff @xmath2 is consistent    figure  [ alg : ccat - alg ] depicts a polynomial - time algorithm for solving c - categoricity .",
    "we next explain how it works , and later discuss its correctness .",
    "as required , the input for the algorithm is an inconsistent prioritizing instance @xmath119 .",
    "( the signature @xmath23 is not needed by the algorithm . )",
    "the algorithm incrementally constructs a subinstance @xmath2 of @xmath1 , starting with an empty @xmath2 .",
    "later we will prove that there is a single c - repair if and only if @xmath2 is consistent ; and in that case , @xmath2 is the single c - repair .",
    "the loop in the algorithm constructs fact sets @xmath262 and @xmath263 .",
    "each @xmath264 is called a and each @xmath265 is called a . both @xmath264 and @xmath265",
    "are constructed in the @xmath97th iteration . on that iteration",
    "we add all the facts of @xmath264 to @xmath2 and remove from @xmath1 all the facts of @xmath264 and all the facts of @xmath265 .",
    "the sets @xmath264 and @xmath265 are defined as follows .",
    "@xmath264 consists of the maximal facts in the current @xmath1 , according to @xmath246 .",
    "@xmath265 consists of all the facts @xmath49 that , together with @xmath266 , complete a hyperedge of preferred facts ; that is , @xmath73 contains a hyperedge that contains @xmath49 , is contained in @xmath267 , and satisfies @xmath254 for every incident @xmath268 .",
    "the algorithm continues to iterate until @xmath1 gets empty . as said above , in the end the algorithm returns true if @xmath2 is consistent , and otherwise false .",
    "next , we give some examples of executions of the algorithm .",
    "[ example : ccat - ceo ] consider the inconsistent prioritizing instance @xmath119 from our company - ceo running example , illustrated on the left side of figure  [ fig : ceo - completions ] .",
    "the algorithm makes a single iteration on this instance , where @xmath269 and @xmath270 .",
    "both @xmath60 and @xmath67 are in @xmath271 since both are maximal .",
    "also , each of @xmath63 , @xmath69 and @xmath63 is in conflict with @xmath271 , and we have @xmath272 , @xmath273 , and @xmath274 .    now consider the inconsistent prioritizing instance @xmath119 from our followers running example .",
    "figure  [ fig : follows - exec ] illustrates the execution of the algorithm , where each column describes @xmath264 or @xmath265 , from left to right in the order of their construction . for convenience , the priority relation @xmath110 ,",
    "as defined in example  [ example : followers - priority ] , is depicted in figure  [ fig : follows - exec ] using corresponding edges between the facts .",
    "on iteration 1 , for instance , we have @xmath275 , since @xmath87 and @xmath95 are the facts without incoming edges on figure  [ fig : follows - exec ] .",
    "moreover , we have @xmath276 . the reason why @xmath277 contains @xmath88 , for example ,",
    "is that @xmath99 is a hyperedge , the fact @xmath87 is in @xmath271 , and @xmath132 ( hence , @xmath278 ) . for a similar reason @xmath277",
    "contains @xmath89 .",
    "@xmath93 is in @xmath277 as @xmath106 is a hyperedge , and though @xmath279 , we have @xmath280 . as another example",
    ", @xmath281 contains @xmath92 since @xmath73 has the hyperedge @xmath103 , the set @xmath282 is contained in @xmath283 , and @xmath284 .    in the end , @xmath285 , which is also the subinstance @xmath145 of example  [ example : follows - repair ] .",
    "since @xmath2 is consistent , the algorithm will determine that there is a single c - repair , and that c - repair is @xmath2 .",
    "[ example : ccat - fail ] we now give an example of an execution on a negative instance of c - categoricity .",
    "( in section  [ sec : g ] we refer to this example for a different reason . )",
    "figure  [ fig : transitive - example ] shows an instance @xmath1 over the schema @xmath286 , which is defined in section  [ sec : spec - schemas ] .",
    "recall that in this schema every two attributes form a key .",
    "each fact @xmath287 in @xmath1 is depicted by a tuple that consists of the three values .",
    "for example , @xmath1 contains the ( conflicting ) facts @xmath288 and @xmath289 .",
    "hereon , we write @xmath290 instead of @xmath291 . the priority relation @xmath110 is given by the directed edges between the facts ; for example , @xmath292 .",
    "undirected edges are between conflicting facts that are incomparable by @xmath110 ( e.g. , @xmath293 and @xmath294 ) .",
    "the execution of the algorithm on @xmath295 is as follows .",
    "on the first iteration , @xmath296 and @xmath297 .",
    "in particular , note that @xmath277 does not contain @xmath298 since it conflicts only with @xmath299 in @xmath271 , but the two are incomparable . similarly , @xmath277 does not contain @xmath294 since it is incomparable with @xmath293 .",
    "consequently , in the second iteration we have @xmath300 and @xmath301 . in the end ,",
    "@xmath302 is inconsistent , and therefore , the algorithm will return false .",
    "indeed , the reader can easily verify that each of the following is a c - repair : @xmath303 , @xmath304 , and @xmath305 .",
    "correctness of @xmath306 is stated in the following theorem .",
    "[ thm : ccategoricity - correct ]    theorem  [ thm : ccategoricity - correct ] , combined with the observation that the algorithm @xmath306 terminates in polynomial time , imply theorem  [ thm : c - categoricity - ptime ] . as previously said ,",
    "the proof of theorem  [ thm : ccategoricity - correct ] is quite involved .",
    "the direction @xmath307 is that of if the algorithm returns true then there is precisely one c - repair .",
    "the direction @xmath308 is that of if there is precisely one c - repair then the algorithm returns true .",
    "soundness is the easier direction to prove .",
    "we assume , by way of contradiction , that there is a c - repair @xmath139 different from the subinstance @xmath2 returned by the algorithm .",
    "such @xmath139 must include a fact @xmath309 from some negative stratum .",
    "we consider an execution of the algorithm @xmath168 that returns @xmath139 , and establish a contradiction by considering the first time such an @xmath309 is being added to the constructed solution",
    ".    proving completeness is more involved .",
    "we assume , by way of contradiction , that the constructed @xmath2 is inconsistent .",
    "we are looking at the first positive stratum @xmath264 such that @xmath310 contains a hyperedge .",
    "then , the crux of the proof is in showing that we can then construct two c - repairs using the algorithm @xmath168 : one contains some fact from @xmath264 and another one does not contain that fact .",
    "we then establish that there are at least two c - repairs , hence a contradiction .",
    "in this section , we investigate the complexity of the g - categoricity .",
    "we first show a tractability result for the case of a schema with a single fd .",
    "then , we show @xmath0-completeness for a specific schema .",
    "finally , we discuss the implication of assuming in the priority relation , and show a general positive result therein .",
    "recall from theorem  [ thm : pareto ] that , assuming @xmath8 , the problem p - categoricity@xmath166 is solvable in polynomial time if and only if @xmath54 consists ( up to equivalence ) of a single fd per relation .",
    "the reader can verify that the same proof works for g - categoricity@xmath166 .",
    "hence , our first result is that the tractable schemas of p - categoricity remain tractable for g - categoricity .",
    "[ thm : global-1fd ]    it is left open whether there is any schema @xmath54 that is not as in theorem  [ thm : global-1fd ] where g - categoricity@xmath166is solvable in polynomial time . in the next section",
    "we give an insight into this open problem ( theorem  [ thm : gcat - s0-hypothetical ] ) .",
    "our next result shows that g - categoricity@xmath166hits a harder complexity class than p - categoricity@xmath166 .",
    "in particular , while p - categoricity@xmath166is always in conp ( due to theorem  [ cor : upperbounds ] ) , we will show a schema @xmath54 where g - categoricity@xmath166is @xmath0-complete .",
    "this schema is the schema @xmath241 from section  [ sec : spec - schemas ] .",
    "[ thm : piptwo ]    the proof of theorem  [ thm : piptwo ] is by a reduction from the @xmath0-complete problem @xmath311 : given a cnf formula @xmath312 , determine whether it is the case that for every truth assignment to @xmath313 there exists a truth assignment to @xmath314 such that the two assignments satisfy @xmath315 .",
    "we can generalize theorem  [ thm : piptwo ] to a broad set of schemas , by using fact - wise reductions from @xmath241 .",
    "this is done in the following theorem .",
    "[ thm : piptwoextend ]    as an example , recall that in @xmath241 we have @xmath316 .",
    "this schema is a special case of theorem  [ thm : piptwoextend ] , since we can use @xmath242 as @xmath44 and @xmath317 as @xmath318 ; and indeed , each of @xmath319 and @xmath320 contains an attribute ( namely @xmath38 and @xmath14 , respectively ) that is not in any of the other three sets .",
    "additional examples of sets of fds that satisfy the conditions of theorem  [ thm : piptwoextend ] ( and hence the corresponding g - categoricity@xmath166is @xmath0-complete ) follow .",
    "all of these sets are over a relation symbol @xmath321 .",
    "( and in each of these sets , the first fd corresponds to @xmath44 and the second to @xmath318 . )    @xmath11 , @xmath322    @xmath323 , @xmath324    @xmath11 , @xmath325    @xmath11 , @xmath326    unlike @xmath241 , to this day we do not know what is the complexity of g - categoricity@xmath327 for any of the other @xmath222 ( defined in section  [ sec : spec - schemas ] ) .",
    "this includes @xmath244 , for which all we know is membership in conp ( as stated in theorem  [ cor : upperbounds ] ) . however , except for this open problem , the proof technique of theorem  [ thm : pareto ] is valid for g - categoricity@xmath166 .",
    "consequently , we can show the following .",
    "[ thm : gcat - s0-hypothetical ]      let @xmath119 be an inconsistent prioritizing instance .",
    "we say that @xmath110 is if for every two facts @xmath49 and @xmath50 in @xmath1 , if @xmath49 and @xmath50 are neighbors in @xmath73 and @xmath247 , then @xmath120 .",
    "transitivity is a natural assumption when @xmath110 is interpreted as a partial order such as `` is of better quality than '' or `` is more current than . '' in this section we consider g - categoricity in the presence of this assumption .",
    "the following example shows that a g - repair is not necessarily a c - repair , even if @xmath110 is transitive .",
    "this example provides an important context for the results that follow .",
    "[ example : x - repair - transitive ] consider again @xmath1 and @xmath110 from example  [ example : ccat - fail ] ( depicted in figure  [ fig : transitive - example ] ) .",
    "observe that @xmath110 is transitive .",
    "in particular , there is no priority between @xmath293 and @xmath298 , even though @xmath328 , because @xmath293 and @xmath298 are not in conflict ( or put differently , they are not neighbors in @xmath329 ) .",
    "consider the following subinstance of @xmath1 .",
    "@xmath330 the reader can verify that @xmath2 is a g - repair , but not a c - repair ( since no execution of @xmath168 can generate @xmath2 ) .",
    "example  [ example : x - repair - transitive ] shows that the notion global optimality is different from completion optimality , even if the priority relation is transitive . yet , quite remarkably , the two notions behave the same when it comes to categoricity .",
    "[ thm : g - c - same - transitive ] let @xmath137 be an inconsistent prioritizing instance such that @xmath110 is transitive .",
    "@xmath164 if and only if @xmath163 .",
    "the `` if '' direction follows from proposition  [ prop : containments ] , since every c - repair is also a g - repair .",
    "the proof of the `` only if '' direction is based on the special structure of the c - repair , as established in section  [ sec : c ] , in the case where only one c - repair exists .",
    "specifically , suppose that there is a single c - repair @xmath2 and let @xmath331 be a consistent subinstance of @xmath1 .",
    "we need to show that @xmath139 has a global improvement .",
    "we claim that @xmath2 is a global improvement of @xmath139 .",
    "this is clearly the case if @xmath332 .",
    "so suppose that @xmath333 .",
    "let @xmath309 be a fact in @xmath334 .",
    "we need to show that there is a fact @xmath335 such that @xmath141 .",
    "we complete the proof by finding such an @xmath49 .",
    "recall from theorem  [ thm : ccategoricity - correct ] that @xmath2 is the result of executing @xmath336 .",
    "consider the positive strata @xmath264 and the negative strata @xmath337 constructed in that execution . since @xmath2 is the union of the positive strata , we get that @xmath309 necessarily belongs to a negative stratum , say @xmath337 . from the definition of @xmath337 it follows that @xmath73 has a hyperedge @xmath170 such that @xmath338 , @xmath339 , and @xmath340 .",
    "let @xmath170 be such a hyperedge .",
    "since @xmath139 is consistent , it can not be the case that @xmath139 contains all the facts in @xmath170 .",
    "choose a fact @xmath341 such that @xmath342",
    ". then @xmath343 , and since @xmath110 is transitive ( and @xmath49 and @xmath309 are neighbors ) , we have @xmath141 .",
    "so @xmath140 and @xmath141 , as required .",
    "combining theorems  [ thm : c - categoricity - ptime ] and  [ thm : g - c - same - transitive ] , we get the following .    [ cor : g - categoricity - transitive - ptime ] for transitive priority relations , problems g - categoricity and c - categoricity coincide , and in particular",
    ", g - categoricity is solvable in polynomial time",
    ".    the reader may wonder whether theorem  [ thm : g - c - same - transitive ] and corollary  [ cor : g - categoricity - transitive - ptime ] hold for p - categoricity as well .",
    "this is not the case .",
    "the hardness of p - categoricity@xmath344 ( theorem  [ thm : hardness - specific - pareto ] ) is proved by constructing a reduction where the priority relation is transitive ( and in fact , it has no chains of length larger than one ) .    in their analysis ,",
    "fagin et al .",
    "@xcite have constructed various reductions for proving conp - hardness of g - repair checking . in several of these ,",
    "the priority relation is transitive .",
    "we conclude that there are schemas @xmath54 such that , on transitive priority relations , g - repair checking is conp - complete whereas g - categoricity is solvable in polynomial time .",
    "[ sec : related ]    we now discuss the relationship between our work and past work on data cleaning .",
    "specifically , we focus on relating and contrasting our complexity results with ones established in past research . to the best of our knowledge , there has not been any work on the complexity of categoricity within the prioritized repairing of staworko et al .",
    "fagin et al .",
    "@xcite investigated a static version of categoricity in the context of text extraction , but the settings and problems are very different , and so are the complexity results ( e.g. , fagin et al .",
    "@xcite establish undecidability results ) .",
    "bohannon et al .",
    "@xcite have studied a repairing framework where repairing operations involve attribute updates and tuple insertions , and where the quality of a repair is determined by a cost function ( aggregating the costs of individual operations ) .",
    "they have shown that finding an optimal repair is np - hard , in data complexity , even when integrity constraints consist of only fds .",
    "this result could be generalized to hardness of categoricity in their model ( e.g. , by a reduction from the problem  @xcite ) .",
    "the source of hardness in their model is the cost minimization , and it is not clear how any of our hardness results could derive from those , as the framework of preferred repairs ( adopted here ) does not involve any cost - based quality ; in particular , as echoed in this paper , an optimal repair can be found in polynomial time under each of the three semantics  @xcite .    in the framework of  (",
    "* chapter 6)@xcite , relations consist of entities with attributes , where each entity may appear in different tuples , every time with possibly different ( conflicting ) attribute values . a partial order on each attribute",
    "is provided , where `` greater than '' stands for `` more current . ''",
    "a of an instance is obtained by completing the partial order on an attribute of every entity , and it defines a where each attribute takes its most recent value .",
    "in addition , a completion needs to satisfy given ( denial ) constraints , which may introduce interdependencies among completions of different attributes .",
    "fan et al .",
    "@xcite have studied the problem of determining whether such a specification induces a single current instance ( i.e. , the corresponding version of categoricity ) , and showed that this problem is conp - complete under data complexity .",
    "it is again not clear how to simulate their hardness in our p - categoricity and g - categoricity , since their hardness is due to the constrains on completions , and these constraints do not have correspondents in our case ( beyond the partial orders ) .",
    "a similar argument relates our lower bounds to those in the framework of conflict resolution by fan geerts  ( * ? ? ?",
    "* chapter  7.3 ) , where the focus is on establishing a unique tuple from a collection of conflicting tuples .",
    "fan et al .",
    "@xcite show that in the absence of constraints , their categoricity problem can be solved in polynomial time ( even in the presence of `` copy functions '' ) .",
    "this tractability result can be used for establishing the tractability side of theorem  [ thm : pareto ] in the special case where the single fd is a key constraint . in the general case of a single fd , we need to argue about relationships among sets , and in particular , the differences among the three x - categoricity problems matter .",
    "cao et al .",
    "@xcite have studied the problem of entity record cleaning , where again the attributes of an entity are represented as a relation ( with missing values ) , and a partial order is defined on each attribute .",
    "the goal is to increase the accuracy of values from the partial orders and an external source of reliable ( `` master '' ) data .",
    "the specification now gives update steps that have the form of logical rules that specify when one value should replace a null , when new preferences are to be derived , and when data should be copied from the master data .",
    "hence , cleaning is established by these rules .",
    "they study a problem related to categoricity , namely the property : is it the case that every application of the chase ( in any rule - selection and grounding order ) results in the same instance ? they show that this property is testable in polynomial time by giving an algorithm that tests whether some invalid step in the end of the execution has been valid sometime during the execution .",
    "we do not see any clear way of deriving any of our upper bounds from this result , due to the difference in the update model ( updating nulls and preferences vs.  tuple deletion ) , and the optimality model ( chase termination vs.  x - repair ) .",
    "the works on  @xcite ( * ? ? ?",
    "* chapters  7.17.2 ) consider models that are substantially different from the one adopted here , where repairs are obtained by chasing update rules ( rather than tuple deletion ) , and uniqueness applies to chase outcomes ( rather than maximal subinstances w.r.t",
    ".  preference lifting ) .",
    "the problems relevant to our categoricity are the  @xcite ( w.r.t .",
    "guarantees on the consistency of some attributes following certain patterns ) , and the problem  @xcite .",
    "they are shown to be intractable ( conp - complete  @xcite and pspace - complete  @xcite ) under combined complexity ( while we focus here on data complexity ) .",
    "finally , we remark that there have several dichotomy results on the complexity of problems associated with inconsistent data  @xcite , but to the best of our knowledge this paper is the first to establish a dichotomy result for any variant of repair uniqueness identification .",
    "we investigated the complexity of the categoricity problem , which is that of determining whether the provided priority relation suffices to clean the database unambiguously in the framework of preferred repairs .",
    "following the three semantics of optimal repairs , we investigated the three variants of this problem : p - categoricity , g - categoricity and c - categoricity .",
    "we established a dichotomy in the data complexity of p - categoricity for the case where constraints are fds , partitioning the cases into polynomial time and conp - completeness .",
    "we further showed that the tractable side of p - categoricity extends to g - categoricity , but the latter can reach @xmath0-completeness already for two fds .",
    "finally , we showed that c - categoricity is solvable in polynomial time in the general case where integrity constraints are given as a conflict hypergraph .",
    "we complete this paper by discussing directions for future research .    in this work",
    "we did not address any qualitative discrimination among the three notions of x - repairs .",
    "rather , we continue the line of work  @xcite that explores the impact of the choice on the entailed computational complexity .",
    "it has been established that , as far as repair checking is concerned , the pareto and the completion semantics behave much better than the global one , since g - repair checking is tractable only in a very restricted class of schemas  @xcite . in this work",
    "we have shown that from the viewpoint of categoricity , the pareto semantics departs from the completion one by being likewise intractable ( while the global semantics hits an even higher complexity class ) , hence the completion semantics outstands so far as the most efficient option to adopt .",
    "it would be interesting to further understand the complexity of g - categoricity , towards a dichotomy ( at least for fds ) .",
    "we have left open the question of whether there exists a schema with a single relation and a set of fds , equivalent to a single fd , such that g - categoricity is solvable in polynomial time . beyond that , for both p - categoricity and g - categoricity it is important to detect islands of tractability based on properties of the data and/or the priority relation ( as schema constraints do not get us far in terms of efficient algorithms , at least by our dichotomy for p - repairs ) , beyond transitivity in the case of g - categoricity ( corollary  [ cor : g - categoricity - transitive - ptime ] ) .",
    "another interesting direction would be the generalization of categoricity to the problems of and the preferred repairs .",
    "for classical repairs ( without a priority relation ) , maslowski and wijsen  @xcite established dichotomies ( fp vs.  # p - completeness ) in the complexity of counting in the case where constraints are primary keys . for the general case of denial constraints , counting the classical repairs reduces to the enumeration of independent sets of a hypergraph with a bounded edge size , a problem shown by boros et al .",
    "@xcite to be solvable in incremental polynomial time ( and in particular polynomial input - output complexity ) . for a general given conflict hypergraph ,",
    "repair enumeration is the well known problem of enumerating the ( also known as the hypergraph problem ) ; whether this problem is solvable in polynomial total time is a long standing open problem  @xcite .    in this work we focused on cleaning within the framework of preferred repairs , where integrity constraints are anti - monotonic and cleaning operations are tuple deletions ( i.e. , ) .",
    "however , the problem of categoricity arises in every cleaning framework that is based on defining a set of repairs with a preference between repairs , including different types of integrity constraints , different cleaning operations ( e.g. , tuple addition and cell update  @xcite ) , and different priority specifications among repairs .",
    "this includes preferences by means of general scoring functions  @xcite , aggregation of scores on the individual cleaning operations  @xcite , priorities among resolution policies  @xcite and preferences based on soft rules  @xcite .",
    "this also includes the llunatic system  @xcite where priorities are defined by lifting partial orders among `` cell groups , '' representing either semantic preferences ( e.g. , timestamps ) or level of completeness ( e.g. , null vs.  non - null ) .",
    "a valuable future direction would be to investigate the complexity of categoricity in the above frameworks , and in particular , to see whether ideas or proof techniques from this work can be used to analyze their categoricity .",
    "motivated by the tractability of c - categoricity , we plan to pursue an implementation of an interactive and declarative system for database cleaning , where rules are of two kinds : integrity constraints and priority specifications ( e.g. , based on the semantics of of fagin et al .",
    "@xcite ) . to make such a system applicable to a wide range of practical use cases",
    ", we will need to extend beyond subset repairs , and consequently , investigate the fundamental direction of extending the framework of preferred repairs towards such repairs .",
    "in this section we provide proofs for section  [ sec : p ] .      in the following section , we say that a block @xmath345 ( respectively , @xmath346 ) is the block ( respectively , subblock ) of a fact @xmath49 if @xmath347 ( respectively @xmath348 ) .",
    "note that each fact has a unique block and subblock .",
    "recall that @xmath9 is the set @xmath349 .",
    "we start by proving the second part of the lemma .",
    "that is , we show that each p - repair of a block @xmath345 is a subblock @xmath346 .",
    "let @xmath5 be a p - repair of @xmath345 .",
    "then @xmath5 is contained in a single subblock of @xmath345 , since @xmath5 is consistent .",
    "moreover , @xmath5 contains all the facts in @xmath346 , or otherwise @xmath5 has a pareto improvement .",
    "next , we prove the first part of the lemma .",
    "let @xmath2 be a p - repair of @xmath1 .",
    "we need to show that @xmath2 is a union of p - repairs over all the blocks @xmath345 of @xmath1 .",
    "observe that @xmath2 is consistent , and so , for each block @xmath345 it contains facts from at most one subblock @xmath346 .",
    "moreover , since @xmath2 is maximal , it contains at least one representative from each block @xmath345 , and furthermore , it contains the entire subblock of each such a representative .",
    "we conclude that @xmath2 is the union of subblocks of @xmath1 .",
    "it is left to show that if a subblock @xmath346 is contained in @xmath2 , then @xmath346 is a p - repair of @xmath345 .",
    "let @xmath346 be a subblock contained in @xmath2 and assume , by way of contradiction , that @xmath5 is a pareto - improvement of @xmath346 in @xmath345 .",
    "let @xmath139 be the instance that is obtained from @xmath2 by replacing @xmath346 with @xmath5 .",
    "observe that @xmath139 is consistent , since no facts in @xmath2 other than those in @xmath346 conflict with facts from @xmath5 .",
    "then clearly , @xmath139 is a pareto improvement of @xmath2 , which contradicts the fact that @xmath2 is a p - repair .",
    "let @xmath2 be a union of p - repairs over all the blocks @xmath345 of @xmath1 .",
    "we need to show that @xmath2 is a p - repair . by the second part of the lemma",
    ", @xmath2 is a union of subblocks .",
    "since each subblock is consistent and facts from different blocks are consistent , we get that @xmath2 is consistent .",
    "it is left to show that @xmath2 does not have a pareto improvement .",
    "assume , by way of contradiction , that @xmath2 has a pareto improvement @xmath5 . by the definition of a pareto improvement , @xmath5 contains a fact @xmath49 such that @xmath120 for all @xmath350 .",
    "let @xmath49 be such a fact .",
    "let @xmath345 be the subblock of @xmath49 .",
    "then , by our assumption the subinstance @xmath2 contains a p - repair of @xmath345 , and from the second part of the lemma this p - repair is a subblock of @xmath345 , say @xmath346 .",
    "but then , @xmath49 is not in @xmath346 ( since @xmath351 ) , and therefore , @xmath5 does not contain any fact from @xmath346 ( since @xmath5 is consistent ) . we conclude that @xmath120 for all @xmath352 , and hence , @xmath346 has a pareto improvement ( namely @xmath353 ) , in contradiction to the fact that @xmath346 is a p - repair of @xmath345 .",
    "we construct a reduction from the exact - cover problem ( @xmath355 ) to the complement of p - categoricity@xmath354 .",
    "the input to @xmath355 is a set @xmath356 of elements and a collection @xmath357 of subsets of @xmath356 , such that their union is @xmath356 .",
    "the goal is to identify whether there is an exact cover of @xmath356 by @xmath357 .",
    "an of @xmath356 by @xmath357 is a collection of pairwise disjoint sets from @xmath357 whose union is @xmath356 .        in the sequel",
    ", we relate to these facts by according to their roman number . for example , facts of the form @xmath372 , where @xmath360 , @xmath361 and @xmath373 , will be referred to as facts of type @xmath374 .",
    "our construction is partly illustrated in figure  [ fig : paretohardness ] for the following input to the @xmath355 problem : @xmath382 , @xmath383 where @xmath384 , @xmath385 and @xmath386 .",
    "note that we denote the fact @xmath387 by @xmath388 . in this case , there is an exact cover of @xmath356 by @xmath357 that consists of the sets @xmath37 and @xmath38 .",
    "the gray facts represent a p - repair .",
    "we start by finding a c - repair .          in the the remainder of the proof",
    ", we relate to the the c - repair from lemma  [ pareto : l : greedy ] by @xmath390 .",
    "note that every c - repair is also a p - repair and therefore @xmath391 is a p - repair of @xmath1 . to complete the proof",
    "we show that there is a solution to @xmath355 if and only if @xmath1 has a p - repair different from @xmath391 .",
    "we construct a p - repair of @xmath1 , namely @xmath5 , different from @xmath391 based on a solution to @xmath355 .",
    "let the collection of sets @xmath392 be a solution to @xmath355 .",
    "let @xmath5 consist of the following facts for all @xmath360 , @xmath361 and @xmath373 .",
    "note that since @xmath5 is different from @xmath391 ( see lemma  [ pareto : l : greedy ] ) , it is left to show that @xmath5 is a p - repair of @xmath1 . to do so",
    ", we show that @xmath5 is consistent and that it does not have a pareto improvement .",
    "it suffices to show that for all @xmath49 in @xmath396 , there exists @xmath397 in @xmath5 such that @xmath398 is inconsistent ( w.r.t .",
    "@xmath399 ) and @xmath400 . for each @xmath401",
    "we choose @xmath402 such that the conditions hold .",
    "we divide to different cases according to the type of @xmath49 .    *",
    "that is , there exists an element @xmath403 in @xmath356 such that @xmath404 .",
    "since the collection @xmath405 is a cover of @xmath356 , there exists @xmath41 in @xmath405 such that @xmath406 .",
    "hence , @xmath407 and we choose @xmath408 .",
    "* this is impossible , since @xmath5 contains all the facts of this type .",
    "* that is , there exists @xmath409 @xmath410 and @xmath373 such that @xmath411 .",
    "we choose @xmath412 . *",
    "that is , there exists a set @xmath413 and @xmath361 such that @xmath414 . since @xmath415",
    ", it holds that @xmath416 .",
    "hence @xmath417 and we choose @xmath418 .",
    "* that is , there exists a set @xmath413 and @xmath361 such that @xmath419 . since @xmath415",
    ", it holds that @xmath420 .",
    "hence @xmath421 and we choose @xmath422 .",
    "* that is , there exists a set @xmath413 where @xmath369 and @xmath423 such that @xmath424 .",
    "since the collection @xmath405 is a cover of @xmath356 , there exists some @xmath42 in @xmath405 such that @xmath425 .",
    "hence , we get that @xmath426 and we choose @xmath427 .",
    "we show that if @xmath1 has a p - repair different from @xmath391 ( from lemma  [ pareto : l : greedy ] ) then there is a solution to @xmath355 .",
    "the proof of this direction consists of several lemmas , and the dependencies between them are described in figure  [ fig : lemmas - onlyif ] .",
    "for example ,",
    "the proof of lemma  [ pareto : l : all ( u , u ) together ] is based on lemmas  [ pareto :",
    "l : notmiddle r2(xx , f_u ) ] ,  [ pareto : l : ( u , u ) not in k , ( u , fu ) in k ] and  [ pareto :",
    "l : ( u , f_u ) in k , ( xu , u ) in k ] .        let @xmath431 , @xmath432 and @xmath433 .",
    "assume , by way of contradiction , that @xmath434 .",
    "since @xmath5 is consistent and @xmath435 is inconsistent with @xmath436 , we obtain that @xmath437 .",
    "since @xmath438 , it holds that @xmath5 must contain a fact @xmath49 that is inconsistent with @xmath435 ( but is consistent with @xmath436 ) .",
    "therefore , @xmath49 must agree with @xmath435 on @xmath38 .",
    "that leads to a contradiction since there is no such fact .",
    "let @xmath431 , @xmath432 and @xmath433 where @xmath439 .",
    "assume that @xmath441 .",
    "since for all @xmath360 , @xmath361 and @xmath373 , we have that @xmath442 , the p - repair @xmath5 must contain a fact @xmath49 that is inconsistent with @xmath362 ( but is consistent with @xmath443 ) .",
    "since @xmath5 is consistent , @xmath49 must agree with @xmath362 on @xmath37 .",
    "thus , @xmath49 must be the fact @xmath363 . replacing both facts @xmath443 and @xmath363 with @xmath362 results in a pareto improvement of @xmath5 which leads to a contradiction since @xmath5 is a p - repair .",
    "assume @xmath446 . assume , by way of contradiction , that @xmath448 .",
    "since @xmath5 is maximal , it must contain a fact @xmath49 that is inconsistent with @xmath363 .",
    "if @xmath49 agrees with @xmath363 on @xmath37 then it can only be of type @xmath444 .",
    "that is , the only possibility is that @xmath404 which leads to a contradiction . if @xmath49 agrees with @xmath363 on @xmath38 , it can only be of type @xmath374 which leads to a contradiction since by lemma  [ pareto : l : notmiddle r2(xx , f_u ) ] , such a fact can not be in a p - repair .",
    "assume @xmath447 . since @xmath5 is consistent , @xmath446 .",
    "it follows from @xmath451 that @xmath5 must contain a fact @xmath49 that is inconsistent with @xmath362 .",
    "since @xmath5 is consistent , @xmath49 is consistent with @xmath363 .",
    "therefore , @xmath49 must agree with @xmath362 on @xmath38 . the possible types for @xmath49 are @xmath429 and @xmath449 . by lemme  [ pareto :",
    "l : notmiddle r2(xx , u ) ] , @xmath49 is not of type @xmath429 .",
    "thus , @xmath49 must be of type @xmath449 .",
    "therefore , @xmath450 for @xmath360 such that @xmath406 ( there exists such @xmath41 since the union of sets of @xmath357 is @xmath356 ) .",
    "assume @xmath452 for all @xmath413 .",
    "assume , by way of contradiction , that @xmath446 .",
    "by lemma  [ pareto : l : ( u , u ) not in k , ( u , fu ) in k ] , @xmath454 . by lemma  [ pareto :",
    "l : ( u , f_u ) in k , ( xu , u ) in k ] , there exists @xmath360 such that @xmath406 and @xmath455 .",
    "this is a contradiction .",
    "let @xmath458 and assume @xmath461 .",
    "assume , by way of contradiction , there exists @xmath373 such that @xmath462 and @xmath463 . by lemma  [ pareto :",
    "l : ( u , u ) not in k , ( u , fu ) in k ] , @xmath454 .",
    "thus , by lemma  [ pareto : l : ( u , f_u ) in k , ( xu , u ) in k ] we have that @xmath464 for some @xmath465 such that @xmath466 . note that since @xmath467 , there must be a fact in @xmath5 that is inconsistent with @xmath468 and is consistent with @xmath469 .",
    "the only such a fact is @xmath470 ( i.e , @xmath471 ) .",
    "this is a contradiction since @xmath461 and @xmath5 is consistent .",
    "let @xmath373 and assume , by way of contradiction , that @xmath460 .",
    "by lemma  [ pareto :",
    "l : all ( u , u ) together ] , for all @xmath373 @xmath453 . since @xmath5 is consistent , it does not contain facts of the form @xmath363 for all @xmath373 ( since the fact @xmath363 is inconsistent with @xmath362 ) .",
    "moreover , @xmath5 does not contain facts of the form @xmath472 where @xmath360 and @xmath406 ( for a similar reason ) . by lemma  [ pareto :",
    "l : notmiddle r2(xx , f_u ) ] ( respectively , [ pareto : l : notmiddle r2(xx , u ) ] ) , @xmath5 does not contain facts of the form @xmath364 ( respectively , @xmath473 ) where @xmath360 and @xmath406 .",
    "it holds that @xmath5 is maximal and thus it contains all of the facts of type @xmath474 .",
    "thus , we conclude that @xmath5 is exactly @xmath391 which leads to a contradiction .",
    "let us denote @xmath369 and assume without loss of generality that @xmath478 .",
    "we prove by induction on @xmath97 that @xmath479 for all @xmath368 .",
    "assume @xmath479 .",
    "since @xmath480 , there must be a fact @xmath116 that is inconsistent with @xmath481 .",
    "since @xmath5 is consistent , @xmath49 must agree with @xmath481 on @xmath37 . by lemma  [ pareto :",
    "l : notmiddle r2(xx , f_u ) ] , @xmath49 is not of the form @xmath482 for @xmath373 and by lemma  [ pareto : l : notmiddle r2(xx , u ) ] @xmath49 is also not of the form @xmath483 for @xmath373 .",
    "therefore , @xmath49 must be @xmath484 .",
    "next , we show that @xmath5 encodes a solution for @xmath355 . specifically , we contend that there is an exact cover of @xmath356 by @xmath357 , namely @xmath485 , that is defined as follows : @xmath486 if and only if @xmath487 for some @xmath488",
    ".      let @xmath373 and assume , by way of contradiction , that for all @xmath486 , it holds that @xmath490 . by our assumption , @xmath491 for all @xmath360 such that @xmath406 .",
    "note that since the union of the sets in @xmath357 is @xmath356 , there exists a set @xmath360 such that @xmath406 .",
    "thus , the definition of the set @xmath485 implies that for all @xmath360 such that @xmath406 , we have that @xmath492 . by lemma  [ pareto :",
    "l : ( x_x , x ) not in k , ( x , x ) in k ] , @xmath460 . by lemma  [ pareto :",
    "l : ( u , u ) not in k ] , this is a contradiction .",
    "let @xmath493 where @xmath494 .",
    "assume , by way of contradiction , that there exists @xmath496 .",
    "by @xmath485 s definition , @xmath487 for some @xmath488 .",
    "lemma  [ pareto :",
    "l : whole set left column ] implies that for all @xmath488 , it holds that @xmath487 .",
    "similarly , for all @xmath497 , we have that @xmath498 . since @xmath496 , both facts @xmath499 and @xmath500 are in @xmath5 .",
    "this is a contradiction to @xmath5 s consistency .",
    "we construct a reduction from cnf satisfiability to p - categoricity@xmath344 .",
    "the input to cnf is a formula @xmath315 with the free variables @xmath502 , such that @xmath315 has the form @xmath503 where each @xmath504 is a clause .",
    "each clause is a conjunction of variables from the set @xmath505 .",
    "the goal is to determine whether there is a true assignment @xmath506 that satisfies @xmath315 .",
    "given such an input , we will construct the input @xmath507 for p - categoricity@xmath344 .",
    "for each @xmath508 and @xmath509 , @xmath1 contains the following facts :        * @xmath513 if @xmath514 appears in clause @xmath504 , * @xmath515 if @xmath516 appears in clause @xmath504 , and * @xmath517 , where @xmath518 , if neither @xmath514 nor @xmath516 appear in clause @xmath504 .",
    "our construction is illustrated in figure  [ fig : paretohard6 ] for the @xmath519 formula : @xmath520 .",
    "observe that the subinstance @xmath2 that consists of the facts @xmath521 for all @xmath98 , is the only c - repair . to complete the proof",
    ", we will show that @xmath315 is satisfiable if and only if @xmath1 has a p - repair different from @xmath2 .",
    "assume @xmath315 is satisfiable .",
    "that is , there exists an assignment @xmath522 that satisfies @xmath315 .",
    "we claim that the subinstance @xmath5 that consists of the facts @xmath523 for all @xmath97 is a p - repair ( that is different from @xmath2 ) .",
    "@xmath5 is consistent since @xmath524 is an assignment ( i.e. , each @xmath514 has exactly one value and the constraint @xmath525 is satisfied ) .",
    "for the same reason , @xmath5 is maximal ( facts of the form @xmath526 can not be added to @xmath5 because of the constraint @xmath527 ) .",
    "it is left to show that @xmath5 does not have a pareto improvement .",
    "assume , by way of contradiction , that it does .",
    "that is , there exists a fact @xmath528 such that @xmath120 for every @xmath117 .",
    "note that follows from @xmath110 s definition , @xmath49 must be of the form @xmath529 .",
    "nevertheless , this implies the clause @xmath504 is not satisfied by @xmath524 which leads us to the conclusion that @xmath315 is not satisfied by @xmath524 .",
    "assume there is a p - repair @xmath5 different from @xmath2 .",
    "since @xmath5 is different from @xmath2 , it must contain a fact @xmath530 for some @xmath97 .",
    "since @xmath5 is consistent and the fd @xmath527 is in @xmath531 , it holds that for all facts @xmath49 in @xmath5 , we have that @xmath532=\\odot$ ] .",
    "@xmath5 is maximal and consistent and thus induces a true assignment @xmath524 , defined by @xmath533 .",
    "assume , by way of contradiction , that @xmath524 does not satisfy @xmath315 .",
    "that is , there exists a clause @xmath504 that is not satisfied .",
    "by @xmath110 s definition , @xmath534 for each @xmath514 that appears in @xmath504 ( with or without negation ) .",
    "moreover , @xmath535 for each @xmath536 that does not appear in @xmath504 ( with or without negation ) .",
    "therefore @xmath537 for every @xmath116 , which implies that @xmath5 has a pareto improvement that contains the fact @xmath538 .",
    "hence , we get a contradiction .",
    "denote the single relation symbol in @xmath23 by @xmath40 .",
    "it holds that @xmath9 is equivalent to a pair of keys and therefore we can denote it by @xmath539 where @xmath540 are subsets of @xmath541 . let @xmath542 .",
    "we define a fact - wise reduction , @xmath543 , using the constant @xmath544 .",
    "that is , denote @xmath545 where for all @xmath546 @xmath547 in order to prove that @xmath208 is indeed a fact - wise reduction , we should show it is well - defined , preserves consistency and inconsistency and is injective .",
    "it is straightforward to see that @xmath208 is injective .",
    "note that since @xmath9 is not equivalent to a single fd , it holds that @xmath548 and @xmath549 .",
    "therefore , there exist @xmath97 and @xmath98 such that @xmath550 and @xmath551 . to show that it preserves consistency",
    ", we should show that for every two facts @xmath49 and @xmath397 , the set @xmath398 is consistent w.r.t @xmath399 if and only if @xmath552 is consistent w.r.t @xmath9 .",
    "assume that @xmath398 is consistent w.r.t @xmath399 , we contend that @xmath552 is consistent w.r.t @xmath9 .",
    "since @xmath398 is consistent w.r.t @xmath399 , if @xmath49 and @xmath397 agree on @xmath37 then they must also agree on @xmath38 and if they do not agree on @xmath37 then they also do not agree on @xmath38 .",
    "thus , either @xmath553 or @xmath554 .",
    "let @xmath559 and let @xmath560 . if @xmath561 and @xmath562 then by @xmath208 s definition and since @xmath563 and @xmath564 are not empty it holds that there exists @xmath565 such that @xmath566 and @xmath567 such that @xmath568 .",
    "thus @xmath569 and @xmath570 do not agree on @xmath41 nor on @xmath42 .",
    "that is , @xmath552 is consistent with respect to @xmath571 .",
    "assume @xmath398 is inconsistent w.r.t @xmath399 , we contend that @xmath552 is inconsistent w.r.t @xmath9 .",
    "since @xmath398 is inconsistent w.r.t @xmath399 , if @xmath49 and @xmath397 agree on @xmath37 then they must disagree on @xmath38 and if they disagree on @xmath37 then they must agree on @xmath38 .",
    "thus , either @xmath555 , @xmath572 or @xmath573 , @xmath574 .",
    "both cases are symmetric and thus we will prove the claim only for the case where @xmath555 and @xmath572 .",
    "let @xmath545 and @xmath575 .",
    "by @xmath208 s definition , @xmath576 for @xmath565 and @xmath577 for @xmath567 .",
    "moreover , for all other @xmath578 , it holds that @xmath579 .",
    "that is , the facts @xmath569 and @xmath570 agree on @xmath41 and disagree on @xmath42 .",
    "hence , @xmath552 is inconsistent w.r.t @xmath9                regarding the fact - wise reduction @xmath591 , note that @xmath592 if and only if @xmath555 and @xmath593 .",
    "note that for each @xmath583 , we have that @xmath594 is computable in polynomial time .",
    "moreover , it is straightforward to see that for each @xmath583 , it holds that @xmath594 is injective .",
    "thus , it is left to show that for each @xmath583 , the fact - wise reduction @xmath594 preserves consistency and inconsistency .",
    "that is , given two facts @xmath542 and @xmath595 , we show that for each @xmath583 , it holds that @xmath596 is consistent w.r.t @xmath597 , if and only if @xmath398 is consistent w.r.t @xmath399 .",
    "we prove the above for @xmath598 .",
    "let @xmath542 and @xmath595 .",
    "assume that @xmath398 is inconsistent with respect to @xmath399 .",
    "we contend that @xmath599 is inconsistent w.r.t @xmath600 .",
    "note that since @xmath398 is inconsistent with respect to @xmath399 , @xmath49 and @xmath397 must agree on one attribute and disagree on the second .",
    "both cases are symmetric and thus it suffices to show that if @xmath542 and @xmath595 agree on @xmath37 and disagree on @xmath38 then @xmath599 is inconsistent w.r.t @xmath600 . indeed , @xmath542 and @xmath595 agree on @xmath37 which implies @xmath555 , and disagree on @xmath38 which implies @xmath601 .",
    "thus , @xmath602 and @xmath603 agree on @xmath37 but do not agree on @xmath14 .",
    "that is , @xmath599 is inconsistent w.r.t @xmath600 .",
    "let @xmath542 and @xmath595 and assume that @xmath398 is consistent with respect to @xmath399 .",
    "we contend that @xmath599 is consistent w.r.t @xmath600 . if @xmath49 and @xmath397 agree on @xmath37 ( i.e. , @xmath604 ) , since they are consistent w.r.t @xmath399 they must agree also on @xmath38 ( i.e. , @xmath593 ) . hence @xmath605 and therefore @xmath606 .",
    "we conclude that @xmath599 is consistent w.r.t @xmath600 . if @xmath49 and @xmath397 do not agree on @xmath37 ( i.e. , @xmath573 ) , since they are consistent w.r.t @xmath399 they must also disagree on @xmath38 ( i.e. , @xmath572 ) .",
    "thus , @xmath607 and @xmath608 do not agree on @xmath37 nor on @xmath38 .",
    "that is , @xmath600 holds and thus @xmath599 is consistent w.r.t @xmath600 .",
    "+ similarly , this can be shown for each @xmath609 ( which are simpler cases than @xmath598 ) .      in the current section",
    "we prove the correctness of the @xmath306 algorithm , introduced in section  [ sec : c ] .",
    "in particular , we prove theorem  [ thm : ccategoricity - correct ] . for convenience , we repeat the theorem here",
    ".      we will divide our proof into two parts .",
    "first we will prove that the algorithm is sound ( i.e. , if @xmath2 is consistent , then @xmath1 has precisely one c - repair ) .",
    "later , we will prove that the algorithm is complete ( i.e. , if @xmath1 has precisely one c - repair , then @xmath2 is consistent ) . before that",
    ", we need a basic lemma that will be used in both parts of the proof .",
    "[ lemma : ccat - findcrepair - from - consistent - j ] suppose that @xmath262 are the positive strata constructed by executing @xmath336 . for every @xmath610 , if @xmath611 is consistent , then there exists an execution of the @xmath168 algorithm on @xmath119 , such that at the beginning of some iteration of that execution the following hold :      let us start the execution of the @xmath168 algorithm on @xmath119 as follows .",
    "first , we will select all of the facts from @xmath271 and add them to @xmath2 ( one by one ) , then we will select all of the facts from @xmath614 and add them to @xmath2 and so on . if we can add all of the facts from @xmath612 to @xmath2 during this process , and at the end all of the facts in @xmath615 belong to @xmath169 , then there exists an execution of the @xmath168 algorithm that satisfies all the conditions and that will conclude our proof .      *",
    "one of the facts in @xmath612 can not be added to @xmath2 . * after adding all of the facts from @xmath612 ( and only these facts ) to @xmath2 , one of the facts in @xmath615 does not belong to @xmath169 .",
    "if the first case holds , let @xmath264 be the first positive stratum such that a fact @xmath616 can not be added to @xmath2 after adding all of the facts in @xmath617 and maybe some of the facts in @xmath264 to @xmath2 .",
    "note that @xmath612 does not contain a hyperedge , thus if @xmath49 can not be added to @xmath2 , it holds that @xmath49 does not belong to @xmath169 .",
    "that is , there exists at least one fact @xmath50 , such that @xmath118 .",
    "moreover , there exists at least one finite sequence , @xmath618 , of facts in @xmath1 ( with @xmath619 ) , such that @xmath620 .",
    "note that for each such sequence of facts , it holds that @xmath621 for every fact @xmath622 in the sequence . in this case ,",
    "one of the following holds for each fact @xmath622 :      we assumed that we were able to add all the facts from @xmath617 to @xmath2 , thus @xmath626 can not belong to @xmath623 for some @xmath624 .",
    "furthermore , by the definition of @xmath264 , after removing all of the facts from @xmath617 and @xmath627 , every fact @xmath616 belongs to @xmath628 ( and consequently to @xmath169 ) . this can not be the case if there exists a fact @xmath621 that belongs to @xmath623 or @xmath337 for some @xmath625 .",
    "thus , the only possibility left is that every fact @xmath626 belongs to @xmath337 for some @xmath624 .",
    "since for every such sequence of facts , @xmath629 belongs to @xmath169 , it can be selected in line  3 of the algorithm at the next iteration . by the definition of @xmath337 , there exists a hyperedge that is contained in @xmath630 .",
    "we know that all the facts in @xmath631 were added to @xmath2 , thus @xmath629 will be excluded from @xmath2 .",
    "after selecting fact @xmath629 from each sequence and removing it from @xmath1 , the next fact , @xmath632 , in each sequence belongs to @xmath169 .",
    "the previous arguments hold for @xmath632 as well , thus @xmath632 can be selected in line  3 of the algorithm at the next iteration .",
    "note that if a fact @xmath622 belongs to more than one sequence , it will be removed after all the previous facts in each one of these sequences are removed .",
    "we can continue with this process until it holds that @xmath633 , and then add it to @xmath2 , in contradiction to our assumption .",
    "if the second case holds , at each of the next iterations of the algorithm ( and before adding facts that do not belong to @xmath612 to @xmath2 ) , there exists a fact @xmath613 that does not belong to @xmath169 . similarly to the previous part , if @xmath49 does not belong to @xmath169 , there exist at least one sequence @xmath618 of facts , such that @xmath621 for every fact in the sequence and each fact @xmath622 belongs to @xmath337 for some @xmath634 .",
    "we again can select all of the facts in each sequence as the maximal elements in line  3 of the algorithm by topological order until @xmath633 .",
    "this is a contradiction to our assumption , thus @xmath49 does belong to @xmath169 after adding all of the facts in @xmath612 to @xmath2 and removing all of the corresponding facts in @xmath635 from @xmath1 .",
    "note that in this case , we will be able to select @xmath49 in line  3 of the algorithm at the next iteration ; however , we may not be able to add @xmath49 to @xmath2 , since @xmath636 is not consistent .",
    "consider the @xmath306 execution on the inconsistent prioritizing instance @xmath119 from our followers running example , illustrated in figure  [ fig : follows - exec ] . in this example",
    ", @xmath637 is consistent .",
    "we can start building the repair @xmath2 , using the @xmath168 algorithm as follows .",
    "( we recall that we denote inclusion in @xmath2 by plus and exclusion from @xmath2 by minus . ) @xmath638 as lemma  [ lemma : ccat - findcrepair - from - consistent - j ] states , at the current iteration of the algorithm , all the facts in @xmath637 belong to @xmath2 .",
    "moreover , the facts in @xmath639 ( that is , @xmath91 and @xmath94 ) belong to @xmath169 , as the second part of the lemma states .",
    "note that in our example , there exists a different execution of the @xmath168 algorithm .",
    "@xmath640 in this case , there does not exist an iteration of the algorithm that satisfies the conditions from lemma  [ lemma : ccat - findcrepair - from - consistent - j ] .",
    "thus , different executions of the algorithm may be possible ; however , there always exists an execution of the @xmath168 algorithm that satisfies the conditions from the lemma .",
    "next , we prove that if @xmath2 is consistent , then @xmath1 has precisely one c - repair .",
    "let us denote by @xmath641 the number of iterations of the @xmath306 algorithm on the input @xmath119 .",
    "that is , it holds that @xmath642 at the end of the algorithm . since @xmath2 is consistent , lemma  [ lemma : ccat - findcrepair - from - consistent - j ] and the fact that the @xmath168 algorithm is sound ( theorem  [ thm : cgreedy ] ) imply that there exists a c - repair @xmath5 that includes all of the facts in @xmath643 .",
    "the following lemma proves that a c - repair can not include any fact that belongs to @xmath265 for some @xmath644 .",
    "let us assume , by way of contradiction , that there exists a c - repair @xmath646 that includes at least one fact from @xmath645 . by theorem  [ thm : cgreedy ]",
    ", @xmath168 is complete , thus there exists an execution of the algorithm that produces @xmath646 .",
    "consider an execution of @xmath168 that produces @xmath646 . in that execution , consider the first time that a fact from a negative stratum is added to @xmath646 ; let @xmath50 be that fact .",
    "that is , @xmath647 for some @xmath648 . by the definition of @xmath265",
    ", there exists a hyperedge @xmath649 that is contained in @xmath650 , such that for every other fact @xmath341 it holds that @xmath247 .",
    "if we are able to choose fact @xmath50 for the repair at some iteration of the algorithm , it necessarily belongs to @xmath169 at this iteration .",
    "therefore , all of the other facts in @xmath170 are no longer included in @xmath1 .",
    "this may be the case if all of the other facts in the hyperedge were already added to @xmath646 .",
    "however , adding @xmath50 to @xmath646 will result in a hyperedge , in contradiction to the fact the @xmath646 is a repair .",
    "therefore , at least one of the facts in the hyperedge was removed from @xmath1 without being added to @xmath646 ; let @xmath49 be such a fact .",
    "that is , there exists another hyperedge @xmath651 that includes @xmath49 , such that all of the other facts in this hyperedge were added to @xmath646 before @xmath49 was removed from @xmath1 .",
    "all of these facts , including @xmath49 , belong to @xmath643 , since we assumed that @xmath50 is the first fact from some @xmath265 that was chosen for the repair .",
    "hence , we found a hyperedge , @xmath651 , that is contained in @xmath643 , in contradiction to the fact that @xmath643 is consistent .",
    "thus , a fact @xmath647 can not be added to any repair of @xmath1 .",
    "lemma  [ lemma : ccat - no - repair - ni ] implies that every c - repair is contained in @xmath2 .",
    "moreover , as said above , there exists a c - repair that includes all of the facts in @xmath2 .",
    "thus , @xmath2 is the only c - repair of @xmath1 and this concludes the proof of soundness of the @xmath306 algorithm .",
    "finally , we prove that if @xmath1 has precisely one c - repair , then @xmath2 is consistent . throughout this section",
    "we fix @xmath119 and assume that there is exactly one c - repair , which we denote by @xmath5 .",
    "let @xmath159 denote the subinstance @xmath310 .",
    "we prove by induction on @xmath578 that after the @xmath578th iteration of @xmath306 , the instance @xmath652 is consistent .",
    "then , we will conclude that @xmath2 is consistent when the algorithm reaches line  9 , and consequently , the algorithm returns true as we expect .",
    "the basis of the induction , @xmath653 , is proved by observing that @xmath390 is an empty set , thus it does not include any hyperedge . for the inductive step ,",
    "we need to prove that if @xmath654 is consistent then @xmath636 is also consistent .",
    "so , suppose that @xmath654 is consistent .",
    "let us assume , by way of contradiction , that @xmath636 is inconsistent , that is , @xmath636 contains a hyperedge .",
    "we next prove the following lemma .",
    "let @xmath170 be a hyperedge that is contained in @xmath656 and has a minimal intersection with @xmath615 .",
    "let @xmath657 be the set @xmath658 .",
    "then @xmath249 since @xmath654 does not contain a hyperedge . to prove the lemma",
    ", we need to show that @xmath659 .",
    "suppose , by way of contradiction , that @xmath660 .",
    "since @xmath654 is consistent , lemma  [ lemma : ccat - findcrepair - from - consistent - j ] implies that we can start building a c - repair using the @xmath168 algorithm by first choosing all of the facts in @xmath612 .",
    "moreover , after choosing all of these facts , there exists an iteration @xmath97 in which each fact in @xmath615 belongs to @xmath169 . since @xmath168 always produces a c - repair ( theorem  [ thm : cgreedy ] ) , we can now choose the fact @xmath661 , which will result in a c - repair @xmath145 .",
    "this holds true due to our assumption that @xmath660 and @xmath662 is minimal ( hence , adding a signle fact to a set of facts that currently includes only facts from @xmath612 does not result in the containment of a hyperedge ) .",
    "the c - repair @xmath145 can not contain all of the facts in @xmath657 , since a repair can not contain a hyperedge .",
    "let us assume that @xmath663 is not in @xmath145 .",
    "if we choose @xmath664 instead of @xmath661 at the @xmath97th iteration , the @xmath168 algorithm will produce a c - repair @xmath144 that includes @xmath664 .",
    "again , we can choose @xmath664 due to our assumption that @xmath660 and @xmath662 is minimal .",
    "that is , we have two distinct c - repairs , @xmath145 and @xmath144 , in contradiction to our assumption that @xmath1 has precisely one c - repair .",
    "since we assumed that @xmath1 has exactly one c - repair and @xmath612 is consistent , lemma  [ lemma : ccat - next - p - no - conflicts ] implies that there exists a hyperedge @xmath665 such that precisely one of the @xmath666 belongs to @xmath615 , while the other facts belong to @xmath612 . without loss of generality",
    ", we can assume that @xmath667 .",
    "we next prove the existence of two distinct c - repairs :        lemma  [ lemma : ccat - findcrepair - from - consistent - j ] implies that it is possible to build a c - repair using @xmath168 by first choosing all of the facts in @xmath612 . as all of the facts in @xmath669 belong to @xmath612 ,",
    "all of them will be chosen in this process as well .",
    "since the @xmath168 algorithm is sound ( theorem  [ thm : cgreedy ] ) , this specific execution of the algorithm will result in a c - repair @xmath2 of @xmath1 that includes all of the facts @xmath670 .",
    "the fact @xmath661 can not be included in @xmath2 , since adding it to @xmath2 will result in a repair that contains a hyperedge , which is impossible by definition .    to complete the proof of completeness",
    ", we prove that there exists another c - repair of @xmath1 that includes @xmath661 . in order to do so",
    ", we again take advantage of the algorithm @xmath168 , and prove the following lemma .      in order to prove the lemma",
    ", we start building the corresponding c - repair , using the @xmath168 algorithm , by first selecting in line  3 of the algorithm only facts from @xmath612 that either can not be added to @xmath2 or satisfy at least one of the following conditions :      note that not all of the facts in @xmath612 that satisfy at least one of the conditions can be selected in this process .",
    "a fact @xmath672 , for example , may be left out of @xmath2 if a fact @xmath673 is not selected because it does not satisfy any of the conditions and it holds that @xmath120 . in this case",
    ", @xmath50 will not belong to @xmath169 until @xmath49 is selected by the algorithm .",
    "however , since @xmath654 is consistent , all of the facts from @xmath612 that can be selected in line  3 of the algorithm during this process can also be added to @xmath2 .",
    "we will now prove that after selecting all of these facts , the algorithm can add the fact @xmath661 to @xmath2 next ( that is , before adding any other fact to @xmath2 ) .",
    "this will eventually result in a c - repair that includes @xmath661 and will conclude our proof .",
    "let us assume , by way of contradiction , that we can not add @xmath661 to @xmath2 next .",
    "that is , one of the following holds :    * there exists a hyperedge that contains @xmath661 such that all of the other facts in the hyperedge have already been added to @xmath2 .",
    "* we must add another fact to @xmath2 before it holds that @xmath674 .",
    "if the first case holds , then there exists a hyperedge @xmath170 , such that @xmath675 and all of the other facts in the hyperedge were added to @xmath2 in the previous iterations of the algorithm .",
    "note that all of the facts that have already been added to @xmath2 , including @xmath668 , belong to @xmath612 .",
    "moreover , it holds that @xmath676 for every fact @xmath677 , since a fact @xmath677 that does not hold @xmath676 , does not satisfy any of the conditions and could not have been added to @xmath2 . hence , we found a hyperedge @xmath170 , such that @xmath675 , and for every other fact @xmath678 it holds that @xmath679 and @xmath676 . by the definition of negative stratum , it should hold that @xmath680 for some @xmath681 ( the exact value of @xmath97 depends on the other facts in this hyperedge ) , in contradiction to the fact that @xmath667 .",
    "thus , the first case is impossible .",
    "if the second case holds , then at one of the next iterations , only facts that can be added to @xmath2 belong to @xmath169 , while @xmath661 does not belong to @xmath169 yet . in this case",
    ", the @xmath168 algorithm must add another fact to @xmath2 before adding @xmath661 to @xmath2 .",
    "since @xmath661 does not belong to @xmath169 , there exists at least one fact @xmath50 such that @xmath682",
    ". moreover , there exists at least one finite sequence , @xmath618 , of facts in @xmath1 ( with @xmath619 ) , such that @xmath620 .",
    "note that for each such sequence of facts , it holds that @xmath621 for every fact @xmath622 in the sequence . in this case ,",
    "one of the following holds for each fact @xmath622 :      by the definition of @xmath615 , after removing all of the facts from @xmath612 and @xmath635 , every fact @xmath613 belongs to @xmath628 .",
    "this can not be the case if there exists a fact @xmath621 that belongs to @xmath623 or @xmath337 for some @xmath683 .",
    "thus , each fact @xmath622 either belongs to @xmath623 or @xmath337 for some @xmath634 .",
    "if @xmath629 belongs to some @xmath623 , then @xmath629 was not added to @xmath2 since it does not satisfy any of the conditions .",
    "this holds true since @xmath620 , thus it can be selected in line  3 of the algorithm .",
    "that is , there exists a hyperedge @xmath684 , such that @xmath685 and it does not hold that @xmath686 .",
    "this is a contradiction to the fact that @xmath687 , thus this can not be the case .",
    "the only possibility left is that @xmath688 for some @xmath634 . since it also holds that @xmath689 , the fact @xmath629 can be selected in line  3 of the algorithm next .",
    "note that by the definition of @xmath337 , there exists a hyperedge that is contained in @xmath630 , such that for every other fact @xmath690 in the hyperedge it holds that @xmath691 .",
    "since @xmath689 none of these facts still belongs to @xmath1 , thus they have already been added to @xmath2 , and @xmath629 will not be added to @xmath2 , but only removed from @xmath1 .",
    "we can continue with this process and choose all of the facts in each one of the corrsponding sequences by topological order , until @xmath692 .",
    "( if a fact @xmath622 belongs to more than one sequence , it will be removed after all the previous facts in each one of these sequences are removed . )",
    "then , we can add @xmath661 to @xmath2 , since every hyperedge that contains @xmath661 and is included in @xmath693 also contains at least one fact @xmath50 that does not satisfy @xmath254 ( otherwise , @xmath661 would belong to some @xmath337 ) .",
    "that is , each hyperedge that contains @xmath661 contains at least one fact that does not satisfy any of the conditions and was not added to @xmath2 , and adding @xmath661 to @xmath2 will not close any hyperedge .",
    "this is a contradiction to our assumption , thus @xmath661 can be chosen for the repair next .",
    "as said above , this concludes our proof .    from lemma  [ lemma : ccat - crepair - no - f1 ] and lemma  [ lemma : ccat - crepair - f1 ] we can conclude that there exist two distinct c - repairs of @xmath1",
    "this is a contradiction to our assumption that @xmath1 has precisely one c - repair .",
    "hence , @xmath636 is necessarily consistent , and this concludes our proof of completeness .          to show @xmath0-hardness , we construct a reduction from @xmath311 to the problem of g - categoricity@xmath344 .",
    "the input to @xmath311 consists of a cnf formula @xmath312 where @xmath313 and @xmath314 are disjoint sequences of variables .",
    "the goal is to determine whether for every assignment to @xmath313 there exists an assignment to @xmath314 such that the two satisfy @xmath315 .",
    "we denote @xmath313 by @xmath694 , @xmath314 by @xmath695 and @xmath696 . the input @xmath167 is constructed from @xmath315 by adding to it the following facts :    * @xmath697 and @xmath698 for each variable @xmath514 , * @xmath699 and @xmath700 for each variable @xmath514 , * @xmath701 and @xmath702 for each variable @xmath703 , * @xmath704 for each clause @xmath504 * @xmath705 which we denote by @xmath706 .",
    "* @xmath707 for all @xmath708 and for all variables @xmath514 , * @xmath709 if @xmath514 appears in clause @xmath504 , * @xmath710 if @xmath516 appears in clause @xmath504 and * @xmath711 for all variables @xmath712 and @xmath708 .      observe that the subinstance @xmath716 is a c - repair and thus it is also a g - repair . to complete the proof",
    "we will show that @xmath716 is the only g - repair if and only if @xmath315 is a `` yes '' instance ; that is , for every assignment to @xmath313 there exists an assignment to @xmath314 such that the two satisfy @xmath315 .",
    "assume that @xmath315 is a `` yes '' instance and let @xmath2 be a g - repair of @xmath1 .",
    "we contend that @xmath2 is exactly @xmath716 .",
    "assume , by way of contradiction that @xmath717 .",
    "since @xmath2 is consistent and since @xmath531 contains the fd @xmath527 , it holds that all of the facts in @xmath2 agree on @xmath37 . by our assumption that @xmath717 , there are two cases :    1 .",
    "for each fact @xmath718 , it holds that @xmath532=1 $ ] . by @xmath110 s definition , we have that @xmath716 is a global improvement of @xmath2 which is in contradiction to @xmath2 being a g - repair",
    ". 2 .   for each fact @xmath718",
    ", it holds that @xmath532 = 0 $ ] .",
    "we state that for all @xmath98 , the fact @xmath719 .",
    "assume , by way of contradiction , there exists @xmath98 for which @xmath720 .",
    "since @xmath2 is maximal it contains a fact @xmath49 that is inconsistent with @xmath704 . since for each fact",
    "@xmath718 , it holds that @xmath532 = 0 $ ] , there is no such fact and as a consequence no such @xmath98 .",
    "hence for all @xmath98 , we have that @xmath719 .",
    "moreover , since @xmath2 is maximal , it must contain a fact @xmath721 for each @xmath722 .",
    "note that @xmath531 contains the fd @xmath723 .",
    "this insures that @xmath2 can not contain both of the facts @xmath724 and @xmath698 .",
    "this implies that @xmath2 encodes an assignment @xmath725 for the variables @xmath726 .",
    "this assignment is given by @xmath727 since @xmath315 is a `` yes '' instance , there exists an assignment @xmath728 for the variables @xmath729 that together with @xmath725 satisfies @xmath315 .",
    "let @xmath5 be the subinstance of @xmath1 that consists of the facts @xmath730 for all @xmath97 and @xmath731 for all @xmath732 .",
    "note that @xmath5 is consistent .",
    "we contend that @xmath5 is a global improvement of @xmath2 .",
    "since @xmath2 and @xmath5 are disjoint , it suffices to show that for every fact @xmath718 there is a fact @xmath733 such that @xmath734 .",
    "let @xmath718 .",
    "if @xmath49 is of the form @xmath721 then we choose @xmath735 .",
    "if @xmath49 is of the form @xmath736 , then we choose @xmath737 where @xmath712 is the variable of a literal that satisfies @xmath504 under the union of @xmath725 and @xmath728 .",
    "we conclude that @xmath5 is a global improvement of @xmath2 , that is , @xmath2 is not a g - repair in contradiction to our assumption .",
    "assume that @xmath716 is the only g - repair of @xmath1 .",
    "we contend that for every assignment to @xmath313 there exists an assignment to @xmath314 such that the two satisfy @xmath315 .",
    "let @xmath725 be an assignment for @xmath313 and let @xmath2 be a consistent subinstance of @xmath1 that consists of the facts @xmath704 for @xmath738 and @xmath739 where @xmath740 .",
    "since @xmath716 is the only g - repair , it holds that @xmath2 has a global improvement .",
    "let us denote such a global improvement by @xmath5 .",
    "assume , without loss of generality , that @xmath5 is maximal ( if not , we can extend @xmath5 with additional facts ) .",
    "by @xmath110 s definition , @xmath5 must consist of facts of the form @xmath741 .",
    "since the fd @xmath527 is in @xmath531 , for each fact @xmath116 , it holds that @xmath532=1 $ ] . since @xmath5 is maximal and",
    "since @xmath742 is in @xmath531 , we have that @xmath5 encodes an assignment @xmath524 for @xmath313 and @xmath314 .",
    "this assignment is given by @xmath743 since @xmath5 is a global improvement of @xmath2 , it must contain the fact @xmath744 whenever @xmath745 is in @xmath2 ( this is true since no other fact has a priority over @xmath745 ) .",
    "therefore @xmath524 extends @xmath725 .",
    "finally we observe that every @xmath504 is satisfied by @xmath524 . a satisfying literal is one that corresponds to a fact @xmath741 that satisfies @xmath746 .",
    "we conclude that @xmath315 is a `` yes '' instance as claimed .",
    "recall the schema @xmath747 where @xmath23 consists of a single ternary relation @xmath239 and @xmath748 .",
    "we define a fact - wise reduction @xmath749 , using the constants @xmath750 .",
    "let @xmath751 .",
    "we define @xmath752 by @xmath753 where for all @xmath546 @xmath754 it is left to show that @xmath208 is a fact - wise reduction .",
    "to do so , we prove that @xmath208 is well defined , is injective and preserves consistency and inconsistency .",
    "it suffices to show that each @xmath755 is well - defined .",
    "we show that the sets in the definition of @xmath755 are pairwise disjoint .",
    "indeed , @xmath41 is disjoint from the sets @xmath756 , @xmath757 and @xmath758 .",
    "moreover , @xmath564 is a subset of @xmath42 and therefore it is disjoint from @xmath757 and @xmath758 .",
    "clearly , @xmath757 and @xmath758 are disjoint .",
    "hence , each @xmath755 is well - defined .",
    "let @xmath759 where @xmath760 and @xmath761 .",
    "assume that @xmath762 .",
    "let us denote @xmath763 and @xmath764 .",
    "note that @xmath756 is not empty since the fd @xmath44 is nontrivial .",
    "moreover , @xmath765 and @xmath758 are not empty since each of @xmath319 and @xmath320 contains an attribute that is in none of the other three sets",
    ". therefore , there are @xmath97 , @xmath98 and @xmath578 such that @xmath550 , @xmath766 and @xmath767 .",
    "hence , @xmath762 implies that @xmath576 , @xmath768 and @xmath769 .",
    "therefore we obtain @xmath555 , @xmath593 and @xmath770 which implies @xmath605 .",
    "assume @xmath398 is consistent w.r.t @xmath531 . we prove that @xmath552 is consistent w.r.t @xmath9 .",
    "note that @xmath569 and @xmath570 agree on @xmath41 since for each @xmath771 we have that @xmath772 , regardless of the input . since @xmath398 is consistent",
    "w.r.t @xmath531 , it holds that @xmath555 . by the definition of @xmath208 and since @xmath555 , we have that @xmath569 and @xmath570 agree on @xmath42 .",
    "hence , @xmath552 satisfies the constraint @xmath44 .",
    "assume that @xmath569 and @xmath570 agree on @xmath319 . by the definition of @xmath208 ,",
    "since @xmath773 is not empty , it holds that @xmath593 . since @xmath398 is consistent w.r.t @xmath531 , the fact that @xmath593 implies that also @xmath770 ( due to the constraint @xmath317 ) .",
    "hence , @xmath557 .",
    "this implies and that @xmath774 is consistent w.r.t @xmath9 .",
    "* @xmath49 and @xmath397 do not agree on @xmath37 .",
    "it holds , by @xmath208 s definition , that @xmath569 and @xmath570 agree on @xmath41 . nevertheless ,",
    "since @xmath49 and @xmath397 do not agree on @xmath37 , we have that @xmath561 .",
    "hence @xmath569 and @xmath570 do agree on @xmath42 .",
    "that is , the constraint @xmath44 is not satisfied , which leads us to the conclusion that @xmath552 is inconsistent w.r.t @xmath9 . *",
    "@xmath49 and @xmath397 agree on @xmath37 .",
    "since @xmath398 is inconsistent w.r.t @xmath531 , we have that @xmath49 and @xmath397 agree on @xmath38 ( i.e. , @xmath593 ) but disagree on @xmath14 ( i.e. , @xmath770 ) .",
    "note that @xmath569 and @xmath570 agree on @xmath319 since @xmath555 and @xmath556 .",
    "nevertheless , they do not agree on @xmath320 since @xmath775 and the set @xmath776 is not empty .",
    "that is , the constraint @xmath318 is not satisfied which leads us to the conclusion that @xmath552 is inconsistent w.r.t @xmath9 ."
  ],
  "abstract_text": [
    "<S> in its traditional definition , a repair of an inconsistent database is a consistent database that differs from the inconsistent one in a `` minimal way . '' </S>",
    "<S> often , repairs are not equally legitimate , as it is desired to prefer one over another ; for example , one fact is regarded more reliable than another , or a more recent fact should be preferred to an earlier one . </S>",
    "<S> motivated by these considerations , researchers have introduced and investigated the framework of preferred repairs , in the context of denial constraints and subset repairs . there , a priority relation between facts is lifted towards a priority relation between consistent databases , and repairs are restricted to the ones that are optimal in the lifted sense . </S>",
    "<S> three notions of lifting ( and optimal repairs ) have been proposed : pareto , global , and completion .    in this paper </S>",
    "<S> we investigate the complexity of deciding whether the priority relation suffices to clean the database unambiguously , or in other words , whether there is exactly one optimal repair . </S>",
    "<S> we show that the different lifting semantics entail highly different complexities . under pareto </S>",
    "<S> optimality , the problem is conp - complete , in data complexity , for every set of functional dependencies ( fds ) , except for the tractable case of ( equivalence to ) one fd per relation . under global optimality , one fd per relation is still tractable , but we establish @xmath0-completeness for a relation with two fds . </S>",
    "<S> in contrast , under completion optimality the problem is solvable in polynomial time for every set of fds . in fact , we present a polynomial - time algorithm for arbitrary conflict hypergraphs . </S>",
    "<S> we further show that under a general assumption of transitivity , this algorithm solves the problem even for global optimality . </S>",
    "<S> the algorithm is extremely simple , but its proof of correctness is quite intricate . </S>"
  ]
}