{
  "article_text": [
    "k.f . is supported by kakenhi no.16h02211 , presto , jst , crest , jst and erato , jst .",
    "mh is partially supported by fund for the promotion of joint international research ( fostering joint international research ) no .",
    "the centre for quantum technologies is funded by the singapore ministry of education and the national research foundation as part of the research centres of excellence programme .",
    "he is also grateful to dr .",
    "michal hajdusek for helpful comments .",
    "the error detection on the black vacuum qubits ( edges of the primal cubic lattice ) is executed as follows .",
    "if there is no error on the graph state , the outcome @xmath109 of the @xmath24-basis measurements satisfies the condition : @xmath110 where @xmath111 indicates an addition modulo two over all black qubits adjacent to the vertex @xmath112 . depending on a given error @xmath113 ( @xmath114 ) on the graph state",
    ", we can obtain the error syndrome @xmath115 at the vertices belonging to the defect region . from the error syndrome ,",
    "the most likely location of the errors is estimated . here",
    "we employ the minimum distance decoding , which can be done by finding a minimum path connecting pairs of vetices of @xmath116 with the minimum - weight - perfect - matching ( mwpm ) algorithm  @xcite .",
    "let @xmath117 be the estimated error location , where @xmath118 indicates the number of 1s in a bit string @xmath119 .",
    "if a chain of edges specified by @xmath120 have a nontrivial cycle in the sense of the relative homology  @xcite , the error correction fails . at the defect region",
    "far from the singular qubits , a nontrivial cycle have at least length @xmath88 , which is the characteristic length of the defect determined from the required accuracy of quantum computation .",
    "let @xmath92 be the size of the quantum computation that alice wants to do fault - tolerantly . to guarantee the accuracy of the output ,",
    "it is enough to choose the distance @xmath121 .",
    "therefore , the number of the qubits of the graph state is @xmath122 .",
    "now we can define the correctable set of errors as follow : an error location @xmath123 belongs to the correctable set @xmath124 of the errors iff there exists a connected component of length @xmath88 in the chain of edges specified by @xmath120 .",
    "the error detection and definition of the correctable error set @xmath125 on the white vacuum qubits are done in the same way but on the dual lattice .    from the test @xmath78 , we know the error location @xmath123 .",
    "since the mwpm algorithm works in polynomial time in the number of vertices with @xmath126 , we can decide whether or not @xmath123 belongs to the correctable error set @xmath127 .",
    "the same argument also holds for the error location @xmath87 on the white vacuum qubits tested by @xmath79 .",
    "therefore , we can efficiently check whether or not the errors on a given resource belong to @xmath128 .",
    "we here , for simplicity , do not employ magic state distillaion  @xcite but encodes each logical qubit into the reed - muller 15-qubit code .",
    "then we perform a fault - tolerant logical @xmath83-basis measurement by transversal physical @xmath83-basis measurements on the singular qubits as done in ref  @xcite .",
    "thereby , alice can fix her strategy of quantum computation , which makes easy to define the correctable set of errors for the test .",
    "let @xmath129 and @xmath104 be the number of concatenation levels and the number of the logical @xmath94-basis measurements , respectively .",
    "then we need @xmath130 physical @xmath83-basis measurements , on the singular qubits .",
    "note that @xmath131 is enough to reduce the logical error sufficiently . in the following , we the error on the graph state",
    "is specified by @xmath132 by converting it into @xmath23 operators on the graph state , @xmath133 .",
    "the logical @xmath83-basis measurement is done by physical transversal @xmath83-basis measurements by encoding each qubit into a concatenated reed - muller 15-qubit codes  @xcite .",
    "this is also the case for all pauli - basis measurements . in the vacuum region near the singular qubits",
    ", we have a logical error of length smaller than @xmath88 as shown in fig .",
    "[ fig2 ] , since they are not topologically protected .",
    "correctable error for the fault - tolerant logical @xmath83-basis measurement is defined for a given error @xmath134 recursively as follows : at physical level , which we call level-@xmath135 , if @xmath136 or @xmath137 becomes a logical error for a singular qubit , the level-@xmath135 ( singular ) qubit is labeled to be faulty . at @xmath138th concatenation level , if the level-@xmath138 logical qubit consisting of 15 level-@xmath139 logical qubits encoded in the reed - muller 15-qubit code has two or more faulty level-@xmath139 logical qubits , the level-@xmath138 logical qubit is labeled to be faulty . at the highest level @xmath140",
    ", if no level-@xmath129 logical qubit is faulty , the given error @xmath141 belongs to the correctable set @xmath142 .",
    "and estimated one @xmath143 are denoted by solid and dotted lines , respectively . the vertices ( error syndrome ) of @xmath126",
    "are denoted by red squares .",
    "the 3d lattice(spatial two dimensions and time - like one dimension ) is depicted as if it is two dimensional ( one dimension for both spatial and time - like axe ) .",
    ", width=188 ]    let us first consider the pass probability of the test for topological protection .",
    "the error @xmath123 is rejected if @xmath136 contains a connected component of length at least @xmath88 .",
    "such a probability is calculated  @xcite to be @xmath144 therefore , if @xmath99 is sufficiently smaller than a constant value , the rejection probability is exponentially suppressed .",
    "next we consider the test for the logical @xmath83-basis measurement .",
    "let @xmath145 be the probability that a level-0 ( singular ) qubit is faulty .",
    "@xmath146 is evaluated in a similar way to the previous case for the topological protection but we have to count logical errors consist of the chains of length lower than @xmath88 : @xmath147 where @xmath148 is the number of chains of length @xmath149 that contribute to the logical error of length @xmath149 .",
    "@xmath148 is counted in ref .",
    "@xcite rigorously up to @xmath150 , which indicates that we can reduce @xmath145 by decreasing @xmath99 sufficiently .",
    "the probability @xmath151 of obtaining the level-@xmath138 faulty qubit is given recursively by @xmath152 the we obtain @xmath153 the probability to obtain no faulty level-@xmath129 logical qubit at the highest level is given by @xmath154 .      since @xmath104 , it is sufficient to chose @xmath157 and @xmath158 , which are independent of @xmath41 , the number of the samples of the graph state",
    ". therefore , in the large @xmath88 limit for a given @xmath92 , we can reduce the logical error probability polynomially , and hence amplify the acceptance probability @xmath159 arbitrarily close to 1 ."
  ],
  "abstract_text": [
    "<S> quantum systems , in general , output data that can not be simulated efficiently by a classical computer , and hence is useful for solving certain mathematical problems and simulating quantum many - body systems . </S>",
    "<S> this also implies , unfortunately , that verification of the output of the quantum systems is not so trivial , since predicting the output is exponentially hard . as another problem , </S>",
    "<S> quantum system is very delicate for noise and thus needs error correction . </S>",
    "<S> here we propose a framework for verification of the output of fault - tolerant quantum computation in the measurement - based model . </S>",
    "<S> contrast to existing analyses on fault - tolerance , we do not assume any noise model on the resource state , but an arbitrary resource state is tested by using only single - qubit measurements to verify whether the output of measurement - based quantum computation on it is correct or not . </S>",
    "<S> the overhead for verification including classical processing is linear in the size of quantum computation . since </S>",
    "<S> full characterization of quantum noise is exponentially hard for large - scale quantum computing systems , our framework provides an efficient way of practical verification of experimental quantum error correction . </S>",
    "<S> moreover , the proposed verification scheme is also compatible to measurement - only blind quantum computation , where a client can accept the delegated quantum computation even when a quantum sever makes deviation , as long as the output is correct .    _ </S>",
    "<S> introduction. _ quantum computation provides a new paradigm of information processing offering both fast and secure information processing , which could not be realized in classical computation  @xcite . </S>",
    "<S> recently , a lot of experimental efforts have been paid to realize quantum computation  @xcite . there , </S>",
    "<S> fault - tolerant quantum computation with quantum error correction  @xcite is inevitable to obtain quantum advantage using noisy quantum devices .    due to the recent rapid progresses on experimental quantum error correction techniques  </S>",
    "<S> @xcite , there is an increasing demand on an efficient way of a performance analysis of fault - tolerant quantum computation . in particular , in the majority of performance analyses of fault - tolerant quantum computation , a specific noise model , such as independent and identical pauli error operation and some specific correlation models , is assumed apriori  @xcite . </S>",
    "<S> however , in an actual experiments more general noise occurs including general trace preserving completely positive ( tp - cp ) maps with various correlation between qubits . </S>",
    "<S> further , to guarantee the correctness of the output of quantum computation , we need to care about all cases including unexpected types of errors . , i.e.,we should not assume any specific error model . </S>",
    "<S> also , in our scenario , the full tomographic approach would not work efficiently for the increasingly many qubits . </S>",
    "<S> unfortunately , existing fault - tolerant quantum computations have not equipped an efficient verification scheme yet .    </S>",
    "<S> the aim of this paper is to develop a fault - tolerant quantum computation equipping a verification scheme without assuming the underlying noise model . as properties of verifiable fault - tolerance , we require following two conditions . </S>",
    "<S> one is _ </S>",
    "<S> detectability _ which means that if the error of a quantum computer is not correctable , such a faulty output of the quantum computation is detected with high probability . </S>",
    "<S> the other is _ acceptability _ which means that an appropriately constructed quantum computer can pass the verification with high probability . </S>",
    "<S> in other words , under a realistic noise model , the test accepts the quantum computation with high probability . </S>",
    "<S> both properties are important to characterize performance of test in statistical hypothesis testing  @xcite .    in this paper , we develop verifiable fault - tolerance in measurement - based quantum computation ( mbqc )  @xcite , which satisfies both detectability and acceptability . </S>",
    "<S> we take a rather different approach to fault - tolerance than conventional one . </S>",
    "<S> we do not assume any noise model underlying , but define a correctable set of errors on a resource state of mbqc and test whether the error on a given resource state belongs to such a set or not . </S>",
    "<S> to this end , we employ the stabilizer test proposed in ref .  </S>",
    "<S> @xcite , where an efficient verification of mbqc can be carried out by testing the graph state . however , this method is not fault - tolerant lacking acceptability ; any small amount of noise on the graph state causes rejection regardless whether or not it is correctable . </S>",
    "<S> although the paper @xcite extended the stabilizer test to the self - testing for the measurement basis , it still has the same problem . </S>",
    "<S> therefore , we crucially extend the stabilizer test  @xcite for a noisy situation , so that we can decide whether the given resource states belong to a set of fault - tolerant resource states or not . under the condition of a successful pass of the test , the accuracy of fault - tolerant mbqc is guaranteed to be arbitrarily high ( i.e. , contraposition of detectability ) . </S>",
    "<S> the total resource required for the verification is linear to the size of quantum computation . as a concrete example </S>",
    "<S> , we explicitly define a set of correctable errors on the resource state for topologically protected mbqc  @xcite , where we can show acceptability by calculating the acceptance probability concretely under a realistic noise model .    </S>",
    "<S> note that contrast to detectability , the requirement of acceptability is unique for the verification of fault - tolerant quantum computation . indeed , when we can expect no error like the previous case @xcite </S>",
    "<S> , we do not need fault - tolerance . </S>",
    "<S> so , we could correctly judge the no error case with probability @xmath0 , i.e. , acceptability of the test is trivially satisfied because the stabilizer test would be passed in the no error case . </S>",
    "<S> on the other hand , in verification of fault - tolerant quantum computation consisting of many elementary parts , each of which can not be checked directly , we have to judge whether the output of the computation is correct or not carefully under an expected error model , which imposes the second requirement , acceptability . </S>",
    "<S> that is , to discuss acceptability , we firstly fix our verification method and an expected error model . </S>",
    "<S> then , we calculate the acceptance probability , which corresponds to power of test in statistical hypothesis testing @xcite .    </S>",
    "<S> we also discuss an application of verifiable fault - tolerance to verification of blind quantum computation  @xcite under a quantum server s deviation or quantum channel noise .    _ a general setup for fault - tolerant mbqc. _ </S>",
    "<S> let us consider a generic scenario of fault - tolerant mbqc on a two - colorable graph state composed of the black system @xmath1 and the white system @xmath2 , which are consist of @xmath3 and @xmath4 qubits , respectively . </S>",
    "<S> then , we have two kinds of operators @xmath5 , @xmath6 , on @xmath7 , where @xmath8 . </S>",
    "<S> when we restrict them to the black system @xmath1 ( the white system @xmath2 ) , we denote @xmath9 and @xmath10 by @xmath11 and @xmath12 ( @xmath13 and @xmath14 ) . by using the binary - valued adjacency matrix @xmath15 ( i.e. </S>",
    "<S> , @xmath16 element is @xmath0 iff vertices @xmath17 and @xmath18 are connected ) corresponding to the graph , the graph state @xmath19 is characterized as @xmath20 for @xmath21 and @xmath22 . </S>",
    "<S> this relation explains that any error on the @xmath23-basis can be converted to an error on the @xmath24-basis . </S>",
    "<S> then , the total space @xmath25 is spanned by @xmath26 . </S>",
    "<S> suppose we execute a fault - tolerant mbqc quantum computation on the two - colorable graph state . </S>",
    "<S> then a set of correctable errors on the two - colorable graph state is defined such that an ideal state @xmath19 and erroneous one @xmath27 result in the same computational outcome under error correction . </S>",
    "<S> such a set of errors can is specified as a subset @xmath28 of @xmath29 . </S>",
    "<S> the projection to the subspace is written by @xmath30 . </S>",
    "<S> we assume that the subset @xmath28 is written as @xmath31 by using two subsets @xmath32 and @xmath33 .    _ </S>",
    "<S> test for verification of fault - tolerance. _        similar to ref .  </S>",
    "<S> @xcite , we employ the following sampling protocol to verify whether the error is correctable . </S>",
    "<S> our protocol runs as follows :    * honest bob generates @xmath34 , where @xmath19 is an @xmath35-qubit graph state on a bipartite graph @xmath36 , whose vertices are divided into two disjoint sets @xmath37 and @xmath38 . </S>",
    "<S> ( see fig .  </S>",
    "<S> [ fig1](a ) . ) </S>",
    "<S> bob sends each qubit of it one by one to alice . </S>",
    "<S> evil bob can generate any @xmath39-qubit state @xmath40 instead of @xmath34 . </S>",
    "<S> * alice divides @xmath41 blocks of @xmath35 qubits into three groups by random choice . </S>",
    "<S> the first group consists of @xmath42 blocks of @xmath35 qubits each . </S>",
    "<S> the second group consists of @xmath42 blocks of @xmath35 qubits each . </S>",
    "<S> the third group consists of a single block of @xmath35 qubits . * </S>",
    "<S> alice uses the third group for her computation . </S>",
    "<S> other blocks are used for the test , which will be explained later . * </S>",
    "<S> if alice passes the test , she accepts the result of the computation performed on the third group .    for each block of the first and second groups </S>",
    "<S> , alice performs the following test :    * for each block of the first group , alice measures qubits of @xmath37 in the @xmath23 basis and qubits of @xmath38 in the @xmath24 basis . </S>",
    "<S> then , she obtain @xmath43 and @xmath44 . if @xmath45 , then the test is passed . </S>",
    "<S> * for each block of the second group , alice measures qubits of @xmath38 in the @xmath23 basis and qubits of @xmath37 in the @xmath24 basis . </S>",
    "<S> then , she obtain @xmath46 and @xmath47 . if @xmath48 , then the test is passed .    </S>",
    "<S> _ detectability and acceptability. _ to show detectability , taking account into unexpected errors , we obtain the following theorem in the same way as @xcite :    [ l1 ] assume that @xmath49 . </S>",
    "<S> if the test is passed , with significance level @xmath50 , we can guarantee that the resultant state @xmath51 of the third group satisfies @xmath52    ( note that the significance level is the maximum passing probability when bob erroneously generates incorrect states so that the resultant state @xmath51 does not satisfy  @xcite . </S>",
    "<S> that is , @xmath53 expresses the minimum probability to detect such incorrect states . ) </S>",
    "<S> the previous study @xcite considers the case with @xmath54 , @xmath55 , and proves this special case by discussing the two kinds of binary events @xmath56 or @xmath57 and @xmath58 or @xmath57 . replacing these two events by the two kinds of events @xmath59 or @xmath60 and @xmath61 or @xmath62 in the proof given in @xcite </S>",
    "<S> , we can show theorem 1 with the current general form .    from the theorem and the relation between the fidelity and trace norm ( * ? ? ? * ( 6.106 ) ) , we can conclude the verifiability : if alice passes the test , she can guarantee that @xmath63 for any povm @xmath64 with the significance level @xmath50 . </S>",
    "<S> that is , the property of fault - tolerant quantum computation guarantees that the probability that the obtained computation outcome is different from the true computation outcome is less than @xmath65 . </S>",
    "<S> if we take @xmath66 , for example , this error probability is @xmath67 if @xmath68 , and therefore the verifiability is satisfied . </S>",
    "<S> note that the lower bound , @xmath69 , of the significance level @xmath50 is tight , since if bob generates @xmath70 copies of the correct state @xmath71 and a single copy of a wrong state , bob can fool alice with probability @xmath72 , which corresponds to @xmath73 . </S>",
    "<S> note that the above theorem on detectability holds without any assumption on the underlying noise . </S>",
    "<S> note that noise in the measurements can also be taken as noise on the resource state , if it does not depnd on the measurement bases . even if it is not the case , we can add noise such that the amounts of noise are the same for all measurement bases .    </S>",
    "<S> next , we consider acceptability . to address the success probability under a realistic noise model , we assume a specific application of pauli channel on @xmath25 as an expected error model . that is , the error given as the distribution @xmath74 on the set @xmath75 of @xmath24-basis errors and @xmath23-basis errors . then , we denote the marginal distribution with respect to the pair of @xmath24-basis errors on @xmath38 and @xmath23-basis errors on @xmath37 ( @xmath23-basis errors on @xmath38 and @xmath24-basis errors on @xmath37 ) by @xmath76 ( @xmath77 ) . </S>",
    "<S> hence , the probability that alice passes the test @xmath78 ( @xmath79 ) with one round is @xmath80 ( @xmath81 ) . </S>",
    "<S> since we apply them @xmath70 rounds , the probability to be passed is @xmath82 . </S>",
    "<S> hence , when the probabilities @xmath80 and @xmath81 are close to @xmath0 , alice can accept the correct computation result on the third group with high probability .    </S>",
    "<S> _ verifiable fault - tolerance for topologically protected mbqc. _ to show acceptability , below we will explain how to define a correctable set of the errors on a graph state . </S>",
    "<S> then , for a concrete example , we will calculate the acceptance probability @xmath82 under a realistic noise model .    </S>",
    "<S> in the theory of fault - tolerant quantum computation , it is conventional that we translate fault - tolerance in the circuit model into fault - tolerance in the measurement - based model  @xcite as follows . in the circuit model , we can define a set of correctable ( sparse ) fault paths so that the output of quantum computation does not damaged even if any error occurs on such a fault path  @xcite . then , translating the correctable ( sparse ) fault paths in the circuit model into the measurement - based model , we can define a correctable set of the errors on the graph state in general . for example , the schemes in refs  @xcite and refs  @xcite can be viewed as measurement - based versions of circuit - based fault - tolerant schemes using the concatenated steane 7-qubit code  @xcite and the surface code with the concatenated reed - muller 15-qubit code  @xcite , respectively .    </S>",
    "<S> -basis . </S>",
    "<S> singular qubits are located in - between two defect regions , which are measured in the @xmath83-basis for a transversal logical @xmath83-basis measurement . </S>",
    "<S> other regions are vacuum , where qubits are measured in the @xmath24-basis to obtain the error syndrome . , </S>",
    "<S> width=245 ]    let us see a concrete example by using topologically protected mbqc  @xcite , which has been employed as a standard framework for fault - tolerant mbqc recently  @xcite . </S>",
    "<S> here we focus on the original scheme proposed in ref .  </S>",
    "<S> @xcite , where the surface code and the concatenated reed - muller code are employed to perform two - qubit clifford gate and single - qubit non - pauli - basis measurements , respectively . in the following we will briefly sketch how the correctable set are defined . a detailed description is shown in appendix  [ app1 ] .    in the following , </S>",
    "<S> we characterize the correctable sets of errors @xmath84 and @xmath85 . </S>",
    "<S> the errors specified by the set @xmath84 , which correspond to @xmath24 basis ( the pauli-@xmath23 operator ) on black qubits and @xmath23 basis ( the pauli-@xmath24 operator ) on white qubits , are detected on the priaml cubic lattice consisting of the edges on which the black qubits are located as shown in fig .  </S>",
    "<S> [ fig1](b ) . </S>",
    "<S> then , the error configuraion @xmath86 can be associated with a set of edges on the primal cubic lattice . </S>",
    "<S> similarly , the errors in the set @xmath85 is detected on the dual cubic lattice and the error configuration @xmath87 is associated with a set of edges on the dual cubic lattice . in the following , </S>",
    "<S> all arguments are made independently of black ( primal lattice ) and white ( dual lattice ) qubits .    depending on quantum computation that alice wants to do fault - tolerantly , </S>",
    "<S> a measurement pattern is determined . </S>",
    "<S> specifically , from an analogy of topological quantum computation  @xcite , the sets of qubits measured in @xmath24 , @xmath23 , and @xmath83-bases  @xcite are called defect , vacuum , and singular qubits , respectively . as shown in fig .  </S>",
    "<S> [ fig2 ] , defect qubits shape tubes , which represent logical degrees of freedom ; at each time slice they corresponds to the surface code with defects . by braiding the defects , </S>",
    "<S> a clifford two - qubit gate can be performed . for the surface code </S>",
    "<S> , the minimum distance decoding can be done by finding a shortest path connecting the boundary of the error chain on the cubic lattice . </S>",
    "<S> then , if the minimum distance decoding results in a logical operator of a weight ( distance ) larger than the code distance @xmath88 by wrapping around a defect or connecting two different defects , such an error is uncorrectable ( see appendix  [ app1 ] for the detail ) . </S>",
    "<S> accordingly , we can define @xmath89 for @xmath90 as the complement of them . </S>",
    "<S> the code distance @xmath88 is chosen to be @xmath91 with @xmath92 being the size of the quantum computation that alice wants to do fault - tolerantly . </S>",
    "<S> therefore , the number of qubits of the graph state is given by @xmath93 .    </S>",
    "<S> around the singular qubits , we still have a logical error of a weight lower than @xmath88 as shown in fig .  </S>",
    "<S> [ fig2 ] . </S>",
    "<S> such a logical error is corrected by using another code , the concatenated reed - muller code . to this end , </S>",
    "<S> the fault - tolerant clifford gates using the surface code are further employed to encode the logical qubits into concatenated reed - muller codes , on which we can implement all pauli - bases and @xmath94-basis measurements transversally . </S>",
    "<S> the corresponding physical @xmath94-basis measurements , i.e. , measurements on the singular qubits , are depicted by red circles in fig .  </S>",
    "<S> [ fig2 ] . </S>",
    "<S> then we can define the correctable set @xmath95 of the errors for the concatenated reed - muller code recursively for @xmath90 as done in ref .  </S>",
    "<S> @xcite ( see appendix  [ app2 ] for the detail ) .    </S>",
    "<S> since we employ two types of error correction codes as seen above , the correctable set of the errors are defined as an intersection of the correctable sets @xmath89 and @xmath95 for the surface code and the concatenated reed - muller code , respectively , for both colors @xmath90 . </S>",
    "<S> since both minimum distance decoding for the surface code and recursive decoding for the concatenated code can be done efficiently , we can efficiently decide whether a given error pattern @xmath96 ( @xmath97 ) are in @xmath84 ( @xmath85 ) or not .    </S>",
    "<S> _ acceptance probability under a typical error model. _ to calculate the acceptance probability , we assume , for simplicity , the errors @xmath10 ( @xmath98 ) are distributed independently and identically for each qubit with probability @xmath99 . </S>",
    "<S> it is straightforward to generalize the following argument to any local cptp noise as long as the noise strength measured by the diamond norm is sufficiently smaller than a certain threshold value  @xcite . </S>",
    "<S> then the standard counting argument of the self - avoiding walk for the surface code  @xcite tells us that @xmath100 for @xmath90 . </S>",
    "<S> apparently , if @xmath99 is sufficiently smaller than a certain constant value , @xmath101 converges to 1 for @xmath90 . by considering a recursive decoding of the concatenated code , </S>",
    "<S> we obtain @xmath102^m,\\end{aligned}\\ ] ] for @xmath90 where @xmath103 is a logical error probability of a weight lower than @xmath88 , which occurs around the singular qubits . </S>",
    "<S> such a logical probability is also calculated as a function of the physical error probaility @xmath99 by counting the number of self - avoiding walk  @xcite as show in appendix  [ app3 ] eq .  </S>",
    "<S> ( [ saw ] ) . </S>",
    "<S> the integer @xmath104 and @xmath105 are the numbers of the logical @xmath94-basis measurements and the number of concatenation , respectively . again by using counting the number of self - avoiding walks  @xcite we can evaluate @xmath103 . by choosing @xmath99 smaller than a certain constant value </S>",
    "<S> , @xmath103 becomes sufficiently small so that @xmath106 converges to 1 for @xmath90 . </S>",
    "<S> since @xmath107 for @xmath90 , the probability @xmath108 also converges to 1 exponentially in the large @xmath88 limit , if the physical error probability @xmath99 is smaller than a certain constant threshold value ( see appendix  [ app3 ] for the detailed calculation ) . since </S>",
    "<S> @xmath88 can be chosen independently of @xmath42 , the acceptance probability @xmath82 converges to 1 .    </S>",
    "<S> _ verifiable blind quantum computation. _ a promising application of the proposed framework is verification of measurement - only blind quantum computation  @xcite . </S>",
    "<S> suppose a quantum server generates two - colorable graph states and sends them to a client who execute universal quantum computation by only single - qubit measurements , where client employ the proposed verification . </S>",
    "<S> first , our protocol is a one - way quantum communication from bob to alice , and therefore , the blindness is guaranteed by the no - signaling principle as in the protocol of ref .  </S>",
    "<S> @xcite , which contrasts to verifiable blind quantum computation  @xcite of bfk ( broadbent - fitzsimons - kashefi ) type  @xcite . </S>",
    "<S> according to theorem  [ l1 ] ( detectability ) under the condition of acceptance the accuracy of the output is guaranteed . </S>",
    "<S> contrast to the earlier verifiable blind quantum computation  @xcite , by virtue of acceptability , the proposed verification scheme can accept the delegated quantum computation even under quantum server s deviation or quantum channel noise as long as they are correctable . in this way , we can verify the quantum server is honest enough to obtain a correct output by only using single - qubit measurements . </S>",
    "<S> it would be interesting to apply the proposed framework to quantum interactive proof systems  @xcite . </S>"
  ]
}