{
  "article_text": [
    "in the planning process for many network infrastructures , when the network is constructed over a significant period of time , the properties of the intermediate partial networks have to be taken into account . _ incremental network design _ , introduced in @xcite , represents a class of optimization problems capturing that feature and combining two types of decisions : which arcs should be added to a given network in order to achieve a certain goal , and when should these arcs be added ?",
    "variants of this problem have been studied in diverse contexts , for instance , the design of transportation networks  @xcite , network infrastructure restoration after disruptions due to natural disasters  @xcite , and the transformation of an electrical power grid into a smart grid  @xcite .",
    "a general class of mathematical optimization problems that captures essential features of the described decision problems , and includes the problem discussed in this paper as a special case , was introduced in  @xcite , where an _ integrated network design and scheduling _",
    "problem is specified by ( 1 ) a scheduling environment that describes the available resources for adding arcs to the network , ( 2 ) a performance measure , which prescribes how a given network is evaluated ( for instance by the shortest @xmath0-@xmath1 path or by the maximum @xmath0-@xmath1 flow in the network ) , and ( 3 ) by the optimization goal , which is either to reach a certain level of performance as quickly as possible or to optimize the cumulative performance over the entire planning horizon .",
    "we focus on the special case corresponding to incremental network design as introduced in  @xcite .",
    "our scheduling environment is such that at most one arc can be added to the network in each time period , and we optimize the cumulative performance , i.e. , the sum of the performance measures of the networks in all time periods . even in this simple setting , the problem has been shown to be np - complete for classical network optimization problems : for the shortest @xmath0-@xmath1 path problem in  @xcite , and for the maximum @xmath0-@xmath1 flow problem in  @xcite .",
    "interestingly , the incremental variant of the minimum spanning tree problem can be solved efficiently by a greedy algorithm  @xcite , while it becomes np - complete in the more general setup of  @xcite .",
    "the performance measure considered in this paper is the value of a maximum @xmath0-@xmath1 flow .    in section  [ sec : problem ] , we introduce notation , state the problem precisely , and present two mip formulations . in section  [ sec : heuristics ] , we describe three heuristics , the first one seeks to increment the flow as quickly as possible , the second seeks to reach a maximum flow as quickly as possible , and the third one is a hybrid of the first two . in section  [ sec : unit_capacity ] , we prove performance guarantees for the first two heuristics in special cases : for unit capacity networks they provide a 2-approximation algorithm and a @xmath2-approximation algorithm , respectively , and these bounds can be strengthened when the network has a special structure .",
    "section  [ sec : computations ] discusses the results of a set of computational experiments using randomly generated instances . after describing the instance generation",
    ", we compare the performance of the two mip formulations , and evaluate and compare the heuristics on hard instances .",
    "we end , in section  [ sec : final ] , with some final remarks .",
    "we are given a network @xmath3 with node set @xmath4 and arc set @xmath5 , where @xmath6 contains existing arcs and @xmath7 contains potential arcs , as well as a source @xmath8 and sink @xmath9 .",
    "for each arc , we are given an integer capacity @xmath10 , and for every node @xmath11 , we denote with @xmath12 and @xmath13 the set of arcs entering @xmath14 and the set of arcs leaving @xmath14 , respectively .",
    "let @xmath15 be the length of the planning horizon .",
    "in every period , we have the option to expand the useable network , which initially consists of only the existing arcs , by `` building '' a single potential arc @xmath16 , which will be available for use in the following time period . in every period ,",
    "the value of a maximum @xmath0-@xmath1 flow is recorded ( using only useable arcs , i.e. , existing arcs and potential arcs that have been built in previous periods ) .",
    "the objective is to maximize the total flow over the planning horizon .",
    "note that the length of the planning horizon ensures that every potential arc can be built .",
    "we refer to a maximum @xmath0-@xmath1 flow using only existing arcs as an _ initial maximum flow _ , and to a maximum flow for the complete network as an _ ultimate maximum flow_. this problem is strongly np - hard  @xcite even when restricted to instances where every existing arc has capacity @xmath17 and every potential arc has capacity @xmath18 .",
    "( a simple proof of this result can be found in the appendix . )",
    "the problem can be formulated as a mixed integer program . for every @xmath19 and @xmath20",
    ", we have a flow variable @xmath21 , and for every @xmath16 and @xmath20 , we have a binary variable @xmath22 which indicates if arc @xmath23 is built before period @xmath24 ( @xmath25 ) or not ( @xmath26 ) . the incremental maximum flow problem is then @xmath27 subject to @xmath28 we denote this formulation by imfp@xmath29 .",
    "a potential weakness of imfp@xmath29 is that it may suffer from symmetry . if multiple arcs need to be build to increase the maximum @xmath0-@xmath1 flow , then the order in which these arcs are build does not matter , which introduces alternative , symmetrical solutions .",
    "next , we present an alternative mip formulation which avoids this difficulty .",
    "let @xmath30 and @xmath31 denote the initial and the ultimate maximum flow value , respectively , and let @xmath32 .",
    "we introduce binary variables @xmath22 for @xmath33 and @xmath34 with the interpretation @xmath35 the number of time periods with maximum flow value @xmath30 is @xmath36 , and for @xmath37 , the number of time periods with maximum flow value @xmath38 is @xmath39 .",
    "consequently , the total flow is @xmath40 = tf - \\sum_{a\\in a_p } \\sum_{k=1}^r y_{ak}.\\end{gathered}\\ ] ] hence the incremental maximum flow problem can also be formulated as follows @xmath41 subject to @xmath42 we denote this formulation by imfp@xmath43 .",
    "observe that the size of imfp@xmath29 strongly depends on the length of the planning horizon , whereas the size of imfp@xmath43 strongly depends on the difference between the initial and ultimate maximum flow values .",
    "in this section , we introduce two natural strategies for trying to obtain high quality solutions : ( 1 ) getting a flow increment as quickly as possible , and ( 2 ) reaching a maximum possible flow as quickly as possible , as well as a hybrid strategy .      a natural greedy strategy is to build the arcs such that a flow increment is always reached as quickly as possible .",
    "suppose we have already built the arcs in @xmath44 to reach a maximum flow value @xmath38 .",
    "a smallest set of potential arcs to be built , in addition to @xmath45 , to reach a flow of value at least @xmath46 can be determined by solving a fixed charge network flow problem : find a flow of value @xmath46 where arcs in @xmath47 have zero cost , and arcs in @xmath48 incur a cost of 1 if they carry a nonzero flow .",
    "more formally , in order to determine the smallest number of potential arcs that have to be built to increase the flow from @xmath38 to at least @xmath46 , we solve the problem minarcs(@xmath49 ) : @xmath50 next , among all the possibilities that increase the flow by building the smallest possible number of potential arcs , we want to choose one that maximizes the flow increase . given the optimal value @xmath51 for the problem minarcs(@xmath49 ) , this can be achieved by solving another mip , denoted by maxval(@xmath52 ) : @xmath53    the greedy heuristic is described formally in algorithm  [ alg : greedy ] ( assuming the entire set @xmath7 is provided as input ) .",
    "@xmath54 with @xmath55 @xmath56 \\ { _ initialize the set of built arcs _ } @xmath57 \\ { _ index of initial flow value _ }    in general , this heuristic still requires the solution of mips minarcs(@xmath49 ) and maxval(@xmath52 ) , hence we do not get a polynomial bound on the runtime . but",
    "these mips are much smaller than imfp@xmath29 and imfp@xmath43 , so we might expect that they can be solved more efficiently .",
    "however , if the capacities of all potential arcs are equal to @xmath17 , then the problems minarcs(@xmath49 ) reduce to minimum cost flow problems , and their solutions are already optimal for maxval(@xmath52 ) , because the optimal flow increment is 1 .",
    "thus for these instances , the quickest increment heuristic runs in polynomial time .    furthermore ,",
    "if the maximization of the flow increment is omitted , then the heuristic can be implemented to run in polynomial time even for general capacities . for this purpose ,",
    "suppose we have already built the arcs in @xmath58 and we have a maximum flow @xmath59 of value @xmath38 for the network @xmath60 .",
    "using the residual network with respect to @xmath59 , we can apply a labeling procedure which computes for each node @xmath14 a triple @xmath61 , where    * @xmath62 is the minimum number of arcs in @xmath63 on any augmenting @xmath0-@xmath14-path , * @xmath64 is the maximum augmentation for any @xmath0-@xmath14-path using at most @xmath62 arcs from @xmath63 , and * @xmath65 is the predecessor of @xmath14 on an @xmath0-@xmath14-path which contains @xmath62 arcs from @xmath63 and can be augmented by @xmath64 units of flow .",
    "this can be done in time @xmath66 , for instance using bfs starting from @xmath0 , and the distance label @xmath67 equals the minimum size of a set @xmath68 with the property that the maximum @xmath0-@xmath1-flow value in the network @xmath69 is strictly larger than @xmath38 .",
    "furthermore , @xmath70 is such a set of size @xmath67 , where @xmath71 is the augmenting @xmath0-@xmath1-path corresponding to the result of the labeling procedure .",
    "suppose there is a set @xmath72 with @xmath73 such that the maximum flow in @xmath74 is strictly larger than @xmath38 .",
    "then the residual network for @xmath75 with respect to the flow @xmath59 of value @xmath76 must contain an augmenting path @xmath77 .",
    "now @xmath78 , thus @xmath77 is an augmenting @xmath0-@xmath1-path which contains less than @xmath67 arcs from @xmath63 , which contradicts the construction of @xmath67 . using this labeling procedure ,",
    "a quickest - increment heuristic can be described as follows .",
    "* initialize the set of built arcs @xmath79 and a zero flow @xmath80 * while @xmath59 is not a maximum flow for @xmath81 do * * find an augmenting path @xmath71 using the smallest number of new potential arcs .",
    "* * add the potential arcs on @xmath71 to @xmath45 .",
    "* * update the flow @xmath59 .",
    "this algorithm runs in time @xmath82 .",
    "the @xmath83-component in our node labels ensures that we find the augmenting path that ( 1 ) requires the smallest number of new arcs to be built , and ( 2 ) allows the maximum augmentation among these paths .",
    "nevertheless , it might be beneficial to build another path which allows more augmentations afterwards without building additional arcs .",
    "this is illustrated in figure  [ fig : example ] .",
    "does the right thing . ]    since algorithm  [ alg : greedy ] , which solves subproblems minarcs@xmath84 and maxval@xmath85 , when implemented using state - of - the - art commercial mip solver , turned out to be sufficiently efficient for our test instances , we decided not to implement the polynomial variant for our computational study , which is presented in section  [ sec : computations ] .",
    "a potential drawback of the quickest increment heuristic is that it might build arcs which yield ( small ) flow increments but that are not used in an ultimate maximum flow . to force the heuristic to build arcs that are used in an ultimate maximum flow , we can first determine a smallest set of potential arcs that admit an ultimate maximum flow by finding an optimal solution @xmath86 to the problem minarcs(@xmath87 ) , and then restricting the arc choices in algorithm  [ alg : greedy ] to the arcs used in the optimal solution @xmath86 , i.e. , by fixing @xmath88 for all @xmath89 with @xmath90 .",
    "this algorithm is described formally in algorithm  [ alg : quickest_ultimate ] .",
    "@xmath91 optimal solution for minarcs@xmath92 @xmath93 @xmath94 solution obtained by _ quickest - increment _ with input @xmath95    because the smallest set of potential arcs that admits an ultimate maximum flow is unlikely to be unique , it is possible that the initial choice of arcs may not be the best .      combining the ideas of quickest flow increment and quickest ultimate flow ,",
    "we can design a general framework .",
    "let @xmath96 be a sequence of target values",
    ". put @xmath97 , and for @xmath98 suppose that we have already determined a set @xmath99 such that the maximum flow value for @xmath100 is @xmath101 . following the quickest ultimate flow strategy ,",
    "we can determine a smallest set of potential arcs @xmath102 with @xmath103 such that @xmath104 allows a flow of value @xmath105 , and then we can use the quickest flow increment strategy to specify the order in which the arcs in @xmath106 are built .",
    "this is described in detail in algorithm  [ alg : quickest_target ] .",
    "@xmath107 @xmath108    note that this framework implicitly also provides a risk mitigation strategy , because we are not locked in to a set of arcs for the entire planning period , as in _ quickest - to - ultimate_.",
    "as mentioned in the introduction , the incremental network design problem with maximum flows is strongly np - hard even when restricted to instances where every existing arc has capacity 1 and every potential arc has capacity 3 . that leaves open the possibility that when all arcs have capacity 1 , i.e. , both existing and potential arcs , the problem is polynomially solvable .",
    "unfortunately , we have been unable to settle the complexity status of the unit - capacity case , but we have been able to derive a number of results regarding the performance of _ quickest - increment _ and _ quickest - to - ultimate _ in the unit - capacity case , which are presented in this section .",
    "figures  [ fig : example_1 ] and  [ fig : example_2 ] illustrate that the heuristics can be off by a factor of close to 2 ( _ quickest - to - ultimate _ ) and 3/2 ( _ quickest - increment _ ) .",
    "the dashed arcs represent paths of potential arcs whose lengths are indicated by the arc labels . for the instance in figure  [ fig : example_1 ] , the time horizon is @xmath109 and the optimal solution ( which is found by _ quickest - increment _ ) has value @xmath110 , while _ quickest - to - ultimate _ provides a solution of value @xmath111 .",
    "for the instance in figure  [ fig : example_2 ] , the time horizon is @xmath112 and the optimal solution ( which is found by _ quickest - to - ultimate _ ) has value @xmath113 , while _ quickest - increment _ provides a solution of value @xmath114 . combining the two examples we get an instance that fools both heuristics ( figure [ fig : example_3 ] ) . for this instance , _ quickest - to - ultimate _ achieves a total flow of @xmath115 , _ quickest - increment _ gets @xmath116 , but a combination of the two strategies yields a total flow of @xmath117 .          in this subsection",
    ", we show that the instances in figures  [ fig : example_1 ] and  [ fig : example_2 ] represent the worst situations for the heuristics _ quickest - to - ultimate _ and _ quickest - increment _ , respectively .",
    "let @xmath51 , @xmath118 and @xmath119 denote the optimal objective value , and the values obtained by _ quickest - to - ultimate _ and _ quickest - increment _ , respectively .",
    "for @xmath120 , let @xmath121 and @xmath122 denote the number of time periods with a maximum flow value @xmath123 in the solution from _ quickest - to - ultimate _ and _ quickest - increment _ , respectively .",
    "in other words , @xmath121 and @xmath122 are the optimal values of the problems minarcs(@xmath124 ) which are solved for increasing the flow from @xmath123 to @xmath125 .",
    "furthermore , let @xmath126 for @xmath127 be the minimum number of potential arcs that have to be built in order to reach a flow of @xmath128 : @xmath129 observe that if the associated sets of arcs would be nested , then they would give rise to an optimal solution .",
    "however , since this is unlikely to be the case in general , the values @xmath126 can only be used to derive an upper bound .",
    "[ lem : bound_opt_by_c ] @xmath130 .    for @xmath120 ,",
    "let @xmath131 be the number of time periods with flow @xmath123 in an optimal solution .",
    "since any feasible solution must have at least @xmath132 periods with flow value at most @xmath123 , we have @xmath133 summing over @xmath134 , we obtain @xmath135 hence @xmath136\\\\ = tf-\\sum_{i=0}^{r-1}\\lambda^*_i(r - i)\\leqslant tf-\\sum_{j=1}^rc_j.\\end{gathered}\\ ] ] this proves the first inequality and the second one follows with @xmath137 for @xmath138 .    the values @xmath118 and @xmath119 can be expressed in terms of the sequences @xmath139 and @xmath140 , respectively .",
    "[ lem : z_i_by_lambda_resp_mu ] @xmath141 and @xmath142 .",
    "we have @xmath143 and similarly for @xmath119",
    ".    the sequences @xmath144 and @xmath145 are non - decreasing .",
    "[ lem : lambda_incr ] we have @xmath146 and @xmath147 .",
    "let @xmath148 be the set of arcs that are used by _ quickest - to - ultimate_. set @xmath149 , and for @xmath150 let @xmath102 be the set of arcs which are built by _ quickest - to - ultimate _ in the first @xmath151 time periods .",
    "then @xmath152 fix some @xmath153 , and let @xmath154 be an optimal solution for the dual characterization of @xmath121 . since @xmath155 can carry an @xmath0-@xmath1-flow of value @xmath123 , the optimal value for the optimization problem which characterizes @xmath121 becomes @xmath156 when the flow value @xmath125 is replaced by @xmath123 . in the dual problem",
    "this is corresponds to the coefficient of @xmath157 in the objective function , and since @xmath154 is also feasible for this modified dual problem , we have @xmath158 and therefore @xmath159    on the other hand , we obtain a feasible solution @xmath160 for the dual characterization of @xmath161 by setting @xmath162 and @xmath163 and together with @xmath164 this implies @xmath165 the inequality @xmath166 is proved in the same way ( with @xmath167 instead of @xmath168 ) .    [ thm : approx_heur_1 ] _ quickest - to - ultimate _ is a @xmath169-approximation algorithm for the incremental maximum flow problem with unit capacities , i.e. , @xmath170 .    using lemma  [ lem : lambda_incr ]",
    ", we have @xmath171 adding the inequality @xmath172 , it follows that @xmath173 by construction , @xmath174 , and with lemma  [ lem : bound_opt_by_c ] we derive @xmath175    in order to prove that for _ quickest - increment _ the case in figure  [ fig : example_2 ] illustrates an upper bound for the approximation ratio , we need some technical preparations .",
    "we start by bounding the numbers @xmath122 by the numbers @xmath126 .",
    "[ lem : mu_bound_by_c ] we have @xmath176 for all @xmath177 with @xmath178 .",
    "fix @xmath134 and @xmath179 with @xmath178 , and let @xmath180 be the feasible region of the maximization problem which characterizes @xmath122 , i.e. , @xmath181 where @xmath102 is the set of arcs built by _ quickest - increment _ in the first @xmath182 time periods . since the maximum flow value on @xmath155 equals @xmath123 , we have that @xmath183 where @xmath184 consequently , @xmath185 and by taking the dual we obtain @xmath186 let @xmath187 be an optimal solution for the problem  ( [ eq : c_primal ] ) to determine @xmath126 , i.e. , an @xmath0-@xmath1-flow of value @xmath128 . solving the system @xmath188 for @xmath189 and @xmath190 yields @xmath191 and @xmath192 , and this implies that a feasible solution @xmath193 for problem  ( [ eq : aux_problem ] ) can be obtained by setting @xmath194 for all @xmath19 and @xmath192 . hence the optimal value of problem  ( [ eq : aux_problem ] ) is at most @xmath195 and this concludes the proof .    from lemmas  [ lem : lambda_incr ] and  [ lem : mu_bound_by_c ]",
    "it follows that @xmath196 satisfies the following conditions : @xmath197 let @xmath198 denote the set of all @xmath199 satisfying  ( [ eq : monotonicity ] ) to  ( [ eq : nonnegativity ] ) . using lemmas  [",
    "lem : bound_opt_by_c ] and  [ lem : z_i_by_lambda_resp_mu ] , a number @xmath200 is an upper bound for the approximation ratio of _ quickest - increment _ , provided @xmath201\\ ] ] is a valid inequality for @xmath202 , or equivalently @xmath203 for all @xmath204 . since @xmath205 and @xmath200 , this inequality is strengthened when @xmath31 is replaced by @xmath206 on the left hand side . by duality",
    ", the stronger inequality is valid for @xmath202 , provided the following system has a solution : @xmath207 let @xmath208 be the set of all @xmath209 satisfying  ( [ eq : dual_for_c ] ) to  ( [ eq : nonneg_2 ] ) .",
    "the above argument implies the following theorem which provides a sufficient condition for @xmath189 to be an approximation factor for _ quickest - increment _ on all instances with @xmath210 .",
    "[ thm : suff_cond ] if @xmath211 , then _ quickest - increment _ is a @xmath189-approximation algorithm for all instances of the incremental maximum flow problem with unit capacities and @xmath210 .    consequently , in order to establish that _ quickest - increment _ is a @xmath2-approximation algorithm , it is sufficient to prove the @xmath212 for all @xmath213 .",
    "to do this , we need another lemma .",
    "[ lem : initial_segment ] let @xmath213 and @xmath214 .",
    "then the following system has a solution with non - negative @xmath215 for @xmath216 , @xmath217 : @xmath218    we proceed by induction on @xmath206 .",
    "for @xmath219 , @xmath220 , a solution is given by @xmath221 , @xmath222 .",
    "so we assume @xmath223 , and we distinguish two cases .",
    ": :    @xmath224 . by induction , there are    nonnegative numbers @xmath215 for    @xmath225 and    @xmath226 satisfying    @xmath227 we extend this by @xmath228 for    @xmath225 .",
    "then    @xmath229 for    @xmath225 and    @xmath230 case 2 .",
    ": :    @xmath231 and @xmath232 . for    @xmath233",
    ", a solution is given by @xmath234 for    @xmath235 , by induction , there are nonnegative numbers    @xmath215 for @xmath236 and    @xmath237 satisfying    @xmath238    let @xmath239 .",
    "we extend our solution by    @xmath240 then    @xmath229 for    @xmath225 ,    @xmath241    @xmath242    where we used @xmath243 for the last inequality , and    @xmath244 .    using lemma  [ lem : initial_segment ]",
    ", we can exhibit a point in @xmath245 .",
    "[ lem : witness_point ] @xmath212 for all @xmath213 .",
    "let @xmath214 and let @xmath215 for @xmath216 and @xmath217 be a point as described in lemma  [ lem : initial_segment ] . for @xmath246 and @xmath217 , let @xmath247 .",
    "in addition , let @xmath248 for @xmath225 , and @xmath249 .",
    "finally , let @xmath250 we claim that @xmath251 .",
    "constraints  ( [ eq : dual_for_c ] ) follow immediately lemma  [ lem : initial_segment ] . the same is true for constraints  ( [ eq : dual_for_lambda ] ) for @xmath252 . for @xmath253 ,",
    "constraints  ( [ eq : dual_for_lambda ] ) are satisfied because @xmath254 finally , constraint  ( [ eq : dual_for_lambda ] ) for @xmath255 follows from @xmath256 which also implies @xmath257 for all @xmath134 .",
    "the bound of @xmath2 for the approximation ratio of _ quickest - increment _ is a consequence of theorem  [ thm : suff_cond ] and lemma  [ lem : witness_point ] .",
    "[ thm : approx_heur_2 ] _ quickest - increment _ is a @xmath2-approximation algorithm for the incremental maximum flow problem with unit capacities .    let us examine the example in figure  [ fig : example_2 ] more closely .",
    "it has initial flow value @xmath258 and ultimate flow value @xmath259 and the essence of the example is that the arcs that are built to reach a flow value 1 can not be used for the ( ultimate ) flow value 2 .",
    "figure [ fig : r_3 ] shows an attempt to generalize the example to one with initial flow value @xmath258 and ultimate flow value @xmath260 .",
    "the instance has a time horizon @xmath261 .    .",
    "]    _ quickest - increment _ starts with building the middle path with @xmath262 potential arcs .",
    "then the cheapest way to achieve a flow of value 2 is to build the two paths containing @xmath24 potential arcs each .",
    "finally , all the remaining arcs have to be built in order to achieve a flow of value 3 .",
    "this gives a total flow of @xmath263 on the other hand , the optimum for large @xmath24 is to build the ultimate flow immediately which yields @xmath264 what works in favor of the heuristic , in terms of performance , is that in order for the heuristic not to build the upper path to achieve a flow of value 2 , it has to be long enough , i.e. longer than the sum of the lengths of the diagonal paths that the heuristic chooses .",
    "if we define @xmath265 then theorem [ thm : approx_heur_2 ] shows that @xmath266 .",
    "it is possible to show that @xmath267 for @xmath268 , and we conjecture that it is possible to show that @xmath269 .      in our quest for",
    "polynomially solvable cases of incremental network design with maximum flows , we next consider , in addition to unit capacities on all arcs , imposing a restriction on the structure of the network .",
    "more specifically , a node set @xmath270 and an arc set @xmath167 consisting of existing arcs @xmath271 for all @xmath272 , existing arcs @xmath273 for all @xmath274 , and some arcs @xmath275 with @xmath272 and @xmath274 , which can be either existing or potential .",
    "thus , @xmath0-@xmath1 flows correspond to matchings in the bipartite graph @xmath276 , and therefore we call this special case the _ incremental maximum matching problem_.    the example in figure [ fig : h1-matching ] shows that _ quickest - to - ultimate _ may fail to find an optimal solution .",
    "the unique maximum cardinality matching is @xmath277 and building arcs ( 1,2 ) , ( 3,4 ) , ( 5,6 ) , and ( 7,8 ) , followed by arcs ( 9,10 ) , ( 11,12 ) , ( 13,14 ) , and ( 15,16 ) , followed by ( 9,4 ) results in a total cumulative flow for _ quickest - to - ultimate _ of @xmath278 , whereas building arcs ( 1,2 ) and ( 9,4 ) , followed by arcs @xmath279 results in a total cumulative flow of @xmath280 .",
    "similarly , the example in figure  [ fig : h2-matching ] shows that _ quickest - increment _ may fail to find an optimal solution .",
    "the initial maximum matching has size @xmath281 , and the unique cheapest way to obtain a matching of size 6 is to build arcs @xmath282 and @xmath283 .",
    "after that , all the remaining potential arcs need to be build to reach a matching of size 7 , and the total cumulative flow for _ quickest - increment _ is @xmath284 . on the other hand , building arcs @xmath285 followed by arcs ( 5,8 ) and ( 7,10 ) results in a total cumulative flow of @xmath286 .",
    "thus , even restricting the structure of the network to bipartite graphs does not trivially give a polynomially solvable case of incremental network design with maximum flows .",
    "we have been able to improve the performance guarantee of _ quickest - to - ultimate _ to @xmath287 for instances of the incremental maximum matching problem . the proof is given in the appendix .",
    "we have conducted a computational study to gain insight into the characteristics that make instances of the incremental maximum flow problem hard to solve , to compare the performance of the two mip formulations , and to assess the performance of the three heuristics .",
    "the following computational tools were used to develop and analyze the formulations and algorithms : python 2.7.5 , matplotlib 1.3.1 , networkx 1.8.1 , and gurobi 5.5 .",
    "all computational experiments were conducted on a 64-bit win7 with intel xeon cpu ( e5 - 1620 ) with 8 cores and 32 gb of ram using a single thread .      for the computational experiments in which we compare the performance of the ip formulations and the heuristics , we use two classes of instances : one using general graphs and one using layered graphs .",
    "general graphs are parameterized by the number of nodes @xmath288 , the expected density @xmath289 , the expected fraction of potential arcs @xmath290 , and the maximum arc capacity @xmath291 . for each combination of parameters ,",
    "10 random instances are generated .",
    "more specifically , for a given number of nodes @xmath288 , an arc between two nodes exists with probability @xmath292 , and if an arc between two nodes exists , the arc is a potential arc with probability @xmath293 ( and thus an existing arc with probability @xmath294 ) .",
    "layered graphs consist of a source node , a sink node , and @xmath295 layers in between @xmath296 .",
    "the source is connected to every node in the first layer and every node in the last layer is connected to the sink .",
    "the nodes in layer @xmath134 may be connected to a node in layer @xmath297 .",
    "layered graphs are parameterized by the number of layers @xmath295 , the number of nodes in each layer @xmath288 , the expected density @xmath298 , the expected fraction of potential arcs @xmath290 , and the maximum arc capacity @xmath291 . for each combination of parameters ,",
    "10 random instances are generated .",
    "the generation proceeds similar to the generation of general instances .",
    "layered instances are considered because they ensure a minimum distance between the source and the sink .",
    "we start by determining the characteristics that make an instance difficult to solve and , at the same time , comparing the performance of the two mip formulations presented in section  [ sec : problem ] .",
    "tables [ tbl : mip_gen_ave ] and [ tbl : mip_layered_ave ] present average performance statistics for various combinations of the instance parameters ( with @xmath299 for general graphs and @xmath300 and @xmath301 for layered graphs ) .",
    "more specifically , we report the arc density ( @xmath292 ) , the fraction of potential arcs ( @xmath293 ) , the maximum arc capacity ( @xmath302 ) , the difference between the value of an ultimate and an initial maximum flow ( @xmath303 ) , the number of instances not solved to optimality within the time limit ( # ) , the average initial gap ( initial gap ) , computed as @xmath304 , where @xmath305 the value of the lp relaxation and @xmath306 is the value of the best solution found , the average final gap over the instances not solved to optimality ( final gap ) , where in the gap computation @xmath305 is replaced by the best bound at termination , and the average solution time ( time ) and average number of nodes in the search tree ( # nodes ) over the instances solved to optimality .",
    ".comparison of mip models for general graphs with @xmath307 ; time limit 1 hour [ cols= \" > , > , > , > , > , > , > , > , > , > , > , > , > , > \" , ]     [ tbl : alg_layered ]    as expected , the three heuristics are able to produce high - quality solutions quickly ( with _ quickest - increment _ possibly being slightly slower than the other two ) . for these instances , the hybrid heuristic",
    "_ quickest - to - target _ seems to performs best ( on average within 0.03% from the best known solution for instances on general graphs and within 0.47% from the best known solution for instances on layered graphs ) .",
    "however , imfp@xmath43 also produces high - quality solutions when given an hour of computing time , often noticeably better than the heuristic solutions .    as the instances used for the above experiments are relatively small",
    ", we performed a final experiment in which we use general and layered graphs with 300 nodes to investigate whether the performance of the heuristics ( both in terms of quality and time ) scales well .",
    "instances of this size are beyond what can be solved to optimality in a reasonable amount of time with imfp@xmath43 .",
    "therefore , instead , we solved the instances twice with gurobi parameter ` solutionlimit ` set to one the first time and to two the second time . when ` solutionlimit ` is set to one",
    ", gurobi uses its embedded heuristics to generate a feasible solution and does not even solve the linear programming relaxation .",
    "when ` solutionlimit ` is set to two , gurobi solves at least one linear programming relaxation .",
    "the results can be found in table [ tab : heur - large ] and table [ tab : heur - large2 ] .",
    "rr rr rr rr rrrr    & & & & & + ( lr)3 - 4(lr)5 - 6(lr)7 - 8(lr)9 - 12    instance & @xmath308 & flow & time & flow & time & flow & time & first & time & second & time + 1 & 349 & * 8,510,022 * & 573.89 & 8,510,019 & 63.96 & 8,510,018 & 69.64 & 8,501,339 & 346.50 & * 8,510,022 * & 2,618.57 + 2 & 276 & * 7,748,950 * & 607.13 & 7,748,926 & 66.64 & 7,748,936 & 80.42 & 7,741,651 & 261.88 & * 7,748,950 * & 1,551.84 + 3 & 306 & * 7,455,851 * & 708.26 & 7,455,825 & 76.61 & 7,455,840 & 82.10 & 7,446,419 & 294.29 & * 7,455,851 * & 2,043.68 + 4 & 302 & 7,693,036 & 553.93 & 7,693,080 & 62.84 & 7,693,084 & 68.21 & 7,683,753 & 298.44 & * 7,693,095 * & 2,820.65 + 5 & 303 & * 8,561,146 * & 636.09 & 8,561,146 & 74.13 & 8,561,141 & 81.39 & 8,551,909 & 295.49 & * 8,561,146 * & 2,194.76 + 6 & 300 & * 8,173,176 * & 647.99 & 8,173,175 & 68.08 & 8,173,174 & 73.66 & 8,164,741 & 291.10 & 8,173,173 & 1,837.50 + 7 & 320 & * 8,551,244 * & 677.60 & 8,551,226 & 70.46 & 8,551,237 & 73.81 & 8,543,003 & 318.91 & * 8,551,244 * & 2,646.82 + 8 & 378 & * 9,707,335 * & 760.95 & 9,707,321 & 85.66 & 9,707,334 & 91.26 & 9,696,827 & 390.26 & * 9,707,335 * & 2,922.14 + 9 & 335 & * 8,078,470 * & 626.21 & 8,078,470 & 75.93 & 8,078,468 & 80.53 & 8,068,707 & 331.73 & * 8,078,470 * & 2,207.85 + 10 & 285 & * 7,676,476 * & 546.08 & 7,676,432 & 64.63 & 7,676,418 & 69.36 & 7,668,636 & 272.20 & * 7,676,476 * & 2,051.99 + * * & * * & * * & * 633.81 * & * * & * 70.894 * & * * & * 77.038 * & * * & * 310.08 * & * * & * 2,289.58 * +    [ tab : heur - large ]    rr rr rr rr rrrr    & & & & & + ( lr)3 - 4(lr)5 - 6(lr)7 - 8(lr)9 - 12    instance & @xmath308 & flow & time & flow & time & flow & time & first & time & second & time + 1 & 52 & 289,131 & 54.44 & 289,171 & 5.98 & * 289,185 * & 22.98 & 288,993 & 52.97 & 289,164 & 165.88 + 2 & 25 & 237,934 & 8.18 & 237,935 & 2.63 & * 237,937 * & 3.40 & 237,919 & 7.03 & 237,920 & 23.67 + 3 & 47 & 304,763 & 20.03 & 304,779 & 32.59 & * 304,781 * & 6.77 & 304,586 & 21.80 & 304,775 & 89.02 + 4 & 40 & * 233,395 * & 10.85 & 233,394 & 5.75 & * 233,395 * & 3.91 & 233,354 & 13.92 & 233,362 & 49.63 + 5 & 21 & 251,797 & 10.33 & 251,800 & 4.51 & * 251,801 * & 4.07 & 251,762 & 5.83 & 251,790 & 24.74 + 6 & 30 & 258,451 & 12.97 & 258,448 & 4.01 & 258,448 & 4.99 & 258,385 & 28.83 & * 258,452 * & 75.28 + 7 & 33 & * 243,606 * & 11.22 & 243,604 & 4.24 & 243,604 & 5.55 & 243,535 & 21.50 & 243,542 & 73.16 + 8 & 23 & * 195,436 * & 5.05 & 195,431 & 1.93 & * 195,436 * & 2.54 & 195,160 & 1.19 & 195,406 & 4.67 + 9 & 29 & * 255,092 * & 9.61 & 255,083 & 4.26 & 255,086 & 6.97 & 254,978 & 13.23 & 255,053 & 48.85 + 10 & 50 & 280,063 & 18.89 & 280,070 & 5.66 & * 280,078 * & 10.04 & 280,003 & 21.67 & 280,077 & 126.33 + * * & * * & * * & * 16.157 * & * * & * 7.156 * & * * & * 7.122 * & * * & * 18.797 * & * * & * 68.123 * +    [ tab : heur - large2 ]    a few interesting observations can be made .",
    "for general instances of this size , _ quickest - increment _ performs best ( it produces the best solution for all but one instance ) , but it is noticeably slower than _ quickest - to - ultimate _ and _ quickest - to - target_. the first solution found by imfp@xmath43 is the worst for all instances , but the second solution found by imfp@xmath43 matches the best in all but one instance .",
    "however , it takes substantially longer to find that solution .",
    "for layered instances of this size , the situation is not as clear cut , both _",
    "quickest - increment _ and _ quickest - to - ultimate _ perform well and outperform imfp@xmath43 in all but one instance .",
    "overall , _",
    "quickest - to - target _ produces high - quality solution very efficiently for all instances and should be the method of choice when time is important .",
    "we have studied the incremental network design with maximum flows .",
    "we have investigated the performance of mixed integer programming formulations and we have analyzed the performance of natural heuristics , both theoretically and empirically .",
    "on the theoretic side , the complexity status of the incremental maximum flow problem for instances with unit arc capacities remains open , even when the network is restricted to bipartite graphs . on the algorithmic side ,",
    "we have identified classes of instances where integer programming solvers struggle and where the natural heuristics , although fast , do not necessarily provide high - quality solutions .",
    "thus , there is an opportunity to explore more sophisticated heuristics , e.g. , metaheuristics .    finally , there are various other incremental network design problems that are worth studying , e.g. , the incremental multicommodity flow problem",
    ".    10    m.  baxter , t.  elgindy , a.  ernst , t.  kalinowski , and m.  savelsbergh . incremental network design with shortest paths .",
    ", 238:675684 , 2014 .",
    "b.  cavdaroglu , e.  hammel , j.e .",
    "mitchell , t.c .",
    "sharkey , and w.a .",
    "wallace . integrating restoration and scheduling decisions for disrupted interdependent infrastructure systems .",
    ", pages 116 , 2013 .",
    "k.  engel , t.  kalinowski , and m.w.p .",
    ". incremental network design with minimum spanning trees .",
    "arxiv : http://arxiv.org / abs/1306.1926[1306.1926 ] , 2013 .    b.j .",
    "kim , w.  kim , and b.h . song .",
    "sequencing and scheduling highway network expansion using a discrete network design model .",
    ", 42(3):621642 , 2008 .",
    "lee , j.e .",
    "mitchell , and w.a .",
    "restoration of services in interdependent infrastructure systems : a network flows approach .",
    ", 37(6):13031317 , 2007 .",
    "lee , j.e .",
    "mitchell , and w.a .",
    "network flow approaches for analyzing and managing disruptions to interdependent infrastructure systems .",
    ", 2009 .",
    "a.  mahmood , m.  aamir , and m.i .",
    "design and implementation of amr smart grid system . in _ electric power conference , 2008 .",
    "epec 2008 .",
    "ieee canada _ , pages 16 .",
    "ieee , 2008 .",
    ". smart grid design for efficient and flexible power networks operation and control . in _",
    "power systems conference and exposition _",
    ", pages 18 .",
    "ieee , 2009 .",
    "nurre , b.  cavdaroglu , j.e .",
    "mitchell , t.c .",
    "sharkey , and w.a .",
    "wallace . restoring infrastructure systems : an integrated network design and scheduling ( inds ) problem .",
    ", 223(3):794806 , 2012 .",
    "nurre and t.c .",
    "integrated network design and scheduling problems with parallel identical machines : complexity results and dispatching rules . , 63(4):306326 , 2014 .",
    "s.  v. ukkusuri and g.  patil .",
    "multi - period transportation network design under demand uncertainty .",
    ", 43(6):625642 , 2009 .",
    "* complexity of incremental maximum flow problem *      we use reduction from the problem _ exact cover by 3-sets _ ( x3c ) .",
    "an instance of x3c is given by a collection @xmath309 of 3-element subsets of the set @xmath310 , and the problem is to decide if there are @xmath288 sets @xmath311 such that @xmath312 .",
    "such an x3c instance can be reduced to the following imfp instance .",
    "the node set is @xmath313 for every @xmath314 , there is a potential arc with capacity @xmath18 from @xmath0 to @xmath315 , and for every @xmath316 there is an existing arc of capacity @xmath17 from @xmath317 to @xmath1 .",
    "moreover , for every @xmath318 there are three existing arcs @xmath319 , @xmath320 and @xmath321 with unit capacities .",
    "clearly the flow in time period @xmath24 is at most @xmath322 , hence the objective value is bounded by @xmath323 + 3n(t - n)\\ ] ] and this upper bound can be achieved if and only if the underlying x3c instance is a yes - instance .      in order to derive a performance guarantee for _",
    "quickest - to - ultimate _ on instances of the incremental maximum matching problem , we strengthen lemma  [ lem : z_i_by_lambda_resp_mu ] .",
    "we need the following auxiliary result .",
    "recall that @xmath332 .",
    "lemmas  [ lem : z_i_by_lambda_resp_mu ] and  [ lem : averaging_is_best ] yield @xmath333 for the case @xmath334 we define @xmath335 .",
    "note that @xmath336 .",
    "this implies that in the first @xmath337 time periods , there is always a potential arc which is used in the ultimate maximum matching , and is not adjacent to any arc in the current maximum matching .",
    "hence @xmath338 for @xmath339 . from lemma",
    "[ lem : z_i_by_lambda_resp_mu ] we obtain @xmath340 using lemma  [ lem : averaging_is_best ] and @xmath341 , this implies @xmath342\\\\ = tf - r\\rho+\\frac{\\rho(\\rho-1)}{2}-\\frac{(c_r-\\rho)(r-\\rho+1)}{2}.\\end{gathered}\\ ] ] if @xmath343 then @xmath344,\\end{gathered}\\ ] ] and if @xmath343 then @xmath345.\\end{gathered}\\ ] ] now the claim follows from @xmath346 .",
    ": :    @xmath348 , i.e. @xmath349 . using    lemmas  [ lem : bound_opt_by_c ] and  [ lem : improved_bound_for_z1 ] , we obtain    @xmath350\\leqslant\\frac{2c_rr}{3}-\\frac{tf}{3}.\\ ] ]    the required inequality follows from @xmath351 and    @xmath352",
    ": :    @xmath334 .",
    "lemma  [ lem : improved_bound_for_z1 ] implies    @xmath353\\right]\\\\    = -\\frac{tf}{3}-\\frac{r(r-1)}{2}-c_r+\\frac{c_rf}{3}+\\frac{r(r - f)}{3}+\\frac{2c_r}{3}.     \\end{gathered}\\ ] ] using @xmath354 and then    substituting @xmath355 , we obtain    @xmath356 now the claim follows from    @xmath346 ."
  ],
  "abstract_text": [
    "<S> we study an incremental network design problem , where in each time period of the planning horizon an arc can be added to the network and a maximum flow problem is solved , and where the objective is to maximize the cumulative flow over the entire planning horizon . after presenting two mixed integer programming ( mip ) formulations for this np - complete problem , we describe several heuristics and prove performance bounds for some special cases . in a series of computational experiments , </S>",
    "<S> we compare the performance of the mip formulations as well as the heuristics . </S>"
  ]
}