{
  "article_text": [
    "most of the known quantum algorithms work in the black - box model of computation . here",
    "one accesses the @xmath1-bit input via _ queries _ and our measure of complexity is the number of queries made by the algorithm . in between the queries , the algorithm can make unitary transformations for free .",
    "this model includes for instance the algorithms of grover , deutsch and jozsa , simon , quantum counting , the recent quantum walk - based algorithms , and even shor s period - finding algorithm ( which is the quantum core of his factoring algorithm ) .",
    "much work has focused on proving _ lower bounds _ in this model .",
    "the two main methods known are the polynomial method and the adversary method .",
    "the polynomial method works by lower - bounding the degree of a polynomial that in some way represents the desired success probability .",
    "the adversary method was originally introduced by ambainis  @xcite .",
    "many different versions have since been given  , but they are all equivalent  . roughly speaking , the adversary method works as follows .",
    "suppose we have a @xmath2-query quantum algorithm that computes some function @xmath3 with high success probability .",
    "let @xmath4 denote the algorithm s state on input @xmath5 after making the @xmath6-th query .",
    "suppose @xmath5 and @xmath7 are two inputs with distinct function values . at the start of the algorithm ( @xmath8 ) , the states @xmath9 and @xmath10 are the same ( the input has not been queried yet ) ,",
    "so their inner product is @xmath11 .",
    "but at the end of the algorithm ( @xmath12 ) , the inner product @xmath13 must be less than some small constant depending on the error probability , otherwise the algorithm can not give the correct answer for both @xmath5 and @xmath7 .",
    "the adversary method takes a ( weighted ) sum of such inner products ( for @xmath14 pairs with @xmath15 ) and analyzes how quickly this sum can go down after each new query .",
    "if it can not decrease quickly in one step , then it follows that we need many steps and we obtain a lower bound on @xmath2 .",
    "the two lower bound methods are incomparable . on the one hand ,",
    "the adversary method proves stronger bounds than the polynomial method for certain iterated functions  @xcite , and also gives tight lower bounds for constant - depth and - or trees  @xcite , where we do not know how to analyze the polynomial degree . on the other hand ,",
    "the polynomial method works well for analyzing zero - error or low - error quantum algorithms  @xcite and gives optimal lower bounds for the collision problem and element distinctness  .",
    "the adversary method fails for the latter problem ( and also for other problems like triangle - finding ) , because the best bound provable with it is @xmath16  . here",
    "@xmath17 and @xmath18 are the certificate complexities of @xmath3 on 0-inputs and 1-inputs . in the case of element distinctness and triangle - finding ,",
    "one of these complexities is constant .",
    "hence the adversary method in its present form(s ) can prove at most an @xmath19 bound , while the true bound is @xmath20  @xcite in the case of element distinctness and the best known algorithm for triangle - finding costs @xmath21  @xcite .",
    "a second limitation of the adversary method is that it can not deal well with the case where there are many different possible outputs , and a success probability much smaller than @xmath22 would still be considered good .    in this paper",
    "we describe a new version of the adversary method that does not suffer from the second limitation , and possibly also not from the first  though we have not found an example yet where the new method breaks through the @xmath23 barrier .",
    "_ very _ roughly speaking , the new method works as follows .",
    "we view the algorithm as acting on a 2-register state space @xmath24 . here",
    "the actual algorithm s operations take place in the first register , while the second contains ( a superposition of ) the inputs .",
    "in particular , the query operation on @xmath25 is now conditioned on the basis states in @xmath26 .",
    "we start the analysis with a superposition of 0-inputs and 1-inputs in the input register , and then track how this register evolves as the computation moves along .",
    "let @xmath27 be the state of this register ( tracing out the @xmath25-register ) after making the @xmath6-th query . by employing symmetries in the problem s structure , such as invariances of the function under certain permutations of its input",
    ", we can decompose the input space into orthogonal subspaces @xmath28 .",
    "we can decompose the state accordingly : @xmath29 where @xmath30 is a density matrix in subspace @xmath31 .",
    "thus the @xmath6-th state can be fully described by a probability distribution @xmath32 that describes how the input register is distributed over the various subspaces .",
    "crucially , only some of the subspaces are `` good '' , meaning that the algorithm will only work if most of the weight is concentrated in the good subspaces at the end of the computation . at the start of the computation ,",
    "hardly any weight will be in the good subspaces .",
    "if we can show that in each query , not too much weight can move from the bad subspaces to the good subspaces , then we again get a lower bound on @xmath2 .",
    "this idea was first introduced by ambainis in  @xcite and used there to reprove the `` strong direct product theorem '' for the or - function of  @xcite ( we ll explain this in a minute ) . in this paper",
    "we extend it and use it to prove direct product theorems for all _ symmetric _ functions .",
    "consider an algorithm that simultaneously needs to compute @xmath0 independent instances of a function @xmath3 ( denoted @xmath33 ) .",
    "direct product theorems deal with the optimal tradeoff between the resources and success probability of such algorithms .",
    "suppose we need @xmath6 `` resources '' to compute a single instance @xmath34 with bounded error probability .",
    "these resources could for example be time , space , ink , queries , communication , etc . a typical direct product theorem ( dpt )",
    "has the following form :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ every algorithm with @xmath35 resources for computing @xmath33 has success probability @xmath36 ( where @xmath37 is some small constant ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this expresses our intuition that essentially the best way to compute @xmath33 on @xmath0 independent instances is to run separate @xmath6-resource algorithms for each of the instances .",
    "since each of those will have success probability less than 1 , we expect that the probability of simultaneously getting all @xmath0 instances right goes down exponentially with @xmath0 .",
    "dpt s can be stated for classical algorithms or quantum algorithms , and @xmath38 could measure worst - case success probability or average - case success probability under some input distribution .",
    "dpt s are generally hard to prove , and shaltiel  @xcite even gives general examples where they are just not true ( with @xmath38 average success probability ) , the above intuition notwithstanding .",
    "klauck , palek , and de  wolf  @xcite recently examined the case where the resource is query complexity and @xmath39 or , and proved an optimal dpt both for classical algorithms and for quantum algorithms ( with @xmath38 worst - case success probability ) .",
    "this strengthened a slightly earlier result of aaronson  @xcite , who proved that the success probability goes down exponentially with @xmath0 if the number of queries is bounded by @xmath40 rather than the @xmath41 of  @xcite . here",
    "we generalize their results to the case where @xmath3 can be any symmetric function , i.e. , a function depending only on the hamming weight @xmath42 of its input . in the case of classical algorithms",
    "the situation is quite simple .",
    "every @xmath1-bit symmetric function @xmath3 has classical bounded - error query complexity @xmath43 and block sensitivity @xmath44 , hence an optimal classical dpt follows immediately from  ( * ? ? ?",
    "* theorem  3 ) .",
    "classically , all symmetric functions essentially `` cost the same '' in terms of query complexity .",
    "this is different in the quantum world .",
    "for instance , the or function has bounded - error quantum query complexity @xmath45  @xcite , while parity needs @xmath46 quantum queries  @xcite . if @xmath3 is a @xmath6-threshold function ( @xmath47 iff @xmath48 , with @xmath49 ) , then @xmath50  @xcite .",
    "our main result is an essentially optimal quantum dpt for all symmetric functions :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ there is a constant @xmath37 such that for every symmetric @xmath3 and every positive integer @xmath0 : every 2-sided error quantum algorithm with @xmath51 queries for computing @xmath33 has success probability @xmath36 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    our new direct product theorem generalizes the polynomial - based results of  @xcite ( which strengthened the polynomial - based  @xcite ) , but our current proof uses the above - mentioned version of the adversary method .",
    "we have not been able to prove this result using the polynomial method .",
    "we can , however , use the polynomial method to prove an incomparable dpt .",
    "this result is worse than our main result in applying only to _",
    "1-sided error _ quantum algorithms - bit output vector are always correct . ] for _ threshold _ functions ; but it s better in giving a much stronger upper bound on the success probability :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ there is a constant @xmath37 such that for every @xmath6-threshold function @xmath3 and every positive integer @xmath0 : every 1-sided error quantum algorithm with @xmath51 queries for computing @xmath33 has success probability @xmath52 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a similar theorem can be proven for the @xmath0-fold @xmath6-search problem , where in each of @xmath0 inputs of @xmath1 bits , we want to find at least @xmath6 ones . the different error bounds @xmath53 and @xmath54 for 1-sided and 2-sided error algorithms intuitively say that imposing the 1-sided error constraint makes deciding each of the @xmath0 threshold problems as hard as actually _ finding _ @xmath6 ones in each of the @xmath0 inputs .      as an application we obtain near - optimal time - space tradeoffs for evaluating solutions to systems of linear equalities . such tradeoffs between the two main computational resources are well known classically for problems like sorting , element distinctness , hashing , etc . in the quantum world , essentially optimal time - space tradeoffs were recently obtained for sorting and for boolean matrix multiplication  @xcite , but little else is known .",
    "let @xmath55 be a fixed @xmath56 matrix of nonnegative integers .",
    "our inputs are column vectors @xmath57 and @xmath58 of nonnegative integers .",
    "we are interested in the system @xmath59 of @xmath60 linear inequalities , and want to find out which of these inequalities hold ( we could also mix @xmath61 , @xmath62 , and @xmath63 , but omit that for ease of notation ) . and @xmath5 are boolean and @xmath64 , this gives @xmath60 overlapping @xmath6-threshold functions . ] note that the output is an @xmath60-bit vector .",
    "we want to analyze the tradeoff between the time @xmath2 and space @xmath65 needed to solve this problem .",
    "lower bounds on @xmath2 will be in terms of query complexity . for simplicity",
    "we omit polylog factors in the following discussion .    in the classical world",
    ", the optimal tradeoff is @xmath66 , independent of the values in @xmath67 .",
    "this follows from  ( * ? ? ?",
    "* section  7 ) .",
    "the upper bounds are for deterministic algorithms and the lower bounds are for 2-sided error algorithms . in the quantum world",
    "the situation is more complex .",
    "let us put an upper bound @xmath68 .",
    "we have two regimes for 2-sided error quantum algorithms :    * quantum regime . if @xmath69 then the optimal tradeoff is @xmath70 ( better than classical ) .",
    "* classical regime . if @xmath71 then the optimal tradeoff is @xmath66 ( same as classical ) .",
    "our lower bounds hold even for the constrained situation where @xmath67 is fixed to the all-@xmath6 vector , @xmath55 and @xmath5 are boolean , and @xmath55 is sparse in having only @xmath72 non - zero entries in each row .    since our dpt for 1-sided",
    "error algorithms is stronger by an extra factor of @xmath6 in the exponent , we obtain a stronger lower bound for 1-sided error algorithms :    * if @xmath73 then the optimal tradeoff for 1-sided error algorithms is @xmath74 . * if @xmath75 then the optimal tradeoff for 1-sided error algorithms is @xmath66 .",
    "we do not know whether the lower bound in the first case is optimal ( probably it is not ) , but note that it is stronger than the optimal bounds that we have for 2-sided error algorithms .",
    "this is the first separation of 2-sided and 1-sided error algorithms in the context of quantum time - space tradeoffs .",
    "suffices for the fastest 1-sided and 2-sided error algorithms so there s no real tradeoff in that case . ]",
    "* remarks : *    \\1 .",
    "klauck et al .",
    "@xcite gave direct product theorems not only for quantum query complexity , but also for 2-party quantum communication complexity , and derived some communication - space tradeoffs in analogy to the time - space tradeoffs .",
    "this was made possible by a translation of communication protocols to polynomials due to razborov  @xcite , and the fact that the dpts of  @xcite were polynomial - based .",
    "some of the results in this paper can similarly be ported to a communication setting , though only the ones that use the polynomial method .",
    "the time - space tradeoffs for 2-sided error algorithms for @xmath76 similarly hold for a system of @xmath60 equalities , @xmath77 . the upper bound clearly carries over , while the lower holds for equalities as well , because our dpt holds even under the promise that the input has weight @xmath6 or @xmath78 .",
    "in contrast , the stronger 1-sided error time - space tradeoff does not automatically carry over to systems of equalities , because we do not know how to prove the dpt with bound @xmath53 under this promise .",
    "we assume familiarity with quantum computing   and sketch the model of quantum query complexity , referring to   for more details , also on the close relation between query complexity and degrees of multivariate polynomials .",
    "suppose we want to compute some function @xmath3",
    ". for input @xmath79 , a _ query _ gives us access to the input bits .",
    "it corresponds to the unitary transformation @xmath80 here @xmath81=\\{1,\\ldots , n\\}$ ] and @xmath82 ; the @xmath83-part corresponds to the workspace , which is not affected by the query .",
    "we assume the input can be accessed only via such queries .",
    "a @xmath2-query quantum algorithm has the form @xmath84 , where the @xmath85 are fixed unitary transformations , independent of @xmath5 .",
    "this @xmath55 depends on @xmath5 via the @xmath2 applications of @xmath86 .",
    "the algorithm starts in initial @xmath65-qubit state @xmath87 and its _ output _ is the result of measuring a dedicated part of the final state @xmath88 . for a boolean function @xmath3 , the output of @xmath55",
    "is obtained by observing the leftmost qubit of the final superposition @xmath88 , and its _ acceptance probability _ on input @xmath5 is its probability of outputting 1 .",
    "we mention some well known quantum algorithms that we use as subroutines .    * * quantum search .",
    "* grover s search algorithm  @xcite can find an index of a 1-bit in an @xmath1-bit input in expected number of @xmath89 queries , where @xmath42 is the hamming weight ( number of ones ) in the input .",
    "if @xmath42 is known , the algorithm can be made to find the index in exactly @xmath89 queries , instead of the expected number  @xcite . by repeated search",
    ", we can find @xmath6 ones in an @xmath1-bit input with @xmath48 , using @xmath90 queries .",
    "* * quantum counting *  ( * ? ? ?",
    "* theorem 13 ) .",
    "there is a quantum algorithm that uses @xmath91 queries to @xmath1-bit @xmath5 to compute an estimate @xmath92 of @xmath42 such that with probability at least @xmath93 @xmath94    for investigating time - space tradeoffs we use the circuit model .",
    "a circuit accesses its input via an oracle like a query algorithm .",
    "time corresponds to the number of gates in the circuit .",
    "we will , however , usually consider the number of queries to the input , which is obviously a lower bound on time . a circuit uses space @xmath65 if it works with @xmath65 bits / qubits only .",
    "we require that the outputs are made at predefined gates in the circuit , by writing their value to some extra bits / qubits that may not be used later on .",
    "the main result of this paper is the following theorem .    [",
    "thsdpt2sided ] there is a constant @xmath37 such that for every symmetric @xmath3 and every positive integer @xmath0 : every 2-sided error quantum algorithm with @xmath51 queries for computing @xmath33 has success probability @xmath36 .",
    "let us first say something about @xmath95 for a symmetric function @xmath96 .",
    "let @xmath6 denote the smallest nonnegative integer such that @xmath3 is constant on the interval @xmath97 $ ] .",
    "we call this value @xmath6 the `` implicit threshold '' of @xmath3 . for instance , functions like or and and have @xmath98 , while parity and majority have @xmath99 .",
    "if @xmath3 is the @xmath6-threshold function , then the implicit threshold is just the threshold .",
    "the implicit threshold is related to the parameter @xmath100 introduced by paturi  @xcite via @xmath101 .",
    "it characterizes the bounded - error quantum query complexity of @xmath3 : @xmath50  @xcite .",
    "hence our resource bound in the above theorem will be @xmath102 for some small constant @xmath37 .",
    "we actually prove a stronger statement , applying to any boolean function @xmath3 ( total or partial ) for which @xmath103 if @xmath104 and @xmath47 if @xmath105 . in this section",
    "we give an outline of the proof .",
    "most of the proofs of technical claims are deferred to .",
    "let @xmath106 be an algorithm that computes @xmath0 instances of this weight-@xmath107 versus weight-@xmath6 problem .",
    "we recast @xmath106 into a different form , using a register that stores the input @xmath108 .",
    "let @xmath109 be the hilbert space on which @xmath106 operates .",
    "let @xmath110 be an @xmath111-dimensional hilbert space whose basis states correspond to inputs @xmath112 with hamming weights @xmath113 .",
    "we transform @xmath106 into a sequence of transformations on a hilbert space @xmath114 .",
    "a non - query transformation @xmath115 on @xmath109 is replaced with @xmath116 on @xmath117 .",
    "a query is replaced by a transformation @xmath118 that is equal to @xmath119 on the subspace consisting of states of the form @xmath120 .",
    "the starting state of the algorithm on hilbert space @xmath117 is @xmath121 where @xmath122 is the starting state of @xmath106 as an algorithm acting on @xmath109 and @xmath123 is a tensor product of @xmath0 copies of the state @xmath124 in which half of the weight is on @xmath125 with @xmath105 , the other half is on @xmath125 with @xmath104 , and any two states @xmath125 with the same @xmath42 have equal amplitudes : @xmath126 let @xmath127 be the state of the algorithm @xmath106 , as a sequence of transformations on @xmath117 , after the @xmath128-th query .",
    "let @xmath129 be the mixed state in @xmath110 obtained from @xmath127 by tracing out the @xmath109 register .",
    "we define two decompositions of @xmath110 into a direct sum of subspaces .",
    "we have @xmath130 where @xmath131 is the input hilbert space for one instance , with basis states @xmath125 , @xmath132 . let @xmath133 and let @xmath134 be a similar state with @xmath135 instead of @xmath136 .",
    "let @xmath137 ( resp .",
    "@xmath138 ) be the space spanned by all states @xmath139 ( resp .",
    "@xmath140 ) and let @xmath141 . for a subspace @xmath65",
    ", we use @xmath142 to denote the projector onto @xmath65 .",
    "let @xmath143 .",
    "for @xmath144 , let @xmath145 be the subspace spanned by the states @xmath146 and @xmath147 be the subspace spanned by @xmath148 for @xmath149 , we define @xmath150 and there is no subspace @xmath151 .",
    "thus @xmath152 .",
    "let us try to give some intuition . in the spaces @xmath153 and @xmath154 , we may be said to `` know '' the positions of @xmath155 of the ones .",
    "in the @xmath154 subspaces we have distinguished the 0-inputs from 1-inputs by the relative phase , while in the @xmath153 subspace we have not distinguished them .",
    "accordingly , the algorithm is doing well on this one instance if most of the state sits in the `` good '' subspaces @xmath154 .    for the space @xmath110",
    "( representing @xmath0 independent inputs for our function ) and @xmath156 , we define @xmath157 let @xmath158 be the direct sum of all @xmath159 such that exactly @xmath160 of the signs @xmath161 are equal to @xmath162 .",
    "then @xmath163 .",
    "this is the first decomposition .",
    "the above intuition for one instance carries over to @xmath0 instances : the more minuses the better for the algorithm .",
    "conversely , if most of the input register sits in @xmath164 for low @xmath160 , then its success probability will be small .",
    "more precisely , in we prove :    [ lem : prob ] let @xmath165 be the reduced density matrix of @xmath110 . if the support of @xmath165 is contained in @xmath166 , then the probability that measuring @xmath109 gives the correct answer is at most @xmath167 .",
    "note that this probability is exponentially small in @xmath0 for , say , @xmath168 .",
    "the following consequence of this lemma is proven in :    [ cor : prob ] let @xmath165 be the reduced density matrix of @xmath110 . the probability that measuring @xmath109 gives",
    "the correct answer is at most @xmath169    to define the second decomposition , we express @xmath170 with @xmath171 for @xmath172 and @xmath173 intuitively , all subspaces except for @xmath174 are `` bad '' for the algorithm , since they equal the `` bad '' @xmath153 subspaces .",
    "let @xmath175 be the direct sum of all @xmath176 satisfying @xmath177",
    ". then @xmath178 .",
    "this is the second decomposition .",
    "intuitively , the algorithm can only have good success probability if for most of the @xmath0 instances , most of the input register sits in @xmath174 .",
    "aggregated over all @xmath0 instances , this means that the algorithm will only work well if most of the @xmath0-input register sits in @xmath175 for @xmath179 large , meaning fairly close to @xmath180 .",
    "our goal below is to show that this can not happen if the number of queries is small .",
    "let @xmath181 .",
    "note that @xmath182 for every @xmath160 : @xmath158 is the direct sum of subspaces @xmath183 having @xmath160 minuses among @xmath184 ; each such minus - subspace sits in the corresponding @xmath174 and hence @xmath185 .",
    "this implies @xmath186 accordingly , if we prove an upper bound on @xmath187 , where @xmath2 is the total number of queries , this bound together with implies an upper bound on the success probability of @xmath106 . to bound @xmath187 , we consider the following potential function @xmath188 where @xmath189",
    ". then for every @xmath128 @xmath190    @xmath191 , because the initial state @xmath192 is a tensor product of the states @xmath124 on each copy of @xmath131 and @xmath124 belongs to @xmath193 , hence @xmath192 belongs to @xmath194 . in",
    "we prove    [ lem : onestep ] there is a constant @xmath195 such that @xmath196    since @xmath189 , means that @xmath197 and @xmath198 . by equation , for the final state after @xmath2 queries",
    "we have @xmath199 we take @xmath168 . then if @xmath200 , this expression is exponentially small in @xmath0 .",
    "together with , this implies the theorem .",
    "the previous section used the adversary method to prove a direct product theorem for 2-sided error algorithms computing @xmath0 instances of some symmetric function . in this section",
    "we use the polynomial method to obtain stronger direct product theorems for 1-sided error algorithms for threshold functions .",
    "an algorithm for @xmath33 has 1-sided error if the 1 s in its @xmath0-bit output vector are always correct .",
    "our use of polynomials is a relatively small extension of the argument in  @xcite .",
    "we use three results about polynomials , also used in  @xcite .",
    "the first is by coppersmith and rivlin   and gives a general bound for polynomials bounded by 1 at integer points :    [ coppersmith &  rivlin  ] [ thcopprivlin ] every polynomial @xmath201 of degree @xmath202 that has absolute value @xmath203,\\ ] ] satisfies @xmath204,\\ ] ] where @xmath205 are universal constants ( no explicit values for @xmath206 and @xmath67 are given in  ) .",
    "the other two results concern the chebyshev polynomials @xmath207 , defined as in  @xcite : @xmath208 @xmath207 has degree @xmath128 and its absolute value @xmath209 is bounded by 1 if @xmath210 $ ] . on the interval @xmath211",
    ", @xmath207 exceeds all others polynomials with those two properties ( @xcite and  ( * ? ? ?",
    "* fact  2 ) ) :    [ thchebextremal ] if @xmath212 is a polynomial of degree @xmath128 such that @xmath213 for all @xmath210 $ ] then @xmath214 for all @xmath215 .",
    "[ paturi  @xcite ] [ lemchebbound ] @xmath216 for all @xmath217 .    for @xmath218",
    ": @xmath219 .",
    "the following lemma is key .",
    "it analyzes polynomials that are 0 on the first @xmath160 integer points , and that significantly `` jump '' a bit later .",
    "[ lem : keypol ] suppose @xmath220 are integers satisfying @xmath221 , and let @xmath201 be a degree-@xmath222 polynomial such that    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "@xmath223 for all @xmath224 , + @xmath225 , + @xmath226 $ ] for all @xmath227 . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    then @xmath228 .",
    "divide @xmath201 by @xmath229 to obtain @xmath230 where @xmath231 .",
    "this implies the following about the values of the polynomial @xmath212 : @xmath232{theorem~\\ref*{thcopprivlin } } } implies that there are constants $ a , b>0 $ such that \\medskip }    & & \\mbox{for all real $ x\\in[e m , n]$}.\\end{aligned}\\ ] ] we now divide @xmath212 by @xmath233 to normalize it , and rescale the interval @xmath234 $ ] to @xmath235 $ ] to get a degree-@xmath128 polynomial @xmath6 satisfying @xmath236{theorem~\\ref*{thchebextremal } } } and { \\hyperref[lemchebbound]{lemma~\\ref*{lemchebbound } } } imply\\medskip }   t(1+\\mu ) & \\leq & e^{2d\\sqrt{2\\mu+\\mu^2}}.\\end{aligned}\\ ] ] combining our upper and lower bounds on @xmath237 gives @xmath238 which implies the lemma .",
    "[ thsdpt1sided ] there exists @xmath37 such that for every threshold function @xmath239 and positive integer @xmath0 : every 1-sided error quantum algorithm with @xmath240 queries for computing @xmath241 has success probability @xmath52 .",
    "we assume without loss of generality that @xmath242 , the other cases can easily be reduced to this .",
    "we know that @xmath243  @xcite .",
    "consider a quantum algorithm @xmath55 with @xmath244 queries that computes @xmath33 with success probability @xmath38 .",
    "roughly speaking , we use @xmath55 to solve one big threshold problem on the total input , and then invoke the polynomial lemma to upper bound the success probability .",
    "define a new quantum algorithm @xmath233 on an input @xmath5 of @xmath245 bits , as follows : @xmath233 runs @xmath55 on a random permutation @xmath246 , and then outputs 1 iff the @xmath0-bit output vector has at least @xmath247 ones .    let @xmath248 .",
    "note that if @xmath249 , then @xmath233 always outputs 0 because the 1-sided error output vector must have fewer than @xmath247 ones .",
    "now suppose @xmath250 .",
    "call an @xmath1-bit input block `` full '' if @xmath246 contains at least @xmath6 ones in that block .",
    "let @xmath251 be the random variable counting how many of the @xmath0 blocks are full .",
    "we claim that @xmath252\\geq 1/9 $ ] . to prove this ,",
    "observe that the number @xmath233 of ones in one fixed block is a random variable distributed according to a hypergeometric distribution ( @xmath253 balls into @xmath60 boxes , @xmath1 of which count as success ) with expectation @xmath254 and variance @xmath255 .",
    "using chebyshev s inequality we bound the probability that this block is not full : @xmath256 & \\leq { \\mathrm{pr}}[|b-\\mu|>3 t]\\leq { \\mathrm{pr}}[|b-\\mu|>(3\\sqrt{t}/2)\\sqrt{v}]\\\\           & < \\frac{1}{(3\\sqrt{t}/2)^2}\\leq \\frac{4}{9}.\\end{aligned}\\ ] ] hence the probability that the block is full ( @xmath257 ) is at least @xmath258 .",
    "this is true for each of the @xmath0 blocks , so using linearity of expectation we have @xmath259 \\leq { \\mathrm{pr}}[f\\geq k/2]\\cdot k + ( 1-{\\mathrm{pr}}[f\\geq k/2])\\cdot\\frac{k}{2}.\\ ] ] this implies @xmath252\\geq 1/9 $ ] , as claimed .",
    "but then on all inputs with @xmath260 , @xmath233 outputs 1 with probability at least @xmath261 .",
    "algorithm @xmath233 uses @xmath262 queries . by  @xcite and symmetrization ,",
    "@xmath233 s acceptance probability is a single - variate polynomial @xmath201 of degree @xmath263 such that    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "@xmath223 for all @xmath224 , + @xmath264 , + @xmath226 $ ] for all @xmath227 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the result now follows by applying with @xmath245 , @xmath248 , @xmath265 , and @xmath266 a sufficiently small positive constant .",
    "let @xmath55 be a fixed @xmath267 matrix of nonnegative integers and let @xmath268 be two input vectors of @xmath60 nonnegative integers smaller or equal to @xmath6 .",
    "a _ matrix - vector product with upper bound _ , denoted by @xmath269 , is a vector @xmath7 such that @xmath270 , b_i)$ ] .",
    "an _ evaluation of a system of linear inequalities @xmath271 _ is the @xmath60-bit vector of the truth values of the individual inequalities . here",
    "we present a quantum algorithm for matrix - vector product with upper bound that satisfies time - space tradeoff @xmath272 .",
    "we then use our direct product theorems to show this is close to optimal .",
    "it is easy to prove that matrix - vector products with upper bound @xmath6 can be computed by a classical algorithm with @xmath273 , as follows .",
    "let @xmath274 and divide the matrix @xmath55 into @xmath275 blocks of size @xmath276 each .",
    "the output vector is evaluated row - wise as follows : ( 1 ) clear @xmath277 counters , one for each row , and read @xmath278 . ( 2 ) for each block , read @xmath277 input variables , multiply them by the corresponding submatrix of @xmath55 , and update the counters , but do not let them grow larger than @xmath278 .",
    "( 3 ) output the counters .",
    "the space used is @xmath279 and the total query complexity is @xmath280 .",
    "the quantum algorithm bounded matrix product works in a similar way and it is outlined in .",
    "we compute the matrix product in groups of @xmath281 rows , read input variables , and update the counters accordingly .",
    "the advantage over the classical algorithm is that we use the faster quantum search and quantum counting for finding non - zero entries .",
    "the @xmath282-th row is called _ open _ if its counter hasnt yet reached @xmath283 .",
    "the subroutine small matrix product maintains a set of open rows @xmath284 and counters @xmath285 for all @xmath286 .",
    "we process the input @xmath5 in blocks , each containing between @xmath287 and @xmath288 non - zero numbers at the positions @xmath155 where @xmath289 \\ne 0 $ ] for some @xmath290 .",
    "the length @xmath179 of such a block is first found by iterated quantum counting ( with number of queries specified in the proof below ) and the non - zero input numbers are then found by a grover search . for each such number , we update all counters @xmath291 and close all rows that exceeded their threshold @xmath283 .    bounded matrix product ( fixed matrix @xmath292 , threshold @xmath6 , input vectors @xmath5 and @xmath67 of length @xmath60 ) + returns output vector @xmath293 :    * for @xmath294 , where @xmath281 : 1 .",
    "run small matrix product on the @xmath295-th block of @xmath277 rows of @xmath55 .",
    "2 .   output the @xmath277 obtained results for those rows .",
    "small matrix product ( fixed @xmath296 , input @xmath297 and @xmath298 ) returns @xmath299 :    1 .",
    "initialize @xmath300 , @xmath301 , @xmath302 , and read @xmath67 .",
    "let @xmath303 denote an on - line computed row - vector with @xmath304 if @xmath305=1 $ ] for some @xmath286 , and @xmath306 otherwise .",
    "2 .   while @xmath307 and @xmath308 , do the following : 1 .",
    "let @xmath309 denote an estimate of the scalar product @xmath310 initialize @xmath311 .",
    "first , while @xmath312 and @xmath313 , double @xmath0 .",
    "second , find by binary search the maximal @xmath314 $ ] such that @xmath315 and @xmath316 .",
    "2 .   use quantum search to find the set @xmath317 of all positions @xmath318 $ ] such that @xmath319 .",
    "3 .   for all @xmath320 , read @xmath321 , and then do the following for all @xmath286 : * increase @xmath291 by @xmath289 x_j$ ] . * if @xmath322 , set @xmath323 and remove @xmath282 from @xmath115 .",
    "4 .   increase @xmath201 by @xmath179 .",
    "3 .   return @xmath7 .",
    "[ thm : matrixproduct ] bounded matrix product has bounded error probability , its space complexity is @xmath324 , and its query complexity is @xmath325 .",
    "the space complexity of small matrix product is @xmath326 , because it stores a subset @xmath284 , integer vectors @xmath327 of length @xmath277 with numbers at most @xmath328 , the set @xmath317 of size @xmath329 with numbers at most @xmath60 , and a few counters .",
    "let us compute its query complexity .",
    "consider the @xmath295-th block found by small matrix product ; let @xmath330 be its left column , let @xmath331 be its length , and let @xmath332 be the set of open rows at the beginning of processing of this block .",
    "the scalar product @xmath333 is estimated by quantum counting with @xmath334 queries .",
    "finding a proper @xmath331 requires @xmath335 iterations .",
    "let @xmath336 be the number of rows closed during processing of this block and let @xmath337 be the total number added to the counters for other ( still open ) rows in this block .",
    "the numbers @xmath338 are random variables .",
    "if we instantiate them at the end of the quantum subroutine , the following inequalities hold : @xmath339 the iterated grover search finds ones for two purposes : closing rows and increasing counters . since each @xmath340",
    ", the total cost in the @xmath295-th block is at most @xmath341 by a cauchy - schwarz inequality , the total number of queries that small matrix product spends in the grover searches is at most @xmath342 the error probability of the grover searches can be made polynomially small in a logarithmic overhead .",
    "it remains to analyze the outcome and error probability of quantum counting .",
    "let @xmath343 $ ] .",
    "one quantum counting call with @xmath334 queries gives an estimate @xmath92 such that @xmath344 with probability at least @xmath345 .",
    "we do it @xmath346 times and take the median , hence we obtain an estimate @xmath347 of @xmath348 with accuracy @xmath349 with polynomially small error probability .",
    "the result of quantum counting is compared with the given threshold , that is with @xmath277 or @xmath350 . binary search for @xmath314",
    "$ ] costs another factor of @xmath351 . by a cauchy - schwarz inequality ,",
    "the total number of queries spent in the quantum counting is at most @xmath352 times @xmath353 because in every block the algorithm closes a row or adds @xmath354 in total to the counters .",
    "the number of closed rows is at most @xmath277 and the number @xmath277 can be added at most @xmath6 times .",
    "the total query complexity of small matrix product is thus @xmath355 and the query complexity of bounded matrix product is @xmath356-times bigger .",
    "the overall error probability is at most the sum of the polynomially small error probabilities of the different subroutines , hence it can be kept below @xmath357 .",
    "here we use our direct product theorems to lower - bound the quantity @xmath358 for @xmath2-query , @xmath65-space quantum algorithms for systems of linear inequalities .",
    "the lower bound even holds if we fix @xmath67 to the all-@xmath6 vector @xmath359 and let @xmath55 and @xmath5 be boolean .",
    "let @xmath360 .",
    "there exists an @xmath56 boolean matrix @xmath55 such that every 2-sided error quantum algorithm that uses @xmath2 queries and @xmath65 qubits of space to decide a system @xmath361 of @xmath60 inequalities , satisfies @xmath362 .",
    "the proof is a modification of theorem  22 of  @xcite ( quant - ph version ) .",
    "they use the probabilistic method to establish the following    * fact : * for every @xmath363 , there exists an @xmath56 boolean matrix @xmath55 , such that all rows of @xmath55 have weight @xmath364 , and every set of @xmath0 rows of @xmath55 contains a set @xmath365 of @xmath247 rows with the following property : each row in @xmath365 contains at least @xmath366 ones that occur in no other row of @xmath365 .    fix a matrix @xmath55 for @xmath367 , for some constant @xmath368 to be chosen later . consider a quantum circuit with @xmath2 queries and space @xmath65 that solves the problem with success probability at least @xmath369 .",
    "we `` slice '' the quantum circuit into disjoint consecutive slices , each containing @xmath370 queries , where @xmath266 is the constant from our direct product theorem ( ) .",
    "the total number of slices is @xmath371 .",
    "together , these disjoint slices contain all @xmath60 output gates .",
    "our aim below is to show that with sufficiently small constant @xmath266 and sufficiently large constant @xmath368 , no slice can produce more than @xmath0 outputs .",
    "this will imply that the number of slices is @xmath372 , hence @xmath373    now consider any slice .",
    "it starts with an @xmath65-qubit state that is delivered by the previous slice and depends on the input , then it makes @xmath374 queries and outputs some @xmath179 results that are jointly correct with probability at least @xmath369 .",
    "suppose , by way of contradiction , that @xmath375 .",
    "then there exists a set of @xmath0 rows of @xmath55 such that our slice produces the @xmath0 corresponding results ( @xmath6-threshold functions ) with probability at least @xmath369 . by the above fact",
    ", some set @xmath365 of @xmath247 of those rows has the property that each row in @xmath365 contains a set of @xmath376 ones that do not occur in any of the @xmath377 other rows of @xmath365 . by setting all other @xmath378 bits of @xmath5 to 0",
    ", we naturally get that our slice , with the appropriate @xmath65-qubit starting state , solves @xmath247 independent @xmath6-threshold functions @xmath239 on @xmath1 bits each .",
    "( note that we need @xmath379 ; this follows from our assumption @xmath380 with appropriately small constant in the @xmath381 . )",
    "now we replace the initial @xmath65-qubit state by the completely mixed state , which has `` overlap '' @xmath382 with every @xmath65-qubit state .",
    "this turns the slice into a stand - alone algorithm solving @xmath383 with success probability @xmath384 but this algorithm uses only @xmath385 queries , so our direct product theorem ( ) with sufficiently small constant @xmath266 implies @xmath386 choosing @xmath368 a sufficiently large constant ( independent of this specific slice ) , our upper and lower bounds on @xmath38 contradict .",
    "hence the slice must produce fewer than @xmath0 outputs .",
    "it is easy to see that the case @xmath387 ( equivalently , @xmath388 ) is at least as hard as the @xmath389 case , for which we have the lower bound @xmath390 , hence @xmath391 . but that lower bound matches the _ classical _ deterministic upper bound up to a logarithmic factor and hence is essentially tight also for quantum .",
    "we thus have two different regimes for space : for small space , a quantum computer is faster than a classical one in solving systems of linear inequalities , while for large space it is not .",
    "a similar slicing proof using ( with each slice of @xmath392 queries producing at most @xmath393 outputs ) gives the following lower bound on time - space tradeoffs for 1-sided error algorithms .",
    "let @xmath394 .",
    "there exists an @xmath56 boolean matrix @xmath55 such that every 1-sided error quantum algorithm that uses @xmath2 queries and @xmath65 qubits of space to decide a system @xmath361 of @xmath60 inequalities , satisfies @xmath395 .",
    "note that our lower bound @xmath396 for 1-sided error algorithms is higher by a factor of @xmath6 than the best upper bounds for 2-sided error algorithms .",
    "this lower bound is probably not optimal . if @xmath75 then the essentially optimal classical tradeoff @xmath391 takes over .",
    "in this paper we described a new version of the adversary method for quantum query lower bounds , based on analyzing the eigenspace structure of the problem we want to lower bound .",
    "we proved two new quantum direct product theorems , the first using the new adversary method , the second using the polynomial method :    * for every symmetric function @xmath3 , every 2-sided error quantum algorithm for @xmath33 using fewer than @xmath397 queries has success probability at most @xmath54 . * for every @xmath6-threshold function @xmath3 , every 1-sided error quantum algorithm for @xmath33 using fewer than @xmath397 queries has success probability at most @xmath53 .",
    "both results are tight up to constant factors . from these results we derived the following time - space tradeoffs for quantum algorithms that decide a system @xmath76 of @xmath60 linear inequalities ( where @xmath55 is a fixed @xmath56 matrix of nonnegative integers , @xmath398 are variable , and @xmath399 for all @xmath295 ) :    * every @xmath2-query",
    ", @xmath65-space 2-sided error quantum algorithm for evaluating @xmath76 satisfies @xmath400 if @xmath69 , and satisfies @xmath391 if @xmath71 .",
    "we gave an algorithm matching these bounds up to polylog factors .",
    "* every @xmath2-query , @xmath65-space 1-sided error quantum algorithm for evaluating @xmath76 satisfies @xmath401 if @xmath73 , and satisfies @xmath391 if @xmath75 .",
    "we do not have a matching algorithm in the first case and conjecture that this bound is not tight .",
    "10    s.  aaronson and y.  shi .",
    "quantum lower bounds for the collision and the element distinctness problems , 51(4):595605 , 2004    s.  aaronson .",
    "limitations of quantum advice and one - way communication . in _ proc .  of 19th",
    "conference on computational complexity _ , p.  320332 , 2004 .",
    "a.  ambainis .",
    "quantum lower bounds by quantum arguments . in _ proc .  of 32nd stoc _ , p.  636643 , 2000 .",
    "a.  ambainis .",
    "polynomial degree vs quantum query complexity . in _ proc .  of 44th focs _",
    ", p.  30239",
    ", 2003 .",
    "a.  ambainis .",
    "quantum walk algorithm for element distinctness . in _ proc .  of 45st focs _ , p.  2231 , 2004 .",
    "a.  ambainis . a new quantum lower bound method , with an application to strong direct product theorem for quantum search .",
    "quant - ph/0508200 , 26 aug 2005 .    h.  barnum , m.  saks , and m.  szegedy . quantum query complexity and semi - definite programming . in _ proc .",
    "of 18th conference on computational complexity _ , p.  179193",
    ", 2003 .",
    "r.  beals , h.  buhrman , r.  cleve , m.  mosca , and r.  de wolf .",
    "quantum lower bounds by polynomials . , 48(4):778797 , 2001 .",
    "e.  bernstein and u.  vazirani .",
    "quantum complexity theory .",
    ", 26(5):14111473 , 1997 .",
    "m.  boyer , g.  brassard , p.  hyer , and a.  tapp .",
    "tight bounds on quantum searching . , 46(45):493505 , 1998 .",
    "g.  brassard , p.  hyer , m.  mosca , and a.  tapp . quantum amplitude amplification and estimation . in _ quantum computation and quantum information : a millennium volume _ , volume 305 of _ ams contemporary mathematics series _ , p.  5374 .",
    "h.  buhrman , r.  cleve , r.  de wolf , and c.  zalka .",
    "bounds for small - error and zero - error quantum algorithms . in _ proc .  of 40th focs _ , p.  358368 , 1999 .",
    "h.  buhrman and r.  de wolf .",
    "complexity measures and decision tree complexity : a survey .",
    ", 288(1):2143 , 2002 .",
    "d.  coppersmith and t.  j. rivlin .",
    "the growth of polynomials bounded at equally spaced points .",
    ", 23(4):970983 , 1992 .",
    "e.  farhi , j.  goldstone , s.  gutmann , and m.  sipser .",
    "a limit on the speed of quantum computation in determining parity .",
    ", 81:54425444 , 1998 .",
    "r.  l. graham , d.  e. knuth , and o.  patashnik . .",
    "addison - wesley , second edition , 1994 .",
    "l.  k. grover . a fast quantum mechanical algorithm for database search . in _ proc .  of 28th stoc _ , p.  212219",
    ", 1996 .",
    "p.  hyer , m.  mosca , and r.  de wolf .",
    "quantum search on bounded - error inputs . in _ proc .  of 30th icalp03 _ ,",
    "volume 2719 of _ lncs _ , p.  291299 .",
    "springer , 2003 .",
    "p.  hyer , j.  neerbek , and y.  shi .",
    "quantum complexities of ordered searching , sorting , and element distinctness . , 34(4):429448 , 2002 .",
    "h.  klauck , r.  palek , and r.  de wolf .",
    "quantum and classical strong direct product theorems and optimal time - space tradeoffs . in _ proc .  of 45th focs _ , p.  1221",
    ", 2004 .",
    "s.  laplante and f.  magniez .",
    "lower bounds for randomized and quantum query complexity using kolmogorov arguments .",
    "in _ proc .  of 19th conference on computational complexity _ , p.  294304",
    ", 2004 .",
    "f.  magniez , m.  santha , and m.  szegedy .",
    "quantum algorithms for the triangle problem . in _ proc .  of 16th soda _ , p.  11091117",
    ", 2005 .",
    "m.  a. nielsen and i.  l. chuang . .",
    "cambridge university press , 2000 .",
    "n.  nisan and m.  szegedy . on the degree of boolean functions as real polynomials .",
    ", 4(4):301313 , 1994 .    r.  paturi . on the degree of polynomials that approximate symmetric boolean functions . in _ proc .  of 24th stoc _ , p.  468474",
    ", 1992 .",
    "a.  razborov .",
    "quantum communication complexity of symmetric predicates .",
    ", 67(1):159176 , 2003 .",
    "t.  j. rivlin . .",
    "wiley - interscience , second edition , 1990 .",
    "r.  shaltiel . towards proving strong direct product theorems . in _ proc .  of 16th conference on computational complexity _ , p.  107119",
    ", 2001 .",
    "r.  palek and m.  szegedy .",
    "all quantum adversary methods are equivalent . , 2(1):118 , 2006 .    s.  zhang . on the power of ambainis",
    "s lower bounds .",
    ", 339(23):241256,2005 .",
    "@xmath402      the measurement of @xmath109 decomposes the state in the @xmath110 register as follows : @xmath403 with @xmath404 being the probability of the measurement giving the answer @xmath405 ( where @xmath406 means the algorithm outputs  not necessarily correctly  that @xmath407 and @xmath306 means @xmath408 ) and @xmath409 being the density matrix of @xmath110 , conditional on this outcome of the measurement . since the support of @xmath165 is contained in @xmath410 , the support of the states @xmath409 is also contained in @xmath410 .",
    "the probability that the answer @xmath405 is correct is equal to @xmath411 we show that , for any @xmath409 with support contained in @xmath412 , is at most @xmath413 .    for brevity ,",
    "we now write @xmath38 instead of @xmath409 . a measurement w.r.t .",
    "@xmath414 and its orthogonal complement commutes with a measurement w.r.t .",
    "the collection of subspaces @xmath415 where @xmath416 range over @xmath417 .",
    "therefore @xmath418 hence to bound it suffices to prove the same bound with @xmath419 instead of @xmath38 .",
    "since @xmath420 we have @xmath421 we prove this bound for the case when @xmath422 is a pure state : @xmath423 .",
    "then equation   is equal to @xmath424 the bound for mixed states @xmath422 follows by decomposing @xmath422 as a mixture of pure states @xmath425 , bounding for each of those states and then summing up the bounds .",
    "let @xmath432 , @xmath433 $ ] form a basis for the subspace @xmath434 .",
    "define a map @xmath435 by @xmath436 .",
    "then @xmath437 is a multiple of a unitary transformation : @xmath438 for some unitary @xmath439 and a constant @xmath440 .",
    "( this follows from in . )",
    "let @xmath441 . since @xmath442 is a unitary transformation , the states @xmath443 form a basis for @xmath444 .",
    "therefore @xmath445 is a basis for @xmath446 .",
    "moreover , the states @xmath447 are a basis for @xmath448 and @xmath449 , respectively .",
    "therefore @xmath450 the inner product between @xmath451 and @xmath452 is @xmath453 note that @xmath454 and @xmath455 .",
    "the terms in this product are @xmath456 if @xmath457 and 0 otherwise .",
    "this means that @xmath452 has inner product @xmath458 with @xmath459 and inner product 0 with all other basis states .",
    "therefore , @xmath460 together with equation , this means that @xmath461 squaring both sides completes the proof of the claim .",
    "the success probability of @xmath106 is the probability that , if we measure both the register @xmath109 containing the result of the computation and @xmath110 , then we get @xmath474 and @xmath108 such that @xmath475 contains @xmath476 ones for every @xmath477 .",
    "consider the probability of getting @xmath478 and @xmath479 with this property , when measuring @xmath469 ( instead of @xmath425 ) . by , this probability is at most @xmath413 .",
    "we have @xmath480 we now apply    [ ] [ lem : bv ] for any states @xmath425 and @xmath469 and any measurement @xmath91 , the variational distance between the probability distributions obtained by applying @xmath91 to @xmath425 and @xmath469 is at most @xmath481 .",
    "let @xmath483 be the state of @xmath484 after @xmath128 queries .",
    "write @xmath485 with @xmath486 being the part in which the query register contains @xmath487 .",
    "let @xmath488 .",
    "then @xmath489 because of @xmath490 we have @xmath491 .",
    "let @xmath492 be the state after the @xmath128-th query and let @xmath493 be a decomposition similar to equation",
    ". follows by showing @xmath494 for each @xmath295 . for @xmath495",
    ", the query does not change the state if the query register contains @xmath487 .",
    "therefore , @xmath496 and @xmath497 .",
    "this means that equation is true for @xmath495 . to prove the @xmath498 case",
    ", it suffices to prove the @xmath499 case ( because of symmetry ) .",
    "let @xmath500 ( with @xmath501 and @xmath502 ) be the uniform superposition over basis states @xmath503 ( of @xmath131 ) with @xmath504 and @xmath505 .",
    "let @xmath506 be the space spanned by all states @xmath500 and let @xmath507 .",
    "let @xmath508 .        for part ( i ) , consider the states @xmath515 in @xmath516 , for @xmath517 .",
    "we have @xmath518 because among the states @xmath519 with @xmath520 and @xmath505 , a @xmath521 fraction have @xmath522 and the rest have @xmath523 .",
    "the projections of these states to @xmath524 are @xmath525 which , by equation ( [ eq-2507 ] ) are exactly the states spanning @xmath526 .",
    "furthermore , we claim that @xmath527 the first containment is true because @xmath528 is spanned by the states @xmath529 which either belong to @xmath530 ( if @xmath531 ) or are a linear combination of states @xmath532 and @xmath533 ( by equation  ( [ eq - new ] ) ) , which belong to @xmath534 and @xmath535 . the second containment follows because the states @xmath536 spanning @xmath535 are the same as the states @xmath537 which belong to @xmath516 , and the states @xmath538 spanning @xmath534 can be expressed as linear combinations of @xmath529 and @xmath537 which both belong to @xmath516 .",
    "the first part of ( [ eq-2707 ] ) now implies @xmath539 also , @xmath540 , because @xmath526 is spanned by the states @xmath541 and @xmath515 belongs to @xmath516 by the definition of @xmath516 and @xmath542 belongs to @xmath516 because of the second part of ( [ eq-2707 ] ) .",
    "therefore , @xmath543 .",
    "for part ( ii ) , we have @xmath544 where the first containment is true because @xmath526 is spanned by linear combinations of vectors @xmath545 ( which belong to @xmath546 ) and vectors @xmath547 ( which belong to @xmath548 ) and the last containment is true because of the second part of equation ( [ eq-2707 ] ) .",
    "now let @xmath549 be one of the vectors spanning @xmath550 . to prove that @xmath425 is in @xmath551 , it remains to prove that @xmath425 is orthogonal to @xmath516 .",
    "this is equivalent to proving that @xmath425 is orthogonal to each of the vectors @xmath552 spanning @xmath516 .",
    "we distinguish two cases ( note that @xmath553 ) :      for simplicity , assume @xmath555 .",
    "then @xmath552 is the same as @xmath556 , which belongs to @xmath535 . by definition",
    ", the vector @xmath425 belongs to @xmath524 and is therefore orthogonal to @xmath556 .        in the base step @xmath559 ) , we have @xmath560 .",
    "since @xmath425 belongs to @xmath524 , it suffices to prove @xmath425 is orthogonal to the projection of @xmath515 to @xmath524 which , by the discussion after equation ( [ eq - new ] ) , equals @xmath561 from equations ( [ eq-2707a ] ) and ( [ eq-2707b ] ) , we see that the inner product of the two states is @xmath562",
    ".    for the inductive step ( @xmath563 ) , assume @xmath564 . up to renormalization",
    ", we have @xmath565 because @xmath566 is in @xmath567 , we have @xmath568 as proven in the previous case , @xmath569",
    ". moreover , by the induction hypothesis we have @xmath570 whenever @xmath571 . therefore equation ( [ eq - new0 ] ) reduces to @xmath572 by symmetry , the inner products in this sum are the same for every @xmath573",
    ". hence they are all 0 , in particular for @xmath574 .",
    "we define @xmath582 by @xmath583 note that @xmath91 does not depend on @xmath155 .",
    "we claim @xmath584 for some constants @xmath368 and @xmath585 that may depend on @xmath586 and @xmath155 but not on @xmath587 . to prove that , we need to prove two things .",
    "first , we claim that @xmath588 where @xmath589 ( note that @xmath517 ) .",
    "equation   follows by @xmath590 this proves ( [ eq - rem4 ] ) , with @xmath469 equal to the second term .",
    "second , for every @xmath155 , @xmath591 and @xmath592 .",
    "the first statement follows from equation ( [ eq - rem4 ] ) , because the subspaces @xmath593 , @xmath594 are spanned by the states @xmath595 and @xmath596 , respectively , and @xmath597 . to prove the second statement , let @xmath598 , @xmath599 .",
    "we would like to prove @xmath600 .",
    "this is equivalent to @xmath601 for all @xmath587 .",
    "we have @xmath602 the first equality follows by writing out @xmath603 , the second equality follows by writing out @xmath91 .",
    "the third equality follows because , for every @xmath5 with @xmath104 and @xmath505 , there are @xmath604 more @xmath605 $ ] satisfying @xmath606 .",
    "the fourth equality follows because @xmath607 is a constant times @xmath608 , and @xmath609 because @xmath610 .    to deduce equation",
    ", we write @xmath611 since @xmath612 and @xmath613 , @xmath614 with the second equality following from ( [ eq - rem4 ] ) and @xmath615 .",
    "this proves the first half of .",
    "the second half follows similarly .",
    "therefore @xmath616 hence @xmath91 is a multiple of a unitary transformation . by equation , @xmath617 and , therefore , @xmath618 is also a multiple of a unitary transformation .",
    "next , we define @xmath91 by @xmath619 .",
    "then @xmath91 is a unitary transformation from the space spanned by @xmath620 , @xmath621 , to the space spanned by @xmath622 , @xmath623 .",
    "we claim that @xmath624 . to prove that , we first observe that @xmath625 since @xmath506 is defined as the subspace spanned by all @xmath500 , this means that @xmath626 and similarly @xmath627 .",
    "since @xmath91 is unitary , this implies @xmath628 and @xmath629    finally , we have @xmath630 , where @xmath631 is defined by @xmath632 . since @xmath633 is unitary , it suffices to prove that @xmath631 is a multiple of a unitary transformation and this follows similarly to @xmath618 being a multiple of a unitary transformation .",
    "let @xmath634 be an arbitrary state in @xmath635 for some @xmath636 .",
    "define @xmath637 for @xmath638 .",
    "let @xmath639 be vectors from subspaces @xmath640 , for some @xmath641 .",
    "we first analyze the case when @xmath642 belongs to the subspace @xmath643 spanned by @xmath644      1 .",
    "@xmath649 belongs to @xmath145 ; 2 .",
    "@xmath650 belongs to @xmath651 ; 3 .",
    "any linear combination of @xmath634 , @xmath652 , @xmath653 and @xmath654 which is orthogonal to @xmath655 and @xmath656 belongs to @xmath657 .",
    "let @xmath587 be @xmath155 distinct elements of @xmath658 .",
    "as shown in the beginning of the proof of , @xmath659 this means that @xmath660 and @xmath661 since the states @xmath662 span @xmath663 , the state @xmath634 is a linear combination of states @xmath664 .",
    "by , the states @xmath665 are linear combinations of @xmath666 with the same coefficients .",
    "therefore , @xmath655 is a linear combination of @xmath667 @xmath668 each of which , by definition , belongs to @xmath145 .",
    "let @xmath669 be distinct elements of @xmath658 .",
    "we claim @xmath670 by , the right hand side of belongs to @xmath671 .",
    "we need to show that it is equal to @xmath672 .",
    "we have @xmath673 where the third equality follows from @xmath674 .",
    "this is because the states @xmath536 spanning @xmath535 are the same as the states @xmath675 in @xmath516 .",
    "write @xmath676 where @xmath677 by , we have @xmath678 , @xmath679 .",
    "therefore , @xmath680 and @xmath681 proving .      to prove the third part of , we observe that any vector orthogonal to @xmath684 and @xmath656 is a linear combination of @xmath685 which , in turn , is a linear combination of vectors @xmath686 and @xmath687 which is a linear combination of vectors @xmath688 this means that we have @xmath689 and @xmath690 .",
    "define @xmath696 .",
    "we calculate the vector @xmath697 both vector @xmath500 and subspace @xmath698 are fixed by @xmath699 for any permutation @xmath700 that fixes @xmath701 and maps @xmath702 to itself .",
    "hence @xmath703 is fixed by any such @xmath704 as well .",
    "therefore , the amplitude of @xmath125 with @xmath705 , @xmath706 in @xmath703 only depends on @xmath707 , so @xmath703 is of the form @xmath708 by the same constant so that @xmath709",
    ". then @xmath703 remains a multiple of @xmath710 but may no longer be equal to @xmath710 .",
    "@xmath711 should be such that the state is orthogonal to @xmath698 and , in particular , orthogonal to the states @xmath712 for all @xmath713 . by writing out @xmath714 :",
    "@xmath715 to show that , we first note that @xmath712 is a uniform superposition of all @xmath125 with @xmath705 , @xmath706 , @xmath716 .",
    "if we want to choose @xmath5 subject to those constraints and also satisfying @xmath717 , then we have to set @xmath718 for @xmath719 different @xmath720 and for @xmath721 different @xmath722 .",
    "this can be done in @xmath723 and @xmath724 different ways , respectively .    by solving the system of equations ( [ eq - system ] ) ,",
    "starting from @xmath725 and going down to @xmath726 , we get that the only solution is @xmath727 let @xmath728 be the normalized version of @xmath710 .",
    "then @xmath729 we have @xmath730 because @xmath500 consists of @xmath731 basis states @xmath125 , @xmath706 , @xmath505 , each having amplitude @xmath732 in both @xmath710 and @xmath500 .",
    "furthermore , @xmath733 here the first equality follows because there are @xmath734 vectors @xmath5 such that @xmath705 , @xmath706 , @xmath718 for @xmath160 different @xmath735 and @xmath736 different @xmath722 , the second equality follows from equation ( [ eq - solution ] ) and the third equality follows from our choice @xmath709 .",
    "we compute the combinatorial sum @xmath742 using hypergeometric series ( * ? ? ?",
    "* section 5.5 ) . since @xmath743 is a rational function of @xmath160",
    ", @xmath742 is a hypergeometric series and its value is @xmath744 we apply vandermonde s convolution @xmath745 ( * ? ? ?",
    "* equation 5.93 on page 212 ) , which holds for every integer @xmath746 , and obtain @xmath747 this proves the first part of the claim , that @xmath748 .",
    "we pick an orthonormal basis for @xmath643 that has @xmath655 and @xmath656 as its first two vectors .",
    "let @xmath773 and @xmath774 be the other two basis vectors .",
    "we define @xmath775 by , @xmath776 belongs to @xmath777 which is contained in @xmath778 .",
    "similarly , @xmath779 belongs to @xmath780 and @xmath781 , @xmath782 belong to @xmath783 . if @xmath172 , this means that @xmath784 if @xmath785 , then @xmath776 , @xmath779 , @xmath781 , @xmath782 are all in @xmath783 .",
    "this means that @xmath786 and it remains unchanged by a query .",
    "we define @xmath787 .",
    "since the support of @xmath642 is contained in the subspace spanned by @xmath788 , we have @xmath789 .",
    "this means that equation can be rewritten as @xmath790 @xmath791 can be also expressed in a similar way , with @xmath792 instead of @xmath793 . by combining equations for @xmath794 and @xmath791 , we get @xmath795 therefore , it suffices to bound @xmath796 and @xmath797 .",
    "w.l.o.g .",
    "we can assume that @xmath642 is a pure state @xmath798 .",
    "let @xmath799 then the state after a query is @xmath800 and we have to bound @xmath801 . for @xmath802",
    ", we have @xmath803 the expression for @xmath804 is similar , with minus signs in front of @xmath805 and @xmath806 .",
    "therefore , @xmath807 since @xmath808 , @xmath809 , @xmath810 , @xmath811 are all at most @xmath812 and @xmath813 , @xmath814 are less than 1 , equation is at most @xmath815 . by , we have @xmath816 we also have @xmath817 where @xmath195 is the big - o constant from . by taking into account that @xmath818 , @xmath819 this proves for the case when the support of @xmath642 is contained in @xmath643 .",
    "( if @xmath642 is a mixed state , we just express it as a mixture of pure states @xmath820 .",
    "the bound for @xmath642 follows by summing equations for every @xmath820 . )    for the general case , we divide the entire state space @xmath110 into 4-dimensional subspaces . to do that",
    ", we first subdivide @xmath110 into subspaces @xmath821 let states @xmath822 , @xmath823 $ ] form a basis for @xmath635 and let @xmath824 for @xmath825 , where the @xmath580 are the unitaries from  . then the @xmath826 form a basis for @xmath827 .",
    "let @xmath828 , @xmath829 $ ] , form a basis for @xmath830 , @xmath831 .",
    "we subdivide into 4-dimensional subspaces @xmath832 spanned by @xmath833 where @xmath834 range over @xmath835 .",
    "let @xmath836 be the collection of all @xmath832 obtained by subdividing all subspaces .",
    "we claim that @xmath837 equation   together with equation implies .",
    "since @xmath838 is defined as a weighted sum of traces @xmath839 , we can prove equation by showing @xmath840 to prove , we define a basis for @xmath110 by first decomposing @xmath110 into subspaces @xmath841 , and then for each subspace , taking the basis consisting of @xmath776 , @xmath779 , @xmath781 and @xmath782 defined by equation . by , each of the basis states belongs to one of the subspaces @xmath842 .",
    "this means that each @xmath842 is spanned by some subset of this basis .",
    "the left hand side of is equal to the sum of squared projections of @xmath642 to basis states @xmath843 that belong to @xmath842 .",
    "each of the terms @xmath844 on the right hand side is equal to the sum of squared projections to basis states @xmath843 that belong to @xmath845 .",
    "summing over all @xmath846 gives the sum of squared projections of @xmath642 to all @xmath843 that belong to @xmath842 .",
    "therefore , the two sides of are equal ."
  ],
  "abstract_text": [
    "<S> we give a new version of the adversary method for proving lower bounds on quantum query algorithms . </S>",
    "<S> the new method is based on analyzing the eigenspace structure of the problem at hand . </S>",
    "<S> we use it to prove a new and optimal strong direct product theorem for 2-sided error quantum algorithms computing @xmath0 independent instances of a symmetric boolean function : if the algorithm uses significantly less than @xmath0 times the number of queries needed for one instance of the function , then its success probability is exponentially small in @xmath0 . </S>",
    "<S> we also use the polynomial method to prove a direct product theorem for 1-sided error algorithms for @xmath0 threshold functions with a stronger bound on the success probability . finally , we present a quantum algorithm for evaluating solutions to systems of linear inequalities , and use our direct product theorems to show that the time - space tradeoff of this algorithm is close to optimal .    [ relations among complexity measures ] </S>"
  ]
}