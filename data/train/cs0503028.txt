{
  "article_text": [
    "to operate effectively in a dynamic and unpredictable environment , agents need correct information about the environment",
    ". often only part of this environment could be sensed by the agent herself .",
    "as the agent may need information about other part of the environment that she could not sense , she needs to cooperate with other agents to get such information .",
    "there are many such systems of cooperative information agents operating in the internet today .",
    "a prominent example of such system is the system of routers that cooperate to deliver messages from one place to another in the internet .",
    "one of the key characteristics of these systems is their resilience in the face of unpredictable changes in their environment and the incapability of many agents to sense such changes causing them to have temporary incorrect information .",
    "this is possible because agents in such systems cooperate by exchanging tentative partial results to eventually converge on correct and consistent global view of the environment .",
    "together they constitute a stabilizing system that allows the individual agents to eventually get a correct view of their surrounding .",
    "agent communications could be classified into push - based communications and pull - based communications . in the push - based communication , agents periodically send information to specific recipients .",
    "push - based communications are used widely in routing system , network protocols , emails , videoconferencing calls , etc .",
    "a key goal of these systems is to guarantee that the agents have a correct view of their surrounding . on the other hand , in the pull - based communication",
    ", agents have to send a request for information to other agents and wait for a reply . until now pull - based communications are the dominant mode of communication in research in multiagent systems , e.g. @xcite , @xcite , @xcite , @xcite , @xcite , @xcite . in this paper",
    ", we consider multiagent systems where agent communications are based on push  technologies .",
    "a prominent example of a push - based multiagent system is the internet routing system .",
    "+ this paper studies the problem of stabilization of systems of cooperative information agents where an information agent is viewed as a deductive database which consists of 3 parts :    * an observation database containing the facts the agent has observed or sensed from its surrounding environment . *",
    "an input database containing the information the agent was told by other agents * an intensional database which is a set of rules for computing derived information from the information stored in the observation and input databases .",
    "it turns out that in general , it is not possible to ensure that the agents will eventually have the correct information about the environment even if they honestly exchange information and do not hide any information that is needed by others and every change in the environment is immediately sensed by some of the agents .",
    "we also introduce sufficient conditions for stabilization .",
    "the stabilization of distributed protocols has been studied extensively in the literature ( @xcite,@xcite,@xcite ) where agents are defined operationally as automata .",
    "dijkstra @xcite defined a system as stabilizing if it is guaranteed to reach a legitimate state after a finite number of steps regardless of the initial state .",
    "the definition of what constitutes a legitimate state is left to individual algorithms .",
    "thanks to the introduction of an explicit notion of environment , we could characterize a legitimate state as a state in which the agents have correct information about their environment . in this sense",
    ", we could say that our agents are a new form of situated agents ( @xcite , @xcite , @xcite ) that may sometimes act on wrong information but nonetheless will be eventually situated after getting correct information about their surrounding . further in our approach , agents are defined as logic programs , and hence it is possible for us to get general results about what kind of algorithms could be implemented in stabilizing multiagent systems in many applications . to the best of our knowledge",
    ", we believe that our work is the first work on stabilization of multiagent systems .",
    "the rest of this paper is organized as follows .",
    "basic notations and definitions used in this paper are briefly introduced in section [ sec : preliminaries ] .",
    "we give an illustrating example and formalize the problem in section [ sec : formalization ] .",
    "related works and conclusions are given in section [ sec : conclusions ] .",
    "proofs of theorems are given in appendices .",
    "in this section we briefly introduce the basic notations and definitions that are needed in this paper .",
    "we assume the existence of a herbrand base @xmath0 .",
    "a logic program is a set of ground clauses of the form : @xmath1 where @xmath2 is an atom from @xmath0 , and @xmath3 are literals ( i.e. , atoms or negations of an atoms ) over @xmath0 , @xmath4 .",
    "@xmath2 is called the head , and @xmath5 the body of the clause .",
    "given a set of clauses s , the set of the heads of clauses in s is denoted by _ head(s)_.    note that clauses with variables are considered as a shorthand for the set of all their ground instantiations .",
    "often the variables appearing in a non - ground clause have types that are clear from the context . in such cases",
    "these variables are instantiated by ground terms of corresponding types .    for each atom @xmath6 ,",
    "the _ definition of a _ is the set of all clauses whose head is @xmath6 .",
    "a logic program is _ bounded _ if the definition of every atom is finite .",
    "let @xmath7 be an arbitrary logic program .",
    "for any set @xmath8 , let @xmath9 be a program obtained from @xmath7 by deleting    1 .",
    "each rule that has a negative literal @xmath10 in its body with @xmath11 , and 2 .",
    "all negative literals in the bodies of the remaining rules    @xmath12 is a _ stable model _ ( @xcite ) of @xmath7 if @xmath12 is the least model of @xmath9 .",
    "+ the _ atom dependency graph _ of a logic program @xmath7 is a graph , whose nodes are atoms in @xmath0 and there is an edge from @xmath6 to @xmath13 in the graph iff there is a clause in @xmath7 whose head is @xmath6 and whose body contains @xmath13 or @xmath14 .",
    "note that in the literature @xcite , the direction of the link is from the atom in the body to the head of a clause .",
    "we reverse the direction of the link for the ease of definition of acyclicity using the atom dependency graph .",
    "an atom @xmath13 is said to be _ relevant _ to an atom @xmath6 if there is a path from @xmath6 to @xmath13 in the atom dependency graph .",
    "a logic program @xmath7 is _ acyclic _ iff there is no infinite path in its atom dependency graph .",
    "it is well known that    each acyclic logic program has exactly one stable model .",
    "routing is one of the most important problems for internetworking . inspired by rip @xcite , one of the most well - known internet routing protocols",
    ", we will develop in this section , as an example , a multiagent system for solving the network routing problem to motivate our work .",
    "[ ex : routing ] consider a network in fig .",
    "[ fig : network ] . for simplicity",
    "we assume that all links have the same cost , say 1 .",
    "( 50,40)(0,0 ) ( 0,5)(0,1)30 ( 0,5)(1,0)20 ( 0,35)(1,0)20 ( 20,35)(1,0)30 ( 20,35)(0,-1)30 ( 20,5)(1,1)30 ( 0,5 ) ( 0,35 ) ( 20,5 ) ( 20,35 ) ( 50,35 ) ( 0,4)(0,0)[t]@xmath15 ( 20,4)(0,0)[t]@xmath16 ( 0,36)(0,0)[b]@xmath17 ( 20,36)(0,0)[b]@xmath18 ( 50,36)(0,0)[b]@xmath19    the problem for each agent is to find the shortest paths from her node to other nodes .",
    "the environment information an agent can sense is the availability of links connecting to her node .",
    "the agents use an algorithm known as `` distance vector algorithm '' ( @xcite , @xcite ) to find the shortest paths from their nodes to other nodes .",
    "if the destination is directly reachable by a link , the cost is 1 .",
    "if the destination is not directly reachable , an agent needs information from its neighbors about their shortest paths to the destination . the agent will select the route to the destination through a neighbor who offers a shortest path to the destination among the agent s neighbors .",
    "thus at any point of time , each agent needs three kinds of information :    the information about the environment , that the agent can acquire with her sensing capability . in our example , agent @xmath17 could sense whether the links connecting her and her neighbors @xmath20 are available .",
    "the algorithm the agent needs to solve her problem . in our example the algorithm for agent @xmath17 is represented by the following clauses :    @xmath21 where    @xmath22 is true iff there a link from @xmath23 to @xmath24 in the network and the link is intact .",
    "links are undirected , i.e. we identify @xmath22 and @xmath25 .",
    "@xmath26 is true iff a shortest path from @xmath17 to @xmath27 has length @xmath28    @xmath29 is true iff the length of shortest paths from @xmath17 to @xmath27 is @xmath28 and there is a shortest path from @xmath17 to @xmath27 that goes through @xmath30 as the next node after @xmath17    @xmath31 is true iff there is a path from @xmath17 to @xmath27 whose length is less than @xmath28 .",
    "the information the agent needs from other agents . for agent @xmath17 to calculate the shortest paths from her node to say @xmath19 , she needs the information about the length of the shortest paths from her neighbors @xmath18 , and @xmath15 to @xmath19 , that means she needs to know the values @xmath28 , @xmath32 such that @xmath33 , @xmath34 , @xmath35 hold .",
    "the agents are situated in the environment .",
    "they may have different accessibility to the environment depending on their sensing capabilities .",
    "the environment is represented by a set of ( ground ) environment atoms , whose truth values could change in an unpredictable way .",
    "an agent is represented by a quad - tuple @xmath36 where    * @xmath37 , the intensional database , is an acyclic logic program .",
    "* @xmath38 is the set of all ( ground ) environment atoms whose truth values the agent could sense , i.e. @xmath39 iff @xmath40 could discover instantly any change in the truth value of @xmath6 and update her extensional database accordingly .",
    "* @xmath41 is the set of all atoms called input atoms , whose truth values the agent must obtain from other agents . +",
    "no atom in @xmath42 appears in the head of the clauses in @xmath37 and @xmath43 .",
    "* @xmath44 is the initial state of the agent .",
    "an agent state is a pair @xmath45 where    * @xmath46 represents what the agent has sensed from the environment .",
    "that means for each @xmath39 , @xmath47 iff @xmath6 is true . *",
    "@xmath48 , the input database of @xmath40 , represents the set of information @xmath40 has obtained from other agents , i.e. @xmath49 iff @xmath40 was told that @xmath6 is true .    given a state @xmath50 , the _ stable model _ of @xmath51 at @xmath52",
    "is defined as the stable model of @xmath53 .",
    "note that @xmath44 and @xmath52 could be different states .",
    "[ ex : network ]",
    "imagine that initially the agents have not sent each other any information and all links are intact .",
    "in this situation , agent @xmath17 is represented as follows :    * @xmath54 contains the clauses shown in example [ ex : routing ] . *",
    "@xmath55 * @xmath56 consists of ground atoms of the form @xmath57 where @xmath58 and @xmath59 is a positive integer . * the initial state @xmath60 where @xmath61    a cooperative multiagent system is a collection of @xmath62 agents @xmath63 with @xmath23= @xmath64,@xmath65 , @xmath66 , @xmath67 such that the following conditions are satisfied    * for each atom @xmath6 , if @xmath68 then @xmath6 has the same definition in @xmath69 and @xmath70 .",
    "* for each agent @xmath23 , @xmath71 * no environment atom appears in the head of clauses in the intentional database of any agent , i.e. for all i , j : @xmath72 .    for each agent",
    "@xmath23 let @xmath73 .",
    "let @xmath74 for @xmath75 .",
    "we say that @xmath23 * depends * on @xmath24 if @xmath23 needs input from @xmath24 , i.e. @xmath76 . the * dependency * of @xmath23 on @xmath24 is defined to be the set @xmath77 . +",
    "as we have mentioned before , the mode of communication for our agents corresponds to the `` push  technology '' .",
    "formally , it means that if @xmath23 depends on @xmath24 then @xmath24 will periodically send @xmath23 a set @xmath78 where @xmath79 is the stable model of @xmath24 .",
    "when @xmath23 obtains s , she knows that each atom @xmath80 is false with respect to @xmath79",
    ". therefore she will update her input database @xmath81 to @xmath82 as follows @xmath83 thus her state has changed from @xmath84 to @xmath85 @xmath86 @xmath87 accordingly . + an environment change",
    "is represented by a pair @xmath88 where @xmath89 ( resp .",
    "@xmath90 ) contains the atoms whose truth values have changed from false ( resp .",
    "true ) to true ( resp .",
    "false ) . therefore , given an environment change @xmath91 , what @xmath23 could sense of this change , is captured by the pair @xmath92 where @xmath93 and @xmath94 .",
    "hence when a change @xmath95 occurs in the environment , agent @xmath23 will update her sensing database @xmath96 to @xmath97 as follows : @xmath98    the state of agent @xmath23 has changed from @xmath84 to @xmath85 @xmath99 @xmath100 accordingly .",
    "let @xmath101 with @xmath102 be a multiagent system .",
    "@xmath103 is called the _ initial state _ of @xmath104 .",
    "+ a _ state _ of @xmath105 is defined as @xmath106 such that @xmath107 is a state of agent @xmath23 .",
    "+ there are two types of transitions in a multiagent system .",
    "a environment transition happens when there is a change in the environment which is sensed by a set of agents and causes these agents to update their extensional databases accordingly .",
    "a communication transition happens when an agent sends information to another agent and causes the later to update her input database accordingly .",
    "+ for an environment change @xmath108 , let @xmath109 be the set of agents which could sense parts of @xmath110 , i.e. @xmath111    [ def : transition ] let @xmath112 , @xmath113 be states of @xmath104 with @xmath114 , @xmath115 .    1 .",
    "[ trans:1]a environment transition @xmath116{c } \\triangle'\\ ] ] caused by an environment change @xmath95 is defined as follows 1 .   for every agent @xmath117",
    "such that @xmath118 : @xmath119 , and 2 .   for each agent @xmath120 : * @xmath121 , * @xmath122 .",
    "[ trans:2 ] a communication transition @xmath123 caused by agent @xmath24 sending information to agent @xmath23 , where @xmath23 depends on @xmath24 , is defined as follows : 1 .   for all @xmath124 such that @xmath125 : @xmath119 2 .",
    "@xmath126 and @xmath127 where @xmath78 and @xmath79 is the stable model of @xmath24 at @xmath128 .",
    "we often simply write @xmath129 if there is a transition @xmath130{c } \\triangle'$ ] or @xmath131 .",
    "[ def : run ] a * run * of a multiagent system @xmath105 is an infinite sequence @xmath132 such that    * @xmath133 is the initial state of @xmath104 and for all agents @xmath134 such that @xmath23 depends on @xmath24 the following condition is satisfied : + _ for each @xmath135 , there is a @xmath136 such that @xmath137 _ + + the above condition is introduced to capture the idea that agents periodically send the needed information to other agents .",
    "* there is a point @xmath135 such that at every @xmath138 in the run , there is no more environment change .",
    "+    for a run @xmath139 where @xmath140 we often refer to the stable model of @xmath23 at state @xmath141 as _ the stable model of @xmath23 at point @xmath124 _ and denote it by @xmath142 .    [ ex : cyclicprogram ]    consider the following multiagent system @xmath143 where @xmath144    consider the following run @xmath145 , where the only environment change occurs at point @xmath146 such that the truth value of @xmath147 becomes false : @xmath148    the states and stable models of @xmath17 and @xmath18 at points @xmath149 , @xmath150 , @xmath146 , @xmath151 , and @xmath152 are as follows +     @xmath124 & @xmath153 & @xmath154 & stable model & @xmath153 & @xmath154 & stable model + @xmath149 & @xmath155 & @xmath156 & @xmath155 & @xmath157 & @xmath156 & @xmath158 + @xmath150 & @xmath155 & @xmath159 & @xmath160 & @xmath157 & @xmath156 & @xmath158 + @xmath146 & @xmath155 & @xmath159 & @xmath160 & @xmath157 & @xmath161 & @xmath162 + @xmath151 & @xmath155 & @xmath159 & @xmath160 & @xmath163 & @xmath161 & @xmath164 + @xmath152 & @xmath155 & @xmath159 & @xmath160 & @xmath163 & @xmath161 & @xmath164 +    [ ex : app1 ]    consider the following run @xmath145 of the multiagent system given in example [ ex : network ] .",
    "@xmath165    initially , all links are intact and all inputs of agents are empty , i.e. @xmath166 for @xmath167 . at point @xmath149 in the run ,",
    "agent @xmath18 sends to agent @xmath17 information about shortest paths from her to other agents . at point @xmath150 in the run ,",
    "the link between @xmath17 and @xmath18 is down .",
    "the information ( output ) an agent needs to send to other agents consists of shortest paths from her to other agents .",
    "thus from the stable model of an agent we are interested only in this output .",
    "let @xmath168 be the set @xmath169 where @xmath142 is the stable model of @xmath23 at point @xmath124 .",
    "@xmath168 denotes the output of @xmath23 at point @xmath124 .",
    "it is easy to see that if there is a transition @xmath170 , then @xmath24 sends to @xmath23 : @xmath171    at point @xmath149 , @xmath17 and @xmath18 have the following states and outputs : @xmath172    @xmath18 sends @xmath12 to @xmath17 in the transition @xmath173 where @xmath174 thus @xmath175    the environment change @xmath176 at point @xmath150 is sensed by @xmath17 and @xmath18 .",
    "the states of @xmath17 and @xmath18 are changed as follows : @xmath177    the following tables show the states and outputs of @xmath17 and @xmath18 at points @xmath149 , @xmath150 , and @xmath146 respectively .",
    "+     @xmath124 & @xmath153 & @xmath154 & @xmath178 + @xmath149 & @xmath179 & @xmath156 & @xmath180 + @xmath150 & @xmath179 & @xmath181 & @xmath182 + @xmath146 & @xmath183 & @xmath181 & @xmath180 +      + @xmath124 & @xmath153 & @xmath154 & @xmath178 + @xmath149 & @xmath184 & @xmath156 & @xmath181 + @xmath150 & @xmath184 & @xmath156 & @xmath181 + @xmath146 & @xmath185 & @xmath156 & @xmath181 +      consider a superagent whose sensing capability and problem solving capability are the combination of the sensing capabilities and problem solving capabilities of all agents , i.e. this agent can sense any change in the environment and her intensional database is the union of the intensional databases of all other agents .",
    "formally , the superagent of a multiagent system @xmath186 where @xmath187 is represented by @xmath188 where    * @xmath189 * @xmath44 , the initial state of @xmath190 , is equal to @xmath191    the superagent actually represents the multiagent system in the ideal case where each agent has obtained the correct information for its input atoms .",
    "[ ex : cyclicprogram1 ] consider the multiagent system in example [ ex : cyclicprogram ] . at point @xmath149 ,",
    "the superagent @xmath190 is represented as follows :    * @xmath192 consists of the following clauses : @xmath193 * @xmath194 .",
    "[ ex : superagent ]    consider the multiagent system in example [ ex : app1 ] .",
    "initially , when all links between nodes are intact , the superagent @xmath195 is represented as follows :    * @xmath192 consists of the following clauses : @xmath196 * the initial state @xmath197    note that the possible values of variables @xmath30 , @xmath27 , @xmath198 are @xmath17 , @xmath18 , @xmath19 , @xmath15 , @xmath16 .",
    "let @xmath104 be a multiagent system .",
    "the * i / o graph * of @xmath104 denoted by @xmath199 is a graph obtained from the atom dependency graph of its superagent s intensional database @xmath192 by removing all nodes that are not relevant for any input atom in @xmath200 .",
    "@xmath104 is * io - acyclic * if there is no infinite path in its i / o graph @xmath199 .",
    "@xmath104 is * bounded * if @xmath192 is bounded .",
    "@xmath104 is * io - finite * if its i / o graph is finite .",
    "the atom dependency graph of @xmath192 and the i / o - graph @xmath199 of the multiagent system in examples [ ex : cyclicprogram ] and [ ex : cyclicprogram1 ] is given in fig . [",
    "fig : i / o - graph ] .",
    "it is obvious that the multiagent system in examples [ ex : cyclicprogram ] and [ ex : cyclicprogram1 ] is bounded but not io - acyclic and the multiagent system in examples [ ex : routing ] , [ ex : network ] , [ ex : app1 ] and [ ex : superagent ] is io - acyclic and bounded .",
    "[ prop : acyclic ] if a multiagent system @xmath104 is * io - acyclic * then @xmath192 is acyclic .",
    "suppose @xmath192 is not acyclic .",
    "there is an infinite path @xmath201 in its atom dependency graph starting from some atom @xmath6 .",
    "there is some agent @xmath23 such that @xmath202 .",
    "since @xmath69 is acyclic , every path in its atom dependency graph is finite .",
    "@xmath201 must go through some atom @xmath203 to outside of @xmath23 s atom dependency graph .",
    "clearly starting from @xmath13 , all atoms in @xmath201 are relevant to @xmath13 .",
    "the infinite path of @xmath201 starting from @xmath13 is a path in the i / o graph @xmath199 . hence @xmath199 is not acyclic .",
    "contradiction !",
    "let @xmath204 be a run and @xmath142 be the stable model of @xmath23 at point @xmath124 .    1 .",
    "@xmath145 is * convergent * for an atom @xmath6 if either of the following conditions is satisfied .",
    "* there is a point @xmath135 such that at every point @xmath138 , for every agent @xmath23 with @xmath205 , @xmath206 in this case we write @xmath207 * there is a point @xmath135 such that at every point @xmath138 , for every agent @xmath23 with @xmath202 , @xmath208 in this case we write @xmath209 2 .",
    "@xmath145 is * convergent * if it is convergent for each atom .",
    "@xmath145 is * strongly convergent * if it is convergent and there is a point @xmath135 such that at every point @xmath138 , for every agent @xmath23 , @xmath210 .",
    "it is easy to see that strong convergence implies convergence .",
    "define @xmath211 as the * convergence model * of @xmath145 .",
    "let @xmath212 be a run where @xmath140 with @xmath213 . as there is a point @xmath135 such that the environment does not change after @xmath135 ,",
    "it is clear that @xmath214 .",
    "the set @xmath215 is called * the stabilized environment * of @xmath145 .    *",
    "a multiagent system is said to be * weakly stabilizing * if every run @xmath145 is convergent , and its convergence model @xmath216 is a stable model of @xmath190 in the stabilized environment of @xmath145 , i.e. @xmath216 is a stable model of @xmath217 where @xmath153 is the stabilized environment of @xmath145 . *",
    "a multiagent system is said to be * stabilizing * if it is weakly stabilizing and all of its runs are strongly convergent .",
    "[ theo:1 ] io - acyclic and bounded multiagent systems are weakly stabilizing .",
    "see [ app : prooftheorem1 ] .",
    "unfortunately , the above theorem does not hold for more general class of multiagent systems as the following example shows .",
    "[ ex : cyclicprogram2 ]    consider the multiagent system @xmath104 and run @xmath145 in example [ ex : cyclicprogram ] .",
    "it is obvious that @xmath104 is bounded but not io - acyclic .",
    "for every point @xmath218 , @xmath219 , @xmath220 .",
    "the stabilized environment of @xmath145 is @xmath222 .",
    "the stable model of @xmath190 in the stabilized environment of @xmath145 is @xmath223 , which is not the same as @xmath216 .",
    "hence the system is not weakly stabilizing .",
    "boundedness is very important for the weak stabilization of multiagent systems .",
    "consider a multiagent system in the following example which is io - acyclic , but not bounded .",
    "[ ex : infinitehb ]    consider the following multiagent system @xmath224 where @xmath225    since @xmath226 , for every run @xmath145 the stabilized environment of @xmath145 is empty .",
    "the stable model of @xmath190 in the stabilized environment of @xmath145 is the set @xmath227@xmath228@xmath229 .",
    "it is easy to see that for each run , the agents need to exchange infinitely many messages to establish all the values of @xmath230 .",
    "hence for every run @xmath145 , for every point @xmath231 in the run : @xmath232 , but @xmath233 is not in the stable model of @xmath190 in the stabilized environment of @xmath145 .",
    "thus the system is not weakly stabilizing .",
    "are the boundedness and io - acyclicity sufficient to guarantee the stabilization of a multiagent system ? the following example shows that they are not .",
    "[ ex : stabcond ]    consider the multiagent system in example [ ex : network ] .",
    "consider the following run @xmath145 with no environment change after point @xmath234 .",
    "@xmath235    initially all links in the network are intact .",
    "the states and outputs of agents are as follows :",
    "* @xmath236 , + @xmath237 + @xmath238 . + @xmath239",
    ". + @xmath240 . * @xmath166 for @xmath241 . * @xmath242 for @xmath243 .",
    "recall that @xmath168 denotes the output of @xmath23 at point @xmath124 and is defined as follows : @xmath244    the following transitions occur in @xmath145 :    * at point @xmath149 , @xmath16 sends @xmath245 to @xmath18 .",
    "this causes the following changes in the input and output of @xmath18 : @xmath246 * at point @xmath150 , @xmath16 sends @xmath247 to @xmath15 .",
    "this causes the following changes in the input and output of @xmath15 : @xmath248 * at point @xmath146 , @xmath18 sends @xmath249 to @xmath17 .",
    "this causes the following changes in the input and output of @xmath17 : @xmath250 * at point @xmath151 , the link between @xmath17 and @xmath18 is down as shown in fig .",
    "[ fig : network1 ] . + ( 50,40)(0,0 ) ( 0,5)(0,1)30 ( 0,5)(1,0)20 ( 20,35)(1,0)30 ( 20,35)(0,-1)30 ( 20,5)(1,1)30 ( 0,5 ) ( 0,35 ) ( 20,5 ) ( 20,35 ) ( 50,35 ) ( 0,4)(0,0)[t]@xmath15 ( 20,4)(0,0)[t]@xmath16 ( 0,36)(0,0)[b]@xmath17 ( 20,36)(0,0)[b]@xmath18 ( 50,36)(0,0)[b]@xmath19 + this causes the following changes in the states and outputs of @xmath17 and @xmath18 : @xmath251 * at point @xmath152 , @xmath15 sends @xmath252 to @xmath17 .",
    "this causes the following changes in the input and output of @xmath17 : @xmath253 * at point @xmath254 , the link between @xmath15 and @xmath16 is down as shown in fig .",
    "[ fig : network2 ] .",
    "+ ( 50,40)(0,0 ) ( 0,5)(0,1)30 ( 20,35)(1,0)30 ( 20,35)(0,-1)30 ( 20,5)(1,1)30 ( 0,5 ) ( 0,35 ) ( 20,5 ) ( 20,35 ) ( 50,35 ) ( 0,4)(0,0)[t]@xmath15 ( 20,4)(0,0)[t]@xmath16 ( 0,36)(0,0)[b]@xmath17 ( 20,36)(0,0)[b]@xmath18 ( 50,36)(0,0)[b]@xmath19 + this causes the following changes in the states and outputs of @xmath15 and @xmath16 : @xmath255 * at point @xmath234 , @xmath17 sends @xmath256 to @xmath15 . this causes the following changes in the input and output of @xmath15 : @xmath257 + note that at point @xmath234 , @xmath258 , i.e. the length of the shortest path from @xmath17 to @xmath16 equals to @xmath146 , is wrong . but",
    "@xmath17 sends this information to @xmath15 .",
    "now the length of the shortest paths to @xmath16 of agents @xmath17 , and @xmath15 equal to @xmath146 , and @xmath151 respectively ( i.e. @xmath259 and @xmath260 , are all wrong .",
    "later on @xmath17 and @xmath15 exchange wrong information , increase the shortest paths to @xmath16 after each round by @xmath146 and go into an infinite loop .",
    "the states and outputs of @xmath17 and @xmath15 at points @xmath261 are shown in fig .",
    "[ statea1 ] and fig .",
    "[ statea4 ] respectively .",
    "@xmath178 + @xmath149 & @xmath262 & @xmath156 & @xmath263 + & @xmath264 & & + @xmath150 & @xmath262 & @xmath156 & @xmath263 + & @xmath264 & & + @xmath146 & @xmath262 & @xmath156 & @xmath263 + & @xmath264 & & + @xmath151 & @xmath265 & @xmath266 & @xmath267 + & & & @xmath268 + @xmath152 & @xmath265 & @xmath266 & @xmath263 + @xmath254 & @xmath265 & @xmath269 & @xmath270 + & & @xmath271 & @xmath272 + @xmath234 & @xmath265 & @xmath269 & @xmath273 + & & @xmath271 & @xmath274 + @xmath275 & @xmath265 & @xmath269 & @xmath273 + & & @xmath276 & @xmath268 + @xmath277 & @xmath265 & @xmath269 & @xmath273 + & & @xmath278 & @xmath279 +     @xmath178 + @xmath149 & @xmath280 & @xmath156 & @xmath281 + & @xmath282 & & + @xmath150 & @xmath280 & @xmath156 & @xmath281 + & @xmath282 & & + @xmath146 & @xmath280 & @xmath283 & @xmath284 + & @xmath282 & & + @xmath151 & @xmath280 & @xmath283 & @xmath284 + & @xmath282 & & + @xmath152 & @xmath280 & @xmath283 & @xmath284 + & @xmath282 & & + @xmath254 & @xmath280 & @xmath283 & @xmath284 + & @xmath282 & & + @xmath234 & @xmath285 & @xmath283 & @xmath281 + @xmath275 & @xmath285 & @xmath286 & @xmath287 + & & @xmath288 & @xmath289 + @xmath277 & @xmath285 & @xmath286 & @xmath287 + & & @xmath288 & @xmath289 +    this example shows that    io - acyclicity and boundedness are not sufficient to guarantee the stabilization of a multiagent system .",
    "as we have pointed out before , the routing example in this paper models the popular routing rip protocol that has been widely deployed in the internet .",
    "example [ ex : stabcond ] shows that rip is not stabilizing . in configuration [ fig : network2 ] , the routers at the nodes @xmath290 go into a loop and continuously change the length of the shortest paths from them to @xmath16 from 2 to infinite .",
    "this is because the router at node @xmath17 believes that the shortest path from it to @xmath16 goes through @xmath15 while the router at @xmath15 believes that the shortest path from it to @xmath16 goes through @xmath17 .",
    "none of them realizes that there is no more connection between them and @xmath16 .. the above theorem generalizes this insight to multiagent systems .",
    "the conclusion is that in general it is not possible for an agent to get correct information about its environment if this agent can not sense all the changes in the environment by itself and has to rely on the communications with other agents .",
    "this is true even if all the agents involved are honest and do not hide their information .",
    "obviously , if a multiagent system is io - acyclic and io - finite , every agent would obtain complete and correct information after finitely many exchanges of information with other agents .",
    "the system is stabilizing .",
    "hence    [ theo:2 ] io - acyclic and io - finite multiagent systems are stabilizing .",
    "see [ app : prooftheorem2 ] .",
    "there are many research works on multiagent systems where agents are formalized in terms of logic programming such as @xcite , @xcite , @xcite . an agent in our framework",
    "could be viewed as an abductive logic program as in @xcite , @xcite where atoms in the input database could be considered as abducibles .",
    "satoh and yamatomo formalized speculative computation with multiagent belief revision .",
    "the semantics of multiagent systems , which is defined based on belief sets and the union of logic programs of agents , is similar to our idea of `` superagent '' .",
    "an agent in @xcite is composed of two modules : the abductive reasoning module ( arm ) , and the agent behaviour module ( abm ) .",
    "agents are grouped within bunches according to the requirements of interaction between agents .",
    "the coordination ( collaboration ) of agents is implicitly achieved through the semantics of the consistency operators . in both works",
    "( @xcite and @xcite ) the communication for agents is based on pull - technologies .",
    "the authors did not address the stabilization issue of multiagent systems .",
    "sadri , toni and torroni in @xcite used a logic - based framework for negotiation to tackle the resource reallocation problem via pull - based communication technology and the solution is considered as `` stabilization '' property .    in this paper",
    ", we consider a specific class of cooperative information agents without considering effects of their actions on the environment e.g. in @xcite , @xcite , @xcite .",
    "we are currently working to extend the framework towards this generalized issue .    in this paper ,",
    "a logic programming based framework for cooperative multiagent systems is introduced , and the stabilization of multiagent systems is then formally defined .",
    "we introduced sufficient conditions in general for multiagent systems under which the stabilization is guaranteed .",
    "we showed that io - acyclic and bounded multiagent systems are weakly stabilizing .",
    "but io - acyclicity and boundedness are not sufficient to guarantee the stabilization of a multiagent system .",
    "we showed that io - acyclic and io - finite multiagent systems are stabilizing .",
    "unfortunately these conditions are strong .",
    "so it is not an easy task to ensure that agents eventually get right information in the face of unpredictable changes of the environment .",
    "our research is inspired by the network routing applications . as the rip ( @xcite , @xcite ) is very simple and had been widely accepted and implemented .",
    "but the rip has many limitations such as the bouncing effect , counting to infinity , looping , etc .",
    "many versions and techniques of the rip have been introduced to reduce undesired features of the rip , but the problem could not be solved thoroughly . with logic programming approach , we showed in this paper , the main reason is that in the rip , the computation of the overall problem solving algorithm is distributed over the network , while the logic program which represents the routing algorithm is not io - finite , the stabilization of the system is thus not guaranteed .",
    "it is also a reason why most experts prefer the ospf ( @xcite , @xcite ) , which is much more complicated and sophisticated protocol , to the rip for network routing .",
    "we have assumed that information sent by an agent is obtained immediately by the recipients . but communications in real networks always have delay and errors in transmissions .",
    "we believe that the results presented in this paper could also be extended for the case of communication with delay and errors .    in this paper communications for agents",
    "are based on push - technologies .",
    "it is interesting to see how the results could be extended to multiagent systems whose communication is based on pull - technologies ( @xcite , @xcite ) .",
    "first it is clear that the following lemma holds .",
    "let @xmath296 be a run of @xmath104 such that after point @xmath135 there is no more change in the environment .",
    "the stabilized environment of @xmath145 is @xmath297 .",
    "let @xmath298\\kern-0.15em\\right]}$ ] be the stable model of @xmath190 in the stabilized environment of @xmath145 , i.e. the stable model of @xmath217 .",
    "the height of an atom @xmath6 in the atom dependency graph of @xmath190 denoted by @xmath299 is the length of a longest path from @xmath6 to other atoms in the atom dependency graph of @xmath190 .",
    "since @xmath192 is acyclic , there is no infinite path in the atom dependency graph of @xmath190 . from the boundedness of @xmath192",
    ", @xmath299 is finite .",
    "+ theorem [ theo:1 ] follows directly from the following lemma .",
    "[ lemma : app12 ] for every atom @xmath6 , there is a point @xmath302 , such that at every point @xmath303 in @xmath145 , for every @xmath23 such that @xmath202 , @xmath304 iff @xmath305\\kern-0.15em\\right]}$ ] .      * _ base case : _ @xmath307 ( @xmath6 is a leaf in the dependency graph of @xmath190 ) .",
    "+ let @xmath23 be an agent with @xmath202 .",
    "there are three cases : 1 .",
    "there must be a clause of the form @xmath309 in @xmath69 .",
    "@xmath309 is also in @xmath192 . at every point @xmath310 , @xmath311 and @xmath301\\kern-0.15em\\right]}$ ] .",
    "2 .   @xmath312 .",
    "there is no change in the environment after @xmath135 , at every point @xmath138 , @xmath313 iff @xmath314 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "3 .   @xmath315 .",
    "there must be an agent @xmath24 such that @xmath316 and @xmath317 . by definition [ def : run ] of the run",
    ", there must be a point @xmath318 such that there is a transition @xmath319 moreover , every transition that can delete ( or insert ) @xmath6 from ( or into ) @xmath81 after point @xmath135 must also have the form @xmath320 for some @xmath24 such that @xmath321 and @xmath317 . by the definition of transition of the form @xmath131 in definition [ def : run ] and the operator @xmath322 in section [ subsec : communicationsensing ] , for a transition @xmath323 , @xmath23 will update @xmath81 as follows @xmath324 where @xmath325 . since @xmath326 , @xmath327 iff @xmath328 iff @xmath329 . as shown in @xmath150 and @xmath146 , at every point @xmath138 , for every @xmath24 such that @xmath330 , @xmath331 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "so at every point @xmath332 , @xmath333 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "+ we have proved that for each @xmath23 such that @xmath202 there a point @xmath334 such that at every point @xmath335 , @xmath313 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "take @xmath336 . at every point @xmath332 , for every agent @xmath23",
    "such that @xmath337 , @xmath313 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "* _ inductive case : _ suppose the lemma holds for every atom @xmath6 with @xmath338 , @xmath310 .",
    "we show that the lemma also holds for @xmath6 with @xmath339 .",
    "+ let @xmath23 be an agent with @xmath202 .",
    "clearly @xmath340 .",
    "there are two cases : 1 .",
    "the atom dependency graph of @xmath190 is acyclic , every child @xmath13 of @xmath6 has @xmath341 . by the inductive assumption , for each @xmath13",
    "there is a point @xmath342 such that at every point @xmath343 , @xmath344 iff @xmath345\\kern-0.15em\\right]}$ ] .",
    "the set of children of @xmath6 in the atom dependency graph of @xmath190 is the same as the set of atoms in the body of all clauses of the definition of @xmath6 .",
    "as @xmath192 is bounded , @xmath6 has a finite number of children in the atom dependency graph of @xmath190 and the definition of @xmath6 is finite .",
    "let @xmath346 is the maximum number in the set of all such above @xmath342 where @xmath13 is a child of @xmath6 .",
    "at every point @xmath347 , for every child @xmath13 of @xmath6 , by the inductive assumption , @xmath348 iff @xmath349\\kern-0.15em\\right]}$ ] .",
    "we prove that @xmath313 iff @xmath350\\kern-0.15em\\right]}$ ] .",
    "+ by lemma [ lemma : app10 ] , @xmath313 iff there is a rule @xmath293 in @xmath351 such that @xmath352 . by inductive assumption for every @xmath353 , @xmath348 iff @xmath349\\kern-0.15em\\right]}$ ] .",
    "moreover @xmath293 is also a rule in @xmath190 .",
    "thus @xmath313 iff there is a rule @xmath293 in @xmath190 such that @xmath298\\kern-0.15em\\right]}\\models bd$ ] iff @xmath301\\kern-0.15em\\right]}$ ] ( by lemma [ lemma : app10 ] ) .",
    "2 .   @xmath315 .",
    "as shown in 1 , for every @xmath24 such that @xmath354 there is a point @xmath355 , such that at every point @xmath356 , @xmath331 iff @xmath350\\kern-0.15em\\right]}$ ] .",
    "let @xmath357 be the maximum of all such @xmath355 .",
    "clearly , at every point @xmath332 , for every @xmath24 such that @xmath354 , @xmath331 iff @xmath350\\kern-0.15em\\right]}$ ] .",
    "+ follow similarly as case @xmath151 in base case of the proof , there is a point @xmath358 such that at every point @xmath359 , @xmath360 iff @xmath331 .",
    "it also means that at every point @xmath359 , @xmath313 iff @xmath350\\kern-0.15em\\right]}$ ] .",
    "+ we have proved that for each @xmath23 such that @xmath202 there a point @xmath334 such that at every point @xmath335 , @xmath313 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "take @xmath336 . at every point @xmath332 , for every agent @xmath23 such that @xmath337 , @xmath313 iff @xmath301\\kern-0.15em\\right]}$ ] .",
    "let @xmath104 be an io - acyclic and io - finite multiagent system",
    ". obviously @xmath104 is also bounded .",
    "let @xmath145 be a run of @xmath104 . by theorem [ theo:1 ] , @xmath145 is convergent . by lemma [ lemma : app12 ] , for every atom @xmath6 in @xmath199",
    "there is a point @xmath362 such that at every point @xmath363 , for every agent @xmath23 such that @xmath202 , @xmath364 iff @xmath365\\kern-0.15em\\right]}$ ] . as @xmath199 is finite ,",
    "take the largest number @xmath124 of all such @xmath362 s for every atoms @xmath6 in @xmath199 .",
    "obviously , at every point @xmath303 , for every agent @xmath23 , @xmath366 .",
    "thus @xmath145 is strongly convergent .",
    "the system is stabilizing and theorem [ theo:2 ] follows immediately .              , 2003 , _ co - operation and competition in alias : a logic framework for agents that negotiate _ , annals of mathematics and artificial intelligence , special issue on computational logic in multi - agent systems , volume 37 , nos . 1 - 2 , pp .",
    "28 - 37 , january 2003 .                        , 2001 , _ dialogues for negotiation : agent varieties and dialogue sequences _ ,",
    "atal01 , international workshop on agents , theories , architectures and languages , j.j .",
    "maher ed . , and `` intelligent agents viii '' , lnai 2333 , pp .",
    "405 - 421 , springer verlag , 2001 ."
  ],
  "abstract_text": [
    "<S> an information agent is viewed as a deductive database consisting of 3 parts :    * an observation database containing the facts the agent has observed or sensed from its surrounding environment . * </S>",
    "<S> an input database containing the information the agent has obtained from other agents * an intensional database which is a set of rules for computing derived information from the information stored in the observation and input databases .    </S>",
    "<S> stabilization of a system of information agents represents a capability of the agents to eventually get correct information about their surrounding despite unpredictable environment changes and the incapability of many agents to sense such changes causing them to have temporary incorrect information . </S>",
    "<S> we argue that the stabilization of a system of cooperative information agents could be understood as the convergence of the behavior of the whole system toward the behavior of a `` superagent '' , who has the sensing and computing capabilities of all agents combined . </S>",
    "<S> we show that unfortunately , stabilization is not guaranteed in general , even if the agents are fully cooperative and do not hide any information from each other . </S>",
    "<S> we give sufficient conditions for stabilization . </S>",
    "<S> we discuss the consequences of our results .    </S>",
    "<S> stabilization , cooperative information agents , logic programming </S>"
  ]
}