{
  "article_text": [
    "simple stochastic games ( ssgs ) are played by two players called @xmath0 and @xmath1 in a sequence of steps .",
    "the players move a pebble along the edges of a directed graph @xmath2 whose vertices are partionned into three sets : @xmath3 , @xmath4 , and @xmath5 .",
    "when the pebble is on a vertex of @xmath3 or @xmath4 , the corresponding player chooses an outgoing edge and moves the pebble along it . when the pebble is on a vertex of @xmath5 ( a _ random _ vertex ) , the outgoing edge",
    "is chosen randomly according to a fixed probability distribution .",
    "the players have opposite goals , as @xmath0 wants to reach a special sink vertex @xmath6 while @xmath1 wants to avoid it forever .",
    "an example of ssg is depicted in figure  [ fig : examplessg ] , with vertices of @xmath3 represented as @xmath7 s , vertices of @xmath4 represented as @xmath8 s , and vertices of @xmath5 represented as @xmath9 s .",
    "ssgs are a natural model of reactive systems .",
    "consider , for example , a hardware component .",
    "it can be modelled as an ssg , whose vertices represent the global states of the component and the target is some error state to avoid .",
    "the nature of a given vertex depends on who can influence the immediate evolution of the system : it is a @xmath1 vertex if the software can choose between different options , a @xmath0 vertex if there is a ( non - deterministic ) input asked from the user , and a random vertex if the evolution depends on a stochastic environment .",
    "an optimal strategy for @xmath1 can then be used as the basis for the synthesis of a `` good '' driver , _ i.e._one which minimises the probability of entering the error state independently of the behaviour of the user .",
    "the main algorithmic problem about ssgs is the computation of values of the vertices and optimal strategies for the players .",
    "this problem was first adressed by condon , who showed that deciding whether the value of a vertex is greater than @xmath10 belongs to np and co - np  @xcite .",
    "condon s algorithm guesses non - deterministically the values of vertices , which are rational numbers of linear size , and checks that they are solutions of some _ local optimality equations_. this algorithm is correct only for _ stopping _ games , where the pebble reaches either the target or a sink target with probability one , regardless of the players strategies .",
    "any ssg can be transformed in polynomial time into a stopping ssg with ( almost ) the same values , but it incurs a quadratic blow - up of the size of the game .",
    "three other algorithms for solving ssgs are presented in  @xcite .",
    "the first one computes the values of the vertices using a quadratic program with linear constraints .",
    "the second one computes iteratively from below the values of the vertices , and the third is a strategy improvement algorithm _",
    " la _ hoffman - karp  @xcite .",
    "the two latter algorithms , as the ones recently proposed in  @xcite , solve a series of linear programs which could be of exponential length . furthermore",
    ", solving a linear program requires high - precision arithmetic , even if it can be done in polynomial time  @xcite .",
    "the best randomised algorithms achieve sub - exponential expected time @xmath11  @xcite . in this paper",
    "we present two algorithms computing the values and optimal strategies in ssgs : the `` permutation - enumeration '' and the `` permutation - improvement '' algorithms .",
    "the common basis for both algorithms is that optimal strategies can be looked for in a subset of the positional strategies called _",
    "permutation strategies_. permutation strategies are derived from permutations over the random vertices . in order to find optimal strategies",
    ", the permutation - enumeration algorithm performs an exhaustive search among all permutation strategies , whereas the permutation - improvement algorithm performs successive improvements of permutation strategies , _  la _ hoffman - karp  @xcite .    the permutation - enumeration and the permutation - improvement algorithms share two advantages over existing algorithms .",
    "first , they perform much better on ssgs with few random vertices , as they run in polynomial time when the number of random vertices is logarithmic in the size of the game : it follows that the problem of solving ssgs is fixed - parameter tractable when the parameter is the number of random vertices .",
    "second , they do not rely on the transformation of the input ssg into a stopping ssg , which avoids the quadratic blow - up of the size of the game .",
    "moreover , the permutation - enumeration algorithm does not use linear or quadratic programming , ( it just computes the solutions to linear systems ) and its worst - case complexity is @xmath12 , where @xmath13 is the number of random vertices , @xmath14 is the number of edges and @xmath15 is the maximal bit - length of transition probabilities .",
    "the nominal complexity of the permutation - improvement algorithm is higher but we do not know any non - trivial lower bound for its complexity : the permutation - improvement algorithm may actually run in polynomial time .",
    "* outline . * in section  [ sec : defs ] , we provide formal definitions for ssgs , values and optimal strategies .",
    "we describe then in section  [ sec : playing ] the central notion of permutation strategies .",
    "section  [ sec : optimality ] presents the permutation - enumeration algorithm , based on the _ self - consistency _ and _ liveness _ properties .",
    "section  [ sec : heuristics ] introduces an improvement policy for permutations which leads to the permutation - improvement algorithm .",
    "a _ simple stochastic game _ is a tuple @xmath16 , where @xmath2 is a graph , @xmath17 is a partition of @xmath18 , and @xmath6 is a distinguished sink vertex in @xmath18 called the _",
    "target _ of the game .",
    "the transitions from the random vertices are equipped with probabilities described by the function @xmath19 $ ] , such that for all @xmath20 , @xmath21 , @xmath22 , and @xmath23 .",
    "an _ infinite play _",
    "@xmath24 is an infinite sequence @xmath25 of vertices such that for all @xmath26 .",
    "it is _ winning for @xmath0 _ if there is a @xmath27 such that @xmath28 ( as @xmath6 is a sink , it follows that @xmath29 ) .",
    "otherwise , @xmath24 is _ winning for @xmath1_. a _ finite play _ is a finite prefix of an infinite play .",
    "a ( pure ) _ strategy _ for @xmath0 is a mapping @xmath30 such that for each finite play @xmath31 ending in a @xmath0 vertex , @xmath32 .",
    "it is _ positional _ if it only depends on the last vertex of @xmath33 : @xmath34 .",
    "a play @xmath35 is _ consistent with @xmath36 _ if for every @xmath37 such that @xmath38 , @xmath39 .",
    "strategies for @xmath1 are defined analogously and are generally denoted by @xmath40 .",
    "the set of plays is made into a measurable space on the @xmath41-algebra generated by the canonical projections @xmath42 , where @xmath43  @xcite .",
    "once an initial vertex @xmath44 and two strategies @xmath36 and @xmath40 for players @xmath0 and @xmath1 have been fixed , the probability measure @xmath45 is defined by : @xmath46 the expectation of a real - valued , measurable and bounded function @xmath47 under @xmath45 is denoted @xmath48}$ ] .",
    "we will often use implicitly the following formulae which rule the probabilities and expectations once a finite prefix @xmath49 is fixed : @xmath50,\\tau[h]}_{h_i}}(\\gamma[h])\\enspace ,",
    "\\label{eq : pdecal}\\\\ { \\mathbb{e}^{\\sigma,\\tau}_{v}\\left[{\\varphi}\\mid v_0\\dots v_i = h_0 \\dots h_i\\right ] } & = & { \\mathbb{e}^{\\sigma[h],\\tau[h]}_{h_i}\\left[{\\varphi}[h]\\right]}\\enspace , \\label{eq : edecal}\\end{aligned}\\ ] ] where @xmath51(\\rho_0\\rho_1\\ldots ) = \\sigma(h_0\\ldots h_{i-1 } \\rho_0\\rho_1\\ldots)$ ] , and @xmath52 $ ] , @xmath53 $ ] , and @xmath54 $ ] are defined analogously .    if we fix only @xmath0 s strategy @xmath41 and the initial vertex @xmath44 , the target vertex will be reached with probability at least : @xmath55 where @xmath56 is the event @xmath57 .",
    "starting from @xmath44 , player @xmath0 has strategies that guarantee a winning outcome with a probability greater than : @xmath58 minus @xmath59 for any @xmath60 .",
    "symmetrically , @xmath1 has strategies that guarantee a winning outcome with a probability less than : @xmath61 plus @xmath59 for any @xmath60 .",
    "it is clear that @xmath62 . in the case of ssgs ,",
    "stronger results are known :    [ theo : pos ] let @xmath63 be a ssg . then , for any vertex @xmath64 , @xmath65 this common value is denoted by @xmath66 . furthermore , there are positional optimal strategies for both players , _ i.e._positional strategies @xmath67 and @xmath68 such that , for any strategies @xmath41 and @xmath69 : @xmath70      a ssg is _ normalised _ if the only vertex with value 1 is the target @xmath6 and there is only one ( sink ) vertex @xmath71 with value @xmath72 .",
    "our motivations for the introduction of this notion are twofold .",
    "first , several proofs are much simpler for normalised games .",
    "second , any ssg can be reduced to an equivalent normalised game in linear time and the resulting game is smaller than the original one .",
    "this reduction is presented on figure  [ fig : normalisation ] : it simply consists in merging the region with value one into @xmath6 and the region with value zero into a new sink vertex @xmath71 .",
    "normalisation . ]    in the remainder of this article , we assume that we are working on a normalised ssg @xmath73 , with @xmath74 random vertices .",
    "the existence of positional optimal strategies is a key property of ssgs and the cornerstone of many algorithms solving these games .",
    "the algorithms we propose rely on a refinement of this result : optimal strategies can be looked for among a subset of the positional strategies , the set of `` permutation strategies '' .    as a matter of fact , theorem  [ theo : pos ] is a corollary of results of the present paper .",
    "the proofs of our results often rely on the existence of values and optimal ( not only @xmath59-optimal ) strategies in ssgs .",
    "this could be avoided the main point is to use @xmath75 instead of @xmath76 but we felt that it was not worth the extra complexity .",
    "the main intuition underlying permutation strategies is that the only meaningful events in a play are the visits to random vertices . between two visits",
    "the players only strive to impose which random vertex will be visited next , and the result of their interaction can be easily predicted .",
    "this is illustrated by figure  [ fig : intuitions ] , which zooms on two details of figure  [ fig : examplessg ] .",
    "coherence and contention . ]    in the left part of figure  [ fig : intuitions ] , @xmath0 must choose between the two random vertices @xmath77 and @xmath78 ( refusing to choose is not really an option ) .",
    "there is no reason to choose @xmath77 in one of the vertices , and @xmath78 in the other .",
    "we could consider only the strategies `` always go to @xmath77 '' and `` always go to @xmath78 '' .",
    "in the right part of figure  [ fig : intuitions ] , we consider relationships between the two players strategies . from their respective vertices @xmath7 and @xmath8 , @xmath0 and @xmath1 can send the pebble to either @xmath79 or @xmath77 .",
    "we could restrict our attention to the cases where @xmath0 goes to one , and @xmath1 to the other .",
    "underlying these intuitions is the idea of a `` preference order '' over the random vertices . in the remainder of this article , we formalise it as a _ permutation _ : a one - to - one correspondance @xmath80 between @xmath5 and @xmath81 . for simplicity , we often write @xmath82 instead of @xmath83 and we consider the sink and target vertices as random vertices with the implicit assumption that they are respectively the lowest and greatest vertices : @xmath84 and @xmath85 .      once a permutation @xmath86 has been fixed , the @xmath80-strategies consist in @xmath0 trying to reach the highest ( with respect to @xmath80 ) possible random vertex , while @xmath1 tries to thwart her .",
    "notice that the situation is not exactly symmetric , since the burden of reaching a random vertex lies with @xmath0 : in case the pebble remains forever in controlled vertices then player @xmath1 wins .",
    "the formal definition of permutation strategies is based on the notion of _ deterministic attractor_.    [ defi : detatt ] let @xmath87 be a set of vertices .",
    "the deterministic attractor of @xmath0 to @xmath88 , denoted by @xmath89 , is computed recursively : @xmath90 an attracting strategy to @xmath88 for @xmath0 is a positional strategy @xmath41 such that : @xmath91 symmetrically , a trapping strategy out of @xmath88 for @xmath1 is a positional strategy @xmath69 such that : @xmath92    the _ @xmath80-regions _ associated with a permutation @xmath86 are defined as embedded deterministic attractors to the random vertices : @xmath93 & = & \\{{\\circledcirc}\\ } \\enspace , \\\\                  \\forall 1 \\le i \\le k , w_{{\\mathbf{f}}}[i ] & = & { \\operatorname{detatt}(\\{{{\\mathbf{f}}}_i,\\ldots , { { \\mathbf{f}}}_k,{\\circledcirc}\\ } ) } \\setminus \\bigcup_{j > i } w_{{\\mathbf{f}}}[j]\\enspace ,",
    "\\\\                  w_{{\\mathbf{f}}}[0 ] & = & \\{{\\otimes}\\ } \\enspace .",
    "\\end{aligned}\\ ] ]      the _ @xmath80-strategies _ @xmath94 and @xmath95 are strategies such that , on each @xmath96 $ ] :    1 .",
    "@xmath94 coincides with an attractor strategy to @xmath97 , 2 .",
    "@xmath95 coincides with a trapping strategy out of @xmath98 .",
    "the @xmath80-regions partition @xmath18 , so we extend the definition domain of @xmath86 to @xmath18 in a natural way : @xmath99 if @xmath100 $ ] .",
    "the following properties are easy to prove : @xmath101 if @xmath0 plays @xmath94 and @xmath1 plays @xmath95 from an initial vertex @xmath44 , the first random vertex reached by the pebble is the unique random vertex @xmath102 such that @xmath103 .",
    "figure  [ fig : regions ] describes the @xmath80-regions and @xmath80-strategies of the game of figure  [ fig : examplessg ] , for @xmath104 .",
    "-regions and @xmath80-strategies in the game of figure  [ fig : examplessg ] . ]      when both players use their respective permutation strategies , the probability that a pebble starting in @xmath44 reaches @xmath6 is denoted by @xmath105 : @xmath106    [ prop : calcstrat ] let @xmath80 be a permutation .",
    "the @xmath80-regions and the @xmath80-strategies can be computed in time @xmath107 and the @xmath80-values can be computed in time @xmath108 .",
    "the @xmath80-regions and @xmath80-strategies can be expressed in terms of _ deterministic _ games as they do not depend on what happens once a random vertex is reached .",
    "we can thus use the results of  @xcite to compute them in time @xmath109 . in order to compute the @xmath80-values ,",
    "we build a markov chain @xmath110 designed to mimic the behaviour of @xmath111 when the players use their @xmath80-strategies .",
    "intuitively , we merge each region @xmath96 $ ] into a single vertex @xmath37 ; formally , @xmath110 is a markov chain with states @xmath112 such that @xmath72 and @xmath113 are absorbing and , for every @xmath114 and @xmath115 , the transition probability from @xmath37 to @xmath116 is given by : @xmath117}{\\delta({{\\mathbf{f}}}_i)(v ) } \\enspace .\\ ] ]    the values @xmath118 $ ] of @xmath110 are computed as follows .",
    "let @xmath119 be the set of vertices from which @xmath113 is reachable in @xmath110 .",
    "then , for each @xmath120 , @xmath121 , and @xmath122 is the unique solution of the following linear system : @xmath123 which can be solved in time @xmath108  @xcite .",
    "for each @xmath64 , @xmath124 .",
    "in this section we describe the permutation - enumeration algorithm which computes optimal strategies for both players .",
    "this algorithm relies on the following key property of permutation strategies .",
    "[ thm : vstrat1 ] in every ssg , there exists a permutation @xmath80 such that @xmath94 is optimal for @xmath0 and @xmath95 is optimal for @xmath1 .",
    "this theorem suggests a very simple enumerative algorithm computing values and optimal strategies : check for each permutation @xmath80 whether the @xmath80-strategies are optimal .",
    "each test can be performed in polynomial time using linear programming  @xcite .",
    "however , linear programming requires high - precision arithmetic and is expensive in practice .",
    "our permutation - enumeration algorithm uses a simpler criterion based on a refinement of theorem  [ thm : vstrat1 ] : we look for permutations which are _ live _ and _ self - consistent_.      the permutation - enumeration algorithm is based on two simple properties on permutations : self - consistency and liveness .",
    "self - consistency expresses the adequation between _ a priori _ preferences ( permutation @xmath80 ) and resulting values ( the @xmath80-values @xmath125 ) .",
    "liveness stipulates that each random vertex has a positive probability to immediately lead to a better from @xmath0 s point of view region .",
    "[ defi : selfconsistency ] a permutation @xmath80 is self - consistent if : @xmath126    [ defi : liveness ] a permutation @xmath80 is live if : @xmath127 , { \\delta({{\\mathbf{f}}}_i)(v ) } > 0\\enspace.\\ ] ]    as we show below , the @xmath80-strategies associated with a live and self - consistent permutation @xmath80 are optimal and there is always such a permutation .",
    "the permutation - enumeration algorithm performs an exhaustive search for a live and self - consistent permutation .",
    "[ theo : algo2 ] the permutation - enumeration algorithm terminates and returns optimal strategies for @xmath0 and @xmath1 .",
    "its worst - case running time is @xmath12 .",
    "correctness and termination are proved in lemmas  [ lem : correctness ] and  [ lem : existence ] , respectively .",
    "the worst - case complexity follows from the fact that there are at most @xmath128 permutations and proposition  [ prop : calcstrat ] .    before we proceed with the proofs of the main lemmas ,",
    "let us make a case for liveness : figure  [ fig : caseliveness ] shows that self - consistency is not enough to guarantee the optimality of the resulting strategies .        in this excerpt from the game of figure  [ fig : examplessg ] ,",
    "@xmath0 s strategy in @xmath7 should be to send the pebble to @xmath77 , as @xmath1 could otherwise trap the play in @xmath129 .",
    "however , consider the permutation @xmath130 : @xmath1 sends the pebble from @xmath8 to @xmath78 to avoid @xmath79 ; @xmath0 sends the pebble from @xmath7 to @xmath8 to reach either @xmath79 or @xmath78 .",
    "we have thus @xmath131 . as a matter of fact , we have @xmath132 , so @xmath133 is self - consistent even though the @xmath133-values are not the correct ones .",
    "liveness forbids this kind of gambits from @xmath0 .",
    "it replaces , in this aspect , the `` stopping '' hypothesis of condon .      we first show that if a permutation @xmath80 is live and self - consistent , the @xmath80-strategies are optimal ( lemma  [ lem : correctness ] ) .",
    "we need two preliminary propositions .",
    "first , if @xmath80 is self - consistent and @xmath0 plays according to @xmath94 , the sequence @xmath134 is a submartingale and symmetrically if @xmath80 is self - consistent and @xmath1 plays according to @xmath95 the sequence @xmath134 is a supermartingale .    [",
    "prop : martingale ] let @xmath80 be a self - consistent permutation .",
    "then , for any strategies @xmath41 and @xmath69 for @xmath0 and @xmath1 , vertex @xmath44 , and integer @xmath37 , @xmath135 } \\geq { \\varphi}_{{\\mathbf{f}}}(v_i)\\enspace,\\\\ \\label{eq : supermartingale } & { \\mathbb{e}^{\\sigma,{\\tau_{{\\mathbf{f}}}}}_{v}\\left[{\\varphi}_{{\\mathbf{f}}}(v_{i+1 } ) \\mid v_0\\dots v_i\\right ] } \\leq { \\varphi}_{{\\mathbf{f}}}(v_i)\\enspace.\\end{aligned}\\ ] ]    in order to prove ( @xmath136 ) , it is enough to show that for any finite play @xmath137 , @xmath138 } & \\geq & { \\varphi}_{{\\mathbf{f}}}(h_i)\\enspace .",
    "\\label{eq : sub1 }      \\end{aligned}\\ ] ] depending on the owner of @xmath139 , ( [ eq : sub1 ] ) follows from one of the following properties of @xmath125 : @xmath140 the equations ( [ eq : ttt2 ] ) and ( [ eq : ttt1 ] ) follows from the definition of @xmath125 , and ( [ eq : ttt5 ] ) follows from the self - consistency of @xmath80 : by definition of the @xmath80-regions , if @xmath141 and @xmath142 then @xmath143 ( see  ) , so @xmath144 .",
    "the proof of   is similar and we do not detail it .",
    "second , we show a `` stopping property '' in the case where @xmath80 is live and @xmath0 plays @xmath94 .",
    "[ prop : live ] let @xmath80 be a live permutation . then , for any strategy @xmath69 for @xmath1 and initial vertex @xmath44 , @xmath145    by definition of liveness , @xmath146 } { \\delta({{\\mathbf{f}}}_i)(w)}\\ ] ] is positive .",
    "let @xmath147 and @xmath148 then the definition of @xmath94 yields : @xmath149 or , since @xmath6 and @xmath71 are sinks : @xmath150 equation ( [ eq : pdecal ] ) yields : @xmath151 hence @xmath152 hence proposition  [ prop : live ] .",
    "we can now prove the correctness of the permutation - enumeration algorithm :    [ lem : correctness ] let @xmath80 be a live and self - consistent permutation .",
    "then @xmath94 is optimal for @xmath0 and @xmath95 is optimal for @xmath1 .",
    "we first prove that @xmath94 ensures that a pebble starting from @xmath44 has probability at least @xmath105 to reach @xmath6 : @xmath153}\\label{eq : co2}\\\\                      & = &    \\lim_{i\\in{\\mathbb{n } } } { \\mathbb{e}^{{\\sigma_{{\\mathbf{f}}}},\\tau}_{v}\\left[{\\varphi}_{{\\mathbf{f}}}(v_i)\\right]}\\label{eq : co3}\\\\                      & \\ge & { \\mathbb{e}^{{\\sigma_{{\\mathbf{f}}}},\\tau}_{v}\\left[{\\varphi}_{{\\mathbf{f}}}(v_0)\\right ] } = { \\varphi}_{{\\mathbf{f}}}(v)\\label{eq : co4}\\enspace,\\end{aligned}\\ ] ] where ( [ eq : co2 ] ) comes from proposition  [ prop : live ] , ( [ eq : co3 ] ) is a property of expectations , and ( [ eq : co4 ] ) comes from proposition  [ prop : martingale ] .",
    "then , we show that @xmath95 ensures that a pebble starting from @xmath44 has probability at most @xmath105 to reach @xmath6 : @xmath154}\\label{eq : co5}\\\\                      & \\le & \\liminf_{i\\in{\\mathbb{n } } } { \\mathbb{e}^{\\sigma,{\\tau_{{\\mathbf{f}}}}}_{v}\\left[{\\varphi}_{{\\mathbf{f}}}(v_i)\\right]}\\label{eq : co6}\\\\                      & \\le & { \\mathbb{e}^{\\sigma,{\\tau_{{\\mathbf{f}}}}}_{v}\\left[{\\varphi}_{{\\mathbf{f}}}(v_0)\\right ] } = { \\varphi}_{{\\mathbf{f}}}(v)\\label{eq : co7}\\enspace,\\end{aligned}\\ ] ] where ( [ eq : co5 ] ) holds because @xmath6 is a sink and @xmath155 , ( [ eq : co6 ] ) is a property of expectations , and ( [ eq : co7 ] ) comes from proposition  [ prop : martingale ] .    thus , for any strategies @xmath41 and @xmath69 for @xmath0 and @xmath1 , @xmath156 which completes the proof of lemma  [ lem : correctness ]      now we show the existence of a live and self - consistent permutation ( lemma  [ lem : existence ] ) .",
    "our construction is based on proposition  [ prop : rec ] and its correctness on proposition  [ prop : valphi ] .",
    "[ prop : rec ] let @xmath87 be a set of vertices including the target vertex @xmath6 and @xmath157 be @xmath158 . then either @xmath159 or there is a random vertex @xmath44 in @xmath157 such that : @xmath160",
    "let @xmath161 be the set of vertices with maximal value in @xmath157 : @xmath162 and suppose that : @xmath163 let @xmath44 be a vertex in @xmath161 .",
    "as @xmath164 is normalised , we just need to show that @xmath165 , _ i.e._there is a strategy @xmath166 for @xmath1 such that for every strategy @xmath41 for @xmath0 , @xmath167 .    by definition of @xmath89",
    ", there is a positional strategy @xmath69 for @xmath1 such that @xmath168 , and it follows from the definition of @xmath161 that @xmath169 . as @xmath161 is also closed under random moves , a pebble starting in @xmath161 can only leave @xmath161 through a move of @xmath0 , which leads to @xmath170 as @xmath171 .    we define now a non - positional strategy @xmath166 in which @xmath1 plays according to @xmath69 as long as the play remains in @xmath161 and switches definitively to an optimal strategy the first time the pebble moves out of @xmath161 .",
    "we can thus partition the plays starting in @xmath44 and consistent with @xmath41 and @xmath166 depending on if and where the play gets out of @xmath161 : @xmath172 is the set of plays remaining forever in @xmath161 , and for each @xmath102 in @xmath173 , @xmath174 is the set of plays where @xmath102 is the first visited vertex outside of @xmath161 .",
    "clearly @xmath175 and by definition of the strategy @xmath166 , @xmath176 , @xmath177 . hence @xmath178",
    "and since this holds for every @xmath41 , @xmath179 .",
    "by definition of @xmath161 this implies @xmath180 .",
    "[ prop : valphi ] let @xmath80 be a live permutation such that : @xmath181 then @xmath80 is self - consistent",
    ".    note that under the same hypotheses , lemma  [ lem : correctness ] imply that @xmath80-strategies are optimal .",
    "we first show that : @xmath182 consider the strategy @xmath183 , which mimics @xmath94 until the first time the pebble reaches a random vertex and then switches definitively to an optimal strategy . by definition of @xmath94 ,",
    "the first random vertex belongs to @xmath184 , so @xmath183 ensures that a pebble starting in @xmath185 reaches @xmath6 with probability at least @xmath186 .",
    "a similar strategy @xmath187 for @xmath1 ensures that this probability is at most @xmath188 .",
    "so @xmath189 , and ( [ eq : ex1 ] ) follows .",
    "now we prove that @xmath76 and @xmath125 coincide . according to   and by definition of permutation strategies , @xmath190 so , if @xmath0 and @xmath1 play according to their @xmath80-strategies , the sequence @xmath191 is a martingale : @xmath192 } & = & \\operatorname{val}(v_i)\\enspace .",
    "\\label{eq : ex2 }          \\end{aligned}\\ ] ] consequenly , for every vertex @xmath44 , @xmath193 : @xmath194}\\label{eq : ex3}\\\\                                  & = &    \\lim_{i\\in{\\mathbb{n } } } { \\mathbb{e}^{{\\sigma_{{\\mathbf{f}}}},{\\tau_{{\\mathbf{f}}}}}_{v}\\left[\\operatorname{val}(v_i)\\right]}\\label{eq : ex4}\\\\                                  & = &    { \\mathbb{e}^{{\\sigma_{{\\mathbf{f}}}},\\tau}_{v}\\left[\\operatorname{val}(v_0)\\right ] } = \\operatorname{val}(v)\\label{eq : ex5}\\enspace ,          \\end{aligned}\\ ] ] where ( [ eq : ex3 ] ) comes from proposition  [ prop : live ] , ( [ eq : ex4 ] ) is a property of expectations , and ( [ eq : ex5 ] ) comes from ( [ eq : ex2 ] ) .",
    "since @xmath76 and @xmath125 coincide , the hypothesis yields the self - consistency of @xmath80 .",
    "this completes the proof of proposition  [ prop : valphi ] .",
    "[ lem : existence ] there exists a live and self - consistent permutation .",
    "we use iteratively proposition  [ prop : rec ] in order to build a permutation @xmath80 such that , for every @xmath195 ,    1 .",
    "@xmath196 ; 2 .   @xmath197 .    by construction @xmath80 is live and @xmath198 .",
    "proposition  [ prop : valphi ] yields the self - consistency of @xmath80 , and lemma  [ lem : existence ] follows .",
    "a drawback of the permutation - enumeration algorithm is that it considers each and every possible permutation of the random vertices , so @xmath199 is a lower bound for the worst - case complexity of this algorithm .",
    "strategy - improvement algorithms avoid such enumerations , instead these algorithms proceed by successive improvements of a strategy : information about sub - optimality of a strategy is used to determine a `` better '' strategy , which ensures convergence to an optimal strategy . in this section , we emulate this idea with a permutation - improvement algorithm .      starting from an initial permutation @xmath80 , we would like to improve @xmath80 again and again until the permutation strategies @xmath94 and @xmath95 are optimal . to test optimality",
    "we check that @xmath80 is live and self - consistent ( see lemma  [ lem : correctness ] ) . when @xmath80 is live but _",
    "not _ self - consistent we compute a new permutation @xmath133 which is live and``better '' than @xmath80 .",
    "a natural improvement policy consists in choosing @xmath133 consistent with the @xmath80-values i.e. @xmath133 refines the pre - order induced by @xmath125 .",
    "unfortunately this is too nave : the corresponding algorithm does not always terminate , a counter - example is given by figure  [ fig : naive ] .",
    "a counter - example for the nave improvement algorithm . ]",
    "if we start with the permutation @xmath200 , the @xmath80-strategies are as follows : in @xmath7 @xmath0 goes to @xmath77 and in @xmath8 @xmath1 goes to @xmath78 .",
    "hence , the @xmath80-values of vertices @xmath79 , @xmath78 , and @xmath77 are respectively @xmath201 , @xmath202 , and @xmath203 , so @xmath80 is not self - consistent .",
    "the next permutation is @xmath204 , and the following @xmath133-strategies ensue : in @xmath7 @xmath0 goes to @xmath79 and in @xmath8 @xmath1 goes to @xmath7 .",
    "the @xmath133-values of vertices @xmath77 , @xmath79 , and @xmath78 are respectively @xmath203 , @xmath205 , and @xmath206 , so @xmath133 is not self - consistent either",
    ". moreover , the next permutation is @xmath200 , so the nave algorithm oscillates endlessly between @xmath80 and @xmath133 , never reaching the correct permutation @xmath207 .",
    "the correct permutation - improvement policy is a bit more complex : given a live but not self - consistent permutation @xmath80 , we choose a permutation @xmath133 which is live and self - consistent in the one - player game @xmath208 $ ] , where vertices of player @xmath0 have only one outgoing edge : the edge consistent with the positional @xmath80-strategy @xmath94 .",
    "this improvement policy guarantees that the value of @xmath209 is greater than the value of @xmath94 ( see lemma  [ lem : progress ] ) and is implemented by the following algorithm .",
    "pick a live permutation @xmath80    the computation of a live and self - consistent permutation in @xmath210 $ ] in line  [ line : improve ] relies on the computation of values of the one - player game @xmath210 $ ] .",
    "details are given in the proof of the following theorem .",
    "[ thm : improve ] the permutation - improvement algorithm terminates and returns optimal strategies for @xmath0 and @xmath1 in at most @xmath199 improvement steps .",
    "furthermore , each improvement step can be carried out in polynomial time .    according to lemma  [ lem : doubleliveness ] the algorithm returns a permutation which is both live and self - consistent in @xmath111 hence according to lemma  [ lem : correctness ] the corresponding permutation strategies are optimal in @xmath111 which proves correctness of the algorithm .",
    "termination and the maximal number of iterations follows from lemma  [ lem : progress ] , which proves that sucessive strategies @xmath94 have better and better values .",
    "the computation of a live and self - consistent permutation in @xmath210 $ ] in line  [ line : improve ] is achieved in polynomial time in the following way .",
    "first , compute the values of the one - player game @xmath210 $ ] using linear programming  @xcite .",
    "second , build in linear time a live permutation @xmath133 consistent with these values like in the proof of lemma  [ lem : existence ] .",
    "the permutation @xmath133 is such that @xmath211 , where @xmath212 denotes the values in the game @xmath210 $ ] .",
    "according to proposition  [ prop : subgame ] the game @xmath210",
    "$ ] is normalised hence proposition  [ prop : valphi ] guarantees that @xmath133 is consistent in @xmath210 $ ] .",
    "let us compare briefly the permutation - enumeration and the permutation - improvement algorithms .",
    "each improvement step of the permutation - improvement algorithm requires the computation of values of a one - player ssg , which can be performed using linear programming .",
    "these values could be computed as well using a permutation - improvement policy or a strategy - improvement algorithm in order to avoid linear programming altogether .",
    "either way , we have to forfeit one of the advantages of the permutation - enumeration algorithm : the computational simplicity of its inner loop . on the other hand",
    ", we do not know any non - trivial lower bound on the number of loops in a run of the permutation - improvement algorithm : it may be polynomial .      the correctness proof is based on the following two results .",
    "[ lem : doubleliveness ] let @xmath41 be a positional strategy for @xmath0 and @xmath80 be a permutation .",
    "if @xmath80 is live in @xmath213 $ ] it is also live in @xmath111 .",
    "let @xmath214 and @xmath215 denote the @xmath80-regions in @xmath111 and @xmath213 $ ] , respectively . by definition , @xmath216 $ ] is the deterministic attractor of @xmath0 to @xmath217 in @xmath111 , while @xmath218 $ ] is the same attractor in @xmath213 $ ] .",
    "as the moves of @xmath0 are restricted in @xmath213 $ ] , we get @xmath219 \\subseteq \\bigcup_{j > i}w_{{\\mathbf{f}}}[j ] \\enspace .",
    "\\label{eq : double1}\\ ] ] thus , the liveness of @xmath80 in @xmath164 follows from its liveness in @xmath220 $ ] , and lemma  [ lem : doubleliveness ] ensues .",
    "[ prop : subgame ] let @xmath80 be a live permutation .",
    "then @xmath210 $ ] is normalised .    in the proof of proposition  [ prop : live ] , we have shown the existence of a positive real number @xmath221 such that for any strategy @xmath69 for min and vertex @xmath222 , @xmath223 hence only @xmath71 has value @xmath72 in @xmath210 $ ] .",
    "clearly only @xmath6 has value @xmath224 in @xmath210 $ ] hence proposition  [ prop : subgame ] follows .      the value of a strategy @xmath41 is denoted @xmath225 and defined by : @xmath226 for proving termination of the permutation - improvement algorithm we prove that successive strategies @xmath94 chosen by the algorithm have greater and greater values .",
    "[ lem : progress ] let @xmath80 be a live permutation in @xmath111 and @xmath133 be a live and self - consistent permutation in @xmath210 $ ] .",
    "then for all @xmath64 , @xmath227 moreover , if for all @xmath64 , @xmath228 then @xmath133 is self - consistent in @xmath111 .",
    "a key remark in the proof of lemma  [ lem : progress ] is that : @xmath229 let @xmath230 be the @xmath133-values in @xmath210 $ ] .",
    "the self - consistency of @xmath133 in @xmath210 $ ] is : @xmath231 lemma  [ lem : correctness ] applied to @xmath210 $ ] implies that the @xmath133-strategy of player @xmath1 in @xmath210 $ ] is optimal in @xmath210 $ ] hence @xmath232 and ( [ eq : coherence ] ) follows .",
    "consider now the sequence @xmath233 , where @xmath234 is the strategy where @xmath0 plays according to @xmath209 until the pebble has visited @xmath235 random vertices , and plays according to @xmath94 afterwards .",
    "in particular @xmath236 .",
    "we show that for every vertex @xmath44 the sequence @xmath237 is non - decreasing and that its limit is less than @xmath238 .",
    "since @xmath236 this will prove lemma  .",
    "we first show by induction that for any integer @xmath235 , @xmath239 _ basis ( @xmath240 ) : _ we have to prove that values of @xmath241 are greater than values of @xmath242 .",
    "let @xmath44 be a vertex , @xmath37 be the index of the @xmath133-region of @xmath44 in @xmath164 , and @xmath116 be the index of the @xmath133-region of @xmath44 in @xmath208 $ ] .",
    "as the moves of @xmath0 are restricted in @xmath208 $ ] the definition of the @xmath133-regions gives @xmath243 and ( [ eq : coherence ] ) yields : @xmath244 if @xmath0 plays with @xmath241 , the definition of @xmath209 ensures that the first random vertex belongs to @xmath245 , so @xmath246 and   yields : @xmath247 on the other hand we prove : @xmath248 let @xmath230 denote @xmath133-values in @xmath249 $ ] .",
    "we have already proved above that @xmath230 is equal to @xmath212 . by definition of @xmath116",
    ", @xmath250 is the first random vertex in a play in @xmath210 $ ] starting from @xmath44 and consistent with a @xmath133-strategy for @xmath1 in @xmath210 $ ] hence @xmath251 which yields  .",
    "it follows from ( [ eq : ii1 ] ) , ( [ eq : ii2 ] ) , and ( [ eq : ii3 ] ) that ( [ eq : ii ] ) holds for @xmath252 .",
    "_ inductive step ( @xmath253 ) : _ the strategies @xmath254 and @xmath255 coincides with @xmath209 until the first visit to a random vertex .",
    "then @xmath254 switches to @xmath255 while @xmath255 switches to @xmath256 . by induction hypothesis ,",
    "@xmath257 , so @xmath258 and ( [ eq : ii ] ) holds for @xmath259 .",
    "now we show that for every @xmath44 , @xmath260 .",
    "let @xmath69 be a strategy for @xmath1 .",
    "we have : @xmath261 where ( [ eq : pro1 ] ) follows from proposition  [ prop : live ] , ( [ eq : pro3 ] ) holds because @xmath209 coincides with @xmath234 for at least @xmath235 steps , and ( [ eq : pro4 ] ) by event inclusion and by definition of the value .",
    "this holds for every strategy @xmath69 hence @xmath262 .",
    "altogether , @xmath263 hence ( [ eq : morre ] ) , which achieves to prove the first part of the lemma .",
    "let us suppose now that @xmath264 .",
    "equation ( [ eq : coherence ] ) yields : @xmath265 we can thus apply proposition  [ prop : valphi ] to @xmath133 in @xmath266 $ ] which yields the self - consistency of @xmath133 in @xmath266 $ ] . by definition of @xmath133-zones ,",
    "they coincide in @xmath164 and @xmath267 $ ] hence the @xmath133-values are equal in @xmath164 and @xmath266 $ ] and @xmath133 is also self - consistent in @xmath164 .",
    "we have presented two algorithms computing optimal strategies in simple stochastic games : the permutation - enumeration and the permutation - improvement algorithms . both of them rely on the existence of optimal permutation strategies .",
    "the permutation - enumeration algorithm simply tests every permutation until it finds a live and self - consistent one .",
    "the permutation - improvement algorithm uses a smarter policy in order to choose a `` better '' permutation in the next round , _  la _ hoffman - karp .",
    "the permutation - enumeration algorithm has exponential worst - case complexity but it is a witness that solving ssgs is fixed - parameter tractable when the parameter is the number of random vertices . the nominal complexity of the permutation - improvement algorithm is a bit higher but we do not know any non - trivial lower bound on the number of improvement steps : the permutation - improvement algorithm may actually run in polynomial time .      *",
    "acknowledgements * we would like to thank marcin jurdziski for some fruitful discussions , the anonymous reviewers for several useful suggestions and julien cristau for his invaluable comments during the writing of the final version .",
    "anne condon .",
    "n algorithms for simple stochastic games . in _ advances in computational complexity theory _ , volume  13 of _ dimacs series in discrete mathematics and theoretical computer science _ , pages 5173 .",
    "american mathematical society , 1993 ."
  ],
  "abstract_text": [
    "<S> simple stochastic games are two - player zero - sum stochastic games with turn - based moves , perfect information , and reachability winning conditions .    </S>",
    "<S> we present two new algorithms computing the values of simple stochastic games . </S>",
    "<S> both of them rely on the existence of optimal _ permutation strategies _ , a class of positional strategies derived from permutations of the random vertices . </S>",
    "<S> the `` permutation - enumeration '' algorithm performs an exhaustive search among these strategies , while the `` permutation - improvement '' algorithm is based on successive improvements , _  la _ hoffman - karp .    </S>",
    "<S> our algorithms improve previously known algorithms in several aspects . </S>",
    "<S> first they run in polynomial time when the number of random vertices is fixed , so the problem of solving simple stochastic games is fixed - parameter tractable when the parameter is the number of random vertices . </S>",
    "<S> furthermore , our algorithms do not require the input game to be transformed into a stopping game . finally , the permutation - enumeration algorithm does not use linear programming , while the permutation - improvement algorithm may run in polynomial time . </S>"
  ]
}