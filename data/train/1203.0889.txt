{
  "article_text": [
    "bulk synchronous execution / communication models are reaching their limit as the amount of concurrency required in high performance computing applications increases .",
    "this problem is further exacerbated when the core computational kernels are naturally load imbalanced , which may increase the overall idle process time .    in this paper , we focus on _ fast _ @xmath1-body methods such as the fast multipole method ( fmm ) on shared - memory multicore architecture .",
    "fmms have a wide range of applications in astrophysics @xcite , acoustics @xcite , elastodynamics @xcite , electromagnetics @xcite , molecular electrostatics @xcite , and quantum physics @xcite .",
    "such methods can reduce the complexity of the @xmath1-body problem from @xmath2 to @xmath0 , while retaining the arithmetic intensity . on the other hand , they inherently present load balancing issues due to the irregularity of the data distribution and dynamic nature of the application .",
    "fmms are therefore a representative class of load imbalanced algorithms for computational science .",
    "one natural solution to this challenging problem is the data flow programming model  @xcite , which consists of expressing the application using task - based parallelism .",
    "the whole application can then be pictured as a directed acyclic graph ( dag ) , where nodes represent computational tasks and edges define the data dependencies among them . a dynamic runtime system is then employed to efficiently schedule the different tasks over the available processing units and to ensure the data dependencies are not violated for numerical correctness purposes .",
    "many related works using dynamic scheduling mainly in the dense linear algebra area ( dla )  @xcite have been demonstrated in the last few years for solving dense linear systems of equations  @xcite as well as eigenvalue and singular value problems  @xcite .",
    "these new _ tile _ algorithms have been integrated into the plasma  @xcite high performance dla library targeting x86 multicore platforms , which relies on the dynamic runtime system quark  @xcite to distribute the tasks to worker threads . in the same token",
    ", the magma library  @xcite solves dla algorithms targeting rather hybrid platforms composed of x86 multicore enhanced with hardware accelerators ( e.g. , gpus ) using the starpu  @xcite framework as the task scheduler .",
    "some efforts have recently been initiated to extend the plasma and magma libraries for distributed memory environment , using the dynamic runtime dague  @xcite .",
    "it is noteworthy to mention that there are also other dla research works based on the same fundamental ideas  @xcite i.e. , using a data - driven execution framework .",
    "all these numerical frameworks will eventually supersede the state - of - the - art dla libraries",
    "i.e. , lapack  @xcite and scalapack  @xcite , for shared and distributed memory systems , respectively .",
    "similar performance numbers could have been actually achieved by using a static scheduler  @xcite , where each worker thread knows its workload ahead of time .",
    "this is mainly because dla algorithms are generally well load balanced and compute intensive enough so that the overhead of the dynamic scheduler is hidden by the computational load of the tasks .",
    "in fact , the real benefit of using the aforementioned dynamic runtime framework for dla , is to achieve high productivity in terms of parallel implementation .",
    "therefore , the dynamic feature of the runtime is not exploited at all for such well balanced algorithms .",
    "it is in this context that @xmath1-body methods are an interesting candidate for dynamic scheduling of tasks based on data dependencies .",
    "@xmath1-body methods also have computationally intensive kernels and would indeed fit well with the data - driven execution model mentioned previously .",
    "the quark - enabled fmm implementation presented in this paper achieves a linear speedup on 16 intel xeon cores .",
    "the remainder of this paper is organized as follows : section  [ sec : fmm ] gives a detailed overview of the fast multipole method as well as highlighting the load imbalance challenge and possible ways to fix it .",
    "section  [ sec : runtime ] recalls some related works in the dynamic runtime area , describes the general principles and features of the quark scheduler and demonstrates how high productivity could be achieved using this runtime with very small intrusions into the original sequential code .",
    "section  [ sec : impl ] presents the implementation details of our fmm code associated with the dynamic scheduler quark .",
    "section  [ sec : results ] gives the performance results on a quad - socket quad - core intel xeon system ( 16 cores total ) .",
    "finally , section  [ sec : conclusion ] summarizes the results of this paper and discusses future work .",
    "this section provides an overview of fast multipole methods , describes the inherent load imbalance issue and shows how task scheduling may efficiently resolve this issue .",
    "the fast multipole method ( fmm ) is a hierarchical @xmath1-body solver , which calculates the interaction of @xmath1 bodies in @xmath0 complexity .",
    "it has high arithmetic intensity @xcite and shows good scalability on large gpu based systems @xcite , and also large cpu based systems @xcite .",
    "it possesses a rare combination of linear complexity of the algorithm , high arithmetic intensity of the kernels , and locally - dominant communication pattern .",
    "a schematic of the flow of the fmm algorithm is shown in figure  [ fig : kernels ] .",
    "the fmm consists of six independent stages , some of which have data dependencies on others .",
    "the domain is partitioned into cells in a hierarchical manner using an octree . in this octree structure",
    ", we refer to the whole domain as the _ root _ cell , and the smallest cells at the bottom as _ leaf _ cells .",
    "the depth of the tree is chosen so that the number of particles per leaf cell remains constant .",
    "the particle distribution can be irregular in which case the tree structure would become highly adaptive .    the first stage is the particle - to - multipole ( p2 m ) kernel , where the mass / charges of the particles are translated into multipole expansions at the center of the leaf cells . the next stage is the multipole - to - multipole ( m2 m ) kernel , where the multipole expansion at the center of the smaller cells are translated to the center of the larger cells .",
    "once the multipole expansions are determined , they can be translated to local expansions using the multipole - to - local ( m2l ) kernel .",
    "note that the m2l kernel can only be performed for _ well separated _ cells as shown in gray in figure  [ fig : kernels ] .",
    "the criteria for choosing well separated cells is based on the ratio between the cell size and their distance from each other @xcite , or by using the parent - neighbor - child relationship in the tree @xcite .",
    "since the neighboring cells at the leaf level will never be handled by the m2l kernel , this part is calculated directly by a particle - to - particle ( p2p ) kernel .",
    "once the local expansions are calculated , they are translated to the center of smaller cells by the local - to - local ( l2l ) kernel .",
    "finally , the local expansion at the leaf cell is used to evaluate the solution on the particle via the local - to - particle ( l2p ) kernel .",
    "we refer the reader to @xcite for a concise presentation of the mathematical formulae for the individual stages , and @xcite for a detailed derivation of these kernels .        out of the six stages of fmm ,",
    "the m2l and p2p consume most of the calculation time .",
    "this is easy to see because p2 m and l2p are performed once per leaf cell , and m2 m and l2l are performed once per cell , while m2l is performed hundreds of times per cell .",
    "the p2p kernel is also a dominant component of the calculation , since the work load between m2l and p2p is always balanced by selecting the number of particles per leaf cell to an optimum value .",
    "the optimum number of particles per leaf cell depends on the efficiency of the kernel implementation and also the hardware which they run on .",
    "the p2p kernel has very high arithmetic intensity ( flop / byte ) and is unlikely to become bandwidth limited on any architecture , whereas the m2l kernel could become bandwidth limited if the order of multipole expansions is small and the architecture has low memory bandwidth relative to it s arithmetic capability .",
    "an important difference between the well known domain decomposition problem of meshes , and domain decomposition of fmms , is that each partition in the fmm requires information from a global ( but hierarchical ) halo region , as shown in figure  [ fig : kernels ] .",
    "when the particle distribution is irregular and the tree structure is adaptive , load balancing these m2l / p2p kernels becomes a non - trivial task .",
    "different target cells will have a different number of source cells to consider , so equally partitioning the domain will result in load imbalance .",
    "furthermore , the dynamic nature of the @xmath1-body simulation necessitates frequent repartitioning and load balancing , so the overhead must be small . a clever way to solve",
    "this dilemma is to record the work load from the previous time step and use it to repartition for the present step .",
    "such strategies were first used in the early 90 s on both sheared memory architectures @xcite and distributed memory architectures @xcite .",
    "the basic idea of using information from the previous step to repartition the present step , can be used with any partitioning scheme such as orthogonal recursive bisection ( orb ) @xcite , partitioning morton / hilbert keys @xcite , and graph based partitioning @xcite .",
    "the work load from the previous step can be used as weights in any of these originally unweighted partitioning schemes .",
    "there are many subtleties in the implementation of these partitioning schemes that affect their practical usefulness . in order to illustrate these subtleties",
    ", we first describe the key differences between the two types of tree structures ; rectangular binary trees resulting from orb , and cubic octrees .",
    "the orb subdivides the domain into rectangular cuboids , while cubic octrees always subdivide into perfect cubes .",
    "since orb always divides into equal number of particles ( which could be weighted according to the previous work load ) the resulting binary tree will be perfectly balanced , and there will be no adaptivity in the tree structure itself . when the number of processes is not a power of two , it is a trivial matter to adjust the subdivisions so that the tree remains balanced .",
    "therefore , in terms of load balancing , this is an ideal tree structure . on the other hand",
    ", cubic octrees will result in an adaptive tree structure with different depth for different branches if the particle distribution is irregular .",
    "the advantage of using cubic octrees is the direct correspondence between the proximity of the nodes in the tree and the geometrical proximity of the cells which they represent .",
    "this means morton / hilbert keys can be used to determine the geometrical location of the cell and vice versa .",
    "therefore , neighbor lists for p2p kernels and well separated lists for m2l kernels can be calculated from the morton / hilbert keys without traversing the tree and without any explicit information about the size and distance of cells .",
    "furthermore , the structured layout of cells permits the use of symmetry in the m2l kernels to reduce redundant computation / storage .",
    "however , load balancing adaptive octrees remains an open area of research @xcite . also , incrementally rebalancing the tree is much simpler for the rectangular binary tree since the tree structure remains constant and only the cell boundaries are updated , whereas the cubic octree requires alteration of the tree structure along with the migration of particles .    in parallel fmms , the tree structure",
    "is used for two separate purposes ; a ) partitioning and balancing the work / communication , and b ) traversal that determines the list of cells for m2l / p2p kernels .",
    "the rectangular binary tree is suitable for the former , while the cubic octree is more appropriate for the latter .",
    "there are three approaches that can be taken ; case a.  use rectangular binary tree for partitioning and cubic octree for traversal \" @xcite , case b.  use cubic octree for both \" @xcite , and case c  use rectangular binary tree for both \" .",
    "there are many techniques that can be applied to overcome the weakness of each of these methods , and as far as the authors are aware , there is no clear conclusion as to which method is superior .",
    "static partitioning of the global tree structure and bulk - synchronous communication of the let are common denominators for the approaches mentioned above . as the amount of concurrency required in future architectures continues to increase exponentially",
    ", these bulk - synchronous execution models will not be able to scale up forever .",
    "the convectional technique of using work / communication imbalance in the previous step to incrementally rebalance the current step can be thought of as a dynamic load balancing scheme in the broad sense .",
    "however , the temporal granularity of the load balancing is restricted to one time step , and within that time step the load balancing is static .",
    "one could argue that the particle distribution and tree structure only change between time steps , and therefore there is no need to have a finer granularity of load balancing if the data structure does not change .",
    "this is true if all threads and all processes on all nodes of a large capability machine performed at a constant performance with 0 % failure rate .",
    "the fact of the matter is that load balancing on future architectures must also be fault tolerant .",
    "furthermore , a single time step can take more than 100 seconds in some applications @xcite , and it is definitely worthwhile to load balance at finer temporal granularity .",
    "data - driven dynamic task scheduling can solve this issue by stealing work from busy threads , while optimizing the data flow at the same time .",
    "since moving data is relatively expensive compared to computing data , it is extremely important that the data movement is optimized . in the following section",
    ", we will give an overview of quark , which is a tool that does precisely what has been described above .",
    "this section gives an overview of different dynamic runtime schedulers and highlights then the main features of quark , which is the task scheduler selected to run the fmm code on homogeneous x86 shared - memory multicore architecture .",
    "by now , multicore processors are ubiquitous in both low - end consumer electronics and high - end servers and supercomputer large installations .",
    "this leads to the emergence of numerous multithreading frameworks , both open - source and commercial , embracing the idea of task scheduling : cilk  @xcite , intel threading building blocks  @xcite , openmp ( tasking features )  @xcite , just to name a few prominent examples . from our perspective ,",
    "one especially important category of such frameworks are the multithreading systems based on data flow principles .",
    "they represent the computation as a direct acyclic graph ( dag ) and schedule tasks at runtime through resolution of data hazards : read after write ( raw ) , write after read ( war ) and write after write ( waw ) .",
    "queueing and runtime for kernels ( quark ) is an example of such a system .",
    "three others , very similar to some extend , academic projects are also available : smpss  @xcite from barcelona supercomputer center , supermatrix  @xcite from the university of texas at austin and starpu  @xcite from inria bordeaux .",
    "while all four systems have their strength and weaknesses , quark  @xcite has vital extensions for use in a numerical library as well as at the application level .",
    "there are many details about the internals of the scheduler , its dependency analysis , memory management , and other performance enhancements that are not covered here .",
    "however , information about an earlier version of this scheduler can be found in  @xcite .    [",
    "[ description - of - dependency - types . ] ] description of dependency types .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the authors describe briefly the scheduling techniques of quark . in order for a scheduler to be able to determine dependencies between the tasks",
    ", it needs to know how each task is using its arguments .",
    "arguments can be value , which are copied to the task , or they can be input , output , or inout , which have the expected meanings . given the sequential order that the tasks are added to the scheduler , and the way that the arguments are used , we can infer the relationships between the tasks . a task can read a data item that is written by a previous task ( read - after write raw dependency ) ; or a task can write a data item that is written by previous task ( write - after - write waw dependency ) ; a task can write a data time that is read by a previous task ( write - after - read war dependency ) . the dependencies between the tasks form an implicit dag , however this dag is never explicitly realized in the scheduler .",
    "the structure is maintained in the way that tasks are queued on data items , waiting for the appropriate access to the data .",
    "the tasks are inserted into the scheduler , which stores them to be executed when all the dependencies are satisfied .",
    "that is , a task is ready to be executed when all parent tasks have completed .",
    "the execution of ready tasks is handled by worker threads that simply wait for tasks to become ready and execute them using a combination of default tasks assignments and work stealing .",
    "[ [ from - sequential - nested - loop - code - to - parallel - execution . ] ] from sequential nested - loop code to parallel execution .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the scheduler is designed to start from the sequential code ( c , c++ , fortran ) , in which calls to computational tasks are exposed .",
    "this is intended to make it easier for algorithm designers to experiment with algorithms and design new algorithms .",
    "each of the calls to the core routines is substituted by a call to a wrapper that decorates the arguments with their sizes and their usage ( ` input ` , ` output ` , ` inout ` , ` nodep ` , ` value ` ) .",
    "the tasks are inserted into the scheduler , which stores them to be executed when all the dependencies are satisfied .",
    "that is , a task is ready to be executed when all parent tasks have completed .",
    "the execution of ready tasks is handled by worker threads that simply wait for tasks to become ready and execute them using a combination of default tasks assignments and work stealing .",
    "the thread doing the task insertion is referred to as the master thread . under certain circumstances ,",
    "the master thread will also execute computational tasks .",
    "figure  [ fig : scheduler - architecture ] provides an idealized overview of the architecture of the dynamic scheduler .",
    "[ [ scheduling - a - window - of - tasks . ] ] scheduling a window of tasks .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    if we were to unfold and retain the entire dag of tasks for a large problem , we would be able to perform some interesting analysis with respect to dag scheduling and critical paths .",
    "however , the size of the data structures would quickly grow overwhelming .",
    "our solution to this is to maintain a configurable window of tasks .",
    "the implicit dag is then traversed through this sliding window , which should be large enough to ensure all cores are kept busy .",
    "when this window size is reached , the core involved in inserting tasks does not accept any more tasks until some are completed .",
    "the usage of a window of tasks has implications in how the loops of an application are unfolded and how much look ahead is available to the scheduler .",
    "[ [ data - locality - and - cache - reuse . ] ] data locality and cache reuse .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    it has been shown in the past that the reuse of memory caches can lead to a substantial performance improvement in execution time .",
    "since we are working with data structures that should fit in the local caches on each core , there is a feature which gives the ability to hint the cache locality behavior .",
    "a parameter in a call can be decorated with the locality flag in order to tell the scheduler that the data item ( parameter ) should be kept in cache if possible . after a computational core ( worker )",
    "executes that task , the scheduler will assign by - default any future task using that data item to the same core . note that the work stealing can disrupt the by - default assignment of tasks to cores .",
    "+ the next section discusses further implementation details of the quark integration into the original fmm source code .",
    "as mentioned in section [ sec : fmm ] , the m2l and p2p kernels are the dominant part of the fmm calculation . therefore , as a first step , we decided to implement the dynamic scheduling by considering as a task each of these kernels . in our implementation , the m2l and p2p kernels exist inside a _ dual tree traversal _",
    "routine ( the _ interact _ procedure ) .",
    "the _ dual tree traversal _ is a method to find all pairs of well separated cells in the octree in @xmath0 time @xcite .",
    "it is more general than the commonly used adaptive lists @xcite because the cells need not be perfect cubes .",
    "the cells can actually be any shape as long as they are mutually exclusive and are grouped hierarchically .",
    "furthermore , the definition of well - separateness can be adjusted more smoothly because the definition of neighboring cells is based on the distance instead of  how many cells to skip \" .",
    "this allows the exclusion of the corner cells , and yields a list that is closer to a sphere than a cube .",
    "once a pair of well separated cells are determined , the m2l kernel is called .",
    "when the dual tree traversal reaches a pair of leaf cells , the p2p kernel is called . in our initial implementation",
    ", the quark interface was placed at the level of these m2l / p2p kernel calls .",
    "every time the m2l / p2p kernel was called , this task would be queued by itself .",
    "then , quark would resolve the data dependency and dynamically schedule the task onto an available worker thread .",
    "however , it turned out that the overhead of the task scheduler was too large to be implemented at this granularity .",
    "in other words , there were too many tiny tasks to schedule .",
    "note that this is not a matter of arithmetic intensity , but the absolute size of both the operations and data being too small .    in order to address the issue above",
    ", we implemented a mechanism , which could schedule tasks of arbitrary ( controllable ) granularity .",
    "this was done by interfacing quark at a higher level in the tree traversal .",
    "grouping fine - grained tasks naturally follow good data locality guidelines by retaining data in caches for as long as the computation continues .",
    "quark does not migrate threads that are in the state of execution . and the look - up and update of the data dependence information takes place only once per each merged _ super _ task .",
    "the savings in overhead will come from both lack of cache memory pollution from quark s internal data structures and elimination of tens if not hundreds of instructions that help quark make scheduling decisions and keep its data in a consistent state .",
    "for example , in the first step of a dual tree traversal , the target cell is split into eight child cells and eight new pairs are formed between the new target cells and old source cell .",
    "if each of these are scheduled as tasks on quark , the overhead of scheduling will be much smaller than the actual task of traversing each of these large subtrees .",
    "thus , there is a tradeoff between the small overhead of coarse grain scheduling , and the load balancing that fine grain scheduling can offer .    in the fmm it is possible to calculate the _ mutual _ interaction of cells , reducing the computation by about half",
    "this is possible because all translation operators are a function of distance , and flipping the sign of the odd terms allows it to be reused when the target and source are interchanged .",
    "however , mutual interaction has a more restrictive data dependency , and non - mutual interaction is more suitable for many cores due to the high degree of parallelism it provides .",
    "figure  [ fig : dag ] shows the actual dag of the fmm traversal using mutual or non - mutual particle interactions .",
    "the nodes represents the coarse - grained tasks and the edges the data dependencies between tasks .",
    "while the dag for mutual interaction is very scattered , the dag for non - mutual interaction clearly exposes more parallelism , which can be exploited as a low hanging fruit by the quark dynamic scheduler .",
    "furthermore , the _ locality _ flag for the non - mutual interaction in figure  [ fig : fmm - mutual - interaction ] permits to ensure that the sequence of tasks within one branch is not interrupted by another thread during the execution , which may pollute the cache memory .",
    "+ the main key for getting high performance is to tune the granularity of the _ super _ task .",
    "we have performed a thorough investigation of the optimal granularity , which will be presented in the following section .",
    "[ source , c ] ---- void evaluator::interact(c_iter ci , c_iter cj , quark * quark , bool mutual ) {    quark_task_flags tflags = quark_task_flags_initializer ;    if ( mutual ) {      quark_insert_task(quark , interactquark,&tflags ,                        sizeof(cell),&*ci , inout ,                        sizeof(cell),&*cj , inout ,                        sizeof(bool),&mutual , value ,                        0 ) ;    } else {      quark_insert_task(quark , interactquark,&tflags ,                        sizeof(cell),&*ci , output | locality ,                        sizeof(cell),&*cj , nodep ,                        sizeof(bool),&mutual , value ,                        0 ) ;    } } ----",
    "in this section , we will present the results of a parametric scalability study of our data - driven fmm approach .",
    "all experiments are performed on a single node with a quad - socket quad - core ` intel  xeon  e7340 ` processor at 2.40 ghz with 16 physical cores .",
    "the code is written in c++ and the compiler is ` gcc version 4.1.2 20080704 ` , and os is ` x86_64 red hat 4.1.2 - 50 ` .",
    "all codes were compiled with  ` g++ -o3 -fopenmp -ffast - math -funroll - loops -fforce - addr ` \" .    we have mentioned in section [ sec : impl ] that a pair of subtrees are assigned to quark as tasks , instead of a pair of cells .",
    "depending on how large these subtrees are , quark will have to balance either a large number of small tasks or a small number of large tasks through work stealing techniques .",
    "the idea here is to optimize the overhead of dynamic task scheduling , by adjusting the size of the subtrees that are passed to quark . in our _ dual tree traversal _",
    "approach , it is trivial to adjust the size of the subtrees that are passed to quark by simply stopping the breadth first ( queue based ) dual tree traversal , and sending all the pairs of subtrees in the queue to quark as individual tasks .",
    "we note that the use of a breadth first traversal is essential to this approach , since it creates tasks of similar size in the queue , whereas a depth first ( stack based ) traversal will result in largely varying task sizes in the stack , which would be much more difficult to balance .",
    "furthermore , a breadth first traversal will create tasks with much higher data - parallelism .",
    "also , the size of the queue can get much larger ( tens of thousands ) than the size of the stack in a depth first traversal ( tens ) .",
    "the results of strong scaling tests for the fmm are shown in fig .",
    "[ fig : scaling ] , where @xmath3 is the size of the queue , @xmath4 is the order of expansion , and @xmath1 is the number of particles . during the dual tree traversal the size of the queue @xmath3 starts from @xmath5 ( pair of root cells ) and increases rapidly .",
    "we simply put a conditional statement in the tree traversal to ship all the queued tasks to quark when the queue size reaches a certain threshold , and this threshold corresponds to the value @xmath3 .",
    "the particles are randomly distributed in a unit cube and the resulting tree is well balanced .    by comparing figures [ fig : p6n5 ] , [ fig : p6n6 ] , and [ fig : p6n7 ]",
    "we see that increasing the problem size @xmath1 automatically gives us better strong scalability , but only if @xmath3 is sufficiently large .",
    "when the task size is small , the overhead of dynamically scheduling @xmath6 tasks becomes a significant burden as shown in figures [ fig : p6n5 ] and [ fig : p9n5 ] .",
    "however , as the task size increases proportional to @xmath1 , the constant overhead of scheduling @xmath6 tasks can be amortized as in figures [ fig : p6n7 ] and [ fig : p9n7 ] . from the fact that @xmath7 is too large for @xmath8 but not for @xmath9",
    ", we may assume that a ratio in the order of @xmath10 is necessary to amortize the cost of the dynamic scheduling .",
    "furthermore , increasing the order of expansion @xmath4 increases the operational intensity of the m2l kernel and results in slightly better scalability , which can be seen by comparing the left and right column of figure [ fig : scaling ] . in figure",
    "[ fig : p9n7 ] we achieve 100 % parallel efficiency on 16 cores , using @xmath11 , @xmath12 , and @xmath7 .",
    "the load - imbalance in the thread execution for @xmath11 , @xmath12 , and @xmath7 is shown in figure [ fig : trace ] .",
    "the tick marks represent the total runtime of the fmm in seconds .",
    "the runtime is 720 , 360 , 180 , 90 , and 45 seconds on 1 , 2 , 4 , 8 , and 16 threads , respectively .",
    "each blue segment represents an individual task that is dynamically scheduled by quark .",
    "these tasks are composed of dual tree traversals of the pair of subtrees and the corresponding m2l / p2p kernels that arise from these traversals .",
    "since the searching of _ well separated _ cell pairs is imbedded inside each task unit and scheduled dynamically , having an irregular tree structure should not degrade the quality of the load balance .",
    "this paper describes a data - driven execution of fmms based on the dynamic runtime system quark .",
    "after carefully tuning the granularity of the subtrees , our implementation achieves a linear speedup on a quad - socket quad - core intel xeon ( 16 cores total ) .",
    "quark permits to achieve not only high performance but also high productivity in terms of parallel implementation",
    ". the end user can therefore focus and spend time improving his core numerical kernels and the burden to get parallel performance is rather shifted on the runtime .    the authors plan to extend this work with the starpu  @xcite dynamic runtime , which schedules tasks on x86 as well as on hardware accelerators ( gpus ) .",
    "although it has a somewhat similar api than quark , the user has still to develop the appropriate kernels for the gpu and can let it up to the runtime to decide on which available resource , x86 or gpu , the task can be executed on .",
    "moreover , starpu provides a reduction operation , which could further improve our current implementation by adding another dimension of parallelism during the execution of the successive tasks seen in the non - mutual dag representation .",
    "finally , the authors will eventually tackle the distributed memory environment using the dague  @xcite framework to perform load balancing across time steps .",
    "e.  anderson , z.  bai , c.  bischof , s.  l. blackford , j.  w. demmel , j.  j. dongarra , j.  d. croz , a.  greenbaum , s.  hammarling , a.  mckenney , and d.  c. sorensen . .",
    "society for industrial and applied mathematics , philadelphia , third edition , 1999 .",
    "l.  s. blackford , j.  choi , a.  cleary , e.  dazevedo , j.  demmel , i.  dhillon , j.  j. dongarra , s.  hammarling , g.  henry , a.  petitet , k.  stanley , d.  walker , and r.  c. whaley . .",
    "siam , philadelphia , pa , 1997 .",
    "/ scalapack / slug/.    g.  bosilca , a.  bouteiller , a.  danalis , m.  faverge , a.  haidar , j.  k. thomas  herault , j.  langou , p.  lemarinier , h.  ltaief , p.  luszczek , a.  yarkhan , and j.  dongarra . .",
    "in _ the 12th ieee international workshop on parallel and distributed scientific and engineering computing ( pdsec-11 ) _ , anchorage , ak , usa , may 2011 .",
    "g.  bosilca , a.  bouteiller , a.  danalis , t.  herault , p.  lemarinier , and j.  j. dongarra . : a generic distributed dag engine for high performance computing . , 2011 .",
    "to appear , http://dx.doi.org/10.1016/j.parco.2011.10.003 .",
    "e.  chan , e.  s. quintana - orti , g.  quintana - orti , and r.  van  de geijn .",
    "supermatrix out - of - order scheduling of matrix operations for smp and multi - core architectures . in _",
    "spaa 07 : proceedings of the nineteenth annual acm symposium on parallel algorithms and architectures _ , pages 116125 , new york , ny , usa , 2007 .",
    "acm .",
    "a.  haidar , h.  ltaief , and j.  dongarra .",
    "parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine - grained and memory - aware kernels . in _ proceedings of 2011 international conference for high performance computing , networking , storage and analysis _ , sc 11 , pages 8:18:11 , new york , ny , usa , 2011 .",
    "acm .",
    "i.  lashuk , a.  chandramowlishwaran , h.  langston , t .- a .",
    "nguyen , r.  sampath , a.  shringarpure , r.  vuduc , l.  ying , d.  zorin , and g.  biros . a massively parallel adaptive fast multipole method on heterogeneous architectures . in",
    "_ proceedings of the conference on high performance computing networking , storage and analysis _ , 2009 .",
    "a.  rahimian , i.  lashuk , k.  veerapaneni , a.  chandramowlishwaran , d.  malhotra , l.  moon , r.  sampath , a.  shringarpure , j.  vetter , r.  vuduc , d.  zorin , and g.  biros .",
    "petascale direct numerical simulation of blood flow on 200k cores and heterogeneous architectures . in _",
    "sc 10 proceedings of the 2010 acm / ieee international conference for high performance computing , networking , storage and analysis _ , 2010 ."
  ],
  "abstract_text": [
    "<S> fast multipole methods have @xmath0 complexity , are compute bound , and require very little synchronization , which makes them a favorable algorithm on next - generation supercomputers . </S>",
    "<S> their most common application is to accelerate @xmath1-body problems , but they can also be used to solve boundary integral equations . when the particle distribution is irregular and the tree structure is adaptive , load - balancing becomes a non - trivial question . </S>",
    "<S> a common strategy for load - balancing fmms is to use the work load from the previous step as weights to statically repartition the next step . </S>",
    "<S> the authors discuss in the paper another approach based on data - driven execution to efficiently tackle this challenging load - balancing problem . </S>",
    "<S> the core idea consists of breaking the most time - consuming stages of the fmms into smaller tasks . </S>",
    "<S> the algorithm can then be represented as a directed acyclic graph ( dag ) where nodes represent tasks , and edges represent dependencies among them . </S>",
    "<S> the execution of the algorithm is performed by asynchronously scheduling the tasks using the quark runtime environment , in a way such that data dependencies are not violated for numerical correctness purposes . </S>",
    "<S> this asynchronous scheduling results in an out - of - order execution </S>",
    "<S> . the performance results of the data - driven fmm execution outperform the previous strategy and show linear speedup on a quad - socket quad - core intel xeon system . </S>"
  ]
}