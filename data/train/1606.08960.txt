{
  "article_text": [
    "the quotient - difference ( qd ) algorithm was proposed by rutishauser from previous works of hadamard @xcite , aitken @xcite , and lanczos @xcite ( for details see @xcite ) .",
    "this algorithm is highly related to the pad approximation @xcite techniques .",
    "the qd algorithm , and its variants , have numerous applications .",
    "for instance , it can be used to obtain the continuous fraction representation of meromorphic functions given by its power series development @xcite .",
    "it is also related with complex analysis , as it provides a direct method to locate poles of complex functions @xcite and zeros of polynomials @xcite .",
    "besides , in eigenvalue computation , the progressive qd algorithm @xcite has a relevant role as it can be interpreted as the lr transform for a tridiagonal matrix @xcite .",
    "unfortunately , in finite precision arithmetic , the quotient - difference algorithm has been shown in experiments to be numerically unstable .",
    "it is overly sensitive to rounding errors . as a consequence , high - precision arithmetic or exact arithmetic",
    "are recommended to overcome such a problem @xcite . in order to increase the accuracy and stability of algorithms for ill - conditioned problems ,",
    "several researchers studied their corresponding accurate compensated algorithms by applying error - free transformations @xcite which can yield , in most circumstances , a full precision accuracy in standard precision .",
    "for instance , to evaluate ill - conditioned polynomials with floating - point coefficients , graillat _ et al . _",
    "@xcite proposed a compensated horner algorithm to evaluate polynomials in monomial basis ; jiang _ et al . _",
    "@xcite presented compensated de - casteljau and clenshaw algorithms to evaluate polynomials in bernstein , chebyshev and legendre basis , respectively .    in this paper , we first perform a complete analysis of the stability of the quotient - difference algorithm by providing forward rounding error bounds and we introduce condition numbers adapted to the problem that permit to give a simple error bound that helps to locate the instability problems .",
    "the bounds shown in this paper provide a theoretical statement of the numerical simulations in literature .",
    "to overcome , or at least , to delay the appearance of instability problems in standard precision , we introduce a new more accurate algorithm , the compensated quotient - difference algorithm .",
    "the proposed algorithm is based on error - free transformations . to obtain the compensated quotient - difference algorithm we consider , especially , the division operation in each inner loop which has never been used in previous works of compensated algorithms .",
    "again , we perform a complete analysis of the stability and now , from the forward rounding error bounds , we observe that the condition numbers are multiplied by the square of the rounding unit , instead of the rounding unit .",
    "this result states that the proposed compensated quotient - difference algorithm is much more stable than the standard quotient - difference algorithm in working precision .",
    "the paper is organized as follows . in section [ sec2 ]",
    ", we introduce the classical qd algorithm , some basic notations about floating - point arithmetic and error - free transformations .",
    "section [ sec 3 err ] presents the error analysis of the qd algorithm and its condition numbers . in section [ sec 4 comp ] , the proposed new compensated qd algorithm , compqd , is provided .",
    "section [ sec 5 comp err ] presents the forward rounding error bounds of the compqd algorithm . finally , in section [ test ] , we give several numerical experiments together with three practical applications to illustrate the efficiency , accuracy and stability of the new compqd algorithm . in the appendices",
    "all the algorithms are detailed , and besides , a new compensated version of the _ progressive _ form of the qd scheme ( compproqd algorithm ) is given .",
    "in this section we review the classical qd algorithm ( subsection [ subsec 2.1 ] ) . in order to perform the detailed error analysis of the algorithms , we give some basic notations ( subsection [ subsec 2.2 ] ) and we present the error - free transformations ( subsection [ subsec 2.3 ] ) .      along this paper , quotient - difference is called qd for short and we assume that the conditions for the existence of the qd scheme ( also known as the qd table @xcite ) are satisfied .",
    "considering the formal power series @xmath0 where @xmath1 , we define its double sequence of hankel determinants by    @xmath2    a remarkable connection among hankel determinants @xcite is given by @xmath3 if we define @xmath4 then the previous relationship ( [ hankel connection ] ) can be interpreted as the following addition rhombus rule @xmath5 and , considering the definition ( [ q and e ] ) , @xmath6 and @xmath7 give the product rhombus rule @xmath8    hence , both rhombus relations , ( [ add q and e ] ) and ( [ product q and e ] ) , give rise to the classical qd algorithm : +    ' '' ''    qd [ algor qd ] +  * input :* @xmath9 , @xmath10 ; @xmath11 , @xmath12 +  * output :*  qd scheme +  * for *  @xmath13 +   +   @xmath14 +   @xmath15 +   +  * end *    ' '' ''    the way of computing in algorithm [ algor qd ] is explained in the following qd table showing the data connection via the above two rhombus rules from the first _",
    "q_-column moving right .",
    "@xmath16      in this paper we assume to work with floating - point arithmetics adhering to ieee-754 floating - point standard rounding to nearest . in our analysis",
    "we assume that there is no computational overflow or underflow .",
    "let @xmath17 represents a floating - point computation , and the evaluation of an expression in floating - point arithmetic is denoted @xmath18 , then its computation obeys the model @xmath19 where @xmath20 ( the set of floating - point numbers ) , @xmath21 and @xmath22 ( @xmath23 is the rounding unit of the computer ) .    for the following error analysis ,",
    "let @xmath24 and @xmath25 here , @xmath26 , @xmath27 , @xmath28 , and @xmath29 .",
    "the second equation can be rewritten as @xmath30 .",
    "we list some notations in table [ notations ] which will be helpful to understand this paper .",
    ".some notations for error analysis [ cols=\"^,^,^\",options=\"header \" , ]     [ find poles]@xcite let @xmath31 and @xmath32 with @xmath33 be two consecutive critical indices and let @xmath34 be @xmath35-normal .",
    "let polynomials @xmath36 be defined by @xmath37 then there exits a subsequence @xmath38 such that @xmath39    there are four steps for locating poles by theorem [ find poles ] :    * _ step 1 : _ expand the function in taylor series ; * _ step 2 : _ obtain the incomplete qd table ( columns @xmath40 ) from the coefficients of taylor series ; * _ step 3 : _ use theorem [ find poles ] to generate a polynomial ; * _ step 4 : _ solve the generated polynomial equation @xmath41 .",
    "now , we consider again the taylor polynomials of degree @xmath42 and @xmath43 expanded from function  ( [ funtay2 ] ) , and we apply qd and compqd algorithms to obtain the incomplete qd table . from theorem  [ find poles ] , we derive that the first pole is @xmath44 .",
    "we consider the location of the other three poles and so @xmath45 , @xmath46 .",
    "it is obvious that function ( [ funtay2 ] ) is 4-normal .",
    "then , from theorem [ find poles ] , we can generate a polynomial @xmath47 such that the reciprocals of the zeros of this polynomial are the three poles of ( [ funtay2 ] ) . here",
    ", we use the code ` solve(f ) ` in matlab to find the zeros of @xmath48 .",
    "the first pole computed by qd and compqd is the same , the other three poles are presented in table [ poles compare 2 ] .",
    "as we can see , the results in table  [ poles compare 2 ] are more accurate than in table  [ poles compare 1 ] . moreover , the three poles computed by using compqd are similar to the poles obtained by symqd . in the case",
    "@xmath49 , the results by using qd have no significant digit , but compqd can still keep some accuracy .",
    "the qd algorithm can be used to find simultaneously all the zeros of a polynomial with real coefficients  @xcite .",
    "we consider the formal power series ( [ fps ] ) of degree @xmath50 .",
    "its zeros @xmath51 @xmath52 can be found as the poles of the rational function @xmath53 . from theorem",
    "[ poles ] , if the moduli of the zeros of @xmath54 are all different , then the @xmath31-th @xmath40-column of @xmath55 tends to @xmath56 when the @xmath31-th @xmath57-column tends to zero .",
    "let @xmath58 , then considering @xmath59 , @xmath40-columns of @xmath60 tend to the reciprocals of the zeros of @xmath61 , which are the zeros of @xmath54 .",
    "the _ progressive _ form of qd scheme @xcite , which is more suitable for this problem , can be used to find zeros . for a current detailed analysis of this algorithm and several modifications",
    "see @xcite . the progressive qd algorithm ( proqd ) and its compensated algorithm ( compproqd ) ,",
    "are presented in appendix  b. the qd table of proqd is built as follows .",
    "@xmath62    in the numerical test , we consider the laguerre orthogonal polynomial ( see @xcite ) of degree 35 defined by the three - term recurrence relation @xmath63    ) and compproqd ( @xmath64 and @xmath65 ) . on the horizontal axis",
    "we show the position @xmath66 of the zeros . ]",
    "we apply proqd and compproqd with @xmath65 to locate the zeros ( ` tol ` is the error tolerance to stop the iterative process of the algorithm ) . for comparison , in the symbolic method",
    ", we use @xmath67 .",
    "the relative errors of zeros computed by proqd and compproqd are reported in figure [ zeros compare ] .",
    "we observe that the relative errors of zeros computed by using proqd are larger than those computed by using compproqd .",
    "that is to say , the compproqd algorithm is more stable and its relative error results are close to the rounding unit .",
    "besides , we test compproqd with @xmath64 , which requires a much smaller number of iterations than compproqd and proqd with @xmath65 . moreover , compproqd with @xmath64 even runs faster than proqd with @xmath65 . note that we can also obtain the zeros with the required accuracy ( e.g. half of the working precision ) faster , just by fixing a smaller error tolerance @xmath68 .",
    "we remark that this method can be combined with a newton method to refine the approximate zeros , once we have a good initial data for the newton process obtained from the compproqd algorithm .",
    "in this paper , we have studied in detail the quotient - difference ( ` qd ` ) algorithm , giving a complete analysis of its stability by providing forward rounding error bounds . in the error analysis",
    "we have introduced new condition numbers adapted to the problem .",
    "although it is well - known that the quotient - difference algorithm can be unstable , the theoretical bounds shown in this paper provide with a rigorous theoretical statement .",
    "instead of using high - precision arithmetic or exact ( symbolic ) arithmetic to overcome this problem , as recommended in numerous papers , we introduce a new more accurate algorithm , the compensated quotient - difference ( compqd ) algorithm based on error - free transformations .",
    "this new algorithm can yield , in most cases , a full precision accuracy in working precision .",
    "the stability of the new method is studied and the forward rounding error bounds show that the effect of the compensated algorithm is to multiply the condition numbers by the square of the rounding unit , delaying significantly the appearance of instability problems in standard precision .",
    "the advantages of the compensated quotient - difference algorithm are shown in several examples and in three practical applications : in the obtention of continued fractions and in pole and zero detection .",
    "the qd ( quad - double ) package @xcite is based on the following algorithms :    @xcite[twosum ] error - free transformation of the sum of two floating - point numbers +  function @xmath69 = { \\tt twosum}(a , b)$ ] +  @xmath70 +  @xmath71 +  @xmath72    algorithm [ twosum ] requires @xmath73 flops .",
    "@xcite[fasttwosum ] error - free transformation of the sum of two floating - point numbers ( @xmath74 ) +  function @xmath69 = { \\tt fasttwosum}(a , b)$ ] +  @xmath70 +  @xmath75    algorithm [ fasttwosum ] requires @xmath76 flops .",
    "@xcite[split ] error - free split of a floating - point numbers into two parts +  function @xmath69 = { \\tt split}(a)$ ] +  @xmath77 ( in double precision factor = @xmath78 ) +  @xmath79 +  @xmath80    algorithm [ split ] requires @xmath81 flops .",
    "@xcite[twoprod ] error - free transformation of the product of two floating - point numbers +  function @xmath69 = { \\tt twoprod}(a , b)$ ] +  @xmath82 +  [ @xmath83 , @xmath84 = split(@xmath85 ) +  [ @xmath86 , @xmath87 = split(@xmath88 ) +  @xmath89    algorithm [ twoprod ] requires @xmath90 flops .",
    "@xcite[twodiv ] error - free transformation of the division of two floating - point numbers +  function @xmath91 = { \\tt divrem}(a , b)$ ] +  @xmath92 +  @xmath69 = { \\tt twoprod}(q , b)$ ] +  @xmath93    algorithm [ twodiv ] requires @xmath94 flops .",
    "@xcite[add_dd_d ] addition of a double - double number and a double number +  function @xmath95 = \\texttt{add\\_dd\\_d}(ah , al , b)$ ] +  @xmath96 = \\texttt{twosum } ( ah , b)$ ] +  @xmath97 +  @xmath95 = \\texttt{fasttwosum}(th , tl)$ ]    algorithm [ add_dd_d ] requires @xmath98 flops .",
    "@xcite[add_dd_dd ] addition of a double - double number and double - double number +  function @xmath99 = \\texttt{add\\_dd\\_dd } ( ah , al , bh , bl)$ ] +  @xmath100 = \\texttt{twosum } ( ah , bh)$ ] +  @xmath96 = \\texttt{twosum } ( al , bl)$ ] +  @xmath101 +  @xmath102 +  @xmath103 +  @xmath104 +  @xmath95 = \\texttt{fasttwosum}(th , tl)$ ]    algorithm [ add_dd_dd ] requires @xmath94 flops .",
    "@xcite[prod_dd_d ] multiplication of a double - double number by a double number +  function @xmath95 = \\texttt{prod\\_dd\\_d}(ah , al , b)$ ] +  @xmath96 = \\texttt{twoprod } ( ah , b)$ ] +  @xmath105 +  @xmath95 = \\texttt{fasttwosum}(th , tl)$ ]    algorithm [ prod_dd_d ] requires @xmath106 flops .",
    "@xcite[prod_dd_dd ] multiplication of two double - double numbers +  function @xmath95 = \\texttt{prod\\_dd\\_dd}(ah , al , bh , bl)$ ] +  @xmath96 = \\texttt{twoprod } ( ah , bh)$ ] +  @xmath107 +  @xmath95 = \\texttt{fasttwosum}(th , tl)$ ]    algorithm [ prod_dd_dd ] requires @xmath108 flops .",
    "@xcite[div_dd_dd ] division of two double - double numbers +  function @xmath109 = { \\tt div\\_dd\\_dd}(ah , al , bh , bl)$ ] +  @xmath110 +  @xmath96={\\tt prod\\_dd\\_d}(bh , bl , q_1)$ ] +  @xmath95={\\tt add\\_dd\\_dd } ( ah , al , -th ,- tl)$ ] +  @xmath111 +  @xmath96={\\tt prod\\_dd\\_d}(bh , bl , q_2)$ ] +  @xmath95={\\tt add\\_dd\\_dd } ( rh , rl , -th ,- tl)$ ] +  @xmath112 +  @xmath113 = { \\tt fasttwosum}(q_1 , q_2)$ ] +  @xmath109 = { \\tt add\\_dd\\_d}(q_1 , q_2 , q_3)$ ]    algorithm [ div_dd_dd ] requires @xmath114 flops .",
    "the double - double arithmetic version of the qd algorithm , is the ddqd algorithm , and it is given by    ddqd algorithm [ algor ddqd ] ( qd algorithm in double - double arithmetic ) +  * input : *  @xmath115 , @xmath116 , @xmath10 +  @xmath117={\\tt div\\_dd\\_dd}(c^{(h)}_{n+1},c^{(l)}_{n+1},c^{(h)}_n , c^{(l)}_n)$ ] , @xmath12 +  * output : *  qd scheme +  * for *  @xmath13 +   +   @xmath99 = \\texttt{add\\_dd\\_dd } ( qh_m^{(n+1 ) } , ql_m^{(n+1 ) } , -qh_m^{(n)},-ql_m^{(n)})$ ] +   @xmath118 = \\texttt{add\\_dd\\_dd } ( rh , rl , eh_{m-1}^{(n+1)},el_{m-1}^{(n+1)})$ ] +   @xmath119 = { \\tt div\\_dd\\_dd}(eh_{m}^{(n+1)},el_{m}^{(n+1)},eh_{m}^{(n)},el_{m}^{(n)})$ ] +   @xmath120 = { \\tt prod\\_dd\\_dd}(th , tl , qh_{m}^{(n+1)},ql_{m}^{(n+1)})$ ] +   +  * end *    algorithm [ algor ddqd ] requires @xmath121 flops in the inner loop .",
    "the _ progressive _ form of the qd scheme @xcite is given by : +    proqd algorithm [ algor proqd ] ( the _ progressive _ form of qd algorithm ) +  * input : *  @xmath122 , @xmath123 ; @xmath124 , +  @xmath125 , @xmath126 , @xmath127 , @xmath128 +  ` tol ` ( error tolerance ) +  * output : *  qd scheme +  * for * @xmath129 +   +   @xmath130 +   @xmath131 +   +   +   @xmath132 , * break * +   +  * end *    the new compensated version of the _ progressive _ form of the qd scheme is given by : +    compproqd algorithm [ algor compproqd ] ( the compensated proqd algorithm ) +  * input : *  @xmath133 , @xmath134 , @xmath135 , @xmath136 , @xmath123 ; +  @xmath137={\\tt div\\_dd\\_dd}(-b^{(h)}_{1},-b^{(l)}_{1},b^{(h)}_0,b^{(l)}_0)$ ] +  @xmath138={\\tt div\\_dd\\_dd}(b^{(h)}_{m+1},b^{(l)}_{m+1},b^{(h)}_m , b^{(l)}_m)$ ] , @xmath139 , @xmath140 , @xmath128 +  ` tol ` ( error tolerance ) +  * output : *  qd scheme +  * for *  @xmath141 +   +   @xmath142={\\tt twosum}(\\widehat{e}_m^{(n)},-\\widehat{e}_{m-1}^{(n+1)})$ ] +   @xmath143={\\tt twosum}(s,\\widehat{q}_{m}^{(n)})$ ] +   @xmath144 +   @xmath145={\\tt fasttwosum}(\\widehat{q}_m^{(n+1)},-\\widehat{\\epsilon q}_m^{(n+1)})$ ] +   @xmath146={\\tt divrem}(\\widehat{q}_{m+1}^{(n)},\\widehat{q}_{m}^{(n+1)})$ ] +   @xmath147={\\tt twoprod}(t,\\widehat{e}_{m}^{(n)})$ ] +   @xmath148 +   @xmath149={\\tt fasttwosum}(\\widehat{e}_{m}^{(n+1)},-\\widehat{\\epsilon e}_{m}^{(n+1)})$ ] +   +   +   @xmath150 , * break * +   +  * end *",
    "10 url # 1`#1`urlprefixhref # 1#2#2 # 1#1                                            p.  langlois , n.  louvet , how to ensure a faithful polynomial evaluation with the compensated horner algorithm , in : p.  kornerup , j.  m.  muller ( eds . ) , 18th ieee international symposium on computer arithmetic , ieee computer society , 2007 , pp .",
    "141149 .",
    "x.  s. li , j.  w. demmel , d.  h. bailey , g.  henry , y.  hida , j.  iskandar , w.  kahan , s.  y. kang , a.  kapur , m.  c. martin , b.  j. thompson , t.  tung , d.  j. yoo , design , implementation and testing of extended and mixed precision blas , acm trans .",
    "28  ( 2 ) ( 2002 ) 152205 ."
  ],
  "abstract_text": [
    "<S> the compensated quotient - difference ( compqd ) algorithm is proposed along with some applications . </S>",
    "<S> the main motivation is based on the fact that the standard quotient - difference ( qd ) algorithm can be numerically unstable . </S>",
    "<S> the compqd algorithm is obtained by applying error - free transformations to improve the traditional qd algorithm . </S>",
    "<S> we study in detail the error analysis of the qd and compqd algorithms and we introduce new condition numbers so that the relative forward rounding error bounds can be derived directly . </S>",
    "<S> our numerical experiments illustrate that the compqd algorithm is much more accurate than the qd algorithm , relegating the influence of the condition numbers up to second order in the rounding unit of the computer . </S>",
    "<S> three applications of the new algorithm in the obtention of continued fractions and in pole and zero detection are shown .    </S>",
    "<S> qd algorithm , compensated qd algorithm , error - free transformation , rounding error , continued fractions , pole detection </S>"
  ]
}