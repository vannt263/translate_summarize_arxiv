{
  "article_text": [
    "state - machine replication is an established way to enhance the resilience of a client - server application  @xcite .",
    "it works by executing the service on multiple independent components that will not exhibit correlated failures .",
    "we consider the approach of _ byzantine fault - tolerance ( bft ) _ , where a group of _ processes _ connected only by an unreliable network executes an application  @xcite .",
    "the processes use a protocol for _ consensus _ or _ atomic broadcast _ to agree on a common sequence of operations to execute .",
    "if all processes start from the same initial state , if all operations that modify the state are _ deterministic _ , and if all processes execute the same sequence of operations , then the states of the correct processes will remain the same .",
    "( this is also called _ active _ replication  @xcite . ) a client executes an operation on the service by sending the operation to all processes ; it obtains the correct outcome based on comparing the responses that it receives , for example , by a relative majority among the answers or from a sufficiently large set of equal responses . tolerating _",
    "byzantine faults _ means that the clients obtain correct outputs as long as a qualified majority of the processes is correct , even if the faulty processes behave in arbitrary and adversarial ways .",
    "traditionally state - machine replication requires the application to be deterministic .",
    "but many applications contain implicit or explicit non - determinism : in multi - threaded applications , the scheduler may influence the execution , input / output operations might yield different results across the processes , probabilistic algorithms may access a random - number generator , and some cryptographic operations are inherently not deterministic .",
    "recently bft replication has gained prominence because it may implement distributed consensus for building _ blockchains _",
    "a blockchain provides a distributed , append - only ledger with cryptographic verifiability and is governed by decentralized control .",
    "it can be used to record events , trades , or transactions immutably and permanently and forms the basis for cryptocurrencies , such as bitcoin or ripple , or for running `` smart contracts , '' as in ethereum . with the focus on active replication",
    ", this work aims at _ permissioned _ blockchains , which run among known entities  @xcite .",
    "in contrast , _ permissionless _ blockchains ( including ethereum ) do not rely on identities and use other approaches for reaching consensus , such as proof - of - work protocols . for",
    "practical use of blockchains , ensuring deterministic operations is crucial since even the smallest divergence among the outputs of different participants lets the blockchain diverge ( or `` fork '' ) .",
    "this work presents a _ general treatment _ of non - determinism in the context of bft replication and introduces a distinction among different models to tackle the problem of non - determinism .",
    "for example , applications involving cryptography and secret encryption keys should be treated differently from those that access randomness for other goals .",
    "we also distinguish whether the replication mechanism has access to the application s source code and may modify it .",
    "we also introduce two novel protocols .",
    "the first , called _ sieve _ , replicates non - deterministicprograms using in a _",
    "way , where we treat the application as a black box and can not change it .",
    "we target workloads that are usually deterministic , but which may occasionally yield diverging outputs .",
    "the protocol initially executes all operations speculatively and then compares the outputs across the processes .",
    "if the protocol detects a minor divergence among a small number of processes , then we _ sieve out the diverging values _ ; if a divergence among too many processes occurs , we _ sieve out the operation _ from sequence .",
    "furthermore , the protocol can use _ any _ underlying consensus primitive to agree on an ordering .",
    "the second new protocol , _ mastercrypt _ , provides master - slave replication with cryptographic security from verifiable random functions .",
    "it addresses situations that require strong , cryptographically secure randomness , but where the faulty processes may leak their secrets .",
    "we introduce three different models and discuss corresponding protocols for replicating non - deterministicapplications .",
    "modular : : :    when the application itself is fixed and can not be changed , then we    need _ modular _ replicated execution . in practice this is often the    case .",
    "we distinguish two approaches for integrating a consensus    protocol for ordering operations with the replicated execution of    operations .",
    "one can either use _ order - then - execute _ , where the    operations are ordered first , executed independently , and the results    are communicated to the other processes through atomic broadcast .",
    "this    involves only deterministic steps and can be viewed as `` agreement on    the input . ''",
    "alternatively , with _",
    "execute - then - order _ , the processes    execute all operations speculatively first and then `` agree on the    output '' ( of the operation ) . in this case operations with diverging    results may have to be rolled back .",
    "+    we introduce protocol  _ sieve _ that uses speculative execution and    follows the _ execute - then - order _ approach .",
    "as described before ,    _ sieve _ is intended for applications with occasional non - determinism .",
    "it represents the first modular solution to replicating    non - deterministicapplications in a bft system .",
    "master - slave : : :    in the _ master - slave _ model , one process is designated as the master    or `` leader , '' makes all non - deterministic choices that come up , and    imposes these on the others which act as slaves or `` followers . ''",
    "because a faulty ( byzantine ) master may misbehave , the slaves must be    able to validate the selections of the master before the operation can    be executed as determined by the master .",
    "the master - slave model is    related to passive replication ; it works for most applications    including probabilistic algorithms , but can not be applied directly for    cryptographic operations . as a further complication",
    ", this model    requires that the developer has access to the internals of the    application and can modify it .",
    "+    for the master - slave model we give a detailed description of the    well - known replication protocol , which has been used in earlier    systems .",
    "cryptographically secure : : :    traditionally , randomized applications can be made deterministic by    deriving pseudorandom bits from a secret seed , which is initially    chosen truly randomly .",
    "outsiders , such as clients of the application ,    can not distinguish this from an application that uses true randomness .",
    "this approach does not work for bft replication , where faulty    processes might expose and leak the seed . to solve this problem ,",
    "we    introduce a novel protocol for master - slave replication with    cryptographic randomness , abbreviated  _ mastercrypt_. it lets the    master select random bits with a _",
    "verifiable random function_. the    protocol is aimed at applications that need strong , cryptographically    secure randomness ; however it does not protect against a faulty master    that leaks the secret .",
    "we also review the established approach of    threshold ( public - key ) cryptography , where private keys are    secret - shared among the processes and cryptographic operations are    distributed in a fault - tolerant way over the whole group .",
    "the modular protocol  _ sieve _ has been developed for running potentially non - deterministicsmart contracts as applications on top of a permissioned blockchain platform , built using bft replication .",
    "an implementation has been made available as open source in `` hyperledger fabric , '' which is part of the linux foundation s hyperledger project .",
    "as of november 2016 , the project has decided to adopt a different architecture ; the platform has been redesigned to use a master - slave approach for addressing non - deterministicexecution .",
    "the problem of ensuring deterministic operations for replicated services is well - known .",
    "when considering only crash faults , many authors have investigated methods for making services deterministic , especially for multi - threaded , high - performance services  @xcite .",
    "practical systems routinely solve this problem today using master - slave replication , where the master removes the ambiguity and sends deterministic updates to the slaves . in recent research on this topic , for instance , kapitza et al .",
    "@xcite present an optimistic solution for making multithreaded applications deterministic .",
    "their solution requires a predictor for non - deterministicchoices and may invoke additional communication via the consensus module .    in the bft model ,",
    "most works consider only sequential execution of deterministic commands , including pbft  @xcite and upright  @xcite .",
    "base  @xcite and cbase  @xcite address byzantine faults and adopt the master - slave model for handling non - determinism , focusing on being generic ( base ) and on achieving high throughput ( cbase ) , respectively .",
    "these systems involve changes to the application code and sometimes also need preprocessing steps for operations .",
    "fault - tolerant execution on multi - core servers poses a new challenge , even for deterministic applications , because thread - level parallelism may introduce unpredictable differences between processes .",
    "eve  @xcite heuristically identifies groups of non - interfering operations and executes each group in parallel .",
    "afterwards it compares the outputs , may roll back operations that lead to diverging states , or could transfer an agreed - on result state to diverging processes .",
    "eve resembles protocol  _ sieve _ in this sense , but lacks modularity .    for the same domain of scalable services running on multi - cores , rex",
    "@xcite uses the master - slave model , where the master executes the operations first and records its non - deterministicchoices .",
    "the slaves replay these operations and use a consensus primitive to agree on a consistent outcome .",
    "rex only tolerates crashes , but does not address the bft model .",
    "fault - tolerant replication involving cryptographic secrets and distributed cryptography has been pioneered by reiter and birman  @xcite . many other works followed , especially protocols using threshold cryptography ; an early overview of solutions in this space was given by cachin  @xcite .    in current work duan and zhang",
    "@xcite discuss how the master - slave approach can handle randomized operations in bft replication , where execution is separated from agreement in order to protect the privacy of the data and computation .",
    "the remainder of this paper starts with section  [ sec : def ] , containing background information and formal definitions of broadcast , replication , and atomic broadcast ( i.e. , consensus ) .",
    "the following sections contain the discussion and protocols for the three models : the modular solution ( section  [ sec : modular ] ) , the master - slave protocol ( section  [ sec : master ] ) , and replication methods for applications demanding cryptographic security ( section  [ sec : secure ] ) .",
    "we consider a distributed system of _ processes _ that communicate with each other and provide a common _ service _ in a fault - tolerant way . using the paradigm of service replication  @xcite",
    ", requests to the service are broadcast among the processes , such that the processes execute all requests in the same order .",
    "the clients accessing the service are not modeled here .",
    "we denote the set of processes by @xmath0and let @xmath1",
    ". a process may be _ faulty _ , by crashing or by exhibiting _",
    "byzantine faults _ ; the latter means they may deviate arbitrarily from their specification .",
    "non - faulty processes are called _ correct_. up to @xmath2 processes may be faulty and we assume that  @xmath3 .",
    "the setup is also called a _ byzantine fault - tolerant ( bft ) service replication system _ or simply a _ bft system_.    we present protocols in a modular way using an event - based notation  @xcite .",
    "a process is specified through its _ interface _ , containing the events that it exposes to other processes , and through a set of _ properties _ , which define its behavior .",
    "a process may react to a received event by doing computation and triggering further events .",
    "the events of a process interface consist of _ input events _ , which the process receives from other processes , typically to invoke its services , and _ output events _ , through which the process delivers information or signals a condition to another process .",
    "every two processes can _ send _ messages to each other using an authenticated point - to - point communication primitive .",
    "when a message arrives , the receiver learns also which process has sent the message .",
    "the primitive guarantees _ message integrity _",
    ", i.e. , when a message  @xmath4 is received by a correct process with indicated sender  @xmath5 , and @xmath5 is correct , then @xmath5 previously sent  @xmath4 .",
    "authenticated communication can be implemented easily from an insecure communication channel by using a message - authentication code ( mac )  @xcite , a symmetric cryptographic primitive that relies on a secret key shared by every pair of processes .",
    "these keys have been distributed by a trusted entity beforehand .",
    "the system is _ partially synchronous _",
    "@xcite in the sense that there is no a priori bound on message delays and the processes have no synchronized clocks , as in an asynchronous system .",
    "however , there is a time ( not known to the processes ) after which the system is _ stable _ in the sense that message delays and processing times are bounded . in other words ,",
    "the system is _ eventually synchronous_. this model represents a broadly accepted network model and covers a wide range of real - world situations .",
    "suppose @xmath6 processes participate in a broadcast primitive .",
    "every process may _ broadcast _ a request or message  @xmath4 to the others .",
    "the implementation generates events to output the requests when they have been agreed ; we say that a request  @xmath4 is _ delivered _ through this .",
    "atomic broadcast also solves the _ consensus _",
    "problem  @xcite .",
    "we use a variant that delivers only messages satisfying a given _ external validity _",
    "condition  @xcite .",
    "[ def : abv ] a _ byzantine atomic broadcast with external validity _ ( _ abv _ ) is defined with the help of a validation predicate  @xmath7 and in terms of these events :    input event : : :    : broadcasts a message @xmath4 to all processes .",
    "output event : : :    : delivers a message @xmath4 broadcast by process    @xmath8 .    the deterministic predicate  @xmath7 validates messages .",
    "it can be computed locally by every process .",
    "it ensures that a correct process only delivers messages that satisfy  @xmath7 .",
    "more precisely , @xmath7 must guarantee that when two correct processes  @xmath8 and @xmath9 have both delivered the same sequence of messages up to some point , then @xmath8 obtains @xmath10 for any message  @xmath4 if and only if @xmath9 also determines that  @xmath11 .    with this validity mechanism , the broadcast satisfies :    validity : : :    if a correct process  @xmath8 broadcasts a    message  @xmath4 , then @xmath8 eventually    delivers  @xmath4 . external validity",
    ": : :    when a correct process delivers some message  @xmath4 , then    @xmath12 .",
    "no duplication : : :    no correct process delivers the same message more than once . integrity : : :    if some correct process delivers a message  @xmath4 with    sender  @xmath8 and process  @xmath8 is correct , then    @xmath4 was previously broadcast by  @xmath8 .",
    "agreement : : :    if a message  @xmath4 is delivered by some correct process ,    then @xmath4 is eventually delivered by every correct process .",
    "total order : : :    let @xmath13 and @xmath14 be any two messages and    suppose @xmath8 and @xmath9 are any two correct    processes that deliver @xmath13 and @xmath14 . if    @xmath8 delivers @xmath13 before @xmath14 ,    then @xmath9 delivers @xmath13 before    @xmath14 .    in practice",
    "it may occur that not all processes agree in the above sense on the validity of a message .",
    "for instance , some correct process may conclude @xmath12 while others find that  @xmath15 .",
    "for this case it is useful to reason with the following relaxation :    weak external validity : : :    when a correct process delivers some message  @xmath4 , then at    least one correct process has determined that @xmath16 at some time between when    @xmath4 was broadcast and when it was delivered .",
    "every protocol for byzantine atomic broadcast with external validity of which we are aware either ensures this weaker notion or can easily be changed to satisfy it .",
    "atomic broadcast is the main tool to implement state - machine replication ( smr ) , which executes a service on multiple processes for tolerating process faults . throughout this work",
    "we assume that many operation requests are generated concurrently by all processes ; in other words , there is request contention .    a _ state machine _ consists of variables and operations that transform its",
    "state and may produce some output .",
    "traditionally , operations are _ deterministic _ and the outputs of the state machine are solely determined by the initial state and by the sequence of operations that it has executed .",
    "the state machine _",
    "functionality _ is defined by  @xmath17 , a function that takes a _ state _",
    "@xmath18 , initially  @xmath19 , and operation  @xmath20 as input , and outputs a successor state  @xmath21 and a _ response _ or _ output value _",
    "@xmath22 : @xmath23    a _ replicated state machine _ can be characterized as in definition  [ def : rsm ] .",
    "basically , its interface presents two events : first , an input event that a process uses to invoke the execution of an operation  @xmath24 of the state machine ; and second , an output event , which is produced by the state machine . the output indicates the operation has been executed and carries the resulting state  @xmath25 and response  @xmath22 .",
    "we assume here that an operation  @xmath24 includes both the name of the operation to be executed and any relevant parameters .",
    "[ def : rsm ] a _ replicated state machine ( rsm ) _ for a functionality @xmath17 and initial state  @xmath19 is defined by these events :    input event : : :    : requests that the state machine executes the    operation  @xmath24 .",
    "output event : : :    : indicates that the state machine has executed an    operation  @xmath24 , resulting in new state  @xmath25 , and    producing response  @xmath22",
    ".    it also satisfies these properties :    agreement : : :    the sequences of executed operations and corresponding outputs are the    same for all correct processes .",
    "correctness : : :    when a correct process has executed a sequence of    operations  @xmath26 , then the sequences of output    states  @xmath27 and responses  @xmath28 satisfies    for @xmath29 ,    @xmath30 termination : : :    if a correct process executes a operation , then the operation    eventually generates an output .",
    "the standard implementation of a replicated state machine relies on an atomic broadcast protocol to disseminate the requests to all processes  @xcite .",
    "every process starts from the same initial state and executes all operations in the order in which they are delivered .",
    "if all operations are _ deterministic _ the states of the correct processes never diverge .",
    "implementations of atomic broadcast need to make some synchrony assumptions or employ randomization  @xcite .",
    "a very weak timing assumption that is also available in many practical implementations is an _ eventual leader - detector oracle _  @xcite .",
    "we define an eventual leader - detector primitive , denoted  @xmath31 , for a system with byzantine processes .",
    "it informs the processes about one correct process that can serve as a leader , so that the protocol can progress .",
    "when faults are limited to crashes , such a leader detector can be implemented from a failure detector  @xcite , a primitive that , in practice , exploits timeouts and low - level point - to - point messages to determine whether a remote process is alive or has crashed .    with processes acting in arbitrary ways , though , one can not rely on the timeliness of simple responses for detecting byzantine faults .",
    "one needs another way to determine remotely whether a process is faulty or performs correctly as a leader .",
    "detecting misbehavior in this model depends inherently on the specific protocol being executed  @xcite .",
    "we use the approach of `` trust , but verify , '' where the processes monitor the leader for correct behavior . more precisely ,",
    "a leader is chosen arbitrarily , but ensuring a fair distribution among all processes ( in fact , it is only needed that a correct process is chosen at least with constant probability on average , over all leader changes ) .",
    "once elected , the chosen leader process gets a chance to perform well .",
    "the other processes monitor its actions .",
    "should the leader not have achieved the desired goal after some time , they complain against it , and initiate a switch to a new leader .    hence we assume that the leader should act according to the application and within some time bounds . if the leader performs wrongly or exceeds the allocated time before reaching this goal , then other processes detect this and report it as a failure to the leader detector by filing a complaint . in an asynchronous system with eventual synchrony as considered here , every process always behaves according to the specification and eventually all remote processes also observe this ; if such correct behavior can not be observed from a process , then the process must be faulty .",
    "this notion of `` performance '' depends on the specific algorithm executed by the processes , which relies on the output from the leader - detection module .",
    "therefore , eventual leader election with byzantine processes is not an isolated low - level abstraction , as with crash - stop processes , but requires some input from the higher - level algorithm .",
    "the event allows to express this .",
    "every process may _ complain _ against the current leader  @xmath8 by triggering this event .",
    "[ def : bld ] a _ byzantine leader detector _ ( @xmath31 ) is defined with these events :    output event : : :    : indicates that process  @xmath8 is trusted to be leader .",
    "input event : : :    : expresses a complaint about the performance of leader    process  @xmath8 .",
    "the primitive satisfies the following properties :    eventual accuracy : : :    there is a time after which every correct process trusts some correct    process .",
    "eventual succession : : :    if more than @xmath2 correct processes that trust some    process  @xmath8 complain about  @xmath8 , then every    correct process eventually trusts a different process    than  @xmath8 .",
    "coup resistance : : :    a correct process  @xmath9 does not trust a new leader unless    at least one correct process has complained against the leader    which  @xmath9 trusted before .",
    "eventual agreement : : :    there is a time after which no two correct processes trust different    processes .",
    "it is possible to lift the output from the byzantine leader detector to an _ epoch - change _ primitive , which outputs not only the identity of a leader but also an increasing _",
    "epoch number_. this abstraction divides time into a series of epochs at every participating process , where epochs are identified by numbers .",
    "the numbers of the epochs started by one particular process increase monotonically ( but they do not have to form a complete sequence ) .",
    "moreover , the primitive also assigns a _ leader _ to every epoch , such that any two correct processes in the same epoch receive the same leader .",
    "the mechanism for processes to complain about the leader is the same as for  @xmath31 .",
    "more precisely , epoch change is defined as follows  @xcite :    [ def : bec ] a _ byzantine epoch - change _ ( @xmath32 ) primitive is defined with these events :    output event : : :    : indicates that the epoch with number  @xmath33 and    leader  @xmath8 starts .",
    "input event : : :    : expresses a complaint about the performance of leader    process  @xmath8 .",
    "the primitive satisfies the following properties :    monotonicity : : :    if a correct process starts an epoch @xmath34 and later    starts an epoch @xmath35 , then @xmath36 .",
    "consistency : : :    if a correct process starts an epoch @xmath34 and another    correct process starts an epoch @xmath35 with    @xmath37 , then @xmath38 .",
    "eventual succession : : :    suppose more than @xmath2 correct processes have started an    epoch  @xmath34 as their last epoch ; when these processes    all complain about  @xmath8 , then every correct process    eventually starts an epoch with a number higher than  @xmath33 .",
    "coup resistance : : :    when a correct process that has most recently started some    epoch  @xmath39 starts a new    epoch  @xmath40 , then at least one correct process has    complained about leader  @xmath41 in epoch  @xmath42 .",
    "eventual leadership : : :    there is a time after which every correct process has started some    epoch and starts no further epoch , such that the last epoch started at    every correct process is epoch  @xmath34 and    process  @xmath8 is correct .",
    "when an epoch - change abstraction is initialized , it is assumed that a default epoch with number  0 and a leader  @xmath43 has been started at all correct processes .",
    "the value of @xmath43 is made available to all processes implicitly .",
    "all `` practical '' bft systems in the eventual - synchrony model starting from pbft  @xcite implicitly contain an implementation of byzantine epoch - change ; this notion was described explicitly by cachin et al .",
    "* chap .  5 ) .",
    "we model cryptographic _ hash functions _ and _ digital signature schemes _ as ideal , deterministic functionalities implemented by a distributed oracle .    a cryptographic _ hash function _ maps a bit string of arbitrary length to a short , unique representation .",
    "the functionality provides only a single operation _ hash _ ; its invocation takes a bit string @xmath44 as parameter and returns an integer @xmath45 with the response .",
    "the implementation maintains a list @xmath46 of all @xmath44 that have been queried so far .",
    "when the invocation contains @xmath47 , then _ hash",
    "_ responds with the index of @xmath44 in @xmath46 ; otherwise , _ hash _",
    "appends @xmath44 to @xmath46 and returns its index .",
    "this ideal implementation models only collision resistance but no other properties of real hash functions .",
    "the functionality of the _ digital signature scheme _ provides two operations , @xmath48 and @xmath49 .",
    "the invocation of @xmath48 specifies a process  @xmath8 , takes a bit string  @xmath4 as input , and returns a signature @xmath50 with the response .",
    "only @xmath8 may invoke @xmath48 .",
    "the operation @xmath49 takes a putative signature  @xmath51 and a bit string  @xmath4 as parameters and returns a boolean value with the response .",
    "its implementation satisfies that @xmath52 returns truefor any process  @xmath8 and @xmath53 if and only if @xmath8 has executed @xmath54 and obtained @xmath51 before ; otherwise , @xmath52 returns false",
    ". every process may invoke _",
    "verify_. the signature scheme may be implemented analogously to the hash function .",
    "in this section we discuss the _ modular _ execution of replicated non - deterministicprograms . here",
    "the program is given as a black box , it can not be changed , and the bft system can not access its internal data structures . very informally speaking ,",
    "if some processes arrive at a different output during execution than `` most '' others , then the output of the disagreeing processes is discarded .",
    "instead they should `` adopt '' the output of the others , e.g. , by asking them for the agreed - on state and response .",
    "when the outputs of `` too many '' processes disagree , the correct output may not be clear ; the operation is then ignored ( or , as an optimization , quarantined as non - deterministic ) and the state rolled back . in this modular solution",
    "any application can be replicated without change ; the application developers may not even be aware of potential non - determinism .",
    "on the other hand , the modular protocol requires that most operations are deterministic and produce almost always the same outputs at all processes ; it would not work for replicating probabilistic functions .",
    "more precisely , a _",
    "non - deterministicstate machine _ may output different states and responses for the same operation , which are due to probabilistic choices or other non - repeatable effects .",
    "hence we assume that _ execute _ is a relation and not a deterministic function , that is , repeated invocations of the same operation with the same input may yield different outputs and responses .",
    "this means that the standard approach of state - machine replication based directly on atomic broadcast fails .",
    "there are two ways for modular black - box replication of non - deterministicapplications in a bft system :    order - then - execute : : :    applying the smr principle directly , the operations are first ordered    by atomic broadcast .",
    "whenever a process delivers an operation    according to the total order , it executes the operation .",
    "it does not    output the response , however , before checking with enough others that    they all arrive at the same outputs . to this end , every process    atomically broadcasts its outputs ( or a hash of the outputs ) and waits    for receiving a given number ( up to @xmath55 ) of outputs from    distinct processes",
    ". then the process applies a fixed decision function    to the atomically delivered outputs , and it determines the successor    state and the response .",
    "+    this approach ensures consistency due to its conceptual simplicity but    is not very efficient in typical situations , where atomic broadcast    forms the bottleneck .",
    "in particular , in atomic broadcast with external    validity , a process can only participate in the ordering of the next    operation when it has determined the outputs of the previous one .",
    "this    eliminates potential gains from pipelining and increases the overall    latency .",
    "execute - then - order : : :    here the steps are inverted and the operations are executed    _ speculatively _ before the system commits their order . as in other    practical protocols , this solution uses the heuristic assumption that    there is a designated _ leader _ which is usually correct .",
    "thus , every    process sends its operations to the leader and the leader orders them .",
    "it asks all processes to execute the operations speculatively in this    order , the processes send ( a hash of ) their outputs to the leader , and    the leader determines a unique output .",
    "note that this value is still    speculative because the leader might fail or there might be multiple    leaders acting concurrently .",
    "the leader then tries to obtain a    confirmation of its speculative order by atomically broadcasting the    chosen output .",
    "once every process obtains this output from atomic    broadcast , it commits the speculative state and outputs the response .",
    "+    in rare cases when a leader is replaced , some processes may have    speculated wrongly and executed other operations than those determined    through atomic broadcast . due to non - determinism in the execution",
    "a    process may also have obtained a different speculative state and    response than what the leader has obtained and broadcast .",
    "this implies    that the leader must either send the state ( or state delta ) and the    response resulting from the operation though atomic broadcast , or that    a process has a different way to recover the decided state from other    processes .    in the following we describe protocol  _ sieve _ , which adopts the approach of _ execute - then - order _ with speculative execution .",
    "protocol  _ sieve _ runs a byzantine atomic broadcast with weak external validity ( abv ) and uses a _",
    "sieve - leader _ to coordinate the execution of non - deterministicoperations .",
    "the leader is elected through a byzantine epoch - change abstraction , as defined in section  [ subsec : leaderelection ] , which outputs epoch / leader tuples with monotonically increasing epoch numbers .",
    "for the _ sieve _ protocol these epochs are called _ configurations _ , and _ sieve _ progresses through a series of them , each with its own sieve - leader .",
    "the processes send all operations to the service through the leader of the current configuration , using an invoke message .",
    "the current leader then initiates that all processes execute the operation speculatively ; subsequently the processes agree on an output from the operation and thereby _ commit _ the operation . as described here , _ sieve _",
    "executes one operation at a time , although it is possible to greatly increase the throughput using the standard method of _ batching _ multiple operations together .",
    "the leader sends an execute message to all processes with the operation  @xmath24 . in turn",
    ", every process executes  @xmath24 _ speculatively _ on its current state  @xmath25 , obtains the speculative next state  @xmath56 and the speculative response  @xmath22 , signs those values , and sends a hash and the signature back to the leader in an approve message .",
    "the leader receives @xmath57 approve messages from distinct processes .",
    "if the leader observes at least @xmath58 approvals for the _ same _ speculative output , then it _ confirms _ the operation and proceeds to committing and executing it .",
    "otherwise , the leader concludes that the operation is _ aborted _ because of diverging outputs .",
    "there must be @xmath58 equal outputs for confirming  @xmath24 , in order to ensure that every process will eventually learn the correct output , see below .",
    "the leader then _ abv - broadcasts _ an order message , containing the operation , the speculative output @xmath59 for a confirmed operation or an indication that it aborted , and for validation the set of approve messages that justify the decision whether to confirm or abort . during atomic broadcast , the external validity check by the processes will verify this justification .",
    "as soon as an order message with operation  @xmath24 is _ abv - delivered _ to a process in _ sieve _ , @xmath24 is committed .",
    "if @xmath24 is confirmed , the process adopts the output decided by the leader .",
    "note this may differ from the speculative output computed by the process .",
    "protocol  _ sieve _ therefore includes the next state  @xmath56 and the response  @xmath22 in the order message . in practice , however , one might not send  @xmath56 , but state deltas , or even only the hash value of @xmath56 while relying on a different way to recover the confirmed state .",
    "indeed , since @xmath58 processes have approved any confirmed output , a process with a wrong speculative output is sure to reach at least one of them for obtaining the confirmed output later .    in case the leader _ abv - broadcasted _ an order message with the decision to abort the current operation because of the diverging outputs ( i.e. , no @xmath58 identical hashes in @xmath57 approve messages ) , the process simply ignores the current request and speculative state . as an optimization",
    ", processes may _ quarantine _ the current request and flag it as non - deterministic .",
    "as described so far , the protocol is open to a denial - of - service attack by multiple faulty processes disguising as sieve - leaders and executing different operations .",
    "note that the epoch - change abstraction , in periods of asynchrony , will not ensure that any two correct processes agree on the leader , as some processes might skip configurations .",
    "therefore _ sieve _ also orders the configuration and leader changes using consensus ( with the _ abv _ primitive ) .    to this effect , whenever a process receives a _ start - epoch _ event with itself as leader , the process _",
    "abv - broadcasts _ a new - sieve - config message , announcing itself as the leader .",
    "the validation predicate for broadcast verifies that the leader announcement concerns a configuration that is not newer than the most recently started epoch at the validating process , and that the process itself endorses the same next leader .",
    "every process then starts the new configuration when the new - sieve - config message is _ abv - delivered_. if there was a speculatively executed operation , it is aborted and its output discarded .",
    "the design of _ sieve _ prevents uncoordinated speculative request execution , which may cause contention among requests from different self - proclaimed leaders and can prevent liveness easily .",
    "naturally , a faulty leader may also violate liveness , but this is not different from other leader - based bft protocols .",
    "the details of protocol  _ sieve _ are shown in algorithms  [ alg : sieve1][alg : sieve2 ] .",
    "the pseudocode assumes that all point - to - point messages among correct processes are authenticated , can not be forged or altered , and respect fifo order .",
    "the invoked operations are unique across all processes and _ self _ denotes the identifier of the executing process .",
    "[ thm : sieve ] protocol  _ sieve _ implements a replicated state machine allowing a non - deterministicfunctionality @xmath17 , except that demonstrably non - deterministic operations may be filtered out and not executed .",
    "the _ agreement _ condition of definition  [ def : rsm ] follows directly from the protocol and from the _ abv _ primitive . every event is immediately preceded by an _",
    "abv - delivered _ order message , which is the same for all correct processes due to _ agreement _ of _ abv_. since all correct processes react to it deterministically , their outputs are the same .",
    "for the _ correctness _ property , note that the outputs @xmath60 ( state and response ) resulting from an operation  @xmath24 must have been confirmed by the protocol and therefore the values were included in an approve message from at least one correct process .",
    "this process computed the values such that they satisfy @xmath61 according to the protocol for handling an execute  message . on the other hand , no correct process outputs anything for committed operations that were aborted , this is permitted by the exception in the theorem statement .",
    "moreover , only operations are filtered out for which distinct correct processes computed diverging outputs , as ensured by the sieve - leader when it determines whether the operation is confirmed or aborted . in order to abort , no set of @xmath58 processes",
    "must have computed the same outputs among the @xmath57 processes sending the approve  messages .",
    "hence , at least two among every set of  @xmath58 correct processes arrived at diverging outputs .",
    "_ termination _ is only required for deterministic operations , they must terminate despite faulty processes that approve wrong outputs .",
    "the protocol ensures this through the condition that at least  @xmath58 among the @xmath57 approve messages received by the sieve - leader are equal .",
    "the faulty processes , of which there are at most  @xmath2 , can not cause an abort through this . but every order message is eventually _ abv - delivered _ and every confirmed operation is eventually executed and generates an output .      [",
    "[ rollback - and - state - transfer . ] ] rollback and state transfer .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    in protocol  _ sieve _ every process maintains a copy of the application state resulting from an operation until the operation is committed .",
    "moreover , the confirmed state and the response of an operation are included in order messages that are _ abv - broadcast_. for practical applications though , this is often too expensive , and another way for recovering the application state is needed .",
    "the solution is to roll back an operation and to transfer the correct state from other processes .",
    "we assume that there exists a _",
    "primitive , ensuring that for @xmath62 , the output of @xmath63 is always  @xmath25 . in the order messages of the protocol , the resulting output state and response are replaced by their hashes for checking the consistency among the processes",
    "thus , when a process receives an order message with a confirmed operation and hashes  @xmath64 and @xmath65 of the output state and response , respectively , it checks whether the speculative state and response satisfy @xmath66 and @xmath67 .",
    "if so , it proceeds as in the protocol .    if the committed operation was aborted , or the values do not match in a confirmed operation , the process rolls back the operation . for a confirmed operation ,",
    "the process then invokes _ state transfer _ and retrieves the correct state  @xmath56 and response  @xmath22 that match the hashes from other clients .",
    "it will then set the state variable  @xmath25 to @xmath56 and output the response  @xmath22 .",
    "rollback helps to implement transfer state efficiently , by sending incremental updates only .    for transferring the state , the process sends a state - request message to all those processes who produced the speculate - signatures contained in the @xmath58 approve messages , which the process receives together with a committed and confirmed operation . since at most @xmath2 of them may fail to respond , the process is guaranteed to receive the correct state .",
    "state transfer is also initiated when a new configuration starts through an _ abv - delivered _ new - sieve - config message , but the process has already speculatively executed an operation in the last configuration without committing it ( this can be recognized by @xmath68 ) .",
    "as in the above use of state transfer , the operation must terminate before the process becomes ready to execute further operations from execute messages .",
    "[ [ synchronization - with - pbft - based - atomic - broadcast . ] ] synchronization with pbft - based atomic broadcast .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when the well - known _ pbft protocol _",
    "@xcite is used to implement _ abv - broadcast _ , two further optimizations are possible , mainly because pbft also relies on a leader and already includes byzantine epoch - change .",
    "hence assume that every process runs pbft according to castro and liskov  ( * ? ? ?",
    "* sec .  4 ) .",
    "first , let an epoch - change event of @xmath32 occur at every view change of pbft .",
    "more precisely , whenever a process has received a correct pbft - new - view message for pbft - view number  @xmath69 and new primary process  @xmath8 , and when the matching view - change messages have arrived , then the process triggers a event at _ sieve_. the process subsequently starts executing requests in the new view .",
    "moreover , complaints from _ sieve _ are handled in the same way as when a backup in pbft _ suspects _ the current primary to be faulty , namely , it initiates a view change by sending a view - change message .",
    "the view change mechanism of pbft ensures all properties expected from  @xmath32 , as follows .",
    "the _ monotonicity _ and _ consistency _ properties of byzantine epoch - change follow directly from the calculation of strictly increasing view numbers in pbft and the deterministic derivation of the pbft - primary from the view .",
    "the _ eventual leadership _",
    "condition follows from the underlying timing assumption , which essentially means that timeouts are increased until , eventually , every correct process is able to communicate with the leader , the leader is correct , and no further epoch - changes occur .",
    "the second optimization concerns the new - sieve - config message . according to _ sieve _",
    "it is _ abv - broadcast _ whenever a new sieve - leader is elected , by that leader .",
    "as the leader is directly mapped to pbft s primary here , it is now the primary who sends this message as a pbft request .",
    "note that this request might not be delivered when the primary fails , but it will be delivered by the other processes according to the properties of _ abv - broadcast _ , as required by _",
    "sieve_. hence , the new sieve - configuration and sieve - leader are assigned either by all correct processes or by none of them .    with these two specializations for pbft ,",
    "_ sieve _ incurs the additional cost of the execute / approve messages in the request flow , and one new - sieve - config following every view - change of pbft . but determining the sieve - leader and implementing @xmath32 do not lead to any additional messages .",
    "non - deterministic operations have not often been discussed in the context of bft systems .",
    "the literature commonly assumes that deterministic behavior can be imposed on an application or postulates to change the application code for isolating non - determinism . in practice , however , it is often not possible .",
    "liskov  @xcite sketches an approach to deal with non - determinism in pbft which is similar to _ sieve _ in the sense that it treats the application code modularly and uses execute - then - order .",
    "this proposal is restricted to the particular structure of pbft , however , and does not consider the notion of external validity for _ abv _ broadcast .    for applications on multi - core servers , the _ eve _",
    "system  @xcite also executes operation groups speculatively across processes and detects diverging states during a subsequent verification stage . in case of divergence",
    ", the processes must roll back the operations .",
    "the approach taken in eve resembles that of _ sieve _ , but there are notable differences .",
    "specifically , the primary application of eve continues to assume deterministic operations , and non - determinism may only result from concurrency during parallel execution of requests .",
    "furthermore , this work uses a particular agreement protocol based on pbft and not a generic _ abv _ broadcast primitive .",
    "it should be noted that _",
    "sieve _ not only works with byzantine atomic broadcast in the model of eventual synchrony , but can equally well be run over randomized byzantine consensus  @xcite .",
    "by adopting the _ master - slave _ model one can support a broader range of non - deterministicapplication behavior compared to the modular protocol .",
    "this design generally requires source - code access and modifications to the program implementing the functionality . in a master - slave protocol for non - deterministicexecution",
    ", one process is designated as _",
    "master_. the master executes every operation first and records all non - deterministicchoices .",
    "all other processes act as _ slaves _ and follow the same choices . to cope with a potentially byzantine master , the slaves",
    "must be given means to verify that the choices made by the master are plausible .",
    "the master - slave solution presented here follows _ primary - backup replication _",
    "@xcite , which is well - known to handle non - deterministicoperations .",
    "for instance , if the application accesses a pseudorandom number generator , only the master obtains the random bits from the generator and the slaves adopt the bits chosen by the master .",
    "this protocol does not work for functionalities involving cryptography , however , where master - slave replication typically falls short of achieving the desired goals .",
    "instead a cryptographically secure protocol should be used ; they are the subject of section  [ sec : secure ] .",
    "as introduced in section  [ sec : modular ] , the _ execute _ operation of a non - deterministicstate machine is a relation .",
    "different output values are possible and represent acceptable outcomes .",
    "we augment the output of an operation execution by adding _ evidence _ for justifying the resulting state and response .",
    "the slave processes may then _ replay _ the choices of the master and accept its output .",
    "more formally , we now extend _ execute _ to _ nondet - execute _ as follows : @xmath70 its parameters @xmath25 , @xmath24 , @xmath21 , and @xmath22 are the same as for _ execute _ ; additionally , the function also outputs _ evidence _",
    "evidence enables the slave processes to execute the operation by themselves and obtain the same output as the master , or perhaps only to validate the output generated by another execution . for this task",
    "there is a function @xmath72 that outputs trueif and only if the set of possible outputs from @xmath73 contains @xmath74 . for completeness",
    "we require that for every @xmath25 and @xmath24 , when @xmath75 , it always holds @xmath76 @xmath77 @xmath78 .    as a basic verification method",
    ", a slave could rerun the computation of the master .",
    "extensions to use cryptographic verifiable computation  @xcite are possible .",
    "note that we consider randomized algorithms to be a special case of non - deterministicones .",
    "the evidence for executing a randomized algorithm might simply consist of the random coin flips made during the execution .      implementing a replicated state machine with non - deterministicoperations using master - slave replication does not require an extra round of messages to be exchanged , as in protocol  _",
    "sieve_. it suffices that the master is chosen by a byzantine epoch - change abstraction and that the master broadcasts every operation together with the corresponding evidence .",
    "more precisely , the processes operate on top of an underlying broadcast primitive _ abv _ and a byzantine epoch - change abstraction  @xmath32 . whenever a process receives a _ start - epoch _ event with itself as leader from  @xmath32 , the process considers itself to be the master for the epoch and _ abv - broadcasts _ a message that announces itself as the master for the epoch .",
    "the epochs evolve analogously to the configurations in _ sieve _ , with the same mechanism to approve changes of the master in the validation predicate of atomic broadcast .",
    "similarly , non - master processes send their operations to the master of the current epoch for ordering and execution .    for every invoked operation  @xmath24",
    ", the master computes @xmath75 and _ abv - broadcasts _ an order message containing the current epoch  @xmath79 and parameters @xmath24 , @xmath21 , @xmath22 , and  @xmath71 .",
    "the validation predicate of atomic broadcast for order messages verifies that the message concerns the current epoch and that @xmath80 using the current state  @xmath25 of the process .",
    "once an order message is _ abv - delivered _",
    ", a process adopts the response and output state from the message as its own .",
    "as discussed in the first optimization for _ sieve _ ( section  [ subsec : sieveopt ] ) , the output state  @xmath21 and response  @xmath22 do not always have to be included in the order messages .",
    "in the master - slave model , they can be replaced by hashes only for those operations where the evidence  @xmath71 contains sufficient data for a process to compute the same @xmath21 and @xmath22 values as the master .",
    "this holds , for example , when all non - deterministicchoices of an operation are contained in  @xmath71 .",
    "should the master _ abv - broadcast _ an operation with evidence that does not execute properly , i.e. , @xmath81 , the atomic broadcast primitive ensures that it is not _ abv - delivered _ through the external validity property . as in _ sieve _",
    ", every process periodically checks if the operations that it has invoked have been executed and complains against the current master using  @xmath32 .",
    "this ensures that misbehaving masters are eventually replaced .",
    "the master - slave protocol is inspired by primary - backup replication  @xcite , and for the concrete scenario of a bft system , it was first described by castro , rodrigues , and liskov in base  @xcite .",
    "the protocol of base addresses only the particular context of pbft , however , and not a generic atomic broadcast primitive .",
    "as mentioned before , the master - slave protocol requires changes to the application for extracting the evidence that will convince the slave processes that choices made by the master are valid .",
    "this works well in practice for applications in which only a few , known steps can lead to divergence .",
    "for example , operations reading inputs from the local system , accessing platform - specific environment data , or generating randomness can be replicated whenever those functions are provided by programming libraries .",
    "master - slave replication may only be employed when the application developer is aware of the causes of non - determinism ; for example , a multi - threaded application influenced by a non - deterministicscheduler could not be replicated unless the developer can also control the scheduling ( e.g. ,  @xcite ) .",
    "security functions implemented with cryptography are more important today than ever . replicating an application that involves a cryptographic secret ,",
    "however , requires a careful consideration of the attack model .",
    "if the bft system should tolerate that @xmath2 processes become faulty in arbitrary ways , it must be assumed that their secrets leak to the adversary against whom the cryptographic scheme is employed .",
    "service - level secret keys must be protected and should never leak to an individual process .",
    "two solutions have been explored to address this issue .",
    "one could delegate this responsibility to a third party , such as a centralized service or a secure hardware module at every process .",
    "however , this contradicts the main motivation behind replication : to eliminate central control points .",
    "alternatively one may use _ distributed cryptography _",
    "@xcite , share the keys among the processes so that no coalition of up to @xmath2 among them learns anything , and perform the cryptographic operations under distributed control .",
    "this model was pioneered by reiter and birman  @xcite and exploited , for instance , by sintra  @xcite or coca  @xcite .    in this section",
    "we discuss two methods for integrating non - deterministic cryptographic operations in a bft system .",
    "the first scheme is a novel protocol in the context of bft systems , called _ mastercrypt _ , and uses verifiable random functions to generate pseudorandom bits .",
    "this randomness is unpredictable and can not be biased by a byzantine process .",
    "the second scheme is the well - known technique of distributed cryptography , as discussed above , which addresses a broad range of cryptographic applications .",
    "both schemes adopt the master - slave replication protocol from the previous section .",
    "a _ verifiable random function ( vrf ) _",
    "@xcite resembles a pseudorandom function but additionally permits anyone to verify non - interactively that the choice of random bits occurred correctly .",
    "the function therefore guarantees correctness for its output without disclosing anything about the secret seed , in a way similar to non - interactive zero - knowledge proofs of correctness .",
    "more precisely , the process owning the vrf chooses a secret seed  @xmath82 and publishes a public verification key  @xmath83 .",
    "then the function family @xmath84 and algorithms @xmath85 and @xmath86 are a vrf whenever three properties hold :    correctness : : :    @xmath87 can be computed    efficiently from @xmath82 and for every  @xmath44 one    can also ( with the help of  @xmath82 ) efficiently generate a    proof @xmath88 such that    @xmath89 . uniqueness : : :    for every input  @xmath44 there is a unique  @xmath90 that    satisfies @xmath91 , i.e. , it is impossible to    find @xmath92 and @xmath93 and @xmath94 and @xmath95 such that    @xmath96 .",
    "pseudorandomness : : :    from knowing @xmath83 alone and sampling values from    @xmath97 and @xmath85 , no polynomial - time    adversary can distinguish the output of @xmath98 from a    uniformly random @xmath99-bit string , unless the adversary    calls the owner to evaluate  @xmath97 or    @xmath85 on  @xmath44 .",
    "thus , a vrf generates a value for every input  @xmath44 which is unpredictable and pseudorandom to anyone _ not _ knowing  @xmath82 . as @xmath98 is unique for a given  @xmath44 ,",
    "even an adversarially chosen key preserves the pseudorandomness of @xmath100 s outputs towards other processes .",
    "efficient implementations of vrfs have not been easy to find , but the literature nowadays contains a number of reasonable constructions under broadly accepted hardness assumptions  @xcite . in practice , when adopting the random - oracle model , vrfs can immediately be obtained from unique signatures such as ordinary rsa signatures  @xcite .    [ [ replication - with - cryptographic - randomness - from - a - vrf . ] ] replication with cryptographic randomness from a vrf .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    with master - slave replication , cryptographically strong randomness secure against faulty non - leader processes can be obtained from a vrf as follows .",
    "initially every process generates a vrf - seed and a verification key . then it passes the verification key to a trusted entity , which distributes the @xmath6 verification keys to all processes consistently , ensuring that all correct processes use the same list of verification keys . at every place where the application needs to generate ( pseudo-)randomness , the vrf is used by the master to produce the random bits and all processes",
    "verify that the bits are unique .    in more detail ,",
    "_ mastercrypt _ works as follows .",
    "the master computes all random choices while executing an operation  @xmath24 as @xmath101 , where _ tag _ denotes a unique identifier for the instance and operation .",
    "this tag must never reused by the protocol and should not be under the control of the master . the master supplies @xmath102 to the other processes as evidence for the choice of  @xmath22 . during the verification step in @xmath103",
    "every process now validates that @xmath104 .",
    "when executing the operation , every process uses the same randomness  @xmath22 .",
    "the pseudorandomness property of the vrf ensures that no process apart from the master ( or anyone knowing its secret seed ) can distinguish @xmath22 from truly random bits .",
    "this depends crucially on the condition that _ tag _ is used only once as input to the vrf .",
    "hence this solution yields a deterministic pseudorandom output that achieves the desired unpredictability and randomness in many cases , especially against entities that are not part of the bft system .",
    "note that simply handing over the seed of a cryptographic pseudorandom generator to all processes and treating the generator as part of a deterministic application would be predictable for the slave processes and not pseudorandom .",
    "of course , if the master is faulty then it can predict the value of  @xmath22 , leak it to other processes , and influence the protocol accordingly .",
    "the protocol should leave as little as possible choice to the master for influencing the value of  _ tag_. it could be derived from an identifier of the protocol or bft system `` instance , '' perhaps including the identities of all processes , followed by a uniquely determined binary representation of the operation s sequence number .",
    "if one assumes all operations are represented by unique bit strings , a hash of the operation itself could also serve as identifier .      _ distributed cryptography _ or , more precisely , _ threshold cryptography _",
    "@xcite distributes the power of a cryptosystem among a group of @xmath6 processes such that it tolerates @xmath2 faulty ones , which may leak their secrets , fail to participate in protocols , or even act adversarially against the other processes . threshold cryptosystems extend cryptographic secret sharing schemes , which permit the process group to maintain a secret such that @xmath2 or fewer of them have no information about it , but any set of _ more _ than @xmath2 can reconstruct it .    a _ threshold public - key cryptosystem ( t - pkcs ) _",
    ", for example , is a public - key cryptosystem with distributed control over the decryption operation .",
    "there is a single public key for encryption , but each process holds a _ key share _ for decryption . when a ciphertext is to be decrypted , every process computes a decryption share from the ciphertext and its key share . from any @xmath58 of these decryption shares , the plaintext can be recovered .",
    "usually the decryption shares are accompanied by zero - knowledge proofs to make the scheme robust .",
    "this models a non - interactive t - pkcs , which is practical because it only needs one round of point - to - point messages for exchanging the decryption shares ; other t - pkcss require interaction among the processes for computing shares .",
    "the public key and the key shares are generated either by a trusted entity before the protocol starts or again in a distributed way , tolerating faulty processes that may try to disrupt the key - generation protocol  @xcite .",
    "a state - of - the - art t - pkcs is secure against _ adaptive chosen - ciphertext attacks _",
    "@xcite , ensuring that an adversary can not obtain any meaningful information from a ciphertext unless at least one correct process has computed a decryption share . with a t - pkcs",
    "the bft system can receive operations in encrypted form , order them first without knowing their content , and only decrypt and execute them after they have been ordered .",
    "this approach defends against violations of the causal order among operations  @xcite .",
    "a _ threshold signature scheme",
    "_ works analogously and can be used , for instance , to implement a secure name service or a certification authority  @xcite .",
    "practical non - interactive threshold signature schemes are well - known  @xcite . to generate cryptographically strong and unpredictable pseudorandom bits , _ threshold coin - tossing schemes _",
    "have also been constructed  @xcite .",
    "they do not suffer from the limitation of the vrf construction in the previous section and ensure that no single process can predict the randomness until at least one correct process has agreed to start the protocol .",
    "[ [ replication - with - threshold - cryptosystems . ] ] replication with threshold cryptosystems .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    threshold cryptosystems have been used in bft replication starting with the work reiter and birman  @xcite .",
    "subsequently sintra  @xcite and other systems exploited it as well with robust , asynchronous protocols .    for integrating a threshold cryptosystems with a bft system ,",
    "no particular assumptions are needed about the structure of the atomic broadcast or even the existence of a leader .",
    "the distributed scheme can simply be inserted into the code that executes operations and directly replaces the calls to the cryptosystems .    to be more precise ,",
    "suppose that @xmath105 invokes a call to one of the three cryptosystem functions discussed before ( that is , public - key decryption , issuing a digital signature , or generating random bits ) . the process now invokes the threshold algorithm to generate a corresponding share .",
    "if the threshold cryptosystem is non - interactive , the process sends this share to all others over the point - to - point links",
    ". then the process waits for receiving @xmath58 shares and assembles them to the result of the cryptographic operation . with interactive threshold schemes ,",
    "the processes invoke the corresponding protocol as a subroutine .",
    "ideally the threshold cryptosystem supports the same cryptographic signature structure or ciphertext format as the standardized schemes ; then the rest of the service ( i.e. , code of the clients ) can remain the same as with a centralized service .",
    "this holds for rsa signatures , for instance  @xcite .",
    "this paper has introduced a distinction between three models for dealing with non - deterministicoperations in bft replication : _ modular _ where the application is a black box ; _ master - slave _ that needs internal access to the application ; and _ cryptographically secure _ handling of non - deterministicrandomness generation . in the past ,",
    "dedicated bft replication systems have often argued for using the master - slave model , but we have learned in the context of blockchain applications that changes of the code and understanding an application s logic can be difficult .",
    "hence , our novel protocol  _ sieve _ provides a modular solution that does not require any manual intervention . for a bft - based blockchain platform , _ sieve _",
    "can simply be run without incurring large overhead as a defense against non - determinism , which may be hidden in smart contracts .",
    "we thank our colleagues and the members of the ibm blockchain development team for interesting discussions and valuable comments , in particular elli androulaki , konstantinos christidis , angelo de caro , chet murthy , binh nguyen , and michael osborne .",
    "this work was supported in part by the european union s horizon 2020 framework programme under grant agreement number  643964 ( supercloud ) and in part by the swiss state secretariat for education , research and innovation ( seri ) under contract number  15.0091 .",
    "j.  bonneau , a.  miller , j.  clark , a.  narayanan , j.  a. kroll , and e.  w. felten . : research perspectives and challenges for bitcoin and cryptocurrencies . in _ proc .",
    "36th ieee symposium on security & privacy _ , pages 104121 , 2015 .              c.  cachin , k.  kursawe , f.  petzold , and v.  shoup .",
    "secure and efficient asynchronous broadcast protocols ( extended abstract ) . in _ advances in cryptology :  crypto 2001 _ , volume 2139 of _ lecture notes in computer science _ , pages 524541 .",
    "springer , 2001 .",
    "k.  croman , c.  decker , i.  eyal , a.  e. gencer , a.  juels , a.  kosba , a.  miller , p.  saxena , e.  shi , e.  g. sirer , d.  song , and r.  wattenhofer . on scaling decentralized blockchains .",
    "in _ proc .",
    "3rd workshop on bitcoin and blockchain research _ , 2016 .",
    "a.  doudou , b.  garbinato , r.  guerraoui , and a.  schiper .",
    "muteness failure detectors : specification and implementation . in _ proc .",
    "3rd european dependable computing conference ( edcc-3 ) _ , volume 1667 of _ lecture notes in computer science _ ,",
    "pages 7187 .",
    "springer , 1999 .",
    "t.  jager .",
    "verifiable random functions from weaker assumptions . in _ proc .",
    "12th theory of cryptography conference ( tcc 2015 ) _ , volume 9015 of _ lecture notes in computer science _ , pages 121143 .",
    "springer , 2015 .",
    "m.  kapritsos , y.  wang , v.  quema , a.  clement , l.  alvisi , and m.  dahlin .",
    "all about eve : execute - verify replication for multi - core servers . in _ proc .",
    "10th symp .",
    "operating systems design and implementation ( osdi ) _ , 2012 .",
    "a.  lysyanskaya .",
    "unique signatures and verifiable random functions from the dh - ddh separation . in _ advances in cryptology :  crypto 2002 _ , volume 2442 of _ lecture notes in computer science _ , pages 597612 .",
    "springer , 2002 .",
    "v.  shoup and r.  gennaro .",
    "securing threshold cryptosystems against chosen ciphertext attack .",
    "in _ advances in cryptology :  eurocrypt 98 _ , volume 1403 of _ lecture notes in computer science _ ,",
    "pages 116 .",
    "springer , 1998 .",
    "t.  swanson .",
    "consensus - as - a - service : a brief report on the emergence of permissioned , distributed ledger systems .",
    "report , apr . 2015 .",
    "url : http://www.ofnumbers.com/wp-content/uploads/2015/04/permissioned-distributed-ledgers.pdf .",
    "m.  vukoli .",
    "the quest for scalable blockchain fabric : proof - of - work vs. bft replication . in _",
    "open problems in network security , proc .",
    "ifip wg  11.4 workshop ( inetsec 2015 ) _ , volume 9591 of _ lecture notes in computer science _ , pages 112125 .",
    "springer , 2016 ."
  ],
  "abstract_text": [
    "<S> service replication distributes an application over many processes for tolerating faults , attacks , and misbehavior among a subset of the processes . with the recent interest in blockchain technologies , distributed execution of one logical application </S>",
    "<S> has become a prominent topic . </S>",
    "<S> the established state - machine replication paradigm inherently requires the application to be deterministic . </S>",
    "<S> this paper distinguishes three models for dealing with non - determinism in replicated services , where some processes are subject to faults and arbitrary behavior ( so - called byzantine faults ) : first , the modular case that does not require any changes to the potentially non - deterministicapplication ( and neither access to its internal data ) ; second , master - slave solutions , where ties are broken by a leader and the other processes validate the choices of the leader ; and finally , applications that use cryptography and secret keys . </S>",
    "<S> cryptographic operations and secrets must be treated specially because they require strong randomness to satisfy their goals .    </S>",
    "<S> the paper also introduces two new protocols . </S>",
    "<S> first , protocol  _ sieve _ uses the modular approach and filters out non - deterministicoperations in an application . </S>",
    "<S> it ensures that all correct processes produce the same outputs and that their internal states do not diverge . </S>",
    "<S> a second protocol , called _ mastercrypt _ , implements cryptographically secure randomness generation with a verifiable random function and is appropriate for most situations in which cryptographic secrets are involved . </S>",
    "<S> all protocols are described in a generic way and do not assume a particular implementation of the underlying consensus primitive . </S>"
  ]
}