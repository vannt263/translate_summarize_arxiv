{
  "article_text": [
    "the exact string matching is one of the oldest tasks in computer science .",
    "the need for it started when computers began processing text . at that time",
    "the documents were short and there were not so many of them .",
    "now , we are overwhelmed by amount of data of various kind .",
    "the string matching is a crucial task in finding information and its speed is extremely important .",
    "the exact string matching task is defined as counting or reporting all the locations of given pattern @xmath0 of length @xmath1 in given text @xmath2 of length @xmath3 assuming @xmath4 , where @xmath0 and @xmath2 are strings over a finite alphabet @xmath5 .",
    "the first solutions designed were to build and run deterministic finite automaton @xcite ( running in space @xmath6 and time @xmath7 ) , the knuth ",
    "pratt automaton @xcite ( running in space @xmath8 and time @xmath7 ) , and the boyer  moore algorithm @xcite ( running in best case time @xmath9 and worst case time @xmath10 ) .",
    "there are numerous variations of the boyer ",
    "moore algorithm like @xcite . in total",
    "more than 120 exact string matching algorithms @xcite have been developed since 1970 .",
    "modern processors allow computation on vectors of length 16 bytes in case of sse2 and 32 bytes in case of avx2 .",
    "the instructions operate on such vectors stored in special registers xmm0xmm15 ( sse2 ) and ymm0ymm15 ( avx2 ) . as one instruction",
    "is performed on all data in these long vectors , it is considered as simd ( single instruction , multiple data ) computation .",
    "in the nave approach ( shown as algorithm  [ naivesearch2 ] ) the pattern @xmath0 is checked against each position in the text @xmath2 which leads to running time @xmath10 and space @xmath11 .",
    "however , it is not bad in practice for large alphabets as it performs only 1.08 comparisons @xcite on average on each character of @xmath2 for english text .",
    "the variable _ found _ in algorithm  [ naivesearch2 ] is not quite necessary .",
    "it is presented in order to have a connection to the simd version to be introduced .    like in the testing evironment of hume & sunday @xcite and the smart library @xcite",
    ", we consider the counting version of exact string matching .",
    "it can be is easily transformed into the reporting version by printing position @xmath12 in line  [ naivesearch2-printi ] .",
    "@xmath13 @xmath14 @xmath15 and ( @xmath16=p[j]$ ] ) @xmath17[naivesearch2-printi ] [ naivesearch2-out ]     and pattern @xmath18 using the simd - nave - search algorithm ( alignment of pattern vector and vector _ found _ to text @xmath2).,scaledwidth=90.0% ]    @xmath13 @xmath19 @xmath20 @xmath21[simdnaivesearch2-printi ] [ simdnaivesearch2-out ]    using simd instructions ( shown in algorithm  [ simdnaivesearch2 ] ) we can compare @xmath22 bytes in parallel , where @xmath23 in case of sse2 or @xmath24 in case of avx2 and ` and ' represents the bit - parallel ` and ' .",
    "this allows huge speedup of a run .    for a given position @xmath12 in the text @xmath2 , the idea is to compare the pattern @xmath0 with the @xmath22 substrings @xmath25",
    "$ ] , for @xmath26 , in parallel , in @xmath8 time in total . to this end",
    ", we use a primitive @xmath27 which , given a position @xmath12 in @xmath2 and @xmath28 in @xmath0 , compares the strings @xmath29 $ ] and @xmath30^\\alpha$ ] and returns an @xmath22-bit integer such that the @xmath31-th bit is set iff @xmath32 = s_2[k]$ ] , in @xmath11 time .",
    "in other words , the output integer encodes the result of the @xmath28-th symbol comparison for all the @xmath22 substrings .",
    "for example , consider the @xmath22 leftmost substrings of length @xmath33 of @xmath2 , corresponding to @xmath34 . for @xmath35 ,",
    "the function compares @xmath36 $ ] with @xmath37^\\alpha$ ] , i.e. , the first symbol of the substrings against @xmath37 $ ] . for @xmath38 ,",
    "the function compares @xmath39 $ ] with @xmath40^\\alpha$ ] , i.e. , the second symbol against @xmath40 $ ] .",
    "let _ found _ be the bitwise and of the integers @xmath27 , for @xmath41 .",
    "clearly , @xmath25 = p$ ] iff the @xmath31-bit of _ found _ is set .",
    "we compute _ found _ iteratively , until we either compare the last symbol of @xmath0 or no substring has a partial match ( i.e. , the vector _ found _ becomes zero ) . then , the text is advanced by @xmath22 positions and the process is repeated starting at position @xmath42 . for a given @xmath12 ,",
    "the number of occurrences of @xmath43 is equal to the number of bits set in _ found _ and is computed using a popcount instruction . reporting all matches in line  [ simdnaivesearch2-printi ] would add an @xmath44 time overhead , as @xmath44 instructions are needed to extract the positions of the bits set in _ found _ , where @xmath45 is the number of occurrences found .",
    "the 16-byte version of function simdcompare is implemented with sse2 intrinsic functions as follows :    ....      simdcompare(x , y , 16 )          x_ptr = _",
    "mm_loadu_si128(x )          y_ptr = _",
    "mm_loadu_si128(s(y,16 ) )          return _ mm_movemask_epi8(_mm_cmpeq_epi8(x_ptr ,",
    "y_ptr ) ) ....    here s(y,16 ) is the starting address of 16 copies of y. the instruction ` _",
    "mm_loadu_si128(x ) ` loads 16 bytes ( = 128 bits ) starting from x to a simd register .",
    "the instruction ` _",
    "mm_cmpeq_epi8 ` compares bytewise two registers and the instruction ` _",
    "mm_movemask_epi8 ` extracts the comparison result as a 16-bit integer . for the 32-byte version ,",
    "the corresponding avx2 intrinsic functions are used . for both versions the sse4 instruction ` _",
    "mm_popcnt_u32 ` is utilized for popcount .      in order to identify nonmatching positions in the text as fast as possible ,",
    "individual characters of the pattern are compared to the corresponding positions in the text in the order given by their frequency in standard text .",
    "first , the least frequent symbol is compared , then the second least frequent symbol , etc . therefore the text type should be considered and frequencies of symbols in the text type should be computed in advance from some relevant corpus of texts of the same type .",
    "hume and sunday @xcite use this strategy in the context of the boyer ",
    "moore algorithm .",
    "@xmath13 @xmath19 @xmath46 @xmath21[freqssimdnaivesearch2-printi ] [ freqsimdnaivesearch2-out ]    algorithm  [ freqsimdnaivesearch2 ] shows the nave approach enriched by frequency consideration . a function @xmath47 gives the order in which the symbols of pattern should be compared ( i.e. , @xmath48 , p[\\pi(2)],\\ldots , p[\\pi(m)]$ ] ) to the corresponding symbols in text .",
    "an array for the function @xmath47 is computed in @xmath49 time using a standard sorting algorithm on frequencies of symbols in @xmath0 .",
    "hume and sunday @xcite call this strategy _ optimal match _ , although it is not necessarily optimal . for example , the pattern ` qui ' is tested in the order ` q'-`u'-`i ' , but the order ` q'-`i'-`u ' is clearly better in practice because ` q ' and ` u ' appear often together .",
    "klekci @xcite compares optimal match with more advanced strategies based on frequencies of discontinuous @xmath50-grams$ ] in a position @xmath12 of the pattern @xmath0 matches to the text , compare next the position of @xmath0 that most unlikely matches . ] with conditional probabilities .",
    "his experiments show that the frequency is beneficial in case of texts of large alphabets like texts of natural language .",
    "computing all possible frequencies of @xmath50-grams is rather complicated and the possible speed - up to optimal match is likely marginal .",
    "thus we consider only simple frequencies of individual symbols .",
    "guard test @xcite is a widely used technique to speed - up string matching .",
    "the idea is to test a certain pattern position before entering a checking loop . instead of a single guard test ,",
    "two or even three tests have been used @xcite .",
    "guard test is a representative of a general optimization technique called loop peeling , where a number of iterations is moved in front of the loop . as a result ,",
    "the loop becomes faster because of fewer loop tests .",
    "moreover , loop peeling makes possible to precompute certain values used in the moved iterations .",
    "for example , @xmath48 $ ] is explicitly known . in some cases , loop peeling may even double the speed of a string matching algorithm applying simd computation as observed by chhabra et al .",
    "@xcite .    in the following ,",
    "we call the number of the moved iterations the peeling factor @xmath51 .",
    "we assume that the first loop test is done after @xmath51 iterations .",
    "thus our approach differs from multiple guard test , where checking is stopped after the first mismatch .",
    "all @xmath51 iterations are performed in our approach .",
    "@xmath13 @xmath52 [ lpfreqsimdnaivesearch2-firstcomparison ]",
    "@xmath53 @xmath46 @xmath21[lpfreqssimdnaivesearch2-printi ] [ lpfreqsimdnaivesearch2-out ]    loop peeling for @xmath54 is shown in algorithm  [ lpfreqsimdnaivesearch2 ] .",
    "the first two comparisons of characters are performed regardless the result of the first comparison ( in line  [ lpfreqsimdnaivesearch2-firstcomparison ] ) .",
    "if we consider string matching in english texts , it is less probable that all the @xmath22 comparisons fail at the same time than the other way round in the case of a pattern picked randomly from the text . therefore it is advantageous to use the value @xmath54 for english .    in theory",
    ", @xmath55 would be good for dna .",
    "namely , every iteration nullifies roughly 3/4 of the remaining set bits of the bitvector _",
    "found_. however , we achieved the best running time in practice with @xmath56 .      if the computation of character frequencies is considered inappropriate , there are other possibilities to speed - up checking . in natural languages",
    "adjacent characters have positive correlation . to break correlations one can use a fixed order which avoids adjacent characters .",
    "we applied the following heuristic order @xmath57 : @xmath37,p[m ] , p[4 ] , p[7],\\ldots , p[3 ] , p[6 ] , \\ldots , p[2 ] , p[5],\\ldots$ ] .    in letter - based languages ,",
    "the space character is the most frequent character .",
    "we can transform @xmath57 to a slightly better scheme @xmath58 by moving first all the spaces to the end and then processing the remaining positions as for @xmath57 .",
    "we have selected four files of different types and alphabet sizes to run experiments on : ` bible.txt ` ( fig .",
    "[ figbible ] , table  [ tab@bible ] ) and ` e.coli.txt ` ( fig .",
    "[ figecoli ] , table  [ tab@ecoli ] ) taken from canterbury corpus @xcite , ` dostoevsky-thedouble.txt ` ( fig .",
    "[ figdostoyevsky ] , table  [ tab@dostoyevsky ] ) , novel the double by dostoevsky in czech language taken from project gutenberg , and ` protein-hs.txt ` ( fig .",
    "[ figprotein ] , table  [ tab@protein ] ) taken from protein corpus @xcite .",
    "file ` dostoevsky-thedouble.txt ` is a concatenation of five copies of the original file to get file length similar to the other files .    ) , scaledwidth=90.0% ]    ) , scaledwidth=90.0% ]    ) , scaledwidth=90.0% ]    ) , scaledwidth=90.0% ]    we have compared methods naive16 and naive32 having 16 and 32 bytes processed by one simd instruction respectively .",
    "naive16-freq and naive32-freq are their variants where comparison order given by nondecreasing probability of pattern symbols ( section  [ sec@frequency_involved ] ) . naive16-fixed and naive32-fixed are the variants where comparison order is fixed ( section  [ sec@alternative_checking_orders ] ) .",
    "our methods were compared with the fastest exact string matching algorithms @xcite up to now sbndm2 , sbndm4 @xcite and epsm @xcite taken from smart library .",
    "the experiments were run on gnu / linux 3.18.12 , with x86_64 intel core i7 - 4770 cpu 3.40ghz with 16 gb ram .",
    "the computer was without any other workload and user time was measured using posix function ` getrusage ( ) ` .",
    "the average of 100 running times is reported .",
    "the accuracy of the results is about @xmath59 .",
    "the experiments show for both sse2 and avx2 instructions that for natural text ( ` bible.txt ` ) with the scheme @xmath57 of fixed frequency of comparisons improves the speed of simd - nave - search but it is further improved by considering frequencies of symbols in the text . in case of natural text with larger alphabet ( ` dostoevsky-thedouble.txt ` ) the scheme @xmath57 improves the speed only for avx2 instructions .",
    "the comparison based on real frequency of symbols is the bext for both sse2 and avx2 instructions . in case of small alphabets ( ` e.coli.txt ` , ` protein-hs.txt ` ) the order of comparison of symbols does not play any role ( except for ` protein-hs.txt ` and sse2 instructions ) .    for files with large alphabet ( ` bible.txt ` , ` dostoevsky-thedouble.txt ` )",
    "the peeling factor @xmath55 gave the best results for all our algorithms except for naive16-freq and naive32-freq where @xmath54 was the best .",
    "the smaller the alphabet is , the less selective the bigrams or trigrams are . for file ` protein-hs.txt ` , @xmath55 was still good and but for dna sequences of four symbols , @xmath56 turned to be the best    we also tested nave - search . in every run it was naturally considerably slower than simd - nave - search .",
    "frequency order and loop peeling can also be applied to nave - search . however , the speed - up was smaller than in case of simd - nave - search in our experiments .",
    "in spite of how many algorithms were developed for exact string matching , their running times are in general outperformed by the avx2 technology . the implementation of the nave search algorithm ( freq - simd - nave - search ) which uses avx2 instructions , applies loop peeling , and compares symbols in the order of increasing frequency is the best choice in general .",
    "however , previous algorithms epsm and sbndm4 have an advantage for small alphabets and long patterns . short patterns of 20 characters or less are objects of most searches in practice and our algorithm is especially good for such patterns . for texts with expected equiprobable symbols ( like in dna or protein strings ) ,",
    "our algorithm naturally works well without the frequency order of symbol comparisons .",
    "our algorithm is considerably simpler than its simd - based competitor epsm which is a combination of six algorithms .",
    "this work was done while jan holub was visiting the aalto university under the asci visitor programme ( dean s decision 12/2016 ) .",
    "s.  faro and m.  o. klekci .",
    "fast packed string matching for short patterns . in p.  sanders and n.",
    "zeh , editors , _ proceedings of the 15th meeting on algorithm engineering and experiments , alenex 2013 _ , pages 113121 .",
    "siam , 2013 .",
    "s.  faro , t.  lecroq , s.  borz , s.  di mauro , and a.  maggio .",
    "the string matching algorithms research tool . in j.",
    "holub and j.  rek , editors , _ proceedings of the prague stringology conference  16 _ , pages 99113 , czech technical university in prague , czech republic , 2016",
    ".          m.  o. klekci .",
    "an empirical analysis of pattern scan order in pattern matching . in sio",
    "iong ao , leonid gelman , david w.  l. hukins , andrew hunter , and a.  m. korsunsky , editors , _ world congress on engineering _ , lecture notes in engineering and computer science , pages 337341 .",
    "newswood limited , 2007 ."
  ],
  "abstract_text": [
    "<S> more than 120 algorithms have been developed for exact string matching within the last 40 years . </S>",
    "<S> we show by experiments that the nave algorithm exploiting simd instructions of modern cpus ( with symbols compared in a special order ) is the fastest one for patterns of length up to about 50 symbols and extremely good for longer patterns and small alphabets . </S>",
    "<S> the algorithm compares 16 or 32 characters in parallel by applying sse2 or avx2 instructions , respectively . </S>",
    "<S> moreover , it uses loop peeling to further speed up the searching phase . </S>",
    "<S> we tried several orders for comparisons of pattern symbols and the increasing order of their probabilities in the text was the best . </S>"
  ]
}