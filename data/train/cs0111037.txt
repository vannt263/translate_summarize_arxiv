{
  "article_text": [
    "classical constraint programming systems ( such as solver from ilog , chip from cosytec or gnuprolog from inria ) are helpless when there is no solution to the constraint system to be solved . in fact , only a ` no solution ` message is provided .",
    "users are left alone to find out why : is it because of the problem itself ( no solution exists ) , an incorrect modelling , a bug in the solver , etc .    in order to promote constraint programming",
    ", the constraints community needs to address this issue . for example , a set of constraints that left alone lead to the unexpected situation would be very informative to the user .",
    "such a set of constraints is called an * explanation * @xcite .",
    "it is a set of constraints justifying propagation events generated by the solver ( value removal , bound update , contradiction ) .",
    "notice that even if a lot of debugging tools were developed during the discipl european project @xcite , there is a lack for tools which provide explanations .",
    "explanations ( sets of _ low - level _ constraints ) are not user - friendly : only developers of constraints system understand them . _",
    "translation _ tools are needed .",
    "obviously , input from the developer of an application is needed .",
    "when developing an application , such an expert needs to _ translate _ the problem from the high - level representation ( the user s comprehension of the problem ) to the low - level representation ( the actual constraints in the system ) .",
    "we call this translation a ` user ` @xmath0 ` system ` translation . for user - friendly explanations ,",
    "we need the other way _ translation _ : from the low - level constraints ( solver adapted ) to the user understandable constraints ( higher level of abstraction ) .",
    "we call this translation a ` system ` @xmath0 ` user ` translation . that translation is usually not explicitly coded in the system . asking a developer to provide such a translator while coding",
    "would be quite strange .",
    "we chose to automatize that translation in an effortless way .    in this paper",
    ", we present an automatic system for generating user - friendly explanation .",
    "we first recall some facts about explanations within constraint programming .",
    "then , we show how our system works on hierarchical applications before presenting an implementation .",
    "we conclude this paper with some potential applications of our user - friendly explanations and some related works .",
    "we consider here csp represented by a couple @xmath1 .",
    "@xmath2 is a set of variables and @xmath3 a set of constraints on those variables .",
    "notice that variable domains are considered as unary constraints .",
    "moreover , the enumeration mechanism is handled as a series of constraints additions and retractions .",
    "those constraints are called _",
    "decision constraints_. indeed , we chose not to limit our tools to value assignments but to allow any kind of decision constraint ( _ eg . _ ordering constraints between tasks in scheduling , splitting constraints in numeric csp ) .",
    "let us consider a constraints system whose current state ( _ i.e. _ the original constraint and the set of decisions made so far ) is contradictory .",
    "a * contradiction explanation * ( _ a.k.a . _ * nogood * @xcite ) is a subset of the current constraints system of the problem that , left alone , leads to a contradiction ( no feasible solution contains a nogood ) .",
    "a contradiction explanation divides into two parts : a subset of the original set of constraints ( @xmath4 in equation  [ eq - nogood ] ) and a subset of decision constraints introduced so far in the search ( here @xmath5 ) .",
    "@xmath6    an operational viewpoint of contradiction explanations can be made explicit by rewriting equation  [ eq - nogood ] the following way : @xmath7 \\setminus j}dc_i\\right)\\rightarrow \\neg dc_{j}\\ ] ]    let us consider @xmath8 in the previous formula .",
    "the left hand side of the implication is called an * eliminating explanation * ( explanation for short ) because it justifies the removal of value @xmath9 from the domain @xmath10 of variable @xmath11 .",
    "it will be noted : @xmath12 .",
    "filtering operations in csp can be considered as a sequence of value removals which can all be explained as in equation  [ eq - explanation ] .",
    "the simplest of all explanations is to merely consider the complete set of currently active constraints ( _ i.e. _ the initial constraints of the problem and the set of all the decisions  and their associated enumeration",
    "constraint  made so far ) .",
    "notice that much more useful explanations can be provided .",
    "explanations can be combined with each other to provide new ones .",
    "let us suppose that @xmath13 is the set of all possible choices for a given decision ( set of possible values , set of possible sequences ) . if a set of explanations @xmath14 ,",
    "... , @xmath15 exists , a new explanation can be derived : @xmath16 .",
    "such new explanation gives more information than each of the old ones .    from the empty domain of a variable @xmath11 , a _ contradiction explanation _",
    "can be computed : @xmath17    notice that when a contradiction explanation does not contain any decision constraint , the associated problem is proved to be over - constrained .",
    "several eliminating explanations generally exist for the removal of a given value . recording all of them leads to an exponential space complexity .",
    "another technique relies on _ forgetting _ ( erasing ) explanations that are no longer relevant to the current variable assignment . by doing so",
    ", the space complexity remains polynomial .",
    "we here retain * one * explanation at a time for a value removal .",
    "notice that as explanations reflect the behavior of the solver , a value in a domain of a variable can not be removed twice .",
    "therefore , only one explanation is really computed while solving .",
    "explanations are useful in many situations @xcite :    * for debugging problems by providing contradiction explanation ; * for handling dynamic problems by providing the past effects of constraints ; * for handling over - constrained problems by combining the two preceding uses ; * for defining new conflict - directed search algorithms .",
    "` mac - dbt ` @xcite and ` path - repair ` @xcite are two successful instances .",
    "@xcite introduces the notion of _ e - constraints _ to encompass explanations and their use within constraint programming .",
    "the work presented in this paper relies on a single hypothesis : all aspects of a constraint - based application can be represented in an hierarchical way .",
    "example  [ conf - description ] presents a small constraint problem : organizing talks among several people .",
    "the conference problem [ conf - description ] michael , peter and alan are organizing a two - day seminar for writing a report on their work . in order to be efficient ,",
    "peter and alan need to present their work to michael and michael needs to present his work to alan and peter ( actually peter and alan work in the same lab ) .",
    "those presentations are scheduled for a whole half - day each .",
    "michael wants to known what peter and alan have done before presenting his own work .",
    "moreover , michael would prefer not to come the afternoon of the second day because he has got a very long ride home .",
    "finally , michael would really prefer not to present his work to peter and alan at the same time .    a constraint model for that problem",
    "is described in example  [ conf - model ] . notice that when modelling the conference problem , the constraints were categorized leading to an hierarchy representing the problem .",
    "a graphical representation is presented in figure  [ fig - conference ] .",
    "indeed , we claim that it is always possible to attach each constraint in a given problem to a single father - abstraction .",
    "this general hypothesis may appear as highly restrictive but as we were trying to find counter - examples we could not exhibit a single one : we always another way of presenting things that lead to an hierarchy .",
    "we therefore think that our intuition may not be as restrictive as we thought in the beginning . moreover ,",
    "posting constraint is usually an imperative step in classical constraint programming . defining procedures for posting constraints are the kind of abstraction we are interested in ( see example  [ coding - conference ] ) .    a constraint model for the conference problem [ conf - model ]",
    "let @xmath18 the variables representing the four presentations ( @xmath19 and @xmath20 are respectively for michael as a speaker and as an auditor and so on ) .",
    "their domain will be @xmath21 $ ] ( @xmath22 is for the morning of the first day and @xmath23 for the afternoon of the second day ) .",
    "several constraints are contained in the problem : implicit constraints regarding the organization of presentations and the constraints expressed by michael .",
    "the implicit constraints can be stated :    * a speaker can not be an auditor in the same half - day .",
    "this constraint is modelled as : @xmath24 : @xmath25 , @xmath26 : @xmath27 , @xmath28 : @xmath29 and @xmath30 : @xmath31 .",
    "* no one can attend two presentations at the same time .",
    "this is modelled as @xmath32 : @xmath33 .",
    "michael constraints can be modelled :    * michael wants to speak after peter and alan : @xmath34 : @xmath35 , @xmath36 : @xmath37 , @xmath38 : @xmath39 and @xmath40 : @xmath41 .",
    "* michael does not want to come on the fourth half - day : @xmath42 : @xmath43 , @xmath44 : @xmath45 , @xmath46 : @xmath47 and @xmath48 : @xmath49 .",
    "* michael does not want to present to peter and alan at the same time : @xmath50 : @xmath51 .",
    "while developing a constraint application , the developer only needs to explicitly state the underlying hierarchy of her problem . only the leaves of this structure ,",
    "namely the low - level constraints can be used by the constraint solver .",
    "the leaves may be way too low - level for a typical user of the final application",
    ". however , she may understand higher levels in the hierarchy .",
    "the hierarchy hypothesis allows the building , with no effort for the developer , of an hierarchical representation of the problem .",
    "once built , this representation may be used to interact with any user through user - friendly explanations .",
    "such explanations are provided using procedures converting the low - level constraints into user understandable nodes of the hierarchy .",
    "those procedures are completely problem - independent and may be provided within the constraint solver .",
    "a user perception of a given problem can be seen as a set of nodes in that tree ( everything above any of those nodes considered as being understandable and everything below any of those nodes ) .",
    "we will call that set a * cut * in the hierarchical view of the considered problem . in our example , here is what it could be ( see also figure  [ conf - views ] ) :    * the room manager of the faculty department has only a very partial view : she does not want to known about wishes or implicit constraints",
    ". the only part of the problem that she wants to deal with is the problem as a whole .",
    "therefore , her view of the problem would be : .",
    "* john who is actually organizing the meetings finds michael too complicated . he does not want to deal with his numerous wishes .",
    "but , he does understand the implicit constraints and must deal with them .",
    "therefore , his view of the problem would be : , and .",
    "* michael does not want to deal with implicit constraints .",
    "although he does understand his own wishes .",
    "therefore , his view of the problem would be : , , and .",
    "computing user - friendly explanations can be done by simply projecting the low - level constraints in the explanation onto the user comprehension of the problem in the hierarchy .",
    "our example , the conference problem has no solution .",
    "one explanation for that situation provided by an e - constraints system is : @xmath52 @xmath53 .",
    "here are their translation into user - friendly explanations :    * for the room manager , the explanation is simple .",
    "there is no possible solution for the problem due to its whole set of constraints .",
    "the projection gives : .",
    "he tells john that there is a problem .",
    "* john looks at the explanation from his point of view .",
    "the projection gives : + and .",
    "michael wishes are too strong because of the _ no two presentations at the same time for a given auditor _ constraint .",
    "john asks michael to review his wishes .",
    "* michael looks at the explanation from his point of view .",
    "the projection gives : + , , and + .",
    "he knows that the whole set of wishes is a problem .",
    "he can choose to discard any .",
    "for example , the constraint on the fourth half - day .",
    "this leads to a solution to the problem .",
    "notice that user input needs also to be translated into low - level interaction with the constraint solver .",
    "a backward projection step is therefore needed .",
    "there are two options : removing all the concerned constraints or only the constraints that do appear in the explanation . in our example",
    ", we can remove all @xmath42 to @xmath48 constraints . but",
    "removing @xmath48 would be of no use in our problem , since it does not appear in the explanation .",
    "moreover , choosing to only remove concerned constraints can help _ partially _ enforcing constraints leading to a kind of _ soft constraints _",
    "( encoded as a set of possibly removed low - level constraints ) .",
    "` palm ` is an explanation - based constraint programming system @xcite that is provided as a ` choco ` @xcite library . `",
    "choco ` is the constraint layer of the ` claire ` @xcite programming language . `",
    "palm ` provides tools to handle explanations in a constraint solver : a specific class , storing methods , retrieving method , ... ` palm ` computes explanations while propagating constraints and can even use them to guide the search @xcite ( it was used in ` mac - dbt ` @xcite and ` path - repair ` @xcite ) .",
    "the ` palm ` system handles variables represented with a complete enumerated domain or only by their bounds .",
    "it provides the classical set of basic arithmetic constraints as well as symbolic constraints ( such as _ alldifferent _ , _ element _ , ... ) .    `",
    "palm ` is designed to ( automatically ) handle over - constrained problem . if a user wants to define her own strategy for handling such problems ( as one might want to do in the conference problem ) , ` palm ` provides specific exceptions that can be catched using the standard ` try / catch ` mechanisms of ` claire ` .",
    "the ` palm ` system is is publicly available at ` www.e-constraints.net ` .",
    "the main idea here is to provide tools that allow the less intrusive possible interaction with the original code of the application .",
    "we therefore introduced the notion of ` ufbox ` ( user - friendly box ) that aggregates set of constraints into an hierarchy .",
    "grouping constraints is done by simply setting the boundaries of the given boxes using two provided methods : ` startufbox ` and ` endufbox ` .",
    "this explains why we need the hierarchy hypothesis : code modification is minimal .",
    "consider the conference problem introduced on example  [ conf - description ] and modelled in example  [ conf - model ] .",
    "example  [ coding - conference ] shows an encoding of that problem in ` choco ` .    coding the conference problem with choco [ coding - conference ]    ....   [ conference ( ) : void   - > let pb : = makeproblem(\"conference problem\",4 )          vars : = createconferencevariables(pb )      in (         postimplicitconstraints(pb , vars ) ,         postmichealconstraints(pb , vars ) ,         solve(pb )      ) ]     // creating the variables [ createconferencevariables(pb : problem ) : list[intvar ] - > ... ]   // posting michael constraints [ postmichaelconstraints(pb : problem , vars : list[intvar ] ) : void - > ... ]    [ postimplicitconstraints(pb : problem , vars : list[intvar ] ) : void   - > postspeakerauditorincompatibilityconstraints(pb , vars ) ,      postnottwopresentationsatthesametimeconstraints(pb , vars ) ] // posting the constraint c5 [ postnottwopresentationsatthesametimeconstraints(pb : problem , vars : list[intvar ] ) - > ... ]    [ postspeakerauditorincompatibilityconstraints(pb : problem , vars : list[intvar ] ) : void   - > post(pb , vars[1 ] !",
    "= = vars[2 ] ) , //",
    "constraint c1      post(pb , vars[3 ] ! = = vars[4 ] ) , // constraint c2      post(pb , vars[1 ]",
    "! = = vars[4 ] ) , // constraint c3      post(pb , vars[3 ] ! = = vars[2 ] ) ] //",
    "constraint c4 ....    as you can see , an implicit hierarchy is appearing when encoding the problem in a programming language : it is easier to maintain such a program if the constraint posting is structured as it was during the modelling phase .    in order to use the ` ufboxes ` that will be used to implement the ideas of this paper , one just needs to add some info while posting constraints .",
    "example  [ coding - conf - ufbox ] shows what we get .",
    "notice that ` startufbox ` needs three parameters : the related ` palmproblem ` , a short description used to ease user definition ( see following section ) and a textual representation of the set of constraints ( should be user - friendly ! ) .    adding ufboxes [ coding - conf - ufbox ]    ....",
    "[ conference ( ) : void   - > let pb : = makepalmproblem(\"conference problem\",4 ) //",
    "switch to palm          vars : = createconferencevariables(pb )      in (         postimplicitconstraints(pb , vars ) ,         postmichealconstraints(pb , vars ) ,         setuserrepresentation(pb , list(\"ic\",\"pab\",\"n4d\",\"npa \" ) ) , // representing michael         solve(pb )      ) ] ... [ postimplicitconstraints(pb : problem , vars : list[intvar ] ) : void   - > startufbox(pb,\"ic\",\"implicit constraints \" ) ,         postspeakerauditorincompatibilityconstraints(pb , vars ) ,         postnottwopresentationsatthesametimeconstraints(pb , vars ) ,      endufbox(pb ) ] ... [ postspeakerauditorincompatibilityconstraints(pb : problem , vars : list[intvar ] ) : void   - > startufbox(pb,\"saic\",\"speaker auditor incompatibility constraint \" ) ,         post(pb , vars[1 ] !",
    "= = vars[2 ] ) , //",
    "constraint c1         post(pb , vars[3 ] ! = = vars[4 ] ) , // constraint c2         post(pb , vars[1 ] ! = = vars[4 ] ) , // constraint c3         post(pb , vars[3 ] ! = = vars[2 ] ) , // constraint c4      endufbox(pb ) ] ....      tools are also provided to represent the user with the short descriptions provided while defining the ` ufboxes ` : the ` setuserrepresentation ` method that takes a list of short descriptions to define the cut in the hierarchy tree .",
    "moreover , projection tools are provided to translate a given explanation into the current user representation .",
    "finally , thanks to ` palm ` capabilities with dynamic problems , tools are provided for handling dynamic addition or removal of ` ufboxes ` ( _ i.e. _ , sets of constraints as a single constraint ) .    using ufboxes [ ex - use ]    .... palm > conference ( ) eval[0 ] > variables : ( am:[1 .. 4 ] , pm:[1 .. 4 ] , ma:[1 .. 4 ] , mp:[1 .. 4 ] )    = = = conference problem : description + .... [ pb ] the complete problem + ...... [ ic ] implicit constraints + ........ [ saic ] speaker - auditor incompatibility constraint + ........ [ n2p ] not two presentations at the same time + ...... [ mc ] michael constraints + ........ [ pab ] peter and alan before michael + ........ [ n4d ] no presentation on the 4th half - day + ........ [ npa ] not peter and alan at the same time    solving the problem ... ! ! ! a contradiction occurred because of :",
    "1 : [ ic ] implicit constraints 2 : [ pab ] peter and alan before michael 3 : [ n4d ] no presentation on the 4th half - day 4 : [ npa ] not peter and alan at the same time    * * which block would you like to relax ?",
    "( 1 - 4 0-none )    2 palm : removing constraint mp > = pm + 1 from pab palm : removing constraint mp > = am + 1 from pab palm : removing constraint ma > = pm + 1 from pab palm : removing constraint ma > = am + 1 from pab    ! ! !",
    "a contradiction occurred because of : 1 : [ ic ] implicit constraints 2 : [ n4d ] no presentation on the 4th half - day 3 : [ npa ] not peter and alan at the same time    * * which block would you like to relax ? ( 1 - 3 0-none )    2",
    "palm : removing constraint am ! = = 4 from n4d    ! ! !",
    "a solution has now been obtained ! ! !",
    "( am:4 , pm:1 , ma:2 , mp:3 )    ! ! !",
    "the following blocks have been relaxed    1 : [ pab - 4 cts ] peter and alan before michael    2 : [ n4d - 4 cts ] no presentation on the 4th half - day which one would you like to set back ?",
    "( 1 - 2 0-none ) 1 in order to do that some constraints need to be removed : palm : removing constraint pm ! = = 4 from p4d palm : removing constraint mp ! = = 4 from p4d    ! ! !",
    "a solution has now been obtained ! ! !",
    "( am:1 , pm:2 , ma:3 , mp:4 ) ....      example  [ ex - use ] shows ` ufboxes ` at use .",
    "as you can see in that example , only understandable information is provided to the user . in that example , michael s representation of the conference problem is used . when encountering a contradiction ( which shows that the problem is over - constrained ) , michael is confronted with an explanation of that contradiction .",
    "he chooses to let peter or alan give a presentation before him ( relaxing block ` pab ` in the example ) . unfortunately",
    ", this will not be sufficient and michael accepts to come on the fourth half - day ( relaxing block ` n4d ` ) .",
    "this time a solution is obtained .",
    "notice that only one constraint from this box needs to be relaxed .",
    "example  [ ex - use ] shows another feature of our problem .",
    "once a problem solved many user interactions have occurred and maybe he / she wants to put back some relaxed constraints . `",
    "palm ` presents the set of relaxed ` ufboxes ` for reconsideration . here , michael wants to put back the ` pab ` block .",
    "a solution is found .",
    "notice that some further constraint relaxations are needed ( from the ` n4d ` box which is still relaxed ) .",
    "user - friendly explanations can be an invaluable tool in the following situations :    * * debugging * + explanations can help focus on relevant parts of the set of constraints when identifying a contradiction .",
    "user - friendly ones are really necessary to interact with the user : constraints sets need to get translated to all kind of users . * * solving over - constrained problems * + as we saw with our toy example ( the conference problem ) , user - friendly explanations ( used as in the debugging situation above ) help the user understanding the deep reasons of the lack of solution to his problem .",
    "moreover , user - friendly explanations are well suited for distributed environments as in our example : a single explanation is presented to different people who have different views on the problem .",
    "the explanations is not modified , only the projection is passed through the system .",
    "notice that solving over - constrained problems can be seen as debugging ! * * dynamic analysis of the solver s behavior * + as for classic explanations , user - friendly explanations can explain specific situations during search . therefore , they can be used to analyse ( and report ) the behavior of the solver to different kinds of users : developer , end - users , managers , ...",
    "@xcite introduced the notion of _ s - box _ within constraint logic programming . _",
    "s - boxes _ are used to structure the constraint store by considering sets of constraints as a single one .",
    "it is worth noticing that _ s - boxes _ have two main drawbacks :    * considering a set of constraints as a single one is relatively easy when considering numerical constraint : one just needs to take the join of the projections .",
    "it is not that easy with other kinds of constraints .",
    "* the main drawback relies in the behavior of _ s - boxes_. indeed , the solver behavior is modified since a whole set of constraints is now replaced by a single one which means that propagation stays into an _",
    "s - box _ until completion before going to another one .",
    "this changes the solver behavior and therefore _ s - boxes _ may only be interesting for visualizing the behavior of the solver or for identifying the reasons for a contradiction but will be of no use when debugging a constraint program .",
    "our proposal limits the grouping of constraints in an abstract way .",
    "the concrete low - level constraints remain unmodified and independent .",
    "@xcite recently introduced user - friendly explanations for logic puzzles .",
    "the idea here is to provide a readable _ trace _ of the solving mechanism by generating a readable statement for each solver event .",
    "generated explanations are generally quite similar to hand - made ones although a bit longer .",
    "however , explanations are associated to low - level constraints and this work does not provide handling of sets of constraints as a whole .",
    "our proposal has that capability and moreover can handle at the same time several views of a same problem .",
    "in this paper , we introduced the notion of user - friendly explanations .",
    "the main idea is to consider constraint programs as an hierarchy of constraints and to add information about that hierarchy within the constraints .",
    "therefore , users can be modelled as a cut in the hierarchy tree and explanations can be projected on their representation of the problems .",
    "our proposal has been implemented within the ` palm ` system and shows interesting properties : possible handling of several different users , adaptability to distributed systems , capability of handling in a single box high - level constraints modelled as a set of low - level constraints , complete generality of the approach , ...    our current works include investigating real life use of our user - friendly explanations .",
    "our first experiment will be conducted within the ` ptidej ` system @xcite .",
    "this work originates from discussions and works with olivier lhomme ."
  ],
  "abstract_text": [
    "<S> in this paper , we introduce a set of tools for providing user - friendly explanations in an explanation - based constraint programming system . the idea is to represent the constraints of a problem as an hierarchy ( a tree ) . </S>",
    "<S> users are then represented as a set of understandable nodes in that tree ( a _ cut _ ) . </S>",
    "<S> classical explanations ( sets of system constraints ) just need to get projected on that representation in order to be understandable by any user . </S>",
    "<S> we present here the main interests of this idea .    </S>",
    "<S> * keywords : * constraint environment , explanations , implementation </S>"
  ]
}