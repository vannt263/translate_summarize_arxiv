{
  "article_text": [
    "all the graphs considered here are supposed to be finite , undirected , simple and loopless .",
    "for such a graph @xmath2 , we denote by @xmath8 and @xmath9 its vertex and edge sets respectively .",
    "furthermore if @xmath10 is a subset of @xmath8 , we denote by @xmath11 $ ] the induced subgraph of @xmath2 .",
    "the problem of finding the * common connected components * of two graphs was defined in @xcite , as follows : let @xmath12 , @xmath13 be two graphs on the same vertex set @xmath0 , find the maximal partition @xmath14 of @xmath0 such for that for every @xmath15 $ ] , @xmath16 $ ] and @xmath17 $ ] are connected . of course this problem is polynomially tractable and some subcases are solvable in linear time ( see @xcite ) .    in this paper",
    "we are particularly interested in the close problem of finding all the * common connected subsets * of two graphs : let @xmath12 , @xmath13 be two graphs on the same vertex set @xmath0 , find all the subsets @xmath18 such that @xmath19 $ ] and @xmath20 $ ] are connected .",
    "more precisely we mainly study the particular case where @xmath12 is a elementary chain , seen as a labelling of @xmath0 by @xmath21 , and @xmath13 is a graph @xmath2 with @xmath22 , the previous problem becomes the * problem of common intervals*. that is to compute the induced subgraphs @xmath3 $ ] , such that @xmath4 is an interval of @xmath5 $ ] and @xmath3 $ ] satisfies some property @xmath6 ( as for example @xmath7 `` being connected '' ) .",
    "this kind of problems appears in biology from comparative genomic , in a more specific case when the graph @xmath2 is a chain or a tree @xcite .    combining two approaches namely the idea of potential beginning developed in @xcite and the notion of generator as defined in @xcite , we succeed to a obtain a very simple generic algorithm which yields optimal algorithms in various applications .",
    "for example in the case where @xmath2 is a tree , our framework yields the first linear time algorithms for the two properties : `` being connected '' and `` being a path '' .",
    "furthermore in the particular case where @xmath2 is a chain , we deal with common intervals of two permutations , although some linear time algorithms already exist @xcite , our framework yields very simple linear time algorithms that compute non only the common intervals , but also the associated tree decomposition .    in this paper",
    "we will first present the general framework , which deals with families of intervals closed by intersection and then describe how the generic algorithms can be specialized for some applications . due to space constraints",
    "we will not develop in details all these applications .",
    "in the sequel , we only consider families of intervals closed under intersection . in other words , we will consider families @xmath23 of intervals such that : if two intervals @xmath24 intersect then their intersection @xmath25 is also in @xmath23 . for example , in the cases where @xmath2 is a tree and @xmath7 `` being connected '' or @xmath7 `` being a path '' , the resulting families are closed by intersection .",
    "but it is not always true , as for the case where @xmath2 is a graph and @xmath7 `` being connected '' , and to manage this case we need to extend the framework presented here , see @xcite .    in the whole section , we assume by convention that the considered families of intervals contain all the singletons of their ground set .",
    "let us now describe a generic algorithm to compute a convenient representation for these families and another one to enumerate their elements",
    ". these algorithms will be specialized different ways in the section [ applications ] , according to the particular combinatorial structures we consider .",
    "@xcite introduced the notion of _ generator _ to represent in linear space families of intervals closed under intersection :    a generator of a family @xmath23 of intervals over @xmath26 closed under intersection is a couple of vectors @xmath27 such that :    * @xmath28 \\geq x$ ] * @xmath29 \\leq y$ ] * @xmath30 \\in \\mathcal{f } \\longleftrightarrow r[x ] \\geq y$ ] and @xmath31 \\leq x$ ]    the following lemma shows that the families of intervals closed under intersection do admit such a representation .",
    "let @xmath23 be a family of intervals closed under intersection .",
    "there exists a generator that represents the family @xmath23 .",
    "let @xmath32 $ ] be the maximum end of an interval of @xmath23 starting at @xmath33 and let @xmath34 $ ] be the minimum beginning of an interval of @xmath23 ending at @xmath35 .",
    "@xmath36 is a generator of @xmath23 .",
    "notice that this representation is particularly useful when we want to consider the intersection of several families of intervals closed under intersection :    if @xmath37 and @xmath38 are two families of intervals closed under intersection , @xmath37 being represented by the generator @xmath39 and @xmath38 by the generator @xmath40 , then @xmath41 is represented by the generator @xmath27 defined by :    1 .",
    "@xmath28 = min(r_1[x],r_2[x])$ ] 2 .   @xmath29 = max(l_1[y],l_2[y])$ ]     with , on its right , an example of generator representing the family of the intervals @xmath4 such that @xmath42 $ ] is connected .",
    "for example , we have @xmath43 = 9 $ ] and @xmath44 = 1 $ ] thus , since @xmath43 \\geq 6 $ ] and @xmath44 \\leq 1 $ ] , @xmath45 $ ] is in this family . ]    [ cols=\"^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     in all the previous cases , we have obtained optimal algorithms both for the computation of a generator and the enumeration .",
    "furthermore for the classes * b * and * d * , all the algorithms of the section [ tree_dec_perm ] can be adapted to these families .",
    "in particular , we can compute their decomposition tree in linear time .",
    "in this section , we address the problem of computing the connected intervals of a path .",
    "this problem is equivalent to the problem of finding the common intervals of two permutations : given two permutations @xmath46 of @xmath47 , compute the subsets of @xmath47 that appear consecutively both in @xmath48 and @xmath49 .",
    "first remark that we can assume that @xmath50 ( by renumbering the elements ) .",
    "the problem then becomes : given a permutation @xmath51 of @xmath47 , compute the integer intervals @xmath4 such that @xmath52 is an integer interval .",
    "these integer intervals are exactly the connected intervals of a path over @xmath47 that visits the vertices in the order given by @xmath51 .    in the literature , the prevalent formulation of the problem is the computation of the common intervals of two permutations .",
    "it appears especially in comparative genomic : if the genomes of two species are close , then we expect that important parts coincides up to some reordering of the genes .",
    "it also models the notion of gene cluster : several genes that present functional associations are expected to appear consecutively .",
    "this problem of finding the common intervals of two permutations was introduced by @xcite in 2000 .",
    "they propose an optimal , but complex , algorithm that enumerates the @xmath53 common intervals in time @xmath54 .",
    "@xcite introduced the notion of irreducible intervals and obtained an @xmath55 algorithm that outputs all @xmath53 common intervals a @xmath56 permutations .",
    "@xcite introduced the tree structure of this family of intervals and presented a linear time algorithm to compute this tree .",
    "@xcite presented a simplest linear time algorithm , introducing the notion of generator that we use to represent the connected intervals of a tree .",
    "in all the section , we consider the permutation @xmath51 given by the order in which the path visits the vertices ( since this order is defined up to a reversal , we arbitrarily choose one of the two possible directions ) .",
    "the connected intervals @xmath57 of our path are exactly the intervals @xmath4 such that @xmath52 is an interval . representing the permutation @xmath51 in two dimensions ( [ square ] ) , these connected intervals",
    "are represented by `` squares . ''      in the tree case , @xmath57 is closed under union and intersection of its overlapping members .",
    "when @xmath2 is a path , @xmath57 is also closed under the difference of its overlapping members .",
    "a family closed under union , intersection and difference of its overlapping members is called _ weakly partitive _ and admits a canonical tree of decomposition @xcite .",
    "since @xmath57 is moreover a family of intervals , this tree has a particularly simple structure that we will explicit .    in the previous section , we presented a linear time algorithm to compute a generator representing the family @xmath57 when @xmath2 is a tree .",
    "we can use this algorithm to compute a generator for the case of a path and then use the procedure described in @xcite to create from a generator the tree representing a weakly partitive family of intervals .",
    "however , using the specific properties of this special case , we can obtain a simplest linear time algorithm that only uses basic data structures like stacks and directly builds the tree .",
    "we will use , like in the tree case , the notion of _ potential beginning _ and _ potential end_.    we will first address the problem of checking the simplicity of a permutation . a permutation is called _ simple _ ( or _ prime _ ) when all its corresponding connected intervals are trivial ( i.e.  of length 1 or @xmath60 ) .",
    "simple permutations are of first interests in the combinatorial study of permutation classes . in particular , @xcite if the simplicity of a permutation could be checked in linear time .",
    "of course , the computation of the tree decomposition of @xmath57 answers this question .",
    "however , we present a very simple linear time algorithm to answer it .",
    "we afterwards extend this algorithm to build the decomposition tree of @xmath57 .",
    "given the permutation @xmath51 , we present a very simple linear time algorithm that computes a non trivial connected interval when there exists one .",
    "this algorithms will cover the main ideas we will use to compute the decomposition tree of @xmath57 .",
    "we will , as in the tree case , consider the elements one by one and maintain the potential beginnings .",
    "for convenience , we redefine the notion of potential beginning in this new context ( even if it coincides with the one given inherited from the tree case ) .",
    "only the elements of @xmath63 have a chance to be the beginning of a connected interval ending after @xmath35 . indeed ,",
    "if there exists for example @xmath64 with @xmath65 , then for @xmath66 , @xmath67)$ ] contains @xmath68 and @xmath69 but not @xmath70 that is between @xmath68 and @xmath69 so @xmath71 \\not \\in \\mathcal{i}$ ] .    for the more general case of a tree",
    ", we have shown that ` potbeg ` behaves like a stack ( when we consider the @xmath35 in increasing order ) and that the beginnings of the connected intervals ending at @xmath35 form a suffix of this stack .",
    "so for a given @xmath35 , we will just have to check the head of ` potbeg ` to detect if there is a non trivial connected interval ending at @xmath35 .        in order to check this condition in constant time ,",
    "we precompute for each @xmath33 the values @xmath76 = \\min",
    "\\{p(z ) | z < x , p(z)>x\\}$ ] and @xmath77 = \\max \\{p(z ) | z < x , p(z)<x\\}$ ] . this precomputation is a classic one and can be done easily in linear time with a stack .",
    "recall that to detect if their exists a non trivial connected interval ending at @xmath35 , we just have to check if the greater potential beginning @xmath78 of @xmath63 is the beginning of a connected interval ending at @xmath35 .    denoting @xmath79 and @xmath80 , we can check if @xmath30 \\in \\mathcal{i}$ ] by testing if @xmath81 . in order to compute @xmath82 and @xmath83",
    "when we want to perform this test , we have to maintain the maximum and minimum between each pair of consecutive potential beginnings in the stack ` potbeg ` ( as shown in the algorithm ) .",
    "notice that , since the beginnings of the connected intervals ending at @xmath35 form a suffix of the stack _ potbeg _ , we can enumerate all the @xmath53 connected intervals in time @xmath54 by replacing the last if - statement of algorithm [ one_ci ] by :          recall that two sets overlap when they intersect without inclusion .",
    "each time we consider a family @xmath23 on a ground set @xmath0 , we assume that @xmath23 contains @xmath0 and all the singletons of @xmath0 .",
    "weakly partitive family _ is a family @xmath23 such that if @xmath85 are two members of @xmath23 that overlap then @xmath86 , @xmath87 , @xmath88 , @xmath89 are in @xmath23 .",
    "it is easy to check that , when @xmath2 is a path , @xmath57 is a weakly partitive family of intervals .",
    "@xcite showed that a weakly partitive family admits a tree representation ( of linear size ) .",
    "we will here explicit this tree in the case of the family of the connected intervals of a permutation @xmath51 .",
    "the nodes of the tree are given by the overlap - free members of the family : a member is overlap - free when it does not overlap any other .",
    "the family @xmath90 of overlap - free members of @xmath57 is laminar by definition and then can be represented with a tree @xmath91 where the parent of @xmath92 is the smallest @xmath93 that strictly contains @xmath94 .",
    "this tree will be labelled in order to represent the whole family @xmath57 .",
    "[ quotient family ] let @xmath94 be a node of @xmath91 .",
    "we denote @xmath97 the list of the children of @xmath94 in @xmath91 given from left to right .",
    "if @xmath98 and @xmath99 are two distinct children of @xmath94 , @xmath100 and @xmath101 are two disjoint intervals . denoting @xmath102 when @xmath103 , we thus obtain a total order . the _ quotient _ family @xmath104 of @xmath94 is defined as the permutation given by @xmath105 on @xmath97 .                  extending the previous algorithm , we present an algorithm that computes the decomposition tree of @xmath57 . roughly speaking , we can just process as before and contract the connected intervals found on the fly .",
    "each time we contract a connected interval , we will manipulate it like a singleton . more generally we will speak about _",
    "nodes_. ` potbeg ` is now a stack of nodes and all the variables used in the previous algorithms can be adapted to support this notion of node .",
    "we have defined above the decomposition tree of a permutation .",
    "in fact , we can define the decomposition forest of any injection from @xmath106 to @xmath47 by considering the overlap - free connected intervals .",
    "the general idea is still to consider the @xmath35 in increasing order . at each step , we maintain the decomposition forest @xmath108 of the restriction of @xmath51 over @xmath109 .",
    "we will see how to update @xmath110 to @xmath108 .",
    "to to this update , we will have two operations @xmath111 and @xmath112 .",
    "assume that we have considered @xmath114 and computed the forest @xmath110 of the overlap - free connected intervals in the restriction of @xmath51 over @xmath114 .",
    "denoting @xmath115 the trees of this forest ( numbered from left to right ) , when we consider @xmath35 we build the node @xmath116 corresponding to the singleton @xmath35 and we represent this configuration by the notation @xmath117 .",
    "this configuration will evolve until the update to @xmath118 is achieved , @xmath116 representing the tree decomposition of the restriction of @xmath51 on its support .",
    "@xmath119 can be seen as a stack ( remark that the stack of potential beginnings is a substack of @xmath120 ) and we will consider operations considering @xmath116 and a suffix of @xmath120 .",
    "metaphorically speaking , we can consider that @xmath116 will `` eat '' head terms of @xmath120 .",
    "more precisely , we consider two kinds of operations .",
    "let us describe the case of an * increasing extension * ( the case of a decreasing one being symmetrical ) .",
    "consider @xmath121 the connected interval corresponding to the root of @xmath122 and @xmath123 the one corresponding to the root of @xmath116 .",
    "when @xmath121 is an increasing node and @xmath124 , we do the following :                              first , we show that a connected interval does not overlap any of the supports @xmath141 .",
    "assume towards contradiction that a connected interval @xmath4 overlaps @xmath136 and we choose @xmath4 minimal for inclusion .",
    "without loss of generality , we assume that @xmath4 overlaps @xmath136 on the right ( i.e. ; the beginning of @xmath136 is not in @xmath4 ) .",
    "let @xmath142 be the supports that @xmath4 intersects .",
    "if @xmath143 then we have that @xmath144 is a connected interval , that contradicts the assumptions .",
    "we thus have @xmath145 .",
    "@xmath4 does not overlap @xmath146 ( if not we would contradict its minimality by considering @xmath147 ) , so @xmath148 . from this",
    "we derive that @xmath149 is a connected interval , contradiction .    from this property",
    "we have that a connected interval is contained in one of the supports @xmath150 .",
    "consequently , every overlap - free connected interval is a node of one of the tree @xmath137 , since each @xmath135 is the decomposition tree of its support .",
    "we hence have the decomposition forest .    if @xmath151 are the trees of the decomposition forest of @xmath51 restricted to @xmath152 , then @xmath153 , obtained with the previous algorithm when adding @xmath56 , is the decomposition forest of @xmath51 restricted to @xmath106 .    from the previous lemma ,",
    "if we assume that @xmath116 is the decomposition tree on its support then , since @xmath154 are the decomposition trees on their support and no prime creation is possible , we obtain the decomposition forest of @xmath51 restricted to @xmath106 .",
    "we then have to demonstrate that @xmath116 is the decomposition tree on its support .",
    "recall that we begin with configuration @xmath117 where @xmath116 is the tree whose only node is the singleton @xmath56 .",
    "recall moreover that while we can perform a monotonic extension or a prime creation , we process it giving priority to the monotonic extension . @xmath134 and @xmath116 thus evolves until we obtain the final configuration .",
    "+ first , we show that we have the two following invariants :    * @xmath155 if @xmath122 is increasing and we can do an increasing extension , then @xmath116 is not increasing . *",
    "@xmath156 if @xmath122 is decreasing and we can do a decreasing extension , then @xmath116 , is not decreasing .",
    "we show only @xmath155 , ( @xmath156 being symmetrical ) .",
    "assume that @xmath122 and @xmath116 are increasing nodes and that we can do an increasing extension .",
    "let @xmath4 denotes the rightmost child of the root of @xmath122 , and let @xmath157 be the first of the root of @xmath116 .",
    "@xmath158 would be a connected interval that overlaps the support of @xmath122 , it contradicts the fact that the root of @xmath122 was overlap - free in the decomposition of the restriction of @xmath51 to @xmath152 .",
    "+ we now show the following invariant : @xmath116 is the tree decomposition on its support .",
    "@xmath159 we demonstrate first that a monotonic extension preserves this property .",
    "as before , we only consider the increasing case .",
    "we consider the node @xmath116 just after the increasing extension and let @xmath160 be its children ( @xmath161 is so the old value of @xmath116 ) .",
    "we now only consider the restriction of @xmath51 to the support of @xmath116 .",
    "assume towards contradiction that one of the nodes of @xmath116 is not overlap - free .",
    "we obtain that there exists a connected interval that overlaps @xmath161 but it would contradict the fact that @xmath161 is not increasing ( according to @xmath155 ) .",
    "hence the nodes of @xmath116 all correspond to overlap - free connected intervals .",
    "reciprocally , it is straightforward that all overlap - free connected intervals of the restriction of @xmath51 on the support of @xmath116 are represented by a node of @xmath116 .",
    "@xmath159 eventually we demonstrate that a prime super - node creation , when there is no possible monotonic extension , preserves the invariant too .",
    "let @xmath162 be the children of the prime node created ( @xmath161 is the old value of @xmath116 ) .",
    "each @xmath163 is the tree decomposition on its support .",
    "if a connected interval would overlap the support of @xmath163 , then it would also intersect @xmath161 and we could have processed a monotonic extension .",
    "moreover , there is no connected interval different from the support of @xmath116 that are an union of several @xmath163 . from lemma [ lemdec ]",
    ", we have have the result .",
    "the linearity of the algorithm comes from the @xmath164 detection of the _ monotonic extensions _ and _ prime super - nodes creations _ using the stack of potential beginnings .",
    "moreover , these two kinds of operations take a constant time to be performed . since each of these two kinds of updates create at least one arc in the final decomposition tree ,",
    "there is at most @xmath165 such updates .",
    "hence the whole complexity is @xmath166 .",
    "sectionconclusion the framework presented here not only simplify existing algorithms , but it allows to solve optimally new problems as developed in section 3 .",
    "we are convinced that this framework can also be applied to improve some algorithms dealing with permutations avoiding some patterns as defined in @xcite . in a companion paper @xcite we have studied the case where @xmath2 is a graph and @xmath7 `` being connected '' and develop a variation of this framework using more sophisiticated data structures .",
    "frdric boyer , anne morgat , laurent labarre , jol pothier , and alain viari .",
    "syntons , metabolons and interactons : an exact graph - theoretical approach for exploring neighbourhood between genomic and functional data . , 21(23):42094215 , 2005 ."
  ],
  "abstract_text": [
    "<S> given an elementary chain of vertex set @xmath0 , seen as a labelling of @xmath0 by the set @xmath1 , and another discrete structure over @xmath0 , say a graph @xmath2 , the * problem of common intervals * is to compute the induced subgraphs @xmath3 $ ] , such that @xmath4 is an interval of @xmath5 $ ] and @xmath3 $ ] satisfies some property @xmath6 ( as for example @xmath7 `` being connected '' ) . </S>",
    "<S> this kind of problems comes from comparative genomic in bioinformatics , mainly when the graph @xmath2 is a chain or a tree @xcite .    </S>",
    "<S> when the family of intervals is closed under intersection , we present here the combination of two approaches , namely the idea of potential beginning developed in @xcite and the notion of generator as defined in @xcite . </S>",
    "<S> this yields a very simple generic algorithm to compute all common intervals , which gives optimal algorithms in various applications . </S>",
    "<S> for example in the case where @xmath2 is a tree , our framework yields the first linear time algorithms for the two properties : `` being connected '' and `` being a path '' . in the case where @xmath2 is a chain , </S>",
    "<S> the problem is known as : * common intervals of two permutations * @xcite , our algorithm provides not only the set of all common intervals but also with some easy modifications a tree structure that represents this set .    </S>",
    "<S> * keywords : * connected intervals , common intervals , graph algorithms , . </S>"
  ]
}