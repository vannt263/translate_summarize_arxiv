{
  "article_text": [
    "* background .",
    "* matrix multiplication over semirings has a multitude of applications in computer science , and in particular in the area of graph algorithms ( e.g. , @xcite ) .",
    "one example is boolean matrix multiplication , related for instance to the computation of the transitive closure of a graph , where the product of two @xmath1 boolean matrices @xmath16 and @xmath17 is defined as the @xmath1 boolean matrix @xmath18 such that @xmath19=1 $ ] if and only if there exists a @xmath20 such that @xmath21=b[k , j]=1 $ ] . more generally , given a set @xmath22 and two binary operations @xmath23 and @xmath24 , the structure @xmath25 is a semiring if it behaves like a ring except that there is no requirement on the existence of an inverse with respect to the operation  @xmath26 . given two @xmath1 matrices @xmath16 and @xmath17 over  @xmath27 , the matrix product over @xmath28 is the @xmath1 matrix @xmath29 defined as @xmath30=\\bigoplus_{k=1}^n \\left(a[i , k]\\odot b[k , j]\\right ) $ ] for any @xmath31 .",
    "the boolean matrix product is simply the matrix product over the semiring @xmath32 .",
    "the @xmath0-product and the distance product , which both have applications to a multitude of tasks in graph theory such as constructing fast algorithms for all - pairs paths problems ( see , e.g. , @xcite ) , are the matrix products over the semiring @xmath33 and the semiring @xmath34 , respectively . whenever the operation @xmath26 is such that a term as @xmath35 can be computed in @xmath36 time using quantum techniques ( e.g. , for @xmath37 using grover s algorithm  @xcite or for @xmath38 and @xmath39 using quantum algorithms for minimum finding  @xcite ) and each operation",
    "@xmath40 can be implemented in @xmath41 time , the product of two @xmath1 matrices over the semiring @xmath28 can be computed in time @xmath10 on a quantum computer .",
    "suppresses the @xmath42 factors .",
    "] this is true for instance for the boolean matrix product , and for both the @xmath0 and distance matrix products .",
    "a fundamental question is whether we can do better than those @xmath10-time straightforward quantum algorithms . for the boolean matrix product ,",
    "the answer is affirmative since it can be computed classically in time @xmath43 , where @xmath15 is the exponent of square matrix multiplication over a field .",
    "however , boolean matrix product appears to be an exception , and for most semirings it is not known if matrix multiplication can be done in @xmath43-time .",
    "for instance , the best known classical algorithm for the @xmath0-product , by duan and pettie @xcite , has time complexity @xmath44 while , for the distance product , no truly subcubic classical algorithm is even known ( without introducing assumptions on the matrices ) .",
    "* our results .",
    "* we construct in this paper the first quantum algorithms with exponent strictly smaller than @xmath45 for matrix multiplication over several semirings .",
    "we first obtain the following result for matrix multiplication over the @xmath0 semiring .",
    "[ the2 ] there exists a quantum algorithm that computes , with high probability , the @xmath0-product of two @xmath1 matrices in time @xmath2 .    in comparison ,",
    "the best known classical algorithm for the @xmath0-product , by duan and pettie  @xcite , has time complexity @xmath44 , as mentioned above .",
    "the @xmath0-product has mainly been studied in the field in fuzzy logic  @xcite under the name _ composition of relations _ and in the context of computing the all - pairs bottleneck paths of a graph ( i.e. , computing , for all pairs @xmath46 of vertices in a graph , the maximum flow that can be routed between @xmath47 and  @xmath48 ) .",
    "more precisely , it is well known ( see , e.g. , @xcite ) that if the @xmath0-product of two @xmath1 matrices can be computed in time @xmath49 , then the all - pairs bottleneck paths of a graph with @xmath4 vertices can be computed in time @xmath50 . as an application of theorem  [ the2 ]",
    ", we thus obtain a @xmath2-time quantum algorithm computing the all - pairs bottleneck paths of a graph of @xmath4 vertices , while classically the best upper bound for this task is @xmath3 , again from  @xcite .    in order to prove theorem [ the2 ] , we construct a quantum algorithm that computes the product of two @xmath1 matrices over the existence dominance semiring ( defined in the next section ) in time @xmath51 .",
    "the dominance product has applications in computational geometry @xcite and graph algorithms @xcite and , in comparison , the best known classical algorithm for this product @xcite has complexity @xmath52 .",
    "computing efficiently the existence dominance product is , nevertheless , not enough for our purpose .",
    "we introduce ( in section [ sec_existence ] ) a new generalization of it that we call the _ generalized existence dominance product _ , and develop both quantum and classical algorithms that compute efficiently this product .",
    "this is the most technical part of this paper .",
    "we also show ( in subsection [ subsec_dist ] ) how these results for the generalized existence dominance product can be used to construct classical and quantum algorithms computing the @xmath5 most significant bits of each entry of the distance product of two @xmath1 matrices . in the quantum setting , we obtain time complexity @xmath53 in comparison , prior to the present work , the best known classical algorithm for the same problem by vassilevska and williams  @xcite had complexity @xmath54 with a slight improvement on the exponent of @xmath4 obtained later by yuster  @xcite .",
    "we obtain an improvement for this classical time complexity as well , reducing it to @xmath55 , which gives a sublinear dependency on @xmath9 .",
    "these results are , to the best of our knowledge , the first quantum algorithms for matrix multiplication over semirings other than the boolean semiring improving over the straightforward @xmath10-time quantum algorithm , and the first nontrivial quantum algorithms offering a speedup with respect to the best classical algorithms for matrix multiplication when no assumptions are made on the sparsity of the matrices involved ( sparse matrix multiplication is discussed below ) .",
    "this shows that , while quantum algorithms may not be able to outperform the classical @xmath43-time algorithm for matrix multiplication of ( dense ) matrices over a ring , they can offer a speedup for matrix multiplication over other algebraic structures .",
    "we finally investigate under which conditions quantum algorithms faster than the best known classical algorithms can be constructed for boolean matrix multiplication .",
    "this question has been recently studied extensively in the output - sensitive scenario @xcite , for which quantum algorithms multiplying two @xmath1 boolean matrices with query complexity @xmath56 and time complexity @xmath57 were constructed , where @xmath58 denotes the number of non - zero entries in the output matrix . in this work ,",
    "we focus on the case where the input matrices are sparse ( but not necessarily the output matrix ) , and evaluate the performance of quantum algorithms in this scenario .",
    "our result ( theorem [ prop ] ) shows how several standard combinatorial ideas for sparse boolean matrix multiplication can be adapted in the quantum setting , and used to construct quantum algorithms faster than the best known classical algorithms .",
    "in particular , we obtain the following result .",
    "[ th_booleansparse ] let @xmath16 and @xmath17 be two @xmath1 boolean matrices each containing at most @xmath59 non - zero entries .",
    "there exists a quantum algorithm that computes , with high probability , the boolean matrix product @xmath60 and has time complexity @xmath61    the complexity of the algorithm of theorem [ th_booleansparse ] is the piece - linear function of @xmath62 represented in figure [ fig ] . in comparison ,",
    "the best known classical algorithm , by yuster and zwick @xcite , has complexity @xmath63 if @xmath64 , @xmath65 if @xmath66 , and @xmath43 if @xmath67 .",
    "our algorithm performs better when @xmath68 .",
    "for instance , if @xmath69 , then our algorithm has complexity @xmath12 , while the algorithm by @xcite has complexity @xmath43 .",
    "[ fig ]     ( in solid lines ) .",
    "the horizontal axis represents the logarithm of  @xmath59 with respect to basis @xmath4 ( i.e. , the value @xmath62 ) . the vertical axis represents the logarithm of the complexity with respect to basis @xmath4 .",
    "the dashed lines represent the upper bounds obtained by @xcite . ]",
    "our main quantum tool is rather standard : quantum enumeration , a variant of grover s search algorithm .",
    "we use this technique in various ways to improve the combinatorial steps in several classical approaches @xcite that are based on a combination of algebraic steps ( computing some matrix products over a field ) and combinatorial steps .",
    "moreover , the speedup obtained by quantum enumeration enables us to depart from these original approaches and optimize the combinatorial and algebraic steps in different ways , for instance relying on rectangular matrix multiplication instead of square matrix multiplication . on the other hand ,",
    "several subtle but crucial issues appear when trying to apply quantum enumeration , such as how to store and access information computed during the preprocessing steps , which induces complications and requires the introduction of new algorithmic ideas .",
    "we end up with algorithms fairly remote from these original approaches , where most steps are tailored for the use of quantum enumeration .",
    "more detailed technical overviews are given at the beginning of sections [ sec_existence ] , [ sec_maxmin ] and  [ sec_red ] .",
    "* rectangular matrix multiplication over fields*. for any @xmath70 , let @xmath71 represent the minimal value @xmath72 such that , over a field , the product of an @xmath73 matrix by an @xmath74 matrix can be computed with @xmath75 arithmetic operations .",
    "the value @xmath76 is denoted by @xmath14 , and the current best upper bound on @xmath14 is @xmath15 , see @xcite .",
    "other important quantities are the value @xmath77 and the value @xmath78 .",
    "the current best lower bound on @xmath79 is @xmath80 , see @xcite .",
    "the following facts are known , and will be used in this paper .",
    "we refer to @xmath81 for details .",
    "[ fact_rmm1 ] @xmath82 for @xmath83 and @xmath84 for @xmath85 .",
    "[ fact_rmm2 ] the following relations hold for any values @xmath70 : ( i ) @xmath86 for any @xmath87 ; ( ii ) @xmath88 for any permutation @xmath89 over @xmath90 ; ( iii ) @xmath91 ; ( iv ) @xmath92 .    * matrix products over semirings .",
    "* we define below two matrix products over semirings considered in sections [ sec_existence ] and [ sec_maxmin ] , respectively , additionally to the boolean product , the @xmath0-product and the distance product defined in the introduction .",
    "these products were also used in @xcite .",
    "let @xmath16 be an @xmath1 matrix with entries in @xmath93 and @xmath17 be an @xmath1 matrix with entries in @xmath94 .",
    "the existence dominance product of @xmath16 and @xmath17 , denoted @xmath95 , is the @xmath1 boolean matrix @xmath29 such that @xmath19=1 $ ] if and only if there exists some @xmath20 such that @xmath21\\le b[k , j]$ ] .",
    "the product @xmath96 is the @xmath1 matrix @xmath29 such that @xmath19=-\\infty$ ] if @xmath21 > b[k , j]$ ] for all @xmath20 , and @xmath19=\\max_k\\{a[i , k]\\:|\\:a[i , k]\\le b[k , j]\\}$ ] otherwise .",
    "it is easy to check , as mentioned for instance in @xcite , that computing the @xmath0-product reduces to computing the product @xmath97 . indeed",
    "if @xmath29 denotes the @xmath0-product of two matrices @xmath16 and @xmath17 , then for any @xmath98 we can write @xmath30=\\max\\left\\{(a{\\leftslice}b)[i , j],(b^t{\\leftslice}a^t)[j , i]\\right\\ } , $ ] where @xmath99 and @xmath100 denote the transposes of @xmath16 and @xmath17 , respectively .",
    "matrix products over the semirings @xmath101 , @xmath102 and @xmath103 studied , for instance , in @xcite , similarly reduce to computing the product @xmath97 .    *",
    "quantum algorithms for matrix multiplication .",
    "* we assume that a quantum algorithm can access any entry of the input matrix in a random access way , similarly to the standard model used in @xcite for boolean matrix multiplication .",
    "more precisely , let @xmath16 and @xmath17 be two @xmath1 matrices , for any positive integer @xmath4 ( the model presented below can be generalized to deal with rectangular matrices in a straightforward way ) .",
    "we suppose that these matrices can be accessed directly by a quantum algorithm : we have an oracle  @xmath104 that , for any @xmath105 , and any @xmath106 , maps the state @xmath107 to @xmath108 \\rangle}{\\vert z \\rangle}$ ] .",
    "we have a similar oracle @xmath109 for @xmath17 .",
    "since we are interested in time complexity , we will count all the computational steps of the algorithm and assign a cost of one for each call to @xmath104 or @xmath109 , which corresponds to the cases where quantum access to the inputs @xmath16 and @xmath17 can be done at unit cost , for example in a random access model working in quantum superposition .",
    "we say that a quantum algorithm for matrix multiplication computes the product of @xmath16 and @xmath17 with high probability if , when given access to oracles @xmath104 and @xmath109 corresponding to @xmath16 and @xmath17 , the algorithm outputs with probability at least @xmath110 all the entries of the product of @xmath16 and @xmath17 .",
    "the complexity of several algorithms in this paper will be stated using an upper bound @xmath58 on the number of non - zero or non - infinite entries in the product of @xmath16 and @xmath17 . the same complexity , up to a logarithmic factor ,",
    "can actually be obtained even if no nontrivial upper bound is known a priori , see @xcite .",
    "we will use variants of grover s search algorithm , as described for instance in  @xcite , to find elements satisfying some conditions inside a search space of size  @xmath111 . concretely , suppose that a boolean function @xmath112 is given and that we want to find a solution , i.e. , an element @xmath113 such that @xmath114 . consider the quantum search procedure ( called safe grover search in @xcite ) obtained by repeating grover s standard search a logarithmic number of times , and checking if a solution has been found .",
    "this quantum procedure outputs one solution with probability at least @xmath115 if a solution exists , and always rejects if no solution exists .",
    "its time complexity is @xmath116 , where @xmath48 denotes the number of solutions , if the function @xmath117 can be evaluated in @xmath118 time . by repeating this procedure and striking out solutions as soon as they are found",
    ", one can find all the solutions with probability at least @xmath115 using @xmath119 computational steps .",
    "we call this procedure",
    "_ quantum enumeration_.",
    "in this section we present a quantum algorithm that computes the existence dominance product of two matrices @xmath16 and @xmath17 .",
    "the underlying idea of our algorithm is similar to the idea in the best classical algorithm for the same problem by duan and pettie @xcite : use a search step to find some of the entries of @xmath120 , and rely on classical algebraic algorithms to find the other entries .",
    "we naturally use quantum search to implement the first part , and perform careful modifications of their approach to improve the complexity in the quantum setting , taking advantage of the features of quantum enumeration .",
    "there are two notable differences : the first one is that the algebraic part of our quantum algorithms uses rectangular matrix multiplication , while @xcite uses square matrix multiplication .",
    "the second and crucial difference is that , for applications in later sections , we give a quantum algorithm that can handle a more general version of the existence dominance product , defined on set of matrices , which we call the _ generalized existence dominance product _ and define below .",
    "[ def : gene ] let @xmath121 be two positive integers , and @xmath122 be the set @xmath123 .",
    "let @xmath124 be the lexicographic order over @xmath125 ( i.e , @xmath126 if and only if @xmath127 or ( @xmath128 and @xmath129 ) ) .",
    "consider @xmath130 matrices @xmath131 , each of size @xmath1 with entries in @xmath93 , and @xmath132 matrices @xmath133 , each of size @xmath1 with entries in @xmath94 .",
    "for each @xmath98 define the set @xmath134 as follows : @xmath135=1\\}\\cup\\{(0,0)\\}.\\ ] ] the generalized existence dominance product of these matrices is the @xmath1 matrix @xmath29 with entries in @xmath125 defined as follows : for all @xmath98 the entry @xmath19 $ ] is the maximum element in @xmath136 , where the maximum refers to the lexicographic order .",
    "note that the case @xmath137 corresponds to the standard existence dominance product , since @xmath19=(1,1)$ ] if @xmath138=1 $ ] and @xmath19=(0,0)$ ] if @xmath138=0 $ ] .",
    "[ prop_densedom ] let @xmath131 be @xmath130 matrices of size @xmath1 with entries in @xmath93 , and @xmath133 be @xmath132 matrices of size @xmath1 with entries in @xmath94 .",
    "let @xmath139 denote the total number of finite entries in the matrices @xmath131 , and @xmath140 denote the total number of finite entries in the matrices @xmath133 .",
    "for any parameter @xmath141 , there exists a quantum algorithm that computes , with high probability , their generalized existence dominance product in time @xmath142    let @xmath143 be a parameter to be chosen later .",
    "let @xmath144 be the list of all finite entries in @xmath131 sorted in increasing order .",
    "decompose @xmath144 into @xmath48 successive parts @xmath145 , each containing at most @xmath146 entries . for each @xmath147 and each @xmath148",
    "we construct two @xmath1 matrices @xmath149 as follows : for all @xmath31 , @xmath150=&\\left\\ { \\begin{array}{ll } a^{(x)}[i , j ] \\textrm { if } a^{(x)}[i , j]\\in",
    "l_r,\\\\ \\infty \\textrm { otherwise , } \\end{array } \\right . & \\hspace{6 mm } \\bar{a}^{(x)}_r[i , j]=&\\left\\ { \\begin{array}{ll } 1 \\textrm { if } a^{(x)}[i , j]\\in l_r,\\\\ 0 \\textrm { otherwise . }",
    "\\end{array } \\right.\\end{aligned}\\ ] ] similarly , for each @xmath151 and each @xmath148 we construct two @xmath1 matrices @xmath152 as follows : for all @xmath31 , @xmath153=&\\left\\ { \\begin{array}{ll } b^{(y)}[i , j ] \\textrm { if } \\min",
    "l_r\\le b^{(y)}[i , j ] < \\max l_r,\\\\ -\\infty \\textrm { otherwise , } \\end{array } \\right . & \\hspace{6 mm } \\bar{b}^{(y)}_r[i , j]=&\\left\\ { \\begin{array}{ll } 1 \\textrm { if } b^{(y)}[i ,",
    "j]\\ge \\max l_r,\\\\ 0 \\textrm { otherwise . } \\end{array } \\right.\\end{aligned}\\ ] ] the cost of this ( classical ) preprocessing step is @xmath154 time .",
    "it is easy to see that , for each @xmath147 and @xmath151 , the following equality holds ( where the operators @xmath155 and @xmath156 refer to the entry - wise or ) : @xmath157 indeed , the second term compares entries that are in a same part @xmath158 , while the first term takes into consideration entries in distinct parts . define two @xmath1 matrices @xmath159 and @xmath160 with entries in @xmath125 as follows : for all @xmath31 , @xmath161=&\\max\\left\\{\\{(0,0)\\}\\cup \\{(x , y)\\in s\\:|\\ : \\sum_{r=1}^t\\bar a_r^{(x)}{\\cdot}\\bar b_r^{(y)}[i , j]=1\\}\\right\\},\\\\ c_2[i , j]=&\\max\\left\\{\\{(0,0)\\}\\cup \\{(x , y)\\in s\\:|\\ : \\sum_{r=1}^t a_r^{(x)}\\ast   b_r^{(y)}[i , j]=1\\}\\right\\}.\\end{aligned}\\ ] ] from equation ( [ eq_rel ] ) , the generalized existence dominance product @xmath29 satisfies @xmath30=\\max\\{c_1[i ,",
    "j],c_2[i , j]\\ } $ ] for all @xmath31 .",
    "the matrix @xmath29 can then be computed in time @xmath162 from @xmath159 and @xmath160 .",
    "the matrix @xmath159 can clearly be computed in time @xmath163 if all the terms @xmath164 are known .",
    "we can obtain all these @xmath165 terms by computing the following boolean product of an @xmath166 matrix by an @xmath167 matrix ( both matrices can be constructed in time @xmath168 ) .",
    "@xmath169 \\cdot \\left [ \\begin{array}{ccc } \\bar b^{(1)}_1&\\cdots\\cdots&\\bar b^{(v)}_1\\\\ \\vdots&&\\vdots\\\\ \\bar b^{(1)}_t&\\cdots\\cdots&\\bar b^{(v)}_t\\\\ \\end{array } \\right]\\ ] ] the cost of this matrix multiplication is @xmath170 . from item ( iv ) of fact [ fact_rmm2 ] , we conclude that the matrix @xmath159 can be computed in time @xmath171    we use the following lemma to help us compute the matrix @xmath160 . while this is the main technical part of the proof of this proposition , for readability",
    "its proof is placed in the appendix .",
    "[ lemma_dom ] there exists a quantum algorithm that , with high probability , outputs    * @xmath172 boolean matrices @xmath173 , each of size @xmath174 , for all @xmath147 and @xmath148 , * @xmath175 boolean matrices @xmath176 , each of size @xmath177 , for all @xmath151 and @xmath148 , * a matrix @xmath178 of size @xmath1 with entries in @xmath179 ,    such that @xmath180=\\max\\left\\{\\{d[i , j]\\}\\cup \\{(x , y)\\in s\\:|\\ : \\sum_{r=1}^t\\hat a_r^{(x)}{\\cdot}\\hat b_r^{(y)}[i , j]=1\\}\\right\\}\\ ] ] for all @xmath31 .",
    "the time complexity of this quantum algorithm is @xmath181    after applying the quantum algorithm of lemma [ lemma_dom ] , we can obtain the matrix @xmath160 , similarly to the computation of @xmath159 , if we know all the terms @xmath182 .",
    "we obtain all these @xmath165 terms by computing the following boolean product of an @xmath166 matrix by an @xmath167 matrix .",
    "@xmath183 \\cdot \\left [ \\begin{array}{ccc } \\hat b^{(1)}_1&\\cdots\\cdots&\\hat b^{(v)}_1\\\\ \\vdots&&\\vdots\\\\ \\hat b^{(1)}_t&\\cdots\\cdots&\\hat b^{(v)}_t\\\\ \\end{array } \\right]\\ ] ] the cost of this matrix multiplication is @xmath170 .",
    "the total cost of computing the matrix @xmath160 is thus @xmath184 which is the desired bound since the term @xmath185 is negligible here by item ( iv ) of fact [ fact_rmm2 ] .",
    "we can give a classical version of this result , whose proof can be found in the appendix , that will be used to prove theorem [ th_dist_cl ] in subsection [ subsec_dist ] .",
    "[ prop_densedom_cl ] there exists a classical algorithm that computes the generalized existence dominance product in time @xmath186 for any parameter @xmath141 .",
    "we now consider the case @xmath137 corresponding to the standard existence dominance product . by optimizing the choice of the parameter @xmath48 in proposition [ prop_densedom ] ,",
    "we obtain the following theorem .",
    "[ th_densedom ] let @xmath16 be an @xmath1 matrix with entries in @xmath93 containing at most @xmath187 non-(@xmath188 ) entries , and @xmath17 be an @xmath1 matrix with entries in @xmath94 containing at most @xmath189 non-(@xmath190 ) entries . there exists a quantum algorithm that computes , with high probability , the existence dominance product of @xmath16 and @xmath17 in time @xmath191 where @xmath192 is the solution of the equation @xmath193 in particular , this time complexity is upper bounded by @xmath194    the complexity of the algorithm of proposition [ prop_densedom ] is minimized for @xmath195 , where @xmath192 is the solution of the equation @xmath193 we can use items ( ii ) and ( iii ) of fact [ fact_rmm2 ] to obtain the upper bound @xmath196 , and optimize the complexity of the algorithm by taking @xmath197 , which gives the upper bound claimed in the second part of the theorem .    in the case of completely dense input matrices",
    "( i.e. , @xmath198 and @xmath199 ) , the second part of theorem  [ th_densedom ] shows that the complexity of the algorithm is @xmath51 .",
    "in this section we show how to apply the results of section [ sec_existence ] to construct quantum algorithms for the @xmath0-product and the distance product .",
    "in this subsection we present a quantum algorithm for the matrix product @xmath97 , which immediately gives a quantum algorithm with the same complexity for the @xmath0-product as explained in section [ prelim ] , and then gives theorem  [ the2 ] .",
    "our algorithm first exploits the methodology by vassilevska et al .",
    "@xcite to reduce the computation of the product @xmath97 to the computation of several sparse dominance products .",
    "the main technical difficulty to overcome is that , unlike in the classical case , computing all the sparse dominance products successively becomes too costly ( i.e. , the cost exceeds the complexity of all the other parts of the quantum algorithm ) . instead",
    ", we show that it is sufficient to obtain a small fraction of the entries in each dominance product and that this task reduces to the computation of a generalized existence dominance product , and then use the quantum techniques of proposition [ prop_densedom ] to obtain precisely only those entries .",
    "there exists a quantum algorithm that computes , for any two @xmath1 matrices @xmath16 and @xmath17 with entries respectively in @xmath93 and @xmath94 , the product @xmath96 with high probability in time @xmath200 where @xmath201 is the solution of the equation @xmath202 in particular , this complexity is upper bounded by @xmath203    let @xmath204 be a parameter to be chosen later . for each @xmath205 , we sort the entries in the @xmath206-th row of @xmath16 in increasing order and divide the list into @xmath207 successive parts @xmath208 with at most @xmath209 entries in each part . for each @xmath210 , define the @xmath1 matrix @xmath211 as follows : @xmath212=a[i , j]$ ] if @xmath213\\in r_r^i$ ] and @xmath212=\\infty$ ] otherwise .",
    "the cost of this ( classical ) preprocessing is @xmath214 time .",
    "we describe below the quantum algorithm that computes @xmath215 .",
    "* for each @xmath31 , we compute the largest @xmath216 such that @xmath217=1 $ ] , if such an @xmath218 exists .",
    "this is done by using the quantum algorithm of proposition [ prop_densedom ] with @xmath219 , @xmath220 , @xmath221 for each @xmath210 and @xmath222 .",
    "note that @xmath223 and @xmath224 .",
    "the complexity of this step is thus @xmath225 for any parameter @xmath226 .",
    "we want to minimize this expression .",
    "let us write @xmath227 and @xmath228 .",
    "for a fixed @xmath229 , the first term is a decreasing function of @xmath201 , while the second term is an increasing function of @xmath201 .",
    "the expression is thus minimized for the value of @xmath201 solution of the equation @xmath230 in which case the expression becomes @xmath231 .",
    "* step 2 . * note that at step 1 we also obtain all @xmath31 such that no  @xmath218 satisfying @xmath232=1 $ ] exists .",
    "for all those @xmath233 , we set @xmath19=-\\infty$ ] .",
    "for all other @xmath233 , we will denote by @xmath234 the value found at step 1 .",
    "we now know that @xmath235=\\max_{k : \\ : a[i , k]\\in r_{r_{ij}}^i}\\{a_{r_{ij}}[i , k]\\:|\\:a_{r_{ij}}[i , k]\\le b[k , j]\\},\\ ] ] and @xmath19 $ ] can be computed in time @xmath236 using the quantum algorithm for maximum finding @xcite , since @xmath237 .",
    "the complexity of step 2 is thus @xmath238 .",
    "this algorithm computes , with high probability , all the entries of @xmath215 .",
    "its complexity is @xmath239 since the term @xmath240 is negligible with respect to @xmath241 by item ( iv ) of fact [ fact_rmm2 ] .",
    "this expression is minimized for @xmath229 and @xmath201 satisfying @xmath242 . injecting this constraint into equation ( [ eqdelta ] ) , we find that the optimal value of @xmath201 is the solution of the equation @xmath243 as claimed .",
    "using items ( i ) and ( ii ) of fact [ fact_rmm2 ] and fact [ fact_rmm1 ] , we obtain @xmath244 and then @xmath245 the complexity is thus @xmath246 .      in this subsection we present a quantum algorithm that computes the most significant bits of the distance product of two matrices , as defined below .",
    "let @xmath16 and @xmath17 be two @xmath1 matrices with entries in @xmath93 .",
    "let @xmath247 be a power of two such that the value of each finite entry of their distance product @xmath29 is upper bounded by  @xmath247 .",
    "for instance , one can take the smallest power of two larger than @xmath248\\}+\\max_{i , j}\\{b[i , j]\\}$ ] , where the maxima are over the finite entries of the matrices .",
    "each non - negative finite entry of @xmath29 can then be expressed using @xmath249 bits : the entry @xmath19 $ ] can be expressed as @xmath30=\\sum_{k=1}^{\\log_2(w)}c[i , j]_k \\frac{w}{2^k } $ ] for bits @xmath19_1,\\ldots , c[i , j]_{\\log_2(w)}$ ] . for any @xmath250",
    ", we say that an algorithm computes the @xmath5 most significant bits of each entry if , for all @xmath31 such that @xmath19 $ ] is finite and non - negative , the algorithm outputs all the bits @xmath19_1,c[i , j]_2,\\cdots , c[i , j]_{\\ell}$ ] .",
    "vassilevska and williams  @xcite have studied this problem , and shown how to reduce the computation of the @xmath5 most significant bits to the computation of @xmath251 existence dominance matrix products of @xmath1 matrices . by combining this with the @xmath252-time algorithm for dominance product from @xcite",
    ", they obtained a classical algorithm that computes the @xmath5 most significant bits of each entry of the distance product of @xmath16 and @xmath17 in time @xmath253    here is the main result of this subsection , obtained by reducing the computation of the @xmath5 most significant bits to computing a generalized existence dominance product .",
    "[ th_dist1 ] there exists a quantum algorithm that computes , for any two @xmath1 matrices @xmath16 and @xmath17 with entries in @xmath93 , the @xmath5 most significant bits of each entry of the distance product of @xmath16 and @xmath17 in time @xmath254 with high probability .",
    "note that the trivial @xmath10-time quantum algorithm can be used to compute all the bits of each entry of the distance product @xmath29 of @xmath16 and @xmath17 .",
    "therefore , we will assume , without loss of generality , that @xmath5 satisfies the inequality @xmath255 , which implies in particular that @xmath256 .",
    "assume first that all the entries of @xmath29 are finite and non - negative .",
    "what we want to do is to compute , for each @xmath31 , the integer @xmath257 such that @xmath19 $ ] is in the interval @xmath258 .    for any integer @xmath259 ,",
    "define the matrices @xmath260 and @xmath261 as follows : for all @xmath31 , @xmath262&=a[i , j]-\\frac{xw}{2^{\\ell/2}},\\hspace{20mm}b'_x[i , j]=-b[i , j]+\\frac{xw}{2^{\\ell}}.\\end{aligned}\\ ] ]    assume for simplicity that @xmath5 is even ( a similar argument works for @xmath5 odd ) . for each @xmath257 , let @xmath263 denote the values such that @xmath264 . for each @xmath257 , define the boolean matrix @xmath265 where @xmath266 means the strict by @xmath267 in the definition of the existence dominance product ( definition 2.1 ) .",
    "note that all our results on the existence dominance product also hold for the strict existence dominance product and their proofs are essentially the same , just replacing inequalities by strict inequalities . ]",
    "existence dominance product .",
    "note that @xmath268 observe that , for each @xmath31 , we have @xmath269=0 \\longleftrightarrow\\min_{k}\\left(a[i , k]+b[k , j]\\right)\\ge \\frac{dw}{2^{\\ell}}.\\ ] ]    for each @xmath31 , the integer @xmath270 such that @xmath19 $ ] is in the interval @xmath271 can thus be found by computing the smallest @xmath257 such that @xmath272=1 $ ] .",
    "we can thus use in definition [ def : gene ] so that the algorithm of proposition [ prop_densedom ] finds the smallest @xmath273 such that @xmath272=1 $ ] instead of the largest @xmath273 .",
    "this is done simply by choosing @xmath124 as the decreasing lexicographic order instead of the usual lexicographic order .",
    "proposition [ prop_densedom ] and its proof are unchanged , since the proof only uses the fact that @xmath124 is a strict total order . ] the quantum algorithm of proposition [ prop_densedom ] , with @xmath274 , @xmath275 and @xmath276 for each @xmath277 . since @xmath278 , @xmath279 and from the inequality @xmath256 on @xmath5 ,",
    "the complexity is @xmath280 for any parameter @xmath281 .",
    "let us write @xmath282 and @xmath227 .",
    "the complexity is minimized for the value @xmath201 such that @xmath283 for which the complexity is @xmath284 . using items ( i ) and ( iii ) of fact [ fact_rmm2 ] and fact [ fact_rmm1 ] , we obtain @xmath285 this gives @xmath286 and thus @xmath287 the complexity is thus @xmath288    finally , we discuss the general case where the entries of @xmath29 can be negative or infinite .",
    "observe that the above algorithm detects which entries of @xmath29 are larger than @xmath289 : these are the entries such that the algorithm finds no @xmath273 such that @xmath272=1 $ ]",
    ". we can find which of these entries are larger than @xmath247 ( and thus infinite ) by computing the dominance product @xmath290 note that the algorithm also finds which entries of @xmath29 are negative : these are the entries for which the smallest @xmath273 such that @xmath272=1 $ ] is @xmath291 .    similarly , we can obtain a better classical algorithm as shown in the following theorem .",
    "[ th_dist_cl ] there exists a classical algorithm that computes , for any two @xmath1 matrices @xmath16 and @xmath17 with entries in @xmath93 , the @xmath5 most significant bits of each entry of the distance product of @xmath16 and @xmath17 in time @xmath292    the proof is similar to the proof of theorem [ th_dist1 ] , but we use proposition [ prop_densedom_cl ] instead of proposition [ prop_densedom ] .",
    "the complexity becomes @xmath293 for any parameter @xmath281 .",
    "let us write @xmath282 and @xmath227 .",
    "this expression is then @xmath294 this expression is minimized for the value @xmath201 such that @xmath295 for which the complexity is @xmath296 .    using items ( i ) and ( iii ) of fact [ fact_rmm2 ] and fact [ fact_rmm1 ]",
    ", we obtain @xmath297 this gives the inequality @xmath298 from which we obtain @xmath299 the complexity is thus @xmath300 as claimed .",
    "note that the dependency on @xmath4 of the @xmath301-time algorithm by vassilevska and williams  @xcite can be slightly improved using the recent @xmath52-time algorithm for dominance product by yuster  @xcite based on rectangular matrix multiplication .",
    "we can similarly obtain an improved bound @xmath302 , for some @xmath303 , with the same approach as in the proof of theorem [ th_dist_cl ] .",
    "however , it is complicated to express the value of @xmath304 in a closed form , so we omit the statement of this slight improvement .",
    "in this section we describe quantum versions of several known combinatorial techniques for handling sparse boolean matrix products .",
    "the main result is the following theorem , which shows how to compute the boolean product of two matrices @xmath16 and @xmath17 by reducing it to four products , each easier to compute than the original one when @xmath16 and @xmath17 are sparse enough .",
    "note that similar ideas have been used in @xcite to analyze applications of those combinatorial techniques in the classical setting . here",
    "we show how to implement these ideas using quantum enumeration and analyze the complexity of the resulting algorithm .",
    "[ prop ] assume that there exists an algorithm that computes , in time @xmath305 , the product of any @xmath306 boolean matrix and any @xmath307 boolean matrix such that their product contains at most @xmath144 non - zero entries .",
    "let @xmath16 and @xmath17 be two @xmath1 boolean matrices with at most @xmath187 and @xmath189 non - zero entries in @xmath16 and  @xmath17 , respectively . for any values of the three parameters @xmath308 and @xmath309 , there exists a quantum algorithm that computes , with high probability , the boolean product @xmath60 and has time complexity @xmath310 where @xmath58 denotes the number of non - zero entries in @xmath60 , and @xmath311 for each @xmath312 .    for any @xmath313 ,",
    "let @xmath314 ( resp .",
    "@xmath315 ) be the number of non - zero entries in the @xmath316-th row of @xmath16 ( resp .",
    "@xmath17 ) and @xmath317 ( resp .",
    "@xmath318 ) be the number of non - zero entries in the @xmath316-th column of @xmath16 ( resp .",
    "@xmath17 ) .",
    "we define the following six sets of indexes , and compute them classically in time @xmath162 .",
    "@xmath319    given two sets @xmath320 and an @xmath1 boolean matrix @xmath321 , the notation @xmath322 will represent the @xmath1 boolean matrix such that @xmath323=1 $ ] if and only if @xmath324=1 $ ] and @xmath325 . for convenience",
    ", @xmath326 will represent the matrix @xmath322 for @xmath327 , and @xmath328 the matrix @xmath322 for @xmath329 .",
    "it is easy to check that @xmath330 where @xmath155 represents the entry - wise or operation .",
    "we will individually compute the four terms of this sum .",
    "the computation of @xmath331 consists in the computation of a @xmath332 matrix by a @xmath333 matrix .",
    "we implement this part using the algorithm whose existence is assumed in the statement of the theorem .",
    "note that , from the sparsity of @xmath17 , we have @xmath334 and thus @xmath335 .",
    "similarly we have @xmath336 and @xmath337 .",
    "additionally , we know that @xmath122 , @xmath338 and @xmath339 have size at most @xmath4 . thus this part can be implemented in @xmath340 time .    in order to compute @xmath341",
    "we do the following .",
    "let @xmath342 denote the number of non - zero entries of @xmath343 .",
    "first , we list all these non - zero entries , classically in time @xmath162 , and record them into two arrays @xmath344 and @xmath345 of size @xmath342 : for each @xmath346 the value @xmath347 $ ] records the row index of the @xmath348-th element of the list , while @xmath349 $ ] records its column index .",
    "then , for each @xmath350 , we compute the set of indexes @xmath351 such that @xmath352=1 $ ] and record them into an array @xmath353 .",
    "note that @xmath353 has length @xmath354 , and that @xmath355 from the definition of @xmath356 .",
    "the computation of all the @xmath353 s can be done classically in @xmath162 time . finally , take @xmath357}$ ] and define the function @xmath358 as follows : for any @xmath346 and any @xmath359}\\}$ ] , @xmath360}\\right)=({\\mathsf{m_1}}[p],{\\mathsf{n}}_{{\\mathsf{m_2}}[p]}[q]),\\ ] ] where @xmath361}[q]$ ] denotes the @xmath362-th element of the array @xmath361}$ ] .",
    "it is easy to check that @xmath363=b[k , j]=1\\right\\ } , \\ ] ] i.e. , @xmath364 is precisely the set of non - zero entries of @xmath341 that we want to find .",
    "a crucial point here is that the function @xmath209 can be evaluated in @xmath365 time using the data structures @xmath344 , @xmath345 and @xmath353 . for any subset @xmath366 of @xmath367 , let @xmath368 be the function such that @xmath369 if and only if @xmath370 .",
    "the quantum procedure starts with @xmath366 being empty , performs successive quantum searches over @xmath371 , each time searching for an element @xmath259 such that @xmath369 and adding @xmath372 to @xmath366 as soon as such an @xmath259 is found , and stops when no new element @xmath259 is found . from the discussion of section [ prelim ] , with high probability",
    "all searches succeed , in which case at the end of the procedure @xmath373 .",
    "let @xmath374 denote the number of non - zero entries in @xmath341 and observe that @xmath375 , since @xmath376 .",
    "the overall complexity of this quantum procedure is @xmath377    the computation of @xmath378 is done as follows . for each @xmath379 ,",
    "let  @xmath380 denote the number of non - zero entries in the @xmath316-th column of @xmath381 .",
    "we first perform a @xmath162-time classical preprocessing step : for each @xmath20 , we construct the set @xmath382 of the row indexes of all non - zero entries in the @xmath316-th column of @xmath381 , and construct the set @xmath383 of the column indexes of all non - zero entries in the @xmath316-th row of @xmath17 .",
    "note that @xmath384 and @xmath385 .",
    "the quantum procedure computing @xmath378 uses a set @xmath386 , initially empty . for each @xmath20 ,",
    "all the @xmath387 such that @xmath388=b[k , j]=1 $ ] and @xmath389 are computed by performing a quantum enumeration , as above , over the set @xmath390 , adding @xmath233 to @xmath366 as soon as such a @xmath233 is found , and stopping when no new element @xmath233 is found .",
    "the overall time complexity is @xmath391 where @xmath392 is the number of elements found when processing @xmath316 .",
    "note that the inequality @xmath393 holds , since @xmath394 also represents the total number of witnesses of @xmath378 , i.e. , the number of triples @xmath395 such that @xmath388=b[k , j]=1 $ ] ( observe that there are at most @xmath58 pairs @xmath233 satisfying this condition , all such that @xmath396 ) . since @xmath397 ,",
    "this complexity is upper bounded by @xmath398    computing @xmath399 is done similarly to the computation of @xmath378 with cost @xmath400    we now compare the results of theorem [ prop ] to previous works . for the case",
    "@xmath401 , the bounds obtained in theorem [ prop ] are not better than the best known output - sensitive algorithms for boolean matrix multiplication @xcite .",
    "interestingly , we nevertheless recover the same complexity @xmath402 as in  @xcite for the region @xmath403 , but using different methods ( this is done by taking @xmath404 , which gives @xmath405 and reduces the computation of @xmath60 to the computation of only @xmath378 ) .",
    "consider now sparse input matrices and , for concreteness , focus on the case @xmath406 ( we denote this value simply by @xmath59 ) .",
    "the complexity of the algorithm by amossen and pagh @xcite , while not stated in this form , can be written as @xmath407 using the notations of theorem [ prop ] . in comparison ,",
    "theorem [ prop ] gives ( by choosing @xmath408 ) the upper bound @xmath409 we see that the second and third terms in our complexity are never worse .",
    "in order to evaluate quantitatively the speedup obtained in the quantum setting , let us consider the case when only the input matrices are sparse ( i.e. , @xmath410 ) .",
    "in this case , the algorithm by amossen and pagh has the same complexity as the algorithm by yuster and zwick @xcite described in the introduction . in comparison , theorem  [ prop ] gives the following result , which shows that our quantum algorithm is better than their classical algorithm , as discussed in the introduction .",
    "let @xmath16 and @xmath17 be two @xmath1 boolean matrices with at most @xmath187 and @xmath189 non - zero entries in @xmath16 and @xmath17 , respectively .",
    "there exists a quantum algorithm that computes , with high probability , the boolean matrix product @xmath60 and has time complexity @xmath411    first consider the case @xmath412 .",
    "assume for now that @xmath413 .",
    "we use the following strategy : we first use quantum enumeration to find all the non - zero entries of @xmath16 and , then , for each such entry @xmath21 $ ] , we output all the @xmath414 s such that @xmath352=1 $ ] .",
    "the complexity of this strategy is @xmath415 .",
    "the same argument gives the upper bound @xmath416 when @xmath417 .    if @xmath418 , then we use the quantum algorithm of theorem [ prop ] with parameters @xmath419 , @xmath420 , @xmath421 , and applying the algorithm for rectangular matrix multiplication over a field described in section [ prelim ] for the part @xmath422 .",
    "this gives overall complexity @xmath63 time .",
    "if @xmath423 , then we use the quantum algorithm of theorem  [ prop ] with parameters @xmath419 , @xmath421 and @xmath424 giving overall complexity @xmath425    finally , if @xmath426 , then we simply use the best existing classical algorithm for dense matrix multiplication .",
    "10    faster join - projects and sparse matrix multiplications . in _ proceedings of icdt _ ( 2009 ) , pp .  121126 .",
    "tight bounds on quantum searching . , 4 - 5 ( 1998 ) , 493505 .",
    "quantum verification of matrix products . in _ proceedings of soda _ ( 2006 ) , pp .",
    "880889 .    .",
    "springer , 1997 .    fast algorithms for ( max , min)-matrix multiplication and bottleneck shortest paths . in _ proceedings of soda _ ( 2009 ) , pp .  384391 .    . academic press , 1980",
    ".    a quantum algorithm for finding the minimum .",
    "arxiv : quant - ph/9607014 , 1996 .    a fast quantum mechanical algorithm for database search . in _ proceedings of stoc _",
    "( 1996 ) , pp .",
    "212219 .",
    "fast rectangular matrix multiplication and applications .",
    ", 2 ( 1998 ) , 257299 .    improving quantum query complexity of boolean matrix multiplication using graph collision . in _ proceedings of icalp ,",
    "( 2012 ) , pp .",
    "522532 .",
    "faster algorithms for rectangular matrix multiplication . in _ proceedings of focs _ ( 2012 ) , pp .  514523 .",
    "improved output - sensitive quantum algorithms for boolean matrix multiplication . in _ proceedings of soda _ ( 2012 ) , pp .",
    "14641476 .",
    "a time - efficient output - sensitive quantum algorithm for boolean matrix multiplication . in _ proceedings of isaac _ ( 2012 ) , pp .",
    "639648 .    a fast output - sensitive algorithm for boolean matrix multiplication .",
    ", 1 ( 2011 ) , 3650 .    quantum algorithms for the triangle problem . , 2 ( 2007 ) , 413424 .    computing dominances in @xmath427 . , 5 ( 1991 ) , 277278 .",
    "all - pairs bottleneck paths in vertex weighted graphs . in _ proceedings of soda _ ( 2007 ) , pp .",
    "978985 .    .",
    "phd thesis , university of edinburgh , 2010 .    .",
    "phd thesis , carnegie mellon university , 2008 .    finding a maximum weight triangle in @xmath428 time , with applications . in",
    "_ proceedings of stoc _",
    "( 2006 ) , pp .",
    "225231 .",
    "all pairs bottleneck paths and max - min matrix products in truly subcubic time .",
    ", 1 ( 2009 ) , 173189 .    multiplying matrices",
    "faster than coppersmith - winograd . in _ proceedings of stoc _ ( 2012 ) , pp .",
    "887898 .",
    "efficient algorithms on sets of permutations , dominance , and real - weighted apsp . in _",
    "proceedings of soda _",
    "( 2009 ) , pp .",
    "950957 .    fast sparse matrix multiplication . , 1 ( 2005 ) , 213",
    "in this appendix we give the proofs of lemma [ lemma_dom ] and proposition [ prop_densedom_cl ] .    in the proof we will use the notation @xmath429 to denote the number of finite entries in the @xmath316-th row of @xmath321 , for any @xmath306 matrix @xmath321 with entries in @xmath430 and any @xmath431 .",
    "for each @xmath148 , we do the following .",
    "consider the @xmath130 matrices @xmath432 .",
    "each matrix has size @xmath1 and we know that the total number of finite entries in these @xmath130 matrices is at most @xmath146 : @xmath433 we will construct @xmath130 matrices @xmath434 , each of size @xmath174 . each @xmath435 will contain all the finite entries in @xmath436 , but these @xmath130 matrices will satisfy the following sparsity condition on each column : @xmath437 these matrices are related to the concept of column balancing developed in @xcite .",
    "let us describe how to construct these matrices @xmath434 .",
    "for each @xmath20 , we first collect together all the finite entries in the @xmath316-th column of @xmath438 and sort them in increasing order .",
    "this gives , for each @xmath316 , a sorted list of at most @xmath439 numbers , with possible repetitions .",
    "we then divide this list into successive parts @xmath440 , for some @xmath441 , such that @xmath442 define @xmath443 and notice that @xmath444 : there are at most @xmath4 parts of size exactly @xmath445 due to equation ( [ proof_eq1 ] ) , and at most @xmath4 parts of size strictly less than @xmath445 ( these parts are among the @xmath4 parts with @xmath446 ) . to each pair",
    "@xmath447 with @xmath20 and @xmath448 , we assign an arbitrary index in @xmath449 , denoted @xmath450 , in a bijective way .",
    "finally , for each @xmath147 , we construct the @xmath174 matrix @xmath435 as follows : for all @xmath205 and all @xmath451 , @xmath452= \\left\\{\\begin{array}{ll } a^{(x)}_r[i , k]&\\textrm { if } k'\\in\\{1,\\ldots , p_r\\ } \\textrm { and   $ a^{(x)}_r[i , k]\\in t_{r , k}^{q}$ , where $ ( k , q)=\\rho_r^{-1}(k')$},\\\\ \\infty&\\textrm { otherwise . } \\end{array } \\right.\\ ] ] this means that each finite entry of @xmath436 appears in @xmath453 , in the same row but generally in a different column",
    ". by construction , equation ( [ proof_eq2 ] ) holds .",
    "the overall cost of this ( classical ) preprocessing step is @xmath454 time .",
    "since the complexity of the quantum procedure described in the last part of the proof will depend crucially on the way information about matrices @xmath453 and @xmath455 is stored , we introduce adequate data structures to record this information . for each @xmath147",
    ", we do the following .",
    "for all @xmath148 we list the finite entries in each column of @xmath453 , classically in time @xmath456 , and create a 3-dimensional array @xmath457 such that @xmath458 $ ] records the index of the row of the @xmath459-th finite entry in the @xmath460-th column of @xmath453 , for each @xmath148 , each @xmath451 , and each @xmath461 .    for each @xmath151 , we do the following .",
    "we construct , classically in time @xmath462 , a list containing all the finite entries of @xmath463 .",
    "let us denote the total number of these finite entries by @xmath464 , and remember that we have @xmath465 .",
    "we then create an array @xmath466 of size @xmath464 : for each @xmath467 , if the @xmath468-th element of the list is @xmath469 $ ] , then @xmath470 $ ] is set to the 3-tuple @xmath471 .",
    "the overall cost of this ( classical ) preprocessing step is @xmath168 time .      for each @xmath148 and each @xmath147",
    ", we construct an @xmath174 boolean matrix @xmath472 as follows : for all @xmath205 and all @xmath451 , @xmath473=1 \\textrm { iff } \\tilde a^{(x)}_r[i , k']\\neq \\infty .\\ ] ] for each @xmath148 and each @xmath151 , we construct an @xmath177 boolean matrix @xmath176 as follows : for all @xmath451 and all @xmath351 , @xmath474=1 \\textrm { iff } k'\\in\\{1,\\ldots , p_r\\ } \\textrm { and } b_r^{(y)}[k , j]\\ge \\max t_{r , k}^{q } , \\textrm { where } ( k , q)=\\rho_r^{-1}(k').\\ ] ] these are the matrices mentioned in the statement of the lemma .",
    "the overall cost of this ( classical ) construction step is @xmath168 time .      for each @xmath148 ,",
    "each @xmath147 and each @xmath151 , consider the boolean product @xmath475 .",
    "this product gives us some of the non - zero entries of @xmath476 , but not all .",
    "indeed , by definition , @xmath477=1 $ ] if and only if @xmath478\\in t_{r , k}^{q}$ ] , where @xmath479 . the indexes of the non - zero entries of @xmath475 are thus precisely all the @xmath31 for which there exists some @xmath20 satisfying @xmath480\\in t_{r , k}^{q } \\textrm { for some } q\\in\\{1,\\ldots , a_{r , k}\\ } \\textrm { and } b_r^{(y)}[k , j]\\ge \\max t_{r , k}^{q}.\\ ] ]    let us now consider the remaining non - zero entries of @xmath476 : the @xmath31 for which there exists some @xmath20 satisfying @xmath481\\in t_{r , k}^{q } \\textrm { for some } q\\in\\{1,\\ldots , a_{r , k}\\ } \\textrm { and } a_r^{(x)}[i , k]\\le b_r^{(y)}[k , j ] < \\max t_{r , k}^{q}.\\ ] ] define the @xmath1 matrix @xmath178 with entries in @xmath482 as follows .",
    "for any @xmath31 , the entry @xmath483 $ ] is the largest element @xmath484 such that equation ( [ eq_cond ] ) holds for some @xmath148 and some @xmath20 , if at least one such @xmath485 exists , and @xmath483=(0,0)$ ] otherwise .",
    "we finally show how to compute the matrix @xmath178 .",
    "the idea is to find , for all @xmath484 in decreasing order , all the pairs of indexes @xmath31 such that equation ( [ eq_cond ] ) holds for some @xmath148 and some @xmath20 , and strike out those pairs as soon as they are found .",
    "the procedure for computing @xmath178 is described in figure [ fig : alg ] .",
    "the set @xmath27 , initially empty , records all pairs @xmath233 for which @xmath483 $ ] has already been computed . during the loop of steps 8 - 13 the procedure enumerates all the @xmath486 such that equation ( [ eq_cond ] ) holds for some @xmath148 and some @xmath20 .",
    "note that only the non-(@xmath190 ) entries of @xmath455 need to be considered and , from equation ( [ eq_cond ] ) , for each such non-(@xmath190 ) entry @xmath487 $ ] only the non-(@xmath188 ) entries @xmath488 $ ] of @xmath436 such that @xmath489\\in t_{r , k}^{q^{(y)}_{rkj}}\\ ] ] need to be considered , where @xmath490 is the smallest integer in @xmath491 such that @xmath492",
    "< \\max t_{r , k}^{q^{(y)}_{rkj}}.\\ ] ] by construction , these non-(@xmath188 ) entries of @xmath436 are in the @xmath493-th column of @xmath435 .",
    "the loop of steps 8 - 13 thus performs successive quantum searches over the set @xmath494\\neq -\\infty \\:\\textrm { and } \\ : \\tilde a_r^{(x)}[i,\\rho_r(k , q^{(y)}_{rkj})]\\neq \\infty \\right\\},\\ ] ] looking for elements @xmath495 such that @xmath496\\le b_r^{(y)}[k , j].\\ ] ]    the procedure of figure [ fig : alg ] correctly computes the matrix @xmath178 whenever the quantum enumeration does not err , that is , with probability at least @xmath497 if safe grover search is used , as discussed in section [ prelim ] .",
    "let us consider its time complexity .",
    "the cost of step 2 is @xmath63 , and the cost of the loop of steps 3 - 5 is @xmath498 since each @xmath490 can be found in @xmath365 time using binary search .    in order to evaluate the cost of the loop of steps 8 - 13",
    ", we need to discuss in more details how to perform the quantum search over the set @xmath499 since subtle issues arise when considering how to access time - efficiently the relevant entries of the matrices and how to check if an element is a solution in @xmath500 time .",
    "note that @xmath501\\neq -\\infty\\end{subarray } } { \\mathrm{col}(\\tilde a_r^{(x)},\\rho_r(k , q_{rkj}^{(y)}))}.\\ ] ] we define a bijection @xmath209 from the set @xmath502 to the set @xmath499 as follows .",
    "remember that the data structures @xmath457 and @xmath466 are available , recording information about the @xmath453 s and the @xmath455 s , respectively . for notational convenience for each @xmath503 with corresponding value @xmath470=(r , k , j)$ ] , we will write @xmath504=r$ ] , @xmath505=k$ ] , @xmath506=j$ ] and @xmath507=\\rho_r(k , q_{rkj}^{(y)})$ ] . note that these four values can be immediately obtained from @xmath470 $ ] .",
    "we define the function @xmath209 as follows : for all @xmath467 and all @xmath508}^{(x)},{\\mathsf{w}}[a])}\\}$ ] , @xmath509}^{(x)},{\\mathsf{w}}[c ] ) } \\right)=({\\mathsf{v_1}}[a],{\\mathsf{u}}^{(x)}\\big[{\\mathsf{v_1}}[a],{\\mathsf{w}}[a],b\\big],{\\mathsf{v_3}}[a],{\\mathsf{v_2}}[a]).\\ ] ] it is easy to check that @xmath209 is a bijection from @xmath502 to @xmath499 .",
    "the crucial point here is that the function @xmath209 can be evaluated in @xmath365 time since @xmath457 and @xmath466 are available ( in particular , given any @xmath510 one can find the values @xmath468 and @xmath459 such that @xmath511}^{(x)},{\\mathsf{w}}[c])}$ ] efficiently , using binary search for instance ) .",
    "we can then implement step 9 by performing quantum searches over the set @xmath502 . from the discussion in section [ prelim ] , the time complexity of the loop of steps 8 - 13 , for fixed @xmath485 ,",
    "is thus @xmath512\\neq -\\infty\\end{subarray } } { \\mathrm{col}(\\tilde a_r^{(x)},\\rho_r(k , q_{rkj}^{(y)}))}\\right)\\times ( \\lambda^{(x , y)}+1)}\\right),\\ ] ] where @xmath513 denotes the number of elements found during the execution of the loop ( i.e. , the number of new entries of @xmath178 computed ) .",
    "the total cost of the procedure of figure [ fig : alg ] is then @xmath514\\neq -\\infty\\end{subarray } } { \\mathrm{col}(\\tilde a_r^{(x)},\\rho_r(k , q_{rkj}^{(y)}))}\\right)\\times ( \\lambda^{(x , y)}+1)}\\right)\\ ] ] using equation ( [ proof_eq2 ] ) , the inequality @xmath515 , and the cauchy - schwarz inequality , we can rewrite this expression as @xmath516\\neq -\\infty\\end{subarray } } \\frac{m_1}{nt}\\right)\\times ( u+\\sum_{x=1}^u\\lambda^{(x , y)})}\\right ) & = \\tilde o\\left(n^2tv+ \\sqrt { \\frac{m_1m_2}{nt}\\times ( uv+\\sum_{x=1}^u\\sum_{y=1}^v\\lambda^{(x , y ) } ) } \\right)\\\\ & = \\tilde o\\left(n^2tv+\\sqrt{\\frac{m_1m_2n}{t}}+\\sqrt{\\frac{m_1m_2uv}{tn}}\\right).\\end{aligned}\\ ] ] this concludes the description of how to construct the matrix @xmath178 .",
    "the algorithm is essentially the same as in the proof of proposition [ prop_densedom ] .",
    "the only change is that a classical algorithm , which we describe below , is used instead of the quantum algorithm in lemma [ lemma_dom ] . in the proof of lemma [ lemma_dom ] we use classical enumeration ( i.e. , exhaustive search ) instead of quantum enumeration in the procedure of figure  [ fig : alg ] .",
    "the complexity of the loop of steps 8 - 13 of the procedure of figure [ fig : alg ] is thus @xmath518 , and the total complexity of the procedure becomes @xmath519\\neq -\\infty\\end{subarray } } { \\mathrm{col}(\\tilde a_r^{(x)},\\rho_r(k , q_{rkj}^{(y)}))}\\right ) & = \\tilde o\\left(n^2tv+\\frac{m_1m_2}{tn}\\right).\\end{aligned}\\ ] ] the overall complexity of the classical version of lemma [ lemma_dom ] is thus @xmath520 which gives the upper bound claimed ."
  ],
  "abstract_text": [
    "<S> in this paper we construct quantum algorithms for matrix products over several algebraic structures called semirings , including the @xmath0-matrix product , the distance matrix product and the boolean matrix product . </S>",
    "<S> in particular , we obtain the following results .    </S>",
    "<S> * we construct a quantum algorithm computing the product of two @xmath1 matrices over the @xmath0 semiring with time complexity @xmath2 . in comparison , the best known classical algorithm for the same problem , by duan and pettie ( soda09 ) , has complexity @xmath3 . as an application </S>",
    "<S> , we obtain a @xmath2-time quantum algorithm for computing the all - pairs bottleneck paths of a graph with  @xmath4 vertices , while classically the best upper bound for this task is @xmath3 , again by duan and pettie . * </S>",
    "<S> we construct a quantum algorithm computing the @xmath5 most significant bits of each entry of the distance product of two @xmath1 matrices in time @xmath6 . in comparison , </S>",
    "<S> prior to the present work , the best known classical algorithm for the same problem , by vassilevska and williams ( stoc06 ) and yuster ( soda09 ) , had complexity @xmath7 . </S>",
    "<S> our techniques lead to further improvements for classical algorithms as well , reducing the classical complexity to @xmath8 , which gives a sublinear dependency on @xmath9 .    </S>",
    "<S> the above two algorithms are the first quantum algorithms that perform better than the @xmath10-time straightforward quantum algorithm based on quantum search for matrix multiplication over these semirings . </S>",
    "<S> we also consider the boolean semiring , and construct a quantum algorithm computing the product of two @xmath1 boolean matrices that outperforms the best known classical algorithms for sparse matrices . </S>",
    "<S> for instance , if the input matrices have @xmath11 non - zero entries , then our algorithm has time complexity @xmath12 , while the best classical algorithm has complexity @xmath13 , where @xmath14 is the exponent of matrix multiplication over a field ( the best known upper bound on @xmath14 is @xmath15 ) . </S>"
  ]
}