{
  "article_text": [
    "r.5    the most basic problem in vlsi and printed circuit board design is to connect two given points , @xmath0 and @xmath1 , by a shortest `` thick '' path avoiding a set of polygonal obstacles in the plane .",
    "the quarter - of - a - century - old approach to the problem is to inflate the obstacles by half the path width , and search for the shortest @xmath2 path amidst the inflated obstacles @xcite .",
    "the found path , when inflated , is the shortest thick @xmath2 path .",
    "it went almost unnoticed that the thick path built by the above procedure may self - overlap ( fig .  [ self ] ) : apart from our recent work on thick paths @xcite , we only found one mention of the possibility of the overlap  fig .  4 in @xcite .",
    "( in a different context , bereg and kirkpatrick ( * ? ? ?",
    "2 ) also noted that minkowski sum of a disk and a path may be not simply - connected . )",
    "when the path represents a thick wire connecting terminals on a vlsi chip or on a circuit board , self - overlap is undesirable as the wire must retain its width throughout .",
    "thus , the objective in the basic wire routing problem should be to find the shortest non - selfoverlapping thick path .",
    "the problem shows up in other places as well .",
    "for instance , one may be interested in the optimal conveyor belt design : the belt is a non - selfoverlapping thick path .",
    "our particular motivation comes from air traffic management where thick paths represent lanes for air traffic .",
    "lane thickness equals to the minimum lateral separation standard , so that aircraft following different lanes stay sufficiently far apart to allow for errors in positioning and navigation .",
    "if an airlane self - overlaps , two aircraft following the lane may come too close to each other ; thus it is desirable to find lanes without self - overlaps .",
    "we prove a surprisingly strong * _ negative result _ * ( section  [ hard ] ) : it is np - hard even to decide whether there exists ( possibly , arbitrarily long ) @xmath2 wire ; this implies that no approximation to the shortest wire can be found in polynomial time ( unless p = np ) .",
    "[ [ short - snakes ] ] short snakes + + + + + + + + + + + +    our intractability result means that in general it is np - hard for a snake to wriggle its way amidst polygonal obstacles ( assuming the snake is uncomfortable with squeezing itself ) .",
    "the good news for snakes is that in our hardness proof the sought wire is considerably long ; i.e. , the hardness of path finding applies only to long snakes .",
    "our * _ positive result _ * ( section  [ short ] ) is that for a bounded - length snake , the shortest path can be found in polynomial time ( assuming real ram and the ability to solve constant - size differential equations in constant time ) by a dijkstra - like traversal of the domain .      in vlsi numerous extensions and generalizations of the basic problem were considered .",
    "these include routing multiple paths , on several levels , and with different constraints and objectives .",
    "it is impossible to survey all literature on the subject ; we will only mention the books @xcite .    in robotics thick paths",
    "were studied as routes for a circular robot . in this",
    "context , path self - overlap poses no problem as even a self - overlapping path may be traversed by the robot ; that is , in contrast to vlsi , robotics research should not care about finding non - selfoverlapping paths . in @xcite",
    ", chew gave an efficient algorithm for finding a shortest thick path in a polygonal domain . in a sense , our algorithm for shortest path for a short snake ( section  [ short ] ) may be viewed as an extension of chew s .",
    "motion planning for an object with few degrees of freedom may be approached with the cell decomposition techniques @xcite .",
    "closest to our bounded - length snake problem is the work on path planning for a segment ( rod ) @xcite .",
    "short snakes are also relevant to more recent applications of motor protein motion @xcite .",
    "in this section we introduce the notation and formulate our problem .",
    "let @xmath3 be an @xmath4-vertex polygonal domain with obstacles .",
    "for a planar set @xmath5 let @xmath6 denote the boundary of @xmath5 , and for @xmath7 let @xmath8 denote the minkowski sum of @xmath9 with the radius-@xmath10 open disk centered at the origin .",
    "let @xmath11 be @xmath3 offset by @xmath10 inside .",
    "the boundary of [r ] consists of straight - line segments and arcs of circles of radius @xmath10 centered on vertices of @xmath3 .",
    "we call such ( maximal ) arcs @xmath10-slides .",
    "let @xmath12 be a path within  ; let @xmath13 denote its length .",
    "a _ thick path _",
    "@xmath14 is the minkowski sum @xmath15 .",
    "the path @xmath12 is called the reference path of @xmath14 ; the _ length _ of @xmath14 is @xmath13 .",
    "a snake is a non - selfoverlapping thick path , i.e. , a path which is a simply - connected region of the plane .",
    "the reference path of the snake is its spine ( fig .",
    "[ anatomy ] ) .",
    "one of the endpoints of the spine is the snake s mouth @xmath16 .",
    "the snake is a `` rope '' that `` pulls itself by the head '' : imagine that there are little legs ( or a wheel , for a toy snake ) located at @xmath16 , by means of which the snake moves .",
    "the friction between the snake s body and the ground is high : any point @xmath17 of the spine will move only when the path from the mouth to @xmath17 is a  pulled - taut string  , i.e. , is a locally shortest path . that is , the snake always stays pulled taut against the obstacles ( or itself ) .",
    "does not have a point connected to @xmath18 with a length-2 segment fully lying within the snake . ]    the input to our problem is the domain @xmath3 , two points @xmath19  the `` start '' and the `` food '' , a number @xmath20  the length of the snake , and the initial direction of the snake at @xmath0 .",
    "( assume w.l.o.g .  that @xmath0 and @xmath21 are at distance 1 from some vertex of @xmath3 . ) .",
    "the goal is to find a path for the snake such that the snake s mouth starts at @xmath0 and ends at @xmath21 ; the constraints are that the snake remains pulled taut and non - selfoverlapping throughout the motion .",
    "the objective is to minimize the distance traveled by the mouth , or equivalently , assuming constant speed of motion , the time until the snake reaches the food .    to simplify the formulation",
    ", we did not specify the initial configuration of the snake ; a pedantic view could be to assume that the snake slithers in from a riemann sheet glued along the diameter of @xmath22 that is perpendicular to the initial direction of the snake s motion .",
    "our results , both positive and negative , remain valid even if the initial configuration of the snake is part of the input .",
    "it is not true that all points of the spine necessarily follow the same path .",
    "whoever guesses that the above model of a snake was developed just for fun , is right .",
    "nevertheless , the proposed problem formulation may be relevant also in more serious circumstances .",
    "it models , e.g. , the path of a rope being pulled by its frontpoint through a polygonal domain . if it is a fire hose or a tube delivering life - saving medicine @xcite , minimizing the time to reach a certain point seems like a natural objective ( more important than , say , the work spent on pulling the tube ) . for another application ,",
    "consider a chain of robots moving amidst obstacles .",
    "each robot , except for the leader of the chain , has very simple program of following its predecessor  just keeping the distance to it .",
    "then the robots form ( approximately ) a pulled taut thick string .",
    "it is possible to come up with problem instances in which no path for a pulled - taut snake exists , while a path for a snake that is not required to be taut , does .",
    "when the snake is relaxed and its spine is a straight - line segment , the snake is the minkowski sum of the length - segment and the unit disk .",
    "such sums are known as hippodromes @xcite , or hippos for short .",
    "we say that a hippo is fat if its length is constant : @xmath23 . in this section",
    "we show that for a fat hippo our problem can be solved in polynomial time .",
    "our algorithm is a dijkstra - style search in an implicitly defined graph @xmath24(fig .",
    "[ overview ] ) : neither the nodes nor the edges of the graph are known in advance . instead , @xmath24is built incrementally , by propagating the labels from the node @xmath25 with the smallest temporary label ( as in standard dijkstra ) .",
    "the labels are propagated to nodes in the   - visibility `` region of @xmath25 , which is what the snake ' ' sees  while it slithers for distance starting from @xmath25 . in order to discover the nodes in the region",
    ", we pull the snake from @xmath25 for length along every possible combinatorial type of path ; by a packing argument , there is only a small number of the types .",
    "the edges of @xmath24correspond to bitangents between the paths and 1-slides .",
    "we prove that the algorithm is polynomial - time by observing that the snake must travel for at least @xmath26 before it `` touches '' itself with its head ; this implies that the snake never `` covers '' any point of @xmath27 with more than @xmath28 `` layers '' , and hence there is a polynomial number of relevant bitangents .",
    "is a node of @xmath24 ; pull the snake from @xmath25 for distance along `` every possible '' path .",
    "endpoints of visibility edges ( some of them are shown with solid circles ) become nodes of @xmath24 . ]    in the reminder of the section we elaborate on the algorithm s details .",
    "consider the unit disk @xmath29 .",
    "the part of the boundary of @xmath29 that is also the boundary of the snake is the unit semicircle whose diameter is perpendicular to the spine at @xmath16 ; we call the part the head and the diameter the headcut .",
    "the endpoint of the spine that is not the mouth is called the antimouth @xmath30 .",
    "the part of the boundary of @xmath31 that is also the boundary of the snake is called the tail .",
    "refer to fig .",
    "[ anatomy ] .",
    "let us have a closer look at the structure of the pulled - taut snake at any moment of time .",
    "some pieces of the spine are straight - line segments",
    ". the segments are bitangents between the other , non - segment pieces supported by vertices of @xmath3 , possibly via several `` layers '' of the snake .",
    "we call each such ( maximal ) piece @xmath32 a bend ; we denote the vertex that supports @xmath32 by @xmath33 , and say that @xmath25 is responsible for  @xmath32 .",
    "[ [ snake - layers ] ] snake layers + + + + + + + + + + + +    we show that each vertex @xmath25 is responsible for @xmath34 bends .",
    "say that a bend @xmath32 belongs to layer 1 if there exists a point @xmath35 such that @xmath36 .",
    "recursively , @xmath32 is layer-@xmath37 bend if it is not layer-@xmath38 and there exists a point @xmath35 such that for some point @xmath39 at layer @xmath38 , we have @xmath40 and @xmath41 fully lies within the ( closure of the ) snake ( fig .  [ anatomy ] ) .",
    "let @xmath42 be the maximum index of a layer .",
    "[ dubins ] @xmath43 .",
    "let @xmath44 be points on layers @xmath45 such that @xmath46 .",
    "let @xmath47 be the part of the spine between @xmath48 and @xmath49 .",
    "the minkowski sum @xmath50 encloses at least one obstacle , @xmath51 ( or else the snake is not pulled taut ) .",
    "the perimeter of the inflated obstacle @xmath52 is at least @xmath53 , thus @xmath54 .",
    "but @xmath55 , hence @xmath56 .",
    "as a corollary from the lemma , we have that life is very simple for a fat enough hippo :    for @xmath57 , an @xmath58-fat hippo can follow a shortest thick path without self - overlap .    [ [ tailed - and - headed - bends ] ] tailed and headed bends + + + + + + + + + + + + + + + + + + + + + + +    one may wonder why we did not opt for a simpler definition of layer-@xmath38 bend @xmath32 as one having a point @xmath59 such that @xmath60 and @xmath61 lies fully within the ( closure of the ) snake .",
    "the reason are two special kinds of bends which make the snake s portrait more complicated than in the case of an infinite - length snake . specifically , we say that a bend @xmath32 at layer @xmath38 is tailed ( resp .",
    "headed ) if @xmath62 touches the tail ( resp .",
    "the simpler definition may not work for such bends ( fig .",
    "[ anatomy ] ) .",
    "any bend that is not tailed or headed is an arc of a circle ( actually , it is part of a slide ) .",
    "a tailed or headed bend @xmath32 is a different shape  string pulled taut against a ball touching @xmath33 .",
    "[ [ snake - configuration ] ] snake configuration + + + + + + + + + + + + + + + + + + +    the snake can be reconstructed in linear time as soon as the following is specified : ( 1 )  list of the vertices responsible for the bends ; ( 2 )  for each bend , its layer ; ( 3 )  for a headed bend ",
    "the vertex or the edge of @xmath3 in contact with the head , and the slope of the headcut ; ( 4 )  similar information for a tailed bend ; ( 5 )  positions of the mouth @xmath16 and antimouth  @xmath30 . we will call ( 1)(5 ) the configuration of the snake .",
    "[ complexity ] the list ( 1 ) contains @xmath63 vertices .",
    "each vertex may be responsible for up to @xmath42 bends , hence the total number of bends is @xmath64 .",
    "( in fact , since the part of the snake between consecutive bends leaning on one vertex , encloses at least one obstacle , every bend can be charged either to a vertex or to an obstacle ; thus the number of bends is actually @xmath65 , where @xmath51 is the number of obstacles . )",
    "suppose that we are given the configuration @xmath66 of the snake at some time ; let @xmath12 be the spine when the snake is in @xmath66 and let @xmath67be the position of the mouth in @xmath66 .",
    "suppose we are also given a path @xmath68 for the mouth starting at @xmath67 .",
    "assume @xmath68 has the following properties : ( 1 ) it is consistent with @xmath66 in that the tangent to @xmath68 at @xmath67coincides with the tangent to @xmath12 at @xmath67 ; ( 2 )  it has a polynomial number of pieces , each of constant description complexity ; ( 3 ) @xmath69 .",
    "in what follows we assume that every path @xmath68 has these properties .",
    "we claim that in polynomial time we can check whether @xmath68 is a feasible path for the mouth , i.e. , whether the snake stays obstacle - free when @xmath16 is pulled along @xmath68 ( say , at unit speed ) .",
    "first we note that it is enough to check only whether the mouth moves feasibly . indeed",
    ", the first time that the snake ( possibly ) becomes infeasible as @xmath16 follows @xmath68 , the mouth is necessarily a part of `` certificate of infeasibility '' .",
    "this is so because the only way that the snake experiences `` side pressure '' is due to appearance of a headed bend .",
    "other than that , any piece @xmath70 of the snake is merely pulled by the preceding piece , @xmath71 : either @xmath70 exactly follows the same path that just was feasible for @xmath71 , or @xmath70 is a tailed bend @xmath32 . of course",
    ", the bend morphs as the time passes , but only becomes `` more feasible '' with time , i.e. , the free space around @xmath32 increases ",
    "@xmath32 is pushed only by the tail , and the tail `` moves away '' with time .",
    "let now @xmath72 be a piece of @xmath68 .",
    "if we know how each piece @xmath70 of the snake changes with time , we can test whether @xmath16 stays feasible while following @xmath72 , by checking the feasibility against each @xmath70 in turn .",
    "that is , while neither the configuration of the snake nor the piece @xmath72 of @xmath68 changes , the feasibility test can be done piece - versus - piece in constant time ( assuming real ram ) .",
    "observe that overall there is only a polynomial number of configuration changes . indeed",
    ", the configuration may change only due to one of the following events : ( 1 )  the tail starts to follow another feature of @xmath3 , ( 2 )  a headed bend appears or changes its combinatorial structure , ( 3 )  a tailed bend disappears or changes its combinatorial structure .",
    "but each of the events ( 1)(3 ) may happen only once per vertex - bend - layer triple ; thus , by lemmas  [ dubins ] and  [ complexity ] there is only a polynomial number of events .",
    "tracking the configuration changes is easy given the way each piece changes with time . for event ( 1 )",
    ", we only have to know how the tail speed changes with the time between consecutive events ( the tail speed is not necessarily constant , we elaborate on it in the next paragraphs ) . for event",
    "( 2 ) we check what is the first time that the head collides with a piece or when a headed bend hits a vertex ; all this can be done in polynomial time as there is only a linear number of candidate collisions .",
    "event ( 3 ) is similar .",
    "the next event time is then the minimum of the event times over all the pieces .",
    "it remains to show how to determine the way each piece changes . here",
    "the crucial role is played by the headed and tailed bends ; again , it is the finiteness of the snake length that makes things involved .",
    "let @xmath73 be the first such bend counting from @xmath16 ( fig .",
    "[ anatomy ] ) .",
    "assume that @xmath74 is a layer-@xmath38 tailed bend ; the situation with a headed bend is actually simpler ( because the mouth speed is constant ) .",
    "let @xmath75 and @xmath76 be the pieces adjacent to @xmath74  both are bitangents ( straight - line segments , possibly of 0 length ) to @xmath74 and adjacent bends .",
    "every point of the spine between @xmath16 and @xmath77 moves at speed 1 , and none of the bends before @xmath74 changes with time .    to figure out what happens after @xmath77",
    ", we have to solve a constant - size differential equation that describes the  propagation  of speed of motion of the spine .",
    "specifically , let @xmath78 denote the speed at which the antimouth moves at time @xmath79 .",
    "knowing @xmath78 and knowing the initial position of the antimouth , we can write the antimouth position as a function of time , and hence we know @xmath80 as a function of time . the points @xmath81 and @xmath82 are points of tangency to @xmath80 from @xmath77 and @xmath83 ; thus knowing @xmath80 we know how the length @xmath84 changes with time . knowing that , and recalling that at @xmath77 the spine moves with unit speed , we can write what the spine speed at @xmath83 is as a function of @xmath79 .",
    "now , the spine speed does not change between @xmath83 and the next point , @xmath85 , that is the start of the tangent to the next headed or tailed bend , @xmath86 .",
    "we perform at @xmath86 the same operations as above , and get the speed of motion of the spine past the bend @xmath86 . continuing in this fashion , in the end ,",
    "after going through all bends , we obtain some expression , @xmath87 for the spine speed after the last bend .    finally , to close the loop , we solve the equation @xmath88 since there is only a constant number of layers ( lemma  [ dubins ] ) , there is only a constant number of the headed and tailed bends , and hence the expression @xmath89 is a sum of a constant number of terms ( each containing @xmath78 and @xmath90 ) , each of constant description complexity . in our computation model , we can solve the equation for @xmath78 in constant time .",
    "substituting @xmath78 back into the formulae for the different bends , we obtain the spine as a function of time , as desired .",
    "assume that at some point the snake is in configuration @xmath66 .",
    "what happens next , as the snake follows the optimal path to @xmath21 ?",
    "local optimality conditions imply that it will `` wiggle around the obstacles '' for some time and then `` shoot '' towards a vertex of @xmath3 .",
    "we formalize this below .",
    "[ [ final - piece - of - anatomy ] ] final piece of anatomy + + + + + + + + + + + + + + + + + + + + + +    the eye of the snake is collocated with the mouth .",
    "the snake can see a point @xmath91 if the segment @xmath92 lies fully within @xmath93 and is tangent to the spine at  @xmath16 .",
    "recall that @xmath94 where @xmath95 is the minkowski sum of @xmath27 with open unit disk ; hence @xmath92 can go along the boundary of @xmath93 ( with @xmath96 being , e.g. , an endpoint of a slide ; see fig .",
    "[ overview ] ) .",
    "the snake itself is transparent for its eye : we do not forbid @xmath92 to intersect the snake .",
    "[ def ] a point @xmath17 on @xmath97 is @xmath98-visible from @xmath67if there exists a path @xmath68 for the mouth ending in a point @xmath99 such that @xmath99 sees @xmath17 and @xmath100 is tangent to @xmath97 at @xmath17 .",
    "we say that @xmath101 is an @xmath98-visibility edge , or an @xmath98-edge for short .",
    "we say that @xmath68 is the wiggle segment of @xmath101 , and that @xmath100 is the visibility segment of the edge .",
    "( we remind that we assume @xmath68 enjoys the properties listed in the beginning of section  [ freeze ] : tangent at @xmath67consistent with @xmath66 , polynomial - size description , length @xmath102 . )    to be on a ( locally ) optimal path , the mouth would like to follow an  - edge also past @xmath99 .",
    "this may not be feasible due to a conflict with the snake itself .",
    "however , such conflicts can be discovered `` on - the - fly '' , as the mouth attempts to move along @xmath100 .",
    "specifically , try to move the mouth along @xmath100 , as described in section  [ move ] .",
    "if during the motion , the head collides with the snake , note what kind of bend the head collides with . if this bend @xmath32 is not tailed , adjust the path for the mouth so that it is tangent to @xmath103 , and follow the adjusted path .",
    "if by the time the mouth reaches @xmath103 , the bend @xmath32 is `` gone '' , i.e. , the head `` misses '' the snake , we know that we are dealing with a tailed bend ( or with the tail itself ) . we identify the time and place of contact with the bend by solving a differential equation similar to ( [ diff ] ) : assuming the speed of the tail is @xmath78 , we know how the bitangent between @xmath16 and the corresponding ball centered at @xmath30 changes ; in particular , we know its length @xmath104 as a function of time . the time @xmath105",
    "when the head hits the tail is then the solution to the equation @xmath106 . after solving the equation we know the configuration of the snake at @xmath105 , and",
    "continue moving the mouth to @xmath17 around the tail .",
    "the above procedure essentially `` develops '' the path @xmath68 piece - by - piece .",
    "this is consistent with section  [ move ] where we described how to pull the snake along a given path @xmath68 for the mouth : the pulling was done piece - by - piece , which means that it can be performed even if @xmath68 is not given in advance but instead is revealed piece after piece . more importantly , using the procedure , we can develop all  - edges incident to @xmath67 , piece - by - piece , in a bfs manner .",
    "we describe this below .    to initiate the developing , look at the visibility segment @xmath107 of the  - edge that has led the mouth to @xmath67 .",
    "the segment is tangent to a slide @xmath108 .",
    "the slide @xmath109 down from @xmath67(i.e .",
    ", in the direction consistent with @xmath107 ) is the first ( potential ) piece of a new  - edge .",
    "we extend bitangents from the piece to all other 1-slides and to all pieces of the spine inflated by 2 .",
    "these bitangents become the next potential pieces for the  - edges . after the bitangents , the next potential pieces are the slides and the spine pieces at which the bitangents end .",
    "we continue in this way ( possibly adjusting the pieces of a particular edge to account for snake self - interaction ) until for each edge its wiggle segment reaches length  .",
    "we now bound the time spent on developing all  - edges from @xmath67 .",
    "each edge has linear complexity ; this can be proved identically to lemma  [ complexity ] . thus all edges can be grown in polynomial time if the number of edges is polynomial .",
    "this is what we prove next :    [ ledges ] let @xmath110 be the set of all  - edges incident to @xmath67 .",
    "@xmath111 .    by definition ,",
    "every edge starts from a path @xmath68 for the mouth of length at most  .",
    "say that paths @xmath112 are the same combinatorial type if the sequence of vertices visited by @xmath113 is a subsequence of that for @xmath114 ( or vice versa ) .",
    "being of the same type is an equivalence relation that splits @xmath110 into classes .",
    "for each class , keep only the path with the longest sequence of visited vertices , and identify the class with the path .",
    "let @xmath115 be the obtained collection of classes .",
    "let @xmath116 .",
    "any  - edge that has a path @xmath117 as its wiggle segment is obtained by extending a bitangent from @xmath68 ( or equivalently from @xmath118 ) to some slide .",
    "thus the total number of  - edges having a path in @xmath118 as the wiggle segment is at most the number of bitangents from @xmath118 to the slides , which is @xmath119 since @xmath118 is @xmath63-complexity .    it remains to show that @xmath120 .",
    "a standard argument shows that @xmath121 depends only on the number of the holes in @xmath93 reachable by length - paths from @xmath67(not on the number of vertices ) : restrict attention to radius - disk @xmath122 centered on @xmath67 , do vertical trapezoidation of @xmath123 , and let @xmath124 be the dual graph of the trapezoidation .",
    "the number of nodes of @xmath124 of degree higher than 2 is linear in the number of holes ( in @xmath93 ) that intersect @xmath122 ; call this number @xmath125 . transform @xmath124 to a graph @xmath126 by replacing each path in @xmath124 by an edge between degree-3 and higher nodes ; the number of nodes in @xmath126 is @xmath127 .",
    "each path from @xmath115 is a walk in @xmath126 that visits every edge of @xmath126 at most @xmath128 times .",
    "the number of such walks @xmath126 depends only @xmath125 , and we prove now that @xmath125 is constant :    [ h ] let @xmath129 be the holes ( of @xmath3 ) that intersect @xmath122 .",
    "the minkowski sum @xmath130 has a constant number of connected components .",
    "if @xmath131 are in different connected components of the sum , the distance between the holes is at least 2 . within constant distance of @xmath67",
    ", there can be only a constant number of points pairwise - separated by distance at least 2 ; thus there is only a constant - size set of holes pairwise in different connected components .",
    "this competes the proof of the lemma .",
    "we are ready now to traverse the ``  - visibility '' graph @xmath24of @xmath3 , searching only the relevant part of @xmath24and not building the whole graph explicitly .",
    "the label of each node in @xmath24consists of two parts : the distance label ( storing the distance from @xmath0 ) and the configuration label ( storing the snake configuration at which the node was reached ) .",
    "that is , a node may have several labels  one per configuration .",
    "however , since there is only a constant number of different configurations of pulled - taut snakes that may reach the node ( lemma  [ ledges ] and claim  [ h ] ) , the total number of labels of any node is constant .",
    "start from @xmath132 , and assign distance label 0 to @xmath0 .",
    "the algorithm grows the graph @xmath24whose edges are the discovered  - edges and whose nodes are the endpoints of the  - edges .",
    "note that by the definition of  - visibility ( definition  [ def ] ) , all nodes of @xmath24reside on slides .",
    "at a generic step , take the node with the smallest ( temporary ) distance label , make the label permanent , and construct  - edges from the node .",
    "the endpoints of the edges join @xmath24and get their ( temporary ) distance labels and configuration labels .",
    "in addition , each already existing node over which the mouth passes , gets its distance label updated if the distance label carried with the mouth is smaller than the node s current label and the configuration label carried with the mouth is the same as the node s configuration label .",
    "the search stops when @xmath21 is reached .",
    "we now prove that the algorithm terminates in a polynomial number of steps .",
    "the visibility segments are bitangents between 1-slides and pieces of the wiggle segments .",
    "these latter pieces are of two types : ( 1 )  slides up to layer @xmath42 and ( 2 )  curves that are obtained as the head rolls over the tail , possibly padded by up to @xmath42 layers of the snake .",
    "there is in principle an uncountable number of possible pieces of the second type .",
    "nevertheless , every step of the algorithm discovers at least one new visibility segment tangent to a piece of the first type . since the number of slides up to layer @xmath42 is @xmath63 , there are @xmath119 of such visibility segments .",
    "each such segment may be discovered only a constant number of times  once per homotopy type of the snake reaching the endpoint of the segment .",
    "thus overall there are @xmath119 steps .",
    "overall , we have our main positive result :    shortest path for a fat hippo can be computed in polynomial time .",
    "in this section we prove that if the snake length is not bounded , deciding existence of a path for the snake is np - hard .",
    "specifically , our problem is : given polygonal domain @xmath3 and points @xmath133 , find a thick non - selfoverlapping @xmath134 path ( i.e. , a thick @xmath134 wire ) .",
    "we show the problem s hardness by a reduction from planar 3sat .",
    "recall that the graph of a 3sat instance has nodes for all variables and clauses , and two types of edges : ( 1 )  a cycle @xmath135 through all variables , and ( 2 )  edges connecting every clause to its three variables ( fig .",
    "planar 3sat is a restriction of 3sat to instances whose graph is planar ; lichtenstein @xcite proved that planar 3sat is np - hard . to show the hardness of wire routing , we start from an instance @xmath136 of planar 3sat",
    "; we identify the instance with its ( planar ) graph , and the variables and clauses with the points in the plane into which they are embedded .     of 3sat .",
    "the variables are shaded circles , the clauses are hollow circles . ]",
    "augmented with parent - child edges , sibling edges , and with variable - clause edges duplicated . ]    , @xmath137 ; the numbers indicate the order in which edges are traversed by the walks . ]    ; the numbers indicate the order in which edges are traversed by the walk . ]",
    "the cycle @xmath135 splits the plane into two parts ; each clause belongs to exactly one part .",
    "we say that the clauses , edges , etc .  inside",
    "( resp .  outside )",
    "@xmath135 are inner ( resp .",
    "outer ) .",
    "focus on the outer clauses .",
    "define parent - child relationship between the clauses as follows .",
    "the clauses that belong to the outer face of the graph @xmath136 are orphans  they have no parents .",
    "now imagine removing an orphan @xmath138 , together with the edges that connect @xmath138 to the variables .",
    "any clause @xmath139 that now ( after @xmath138 s removal ) belongs to the outer face of @xmath136 is a child of @xmath138 ( and @xmath138 is the parent of @xmath139 ) .",
    "recursively , any clause @xmath140 is the parent for all clauses that appear on the outer face of @xmath136 after removal of @xmath140 ( and all its ancestors ) .",
    "we now augment @xmath136 with new edges .",
    "for any parent , the children are angularly sorted around the parent .",
    "we connect the first and the last child to the parent ; if a parent has only one child , connect the parent and the child by 2 parallel edges ( parallel in the graph - theoretic sense , in the embedding they are not parallel ) .",
    "add also edges between siblings ; in particular , connect orphans with a cycle , in the order in which they appear on the outer face of @xmath136 ( fig .  [ 2 ] ) . finally , add a parallel edge for each clause - variable edge ( so that every clause is connected to each of its variables with 2 parallel edges ) .",
    "let @xmath141be the closed walk that goes through the outer clauses and all variables in the dfs manner , with preference to go right ( as seen from a clause ) and down ( i.e. , towards @xmath135 ) .",
    "specifically , at the `` top level '' , the walk contains the cycle through all orphans .",
    "in addition , at each orphan @xmath138 ( and in general , at each clause ) the walk is the dfs traversal of the subtree of @xmath138 : it goes to the rightmost ( as seen from @xmath138 ) variable of @xmath138 , then goes back to @xmath138 ( using the parallel edge ) , and then  either to the next variable of @xmath138 or to the rightmost child @xmath139 of @xmath138 ( whichever is more to the right ) . at @xmath139 ,",
    "the walk recurses down to the rightmost variable of @xmath139 , then goes back to @xmath139 , and then again  either to the next variable of @xmath139 or to the rightmost child of @xmath139 , etc .",
    "the walk follows the edge to the sibling or to the parent of a clause @xmath140 after all children and variables of @xmath140 have been visited .",
    "in particular , the variables of childless clauses are just visited one - by - one , from right to left .",
    "refer to fig .",
    "we do an analogous augmentation of the subgraph of @xmath136 inside the cycle @xmath135 .",
    "specifically , we choose some face @xmath142 of @xmath136 inside @xmath135 , and let @xmath142 play the role of the outer face : the orphan clauses are those on the boundary of @xmath142 ; the children are defined recursively as the clauses that appear on @xmath142 after deletion of parents . as before , we duplicate variable - clause edges .",
    "let @xmath137be closed walk analogous to @xmath141 : @xmath137goes through the orphans , recursing to variables and children in the dfs manner , with the preference to go left ( as seen from a clause ) and towards @xmath135 .",
    "refer to fig .",
    "[ 3 ] .",
    "we now splice the walks @xmath141 , @xmath137 , and the cycle @xmath135 into a single closed walk @xmath143through @xmath136 .",
    "let @xmath144 be an arbitrary edge of @xmath135 , and let @xmath145 be an outer clause that belongs to the face of @xmath136 that has @xmath144 on the boundary .",
    "remove @xmath144 from @xmath135 , and add edges @xmath146 ( fig .  [ 4 ] ) .",
    "similarly , remove an edge @xmath147 from @xmath135 , and add edges @xmath148 to an inner clause @xmath149 .",
    "the walk @xmath143starts from following @xmath141until reaching @xmath145 , at which point it uses the edge @xmath150 .",
    "( this may not necessarily be the first time the walk visits @xmath145 ; the walk uses @xmath150 so that the usage is consistent with the ordering of edges around @xmath145  refer to fig .",
    "[ 4 ] , where @xmath145 is reached first by edge 22 , while @xmath150 is only 25th . ) from @xmath59 , the walk follows the cycle @xmath135 up to @xmath151 , where it uses the edge @xmath152 to enter inside @xmath135 . from @xmath149 , the walk @xmath143follows the walk @xmath137all the way around back to @xmath149 .",
    "it then uses @xmath153 to get back to @xmath135 , upon which it traverses @xmath135 from @xmath154 to @xmath30 . at @xmath30 ,",
    "the walk uses @xmath155 and follows the rest of @xmath141from there .      as the last step of the reduction ,",
    "we convert @xmath136 to an instance of finding a thick wire . for that",
    ", we thicken the edges of @xmath136 , turning them into channels of width  2 .",
    "we replace variables and clauses with gadgets shown in figs .",
    "[ var ] and  [ clause ] resp .",
    "the connections ( channels ) between variables and clauses ( fig .  [ connections ] )",
    "ensure that whenever a channel from a clause to a variable is used by the wire , the variable satisfies the clause .",
    "we cut ( the channel corresponding to ) one of the edges of @xmath135 , and place the points @xmath133 on the opposite sides of the cut .",
    "this turns the closed walk @xmath143into an @xmath134 path . by our construction ,",
    "the only @xmath134 wire in the instance is one that follows the walk @xmath143 in @xmath136 , possibly , omitting some clause - variable edges ( channels ) .",
    "indeed , neither channels nor gadgets have any leakage  the wire must follow them through . the only flexibility that the wire has is ( 1 )  how to traverse the variable gadgets , and ( 2 )  which clause - variable channels ( not ) to use .",
    "but we know , by clause gadget construction ( see fig .",
    "[ clause ] ) , that at least one channel from every clause must be used ; moreover , when it is used , the variable must satisfy the clause ( see fig .",
    "[ connections ] ) .",
    "thus , the @xmath134 wire exists if and only if @xmath136 is satisfiable .",
    "we showed that for a snake to stay simple , it must grow fat ( or else , learn to squeeze ) .",
    "we mention few open problems here :    to minimize snake s squeeze factor , it would be interesting to find a path that minimizes maximum self - overlap of a snake .",
    "it is easy to see that a snake of thickness 1/2 can follow ( without self - overlap ) the shortest ( possibly self - overlapping ) path for a thickness-1 snake .",
    "is 1/2 best possible ?",
    "note that in our hardness proof , a non - zero amount of overlap is enforced ;",
    "what is the largest self - overlap for which the problem remains hard ?    minimizing the path length for one point of the snake is similar to finding `` @xmath156-optimal '' motion of a rod @xcite .",
    "other objectives are possible : e.g. , distance traveled by another point ( not the mouth ) or the average distance traveled ( @xmath157-optimality , etc . ) .",
    "does the situation with the snake mimic that for the rod : minimizing motion of any point is np - hard , except for a rod endpoint ?    what is the hardness of computing paths for a short snake that is not required to be pulled taut ?",
    "it seems that the answer to this question leads to an interesting research direction of `` snake packing '' : given a polygonal domain , can one layout a length - snake in it ?",
    "the problem is np - hard by a reduction from hamiltonicity of grid graphs ; what about , say , simple polygons ?",
    "t.  asano , d.  kirkpatrick , and c.  k. yap . minimizing the trace length of a rod endpoint in the presence of polygonal obstacles is np - hard . in _ proceeding of canadian conference on computational geometry _ , pages 1013 , 2003 .",
    "a.  f. cook iv , c.  wenk , o.  daescu , s.  bitner , y.  k. cheung , and a.  kurdia .",
    "visiting a sequence of points with a bevel - tip needle . in _ proceedings of the 9th latin american theoretical informatics symposium _ , 2010 ."
  ],
  "abstract_text": [
    "<S> we prove that it is np - hard to decide whether two points in a polygonal domain with holes can be connected by a wire . </S>",
    "<S> this implies that finding any approximation to the shortest path for a long snake amidst polygonal obstacles is np - hard . on the positive side </S>",
    "<S> , we show that snake s problem is `` length - tractable '' : if the snake is `` fat '' , i.e. , its length / width ratio is small , the shortest path can be computed in polynomial time . </S>"
  ]
}