{
  "article_text": [
    "an _ oracle _ is given as a boolean function of @xmath11 variables , denoted by @xmath12 , and so there are @xmath13 ( or @xmath2 for @xmath14 ) different oracles .",
    "an _ oracle computation _ is , given a specific oracle @xmath15 which we do not know , to determine , through queries to the oracle , whether or not @xmath15 satisfies a certain property .",
    "note that @xmath15 has @xmath5 black - box @xmath16-values , @xmath17 through @xmath18 .",
    "( @xmath17 is also denoted as @xmath19 , @xmath18 as @xmath20 , and similarly for an intermediate @xmath21 . )",
    "so , in other words , we are asked whether or not these @xmath5 bits satisfy the property .",
    "there are many interesting such properties : for example , it is called _ or _ if the question is whether all the @xmath5 bits are @xmath22 and _ parity _ if the question is whether the @xmath5 bits include an even number of @xmath23 s . the most general question ( or job in this case ) is to obtain all the @xmath5 bits .",
    "our complexity measure is the so - called _ query complexity _ ,",
    "i.e. , the number of oracle calls , to get a right answer with bounded error .",
    "note that the trivial upper bound is @xmath5 since we can tell all the @xmath5 bits by asking @xmath19 through @xmath20 .",
    "if we use a classical computer , this @xmath5 is also a lower bound in most cases .",
    "if we use a quantum computer , however , several interesting speedups are obtained .",
    "for example , the previous three problems have a ( quantum ) query complexity of @xmath7 , @xmath24 and @xmath25 , respectively @xcite .    in this paper",
    ", we discuss the following problem which we call the _ oracle identification _ problem : we are given a set @xmath0 of @xmath1 different oracles out of the @xmath2 ones for which we have the complete information ( i.e. , for each of the @xmath2 oracles , we know whether it is in @xmath0 or not ) .",
    "now we are asked to determine which oracle in @xmath0 is currently in the black - box .",
    "a typical example is the grover search @xcite where @xmath26 and @xmath27 iff @xmath28 .",
    "( namely , exactly one bit among the @xmath5 bits is @xmath23 in each oracle in @xmath0 . finding its position is equivalent to identifying the oracle itself",
    ") it is well - known that its query complexity is @xmath29 .",
    "another example is the so - called bernstein - vazirani problem @xcite where @xmath26 and @xmath27 iff the inner product of @xmath30 and @xmath31 ( mod @xmath32 ) is 1 .",
    "a little surprisingly ,",
    "its query complexity is just one .",
    "thus the oracle identification problem is a promise version of the oracle computation problem . for both oracle computation and oracle identification problems",
    ", @xcite developed a very general method for proving their lower bounds of the query complexity . also , many nontrivial upper bounds are known as mentioned above .",
    "however all those upper bounds are for specific problems such as the grover search ; no general upper bounds for a wide class of problems have been known so far .    * our contribution . * in this paper , we give general upper and lower bounds for the oracle identification problem .",
    "more concretely we prove : ( i )  the query complexity of the oracle identification for _ any _ oracle set @xmath0 is @xmath3 if @xmath33 .",
    "( ii )  it is @xmath7 for _ any _ @xmath0 if @xmath8 .",
    "( iii )  for a wide range of oracles ( @xmath34 ) such as random oracles and balanced oracles , the query complexity is @xmath35 , where @xmath10 is a parameter determined by @xmath0 .",
    "the bound in ( i ) is better than the obvious bound @xmath5 if @xmath6 . both algorithms for ( i ) and ( ii ) are quite tricky , and the result ( ii ) includes the upper bound for the grover search as a special case . result ( i ) is almost optimal , and results ( ii ) and ( iii ) are optimal ; to prove their optimality we introduce a general lower bound theorem whose statement is simpler than that of @xcite .    * related results .",
    "* query complexity has constantly been one of the central topics in quantum computation ; to cover everything is obviously impossible . for the upper bounds of the query complexity ,",
    "the most significant result is due to @xcite , known as the grover search , which also derived many applications and extensions @xcite . in particular",
    ", some results showed efficient quantum algorithms by combining the grover search with other ( quantum and classical ) techniques .",
    "for example , quantum counting algorithm @xcite gives an approximate counting method by combining the grover search with the quantum fourier transformation , and quantum algorithms for the claw - finding and the element distinctness problems @xcite also exploit classical random sampling and sorting .",
    "most recently , @xcite developed an optimal quantum algorithm with @xmath36 queries for element distinctness problem , which makes use of quantum walk and matches to the lower bounds shown by @xcite .",
    "@xcite used the element distinctness algorithm to design a quantum algorithm for finding triangles in a graph .",
    "@xcite also showed an efficient quantum search algorithm for spacial regions based on recursive grover search , which is applicable to some geometrically structured problems such as search on a 2-d grid .",
    "on the lower - bound side , there are two popular techniques to derive quantum lower bounds , i.e. , the polynomial method and the quantum adversary method .",
    "the polynomials method was firstly introduced for quantum computation by @xcite who borrowed the idea from the classical counterpart .",
    "for example , it was shown that for bounded error cases , evaluations of @xmath37 and @xmath38 functions need @xmath29 number of queries , while parity and majority functions at least @xmath39 and @xmath40 , respectively .",
    "recently , @xcite used the polynomials method to show the lower bounds for the collisions and element distinctness problems .",
    "the classical adversary method was used in @xcite , which is also called the hybrid argument .",
    "their method can be used , for example , to show the lower bound of the grover search .",
    "as mentioned above , @xcite introduced a quite general method , which is known as the quantum adversary argument , for obtaining lower bounds of various problems , e.g. , the grover search , and of ors and inverting a permutation .",
    "@xcite recently established a lower bound of @xmath41 on the bounded - error quantum query complexity of read - once boolean functions by extending @xcite .",
    "@xcite generalized the quantum adversary method respectively from the aspect of semidefinite programming , and @xcite generalized the method from kolmogorov complexity perspective .",
    "furthermore , @xcite showed the lower bounds for graph connectivity and local search problem respectively using the quantum adversary method .",
    "@xcite also gave a comparison between the quantum adversary method and the polynomial method .",
    "our model is basically the same as standard ones ( see e.g. , @xcite ) . for a boolean function @xmath42 of @xmath11 variables , an _ oracle _",
    "maps @xmath43 to @xmath44 .",
    "quantum computation _ is a sequence of unitary transformations @xmath45 , where @xmath46 is a single oracle call against our _ black - box oracle _",
    "( sometimes called an _ input oracle _ ) , and @xmath47 may be any unitary transformation without oracle calls .",
    "the above computation sequence involves @xmath48 oracle calls , which is our measure of the complexity ( _ the query complexity _ ) .",
    "let @xmath14 and hence there are @xmath2 different oracles .",
    "our problem is called the _ oracle identification problem _ ( _ oip _ ) .",
    "an oip is given as an infinite sequence @xmath49 .",
    "each @xmath50 ( @xmath51 ) is a set of oracles ( boolean functions with @xmath11 variables ) whose size , @xmath52 , is denoted by @xmath1 ( @xmath53 ) .",
    "a ( quantum ) algorithm @xmath54 which solves the oip is a quantum computation as given above .",
    "@xmath54 has to determine which oracle ( @xmath55 ) is the current input oracle with bounded error .",
    "if @xmath54 needs at most @xmath56 oracle calls , we say that the query complexity of @xmath54 is @xmath56 .",
    "it should be noted that @xmath54 knows the set @xmath50 completely ; what is unknown for @xmath54 is the current input oracle .",
    "for example , the grover search is an oip whose @xmath50 contains @xmath5 ( i.e. , @xmath34 ) boolean functions @xmath57 such that @xmath58 note that @xmath21 means @xmath59 ( @xmath60 @xmath22 or @xmath23 ) such that @xmath61 is the binary representation of the number @xmath31 .",
    "note that @xmath50 is given as a @xmath62 boolean matrix .",
    "more formally , the entry at row @xmath30 ( @xmath63 ) and column @xmath31 ( @xmath64 ) shows @xmath65 .",
    "1 shows such a matrix of the grover search for @xmath66 .",
    "each row corresponds to each oracle in @xmath50 and each column to its boolean value .",
    "2 shows another famous example given by an @xmath67 matrix , which is called the bernstein - vazirani problem @xcite .",
    "it is well known that there is an algorithm whose query complexity is just one for this problem @xcite .    as described in the previous section ,",
    "there are several similar ( but different subtly ) settings .",
    "for example , the problem in @xcite is given as a matrix which includes all the rows ( oracles ) each of which contains @xmath39 @xmath23 s or @xmath68 @xmath23 s for @xmath69 .",
    "we do not have to identify the current input oracle itself but have only to answer whether the current oracle has @xmath39 @xmath23 s or not .",
    "( the famous deutsch - jozsa problem @xcite is its special case . )",
    "the @xmath70-target grover search is given as a matrix consisting of all ( or a part of ) the rows containing @xmath70 @xmath23 s .",
    "again we do not have to identify the current input oracle but have to answer with a column which has value @xmath23 in the current input .",
    "3 shows an example , where each row contains @xmath71 ones .",
    "one can see that the multi - target grover search is easy ( @xmath72 queries are enough since we have roughly one half @xmath23 s ) , but identifying the input oracle itself is much harder .",
    "@xcite gave a very general lower bounds for oracle computation .",
    "when applying to the oip ( the original statement is more general ) , it claims the following :    [ ambainis ] let @xmath73 be a given set of oracles , and @xmath74 be two disjoint subsets of @xmath73 .",
    "let @xmath75 be such that + 1 .",
    "for every @xmath76 , there exist at least @xmath77 different @xmath78 such that @xmath79 .",
    "+ 2 . for every @xmath80 ,",
    "there exist at least @xmath81 different @xmath76 such that @xmath79 .",
    "+ let @xmath82 be the number of @xmath78 such that @xmath79 and @xmath83 and @xmath84 be the number of @xmath76 such that @xmath79 and @xmath83 .",
    "let @xmath85 be the maximum of @xmath86 over all @xmath79 and @xmath87 such that @xmath83 .",
    "then , the query complexity for @xmath73 is @xmath88 .    in this paper",
    ", we always assume that @xmath89 .",
    "if @xmath90 , then we can select @xmath1 columns out of the @xmath5 ones while keeping the uniqueness property of each oracle .",
    "then by changing the state space from @xmath11 bits to at most @xmath91 bits , we have a new @xmath92 matrix , i.e. , a smaller oip problem .",
    "as mentioned in the previous section , we have a general lower bound for the oip .",
    "but we do not know any nontrivial general upper bounds . in this section ,",
    "we give two general upper bounds for the case that @xmath93 and for the case that @xmath94 .",
    "the former is almost tight as described after the theorem , and the latter includes the upper bound for the grover search as a special case .",
    "an @xmath62 oip denotes an oip whose @xmath50 ( or simply @xmath0 by omitting the subscript ) is given as an @xmath62 matrix as described in the previous section . before proving the theorems , we introduce a convenient technique called a _",
    "column flip_.    * column flip .",
    "* suppose that @xmath0 is any @xmath62 matrix ( a set of @xmath1 oracles ) .",
    "then any quantum computation for @xmath0 can be transformed into a quantum computation for an @xmath62 matrix @xmath95 such that the number of @xmath23 s is less than or equal to the number of @xmath22 s in every column .",
    "( we say that such a matrix is _",
    "@xmath23-sensitive_. ) the reason is straightforward . if some column in @xmath0 holds more @xmath23 s than @xmath22 s , then we  flip \" all the values",
    "of course we have to change the current oracle into the new ones but this can be easily done by adding an extra circuit to the output of the oracle .",
    "[ n_times_m_u ] the query complexity of any @xmath62 oip is @xmath3 if @xmath96 .    to see the idea , we first prove an easier bound , i.e. , @xmath97 .",
    "( since @xmath1 can be an exponential function in @xmath5 , this bound is significantly worse than that of the theorem . ) if necessary , we convert the given matrix @xmath0 to be @xmath23-sensitive by column flip .",
    "then , just apply the grover search against the input oracle .",
    "if we get a column @xmath31 ( the input oracle has @xmath23 there ) , then we can eliminate all the rows having @xmath22 in that column .",
    "the number of such removed rows is at least one half by the @xmath23-sensitivity .",
    "just repeat this ( including the conversion to @xmath23-sensitive matrices ) until the number of rows becomes @xmath23 , which needs @xmath98 rounds .",
    "each grover search needs @xmath7 oracle calls .",
    "since we perform many grover searches , the @xmath99 term is added to take care of the success probability .    in this algorithm",
    "we counted @xmath7 oracle calls for the grover search , which is the target of our improvement .",
    "more precisely , our algorithm is the following quantum procedure .",
    "let @xmath100 be the given @xmath101 matrix :    _ step 1 .",
    "_  let @xmath102 be a set of candidate oracles ( or equivalently an @xmath62 matrix each row of which corresponds to each oracle ) .",
    "set @xmath103 initially .",
    "_ step 2 . _  repeat steps 3 - 6 until @xmath104 .    _ step 3 .",
    "_  convert @xmath105 into @xmath23-sensitive matrix .",
    "_  compute the largest integer @xmath10 such that at least one half rows of @xmath105 contain @xmath10 1 s or more .",
    "( this can be done simply by sorting the rows of @xmath105 with the number of 1 s . )    _ step 5 . _",
    "for the current ( modified ) oracle , perform the multi - target grover search @xcite where we set @xmath106 to the maximum number of oracle calls .",
    "iterate this grover search @xmath107 times ( to increase the success probability ) .",
    "_  if we succeeded in finding 1 by the grover search in the previous step , i.e. , a column @xmath31 such that the current oracle actually has 1 in that column , then eliminate all the rows of @xmath105 having 0 in their column @xmath31 .",
    "( let @xmath105 be this reduced matrix . )",
    "otherwise eliminate all the rows of @xmath105 having at least @xmath10 1 s .",
    "now we estimate the number of oracle calls in this algorithm .",
    "let @xmath108 and @xmath109 be the number of the rows of @xmath105 and the value of @xmath10 in the @xmath110-th repetition respectively .",
    "initially , @xmath111 . note that the number of the rows of @xmath105 becomes @xmath112 or less after step 6 , i.e. , @xmath113 even if the grover search is successful or not in step 5 since the number of 1 s in each column of the modified matrix is less than @xmath112 and the number of the rows which have at least @xmath10 1 s is @xmath112 or more . assuming that we need the @xmath114 repetitions to identify the current input oracle , the total number of the oracle calls is @xmath115 we estimate the lower bounds of @xmath109 .",
    "note that there are no identical rows in @xmath105 and the number of possible rows that contain at most @xmath109 1 s is @xmath116 in the @xmath110-th repetition .",
    "thus , it must hold that @xmath117 since @xmath118 , @xmath119 if @xmath120 , otherwise @xmath121 .",
    "therefore the number of the oracle calls is at most @xmath122 where the number of rows of @xmath105 becomes @xmath5 or less after the @xmath123-th repetition . for @xmath124 , there exists a sequence of integers @xmath125 @xmath126 such that @xmath127 since @xmath128 for @xmath129 . thus , we have @xmath130 then , the total number of the oracle calls is @xmath131 .",
    "next , we consider the success probability of our algorithm . by the analysis of the grover search in @xcite ,",
    "if the number of 1 s of the current modified oracle is larger than @xmath109 in the @xmath110-th repetition , then we can find 1 in the current modified oracle with probability at least @xmath132 .",
    "this success probability worsens after @xmath114 rounds of repetition but still keeps a constant as follows : @xmath133    [ n_times_m_l ] there is an oip whose query complexity is @xmath134 .    this can be shown in the same way as theorem  5.1 in @xcite as follows .",
    "let @xmath135 be the set of all the oracles whose values are 1 at exactly @xmath10 positions and @xmath136 be the set of all the oracles that have @xmath23 s at exactly @xmath137 positions .",
    "we consider the union of @xmath135 and @xmath136 for our oracle identification problem .",
    "thus , @xmath138 , and therefore , we have @xmath139 .",
    "let also a relation @xmath140 be the set of all @xmath141 such that @xmath142 , @xmath143 and they differ in exactly a single position . then the parameters in theorem  5.1 in @xcite take values @xmath144 , @xmath145 and @xmath146 .",
    "thus the lower bound is @xmath147 . since @xmath148",
    ", @xmath10 can be as large as @xmath149 , which implies our lower bound .",
    "thus the bound in theorem  1 is almost tight but not exactly .",
    "when @xmath34 , however , we have another algorithm which is tight within a factor of constant .",
    "although we prove the theorem for @xmath34 , it also holds for @xmath150 .",
    "[ n_times_n ] the query complexity of any @xmath67 oip is @xmath7 .",
    "let @xmath0 be the given @xmath67 matrix .",
    "our algorithm is the following procedure :    _ step 1 . _",
    "let @xmath103 .",
    "if there is a column in @xmath105 which has at least @xmath151 @xmath22 s and at least @xmath151 @xmath23 s , then perform a _",
    "classical _ oracle call with this column .",
    "eliminate all the inconsistent rows and update @xmath105 .",
    "_  modify @xmath105 to be @xmath23-sensitive . perform the multi - target grover search @xcite to obtain column @xmath31 .",
    "_  find a column @xmath152 which has @xmath22 and @xmath23 in some row while the column @xmath31 obtained in the step 2 has @xmath23 in that row ( there must be such a column because any two rows are different ) .",
    "perform a _",
    "classical _ oracle call with column @xmath152 and remove inconsistent rows .",
    "update @xmath105 .",
    "repeat this step until @xmath104 .    since the correctness of the algorithm is obvious",
    ", we only prove the complexity .",
    "a single iteration of step 1 removes at least @xmath151 rows , and hence we can perform at most @xmath151 iterations ( at most @xmath151 oracle calls ) .",
    "note that after this step each column of @xmath105 has at most @xmath151 @xmath22 s or at most @xmath151 @xmath23 s .",
    "since we perform the column flip in step 2 , we can assume that each column has at most @xmath151 @xmath23 s .",
    "the grover search in step 2 needs @xmath7 oracle calls .",
    "since column @xmath31 has at most @xmath151 @xmath23 s , the classical elimination in step 3 needs at most @xmath151 oracle calls .",
    "in this section , we investigate the case that @xmath34 in more detail .",
    "note that theorem  3 is tight for the whole @xmath67 oip but not for its subfamilies .",
    "( for example , the bernstein - vazirani needs only @xmath72 queries . ) to seek optimal bounds for subfamilies , we introduce the following parameter : let @xmath0 be an oip given as an @xmath62 matrix .",
    "then @xmath153 be the maximum number of @xmath23 s in a single column of the matrix .",
    "we first give a lower bound theorem in terms of this parameter , which is a simplified version of proposition  1 .",
    "[ lower_bound ] let @xmath0 be an @xmath62 matrix and @xmath154 .",
    "then @xmath0 needs @xmath155 queries .    without loss of generality",
    ", we can assume that @xmath0 is @xmath23-sensitive , i.e. , @xmath156 .",
    "we select @xmath135 ( @xmath136 , resp . ) as the upper ( lower , resp . )",
    "half of @xmath0 ( i.e. , @xmath157 ) and set @xmath158 ( i.e. , @xmath159 for every @xmath160 and @xmath161 ) .",
    "let @xmath162 be the number of 1 s in the @xmath31-th column of @xmath136 .",
    "now it is not hard to see that we can set @xmath163 , @xmath164 where @xmath165 is the number of @xmath23 s in column @xmath31 . since @xmath166",
    ", this value is bounded from above by @xmath167 .",
    "hence , proposition  [ ambainis ] implies @xmath168    although this lower bound looks much simpler than proposition  1 , it is equally powerful for many cases .",
    "for example , we can obtain @xmath41 lower bound for the oip given in fig .",
    "3 which we denote by @xmath135 .",
    "note in general that if we need @xmath48 queries for a matrix @xmath0 , then we also need at least @xmath48 queries for any @xmath169 .",
    "therefore it is enough to obtain a lower bound for the matrix @xmath170 which consists of the @xmath39 upper - half rows of @xmath135 and all the @xmath23 s of the right half can be changed to @xmath22 s by the column flip . since @xmath171 , theorem  4 gives us an lower bound of @xmath41 .",
    "now we give tight upper bounds for three subfamilies of @xmath67 matrices .",
    "the first one is not a worst - case bound but an average - case bound : let @xmath172 be an @xmath67 matrix where each entry is @xmath23 with the probability @xmath173 .    [ random ]",
    "the query complexity for @xmath172 is @xmath9 with high probability if @xmath174 for @xmath175 .",
    "suppose that @xmath135 is an @xmath172 . by using a standard chernoff - bound argument",
    ", we can show that the following three statements hold for @xmath135 with high probability ( proofs are omitted ) .",
    "( i ) let @xmath176 be the number of 1 s in column @xmath30 . then for any @xmath30 , @xmath177 .",
    "( ii ) let @xmath178 be the number of 1 s in row @xmath31 .",
    "then for any @xmath31 , @xmath179 .",
    "( iii ) suppose that @xmath180 is a set of any @xmath181 columns in @xmath135 ( @xmath181 is a function in @xmath182 which is constant since @xmath182 is a constant ) .",
    "then the number of rows which have 1 s in all the columns in @xmath180 is at most @xmath183 .",
    "our lower bound is immediate from ( i ) by theorem  [ lower_bound ] . for the upper bound ,",
    "our algorithm is quite simple .",
    "just perform the grover search independently @xmath181 times .",
    "each single round needs @xmath184 oracle calls by ( ii ) .",
    "after that the number of candidates is decreased to @xmath183 by ( iii ) .",
    "then we simply perform the classical elimination , just as step 3 of the algorithm in the proof of theorem  3 , which needs at most @xmath183 oracle calls .",
    "since @xmath181 is a constant , the overall complexity is @xmath185 if @xmath186 .",
    "the second subfamily is called a _",
    "balanced matrix_. let @xmath187 be a family of @xmath67 matrices in which every row and every column has exactly @xmath10 @xmath23 s .",
    "( again the theorem holds if the number of @xmath23 s is @xmath188 . )    [ balanced ] the query complexity for @xmath187 is @xmath9 if @xmath189 .",
    "the lower - bound part is obvious by theorem  4 .",
    "the upper - bound part is to use a single grover search @xmath190 @xmath10 classical elimination .",
    "thus the complexity is @xmath191 , which is @xmath184 if @xmath189 .",
    "the third one is somewhat artificial .",
    "let @xmath192 , called an _ hybrid matrix _ because it is a combination of grover and bernstein - vazirani , be a matrix defined as follows : let @xmath193 and + @xmath194 then @xmath195 iff ( i ) @xmath196 and ( ii ) @xmath197 ( mod @xmath32 ) . fig",
    "4 shows the case that @xmath198 and @xmath199 .    [ hybrid ] the query complexity for @xmath192 is @xmath9 , where @xmath200 .",
    "we combine the grover search @xcite with bv algorithm@xcite to identify the oracle @xmath201 by determining the hidden value @xmath202 of @xmath201 .",
    "we first can determine the first @xmath203 bits of @xmath202 .",
    "fixing the last @xmath152 bits to @xmath204 , we apply the grover search using oracle @xmath201 for the first @xmath203 bits to determine @xmath205 .",
    "it should be noted that @xmath206 and @xmath207 for any @xmath208 .",
    "next , we apply bv algorithm to determine the remaining @xmath152 bits of @xmath202 .",
    "this algorithm requires @xmath184 queries for the grover search and @xmath72 queries for bv algorithm to determine @xmath202 .",
    "therefore we can identify the oracle @xmath201 using @xmath184 queries .",
    "the lower bound for the general @xmath62 oip is obviously @xmath5 if @xmath96 .",
    "when @xmath34 , we can obtain bounds being smaller than @xmath5 for some cases .",
    "the deterministic query complexity for @xmath209 oip @xmath0 with @xmath210 is at least @xmath211 .",
    "let @xmath201 be the current input oracle .",
    "the following proof is due to the standard adversary argument .",
    "let @xmath54 be any deterministic algorithm using the oracle @xmath201 .",
    "suppose that we determine @xmath212 to identify the oracle @xmath201 .",
    "then the execution of @xmath54 is described as follows : ( i ) in the first round , @xmath54 calls the oracle with the predetermined value @xmath213 and the oracle answers with @xmath214 .",
    "( ii ) in the second round , @xmath54 calls the oracle with value @xmath215 , which is determined by @xmath216 and the oracle answers with @xmath217 . (",
    "iii ) in the @xmath218-st round , @xmath54 calls the oracle with @xmath219 which is determined by @xmath220 and the oracle answers with @xmath221 .",
    "( iv ) in the @xmath77-th round @xmath54 outputs @xmath202 which is determined by @xmath222 and stops .",
    "thus , the execution of @xmath54 is completely determined by the sequence @xmath223 which is denoted by @xmath224 .",
    "( obviously , if we fix a specific @xmath202 , then @xmath224 is uniquely determined ) .",
    "let @xmath225 and suppose that @xmath54 halts in the @xmath226-th round .",
    "we compute the sequence @xmath227 , and another sequence @xmath228 , as follows ( note that @xmath229 are similar to @xmath230 above and are chosen by the adversary ) : ( i ) @xmath231 .",
    "( ii ) suppose that we have already computed @xmath232 , and @xmath233 .",
    "let @xmath234 be the value with which @xmath54 calls the oracle in the @xmath218-st round .",
    "( recall that @xmath234 is determined by @xmath233 . )",
    "let @xmath235 and @xmath236 . then if @xmath237 then we set @xmath238 and @xmath239 . otherwise , i.e. , if @xmath240 , then we set @xmath241 and @xmath242 .",
    "now we can make the following two claims .",
    "* claim 1 . * @xmath243 .",
    "( reason : note that @xmath244 and the size of @xmath245 decreases as @xmath30 increases . by the construction of @xmath245 , one can see that until @xmath246 becomes @xmath247 , its size decreases additively by at most @xmath10 in a single round and after that it decreases multiplically at most one half .",
    "the claim then follows by a simple calculation . )",
    "* claim 2 . *",
    "if @xmath248 , then @xmath249 .",
    "( reason : obvious since @xmath250 . )",
    "now it follows that there are two different @xmath251 and @xmath252 in @xmath253 such that @xmath254 by claims 1 and 2 .",
    "therefore @xmath54 outputs the same answer for two different @xmath251 and @xmath252 , a contradiction .    for the classical upper bounds ,",
    "we only give the bound for the hybrid matrix .",
    "similarly for @xmath172 and @xmath187 .",
    "the deterministic query complexity for @xmath192 is @xmath255 .",
    "let @xmath201 be the current input oracle .",
    "the algorithm consists of an exhaustive and a binary search to identify the oracle @xmath201 by determining the hidden value @xmath202 of @xmath201 .",
    "first , we determine the first @xmath203 bits of @xmath202 by fixing the last @xmath152 bits to all @xmath22 s and using exhaustive search .",
    "second , we determine the last @xmath152 bits of @xmath202 by using binary search .",
    "this algorithm needs @xmath256 queries in the exhaustive search , and @xmath257 queries in the binary search .",
    "therefore , the total complexity of this algorithm is @xmath258 .",
    "some future directions are as follows : the most interesting one is a possible improvement of theorem  1 , for which our target is @xmath259 .",
    "also , we wish to have a matching lower bound , which is probably possible by making the argument of theorem  2 a bit more exact .",
    "as mentioned before , in a certain situation , we do not have to determine the current oracle completely but have only to do that  approximately \" , e.g. , have to determine whether it belongs to some subset of oracles .",
    "it might be interesting to investigate how this approximation makes the problem easier ( or basically not ) .",
    "most recently , it turned out that our problem oip is equivalent to _ exact learning _ , which is a well - studied model of computional learning , by comments from servedio .",
    "@xcite has already shown interesting results on the quantum exact learning , which are independent of our main result on the quantum upper bound of any oip .",
    "more precisely , @xcite defined a natural quantum version of two learning models and proved the equivalence up to polynomial factors between classical and quantum query complexity for the models . interpreting the result on the exact learning into the context of our oip ,",
    "if there exists a quantum algorithm that solves an oip @xmath0 with @xmath260 queries then there exists a deterministic algorithm that solves @xmath0 with @xmath261 queries .",
    "d.  biron , o.  biham , e.  biham , m.  grassl , and d.  a. lidar .",
    "generalized grover search algorithm for arbitrary initial amplitude distribution . in _ proceedings of the 1st nasa international conference on quantum computing and quantum communication , lncs ,",
    "1509 , springer - verlag _ , pages 140147 , 1998 .",
    "h.  buhrman , c.  drr , m.  heiligman , p.  hyer , f.  magniez , m.  santha and r.  de  wolf . quantum algorithms for element distinctness . in _ proceedings of the 16th ieee annual conference on computational complexity _ ,",
    "pages 131137 , 2001 .",
    "g.  brassard , p.  hyer , m.  mosca , a.  tapp .",
    "quantum amplitude amplification and estimation . in _",
    "ams contemporary mathematics series millennium volume entitled `` quantum computation & information '' _ , volume 305 , pages 5374 , 2002 .",
    "d.  p. chi and j.  kim .",
    "quantum database searching by a single query . in _ proceedings of the 1st nasa international conference on quantum computing and quantum communication , lncs , vol .",
    "1509 , springer - verlag _ , pages 148151 , 1998 .",
    "l.  laplante and f. magniez .",
    "lower bounds for randomized and quantum query complexity using kolmogorov arguments . in _ proceedings of the 19th ieee conference on computational complexity _ , to appear , 2004 .",
    "also in _ quant - ph/0311189_."
  ],
  "abstract_text": [
    "<S> the oracle identification problem ( oip ) is , given a set @xmath0 of @xmath1 boolean oracles out of @xmath2 ones , to determine which oracle in @xmath0 is the current black - box oracle . </S>",
    "<S> we can exploit the information that candidates of the current oracle is restricted to @xmath0 . </S>",
    "<S> the oip contains several concrete problems such as the original grover search and the bernstein - vazirani problem . </S>",
    "<S> our interest is in the quantum query complexity , for which we present several upper and lower bounds . </S>",
    "<S> they are quite general and mostly optimal : ( i ) the query complexity of oip is @xmath3 for _ any _ @xmath0 such that @xmath4 , which is better than the obvious bound @xmath5 if @xmath6 . </S>",
    "<S> ( ii ) it is @xmath7 for _ any _ @xmath0 if @xmath8 , which includes the upper bound for the grover search as a special case . </S>",
    "<S> ( iii ) for a wide range of oracles ( @xmath8 ) such as random oracles and balanced oracles , the query complexity is @xmath9 , where @xmath10 is a simple parameter determined by @xmath0 . </S>"
  ]
}