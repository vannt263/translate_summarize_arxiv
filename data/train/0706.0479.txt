{
  "article_text": [
    "( the picture on the front page is an incidence matrix for a binary tree .",
    "empty squares indicate zero entries and bullets indicate non - zero entries . )",
    "recently , farhi - goldstone - gutmann proposed in fgg07 @xcite a quantum algorithm for evaluating certain boolean formulas @xmath0 on @xmath1 variables .",
    "fgg07 considers only those @xmath2 representable as balanced binary nand trees . these are perfectly bifurcating trees , with a nand at every non - leaf node , with @xmath1 leaves and @xmath3 levels , where each leaf represents a different input variable of @xmath2 .",
    "the fgg07 algorithm evaluates these balanced binary nand formulas in time @xmath4 .",
    "the fgg07 algorithm uses a continuous time quantum walk .",
    "the input to the nand formula is entered into the quantum walk by means of an  oracle hamiltonian \" , which is applied constantly and continuously during the quantum walk .",
    "one describes this situation as a * continuous querying of the oracle*.    a few days after fgg07 appeared at arxiv , cleve et al published cle07 @xcite at the same library .",
    "this short two page paper points out that one can translate the fgg07 algorithm to a counterpart algorithm .",
    "the counterpart algorithm enters the input into the quantum walk during a finite number of interruptions or queries .",
    "this alternative method of entering the input is described as a * discrete querying of the oracle*. cle07 shows that the counterpart algorithm will yield a solution to a balanced binary nand formula after @xmath5 queries , for any @xmath6 .",
    "next , chi07 @xcite , by childs et al , appeared on arxiv .",
    "chi07 proposes an fgg07-inspired , discrete - queries algorithm for evaluating arbitrary ( not necessarily balanced or binary ) nand formulas .",
    "the chi07 algorithm , like the cle07 one , requires @xmath5 queries to evaluate a nand formula .",
    "it uses a quantum walk on a tree graph , with a tail of nodes attached to the root node of the tree .",
    "in contrast , the fgg07 algorithm attaches a runway to the tree .",
    "the runway is a finite line of nodes attached at its middle node to the root node of the tree .",
    "the chi07 algorithm uses quantum phase estimation to deduce the value of the nand formula . in contrast , fgg07 uses a scattering experiment to deduce this value .",
    "next , amb07@xcite , by ambainis , appeared on arxiv .",
    "amb07 describes an fgg07-inspired , discrete - queries algorithm that can evaluate balanced binary nand formulas with @xmath7 queries .",
    "thus , the amb07 algorithm improves over cle07 and chi07 by removing the @xmath8 .",
    "amb07 also gives an algorithm that allows one to evaluate arbitrary nand formulas with @xmath9 queries .",
    "we say a unitary operator acting on a set of qubits has been compiled if it has been expressed as a seo ( sequence of elementary operations , like cnots and single qubit operations ) .",
    "seo s are often represented as quantum circuits .",
    "this paper , like cle07 , chi07 and amb07 , considers fss07-inspired algorithms with discrete querying .",
    "such algorithms use two types of unitary evolution : oracle and non - oracle .",
    "non - oracle evolutions are independent of the nand formula input , whereas oracle evolutions depend on this input .",
    "the goal of this paper is to compile these oracle and non - oracle evolutions .",
    "we present explicit seo s and their associated circuits , for these evolutions .",
    "such circuits will be required for most physical implementations of the algorithms proposed in cle07 , chi07 and amb07 , but are not given by those papers .",
    "such missing circuits constitute a large gap in our practical knowledge that this paper is intended to fill .",
    "some papers ( for example , refs.@xcite ) have previously addressed the issue of compiling quantum walks over trees and other graphs .",
    "some of these papers use oracles to encode the graph topology .",
    "our approach is different .",
    "we do not use any oracles to encode the graph topology .",
    "this paper considers only balanced binary nand trees , although i think some of the methods of this paper can be applied to more general trees .",
    "our compilation methods are based on the csd ( cosine sine decomposition)@xcite , a matrix decomposition from linear algebra .",
    "this decomposition is explained in section [ sec - csd ] . for now , suffice it to say that the cs decomposition has been used very successfully in the past to compile unstructured unitary matrices exactly .",
    "in this section , we will define some notation that is used throughout this paper . for additional information about our notation",
    ", we recommend that the reader consult ref.@xcite .",
    "ref.@xcite is a review article , written by the author of this paper , which uses the same notation as this paper .",
    "we will often use the symbol @xmath10 for the number ( @xmath11 ) of qubits and @xmath12 for the number of states with @xmath10 qubits .",
    "the quantum computing literature often uses @xmath13 for @xmath10 and @xmath14 for @xmath15 , but we will avoid this notation .",
    "we prefer to use @xmath13 for the number operator , defined below .",
    "let @xmath16 .",
    "as usual , let @xmath17 represent the set of integers ( negative and non - negative ) , real numbers , and complex numbers , respectively . for integers",
    "@xmath18 , @xmath19 such that @xmath20 , let @xmath21 .",
    "for @xmath22 equal to @xmath23 or @xmath24 , let @xmath25 and @xmath26 represent the set of positive and non - negative @xmath22 numbers , respectively .",
    "for any positive integer @xmath27 and any set @xmath28 , let @xmath29 denote the cartesian product of @xmath27 copies of @xmath28 ; i.e. , the set of all @xmath27-tuples of elements of @xmath28 .",
    "we will use @xmath30 to represent the  truth function \" ; @xmath30 equals 1 if statement @xmath28 is true and 0 if @xmath28 is false .",
    "for example , the kronecker delta function is defined by @xmath31 .",
    "let @xmath32 and @xmath33 . if @xmath34 , where @xmath35 , then @xmath36 .",
    "conversely , @xmath37 .",
    "we define the single - qubit states @xmath38 and @xmath39 by    = , = .",
    "if @xmath40 , we define the @xmath10-qubit state @xmath41 as the following tensor product    =  . for example ,    = = .    when we write a matrix , and",
    "leave some of its entries blank , those blank entries should be interpreted as zeros .",
    "@xmath42 and @xmath43 will represent the @xmath44 unit and zero matrices , respectively . for any matrix @xmath45",
    ", @xmath46 will stand for its complex conjugate , @xmath47 for its transpose , and @xmath48 for its hermitian conjugate .",
    "for any two same - sized square matrices @xmath49 and",
    "@xmath50 , we define the o - dot product @xmath51 by @xmath52 .",
    "for any matrix @xmath49 and positive integer @xmath27 , let    a^k = _ k a ,    a^k = _ k a .",
    "suppose @xmath53 and @xmath54 is any @xmath55 matrix .",
    "we define @xmath56 by    m ( ) = i_2 i_2 m i_2 i_2 , [ eq - m - beta - def ] where the matrix @xmath54 on the right hand side is located at qubit position @xmath57 in the tensor product of @xmath10 @xmath55 matrices .",
    "the numbers that label qubit positions in the tensor product increase from right to left ( @xmath58 ) , and the rightmost qubit is taken to be at position 0 .",
    "the pauli matrices are    = (    cc 0&1 + 1&0    ) , = (    cc 0&-i + i&0    ) , = (    cc 1&0 + 0&-1    ) .",
    "let @xmath59 .",
    "for any @xmath60 , let @xmath61 .",
    "the one - qubit hadamard matrix @xmath62 is defined as :    h= .",
    "the @xmath10-qubit hadamard matrix is defined as @xmath63 .    the number operator @xmath13 for a single qubit is defined by    n = = .",
    "note that    n = 0 = 0 , n = 1 .",
    "we will often use @xmath64 as shorthand for    = 1-n = = .",
    "define @xmath65 and @xmath66 by    p_0 = = = , p_1 = n = = .",
    "two other related @xmath55 matrices are    = = , = = . @xmath65 and @xmath66 are orthogonal projection operators and they add to one :    p_a p_b = ( a , b ) p_b a , bbool ,    p_0 + p_1 = i_2 .    for @xmath67 ,",
    "= p_a_-1 p_a_2 p_a_1 p_a_0 .",
    "for example , with 2 qubits we have    p_00 = p_0 p_0 = diag(1 , 0 , 0 , 0 ) ,    p_01 = p_0 p_1 = diag(0 , 1 , 0 , 0 ) ,    p_10 = p_1 p_0 = diag(0 , 0 , 1 , 0 ) ,    p_11 = p_1 p_1 = diag(0 , 0 , 0 , 1 ) .",
    "note that    p_p_= ( , ) p _ , bool^ ,    _",
    "= i_2 i_2 i_2 = i_2^ .",
    "if @xmath68 , and @xmath53 , then we will denote @xmath69 by replacing the symbol @xmath70 in @xmath71 by a dot .",
    "for example , @xmath72    next we explain our circuit diagram notation .",
    "we label single qubits ( or qubit positions ) by a greek letter or by an integer .",
    "when we use integers , the topmost qubit wire is 0 , the next one down is 1 , then 2 , etc .",
    "_ note that in our circuit diagrams , time flows from the right to the left of the diagram .",
    "_ careful : many workers in quantum computing draw their diagrams so that time flows from left to right .",
    "we eschew their convention because it forces one to reverse the order of the operators every time one wishes to convert between a circuit diagram and its algebraic equivalent in dirac notation .",
    "@xmath73 will stand for hermitian conjugate .",
    "for example , @xmath74 will denote @xmath75 , and @xmath76 $ ] will denote @xmath77 $ ] .",
    "this notation is useful when @xmath49 is a long expression that we do not wish to repeat .",
    "svd will stand for singular value decomposition .",
    "an svd of a matrix @xmath49 consists of matrices @xmath78 such that @xmath79 , where the matrices @xmath80 are unitary and @xmath81 is a non - negative diagonal matrix .",
    "we will say that this svd is ",
    "one - sided \" if one  side \" equals the identity matrix ; i.e. , if @xmath82 or @xmath83 .",
    "when we use @xmath84 for non - commuting operators @xmath85 , we mean @xmath86 , not @xmath87 or any other permutation .",
    "thus , the multiplication must be performed in the order indicated .",
    "in this section , we will review some properties of circulant matrices@xcite .",
    "these properties will be used later on , to compile the evolution operator for a random walk on a closed loop .",
    "a * circulant matrix * is any matrix of the form    c = , for @xmath88 and @xmath89 .",
    "note that each row of @xmath90 is a cyclic shift of the row above it .    if we denote the eigenvalues and eigenvectors of @xmath90 by    cv = v , then it is easy to show ( see ref.@xcite ) that the @xmath13 eigenvalues and corresponding eigenvectors of @xmath90 are given by    _",
    "m = _ k=0^n-1 c_k ( ^m)^k , v^(m ) = , = e^-i , for @xmath91 .",
    "define matrices @xmath92 and @xmath93 by    u= ( v^(0),v^(1),v^(2),,v^(n-1 ) ) , d= diag(_0,_1,_2,,_n-1 ) .",
    "then    cu= ud , c= u d u^. the matrix @xmath92 is in fact the discrete fourier transform ( dft ) matrix .    in this paper , we will consider the case that @xmath94 and all other @xmath95 are zero . in this case ,    _ m = ( ^m + ( ^m)^n-1)= ( ^m + ^-m)= 2 ( ) .      in this section",
    ", we will review the trotter rescaling of the lie and suzuki approximants of @xmath96 .",
    "more information about this topic may be found in ref.@xcite .",
    "suppose @xmath97 and @xmath98 .",
    "define l_1(t ) = e^tae^tb . in this paper",
    ", we will refer to @xmath99 as the * lie first - order approximant * of @xmath100 .",
    "we call it a first - order approximant because , for small @xmath101 , according to the baker - campbell - hausdorff expansion@xcite ,    l_1(t)=e^t(a+b ) + [ a , b ] + ( t^3 ) = e^t(a+b ) + ( t^2 ) .    but what if @xmath101 is nt small ? even when @xmath101 is not small , one can still use the lie approximant to approximate @xmath102 . indeed , if @xmath14 is a very large integer , then    l_1^n()&= & ( e^a e^b ) ^n + & = & ( e^(a+b ) + [ a , b ] + ( ) ) ^n + & = & e^t(a+b ) + [ a , b ] + ( ) + & = & e^t(a+b ) + ( ) .",
    "henceforth , will refer to this nice trick as a * trotter rescaling * of an approximant ( in this case , the lie approximant ) .",
    "see fig.[fig - trotter ] .",
    "next define s_2(t ) = e^te^tbe^t .",
    "we will refer to @xmath103 as the * suzuki second - order approximant * .",
    "one can show@xcite that for small @xmath101 :    s_2(t)=e^t(a+b ) + [ + b,[b , a ] ] + ( t^5 ) = e^t(a+b ) + ( t^3 ) .",
    "suzuki also defined higher order approximants based on @xmath103 . for @xmath104 , define the * suzuki @xmath105th - order approximant * @xmath106 by    s_2k+2(t ) = s_2k^2(a_2k t ) s_2k((1 - 4a_2k)t ) ) s_2k^2(a_2k t ) , for some @xmath107 .",
    "it is possible to show that for @xmath108 and small @xmath101 :    s_2k+2(t)= e^t(a+b ) + ( t^2k+3 ) a_2k = .",
    "@xmath109 is a monotone decreasing sequence with @xmath110 and @xmath111 .    as with the lie approximant , is possible to do a trotter rescaling of the suzuki approximants .",
    "one finds that for @xmath112 , large @xmath14 and fixed @xmath101 :    s_2k^n()= e^t(a+b ) + ( ) .    henceforth , what we have called @xmath14 so far in this section will be renamed @xmath113 , to distinguish it from all the other @xmath14 s used in this paper .",
    "the @xmath114 in @xmath113 stands for trotter , since it represents the number of trotter time slices ( trots ? ) .",
    "if we call @xmath115 the number of factors of the type @xmath116 or @xmath117 for some @xmath118 , then we can compare @xmath115 and the error for the trotterized lie and suzuki approximants is the number of exponentials in @xmath119 , then @xmath120 , @xmath121 , @xmath122 . in general , @xmath123 for @xmath124 .",
    "solving the difference equation @xmath125 with @xmath126 yields @xmath127 . finally , note that @xmath128 . ] :    [ cols=\"<,^,^\",options=\"header \" , ]     henceforth , we will say that a seo is tractable if it has @xmath129 cnots , for some @xmath130 .",
    "our plan is to combine @xmath131 and @xmath132 via trotterized suzuki .",
    "let @xmath115 be the number of times @xmath131 or @xmath132 appear in the trotterized suzuki product that approximates @xmath133 . according to eq.([eq - best - nexp ] ) , if we want to evaluate a nand formula in time @xmath134 , then    n_exp ( ( ) ^+ ) . thus    ( e^i(h_bulk+h_corr ) ) ) & = & n_exp(e^ih_bulke^ih_corr ) + & & ( ( ) ^+ ) ( e^ih_bulke^ih_corr )",
    ". if @xmath135 is tractable , then @xmath136 .",
    "[ lem - anti - d - sans - svd ] suppose @xmath137 . then    ( i ) = .",
    "note that = f + f^. [ eq - sigp - fh - sigm - f ] since @xmath138 and @xmath139 , @xmath140 .",
    "thus , when we raise the right hand side of eq.([eq - sigp - fh - sigm - f ] ) to a power , only terms proportional to an alternating sequence of @xmath141 and @xmath142 survive . for @xmath88 ,",
    "one gets    ( f + f^)^2n & = & ( ) ^n(f^f)^n + ( ) ^n(f f^)^n + & = & p_0(f^f)^n + p_1(f f^)^n , and    ( f + f^)^2n+1 & = & p_0(f^f)^n f^+ p_1(f f^)^n f + & = & ( f^f)^n f^+ ( f f^)^n f . thus    @xmath143    and    @xmath144",
    "an important special case is when @xmath147 for all @xmath146 , where @xmath148 is defined by eq.([eq - const - delta - assump ] ) .",
    "this appendix will discuss some idiosyncrasies of this special case .    when the @xmath148 are all equal , it is possible to make a slight redefinition of @xmath149 in eq.([eq - gamma - defs ] ) so that the decomposition of @xmath150 into @xmath151 given by eq.([eq - strati ] ) is good to order @xmath152 instead of @xmath153 .",
    "we show this next for @xmath154 .",
    "generalization to higher @xmath155 will be obvious .",
    "let    f = 1 + .",
    "then    e^i _ 16= _ 1^<3 > _ 2^<3 > _ 3^<3 > + ( ^4 ) , where    _ 3^<3 > = ( i ) ,    _",
    "2^<3 > = ( i f ) ,    _",
    "1^<3 > = ( i f ) ,    and    _ = _ ( ) e^i , z_1,3 .",
    "according to eq.([eq - approx - with - t1-t2 ] ) ,    @xmath156 ) \\\\ & = & \\exp(i \\left [ \\begin{array}{cc } \\cala_8 &   \\\\   & 0_8 \\end{array } \\right ] ) \\exp ( \\left [ \\begin{array}{cc } t_1 + t_2 & i\\calbbar_8\\\\ i\\calbbar_8 & -i \\frac{\\calb_8\\cala_8\\calb_8}{6 } \\end{array } \\right ] ) + \\calo(\\coco^5 ) \\;.\\end{aligned}\\ ] ]    one finds that    t_1 = i , t_2 = ( ^4 ) , and    _ 8 _ 8 _ 8 = 0 .",
    "therefore ,    @xmath157 ) \\exp(i \\left [ \\begin{array}{cc } \\frac{\\coco^2}{6}\\left [ \\begin{array}{cc } 0 & \\calb_4\\\\ \\calb_4 & 0 \\end{array } \\right ] & \\calbbar_8\\\\ \\calbbar_8 & 0_8 \\end{array } \\right ] ) + \\calo(\\coco^4 ) \\label{eq - const - dlam - proof-1 } \\\\ & = & \\exp(i \\left [ \\begin{array}{cc } \\left [ \\begin{array}{cc } \\cala_4 & f\\calb_4\\\\ f\\calb_4 & 0 \\end{array } \\right ] &   \\\\   & 0_8 \\end{array } \\right ] ) \\gamma_3^{<3 > } + \\calo(\\coco^4 ) \\label{eq - const - dlam - proof-2 } \\;.\\end{aligned}\\ ] ]    to go from eq.([eq - const - dlam - proof-1 ] ) to eq.([eq - const - dlam - proof-2 ] ) , we used @xmath158 $ ] . furthermore ,    @xmath159 &   \\\\   & 0_8 \\end{array } \\right ] ) = } \\nonumber\\\\ & = & \\exp(i \\left [ \\begin{array}{cc } \\left [ \\begin{array}{cc } \\cala_4 & \\\\ & 0_4 \\end{array } \\right ] &   \\\\   & 0_8 \\end{array } \\right ] ) \\exp(i \\left [ \\begin{array}{cc }      \\left [      \\begin{array}{cc }          \\frac{\\coco^2}{6 }          \\left [          \\begin{array}{cc }          0 & f\\calbbar_2\\\\          f\\calbbar_2 & 0          \\end{array }          \\right ]      & f\\calbbar_4\\\\      f\\calbbar_4 & 0_4      \\end{array }      \\right ] & \\\\ & 0_8 \\end{array } \\right ] ) \\\\ & = & \\gamma_1^{<3 > } \\gamma_2^{<3 > } \\;,\\end{aligned}\\ ] ]    where we used @xmath160 $ ] and @xmath161 .    another useful consequence of @xmath147 for all @xmath146 is that in this case it is easy to calculate the @xmath162 coefficients used in section [ sec - calbbar - in - braket ] .",
    "indeed , observe that in this case all non - zero entries of @xmath163 equal @xmath164 .",
    "define    b = ( ) e^i .",
    "let @xmath165 and @xmath166 denote the real and imaginary parts of @xmath19 , respectively .",
    "now we can use the following rule . in section [ sec - calbbar - in - braket ] ,",
    "in the bra - ket expansions of @xmath167 , replace , all @xmath162 that are preceded by an imaginary @xmath168 , by @xmath166 , and replace , all @xmath162 that are not preceded by an imaginary @xmath168 , by @xmath165 .",
    "for example , in the example of lemma [ lem - svd - calbbar ] , one has    _ 3 = = |b| , _ 3 = , _ 3 = ,    _ 7 = , _ 7 = , _ 7 = ,    _ 15 = , _ 15 = , _ 15 = ,    _ 31 = , _ 31 = , _ 31",
    "suppose @xmath169 for @xmath170 , and @xmath171 .",
    "suppose @xmath172 is a qubit , and @xmath173 is a vector of @xmath155 qubits , and all these @xmath174 qubits are distinct . in this appendix",
    ", we will show how to compile the oracle evolution operator    u_o = ( ) ^ _",
    "bool^ x_p _ ( ) , when @xmath175^t$ ] is banded .",
    "if we envision @xmath176 as a sequence of ones and zeros , then we will call a band of @xmath176 , any subsequence of @xmath176 consisting of adjacent terms , all of which are one .",
    "it @xmath176 contains a fixed ( @xmath155 independent ) number of bands , we will say it is banded .",
    "we will consider first the case when @xmath176 has a single front band . by this",
    "we mean that the first @xmath177 terms of @xmath176 are one , and the rest are zero .",
    "thus    = [ _ n_1 , _ -n_1]^t . define a binary vector @xmath178 and its corresponding set of binary vectors @xmath179 by    = bin(n_1 - 1 ) , s()= \\{bool^ : 0dec ( ) dec ( ) } . in the single front band case",
    ", @xmath180 reduces to :    u_o = ( ) ^_s ( ) p _ ( ) .",
    "[ eq - def - uo ] @xmath180 , in the form given by eq.([eq - def - uo ] ) , is already compiled .",
    "but the length of this compilation can be reduced significantly by reducing @xmath181 .",
    "let us consider an example first , before dealing with the general case .",
    "suppose @xmath182 and @xmath183 .",
    "although @xmath184 is a sum of 109 projection operators of the type @xmath185 where @xmath186 , it can be expressed as a sum of just six simpler projection operators :    _ s(bin(109 ) ) p_= \\ {    ll p_00 , & + + p_010 , & + + p_0110,0 & + + p_0110,10 & + + p_0110,1100 + + p_0110,1101 & ( * )    . .",
    "[ eq - proj - sum-109 ] fig.[fig - h - in ] gives a circuit diagram for eq.([eq - def - uo ] ) , assuming @xmath187 , and with @xmath184 expressed in the simplified form given by the right hand side of eq.([eq - proj - sum-109 ] ) .",
    "it s also interesting to consider an example in which @xmath188 is an even number instead of an odd one .",
    "when @xmath189 instead of 109 , we must remove the operator marked by an asterisk in eq.([eq - proj - sum-109 ] ) , and the operator marked by an asterisk in fig.[fig - h - in ] .    the pattern of the control vertices in eq.([eq - proj - sum-109 ] ) and fig.[fig - h - in ] is not hard to uncover .",
    "there is exactly one mcnot for each nonzero bit in @xmath190 .",
    "in addition , there is one  final \" mcnot with controls equal to @xmath191 .",
    "call @xmath192 the  non - final \" mcnots .",
    "there is precisely one of these for each bit @xmath193 such that the @xmath57 component of @xmath178 ( i.e. , @xmath194 ) equals one , and none when @xmath195 .",
    "@xmath192 always has control @xmath65 at bit @xmath57 . at bits @xmath196",
    ", @xmath192 has a control @xmath197 .",
    "hence , in general ,    _ s ( ) p_()= \\ {    l _ z_0,-1 ( ( ) _ , 1 ) p_0 ( ) _ z_+1 , -1 p _ ( ) _ ( )     + + p _ ( )    . .",
    "note that the number of mcnots in @xmath180 is @xmath198 .",
    "the number of cnots in each of these mcnots is @xmath198 .",
    "thus , the number of cnots in @xmath180 is @xmath199 .",
    "now suppose @xmath176 has a single band which is , however , not at the front .",
    "suppose it ranges from @xmath200 to @xmath201",
    ". then just multiply @xmath180 for a single front band up to @xmath202 times @xmath180 for a single front band up to @xmath201 .",
    "multiple bands can be handled similarly .",
    "sometimes it is possible to apply @xmath203 on individual qubits and/or apply qubit permutations to @xmath180 so as to get a new @xmath180 with fewer bands .",
    "fewer bands will lead to a shorter seo of the type proposed in this appendix .",
    "@xmath203 on individual qubits and/or qubit permutations do not increase the length of a seo if they are applied to the seo on both sides , via a @xmath51 product .",
    "the goal of this appendix is not to say something new about grover s algorithm@xcite .",
    "after all , grover s algorithm has been studied so extensively in the literature that it s almost impossible to say anything new about it .",
    "the goal of this appendix is , rather , to review how one compiles the oracle and non - oracle evolution operators associated with grover s algorithm .",
    "this will allow the reader to compare the compilation of grover s algorithm with the compilation of fgg07 presented in this paper .",
    "in grover s algorithm , one alternates between an oracle evolution operator , call it @xmath209 , and a non - oracle evolution operator , call it @xmath210 .",
    "the oracle evolution operator depends on the target state whereas the non - oracle evolution operator does not .",
    "more precisely , these two evolution operators are defined by :        in grover s algorithm , one applies @xmath211 times the product @xmath212 .",
    "a variant of this would be to apply @xmath213 times the product @xmath214 , for some @xmath215 .",
    "one can think of this variant of grover s algorithm as a trotterized lie approximation :        .",
    "[ eq - suggested - hams ] this variant of grover s algorithm is a quantum walk over a fully connected graph with @xmath15 nodes .",
    "transitions occur on this graph along edges connecting distinct nodes and also from a node back to itself .",
    "self transitions occur with strength proportional to @xmath218 for all nodes except the one representing the target state .",
    "self transitions for the target node occur with strength proportional to @xmath219 , larger than the strength for the other self transitions .",
    "transitions along the edges connecting distinct nodes occur with vanishing strength proportional to @xmath220 .    compiling the oracle evolution operator for grover",
    "s algorithm is trivial .",
    "let @xmath221 denote the @xmath10-dimensional vector of qubit positions for the @xmath10 primary qubits used in grover s algorithm , and let @xmath172 denote the qubit position of an additional ( not in @xmath221 ) ancilla qubit",
    ". then          = h^h^ .",
    "[ eq - mu - svd ] eq.([eq - mu - svd ] ) is merely the eigenvalue decomposition ( and svd ) of @xmath207 .",
    "since @xmath207 is a circulant matrix , we could have obtained eq.([eq - mu - svd ] ) from the eigenvalue decomposition of circulant matrices presented in section [ sec - circulant ] .",
    "an immediate consequence of eq.([eq - mu - svd ] ) is"
  ],
  "abstract_text": [
    "<S> we say a unitary operator acting on a set of qubits has been compiled if it has been expressed as a seo ( sequence of elementary operations , like cnots and single - qubit operations ) . </S>",
    "<S> seo s are often represented as quantum circuits . </S>",
    "<S> arxiv : quant - ph/0702144 by farhi - goldstone - gutmann has inspired a recent flurry of papers , that propose quantum algorithms for evaluating nand formulas via quantum walks over tree graphs . </S>",
    "<S> these algorithms use two types of unitary evolution : oracle and non - oracle . </S>",
    "<S> non - oracle evolutions are independent of the nand formula input , whereas oracle evolutions depend on this input . in this paper </S>",
    "<S> we compile ( i.e. , give explicit seos and their associated quantum circuits for ) the oracle and non - oracle evolution operators used in some of these nand formula evaluators . </S>",
    "<S> we consider here only the case of balanced binary nand trees . </S>",
    "<S> our compilation methods are based on the csd ( cosine sine decomposition ) , a matrix decomposition from linear algebra . </S>",
    "<S> the cs decomposition has been used very successfully in the past to compile unstructured unitary matrices exactly . </S>"
  ]
}