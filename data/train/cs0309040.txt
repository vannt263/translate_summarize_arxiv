{
  "article_text": [
    "let @xmath0 be a connected undirected graph with @xmath1 nodes and @xmath2 edges . for @xmath9 , a _",
    "@xmath3-dominating set _",
    "@xmath4 in @xmath5 is a set of nodes with the property that every node in @xmath5 is at most @xmath3 edges away from at least one of the nodes of @xmath4 .",
    "the problem of finding @xmath3-dominating sets of relatively small sizes is important in a variety of contexts , including multicast systems @xcite , the placement of servers in a computer network @xcite , the caching of replicas in database and operating systems @xcite , and message routing with sparse tables @xcite .",
    "finding a @xmath3-dominating set in @xmath5 with the least possible number of nodes is an np - hard problem @xcite , so one normally settles for a set of small size that is not necessarily optimal .",
    "in general , the small size to be sought is at most @xmath6 , since it can be argued that a @xmath3-dominating set with no more than this number of nodes always exists @xcite , and likewise that a connected graph on @xmath1 nodes necessarily exists for which every @xmath3-dominating set has at least @xmath6 nodes @xcite .    the argument for @xmath6 as an upper bound is instructive in the present context , and goes as follows @xcite .",
    "let @xmath10 be a rooted spanning tree of @xmath5 and @xmath11 a partition of its nodes such that , for @xmath12 , every node in @xmath13 is away from the root a number @xmath14 of tree edges such that @xmath15 .",
    "this partition can be constructed easily by traversing @xmath10 breadth - first from the root and assigning every new layer of nodes circularly to the sets @xmath11 .",
    "clearly , every one of these sets is a @xmath3-dominating set in @xmath5 .",
    "also , because they partition the graph s node set , and considering that @xmath16 , it must be that at least one of them has no more than @xmath6 nodes .",
    "our topic in this paper is finding a @xmath3-dominating set in @xmath5 having no more than @xmath6 nodes by means of a synchronous distributed computation on @xmath5 .",
    "the model of distributed computation that we adopt is the standard fully synchronous model @xcite . in this model ,",
    "the nodes of @xmath5 are processors that function in lockstep at the occurrence of clock pulses , and its edges are bidirectional communication channels that deliver messages between their end nodes before the clock pulse that follows the sending of the message occurs .",
    "time is measured by counting clock pulses .    the current best synchronous algorithm to find",
    "a @xmath3-dominating set in @xmath5 is from @xcite , and is henceforth referred to as algorithm kp .",
    "it proceeds in two stages : the first stage partitions @xmath5 into the trees of a rooted spanning forest @xmath17 , each having at least @xmath18 nodes and height @xmath19 ; the second stage approaches each tree @xmath20 as described earlier for the spanning tree @xmath10 and partitions its nodes into the sets @xmath21 . if @xmath22 is the number of trees in @xmath17 , then the @xmath3-dominating set output by the algorithm is @xmath23 , where @xmath24 are the trees of @xmath17 and @xmath25 is the smallest set of @xmath26 for @xmath27 . if @xmath28 is the number of nodes of @xmath20 , then @xmath29 since @xmath30 for all @xmath20 .",
    "while the second stage of algorithm kp can be easily implemented within the bounds of @xmath19 time and @xmath31 messages , its first stage is based on an arcane combination of previously developed algorithms for related problems @xcite , resulting in a time complexity of @xmath7 and a message complexity of @xmath32 .",
    "the latter , incidentally , is our best estimate of what is really involved , in terms of communication needs , in algorithm kp ",
    "such needs are thoroughly ignored in @xcite , but this message complexity seems to follow from the message complexities of the algorithm s building blocks .    in this paper , we introduce a new synchronous distributed algorithm for finding a @xmath3-dominating set of no more than @xmath6 nodes in @xmath5 . like algorithm kp",
    ", our algorithm too comprises two subsequent stages , each having the same goal as its counterpart in algorithm kp .",
    "the second stage , in particular , is exactly the same as algorithm kp s .",
    "our contribution is the introduction of a new algorithm for the partition of @xmath5 into the trees of @xmath17 .",
    "when compared to algorithm kp , our algorithm has the same complexity of @xmath7 time while improving on the message complexity , which in our case is of @xmath8 .",
    "we also find our algorithm to be conceptually simpler than algorithm kp , which can probably be attributed to the fact that it was designed from scratch with the partitioning problem in mind .",
    "while our algorithm simply generates a sequence of `` meta - graphs , '' the last of which has nodes that directly give the rooted trees of @xmath17 , algorithm kp reduces the partition problem to other related problems and then combines algorithms for those problems into building a solution to the partition problem .",
    "henceforth , we let the algorithm we introduce be called algorithm pb .    the following is how the remainder of the paper is organized .",
    "the first stage of algorithm pb is introduced in section [ alg ] and analyzed for correctness and complexity in section [ corr ] .",
    "concluding remarks are given in section [ concl ] .",
    "in this section we introduce the first stage of algorithm pb .",
    "this stage finds a rooted spanning forest @xmath17 in @xmath5 , each of whose trees has at least @xmath18 nodes and @xmath19 height , and is referred to in the sequel as partition_@xmath5 .",
    "partition_@xmath5 starts by letting the node set of @xmath5 be the node set of a directed graph @xmath33 , and proceeds from there in @xmath34 phases . for @xmath35 ,",
    "phase @xmath36 first builds the edge set of @xmath37 and then begins the transformation of @xmath37 into another directed graph , @xmath38 , by clustering the nodes of @xmath37 together to form the nodes of @xmath38 .",
    "each node of @xmath37 stands for a rooted tree in @xmath5 , and this clustering is performed in such a way that not only is each resulting node of @xmath38 also a rooted tree in @xmath5 , but one that has at least @xmath39 nodes and @xmath40 height .",
    "after completion of phase @xmath41 , the node set of @xmath42 represents the desired rooted spanning forest @xmath17 ( earlier termination is also possible , as we discuss shortly ) .",
    "if @xmath43 and @xmath44 are nodes of @xmath37 , then we say that @xmath43 and @xmath44 are _ potential neighbors _ in @xmath37 if an edge exists in @xmath5 joining some node in the rooted tree represented by @xmath43 to some node in the rooted tree represented by @xmath44 .",
    "we say that they are _ neighbors _ in @xmath37 if a directed edge exists between them .",
    "a node that has no neighbors is _",
    "isolated_. if @xmath43 and @xmath44 are neighbors in @xmath37 , then we use @xmath45 to indicate that the edge between @xmath43 and @xmath44 is directed from @xmath43 to @xmath44 . in this case , we say that @xmath43 is an _ upstream _ neighbor of @xmath44 , which in turn is an _ downstream _ neighbor of @xmath43 .",
    "partition_@xmath5 is based on manipulations of node _ identifiers _ , which we assume to be a distinct nonnegative integer for every node in @xmath5 .",
    "the identifier of node @xmath43 in @xmath37 , denoted by @xmath46 , is the identifier of the root of its tree .",
    "if a node s identifier is less than those of all its neighbors , then we call the node a _ local minimum_. if it is greater , then we call it a _ local maximum_. the following is how partition_@xmath5 works during phase @xmath36",
    ". we use @xmath47 to denote @xmath48 , where @xmath49 is repeated @xmath50 times",
    ".    * step 1 . *",
    "find the edges of @xmath37 :    1 .",
    "let each node of @xmath37 be _ inactive _ , if the height of the corresponding rooted tree is at least @xmath39 , or _",
    "active _ , otherwise .",
    "2 .   for every active node @xmath43 of @xmath37 , find the potential neighbors of @xmath43 in @xmath37 .",
    "if no potential neighbors are found for any node , then halt and exit partition_@xmath5 .",
    "3 .   for each active node @xmath43 of @xmath37 ,",
    "let @xmath44 be the active potential neighbor of @xmath43 with the least identifier .",
    "if @xmath43 has no active potential neighbors , then let @xmath44 be the ( inactive ) potential neighbor of @xmath43 having the least identifier .",
    "add @xmath45 to the edge set of @xmath37 , thus making @xmath43 and @xmath44 neighbors in @xmath37 .",
    "_ if no neighbors are found for any node in step 1b , then in reality @xmath37 has one single node that encompasses all the nodes of @xmath5 and therefore corresponds to a rooted spanning tree of @xmath5 . in this case , partition_@xmath5 terminates prematurely , that is , before completing all @xmath34 phases .",
    "_ at the end of step 1c , every active node of @xmath37 has exactly one downstream neighbor , while every inactive node has none .",
    "similarly , both active nodes whose downstream neighbor is active and inactive nodes may have between zero and some positive number of upstream neighbors .",
    "an active node whose downstream neighbor is inactive has no upstream neighbors",
    ".    * step 2 . *",
    "find the nodes of @xmath38 :    1 .",
    "if @xmath45 is an edge of @xmath37 such that @xmath43 is an active node and @xmath44 an inactive node , then combine @xmath43 into @xmath44 by creating a single node whose identifier remains @xmath51 .",
    "let @xmath52 be the set of active nodes of @xmath37 that are not isolated .",
    "2 .   for @xmath53 ,",
    "let @xmath54 be the set of upstream neighbors of @xmath43 .",
    "if @xmath55 , then let @xmath56 be the member of @xmath57 having the least identifier .",
    "for @xmath58 such that @xmath59 , check whether @xmath60 . in the affirmative case , combine @xmath44 into @xmath43 . otherwise ( i.e. , @xmath61 ) , eliminate edge @xmath62 .",
    "let @xmath52 be the set of active nodes of @xmath37 that are not isolated .",
    "3 .   for @xmath53 ,",
    "if @xmath43 is a local minimum , then combine its ( at most two ) neighbors into it and make it isolated by eliminating edges from @xmath37 appropriately . also , combine into the newly - formed node any node in @xmath52 that may have become isolated .",
    "let @xmath52 be the set of active nodes of @xmath37 that are not isolated .",
    "repeat step 2c for local maxima , then let @xmath52 be the set of active nodes of @xmath37 that are not isolated",
    ". for @xmath53 , let @xmath63 .",
    "5 .   for @xmath53 ,",
    "let @xmath64 where @xmath56 is the downstream neighbor of @xmath43 , and @xmath65 where @xmath56 is the upstream neighbor of @xmath43 .",
    "now consider the binary representations of @xmath66 , @xmath67 , and @xmath68 , and let @xmath69 be the set of positive integers @xmath70 such that @xmath66 and @xmath67 have the same bit at the @xmath70th position while @xmath67 and @xmath68 do not . likewise , let @xmath71 be the set of numbers @xmath70 such that @xmath66 and @xmath67 have different bits at the @xmath70th position while @xmath67 and @xmath68 have the same bit .",
    "assuming that position numbers increase from right to left in a binary representation , let @xmath72 be the greatest member of @xmath73 .",
    "if @xmath45 is an edge of @xmath37 such that @xmath74 , then combine @xmath43 into @xmath44 and make the resulting node isolated by eliminating edges appropriately ( if any node in @xmath52 becomes isolated because of this , then combine that node into the newly - formed node as well ) .",
    "now let @xmath52 be the set of active nodes of @xmath37 that are not isolated , then repeat steps 2c and 2d with @xmath75 s in place of @xmath76 s , and once again let @xmath52 be the set of active nodes of @xmath37 that are not isolated . if @xmath77 , then let @xmath78 for all @xmath53 and repeat step 2e .",
    "if @xmath79 , then let the set of isolated nodes of @xmath37 be the node set of @xmath38 .",
    "_ in step 2a , it is possible for more than one @xmath43 to exist for the same @xmath44 . in this case , every such @xmath43 is combined into the single resulting node of identifier @xmath51 .",
    "note that for no such @xmath43 there may exist a node @xmath56 such that @xmath80 or @xmath81 is an edge of @xmath37 .",
    "this is so , respectively , because @xmath43 has an inactive downstream neighbor and by step 1c has no active neighbors , and because @xmath44 , being inactive , has no downstream neighbors . as a consequence ,",
    "the newly - formed node is isolated in @xmath37 . at the end of step 2a ,",
    "the single downstream neighbor of every member of @xmath52 is active , and therefore also a member of @xmath52 .",
    "_ in step 2b , there may exist more than one @xmath58 such that @xmath59 and @xmath60 .",
    "every such @xmath44 gets combined into node @xmath43 . at the end of step 2b ,",
    "every member of @xmath52 has exactly one downstream neighbor and at most one upstream neighbor .",
    "that is , the members of @xmath52 are arranged into groups of nodes , each group having at most one node with no upstream neighbor and exactly one node that has the same neighbor for both upstream and downstream neighbor .",
    "except for these two - node directed cycles , such groups of nodes may be regarded as directed chains .",
    "_ at the end of step 2d , the members of @xmath52 are arranged into directed chains of nodes whose identifiers are strictly increasing or decreasing along the chains .",
    "each such chain has at least two nodes , of which exactly one has no upstream neighbor and exactly one has no downstream neighbor .",
    "_ step 2e repeatedly manipulates the node labels @xmath67 so that the finding of minima and maxima , respectively as in steps 2c and 2d , can once again be used to combine nodes in @xmath52 into isolated nodes .",
    "initially , node identifiers are used for labels , but subsequently they get replaced by integers that point into the binary representations of the labels used in the previous iteration .",
    "as the iterations progress , these integers have an ever - dwindling range : if @xmath82 identifies an iteration within step 2e , then the range of labels during iteration @xmath83 is @xmath84 . eventually , during a certain iteration @xmath85 , this range becomes @xmath86 and consequently the taking of minima and maxima as in steps 2c and 2d is guaranteed to produce an empty @xmath52 .",
    "at the beginning of each iteration , the members of @xmath52 are arranged into directed chains whose labels are strictly increasing or decreasing along the chains .",
    "each such chain has at least two nodes , of which exactly one has no upstream neighbor and exactly one has no downstream neighbor .",
    "steps 1 and 2 specify the @xmath36th phase of partition_@xmath5 as the manipulation of directed graphs , first to find the edges of @xmath37 in step 1 , then in step 2 to find the nodes of @xmath38 .",
    "of course , the realization of such operations on graphs requires communication among the nodes of @xmath37 , which ultimately translates into communication among the nodes of @xmath5 .",
    "however , the assumption of a synchronous model of distributed computation makes the communication needs of partition_@xmath5 rather straightforward to realize @xcite .    because each node in @xmath37 stands for a rooted tree in @xmath5 , steps 1 and 2",
    "can be regarded as being executed by the trees roots , which in turn coordinate the remaining nodes in their trees in carrying out the various tasks prescribed by the algorithm .",
    "for example , step 1a is a broadcast with feedback on tree edges started by the root , which sends out the upper bound of @xmath87 on the tree height for the @xmath36th phase .",
    "this is propagated by the other nodes in the tree , which send on what they receive , if nonzero , after decrementing it by one .",
    "the feedback is started by the leaves , which clearly never happens if at least one leaf is not reached by the broadcast , thus signaling to the root that the tree is oversized .",
    "in the same vein , by simply letting every node in @xmath5 that belongs to the same node @xmath43 in @xmath37 have a record of @xmath46 , finding the potential neighbors of @xmath43 in step 1b and the directed edges incident to it in @xmath37 in step 1c are also simple procedures that function by probing the connections of @xmath43 in @xmath5 .",
    "whenever an edge is deployed between two nodes in @xmath37 , a corresponding edge in @xmath5 , referred to as the _ preferred edge _ between those two nodes , can also be easily identified and recorded for later use .",
    "all the remaining actions in partition_@xmath5 can be realized via communication between the roots of two trees whose nodes in @xmath37 are connected by an edge .",
    "whenever a message needs to be sent , it can be routed on tree edges only , except to move from one tree to the other , at which time it must go through the preferred edge between the two trees .",
    "this is , for example , the basis for realizing the combination of a node into another : combining a node @xmath43 into a node @xmath44 that is connected to it by an edge in @xmath37 involves making the preferred edge between them an edge of the new tree and then propagating through @xmath43 s tree the information that a new root exists and has identifier @xmath51 .",
    "most of our correctness and complexity arguments hinge on how well step 2e succeeds in breaking directed chains of nodes in @xmath37 as needed .",
    "it is to the properties of step 2e that we turn first .",
    "[ lemma1 ] let @xmath45 be an edge at the beginning of an iteration of step 2e of partition_@xmath5 .",
    "the following holds :    1 .   if @xmath88 and @xmath89 , then @xmath90 ; 2 .",
    "if @xmath91 and @xmath92 , then @xmath90 ; 3 .   if @xmath91 and @xmath89 , then @xmath90 .    _",
    "proof : _ by steps 2a through 2e , edge @xmath45 is in a chain of nodes whose labels are either strictly increasing or strictly decreasing along the chain .",
    "suppose the former case first",
    ". then @xmath93 .    if @xmath88 , then @xmath66 and @xmath67 have the same bit at position @xmath72 while @xmath67 and @xmath94 have different bits at that same position . if @xmath89 , then @xmath67 and @xmath94 have the same bit at position @xmath95 while @xmath94 and @xmath96 have different bits at that same position .",
    "so @xmath72 and @xmath95 can not be the same position , thus proving ( i ) .",
    "if @xmath91 , then @xmath66 and @xmath67 have different bits at position @xmath72 while @xmath67 and @xmath94 have the same bit at that same position .",
    "if @xmath92 , then @xmath67 and @xmath94 have different bits at position @xmath95 while @xmath94 and @xmath96 have the same bit at that same position .",
    "so @xmath72 and @xmath95 can not be the same position , which proves ( ii ) .    we now prove ( iii ) . if @xmath91 , then @xmath66 and @xmath67 have different bits at position @xmath72 while @xmath67 and @xmath94 have the same bit at that same position .",
    "suppose these bits are @xmath97 , respectively for @xmath66 , @xmath67 , and @xmath94 .",
    "by definition of @xmath72 , at all other positions to the left of @xmath72 in the binary representations of @xmath66 , @xmath67 , @xmath94 ( that is , positions corresponding to higher powers of two ) we must have the same bit for all three labels or bits that differ from @xmath66 to @xmath67 and also from @xmath67 to @xmath94 .",
    "in other words , the only possibilities are @xmath98 , @xmath99 , @xmath100 , and @xmath101 .",
    "but these possibilities have all the same bit for @xmath66 and @xmath94 , which contradicts the fact that @xmath102 . then the bits for @xmath66 , @xmath67 , and @xmath94 at position @xmath72 must be @xmath103 .    if @xmath74 , then the bits of @xmath67 and @xmath94 are both @xmath104 at position @xmath95 , which is in agreement with the definition of @xmath105 . by this same definition , at position @xmath95 the bit of @xmath96 must be @xmath106 . to the left of @xmath95 , the possibilities for @xmath67 , @xmath94 , @xmath96 are @xmath98 , @xmath99 , @xmath100 , and @xmath101 , again following the definition of @xmath95 .",
    "this implies the same bit for @xmath67 and @xmath96 at all those positions , which like before contradicts the fact that @xmath107 .",
    "so @xmath90 .",
    "if @xmath45 is in a chain of nodes whose labels are strictly decreasing along the chain , then @xmath108 . in this case , the arguments that prove ( i ) and ( ii ) remain unchanged , while in the proof of ( iii ) it suffices to complement every bit in the triples we displayed ( this leads to contradictions of @xmath109 and @xmath110 ) .",
    "@xmath111    [ lemma2 ] let @xmath45 be an edge at the beginning of an iteration of step 2e of partition_@xmath5 . if @xmath74 , then @xmath88 and @xmath92 .",
    "_ proof : _ if @xmath91 with either @xmath92 or @xmath89 , then by lemma [ lemma1 ] , parts ( ii ) and ( iii ) , @xmath90 . if @xmath88 and @xmath89 , then by lemma [ lemma1 ] , part ( i ) , @xmath90 .",
    "thence the lemma .",
    "@xmath111    [ lemma3 ]",
    "let @xmath112 be part of a chain at the beginning of an iteration of step 2e of partition_@xmath5 .",
    "if @xmath74 , then @xmath113 .",
    "_ proof : _ by lemma [ lemma2 ] , @xmath88 and @xmath92 . by lemma [ lemma1 ] , parts ( ii ) and ( iii ) , @xmath113 .",
    "@xmath111    now let @xmath114 be the last phase of partition_@xmath5 in which premature termination in step 1b does not occur .",
    "then @xmath115 and we have the following .    [ lemma4 ] for @xmath116 , every node of @xmath38 that is not an inactive node of @xmath37 is formed by the combination of at least two nodes of @xmath37 .",
    "_ proof : _ by step 2e , the node set of @xmath38 is the set of isolated nodes in @xmath37 at the end of step 2 .",
    "the lemma follows easily from the fact that every isolated node produced during step 2 ( that is , isolated nodes that are not inactive during phase @xmath36 ) result from the combination of at least two nodes of @xmath37 . @xmath111    we are now in position to demonstrate that partition_@xmath5 does indeed achieve its goals .",
    "[ theorem5 ] for @xmath117 , the nodes of @xmath37 form a rooted spanning forest of @xmath5 .",
    "each tree in this forest has at least @xmath118 nodes and @xmath119 height .",
    "_ proof : _ the theorem holds trivially for @xmath120 , and we prove it inductively for @xmath121 with @xmath122 .",
    "the induction hypothesis is that the nodes of @xmath37 form a rooted spanning forest of @xmath5 , each of whose trees having at least @xmath118 nodes and @xmath119 height .    in order to show that the nodes of @xmath38 do indeed",
    "form a rooted spanning forest of @xmath5 , by the induction hypothesis it suffices to argue that the set @xmath52 is empty at the end of phase @xmath36 .",
    "the reason for this is that it is the set of isolated nodes at the end of phase @xmath36 that we take to be the node set of @xmath38 , and that @xmath79 indicates that every node in @xmath5 is part of the tree represented by some isolated node . but this follows directly from the fact that the range of labels during step 2e decreases steadily as the iterations progress .",
    "eventually , this range becomes such that every label is either @xmath106 or @xmath104 , at which time the finding of minima and maxima makes @xmath52 empty .",
    "having shown this , we consider the number of nodes and height of each of the trees in the node set of @xmath38 .",
    "a node of @xmath38 is either an inactive node of @xmath37 or results , by lemma [ lemma4 ] , from the combination of at least two nodes of @xmath37 . in the former case , by step 1a",
    "the node corresponds to a rooted tree in @xmath5 with at least @xmath39 nodes . in the latter case , by the induction hypothesis",
    ", it corresponds to a rooted tree in @xmath5 with at least @xmath123 nodes for @xmath124 , that is , at least @xmath39 nodes .    as for the height , we reason similarly .",
    "if a node in @xmath38 is an inactive node of @xmath37 , then its height is , by the induction hypothesis , @xmath119 , which in turn is @xmath40 .",
    "if it is a combination of at least two nodes of @xmath37 , then either this combination takes place in one of steps 2a through 2d or in step 2e . in the former case , the combination",
    "is either performed over a single edge ( steps 2a and 2b ) , or it is performed over a chain of at most six edges ( first in step 2c , then in step 2d ) . in either case , the induction hypothesis leads to a height of @xmath123 for @xmath125 a constant , which is @xmath40 .",
    "the case of step 2e is entirely analogous , since by lemma [ lemma3 ] it is either performed over a single edge , or else by the taking of minima and maxima , as in steps 2c and 2d .",
    "@xmath111    [ corollary6 ] the nodes of @xmath126 form a rooted spanning forest of @xmath5 , and in this forest each tree has at least @xmath18 nodes and @xmath19 height .    _ proof : _ if partition_@xmath5 terminates in step 1b of some phase , then @xmath127 and the corollary holds , because @xmath128 has in this case one single node encompassing all the @xmath16 nodes of @xmath5 , and furthermore the height of the tree that corresponds to this single node is by theorem [ theorem5 ] @xmath129 , which is @xmath19 . if partition_@xmath5 runs through all the phases , then @xmath130 and the corollary follows directly from theorem [ theorem5 ] with @xmath131 .",
    "@xmath111    we now finalize the section by discussing the time and number of messages needed by partition_@xmath5 and by algorithm pb as a whole .",
    "[ theorem7 ] partition_@xmath5 requires @xmath7 time and @xmath8 messages to complete .    _",
    "proof : _ during the @xmath36th phase , @xmath132 , each of steps 1a through 2d requires a constant number of communication `` rounds , '' each in turn requiring a number of time units proportional to the height of a rooted tree in that phase , which by theorem [ theorem5 ] is @xmath119 .",
    "the same holds for each of the iterations of step 2e , of which there are at most @xmath133 . then the time",
    "required for partition_@xmath5 to complete grows with @xmath134 so partition_@xmath5 requires @xmath7 time .",
    "the number of messages that partition_@xmath5 requires can be estimated likewise for phase @xmath36 , as follows .",
    "the number of messages sent during step 1 is dominated by step 1b to determine the potential neighbors in @xmath5 of a node in @xmath37 , which requires @xmath135 messages .",
    "steps 2a and 2b require @xmath31 messages , which is the total number of tree edges , because several nodes may be combined into the same node during those steps .",
    "however , each of the @xmath136 communication `` rounds '' in steps 2c through 2e is more economical , because the chain structure of @xmath37 in those steps allows communication to take place along single paths from the trees roots , and so the number of messages flowing in each rooted tree is proportional to its height , which during phase @xmath36 is @xmath119 by theorem [ theorem5 ] . also by theorem [ theorem5 ] , each rooted tree in @xmath37 has at least @xmath118 nodes , so there are at most @xmath137 rooted trees in @xmath37 .",
    "it follows that the number of messages required by partition_@xmath5 for completion grows with @xmath138 so partition_@xmath5 requires @xmath8 messages .",
    "@xmath111    [ corollary8 ]",
    "algorithm pb requires @xmath7 time and @xmath8 messages to complete .",
    "_ proof : _ immediate from theorem [ theorem7 ] , considering that the algorithm s second stage requires @xmath19 time and @xmath31 messages .",
    "we have considered the problem of finding a @xmath3-dominating set with no more than @xmath6 nodes in @xmath5 , and given a new synchronous distributed algorithm to solve it in @xmath7 time while requiring @xmath8 messages .",
    "our algorithm follows the same overall strategy of @xcite , according to which first a rooted spanning forest is found in @xmath5 with certain characteristics , and then the desired @xmath3-dominating set on that forest .",
    "our algorithm introduces a new approach to finding the rooted spanning forest , which we think is conceptually simpler than the one of @xcite , and shares with the algorithm of @xcite the additional computation that is required to find the @xmath3-dominating set . in both algorithms ,",
    "the overall complexity is dominated by the forest - finding stage .",
    "both have the same time complexity , but ours has better message complexity ."
  ],
  "abstract_text": [
    "<S> we consider a connected undirected graph @xmath0 with @xmath1 nodes and @xmath2 edges . a @xmath3-dominating set @xmath4 in @xmath5 is a set of nodes having the property that every node in @xmath5 is at most @xmath3 edges away from at least one node in @xmath4 . finding a @xmath3-dominating set of minimum size is np - hard . </S>",
    "<S> we give a new synchronous distributed algorithm to find a @xmath3-dominating set in @xmath5 of size no greater than @xmath6 . </S>",
    "<S> our algorithm requires @xmath7 time and @xmath8 messages to run . </S>",
    "<S> it has the same time complexity as the best currently known algorithm , but improves on that algorithm s message complexity and is , in addition , conceptually simpler .    </S>",
    "<S> @xmath3-dominating sets , distributed algorithms , graph algorithms </S>"
  ]
}