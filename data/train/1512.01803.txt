{
  "article_text": [
    "floating point arithmetic is based on the idea that at each step of a computation , a number is rounded to a prescribed precision , which in standard ieee arithmetic is 53 bits or about 16 digits  @xcite . by rounding at every step in this fashion ,",
    "one eliminates the combinatorial explosion of the lengths of numerators and denominators that would occur in exact rational arithmetic : all numbers are represented to the same relative accuracy and require the same storage .",
    "it is ultimately for this reason that virtually all computational science is carried out in floating point arithmetic .",
    "chebfun and other related software systems that have arisen in the past fifteen years are based on implementing an analogous principle for functions as opposed to numbers  @xcite .",
    "if @xmath2 is a lipschitz continuous function on @xmath3 $ ] , it has a uniformly and absolutely convergent chebyshev series @xmath4 where @xmath5 denotes the degree @xmath6 chebyshev polynomial , with @xmath7 changed to @xmath8 in the case of the coefficient @xmath9  @xcite .",
    "if @xmath2 has several derivatives of smoothness or better , the series typically converges to 16-digit accuracy after tens or hundreds of terms , making computation with functions in this form eminently practical when carried out with stable and efficient algorithms , including solution of problems such as rootfinding , integration , differentiation , minimization , and maximization .",
    "piecewise - smooth functions can be represented by concatenating such representations , with intervals and subintervals @xmath1 $ ] other than @xmath3 $ ] handled by the obvious linear change of variables applied to ( [ series ] ) .",
    "for example , consider the function @xmath10 , \\label{examplefun}\\ ] ] which is @xmath11 but not analytic . in chebfun , in @xmath12 secs .  on a typical 2015 desktop computer , the following commands plot @xmath2 and determine its zeros and maximum value in @xmath3 $ ] .",
    "the plot appears in figure  [ functionf ] .    ....",
    "> > f = chebfun(@(x ) 3*exp(-1./(x+1))-(x+1 ) ) ; > >",
    "plot(f ) > >",
    "roots(f )     ans =       -1.000000000000000",
    "-0.338683188672833        0.615348950784159 > > max(f )     ans = 0.108671573231256 ....    above , the function @xmath2 of ( [ examplefun ] ) represented in chebfun by a polynomial of degree @xmath13 .",
    "below , the error at @xmath14 equally spaced points in @xmath3$].,title=\"fig:\",width=329 ]   +  above , the function @xmath2 of ( [ examplefun ] ) represented in chebfun by a polynomial of degree @xmath13 .",
    "below , the error at @xmath14 equally spaced points in @xmath3$].,title=\"fig:\",width=302 ]    -1.5em    figure  [ functionf ] also shows the error in the chebfun approximation to this function at @xmath14 equally spaced points in @xmath3 $ ] .",
    "evidently the approximation has about 15 digits of accuracy relative to the global scale of @xmath2 .",
    "chebfun represents @xmath2 by a polynomial of degree 165 , which corresponds to a polynomial interpolant on a 166-point grid :    .... > >",
    "length(f )     ans = 166 ....    this function representation is called a _ chebfun _ ( with a lower - case _ c _ ) .",
    "figure  [ functionfcoeffs ] shows the absolute values of the chebyshev coefficients @xmath15 on a log scale .",
    "this paper is about how representations like this are determined , not only when a chebfun like @xmath2 is constructed from scratch , but as further operations on chebfuns are carried out such as @xmath16 , @xmath17 , @xmath18 , @xmath19 , and so on .",
    "( for the last of these , poles are introduced at the zeros of @xmath2 and the new function is represented by a chebfun with three smooth pieces , each of which is called a _",
    "fun_. ) the same algorithm is applied for solution of ordinary differential equation boundary - value problems ( ode bvps ) via chebyshev spectral collocation ( section  8) .",
    "the core of the chebfun construction process is sampling a function on successively finer grids . in its standard mode of operation ,",
    "the constructor samples a function on chebyshev grids with @xmath20 points , computing the chebyshev coefficients of the polynomials of degrees @xmath21 in sequence that interpolate the data on each grid .",
    "( the @xmath22-point chebyshev grid consists of the points @xmath23 @xmath24 . )",
    "when coefficients fall to the level of machine precision , the refinement stops and the series is chopped . figure  [ seriesfig ] shows how this process plays out for this function @xmath2 .",
    "grids of 17 , 33 , 65 , and 129 points are tried first , and then on the grid of 257 points , the chebyshev coefficients reach a plateau at a level close to machine precision .",
    "this corresponds to a chebyshev series of degreee 256 , which the constructor then chops to degree 165 .",
    "chebyshev coefficients @xmath25 for the chebfun representation of @xmath2.,width=312 ]    -1.5em    chebfun construction process for the function @xmath2 of @xmath26 .",
    "the grid is refined repeatedly until a plateau of rounding errors near the level of machine precision is detected , and then the series is chopped at the beginning of the plateau to give the result shown in figure  @xmath27.,width=288 ]    -1em    a simple way for a user to see where chebfun has chopped a series is to call plotcoeffs after constructing a function both in the usual way and with the ` ' doublelength ' ` flag , which constructs it with twice the adaptively selected degree .",
    "for example , figure  [ doublelength ] plots such results for the function @xmath28 based on the commands    .... > > ff = @(x ) exp(sin(pi*x ) ) ; > > f = chebfun(ff ) ; plotcoeffs(f , ' . ' ) > > f2 = chebfun(ff,'doublelength ' ) ; plotcoeffs(f2 , ' . ' ) ....    the doublelength flag constructs a chebfun of twice the adaptively determined degree .",
    "combining this with plotcoeffs provides a simple way for users to see how chebfun has chosen to represent a function .",
    "( a ) : plotcoeffs(chebfun(ff ) ) .",
    "( b ) : plotcoeffs(chebfun(ff,doublelength ) ) . ]",
    "-1em    in brief , then , this paper is about the design of an automated procedure for getting from figure  [ seriesfig ] to figure  [ functionfcoeffs ] .",
    "it is based on more than a decade of experience during which millions of chebfuns have been constructed by ourselves and other chebfun users around the world .",
    "this experience has shown that there are surprisingly many challenges along the way to making this straightforward - seeming construction process fully reliable .",
    "to begin , we mention a simplifying assumption that applies throughout our work .",
    "this is that chopping decisions are made entirely on the basis of chebyshev coefficients , not function values . loosely speaking ,",
    "we have chosen to regard the task of getting from figure  [ seriesfig ] to figure  [ functionfcoeffs ] as the `` whole problem '' of chebfun construction .",
    "this construction in coefficient space is not the only way in which the problem might have been approached . in principle",
    ", one might decide how fine a grid is needed by constructing an approximation on one grid and then evaluating it at off - grid points .",
    "mathematically , this could lead to interesting questions associated with pointwise accuracy of approximations and expansions . on the other hand",
    ", many off - grid points would have to be tested for reliability .",
    "we would not claim that constructing functions via coefficients is the only reasonable approach , but for better or worse , this is the route chebfun has followed from the beginning .",
    "one of the benefits of this approach is that the human eye , looking at plots like figures  [ functionfcoeffs ] and  [ seriesfig ] , can help judge how well an algorithm is working  and section  5 of this paper is built around such plots .",
    "there is one place where the principle of coefficients - only construction is broken . after a candidate chebfun",
    "is constructed , to confirm that it is valid , chebfun executes a code called sampletest that samples the chebfun at two arbitrary points in the interval of definition to make sure it matches the function being constructed .",
    "the idea here is to catch the case in which the function being sampled contains an isolated high - order chebyshev polynomial component that aliases to a low - order one on chebyshev grids .",
    "for example , the chebyshev polynomial @xmath29 takes the value @xmath30 at every point of the chebyshev grids with 17 , 33 , and 65 points , so a pure coefficient - based construction process would confuse this function with the constant @xmath30 . for this function",
    ", chebfun gets the right answer since sampletest duly fails for the candidate chebfuns constructed on each of the grids just mentioned , until finally the correct chebfun is identified on the grid of 129 points .    ....",
    "> > length(chebfun(@(x ) cos(128*acos(x ) ) ) )     ans = 129 ....    of course , in principle a function might arise that outwits sampletest , but we have never seen this happen .",
    "the possibility of being fooled by special data has been familiar to numerical analysts since the 1960s , when de boor , lyness and others pointed out that adaptive quadrature routines can always be fooled by an integrand that happens to take , say , the value  0 at every sample point  @xcite .",
    ", by the use of randomized tests",
    ". however , chebfun avoids randomization , because it is too disturbing to users if results are occasionally unrepeatable , even if the differences involve unimportant choices at the level of machine precision . ]",
    "following the principle of floating - point arithmetic , all algorithmic decisions in chebfun are based on relative quantities .",
    "thus , for example , @xmath31 and @xmath32 are represented by polynomials of exactly the same degree 165 as @xmath2 itself :    .... > > length(chebfun('2.^(500)*(3*exp(-1./(x+1))-(x+1 ) ) ' ) )     ans = 166 > > length(chebfun('2.^(-500)*(3*exp(-1./(x+1))-(x+1 ) ) ' ) )     ans = 166 ....    a further check of coefficients confirms that they are exactly the same in all three cases apart from factors of @xmath33 . to achieve scale - invariance",
    ", chebfun makes decisions about chopping a sequence of coefficients relative to the largest coefficient in absolute value .",
    "scale - related irregularities will not arise unless a function nears the overflow or underflow limits around @xmath34 .",
    "a different question is what relative accuracy to seek in constructing functions numerically .",
    "chebfun s design makes use of a user - adjustable eps parameter that determines convergence , which is set by default to machine epsilon , @xmath35 . for most chebfun calculations ,",
    "we have long recommended that users leave eps at this value rather than increasing it in the hope of a speedup .",
    "the reason is that chebfun usually manages to exploit the piecewise smoothness of functions , so that halving the accuracy requirement from 16 to 8 digits , say , would typically at best halve the total cost .",
    "we are motivated by the analogy with floating - point arithmetic , where the consensus of decades of scientific computing is that it is usually best to work in a fixed relatively fine precision rather than try to make savings by fine - tuning the precision .",
    "there are two contexts in which it may most often be desirable to loosen eps in chebfun calculations .",
    "one is in solving differential equations , where the work may scale worse than linearly as the grid is refined in search of greater accuracy  and , moreover , matrices may arise whose ill - conditioning forces the loss of some digits in any case . as we shall describe in section  8 ,",
    "chebfun by default loosens eps to about @xmath36 for ode bvps and ivps .",
    "the other is in working with noisy data .",
    "if one is constructing functions from data only accurate to six digits , say , then it will probably be important to set eps to a number on the order of @xmath37 .",
    "for example , here is a construction of a chebfun for the function @xmath2 of ( [ examplefun ] ) with precision @xmath37 instead of the default value .",
    "the degree of the chebfun reduces from @xmath13 to @xmath38 , and @xmath39 is now accurate to 7 digits .",
    "figure  [ fig1e8 ] shows the chebyshev coefficients . a plot of the function itself looks indistinguishable from figure  [ functionf]a .",
    "> > f = chebfun(@(x ) 3*exp(-1./(x+1))-(x+1 ) , ' eps ' , 1e-6 ) ; > >",
    "length(f )     ans = 51 > > max(f )     ans = 0.108671567726459 ....    further examples of loosening of eps are presented in section  5 ( figure  [ fig9 ] ) .",
    "chebyshev coefficients @xmath25 for the chebfun representation of @xmath2 constructed with @xmath40 .",
    "compare figure  @xmath27 , based on the default precision.,width=326 ]    -1.5em",
    "we now present the algorithm implemented in the chebfun code standardchop , introduced in version 5.3 in november 2015 .",
    "some of aims in the design of this algorithm have been these :    1 .",
    "be simple enough to explain to people ( and ourselves ! ) .",
    "2 .   be simple enough to reason about mathematically .",
    "3 .   in particular , have as few input and output parameters as possible .",
    "4 .   unify diverse algorithms previously applied in various corners of chebfun ( ode bvps , ode ivps , `` trigfuns '' for periodic functions , 2d functions@xmath41 ) .",
    "5 .   maintain accuracy as close as possible to 16 digits , or 10 digits for odes ( by default ) .",
    ".   nevertheless , detect plateaus of rounding errors at a slightly higher level if necessary and chop accordingly . 7 .   at the same time , get an extra digit or two when this is cheap . 8 .",
    "adjust in a systematic way to user - specified looser tolerances , e.g.  for computing with functions contaminated by noise .",
    "do nt examine too many more coefficients than are eventually kept .",
    "get the right answer when the function really is a low - degree polynomial .",
    "avoid anomalies where chebfun makes an `` obviously wrong '' chop .    for full details about standardchop , see the code listing ( which includes careful comments ) in the appendix .",
    "we do not claim that this algorithm is optimal , merely that it is a good candidate in a complex situation .",
    "indeed , the larger purpose of this article is not so much to advocate a particular algorithm as to delineate some of the surprisingly many considerations that arise in trying to generalize the notion of floating point arithmetic from numbers to functions . in the remaining sections ,",
    "the motivation for the design of standardchop will be further explained via many examples .",
    "standardchop takes two inputs , a real or complex number sequence coeffs of length @xmath42 , and a relative tolerance @xmath43 , which is normally set equal to chebfun s general tolerance eps .",
    "it produces one output : an integer @xmath44 $ ] . if @xmath45 , the constructor is `` happy '' and coeffs should be chopped to length cutoff .",
    "if @xmath46 , the constructor is `` unhappy '' and a longer coefficient sequence is needed .",
    "note that matlab s convention of beginning indexing at 1 rather than  0 is a potential source of confusion .",
    "the sequence coeffs is indexed from 1 to @xmath47 , so the description below is framed in those terms . in the standard application",
    "this will correspond to a chebyshev series with coefficients from degree @xmath48 to @xmath49 , and the final index cutoff to be retained will correspond to degree @xmath50 .",
    "standardchop proceeds in three steps .",
    "_ step @xmath30 .",
    "compute the upper envelope of coeffs and normalize . _",
    "the input sequence coeffs is replaced by the nonnegative , monotonically nonincreasing sequence @xmath51 .",
    "( note that the use of the absolute value makes the chopping algorithm applicable to complex functions as well as real ones . )",
    "if @xmath52 , this sequence is then normalized by division by @xmath53 to give a nonnegative , monotonically nonincreasing sequence whose first element is @xmath30 .",
    "the output of standardchop will depend only on envelope , so this first step entails a substantive algorithmic decision : to assess a sequence only on its rate of decay , ignoring any oscillations along the way .",
    "_ step @xmath54 .",
    "search for a plateau . _",
    "the algorithm now searches for a sufficiently long , sufficiently flat plateau of sufficiently small coefficients .",
    "if no such plateau is found , the construction process is unhappy : cutoff is set to @xmath47 and the algorithm terminates",
    ". a plateau can be as high as @xmath55 if it is perfectly flat but need not be flat at all if it is as low as @xmath56 .",
    "precisely , a plateau is defined as a stretch of coefficients @xmath57 with @xmath58 and @xmath59 with the property @xmath60 the integer plateaupoint is set to @xmath61 , where @xmath62 is the first point that satisfies these conditions .",
    "_ step @xmath63 .",
    "chop the sequence near the beginning of the plateau . _",
    "having identified an index plateaupoint that is followed by a plateau , one might think that the code would simply set @xmath64 and terminate .",
    "such a procedure works well most of the time .",
    "however , exploring its application to hundreds of functions reveals some examples where plateaupoint does nt catch the true `` elbow '' of the envelope curve .",
    "sometimes , it is clear to the eye that a little more accuracy could be achieved at low cost by extending the sequence a little further ( algorithmic aim  7 in the list of the last section ) .",
    "other times , if a plateau is detected just below the highest allowed level @xmath55 , it is clear to the eye that the plateau actually begins at an earlier point slightly higher than @xmath55 . to adjust for these cases , step  3 sets cutoff not simply to plateaupoint , but to the index just before the lowest point of the envelope curve as measured against a straight line on a log scale titled downward with a slope corresponding to a decrease over the range by the factor @xmath65 .",
    "figure  [ stepsfig ] gives the idea , and for precise details , see the code listing in the appendix .",
    "sketch of the chebfun construction process for @xmath66 .",
    "( a ) after rejecting the @xmath67- , @xmath68- , and @xmath69-point chebyshev grids , chebfun computes coefficients on the @xmath70-point grid .",
    "( b ) in step 1 of standardchop , the monotonically nonincreasing normalized envelope of the coefficients is constructed , and the plateau is found to be long , low , and level enough for chopping .",
    "step 2 picks @xmath71 as the last point before the plateau , marked by a triangle at position 70 on the axis ( since the corresponding degree is  70 ) .",
    "( c ) step 3 finds the lowest coefficient relative to a line tilted slightly downward , giving @xmath72 , marked by a circle at position 74 .  for this function",
    "the net effect of extending the series through @xmath73 rather than @xmath74 is an improvement in accuracy by about one bit . ]",
    "we now present four figures each containing four plots , for a total of sixteen examples selected to illustrate various issues of chebfun construction .",
    "we present these in the context of chebfuns constructed from scratch , as in the example ` f = chebfun(@(x ) exp(x)./(1+x.^2 ) ) ` , but approximately the same results would arise in computation with functions as in ` x = chebfun(@(x ) x ) ` , ` f = exp(x)./(1+x.^2 ) ` , as discussed in section  8 . in each case",
    "we use the default interval @xmath3 $ ] .",
    "( a ) treatment of a polynomial .",
    "( b ) capturing a small - magnitude component .",
    "( c ) a non - polynomial function .",
    "( d ) scale - invariance.,width=432 ]    .2 in    each example is presented in the same format , as two sequences of chebyshev coefficients @xmath25 superimposed on a log scale .",
    "the open circles show the coefficients of the chebfun as finally constructed .",
    "the solid dots show the coefficients from the grid of @xmath75 points on which the constructor has decided it is `` happy '' .",
    "thus the sequence of solid dots is chopped to obtain the final sequence of open circles .",
    "the standardchop indices cutoff and plateaupoint can be identified in these figures .",
    "the final circle marks @xmath50 , the highest degree of the chebfun finally constructed .",
    "the triangle plotted on the bottom axis marks @xmath76 , the point just before the beginning of the plateau that was detected .",
    "often these two points are the same , indicating that step 3 of standardchop has had no effect . in several cases",
    "@xmath77 is slightly greater than @xmath78 , indicating that step 3 has detected that a little more accuracy can be attained at low cost , as in figure  [ stepsfig ] ( algorithmic aim  7 in the list of section  4 ) . in two cases ,",
    "@xmath77 is much smaller than @xmath78 , indicating that , given that the series is to be chopped , it is more cost - effective to chop it earlier ( algorithmic aim  11 ) .",
    "( a ) a little noise leads to earlier chopping .",
    "( b ) this short stretch of small coefficients is not treated as a plateau .",
    "( c ) this longer stretch is treated as a plateau .",
    "( d ) with higher amplitude , again it is not a plateau.,width=432 ]    the mention of the term `` cost - effective '' highlights the fact that throughout this design process , choices of strategies and parameters have been made that are somewhat arbitrary .",
    "how many coefficients that `` look like a noise plateau '' should be sampled before the system decides to look no further ? if coefficients have fallen close to the ideal tolerance but it appears far more would be needed to reach it , where should the series be chopped ? can the eye be trusted if it judges that a chopping point is `` obviously wrong '' ?",
    "standardchop embodies answers to such questions , and the examples of this section have been chosen to illustrate how these choices play out in practice .",
    "we hope we have struck a good balance of accuracy , efficiency , and avoidance of disturbing anomalies .",
    "we begin with examples [ fig6]a and [ fig6]b , selected to remind us that chebfun must deal effectively with functions that are actually low - degree polynomials ( algorithmic aim  10 ) . usually there will be a high cliff between the coefficients to be retained and those to be discarded , as with @xmath79 .",
    "sometimes , however , the cliff will be not so high , as with @xmath80 , and here the constructor must make a decision .",
    "if @xmath81 is changed to @xmath82 in figure [ fig6]b , it makes the other decision and chops the series after degree @xmath54 .",
    "( with the in - between value @xmath83 , not shown , it keeps the @xmath84 coefficient but discards the slightly smaller @xmath85 one . )",
    "examples [ fig6]c and [ fig6]d begin the exploration of the more usual case , functions that are not polynomials but will be approximated by polynomials .",
    "example [ fig6]c is the most basic function of all , @xmath86 , and example [ fig6]d divides this by @xmath87 to illustrate exact binary scale - invariance .",
    "( a ) sampletest catches the @xmath88 component .",
    "( b ) some series grow exponentially before decaying .",
    "( c ) when convergence is slow , chebfun balances cost and benefit and chops before reaching the target tolerance .",
    "( d ) here @xmath89 but @xmath90.,width=432 ]    example [ fig7]a repeats @xmath91 , but with a little noise added in the form of a term @xmath92 , raising the level of the plateau . here the flexibility of the constructor leads to a chop one term earlier than before ( algorithmic aim  6 )",
    ". examples [ fig7]b[fig7]d explore the engineering choices involved in the design of the plateau detector . in example",
    "[ fig7]b , a short plateau at level @xmath93 is not long enough to count , and the constructor insists on going further .",
    "the longer quite flat plateau at the same level in example [ fig7]c , on the other hand , is accepted for chopping , a consequence of algorithmic aim  9 .",
    "example [ fig7]d shows that raising the magnitude by one further factor of @xmath94 is enough for chebfun once again not to accept it as a plateau ( algorithmic aim  5 ) .",
    "example [ fig8]a illustrates how sampletest can catch a component that otherwise might have been missed because of aliasing .",
    "example [ fig8]b shows that the scale of a function may be determined by chebyshev coefficients far from the beginning of the series .",
    "this example also illustrates chebfun s treatment of complex functions . in example",
    "[ fig8]c the series converges very slowly , and step  3 of standardchop leads to a reduction of cutoff well below plateaupoint , the rationale being that the last 500 coefficients have not brought enough improvement to be worth the cost .",
    "( to force higher accuracy , one could specify the length of the chebfun explicitly . )",
    "example [ fig8]d also has @xmath95 , but here it is a matter of avoiding a chopping point that would have been `` obviously wrong '' ( algorithmic aim 11 ) .",
    "the examples of figure  [ fig9 ] explore the treatment of noise ( algorithmic aim  8) .",
    "example [ fig9]a involves a function with too much noise ; standardchop is never happy on any grid , and chebfun issues a warning message after attempting the default maximum grid size of @xmath96 .",
    "example [ fig9]b shows the different result achieved if eps is increased to @xmath97 .",
    "examples [ fig9]c and [ fig9]d are a similar pair , except now , the noise is introduced not explicitly by randn but implicitly via cancellation error in the computation of a function with a removable singularity at @xmath98 .    ( a ) explicit noise prevents convergence .",
    "( b ) convergence achieved with @xmath99 .",
    "( c ) noise from cancellation error prevents convergence .",
    "( d ) convergence achieved with @xmath100.,width=432 ]",
    "the name standardchop comes from an idea of long standing in the chebfun project , that a user may wish to apply different chopping strategies in different contexts .",
    "sometimes one might want to insist on finding coefficients beneath a specified tolerance : a _ `` strict '' _ chopping rule .",
    "sometimes one might wish to seek a plateau of noise or rounding errors without any a priori notion whatever about how high this might be : a _ `` loose '' _ chopping rule .",
    "our presumption has been that most of the time , one would wish to operate in an in - between , _",
    "`` standard '' _ mode , where the algorithm has an a priori notion of eps but applies it with some flexibility . in standardchop , as we have described , the series ultimately accepted will normally stop somewhere between @xmath101 and @xmath102 .    before the release of version 5.3 , chebfun offered strict and standard ( = `` classic '' ) construction modes , with the latter as the default .",
    "the strict mode got almost no use , however , and a loose mode was not implemented .",
    "the new standardchop has now replaced `` classic '' as the default .",
    "up to now , we have written as if all chebfun does is construct polynomial approximations from strings or anonymous functions .",
    "but if this were the case , there would be no need for it!the job could be done better with symbolic computing .",
    "the point of a system like this is not just construction of functions from scratch , but numerical computation with functions , which necessitates ongoing use of the construction process at each step .",
    "most of the time , chebfun follows this prescription exactly . if a chebfun is operated on by an operation like exp(f ) , or if two chebfuns are combined by an operation like f./g , the usual process consists of using the existing representations of f and g to compute sample values on grids of size @xmath103 and apply standardchop as usual to construct the new result .",
    "this description applies both for classic nonperiodic chebfuns , represented by chebyshev series , and the more recently introduced periodic chebfuns , as discussed in the next section .",
    "some mathematical operations , on the other hand , can ( or must ) be carried out without going through this construction process .",
    "the simplest example is the unary minus operation : to construct -f from f , we negate the coefficients rather than sampling f anew . besides taking a little time , resampling would sometimes change the representation slightly since it would introduce new rounding errors .",
    "for example , the chebfun f = chebfun(@(x ) sin(1./(x+.03i ) ) in figure [ fig8]b has length 4441 , and so does -f , but if we construct the negative via chebfun(@(x ) -f(x ) ) the rounding error plateau is higher and the length reduces to @xmath104 .",
    "thus chebfun construction is approximately , but not exactly , a projection . ]",
    "some operations are not carried out by calling the constructor , but lead to chebyshev series whose tails may be below the noise level .",
    "one instance of this is cumsum , which computes the integral of a chebfun by manipulating its chebyshev coefficients .",
    "the amplitudes of the higher coefficients will be reduced in the process and can be trimmed without loss of overall accuracy .",
    "this is intuitively natural since integration is a smoothing operation and thus can be expected to result in shorter series .",
    "chebfun has a code simplify that effects this trimming by calling standardchop after first prolonging the length of the chebyshev series by about @xmath105 to ensure it is long enough for standardchop to work properly .",
    "for example ,",
    "f = chebfun(@(x ) log(1.1-x ) ) has length 75 , so mathematically , one might expect cumsum(f ) to have length 76 . since cumsum calls simplify , however , the length is actually  70 .",
    "multiplication of two chebfuns , the operation f.*g , is also currently carried out in chebfun by manipulating coefficients , then calling simplify .",
    "addition and subtraction are currently carried out by manipulating coefficients without calling simplify , but this is likely to change .",
    "another example of a chebfun algorithm that bypasses the construction process is conv , which computes the convolution of two functions .",
    "this code uses a fast algorithm introduced by hale and townsend that converts chebyshev series to legendre series for the convolution , then converts back again and calls simplify  @xcite .",
    "construction via pointwise sampling would be much more expensive .",
    "we have presented a general construction process whereby chebfun samples a function on successively finer grids , computes chebyshev coefficients , and calls standardchop to decide if convergence has been achieved .",
    "we now describe various parts of chebfun in which this algorithm is applied in specialized ways . before the introduction of version 5.3 ,",
    "these operations were carried out by different alogorithms , and their replacement by standardchop has been a significant simplification ( algorithmic aim  4 of section  4 ) .",
    "a chebfun may consist of a concatenation of several smooth pieces , called _ funs , _ each with its own chebyshev series representation .",
    "breakpoints between funs are introduced by operations known to break smoothness at certain points , such as abs(f ) at points where f passes through zero , and they can also be determined by a fast edge - detection algorithm  @xcite .",
    "the complication that arises in construction of chebfuns with several pieces is that a chebfun can normally be evaluated to a certain accuracy relative to its global scale over the whole interval of definition  not the local scale of an individual fun . to achieve the necessary effect ,",
    "standardchop is called with its input parameter tol set not to the chebfun tolerance eps as usual , but to eps*vscaleglobal / vscalelocal , where vscaleglobal and vscalelocal are estimates of the scales of the global chebfun and the local fun , respectively .      beginning with version 5.0 in 2014 , chebfun has had a capability of working with periodic functions represented by fourier series in addition to the usual nonperiodic functions represented by chebyshev series  @xcite .",
    "this adds efficiency and accuracy for periodic problems and is particularly attractive in eliminating discontinuities of periodic functions or their derivatives at boundary points .",
    "a  periodic chebfun is informally called a `` trigfun '' .    to construct a trigfun , which occurs when the user specifies the flag ` ' trig ' ` , chebfun samples the function on periodic equispaced grids of @xmath106 points and constructs trigonometric series for the corresponding interpolating trigonometric polynomials .",
    "these series are of degrees @xmath107 in the usual terminology , where a series of degree 8 for @xmath108 $ ] , for example , consists of coefficients @xmath109 multiplying exponentials @xmath110 .",
    "the decision of when a series is `` happy '' and where to chop it is made by standardchop applied to the sequence @xmath111 , @xmath112 ( repeated twice ) , @xmath113 ( repeated twice ) , and so on .",
    "the reason for this duplication of each coefficient is so that fourier series will be treated by essentially the same parameters as chebyshev series , with 17 values being the minimal number for happiness .",
    "an example of fourier coefficients of a trigfun is shown in figure  [ doublelengthtrig ] , which revisits the function @xmath28 of figure  [ doublelength ] now in fourier mode .",
    "repetition of figure  [ doublelength ] for the function @xmath28 , but now with chebfun called with the trig flag , producing a fourier rather than chebyshev representation . ]    -1em      one of the most important capabilities of chebfun for users is the solution of ordinary differential equations ( odes ) , both boundary - value problems ( bvps ) and initial - value problems ( ivps ) , which can be linear or nonlinear .    to solve a linear bvp",
    ", chebfun discretizes the problem on chebyshev grids of sizes approximately @xmath114 and checks for happiness on each grid  @xcite .",
    "apart from the modified grid sequence , which is based on half - integer as well as integer powers of  2 , this process differs from standard construction in two ways .",
    "one is that this is not just a matter of `` sampling '' a fixed function , since the value at a grid point such as @xmath48 , for example , will change as the gridding is refined . in chebfun terminology , this means bvps are constructed in a `` resampling '' mode , with function values already obtained on a coarse grid recomputed on each finer grid .",
    "the other difference is that for solving bvps , standardchop is called with @xmath115 , where the parameter bvptol is by default set to @xmath116 rather than machine epsilon .",
    "one reason for this is that solution of bvps on fine grids is expensive , with @xmath117 complexity on a grid of @xmath47 points , so pushing to full machine precision may be slow .",
    "in addition , the matrices involved in the solution process are often ill - conditioned , so setting @xmath118 would sometimes be problematic .",
    "figure  [ figode ] illustrates the chebfun solution of @xmath119 for @xmath120 $ ] with @xmath121 and the corresponding amplitudes of chebyshev coefficients . in this unproblematic case",
    "the default tolerance @xmath122 does not achieve the maximum accuracy possible , and a second plot of coefficients is shown for a solution with @xmath123 .    ( a ) chebfun solution to @xmath119 for @xmath120 $ ] .",
    "( b ) chebyshev coefficients @xmath25 for standard construction with the default tolerance @xmath124 .",
    "( c ) more accuracy achieved by tightening the tolerance to @xmath123.,width=307 ]    -1.5em    if a bvp is nonlinear , chebfun embeds the construction process just described in a newton or damped - newton iteration , with the necessary derivatives formulated in a continuous setting as frchet derivative operators constructed by automatic differentiation  @xcite .",
    "the correction functions will eventually become very small , and it is necessary for the chebyshev series involved in their construction to be judged relative to the scale of the overall function , not that of the correction .",
    "accordingly , standardchop is called with its value of tol increased by a factor analogous to vscaleglobal / vscalelocal , as described in  8.1 .",
    "the newton iteration is exited when its estimated error falls below @xmath125 .",
    "ivps in chebfun are solved differently from bvps , by marching rather than a global spectral discretization  @xcite .",
    "this solution process has nothing a priori to do with chebyshev grids , and it is carried out by standard matlab ode codes : ode113 by default , which can be changed e.g.  to ode15s for a stiff problem . as with bvps , chebfun aims by default for about 12 digits rather than 16 . to be precise , ode113 by default is called with abstol = 1e5*macheps and reltol = 1e2*macheps ( see footnote  2 ) . the computed function that results is then converted to a chebfun by a call to standardchop with tol set to the maximum of reltol and abstol / vscale .",
    "a quasimatrix is a chebfun with more than one column , that is , a collection of several functions defined on the same interval @xmath1 $ ] . by default",
    ", chebfun constructs each column of a quasimatrix independently , calling standardchop with @xmath126 as usual . for some applications , however , it is appropriate for the columns to be constructed relative to a single global scale , for example if they correspond to pieces of a decomposition of a single function . for such applications a user can specify the flag ` ' globaltol ' ` , and",
    "then standardchop will be called with tol appropriately adjusted for the various columns as described in  8.1 and 8.3 .",
    "the next subsection gives an example .",
    "chebyshev coefficients of the rows of the chebfun2 of @xmath127 , corresponding to the @xmath128 part of the bivariate representation .",
    "the curves for the 12 rows begin at different heights but end at approximately the same height , reflecting calls to standardchop with the globaltol flag set so that tolerances are adjusted to a global scale.,width=297 ]    -1.6em      finally we mention that chebfun can also compute with smooth functions in two dimensions , since the release of chebfun2 in 2012  @xcite , and soon in 3d with the upcoming release of chebfun3  @xcite . in both cases ,",
    "functions are represented by low - rank approximations constructed from outer products of 1d functions , which in turn are represented by the usual chebfun chebyshev series , or fourier series in periodic directions .",
    "these series are constructed with standardchop in the ` ' globaltol ' ` mode described above .",
    "to illustrate , figure  [ figquasi ] plots the chebyshev coefficients of the 12 rows representing the @xmath128-dependence of the chebfun2 representation of @xmath127 .",
    "although chebfun has been chopping chebyshev series for more than a decade , and more recently also fourier series , the details have been inconsistent and ad hoc until lately .",
    "this paper has described the new algorithm standardchop , which unifies these processes with a clear structure .",
    "other related projects for numerical computation with functions face the same challenge of `` rounding '' of functions .",
    "a list of chebfun - related projects can be found under the `` about '' tab at www.chebfun.org , currently including approxfun.jl  @xcite , pychebfun , fourfun  @xcite , chebint  @xcite , pacal  @xcite , sincfun  @xcite , a collection of lisp codes by fateman  @xcite , libchebfun , and rktoolbox  @xcite .",
    "the introduction of standardchop has made the foundations of the chebfun project more secure .",
    "at the same time , we reiterate that we make no claim that this algorithm is optimal , or even represents the only reasonable approach to this problem . just as it took decades for floating - point arithmetic of real numbers to reach a reasonably settled state with the introduction of the ieee floating point standard in the mid-1980s  @xcite , perhaps it will take a long time for consensus to emerge as to the best ways to realize the analogue of floating - point arithmetic for numerical computation with functions .",
    "we have benefitted from extensive discussions with others in the chebfun team including anthony austin , sgeir birkisson , toby driscoll , nick hale , behnam hashemi , mohsin javed , hadrien montanelli , mikael slevinsky , alex townsend , grady wright , and kuan xu .",
    "we also acknowledge insightful suggestions from folkmar bornemann of tu munich .",
    "this work was supported by the european research council under the european union s seventh framework programme ( fp7/20072013)/erc grant agreement no .",
    "291068 .",
    "the views expressed in this article are not those of the erc or the european commission , and the european union is not liable for any use that may be made of the information contained here .",
    ".... function cutoff = standardchop(coeffs , tol ) % standardchop   a sequence chopping rule of \" standard \" ( as opposed to \" loose \" or % \" strict \" ) type , that is , with an input tolerance tol that is applied with some % flexibility .",
    "this code is used in all parts of chebfun that make chopping % decisions , including chebfun construction ( chebtech , trigtech ) , solution of % ode bvps ( solvebvp ) , solution of ode ivps ( odesol ) , simplification of chebfuns % ( simplify ) , and chebfun2 .",
    "see j. l. aurentz and l. n. trefethen , \" chopping a % chebyshev series \" , arxiv , december 2015 .",
    "% % input : % % coeffs   a nonempty row or column vector of real or complex numbers %          which typically will be chebyshev or fourier coefficients .",
    "% % tol      a number in ( 0,1 ) representing a target relative accuracy .",
    "%          tol will typically will be set to the chebfun eps parameter , %          sometimes multiplied by a factor such as vglobal / vlocal in %          construction of local pieces of global chebfuns .",
    "%          default value : machine epsilon ( matlab eps ) .",
    "% % output : % % cutoff   a positive integer .",
    "%          if cutoff = = length(coeffs ) , then we are \" not happy \" : %          a satisfactory chopping point has not been found .",
    "%          if cutoff < length(coeffs ) , we are \" happy \" and cutoff %          represents the last index of coeffs that should be retained .",
    "% % examples : % % coeffs = 10.^-(1:50 ) ; random = cos((1:50).^2 ) ; % standardchop(coeffs ) % = 18 % standardchop(coeffs + 1e-16*random ) % = 15 % standardchop(coeffs + 1e-13*random ) % = 13 % standardchop(coeffs + 1e-10*random ) % = 50 % standardchop(coeffs + 1e-10*random , 1e-10 ) % = 10    % jared aurentz and nick trefethen , july 2015 .",
    "% % copyright 2015 by the university of oxford and the chebfun developers .",
    "% see http://www.chebfun.org/ for chebfun information .",
    "% standardchop normally chops coeffs at a point beyond which it is smaller than % tol^(2/3 ) .",
    "coeffs will never be chopped unless it is of length at least 17 and % falls at least below tol^(1/3 ) .",
    "it will always be chopped if it has a long % enough final segment below tol , and the final entry coeffs(cutoff ) will never % be smaller than tol^(7/6 ) .",
    "all these statements are relative to % max(abs(coeffs ) ) and assume cutoff > 1 .",
    "these parameters result from % extensive experimentation involving functions such as those presented in % the paper cited above .",
    "they are not derived from first principles and % there is no claim that they are optimal .",
    "% make sure coeffs has length at least 17 : n = length(coeffs ) ; cutoff = n ; if ( n < 17 )      return end     % step 1 : convert coeffs to a new monotonically nonincreasing %          vector envelope normalized to begin with the value 1 .",
    "% step 2 : scan envelope for a value plateaupoint , the first point j-1 , if any , % that is followed by a plateau .",
    "a plateau is a stretch of coefficients % envelope(j), ... ,envelope(j2 ) , j2 = round(1.25*j+5 ) < = n , with the property % that envelope(j2)/envelope(j ) >",
    "r.   the number r ranges from r = 0 if % envelope(j ) = tol up to r = 1 if envelope(j ) = tol^(2/3 ) .",
    "thus a potential % plateau whose starting value is envelope(j ) ~ tol^(2/3 ) has to be perfectly % flat to count , whereas with envelope(j ) ~ tol it does n't have to be flat at % all .   if a plateau point is found , then we know we are going to chop the % vector , but the precise chopping point cutoff still remains to be determined % in step 3 .    for j",
    "= 2:n      j2 = round(1.25*j + 5 ) ;       if ( j2 > n )          % there is no plateau : exit          return      end            e1 = envelope(j ) ;      e2 = envelope(j2 ) ;      r = 3*(1 - log(e1)/log(tol ) ) ;      plateau = ( e1 = = 0 ) | ( e2/e1 > r ) ;      if ( plateau )          % a plateau has been found : go to step 3          plateaupoint = j - 1 ;          break      end end    % step 3 : fix cutoff at a point where envelope , plus a linear function % included to bias the result towards the left end , is minimal .",
    "% % some explanation is needed here .",
    "one might imagine that if a plateau is % found , then one should simply set cutoff = plateaupoint and be done , without % the need for a step 3 . however , sometimes cutoff should be smaller or larger % than plateaupoint , and that is what step 3 achieves .",
    "% % cutoff should be smaller than plateaupoint if the last few coefficients made % negligible improvement but just managed to bring the vector envelope below the % level tol^(2/3 ) , above which no plateau will ever be detected .",
    "this part of % the code is important for avoiding situations where a coefficient vector is % chopped at a point that looks \" obviously wrong \" with plotcoeffs .",
    "% % cutoff should be larger than plateaupoint if , although a plateau has been % found , one can nevertheless reduce the amplitude of the coefficients a good % deal further by taking more of them .",
    "this will happen most often when a % plateau is detected at an amplitude close to tol , because in this case , the % \" plateau \" need not be very flat .",
    "this part of the code is important to % getting an extra digit or two beyond the minimal prescribed accuracy when it % is easy to do so .",
    "if ( envelope(plateaupoint ) = = 0 )      cutoff = plateaupoint ; else      j3 = sum(envelope > = tol^(7/6 ) ) ;      if ( j3 < j2 )          j2 = j3 + 1 ;          envelope(j2 ) = tol^(7/6 ) ;      end      cc = log10(envelope(1:j2 ) ) ;      cc = cc ( : ) ;      cc = cc + linspace(0 , ( -1/3)*log10(tol ) , j2 ) ' ;      [ ~ , d ] = min(cc ) ;      cutoff = max(d - 1 , 1 ) ; end                                        k. poppe and r. cools , chebint : a matlab / octave toolbox for fast multivariate integration and interpolation based on chebyshev approximations over hypercubes , _ acm trans .  math .",
    "_ 40 ( 2013 ) , 2:12:13 ."
  ],
  "abstract_text": [
    "<S> chebfun and related software projects for numerical computing with functions are based on the idea that at each step of a computation , a function @xmath0 defined on an interval @xmath1 $ ] is `` rounded '' to a prescribed precision by constructing a chebyshev series and chopping it at an appropriate point . </S>",
    "<S> designing a chopping algorithm with the right properties proves to be a surprisingly complex and interesting problem . </S>",
    "<S> we describe the chopping algorithm introduced in chebfun version 5.3 in 2015 after many years of discussion and the considerations that led to this design . </S>"
  ]
}