{
  "article_text": [
    "in this paper , we study two scenarios of hardness amplification . in the first scenario , one is given a predicate  @xmath0 , which is somewhat hard to compute given  @xmath1 .",
    "more concretely : @xmath2 \\leq 1-\\frac{\\delta}{2}$ ] for any @xmath3 in some given complexity class , where typically  @xmath4 is not too close to @xmath5 but at least polynomially big ( say , @xmath6 ) . one then aims to find a predicate which is even harder to compute .    in the second scenario , one is given a computational search problem , specified by some relation  @xmath7 .",
    "one then assumes that no algorithm of a certain complexity satisfies @xmath8 > 1-\\delta$ ] , and again , is interested in finding relations which are even harder to satisfy .",
    "it is sometimes the case that  @xmath9 may only be efficiently computable given some side information generated while sampling  @xmath1 .",
    "such problems are called `` weakly verifiable puzzles '' .",
    "our aim is to give proofs for theorems in both scenarios which are both simple and versatile . in particular",
    ", we will see that our proofs are applicable in the interactive setting , where they give stronger results than those previously known .",
    "[ [ overview - and - previous - work ] ] overview and previous work + + + + + + + + + + + + + + + + + + + + + + + + + +    roughly speaking , yao s xor - lemma @xcite states that if a predicate @xmath0 is somewhat hard to compute , then the @xmath10-wise xor @xmath11 will be even harder to compute . while intuitive , such statements are often somewhat difficult to prove .",
    "the first proof of the above appears to be by levin @xcite ( see also @xcite ) . in some cases ,",
    "even stronger statements are needed : for example , the extraction lemma states that one can even extract several bits out of the concatenation @xmath12 , which look pseudorandom to a distinguisher given @xmath13 . proving this statement for tight parameters",
    "is considered the technically most difficult step in the original proof that one - way functions imply pseudorandom generators @xcite . excluding this work , the easiest proof available seems to be based on impagliazzo s hard - core set theorem @xcite , more concretely the uniform version of it @xcite . a proof along those lines is given in @xcite .",
    "similar considerations are true for the more efficient proof that one - way functions imply pseudorandom generators given by haitner et al.@xcite .",
    "[ [ contributions - of - this - paper ] ] contributions of this paper + + + + + + + + + + + + + + + + + + + + + + + + + + +    in this paper , we are concerned with statements of a similar nature as ( but which generalize beyond ) yao s xor - lemma .",
    "we give a new theorem , which is much easier to prove than the hard - core set theorem , and which is still sufficient for all the aforementioned applications .",
    "our main observation can be described in relatively simple terms . in the known proof based on hard - core sets ( @xcite ) ,",
    "the essential statement is that there is a large set @xmath14 , such that for  @xmath15 it is computationally difficult to predict @xmath0 with a non - negligible advantage over a random guess .",
    "proving the existence of the set @xmath14 requires some work ( basically , boosting , as shown in @xcite ) .",
    "we use the idea that the set @xmath14 can be made _ dependent _ on the circuit which attempts to predict @xmath16 .",
    "the existence of a hard set @xmath14 for a particular circuit is a much easier fact to show ( and occurs as a building block in some proofs of the hard - core theorem ) .",
    "for our idea to go through , @xmath14 has to be made dependent on some of the inputs to  @xmath17 as well as some other fixed choices .",
    "this technique of switching quantifiers resembles a statement in @xcite , where impagliazzo s hard - core set theorem is used to show that in some definitions of pseudo - entropy it is also possible to switch quantifiers .    besides being technically simpler , making the set  @xmath14 dependent on  @xmath17 has an additional advantage .",
    "for example , consider a proof of the xor lemma . to get a contradiction ,",
    "a circuit  @xmath17 is assumed which does well in predicting the xor , and a circuit  @xmath18 for a single instance is built from  @xmath17 . on input  @xmath1",
    ", @xmath18 calls  @xmath17 as a subroutine several times , each time `` hiding ''  @xmath1 as one of the elements of the input . using our ideas , we can ensure that @xmath1 is hidden always in the same place @xmath19 , and even more , the values of the inputs @xmath20 are constant and independent of @xmath1 .",
    "this property , which we call non - rewinding , is useful in the case one wants to amplify the hardness of interactive protocols .",
    "we remark that in this paper we are not concerned with efficiency of xor - lemmas in the sense of derandomizing them ( as in , e.g. , @xcite ) .",
    "[ [ overview - and - previous - work-1 ] ] overview and previous work + + + + + + + + + + + + + + + + + + + + + + + + + +    the notion of weakly verifiable puzzles was introduced by canetti et al .",
    "a weakly verifiable puzzle consists of a sampling method , which produces an instance  @xmath1 together with a circuit  @xmath21 , checking solutions .",
    "the task is , given  @xmath1 but not necessarily  @xmath22 , to find a string  @xmath23 for which @xmath24 .",
    "one - way functions are an example : @xmath21 just outputs  @xmath5 if @xmath25 ( since @xmath22 depends on the instance it can contain @xmath1 ) .",
    "however , weakly verifiable puzzles are more general , since @xmath22 is not given at the time @xmath23 has to be found .",
    "canetti et al .",
    "show that if no efficient algorithm finds solutions with probability higher than  @xmath4 , then any efficient algorithm finds @xmath10 solutions simultaneously with probability at most  @xmath26 , for some negligible @xmath27 .",
    "this result was strengthened by @xcite , showing that requiring some  @xmath28 fraction of correct answers already makes efficient algorithms fail , if  @xmath10 is large enough .",
    "independently of the current work , jutla @xcite improved their bound to make it match the standard chernoff bound .",
    "a different strengthening was given in @xcite , where it was noted that the algorithm in @xcite has an additional property which implies that it can be applied in an interactive cryptographic setting , also they studied how much easier solving a weakly verifiable puzzle becomes if one simply asks for a single correct solution from @xmath10 given puzzles . also independently of our work , chung et al .",
    "@xcite give a proof for the threshold case ( similar to jutla ) which is also applicable in an interactive setting ; however , their parameters are somewhat weaker than the ones given by most other papers .",
    "finally , @xcite gives yet another strengthening : they allow a weakly verifiable puzzle to have multiple solutions indexed by some element @xmath29 , and the adversary is allowed to interactively obtain some of them .",
    "they then study under what conditions the hardness is amplified in this setting .",
    "[ [ contributions - of - this - paper-1 ] ] contributions of this paper + + + + + + + + + + + + + + + + + + + + + + + + + + +    in this work , we present a theorem which unifies and strengthens the results given in @xcite : assume a monotone function @xmath30 specifies which subpuzzles need to be solved in order to solve the resulting puzzle ( i.e. , if @xmath31 are bits where @xmath32 indicates that a valid solution for puzzle @xmath19 was found , then @xmath33 iff this is sufficient to give a valid solution for the overall case . )",
    "our theorem gives a tight bound for any such @xmath34 ( in this sense , previous papers considered only threshold functions for @xmath34 ) .",
    "furthermore , as we will see our proof is also applicable in an interactive setting ( the proofs given in @xcite do not have this property ) .",
    "our proof is heavily inspired by the one given in @xcite .      [",
    "[ overview - and - previous - work-2 ] ] overview and previous work + + + + + + + + + + + + + + + + + + + + + + + + + +    consider a cryptographic protocol , such as bit commitment .",
    "suppose that a non - perfect implementation of such a protocol is given , which we would like to improve .",
    "for example , assume that a cheating receiver can guess the bit committed to with some probability , say  @xmath35 .",
    "furthermore , suppose that a cheating sender can open the commitment in two ways with some probability , say  @xmath36 .",
    "can we use this protocol to get a stronger bit commitment protocol ?",
    "such questions have been studied in various forms both in the information theoretic and the computational model @xcite .",
    "however , all of the previous computational work except @xcite focused on the case where the parties participating in the protocol are at least semi - honest , i.e. , they follow the protocol correctly ( this is a natural assumption in the case for the work on key agreement @xcite , as in this case the participating parties can be assumed to be honest ) .",
    "an exception to this trend was the work by halevi and rabin @xcite , where it was shown that for _ some _ protocols , the information theoretic bounds also apply computationally .",
    "the above are results in case where the protocol is repeated _ sequentially_. the case where the protocol is repeated in parallel is more complicated @xcite .    [",
    "[ contributions - of - this - paper-2 ] ] contributions of this paper + + + + + + + + + + + + + + + + + + + + + + + + + + +    we explicitly define  non - rewinding \" ( which was , however , pointed to in @xcite ) which helps to provide a sufficient condition for transforming complexity theoretic results into results for cryptographic protocols .",
    "using , the above results , and specifically that the above results are non - rewindable , we show that we can strengthen any protocol in which the security goal is to make a bit one party has unpredictable to the other party , in the case where an information theoretic analogue can be strengthened .",
    "we also study interactive weakly verifiable puzzles ( as has been done implicitly in @xcite ) , and show that natural ways to amplify the hardness of these work .",
    "we only remark that our proof is applicable to parallel repetition for non - interactive ( two - round ) protocols ( e.g. captchas ) .    due to space restrictions ,",
    "many of the proofs and even some of the formal statements of theorems have been moved to the appendix .",
    "consider a circuit @xmath17 which has a tuple of designated input wires labeled @xmath37 .",
    "an oracle circuit @xmath38 with calls to @xmath17 is _ non - rewinding _ if there is a fixed @xmath19 and fixed strings @xmath39 to @xmath40 such that for any input @xmath23 to @xmath18 , all calls to @xmath17 use inputs @xmath41 on the wires labeled @xmath42 .",
    "let  @xmath17 be a circuit which has a block of input wires labeled @xmath1 .",
    "an oracle circuit  @xmath18 which calls @xmath17 ( possibly several times ) treats @xmath1 obliviously if the input @xmath1 to @xmath18 is forwarded to @xmath17 directly , and not used in any other way in @xmath18 .",
    "we say that an event happens _ almost surely _ if it has probability @xmath43 .",
    "we denote by @xmath44 $ ] the set @xmath45 .",
    "the density of a set  @xmath46 is @xmath47 .",
    "we sometimes identify a set  @xmath14 with its characteristic function @xmath48 .",
    "we often denote a tuple @xmath49 by @xmath50 .",
    "if a distribution @xmath51 over some set is given , we write  @xmath52 to denote that @xmath1 is chosen according to @xmath51 .",
    "we sometimes identify sets with the uniform distribution over them .",
    "we let @xmath53 be the bernoulli distribution over  @xmath54 with parameter  @xmath4 , i.e. , @xmath55 = \\delta$ ] .",
    "furthermore , @xmath56 is the distribution over  @xmath57 where each bit is i.i.d .",
    "according to @xmath53 .",
    "when two interactive algorithms @xmath3 and @xmath58 are given , we will denote by @xmath59 the output @xmath3 has in an interaction with @xmath58 , and by @xmath60 the output which @xmath58 has .",
    "we sometimes consider probabilities like @xmath61 $ ] , in which case the probability is over random coins of @xmath3 and @xmath58 ( if any ) , but they are chosen the same on the left and the right hand side .",
    "fix a predicate @xmath62 and a circuit @xmath63 which takes an arbitrary @xmath64 , a bit @xmath65 , and some randomness @xmath66 as input .",
    "we may think of @xmath17 as a circuit which tries to distinguish the case @xmath67 from the case @xmath68 . our idea is to identify a set @xmath14 for which we can show the following :    1 .",
    "if @xmath1 is picked randomly from @xmath14 , then @xmath69 \\approx \\pr[c(x , 1-p(x ) , r)=1]$ ] .",
    "@xmath17 can be used to predict @xmath0 for a uniform random @xmath1 correctly with probability close to @xmath70    on an informal level , one could say that @xmath14 explains the hardness of computing @xmath16 from @xmath17 s point of view : for elements from @xmath14 the circuit just behaves as a uniform random guess , on the others it computes ( or , more accurately , _ helps _ to compute ) @xmath16 .",
    "readers familiar with impagliazzo s hardcore lemma will notice the similarity : impagliazzo finds a set which explains the computational difficulty of a predicate for _ any _ circuit of a certain size .",
    "thus , in this sense impagliazzo s theorem is stronger .",
    "the advantage of ours is that the proof is technically simpler , and that it can be used in the interactive setting ( see section  [ sec : interactionpredicate ] ) which seemingly comes from the fact that it helps to build non - rewinding proofs .",
    "the following theorem formalizes the above discussion .",
    "it will find @xmath14 by producing a circuit which recognizes it , and also produces a circuit @xmath71 which uses @xmath17 in order to predict @xmath16 .",
    "[ theorem single pred ] let @xmath72 be a computable predicate .",
    "there is an algorithm @xmath73 which takes as input a randomized circuit @xmath74 and a parameter @xmath27 , and outputs two deterministic circuits @xmath71 and @xmath14 , both of size @xmath75 , as well as @xmath76 $ ] , such that almost surely the following holds :    large set : : :    @xmath77 recognizes a set @xmath78 of density at least    @xmath79 .",
    "indistinguishability : : :    for the above set @xmath80 we have    @xmath81 -          \\pr_{x\\leftarrow \\{0,1\\}^n , r}[c(x , p'(x),r)=1]\\bigr| \\leq \\epsilon ,        \\end{aligned}\\ ] ] where @xmath82 ,    i.e. , @xmath83 is the predicate which equals  @xmath16    outside  @xmath14 and differs from  @xmath16    within  @xmath14 .",
    "predictability : : :    @xmath71 predicts @xmath16 well :    @xmath84        \\geq 1-\\frac{\\delta}{2}$ ] .",
    "additionally , these algorithms have the following properties :    1 .   unless @xmath85 algorithm @xmath71 predicts slightly better : , which can always be guaranteed . ] @xmath86\\geq 1-\\frac{\\delta}{2 } + \\frac{\\epsilon}{4}$ ] .",
    "if @xmath16 is efficiently samplable ( i.e. , pairs @xmath87 can be generated in polynomial time ) , @xmath73 runs in time @xmath88 .",
    "@xmath73 , @xmath14 , and @xmath71 can be implemented with oracle access to @xmath17 only ( i.e. , they do not use the description of @xmath17 ) .",
    "4 .   when thought as oracle circuits , @xmath14 and @xmath71 use the oracle @xmath17 at most @xmath89 times . also , they both treat @xmath1 obliviously , and their output only depends on the number of @xmath5 s obtained from the oracle calls to @xmath17 and , in case of @xmath14 , the input @xmath0 .",
    "( 0,-0.5 )  ( 0,0 ) node [ left ] @xmath90  ( 0,1 ) node [ left ] @xmath5  ( 0,1.2 ) node [ above ] @xmath91 ; ( -0.1,1 ) ",
    "( 0.1,1 ) ; ( -0.1,0 )  ( 5,0 ) ; ( 5 , -0.5 ) node @xmath92 ; ( 5 , -0.75 ) node ( ordered by",
    "@xmath93 ) ;    ( 0,0 )  ( 0.0 , -0.35 )  ( 0.2 , -0.32 )  ( 0.4,-.17 )  ( 0.6,-.14 )  ( 0.8,-.1 )  ( 1.0 , -.08 ) ",
    "( 1.2 , -.02 )  ( 1.4,0 ) ; ( 0,0 ) ",
    "( 0.0 , -0.35 )  ( 0.2 , -0.32 )  ( 0.4,-.17 ) ",
    "( 0.6,-.14 )",
    " ( 0.8,-.1 )  ( 1.0 , -.08 )  ( 1.2 , -.02 )  ( 1.4,0 ) ;    ( 1.4,0 )  ( 1.6,0.03 )  ( 1.8,0.05 )  ( 2.0,0.07 )  ( 2.2,0.18 )  ( 2.2,0.18 )  ( 2.4,0.25 )  ( 2.6,0.27 )  ( 2.8,.30 )  ( 2.8,0 ) node [ black , below ] @xmath94 ; ( 1.4,0 )  ( 1.6,0.03 )  ( 1.8,0.05 )  ( 2.0,0.07 )  ( 2.2,0.18 )  ( 2.2,0.18 )  ( 2.4,0.25 )  ( 2.6,0.27 )  ( 2.8,.30 )  ( 2.8,0 ) ;    ( 2.8,.3 )  ( 3.0,.34 )  ( 3.2,.35 )  ( 3.4,.36 )  ( 3.6,.365 )  ( 3.8,.37 )  ( 4.0,.38 )  ( 4.2,.42 )  ( 4.4,.44 )  ( 4.6,.465 )  ( 4.8,.47 ) ; ( 2.8,.3 )  ( -.1,.3 ) node [ left ] @xmath95 ;    ( 0.5,-0.1 )  ( 1.3 , -0.3 ) node[below ] @xmath3 ; ( 2.3,0.1 )  ( 2.0 , -0.3 ) node[below ] @xmath58 ;    ( 2.5 , -1 ) node ( a ) ;    ( 0,-0.5 )  ( 0,0 ) node [ left ] @xmath90  ( 0,1 ) node [ left ] @xmath5  ( 0,1.2 ) node [ above ] @xmath91 ; ( -0.1,1 )  ( 0.1,1 ) ; ( -0.1,0 )  ( 5,0 ) ; ( 5 , -0.5 ) node @xmath92 ; ( 5 , -0.75 ) node ( ordered by  @xmath93 ) ;    ( 0,0 ) ",
    "( 0.0 , -0.05 )  ( 0.3 , -0.05 )  ( 0.6,-.05 )  ( 0.9,-.04 )  ( 1.2,-.04 ) ",
    "( 1.6 , -.03 )  ( 2.0,-.02 ) ",
    "( 2.4 , 0 ) ; ( 0,0 ) ",
    "( 0.0 , -0.05 )  ( 0.3 , -0.05 )  ( 0.6,-.05 )  ( 0.9,-.04 )  ( 1.2,-.04 ) ",
    "( 1.6 , -.03 )  ( 2.0,-.02 ) ",
    "( 2.4 , 0 ) ;    ( 2.4,0 )  ( 2.5,0.05 )  ( 2.6,0.13 )  ( 2.7,0.19 )  ( 2.8,.30 )  ( 2.8,0 ) node [ black , below ] @xmath94 ; ( 2.4,0 )  ( 2.5,0.05 )  ( 2.6,0.13 )  ( 2.7,0.19 )  ( 2.8,.30 )  ( 2.8,0 ) ;    ( 2.8,.3 ) ",
    "( 3.0,.34 ) ",
    "( 3.2,.35 ) ",
    "( 3.4,.36 ) ",
    "( 3.6,.365 ) ",
    "( 3.8,.37 ) ",
    "( 4.0,.38 ) ",
    "( 4.2,.42 ) ",
    "( 4.4,.44 ) ",
    "( 4.6,.465 )  ( 4.8,.47 ) ; ( 2.8,.3 )  ( -.1,.3 ) node [ left ] @xmath95 ;    ( 0.5,-0.03 )  ( 1.3 , -0.3 ) node[below ] @xmath3 ; ( 2.7,0.1 )  ( 2.0 , -0.3 ) node[below ] @xmath58 ; ( 2.5 , -1 ) node ( b ) ;    before we give the proof , we would like to mention that the proof uses no new techniques .",
    "for example , it is very similar to lemma 2.4 in @xcite , which in turn is implicit in @xcite ( see also lemma 6.6 and claim 7 on page 121 in @xcite ) .",
    "our main contribution here is to give the statement and to note that it is very powerful .",
    "the proof uses no new techniques .",
    "for example , it is very similar to lemma 2.4 in @xcite , which in turn is implicit in @xcite ( see also lemma 6.6 and claim 7 on page 121 in @xcite ) .",
    "our main contribution here is to give the statement and to note that it is very powerful .",
    "the proof itself is only given in the appendix of the paper .",
    "it is only remarkable for how straight - forward it is ( given the statement ) .",
    "[ [ proof - overview . ] ] proof overview .",
    "+ + + + + + + + + + + + + + +    we assume that overall @xmath96 is more often @xmath5 than @xmath97 .",
    "make @xmath14 the largest set for which the indistinguishability property is satisfied as follows : order the elements of @xmath98 according to @xmath99 - \\pr_{r}[c(x,1-p(x),r)=1]$ ] , and insert them into @xmath14 sequentially until both @xmath100 > \\pr_{x\\leftarrow s , r}[c(x,1-p(x),r)=1]$ ] and indistinguishability is violated .",
    "then , it only remains to describe  @xmath71 . for any @xmath101 note that @xmath102 - \\pr[{c(x,1-p(x ) , r)=1 } ] \\geq \\epsilon$ ] , as otherwise @xmath1 could be added to @xmath14 .",
    "thus , for those elements @xmath0 is the bit @xmath103 for which @xmath104 $ ] is bigger . in this overview",
    "we assume that @xmath105 $ ] can be found exactly , so we let @xmath106 compute the probabilities for @xmath107 and @xmath108 , and answer accordingly ; we will call this rule the `` majority rule '' . clearly , @xmath106 is correct if @xmath109 , and in order to get `` predictability '' , we only need to argue that @xmath71 is not worse than a random guess on @xmath14 .",
    "consider now figure  [ fig : littlepicture ] ( a ) , where the elements are ordered according to @xmath91 .",
    "the areas depicted @xmath3 and @xmath58 are roughly equal , which follows by the way we chose @xmath14 ( note that @xmath110-\\pr_{x \\leftarrow    s , r}[c(x,1-p(x),r)=1 ] = { \\textbf{e}}_{x \\leftarrow s}[\\delta_x]$ ] ) .",
    "at this point our problem is that the majority rule will give the incorrect answer for all elements for which @xmath111 , and as shown in figure  [ fig : littlepicture ] ( b ) , this can be almost all of @xmath14 , so that in general the above @xmath71 _ does _ perform worse than a random guess on @xmath14 .",
    "the solution is to note that it is sufficient to follow the majority rule in case the gap is bigger than @xmath95 . in the full proof",
    "we will see that if the gap is small so that @xmath112 - \\pr[c(x,1,r)=1 ] \\leq \\delta_{x^*}$ ] then a randomized decision works : the probability of answering @xmath113 is @xmath5 if the gap is @xmath114 , the probability of answering @xmath113 is 0 if the gap is @xmath115 .",
    "when the gap is in between then the probability of answering @xmath113 is linearly interpolated based on the value of the gap .",
    "so for example , if the gap is 0 , then @xmath113 with probability @xmath116",
    ". then elements in the region marked @xmath3 with negative gap larger than @xmath95 are problematic . ]",
    "a bit of thought reveals that this is exactly because the areas @xmath3 and @xmath58 in figure  [ fig : littlepicture ] are almost equal .    in the full proof ,",
    "we also show how to sample all quantities accurately enough ( which is easy ) and how to ensure that  @xmath14 is a set of the right size ( which seems to require a small trick because @xmath91 as defined above is not computable exactly , and so we actually use a different quantity for @xmath91 ) .",
    "we think that the second is not really required for the applications later , but it simplifies the statement of the above theorem and makes it somewhat more intuitive .",
    "we describe algorithm @xmath73 .",
    "first , obtain an estimate @xmath117 -      \\pr_{r , x}[c(x,1-p(x ) , r)=1 ]    \\end{aligned}\\ ] ] such that almost surely @xmath118 is within  @xmath119 of the actual quantity .",
    "if  @xmath120 , we can return  @xmath121 , @xmath122 , and a circuit  @xmath71 which guesses a uniform random bit . if  @xmath123 replace @xmath17 with the circuit which outputs  @xmath124 in the following argument .",
    "thus , from now on assume  @xmath125 and that the actual quantity is at least  @xmath126 .",
    "sample random strings  @xmath127 for @xmath17 , where  @xmath128 , and let  @xmath129 be the circuit which computes @xmath130 . using a chernoff bound , we see that for all @xmath64 @xmath131 -      \\pr_r[c(x,1-p(x ) , r)]=1]= \\nonumber\\\\      & \\pr_{i \\in [ m]}[c'(x , p(x ) , i)=1 ] - \\pr_{i \\in [ m]}[c'(x,1-p(x ) , i)]=1 ]      \\pm \\epsilon/4    \\end{aligned}\\ ] ] almost surely .",
    "define , for any  @xmath1 , @xmath132}[c'(x , p(x ) , r_i)=1 ] - \\pr_{i \\in [ m]}[c'(x,1-p(x ) , r_i)=1 ] .",
    "\\end{aligned}\\ ] ] because we define  @xmath91 using  @xmath133 instead of @xmath17 , we can compute  @xmath91 exactly for a given  @xmath1 . now ,",
    "order the  @xmath1 according to @xmath91 : let  @xmath134 if @xmath135 , or both  @xmath136 and  @xmath137 , where  @xmath138 is the lexicographic ordering on bitstrings .",
    "we can compute  @xmath134 efficiently given @xmath139 and @xmath140 .",
    "we claim that we can find  @xmath94 such that almost surely ( we assume  @xmath141 , otherwise we can get the theorem with exhaustive search ) @xmath142 we pick  @xmath143 candidates , then almost surely one of them satisfies  ( [ eq:3 ] ) with a safety margin of  @xmath144 . for each of those candidates we estimate @xmath145 up to an error of  @xmath146 , and keep one for which almost surely  ( [ eq:3 ] ) is satisfied .",
    "we let @xmath77 be the circuit which recognizes the set  @xmath147 , estimate  @xmath148 almost surely within an error of  @xmath149 , and output  @xmath150 .",
    "the situation at this moment is illustrated in figure  [ fig : littlepicture ] , and it is clear that the properties `` large set '' and `` indistinguishability '' are satisfied .",
    "we next describe  @xmath71 . on input @xmath1",
    ", @xmath71 calculates ( exactly ) @xmath151}[c'(x,1 , i ) = 1 ] - \\pr_{i \\in [ m]}[c'(x,0 , i ) = 1 ] = ( 2p(x)-1)\\delta_x\\;.    \\end{aligned}\\ ] ] if @xmath152 ( where  @xmath95 is defined by  ( [ eq:4 ] ) for the element  @xmath94 which defines  @xmath14 ) , then output  @xmath5 , if @xmath153 output @xmath90 .",
    "if neither of the previous cases apply , output  @xmath5 with probability @xmath154 .    to analyze the success probability of @xmath71 , we distinguish two cases . if  @xmath101 , we know that  @xmath155",
    ". therefore , in this case , we get the correct answer with probability @xmath5 .",
    "if  @xmath156 , it is also easy to check that this will give the correct answer with probability @xmath157 , and thus , on average @xmath158 , using  ( [ eq:3 ] ) . in total",
    ", we have probability at least @xmath159 of answering correctly . since @xmath160 , this quantity is at least @xmath161 , which implies `` predictability '' .",
    "it is possible to make @xmath71 deterministic by trying all possible values for the randomness and estimating the probability of it being correct .    in order to get the additional property 1 ,",
    "we first run the above algorithm with input @xmath162 instead of @xmath27 . if @xmath163 , we instead output the set containing all elements and return @xmath5 in place of @xmath4 .",
    "note that indistinguishability still holds because we only add a fraction of @xmath164 elements to @xmath14 .",
    "if @xmath165 , we enlarge @xmath14 by at least @xmath126 and at most @xmath164 ; this can be done by finding a new candidate for @xmath94 as above .",
    "we then output the new set and @xmath166 .",
    "the additional properties 2 , 3 and 4 follow by inspection of the proof .",
    "we explain our idea on an example : suppose we want to prove yao s xor - lemma .",
    "thus , we are given a predicate @xmath167 which is somewhat hard to compute , i.e. , @xmath168 < 1-\\frac{\\delta}{2}$ ] for any circuit @xmath169 coming from some family of circuits ( the superscript @xmath170 should indicate that this is a circuit operating on a single instance ) .",
    "we want to show that any circuit @xmath171 from a related family predicts @xmath172 from @xmath173 correctly with probability very close to @xmath116 , and aiming for a contradiction we now assume that a circuit @xmath171 exists which does significantly better than this is given .    as a first step ,",
    "we transform @xmath171 into a circuit @xmath174 as follows : @xmath175 invokes @xmath176 and outputs @xmath5 if the result equals @xmath177 , otherwise it outputs @xmath90 .",
    "we see that we would like to show @xmath178 \\approx \\frac{1}{2}$ ] .",
    "here is the key idea : we apply theorem  [ theorem single pred ] sequentially on every position @xmath19 of @xmath175 . done properly , in each position one of the following happens : ( a ) we can use @xmath175 to predict  @xmath0 from  @xmath1 with probability at least @xmath179 , or ( b ) we find a large set @xmath180 such that if @xmath181 , @xmath175 behaves roughly the same in case @xmath182 equals @xmath183 and in case @xmath182 is a uniform random bit .",
    "if ( a ) happens at any point we get a contradiction and are done , so consider the case that ( b ) happens @xmath10 times .",
    "recall now how @xmath175 was built from @xmath171 : it compares the output of @xmath184 to @xmath177 .",
    "if @xmath185 lands in the large set for any @xmath19 we can assume that @xmath182 is a random bit ( and it is very unlikely that this happens for no @xmath19 ) . then , @xmath175 outputs @xmath5 exactly if @xmath171 correctly predicts a uniform random bit which is independent of the input to @xmath171 .",
    "the probability such a prediction is correct is exactly  @xmath116 , and overall we get that @xmath171 is correct with probability close to @xmath116 .",
    "the theorem gives the formal statement for @xmath175 , we later do the transformation to @xmath171 as an example .",
    "the theorem gives the formal statement for @xmath175 , in the appendix the transformation to @xmath171 is done as an example .",
    "fix a predicate @xmath62 and a boolean circuit @xmath186 .",
    "we are interested in the probability that the circuit outputs @xmath5 in the following experiment  @xmath5 :    .... * \\textbf{experiment 1 : } *          $ \\forall i \\in \\{1,\\ldots , k\\ } : x_i \\leftarrow \\{0,1\\}^n$          $ \\forall i\\in \\{1,\\ldots , k\\ } : b_i : = p(x_i)$          $ r \\leftarrow \\{0,1\\}^*$          output $ c^{(k)}(x_1,b_1,\\ldots , x_k , b_k , r)$ ....    we will claim that there are large sets @xmath187 with the property that for any @xmath185 which falls into @xmath180 , we can set @xmath182 to a random bit and the probability of the experiment producing a @xmath5 will not change much .",
    "however , we will allow the sets @xmath180 to depend on the @xmath188 and @xmath189 for @xmath190 ; we therefore assume that an algorithm @xmath191 is given which produces such a set on input @xmath192 .    .... * \\textbf{experiment 2 : } *          for $ i : = 1 $ to $ k$ do             $ t_i : = ( x_1,b_1,\\ldots , x_{i-1 } , b_{i-1})$             $ s^*_i : = \\gens(t_i)$             $ x_i \\leftarrow \\{0,1\\}^n$             if $ x_i \\in s^*_{i}$ then $ b_i \\leftarrow \\{0,1\\}$ else $ b_i : = p(x_i)$ fi          end for          $ r \\leftarrow \\{0,1\\}^*$          output $ c^{(k)}(x_1,b_1,\\ldots , x_k , b_k , r)$ ....    theorem  [ theorem many pred ] essentially states the following : assume no small circuit can predict @xmath0 from @xmath1 with probability @xmath179 . for any fixed circuit  @xmath175 , any @xmath27 , and any @xmath10",
    "there is an algorithm @xmath191 which produces sets @xmath193 with @xmath194 and such that the probability that experiment  1 outputs  1 differs by at most @xmath27 from the probability that experiment  2 outputs  1 .",
    "[ theorem many pred ] let  @xmath16 be a computable predicate , @xmath195 parameters .",
    "there are two algorithms @xmath73 and @xmath191 as follows : @xmath73 takes as input a randomized circuit @xmath175 and a parameter @xmath27 and outputs a deterministic circuit @xmath71 of size @xmath196 as well as @xmath76 $ ] .",
    "@xmath191 takes as input a circuit @xmath175 , a tuple @xmath197 , and a parameter @xmath27 and outputs a deterministic circuit @xmath198 of @xmath196 .",
    "after a run of @xmath73 , almost surely the following properties are satisfied :    large sets : : :    for any value of @xmath199 the circuit    @xmath200 recognizes a set    @xmath201 . the probability that in an execution of    experiment  2 we have  @xmath202 for any of    the  @xmath180 which occur is at most  @xmath27 .",
    "indistinguishability : : :    using sets @xmath203 as above in experiment 2 gives    @xmath204 - \\pr[\\text{experiment            2 outputs 1}\\bigr| \\leq \\epsilon .",
    "\\end{aligned}\\ ] ] predictability : : :    @xmath71 predicts @xmath16 well : @xmath205",
    "\\geq 1-\\frac{\\delta}{2}$ ] .",
    "additionally , these algorithms have the following properties :    1 .   unless @xmath85 algorithm @xmath71 predicts slightly better : @xmath206 \\geq 1-\\frac{\\delta}{2 } +      \\frac{\\epsilon}{16k}$ ] .",
    "if @xmath16 is efficiently samplable ( i.e. , pairs @xmath87 can be generated in polynomial time ) , @xmath73 and @xmath191 run in time @xmath207 .",
    "3 .   @xmath73 , @xmath191 , @xmath208 , and @xmath71 can be implemented with oracle access to @xmath17 only ( i.e. , they do nt use the description of @xmath17 ) .",
    "4 .   when thought of as oracle circuits , @xmath208 and @xmath71 use the oracle @xmath17 at most @xmath209 times .",
    "also , they both treat @xmath1 obliviously and are non - rewinding . finally , their output only depends on the number of @xmath5 s obtained from the oracle calls to @xmath17 and , in case of @xmath208 , the input @xmath0 .    the proof is given in the appendix , but follows the informal discussion above .",
    "for any fixed tuple @xmath192 , consider the circuit  @xmath210 which uses @xmath66 to pick random  @xmath188 for  @xmath211 , and runs  @xmath212",
    ". may not be a small circuit because at this point we do not assume @xmath16 to be efficiently samplable , and @xmath213 seems to need to use @xmath66 to sample pairs @xmath214 for @xmath211 .",
    "however , we can think of @xmath213 as oracle circuit with oracle access to @xmath16 at this moment .",
    "inspection of the previous proof shows that later we can remove the calls to @xmath16 , as the @xmath215 with @xmath211 can be fixed .",
    "] we let @xmath191 be the algorithm which invokes @xmath73 with parameter @xmath216 from theorem  [ theorem single pred ] on the circuit  @xmath213 and then returns the circuit recognizing a set from there .",
    "we next describe @xmath73 : for  @xmath217 iterations , pick a random  @xmath218 , use the procedure in experiment  2 until loop @xmath19 , and run algorithm @xmath73 from theorem  [ theorem single pred ] with parameter @xmath216 .",
    "this yields a parameter @xmath4 and a circuit @xmath71 .",
    "we output the pair  @xmath219 for the smallest  @xmath4 ever encountered .",
    "since @xmath10 and @xmath27 are polynomial in @xmath220 , almost surely every time theorem  [ theorem single pred ] is used the almost surely part happens .",
    "thus , we get the property `` predictability '' ( and in fact the stronger property listed under additionally ) immediately .",
    "we now argue `` large sets '' : consider the random variable @xmath4 when we pick a random @xmath19 , simulate an execution up to iteration @xmath19 of experiment  2 , then run @xmath73 from theorem  [ theorem single pred ] .",
    "let @xmath221 be the @xmath222-quantile of this distribution , i.e. , the smallest value such that with probability @xmath222 the value of @xmath4 is at most @xmath221 . the probability that a value not bigger than @xmath221 is output by @xmath73 is at least @xmath223 , in which case `` large sets '' is satisfied .",
    "we show `` indistinguishability '' with a standard hybrid argument .",
    "consider the experiment  @xmath224 :    .... * \\textbf{random experiment $ h_j$ : } *          for $ i : = 1 $ to $ k$ do             $ t_i : = ( x_1,b_1,\\ldots , t_{i-1 } , b_{i-1})$             $ s_{i}^ * : = \\gens(t_i)$             $ x_i \\leftarrow \\{0,1\\}^n$             if $ i \\leq j$ and $ x_i",
    "\\in s^*_t$ then                $ b_i \\leftarrow \\{0,1\\}$             else                $ b_i : = p(x_i)$             end if          end for          $ r \\leftarrow \\{0,1\\}^*$          output $ c^{(k)}(x_1,b_1,\\ldots , x_k , b_k , r)$ ....    experiment  @xmath225 is equivalent to experiment  @xmath5 , experiment @xmath226 is the same as experiment  @xmath227 .",
    "applying theorem  [ theorem single pred ] we get that for every fixed  @xmath228 , almost surely @xmath229 -\\nonumber\\\\    \\pr_{x_i,\\ldots , x_k}[&c^{(k)}(x_1,b_1,\\ldots , x_{j-1},b_{j-1},x_j , b_j^{(j)},\\ldots , x_k , p(x_k ) ) = 1 ] \\bigr|    \\leq \\epsilon/4k\\;,\\end{aligned}\\ ] ] where @xmath230 is chosen as @xmath231 in experiment @xmath232 , and @xmath233 is chosen the same way as @xmath189 is chosen in experiment @xmath234 ( in theorem  [ theorem single pred ] the bit is flipped , but when using a uniform bit instead of flipping it the distinguishing probability only gets smaller ) . applying the triangle inequality @xmath235 times",
    "we get that almost surely the difference of the probabilities in experiment  1 and experiment  2 is at most @xmath236 .",
    "since `` almost surely '' means with probabilities @xmath237 , we get `` indistinguishability '' .",
    "we already showed the additional property 1 .",
    "properties 2,3 , and 4 follow by inspection .      as a first example",
    ", we prove yao s xor - lemma from theorem  [ theorem many pred ] . we will give the proof for the non - uniform model , but in fact it would also work in the uniform model of computation .",
    "let @xmath62 be a predicate , such that for all circuits  @xmath71 of size at most  @xmath238 : @xmath239 < 1-\\frac{\\delta'}{2}.    \\end{aligned}\\ ] ] then , for all circuits of size @xmath240 : @xmath241 \\leq      \\frac{1}{2 } + ( 1-\\delta')^k + \\epsilon ' .",
    "\\end{aligned}\\ ] ]    assume a circuit @xmath171 which contradicts ( [ eq:11 ] ) is given , we will obtain a circuit @xmath71 which contradicts ( [ eq:14 ] ) . for this , let @xmath242 be the circuit which runs @xmath176 and outputs @xmath5 if the result is the same as @xmath243 .",
    "we apply theorem  [ theorem many pred ] setting the parameter @xmath27 to @xmath244 , which produces ( among other things ) a parameter @xmath4 .",
    "we assume that the 3 properties which almost surely hold do hold ( otherwise run @xmath73 again ) . in case @xmath245",
    ", we use @xmath71 to get a contradiction .",
    "otherwise , we get @xmath246      = \\pr[c(x_1,p(x_1),\\ldots , x_k , p(x_k ) ) = 1]\\\\      & \\leq      \\pr[\\text{$c$ outputs $ 1 $ in experiment 2 } ] + \\frac{\\epsilon'}{2 } \\\\      & \\leq      \\pr[\\text{$c$ outputs $ 1 $ in experiment 2 and all sets $ s_i^*$        were of density at least $ \\delta$ } ] + \\epsilon'\\\\      & \\leq      \\frac{1}{2 } + ( 1-\\delta)^k + \\epsilon'\\;.    \\end{aligned}\\ ] ]      roughly speaking , the construction of a pseudorandom generator from an arbitrary one - way function proceeds in two steps ( see @xcite for a more detailed description of this view ) .",
    "first , using the goldreich - levin theorem @xcite , one constructs a _ _ pseudo - entropy pair _ _",
    "@xmath247 , which is a pair of functions @xmath248 , @xmath249 such that for all efficiently computable  @xmath3 , @xmath250 \\leq 1-\\frac{\\delta'}{2},\\end{aligned}\\ ] ] for some non - negligible @xmath251 , and which satisfies some additional information theoretic property ( the information theoretic property ensures that predicting @xmath0 from  @xmath252 is a computational problem , and ( [ eq:5 ] ) does not already hold because @xmath253 is , say , a constant function ) .",
    "second , given independently sampled instances @xmath13 , the extraction lemma then says that extracting @xmath254 bits from the concatenation @xmath255 will give a string which is computationally indistinguishable from a random string .",
    "due to the information theoretic property above , once one has the extraction lemma , it is relatively easy to get a pseudo - random generator . in the following",
    "we will prove this extraction lemma .    a technicality : the predicate which is hard to predict in this case is supposed to have input @xmath252 and output @xmath0 .",
    "however , in reality this does not have to be a predicate : @xmath253 is not always injective ( in fact , for @xmath253 obtained as above it will not be ) .",
    "most works avoid this problem by now stating that previous theorems also hold for randomized predicates .",
    "this is often true , but some of the statements get very subtle if one does it this way , and statements which involve sets of `` hard '' inputs very much so .",
    "we therefore choose to solve the problem in a different way .",
    "we consider circuits which try to predict @xmath0 from @xmath1 , but are limited in that they first are required to apply @xmath253 on @xmath1 and not use @xmath1 anywhere else . now",
    ", we have a predicate again , but it can only be difficult for this restricted class .",
    "however , since the oracle circuit @xmath71 in theorem  [ theorem many pred ] treats @xmath1 obliviously we stay within this class .",
    "let @xmath247 be a pair of functions satisfying  ( [ eq:5 ] ) for any polynomial time machine @xmath3 and set @xmath256 .",
    "let  @xmath257 be a strong extractor which extracts @xmath258 bits from any @xmath10-bit source with min - entropy  @xmath259 such that the resulting bits have statistical distance at most  @xmath260 from uniform .",
    "then , for any polynomial time  @xmath3 @xmath261 -      \\pr[a(f(x_1),\\ldots , f(x_k),s , u_m ) = 1]\\label{eq:15 }    \\end{aligned}\\ ] ] is negligible .",
    "assume otherwise , and let @xmath262 be inverse polynomial and infinitely often smaller than the distinguishing advantage of @xmath3 .",
    "we consider the circuit @xmath186 which first applies  @xmath253 on every  @xmath185 , then pick @xmath238 at random , computes @xmath263 , and executes @xmath264 .",
    "we apply theorem  [ theorem many pred ] on @xmath17 using parameter  @xmath236 , which produces , among other things , a parameter  @xmath4 .",
    "consider first the case @xmath265 .",
    "then , there is a circuit  @xmath71 which predicts @xmath0 from  @xmath1 and uses  @xmath1 obliviously in  @xmath17 .",
    "this implies that the resulting circuit evaluates @xmath252 for any input  @xmath1 and ignores the input otherwise ; we can therefore strip off this evaluation , and get a circuit which contradicts  ( [ eq:5 ] ) . in case @xmath266 ,",
    "we run experiment 2 . if all sets which occur in the experiment are of size at least @xmath4 ( and this happens with probability at least @xmath267 ) , then we can use a chernoff - bound to see that with probability @xmath268 , at least @xmath269 of the @xmath185 land in their respective set @xmath270 .",
    "thus , in this case the extractor will produces a  @xmath271 which is @xmath272-close to uniform and the indistinguishability property of theorem  [ theorem many pred ] implies that  ( [ eq:15 ] ) is negligible .      again we start with an example : consider a slightly weak bit commitment protocol , where the receiver can guess the bit the sender committed to with probability @xmath179 .",
    "in such a case , we might want to strengthen the scheme .",
    "for example , in order to commit to a single bit  @xmath103 , we could ask the sender to first commit to two random bits @xmath273 and @xmath274 , and then send @xmath275 to the receiver .",
    "the hope is that the receiver has to guess both @xmath273 and @xmath274 correctly in order to find @xmath103 , and so the protocol should be more secure .    in the case where the protocol has some defect that sometimes allows a sender to cheat",
    ", we might also want to consider the protocol where the sender commits twice to @xmath103 , or , alternatively , that he commits to @xmath273 , then to @xmath274 , and sends both @xmath276 and @xmath277 to the receiver . in this case",
    ", one can hope that a cheating receiver still needs to break the protocol at least once , and that the security should not degrade too much .    just how will the security change ?",
    "we want to consider a scenario in which the security is information theoretic .",
    "we can do this by assuming that instead of the weak protocol , a trusted party distributes a bit  @xmath278 to the sender and some side information  @xmath279 to the receiver .",
    "the guarantee is that for any @xmath253 , @xmath280 \\leq 1 - \\frac{\\delta}{2}$ ] .",
    "in such a case , one can easily obtain bounds on the security of the above protocols , and the hope is that the same bounds hold in the computational case . the theorem below states that this is indeed true ( for protocols where the security consists of hiding single bits ) .",
    "we remark that while the two aforementioned examples of protocol composition are already handled in @xcite ( their result applies to any direct product and any xor as above ) , theorem  [ theorem bit protocols ] handles any information theoretic amplification protocol as long as it can be implemented efficiently .",
    "a pair @xmath281 of random variables over @xmath282 , where @xmath283 is any finite set , is @xmath4-hiding if @xmath284 \\leq      1-\\frac{\\delta}{2}.    \\end{aligned}\\ ] ]    [ theorem bit protocols ] let a cryptographic protocol ( which we think of as `` weak '' ) @xmath285 be given in which @xmath286 has as input a single bit @xmath287 .",
    "assume that there is a function @xmath4 such that for any polynomial time adversary @xmath288 there is a negligible function @xmath289 such that @xmath290 \\leq 1 -      \\frac{\\delta}{2 } + \\nu(n ) ,    \\end{aligned}\\ ] ] where the probability is also over the coins of @xmath286 and @xmath288 ( if any ) .",
    "let further an information theoretic protocol @xmath291 be given . in @xmath292 , @xmath293 takes @xmath10 input bits @xmath294 and has a single output bit .",
    "furthermore , assume that @xmath292 is hiding in the sense that for @xmath10 independent @xmath4-hiding random variables @xmath295 , any ( information theoretic ) adversary @xmath296 , and for some function  @xmath297 : @xmath298 < \\frac{1}{2 } + \\eta(k ) .    \\end{aligned}\\ ] ]    let @xmath299 be the protocol where @xmath3 and @xmath58 first execute @xmath300 copies of @xmath301 sequentially , where @xmath3 uses uniform random bits as input .",
    "then , they run a single execution of protocol @xmath292 . in the execution to @xmath292",
    ", @xmath3 uses his @xmath10 input bits to the weak protocols as input .",
    "the output of @xmath3 in @xmath14 is the output of @xmath3 in the execution of @xmath292 .",
    "we also need that @xmath302 and @xmath300 are such that @xmath292 can be run in time @xmath207 for @xmath303 .",
    "then , for any polynomial time @xmath304 there is a negligible function @xmath305 such that @xmath306 \\leq \\frac{1}{2 } +      \\eta(k ) + \\nu'(n)\\;.    \\end{aligned}\\ ] ]    let @xmath64 be the concatenation of the randomness which @xmath3 uses in an execution of the protocol @xmath301 and his input bit @xmath287 .",
    "we let @xmath62 be the predicate which outputs @xmath307 .    in order to obtain a contradiction",
    ", we fix an adversary @xmath304 for the protocol  @xmath14 which violates  ( [ eq:7 ] ) .",
    "we would like to apply theorem  [ theorem many pred ] .",
    "for this , we define @xmath186 as follows : @xmath175 first simulates an interaction of @xmath304 with @xmath308 , where @xmath308 uses randomness @xmath185 in the @xmath19th invocation of the weak protocol  @xmath301 . after this",
    ", @xmath304 is in some state in which it expects an invocation of the information theoretic protocol .",
    "@xmath175 simulates this information theoretic protocol , but it runs @xmath293 with inputs @xmath309 instead of the actual inputs to the weak protocols . in the end , @xmath304 produces a guess for the output bit of @xmath308 , and @xmath175 outputs @xmath5 if this guess equals the output of @xmath310 in the simulation .    in experiment  1 of theorem",
    "[ theorem many pred ] , @xmath311 is used , and so @xmath175 exactly simulates an execution of the protocol  @xmath14 . since we assume that @xmath304 contradicts ( [ eq:7 ] ) , we see that the probability that @xmath175 outputs  @xmath5 in experiment 1 is , for infinitely many  @xmath220 and some constant  @xmath287 at least @xmath312 .",
    "we now apply theorem  [ theorem many pred ] on the circuit @xmath175 with parameter @xmath313 .",
    "this yields a parameter @xmath314 ( the subscript indicates that it is from theorem  [ theorem many pred ] ) .",
    "we claim that @xmath315    to see this , we assume otherwise and obtain a contradiction . in experiment 2 ,",
    "let @xmath316 be the communication produced by the weak protocol @xmath301 in round @xmath19 .",
    "assuming all sets @xmath193 in the execution are of size at least @xmath4 ( this happens with probability at least @xmath317 ) , the tuples @xmath318 are @xmath4-hiding random variables .",
    "consequently , when the circuit @xmath175 simulates the information theoretic protocol @xmath292 using bits @xmath182 , it actually simulates it in an instance in which it was designed to be used .",
    "since ( [ eq:17 ] ) holds for an arbitrary adversary in this case we get that @xmath319 \\leq \\frac{1}{2 } +      \\eta(k ) .",
    "\\end{aligned}\\ ] ] therefore , the probability that @xmath175 outputs @xmath5 in experiment 2 is at most @xmath320 , and using `` indistinguishability '' the probability that @xmath175 outputs  @xmath5 in experiment 1 is at most @xmath321 .",
    "however , our assumption was that the probability that @xmath175 outputs  @xmath5 is at least @xmath322 , and so almost surely @xmath73 does not output such a big @xmath314 , establishing ( [ eq:18 ] ) .",
    "theorem  [ theorem many pred ] also provides us with a non - rewinding circuit  @xmath71 which treats @xmath1 obliviously and which satisfies `` predictability '' .",
    "we explain how to use @xmath71 to break  ( [ eq:16 ] ) , the security property of the weak protocol @xmath301 .",
    "since @xmath106 is non - rewinding , it uses the input @xmath1 exclusively in a fixed position  @xmath19 , together with a fixed prefix @xmath323 , in all calls to @xmath175 .",
    "we first extract @xmath19 and the prefix .",
    "we now explain a crucial point : how to interact with @xmath286 in order to cheat .",
    "we simulate the @xmath324 interactions of @xmath286 with @xmath304 up to and including round @xmath324 using @xmath325 as the input bit and randomness of @xmath3 . in round",
    "@xmath19 , we continue with the _ actual _ interaction with @xmath286 .",
    "here , @xmath286 uses randomness @xmath1 ( on which we , however , do not have access ) .",
    "after this interaction , we need to be able to extract the bit @xmath287 of @xmath286 . for this",
    ", we evaluate @xmath106 , which we claim is possible .",
    "since @xmath71 is oblivious and deterministic , the only difficulty is in evaluating the calls to @xmath326 .",
    "all calls use the same values for @xmath327 . recalling how @xmath175 is defined",
    ", we see that we can continue from the state we had after the interaction with @xmath286 in order to evaluate @xmath175 completely ( note that all the @xmath182 are given , so the we can also evaluate the information theoretic protocol @xmath292 ) .",
    "we get from theorem  [ theorem many pred ] that @xmath71 satisfies , almost surely , infinitely often , using ( [ eq:18 ] ) @xmath328 \\geq 1 -      \\frac{\\delta}{2 } + \\frac{1}{48 kn^c}\\;.    \\end{aligned}\\ ] ] this therefore gives a contradiction to ( [ eq:16 ] ) : in order to get rid of the `` almost surely '' , we just consider the algorithm which first runs @xmath73 and then applies the above protocol  this only loses a negligible additive term in the probability .",
    "consider a bit commitment protocol , in which a sender commits to a single bit @xmath103 . in a first phase the sender and the receiver enact in an interactive protocol ,",
    "after which the sender holds some opening information @xmath23 , and the receiver has some way of checking whether @xmath329 is a valid decommitment .",
    "if the protocol is secure , then it is a computationally hard problem for the sender to come up with two strings @xmath330 and @xmath331 such that both @xmath332 and @xmath333 are valid decommitments , in addition , he may not even know the function the receiver will use to validate a decommitment pair , indeed produces the communication in the first round , and whether in a simulation of the second protocol he accepts . ] and thus in general there is no way for the sender to recognize a valid pair @xmath334 .",
    "we abstract this situation in the following definition ; in it we can say that the solver produces no output because in the security property all efficient algorithms are considered anyhow .    an _ interactive weakly verifiable puzzle _ consists of a protocol @xmath335 and",
    "is given by two interactive algorithms @xmath16 and @xmath14 , in which @xmath16 ( the problem poser ) produces as output a circuit  @xmath22 , and @xmath14 ( the solver ) produces no output .",
    "the _ success probability _ of an interactive algorithm  @xmath80 in solving a weakly verifiable puzzle @xmath335 is : @xmath336    \\end{aligned}\\ ] ] the puzzle is _ non - interactive _ if the protocol consists of @xmath16 sending a single message to @xmath14 .",
    "our definition of a non - interactive weakly verifiable puzzle coincides with the usual one @xcite .",
    "the security property of an interactive weakly verifiable puzzle is that for any algorithm ( or circuit ) @xmath80 of a restricted class , the success probability of @xmath80 is bounded .",
    "an important property is that  @xmath80 does not get access to  @xmath22 . besides bit commitment above ,",
    "an example of such a puzzle is a captcha . in both cases",
    "it is not obvious whether a given solution is actually a correct solution .",
    "suppose that @xmath34 is a monotone boolean function with  @xmath10 bits of input , and @xmath337 is a puzzle .",
    "we can consider the following new puzzle @xmath338 : the sender and the receiver sequentially create  @xmath10 instances of @xmath339 , which yields circuits @xmath340 for @xmath16 .",
    "then @xmath341 outputs the circuit @xmath342 which computes @xmath343 .",
    "intuitively , if no algorithm solves a single puzzle  @xmath344 with higher probability than  @xmath4 , the probability that an algorithm solves  @xmath338 should not be more than approximately  @xmath345 $ ] .",
    "( recall that @xmath56 is the distribution on @xmath10-bits , where each bit is independent and 1 with probability @xmath4 . )",
    "the following theorem states exactly this .",
    "[ theorem wvp ] there exists an algorithm @xmath346 which takes as input a circuit @xmath17 , a monotone function @xmath34 , and parameters @xmath347 , and produces a circuit  @xmath18 such that the following holds .",
    "if  @xmath17 is such that @xmath348 \\geq \\pr_{u \\leftarrow        \\mu_{\\delta}^{k}}[g(u ) = 1 ] + \\epsilon ,    \\end{aligned}\\ ] ] then , @xmath18 satisfies almost surely , @xmath349 \\geq \\delta +      \\frac{\\epsilon}{6k}.      \\label{'eq - puzzle - theorem - b ' }    \\end{aligned}\\ ] ] additionally , @xmath73 and  @xmath18 only require oracle access to both  @xmath34 and  @xmath17 , and @xmath18 is non - rewinding .    furthermore , @xmath350 and @xmath73 runs in time @xmath351 with oracle calls to @xmath17 .",
    "the monotone restriction on  @xmath34 in the previous theorem is necessary .",
    "for example , consider @xmath352 .",
    "it is possible to satisfy @xmath34 with probability 1 by producing an incorrect answer , but @xmath353 = 1 - \\delta$ ] .",
    "[ [ algorithm - description ] ] algorithm description + + + + + + + + + + + + + + + + + + + + +    if @xmath354 , @xmath73 creates the circuit @xmath18 which runs @xmath17 and outputs its answer .",
    "then either @xmath34 is the identity or a constant function .",
    "if @xmath34 is the identity , the statement is trivial .",
    "if @xmath34 is a constant function , the statement is vacuously true .",
    "@xmath18 is non - rewinding .    in the general case , we need some notation . for @xmath355 ,",
    "let @xmath356 denote the set of inputs  @xmath357 ( i.e. , the first input bit is disregarded and replaced by @xmath103 ) .",
    "we remark that @xmath358 due to monotonicity of @xmath34 .",
    "we will commonly denote by @xmath359 an element drawn from  @xmath56 .",
    "after a given interaction of @xmath17 with @xmath341 , let @xmath360 denote the string where @xmath32 is the output of @xmath361 on input @xmath362 , which is the @xmath19th output of @xmath17 .",
    "we denote the randomness used by  @xmath341 in execution @xmath19 by @xmath363 .    for @xmath364",
    "we now define the surplus @xmath365 .",
    "it denotes how much better @xmath17 performs than `` it should '' , in the case where the randomness of  @xmath341 in the first instance is fixed to @xmath366 , and the output of  @xmath367 is ignored ( i.e. , we do nt care whether @xmath17 solves the first puzzle right ) , and  @xmath103 is used instead : @xmath368 -    \\pr_{u\\leftarrow\\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_b],\\end{aligned}\\ ] ] where the first probability is also over the interaction between @xmath341 and @xmath17 as well as randomness @xmath17 uses ( if any ) .",
    "the algorithm then works as follows : first pick  @xmath369 candidates @xmath366 for the randomness of @xmath341 in the first position . for",
    "each of those , simulate the interaction @xmath370 and then get estimates  @xmath371 and @xmath372 of  @xmath373 and @xmath374 such that  @xmath375 almost surely .",
    "we consider two cases :    * one of the estimates satisfies @xmath376 .",
    "+ in this case , we fix  @xmath377 and  @xmath378 , and invoke  @xmath379 , using the function @xmath380 and circuit @xmath133 which is defined as follows : @xmath133 first ( internally ) simulates an interaction of @xmath381 with @xmath17 , then follows up with an interaction with @xmath382 . * for all estimates @xmath383 .",
    "+ in this case , we output the following circuit  @xmath384 : in a first phase , use @xmath17 to interact with @xmath381 . in the second phase ,",
    "simulate @xmath235 interactions with @xmath381 and obtain @xmath385 .",
    "for @xmath386 set @xmath387 .",
    "if  @xmath388 , return  @xmath331 , otherwise repeat the second phase @xmath389 times .",
    "if all attempts fail , return the special value  @xmath390 ( or an arbitrary answer ) .    due to space constraints",
    ", the proof of correctness of the above algorithm is omitted , but can be found in the appendix .    [ [ overview - of - correctness ] ] overview of correctness + + + + + + + + + + + + + + + + + + + + + + +    the interesting case is when @xmath73 does not recurse . in this case we know that @xmath17 has higher success probability than @xmath391 $ ] , but for most @xmath366 , the surpluses @xmath373 and @xmath374 are less than @xmath392 . intuitively , then @xmath17 is correct on the first coordinate unusually often when @xmath393 ( as this is the only time that being correct on the first coordinate helps ) . if we could assume that 1 ) that the algorithm",
    "always _ outputs an answer , and 2 ) for _ every _",
    "@xmath366 , the surpluses , @xmath373 and @xmath374 are less than @xmath392 , then the theorem would follow by straight - forward manipulations of probability .",
    "unfortunately these assumptions are not true , but the proof below shows that because these assumptions only fail slightly , not much is lost .",
    "informally , equations  [ eq:22]-[eq:27 ] show that if the algorithm fails to output an answer it is either because @xmath394 $ ] is very small ( in which case this @xmath366 will not contribute much anyhow ) , or because we are unlucky ( which happens with very small probability ) .",
    "additionally , equations  [ eq:29]-[eq:33 ] show that because we did not find a @xmath366 with large surplus , we can assume that ( unless we were very unlucky ) there are few @xmath366 with large surpluses , which can not have undue influence .",
    "[ [ analysis - of - correctness ] ] analysis of correctness + + + + + + + + + + + + + + + + + + + + + + +    consider first the case that we find @xmath395 for which @xmath396 .",
    "we can assume that @xmath397 , since the error is at most  @xmath398 almost surely .",
    "thus , we satisfy all the requirements to use @xmath73 with  @xmath235 ( using @xmath94 as the first input and @xmath399 as the monotone function with @xmath10 inputs ) , which will return a non - rewinding circuit for which @xmath400 \\geq \\delta + ( 1-\\frac{1}{k})\\epsilon/6(k-1 ) = \\delta + \\epsilon/6k$ ] . the remaining properties are easily verified .",
    "the more interesting case is if @xmath73 does not recurse .",
    "first , we get , for any puzzle  @xmath401 ( simply using  ( [ eq:13 ] ) and  @xmath358 ) : @xmath402 = \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^ * ] -    ( s_{\\pi^*,1 } - s_{\\pi^*,0})\\end{aligned}\\ ] ] and thus , still fixing  @xmath366 and multiplying by @xmath403 / \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1 - { \\mathcal{g}}_0]$ ] : @xmath404 & =    \\frac{\\pr_r[\\gamma^*(d(x^*,r))=1 ] \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^ * ] }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }   \\nonumber\\\\    & \\qquad\\qquad-    \\frac{\\pr_r[\\gamma^*(d(x^*,r))=1 ] ( s_{\\pi^*,1}-s_{\\pi^*,0 } ) }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}.\\label{eq:10}\\end{aligned}\\ ] ] we bound the first summand in ( [ eq:10 ] ) : @xmath405 \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^*]\\nonumber\\\\    & =    \\pr_r[\\gamma^*(d(x^*,r))\\neq \\bot ]    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^*].\\end{aligned}\\ ] ] if @xmath406 \\leq \\frac{\\epsilon}{6k}$ ] , then  @xmath407 \\pr[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] -\\frac{\\epsilon}{6k}$ ] . if @xmath408 > \\frac{\\epsilon}{6k}$ ] then @xmath409 \\geq 1-\\frac{\\epsilon}{6k}$ ] since @xmath18 only outputs  @xmath390 if after @xmath410 none of the elements  @xmath287 was in  @xmath411 . in both cases : @xmath412    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^*]\\\\    & \\geq    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] - \\frac{\\epsilon}{6 k}\\\\    & =    \\pr_{\\pi^{(k)}}[c_1 = 1 \\land c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0| \\pi_1 = \\pi^ * ] - \\frac{\\epsilon}{6 k}\\\\    & =    \\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] -    \\frac{\\epsilon}{6 k}\\\\    & = \\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - s_{\\pi^*,0 }    - \\frac{\\epsilon}{6 k }   \\label{eq:27}\\end{aligned}\\ ] ] inserting into ( [ eq:10 ] ) gives @xmath413\\bigr ]    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - \\frac{\\epsilon}{6 k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr ] \\nonumber\\\\ & \\qquad\\qquad    - { \\textbf{e}}_{\\pi^*}\\bigl[\\frac {      s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]      ( s_{\\pi^*,1 } - s_{\\pi^*,0})}{\\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr]\\label{eq:12}\\end{aligned}\\ ] ] we bound the second summand of  ( [ eq:12 ] ) .",
    "consider the set  @xmath414 of puzzles for which both @xmath374 and  @xmath373 are not very large .",
    "formally : @xmath415 almost surely , @xmath416 : otherwise @xmath73 would accept one of the sampled puzzles almost surely and recurse .",
    "thus , we get @xmath417    ( s_{\\pi^*,1 } - s_{\\pi^*,0})]\\nonumber\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^ * \\leftarrow { \\mathcal{w } } } [    s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]    ( s_{\\pi^*,1 } - s_{\\pi^*,0})]\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^*\\leftarrow{\\mathcal{w } } } [    s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]    ( ( 1-\\frac{1}{2k})\\epsilon - s_{\\pi^*,0})]\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^*\\leftarrow{\\mathcal{w } } } [    s_{\\pi^*,0 } + ( ( 1-\\frac{1}{2k})\\epsilon - s_{\\pi^*,0})]\\\\    & = \\bigl(1-\\frac{1}{3k}\\bigr)\\epsilon .",
    "\\label{eq:33}\\end{aligned}\\ ] ] we insert into ( [ eq:12 ] ) ( and then use @xmath418= \\pr[u \\in { \\mathcal{g}}_0 ] + \\delta \\pr[u\\in{\\mathcal{g}}_1 - { \\mathcal{g}}_0]$ ] ) to get @xmath419\\\\    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - \\frac{\\epsilon}{6 k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }    -    \\frac{(1-\\frac{1}{3k})\\epsilon}{\\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr]\\\\    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{u\\leftarrow\\mu_\\delta^k}[g(u ) = 1 ] + \\epsilon - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - ( 1-\\frac{1}{6k})\\epsilon }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr ] \\\\    &",
    "=    \\frac{\\delta",
    "\\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in { \\mathcal{g}}_1-{\\mathcal{g}}_0 ] + \\frac{\\epsilon}{6k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }    \\geq \\delta + \\frac{\\epsilon}{6k}.\\end{aligned}\\ ] ] this concludes the proof of theorem  [ theorem wvp].@xmath420",
    "theorems  [ theorem bit protocols ] and  [ theorem wvp ] can be used to show how to strengthen bit commitment protocols , which was the main open problem in @xcite .",
    "we explain this as an example here .",
    "assume we have given a weak bit protocol , where a cheating receiver can guess a bit after the commitment phase with probability @xmath421 , and a cheating sender can change the bit he committed to with probability @xmath422 .",
    "we show that such a protocol can be strengthened if @xmath423 .",
    "we should point out that a different way to prove a similar theorem exists : one can first show that such a weak bit - commitment protocol implies one - way functions ( using the techniques of @xcite ) .",
    "the long sequence of works @xcite imply that one - way functions are sufficient to build bit commitment protocols ( the first two papers will yield statistically binding protocols , the last three statistically hiding protocols ) .",
    "however , this will be less efficient and also seems less natural than the method we use here .",
    "theorems  [ theorem bit protocols ] and  [ theorem wvp ] can be used to show how to strengthen bit commitment protocols .",
    "we explain this as an example here .",
    "assume we have given a weak bit protocol , where a cheating receiver can guess a bit after the commitment phase with probability @xmath421 , and a cheating sender can change the bit he committed to with probability @xmath422 .",
    "we show that such a protocol can be strengthened if @xmath424 .",
    "we should point out that a different way to prove a similar theorem exists : one can first show that such a weak bit - commitment protocol implies one - way functions ( using the techniques of @xcite ) . the long sequence of works @xcite",
    "imply that one - way functions are sufficient to build bit commitment protocols ( the first two papers will yield statistically binding protocols , the last three statistically hiding protocols )",
    ". however , this will be less efficient and also seems less natural than the method we use here .",
    "we formalize a `` weak '' bit commitment protocol between a sender and a receiver by considering algorithms  @xmath425 and  @xmath426 , where  @xmath103 is the bit which the sender commits to , and @xmath427 and @xmath428 are the randomness of the sender and receiver respectively .",
    "we denote by @xmath429 the communication which one obtains by running @xmath425 interacting with  @xmath426 .",
    "also , @xmath430 denotes the output which @xmath14 produces in such an interaction , which for an honest @xmath14 will be used later to verify the commitment .",
    "let @xmath431 denote the output receiver @xmath9 produces which can be thought of as a guess of @xmath103 .",
    "correctness : :    the protocol works if both parties are honest . more concretely ,    for  @xmath435 and    @xmath436    we have that @xmath437 with probability    @xmath438 . binding : :    a malicious sender can not open the commitment in two ways : for any    randomized polynomial time machine @xmath439 , setting    @xmath440 , the probability that    @xmath80 outputs @xmath441    and  @xmath442 such that @xmath443 and @xmath444 is at most    @xmath422 .",
    "hiding : :    for any randomized polynomial time machine  @xmath445 ,    @xmath446 \\leq        1-\\frac{\\beta}{2}$ ] , if  @xmath103 is chosen uniformly at    random .",
    "we point out that our notation is chosen such that for a strong bit commitment scheme , @xmath450 and  @xmath451 . given an @xmath422-binding @xmath432-hiding bit commitment protocol , we would like to use it to get a strong bit commitment protocol . by a simulation technique @xcite",
    "this is impossible if  @xmath452 ( there is a simple protocol which achieves this bound for semi - honest parties without any assumption : with probability  @xmath453 the sender sends his output bit to the receiver , and otherwise neither party sends anything ) .",
    "our results will show that if  @xmath454 then such a strengthening exists .",
    "previously , such a result was only known for @xmath455 @xcite ( if one is restricted to reductions in which the parties can only use the given protocol interactively , and not to build a one - way function ) .",
    "given a weak protocol  @xmath456 , we will transform it as follows : the parties will execute  @xmath456 sequentially @xmath10 times , where the sender uses random bits as input .",
    "then , they will apply an `` extraction protocol '' , which is made with the following two properties in mind : a party who knows at least  @xmath453 fraction of the committed bits will know the output bit almost surely ; a party who has no information about @xmath457 fraction of the input bits will have no information about the output bit almost surely .",
    "it turns out that such an extraction process can be modeled as a monotone boolean circuit , where every wire is used in at most one gate ( i.e. , read - once formulas ) .    to get such a circuit , we use the following lemma .",
    "it can be obtained by the techniques of valiant @xcite .",
    "also , it appears in a more disguised form as lemma 7 in @xcite ( where it is used for the same task we use it here , but not stated in this language ) .",
    "there exists a @xmath459 and an efficiently computable monotone circuit  @xmath460 where every wire is used in at most one gate and such that @xmath461 > 1 - 2^{-n }    \\end{aligned}\\ ] ] and @xmath462 < 2^{-n }    \\end{aligned}\\ ] ]        let  @xmath456 be an @xmath422-binding and  @xmath432-hiding bit commitment protocol for polynomial time computable functions  @xmath422 and @xmath432 with @xmath424 .",
    "then , there is an oblivious black - box construction of a bit commitment scheme @xmath463 .",
    "let  @xmath34 be as guaranteed by lemma  [ lem : dks99 ] for these parameters  @xmath464 , and  @xmath10 the input length of  @xmath34 .",
    "the players run  @xmath10 instances of  @xmath456 sequentially , where the sender commits to a uniform random bit @xmath32 in instance  @xmath19 .",
    "we associate each @xmath32 to one of the input wires .",
    "the sender then runs the following `` extraction protocol '' , in which he uses additional variables on all gates . ]",
    "we associate those with the other wires in @xmath34 . as evaluating which values in the following protocols",
    "look completely random : a @xmath5 on wire  @xmath19 signalizes that @xmath32 looks random to some party . ]",
    "the sender then traverses @xmath34 as if he were evaluating the circuit .",
    "when encountering a gate with input wires  @xmath19 , @xmath466 , and output wire  @xmath467 , he distinguish two cases . if the gate is an or gate , set  @xmath468 .",
    "if the gate is an and gate , the sender sets  @xmath469 to be a completely new random value and sends @xmath470 and @xmath471 to the receiver .",
    "once the sender `` evaluated '' @xmath34 in this way , he sends @xmath472 to the receiver ( where  @xmath103 is the input to the sender , and  @xmath473 is the bit associated with the output wire of @xmath34 ) .",
    "to open the commitment , the sender sends all the opening information for the individual positions to the receiver .",
    "the receiver then checks if the extraction phase was done consistently , and accepts if all these tests succeed and the output matches .",
    "_ hiding : _ we would like to use theorem  [ theorem bit protocols ] . for this , it only remains to argue that the extraction protocol is information theoretically secure . for any @xmath432-hiding random variables ,",
    "we define a random variable @xmath474 over  @xmath54 by fixing @xmath475 =    \\frac{\\min(\\pr[x=0 , z = z ] , \\pr[x=1,z = z])}{\\pr[x = x , z = z]}$ ] .",
    "one checks that for any function @xmath476 we have @xmath477 = \\frac{1}{2}$ ] and @xmath478 = 1 - \\frac{\\beta}{2}$ ] ( the point of @xmath474 is that it is @xmath5 exactly if @xmath279 gives no information about @xmath278 , and furthermore @xmath474 is often @xmath5 ) .",
    "we get random variables @xmath479 in this way , and evaluate the circuit @xmath480 .",
    "one sees per induction that @xmath481 together with the communication produced gives no information about the bit corresponding to a wire iff the corresponding value when evaluating @xmath480 is one .",
    "since the probability that the output is @xmath5 is @xmath482 , we get the information theoretic security .",
    "_ binding : _ we can interpret the bit commitment protocol as an interactive weakly verifiable puzzle : in the interaction , the receiver is the person posing the puzzle , and the sender is the solver . in order to solve the puzzle",
    ", the sender needs to send two valid openings to the receiver .    in order to break the resulting puzzle",
    ", the sender needs to solve the subpuzzles in all positions @xmath483 for some input for which @xmath484 . using theorem  [ theorem wvp ] for @xmath485",
    "thus gives the result .",
    "theorems  [ theorem bit protocols ] and  [ theorem wvp ] can be used to show how to strengthen bit commitment protocols .",
    "we explain this as an example here .",
    "assume we have given a weak bit protocol , where a cheating receiver can guess a bit after the commitment phase with probability @xmath421 , and a cheating sender can change the bit he committed to with probability @xmath422 .",
    "we show that such a protocol can be strengthened if @xmath424 .",
    "we should point out that a different way to prove a similar theorem exists : one can first show that such a weak bit - commitment protocol implies one - way functions ( using the techniques of @xcite ) .",
    "the long sequence of works @xcite imply that one - way functions are sufficient to build bit commitment protocols ( the first two papers will yield statistically binding protocols , the last three statistically hiding protocols ) . however , this will be less efficient and also seems less natural than the method we use here .",
    "we formalize a `` weak '' bit commitment protocol between a sender and a receiver by considering algorithms  @xmath425 and  @xmath426 , where  @xmath103 is the bit which the sender commits to , and @xmath427 and @xmath428 are the randomness of the sender and receiver respectively .",
    "we denote by @xmath429 the communication which one obtains by running @xmath425 interacting with  @xmath426 .",
    "also , @xmath430 denotes the output which @xmath14 produces in such an interaction , which for an honest @xmath14 will be used later to verify the commitment .",
    "let @xmath431 denote the output receiver @xmath9 produces which can be thought of as a guess of @xmath103 .",
    "correctness : :    the protocol works if both parties are honest . more concretely ,    for  @xmath435 and    @xmath436    we have that @xmath437 with probability    @xmath438 . binding : :    a malicious sender can not open the commitment in two ways : for any    randomized polynomial time machine @xmath439 , setting    @xmath440 , the probability that    @xmath80 outputs @xmath441    and  @xmath442 such that @xmath443 and @xmath444 is at most    @xmath422 .",
    "hiding : :    for any randomized polynomial time machine  @xmath445 ,    @xmath446 \\leq        1-\\frac{\\beta}{2}$ ] , if  @xmath103 is chosen uniformly at    random .",
    "we point out that our notation is chosen such that for a strong bit commitment scheme , @xmath450 and  @xmath451 . given an @xmath422-binding @xmath432-hiding bit commitment protocol",
    ", we would like to use it to get a strong bit commitment protocol . by a simulation technique",
    "@xcite this is impossible if  @xmath452 ( there is a simple protocol which achieves this bound for semi - honest parties without any assumption : with probability  @xmath453 the sender sends his output bit to the receiver , and otherwise neither party sends anything ) .",
    "our results will show that if  @xmath454 then such a strengthening exists .",
    "previously , such a result was only known for @xmath455 @xcite ( if one is restricted to reductions in which the parties can only use the given protocol interactively , and not to build a one - way function ) .",
    "given a weak protocol  @xmath456 , we will transform it as follows : the parties will execute  @xmath456 sequentially @xmath10 times , where the sender uses random bits as input .",
    "then , they will apply an `` extraction protocol '' , which is made with the following two properties in mind : a party who knows at least  @xmath453 fraction of the committed bits will know the output bit almost surely ; a party who has no information about @xmath457 fraction of the input bits will have no information about the output bit almost surely .",
    "it turns out that such an extraction process can be modeled as a monotone boolean circuit , where every wire is used in at most one gate ( i.e. , read - once formulas ) .",
    "to get such a circuit , we use the following lemma .",
    "it can be obtained by the techniques of valiant @xcite .",
    "also , it appears in a more disguised form as lemma 7 in @xcite ( where it is used for the same task we use it here , but not stated in this language ) .",
    "there exists a @xmath459 and an efficiently computable monotone circuit  @xmath460 where every wire is used in at most one gate and such that @xmath461 > 1 - 2^{-n }    \\end{aligned}\\ ] ] and @xmath462 < 2^{-n }    \\end{aligned}\\ ] ]        let  @xmath456 be an @xmath422-binding and  @xmath432-hiding bit commitment protocol for polynomial time computable functions  @xmath422 and @xmath432 with @xmath424 .",
    "then , there is an oblivious black - box construction of a bit commitment scheme @xmath463 .",
    "let  @xmath34 be as guaranteed by lemma  [ lem : dks99 ] for these parameters  @xmath464 , and  @xmath10 the input length of  @xmath34 .",
    "the players run  @xmath10 instances of  @xmath456 sequentially , where the sender commits to a uniform random bit @xmath32 in instance  @xmath19 .",
    "we associate each @xmath32 to one of the input wires .",
    "the sender then runs the following `` extraction protocol '' , in which he uses additional variables on all gates . ]",
    "we associate those with the other wires in @xmath34 . as evaluating which values in the following protocols",
    "look completely random : a @xmath5 on wire  @xmath19 signalizes that @xmath32 looks random to some party . ]",
    "the sender then traverses @xmath34 as if he were evaluating the circuit . when encountering a gate with input wires  @xmath19 , @xmath466 , and output wire  @xmath467 , he distinguish two cases . if the gate is an or gate , set  @xmath468 .",
    "if the gate is an and gate , the sender sets  @xmath469 to be a completely new random value and sends @xmath470 and @xmath471 to the receiver .",
    "once the sender `` evaluated '' @xmath34 in this way , he sends @xmath472 to the receiver ( where  @xmath103 is the input to the sender , and  @xmath473 is the bit associated with the output wire of @xmath34 ) .",
    "to open the commitment , the sender sends all the opening information for the individual positions to the receiver .",
    "the receiver then checks if the extraction phase was done consistently , and accepts if all these tests succeed and the output matches .",
    "_ hiding : _ we would like to use theorem  [ theorem bit protocols ] . for this , it only remains to argue that the extraction protocol is information theoretically secure . for any @xmath432-hiding random variables ,",
    "we define a random variable @xmath474 over  @xmath54 by fixing @xmath475 =    \\frac{\\min(\\pr[x=0 , z = z ] , \\pr[x=1,z = z])}{\\pr[x = x , z = z]}$ ] .",
    "one checks that for any function @xmath476 we have @xmath477 = \\frac{1}{2}$ ] and @xmath478 = 1 - \\frac{\\beta}{2}$ ] ( the point of @xmath474 is that it is @xmath5 exactly if @xmath279 gives no information about @xmath278 , and furthermore @xmath474 is often @xmath5 ) .",
    "we get random variables @xmath479 in this way , and evaluate the circuit @xmath480 .",
    "one sees per induction that @xmath481 together with the communication produced gives no information about the bit corresponding to a wire iff the corresponding value when evaluating @xmath480 is one .",
    "since the probability that the output is @xmath5 is @xmath482 , we get the information theoretic security .    _",
    "binding : _ we can interpret the bit commitment protocol as an interactive weakly verifiable puzzle : in the interaction , the receiver is the person posing the puzzle , and the sender is the solver . in order to solve the puzzle",
    ", the sender needs to send two valid openings to the receiver .    in order to break the resulting puzzle , the sender needs to solve the subpuzzles in all positions @xmath483 for some input for which @xmath484 . using theorem  [ theorem wvp ] for @xmath485",
    "thus gives the result .",
    "we describe algorithm @xmath73 . first , obtain an estimate @xmath117 -      \\pr_{r , x}[c(x,1-p(x ) , r)=1 ]    \\end{aligned}\\ ] ] such that almost surely @xmath118 is within  @xmath119 of the actual quantity .",
    "if  @xmath120 , we can return  @xmath121 , @xmath122 , and a circuit  @xmath71 which guesses a uniform random bit . if  @xmath123 replace @xmath17 with the circuit which outputs  @xmath124 in the following argument .",
    "thus , from now on assume  @xmath125 and that the actual quantity is at least  @xmath126 .",
    "sample random strings  @xmath127 for @xmath17 , where  @xmath128 , and let  @xmath129 be the circuit which computes @xmath130 . using a chernoff bound , we see that for all @xmath64 @xmath131 -      \\pr_r[c(x,1-p(x ) , r)]=1]= \\nonumber\\\\      & \\pr_{i \\in [ m]}[c'(x , p(x ) , i)=1 ] - \\pr_{i \\in [ m]}[c'(x,1-p(x ) , i)]=1 ]      \\pm \\epsilon/4    \\end{aligned}\\ ] ] almost surely .",
    "define , for any  @xmath1 , @xmath132}[c'(x , p(x ) , r_i)=1 ] - \\pr_{i \\in [ m]}[c'(x,1-p(x ) , r_i)=1 ] .",
    "\\end{aligned}\\ ] ] because we define  @xmath91 using  @xmath133 instead of @xmath17 , we can compute  @xmath91 exactly for a given  @xmath1 . now ,",
    "order the  @xmath1 according to @xmath91 : let  @xmath134 if @xmath135 , or both  @xmath136 and  @xmath137 , where  @xmath138 is the lexicographic ordering on bitstrings .",
    "we can compute  @xmath134 efficiently given @xmath139 and @xmath140 .",
    "we claim that we can find  @xmath94 such that almost surely ( we assume  @xmath141 , otherwise we can get the theorem with exhaustive search ) @xmath142 we pick  @xmath143 candidates , then almost surely one of them satisfies  ( [ eq:3 ] ) with a safety margin of  @xmath144 . for each of those candidates we estimate @xmath145 up to an error of  @xmath146 , and keep one for which almost surely  ( [ eq:3 ] ) is satisfied .",
    "we let @xmath77 be the circuit which recognizes the set  @xmath147 , estimate  @xmath148 almost surely within an error of  @xmath149 , and output  @xmath150 .",
    "the situation at this moment is illustrated in figure  [ fig : littlepicture ] , and it is clear that the properties `` large set '' and `` indistinguishability '' are satisfied .",
    "we next describe  @xmath71 . on input @xmath1",
    ", @xmath71 calculates ( exactly ) @xmath151}[c'(x,1 , i ) = 1 ] - \\pr_{i \\in [ m]}[c'(x,0 , i ) = 1 ] = ( 2p(x)-1)\\delta_x\\;.    \\end{aligned}\\ ] ] if @xmath152 ( where  @xmath95 is defined by  ( [ eq:4 ] ) for the element  @xmath94 which defines  @xmath14 ) , then output  @xmath5 , if @xmath153 output @xmath90 .",
    "if neither of the previous cases apply , output  @xmath5 with probability @xmath154 .    to analyze the success probability of @xmath71 , we distinguish two cases . if  @xmath101 , we know that  @xmath155",
    ". therefore , in this case , we get the correct answer with probability @xmath5 .",
    "if  @xmath156 , it is also easy to check that this will give the correct answer with probability @xmath157 , and thus , on average @xmath158 , using  ( [ eq:3 ] ) . in total",
    ", we have probability at least @xmath159 of answering correctly . since @xmath160 , this quantity is at least @xmath161 , which implies `` predictability '' .",
    "it is possible to make @xmath71 deterministic by trying all possible values for the randomness and estimating the probability of it being correct .    in order to get the additional property 1",
    ", we first run the above algorithm with input @xmath162 instead of @xmath27 .",
    "if @xmath163 , we instead output the set containing all elements and return @xmath5 in place of @xmath4 .",
    "note that indistinguishability still holds because we only add a fraction of @xmath164 elements to @xmath14 .",
    "if @xmath165 , we enlarge @xmath14 by at least @xmath126 and at most @xmath164 ; this can be done by finding a new candidate for @xmath94 as above .",
    "we then output the new set and @xmath166 .",
    "for any fixed tuple @xmath192 , consider the circuit  @xmath210 which uses @xmath66 to pick random  @xmath188 for  @xmath211 , and runs  @xmath212",
    ". may not be a small circuit because at this point we do not assume @xmath16 to be efficiently samplable , and @xmath213 seems to need to use @xmath66 to sample pairs @xmath214 for @xmath211 .",
    "however , we can think of @xmath213 as oracle circuit with oracle access to @xmath16 at this moment .",
    "inspection of the previous proof shows that later we can remove the calls to @xmath16 , as the @xmath215 with @xmath211 can be fixed .",
    "] we let @xmath191 be the algorithm which invokes @xmath73 with parameter @xmath216 from theorem  [ theorem single pred ] on the circuit  @xmath213 and then returns the circuit recognizing a set from there .",
    "we next describe @xmath73 : for  @xmath217 iterations , pick a random  @xmath218 , use the procedure in experiment  2 until loop @xmath19 , and run algorithm @xmath73 from theorem  [ theorem single pred ] with parameter @xmath216 .",
    "this yields a parameter @xmath4 and a circuit @xmath71 .",
    "we output the pair  @xmath219 for the smallest  @xmath4 ever encountered .",
    "since @xmath10 and @xmath27 are polynomial in @xmath220 , almost surely every time theorem  [ theorem single pred ] is used the almost surely part happens .",
    "thus , we get the property `` predictability '' ( and in fact the stronger property listed under additionally ) immediately .",
    "we now argue `` large sets '' : consider the random variable @xmath4 when we pick a random @xmath19 , simulate an execution up to iteration @xmath19 of experiment  2 , then run @xmath73 from theorem  [ theorem single pred ] .",
    "let @xmath221 be the @xmath222-quantile of this distribution , i.e. , the smallest value such that with probability @xmath222 the value of @xmath4 is at most @xmath221 . the probability that a value not bigger than @xmath221 is output by @xmath73 is at least @xmath223 , in which case `` large sets '' is satisfied .      .... * \\textbf{random experiment $ h_j$ : } *          for $ i : = 1 $ to $ k$ do             $ t_i : = ( x_1,b_1,\\ldots , t_{i-1 } , b_{i-1})$             $ s_{i}^ * : = \\gens(t_i)$             $ x_i \\leftarrow \\{0,1\\}^n$             if $ i \\leq j$ and $ x_i \\in s^*_t$ then                $ b_i \\leftarrow \\{0,1\\}$             else                $ b_i : = p(x_i)$             end if          end for          $ r \\leftarrow \\{0,1\\}^*$          output $ c^{(k)}(x_1,b_1,\\ldots , x_k , b_k , r)$ ....    experiment  @xmath225 is equivalent to experiment  @xmath5 , experiment @xmath226 is the same as experiment  @xmath227 .",
    "applying theorem  [ theorem single pred ] we get that for every fixed  @xmath228 , almost surely @xmath229 -\\nonumber\\\\    \\pr_{x_i,\\ldots , x_k}[&c^{(k)}(x_1,b_1,\\ldots , x_{j-1},b_{j-1},x_j , b_j^{(j)},\\ldots , x_k , p(x_k ) ) = 1 ] \\bigr|    \\leq \\epsilon/4k\\;,\\end{aligned}\\ ] ] where @xmath230 is chosen as @xmath231 in experiment @xmath232 , and @xmath233 is chosen the same way as @xmath189 is chosen in experiment @xmath234 ( in theorem  [ theorem single pred ] the bit is flipped , but when using a uniform bit instead of flipping it the distinguishing probability only gets smaller ) . applying the triangle inequality @xmath235 times",
    "we get that almost surely the difference of the probabilities in experiment  1 and experiment  2 is at most @xmath236 .",
    "since `` almost surely '' means with probabilities @xmath237 , we get `` indistinguishability '' .",
    "the interesting case is when @xmath73 does not recurse . in this case",
    "we know that @xmath17 has higher success probability than @xmath391 $ ] , but for most @xmath366 , the surpluses @xmath373 and @xmath374 are less than @xmath392 . intuitively , then @xmath17 is correct on the first coordinate unusually often when @xmath393 ( as this is the only time that being correct on the first coordinate helps ) . if we could assume that 1 ) that the algorithm _",
    "always _ outputs an answer , and 2 ) for _ every _",
    "@xmath366 , the surpluses , @xmath373 and @xmath374 are less than @xmath392 , then the theorem would follow by straight - forward manipulations of probability .",
    "unfortunately these assumptions are not true , but the proof below shows that because these assumptions only fail slightly , not much is lost .",
    "informally , equations  [ eq:22]-[eq:27 ] show that if the algorithm fails to output an answer it is either because @xmath394 $ ] is very small ( in which case this @xmath366 will not contribute much anyhow ) , or because we are unlucky ( which happens with very small probability ) .",
    "additionally , equations  [ eq:29]-[eq:33 ] show that because we did not find a @xmath366 with large surplus , we can assume that ( unless we were very unlucky ) there are few @xmath366 with large surpluses , which can not have undue influence .",
    "consider first the case that we find @xmath395 for which @xmath396 .",
    "we can assume that @xmath397 , since the error is at most  @xmath398 almost surely .",
    "thus , we satisfy all the requirements to use @xmath73 with  @xmath235 ( using @xmath94 as the first input and @xmath399 as the monotone function with @xmath10 inputs ) , which will return a non - rewinding circuit for which @xmath400 \\geq \\delta + ( 1-\\frac{1}{k})\\epsilon/6(k-1 ) = \\delta + \\epsilon/6k$ ] . the remaining properties are easily verified .",
    "the more interesting case is if @xmath73 does not recurse .",
    "first , we get , for any puzzle  @xmath401 ( simply using  ( [ eq:13 ] ) and  @xmath358 ) : @xmath402 = \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^ * ] -    ( s_{\\pi^*,1 } - s_{\\pi^*,0})\\end{aligned}\\ ] ] and thus , still fixing  @xmath366 and multiplying by @xmath403 / \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1 - { \\mathcal{g}}_0]$ ] : @xmath404 & =    \\frac{\\pr_r[\\gamma^*(d(x^*,r))=1 ] \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^ * ] }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }   \\nonumber\\\\    & \\qquad\\qquad-    \\frac{\\pr_r[\\gamma^*(d(x^*,r))=1 ] ( s_{\\pi^*,1}-s_{\\pi^*,0 } ) }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}.\\label{eq:10}\\end{aligned}\\ ] ] we bound the first summand in ( [ eq:10 ] ) : @xmath405 \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0|\\pi_1 = \\pi^*]\\nonumber\\\\    & =    \\pr_r[\\gamma^*(d(x^*,r))\\neq \\bot ]    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^*].\\end{aligned}\\ ] ] if @xmath406 \\leq \\frac{\\epsilon}{6k}$ ] , then  @xmath407 \\pr[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] -\\frac{\\epsilon}{6k}$ ] . if @xmath408 > \\frac{\\epsilon}{6k}$ ] then @xmath409 \\geq 1-\\frac{\\epsilon}{6k}$ ] since @xmath18 only outputs  @xmath390 if after @xmath410 none of the elements  @xmath287 was in  @xmath411 . in both cases : @xmath412    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^*]\\\\    & \\geq    \\pr_{\\pi^{(k)}}[c_1 = 1 | c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 , \\pi_1 = \\pi^ * ]    \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] - \\frac{\\epsilon}{6 k}\\\\    & =    \\pr_{\\pi^{(k)}}[c_1 = 1 \\land c \\in { \\mathcal{g}}_1 - { \\mathcal{g}}_0| \\pi_1 = \\pi^ * ] - \\frac{\\epsilon}{6 k}\\\\    & =    \\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{\\pi^{(k)}}[c \\in { \\mathcal{g}}_0 | \\pi_1 = \\pi^ * ] -    \\frac{\\epsilon}{6 k}\\\\    & = \\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - s_{\\pi^*,0 }    - \\frac{\\epsilon}{6 k }   \\label{eq:27}\\end{aligned}\\ ] ] inserting into ( [ eq:10 ] ) gives @xmath413\\bigr ]    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - \\frac{\\epsilon}{6 k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr ] \\nonumber\\\\ & \\qquad\\qquad    - { \\textbf{e}}_{\\pi^*}\\bigl[\\frac {      s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]      ( s_{\\pi^*,1 } - s_{\\pi^*,0})}{\\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr]\\label{eq:12}\\end{aligned}\\ ] ] we bound the second summand of  ( [ eq:12 ] ) .",
    "consider the set  @xmath414 of puzzles for which both @xmath374 and  @xmath373 are not very large .",
    "formally : @xmath415 almost surely , @xmath416 : otherwise @xmath73 would accept one of the sampled puzzles almost surely and recurse .",
    "thus , we get @xmath417    ( s_{\\pi^*,1 } - s_{\\pi^*,0})]\\nonumber\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^ * \\leftarrow { \\mathcal{w } } } [    s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]    ( s_{\\pi^*,1 } - s_{\\pi^*,0})]\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^*\\leftarrow{\\mathcal{w } } } [    s_{\\pi^*,0 } + \\pr_r[\\gamma^*(d(x^*,r))=1 ]    ( ( 1-\\frac{1}{2k})\\epsilon - s_{\\pi^*,0})]\\\\    & \\leq    \\frac{\\epsilon}{6k } +    { \\textbf{e}}_{\\pi^*\\leftarrow{\\mathcal{w } } } [    s_{\\pi^*,0 } + ( ( 1-\\frac{1}{2k})\\epsilon - s_{\\pi^*,0})]\\\\    & = \\bigl(1-\\frac{1}{3k}\\bigr)\\epsilon . \\label{eq:33}\\end{aligned}\\",
    "] ] we insert into ( [ eq:12 ] ) ( and then use @xmath418= \\pr[u \\in { \\mathcal{g}}_0 ] + \\delta \\pr[u\\in{\\mathcal{g}}_1 - { \\mathcal{g}}_0]$ ] ) to get @xmath486    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{\\pi^{(k)}}[g(c ) = 1 | \\pi_1 = \\pi^ * ] - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - \\frac{\\epsilon}{6 k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }    -    \\frac{(1-\\frac{1}{3k})\\epsilon}{\\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr]\\\\    & \\geq    { \\textbf{e}}_{\\pi^*}\\bigl [    \\frac{\\pr_{u\\leftarrow\\mu_\\delta^k}[g(u ) = 1 ] + \\epsilon - \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u \\in { \\mathcal{g}}_0 ] - ( 1-\\frac{1}{6k})\\epsilon }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0]}\\bigr ] \\\\    &",
    "=    \\frac{\\delta \\pr_{u",
    "\\leftarrow \\mu_{\\delta}^k}[u\\in { \\mathcal{g}}_1-{\\mathcal{g}}_0 ] + \\frac{\\epsilon}{6k } }    { \\pr_{u \\leftarrow \\mu_{\\delta}^k}[u\\in{\\mathcal{g}}_1-{\\mathcal{g}}_0 ] }    \\geq \\delta + \\frac{\\epsilon}{6k}.\\end{aligned}\\ ] ] this concludes the proof of theorem  [ theorem wvp].@xmath420"
  ],
  "abstract_text": [
    "<S> we give new proofs for the hardness amplification of efficiently samplable predicates and of weakly verifiable puzzles which generalize to new settings . more concretely , </S>",
    "<S> in the first part of the paper , we give a new proof of yao s xor - lemma that additionally applies to related theorems in the cryptographic setting . </S>",
    "<S> our proof seems simpler than previous ones , yet immediately generalizes to statements similar in spirit such as the extraction lemma used to obtain pseudo - random generators from one - way functions [ hstad , impagliazzo , levin , luby , siam j. on comp . </S>",
    "<S> 1999 ] .    </S>",
    "<S> in the second part of the paper , we give a new proof of hardness amplification for weakly verifiable puzzles , which is more general than previous ones in that it gives the right bound even for an arbitrary monotone function applied to the checking circuit of the underlying puzzle .    </S>",
    "<S> both our proofs are applicable in many settings of interactive cryptographic protocols because they satisfy a property that we call  non - rewinding \" . </S>",
    "<S> in particular , we show that any weak cryptographic protocol whose security is given by the unpredictability of single bits can be strengthened with a natural information theoretic protocol . as an example </S>",
    "<S> , we show how these theorems solve the main open question from [ halevi and rabin , tcc2008 ] concerning bit commitment .    </S>",
    "<S> * keywords : * hardness amplification , weakly verifiable puzzles , xor lemma </S>"
  ]
}