{
  "article_text": [
    "any planar straight - line graph ( pslg ) subdivides the plane into cells , some of which may be unbounded . the voronoi diagram ( also commonly referred to as _ dirichlet tesselation _ , or _",
    "thiessen polygon _ ) of a set @xmath1 of @xmath2 points is a pslg with @xmath2 cells , where each cell belongs to one point from @xmath1 and consists of all points in the plane that are closer to that point than to any other in @xmath1 .",
    "let @xmath0 be a given pslg , whose cells can be considered bounded and convex for all practical purposes . indeed ,",
    "if some cell is not convex , it can always be partitioned into convex subcells , thus yielding a finer tesselation .",
    "the asymptotic size complexity of the pslg remains the same by this convexification  operation .",
    "the _ inverse voronoi problem _ ( ivp ) consists of deciding whether @xmath0 coincides with the voronoi diagram of some set @xmath1 of points in the plane , and if so , finding @xmath1 .",
    "this problem was first studied by ash and bolker  @xcite .",
    "subsequently , aurenhammer presented a more efficient algorithm  @xcite , which in turn was improved by hartvigsen , with the aid of linear programming  @xcite , and later by schoenberg , ferguson and li  @xcite .",
    "yeganova also used linear programming to determine the location of @xmath1  @xcite .    in the ivp ,",
    "the set @xmath1 is limited to have one point per cell ; a generalized version of this problem ( givp ) allows more than one point per cell . in this case",
    ", new vertices and edges may be added to @xmath0 , but the original ones must be kept , as shown in figure [ givp1 ] . with this relaxation the set @xmath1 always exists , hence we are interested in minimizing its size .",
    "[ givp1 ]    the givp in @xmath3 was indirectly mentioned in @xcite , in the context of set separation .",
    "it was formally stated and discussed in the iii cuban workshop on algorithms and data structures , held in havana in 2003 , where an algorithm for solving the problem in @xmath3 was sketched by the current authors . however , the manuscript remained dormant for several years , and the algorithm was only published in spanish in 2007 @xcite .",
    "recently , the problem was revisited in @xcite , where another algorithm for the givp in @xmath3 is given , and the special case of a rectangular tesselation is discussed in greater detail .",
    "the authors of @xcite were unaware of @xcite , however the two algorithms turn out to have certain common aspects .",
    "this paper is an expanded and updated english version of @xcite .",
    "it contains a description and analysis of the aforementioned algorithm for solving the givp in @xmath3 .",
    "this is followed by the description of an implementation of the algorithm , which was used to make a first ( if only preliminary ) experimental study of the algorithm s performance .",
    "our algorithm generates @xmath4 sites in the worst case , where @xmath5 is the number of edges of @xmath0 ( provided that the smallest angle of @xmath0 is constant ) .",
    "this bound is asymptotically optimal for tesselations with such angular constraints .    in comparison ,",
    "the analysis given for the algorithm in  @xcite states that @xmath6 sites are generated , where @xmath7 is the size of a refinement of @xmath0 such that all faces are triangles with acute angles . given an arbitrary pslg",
    ", there does not appear to be any known polynomial upper bound on the size of its associated acute triangulation .",
    "even though it seems to us that the analysis in  @xcite should have given a tighter upper bound in terms of @xmath7 , even a linear bound would not make much of a difference , given that @xmath7 can be very large compared to the size of @xmath0 .",
    "the analysis in  @xcite is purely theoretical , so it would be interesting to perform an experimental study to shed some light on the algorithm s performance in practice .",
    "this paper is organized as follows : in section [ aljuarizmi ] we describe the algorithm and discuss its correctness and performance . in section",
    "[ implement ] we derive some variants of the general strategy , and deal with several implementation issues of each variant . section [ exper ] is devoted to an experimental analysis of the algorithm s performance . finally , in section [ open ]",
    "we summarize our results and discuss some open problems arising as a result of our work .",
    "first we establish some notation and definitions . in that respect",
    "we have followed some standard texts , such as @xcite .",
    "let @xmath8 and @xmath9 be points of the plane ; as customary , @xmath10 is the segment that joins @xmath8 and @xmath9 , and @xmath11 denotes its length .",
    "@xmath12 denotes the bisector of @xmath8 and @xmath9 , and @xmath13 is the half - plane determined by @xmath12 , containing @xmath8 . for a set @xmath1 of points in the plane , vor(@xmath1 ) denotes the _ voronoi diagram _ generated by @xmath1 .",
    "the points in @xmath1 are called _ voronoi sites _ or _",
    "generators_.    if @xmath14 , @xmath15 denotes the cell of vor(@xmath1 ) corresponding to the site @xmath8 . for any point @xmath9",
    ", @xmath16 is the largest empty circle centered at @xmath9 , with respect to @xmath1 ( the subscript @xmath1 can be dropped if it is clear from the context ) .",
    "two points @xmath17 are said to be _",
    "( strong ) neighbors _ ( with respect to @xmath1 ) if their cells share an edge in vor(@xmath1 ) ; in this case @xmath18 denotes that edge .",
    "we will make frequent use of the following basic property of voronoi diagrams :    [ when - edge ] the bisector @xmath12 defines an edge of the voronoi diagram if , and only if , there exists a point @xmath19 on @xmath12 such that @xmath20 contains both @xmath8 and @xmath9 on its boundary , but no other site .",
    "the ( open ) edge in question consists of all points @xmath19 with that property .",
    "the technique used by the algorithm is to place pairs of points ( _ sentinels _ ) along each edge @xmath21 of the pslg ( each pair is placed so that it is bisected by @xmath21 ) in order to guard  or protect  @xmath21 .",
    "the number of sentinels required to protect @xmath21 depends on its length and the relative positions of its neighboring edges .",
    "each pair of sentinels meant to guard @xmath21 is placed on the boundary of some circle , whose center lies on @xmath21 . furthermore this circle will not touch any other edge .",
    "the only exception is when the circle is centered on an endpoint of @xmath21 , in which case it is allowed to touch all other edges sharing that endpoint .",
    "more formally , we have the following .",
    "let @xmath0 be a pslg , and let @xmath21 be an edge of @xmath0 .",
    "let @xmath1 be a set of points , and @xmath17 .",
    "the pair of points @xmath22 is said to be a * pair of sentinels * of @xmath21 if they are strong neighbors with respect to @xmath1 , and @xmath18 is a subsegment of @xmath21 . in this case , @xmath21 ( or more precisely , the segment @xmath18 ) is said to be * guarded * by @xmath8 and @xmath9 .",
    "the algorithm works in two stages : first , for each vertex @xmath23 of @xmath0 we draw a circle centered on @xmath23 .",
    "this is our set of _ initial circles _",
    "( this is described in more detail below ) .",
    "then we proceed to cover each edge @xmath21 of @xmath0 by non - overlapping _ inner circles _ , whose centers lie on @xmath21 , and which do not intersect any other edges of @xmath0",
    ".    let @xmath24 be a given vertex of @xmath0 , and let @xmath25 be the length of the shortest edge of @xmath0 incident to @xmath24 .",
    "we denote as @xmath26 the initial circle centered at @xmath24 , which will be taken as the largest circle with radius @xmath27 that does not intersect any edge of @xmath0 , except those that are incident to @xmath24 .",
    "once we have drawn @xmath26 , for each edge @xmath21 incident to @xmath24 we can choose a pair of sentinels @xmath22 , placed on @xmath26 , one on each side of @xmath21 , at a suitably small distance @xmath28 from @xmath21 , as in figure [ circle1 ] .",
    "later in this section we discuss how to choose @xmath28 appropriately .     for vertex @xmath24 and sentinels of @xmath21,scaledwidth=60.0% ]",
    "let @xmath29 be the point of intersection between @xmath26 and @xmath21 ; now @xmath8 and @xmath9 guard the segment @xmath30 of @xmath21 , which means that @xmath30 will appear in the voronoi diagram that will be constructed , provided that we do not include any new points inside @xmath26 ( see lemma [ when - edge ] ) .",
    "let @xmath31 be an edge of @xmath0 , and @xmath32 the intersection points of @xmath33 and @xmath34 with @xmath21 , respectively .. ] the segments @xmath35 and @xmath36 are now guarded , whereas the ( possibly empty ) segment @xmath37 still remains unguarded . in order to guard @xmath37 it suffices to cover that segment with circles centered on it , not intersecting with any edge other than @xmath21 , and not including any sentinel belonging to another circle .",
    "then we can choose pairs of sentinels on each covering circle , each sentinel being at distance @xmath28 from @xmath21 , as shown in figure [ circle2 ] .        as a consequence of lemma [ when - edge ] ,",
    "@xmath21 will be guarded in all its length , provided that no new point is later included inside one of the circles centered on @xmath21 . to ensure this",
    ", we will not allow an inner circle of @xmath21 to get closer than @xmath28 to another edge @xmath38 , because then a sentinel of @xmath38 might fall inside the circle . with this precaution , the sentinels guarding @xmath21 will not interfere with other edges , since they will not be included in any circle belonging to another edge .    in summary , an outline of the algorithm is :    1 .",
    "for each vertex @xmath39 , draw initial circle @xmath26 centered on @xmath24 .",
    "2 .   choose a suitable value of @xmath28 .",
    "3 .   for each vertex @xmath24 and for each edge @xmath21 incident to @xmath24 , place a pair of sentinels on @xmath26 , symmetric to one another with respect to @xmath21 , at distance @xmath28 from @xmath21 .",
    "4 .   for each edge @xmath40 , cover the unguarded segment of @xmath21 with inner circles centered on @xmath21 , and then place pairs of sentinels on each circle .",
    "this algorithm is a general strategy that leads to several variants when step 4 is specified in more detail , as will be seen in section [ implement ] . in order to prove that the algorithm works it suffices to show that :    1 .",
    "the algorithm terminates after constructing a finite number of circles ( and sentinels ) .",
    "2 .   after termination",
    ", every edge of @xmath0 is guarded ( see the discussion above ) .    in order to show that the algorithm terminates we will establish some facts .",
    "let @xmath41 be the radius of the smallest initial circle .",
    "now let @xmath42 be the smallest angle formed by any two incident edges of @xmath0 , say @xmath21 and @xmath38 . by taking @xmath43",
    "we make sure that any sentinel will be closer to the edge that it is meant to guard than to any other edge .",
    "this is valid for all initial circles .",
    "after all initial circles have been constructed , together with their corresponding sets of sentinels , for every edge @xmath21 there may be a _ middle segment _ that remains unguarded .",
    "this segment must be covered by a finite number of inner circles .",
    "take one edge , say @xmath21 , with middle unguarded segment of length @xmath44 .",
    "if we use circles of radius @xmath28 to cover the unguarded segment , then we can be sure that these circles will not intersect any circle belonging to another edge .",
    "exactly @xmath45 such circles will suffice to cover the middle segment , where the last one may have a radius @xmath46 smaller than @xmath28 . for this last circle ,",
    "the sentinels could be placed at distance @xmath47 from @xmath21 ( c.f .",
    "figure [ circle3 ] ) .     by inner circles of radius @xmath28,scaledwidth=80.0% ]    using circles of radius @xmath28",
    "is , among all the possible variants mentioned here , the one that yields the largest number of circles , and hence the largest number of sentinels ( generators of the voronoi diagram ) .",
    "now let @xmath21 be the longest edge of @xmath0 , with length @xmath48 .",
    "in the worst case , the number of inner circles that cover @xmath21 will be @xmath49 , and the number of sentinels will be twice that number plus four ( corresponding to the sentinels of both initial circles ) . therefore , the algorithm generates a number of points that is linear in @xmath5 , the number of edges , which is asymptotically optimal , since a lower bound for the number of points is the number of faces in @xmath0 .",
    "note that by letting @xmath0 become part of the problem instance , the number of generators becomes a function of @xmath42 , and it is no longer linear in @xmath5 . in practice , however , screen resolution and computer arithmetic impose lower bounds on @xmath42 .",
    "under such constraints , the above analysis remains valid .",
    "this leads to our main result :    let @xmath0 be a planar straight - line graph , whose smallest angle @xmath42 is larger than a fixed constant .",
    "then , the corresponding generalized inverse voronoi problem can be solved with @xmath4 generators , where @xmath5 is the number of edges of @xmath0 .",
    "in step 4 of the algorithm given in the previous section , the method to construct the inner circles was left unspecified .",
    "taking the circles with radius @xmath28 , as suggested in the preceding analysis , is essentially a brute - force approach , and may easily result in too many sentinels being used . in this section",
    "we discuss two different methods for constructing the inner circles .",
    "first let us note that in order to reduce the number of sentinels in our construction we may allow two adjacent circles on the same edge to overlap a little , so that they can share a pair of sentinels ( see figure [ circle2b ] ) .",
    "this observation is valid for all variants of the algorithm .",
    "the first variant for the construction of the inner circles along an edge is to place them sequentially ( iteratively ) , letting them grow as much as possible , provided that they do not enter the @xmath28-wide security area  of another edge .",
    "obviously , this greedy heuristic must yield a smaller number of voronoi generators than the naive approach of taking all circles with radius @xmath28 .",
    "suppose we want to construct an inner circle @xmath50 for edge @xmath21 , adjacent to another circle on @xmath21 that has already been fixed and on which we have already placed two sentinels : @xmath51 , and @xmath52 .",
    "let @xmath38 be the first edge that will be touched by @xmath50 as it grows , while constrained to have its center on @xmath21 and @xmath53 on its boundary .",
    "let @xmath54 be a straight line parallel to @xmath38 , at distance @xmath28 from @xmath38 , and closer to @xmath50 than @xmath38 .",
    "let @xmath21 be defined by the equation @xmath55 , and @xmath54 by the equation @xmath56 .",
    "can be obtained easily after the initial circles have been constructed and their sentinels placed . ]",
    "the distance of any point @xmath57 to @xmath54 is given by @xmath58 .",
    "the radius of @xmath50 must be equal to this distance .",
    "hence the @xmath19-coordinate of the center satisfies the following quadratic equation : @xmath59    or    @xmath60 @xmath61 @xmath62    where @xmath63 .",
    "+   + our second variant for constructing inner circles is also based on the principle of letting them grow until they come within distance @xmath28 of some edge . yet , instead of growing the circles sequentially along the edge that is to be covered , we center the first inner circle on the midpoint of the unguarded middle segment .",
    "this will yield at most two smaller disjoint unguarded segments , on which we recurse . in the worst case",
    ", a branch of the recursion will end when an unguarded segment can be covered by a circle of radius @xmath28 .",
    "the advantage of this approach is that the coordinates of the center can be determined with much less computation , thus avoiding potential roundoff errors .",
    "additionally , this variant is more suitable for parallel implementation than the previous one . on the other hand , we need an extra data structure to handle the unguarded segments .",
    "we end this discussion with a word about the choice of @xmath28 . on one hand",
    ", @xmath28 must be sufficiently small for the construction to be carried out . on the other hand , for the sake of robustness to numerical errors",
    ", it is convenient to take @xmath28 as large as possible .",
    "that is why we defer the actual choice of @xmath28 until the initial circles have been drawn .",
    "a different approach might be to use a variable - sized @xmath28 , which would lead to a more complicated , yet ( hopefully ) more robust algorithm .    a final remark : for the sake of simplicity we have assumed throughout the whole discussion that the cells of the input tesselation are convex , but our algorithm could be easily generalized to accept tesselations with non - convex cells .",
    "from the analysis in section [ aljuarizmi ] we know that the number of sites generated by our algorithm is linear in the size of the input , provided that the smallest angle @xmath42 is constant .",
    "however , we would like to get a more precise idea about the algorithm s performance , and the difference between the two strategies we have suggested for step 4 . for that purpose",
    ", we have implemented the algorithm and carried out a set of experiments .",
    "our experimental workbench consists of a graphical user interface , which can generate a tesselation on a random point set , store it in a dcel data structure , and then apply one of the two variants of the algorithm for solving the givp , described in section [ aljuarizmi ] .",
    "the gui is described in more detail in @xcite , and a beta windows version can be downloaded from https://www.researchgate.net/publication/239994361_voronoi_data .",
    "the file voronoi data.rar  contains the windows executable and a few dcel files , consisting of sample tesselations .",
    "the user can generate additional tesselations randomly , and apply either variant of the algorithm on them .",
    "the tesselations are generated as follows : first , the vertex set of @xmath0 is randomly generated from the uniform distribution in a rectangular region .",
    "then , pairs of vertices are chosen randomly to create edges . if a new edge intersects existing edges , then the intersection points are added as new vertices , and the intersecting edges are decomposed into their non - intersecting segments . finally , some edges are added to connect disjoint connected components and dangling vertices , so as to make the pslg biconnected .",
    "table [ tab : results ] displays some statistics about 40 such randomly generated tesselations : number of vertices , number of edges , number of regions , number of voronoi sites with the recursive version of step 4 , number of voronoi sites with the sequential version of step 4 , the smallest angle @xmath42 , and the width @xmath28 of the security area .",
    "the tesselations have been listed in increasing order of the number of edges . for each parameter",
    ", the table also provides the median ( med ) , the mean value ( avg ) , and the standard deviation ( std ) .     & & & & * smallest * & + & & & & * recursive * & * sequential * & * angle * & @xmath28**-neigh . * * + & * vertices * & * edges * & * regions * & * version * & * version * & * ( degrees ) * & * ( pixels ) * + & 72 & 142 & 66 & 1 020 & 852 & 1.63 & 1.20 + & 117 & 206 & 91 & 916 & 870 & 4.09 & 12.30 + & 194 & 252 & 60 & 1 468 & 1 296 & 1.07 & 9.61 + & 274 & 376 & 105 & 1 672 & 1 596 & 1.60 & 12.26 + & 229 & 429 & 202 & 2 400 & 2 148 & 3.38 & 0.91 + & 314 & 441 & 129 & 2 208 & 2 020 & 0.56 & 5.70 + & 336 & 472 & 138 & 2 656 & 2 374 & 0.47 & 4.03 + & 339 & 475 & 138 & 3 098 & 2 618 & 3.95 & 0.18 + & 344 & 480 & 138 & 3 140 & 2 720 & 0.23 & 4.48 + & 357 & 493 & 138 & 2 844 & 2 530 & 0.13 & 7.24 + & 339 & 501 & 164 & 2 580 & 2 364 & 0.38 & 3.81 + & 390 & 568 & 180 & 2 680 & 2 520 & 8.92 & 0.60 + & 438 & 637 & 281 & 3 320 & 3 028 & 0.21 & 6.34 + & 403 & 641 & 240 & 3 838 & 3 382 & 0.16 & 7.07 + & 472 & 684 & 214 & 3 432 & 3 144 & 0.25 & 2.56 + & 397 & 721 & 319 & 4 244 & 3 718 & 0.11 & 3.16 + & 421 & 784 & 365 & 5 112 & 4 406 & 1.30 & 0.12 + & 564 & 826 & 264 & 4 092 & 3 790 & 0.70 & 0.11 + & 504 & 986 & 463 & 4 148 & 4 020 & 2.37 & 14.16 + & 512 & 999 & 472 & 4 276 & 4 134 & 1.52 & 3.68 + & 552 & 1 056 & 506 & 4 048 & 4 796 & 0.25 & 4.40 + & 574 & 1 107 & 535 & 4 856 & 4 689 & 3.68 & 0.75 + & 601 & 1 166 & 567 & 5 240 & 5 009 & 0.80 & 3.43 + & 645 & 1 256 & 613 & 5 852 & 5 521 & 0.77 & 3.62 + & 672 & 1 292 & 622 & 5 720 & 5 992 & 0.25 & 3.44 + & 738 & 1 311 & 575 & 6 124 & 5 832 & 0.34 & 1.84 + & 724 & 1 399 & 677 & 6 440 & 6 194 & 0.23 & 3.23 + & 815 & 1 441 & 628 & 6 832 & 6 478 & 1.20 & 0.30 + & 763 & 1 479 & 718 & 6 960 & 6 599 & 2.14 & 0.19 + & 772 & 1 495 & 725 & 6 900 & 6 610 & 2.54 & 0.29 + & 855 & 1 522 & 669 & 7 684 & 7 158 & 1.43 & 0.31 + & 894 & 1 607 & 712 & 9 062 & 8 685 & 0.36 & 0.23 + & 898 & 1 615 & 716 & 8 152 & 7 580 & 1.19 & 0.33 + & 963 & 1 750 & 789 & 9 637 & 9 045 & 0.88 & 0.29 + & 1 006 & 1 842 & 838 & 9 236 & 8 582 & 1.85 & 0.34 + & 1 018 & 1 874 & 858 & 10 144 & 9 228 & 1.09 & 0.27 + & 984 & 1 902 & 920 & 7 924 & 7 792 & 4.40 & 0.25 + & 1 015 & 1 962 & 949 & 8 396 & 8 198 & 3.34 & 0.31 + & 1 066 & 1 973 & 909 & 10 392 & 9 492 & 0.63 & 0.30 + & 1 019 & 1 999 & 982 & 8 952 & 8 616 & 1.49 & 0.45 + & * 558 * & * 1 027.5 * & * 489 * & * 4 566 * & * 4 547.5 * & * 3.4 * & * 0.3 * + & * 590 * & * 1 054 * & * 467 * & * 5 192 * & * 4 891 * & * 0.59 * & * 4.06 * + & * 282.7 * & * 571.24 * & * 292.73 * & * 2 715.5 * & * 2 600 * & * 3.36 * & * 0.74 * +    from the tabulated data we can also get empirical estimates about the correlation among different parameters , especially @xmath42 and @xmath28 , and about the distribution of their values . the parameters @xmath42 and @xmath28 show a weak negative correlation with the number of edges , of @xmath64 and @xmath65 respectively . in turn",
    "they are positively correlated with one another , with a correlation of @xmath66 .",
    "these empirical findings agree with intuition .",
    "figures [ histoalpha ] and [ histoepsilon ] display the histograms of @xmath42 and @xmath28 with 20 bins .",
    "they can be well approximated by poisson distributions , with @xmath67 and @xmath68 , respectively , and with 95% confidence intervals @xmath69 $ ] and @xmath70 $ ] .",
    ", scaledwidth=100.0% ]    , scaledwidth=100.0% ]    the comparison between the two variants of the algorithm is shown in figure [ plot1b ] .",
    "we can see that the sequential variant is slightly better than the recursive variant , as it generates a smaller number of sites in most cases . however , the difference between both variants is not significant . indeed , the linear regression fits have very similar slopes : the linear fit for the sequential variant is @xmath71 , whereas the linear fit in the recursive case is @xmath72 .    ,",
    "our results show that the generalized inverse voronoi problem can be solved with a number of generators that is linear in the size of the input tesselation , provided that we enforce a lower bound on the size of the smallest angle . on the other hand ,",
    "the algorithm described in @xcite produces @xmath6 generators , where @xmath7 is the number of vertices of an acute triangulation of @xmath0 . as the performance of the two algorithms",
    "is given as a function of different parameters , a theoretical comparison between them is not straightforward .",
    "an experimental study could be helpful , but that would require an implementation of the algorithm in @xcite . in practice , our algorithm generates approximately @xmath73 voronoi sites , where @xmath5 is the number of edges of the input tesselation .    in any case , the number of generators produced by both algorithms may still be too large , and it may be possible to reduce it to a number closer to @xmath74 , the number of faces of the tesselation , which is the trivial lower bound .",
    "this lower bound can only be achieved if the tesselation is a voronoi tesselation . in the more general case",
    ", how close to @xmath74 can we get ?",
    "in particular , our algorithm still has plenty of room for improvement . in section [ implement ]",
    "we have already mentioned several strategies that can decrease the number of voronoi sites produced .",
    "the design of a parallel version , and a version that is robust against degenerate cases and numerical roundoff errors , are other issues to consider .",
    "roundoff errors have long been an important concern in computational geometry in general , and in voronoi diagram computation , in particular ( see e.g. @xcite ) .",
    "other practical questions have to do with the experimental analysis of our algorithms .",
    "we have devised a method to generate a pslg on a random point set , but we have not analyzed how this compares to generating such graphs uniformly from the set of all pslgs that can be defined on a given point set . regarding certain properties of our generated graphs ( expected number of vertices , edges , and faces , expected area of the faces , distribution of the smallest angle , etc . ) , we have not attempted a theoretical analysis , but we have estimated some of these parameters empirically .",
    "a more comprehensive set of experiments will reveal how these tesselations compare with those generated by other methods .    as a final remark ,",
    "we point out that our algorithm could also be generalized to other metrics , continuous or discrete , including graph metrics .",
    "potential applications include image representation and compression , as described in @xcite , and pattern recognition ( e.g. given a partition of some sample space , we could select a set of representatives  for each class ) . in the case of graphs ,",
    "voronoi partitions can be used to find approximate shortest paths ( see @xcite , for instance ) . in social networks ,",
    "node clustering around a set of representative  nodes , or super - vertices , is a popular technique for network visualization and@xmath75or anonymization @xcite .",
    "janos pach contributed some key ideas for the algorithm , at the early stages of this work .",
    "hebert prez - ross was partially supported by the spanish ministry of economy and competitiveness , under project tin2010 - 18978 .",
    "guillermo pineda - villavicencio was supported by a postdoctoral fellowship funded by the skirball foundation , via the center for advanced studies in mathematics at the ben - gurion university of the negev , israel , and by an isf grant .",
    "banerjee , s. , bhattacharya , b.b . ,",
    "das , s. , karmakar , a. , maheshwari , a. , roy , s. on the construction of a generalized voronoi inverse of a rectangular tesselation . in : procs .",
    "ieee symp . on voronoi diagrams in science and engineering ,",
    ". 132137 .",
    "ieee , new brunswick , nj ( 2012 ) .",
    "ratti , b. , sommer , c. approximating shortest paths in spatial social networks . in : procs .",
    "2012 ase / ieee int . conf .",
    "on social computing and 2012 ase / ieee int . conf . on privacy , security , risk and trust , pp 585586 ."
  ],
  "abstract_text": [
    "<S> given a tesselation of the plane , defined by a planar straight - line graph @xmath0 , we want to find a minimal set @xmath1 of points in the plane , such that the voronoi diagram associated with @xmath1 fits  @xmath0 . </S>",
    "<S> this is the generalized inverse voronoi problem ( givp ) , defined in @xcite and rediscovered recently in @xcite . </S>",
    "<S> here we give an algorithm that solves this problem with a number of points that is linear in the size of @xmath0 , assuming that the smallest angle in @xmath0 is constant .    </S>",
    "<S> diagram , dirichlet tesselation , planar tesselation , inverse voronoi problem </S>"
  ]
}