{
  "article_text": [
    "the need for high performance computational biology has emerged as a result of fast growth in biological information , the complexity of interactions that underlie many processes in biology , as well as the diversity and the interconnectedness of organisms at the molecular level @xcite .",
    "these biological information are accumulated via different techniques , however they require adequate analysis and processing to extract useful information that make the results evident .    according to benson et al .",
    "@xcite the number of deoxyribonucleic acid ( dna ) sequences and nucleotide bases in these sequences is growing exponentially , doubling every 18 months . as these data are collected , motif search and dna sequencing are just some examples among many for analytics of next gen sequencing analysis .",
    "a dna sequence contains specific genetic instructions , which make the living organisms function properly . in a dna strand",
    "there are four bases of nucleotides : a - adenine , c - cytosine , g - guanine and t - thymine .",
    "dna analysis is important for discovery of differences and similarities of organisms and exploration of the evolutionary relationship between them .",
    "this process often requires comparisons of the corresponding dna sequences , for example , checking whether one sequence is a subsequence of another , or comparing the occurrences of specific @xmath2-mers in the corresponding dna sequences . in computational biology @xmath2-mers",
    "refer to all the possible sub - strings ( sub - sequences ) of length @xmath2 of a dna sequence .",
    "they have an important role during sequence assembly and can be used in sequence alignment as well .",
    "analyzing dna sequences within a reasonable time is important for domain scientists to study various phenomenons , such as the evolution of viruses and bacteria during an early phase @xcite , or diagnosis of genetic predispositions to certain diseases .",
    "modern parallel computing systems promise to provide the capabilities to cope with the dna analysis processing requirements .",
    "existing approaches use both hardware and software to accelerate regular expression matching . the hardware based approaches ( such as @xcite ) are faster , but less flexible and more expensive , whereas software based acceleration techniques are flexible in terms of updating or adding new patterns @xcite .",
    "recently different software based dna analysis techniques designed for multi - core systems have been proposed @xcite .    in this paper , we will first explore and discuss the parallelization opportunities of dna analysis , and thereafter we introduce a parallel algorithm for dna analysis that is based on finite automata .",
    "we use a domain decomposition approach for parallelization ; in our approach the dna sequence is split into several chunks , and each chunk is assigned to a thread to perform pattern matching .",
    "our algorithm is optimized to do efficient speculations of the possible initial states for each chunk .",
    "only one regular expression matching ( rem ) for a chunk is required to be completely performed ; the remaining rems stop when the converging point is reached . a converging point is a state where two or more rem starting from different states meet after the same number of symbols is read .",
    "furthermore , we use a memory efficient data structure that saves the necessary information to count and highlights the @xmath2-mers .",
    "experiments with real - world dna segments ( for human and various animals ) on a dual socket shared - memory system with 48 threads show significant speedups compared to the sequential version ( up to 17.6x ) .",
    "the implementation of our algorithm is up to 3x faster than a pattern - based algorithm implemented using the re2 library @xcite .",
    "major contributions of this paper include :    * a parallel algorithm for dna analysis that is based on finite automata ; * empirical evaluation of our algorithm with real - world dna segments of mouse ( 2.7 gb ) , cat ( 2.4 gb ) , dog ( 2.4 gb ) , chicken ( 1 gb ) , human ( 3.2 gb ) and turkey ( 0.2 gb ) ; * a comparison of our algorithm with a pattern - based algorithm implementation that uses re2 library .",
    "the rest of the paper is organized as follows .",
    "section [ methodology ] provides background information on pattern matching , whereas section [ our - approach ] presents our algorithm for counting and extracting @xmath2-mers in a dna sequence .",
    "section [ exp_evaluation ] presents the experimental setup and discusses the experimental results . the work described in this paper is compared and contrasted to the related work in section [ related_work ] .",
    "section [ summary_future_work ] provides a summary of our work .",
    "regular expression matching verifies whether a pattern is present in a string .",
    "rem is commonly used for determining the locations of a pattern within a sequence of tokens , in search and replace functions , or to highlight important information out of a huge data set . in the context of computational biology ,",
    "pattern matching is used for analyzing and processing biological information in order to extract the useful parts of the data and make them evident .",
    "the formal definition of the rem is as follows : the input text is an array @xmath3 $ ] where @xmath4 is the length of the input , and pattern @xmath5 $ ] where the length of the pattern @xmath6 .",
    "the alphabet @xmath7 defines the possible characters of the input string .",
    "a finite automaton ( fa ) is a machine for processing information by scanning the input text @xmath8 in order to find the occurrences of the pattern @xmath9 .",
    "a formal definition of the fa is as follows : fa is a quintuple of ( @xmath10 ) , where @xmath11 is the finite set of states , @xmath7 is the finite alphabet , @xmath12 is the transition function @xmath13 , @xmath14 is the start state and @xmath15 is the distinguished set of final states .",
    "a well known algorithm for multiple pattern matching is the aho - corasick algorithm .",
    "it is able to match any occurrences ( including the overlapped ones ) of multiple patterns linearly to the size of the input string .",
    "it examines each character of the input string only once .",
    "it builds an automaton by creating states and transitions corresponding to these states .",
    "it adds failure transitions when there is no regular transition leaving from the current state on a particular character , which makes it possible to match multiple and overlapping occurrences of the patterns .",
    "furthermore , this algorithm is capable of delivering input - independent performance if implemented efficiently in parallel systems , which is a reason why we use this algorithm as basis of our work .",
    "in this section we first provide the details about the outline of our algorithm .",
    "thereafter we discuss the most important implementation aspects to achieve a scalable algorithm for counting and extracting specific @xmath2-mers from a large dna sequence .",
    "figure [ fig : work - partitioning ] depicts two possible ways for parallel execution of regular expression matching for bio - computing applications : ( a ) _ input - based approach _ that splits the input string into smaller chunks and processes them in separate threads and ( b ) _ pattern - based approach _ that splits the patterns in sub - patterns , creating separate state machines for each of them and processing the same input string with each different machine @xcite .    our algorithm uses the input - based approach .",
    "the challenge of this approach is determining the initial state for each chunk .",
    "finding the correct starting state for each chunk is important for finding the occurrences of the patterns that appear in the crossing border .",
    "other researchers use different ways of finding the initial states , for instance luchaup et al .",
    "@xcite use speculation to find the initial state based on the most visited states , devi and rajagopalan @xcite use an index based technique , chacon et al .",
    "@xcite use suffix - arrays , villa et al .",
    "@xcite , uses the pattern length overlapping approach .",
    "our way of determining the possible initial states is as follows : ( 1 ) find the set of source states ( @xmath16 ) for the first element of the sub - input mapped to the running thread ( @xmath17 ) ; ( 2 ) find the set of destination states ( @xmath18 ) for the last character of the sub - input mapped to the previous thread ( @xmath19 ) ; ( 3 ) find the intersection of @xmath18 and @xmath16 ( @xmath20 ) , which is the set of possible initial states @xcite .",
    "the first thread ( @xmath21 ) always starts from the initial state @xmath22 .",
    "each thread is responsible for finding the set of possible initial states , and for each state of this set a regular expression matching is performed .",
    "when all threads have finished their job , the results are joined by a binary reduction , which connects the last visited state of @xmath23 to the first visited state of @xmath24 .",
    "this method provides very good results for sparse transition tables and good performance for dense matrices for dfas with relatively small number of states .",
    "however , in a dfa with large number of states this method seems to be less efficient .",
    "this happens because one thread may be responsible to perform multiple rem for the same input , due to multiple possible initial states . to reduce the operations required for each thread to perform the rem starting from different states ,",
    "further optimizations are needed .",
    "while investigating the rem using the modified aho - corasick dfa representation , we noticed that the result converges after several symbols are read ( in our experiments , 10 is the max number of steps required to find the converging point ) .",
    "a converging point is a state where two or more rem starting from different states meet after the same number of symbols are examined .",
    "this insight allows us to significantly minimize the execution cost required to perform the rem starting from each possible initial state .",
    "the details about the process of the convergence are given in the next section .",
    ", @xmath25 , @xmath26 and @xmath27,width=288 ]    in this section we will explain the implementation details of our algorithm , including the process of building the dfa , splitting the input among the available threads , finding the set of possible initial states for each chunk assigned to a thread , running the rem for the first state in this set and the process of finding the _ converging point_. a reference of each process to the corresponding lines of codes in algorithm [ alg : k - mers - coex ] will be provided .",
    "furthermore , we define @xmath28 as the state of the automaton where @xmath29 is the state i d , @xmath30 as a sub - pattern of the selected patterns , @xmath31 as the process of performing an rem starting from the item at index @xmath29 of the set of possible initial states .",
    "the values used in the _ switch - case _ ( line [ alg : k - mers - coes : switch - start ] - [ alg : k - mers - coes : switch - end ] ) ( ex .",
    "122 , 127 , 128 ... ) determine that a specific sub - pattern ( @xmath30 ) has been matched .",
    "the ac algorithm with failure transitions has a drawback due to the non - deterministic transitions for a single input character .",
    "figure [ fig : automaton ] illustrates our solution to eliminate the failure transitions by adding the right transition ( indicated by dashed lines ) for each state . having a valid transition for each possible character to another state in the automaton ,",
    "guarantees that for each symbol the same amount of operations will be performed .",
    "the example automaton shown on figure [ fig : automaton ] is able to match the following patterns : @xmath32 , @xmath25 , @xmath26 and @xmath27 .",
    "for example , if we read string @xmath33 we reach state @xmath34 , and when @xmath35 , @xmath36 or @xmath37 is read we know exactly that state @xmath38 , @xmath39 or @xmath40 is next , respectively .      the process of splitting the input among the available threads is depicted in table [ table : input_split].a .",
    "this is a straight forward step , where the input length is divided by the number of available threads ( line [ alg : k - mers - coex : start - split]-[alg : k - mers - coex : end - split ] ) .",
    "the chunks are assigned to the threads consecutively based on the thread ids .",
    "the pseudo - code of the process of finding the pss ( see section [ coex ] ) is shown on algorithm [ alg : k - mers - coex ] line [ alg : k - mers - coex : get_pss_0 ] . when the pss are determined",
    "the thread performs an rem starting from each item of pss ( line [ alg : k - mers - coex : rem - start ] ) .",
    "table [ table : input_split].b , c depicts the rem process starting from each item of pss ; each table corresponds to a thread .",
    "for example , the first thread ( see table [ table : input_split].b ) initiates the rem starting from the following pss : @xmath41 , @xmath40 , @xmath42 , and @xmath43 .    for every @xmath31 ( rem starting from the @xmath44 at index @xmath29 ) a @xmath45 structure",
    "is created and stored in the @xmath46 .",
    "the @xmath45 structure stores the _ initial state _ , _ last state _ and the total number of occurrences for each of the sub - patterns ( line [ alg : k - mers - coex : cr_start ] - [ alg : k - mers - coex : cr_end ] ) .",
    "@xmath47 @xmath48 [ alg : k - mers - coex : global - data - structure ] in parallel [ alg : k - mers - coex : start - split ] [ alg : k - mers - coex : end - split ] [ alg : k - mers - coex : get_pss ] [ alg : k - mers - coex : get_pss_0 ] [ alg : k - mers - coex : fr ] [ alg : k - mers - coex : rem - start ] [ alg : k - mers - coex : cr ] [ alg : k - mers - coes : switch - start ] [ alg : k - mers - coes : switch - end ]    [ alg : k - mers - coex : save - to - global ] [ alg : k - mers - coex : fullrun - start ] [ fullrun - end ] [ alg : k - mers - coex : converge - point ] [ alg : k - mers - coex : converge - point - calc ]    [ alg : kmers - coes : psi_start ]    [ alg : kmers - coes : psi_end ] [ alg : k - mers - coex : cr_start ] [ alg : k - mers - coex : cr_end ] [ alg : k - mers - coex : fr_start ] [ alg : k - mers - coex : fr_end ]    lllllllllllllll + & & & @xmath49 & @xmath50 & @xmath51 & @xmath52 & @xmath53 & @xmath54 & @xmath55 & @xmath56 & @xmath57 & @xmath58 & & +    & & & & & & & & & & & & & & chunk 1 +    & & & & & & & & & & & & & & chunk 2 +   +    llllllllllllll +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +     +    llllllllllllll +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +    & & & & & & & & & & & & & +    .a tabular representation of the @xmath59 ( line [ alg : k - mers - coex : fr ] ) [ cols=\"<,<,<,<,<,<,<,<,<,<,<\",options=\"header \" , ]              we first present the performance results of our @xmath2-mers coex algorithm for various problem and machine sizes , and thereafter we compare our algorithm with a pattern - based algorithm implementation that uses re2 library ( known as _ regex - dna _ benchmark ) .",
    "figure [ fig : executiontime ] depicts the execution time in logarithmic scale for each of our selected data - sets and for various numbers of threads \\{1,2,6,12,24,48}. we observe a good scalability of our algorithm as we increase the number of threads or the input size .",
    "for example , the analysis of the human s dna sequence using one thread takes 27 seconds , and by increasing the number of threads to 2 , 6 , 12 , 24 and 48 the execution time reduces to 14.3s , 5.3s , 3s , 2s and 1.5s respectively .",
    "-mers coex algorithm implementation . ]",
    "-mers coex and the _ regex - dna benchmark _",
    "( re2 ) ]    figure [ fig : speedup ] depicts the obtained speedup of our algorithm compared to a sequential version of the aho - corasick algorithm for dna analysis .",
    "we may observe that the @xmath2-mers coex algorithm scales gracefully with respect to the size of data - sets and the number of threads .",
    "the maximal speedup of 17.65@xmath0 is achieved for the largest data - set ( that is the human dna segment ) using 48 threads .",
    "figure [ fig : comparison ] compares the performance of our @xmath2-mers coex algorithm with the _ regex - dna benchmark _",
    "@xcite , which is implemented in c++ using the re2 library  @xcite and openmp .",
    "the re2 implementation is based on splitting the pattern in smaller patterns , and matching the input string in parallel for each sub - pattern . since the _ regex - dna benchmark _ does not support larger data - sets , we have compared the two algorithms for the two smallest data - sets : chicken ( 1060 mb ) and turkey ( 193 mb ) .",
    "our @xmath2-mers coex algorithm outperforms the _ regex - dna benchmark _ for both data - sets .",
    "we may observe that the @xmath2-mers coex algorithm running on one thread takes the same amount of time as the _ regex - dna benchmark _ running on the total amount of threads .",
    "this happens because one thread has to perform at least one sequential rem for a specific sub - pattern . in this class of algorithms where the execution time is mainly dependent on the length of the input , balancing the work among the available threads",
    "should be done by splitting the input string , instead of the pattern length .",
    "one could benefit from partitioning a long pattern into smaller one , in cases when the input string is either relatively short or can not be split ( real - time network intrusion detection ) .",
    "in this section we discuss the state - of - the - art in pattern matching and dna sequence analysis techniques for multi - core architectures .",
    "existing approaches use both hardware and software to accelerate the process of regular expression matching . in comparison to hardware based state machines , which are faster , less flexible and more expensive , software based acceleration techniques are flexible in terms of updating or adding new patterns @xcite .",
    "herath et al .",
    "presented in @xcite an implementation of the aho - corasick string matching algorithm using posix threads , which is based on the pattern partitioning approach .",
    "a replication of the herath s study with the intention to improve the software implementation of the aho - corasick algorithm was conducted by arudchutha et al .",
    "@xcite .",
    "marais and kingsford @xcite present the jellyfish tool , which is based on the lock - free hash table that is optimized for counting @xmath2-mers of length up to 31 bases .",
    "rizk et al .",
    "@xcite present a similar approach to jellyfish @xcite , so called dsk , which is designed for small - memory servers .",
    "the @xmath2-mers are counted by traversing the hash tables .",
    "using hash tables for the internal representation resulted to be memory inefficient @xcite .",
    "as described by drews et al .",
    "@xcite a sequence corresponding to a human chromosome with 24 - 230 mb of input data would require gigabytes of memory to store the @xmath2-mers information .",
    "drews et al .",
    "@xcite achieved significant speedup by partitioning the input string among the threads in such a way that each thread processes only sequences starting with a specified prefix used to divide the radix tree among the threads .",
    "they achieved up to 6.9@xmath0 speedup on a shared memory system with 8 cores .    the n - step fm - index approach presented by chacn et al .",
    "@xcite achieved speedups from 1.4@xmath0 to 2.4@xmath0 with respect to their original fm - index search algorithm .",
    "an approach based on the aho - corasick string matching algorithm designed for the cray xmt architecture is proposed by villa et al .",
    "they split the input among the available threads , and overlap the input by the pattern length .",
    "their approach is applicable for multiple patterns as long as they are of the same length , otherwise , the occurrences of the shortest patterns occurring on the crossing border may be counted by both threads . a method for searching arbitrary regular expressions using speculation",
    "is proposed by luchaup et al . @xcite .",
    "the drawback is that if an rem performed by a thread does not converge on its sub - input , then the next thread has to start from a new state that breaks the serialization and limits the scalability .",
    "our @xmath2-mers coex algorithm is tailored for large - scale dna analysis . in our approach ,",
    "the dna segment is split into several chunks , and efficient speculations of the possible initial states for each chunk are performed .",
    "furthermore , our algorithm optimizes the rem using a converging point .",
    "we have described a parallel algorithm based on finite automata for counting and extracting @xmath2-mers in a dna segment . in a series of experiments with real world data - sets",
    "we have observed that the algorithm scales well with respect to various problem and machine sizes .",
    "we achieved the maximal speedup of 17.65@xmath0 for the largest data - set ( that is the human dna segment ) using 48 threads on a dual - socket shared - memory system with 24 physical cores . in comparison to the _ regex - dna benchmark",
    "_ our algorithm was up to three times faster .    in this paper",
    "we have studied the performance of our approach for dna sequence analysis on a shared - memory system with two 12-core intel xeon processors .",
    "it may be useful to compare the performance that we achieved using all available cores of the host intel xeon processors with the performance achieved when all available cores of the intel xeon phi coprocessor are used @xcite . furthermore , software technologies , such as @xcite , enable the use of all cores of homogeneous processors of the host and all available cores of the coprocessor .",
    "future work could address generalization of our approach for dna sequence analysis for various types of accelerated systems using techniques that ensure performance portability @xcite .",
    "the use of modeling and simulation techniques @xcite could help to reason about the performance on extreme - scale computing architectures @xcite .",
    "e.  abraham , c.  bekas , i.  brandic , s.  genaim , e.  b. johnsen , i.  kondov , s.  pllana , and a.  streit .",
    "preparing hpc applications for exascale : challenges and recommendations . in _",
    "2015 international conference on network - based information systems ( nbis)_. ieee , 2015 .",
    "a.  chacn , j.  c. moure , a.  espinosa , and p.  hernndez .",
    "n - step fm - index for faster pattern matching . in v.",
    "n. alexandrov , m.  lees , v.  v. krzhizhanovskaya , j.  dongarra , and p.  m.  a. sloot , editors , _ iccs _ , volume  18 of _ procedia computer science _ , pages 7079 .",
    "elsevier , 2013 .",
    "j.  dokulil , e.  bajrovic , s.  benkner , s.  pllana , m.  sandrieser , and b.  bachmayer .",
    "high - level support for hybrid parallel execution of c++ applications targeting intel xeon phi coprocessors . , 18(0):2508  2511 , 2013 .",
    "2013 international conference on computational science .",
    "t.  fahringer , s.  pllana , and j.  testori .",
    "teuta : tool support for performance modeling of distributed and parallel applications . in _",
    "computational science - iccs 2004 _ , volume 3038 of _ lecture notes in computer science _ , pages 456463 .",
    "springer berlin heidelberg , 2004 .",
    "d.  herath , c.  lakmali , and r.  ragel .",
    "accelerating string matching for bio - computing applications on multi - core cpus . in _ industrial and information systems ( iciis ) , 2012 7th ieee international conference on _ , pages 16 , aug 2012 .",
    "c.  kessler , u.  dastgeer , s.  thibault , r.  namyst , a.  richards , u.  dolinsky , s.  benkner , j.  traff , and s.  pllana .",
    "programmability and performance portability aspects of heterogeneous multi-/manycore systems . in _ design ,",
    "automation test in europe conference exhibition ( date ) , 2012 _ , pages 14031408 , march 2012 .",
    "s.  memeti and s.  pllana .",
    "parem : a novel approach for parallel regular expression matching . in _ computational science and engineering ( cse ) , 2014 ieee 17th international conference on _ , pages 690697 , dec 2014 .",
    "k.  j. nordstrm , m.  c. albani , g.  v. james , c.  gutjahr , b.  hartwig , f.  turck , u.  paszkowski , g.  coupland , and k.  schneeberger .",
    "mutation identification by direct comparison of whole - genome sequencing data from mutant and wild - type individuals using k - mers .",
    ", 31(4):325330 , 2013 .",
    "s.  pllana , s.  benkner , e.  mehofer , l.  natvig , and f.  xhafa . towards an intelligent environment for programming multi - core computing systems . in _ euro - par 2008 workshops - parallel",
    "processing _ ,",
    "volume 5415 of _ lecture notes in computer science _ , pages 141151 .",
    "springer berlin heidelberg , 2009 .",
    "s.  pllana , s.  benkner , f.  xhafa , and l.  barolli .",
    "hybrid performance modeling and prediction of large - scale computing systems . in _",
    "complex , intelligent and software intensive systems , 2008 .",
    "cisis 2008 . international conference on _ , pages 132138 , march 2008 .",
    "j.  reif and s.  sahu .",
    "autonomous programmable nanorobotic devices using dnazymes . in m.",
    "garzon and h.  yan , editors , _ dna computing _ , volume 4848 of _ lecture notes in computer science _ , pages 6678 . springer berlin heidelberg , 2008 .",
    "b.  soewito and n.  weng .",
    "methodology for evaluating dna pattern searching algorithms on multiprocessor . in _ proceedings of the 7th ieee international conference on bioinformatics and bioengineering , bibe 2007 , october 14 - 17 , 2007 , harvard medical school , boston ,",
    "ma , usa _ , pages 570577 , 2007 ."
  ],
  "abstract_text": [
    "<S> rapid analysis of dna sequences is important in preventing the evolution of different viruses and bacteria during an early phase , early diagnosis of genetic predispositions to certain diseases ( cancer , cardiovascular diseases ) , and in dna forensics . </S>",
    "<S> however , real - world dna sequences may comprise several gigabytes and the process of dna analysis demands adequate computational resources to be completed within a reasonable time . in this paper </S>",
    "<S> we present a scalable approach for parallel dna analysis that is based on finite automata , and which is suitable for analyzing very large dna segments . </S>",
    "<S> we evaluate our approach for real - world dna segments of mouse ( 2.7 gb ) , cat ( 2.4 gb ) , dog ( 2.4 gb ) , chicken ( 1 gb ) , human ( 3.2 gb ) and turkey ( 0.2 gb ) . </S>",
    "<S> experimental results on a dual - socket shared - memory system with 24 physical cores show speedups of up to 17.6@xmath0 . </S>",
    "<S> our approach is up to @xmath1 faster than a pattern - based parallel approach that uses the re2 library .    </S>",
    "<S> parallel dna analysis , multi - core architectures , finite automata </S>"
  ]
}