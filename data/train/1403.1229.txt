{
  "article_text": [
    "the investigation of the factorization properties of scattering amplitudes at their singularities @xcite lead to important results in quantum field theory and theoretical particle physics , such as the development of new methods for phenomenological computations .",
    "in particular , integrand reduction methods , developed for one - loop diagrams  @xcite and recently extended to higher loops  @xcite , use the knowledge of the analytic and algebraic structure of loop integrands in order to rewrite scattering amplitudes as linear combinations of master integrals .    at one loop ,",
    "integrand - reduction methods allow to express any integrand in dimensional regularization as a sum of contributions with at most five propagators in the loop , regardless of the number of external legs of the amplitude .",
    "the numerators of these contributions are _ polynomial residues _ which have a universal parametric form that does not depend on the process .",
    "this parametric form can be written as a sum of monomials in the components of the loop momentum , multiplied by unknown process - dependent coefficients .",
    "after integration , the amplitude becomes a linear combination of known integrals .",
    "the coefficients of this linear combination can be identified with a subset of the ones which parametrize the residues .",
    "therefore , the problem of the computation of any one - loop amplitude can be reduced to the one of performing a polynomial fit of the coefficients of the residues .",
    "the fit of the unknown coefficients can be efficiently performed by evaluating the numerator of the integrand on _ multiple cuts _",
    ", i.e.  on values of the loop momentum such that a subset of the loop denominators vanish .",
    "the multiple - cut conditions can be viewed as _ projectors _ which isolate the residue sitting on the cut denominators .",
    "a residue can be evaluated by putting on - shell the corresponding loop propagators and subtracting from the integrand the non - vanishing contributions coming from higher - point residues .",
    "this leads to a top - down algorithm which allows to compute any one - loop amplitude with any number of external legs .    within semi - numerical computations ,",
    "the algorithm is usually implemented by sampling the integrand on several solutions of the multiple cuts and subtracting at each step of the reduction all the non - vanishing contributions coming from higher - point residues .",
    "this yields a system of equations for the coefficients of each residue .",
    "the method is suited for automation and it has been implemented in several codes , some of which are public ( e.g.cuttools  @xcite and samurai  @xcite ) .",
    "its usage within several automated frameworks @xcite has been particularly successful and produced highly non - trivial phenomenological results .    in this paper",
    "we present a new public c++ library called ninja , which implements an alternative integrand - reduction algorithm first proposed in ref .",
    "this is based on the systematic application of the laurent series expansion to an integrand on the multiple cuts . after performing a suitable laurent expansion on a multiple cut , in the asymptotic limit both the integrand and the subtraction terms",
    "exhibit the same polynomial behavior as the residue .",
    "this allows one to directly identify the coefficients of the residues ( and thus the ones of the master integrals ) with the ones of the laurent expansion of the integrand , corrected by subtractions terms which can be computed once and for all as functions of a subset of the higher - point coefficients .",
    "this leads to a diagonal system of equations for each residue and to a significant reduction of the number of subtraction terms which affect the computation of lower - point contributions .",
    "ninja takes as input the numerator cast into four different forms .",
    "the first is a procedure which evaluates it as a function of the loop momentum .",
    "the others instead compute the leading terms of properly defined laurent expansions of the numerator .",
    "since the integrand of a one - loop amplitude is a rational function of the loop momentum , the laurent expansions for an integrand can be obtained via a partial fraction decomposition .",
    "ninja implements it semi - numerically via a simplified polynomial division algorithm between the expansions of the numerator and the ones of the denominators .",
    "the coefficients of the laurent expansion are then corrected by the subtraction terms and multiplied by the master integrals .",
    "these are computed by interfacing ninja with an external library which can be specified by the user .",
    "interfaces for oneloop @xcite and looptools  @xcite are already provided with the distribution .",
    "the simplified subtractions and the diagonal systems of equations make the algorithm implemented in ninja significantly simpler and lighter than the traditional one .",
    "the library has been interfaced with the one - loop package gosam  @xcite and has already been used to compute nlo corrections to higgs boson production in association with a top - quark pair and a jet  @xcite and several six- , seven- and eight - point amplitudes involving both massive and massless particles as external states or propagating in the loop  @xcite .",
    "these applications showed that ninja has better performance and numerical stability than implementations of traditional integrand reduction algorithms .",
    "in particular , ref .",
    "@xcite provides a detailed analysis of the performance and accuracy of this library . with this paper ,",
    "we make ninja publicly available as a standalone library which can be interfaced to other packages and frameworks for one - loop computations .    in order to simplify the generation of the numerator expansions and the corresponding source code needed by ninja as input , we distribute with the library a small python package called ninjanumgen which uses form-4  @xcite in order to compute the expansions and produce an optimized source code which can be used by the library .    in this paper , besides the description of the implementation of the algorithm and the usage of the library",
    ", we also propose a method for the extension of the integrand reduction via laurent expansion for the computation of integrals whose rank is one unit higher than the number of loop denominators .",
    "this method is not present elsewhere in the literature and has been implemented in ninja , allowing thus to use the library for computations in non - renormalizable and effective theories as well .",
    "the paper is organized as follows . in section  [ sec : laurent ] we give a review of the laurent expansion method for the integrand reduction of one - loop amplitudes . in section  [ sec : ninja ] we discuss its semi - numerical implementation in the library ninja .",
    "the usage of the library is explained , with the help of simple examples , in section  [ sec : usage ] . in section",
    "[ sec : examples ] we give a description of the examples which are distributed with the library , giving a better view of its usage and capabilities . appendix [ sec : ninjanumgen ] gives more details on the usage of the package ninjanumgen . in appendix",
    "[ sec : hr ] we present the extension of the algorithm to higher - rank integrals .",
    "appendix [ sec : intlib ] gives more information on the interface between ninja and the libraries of master integrals .",
    "since this paper is rather technical , the reader which is mostly interested in the usage of the library might want to read sections [ sec : usage ] and [ sec : examples ] first , referring to the previous sections or the appendices at a later time if needed .",
    "in this section we review the _ integrand reduction via laurent - expansion method _  @xcite for the computation of one - loop integrals .",
    "the method is based on the systematic application of the laurent series expansion on the universal integrand decomposition of one - loop amplitudes , which allows to reduce any amplitude as a linear combination of known master integrals .",
    "a generic contribution @xmath0 to an @xmath1-point one - loop amplitude in dimensional regularization has the form @xmath2 in the previous equation , the integrand @xmath3 is a _ rational function _ of the components of the @xmath4-dimensional loop momentum @xmath5 , with @xmath6 .",
    "the numerator @xmath7 is a process - dependent polynomial in @xmath5 , while the denominators @xmath8 are quadratic polynomials in @xmath5 and correspond to feynman loop propagators , @xmath9 the function @xmath10 appearing in eq .",
    "is a conventional normalization factor given by  @xcite @xmath11 as a function of the renormalization scale @xmath12 and the dimension @xmath13 .",
    "the @xmath4-dimensional loop momentum @xmath5 can be split into a four - dimensional part @xmath14 and a @xmath15-dimensional part @xmath16 as @xmath17 the numerator @xmath18 will therefore be a polynomial in the four components of @xmath14 and the extra - dimensional variable @xmath19 .",
    "every one - loop integrand in dimensional regularization can be decomposed as sum of integrands having five or less loop denominators @xcite @xmath20 where the second sum on the r.h.s",
    ".  runs over all the subsets of the denominator indexes @xmath21 containing @xmath22 elements .",
    "the _ residues _",
    "@xmath23 appearing in eq .",
    "are irreducible polynomials , i.e.polynomials which do not contain terms proportional to the corresponding loop denominators @xmath24 .",
    "these residues have a universal , process - independent parametric form in terms of unknown , process - dependent coefficients .    for any set of denominators @xmath24 with @xmath25",
    ", one can build a @xmath26-dimensional basis of massless momenta @xmath27  @xcite .",
    "the first two elements of the basis are linear combinations of two external momenta @xmath28 , @xmath29 of the sub - diagram identified by the considered set of loop denominators . more explicitly , we define @xmath30 with @xmath31 where the momenta @xmath32 were defined in eq .  .",
    "if the sub - diagram has less than two independent external momenta , the remaining ones are substituted by arbitrary reference vectors in the definition of @xmath33 and @xmath34 .",
    "the momenta @xmath35 and @xmath36 are instead chosen to be orthogonal to the first two and can be defined using the spinor notation as @xmath37}{2 } , \\qquad e_4^\\mu = \\frac{\\langle e_2\\ , \\gamma^\\mu\\ , e_1]}{2}.\\ ] ] they satisfy the property @xmath38 . for subsets of @xmath39 denominators , we also define the vectors @xmath40 and @xmath41 @xmath42 with @xmath43 .",
    "we observe that the vector @xmath41 is orthogonal to all the external legs of the sub - diagram identified by the four denominators .    by expanding the four dimensional part @xmath14 of the loop momentum @xmath44 in the basis @xmath45",
    ", the numerator and the denominators can be written as polynomials in the coordinates @xmath46 , @xmath47 with @xmath48 the coordinates @xmath49 can be written as scalar products @xmath50 where @xmath51 .",
    "for @xmath39 we also consider the alternative expansion of the loop momentum @xmath52 with @xmath53    the universal parametric form of the residues @xmath23 in a renormalizable theory is @xcite @xmath54 where we understand that the unknown coefficients @xmath55 depend on the indexes of the residue ( e.g.  @xmath56 ) , while the scalar products @xmath49 and @xmath57 depend on both the indexes of the residue and the loop momentum @xmath14 .",
    "the parametrization in eq .   can be extended to effective and non - renormalizable theories where the rank of the numerator can be larger than the number of loop propagators @xcite .",
    "more details on the higher - rank case are given in appendix  [ sec : hr ] .",
    "most of the terms appearing in eq .",
    "are _ spurious _ , i.e.  they vanish after integration and do not contribute to the final result .",
    "the amplitude @xmath0 can thus be expressed as a linear combination of master integrals , corresponding to the non - spurious terms of the integrand decomposition , namely @xmath58   \\bigg\\ } \\pagebreak[1 ] \\nn       & + \\sum_{\\{i_1 , i_2 , i_3\\}}\\bigg\\ {            c_{0}^ { ( i_1 i_2 i_3 ) } i_{i_1 i_2 i_3 } +            c_{7}^ { ( i_1 i_2 i_3 ) } i_{i_1 i_2 i_3}[\\mu^2 ] \\bigg\\ } \\pagebreak[1 ] \\nn       & + \\sum_{\\{i_1 , i_2\\}}\\bigg\\ {            c_{0}^ { ( i_1 i_2 ) } i_{i_1 i_2 }           + c_{1}^ { ( i_1 i_2 ) } i_{i_1 i_2}[(q+p_{i_1})\\cdot e_2 ] \\nn          & \\qquad          + c_{2}^ { ( i_1 i_2 ) } i_{i_1 i_2}[((q+p_{i_1})\\cdot e_2)^2 ]          +   c_{9}^ { ( i_1 i_2 ) } i_{i_1 i_2}[\\mu^2 ]   \\bigg\\ } \\pagebreak[1 ] \\nn   & +   \\sum_{i_1 }        c_{0}^ { ( i_1 ) } i_{i_1 } ,    \\label{eq : integraldecomposition}\\end{aligned}\\ ] ] where @xmath59 \\equiv h(\\mu_r^2,d)\\ , \\int d^d \\bar q { \\alpha \\over d_{i_1 } \\cdots d_{i_k } } ,   \\qquad i_{i_1 \\cdots i_k } \\equiv    i_{i_1 \\cdots i_k}[1].\\ ] ] the coefficients of this linear combination can be identified with a subset of the coefficients of the parametric residues in eq .  .",
    "since all the master integrals appearing in eq .   are known , the problem of the computation of an arbitrary one - loop amplitude can be reduced to the problem of the determination of the non - spurious coefficients appearing in the parametrization of the residues @xmath23 .",
    "the coefficients appearing in the integrand decomposition can be computed by evaluating the integrand on _ multiple cuts _ ,",
    "i.e.  on values of the loop momentum @xmath5 such that a subset of loop denominators vanish @xcite .",
    "more in detail , the coefficients of a @xmath22-point residue @xmath23 can be determined by evaluating the integrand on the corresponding @xmath22-ple cut @xmath60 .",
    "for these values of the loop momentum , the only non - vanishing contributions of the integrand decomposition are the ones coming from the residue in consideration and from all the higher - point residues which have @xmath61 as a subset of their loop denominators .    within the original integrand reduction algorithm  @xcite ,",
    "the coefficients are computed by sampling the numerator of the integrand on a finite subset of the on - shell solutions , subtracting all the non - vanishing contributions coming from higher - point residues , and finally solving the resulting linear system of equations .",
    "this is therefore a top - down approach , where higher - point residues are computed first , starting from @xmath62 , and systematically subtracted from the integrand for the evaluation of lower - point contributions .",
    "these are referred to as subtractions at the integrand level .",
    "the integrand reduction via laurent expansion method , presented in ref .",
    "@xcite , improves this reduction strategy by elaborating on techniques proposed in  @xcite .",
    "whenever the analytic dependence of the integrand on the loop momentum is known , this approach allows to compute the coefficients of a residue @xmath23 by performing a laurent expansion of the integrand with respect to one of the components of the loop momentum which are not fixed by the on - shell conditions of the corresponding multiple cut @xmath63 . in the asymptotic limit defined by this laurent expansion ,",
    "both the integrand and the higher - point subtractions exhibit the same polynomial behavior as the residue",
    ". therefore one can directly identify the unknown coefficients with the ones of the laurent expansion of the integrand , corrected by the contributions coming from higher - point residues .",
    "hence , by choosing a suitable laurent expansion , one obtains a diagonal system of equations for the coefficients of the residues , while the subtractions of higher - point contributions can be implemented as _",
    "corrections at the coefficient level _ which replace the subtractions at the integrand level of the original algorithm .",
    "since the polynomial structure of the residues is universal and does not depend on the process , the parametric form of the coefficient - level corrections can be computed once and for all , in terms of a subset of the higher - point coefficients .",
    "more in detail , the corrections at the coefficient level are known functions of a subset of the coefficients of 3- and 2-point residues . in particular , no subtraction term coming from 4- and 5-point contributions is ever needed .",
    "this allows to skip the computation of the ( spurious ) 5-point contributions entirely , and to completely disentangle the determination of 4-point residues from the one of lower point contributions .    in the following ,",
    "we address more in detail the computation of 5- , 4- , 3- , 2- , and 1-point residues , also commonly known as _ pentagons _ , _ boxes _ , _ triangles _ , _ bubbles _ and _ tadpoles _ respectively . for simplicity , we focus on renormalizable theories , where ( up to a suitable choice of gauge ) the maximum allowed rank of the integrand is equal to the number of loop denominators and the most general parametrization of the residues is the one given in eq .  .",
    "ninja can also be used for the computation of integrals whose rank exceeds the number of denominators by one .",
    "the extension of the method to the higher - rank case is discussed in appendix  [ sec : hr ] .",
    "[ [ point - residues ] ] 5-point residues + + + + + + + + + + + + + + + +    as mentioned above , pentagon contributions are spurious . within the original integrand reduction algorithm ,",
    "their computation is needed because they appear in the subtractions at the integrand level required for the evaluation of lower - point contributions .",
    "a 5-point residue only has one coefficient , which can easily be computed by evaluating the numerator of the integrand on the corresponding 5-ple cut . within the laurent expansion approach ,",
    "the subtraction terms coming from five - point residues always vanish in the asymptotic limits we consider , therefore their computation can be skipped .",
    "for this reason , in the library ninja the computation of pentagons is disabled by default , even though it can be enabled for debugging purposes , as explained in section [ sec : runtime ] .",
    "[ [ point - residues-1 ] ] 4-point residues + + + + + + + + + + + + + + + +    the coefficient @xmath64 of a box contribution @xmath65 can be determined via four - dimensional quadruple cuts @xcite .",
    "a quadruple cut @xmath66 in four dimensions ( i.e.  @xmath67 , @xmath68 ) has two solutions , @xmath69 and @xmath70 .",
    "the coefficient @xmath64 can be expressed in terms of these solutions as @xmath71 given the simplicity of eq .",
    ", this is the only coefficient which ninja computes in the same way as the traditional algorithm .",
    "the coefficient @xmath72 can instead be determined by evaluating the integrand on @xmath4-dimensional quadruple cuts in the asymptotic limit of large @xmath19  @xcite .",
    "a @xmath4-dimensional quadruple cut has an infinite number of solutions which can be parametrized by the ( @xmath73)-dimensional variable @xmath19 .",
    "these solutions become simpler in the considered limit , namely @xmath74 where the vector @xmath75 and the constant @xmath76 are fixed by the cut conditions .",
    "the coefficient @xmath72 is non - vanishing only if the rank of the numerator is greater or equal to the number of loop denominators . in a renormalizable theory",
    ", it can be found in the @xmath77 asymptotic limit as the leading term of the laurent expansion of the integrand @xmath78 the other coefficients of the boxes are spurious and , since they neither contribute to the final result nor to the subtraction terms , their computation can be skipped .",
    "[ [ point - residues-2 ] ] 3-point residues + + + + + + + + + + + + + + + +    the coefficients of the residues of a generic triangle contribution @xmath79 can be determined by evaluating the integrand on the solutions of the corresponding @xmath4-dimensional triple cut  @xcite .",
    "these can be parametrized by the variable @xmath19 and the free parameter @xmath80 , @xmath81 where the vector @xmath75 and the constant @xmath76 are fixed by the cut conditions @xmath82 .",
    "the momentum @xmath75 is a linear combination of @xmath33 and @xmath34 and is therefore orthogonal to @xmath35 and @xmath36 . on these solutions ,",
    "the non - vanishing contributions to the integrand decomposition are the ones of the residue @xmath79 , as well as the ones of the boxes and pentagons which share the three cut denominators . however , after performing a laurent expansion for large @xmath80 and dropping the terms which vanish in this limit , the pentagon contributions vanish , while the box contributions are constant in @xmath80 but they also vanish when taking the average between the parametrizations @xmath69 and @xmath70 of eq .  .",
    "more explicitly , @xmath83 moreover , the expansion of the integrand is given by @xmath84 and it has the same polynomial behavior as the expansion of the residue @xmath79 , @xmath85 by comparison of eq .  , and one can directly identify the ten triangle coefficients as the corresponding terms of the expansion of the integrand , @xmath86 hence , with the laurent expansion method , the determination of the 3-point residues does not require any subtraction of higher - point terms .",
    "[ [ point - residues-3 ] ] 2-point residues + + + + + + + + + + + + + + + +    the coefficients of a generic 2-point residue @xmath87 can be evaluated on the on - shell solutions of the corresponding double cut @xmath88 , which can be parametrized as @xmath89 in terms of the three free parameters @xmath90 , @xmath80 and @xmath19 , while the constants @xmath91 and @xmath92 are fixed by the on - shell conditions . after evaluating the integrand on these solutions and performing a laurent expansion for @xmath93 , the only non - vanishing subtraction terms come from the triangles , @xmath94 even though the integrand and the subtraction terms are rational functions , in the asymptotic limit they both have the same polynomial behavior as the residue , namely @xmath95   \\\\      \\frac{\\delta_{i_1 i_2 j}(q_+,\\mu^2)}{d_j } = { } &   c_{s_3,0}^{(j)}+ c_{s_3,9}^{(j)}\\ , { \\mu^2}+ c_{s_3,1}^{(j)}\\ , { x } + c_{s_3,2}^{(j)}\\ , { x^2 } - \\big ( c_{s_3,5}^{(j ) } +   c_{s_3,8}^{(j ) } { x}\\big ) { t } + c_{s_3,6}^{(j)}\\ , { t^2}+\\o(1/{t } ) \\nn     \\frac{\\delta_{i_1 i_2 j}(q_-,\\mu^2)}{d_j } = { } &   c_{s_3,0}^{(j)}+ c_{s_3,9}^{(j)}\\ , { \\mu^2}+ c_{s_3,1}^{(j)}\\ , { x } + c_{s_3,2}^{(j)}\\ , { x^2 } - \\big ( c_{s_3,3}^{(j ) } +   c_{s_3,7}^{(j ) } { x}\\big ) { t } + c_{s_3,4}^{(j)}\\ , { t^2}+\\o(1/{t } ) \\label{eq : bubblessubexp } \\pagebreak[1 ] \\\\     \\delta_{i_1",
    "i_2}(q_+,\\mu^2 ) = { } & c_0+c_9\\ , { \\mu^2}+c_1\\ , ( e_1\\cdot e_2)\\ , { x } + c_2 \\ , ( e_1\\cdot e_2)^2\\ ,   { x^2}\\nn     & + \\big(c_5 + c_8 \\ , ( e_1\\cdot e_2)\\ ,   { x}\\big)\\ , ( e_3\\cdot e_4)\\ , { t } + c_6\\ , ( e_3\\cdot e_4)^2\\ , { t^2}+\\o(1/{t } ) \\nn     \\delta_{i_1 i_2}(q_-,\\mu^2 ) = { } & c_0+c_9\\ , { \\mu^2}+c_1\\ , ( e_1\\cdot e_2)\\ , { x } + c_2\\ , ( e_1\\cdot e_2)^2\\ , { x^2 } \\nn     & + \\big(c_3 + c_7 \\ , ( e_1\\cdot e_2)\\ , { x}\\big)\\ , ( e_3\\cdot e_4)\\ , { t } + c_4\\ , ( e_3\\cdot e_4)^2\\ , { t^2}+\\o(1/{t } ) .",
    "\\label{eq : bubbledeltaexp}\\end{aligned}\\ ] ] the coefficients @xmath96 of the expansion of the subtractions terms in eq.s are known parametric functions of the triangle coefficients .",
    "hence , the subtraction of the triangle contributions can be implemented by applying coefficient - level corrections to the terms appearing in the expansion of the integrand .",
    "more explicitly , by inserting eq.s  , and in eq .",
    "one gets @xmath97    [ [ point - residues-4 ] ] 1-point residues + + + + + + + + + + + + + + + +    the only non - spurious coefficient @xmath64 of a tadpole residue @xmath98 can be computed by evaluating the integrand on solutions of the single cut @xmath99 . for this purpose",
    ", one can consider 4-dimensional solutions of the form @xmath100 parametrized by the free variable @xmath80 . in the asymptotic limit @xmath101 ,",
    "only bubble and triangle subtraction terms are non - vanishing , @xmath102 similarly to the case of the 2-point residues , in this limit the integrand and the subtraction terms exhibit the same polynomial behavior as the residue , i.e.@xmath103 putting everything together , the coefficient of the tadpole integral can be identified with the corresponding one in the expansion of the integrand , corrected by coefficient - level subtractions from bubbles and triangles @xmath104 the subtraction terms @xmath105 and @xmath106 , coming from 2-point and 3-point contributions respectively , are known parametric functions of the coefficients of the corresponding higher - point residues .",
    "the c++ library ninja provides a semi - numerical implementation of the laurent expansion method described in section  [ sec : laurent ] .",
    "the laurent series expansion is typically an analytic operation , but since a one - loop integrand is a rational function of the loop variables , its expansion can be obtained via a partial fraction decomposition between the numerator and the denominators .",
    "this is implemented in ninja via a simplified polynomial - division algorithm , which takes as input the coefficients of a parametric expansion of the numerator @xmath18 and computes the leading terms of the quotient of the polynomial division with respect to the uncut denominators . in this section",
    "we describe the input needed for the reduction performed by ninja and we give further details about the implementation of the reduction .",
    "all the types , classes and functions provided by the ninja library are defined inside the ` ninja ` namespace . in particular , the types ` real ` and ` complex ` are aliases for ` double ` and ` std::complex < double > ` , unless the library was compiled in quadruple precision .",
    "classes for real and complex momenta are defined as ` realmomentum ` and ` complexmomentum ` respectively .",
    "they are wrappers of four - dimensional arrays of the corresponding floating - point types , which overload arithmetic and subscript operators .",
    "more in detail , an instance ` p ` of one of these classes represents a momentum @xmath107 according to the representation @xmath108},\\texttt{p[1]},\\texttt{p[2]},\\texttt{p[3]}\\ } = \\{e_p , x_p , y_p , z_p\\},\\ ] ] i.e.  with the energy in the zeroth component , followed by the spatial components .",
    "the inputs needed from the reduction algorithm implemented in ninja are the momenta @xmath32 and the masses @xmath109 of the loop denominators defined in eq .  , besides the numerator @xmath110 of the integrand .",
    "the latter must be cast in four different forms , one of which is optional .",
    "the c++ implementation requires the numerator to be an instance of a class inherited from the abstract class ` ninja::numerator ` .",
    "the latter defined as    .... class numerator {    public :      virtual complex evaluate(const ninja::complexmomentum & $ \\(q\\)$ ,                             const ninja::complex & $ \\(\\mu^{2 } \\)$ ,                             int cut ,                             const ninja::partitionint partition [ ] )                             = 0 ;      virtual void muexpansion(const ninja::complexmomentum $ \\(v\\)$ [ ] ,                             const ninja::partitionint partition [ ] ,                             ninja::complex c [ ] ) { }      virtual void t3expansion(const ninja::complexmomentum & $ \\(v_{0}\\)$ ,                             const ninja::complexmomentum & $ \\(v_{3}\\)$ ,                             const ninja::complexmomentum & $ \\(v_{4}\\)$ ,                             const ninja::complex & $ \\(\\beta\\)$ ,",
    "int mindeg ,                             int cut ,                             const ninja::partitionint partition [ ] ,                             ninja::complex c [ ] ) = 0 ;      virtual void t2expansion(const ninja::complexmomentum & $ \\(v_{1}\\)$ ,                             const ninja::complexmomentum & $ \\(v_{2}\\)$ ,                             const ninja::complexmomentum & $ \\(v_{3}\\)$ ,                             const ninja::complexmomentum & $ \\(v_{4}\\)$ ,                             const ninja::complex $ \\(\\beta\\)$ [ ] ,                             int mindeg ,                             int cut ,                             const ninja::partitionint partition [ ] ,                             ninja::complex c [ ] ) = 0 ;      virtual ~numerator ( ) { }    } ; ....    the input parameters ` cut ` and ` partition ` are common to more methods and give information about the multiple cut where ninja is currently evaluating the numerator .",
    "although this information is not always necessary , there might be occasions where it could be useful for an efficient evaluation of the numerator .",
    "the integer ` cut ` is equal to @xmath22 if the numerator is being evaluated on a @xmath22-ple cut , with @xmath111 .",
    "this parameter is not given in the method ` muexpansion ` because the latter is always evaluated on quadruple cuts ( i.e.  @xmath112 ) .",
    "the parameter ` partition ` points to an array of integers ( namely of integer type ` ninja::partitionint ` ) , with length equal to ` cut ` , containing the indexes of the cut numerators .",
    "if the user asks to perform a global test ( see section  [ sec : runtime ] ) , the numerator will also be evaluated outside the solutions of the multiple cuts , in which case the parameter ` cut ` will be set to zero . as an example , if the method ` t3expansion ` is evaluated on the 3-ple cut @xmath113 for the determination of the 3-point residue @xmath114 , we will have @xmath115 , @xmath116}=0 $ ] , @xmath117}=2 $ ] , and @xmath118}=5 $ ] .",
    "the returned expansion only needs to be valid for the cut specified ( e.g.  @xmath113 in the previous example ) .",
    "here is a detailed description of each method of the class ` ninja::numerator ` , for a generic numerator of an @xmath1-point integrand of rank @xmath119 .",
    "if the analytic expression of the integrand is available , all these methods can be easily generated with the help of the simple python package ninjanumgen , which is distributed with the library and whose usage is described in section  [ sec : integrand ] and in appendix  [ sec : ninjanumgen ] . the details which follow",
    "are only needed to those who prefer to provide an alternative implementation of the required methods without ninjanumgen .",
    "it must return the value of the numerator @xmath110 evaluated at the ( complex ) values of @xmath14 and @xmath19 given as input .",
    "this is used for the computation of the laurent expansion in @xmath19 required to obtain the coefficient @xmath72 of the boxes . in the renormalizable case",
    ", this method should compute the leading term of a parametric expansion in @xmath80 of the integrand defined by @xmath120 where @xmath41 is given by @xmath40`[0 ] ` , i.e.  by the zeroth entry of the array of momenta @xmath40 .",
    "for renormalizable theories this array will therefore only contain at most one element .",
    "the method should write the leading coefficient of the expansion in the zeroth entry of the array pointed by the parameter ` c ` , i.e.    ....      c[0 ] = $ \\(\\n\\)$[$\\(t^{r}\\)$ ] ; ....    the generalization of this method to the higher - rank case is described in appendix  [ sec : hr ] .",
    "the implementation of this method is only required when @xmath121 .",
    "it is also not needed if the user chooses to disable the @xmath19-expansion method for the boxes , but in that case more evaluations of the numerator will be needed and the computation of the pentagons will not be skipped .      this method is used for the computation of the coefficients of the residues of both the triangles and the tadpoles .",
    "it must compute the coefficients of the terms @xmath122 for @xmath123 , given by substituting into the numerator the parametric expansion of the loop momentum defined by @xmath124 as a function of the momenta @xmath125 and the constant @xmath76 which are passed as parameters .",
    "the maximum value of the parameter ` mindeg ` is @xmath126 .",
    "since in a renormalizable theory @xmath127 , and by definition of rank we have @xmath128 , in this case at most 6 terms can be non - vanishing in the specified range of @xmath129 .",
    "the method should write these terms in the entries of the array pointed by ` c ` , ordered by decreasing powers of @xmath80 .",
    "terms with the same power of @xmath80 should be ordered by increasing powers of @xmath19 .",
    "a pseudo - implementation will therefore look like    ....      int idx = 0 ;      for ( int j=$\\(r\\)$ ; j>=$\\(r\\)$-mindeg ; --j )        for ( int k=0 ; 2*k<=$\\(r\\)$-j ; + + k )          c[idx++ ] = $ \\(\\n\\)$[$\\(t^{j}\\mu^{2k}\\)$ ] ; ....      in the current version of ninja , this method is called during the computation of the coefficients of the bubbles .",
    "it must compute the coefficients of the terms @xmath130 for @xmath131 , given by the expansion @xmath132 as a function of the momenta @xmath125 and the constants @xmath133}$ ] , which are passed as parameters to the method .",
    "the maximum value of ` mindeg ` is @xmath134 . in a renormalizable theory",
    ", this implies that one can have at most 7 non - vanishing terms in this range of @xmath129 .",
    "it is worth observing that the expansion in eq .",
    "can be obtained from the previous one in eq .   with the substitutions @xmath135 the terms of the expansion",
    "must be stored in the entries of the array pointed by ` c ` , ordered by decreasing powers of @xmath80 .",
    "terms with the same power of @xmath80 should be ordered from the lowest to the highest with respect to the lexicographical order in the variables @xmath136 .",
    "a pseudo - implementation will have the form    ....    int idx = 0 ;    for ( int j=$\\(r\\)$ ; j>=$\\(r\\)$-mindeg ; --j )      for ( int l=0 ; l<=$\\(r\\)$-j ; + + l )        for ( int k=0 ; 2*k<=$\\(r\\)$-j - l ; + + k )          c[idx++ ] = $ \\(\\n\\)$[$\\(t^{j}x^{l}\\mu^{2k}\\)$ ] ; ....      for every phase - space point , ninja at run - time computes the parametric solutions of the multiple cuts corresponding to each residue .",
    "the laurent expansion of the integrand on these solutions is performed via a simplified polynomial division between the expansion of the numerator and the set of the uncut denominators .",
    "the coefficients of this expansion are corrected by the coefficient - level subtractions appearing in eq .   and  .",
    "the non - spurious coefficients are finally multiplied by the corresponding master integrals in order to obtain the integrated result as in eq .  .",
    "the coefficients of the expansions of the numerator are written on a contiguous array by the numerator methods described in section  [ sec : input ] .",
    "the laurent expansion is obtained via a simplified polynomial division .",
    "the latter is performed in - place on the same array , keeping only the elements which are needed for the final result . a possible implementation for an univariate expansion , with a numerator @xmath137}\\ ,",
    "t^r + \\texttt{num[1]}\\ , t^{r-1 } + \\ldots + \\texttt{num[nterms-1]}\\ , t^{r-\\texttt{nterms}+1 } + \\o(t^{r-\\texttt{nterms}})\\ ] ] and denominator @xmath138}\\ , t + \\texttt{d[1]}\\ , + \\texttt{d[2]}\\ , \\frac{1}{t},\\ ] ] would have the form    ....    void division(complex num [ ] , int nterms , complex den[3 ] )    {      for ( int i=0 ; i < nterms ; + + i ) {        num[i ] /= den[0 ] ;        if ( i+1<nterms ) {          num[i+1 ] -= den[1]*num[i ] ;          if ( i+2<nterms )            num[i+2 ] -= den[2]*num[i ] ;                    }      }    } ....    one can check that this routine correctly replaces the first ` nterms ` elements of the array ` num ` with the first ` nterms ` leading elements of the laurent expansion of @xmath139 . the actual implementation in ninja , having to deal with multivariate expansions , is significantly more involved than the ` division ` procedure presented here .",
    "nevertheless , it qualitatively follows the same algorithm .",
    "the coefficients obtained by the division are then corrected by the coefficient - level subtractions and thus identified with the corresponding coefficients of the residues , as explained in section  [ sec : laurent ] .",
    "once the reduction is complete , the non - spurious coefficients are multiplied by the corresponding master integrals .",
    "ninja calls the routines implementing the master integrals through a generic interface which , as in the case of the numerator , is defined in the c++ code via an abstract class ( called ` integrallibrary ` ) .",
    "this allows one to use any integral library which can be specified at run - time .",
    "more details on the implementation of this interface are given in appendix  [ sec : intlib ] .",
    "the current version of ninja already implements it for two integral libraries .    the first built - in interface , `",
    "ninja::avhoneloop ` , is a c++ wrapper of the routines of the oneloop library @xcite .",
    "this wrapper caches every computed integral allowing constant - time lookup of their values from their arguments .",
    "the caching of the integrals can significantly speed up the computation , especially for complex processes .",
    "every instance of the class ` avhoneloop ` has an independent cache of master integrals ( hence , one may safely use it in multi - threaded applications by using one instance of the class per thread ) .",
    "the second implementation of the interface , ` ninja::looptools ` , uses instead the looptools library  @xcite , which already has an internal cache of computed integrals .",
    "in this section we explain how to use the library for the computation of a generic one - loop integral .",
    "ninja can be interfaced to any one - loop generator capable of providing the input it needs , and in particular to packages which can reconstruct the analytic dependence of the numerators on the loop momentum .",
    "an interface for the one - loop package gosam  @xcite is already built in the library , and has been used for highly non - trivial phenomenological computations  @xcite .",
    "an interface with the package formcalc  @xcite is currently under development .",
    "the author is open to give his assistance in interfacing other packages as well .    in this paper",
    "we focus on the usage of ninja as a standalone library .",
    "we will show how to generate the numerator methods needed as input , starting from an analytic expression of the numerator , with the help of the python package ninjanumgen which is distributed with the library .",
    "we will then explain how to perform the reduction , and how to set the main available options .",
    "ninja can be obtained at the url ` http://ninja.hepforge.org ` .",
    "the library is distributed with its source code using the gnu build system ( also known as autotools ) .",
    "it can be compiled and installed with the shell commands    ....",
    "./configure     make     make install ....",
    "this will typically install the library and the header files in sub - directories of ` /usr / local ` .",
    "the ` prefix ` option can be used in order to specify a different installation path . in this case",
    ", you might need to update your ` ld_library_path ` ( or ` dyld_library_path ` on mac os ) environment variable accordingly . in order to use ninja for",
    "the production of phenomenological results , one must interface it with a library of master integrals .",
    "as already mentioned , interfaces to the oneloop and looptools libraries are provided ( see appendix  [ sec : intlib ] for interfacing a different library ) .",
    "they can be enabled by passing to the ` configure ` script the options ` with - avholo[=flags ] ` and ` with - looptools[=flags ] ` .",
    "for instance , the following commands    [ source , bash ] ----    ./configure",
    "--prefix=$\\$$home / ninja \\",
    "--with - avholo='-l / path / to / avh_olo / lib -lavh_olo ' \\",
    "fcinclude =- i / path / to / avh_olo / include     make install ----    will install all the files in sub - directories of ` $ home / ninja ` and build the interface with the oneloop library , which must be already installed and linkable with the flags specified with the ` with - avholo ` option .",
    "we also specified the ` fcinclude ` variable with the flags which are needed to find fortran-90 modules when they are not installed in a default directory .",
    "given the importance of numerical precision in the calculation of scattering amplitudes , there is also the option to compile the library in quadruple precision ( ` with - quadruple ` ) , which uses the gcc libquadmath library . by using the ` ninja::real ` and ` ninja::complex ` floating point types , the same source code can be compiled both in double and quadruple precision , depending on how ninja has been configured .",
    "a full list of optional arguments for the ` configure ` script can be obtained with the command ` ./configure",
    "help ` . while most of them are common to every package distributed with the gnu build system , some are instead specific to the ninja library and they are described in table  [ tab : configure ] . in",
    "most of the cases , only the options for interfacing the integral libraries should be needed .",
    ".options and environment flags for the ` configure ` script . only the options which modify the default behavior of ninja are listed .",
    "[ cols=\"<,<\",options=\"header \" , ]      in this example we consider six incoming photons  @xcite .",
    "this is a non - trivial case where the ` setcutstop ` method of an ` amplitude ` class can make the computation more efficient when lower point cuts do not contribute to the total result .",
    "a generic six - photon diagram has an integrand of the form @xmath140 where we assumed the fermion running in the loop to be massless .",
    "the momenta @xmath141 are defined by @xmath142 one can work out the algebra , define the corresponding spinor products and vectors , and generate the input for ninja in the same way as for the four - photons case .",
    "one can also check that the terms proportional to @xmath19 in the final expression for the integral vanish upon integration .",
    "therefore , we can perform the simplification @xmath143 , or equivalently @xmath144 , in the numerator .",
    "moreover , one can exploit the knowledge that only the cut - constructible contributions of boxes and triangles contribute to the total result , hence we can ask ninja to stop the reduction at triple cuts with    ....",
    "amp.setcutstop(3 ) ; ....    and remove the rational part from the result with    ....    amp.onlycutconstructible ( ) ; ....    which will make the computation more efficient ( in the example implemented here , the run - time is reduced by about 33% ) .    in the file ` 6photons.cc ` we call the method ` evaluate ` on all the independent permutations of the external legs , generated at run - time with the function ` std::next_permutation ` of the c++ standard library .",
    "the results have been compared with the ones in ref.s  @xcite as well as with a similar computation performed with samurai for several helicity choices .      with this example",
    ", we discuss a possible strategy for the generation of the input needed by ninja which can be suited for more complex computations where an efficient evaluation of the numerator methods at run - time can be important .",
    "we consider the one - loop integral defined by the diagram depicted in figure  [ fig : ttbarh ] , contributing to the 5-point helicity amplitude @xmath146 .",
    "[ sec : ttbarh ]    .",
    "this picture has been generated using gosam.,scaledwidth=45.0% ]    the analytic expression for the integrand of this example , which can be worked out from the feynman rules of the standard model , has been generated with the help of the package gosam and can be found in the form file ` ttbarh.frm ` .",
    "this already contains some abbreviations which are independent from the loop momentum @xmath44 of the diagram . at run - time , these @xmath5-independent abbreviations are computed only once per phase space point , making thus the evaluation of the numerator and its expansions more efficient .",
    "this analytic expression is processed by ninjanumgen which produces the numerator expansions .",
    "we also add to the numerator class ` ttbarhdiagram ` an ` init ` method which uses the spinor library described in section  [ sec:4photons ] in order to compute the relevant spinor products and polarization vectors , as well as the abbreviations which do not depend on the loop momentum .",
    "these are stored as private data members of the class . for simplicity ,",
    "our result neglects the coupling constants and an overall color factor .",
    "even though we considered a single diagram and a specific helicity choice , this example illustrates a general strategy for the generation of an analytic numerator expression which is suited for the numerical evaluations performed by integrand - reduction algorithms like the one implemented in the library ninja .",
    "the full amplitude for this process has been computed in ref.s  @xcite , while an additional jet has recently been added to the final state in ref.s  @xcite where ninja has been used for the reduction of the corresponding integrands generated by gosam .      in this example",
    "we show how ninja can be used in order to compute integrals whose rank is higher than the number of loop denominators .",
    "this simple test is similar to the example presented in ref .",
    "[ sec : usage ] , hence we will describe each step as in the previous case . we define a 5-point amplitude of rank 6 , with kinematics @xmath147 and integrand @xmath148 in terms of the reference vectors @xmath149 ( @xmath150 ) and the momenta @xmath141 running into the loop @xmath151    we follow the same steps outlined in section [ sec : usage ] . with ninjanumgen",
    "we generate the methods for ninja . after writing the integrand in the form file ` mynumhr.frm ` we call the script with the command    ....    ninjanumgen mynumhr.frm --nlegs 5 --rank 6 -o mynumhr.cc ....    which creates the file ` mynumhr.cc ` and a template for the header ` mynumhr.hh ` .",
    "once again , we define the vectors @xmath149 as public members of the numerator class ` diagram ` , by inserting    ....    public :      ninja::complexmomentum v0,v1,v2,v3,v4,v5 ; ....    in the class definition .",
    "a possible test program can be almost identical to the one we showed in section [ sec : dummyex4 ] , with obvious changes in the definition of the rank , the number of external legs and the reference vectors @xmath149 .",
    "this is implemented in the file ` simple_higher_rank_test.cc ` . in order to run this example ,",
    "the user must compile the library with the ` enable - higher_rank ` option , otherwise a call to the ` evaluate ` method of an ` amplitude ` object will cause a run - time error .",
    "as one can see , when ninjanumgen is used for the generation of the expansions , the higher - rank case is handled automatically without any intervention by the user .",
    "besides , the internal higher - rank routines of ninja will be automatically called whenever the rank @xmath119 is equal to @xmath152 ( where @xmath1 is the number of loop propagators ) , while in the public programming interface there is no difference with respect to the normal - rank case .      in the last examples , we wish to illustrate the possibility of using ninja in a multi - threaded application .",
    "these examples are implemented using posix threads , which are a standard in unix - like operating systems , but adapting them to different programming interfaces for threads ( such as openmp ) should be straightforward .    in order to implement a thread - safe application , one should avoid race conditions which might occur if different threads try to write on the same variables .",
    "in particular , one should avoid accessing global variables for writing from different threads .",
    "the only global variables used directly by ninja are those controlling the global options described in section  [ sec : globaloptions ] .",
    "as explained in that section , these options are only meant to change the general behavior of the library for debugging purposes ( e.g.  for checking that the provided numerator methods are correct ) , while in general the default options should not be changed during a phase - space integration , especially when performance is important . hence ,",
    "on the side of the ninja library , there should be no issue and one can safely call the ` evaluate ` method from different ` amplitude ` objects in different threads .    during a call of the ` evaluate ` method on an ` amplitude ` object ,",
    "issues might however arise from global variables used by the chosen library of master integrals or the numerator methods .",
    "as for the numerator methods , all the examples distributed with ninja define a thread - safe numerator class ( more specifically , one can safely call numerator methods from different instances of the class in different threads ) .",
    "this is simply done by using data members of the class instead of global variables , making thus different instances of the same class completely independent .",
    "if the procedures implemented by libraries of master integrals are thread - safe , one can therefore use ninja in multi - threaded applications . as an example",
    ", one can use the class ` avhoneloop ` which , as explained in section  [ sec : mis ] , wraps routines of the oneloop library and adds a cache of computed integrals .",
    "the cache is a non - static data member of the class .",
    "one can therefore create one instance of this class per thread and assign it accordingly to the ` amplitude ` objects to be evaluated in the same thread .",
    "as an example , with    ....",
    "avh_olo.init(1 ) ;    avhoneloop my_lib[n_threads ] ;    amplitude < realmasses > amp[n_threads ] ;    for ( int i=0 ; i < n_threads ; + + i )      amp[i].setintegrallibrary(my_lib[i ] ) ; ....    we create ` n_threads ` amplitude objects whose ` evaluate ` method can be safely called in a separate thread ( in the first line , we called the ` init ` method on the global instance ` avh_olo ` defined in the library , in order to allow oneloop to perform its global initialization ) . in this way",
    ", different threads will also have an independent cache of master integrals .",
    "this strategy allows to build a multi - threaded application which uses ninja for the reduction of one - loop integrals .",
    "recent versions of looptools ( namely looptools-2.10 or later ) can also be used in threaded applications , since they have a mutex regulating writing access to the internal cache of integrals .    in",
    "the following we discuss the possibility to build a multi - threaded application with ninja and any other ( not necessarily thread - safe ) library of master integrals .",
    "indeed , even though ninja has obviously no control over possible issues arising from routines of external libraries , we offer an easy way to work around any potential problem . in this case",
    ", there is no general way to ensure that calling routines of the same integral library from different threads will not cause conflicts .",
    "however , one can avoid these conflicts by scheduling the calls of the external procedures in such a way that they are never evaluated at the same time from two or more threads .",
    "if the computation of the master integrals takes only a small fraction of the total run time ( which is usually the case when a cache of integrals is present ) , the effects of this on the performance will in general be reasonably small .    within ninja , implementing a scheduled access on the routines used by a library of master integrals",
    "is straightforward . as explained more in detail in appendix",
    "[ sec : intlib ] , the generic interface used by ninja in order to call master integral procedures , has two methods called ` init ` and ` exit ` which are evaluated exactly once in each call of the ` evaluate ` method , immediately before the computation of the first master integral and after the computation of the last master integral respectively .",
    "therefore we can use mutexes ( such as the ones present the posix standard for threads ) in order to _ lock _ the calls to the master integrals in the ` init ` method and _ unlock _ them in the ` exit ` method .",
    "this makes sure that , between the calls of the ` init ` and ` exit ` methods , no other thread will use the master integral routines , hence avoiding any possible conflict .    in order to make a library of master integrals thread - safe",
    ", we use the template class ` threadsafeintegrallibrary ` , which is included in the distribution .",
    "this automatically wraps an existing class derived from ` integrallibrary ` and adds to it a mutex that schedules the calls to the master integrals as explained above . as an example , defining a thread - safe version of a generic library ` baselibrary ` can be simply achieved with    ....    # include < ninja / thread_safe_integral_library.hh >    using namespace ninja ;    threadsafeintegrallibrary < baselibrary > my_lib ; ....    which defines a new interface ` my_lib ` that can be made the default by calling    ....    setdefaultintegrallibrary(my_lib ) ; ....    before any thread is created ( alternatively , we could call the ` setintegrallibrary ` method on each ` amplitude ` object , either outside or inside the threads ) .    in the files ` thread_4photons.cc ` and ` thread_6photons.cc ` we repeat the examples of the four- and six - photons amplitudes , but this time we compute several phase - space points in parallel on different threads . as mentioned before",
    ", we do not need to implement other numerator classes , since the ones described in sections [ sec:4photons ] and [ sec : sixphotons ] can be safely used in multi - threaded applications . in the source files ,",
    "we implement both the approaches described in this section",
    ". the preprocessor will select the former if the oneloop interface has been enabled and the latter otherwise .",
    "the multi - threaded examples can be compiled with    ....    make thread - examples ....    if at least one between the oneloop and looptools libraries was enabled during configuration and your system supports posix threads .",
    "a complete discussion on the implementation of multi - threaded applications for doing phenomenology at one - loop is beyond the purposes of this paper .",
    "moreover , a detailed assessment of possible advantages of this approach would generally depend on the generator of the integrands and the phase space integration . in these examples we showed that the methods implementing the reduction via laurent expansion in ninja can be safely used in multi - threaded programs .",
    "we presented the public c++ library ninja which implements the integrand reduction via laurent expansion method for the computation of one - loop amplitudes in quantum field theories .",
    "the main procedures of the library take as input the numerator of the integrand and some parametric expansions of the same , which can be generated with the help of the simple python package ninjanumgen included with the distribution .",
    "the expansions of the integrand on the multiple cuts are computed semi - numerically at run - time , via a simplified polynomial - division algorithm .",
    "some of the coefficients of the laurent expansions are thus identified with the ones which multiply the master integrals .",
    "the algorithm is light and proved to have good performance and numerical stability , hence it is suited for applications to complex one - loop processes , characterized by either several external legs or several mass scales .",
    "we described the usage of the library , in particular the generation of the input , the calls of the procedures for the reduction , and the interface to libraries of master integrals .",
    "this information can be used in order to interface the library with existing one - loop packages .",
    "we thus expect that ninja will be useful for future computations in high - energy physics , especially for those involving more complex processes .",
    "the author thanks all the other members of the gosam collaboration for the common development of a one - loop package which could be interfaced with ninja , and especially pierpaolo mastrolia , edoardo mirabella and giovanni ossola for innumerable discussions and exchanges .",
    "the author also thanks thomas hahn for his support with looptools and comments on the draft .",
    "this work was supported by the alexander von humboldt foundation , in the framework of the sofja kovalevskaja award project `` advanced mathematical methods for particle physics '' , endowed by the german federal ministry of education and research .",
    "the reduction procedures implemented in ninja take as input a class derived from the abstract class ` ninja::numerator ` .",
    "this must implement the required expansions in the corresponding methods .",
    "if the analytic expression of the numerator can be provided by the user , the source code for the methods can be automatically generated with the help of the simple python package ninjanumgen , which is distributed with the library and can be installed as explained in section  [ sec : installation ] . the package can be used both as a script or as a module within python .    in section [ sec : integrand ] we already gave a simple example of its usage as a script .",
    "as explained there , the user must create a file containing a form expression of the numerator of the integrand .",
    "the package uses form-4 in order to generate the expansions which are needed and produce a c++ source file with the definitions of the corresponding methods . if not already present , an header file with a sketch of the definition of the class will also be created",
    ". the user can complete it by adding data members and methods which are specific of this class .",
    "form allows one to define symbols between square brackets ( e.g.`[symbol_name ] ` ) , containing characters which otherwise would not be permitted in a declaration .",
    "ninjanumgen also allows the usage of such symbols in the expression of the numerator , and it will remove the brackets ( which would produce illegal c++ code ) when writing the final source files .",
    "this gives the user a wider range of possibilities , for instance using symbols which correspond to variable names containing underscores or data members of structures ( e.g.  with ` [ structure_instance.data_member ] ` ) .",
    "we first give a few more details about the usage of the package as a script .",
    "it is invoked with the command    .... ninjanumgen --nlegs nlegs $ { \\it optional - arguments}$ file ....    where ` file ` is the name of the file which contains the numerator expression and ` nlegs ` is the number of external legs of the loop , which is equal to the number of loop denominators .",
    "a description of all the allowed arguments can be obtained with the command    ....    ninjanumgen --help ....    and the most important ones are :    ` rank rank ` , ` -r rank ` : :    rank of the numerator , by default it will be assumed to be equal to    the number of external legs of the loop ` diagname diagname ` , ` -d diagname ` : :    name of the numerator expression in the form file , by default it will    be assumed to be ` diagram ` ` cdiagname cdiagname ` : :    name of the numerator class in the generated c++ files , by default it    will be the same as the form expression ` formexec formexec ` : :    the form executable , the default is ` form ` ` qvar qvar ` : :    name of the loop momentum variable @xmath14 defined in eq",
    ".  ,    the default is ` q ` ` mu2var mu2var ` : :    name of the loop variable @xmath19 defined in eq",
    ".  , the    default is ` mu2 ` ` output output ` , ` -o output ` : :    name of the output source file , the default is ` ninjanumgen.cc ` ` header header ` : :    c++ header file containing the definition of the numerator class : if    the file does not exists , one will be created . by default",
    "it will have    the same name as the output but with ` .hh ` extension .",
    "as mentioned , one can also use the package as a python module ( ` ninjanumgen ` ) .",
    "this contains a class ` diagramexpansion ` which can be used for the generation of the source code which implements the numerator methods .",
    "the input parameters of the constructor of this class roughly correspond to the arguments which can be used in the script .",
    "a detailed description can be obtained , after installation , by invoking python in interactive mode ( usually done with the command ` python ` ) and typing    ....    import ninjanumgen    help(ninjanumgen.diagramexpansion ) ....    the method ` writesource ` generates the source files . as a simple example , the source for the integrand we defined in section  [ sec : integrand ] could have been generated within python with the commands    ....    # import the module    import ninjanumgen      # define the mandatory arguments for the constructor    n_legs = 4    input_file = ' mynum.frm '    output_file = ' mynum.cc '       # define an instance of the class diagramexpansion    mynum = ninjanumgen.diagramexpansion(input_file ,                                         output_file ,                                         n_legs , rank=4 )      # generate the source    mynum.writesource ( ) ....    we suggest to look at the python files in the ` examples ` directory for other basic examples .",
    "as pointed out in ref .",
    "@xcite , the laurent expansion method can be generalized to non - renormalizable and effective theories with higher - rank numerators . in a renormalizable theory , with a proper choice of gauge the rank @xmath119 can not be greater than the number @xmath1 of loop propagators .",
    "ninja , if configured with the ` enable - higher_rank ` option , can also be used for the computation of integrals with @xmath153 . here",
    "we describe the generalization of the method to the higher - rank case , underlining the points where it differs from the renormalizable case .    in eq .",
    ", we gave the most general parametrization of the residues @xmath23 in a renormalizable theory .",
    "in the higher - rank case with @xmath153 , such parametrization is generalized as follows  @xcite @xmath154 the generalized integral decomposition is thus @xmath155 \\pagebreak[1 ] \\nn       & + \\sum_{\\{i_1 , i_2\\}}\\bigg\\ {            c_{10}^ { ( i_1 i_2 ) } i_{i_1 i_2}[\\mu^2\\ , ( q+p_{i_1})\\cdot e_2 ) ]          + c_{13}^ { ( i_1 i_2 ) } i_{i_1 i_2}[((q+p_{i_1})\\cdot e_2)^3 ] \\bigg\\ } \\pagebreak[1 ] \\nn   & +   \\sum_{i_1 }       \\bigg\\ { c_{14}\\ , i_{i_1}[\\mu^2 ] + c_{15}^ { ( i_1)}\\ , i_{i_1}[((q+p_{i_1})\\cdot e_3)((q+p_{i_1})\\cdot e_4 ) ] \\bigg\\ }   \\label{eq : hrintegraldecomposition}\\end{aligned}\\ ] ] this higher - rank decomposition has been used for the computation of nlo corrections to higgs - boson production in association with two @xcite and three @xcite jets .",
    "other libraries which implement the reduction of higher - rank integrals are xsamurai  @xcite , which extends the more traditional integrand reduction algorithm of samurai , and golem95  @xcite .      while the extension of the laurent expansion method for the computation of higher - rank 3-point and 2-point residues is straightforward , for 4-point and 1-point residues some further observations are in order . here",
    "we propose a generalization of the laurent expansion method which allows to efficiently compute the non - spurious coefficients of 4- and 1-point residues without spoiling the nice features of the algorithm , such as the simplified subtractions of higher - point contributions and the diagonal systems of equations .",
    "this generalization is not present elsewhere in the literature and has been implemented in the ninja library .",
    "[ [ point - residues-5 ] ] 4-point residues + + + + + + + + + + + + + + + +    the coefficient @xmath64 can be computed exactly as in the renormalizable case . for the coefficient @xmath156",
    ", one needs instead to keep also the next - to - leading term in the @xmath19 expansion described before , so that the @xmath4-dimensional solutions of a quadruple cut , given in eq .",
    ", in the asymptotic limit become @xmath157 where it is worth noticing that @xmath75 can be obtained as the average of the two solutions of the corresponding four - dimensional quadruple cut . in this limit",
    ", the expansion of the integrand reads @xmath158 hence the leading term is now the spurious coefficient @xmath159 , but @xmath72 can still be obtained as the next - to - leading term .",
    "this can be implemented semi - numerically , by keeping the two leading terms of the expansion of the numerator and performing a polynomial division with respect to the two leading terms in the expansion of the uncut denominators which have the form @xmath160 given the very limited number of terms involved , the division can be implemented very efficiently in a small number of operations .",
    "more in detail , if ` num ` and ` den ` are arrays of length two containing the leading and next - to - leading terms in the expansion of the numerator and a denominator respectively , we can perform the division in place with the commands    ....",
    "num[0 ] /= den[0 ] ;     num[1 ] -= den[1]*num[0 ] ;     num[1 ] /= den[0 ] ; ....    which will have the effect of replacing the entries of ` num ` with the ones of the expansion of @xmath139 .",
    "we also observe that the computation and the subtraction of pentagons is not needed in the higher - rank case either .",
    "[ [ point - residues-6 ] ] 1-point residues + + + + + + + + + + + + + + + +    on higher - rank 1-point residues @xmath98 we consider @xmath4-dimensional solutions of the corresponding single cut of the form @xmath161 in terms of the free variables @xmath80 and @xmath19 . by taking the @xmath93 limit of the integrand and the subtraction terms evaluated on these solutions , we obtain an asymptotic polynomial expansion of the form @xmath162 one can check that the non - spurious coefficients of the tadpole are given in terms of the ones of the expansions above by @xmath163      in the higher - rank case , the ` muexpansion ` method of the numerator needs to compute both the leading and the next - to - leading term of the expansion in @xmath19 .",
    "the package ninjanumgen , takes care of this automatically when the specified rank is higher than the number of external legs of the loop .",
    "the information in the next paragraph is only needed for a custom implementation of the method without ninjanumgen .",
    "the ` muexpansion ` method in the higher - rank case should compute the two leading terms of the expansion in @xmath80 of the numerator , defined by @xmath164 with @xmath165}}$ ] , where @xmath40 is the array of momenta passed as input parameter .",
    "the leading and next - to - leading terms of the expansion should be written in the first two entry of the array pointed by the parameter ` c ` , i.e.    ....      c[0 ] = $ \\(\\n\\)$[$\\(t^{r}\\)$ ] ;      c[1 ] = $ \\(\\n\\)$[$\\(t^{r-1}\\)$ ] ; ....",
    "all the other methods should have instead the same definition described in section  [ sec : input ] .      as one can see from eq .",
    ", in the higher - rank case five new types of integral appear in the final decomposition .",
    "they are a 2-point integral of rank 3 , a 1-point integral of rank 2 , and three more integrals containing @xmath19 at the numerator which contribute to the rational part of the amplitude .",
    "ninja contains an implementation of all these higher - rank integrals in terms of lower - rank ones .",
    "this means that , should the user choose to interface a custom integral library ( see appendix  [ sec : intlib ] ) , these higher - rank integrals would not be needed , although specifying an alternative implementation would still be possible .",
    "all the integrals of eq .   which contribute to the rational part of the amplitude",
    "have already been computed in ref .",
    "@xcite . with our choice of the normalization factor given in eq .  , they read @xmath166 = { } & \\frac{1}{6}\\left ( \\frac{s_{i_2 i_1 } + s_{i_3 i_2 } + s_{i_1 i_3}}{4 } - m_{i_1}^2 - m_{i_2}^2 - m_{i_3}^2 \\right ) + \\o(\\epsilon)\\\\    i_{i_1 i_2}[\\mu^2\\ , ( ( q+p_{i_1 } ) \\cdot v ) ] = { } & \\frac{((p_{i_2}-p_{i_1 } ) \\cdot v)}{12}\\big ( s_{i_2 i_1 } - 2\\ , m_{i_1}^2 - 4\\ , m_{i_2}^2 \\big )   + \\o(\\epsilon ) \\\\    i_{i_1}[\\mu^2 ] = { } & \\frac{m_{i_1}^4}{2 }    + \\o(\\epsilon)\\end{aligned}\\ ] ] where @xmath167 were defined in eq .",
    "and @xmath40 is an arbitrary vector .",
    "the tadpole of rank 2 appearing in eq .   can also be written as a function of the scalar tadpole integral @xmath168 as follows @xmath169 = { } m_{i_1}^2\\ , \\frac{(e_3\\cdot e_4)}{4}\\left ( i_{i_1 } + \\frac{m_{i_1}^2}{2 } \\right )    + \\o(\\epsilon).\\ ] ] since the vector @xmath170 in the bubble integral of rank 3 appearing in eq .",
    "is massless , the corresponding integral is simply proportional to the form factor @xmath171 , @xmath172 = ( ( p_{i_2}-p_{i_1})\\cdot e_2)^3\\ , b_{111}(s_{i_2 i_1},m_{i_1}^2 , m_{i_2}^2).\\ ] ] the form factor can be computed using the formulas of ref .",
    "@xcite , as a function of form factors of scalar integrals @xmath173 . in the special case with",
    "@xmath174 we use eq .",
    "( a.6.2 ) and ( a.6.3 ) of that reference . for the general case @xmath175",
    "we implement instead the following formula @xmath176-m_{i_2}^2   \\ , i_{i_2}-i_{i_2}[\\mu^2 ] \\nn & - 4   \\ , i_{i_1 i_2}[\\mu^2\\ , ( ( q+p_{i_1})\\cdot ( p_{i_2}-p_{i_1 } ) ) ]",
    "\\nn & - 4 \\ , m_{i_1}^2 \\ ,",
    "i_{i_1 i_2}[(q+p_{i_1})\\cdot ( p_{i_2}-p_{i_1})]\\big ) \\nn & + 4\\ , ( m_{i_2}^2-m_{i_1}^2-s_{i_2 i_1 } ) \\ , i_{i_1 i_2}[((q+p_{i_1})\\cdot ( p_{i_2}-p_{i_1}))^2 ] \\bigg\\}.\\end{aligned}\\ ] ]",
    "ninja already implements interfaces for the oneloop and the looptools integral libraries .",
    "these libraries have been used in a large number of computations and provide very reliable results , hence they should suffice for most purposes . however , ninja has been designed considering the possibility of using any other library of master integrals .",
    "the master integrals are computed by calling virtual methods of the abstract class ` ninja::integrallibrary ` , which is defined in the header file ` ninja / integral_library.hh ` .",
    "therefore , any library of master integrals can be interfaced by implementing a class derived from ` integrallibrary ` .",
    "each method of the library corresponds to a different master integral appearing in eq .  , which should be implemented for both real and complex internal masses ( and optionally for the massless case ) .",
    "an implementation of higher - rank integrals can also be provided but it is not needed , since ninja has a default implementation of them in terms of lower rank integrals .",
    "there are two further methods , namely ` init ` and ` exit ` .",
    "the former is called inside the method ` amplitude::evaluate ` just before the computation of the first needed master integral , while the latter is called after the last master integral has been computed .",
    "the method ` init `      takes as input the square of the renormalization scale to be used in the subsequent calls of the methods implementing the master integrals .",
    "it can also be used in order to perform any other initialization the library might need before computing the integrals .",
    "the ` exit ` method instead , does not need to be implemented and by default it will not perform any action . in section  [ sec : threads ] we gave an example of a case where a non - trivial implementation of the ` exit ` method could be useful .",
    "- real masses    virtual void    getboxintegralrm(complex rslt[3 ] ,                     real s21 , real s32 , real s43 ,                     real s14 , real s31 , real s42 ,                     real m1sq , real m2sq ,                     real m3sq , real m4sq ) = 0 ;      // - complex masses    virtual void    getboxintegralcm(complex rslt[3 ] ,                     real s21 , real s32 , real s43 ,                     real s14 , real s31 , real s42 ,                     const complex & m1sq ,                     const complex & m2sq ,                     const complex & m3sq ,                     const complex & m4sq ) = 0 ; ....    and they must write the @xmath177 term of the result in the @xmath178-th entry of the array ` rslt ` , for @xmath179 .",
    "the arguments are the invariants @xmath167 and the squared masses @xmath180 .",
    "similar methods need to be provided for 3-point , 2-point and 1-point master integrals , as described in detail in the comments inside the header file ` ninja / integral_library.hh ` .",
    "examples of implementation of this interface for the libraries oneloop and looptools can be found in the source code .",
    "more in detail , we define the instances ` ninja::avh_olo ` and ` ninja::loop_tools ` of the classes ` ninja::avhoneloop ` and ` ninja::looptools ` respectively , which implement the methods described above as wrappers of the corresponding routines in each integral library .",
    "the oneloop interface also implements a cache of master integrals on top of these routines .",
    "the cache is implemented similarly to a hash table , which allows constant - time look - up of each computed integral from its arguments .",
    "hence , the methods of the ` avhoneloop ` class will call the routines of the oneloop library only if a master integral is not found in the cache . the cache can be cleared with the class method ` avhoneloop::clearintegralcache ` . during a phase - space integration ,",
    "we suggest calling this method once per phase space point , especially for more complex processes .",
    "this method does not completely free the allocated memory , but keeps the buckets of the hash table available in order to store the integrals more efficiently in subsequent calls of the respective methods .",
    "if the user wishes to completely free the allocated memory , the method ` avhoneloop::freeintegralcache ` can be used , although in general ` clearintegralcache ` should be preferred .",
    "as already mentioned , every instance of ` avhoneloop ` has a cache of master integrals as data member",
    ". this can be useful for building multi - threaded applications , as discussed in the examples of section  [ sec : threads ] .",
    "since looptools already has an internal cache of master integrals , the implementation of its interface is much simpler and only consists in wrapper of its routines .",
    "we implemented a ` clearintegralcache ` method in the ` looptools ` class as well , which in this case simply calls the routine which clears the cache of integrals in looptools ."
  ],
  "abstract_text": [
    "<S> we present the public c++ library ninja , which implements the integrand reduction via laurent expansion method for the computation of one - loop integrals . </S>",
    "<S> the algorithm is suited for applications to complex one - loop processes . </S>"
  ]
}