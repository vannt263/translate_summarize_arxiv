{
  "article_text": [
    "in this paper , we address the issue of automatically proving non - termination of sequential java bytecode programs .",
    "we describe and implement a static analysis that takes a program @xmath0 as input and attempts to prove that there exists an infinite execution of @xmath0 .",
    "it is well - known that termination of computer programs is an undecidable property , hence a non - termination analyser for java bytecode can be used to complement any existing termination analyser , _",
    "aprove  @xcite , costa  @xcite or julia  @xcite .",
    "research in non - termination has mainly been focused on logic programs @xcite and term rewriting systems @xcite .",
    "only a few recent papers address the problem of proving non - termination of imperative programs : @xcite considers java bytecode , @xcite considers programs written in the c language and @xcite considers imperative programs that can be described as logical formul written in a simple while - language .      in  @xcite , we presented a first experimentation with the automatic derivation of non - termination proofs for java bytecode programs .",
    "there , we started from the results introduced in a preliminary version of  @xcite where the original java bytecode program @xmath0 is translated into a constraint logic program @xmath1 whose termination entails that of @xmath0 .",
    "we had the idea of carrying out a very simple non - termination analysis of @xmath1 using earlier results introduced in  @xcite . during our experiments with non - terminating java bytecode programs",
    ", we made the empirical observation that the non - termination of @xmath1 entails that of @xmath0 when @xmath1 is an _",
    "exact _ translation of @xmath0 .",
    "we only introduced a very intuitive and non - formal definition of _ exactness _ and we did not give any formal proof of this entailment . in this paper , we provide the formal definitions and results that are missing in  @xcite ; the corresponding formal proofs are available in the long version at  @xcite .",
    "we also provide a non - termination criterion that works for method calls and recursion , together with a new experimental evaluation of our results over a set of 113 java bytecode programs .",
    "the technique we apply for proving non - termination of @xmath1 is an improvement of a simple sufficient condition for linear binary clp programs  @xcite .",
    "this improved condition ( proposition  [ proposition : unit - loop ] ) is another contribution of this paper .",
    "our main result ( theorem  [ theorem : non - term ] ) is independent of the non - termination detection procedure .",
    "let us point out that there is no perfect non - termination criterion for the clp programs we consider : @xcite shows that the termination of binary clp programs with linear constraints over the integers is undecidable",
    ". however some interesting subclasses have been recently investigated .",
    "for instance , when all the constraints are of the form @xmath2 or @xmath3 , termination of the binary clp program is decidable @xcite .",
    "so when the generated clp program falls into this class , we could replace our general non - termination test by a decision procedure for non - termination .",
    "our results are fully implemented inside the julia static analyser , that we used for conducting the experiments .",
    "julia is a commercial product ( ` http://www.juliasoft.com ` ) .",
    "its non - termination analysis can be freely used through the web interface  @xcite , whose power is limited by a time - out and a maximal size of analysis .      to the best of our knowledge , only @xcite introduce methods and implementations that are directly comparable to the results of this paper .    in  @xcite ,",
    "the program @xmath0 under analysis is first transformed into a _ termination graph _ that finitely represents all runs through the program .",
    "then , a term rewrite system is generated from the graph and existing techniques from term rewriting are used to prove non - termination of the rewrite system .",
    "this approach has been successfully implemented inside the aprove analyser  @xcite .",
    "note that the rewrite system generated from the termination graph is an _ abstraction _",
    "@xcite of @xmath0 ; the technique that we present in this paper also computes an abstraction of @xmath0 but a difference is that our abstraction consists of a constraint logic program @xmath1 instead of a term rewrite system .",
    "the technique described in  @xcite is a combination of dynamic and static analysis .",
    "it consists in generating _ lassos _ that are checked for _",
    "feasibility_. a lasso consists of a finite program path called stem , followed by a finite program path called loop ; it is feasible when an execution of the stem can be followed by infinitely many executions of the loop .",
    "lassos are generated through a dynamic execution of the program on concrete as well as symbolic inputs ; symbolic constraints are gathered during this execution and are used for expressing the feasibility of the lassos as a constraint satisfaction problem .",
    "this technique has been implemented inside the tnt non - termination analyser for c programs .",
    "the analysis that we present in this paper also looks for feasible lassos : it tries to detect some loops that have an infinite execution from some input values and to prove that these values are reachable from the main entry point of the program ( proposition  [ proposition : compound - loops ] ) .",
    "a difference is that our technique does not combine static with dynamic analysis .",
    "another difference is that the approach of  @xcite provides a bit - level analysis which is able to detect non - termination due , _ e.g. , _ to arithmetic overflow .    in  @xcite ,",
    "the authors consider a simple while - language that is used to describe programs as logical formul .",
    "the non - termination of the program @xmath0 under analysis is expressed as a logical formula involving the description of @xmath0 .",
    "the method then consists in proving that the non - termination formula is true by constructing a proof tree using a gentzen - style sequent calculus .",
    "the rule of the sequent calculus corresponding to the ` while ` instruction uses invariants , that have to be generated by an external method .",
    "hence , @xcite introduces several techniques for creating and for scoring the invariants according to their probable usefulness ; useless invariants are discarded ( invariant filtering ) .",
    "the generated invariants are stored inside a queue ordered by the scores .",
    "the algorithms described in  @xcite have been implemented inside the invel non - termination analyser for java programs  @xcite .",
    "invel uses the key  @xcite theorem prover for constructing proof trees .",
    "as far as we know , it was the first tool for automatically proving non - termination of imperative programs .",
    "one of the main differences between the techniques introduced in  @xcite and ours is that we first construct an abstraction of the program under analysis and then we keep on reasoning on this abstraction only .",
    "the algorithms presented in  @xcite model the semantics of the concrete program more accurately .",
    "they hence do not suffer from some lack of precision that we face ; we were not able to exactly translate some bytecode instructions into constraints , therefore our method fails on the programs that include these instructions .",
    "on the other hand , the techniques that directly consider the original concrete program are generally time consuming and they do not scale very well . finally , a major difference between our approach and that of  @xcite is that we are able to detect non - termination due to infinite recursion , whereas @xcite are not .",
    "our experiments illustrate this consideration very clearly .",
    "note that the approach in  @xcite can deal with non - terminating recursion .",
    "the rest of this paper is organised as follows .",
    "section  [ section : preliminaries ] introduces the basic formal material borrowed from  @xcite .",
    "section  [ section : exact - approximations ] provides a formal definition of exactness for the abstraction of a java bytecode instruction into a linear constraint . in section  [ section : compilation ] , we show how to automatically generate a constraint logic program @xmath1 from a java bytecode program @xmath0 so that the non - termination of @xmath1 entails that of @xmath0 . section  [ section : clp - nontermination ] deals with proving non - termination of @xmath1 ; it provides an improvement of a non - termination criterion that we proposed in  @xcite .",
    "section  [ section : experiments ] describes our experiments on a set of 113 non - terminating programs obtained from different sources .",
    "section  [ section : conclusion ] concludes the paper .",
    "we strictly adhere to the notations , definitions , and results introduced in  @xcite .",
    "we briefly list the elements that are relevant to this paper . for ease of exposition",
    ", we consider a simplification of the java bytecode where values can only be integers , locations or ` null ` .",
    "[ def : state ] the set of _ values _ is @xmath4 , where @xmath5 is the set of integers and @xmath6 is the set of _ memory locations_. a _ state _ of the java virtual machine is a triple @xmath7 where @xmath8 is an array of values , called _ local variables _ and numbered from @xmath9 upwards , @xmath10 is a stack of values , called _ operand stack _ ( in the following , just _ stack _ ) , which grows leftwards , and @xmath11 is a _ memory _ , or _ heap _ , which maps _ locations _ into _ objects_. an object is a function that maps its fields into values .",
    "we write @xmath12 for the value of the @xmath13th local variable ; we write @xmath14 for the value of the @xmath13th stack element ( @xmath15 is the base of the stack , @xmath16 is the element above and so on ) .",
    "the set of all states is denoted by @xmath17 . when we want to fix the exact number @xmath18 of local variables and @xmath19 of stack elements allowed in a state , we write @xmath20 .",
    "[ example : state ] consider a memory @xmath21\\ ] ] where @xmath22 $ ] , @xmath23 $ ] , @xmath24 $ ] , @xmath25 $ ] and @xmath26 $ ] .",
    "then , @xmath27\\operatorname{\\mid\\!\\mid}\\ell_1::\\ell_2::\\ell_3\\operatorname{\\mid\\!\\mid}\\mu\\rangle\\ ] ] is a state in @xmath28 . here",
    ", @xmath29 is the topmost element of the stack of @xmath30 , @xmath31 is the underlying element and @xmath32 is the element still below it .",
    "[ def : types ] the set of _ types _ of our simplified java virtual machine is @xmath33 , where @xmath34 is the set of all classes .",
    "the @xmath35 type can only be used as the return type of methods .",
    "a method signature is denoted by @xmath36 standing for a method named @xmath37 , defined in class @xmath38 , expecting @xmath39 explicit parameters of type , respectively , @xmath40 and returning a value of type @xmath41 , or returning no value when @xmath42 .",
    "we recall that in object - oriented languages , a non - static method @xmath36 has also an _ implicit _ parameter of type @xmath38 called ` this ` inside the code of the method .",
    "hence , the actual number of parameters is @xmath43 .",
    "a restricted set of eleven java bytecode instructions is considered in  @xcite .",
    "these instructions exemplify the operations that the java virtual machine performs .",
    "similarly , in this paper we only consider nine instructions , but our implementation handles most of their variants .",
    "[ def : instructions ] we let @xmath44 denote the set consisting of the following java bytecode instructions .    * @xmath45 , pushes the constant @xmath46 on top of the stack . *",
    "@xmath47 , duplicates the topmost element of the stack .",
    "* @xmath48 , creates an object of class @xmath38 and pushes a reference to it on the stack . *",
    "@xmath49 , pushes the value of local variable @xmath50 on top of the stack . *",
    "@xmath51 , pops the top value from the stack and writes it into local variable @xmath50 .",
    "* @xmath52 , pops the topmost two values from the stack and pushes their sum instead .",
    "* @xmath53 , where @xmath54 has integer type , pops the topmost two values @xmath55 ( the top ) and @xmath56 ( under @xmath55 ) from the stack where @xmath56 must be a reference to an object @xmath57 or @xmath58 ; if @xmath56 is @xmath58 , the computation stops , else @xmath55 is stored into field @xmath54 of @xmath57 .",
    "* @xmath59 , with @xmath60 , pops the topmost element from the stack and checks if it is 0 ( when @xmath41 is @xmath61 ) or @xmath58 ( when @xmath41 is a class ) ; if it is not the case , the computation stops . *",
    "@xmath62 , with @xmath63 , pops the topmost element from the stack and checks , respectively , if it is less than 0 , less than or equal to 0 , greater than 0 , greater than or equal to 0 ; if it is not the case , the computation stops . * @xmath64 .",
    "if @xmath37 is a static method , this instruction pops the topmost @xmath39 values ( the _ actual parameters _ ) @xmath65 , ",
    ", @xmath66 from the stack ( where @xmath66 is the topmost value ) and @xmath37 is run from a state having an empty stack and a set of local variables bound to @xmath67 .",
    "if @xmath37 is not static , this instruction pops the topmost @xmath43 values ( the _ actual parameters _ ) @xmath68 , @xmath65 , ",
    ", @xmath66 from the stack ( where @xmath66 is the topmost value ) .",
    "value @xmath68 is called _",
    "receiver _ of the call and must be @xmath58 or a reference to an object of class @xmath38 or of a subclass of @xmath38 . if the receiver is @xmath58 , the computation stops .",
    "otherwise , method @xmath37 is run from a state having an empty stack and a set of local variables bound to @xmath69 .    unlike  @xcite",
    ", we do not consider the instruction @xmath70 , which is used for getting the value of the field @xmath54 of an object , and @xmath53 , where @xmath54 has class type .",
    "this is because we can not design an exact abstraction , as defined in sect .",
    "[ section : exact - approximations ] , of these instructions .",
    "we also do not consider the instruction @xmath71 , which pops the topmost element from the stack , checks if it is 0 ( when @xmath41 is ` int ` ) or ` null ` ( when @xmath41 is a class ) and , if it is the case , stops the computation .",
    "this is because we have implemented the results of this paper inside the julia analyser , which now systematically replaces the @xmath72 instruction with a disjunction of @xmath73 ( less than 0 ) and @xmath74 ( greater than 0 ) ; these two instructions belong to the set considered by our implementation .",
    "finally , the @xmath75 instruction considered in  @xcite has the form @xmath76 where @xmath77 is an over - approximation of the set of methods that might be called at run - time , at the program point where the call occurs .",
    "this is because object - oriented languages , such as java bytecode , allow dynamic lookup of method implementations in method calls , on the basis of the run - time class of their receiver .",
    "hence , the exact control - flow graph of a program is not computable in general , but an over - approximation can be computed instead . in this paper",
    ", we present a technique for proving _ existential _ non - termination _",
    "i.e. , _ for proving that _ there exists _ some inputs that lead to an infinite execution .",
    "so , we have to ensure that the methods we consider in the @xmath75 instructions are effectively called at run - time : this happens when @xmath78 only consists of one element .",
    "therefore , unlike  @xcite , we only consider calls of the form @xmath64 in this paper , and our technique can not deal with situations where @xmath78 consists of more than one element .",
    "we assume that _ flat _ code , as the one in fig .",
    "[ fig : sum_term_java ] , is given a structure in terms of blocks of code linked by arrows expressing how the flow of control passes from one to another .",
    "we require that a @xmath75 instruction can only occur at the beginning of a block .",
    "for instance , fig .",
    "[ fig : sum_nonterm_blocks ] shows the blocks derived from the code of the method ` sum ` in fig .  [ fig : sum_term_java ] .",
    "note that at the beginning of the methods , the local variables hold the parameters of the method .    from now on ,",
    "java bytecode program _ will be a graph of blocks , such as that in fig .",
    "[ fig : sum_nonterm_blocks ] ; inside each block , there is one or more instructions among those described in definition  [ def : instructions ] .",
    "this graph typically contains many disjoint subgraphs , each corresponding to a different method or constructor . the ends of a method or constructor , where the control flow returns to the caller , are the end of every block with no successor , such as the leftmost one in fig .",
    "[ fig : sum_nonterm_blocks ] . for simplicity , we assume that the stack there contains exactly as many elements as are needed to hold the return value ( normally @xmath79 element , but @xmath9 element in the case of methods returning @xmath35 , such as all the constructors or the ` main ` method ) .    a denotational semantics for java bytecode is presented in  @xcite together with a _ path - length _ relational abstract domain that is used for proving termination of java bytecode programs .",
    "denotations are state transformers that can be composed to model the sequential execution of instructions .",
    "[ def : denotation ] a denotation is a partial function @xmath80 from an _ input _ state to an _ output _ or _ final _ state .",
    "the set of denotations is denoted by @xmath81 .",
    "when we want to fix the number of local variables and stack elements in the input and output states , we write @xmath82 , standing for @xmath83 . let @xmath84 .",
    "their _ sequential composition _ is @xmath85 , which is undefined when @xmath86 is undefined or when @xmath87 is undefined .    for each instruction @xmath88 in @xmath44 and program point @xmath89 where @xmath88 occurs",
    ", @xcite provides the definition of a corresponding denotation @xmath90 .",
    "let @xmath89 be a program point where the instruction @xmath47 occurs and let @xmath91 and @xmath92 be the number of local variables and stack elements at @xmath89 .",
    "the denotation @xmath93 corresponding to @xmath47 at @xmath89 is defined as : @xmath94 and @xmath95 where @xmath96 denotes a non - empty stack whose top element is @xmath97 and remaining portion is @xmath10 .",
    "@xcite also defines the abstraction of @xmath90 into its path - length polyhedron @xmath98 .",
    "[ def : path_length_domain ] let @xmath99 .",
    "the set @xmath100 of the _ path - length polyhedra _ contains all finite sets of integer linear constraints over the variables @xmath101 , using only the @xmath102 , @xmath103 and @xmath104 comparison operators .",
    "the path - length polyhedron @xmath105 describes the relationship between the _ sizes _ @xmath106 and @xmath107 of the local variables and stack elements in the input state of @xmath90 and the sizes @xmath108 and @xmath109 of the local variables and stack elements in the output state of @xmath90 .",
    "the size of a local variable or stack element @xmath55 in a memory @xmath11 is denoted by @xmath110 and is informally defined as : if @xmath111 then @xmath112 , if @xmath55 is ` null ` then @xmath113 and if @xmath55 is a location then @xmath110 is the maximal length in @xmath11 of a chain of locations that one can follow from @xmath55 .",
    "@xcite defines @xmath114 where @xmath115 .",
    "hence , @xmath116 expresses the fact that after an execution of @xmath47 , the new top of the stack has the same path - length as the former one ( @xmath117 ) and that the path - length of the local variables and stack elements is unchanged ( @xmath118 ) .",
    "note that @xcite also provides the definition of the abstract counterpart @xmath119 of the operator @xmath120 used for composing denotations .",
    "the operator @xmath119 is hence used for composing path - length polyhedra .    [",
    "def : abstract_transformers ] let @xmath121 together with @xmath122 .",
    "let @xmath123 .",
    "we define @xmath124 as @xmath125\\cup      { \\mathit{\\mathit{pl}}}_2[{\\check{{v}}}\\mapsto\\overline{v}\\mid\\overline{v}\\in t ]    \\right)\\ ] ] where @xmath126 $ ] ( resp .",
    "$ ] ) denotes the replacement in @xmath128 ( resp .",
    "@xmath129 ) of @xmath130 with @xmath131 ( resp .",
    "@xmath132 with @xmath131 ) .",
    "the abstractions @xmath105 , for each @xmath133 , and the abstraction @xmath119 are all proved to be _ correct _ _",
    "@xcite provides the proof that these abstractions include their concrete counterpart in their concretisation .",
    "[ def : model ] let @xmath134 and @xmath135 be an assignment from a superset of the variables of @xmath136 into @xmath137 .",
    "we say that @xmath138 is a _ model _ of @xmath136 and we write @xmath139 when @xmath140 is true , that is , by substituting , in @xmath141 , the variables with their values provided by @xmath138 , we get a tautological set of ground constraints .",
    "any state can be mapped into an input path - length assignment , when it is considered as the input state of a denotation , or into an output path - length assignment , when it is considered as the output state of a denotation .",
    "[ def : assignment ] let @xmath142 .",
    "input path - length assignment _ is @xmath143\\\\      & \\cup[{\\check{{s}}}^k\\mapsto{\\mathit{len}}(s^k,\\mu)\\mid 0\\le k < \\#s ]    \\end{aligned}\\ ] ] and , similarly , its _ output path - length assignment _ is @xmath144\\\\      & \\cup [ { \\hat{{s}}}^k\\mapsto{\\mathit{len}}(s^k,\\mu)\\mid 0\\le k < \\#s]~.    \\end{aligned}\\ ] ]    [ example : len ] in example  [ example : state ] , @xmath145      = \\left[\\begin{array}{l }          { \\check{{l}}}^0\\mapsto 5,\\\\          { \\check{{l}}}^1\\mapsto 1,\\\\          { \\check{{s}}}^0 \\mapsto 2,\\\\          { \\check{{s}}}^1 \\mapsto 1,\\\\          { \\check{{s}}}^2 \\mapsto 2        \\end{array}\\right]\\;.    \\end{aligned}\\ ] ] similarly , @xmath146\\;.\\ ] ]",
    "our technique for proving non - termination of a java bytecode program @xmath0 consists in abstracting @xmath0 as a @xmath147 program @xmath1 , then in proving non - termination of @xmath1 , and finally in concluding the non - termination of @xmath0 from that of @xmath1 , when it is possible . in  @xcite , we observed informally that when the abstraction of @xmath0 as @xmath1 is _ exact _ , the non - termination of @xmath1 entails that of @xmath0 . in this section",
    ", we give a formal definition of exactness .",
    "first , we start with preliminary definitions , where we let @xmath148 denote the codomain of the denotation @xmath149 .",
    "[ definition : input_output_assignment ] let @xmath150 and @xmath138 be a model of @xmath141 .",
    "we let @xmath151 denote the assignment obtained by restricting the domain of @xmath138 to the input variables @xmath152 ,  , @xmath153 and @xmath154 ,  , @xmath155 .",
    "we let @xmath156 denote the assignment obtained by restricting the domain of @xmath138 to the output variables @xmath157 ,  , @xmath158 and @xmath159 ,  ,",
    "@xmath160 .",
    "we say that a state @xmath30 is _ compatible _ with a denotation @xmath161 when @xmath30 satisfies the static information at @xmath161 ( number and type of local variables and stack elements ) .",
    "we say that a denotation @xmath149 is _ compatible _ with a denotation @xmath162 when any state in @xmath148 is compatible with @xmath162 .",
    "our definition of exactness is the following .",
    "intuitively , the abstraction of a denotation @xmath161 into a path - length polyhedron @xmath141 is exact when @xmath141 , considered as an input - output mapping from input to output variables , exactly matches @xmath161 _ i.e. , _ any model of @xmath141 only corresponds to states for which @xmath161 is defined .",
    "[ definition : models ] let @xmath163 and @xmath150 .",
    "we say that @xmath141 is an _ exact abstraction _ of @xmath161 , and we write @xmath164 , when for any model @xmath138 of @xmath141 and any state @xmath30 compatible with @xmath161 , @xmath165 implies that @xmath166 is defined and @xmath167 .",
    "exactness is preserved by sequential composition :    [ proposition : composition ] let @xmath168 , @xmath121 be such that @xmath169 .",
    "let @xmath170 and @xmath122 be such that @xmath171 .",
    "suppose that @xmath149 is compatible with @xmath162 .",
    "then , we have @xmath172 .    except from @xmath75 ,",
    "all the bytecode instructions we consider in this paper are exactly abstracted :    [ proposition : instructions_exactness ] for any @xmath173 and program point @xmath89 where @xmath88 occurs , we have @xmath174 .",
    "the proof for @xmath48 assumes that the denotation of this bytecode is a total map .",
    "this is true only if we assume that the system has infinite memory .",
    "termination caused by out of memory is not really termination from our point of view .",
    "we deal with the @xmath75 instruction in sect .",
    "[ section : compilation ] : we do not abstract its denotation into a path - length polyhedron but rather translate it into a call to a predicate ( see definitions  [ def : clp_block_call_not_void][def : clp_block_call_not_void_one_inst ] below ) .    let @xmath89 be a program point where the instruction @xmath47 occurs and let @xmath91 and @xmath92 be the number of local variables and stack elements at @xmath89 .",
    "we have @xmath175 let @xmath138 be a model of @xmath116 .",
    "let @xmath30 be a state that is compatible with @xmath93 .",
    "then , @xmath176 and @xmath30 has the form @xmath177 .",
    "clearly , @xmath178 is defined and we have @xmath179 .",
    "suppose that @xmath165 .",
    "* for any @xmath180 , we have @xmath181 because @xmath30 and @xmath178 have the same array of local variables @xmath8 and memory @xmath11 . moreover , as @xmath165 , we have @xmath182 . as @xmath138 is a model of @xmath116 , with @xmath183",
    ", we have @xmath184 . therefore , @xmath185 . * similarly , for any @xmath186 , @xmath187 .",
    "* finally , consider the top element @xmath188 in the stack of @xmath178 .",
    "we have @xmath189 as @xmath138 is a model of @xmath116 , with @xmath190 , we have @xmath191 .",
    "so , @xmath192 .    consequently , we have @xmath193 .",
    "the technique that we describe in  @xcite for proving the termination of a java bytecode program @xmath0 computes a @xmath147 program @xmath1 which is an _ over - approximation _ of @xmath0 , in the sense that the set of executions of @xmath0 is `` included '' in that of @xmath1 .",
    "this is because some bytecode instructions considered in  @xcite _ e.g. , _",
    "@xmath75 , are not exactly abstracted , in the sense of definition  [ definition : models ] , but are over - approximated instead .    the bytecode instruction @xmath70 pops the topmost value @xmath56 of the stack , which must be a reference to an object @xmath57 or @xmath58 , and pushes @xmath194 at its place . if @xmath56 is @xmath58 , the computation stops . for any program point @xmath89 with @xmath91 local variables and @xmath92 stack elements and any field @xmath54 with integer type , @xcite defines : @xmath195 the denotation @xmath196 is not exactly abstracted by the path - length polyhedron @xmath197 because @xmath197 does not provide any constraint for the top @xmath198 of the output stack , while in @xmath196 a new element appears on top of the output stack .",
    "hence , @xmath197 does not exactly matches @xmath196 : for some model @xmath138 of @xmath197 , there exists a state @xmath30 which is such that @xmath165 and @xmath199 . for instance , suppose that @xmath200 and @xmath201 and let @xmath202 \\;.",
    "\\end{aligned}\\ ] ] then , @xmath138 is a model of @xmath197 .",
    "the state @xmath27\\operatorname{\\mid\\!\\mid}\\ell_1::\\ell_2::\\ell_3\\operatorname{\\mid\\!\\mid}\\mu\\rangle\\ ] ] of example",
    "[ example : state ] is compatible with @xmath196 and , by example  [ example : len ] , we have @xmath165 . moreover , as @xmath203 , @xmath204\\operatorname{\\mid\\!\\mid}\\ell_4::\\ell_2::\\ell_3\\operatorname{\\mid\\!\\mid}\\mu\\rangle\\;.\\ ] ] as @xmath205 , we have @xmath206      \\multicolumn{1}{r}{\\hspace{2 cm }        [ { \\hat{{l}}}^0\\mapsto 5 ,        { \\hat{{l}}}^1\\mapsto 1 ,        { \\hat{{s}}}^0\\mapsto 2 ,        { \\hat{{s}}}^1\\mapsto 1 ,        { \\hat{{s}}}^2\\mapsto 1]\\;. }    \\end{array}\\ ] ] consequently , @xmath207 .    for non - termination , we rather need an _ under - approximation _ of @xmath0 , _",
    "i.e. , _ a program whose set of executions is `` included '' in that of @xmath0 . note that because of proposition  [ proposition : instructions_exactness ] , when @xmath0 only consists of instructions in @xmath208 , the set of executions of @xmath1 , computed as in  @xcite , exactly matches that of @xmath0 and we have :    [ theorem : clp_completeness ] let @xmath209 be a java virtual machine , @xmath0 be a java bytecode program consisting of instructions in @xmath208 , and @xmath210 be a block of @xmath0 .",
    "let @xmath1 be the abstraction of @xmath0 as a @xmath147 program , computed as in  @xcite .",
    "the query @xmath211 has only terminating computations in @xmath1 , for any fixed integer values for @xmath212 , _ if and only if _ all executions of @xmath209 started at block @xmath210 terminate .    in this section",
    ", we consider a java bytecode program @xmath0 consisting of _ any _ instructions in @xmath44 ( including @xmath75 ) and we describe a technique for abstracting @xmath0 as a @xmath147 program @xmath1 whose non - termination entails that of @xmath0 .",
    "we do not abstract the @xmath75 instruction into a path - length polyhedron but we rather translate it into an explicit call to a predicate .",
    "we consider a block @xmath210 : @xmath213 of @xmath0 occurring in a method @xmath214 and we describe the set @xmath215 of @xmath147 clauses derived from @xmath210 ; here , @xmath216 @xmath217 , ",
    ", @xmath218 are the instructions of @xmath210 and @xmath219 ,  , @xmath220 are the successor blocks of @xmath210 in @xmath0 .",
    "we let @xmath221 be the input local variables and stack elements at the beginning of @xmath210 and @xmath222 be the output local variables and stack elements at the end of @xmath210 ( in some fixed order ) .    we let @xmath223 and @xmath224 be some fresh variables , not occurring in @xmath225 , and we use them to capture the path - length of the return value of @xmath214 . in definitions  [ def :",
    "clp_block_no_call_not_void][def : clp_block_call_not_void_one_inst ] below , when @xmath210 has no successor ( @xmath226 ) , at the end of @xmath210 the stack contains exactly the return value of @xmath214 ; hence , @xmath159 is bound to the path - length of this return value and we set @xmath227 in order to capture this path - length .",
    "it is important to remark that we assume a specialised semantics of _ clp _ computations here , where variables are always bound to integer values , except for @xmath223 and @xmath224 .",
    "this means that we do not allow _ free _ variables in a call to a predicate , except for @xmath223 and @xmath224 which are always free until they get bound to a value in a clause corresponding to a block with no successor ( see the constraints @xmath227 in definitions  [ def : clp_block_no_call_not_void][def : clp_block_call_not_void_one_inst ] below ) .",
    "first , we consider the situation where @xmath210 does not start with a @xmath75 instruction .",
    "for each successor @xmath228 of @xmath210 , we generate a clause of the form @xmath229 which indicates that the flow of control passes from @xmath210 to @xmath228 . here , @xmath46 is a constraint which expresses the sequential execution of the instructions of @xmath210 .",
    "[ def : clp_block_no_call_not_void ] suppose that @xmath216 is not a @xmath75 instruction .",
    "let @xmath230 we define @xmath215 as follows .    1 .   if @xmath231 , @xmath215 is the set consisting of the @xmath147 clauses @xmath232 2 .",
    "if @xmath233 , @xmath215 is the set consisting of the @xmath147 clause @xmath234    now , suppose that block @xmath210 starts with a @xmath75 instruction to a non - static method @xmath37 with @xmath39 actual parameters .",
    "then , at the beginning of @xmath210 , the actual parameters of @xmath37 sit on the top of the stack and , at the end of the @xmath75 instruction , these parameters are replaced with the return value of @xmath37 : @xmath235 ( @xmath68 is the receiver and the memory @xmath11 may be affected by the call ) . therefore , if @xmath91 and @xmath92 are the number of local variables and stack elements after the @xmath75 instruction , then , in the input state of @xmath75 , @xmath236 ,  , @xmath237 are the actual parameters of @xmath37 where @xmath237 is the receiver and , in the output state of @xmath75 , @xmath237 is the return value of @xmath37 . note that the array @xmath8 of local variables and the stack portion @xmath10 under the actual parameters remain unchanged after the call . in general",
    ", this does not mean that the path - length of their elements remains the same , as the execution of a method may modify the memory @xmath11 , hence the path - length of locations in @xmath8 and @xmath10 .",
    "in the scope of this paper , however , we discard the instructions of the form @xmath53 where @xmath54 has class type .",
    "therefore , the instructions we consider do not modify the path - length of locations ; hence after a method call , the path - length of the elements of @xmath8 and @xmath10 remains the same . in definition",
    "[ def : clp_block_call_not_void ] and definition  [ def : clp_block_call_not_void_one_inst ] below , this operational semantics of @xmath75 is modelled by :    * the constraint @xmath238 which specifies that the path - length of the local variables and stack elements under the actual parameters is not modified by the call , * the constraint @xmath239 , which specifies that the receiver of the call is not @xmath58 , and * the atom @xmath240 , where @xmath241 denotes the entry block of @xmath37 .    when the call is over , control returns to the next instruction .",
    "we distinguish two situations here : that where @xmath210 contains more than one instruction ( definition  [ def : clp_block_call_not_void ] ) , then control returns to the instruction in @xmath210 following the call to @xmath37 , and the situation where @xmath210 consists of the call to @xmath37 only ( definition  [ def : clp_block_call_not_void_one_inst ] ) , then control returns to a successor of @xmath210 .",
    "[ def : clp_block_call_not_void ] suppose that @xmath242 and that @xmath216 is not the only instruction in @xmath210 ( _ i.e. , _",
    "@xmath243 ) .",
    "let @xmath244 let @xmath245 be the output local variables and stack elements at the end of @xmath216 and @xmath246 be the input local variables and stack elements at the beginning of @xmath217 ( in some fixed order ) .",
    "we suppose that @xmath223 and @xmath224 do no occur in @xmath246 and @xmath245 .",
    "we define @xmath215 as follows .    1 .",
    "if @xmath247 , @xmath215 is the set consisting of the @xmath147 clause @xmath248 together with @xmath249 where @xmath250 is a fresh predicate symbol .",
    "2 .   if @xmath233 , @xmath215 is the set consisting of the @xmath147 clause @xmath251 together with @xmath252 where @xmath250 is a fresh predicate symbol .",
    "[ def : clp_block_call_not_void_one_inst ] suppose that @xmath242 and that @xmath216 is the only instruction in @xmath210 ( _ i.e. , _",
    "@xmath253 ) .",
    "we define @xmath215 as follows .    1 .   if @xmath247 , @xmath215 is the set consisting of the @xmath147 clauses @xmath254 2 .   if @xmath233 , then @xmath255 and @xmath215 is the set consisting of the @xmath147 clause @xmath256    the return type of the methods that we consider in definitions  [ def : clp_block_no_call_not_void][def : clp_block_call_not_void_one_inst ] is supposed to be non-`void ` .",
    "the situation where block @xmath210 occurs inside a method whose return type is ` void ` is handled similarly , except that we remove the variables @xmath223 and @xmath224 and the constraints where they occur .",
    "the situation where the first instruction of @xmath210 is @xmath257 , where the return type of @xmath37 is @xmath35 , is handled as in definitions  [ def : clp_block_call_not_void][def : clp_block_call_not_void_one_inst ] , except that we remove the last parameter of @xmath241 . in definitions",
    "[ def : clp_block_call_not_void][def : clp_block_call_not_void_one_inst ] , @xmath37 is also supposed to be a non - static method .",
    "the situation where @xmath37 is static is handled similarly , except that we remove the constraint @xmath239 , as there is no call receiver on the stack .",
    "[ def : clp_construction ] let @xmath0 be a java bytecode program given as a graph of blocks .",
    "the @xmath147 program @xmath1 derived from @xmath0 is defined as @xmath258    in this paper , we consider the _ leftmost selection rule _ for computations in @xmath147 programs .",
    "then , we have :    [ theorem : non - term ] let @xmath209 be a java virtual machine , @xmath0 be a java bytecode program consisting of instructions in @xmath44 , and @xmath210 be a block of @xmath0 .",
    "let @xmath212 be some fixed integer values and @xmath223 be a free variable .",
    "if the query @xmath259 has an infinite computation in @xmath1 then there is an execution of @xmath209 started at block @xmath210 that does not terminate .    ....      public class sum {        public static int sum(int n ) {",
    "if ( n = = 0 ) return 0 ;          else return n + sum(n - 1 ) ;        }        public static void main(string args [ ] ) {          sum(-1 ) ;        }      }     ....    [ example : sumnonterm ] consider the recursive method ` sum ` in fig .",
    "[ fig : sum_term_java ] , whose graph of blocks is given in fig .",
    "[ fig : sum_nonterm_blocks ] .",
    ", where each block is decorated with a unique name . on the right of each instruction ,",
    "we report the number of local variables and stack elements at that program point , just before executing the instruction . ]",
    "* the block @xmath260 has @xmath219 , @xmath261 and @xmath262 as successors and its first instruction is not a @xmath75 instruction .",
    "let @xmath89 be the program point where the instruction @xmath263 of the block @xmath260 occurs .",
    "we have @xmath264 hence , by definition  [ def : clp_block_no_call_not_void ] , @xmath265 consists of the following clauses : @xmath266 * the block @xmath219 has no successor and its first instruction is not a @xmath75 instruction .",
    "let @xmath89 and @xmath267 be the program points where the instructions @xmath268 and @xmath269 of the block @xmath219 occur , respectively .",
    "we have @xmath270 hence , by definition  [ def : clp_block_no_call_not_void ] , @xmath271 consists of the following clause : @xmath272 * the block @xmath273 consists of only one instruction , which is a call to a static method , and it has @xmath274 as unique successor .",
    "we have @xmath275 hence , by definition  [ def : clp_block_call_not_void_one_inst ] , @xmath276 consists of the following clause : @xmath277    the complete @xmath147 program derived from the program in fig .",
    "[ fig : sum_term_java ] consists of the clauses in table  [ table : clp ] .",
    "@xmath278        ( r_2 ) & \\mathit{sum}({\\check{{l}}}^0,{\\check{{s}}}_{\\mathit{sum } } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{l}}}^0={\\hat{{s}}}^0 ,        { \\check{{s}}}_{\\mathit{sum}}={\\hat{{s}}}_{\\mathit{sum}}\\},\\\\        & \\hspace{2.1cm}b_2({\\hat{{l}}}^0,{\\hat{{s}}}^0,{\\hat{{s}}}_{\\mathit{sum } } )        \\\\[1ex ]        ( r_3 ) & \\mathit{sum}({\\check{{l}}}^0,{\\check{{s}}}_{\\mathit{sum } } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{l}}}^0={\\hat{{s}}}^0 ,        { \\check{{s}}}_{\\mathit{sum}}={\\hat{{s}}}_{\\mathit{sum}}\\},\\\\        & \\hspace{2.1cm}b_3({\\hat{{l}}}^0,{\\hat{{s}}}^0,{\\hat{{s}}}_{\\mathit{sum } } )        \\\\[1ex ]        ( r_4 ) & b_1({\\check{{l}}}^0,{\\check{{s}}}^0,{\\check{{s}}}_{b_1 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{s}}}^0 = 0,0={\\hat{{s}}}^0 ,        { \\check{{s}}}_{b_1}={\\hat{{s}}}^0\\ }        \\\\[1ex ]        ( r_5 ) & b_2({\\check{{l}}}^0,{\\check{{s}}}^0,{\\check{{s}}}_{b_2 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{s}}}^0 \\leq -1,{\\check{{s}}}_{b_2}={\\hat{{s}}}_{b_2}\\},\\\\        & \\hspace{2cm}b_4({\\hat{{l}}}^0,{\\hat{{s}}}_{b_2 } )        \\\\[1ex ]        ( r_6 ) & b_3({\\check{{l}}}^0,{\\check{{s}}}^0,{\\check{{s}}}_{b_3 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{s}}}^0 \\geq 1,{\\check{{s}}}_{b_3}={\\hat{{s}}}_{b_3}\\},\\\\        & \\hspace{2cm}b_4({\\hat{{l}}}^0,{\\hat{{s}}}_{b_3 } )        \\\\[1ex ]        ( r_7 ) & b_4({\\check{{l}}}^0,{\\check{{s}}}_{b_4 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0 ,        { \\check{{l}}}^0={\\hat{{s}}}^0,{\\check{{l}}}^0 - 1={\\hat{{s}}}^1 ,        { \\check{{s}}}_{b_4}={\\hat{{s}}}_{b_4}\\},\\\\        & \\hspace{1.6 cm }        b_5({\\hat{{l}}}^0,{\\hat{{s}}}^0,{\\hat{{s}}}^1,{\\hat{{s}}}_{b_4 } )        \\\\[1ex ]        ( r_8 ) & b_5({\\check{{l}}}^0,{\\check{{s}}}^0,{\\check{{s}}}^1,{\\check{{s}}}_{b_5 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{s}}}^0={\\hat{{s}}}^0 ,        { \\check{{s}}}_{b_5}={\\hat{{s}}}_{b_5}\\},\\\\        & \\hspace{2.5cm}\\mathit{sum}({\\check{{s}}}^1,{\\hat{{s}}}^1 ) ,        b_6({\\hat{{l}}}^0,{\\hat{{s}}}^0,{\\hat{{s}}}^1,{\\hat{{s}}}_{b_5 } )        \\\\[1ex ]        ( r_9 ) & b_6({\\check{{l}}}^0,{\\check{{s}}}^0,{\\check{{s}}}^1,{\\check{{s}}}_{b_6 } ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,{\\check{{s}}}^0+{\\check{{s}}}^1={\\hat{{s}}}^0 ,        { \\check{{s}}}_{b_6}={\\hat{{s}}}^0\\ }        \\\\                          \\hline\\hline        \\multicolumn{2}{|c|}{\\texttt{main}}\\\\        \\hline        ( r_{10 } ) & \\mathit{main}({\\check{{l}}}^0 ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0,-1={\\hat{{s}}}^0\\ } ,        b_7({\\hat{{l}}}^0,{\\hat{{s}}}^0 )        \\\\[1ex ]        ( r_{11 } ) & b_7({\\check{{l}}}^0,{\\check{{s}}}^0 ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0\\ } ,        \\mathit{sum}({\\check{{s}}}^0,{\\hat{{s}}}^0 ) ,        b_8({\\hat{{l}}}^0,{\\hat{{s}}}^0 )        \\\\[1ex ]        ( r_{12 } ) & b_8({\\check{{l}}}^0,{\\check{{s}}}^0 ) { \\mathop{\\leftarrow}\\limits}\\{{\\check{{l}}}^0={\\hat{{l}}}^0\\}\\\\        \\hline      \\end{array}\\ ] ]",
    "let @xmath0 be a java bytecode program and @xmath210 be a block of @xmath0 . by theorem  [ theorem : non - term ]",
    ", the existence of an infinite computation in @xmath1 of a query of the form @xmath279 entails that there is an execution of the java virtual machine starting at @xmath210 that does not terminate . in  @xcite",
    ", we provide a criterion that can be used for proving the existence of a non - terminating query for a _ binary _ @xmath147 program _",
    "i.e. , _ a program consisting of clauses whose body contains at most one atom ( we refer to such clauses as binary clauses ) . note that by definitions  [ def : clp_block_call_not_void][def : clp_block_call_not_void_one_inst ]",
    ", @xmath1 may not be binary as it may contain clauses whose body consists of two atoms .",
    "we use the binary unfolding operation  @xcite to transform @xmath1 into a binary program .",
    "we write @xmath147 clauses as @xmath280 where @xmath46 is a @xmath147 constraint , @xmath281 , @xmath282 ,  , @xmath283 are atoms and @xmath284 is a sequence of atoms .",
    "when @xmath285 or @xmath284 are empty sequences , we write the clause as @xmath286 .",
    "we let @xmath287 denote the set of all the binary clauses of the form @xmath288 where @xmath39 is a predicate symbol and @xmath289 and @xmath290 are disjoint sequences of distinct variables .",
    "we also let @xmath291 $ ] denote the projection of @xmath292 $ ] onto the variables of @xmath281 and @xmath284 .",
    "[ definition : binunf ] let @xmath1 be a @xmath147 program and @xmath293 be a set of binary clauses .",
    "then , @xmath294 where @xmath295 and @xmath296 is the set @xmath297            \\langle h_j \\leftarrow c_j\\rangle_{j=1}^{i-1 }            \\in x            \\mbox { renamed apart from $ r$}\\\\[1ex ]            h_i \\leftarrow c_i , \\mathbf{b } \\in x \\cup \\mathit{id }            \\mbox { renamed apart from $ r$}\\\\[1ex ]            i < m \\rightarrow \\mathbf{b } \\neq \\emptyset\\\\[1ex ]            c   = \\overline{\\exists}_{\\mathit{var}(h,\\mathbf{b } ) } \\big [            c_0 \\land \\mathop{\\land}\\limits_{j=1}^i ( c_j \\land            b_j = h_j)\\big]\\\\[1ex ]            c \\mbox { is satisfiable }          \\end{array}\\right\\ }      \\end{array}\\ ] ]    we define the powers of @xmath298 as usual : @xmath299 it can be shown that the least fixpoint ( @xmath300 ) of this monotonic operator always exists and we set @xmath301    [ example : proving_non_termination ] consider the program @xmath1 in table  [ table : clp ] .",
    "we have @xmath302 .",
    "moreover ,    * the set @xmath303 includes the following clauses : @xmath304        ( u_2 )        & b_7({\\check{{l}}}^0,{\\check{{s}}}^0 )        & \\{\\},\\mathit{sum}({\\check{{s}}}^0,{\\hat{{s}}}^0 )      \\end{array}\\ ] ] where @xmath305 is obtained by unfolding @xmath306 with @xmath287 and @xmath307 by unfolding @xmath308 with @xmath287 , * the set @xmath309 includes the following clauses : @xmath310        ( u_4 )        & \\mathit{main}({\\check{{l}}}^0 )        & \\{-1={\\check{{s}}}^0\\ } ,        \\mathit{sum}({\\check{{s}}}^0,{\\hat{{s}}}^0 )      \\end{array}\\ ] ] where @xmath311 is obtained by unfolding @xmath312 with @xmath305 and @xmath313 by unfolding @xmath314 with @xmath307 , * the set @xmath315 includes the following clause , obtained by unfolding @xmath316 with @xmath311 : @xmath317 * the set @xmath318 includes the following clause , obtained by unfolding @xmath319 with @xmath320 : @xmath321    it is proved in  @xcite that existential non - termination in @xmath1 is _ equivalent _ to existential non - termination in @xmath322 :    [ theorem - observing - termination ] let @xmath1 be a @xmath147 program and @xmath323 be a query consisting of one atom .",
    "then , @xmath323 has an infinite computation in @xmath1 _ if and only if _ @xmath323 has an infinite computation in @xmath322 .",
    "note that @xmath322 is a possibly infinite set of binary clauses . in practice , we compute only the first @xmath324 iterations of @xmath298 , where @xmath324 is a parameter of the analysis , and we have @xmath325 .",
    "therefore , any query that has an infinite computation in @xmath326 also has an infinite computation in @xmath322 , hence , by theorem  [ theorem - observing - termination ] , in @xmath1 .    in the results we present below",
    ", @xmath39 is a predicate symbol , @xmath289 and @xmath290 are disjoint sequences of distinct variables and @xmath46 is a @xmath147 constraint on @xmath289 and @xmath290 only ( _ i.e. , _ the set of variables appearing in @xmath46 is a subset of @xmath327 ) .",
    "the criterion that we provide in  @xcite for proving the existence of a non - terminating query can be formulated as follows in the context of @xmath147 clauses .",
    "[ proposition : unit - loop - tplp ] let @xmath328 be a @xmath147 binary clause where @xmath46 is satisfiable .",
    "let @xmath329 denote the projection of @xmath46 onto @xmath289 .",
    "suppose the formula @xmath330\\ ] ] is true .",
    "then , @xmath331 has an infinite computation in @xmath332 , for some fixed integer values for @xmath333 .",
    "the sense of proposition  [ proposition : unit - loop - tplp ] is the following .",
    "satisfiability for @xmath46 means that there exists some `` input '' to the clause _",
    "i.e. , _ some value from which one can `` enter '' the clause .",
    "the logical formula means : let @xmath334 be some input to the clause ( _ i.e. , _",
    "@xmath335 ) , then any output @xmath336 corresponding to @xmath334 ( _ i.e. , _",
    "@xmath337 ) is also an input to the clause ( _ i.e. , _",
    "@xmath338 ) . shortly ,",
    "if one can enter the clause with @xmath334 , then one can enter the clause again with _ any _ output corresponding to @xmath334 .",
    "this corresponds to a notion of _ unavoidable _ ( _ universal _ ) non - termination , as any input to the clause necessarily leads to an infinite computation .",
    "the criterion provided in proposition  [ proposition : unit - loop - tplp ] can be refined into :    [ proposition : unit - loop ] let @xmath328 be a @xmath147 binary clause where @xmath46 is satisfiable .",
    "let @xmath329 denote the projection of @xmath46 onto @xmath289 .",
    "suppose the formula @xmath339\\ ] ] is true .",
    "then , @xmath331 has an infinite computation in @xmath332 , for some fixed integer values for @xmath333 .",
    "now , the sense of the logical formula is : if one can enter the clause with an input @xmath334 , then",
    "_ there exists _ an output @xmath336 corresponding to @xmath334 such that one can enter the clause again with @xmath336 .",
    "this corresponds to a notion of _ potential _ ( _ existential _ ) non - termination , as for any input to the clause there is a corresponding output that leads to an infinite computation .",
    "the criterion of proposition  [ proposition : unit - loop - tplp ] entails that of proposition  [ proposition : unit - loop ] , but the converse does not hold in general ( _ e.g. , _ for the clause @xmath340 the logical formula of proposition  [ proposition : unit - loop ] is true whereas that of proposition  [ proposition : unit - loop - tplp ] is not ) .    in proposition",
    "[ proposition : unit - loop ] , we consider _ recursive _ binary clauses .",
    "a recursive clause in @xmath322 is a _ compressed _ form of a loop in @xmath1 .",
    "the next result allows one to ensure that a loop is reachable from a given program point .",
    "[ proposition : compound - loops ] let @xmath341      r ' & p'(\\tilde{x } ' ) { \\mathop{\\leftarrow}\\limits}c ' , p(\\tilde{y } ' )    \\end{array}\\ ] ] be some @xmath147 binary clauses where @xmath46 and @xmath342 are satisfiable .",
    "let @xmath329 denote the projection of @xmath46 onto @xmath289 .",
    "suppose the formul    * @xmath343 $ ] * @xmath344    are true .",
    "then , @xmath345 has an infinite computation in @xmath346 , for some fixed integer values for @xmath333 .",
    "the sense of the second logical formula in proposition  [ proposition : compound - loops ] is that there is an output to the clause @xmath347 which is an input to the clause @xmath348 .",
    "moreover , any input to @xmath347 that satisfies the second formula is the starting point of a potential infinite computation ; if the first logical formula in proposition  [ proposition : compound - loops ] was that of proposition  [ proposition : unit - loop - tplp ] , then it would be the starting point of an unavoidable infinite computation .",
    "the clauses @xmath313 and @xmath349 in example  [ example : proving_non_termination ] satisfy the pre - conditions of proposition  [ proposition : compound - loops ] .",
    "hence , by proposition  [ proposition : compound - loops ] , there is a value @xmath55 in @xmath5 which is such that @xmath350 has an infinite computation in @xmath322 , hence an infinite computation in @xmath1 .",
    "consequently , by theorem  [ theorem : non - term ] , there is an execution of the java virtual machine started at block @xmath351 that does not terminate , where @xmath351 is the initial block of the java bytecode program corresponding to the java program in fig .",
    "[ fig : sum_term_java ] .",
    "we implemented our approach in the julia analyser .",
    "non - termination proofs of @xmath147 programs are performed by the binterm tool , a component of julia that implements proposition  [ proposition : compound - loops ] .",
    "binterm is written in swi - prolog  @xcite and relies on the parma polyhedra library  @xcite for checking satisfiability of integer linear constraints .",
    "elimination of existentially quantified variables in @xmath352 follows the approach of the omega test  @xcite .",
    "we evaluated our analyser on a collection of 113 examples , made up of :    * a set of 75 iterative examples , consisting of 54 programs provided by  @xcite and the 21 non - terminating programs submitted by the julia team to the _ international termination competition _",
    "@xcite in 2011 , * a set of 38 recursive examples , consisting of 34 programs that we obtained by turning some examples from  @xcite into recursive programs , and 4 programs that we wrote ourselves ; all of these recursive programs do not terminate due to an infinite recursion .    in our experiments ,",
    "we compared aprove , invel and the new version of julia .",
    "we used the default settings for each tool _ i.e. , _ a time - out of 60 seconds for aprove , a maximum number of iterations set to 10 for invel and , for julia , a time - out of 20 seconds for each strongly connected component of the @xmath147 program .",
    "details on the experiments are available at  @xcite .",
    "we do not provide running times as we could not run all the tools on a same machine ( the aprove implementation that performs non - termination proofs is available through a web interface only ) .",
    "table  [ table : results - imp ] and table  [ table : results - rec ] give an overview of the results that we obtained . here",
    ", `` invel '' is the set of 54 examples from  @xcite , `` julia tc11 '' is the set of 21 non - terminating examples submitted by julia to the competition in 2011 , `` invel rec . ''",
    "is the set obtained by turning 34 invel examples into recursive programs and `` julia rec . ''",
    "corresponds to the 4 programs that we wrote .",
    "moreover , * y * and * n * indicate how often termination ( resp .",
    "non - termination ) could be proved , * f * indicates how often a tool failed within the time limit set by its default settings and * t * states how many examples led to time - out .",
    "finally , * p * ( * * p**roblems ) gives the number of times a tool stopped with a run - time exception or produced an incorrect answer : the invel analyser issued 2 incorrect answers ( 2 terminating programs incorrectly proved non - terminating ) and stopped twice with a ` nullpointerexception ` .",
    "table  [ table : results - imp ] shows that julia failed on 22 invel examples ; 13 of these failures are due to the use , in the corresponding programs , of bytecode instructions that are not exactly abstracted into constraints .",
    "table  [ table : results - rec ] clearly shows that only julia could detect non - terminating recursions .",
    ".the results of our experiments on iterative programs . [ cols=\"<,^,^,^,^,^,^,^,^,^ \" , ]      for our experiments , there are three cases .",
    "let us consider the invel examples .",
    "* for ` alternatingincr.jar ` , we get one warning : + .... [ termination ] are you sure that   simple.alternatingincr.increase always terminates ? .... + it means that julia has a proof that the upper approximation of the program built to prove termination loops in @xmath353 , indicating a potential non - termination of the original program . * for ` alterndiv.jar ` , we get two warnings : + .... [ termination ] are you sure that   simple.alterndiv.alterndiv.loop always terminates ?    [ termination ] simple.alterndiv.main.main may   actually diverge .... + the first warning has the same interpretation as above while the second one emphasizes that julia has a non - termination proof for the original program . * for ` whilebreak.jar ` , there are no warnings .",
    "it means that julia has a termination proof for the original program .",
    "the work we have presented in this paper was initiated in  @xcite , where we observed that in some situations the non - termination of a java bytecode program can be deduced from that of its @xmath147 translation . here",
    ", we have introduced the formal material that is missing in  @xcite and we have presented a new experimental evaluation , conducted with the julia tool which now includes an implementation of our results .",
    "currently , our non - termination analysis can not be applied to programs that include certain types of object field access .",
    "we are actively working at extending its scope , so that it can identify sources of non - termination such as traversal of cyclical data structures .",
    "10    e.  albert , p.  arenas , s.  genaim , g.  puebla , and d.  zanardini .",
    "cost analysis of object - oriented bytecode programs .",
    ", 413(1):142159 , 2012 .",
    "jbc - nonterm/ ` .",
    "r.  bagnara , p.  m. hill , and e.  zaffanella .",
    "the parma polyhedra library : toward a complete set of numerical abstractions for the analysis and verification of hardware and software systems .",
    ", 72(12):321 , 2008 .",
    "b.  beckert , r.  hhnle , and p.  h. schmitt , editors . ,",
    "volume 4334 of _ lecture notes in computer science_. springer , 2007 .",
    "a.  m. ben - amram .",
    "monotonicity constraints for termination in the integer domain . , 7(3 ) , 2011 .",
    "r.  n. bol , k.  r. apt , and j.  w. klop .",
    "an analysis of loop checking mechanisms for logic programs .",
    ", 86:3579 , 1991 .",
    "a.  r. bradley , z.  manna , and h.  b. sipma .",
    "polyranking for polynomial loops ( extended version ) , 2005 .",
    "available at ` http://theory.stanford.edu/~arbrad/papers/tcs_term.pdf ` .",
    "m.  brockschmidt , t.  strder , c.  otto , and j.  giesl .",
    "automated detection of non - termination and nullpointerexceptions for java bytecode . in _ proc . of the 2nd international conference on formal verification of object - oriented software ( foveoos 11 )",
    "_ , lecture notes in computer science .",
    "springer , 2011 . to appear .",
    "m.  codish and c.  taboch . a semantic basis for the termination analysis of logic programs .",
    ", 41(1):103123 , 1999 .",
    "p.  cousot and r.  cousot .",
    "abstract interpretation : a unifed lattice model for static analysis of programs by construction or approximation of fixpoints . in _ proc . of the 4th symposium on principles of programming languages ( popl77 )",
    "_ , pages 238252 .",
    "acm press , 1977 .",
    "d.  de  schreye , k.  verschaetse , and m.  bruynooghe .",
    "a practical technique for detecting non - terminating queries for a restricted class of horn clauses , using directed , weighted graphs . in _ proc . of the 7th international conference on logic programming ( iclp90 ) _ , pages 649663 . the mit press , 1990 .",
    "m.  gabbrielli and r.  giacobazzi .",
    "goal independency and call patterns in the analysis of logic programs . in _ proc . of the acm symposium on applied computing ( sac94 )",
    "_ , pages 394399 .",
    "acm press , 1994 .",
    "j.  giesl , p.  schneider - kamp , and r.  thiemann . : automatic termination proofs in the dependency pair framework . in u.",
    "furbach and n.  shankar , editors , _ proc . of the 3rd international joint conference on automated reasoning ( ijcar06 )",
    "_ , volume 4130 of _ lecture notes in artificial intelligence _ ,",
    "pages 281286 .",
    "springer , 2006 .",
    "j.  giesl , r.  thiemann , and p.  schneider - kamp . proving and disproving termination of higher - order functions . in b.",
    "gramlich , editor , _ proc . of the 5th international workshop on frontiers of combining systems ( frocos05 ) _ , volume 3717 of _ lecture notes in artificial intelligence _",
    ", pages 216231 .",
    "springer , 2005 .",
    "a.  gupta , t.  a. henzinger , r.  majumdar , a.  rybalchenko , and r .-",
    "xu . proving non - termination . in g.  c. necula and p.  wadler , editors , _ proc .",
    "of the 35th acm sigplan - sigact symposium on principles of programming languages ( popl08 ) _ , pages 147158 .",
    "acm press , 2008 .",
    "` http://www.key-project.org/nontermination/ ` .",
    "invel  the automatic non - termination detection tool .    ` http://julia.scienze.univr.it/nontermination ` .",
    "julia special configuration for ( non-)termination experiments .",
    "c.  otto , m.  brockschmidt , c.  von essen , and j.  giesl .",
    "automated termination analysis of java bytecode by term rewriting . in c.  lynch ,",
    "editor , _ proc . of the 21st international conference on rewriting techniques and applications ( rta10 )",
    "_ , volume  6 of _ leibniz international proceedings in informatics _ , pages 259276 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik , 2010 .",
    "e.  payet .",
    "loop detection in term rewriting using the eliminating unfoldings .",
    ", 403:307327 , 2008 .",
    "e.  payet and f.  mesnard .",
    "a non - termination criterion for binary constraint logic programs .",
    ", 9(2):145164 , 2009 .",
    "long version available at the web address ` http://arxiv.org/abs/0807.3451 ` .    e.  payet and f.  mesnard .",
    "non - termination inference of logic programs . , 28 ,",
    "issue  2:256289 , march 2006 .",
    "e.  payet and f.  spoto .",
    "experiments with non - termination analysis for java bytecode . in e.",
    "albert and s.  genaim , editors , _ proc . of the 4th international workshop on bytecode semantics , verification , analysis and transformation ( bytecode09 ) _ ,",
    "volume 253 , issue  5 of _ electronic notes in theoretical computer science _ , pages 8396 , 2009 .    ` http://personnel.univ-reunion.fr/epayet/ research / resources / ppdp12long.pdf ` .    `",
    "http://personnel.univ-reunion.fr/epayet/ research / ppdp12/html / experiments.html ` .",
    "w.  pugh .",
    "a practical algorithm for exact array dependence analysis .",
    ", 35(8):102114 , 1992 .",
    "shen , j .- h . you , l .- y .",
    "yuan , s.  shen , and q.  yang . a dynamic approach to characterizing termination of general logic programs .",
    ", 4(4):417434 , 2003 .",
    "shen , l .- y .",
    "yuan , and j .- h . you .",
    "loops checks for logic programs with functions . , 266(1 - 2):441461 , 2001 .",
    "f.  spoto , f.  mesnard , and e.  payet . a termination analyzer for java bytecode based on path - length .",
    ", 32 , issue  3:70  pages , march 2010 .    `",
    "http://termcomp.uibk.ac.at/termcomp/home.seam ` .",
    "the termination competition website .",
    "h.  velroyen and p.  rmmer .",
    "non - termination checking for imperative programs . in b.",
    "beckert and r.  hhnle , editors , _ proc .  of the 2nd international conference on tests and proofs ( tap08 )",
    "_ , volume 4966 of _ lecture notes in computer science _ , pages 154170 .",
    "springer , 2008 .",
    "j.  waldmann .",
    "matchbox : a tool for match - bounded string rewriting . in v.",
    "van oostrom , editor , _ proc . of the 15th international conference on rewriting techniques and applications ( rta04 )",
    "_ , volume 3091 of _ lecture notes in computer science _ , pages 8594 .",
    "springer - verlag , 2004 .",
    "j.  waldmann .",
    "compressed loops ( draft ) , 2007 .",
    "available at ` http://dfa.imn.htwk-leipzig.de/matchbox/methods/ ` .",
    "j.  wielemaker , t.  schrijvers , m.  triska , and t.  lager . . ,",
    "12(1 - 2):6796 , 2012 .",
    "h.  zankl and a.  middeldorp .",
    "nontermination of string rewriting using sat . in _ proc . of the 9th international workshop on termination ( wst07 ) _ , pages 5255 , 2007 .",
    "h.  zantema .",
    "termination of string rewriting proved automatically .",
    ", 34(2):105139 , 2005 .",
    "let @xmath168 , @xmath170 , @xmath121 and @xmath122 .",
    "suppose that @xmath169 , that @xmath171 and that @xmath149 is compatible with @xmath162 . for sake of readability , we let @xmath354 denote the constraint @xmath355 . we have @xmath356 and @xmath357 .",
    "we have to prove that @xmath358 .",
    "so , consider any model @xmath138 of @xmath354 and any state @xmath30 compatible with @xmath359 .",
    "suppose that @xmath360 .",
    "we have to prove that @xmath361 is defined and @xmath362 .",
    "let @xmath363 by definition  [ def : abstract_transformers ] , @xmath364 \\cup { \\mathit{\\mathit{pl}}}_2[{\\check{{v}}}\\mapsto\\overline{v}\\;|\\;\\overline{v}\\in t ] \\big)\\;.\\ ] ] as @xmath138 is a model of @xmath354 , there exists an assignment @xmath365 that coincides with @xmath138 on every variable not in @xmath366 and which is such that @xmath367    \\quad\\text{and}\\quad    \\rho'\\models{\\mathit{\\mathit{pl}}}_2[{\\check{{v}}}\\mapsto\\overline{v}\\;|\\;\\overline{v}\\in t ]    \\;.\\ ] ] consider the following facts and definitions .",
    "* the state @xmath30 is compatible with @xmath359 , hence it is compatible with @xmath149 .",
    "* we define the assignment @xmath368 as : @xmath369\\\\[1ex ]      & \\cup & [ { \\check{{s}}}^k\\mapsto \\rho'({\\check{{s}}}^k )      \\;|\\ ; 0\\le k < s_i]\\\\[1ex ]      & \\cup & [ { \\hat{{v}}}\\mapsto\\rho'(\\overline{v})\\;|\\ ;      \\overline{v}\\in t]\\;.    \\end{array}\\ ] ] by  ( [ equation - composition-1 ] ) , @xmath370 , hence @xmath368 is a model of @xmath128 .",
    "moreover , @xmath30 is compatible with @xmath149 and @xmath360 with @xmath371 . as @xmath169 ,",
    "then @xmath86 is defined and @xmath372 .",
    "* we define the assignment @xmath373 as : @xmath374\\\\[1ex ]      & \\cup & [ { \\hat{{l}}}^k\\mapsto \\rho'({\\hat{{l}}}^k )      \\;|\\ ; 0\\le k < l_o]\\\\[1ex ]      & \\cup & [ { \\hat{{s}}}^k\\mapsto \\rho'({\\hat{{s}}}^k )      \\;|\\ ; 0\\le k < s_o]\\;.    \\end{array}\\ ] ] by  ( [ equation - composition-1 ] ) , @xmath375 , hence @xmath373 is a model of @xmath129 .",
    "moreover , @xmath86 is compatible with @xmath162 ( because @xmath149 is compatible with @xmath162 ) and @xmath372 . by definition of @xmath368 and @xmath373 , for each variable @xmath131 in @xmath366 we have @xmath376 .",
    "hence , @xmath372 implies that @xmath377 . as @xmath171 ,",
    "then @xmath87 is defined and we have @xmath378 with @xmath379 .",
    "let @xmath88 be an instruction in @xmath386 .",
    "we have to prove that @xmath174 .",
    "hence , consider any model @xmath138 of @xmath105 and any state @xmath30 compatible with @xmath90 , and suppose that @xmath165 .",
    "we have to prove that @xmath387 is defined and that @xmath388 .    *",
    "suppose that @xmath389 .",
    "then , @xmath390 note that @xmath387 is defined because @xmath90 is defined for any state that is compatible with it . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath7 .",
    "* * let @xmath391 and @xmath392 . by definition of @xmath90",
    ", we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; moreover , as @xmath138 is a model of @xmath397 , with @xmath398 , we have @xmath399 and @xmath400 .",
    "therefore , @xmath401 and @xmath402 * * suppose that @xmath403 . by definition of @xmath90",
    ", we have @xmath404 . as @xmath138 is a model of @xmath397 , with @xmath405",
    ", we have @xmath406 .",
    "hence , @xmath407 * * suppose that @xmath408 . by definition of @xmath90 , @xmath409 .",
    "as @xmath138 is a model of @xmath397 , with @xmath410 , we have @xmath411 .",
    "hence , @xmath407 + consequently , we have @xmath412 .",
    "* suppose that @xmath413 .",
    "then , @xmath414 note that @xmath415 and that @xmath387 is defined because @xmath90 is defined for any state that is compatible with it . without loss of generality , suppose that @xmath30 has the form @xmath177 . * * let @xmath391 and @xmath392 . by definition of @xmath90",
    ", we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; moreover , as @xmath138 is a model of @xmath397 , with @xmath398 , we have @xmath399 and @xmath400 .",
    "therefore , @xmath401 and @xmath402 * * by definition of @xmath90 , we have @xmath416 with @xmath417 . as @xmath165 , we have @xmath418 . as @xmath138 is a model of @xmath397 , with @xmath419",
    ", we have @xmath420 .",
    "hence , @xmath407 + consequently , we have @xmath412 .",
    "* suppose that @xmath421 .",
    "then , @xmath422\\rangle\\\\      & \\text{where $ \\ell$ is a fresh location}\\\\      & \\text{and $ o$ is an object of class $ \\kappa$}\\\\      & \\text{whose fields hold $ 0 $ or $ \\mathtt{null}$. }    \\end{aligned}\\ ] ] note that @xmath387 is defined because we assume that @xmath90 is a total map defined for any state that is compatible with it . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath7 .",
    "* * let @xmath391 and @xmath392 . by definition of @xmath90 , we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; moreover , as @xmath138 is a model of @xmath397 , with @xmath398 , we have @xmath399 and @xmath400 . therefore , @xmath401 and @xmath402 * * by definition of @xmath90 , we have @xmath423 . as @xmath138 is a model of @xmath397 , with @xmath424",
    ", we have @xmath425 .",
    "hence , @xmath407 + consequently , we have @xmath412 . *",
    "suppose that @xmath426 .",
    "then , @xmath427 note that @xmath387 is defined because @xmath90 is defined for any state that is compatible with it . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath7 .",
    "* * let @xmath391 and @xmath392 . by definition of @xmath90",
    ", we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; moreover , as @xmath138 is a model of @xmath397 , with @xmath398 , we have @xmath399 and @xmath400 .",
    "therefore , @xmath401 and @xmath402 * * by definition of @xmath90 , we have @xmath428 . as @xmath165",
    ", we have @xmath429 . as @xmath138 is a model of @xmath397 , with @xmath430",
    ", we have @xmath431 .",
    "hence , @xmath407 + consequently , we have @xmath412 .",
    "* suppose that @xmath432",
    ". then , @xmath433\\operatorname{\\mid\\!\\mid}s\\operatorname{\\mid\\!\\mid}\\mu\\rangle \\ ; .",
    "\\end{aligned}\\ ] ] note that @xmath415 , that @xmath434 and that @xmath387 is defined because @xmath90 is defined for any state that is compatible with it . without loss of generality , suppose that @xmath30 has the form @xmath177 . * * let @xmath435 and @xmath436 . by definition of @xmath90 , we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; as @xmath138 is a model of @xmath397 , with @xmath437 , we have @xmath399 and @xmath400 . therefore , @xmath401 and @xmath402 * * by definition of @xmath90 , @xmath438 with @xmath417 .",
    "as @xmath165 , we have @xmath418 . as @xmath138 is a model of @xmath397 , with @xmath439 , we have @xmath440 .",
    "hence , @xmath441 + consequently , we have @xmath412 .",
    "* suppose that @xmath442 .",
    "then , @xmath443 note that @xmath444 . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath445 .",
    "as @xmath30 is compatible with @xmath90 , @xmath446 and @xmath447 are integer values .",
    "moreover , @xmath387 is defined because @xmath90 is defined for any state that is compatible with it . * * let @xmath391 and @xmath448 . by definition of @xmath90 , we have @xmath393 and @xmath394 ; as @xmath165 , we have @xmath395 and we have @xmath396 ; as @xmath138 is a model of @xmath397 , with @xmath449 , we have @xmath399 and @xmath400 .",
    "therefore , @xmath401 and @xmath402 * * by definition of @xmath90 , we have @xmath450 with @xmath451 as @xmath165 , we have @xmath418 and @xmath452 . as @xmath138 is a model of @xmath397 , with @xmath453",
    ", we have @xmath454 .",
    "hence , @xmath455 + consequently , we have @xmath412 .",
    "* suppose that @xmath456 where @xmath54 has integer type .",
    "then , @xmath457\\rangle\\\\        \\hspace{1.5cm}\\text{if $ \\ell\\neq\\mathtt{null}$}\\\\        \\mathit{undefined}\\quad\\text{otherwise . }",
    "\\end{cases }    \\end{aligned}\\ ] ] note that @xmath444 . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath458 .",
    "as @xmath138 is a model of @xmath397 , with @xmath459 , we have @xmath460 . as @xmath165",
    ", then we have @xmath461 , with @xmath462 . hence , @xmath463 .",
    "as @xmath30 is compatible with @xmath90 , @xmath56 does not have integer type .",
    "so , @xmath463 implies that @xmath464 .",
    "consequently , @xmath387 is defined .",
    "+ we let @xmath465 denote the memory @xmath466 $ ] .",
    "note that @xmath467 .",
    "+ for any @xmath468 , we have @xmath469 for any @xmath470 , we have @xmath471 + by definition  24 in  @xcite , for any @xmath468 we have @xmath472 and @xmath473 . hence , @xmath474 .",
    "+ let @xmath470 .",
    "note that @xmath465 coincides with @xmath11 , except , possibly , on the value of field @xmath54 of objects @xmath475 and @xmath476 .",
    "field @xmath54 has integer type ; by definition  24 in  @xcite , the path - length of a location does not depend on the value of the fields with integer type of the objects in memory .",
    "hence , @xmath477 .",
    "+ let @xmath391 and @xmath448 . by definition of @xmath90 and by the claim above , @xmath478 and @xmath479 as @xmath165 , we have @xmath480 moreover , as @xmath138 is a model of @xmath397 , with @xmath481 we have @xmath399 and @xmath400 .",
    "therefore , @xmath482 and @xmath483 + consequently , we have @xmath412 .",
    "* suppose that @xmath484 .",
    "then , @xmath485 note that @xmath415 . without loss of generality ,",
    "suppose that @xmath30 has the form @xmath177 . as @xmath138 is a model of @xmath397 , with @xmath486 , we have @xmath487 . as @xmath165",
    ", then we have @xmath488 , with @xmath489 .",
    "hence , @xmath490 . * * suppose that @xmath491 . as @xmath30 is compatible with @xmath90 , @xmath97 has type @xmath61 , hence @xmath490 implies that @xmath492 .",
    "consequently , @xmath387 is defined .",
    "* * suppose that @xmath493 .",
    "as @xmath30 is compatible with @xmath90 , @xmath97 has type @xmath493 , hence @xmath490 implies that @xmath494 .",
    "consequently , @xmath387 is defined .",
    "+ let @xmath391 and @xmath436 . by definition of @xmath90 , we have @xmath495 and @xmath496 ; as @xmath165 , we have @xmath497 and @xmath498 ; moreover , as @xmath138 is a model of @xmath397 , with @xmath499 we have @xmath399 and @xmath400 .",
    "therefore , @xmath482 and @xmath483 + consequently , we have @xmath412 .      an important step of our analysis consists in deducing the non - termination of @xmath0 from that of @xmath1 .",
    "the idea consists in constructing an infinite execution of @xmath0 from an infinite derivation with @xmath1 .",
    "each step of the infinite derivation consists of an atom @xmath211 , where @xmath212 are integer values , and we must be able to transform this atom into a state whose path - length matches @xmath212 .    [",
    "proposition : instructions_exists_sigma ] for any @xmath173 , any program point @xmath89 where @xmath88 occurs and any model @xmath138 of @xmath98 , there exists a state @xmath30 which is compatible with @xmath90 and such that @xmath165 .    as",
    "a memory @xmath11 is a mapping from locations to objects , we let @xmath500 denote the domain of @xmath11 .",
    "an update of @xmath11 is written as @xmath501 $ ] , where the domain of @xmath11 may be enlarged ( if @xmath502 ) .    without loss of generality , we assume that every class @xmath38 in the program under analysis satisfies the following property : for any integer @xmath503 , any memory @xmath11 and any location @xmath502 , there exists an object @xmath57 instance of @xmath38 such that @xmath504 ) = n$ ] .",
    "if the program includes a class @xmath505 that does not satisfy this property , just add to @xmath38 a dummy field of type @xmath38 .",
    "the termination of the transformed program is equivalent to that of the original one .",
    "let @xmath88 be an instruction in @xmath208 .",
    "let @xmath89 be a program point where @xmath88 occurs and @xmath381 be the number of local variables and stack elements at @xmath89 .",
    "let @xmath138 be a model of @xmath105 .",
    "given the above assumption , we can construct a state @xmath7 in @xmath20 which is such that : for any @xmath13 in @xmath506 ( resp . in @xmath507 ) ,    * if the @xmath13th local variable ( resp .",
    "stack element ) has integer type at @xmath89 , then @xmath12 is @xmath508 ( resp .",
    "@xmath14 is @xmath509 ) ; * if the @xmath13th local variable ( resp .",
    "stack element ) has class type at @xmath89 and @xmath510 ( resp .",
    "@xmath511 ) , then @xmath12 is @xmath58 ( resp .",
    "@xmath14 is @xmath58 ) ; * if the @xmath13th local variable ( resp .",
    "stack element ) has class type at @xmath89 and @xmath512 ( resp .",
    "@xmath513 ) , then @xmath12 ( resp .",
    "@xmath14 ) is a location @xmath56 which is such that @xmath514 ( resp .",
    "@xmath515 ) .        let @xmath209 be a java virtual machine , @xmath0 be a java bytecode program consisting of instructions in @xmath386 , and @xmath210 be a block of @xmath0 . by theorem  56 of @xcite , if @xmath211 has only terminating computations in @xmath1 , for any fixed integer values for @xmath212 , then all executions of @xmath209 started at @xmath210 terminate .",
    "let us prove that if all executions of @xmath209 started at @xmath210 terminate , then @xmath211 has only terminating computations in @xmath1 , for any fixed integer values for @xmath212 .",
    "this is equivalent to proving that if there exists some fixed integer values for @xmath212 such that @xmath211 has an infinite computation in @xmath1 , then there exists an execution of @xmath209 started at @xmath210 that does not terminate .",
    "hence , suppose that for some fixed integer values for @xmath212 there exists an infinite computation of @xmath211 in @xmath1 .",
    "note that for any block @xmath250 of @xmath0 , the unification of the clp atom @xmath516 with the atom @xmath517 corresponds to the @xmath119 operation ( renaming of the variables into new overlined variables and existential quantification )",
    ". then , by definition of our specialised semantics , there exists an infinite sequence of integer values @xmath518 where @xmath519 are clauses from @xmath1 . for each @xmath520 , @xmath521 are integer values for @xmath522 and the assignment @xmath523\\ ] ] is a model of @xmath524 .    by definition of @xmath1 ( definition  53 of  @xcite ) , we have @xmath525 where @xmath216 ,  , @xmath526 are the instructions occurring in block @xmath210 and , for each @xmath527 , @xmath528 where @xmath529 ,  , @xmath530 are the instructions occurring in block @xmath531 .",
    "we let @xmath532 and @xmath533 as @xmath0 is a valid java bytecode program , any @xmath534 is compatible with its direct successor @xmath535 . hence , by proposition  [ proposition : composition ] and proposition  [ proposition : instructions_exactness ] , for each @xmath520 we have @xmath536 .",
    "as @xmath537 is a model of @xmath538 and @xmath539 , there exists a model @xmath138 of @xmath540 which is such that @xmath541 . by proposition  [ proposition : instructions_exists_sigma ]",
    "there exists a state @xmath30 compatible with @xmath542 which is such that @xmath543 .",
    "note that for each @xmath520 , the state @xmath30 is compatible with @xmath544 because @xmath30 is compatible with @xmath542 and @xmath542 is the denotation that is applied first in @xmath544 .",
    "moreover , for each @xmath520 we have @xmath545 _ i.e. , _ @xmath546 .",
    "let @xmath520 . as @xmath547 ,  ,",
    "@xmath536 , by proposition  [ proposition : composition ] we have @xmath548 .",
    "moreover , @xmath549 is a model of @xmath550 , the state @xmath30 is compatible with @xmath544 and @xmath551 .",
    "hence , by definition  [ definition : models ] , @xmath552 is defined .",
    "consequently , we have proved that @xmath552 is defined for any @xmath50 in @xmath553 . by the equivalence of the denotational and operational semantics ( theorem  23 of  @xcite )",
    ", there exists an infinite operational execution of @xmath209 from block @xmath210 starting at state @xmath30 .",
    "let @xmath209 be a java virtual machine , @xmath0 be a java bytecode program consisting of instructions in @xmath44 , and @xmath210 be a block of @xmath0 .",
    "let @xmath212 be some fixed integer values and @xmath223 be a free variable .",
    "suppose that the query @xmath259 has an infinite computation in @xmath1 .",
    "first , suppose that @xmath0 does not contain any @xmath75 instruction .",
    "then , @xmath1 is constructed using definition  [ def : clp_block_no_call_not_void ] only .",
    "let @xmath554 be the @xmath147 program constructed as in  @xcite .",
    "the existence of an infinite computation of @xmath555 in @xmath1 entails the existence of an infinite computation of @xmath211 in @xmath554 which , by theorem  [ theorem : clp_completeness ] , entails the existence of a non - terminating execution of @xmath209 started at block @xmath210 .    now , suppose that @xmath0 contains a @xmath75 instruction to a method @xmath37 .",
    "then , the result follows from propositions  [ proposition : composition ] , [ proposition : instructions_exactness ] and [ proposition : instructions_exists_sigma ] and the fact that , in definitions  [ def : clp_block_call_not_void][def : clp_block_call_not_void_one_inst ] , the operational semantics of the call is modeled in @xmath1 by :    * the constraint @xmath556 , which specifies that the path - length of the local variables and stack elements under the actual parameters is not modified by the call , * the constraint @xmath239 , which specifies that the receiver of the call is not @xmath58 , * the atom @xmath240 , where @xmath241 denotes the entry block of @xmath37 and @xmath557 are the actual parameters of @xmath37 and @xmath198 is the result of @xmath37 , * if the block @xmath558 where the call occurs consists of more than one instruction , clauses of the form @xmath559 where the call to @xmath560 in the first clause models the continuation of the execution after the call to @xmath37 , * if the block @xmath558 where the call occurs consists of exactly one instruction , clauses of the form @xmath561 where the calls to @xmath219 , ",
    ", @xmath220 model the continuation of the execution after the call to @xmath37 ."
  ],
  "abstract_text": [
    "<S> we introduce a fully automated static analysis that takes a sequential java bytecode program @xmath0 as input and attempts to prove that there exists an infinite execution of @xmath0 . </S>",
    "<S> the technique consists in compiling @xmath0 into a constraint logic program @xmath1 and in proving non - termination of @xmath1 ; when @xmath0 consists of instructions that are _ exactly _ compiled into constraints , the non - termination of @xmath1 entails that of @xmath0 . our approach can handle method calls ; to the best of our knowledge , it is the first static approach for java bytecode able to prove the existence of infinite recursions . </S>",
    "<S> we have implemented our technique inside the julia analyser . </S>",
    "<S> we have compared the results of julia on a set of 113 programs with those provided by aprove and invel , the only freely usable non - termination analysers comparable to ours that we are aware of . </S>",
    "<S> only julia could detect non - termination due to infinite recursion .    </S>",
    "<S> [ mechanical verification ] [ denotational semantics program analysis ] </S>"
  ]
}