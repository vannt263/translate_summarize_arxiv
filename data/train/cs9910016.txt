{
  "article_text": [
    "over the last few years , there has been increasing interest in the area of software agents .",
    "such agents provide a wide variety of services including identification of interesting newspaper articles , software robots that perform tasks ( and plan ) on a user s behalf , content based routers , agent based telecommunication applications , and solutions to logistics applications .",
    "@xmath0 ( see |http://www.cs.umd.edu / projects / impact/| ) is a multinational project whose aim is to define a formal theory of software agents , implement ( appropriate fragments of ) the theory efficiently , and develop an appropriate suite of applications on top of this implementation . an _",
    "impact_agent manages a set of data types / structures ( including a message box ) through a set of application program interface ( api ) function calls .",
    "the state of the agent at a given point in time is a set of objects belonging to these data types .",
    "each agent has a set of integrity constraints that its state must always satisfy .",
    "when an agent s state changes ( due to external events such as receipt of a message ) , the agent tries to modify its state so that the integrity constraints are satisfied .",
    "to do this , it has a suite of actions , and an _ agent program _ that specifies the operating principles ( what is permitted , what is forbidden , what is obligatory , etc . , and under what conditions ? ) .",
    "@xcite provides a detailed study of the semantics and complexity of such agents , @xcite contains compile - time and run - time algorithms , while @xcite focuses on system architecture .",
    "past work on _",
    "impact_assumes that all agents reason with a complete and certain view of the world .",
    "however , in many real world applications , agents have only a partial , uncertain view of what is true in the world . though an agent may need to reason about uncertainty for many reasons , in this paper , we will assume that the main cause of uncertainty in an agent is due to its state being uncertain .",
    "for example , when an image processing agent is asked to identify an enemy vehicle , it might return the fact that vehicle @xmath1 is a t72 tank ( with 6070% probability ) and a t-80 tank ( with 20 - 45% probability )",
    ". however , this raises several problems , the first of which is that as an action can only be executed if its precondition is true in the current state , if the agent does nt know what the state is , then it can not determine which of its actions are executable , and which are not .",
    "second , even if an action is executable , the state that results may not be precisely determinable either .",
    "one consequence of all this is that the semantics of agent programs change significantly when such uncertainties arise .    the main contributions ( and organization ) of this paper",
    "may now be summed up as follows .    1 .   in section  [ c7-sec - prelim ]",
    ", we present a brief overview of agents ( without any uncertainty involved ) as described in @xcite .",
    ", in section  [ c9-pcc : sec ] , we define the concept of a probabilistic code call , which is the basic syntactic construct through which uncertainty in abstract data types manifests itself .",
    "3 .   in section  [ c9-syn : sec ] , we define the syntax of probabilistic agent programs .",
    "specifically , we show that probabilistic agent programs allow an agent developer to specify the permissions , obligations , forbidden actions , etc .",
    "associated with an agent depending not only on the probabilities that certain conditions hold in the agent s state , but also on the developer s assumptions about the relationship between these conditions ( e.g. the probability that a conjunction holds in a given state depends not only on the probabilities of the conjuncts involved , but also on the dependencies if any between the conjuncts ) .",
    "4 .   in section  [ c9-papsem : sec ] , we develop three formal semantics for probabilistic agent programs which extend each other as well as the semantics for ( ordinary , non probabilistic ) agent programs defined by .",
    "we also provide results relating these diverse semantics .",
    ", in section  [ c9-sec : computing ] , we develop a sound and complete algorithm to compute the semantics defined when only positive agent programs are considered .",
    "we also show that the classical agent programs of are a special case of our probabilistic programs .",
    "6 .   in section  [ c9-papstrsem : sec ]",
    ", we provide an alternative , kripke style semantics for agent programs .",
    "in contrast to the previous `` family '' of semantics which assume that an agent s precondition must be true with 100% probability for the agent to execute it , this semantics also allows an agent to execute it when it is not sure ( with 100% probability ) that the action s precondition is true .",
    "we extend all three semantics of agent programs defined earlier in section  [ c9-papsem : sec ] to handle these intuitions . unfortunately ,",
    "as we show in this section , this desire for a `` more sophisticated '' sematics comes at a high computational price .",
    "in _ impact _ , each agent @xmath2 is built on top of a body of software code ( built in any programming language ) that supports a well defined application programmer interface ( either part of the code itself , or developed to augment the code ) .",
    "hence , associated with each agent @xmath2 is a body of software code @xmath3 defined as follows .",
    "we may characterize the code on top of which an agent is built as a triple @xmath4 where :    1 .",
    "@xmath5 is the set of all data types managed by @xmath6 , 2 .",
    "@xmath7 is a set of predefined functions which makes access to the data objects managed by the agent available to external processes , and 3 .",
    "@xmath8 is a set of type composition operations .",
    "a type composition operator is a partial @xmath9-ary function @xmath10 which takes types @xmath11 as input , and yields a type @xmath12 as output .",
    "as @xmath10 is a partial function , @xmath10 may only be defined for certain arguments @xmath11 , i.e. , @xmath10 is not necessarily applicable on arbitrary types .",
    "when @xmath2 is clear from context , we will often drop the superscript @xmath2 .",
    "intuitively , @xmath5 is the set of all data types managed by @xmath2 , @xmath7 is the set of all function calls supported by @xmath6 s application programmer interface ( _ api _ ) .",
    "@xmath8 is the set of ways of creating new data types from existing data types .",
    "this characterization of a piece of software code is widely used ( cf . the _ object data management group _ s _",
    "odmg_standard  @xcite and the _ corba_framework  @xcite ) .",
    "each agent also has a message box having a well defined set of associated code calls that can be invoked by external programs .",
    "consider a surveillance application where there are hundreds of ( identical ) surveillance agents , and a geographic agent .",
    "the data types associated with the surveillance and geographic agent include the standard ` int , bool , real , string , file ` data types , plus those shown below :    cc * surveillance agent * & * geographic agent * +    [ cols= \" < \" , ]     i.e. , the states 1 and 2 merge together yielding the new state `` a '' and their probabilities are summed .",
    "similarly , states 4 and 5 yield the new state `` c '' .",
    "the following result states that our definitions are coherent .",
    "the result of @xmath13-execution of an action in a probabilistic kripke structure is also a probabilistic kripke structure .",
    "let @xmath14 be the original kripke structure , and @xmath15 the result of executing the action .",
    "we just need to show that @xmath16 . using definition  :",
    "probabilistic feasible status sets prevent an action from being executed unless its precondition is known for sure to be true ( which is exactly the intuitive reading of @xmath18}}\\xspace } pre(\\alpha)$ ] , for a probabilistic agent state @xmath19 and an action @xmath20 ) .",
    "analogously , an action constraint has to be checked only if its precondition is certainly true .",
    "finally , state consistency requires that the execution of the actions does not corrupt the consistency of the original agent state , i.e. it has to lead to an agent state where the integrity constraints are with 100% probability ,    in this section , we define the concept of @xmath21-feasibility , where @xmath21 is a probability .",
    "@xmath21-feasibility weakens the above requirements to only requiring that preconditions are true with probability @xmath21 ( or higher ) .",
    "suppose @xmath22 is a probabilistic agent program , @xmath19 is a probabilistic agent state , and @xmath23 is a probabilistic status set",
    ". then @xmath24    1 .",
    "@xmath25 and @xmath26 ; 2 .   for every annotated code call condition @xmath27}}\\xspace},{\\ensuremath{\\otimes}\\index{\\ensuremath{\\otimes}}\\index{disj@\\ensuremath{\\otimes}}\\xspace}\\rangle}\\xspace}$ ] in the body of @xmath28 ,",
    "it is the case that @xmath29}}\\xspace }    { \\ensuremath{\\chi:\\langle { \\ensuremath{\\protect\\mathrm{[}{\\ensuremath{\\mathsf{ai}}\\index{\\ensuremath{\\protect\\mathsf{ai}}}\\index{ai@\\ensuremath{\\protect\\mathsf{ai}}}\\xspace}_1,{\\ensuremath{\\mathsf{ai}}\\index{\\ensuremath{\\protect\\mathsf{ai}}}\\index{ai@\\ensuremath{\\protect\\mathsf{ai}}}\\xspace}_2\\protect\\mathrm{]}}\\xspace},{\\ensuremath{\\otimes}\\index{\\ensuremath{\\otimes}}\\index{disj@\\ensuremath{\\otimes}}\\xspace}\\rangle}\\xspace}$ ] ; 3 .   if @xmath30 , then the preconditions of @xmath20 are true with probability @xmath21 or greater , i.e. @xmath31}}\\xspace } pre(\\alpha)$ ] ; 4 .   for every action status atom of the form @xmath32 in @xmath33 such that @xmath30 , the preconditions of @xmath34 are true with probability @xmath21 or greater , i.e. @xmath31}}\\xspace } pre(\\beta)$ ]  @xmath35    the only difference between this definition and that of @xmath36 is that the entailment @xmath37}}\\xspace}$ ] is replaced by the more general @xmath38}}\\xspace}$ ] .    a probabilistic status set",
    "@xmath23 is _ deontically p - consistent _ with respect to a probabilistic agent state @xmath19 _ if , by definition,_it satisfies the following rules for any ground action @xmath20 :    * if @xmath39 , then @xmath40 . * if @xmath41 , then @xmath42 . * if @xmath41 , then the preconditions of @xmath20 are true with probability @xmath21 or greater , i.e. @xmath31}}\\xspace } pre(\\alpha)$ ] .",
    "a probabilistic status set @xmath23 is _ action p - consistent _ with respect to an agent state @xmath19 iff for every action constraint of the form @xmath43 either @xmath44}}\\xspace}\\chi$ ] or @xmath45 .",
    "generalizing probabilistic state consistency to @xmath21-probabilistic state consistency may be done in two ways .",
    "a probabilistic status set @xmath23 is _ weakly probabilistically state p - consistent _ w.r.t .",
    "state @xmath19 iff the new state , @xmath46 obtained after concurrently executing all actions of the form @xmath47 satisfies all integrity constraints with probability greater than or equal to @xmath21 , i.e. for every integrity constraint @xmath48 either @xmath49}}\\xspace } \\psi $ ] or @xmath50}}\\xspace } \\chi $ ] .",
    "+ we say that a probabilistic status set @xmath23 is _ strongly probabilistically state p - consistent _ w.r.t .",
    "state @xmath19 iff the new state @xmath51 satisfies the following condition : if @xmath19 satisfies the integrity constraints with probability @xmath52 ( @xmath53 $ ] ) then also @xmath51 does so .",
    "these definitions induce two types of feasibility for arbitrary probabilities @xmath21 .",
    "let @xmath22 be an agent program and let @xmath19 be an agent state .",
    "then , a probabilistic status set @xmath23 is a _",
    "p - feasible probabilistic status set _ for @xmath22 on @xmath19 , if the following conditions hold :    ( p-@xmath541 ) : : :    @xmath55    ( closure under the program rules ) ; ( p-@xmath542 ) : : :    @xmath23    is deontically and action p - consistent ( deontic and action    p - consistency ) ; ( p-@xmath543 ) : : :    @xmath23    is action closed and deontically closed ( deontic and action closure ) ; ( p-@xmath544 ) : : :    @xmath23    is weakly ( resp .",
    "strong ) state p - consistent ( state p - consistency ) .",
    "if @xmath56 is a p - feasible probabilistic status set for @xmath22 on @xmath19 and @xmath57 , then @xmath56 _ is not always _ q - feasible .",
    "indeed , @xmath58\\supseteq [ p,1]$ ] , and then for any formula @xmath59 @xmath31}}\\xspace}\\phi$ ] implies that @xmath60}}\\xspace}\\phi$ ] ( and analogously for @xmath61}}\\xspace}$ ] and @xmath62}}\\xspace}$ ] ) .",
    "this means that all preconditions of actions , preconditions of action constraints and integrity constraints which are verified for @xmath21 are also verified for @xmath63 . + the problem is that @xmath64 is anti - monotonic w.r.t .",
    "@xmath21 , as a smaller value for @xmath21 may allow a larger set of rules to be firable .",
    "then the closure under the program rules is not guaranteed any more .",
    "the following example illustrates this point .",
    "consider the following trivial program : @xmath65 where @xmath66 , and @xmath67 .",
    "suppose @xmath68 .",
    "conditions p-@xmath5424 are true for any value of @xmath21 .",
    "note that 0.8-@xmath69 nd hence , @xmath54is 0.8-feasible .",
    "in contrast , we see that 0.6-@xmath70 , and hence @xmath54is not 0.6-feasible .",
    "we can easily see that probabilistic feasibility is a particular case p - feasibility :    let @xmath22 be a probabilistic agent program and let @xmath19 be a consistent ( or equivalently 1-consistent ) agent state .",
    "then , a probabilistic status set @xmath23 is a feasible probabilistic status set _ if and only if _ it is weakly 1-feasible _ if and only if_it is strongly 1-feasible .    all definitions for weak p - feasibility trivially coincide with those for feasibility if p=1 .",
    "the distinction between weak and strong p - feasibility is just in the definition of p - consistency , and we can easily see that for p=1 they coincide , since a probability _ greater or equal to _ 1 can not be but equal to 1 .      the notions of rational and reasonable status sets can be straightforwardly extended to those of p - rational and p - reasonable status sets .    a probabilistic status set @xmath23 is a _",
    "p - rational probabilistic status set _",
    ", if @xmath23 is a p - feasible probabilistic status set and there exists no probabilistic status set @xmath71 satisfying conditions @xmath72@xmath73 of a p - feasible probabilistic status set .    obviously , in the case that @xmath74 ( i.e. , there are no integrity constraints ) p - rational status sets are simply inclusion - minimal feasible status sets .",
    "let @xmath22 be a probabilistic agent program , let @xmath75 be an agent state , and let @xmath23 be a probabilistic status set .    1 .",
    "if @xmath22 is a positive probabilistic agent program , then @xmath23 is a _",
    "p - reasonable probabilistic status set _ for @xmath22 on @xmath75 , _ if , by definition,_@xmath23 is a p - rational probabilistic status set for @xmath22 on @xmath75 .",
    "2 .   exploiting the definition of @xmath76 ( see definition  )",
    ", @xmath23 is a _",
    "p - reasonable probabilistic status set _ for @xmath22 w.r.t .",
    "@xmath75 , if it is a p - reasonable probabilistic status set of the program @xmath76 with respect to @xmath75 .",
    "it is easy to verify that all p - reasonable probabilistic status sets are p - rational probabilistic status sets :    let @xmath22 be a probabilistic agent program and @xmath75 an agent state .",
    "then , every p - reasonable probabilistic status set of @xmath22 on @xmath75 is a p - rational probabilistic status set of @xmath22 on @xmath75 .",
    "identical to the proof of proposition  .    as in section",
    ", we can define a fixpoint operator and build an algorithm on its top to compute p - reasonable status sets for positive programs .",
    "@xmath77    operator @xmath78 can be computed by an algorithm identical to algorithm  , but for step 4 , where the entailment @xmath37}}\\xspace}$ ] has to be replaced by @xmath38}}\\xspace}$ ] .",
    "@xmath78 is monotonic and continuous and has a unique least fixpoint .",
    "suppose @xmath22 is a positive .",
    "then the operator @xmath78 is monotone and continuous , i.e.    1 .",
    "@xmath79 , 2 .",
    "@xmath80 is a fixpoint of @xmath78 .",
    "moreover , it is the least fixpoint of @xmath78 .",
    "( we assume the iterations of @xmath78 are defined in the same way as the iterations of @xmath81 ) .",
    "the following result now follows immediately and has a proof similar to that of theorem  .",
    "[ p - rat - as - least ] + let @xmath22 be a positive probabilistic agent program , and let @xmath75 be an agent state .",
    "then , @xmath23 is a p - rational probabilistic status set of @xmath22 on @xmath75 , _ if and only if_@xmath82 and @xmath23 is a p - feasible probabilistic status set .",
    "uniqueness of the p - reasonable status set ( if it exists ) holds too , and then we can compute it by algorithm  , replacing  as usual  the entailment @xmath37}}\\xspace}$ ] with @xmath38}}\\xspace}$ ] .    unfortunately , the resulting algorithm is not polynomial because of the integrity constraint check in steps ( 11)(12 ) .",
    "this will be discussed in detail in section  [ al - wic ] below .",
    "however , when no integrity constraints are present , the algorithm is still polynomial .    the problem of computing p - reasonable probabilistic status sets of positive swithout integrity constraints ( i.e. , @xmath83 ) has polynomial data - complexity .",
    "in this section , we provide an algorithm to check @xmath21-consistency of an integrity constraint ic after an action have been executed in state @xmath19 , leading to a new state @xmath84 assuming that all integrity constraints are true in the original state @xmath19 .",
    "suppose @xmath85 are all states compatible with @xmath86 while @xmath87 are those compatible with the new state @xmath88 .",
    "let @xmath89 denote the probabilities of @xmath90 respectively .",
    "then consider the following system of constraints :    @xmath91 the objective function captures the probability of @xmath92 being true in the new kripke structure . *",
    "( k ) * and * ( ck ) * define any arbitrary compatible kripke structure over @xmath93 states w.r.t .",
    "@xmath19 ( which cointains @xmath94 objects ) , * ( ic ) * expresses the fact that our actual state has to be p - consistent , while * ( k@xmath95 k ) * defines the kripke structure obtained after the execution of action @xmath20 .",
    "eventually , * ( ig ) * gives an upper and a lower bound to the probability of worlds ( it extends the bool expression for conjunction of events of unknown inter - relation ) .",
    "it is easy to see that a straightforward implementation of this algorithm requires exponential time and space .",
    "there has been an incredible amount of work on uncertainty in knowledge based and database systems @xcite .",
    "however , almost all this work assumes that we are reasoning with logic or with bayesian nets @xcite and most work proceeds under strong assumptions about the relationships between events ( e.g. most bayesian approaches assume conditional independence between events , while other approaches such as @xcite assume that we have no knowledge of the dependencies between events ) .",
    "this paper introduces techniques to allow an agent developer to encode different assumptions about the relationships between events , when writing probabilistic agent programs .",
    "the idea of conjunction strategies to facilitate this was first introduced in the system @xcite in an attempt to allow users querying probabilistic relational databases to express in their query , their knowledge of the dependencies between events .",
    "later , @xcite extended the use of conjunction and disjunction strategies to the case of logic programs . in this paper ,",
    "the idea of conjunction strategies are applied in the context of deontic - logic based agent programs .",
    "we are not aware of any extant work on allowing flexible dependency assumptions in the context of logics and actions .",
    "research on epistemic logic ( e.g. , @xcite ) enables reasoning about what is known and is not known at a given time .",
    "however , epistemic logics have not been used as a representation in decision making and in automated planning systems , perhaps , because the richness of these languages makes efficient reasoning very difficult . in contrast , our framework has polynomial data complexity .",
    "study the semantics of reasoning about distributed systems when uncertainty is present .",
    "they develop a logic where a process has knowledge about the probability of events which facilitates decision - making by the process .",
    "we , on the other hand , consider probabilistic states , and as argued in  @xcite this also allows us to reason about probabilistic beliefs , i.e. probabilities are assigned to the agents beliefs about events , rather than to the events themselves .",
    "that is , in halpern s work @xcite , the beliefs of the agent are certain , but in our framework , the beliefs of the agent may themselves be uncertain ( with the phenomenon when they are certain being a special case of our framework ) .    presented a framework that allows a natural specification of multi - agent decision problems .",
    "it extends logic with a new way to handle and think about non - determinism and uncertainty in terms of independent choices made by various agents , including nature and a logic program that gives the consequence of choices .",
    "it has general independence assumption .",
    "this work is more expressive than ours , but its generality leads to complexity problems and to difficulties in using the framework .    developed a logic that allows to write sentences that describe uncertainty in the state of the world , uncertainty of action effects , combine possibility and chance , distinguish between truth and chance and express information about probability distributions .",
    "he uses model theoretic semantics and demonstrates how his logic can be used to specification various reasoning and planning problems .",
    "the main purpose of the specification is to prove correctness , and not for programming of agents .",
    "model uncertainty about the true state of the world with a probability distribution over the state space .",
    "actions have uncertain effects , and each of these effects is also modeled with a probability distribution .",
    "they seek plans whose probability of success exceeds the threshold .",
    "they describe , an implemented algorithm for probabilistic planning .",
    "in contrast , we focus on programming agents , rather than on how agents will construct plans .",
    "other researchers extended kushmerick et al.s model to increase the efficiency of the planning @xcite or to more realistic domains @xcite . developed a framework for anytime generation of plans under incomplete and ambiguous knowledge and actions with alternative and context dependent effects .",
    "propose using _ partially observable markov decisionprocesses _",
    "( s ) for planning under uncertainty .",
    "similar to they use a probability distributions over states to express uncertainty about the situation of the agent .",
    "they also consider the problem of non - deterministic actions and getting feedback from the environment which we mentioned only briefly .",
    "agents are programs that autonomously react to changes in their environment by taking appropriate actions . in @xcite ,",
    "the authors have proposed a framework within which agents may be built on top of an existing body of legacy code , and/or on top of specialized data structures appropriate for the intended functionality of the agent being built .    however , there are an increasing number of applications where agents are uncertain about what is true in their state ( or environment ) .",
    "such situations occur all the time in image identification programs , in programs that predict future events ( such as battlefield events , stock market events , etc . ) , and in scenarios where an agent @xmath2 attempts to predict what an agent @xmath96 will do .    in this paper",
    ", we first introduce the concept of a probabilistic code call , which is a mechanism to describe uncertain application program interfaces for arbitrary functions over arbitrary data types . based on this concept ,",
    "we define probabilistic agent programs  sets of rules that encode the operating principles of an agent .",
    "such rules encode the _ probabilistic _ conditions under which an agent is obliged to take some actions , permitted to take some actions and/or forbidden to take some actions .",
    "we then provide two broad classes of semantics for such `` probabilistic agents . '' in the first class of semantics , actions that are permitted , obligatory or done , must have preconditions that are true with 100% probability in the current agent state . in the second class of semantics ( which use probabilistic variants of kripke structures ) , the actions that are permitted , obligatory or done , must have preconditions that are true with at least a given probability .",
    "this latter class of semantics allows reasoning by cases .",
    "we provide complexity arguments showing that though the second family of semantics is perhaps epistemologically more appealing than the first , the second family of semantics is also computationally more complex .",
    "finally , the paper includes algorithms to compute the semantics of probabilistic agent programs , as long as such programs are negation free .",
    "future work on probabilistic agent programs will focus on computing the semantics of s that contain negation .",
    "a detailed study of computational complexity is also envisaged .",
    "we are also interested in identifying polynomially computable fragments of s and implementing them on top of the current _ impact_implementation .",
    "last , but not least , _ impact_has been used in a battlefield monitoring application where there is considerable uncertainty in predicting tactical enemy movements .",
    "we hope to build an application of s addressing this problem , once the implementation of s is complete .",
    "apt , k. ( 1990 ) . .",
    "in j.  van leeuwen ( ed . ) , _ handbook of theoretical computer science _",
    ", volume  b , chapter  10 , pp .",
    "elsevier science publishers b.v .",
    "( north - holland ) .",
    "arisha , k. , f.  ozcan , r.  ross , v.  s. subrahmanian , t.  eiter , and s.  kraus ( 1999 , march / april ) . .",
    "_ 14 _ , 6472 .",
    "boole , g. ( 1854 ) . .",
    "macmillan , london .",
    "( ed . ) ( 1997 ) . .",
    "morgan kaufmann .",
    "dekhtyar , a. and v.  s. subrahmanian ( 1997 ) . . in l.",
    "naish ( ed . ) , _ proceedings of the 14th international conference on logic programing _ , leuven , belgium , pp .   391405 . mit press .",
    "extended version accepted for publication in journal of logic programming ,     dix , j. , v.  s. subrahmanian , and g.  pick ( 2000 ) . .",
    "accepted for publication in journal of logic programming , to appear 2000 .",
    "doan , a. ( 1996 ) . . in _ proceedings of the third international concerence on artificial - intelligence planning systems _ , edinburgh , scotland , uk .",
    "eiter , t. , v.  subrahmanian , and g.  pick ( 1999 ) . .",
    "108_(1 - 2 ) , 179255 .",
    "eiter , t. , v.  subrahmanian , and t.  rogers ( 1999 , may ) . .",
    "technical report infsys rr-1843 - 99 - 07 , institut fr informationssysteme , technische universitt wien , a-1040 vienna , austria .",
    "eiter , t. and v.  s. subrahmanian ( 1999 ) . .",
    "108_(1 - 2 ) , 257307 .",
    "fagin , r. , j.  y. halpern , and n.  megiddo ( 1990 , july / august ) . .",
    "87_(1/2 ) , 78128 .",
    "gelfond , m. and v.  lifschitz ( 1988 ) . .",
    "in _ logic programming : proceedings fifth international conference and symposium _ , cambridge , massachusetts , pp .",
    "10701080 . mit press .",
    "haddawy , p. ( 1991 ) . .",
    "ph .  d. thesis , university of illinois .",
    "technical report uiucdcs - r-91 - 1719 .",
    "haddawy , p. , a.  doan , and r.  goodwin ( 1996 ) . .",
    "in _ proceedings of the third international concerence on artificial - intelligence planning systems _ , edinburgh , scotland , uk .",
    "halpern , j.  y. and m.  tuttle ( 1992 ) . .",
    "technical report , ibm .",
    "ibm research report .",
    "kaelbling , l.  p. , m.  l. littman , and a.  r. cassandra ( 1998 ) . .",
    "_ 101 _ , 99134 .",
    "kifer , m. and v.  s. subrahmanian ( 1992 ) . .  _",
    "12_(4 ) , 335368 .",
    "koller , d. ( 1998 ) . .",
    "in _ proceedings of the fifteenth national conference on artificial intelligence , aaai98 _ , madison , wisconsin . aaai press / mit press .",
    "koller / invited98| .",
    "kraus , s. and d.  lehmann ( 1988 ) . .",
    "_ 58 _ , 155174 .",
    "kushmerick , n. , s.  hanks , and d.  weld ( 1995 ) . .",
    "76_(1 - 2 ) , 239286 .",
    "lakshmanan , v.  s. , n.  leone , r.  ross , and v.  s. subrahmanian ( 1997 , september ) . .  _",
    "22_(3 ) , 419469 .",
    "lloyd , j. ( 1984 , 1987 ) . .",
    "berlin , germany : springer - verlag .",
    "moore , r. ( 1985 ) . .",
    "in j.  hobbs and r.  moore ( eds . ) , _ formal theories of the commonsesnse world_. norwood , n.j . : ablex publishing .",
    "morgenstern , l. ( 1988 ) . .",
    "ph .  d. thesis , new york university .",
    "ng , r. and v.  s. subrahmanian ( 1993a ) . .  _",
    "10_(2 ) , 191235 .",
    "ng , r. and v.  s. subrahmanian ( 1993b ) . .  _",
    "101_(2 ) , 150201 .    poole , d. ( 1997 ) .",
    "the independent choice logic for modelling multiple agents under uncertainty .  _",
    "94_(1 - 2 ) , 756 .",
    "ross , s. ( 1997 ) . .",
    "prentice - hall .",
    "shafer , g. and j.  peal ( eds . ) ( 1990 ) . .",
    "morgan kaufmann .",
    "siegal , j. ( 1996 ) . .",
    "new york : john wiley & sons .",
    "subrahmanian , v.  s. ( 1987 , september ) . .",
    "in _ proceedings of the 4th ieee symposium on logic programming _ , pp .   173182 . computer society press .",
    "thibaux , s. , j.  hertzberg , w.  shoaff , and m.  schneider ( 1995 ) . .  _",
    "the following definitions are taken from @xcite .",
    "[ c7-ss ] a _ status set _ is any set @xmath56 of ground action status atoms over @xmath6 . for any operator @xmath97 ,",
    "we denote by @xmath98 the set @xmath99 .",
    "[ c6-def : dac ] a status set @xmath56 is called _ deontically consistent _ , _ if , by definition,_it satisfies the following rules for any ground action @xmath20 :    * if @xmath100 , then @xmath101 * if @xmath102 , then @xmath103 * if @xmath102 , then @xmath104 , where @xmath105 denotes the existential closure of @xmath106 , i.e. , all free variables in @xmath106 are governed by an existential quantifier .",
    "this condition means that the action @xmath20 is in fact executable in the state @xmath75 .    a status set @xmath56 is called _ action consistent _ , if @xmath107 holds .",
    "besides consistency , we also wish that the presence of certain atoms in @xmath56 entails the presence of other atoms in @xmath56 .",
    "for example , if @xmath108 is in @xmath56 , then we expect that @xmath109 is also in @xmath56 , and if @xmath108 is in @xmath56 , then we would like to have @xmath110 in @xmath56 .",
    "this is captured by the concept of deontic and action closure .",
    "[ c6-def : dcl ] the _ deontic closure _ of a status @xmath56 , denoted @xmath111 , is the closure of @xmath56 under the rule    * _ if @xmath100 , then @xmath102 _    where @xmath20 is any ground action .",
    "we say that @xmath56 is _ deontically closed _ , if @xmath112 holds .",
    "the _ action closure _ of a status set @xmath56 , denoted @xmath113 , is the closure of @xmath56 under the rules    * _ if @xmath100 , then @xmath114 _ * _ if @xmath114 , then @xmath102 _    where @xmath20 is any ground action .",
    "we say that a status @xmath56 is action - closed , if @xmath115 holds .",
    "the following straightforward results shows that status sets that are action - closed are also deontically closed , i.e.    [ c7-def : appold ] suppose @xmath116 is an agent program , and @xmath75 is an agent state .",
    "then , @xmath117is defined to be the set of all ground action status atoms @xmath118 such that there exists a rule in @xmath119 having a ground instance of the form @xmath120 @xmath121 such that    1 .",
    "@xmath122 and @xmath123 , and 2 .",
    "every code call @xmath124 succeeds in @xmath75 , and 3 .",
    "every code call @xmath125 does not succeed in @xmath75 , and 4 .   for every atom @xmath126",
    "such that @xmath127 , the action @xmath20 is executable in state @xmath75 .",
    "note that part ( 4 ) of the above definition only applies to the `` positive '' modes @xmath128 .",
    "it does not apply to atoms of the form @xmath129 as such actions are not executed , nor does it apply to atoms of the form @xmath130 , because execution of an action might be ( vacuously ) waived , if its prerequisites are not fulfilled .",
    "our approach is to base the semantics of agent programs on consistent and closed status sets .",
    "however , we have to take into account the rules of the program as well as integrity constraints .",
    "this leads us to the notion of a feasible status set .",
    "[ c6-feasss ] let @xmath116 be an agent program and let @xmath75 be an agent state .",
    "then , a status set @xmath56 is a _ feasible status set _ for @xmath116 on @xmath75 , if the following conditions hold :    ( s1 ) : : :    ( closure under the program rules )    @xmath131 ; ( s2 ) : :    ( deontic and action consistency ) @xmath56 is deontically and    action consistent ; ( s3 ) : :    ( deontic and action closure ) @xmath56 is action closed and    deontically closed ; ( s4 ) : :    ( state consistency )    @xmath132 ,    where    @xmath133    is the state which results after taking all actions in    @xmath134    on the state    @xmath75 .",
    "a status set @xmath56 is _ grounded _",
    ", if there exists no status set @xmath135 such that @xmath136 and @xmath137 satisfies conditions @xmath138@xmath139 of a feasible status set .",
    "a status set @xmath56 is a _ rational status set _",
    ", if @xmath56 is a feasible status set and @xmath56 is grounded .",
    "let @xmath116 be an agent program , let @xmath75 be an agent state , and let @xmath56 be a status set .    1 .",
    "if @xmath116 is a positive agent program , then @xmath56 is a _",
    "reasonable status set _ for @xmath116 on @xmath75 , if and only if @xmath56 is a rational status set for @xmath116 on @xmath75 .",
    "the reduct of @xmath116 w.r.t .",
    "@xmath56 and @xmath75 , denoted by @xmath140 , is the program which is obtained from the ground instances of the rules in @xmath116 over @xmath75 as follows . 1 .",
    "first , remove every rule @xmath28 such that @xmath141 ; 2 .   remove all atoms in @xmath142 from the remaining rules .",
    "+ then @xmath56 is a _ reasonable status set _ for @xmath116 w.r.t.@xmath75 , if it is a reasonable status set of the program @xmath140 with respect to @xmath75 .",
    "* ( of proposition  [ c9-prop : feas ] ) * +    1",
    ".   suppose @xmath47 .",
    "then , as @xmath23 is feasible , we know that @xmath143 , and hence @xmath144 . as @xmath23 is feasible , and hence deontically consistent , the third condition of deontic consistency specifies that @xmath20 s precondition is true in state @xmath75 .",
    "this follows immediately because as @xmath23 is feasible , we have @xmath143 . the second condition defining @xmath145 , when written in contrapositive form , states that @xmath146 implies that @xmath147 .",
    "3 .   as @xmath23 is feasible , @xmath143 .",
    "the first condition specifying @xmath145 allows us to infer that @xmath148 implies that @xmath47 .",
    "the result follows immediately from part ( 1 ) of this proposition .",
    "4 .   from the above argument , as @xmath143",
    ", we can conclude that @xmath148 implies that @xmath144 . by the deontic consistency requirement , @xmath149 .    * ( of theorem  [ c9-prop : reasonable - sub - rational ] ) * + in order to show that a reasonable probabilistic status set @xmath23 of @xmath22 is a rational status of @xmath22 , we have to verify ( 1 ) that @xmath23 is a feasible probabilistic status set and ( 2 ) that @xmath23 is grounded .",
    "since @xmath23 is a reasonable probabilistic status set of @xmath22 , it is a rational probabilistic status set of @xmath150 , i.e. , a feasible and grounded probabilistic status set of @xmath151 .",
    "since the conditions @xmath152@xmath153 of the definition of feasible probabilistic status set depend only on @xmath23 and @xmath75 but not on the program , this means that for showing ( 1 ) it remains to check that @xmath154 ( closure under the program rules ) is satisfied .",
    "let thus @xmath28 be a ground instance of a rule from @xmath22 .",
    "suppose the body @xmath155 of @xmath28 satisfies the conditions 1.4 .  of @xmath154 .",
    "then , by the definition of @xmath76 , we have that the reduct of the rule @xmath28 , obtained by removing all literals of @xmath142 from the body , is in @xmath151 .",
    "since @xmath23 is closed under the rules of @xmath151 , we have @xmath156 .",
    "thus , @xmath23 is closed under the rules of @xmath22 , and hence @xmath154 is satisfied . as a consequence , ( 1 ) holds .    for ( 2 ) , we suppose @xmath23 is not grounded , i.e. , that some smaller @xmath71 satisfies @xmath154@xmath157 for @xmath22 , and derive a contradiction . if @xmath158 satisfies @xmath154 for @xmath22 , then @xmath158 satisfies @xmath154 for @xmath151 . for , if @xmath28 is a rule from @xmath151 such that 1.4 .  of @xmath154 hold for @xmath158 ,",
    "then there is a ground rule @xmath159 of @xmath22 such that @xmath28 is obtained from @xmath159 in the construction of @xmath76 and , as easily seen , 1.4 . of @xmath154",
    "hold for @xmath158 .",
    "since @xmath158 satisfies @xmath154 for @xmath22 , we have @xmath160 .",
    "it follows that @xmath158 satisfies @xmath154 for @xmath151 .",
    "furthermore , since @xmath152 and @xmath157 do no depend on the program , also @xmath152 and @xmath157 are satisfied for @xmath158 w.r.t .",
    "this means that @xmath23 is not a rational probabilistic status set of @xmath151 , which is the desired contradiction .",
    "suppose @xmath22 has a feasible probabilistic status set .",
    "then the set of all feasible probabilistic status sets of @xmath22 on @xmath75 has a non - empty set of inclusion - minimal elements . indeed , from the grounding of the probabilistic agent program",
    ", we can remove all rules which violate the conditions 2.-4 .  of the operator @xmath161 , and can remove literals involving code calls from the remaining rules .",
    "moreover , the deontic and action closure conditions can be incorporated into the program via rules .",
    "thus , we end up with a set @xmath162 of propositional clauses , whose models are feasible probabilistic status sets of @xmath22 . since @xmath22 has a feasible probabilistic status set , @xmath162 has a model , i.e. , an assignment to the propositional atoms which satisfies all clauses in @xmath162 .",
    "now , each satisfiable set of clauses in a countable language posseses at least one minimal model ( w.r.t .",
    "inclusion , i.w .",
    ", a @xmath163-minimal set of atoms is assigned the value @xmath164 ) ; this can be shown applying the same technique which proves that every such set of clauses can be extended to a maximal satisfiable set of clauses .",
    "thus , @xmath162 has at least one minimal model .",
    "as easily seen , any such model is a minimal feasible probabilistic status set of @xmath22 .      to show that @xmath158 is grounded",
    ", we need to show that @xmath158 satisfies conditions ( @xmath541)(@xmath543 ) of the definition of feasible probabilistic status set  this is true because @xmath158 is feasible . in addition",
    ", we need to show that no strict subset @xmath165 of @xmath23 satisfies conditions ( @xmath541)(@xmath543 ) .",
    "suppose there is a strict subset @xmath165 of @xmath23 satisfying conditions ( @xmath541)(@xmath543 ) .",
    "then , as @xmath74 , @xmath165 also satisfies condition ( @xmath544 ) of the definition of feasibility , and hence @xmath165 is a feasible probabilistic status set .",
    "but this contradicts the inclusion minimality of @xmath158 , and hence , we may infer that @xmath158 has no strict subset @xmath165 of @xmath23 satisfying conditions ( @xmath541)(@xmath543 ) .",
    "thus , @xmath158 is grounded , and we are done .    * ( of theorem  [ prop_comp_kripke ] ) * + for each random variable @xmath166 returned by some ground code call condition in the probabilistic state @xmath19 , let us define its _ normalized _ version @xmath167 where : @xmath168 i.e. , we delete the zero - probability elements and add the extra one @xmath169 ( which stands for `` none of the above '' ) whenever the distribution @xmath170 is incomplete .",
    "now we can see that each tuple @xmath171 in the cartesian product @xmath172 corresponds to a distinct compatible state @xmath173 w.r.t .",
    "@xmath19 . in @xmath173 ,",
    "a ground code call returns an object @xmath174 iff in the probabilistic state @xmath19 it returns a variable @xmath175 such that @xmath176 .",
    "let associate to each state @xmath173 of this kind the value @xmath177 and set @xmath178 for all the other states .",
    "we can easily verify that @xmath179 is a compatible probabilistic kripke structure for @xmath19 : for each random variable @xmath175 returned in state @xmath19 and each object @xmath180 if @xmath181 then @xmath182 , so it could appear only in the zero - probability states ; otherwise : @xmath183 both cases satisfy the condition for compatibility .",
    "finally , it is easy to verify that @xmath184 is really a probabilistic kripke structure : @xmath185    * ( of theorem  [ prop - atleast ] ) * + let us consider the compatible kripke structure described in the proof of proposition  , and let us assume that @xmath186 and @xmath187 are the variables required in the thesis .",
    "the corresponding _ completed _ versions @xmath188 and @xmath189 will then contain at least two non zero - probability objects ( one of them could be the extra object @xmath169 ) , respectively @xmath190 and @xmath191 .",
    "now let choose an arbitrary real number @xmath192 such that : @xmath193 we can build a kripke structure @xmath194 , where @xmath195 is defined in the same way as @xmath196 but replacing @xmath197 by @xmath198 , which in turn is defined in the following way : @xmath199 it is easy to verify that it is a compatible kripke structure . since @xmath192 can be arbitrarily chosen within a non - point interval , we can obtain an infinite number of distinct compatible kripke structures .    *",
    "( of theorem  [ p - rat - as - least ] ) * + @xmath200 suppose @xmath201 a rational probabilistic status set of @xmath22 on @xmath75 .",
    "then , @xmath23 is feasible by definition of rational probabilistic status set . by lemma  [ c9-lem : fixpoint ] , @xmath23 is a pre - fixpoint of @xmath81 .",
    "since @xmath81 is monotone , it has by the knaster - tarski theorem a least pre - fixpoint , which coincides with @xmath202 ( see @xcite ) . thus , @xmath203 . clearly , @xmath202 satisfies @xmath154 and @xmath157 ; moreover , @xmath202 satisfies @xmath152 , as @xmath23 satisfies @xmath152 and this property is hereditary . by the definition of rational probabilistic status set , it follows @xmath204 .",
    "@xmath205 suppose @xmath201 is a feasible probabilistic status set .",
    "since every probabilistic status set @xmath158 which satisfies @xmath154@xmath206 is a pre - fixpoint of @xmath81 and @xmath202 is the least prefix point , @xmath207 implies @xmath208 .",
    "it follows that @xmath23 is rational .",
    "notice that in case of positive programs , @xmath202 always satisfies the conditions @xmath154 and @xmath157 of a feasible probabilistic status set ( i.e. , all closure conditions ) , and thus is a rational probabilistic status set if it satisfies @xmath152 and @xmath153 , i.e. , the consistency criteria .",
    "the uniqueness of the rational probabilistic status set is immediate from the previous theorem ."
  ],
  "abstract_text": [
    "<S> agents are small programs that autonomously take actions based on changes in their environment or `` state . '' over the last few years , there have been an increasing number of efforts to build agents that can interact and/or collaborate with other agents . in one of these efforts , have shown how agents may be built on top of legacy code . </S>",
    "<S> however , their framework assumes that agent states are completely determined , and there is no uncertainty in an agent s state . </S>",
    "<S> thus , their framework allows an agent developer to specify how his agents will react when the agent is 100% sure about what is true / false in the world state . in this paper </S>",
    "<S> , we propose the concept of a _ </S>",
    "<S> probabilistic agent program _ and show how , given an arbitrary program written in any imperative language , we may build a declarative `` probabilistic '' agent program on top of it which supports decision making in the presence of uncertainty . </S>",
    "<S> we provide two alternative semantics for probabilistic agent programs . </S>",
    "<S> we show that the second semantics , though more epistemically appealing , is more complex to compute . we provide sound and complete algorithms to compute the semantics of _ positive _ agent programs . </S>"
  ]
}