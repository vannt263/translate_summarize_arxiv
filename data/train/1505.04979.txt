{
  "article_text": [
    "shanon proved existence of maximum data transmission rate , called channel capacity @xcite . since then",
    ", different capacity - approaching codes have been designed , like turbo codes @xcite and ldpc codes @xcite .",
    "the first provable capacity - achieving codes , polar codes , were recently invented by arikan @xcite .",
    "polar codes are considered to be a major breakthrough in coding theory , since they are the first family of codes known to achieve channel capacity with explicit construction . besides achieving the capacity for binary - input symmetric memoryless channels @xcite",
    ", polar codes were also proved in @xcite to be able to achieve the capacity for any discrete and continuous memoryless channel . moreover ,",
    "an explicit construction method for polar codes was provided and it was shown that they can be efficiently encoded and decoded with complexity @xmath0 , where @xmath1 is the code length . since then , polar codes have become one of the most popular topics in information theory and have attracted a lot of attention .",
    "several decoding methods are available for decoding polar codes @xcite-@xcite , scd and its variants and bpd are two popular methods .",
    "sc decoders suffer from long latency due to the serial nature of the sc algorithm .",
    "however , the sc algorithm requires less computation as compared to bpd .",
    "based on this property , several high - throughput low - cost sc decoders were reported in @xcite@xcite .",
    "another advantage of the sc algorithm is its ability to achieve good error - correcting performance for long code lengths . for short code length , based on the scd",
    ", the list - decoding or stack decoding method also achieve good error - correcting performance @xcite@xcite .    on the other hand , polar bp decoders @xcite-@xcite have the intrinsic advantage of parallel processing .",
    "therefore , compared with their sc counterparts , polar bp decoders are more attractive for low - latency applications . for iterative decoders ( such as polar bp decoders ) , the required latency and energy dissipation increase linearly with the number of iterations .",
    "however , the need for a large number of iterations makes bp decoders suffer from high computation complexity , and hence polar bp decoders are still not as attractive as their sc counterparts . to this end , another decoding method , called soft cancellation ( scan ) decoding , is proposed in @xcite . by restricting the soft information propagation schedule in the decoding process",
    ", the computational complexity of scan is much lower than that of bpd .",
    "however , different from bpd , the scan operation is serial in nature , leading to a much longer decoding latency .",
    "hence , aiming at the low - latency polar codes decoder , we concentrate on the bpd in this work .    to address the issues of the large number of iterations and high computation complexity inherent in bp decoders , yuan et al .",
    "@xcite proposed a g - matrix - based early stopping scheme , which is based on the fact that iterative decoders normally converge earlier than reaching a fixed maximum number of iterations . the g - matrix - based stopping criterion",
    "can then be used to stop the computation if convergence has been reached . to further reduce the computation complexity , in this paper ,",
    "we propose a method based on the convergence of the sub - factor - graphs , which is reached at a much earlier stage .",
    "borrowing the idea from scd , some of the sub - factor - graphs are checked during each iteration and if they have converged , they are frozen and do not need to be computed in the subsequent iterations .",
    "also the freezing of these sub - factor - graphs will help to improve the convergence of the decoding process over rest of the factor graph . as a result , the computation complexity and also the average number of iterations are reduced .",
    "experimental results show that our proposed method results in about 40 ~ 46 % lower computation complexity , as well as lower latency , when compared to the previously proposed early stopping scheme @xcite .      in this paper , the following notation conventions are used .",
    "matrices are denoted in boldface capital letters , and vectors in boldface lowercase letters .",
    "the subscript @xmath2 of a matrix represents an @xmath3 square matrix and @xmath4 denotes an @xmath5 vector .",
    "@xmath6 $ ] stands for the @xmath7 element of vector @xmath8 , @xmath9 stands for vector @xmath8 at the @xmath10 iteration and @xmath11 represents the sub - vector of @xmath8 with the starting and ending index of @xmath12 and @xmath13 .",
    "the transpose of a vector @xmath8 is denoted by @xmath14 .",
    "polar codes are based on the phenomenon of channel polarization .",
    "more precisely , by recursively combining and splitting individual channels , some of these channels become essentially error - free , while others become completely noisy .",
    "furthermore , the fraction of the noiseless channels tends towards the capacity of the underlying binary symmetric channels @xcite .",
    "therefore , an @xmath15 polar code can be generated in two steps .",
    "first , an @xmath1-bit message @xmath16 is constructed by assigning the @xmath17 reliable and @xmath18 unreliable positions as information bits and 0 bits , respectively .",
    "the @xmath18 unreliable positions , which are forced to 0 , are called the frozen bits ( also known as the frozen set @xmath19 ) .",
    "then , the @xmath1 -bit @xmath16 is multiplied with the generator matrix @xmath20 to generate an @xmath1 -bit transmitted codeword @xmath8 , where @xmath21 is the @xmath22 kronecker power of @xmath23 $ ] and @xmath24 .",
    "1 shows the encoding signal flow graph for @xmath25 polar codes , where the @xmath26 sign represents the xor operation .      as presented in @xcite ,",
    "similar to ldpc codes , polar codes can be decoded by applying the belief propagation ( bp ) algorithm over their factor graphs . for an @xmath15 polar code @xmath27 ,",
    "the factor graph is an @xmath28-stage network consisting of @xmath29 nodes , where each node is associated with a right - to - left and a left - to - right likelihood message denoted by @xmath30 and @xmath31 , respectively .",
    "@xmath32 denotes the right to left likelihood message of the @xmath7 node at the @xmath33 stage and the @xmath10 iteration .",
    "fig.2 ( a ) shows an example of a 3-stage factor graph for @xmath25 polar codes . here",
    "each stage consists of @xmath34 processing elements ( pes ) . during the bp decoding procedure ,",
    "these messages are propagated and updated among adjacent nodes using the min - sum updating rule , as shown by the following equations @xcite :    @xmath35    @xmath36    @xmath37    @xmath38    @xmath39 is a scaling parameter introduced in @xcite for the improvement of the decoding performance of a bp decoder . according to the decoding procedure of bp algorithm ,",
    "pes are activated stage - by - stage from left to right in each iteration .",
    "after the number of iterations reaches the specific maximum number ( max_iter ) , node @xmath40 will output the decoded information bit @xmath41 based on the hard decision of the messages @xmath42 .",
    "3(a ) shows the scheduling tree of the successive cancellation decoding ( scd ) of the ( 8,4 ) polar code @xcite , and fig .",
    "3(b ) depicts the equivalent bpd factor graph of the same ( 8,4 ) polar code . at each stage",
    "the scd scheduling tree is split into a number of sub - trees , each of which is responsible for decoding a corresponding constituent code .",
    "the size of the sub - tree varies at each level and is reduced by half when moving from one stage to another stage .    before presenting the details of our proposed scheme , we first introduce the notion of the _ connected sub - factor - graph_. a connected sub - factor graph ( csfg ) is defined as a sub - factor - graph which has the same number of inputs and outputs and where the output nodes are at the stage @xmath43 and each input is connected to each output through some pes in the sub - factor - graph .",
    "3(b ) shows two examples of csfgs .",
    "it can be seen that each csfg has a corresponding sub - tree in the scheduling tree of scd .",
    "3 ( a ) and ( b ) show examples of the corresponding sub - trees and the connected sub - factor - graph of the ( 8,4 ) polar code . the number of csfgs at each stage is given by @xmath44 , where @xmath45 is the stage number .",
    "for the ( 8,4 ) polar code , as shown in fig .",
    "3 ( c ) and ( d ) , the numbers of csfgs at stages 1 and 2 are 2 and 4 , respectively .    at each iteration @xmath46 , the nodes at stage @xmath45 in the bpd factor graph output left - to - right llr - based propagating messages @xmath47 , and these are the inputs to the @xmath44 csfgs at stage @xmath45 .",
    "@xmath48 are the inputs to the first csfg , while @xmath49are those for the @xmath50 csfg .",
    "each csfg is responsible for the decoding of the corresponding constituent code from its respective input messages .",
    "the proposed scheme borrows the idea of successive cancellation decoding ( scd ) , where the results of the previous - decoded bits are used for the decoding of the current bit .",
    "here we introduce a csfg freezing concept for a low complexity bpd . at a particular iteration @xmath46 ,",
    "when the message passing reaches a certain stage @xmath45 , if a csfg at that stage can correctly decode its corresponding constituent code ( i.e. the csfg has reached convergence ) , it is frozen and no message passing or updating within the csfg will be needed in the subsequent iterations .",
    "the details of how to check whether a csfg can be frozen will be presented later .",
    "one important thing is the checking order for the freezing of the csfg .",
    "a csfg can only be frozen if all the previous csfgs ( in the order of the decoding bits ) at that stage have been frozen .",
    "if a csfg is not frozen , it means the message values inside it will still be changed in the subsequent iterations .",
    "similar to the scd operation , the message values of this csfg will be used for the decoding of the constituent codes of the subsequent csfgs .",
    "therefore the freezing of the csfgs at a stage has to follow an order based on the decoded bit . when a csfg at a certain stage is checked for freezing ,",
    "if it can not correctly decode its constituent code , then it can not be frozen and the message passing and updating have to be executed for pes at that stage .",
    "after that , we move to the next stage and check the convergence of the corresponding csfgs .",
    "when we move to the next stage , the number of csfgs will be doubled .",
    "this freezing - checking procedure will continue from stage to stage until the end of the bpd factor graph is reached .",
    "next we will present how we can freeze a csfg . as discussed above",
    ", a csfg corresponds to a sub - tree in the scd scheduling tree , which can also be viewed as a constituent code of the original polar code . at the @xmath10 iteration and stage @xmath45 ,",
    "the left - to - right propagation messages @xmath49 connected to the @xmath50 csfg can be viewed as the llr inputs to decode the corresponding constituent code .",
    "we can apply maximum - likelihood decoding ( mld ) on this constituent code with @xmath49as input to obtain a decoded output vector @xmath51 , which is a sub - vector of the source word ( @xmath52 ) of the original polar code . as will be shown later ,",
    "if the freezing of the csfgs follows the proposed order , the input messages of csfg @xmath49 are reliable enough and mld @xmath51 , based on these input messages , can be taken as the decoded result of the constituent code .",
    "the freezing order of the csfg has to follow the decoded bit order , and the top csfgs at each stage will be frozen first .",
    "4 shows the scd scheduling tree and the factor graph of the ( 8,4 ) polar code .",
    "we can see that the top csfgs are actually corresponding to the first few sub - trees that follow the depth - first traversal of the scd scheduling tree .",
    "at the first iteration , the input messages to these csfgs are the same as the input llr messages of the corresponding scd sub - trees .",
    "hence if we can decode the input messages of these csfgs using mld , the decoding performance on the corresponding constituent code will achieve or even exceed that of scd .",
    "if the csfgs can not be frozen at this iteration , and need further iteration to converge , due to the nature of the iterative decoding , the reliability of the input messages to these csfgs will become better and hence the input llr messages of these csfgs will be more reliable than the input messages to the scd sub - tree . as a result the mld performance will not be worse than that of scd .",
    "mld is based on an exhaustive search and hence it has a huge complexity . to reduce the complexity ,",
    "novel checking criterion is suggested to efficiently find the mld result of the constituent code .",
    "let @xmath48 be the left - to - right propagation messages of a csfg at stage @xmath45 .",
    "we obtain a hard decision vector @xmath53 $ ] for these messages where    @xmath54    given @xmath55 as input to the csfg , the decoded bit vector at its output @xmath56 , which is also a sub - vector of the source word of the original polar code @xmath57 , is obtained by the inverse operation of polar code encoding that is given as    @xmath58    @xmath59    fig .",
    "5(a ) shows an example of hard decision decoding .",
    "the csfg can be frozen if the sub - source - word vector @xmath56 satisfies the following frozen set criteria :    @xmath60    the following lemma shows that if the frozen set criteria ( 4 ) are satisfied , the sub - source - word vector @xmath56 obtained by ( 3 ) is indeed the decoding results of the mld on the corresponding constituent code of the csfg .",
    "let @xmath61and @xmath55 be the input llr messages and hard decision vector based on ( 2 ) for the corresponding csfg at the @xmath33 stage .",
    "if @xmath56 is obtained from @xmath55 based on ( 3 ) and it satisfies the frozen - set criteria of ( 4 ) , then @xmath56 is the maximum likelihood detection ( mld ) result of the corresponding constituent code with input messages @xmath61 .",
    "the csfg at the @xmath33 stage represents a short polar ( constituent ) code of length @xmath62 .",
    "its input and output are related by @xmath63 . from @xcite and @xcite ,",
    "given the input llr @xmath61 , the likelihood value of an arbitrary source word @xmath64 is given by @xmath65)r_{1:2^{m - j},j+1}[i]$ ] , where @xmath63 .",
    "if no source word bit is a frozen bit , i.e. , @xmath41 can assume both 0 and 1 for @xmath66 , the source word @xmath56 obtained from @xmath55 has a maximum likelihood value which is equal to @xmath67|.$ ] if a certain source word bit is a frozen bit , the searching space of the valid source word is smaller and @xmath67|$ ] may not be achieved . however , if @xmath56 satisfies ( 4 ) , this likelihood value is achievable and the source word @xmath56 is a valid source word .",
    "hence , @xmath56 is the mld result .",
    "when a csfg at stage @xmath45 is frozen , the corresponding computations and message updating are not needed for the rest of the iterations .",
    "we can also fix its right - to - left feedback propagating messages @xmath68 for the rest of the iterations based on its @xmath55 since the output decoding decision for this csfg has already been made and we have    @xmath69    in one iteration , propagating messages from left to right , for any csfg , if the frozen set criteria ( 4 ) is not satisfied then we can not freeze this csfg .",
    "we then update the messages at this stage using equation ( 1 ) , move to the next stage and repeat the same procedure .",
    "5(b ) shows an example . at the second iteration",
    ", we check the bottom csfg at stage 1 .",
    "@xmath70 does not satisfy the frozen bit criteria ( 4 ) and we can not freeze this csfg .",
    "so the messages are updated at stage 1 and we move to the next stage ( stage 2 ) to check whether the first un - frozen csfg can be frozen at stage 2 , as shown in fig .",
    "a csfg can only be considered for freezing if all the preceding csfgs at the same stage have been frozen .",
    "this procedure is repeated until all the csfgs at a stage are frozen or we reach the maximum number of iterations , which corresponds to the completion of the decoding process .    with the freezing of csfgs , computations and message updating operations",
    "do not need to be executed for rest of the iterations .",
    "therefore the overall computation complexity , and hence the energy consumption , are reduced .",
    "moreover the right - to - left feedback propagating messages @xmath68 are fixed to either -@xmath71 or + @xmath71 depending on the value of the hard - decision bit when a csfg is frozen .",
    "this boosts the reliability of the feedback messages and will help the rest of the unfrozen csfgs to converge faster in the subsequent iterations , thus helping to reduce the overall number of iterations for the decoding and hence the average latency .",
    "to verify the error correcting performance and complexity saving for the proposed frozen - csfg - based bpd scheme , we carry out a simulation on a polar code of length 1024 and rate and compare the result with the original bpd scheme in @xcite ( which we denote as the baseline bpd ) and the bpd using a g - matrix - based stopping criterion in @xcite . fig .",
    "6 shows the simulation results over an awgn channel with bpsk modulation . for a fair comparison ,",
    "we use the same set of parameters as @xcite , where min - sum approximation with scaling parameter @xmath72 and max_iter = 40 were used . as seen in fig .",
    "6(a ) , the proposed method has no performance degradation compared with the other two existing bpd schemes .",
    "the average number of iterations required for decoding a code word are compared in fig .",
    "it can be seen that the proposed method requires the least number of iterations , resulting in lower latency and higher throughput compared to @xcite . at snr",
    "= 3db , the average number of iterations is reduced by 46% and 17% when compared to the baseline bpd and the g - matrix - based early stop method , respectively .",
    "we also compare the overall computation complexity of the three bpd schemes . for each pe in the factor graph , we count the number of iterations until its operation is frozen in the proposed scheme .",
    "we then sum the number of iterations , for which that pe is active , for all the pes . for the other two schemes , since every pe needs to be executed in every iteration , the computation complexity just depends on the average number of iterations .",
    "6(c ) shows the normalized average number of computations required for all three schemes .",
    "it can be observed that the proposed scheme requires the least number of computations , which translates directly to lower power consumption and latency for the overall decoding process .",
    "it can be seen that at snr = 3db , the average computation complexity is reduced by 65% and 46% when compared with the baseline scheme and the early - stopping scheme , respectively .",
    "as state of the are bpd , computaion savings for the proposed method are comaperd with g - matrix based early stopping method in fig .",
    "in this work we have presented a novel scheme to reduce the average number of computations as well as average latency in belief propagation decoding ( bpd ) for polar codes based on the concept of a frozen connected sub - factor - graph .",
    "simulation results show that there is no performance degradation of the proposed scheme when compared with the original belief propagation algorithm and the g - matrix - based early stopping criterion , while the scheme enjoys a 46 ~ 65 % reduction in computation complexity , and 17 ~ 46% reduction in latency at snr = 3db . in future work , the vlsi architecture and a hardware implementation will be developed .                c. leroux , i. tal , a. vardy , and w. j. gross , hardware architectures for successive cancellation decoding of polar codes , _ in proc .",
    "acoust . , speech , signal process .",
    "( icassp ) _ , pp .",
    "16651668 , may 2011 .",
    "y. fan , j. chen , c. xia , c.y .",
    "tsui , j. jin , h. shen and b. li low - latency list decoding of polar codes with double thresholding _ in proc .",
    "speech , signal process .",
    "( icassp)_,in press , arxiv:1504.03437 ."
  ],
  "abstract_text": [
    "<S> since their invention , polar codes have received a lot of attention because of their capacity - achieving performance and low encoding and decoding complexity . successive cancellation decoding ( scd ) and belief propagation decoding ( bpd ) are two approaches for decoding polar codes . </S>",
    "<S> scd is able to achieve good error - correcting performance and is less computationally expensive as compared to bpd . </S>",
    "<S> however scd suffers from long latency due to the serial nature of the successive cancellation algorithm . </S>",
    "<S> bpd is parallel in nature and hence is more attractive for low latency applications . </S>",
    "<S> however , since it is iterative , the required latency and energy dissipation increases linearly with the number of iterations . in this work </S>",
    "<S> , we borrow the idea of scd and propose a novel scheme based on sub - factor - graph freezing to reduce the average number of computations as well as the average number of iterations required by bpd , which directly translates into lower latency and energy dissipation . </S>",
    "<S> simulation results show that the proposed scheme has no performance degradation and achieves significant reduction in computation complexity over the existing methods .    </S>",
    "<S> = 1    belief propagation decoding ( bpd ) ; successive cancellation decoding ( scd ) ; energy efficiency ; iterative decoders ; factor graph ; polar codes </S>"
  ]
}