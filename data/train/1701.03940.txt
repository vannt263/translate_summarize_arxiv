{
  "article_text": [
    "the incremental gaussian mixture network ( igmn ) @xcite is a supervised algorithm which approximates the em algorithm for gaussian mixture models @xcite , as shown in @xcite .",
    "it creates and continually adjusts a probabilistic model of the joint input - output space consistent to all sequentially presented data , after each data point presentation , and without the need to store any past data points .",
    "its learning process is aggressive , meaning that only a single scan through the data is necessary to obtain a consistent model .",
    "igmn adopts a gaussian mixture model of distribution components that can be expanded to accommodate new information from an input data point , or reduced if spurious components are identified along the learning process .",
    "each data point assimilated by the model contributes to the sequential update of the model parameters based on the maximization of the likelihood of the data .",
    "the parameters are updated through the accumulation of relevant information extracted from each data point .",
    "new points are added directly to existing gaussian components or new components are created when necessary , avoiding merge and split operations , much like what is seen in the adaptive resonance theory ( art ) algorithms @xcite .",
    "it has been previously shown in @xcite that the algorithm is robust even when data is presented in random order , having similar performance and producing similar number of clusters in any order .",
    "also , @xcite has shown that the resulting models are very similar to the ones produced by the batch em algorithm .",
    "the igmn is capable of supervised learning , simply by assigning any of its input vector elements as outputs . in other words ,",
    "any element can be used to predict any other element , like auto - associative neural networks @xcite or missing data imputation @xcite .",
    "this feature is useful for simultaneous learning of forward and inverse kinematics @xcite , as well as for simultaneous learning of a value function and a policy in reinforcement learning @xcite .",
    "previous successful applications of the igmn algorithm include time - series prediction @xcite , reinforcement learning @xcite , mobile robot control and mapping @xcite and outlier detection in data streams @xcite .",
    "however , the igmn suffers from cubic time complexity due to matrix inversion operations and determinant computations .",
    "its time complexity is of @xmath4 , where @xmath1 is the number of data points , @xmath2 is the number of gaussian components and @xmath3 is the problem dimension .",
    "it makes the algorithm prohibitive for high - dimensional tasks ( like visual tasks ) and thus of limited use .",
    "one solution would be to use diagonal covariance matrices , but this decreases the quality of the results , as already reported in previous works @xcite . in @xcite , we propose the use of rank - one updates for both inverse matrices and determinants applied to full covariance matrices , thus reducing the time complexity to @xmath0 for learning while keeping the quality of a full covariance matrix solution .    for the specific case of the igmn algorithm , to the best of our knowledge , this has not been tried before , although we can find similar efforts for related algorithms .",
    "in @xcite , rank - one updates were applied to an iterated linear discriminant analysis algorithm in order to decrease the complexity of the algorithm .",
    "rank - one updates were also used in @xcite , where gaussian models are employed for feature selection . finally , in @xcite , the same kind of optimization",
    "was applied to maximum likelihood linear transforms ( mllt ) .    in this work ,",
    "we present improved formulas for the covariance matrix updates , removing the need for two rank - one updates , which increases efficiency and stability .",
    "it also presents new promising results in reinforcement learning tasks , showing that this algorithm is not only scalable from the computational point - of - view , but also in terms of data - efficiency , promoting fast learning from few data points / experiences .",
    "the next section describes the algorithm in more detail with the latest improvements to date .",
    "section [ sec : figmn ] describes our improvements to the algorithm .",
    "section [ sec : experiments ] shows the experiments and results obtained from both versions of the igmn for comparison , and section [ sec : conclusion ] finishes this work with concluding remarks .",
    "in the next subsections we describe the igmn algorithm , a slightly improved version of the one described in @xcite .",
    "the algorithm starts with no components , which are created as necessary ( see subsection [ sec : create ] ) .",
    "given input @xmath5 ( a single instantaneous data point ) , the igmn algorithm processing step is as follows .",
    "first , the squared mahalanobis distance @xmath6 for each component @xmath7 is computed :    @xmath8    where @xmath9 is the @xmath10 component mean , @xmath11 its full covariance matrix . if any @xmath6 is smaller than than @xmath12 ( the @xmath13 percentile of a chi - squared distribution with @xmath3 degrees - of - freedom , where @xmath3 is the input dimensionality and @xmath14 is a user defined meta - parameter , e.g. , @xmath15 ) , an update will occur , and posterior probabilities are calculated for each component as follows :    @xmath16    @xmath17    where @xmath2 is the number of components .",
    "now , parameters of the algorithm must be updated according to the following equations :    @xmath18    @xmath19    @xmath20    @xmath21    @xmath22    @xmath23    @xmath24    @xmath25    @xmath26    where @xmath27 and @xmath28 are the accumulator and the age of component @xmath7 , respectively , and @xmath29 is its prior probability .",
    "the equations are derived using the robbins - monro stochastic approximation @xcite for maximizing the likelihood of the model .",
    "this derivation can be found in @xcite .",
    "if the update condition in the previous subsection is not met , then a new component @xmath7 is created and initialized as follows :    @xmath30 where @xmath2 already includes the new component and @xmath31 can be obtained by : @xmath32    where @xmath33 is a manually chosen scaling factor ( e.g. , 0.01 ) and @xmath34 is the standard deviation of the dataset . note that the igmn is an online and incremental algorithm and therefore it may be the case that we do not have the entire dataset to extract descriptive statistics . in this case",
    "the standard deviation can be just an estimation ( e.g. , based on sensor limits from a robotic platform ) , without impacting the algorithm .",
    "optionally , a component @xmath7 is removed whenever @xmath35 and @xmath36 , where @xmath37 and @xmath38 are manually chosen ( e.g. , 5.0 and 3.0 , respectively ) . in that case , also , @xmath39 must be adjusted for all @xmath40 , @xmath41 , using ( [ equ : igmn - p ] ) . in other words ,",
    "each component is given some time @xmath37 to show its importance to the model in the form of an accumulation of its posterior probabilities @xmath27 .",
    "those components are entirely removed from the model instead of merged with other components , because we assume they represent outliers . since the removed components have small accumulated activations",
    ", it also implies that their removal has almost no negative impact on the model quality , often producing positive impact on generalization performance due to model simplification ( a more throughout analysis of parameter sensibility for the igmn algorithm can be found in @xcite ) .      in the igmn",
    ", any element can be predicted by any other element . in other words , inputs and targets",
    "are presented together as inputs during training .",
    "thus , inference is done by reconstructing data from the target elements ( @xmath42 , a slice of the entire input vector @xmath5 ) by estimating the posterior probabilities using only the given elements ( @xmath43 , also a slice of the entire input vector @xmath5 ) , as follows :    @xmath44    it is similar to ( [ equ : posterior ] ) , except that it uses a modified input vector @xmath43 with the target elements @xmath42 removed from calculations .",
    "after that , @xmath42 can be reconstructed using the conditional mean equation :    @xmath45    where @xmath46 is the sub - matrix of the @xmath7th component covariance matrix associating the unknown and known parts of the data , @xmath47 is the sub - matrix corresponding to the known part only and @xmath48 is the @xmath7th s component mean without the element corresponding to the target element .",
    "this division can be seen below : @xmath49    it is also possible to estimate the conditional covariance matrix for a given input , which allows us to obtain error margins for the inference procedure .",
    "it is computed according to the following equation :    @xmath50",
    "in this section , the more scalable version of the igmn algorithm , the fast incremental gaussian mixture network ( figmn ) is presented .",
    "it is an improvement over the version presented in @xcite .",
    "the main issue with the igmn algorithm regarding computational complexity lies in the fact that equation [ equ : igmn - maha ] ( the squared mahalanobis distance ) requires a matrix inversion , which has a asymptotic time complexity of @xmath51 , for @xmath3 dimensions ( @xmath52 for the strassen algorithm or at best @xmath53 with the most recent algorithms to date @xcite ) .",
    "this renders the entire igmn algorithm as impractical for high - dimension tasks .",
    "here we show how to work directly with the inverse of covariance matrix ( also called the precision or concentration matrix ) for the entire procedure , therefore avoiding costly inversions .",
    "firstly , let us denote @xmath54 , the precision matrix .",
    "our task is to adapt all equations involving @xmath55 to instead use @xmath56 .",
    "we now proceed to adapt equation [ equ : igmn - c ] ( covariance matrix update ) .",
    "this equation can be seen as a sequence of two rank - one updates to the @xmath55 matrix , as follows :    @xmath57    @xmath58    this allows us to apply the sherman - morrison formula @xcite :    @xmath59    this formula shows how to update the inverse of a matrix plus a rank - one update . for the second update , which subtracts , the formula becomes :    @xmath60    in the context of igmn , we have @xmath61 and @xmath62 for the first update , while for the second one we have @xmath63 and @xmath64 . rewriting [ equ : sherman ] and [ equ : sherman2 ] we get ( for the sake of compactness , assume all subscripts for @xmath56 and @xmath65 to be @xmath7 ) :    @xmath66    @xmath67",
    "these two equations allow us to update the precision matrix directly , eliminating the need for the covariance matrix @xmath55 .",
    "they have @xmath68 complexity due to matrix - vector products .",
    "it is also possible to combine the two rank - one updates into one , and this step was not present in previous works .",
    "the first step is to combine [ equ : figmn - c1 ] and [ equ : figmn - c2 ] into a single rank - one update , by using equations [ equ : igmn - e ] to [ equ : igmn - enew ] , resulting in the following :    @xmath69    then , by applying the sherman - morrison formula to this new update , we arrive at the following precision matrix update formula for the figmn :    @xmath70    although less intuitive than [ equ : figmn - c1 ] and [ equ : figmn - c2 ] , the above formula is smaller and more efficient , requiring much less vector / matrix operations , making figmn yet faster and even more stable ( [ equ : figmn - c2 ] depends on the result of [ equ : figmn - c1 ] , which may be a singular matrix ) .    following on the adaptation of the igmn equations , equation [ equ : igmn - maha ] ( the squared mahalanobis distance ) allows for a direct substituion , yielding the following new equation :    @xmath71    which now has a @xmath68 complexity , since there is no matrix inversion as the original equation .",
    "note that the sherman - morrison identity is exact , thus the mahalanobis computation yields exactly the same result , as will be shown in the experiments . after removing the cubic complexity from this step",
    ", the determinant computation will be dealt with next .",
    "since the determinant of the inverse of a matrix is simply the inverse of the determinant , it is sufficient to invert the result . but computing the determinant itself is also a @xmath51 operation , so we will instead perform rank - one updates using the matrix determinant lemma @xcite , which states the following :    @xmath72    @xmath73    since the igmn covariance matrix update involves a rank - two update , adding a term and then subtracting one , both rules must be applied in sequence , similar to what has been done with the @xmath56 equations . equations [ equ : figmn - c1 ] and [ equ : figmn - c2 ] may be reused here , together with the same substitutions previously showed , leaving us with the following new equations for updating the determinant ( again , @xmath7 subscripts were dropped ) :    @xmath74    @xmath75    just as with the covariance matrix , a rank - one update for the determinant update is also derived ( again , using the definitions from [ equ : igmn - e ] to [ equ : igmn - enew ] ) :    @xmath76    this was the last source of cubic complexity , which is now quadratic .    finishing the adaptation in the learning part of the algorithm",
    ", we just need to define the initialization for @xmath56 for each component .",
    "what previously was @xmath77 now becomes @xmath78 , the inverse of the variances of the dataset .",
    "since this matrix is diagonal , there are no costly inversions involved . and for initializing the determinant @xmath79 , just set it to @xmath80 , which again takes advantage of the initial diagonal matrix to avoid costly operations .",
    "note that we keep the precision matrix @xmath56 , but the determinant of the covariance matrix @xmath55 instead .",
    "see algorithms [ alg : figmn - learn ] to [ alg : figmn - create ] for a summary of the new learning algorithm ( excluding pruning , for brevity ) .",
    "@xmath81 , @xmath82 @xmath83 @xmath84    @xmath85    @xmath86    @xmath87 @xmath88    @xmath89    @xmath90    @xmath91    @xmath92    @xmath93    @xmath94    @xmath95    @xmath96 new gaussian component @xmath2 with @xmath97 , @xmath98 , @xmath99 , @xmath100 , @xmath101 , @xmath102    finally , the inference equation [ equ : reconstructfull ] must also be updated in order to allow the igmn to work in supervised mode .",
    "this can be accomplished by the use of a block matrix decomposition ( the @xmath103 subscripts stand for `` input '' , and refers to the input portion of the covariance matrix , i.e. , the dimensions corresponding to the known variables ; similarly , the @xmath104 subscripts refer to the `` target '' portions of the matrix , i.e. , the unknowns ; the @xmath105 and @xmath106 subscripts refer to the covariances between these variables ) :    @xmath107    here , according to equation [ equ : reconstructfull ] , we need @xmath46 and @xmath108 .",
    "but since the terms that constitute these sub - matrices are relative to the original covariance matrix ( which we do not have ) , they must be extracted from the precision matrix directly .",
    "looking at the decomposition , it is clear that @xmath109 ( the terms between parenthesis in @xmath110 and @xmath111 cancel each other , while @xmath112 due to symmetry ) .",
    "so equation [ equ : reconstructfull ] can be rewritten as :    @xmath113    where @xmath114 and @xmath111 can be extracted directly from @xmath56 .",
    "however , we still need to compute the inverse of @xmath111 .",
    "so we can say that this particular implementation has @xmath115 complexity for learning and @xmath116 for inference .",
    "the reason for us to not worry about that is that @xmath117 , where @xmath103 is the number of inputs and @xmath118 is the number of outputs .",
    "the inverse computation acts only upon the output portion of the matrix . since , in general , @xmath119 ( in many cases even @xmath120 ) , the impact is minimal , and the same applies to the @xmath121 product .",
    "in fact , weka ( the data mining platform used in this work @xcite ) allows for only 1 output , leaving us with just scalar operations .",
    "a new conditional variance formula was also derived to use precision matrices , as it was not present in previous works .",
    "looking again at [ equ : igmn - condconv ] , we see that it is the schur complement of @xmath47 in @xmath55 @xcite . by analysing the block decomposition equation ,",
    "it becomes obvious that , in terms of the precision matrix @xmath56 , the conditional covariance matrix has the form : @xmath122    thus , we are now able to compute the conditional covariance matrix during the inference step of the figmn algorithm , which can be useful in the reinforcement learning setting ( providing error margins for efficient directed exploration ) . and",
    "better yet , @xmath123 is already computed in the inference procedure of the figmn , which leaves us with no additional computations .",
    "the first experiment was meant to verify that both igmn implementations produce exactly the same results .",
    "they were both applied to 7 standard datasets distributed with the weka software ( table [ datasets ] ) .",
    "parameters were set to @xmath124 ( chosen by 2-fold cross - validation ) and @xmath125 , the smallest possible double precision number available for the java virtual machine ( and also the default value for this implementation of the algorithm ) , such that gaussian components are created only when strictly necessary .",
    "the same parameters were used for all datasets .",
    "results were obtained from 10-fold cross - validation ( resulting in training sets with 90% of the data and test sets with the remaining 10% ) and statistical significances came from paired t - tests with @xmath126 .",
    "as can be seen in table [ accuracy ] , both igmn and figmn algorithms produced exactly the same results , confirming our expectations .",
    "the number of clusters created by them was also the same , and the exact quantity for each dataset is shown in table [ clusters ] .",
    "the weka packages for both variations of the igmn algorithm , as well as the datasets used in the experiments can be found at @xcite . in order to experiment with high dimensional datasets and confirm the algorithm s scalability , it was applied to the mnist and cifar-10 datasets as well .    besides the confirmation we wanted",
    ", we could also compare the igmn / figmn classification accuracy for the referred datasets against other 4 algorithms : random forest ( rf ) , neural network ( nn ) , linear svm and rbf svm .",
    "the neural network is a parallel implementation of a state - of - the - art dropout neural network @xcite with 100 hidden neurons , 50% dropout for the hidden layer and 20% dropout for the input layer ( this specific implementation can be found at https://github.com/amten/neuralnetwork ) .",
    "the 4 algorithms were kept with their default parameters .",
    "the igmn algorithms produced competitive results , with just one of them ( glass ) being statistically significant below the accuracy produced by the random forest algorithm .",
    "this value was significantly inferior for all other algorithms too . on average ,",
    "the igmn algorithms were the second best from the set , losing only to the random forest .",
    "note , however , that the random forest is a batch algorithm , while the igmn learns incrementally from each data point .",
    "also , the resulting random forest model used 6 times more memory than the igmn model .",
    "we also tested the figmn accuracy on the mnist dataset , but even after parameter tuning , the results where not on par with the state - of - the - art ( above 99% for deep learning methods ) , reaching a maximum of around 93% accuracy .",
    "note , however , that figmn is a `` flat '' machine learning algorithm .",
    "future works may explore the possibility of stacking many levels of figmn s in order to obtain better classification results in vision tasks .",
    "a second experiment was performed in order to evaluate the speed performance of the proposed algorithm , both the original and improved igmn algorithms , using the parameters @xmath127 and @xmath128 , such that a single component was created and we could focus on speedups due only to dimensionality ( this also made the algorithm highly insensitive to the @xmath33 parameter ) .",
    "they were applied to the 2 highest dimensional datasets in table [ datasets ] , namely , the mnist and cifar-10 datasets .",
    "the mnist dataset was split into a training set with 60000 data points and a testing set containing 10000 data points , the standard procedure in the machine learning community @xcite .",
    "similarlly , the cifar-10 dataset was split into 50000 training data points and 10000 testing data points , also a standard procedure for this dataset @xcite .",
    "results can be seen in table [ trainingtime ] .",
    "training time for the mnist dataset was  20 times smaller for the fast version while the testing time was  16 times smaller .",
    "it makes sense that the testing time has shown a bit less improvement , since inference only takes advantage from the incremental determinant computation but not from the incremental inverse computation . for the cifar-10 dataset , it was impractical to run the original igmn algorithm on the entire dataset , requiring us to estimate the total time , linearly projecting it from 100 data points ( note that , since the model always uses only 1 gaussian component during the entire training , the computation time per data point does not increase over time ) .",
    "it resulted in  32 days of cpu time estimated for the original algorithm against 15545s ( @xmath129 ) for the improved algorithm , a speedup above 2 orders of magnitude .",
    "testing time is not available for the original algorithm on this dataset , since the training could not be concluded .",
    "additionally , we compared a pure clustering version of the figmn algorithm on the mnist training set against batch em ( the implementation found in the weka software ) . while the figmn algorithm took @xmath130 hours to finish , using 208 gaussian components , the batch em algorithm took @xmath131 to complete a",
    "_ single iteration _ ( we set the fixed number of components to 208 too ) using 4 cpu cores .",
    "besides generally requiring more than one iteration to achieve best results , the batch algorithm required the entire dataset in ram .",
    "the figmn memory requirements were much lower .",
    "finally , both versions of the igmn algorithm with @xmath127 and @xmath128 were compared on 11 synthetic datasets generated by weka .",
    "all datasets have 1000 data points drawn from a single gaussian distribution ( 90% training , 10% testing ) and an exponentially growing number of dimensions : 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 and 1024 .",
    "this experiment was performed in order to compare the scalability of both algorithms .",
    "results for training and testing can be seen in fig .",
    "[ figures ] :         [ figures ]    as predicted , the figmn algorithm scales much better in relation to the number of input dimensions of the data .",
    "additionally , the figmn algorithm was employed for solving three different classical reinforcement learning tasks in the openai gym environment : cart - pole , mountain car and acrobot .",
    "reinforcement learning tasks consist in learning sequences of actions from trial and error on diverse environments .",
    "the mountain car task consists in controlling an underpowered car in order to reach the top of a hill .",
    "it must go up the opposite slope to gain momentum first .",
    "the agent has three actions at its disposal , accelerating it leftward , rightward , or no acceleration at all .",
    "the agent s state is made up of two features : current position and speed .",
    "the cart - pole task consists in balancing a pole above a small car which can move left or right at each timestep .",
    "four variables are available as observations : current position and speed of the cart and current angle and angular velocity of the pole .",
    "finally , the acrobot task requires a 2-joint robot to reach a certain height with the tip of its `` arm '' .",
    "torque in two directions can be exerted on the 2 joints , resulting in 4 possible actions .",
    "current angle and angular velocity of each joint are provided as observations .",
    "the figmn algorithm was compared to other 3 algorithms with high scores on openai gym : sarsa(@xmath132 ) , trust region policy optimization ( trpo ; a policy gradient method , suitable to continuous states , actions and time , but which works in batch mode and has low data - efficiency ) @xcite and dueling double dqn ( an improvement over the dqn algorithm , using two value function approximators with different update rates and generalizing between actions ; it is restricted to discrete actions ) @xcite .",
    "table [ episodes ] shows the number of episodes required for each algorithm to reach the required reward threshold for the 3 tasks .",
    "it is evident that q - learning with figmn function approximation produces better results than sarsa(@xmath132 ) with discretized states .",
    "its results are also superior to trpo s by a large margin . but",
    "duel ddqn appears as the most data - efficient algorithm in this comparison ( possibly due to its fixed topology which simplifies the learning procedure ) .",
    "we have shown how to work directly with precision matrices in the igmn algorithm , avoiding costly matrix inversions by performing rank - one updates .",
    "the determinant computations were also avoided using a similar method , effectively eliminating any source of cubic complexity from the learning algorithm . while previous works used two rank - one updates for covariance matrices and determinants , this work shows how to perform such updates with single rank - one operations .",
    "these improvements resulted in substantial speedups for high - dimensional datasets , turning the igmn into a good option for this kind of tasks .",
    "the inference operation still has cubic complexity , but we argue that it has a much smaller impact on the total runtime of the algorithm , since the number of outputs is usually much smaller than the number of inputs .",
    "this was confirmed in the experiments .",
    "reinforcement learning experiments were also useful for showing that the figmn algorithm is data - efficient , i.e. , it requires few data points in order to learn a usable model .",
    "thus , besides being computationally fast , it also learns fast .    in general",
    ", we could see that the fast igmn is a good option for supervised learning , with low runtimes , good accuracy and high data - efficiency .",
    "it should be noted that this is achieved with a single - pass through the data , making it also a valid option for data streams .",
    "heinen mr , engel pm , pinto rc . using a gaussian mixture neural network for incremental learning and robotics . in : neural networks ( ijcnn ) , the 2012 international joint conference on .",
    "ieee ; 2012 .",
    "p. 18 .",
    "damas b , santos - victor j. an online algorithm for simultaneously learning forward and inverse kinematics . in : intelligent robots and systems ( iros ) , 2012",
    "ieee / rsj international conference on .",
    "ieee ; 2012 .",
    "p. 14991506 .",
    "pinto rc , engel pm , heinen mr . echo state incremental gaussian mixture network for spatio - temporal pattern processing . in : proceedings of the ix enia - brazilian meeting on artificial intelligence , natal ( rn ) ; 2011 . .",
    "pinto rc , engel pm , heinen mr .",
    "recursive incremental gaussian mixture network for spatio - temporal pattern processing .",
    "proc 10th brazilian congr computational intelligence ( cbic ) fortaleza , ce , brazil ( nov 2011);.    flores jhf , engel pm , pinto rc . autocorrelation and partial autocorrelation functions to improve neural networks models on univariate time series forecasting . in : neural networks ( ijcnn ) , the 2012 international joint conference on .",
    "ieee ; 2012 .",
    "p. 18 .",
    "heinen mr , bazzan al , engel pm .",
    "dealing with continuous - state reinforcement learning for intelligent control of traffic signals . in : intelligent transportation systems ( itsc ) , 2011 14th international ieee conference on .",
    "ieee ; 2011 .",
    "p. 890895 .",
    "de  pontes  pereira r , engel pm , pinto rc .",
    "learning abstract behaviors with the hierarchical incremental gaussian mixture network . in : neural networks",
    "( sbrn ) , 2012 brazilian symposium on .",
    "ieee ; 2012 .",
    "p. 131135 .",
    "salmen j , schlipsing m , igel c. efficient update of the covariance matrix inverse in iterated linear discriminant analysis .",
    "pattern recognition letters .",
    "2010;31(13):1903  1907 .",
    "meta - heuristic intelligence based image processing .",
    "sherman j , morrison wj .",
    "adjustment of an inverse matrix corresponding to a change in one element of a given matrix .",
    "the annals of mathematical statistics .",
    "1950 03;21(1):124127 .",
    "available from : http://dx.doi.org/10.1214/aoms/1177729893 ."
  ],
  "abstract_text": [
    "<S> this work presents a fast and scalable algorithm for incremental learning of gaussian mixture models . by performing rank - one </S>",
    "<S> updates on its precision matrices and determinants , its asymptotic time complexity is of @xmath0 for @xmath1 data points , @xmath2 gaussian components and @xmath3 dimensions . </S>",
    "<S> the resulting algorithm can be applied to high dimensional tasks , and this is confirmed by applying it to the classification datasets mnist and cifar-10 . </S>",
    "<S> additionally , in order to show the algorithm s applicability to function approximation and control tasks , it is applied to three reinforcement learning tasks and its data - efficiency is evaluated .    </S>",
    "<S> example.eps gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore </S>"
  ]
}