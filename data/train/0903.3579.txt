{
  "article_text": [
    "in this paper we look at the classical problem of computing the cost of string ( or sequence ) alignments , particularly the longest common subsequence and edit distance problems . since this problem was originally proposed  @xcite , a multitude of algorithms have been found to compute edit distances or equivalently longest common subsequences of two input strings ( see e.g.  @xcite for an overview ) .",
    "an interesting extension to string alignment is semi - local string comparison . in this problem , we are interested in computing longest common subsequence lengths for one string and all substrings of the other string .",
    "schmidt  @xcite proposed an algorithm for computing all longest paths in grid dags which was applied to string - substring longest common subsequence ( lcs ) computation by alves et al .",
    "@xcite , who found an algorithm which runs in @xmath0 time .",
    "tiskin  @xcite developed further understanding of the algorithm and its data structures , obtaining a subquadratic time algorithm for semi - local string comparison including string - substring and prefix - suffix lcs computation .",
    "semi - local string comparison is useful as an intermediate step towards fully - local string comparison , in which all pairs of substrings of the input strings are compared .",
    "a straightforward application is e.g.  computing the lcs efficiently in a sliding window ( a slightly simpler version of this problem was studied in  @xcite ) .",
    "semi - local string comparison is also a useful tool for obtaining efficient parallel algorithms for lcs computation  @xcite .",
    "a summary of other algorithmic applications is given in  @xcite .",
    "in this paper , we develop a new interpretation of standard and semi - local lcs algorithms , based on a certain class of traditional comparison networks known as transposition networks .",
    "this approach allows us to obtain new algorithms for sparse semi - local string comparison and for comparison of highly similar and highly dissimilar strings , as well as semi - local comparison of run - length compressed strings .",
    "the remainder of this paper is structured as follows .",
    "we introduce the necessary concepts of string comparison in section  [ sec : sequencecomparison ] , and describe the transposition network method in section  [ sec : transpositionnetworks ] .",
    "we then show new algorithms for sparse semi - local string comparison in section  [ sec : sparsegdags ] , show how to compare run - length compressed strings semi - locally in section  [ sec : rle ] , and discuss comparing highly similar or highly dissimilar strings in section  [ sec : similiarity ] .",
    "let @xmath1 and @xmath2 be two strings over an alphabet @xmath3 of size @xmath4 .",
    "we distinguish between consecutive _ substrings _ of a string @xmath5 which can be obtained by removing zero or more characters from the beginning and/or the end of @xmath5 , and _ subsequences _ which can be obtained by deleting zero or more characters in any position .",
    "the _ longest common subsequence _ ( lcs ) of two strings is the longest string that is a subsequence of both input strings , its length @xmath6 ( the llcs ) is a measure for the similarity of the two strings . throughout this paper",
    "we will denote the set of integers @xmath7 by @xmath8 $ ] , and the set @xmath9 of odd half - integers by @xmath10 .",
    "we will further mark odd half - integer variables using a @xmath11 symbol .     of prefix - prefix lcs lengths , scaledwidth=80.0% ]",
    "let the _ alignment dag _ be defined by a set of vertices @xmath12 with @xmath13 $ ] and @xmath14 $ ] and edges as follows .",
    "we have horizontal and vertical edges @xmath15 and @xmath16 of weight  0 .",
    "further , we introduce diagonal edges @xmath17 of weight  1 which are present only if @xmath18.[def : alignment dag ]    longest common subsequences of a substring @xmath19 and @xmath20 correspond to longest paths in this graph from @xmath21 to @xmath22 .    we define the _ extended alignment dag _ as the infinite horizontal extension of the alignment dag , having vertices @xmath12 as above , but allowing @xmath23 $ ] , adding corresponding horizontal and vertical edges as above for all additional vertices , and further including diagonal edges @xmath24 of weight  1 for all @xmath25 and @xmath26 .",
    "[ def : extended alignment dag ]    for many applications , the lcs itself is of lesser interest than its length .",
    "looking at the llcs for different substrings , including prefixes or suffixes of the input strings , exposes not only their global similarity , but also locations of high or low similarity .",
    "for example , the standard dynamic programming lcs algorithm compares all prefixes of one string to all prefixes of the other string  @xcite and stores their lcs lengths in the dynamic programming matrix @xmath27 .",
    "semi - local string comparison  @xcite is an alternative to this standard string alignment method .",
    "solutions to the semi - local lcs problem are given by a _",
    "highest - score matrix _ which we define as follows .    in a",
    "_ highest - score matrix _ @xmath28 , each entry @xmath29 is defined as the llcs of @xmath5 and substring @xmath30 .",
    "illustration of the seaweed algorithm ]    illustration of the seaweed algorithm , height=151 ]    the definition of highest - score matrices can also be extended to include the llcs of all _ prefixes _ @xmath31 and all _ suffixes _",
    "@xmath32 , or the llcs of all suffixes @xmath33 and all prefixes @xmath34 .",
    "since the values of @xmath29 for different @xmath35 and @xmath36 are strongly correlated , it is possible to derive an implicit , space - efficient representation of matrix @xmath29 .",
    "this implicit representation of a semi - local highest - score matrix consists of a set of _",
    "critical points_.    [ def : critpoints ] the critical points of a highest - score matrix @xmath28 are defined as the set of odd half - integer pairs @xmath37 such that @xmath38 .",
    "tiskin  @xcite showed that in order to represent a highest - score matrix for two strings of lengths @xmath39 and @xmath40 , exactly @xmath41 such critical points are necessary .",
    "note that infinitely many critical points exist in the extended alignment dag .",
    "however , due to the structure of the extended alignment dag , only a _ core _ of @xmath41 critical points need to be stored .",
    "each of the remaining _ off - core _ critical points can be computed in constant time .",
    "[ thm : implicitrep ] the highest - score matrix @xmath28 can be represented implicitly using only @xmath42 space by its core critical points .",
    "we have : @xmath43 .",
    "see  @xcite .",
    "theorem  [ thm : implicitrep ] is a direct consequence of the monge properties  @xcite of highest - score matrices .",
    "this theorem is particularly useful as it was also shown possible to combine two highest - score matrices in subquadratic time using their implicit representation  @xcite in order to obtain the highest - score matrix corresponding to comparing one string and a concatenation of two other strings . in  @xcite",
    ", these methods were applied to obtaining efficient parallel algorithms for the lcs problem .",
    "the set of critical points can be obtained using the _ seaweed algorithm _",
    "( by alves et al .",
    "@xcite , based on schmidt  @xcite , adapted by tiskin  @xcite ) which computes critical points incrementally for all prefixes of the input strings .",
    "this dynamic programming procedure is graphically illustrated by tracing _",
    "seaweed curves _ that start at odd half - integer positions between two adjacent vertices @xmath44 and @xmath45 in the top row of the extended alignment dag , and end between two adjacent vertices @xmath46 and @xmath47 in the bottom row ( see figure  [ fig : seaweeds ] ) . each critical point is computed as the pair of horizontal start and end coordinates of such a seaweed curve .    given the sequence @xmath48\\}$ ] where @xmath49 is a critical point in the highest - score matrix of @xmath50 and @xmath20 , a seaweed curve is obtained by connecting the sequence of points @xmath51 @xmath52 .",
    "when drawing the ( extended ) alignment dag in the plane , its horizontal and vertical edges partition the plane into rectangular cells which , depending on the input strings , may contain a diagonal edge or not .    for every pair of characters @xmath53 and @xmath54",
    "we define a corresponding _ cell _ @xmath55 .",
    "cells corresponding to a matching pair of characters will be called _ match cells _ , cells corresponding to mismatching characters or to cells only present in the extended alignment dag will be called _",
    "mismatch cells_.    two seaweed curves enter every cell in the extended alignment dag , one at the left and one at the top .",
    "the seaweed curves proceed through the cell either downwards or rightwards . in the cell ,",
    "the directions of these curves are interchanged either if there is a match @xmath56 , or if the same pair of seaweed curves have already crossed .",
    "otherwise , their directions remain unchanged and the curves cross .",
    "the seaweed algorithm is illustrated in figure  [ fig : seaweed_algorithm ] .",
    "more efficient special case algorithms for the lcs problem can be obtained when parameterizing either by the number @xmath57 of match cells , by the length @xmath6 of the lcs , or by the edit distance .",
    "previously , high - similarity string comparison has been considered in @xcite ; all these papers give lcs algorithms for highly similar strings , running in time @xmath58 , where @xmath59 is either the edit distance between the strings ( as in @xcite ) , or a different closely related similarity measure .",
    "high - dissimilarity string comparison has been considered in @xcite ; the best running time for lcs on highly dissimilar strings is @xmath60 . a good survey of parameterized string comparison algorithms is given by  @xcite .",
    "the basis of parameterized lcs computation for dissimilar strings is to determine the lcs of two strings as a longest _ chain _ of match cells @xmath61 @xmath62 with @xmath63 and @xmath64 .",
    "we define a partial order on the set of match cells by @xmath65 iff . @xmath66 and @xmath67 ; further , we say that @xmath68 is dominated by @xmath69 . due to dilworth s lemma",
    "@xcite , the minimum number of antichains ( sets of pairwise incomparable elements ) necessary to cover a partially ordered set is equal to the length of the longest chain . therefore , the lcs of two strings can be obtained by computing a minimal antichain decomposition of the set of matches under the @xmath70 ordering .",
    "consider chains ending at a match @xmath71 .",
    "if any longest such chain has length @xmath72 , then this match is said to have _",
    "if match @xmath71 has rank @xmath72 and for all other matches @xmath73 of rank @xmath72 either @xmath74 and @xmath75 or @xmath76 and @xmath77 , then match @xmath71 is called ( @xmath72-)dominant .",
    "the set of all dominant matches completely specifies the table of prefix - prefix lcs lengths @xmath78 .",
    "let the contours of @xmath79 be formed by the rows and columns of cells through which the values of @xmath79 increase by one .",
    "a cell @xmath37 belongs to a contour in @xmath79 if @xmath80 , @xmath81 , or @xmath82 .",
    "figure  [ fig : lcsexample ]  ( b ) shows an example .",
    "all match cells belonging to the same contour form an antichain in a minimal antichain decomposition , and each contour is specified completely by the dominant matches on it .",
    "since parameterized algorithms process the input match - by - match instead of computing the entire prefix - prefix lcs score matrix , it is necessary to pre - process the input strings to obtain lists of match cells .",
    "different approaches exist for this , depending on the assumptions that can be made about the alphabet .",
    "generally , it is necessary to allow less - than / greater - than comparisons in addition to testing for equality ( otherwise , @xmath83 was shown to be a lower bound  @xcite ) .",
    "based on this assumption , we can obtain a set of match lists which give for every character @xmath84 in @xmath5 the positions @xmath35 where @xmath85 in @xmath86 time .",
    "these lists usually allow queries for increasing or decreasing values of @xmath35 and are called occurrence lists or match lists accordingly .",
    "the lists are obtained by determining the inverse sorting permutation for @xmath20 ( i.e.  a permutation that transforms a sequence which contains all characters from @xmath20 in sorted order into @xmath20 ) . for every character @xmath84 in @xmath5",
    ", we can find the head of a list of match positions in time @xmath87 by binary search . for small alphabets ,",
    "it is possible to pre - process the input in time @xmath88 to obtain a similar representation ( see @xcite for discussion ) .",
    "we will denote the result of this preprocessing as follows .    the functions @xmath89 \\cup { \\infty } $ ] for @xmath90 $ ] specify the match positions .",
    "we have :    * @xmath91 , * @xmath92 or @xmath93 for all @xmath94 $ ] .",
    "this notation allows storing the match lists using @xmath42 space .",
    "we can obtain these functions for arbitrary ordered alphabets in time @xmath86 by sorting one of the input strings and then using binary search to create the match lists . for small alphabets of size",
    "@xmath95 , the sorting permutation can be determined in time @xmath88 by counting character frequencies for all characters contained in @xmath20 .",
    "after this pre - processing step , we can determine @xmath96 in @xmath97 time using @xmath42 storage .",
    "comparison networks ( see e.g.  @xcite ) are a traditional method for studying oblivious algorithms for sorting sequences of numbers .",
    "comparison network _ has @xmath40 inputs and @xmath40 outputs , which are connected by an arbitrary number of _",
    "a comparator has two inputs and two outputs .",
    "it compares the input values and returns the larger value at a prescribed output , and the smaller value at the other output .",
    "we will draw comparison networks as @xmath40 wires , where pairs of wires may be connected by comparators that operate on the values passing through the wires .",
    "comparators are usually grouped into a sequence of @xmath72 _ stages _ , where each wire is connected to at most one comparator in a single stage .",
    "a comparison network is called _ transposition network _ if all comparators only connect adjacent wires .",
    "transposition networks allow for another interpretation of the seaweed algorithm .",
    "as shown in figure  [ fig : mergingnetwork ] , every mismatch cell behaves like a comparator on the starting points of the seaweeds that enter the cell from the left and the top .",
    "the larger value is returned on the right output , and the smaller value is returned on the bottom output . for a match cell , the input values",
    "are not compared but just translated top to right and left to bottom .",
    "therefore , we can define a transposition network for every problem instance as follows .",
    "the network @xmath98 has @xmath41 diagonal wires .",
    "every mismatch cell @xmath37 corresponds to a comparator in stage @xmath99 connecting wires @xmath100 and @xmath101 ( see figure  [ fig : mergingnetwork ] ) .",
    "match cells do not contain comparators .",
    "as comparators in the network correspond to cells in the alignment dag , we choose the convention of drawing the network wires top left to bottom right .",
    "values moving through a cell or comparator can therefore move either down or to the right .",
    "the network @xmath98 realizes the seaweed algorithm .",
    "the inputs are originally in inversely ( in relation to the direction of the comparators ) sorted order and trace the seaweed curves on their paths through the transposition network .",
    "note that the direction of the comparators can be determined arbitrarily , as long as it is opposite to the sorting of the input sequence .",
    "another degree of freedom when defining transposition networks lies in the behaviour of comparators for equal inputs .",
    "even though this does not affect the network output , changing the convention of swapping or not swapping equal values can simplify specification of non - oblivious algorithms for computing the output values .    in order to solve the global or semi - local lcs problem for strings @xmath5 and @xmath20 using the transposition network method , we have to define appropriate input values for @xmath98 . in order to obtain the full set of critical points ,",
    "the inputs are set to the seaweed starting points : input @xmath102 is initialized with @xmath103 , @xmath104 .",
    "let the vector @xmath105 denote the output of the network .",
    "if all comparators return the larger input on the bottom output , and the smaller input on the right output , the pairs @xmath106 with @xmath107 correspond to the core critical points of the corresponding highest - score matrix .",
    "since there are @xmath108 comparators in the transposition network , the resulting algorithm runs in time @xmath108 .    using the transposition network method",
    ", we can see the connection between semi - local string comparison and existing lcs algorithms is the fact that both approaches compute lcs scores incrementally for prefixes of the input strings : the standard lcs dynamic programming approach computes lcs lengths , and the seaweed algorithm computes implicit highest score matrices for all prefixes of the input strings .",
    "when looking at this relationship in more detail , it becomes clear that standard lcs algorithms can be obtained by the transposition network method using input values of only zero or one .",
    "a first direct consequence are bit - parallel lcs algorithms  @xcite , which can be obtained by computing the output of the transposition network cell - column by cell - column using bit - vector boolean operations and bit - vector addition . in the remainder of this paper",
    "we will show further examples where existing algorithms for comparing two strings globally can be derived from transposition networks , and discuss generalizing them to semi - local string comparison .",
    "we now consider _ sparse string comparison _ , i.e.  string comparison parameterized by the number of matches @xmath57 in the alignment dag .",
    "hunt and szymanski  @xcite proposed an algorithm for sparse string comparison that computes the lcs of two input strings in @xmath109 time .",
    "an extreme case of this is the comparison of permutation strings of length @xmath40 over the alphabet @xmath110 $ ] . in this case , only @xmath40 match cells exist .",
    "tiskin  @xcite gave an @xmath111 algorithm for semi - local comparison of permutation strings .",
    "since in sparse string comparison the alignment dag contains few matches , large rectangular areas of the transposition network have full sets of comparators .",
    "these areas will be denoted as follows .",
    "let network @xmath112 be defined as an @xmath113 network which corresponds to a problem instance with no matches .",
    "it therefore contains a full set of @xmath114 comparators .",
    "we now give a more general sparse semi - local string comparison algorithm parameterized by the number of matches .",
    "we will first show a non - oblivious algorithm to compute the output of @xmath115 networks efficiently , and then propose a technique for evaluating a @xmath113 network by partitioning it into smaller @xmath115 networks .",
    "consider an @xmath116 rectangular area in the alignment dag with only mismatch cells , and the corresponding @xmath117 network .",
    "such an area occurs whenever two substrings over disjoint character sets are compared .",
    "the network consists of a full set of @xmath118 comparators and @xmath119 wires .",
    "if the first @xmath120 and the following @xmath121 wires are initialized with two pre - sorted sequences of numbers , this network works as a merging network  @xcite .",
    "the problem of merging pre - sorted sequences can be solved non - obliviously in time @xmath122 . however , as the inputs to the @xmath115 network are not necessarily pre - sorted , this is not sufficient .",
    "[ thm : diamondnet ] it is possible to compute the outputs of the @xmath115 network non - obliviously in time @xmath123 if the inputs are in arbitrary order .",
    "additionally , if the sorting permutation of the inputs is known ( but the inputs are still in arbitrary order ) , the problem can be solved in @xmath122 time , as the factor of @xmath124 only comes from the initial sorting step .    to non - obliviously",
    "compute the output of @xmath125 , consider the path that the largest input takes through the network .",
    "if the largest input enters the network on wire @xmath36 , all comparators it passes will return it as the larger element , which means that it will reach the leftmost output possible .",
    "we then proceed through the remaining inputs in descending order , determining for every input the leftmost output it can reach , considering that some outputs have already been occupied by larger values . any current value that enters the comparison network on a wire @xmath36 that is less than @xmath120 wires ahead of the first free output",
    "will be translated to the first ( leftmost ) available output .",
    "if the current value enters the network more than @xmath120 wires to the right of the first available output , it can only pass through @xmath120 comparators and will therefore reach output @xmath126 .",
    "the free outputs are indicated by a boolean array @xmath127 , where occupied outputs are marked with a value of true .",
    "since we proceed through the input values in descending order , this yields the same output as direct evaluation of the transposition network .",
    "the entire algorithm is shown in algorithm  [ alg : diamondnet_solve_2 ] .",
    "@xmath128    input : @xmath129 , \\ldots , i[m'+n']$ ] output : @xmath130 , \\ldots , o[m'+n']$ ] let @xmath131 > i[l[2 ] ] > \\ldots > i[l[m'+n']]$ ] @xmath132 for @xmath133)$ ] do @xmath134 \\leftarrow $ ] false @xmath135 @xmath136 @xmath137 for @xmath138 @xmath139 \\text { is the next largest element}$ ] if @xmath140 < \\beta + m'$ ] then @xmath141 @xmath142 \\leftarrow i[l[k]]$ ] @xmath143 @xmath144 = $ ] true @xmath145 while @xmath146 $ ] ) do @xmath147 else @xmath148 @xmath149 - m ' ] \\leftarrow i[l[k]]$ ] @xmath143 @xmath150 - m ' ] = $ ] true @xmath145 end if end while    using algorithm  [ alg : diamondnet_solve_2 ] , we obtain an improved algorithm for sparse semi - local comparison . for simplicity assume that both strings are of length @xmath40 and ( w.l.o.g . ) that @xmath40 is a power of  2 .",
    "after pre - processing the input strings for obtaining match lists , the problem of semi - local string comparison can be solved in @xmath151 time .",
    "we first find the sorting permutations of the input strings .",
    "this is possible in time @xmath152 , similar to obtaining @xmath153 in section  [ sec : sequencecomparison ] .",
    "after this pre - processing , we partition the alignment dag into blocks using a recursive quadtree scheme . consider processing such a block of size @xmath154 .",
    "let this block correspond to comparing substrings @xmath155 and @xmath156 .",
    "as an input for each such block , we have the sorting permutations of the two corresponding substrings , the input values for the transposition network corresponding to the block , and also the sorting permutation for these input values . for each block , we obtain the output values of its transposition network and their sorting permutation as follows .    for a @xmath154 block , we can count the number of matches in it in time @xmath157 by linear search in the sorting permutations of the corresponding substrings .",
    "whenever we find a block that does not contain any matches , we stop partitioning and use algorithm  [ alg : diamondnet_solve_2 ] to compute the outputs of the corresponding comparison network .",
    "otherwise , we continue to partition until we obtain a @xmath158 block that only consists of a single match .",
    "a @xmath158 leaf block consisting of a single match can be processed trivially in constant time . due to theorem  [ thm : diamondnet ]",
    ", we can compute the outputs for a @xmath154 mismatch block in @xmath157 time when the sorting permutation is known for the inputs .",
    "the sorting permutation for the root block of the quadtree is known , since the root of the quadtree corresponds to the full alignment dag , and the inputs to its transposition network form a sequence sorted in reverse .",
    "for all other blocks , we keep track of the sorting permutation of both its input and output elements . for every output we can trace the input it came from before executing algorithm  [ alg : diamondnet_solve_2 ] and therefore know the permutation that was performed by the transposition network within the block . knowing this permutation and the sorting permutation of the inputs allows to establish the sorting permutation of the outputs in time @xmath157 .    to summarize , given the input values and their sorting permutation for every leaf block of the quadtree recursion",
    ", we can compute the output values and their sorting permutation in time @xmath157 .",
    "all non - leaf blocks are partitioned into four sub - blocks of size @xmath159 .",
    "the inputs and their sorting permutation are split and used to recursively process the sub - blocks .",
    "we can then establish the sorting permutation of the outputs for the entire block in linear time by merging . to compute the outputs of any intermediate block we therefore need time @xmath157 in addition to the time necessary for recursively processing the sub - blocks .",
    "consider the top @xmath160 levels of the quadtree .",
    "in each subsequent level , the number of blocks increases by at most a factor of four , and the block size decreases by a factor of two .",
    "therefore , this part of the quadtree is dominated by level @xmath160 which contains at most @xmath57 blocks , each of size @xmath161 .",
    "the total work required on this part of the tree is therefore @xmath162 .",
    "the remaining levels of the quadtree can each have at most @xmath57 blocks that still contain matches .",
    "the block size in each level still decreases by a factor of two . therefore , this part of the quadtree is also dominated by level @xmath160 and requires the same asymptotic amount of work .",
    "the overall time for the algorithm is therefore bounded by @xmath163 the resulting algorithm has running time @xmath151 , and thus provides a smooth transition between the dense case ( @xmath164 , running time @xmath0 ) and the permutation case ( @xmath165 , running time @xmath111 ) . @xmath128",
    "another straightforward application of algorithm  [ alg : diamondnet_solve_2 ] is comparing run - length compressed strings  @xcite . in this compression method ,",
    "a run of repeating characters is encoded by a single character together with the number of repetitions .",
    "a run - length encoded string @xmath166 consists of @xmath167 character runs @xmath168 of lengths @xmath169 .",
    "the length of the full string is therefore @xmath170 . when constructing the alignment dag for comparing two run - length compressed strings @xmath171 and @xmath172 , rectangular areas without matches occur when character runs in @xmath173 and @xmath174 mismatch .",
    "analogously , large rectangular areas with containing only match cells occur if the characters do match ( see figure  [ fig : rle_gdag ] ) . using the comparison network method and algorithm  [ alg : diamondnet_solve_2 ] ,",
    "these rectangular areas can be processed in cost proportional to their perimeter .",
    "given two input strings with uncompressed lengths @xmath39 and @xmath40 , and compressed lengths @xmath167 and @xmath175 , this method results in an algorithm for semi - local comparison which has cost @xmath176 , j\\in [ 1:\\overline{n } ] } o(|x_i|+|y_j| ) = o(\\overline{m}n + m\\overline{n})$ ] .",
    "this is as good as the result from  @xcite , additionally solving the more general problem of semi - local string comparison of run - length compressed strings .",
    "in section  [ sec : sparsegdags ] we described an efficient algorithm for semi - local string comparison , parameterized by the overall number of matches .",
    "we now describe an application of the transposition network method to designing algorithms that are parameterized by the lcs length @xmath6 of the input strings or their lcs distance @xmath177 .",
    "such parametrization provides efficient algorithms when the corresponding parameter is low , i.e.  when the strings are highly dissimilar or highly similar .    in  @xcite ,",
    "matches are processed row by row to establish which antichain they belong to .",
    "apostolico and guerra improved this algorithm by avoiding the need to consider non - dominant matches  @xcite ( see section  [ sec : sequencecomparison ] ) , and changing the order in which the match cells are processed .",
    "this allows to obtain an algorithm that is parameterized by the length of the lcs .",
    "further , there have been various extensions to this approach , which improve the running time by either using different data structures  @xcite or narrowing the area in which to search for dominant matches hence giving algorithms which are efficient both when the lcs of the two strings is long or short  @xcite . in this paper",
    ", we will show how the transposition network method can be used to match these algorithms for global lcs computation . for semi - local alignment",
    ", we achieve a running time of @xmath178 , which is efficient for dissimilar strings .",
    "we will now show the connection between the antichain decomposition of the set of match cells and the transposition network method .",
    "consider an @xmath113 network with the following input values : the first @xmath39 wires ( i.e.  the inputs on left hand side of the alignment dag ) are initialized with ones , and the following @xmath40 wires ( i.e.  the inputs at the top of the alignment dag ) are filled with zeros . on all comparators , smaller values are returned at the bottom output .",
    "we will refer to this specific transposition network setup as _",
    "@xmath179 with 0/1 inputs_. using only zeros and ones as inputs to @xmath98 corresponds to tracing seaweeds anonymously , only distinguishing between those seaweeds that start at the top and those seaweeds that start at the left .",
    "the 0 - 1 transposition network approach allows to understand previous results for parameterized lcs computation in terms of transposition networks , and helps to extend some of these to semi - local string comparison .",
    "[ cor:0 - 1 net output ] in @xmath98 with 0/1 inputs as described above , let @xmath6 be the number of ones reaching output wires below @xmath180 ( i.e.  the bottom of the alignment dag ) .",
    "this number is equal to the number of zeros reaching an output wire above @xmath39 ( i.e.  the right side of the alignment dag ) , and @xmath181 .    from theorem  [ thm : implicitrep ] , we know that @xmath182 , where @xmath183 is the number of seaweeds that start at the top and end at the bottom of the alignment dag .",
    "the number of zeros ending up at the bottom is therefore equal to  @xmath183 , and the number of ones ending up at the bottom is equal to @xmath184 . since the transposition network outputs a permutation of the input , and since we have @xmath40 input zeros , @xmath185  zeros must end up at the right .",
    "@xmath128    we will now look at the behaviour of @xmath98 with 0/1 inputs in more detail . in order to be able to trace paths of individual values",
    ", we must specify the behaviour of the comparators for equal input values ( note that changing this specification does not change the output of @xmath98 ) .",
    "assume that comparators in @xmath98 swap their input values if these are equal .",
    "if the alignment dag contains only mismatch cells and therefore a full set of comparators , all ones move from the left to the right , and all zeros move from the top to the bottom . when introducing a match cell and hence removing a comparator ,",
    "the zero that enters the match cell at the top is translated to the right , and the value of one entering the match cell at the left is translated to the bottom .",
    "we trace these two values further : as identical values are swapped by convention , both the one ( and equally the zero ) will not change direction of movement and be passed on vertically ( horizontally in case of the zero ) through all comparators .",
    "we will refer to ones which move downwards and to zeros which move to the right as _",
    "stray values only change direction again when they either encounter a match cell or another stray value .",
    "if two stray values enter the same cell , they leave this cell in the original directions , the one moving rightwards , and the zero moving downwards .",
    "this happens independently of whether this cell contains a match : in a match cell , no comparison is performed , the stray zero is returned at the bottom and the stray one is returned at the right . in a mismatch cell ,",
    "the zero is also returned at the bottom since it is the smaller value .",
    "therefore , two stray values always return to their original direction of movement when meeting in the same cell .",
    "another observation is that any cell which has exactly one stray input value must have equal inputs .",
    "if such a cell is a match cell , the stray input value returns to its original direction of movement , and the other input becomes stray . if the cell does not contain a match , the inputs are exchanged by convention , and the stray value remains stray .",
    "to summarize , stray values caused by a match cell will start a row ( stray zeros ) or column ( stray ones ) of cells which output stray values . this row or column only ends when meeting another column or row of cells which output stray values .",
    "figure  [ fig : zeroone_example ] shows an example of the @xmath98 with 0/1 inputs for the problem instance shown in figure  [ fig : lcsexample ] on page  .",
    "it seems intuitive from this figure that the stray zeros and ones trace contours in @xmath79 .",
    "[ thm : straycellsvscontours ] a cell belongs to a contour in the matrix of prefix - prefix lcs lengths @xmath79 iff it has at least one stray value as an input or output .",
    "this follows from corollary  [ cor:0 - 1 net output ] by induction on the number of contours .",
    "if @xmath79 has no contours , no match cells can exist .",
    "if there is exactly one contour in @xmath79 , all match cells must belong to this contour , and the contour splits the set of cells into two parts of mismatch cells .",
    "consider the set of mismatch cells to the top / left of the contour .",
    "all cells in this set have zeros as their top input and ones as their left input since these are either the input values to the transposition network , or have been translated through the previous mismatch cells as shown in case ( e ) of figure  [ fig : matchcategory ] .",
    "all dominant matches on the contour must have a zero as their top input and a one as their left input as well , since they must be at the right and below a case ( e ) mismatch cell , or equivalently at the top or left of the alignment dag .",
    "dominant match cells output a stray zero on the right and a stray one on the bottom ( see case ( d ) in figure  [ fig : matchcategory ] ) .",
    "any cell that has a stray zero as its left input and a zero as its top input must be to the right of a match .",
    "as there is only one contour the cell can not be below another match and therefore @xmath79 will increase vertically in this cell since the prefix - prefix lcs can be extended by the first match to the left .",
    "symmetrically , this is true for any cell with a stray and a none - stray one as its inputs ( see cases ( a ) and ( b ) in figure  [ fig : matchcategory ] ) . in the only remaining case , two stray values meet in the same cell @xmath37 ( case ( c ) in figure  [ fig : matchcategory ] ) . in this case , the prefix - prefix lcs could either be extended by using the matches above @xmath37 or by using the matches to the left of @xmath37 , but not by using both since they are incomparable under the @xmath70 ordering ( and no path containing one of each of those matches exists in the alignment dag ) .",
    "now consider the cells immediately to the right or below the contour .",
    "these cells can not be to the right or below dominant matches ( otherwise they would belong to the contour ) .        therefore , these cells must all have non - stray inputs ( i.e.  a zero at the top input and a one at the left input ) , since cells on the horizontal contour output zeros on the bottom , cells on the vertical contour output ones at the right , and contour knees output a zero on the bottom and a one at the right output .",
    "as all the cells immediately neighbouring the contour to the right or below must be mismatch cells ( only one contour exists @xmath186 all match cells are on it ) , they all belong to case ( e ) in figure  [ fig : matchcategory ] and in consequence all cells below or to the right of them as well .",
    "therefore , theorem  [ thm : straycellsvscontours ] is true in the case where only one contour exists .",
    "furthermore , all additional contours must either have case ( e ) cells on top and to their left , or border directly on another contour .",
    "cell contours output non - stray values on the right / the bottom if they have non - stray inputs .",
    "therefore , theorem  [ thm : straycellsvscontours ] is also true for more than one contour . @xmath128",
    "the resulting algorithm is for computing output of @xmath98 with 0/1 inputs is equivalent to  @xcite , giving a running time of @xmath187 which can be improved to @xmath188 using the finger searching technique  @xcite .",
    "consider the problem of comparing two strings that are highly similar .",
    "myers  @xcite proposed an algorithm to compare strings in time @xmath58 , where @xmath59 is the edit distance between the strings . the idea behind this algorithm is to incrementally extend only the longest paths in the alignment dag until the lcs is found .",
    "a similar algorithm can be obtained by using 0 - 1 transposition networks as follows .",
    "if the two input strings are identical , no comparators exist on the main diagonal of alignment dag cells , i.e.  between transposition network wires @xmath39 and @xmath180 .",
    "this means that no ones can get to the right hand side , and no zeros can get to the bottom of the alignment dag .",
    "we can look at this as two streams of zeros and ones , and do not need to evaluate comparisons within a single stream of zeros or ones .",
    "the only comparators which can possibly swap inputs are the ones between streams .",
    "if a comparator occurs between two streams , the inputs will only be swapped if the zero is input from the top , i.e.  we can restrict our attention to the upper boundaries of streams of ones .",
    "figure  [ fig : highsim ] shows an example .",
    "the comparators drawn in black are those between streams of zeros and ones which must swap their inputs .",
    "let a _ 1 - 0 boundary _ in stage @xmath189 of @xmath98 with 0/1 inputs be defined as any location in this stage where two adjacent wires @xmath190 and @xmath191 carry values one and zero respectively .    the number of 1 - 0 boundaries in any stage of the transposition network is dominated by @xmath192.[cor:1 - 0boundaries ]    by induction : assume @xmath193 .",
    "the transposition network has two wires which are initialized with a zero and a one .",
    "therefore , the number of 1 - 0 boundaries must be less or equal than @xmath194 .",
    "the lcs distance @xmath72 can be @xmath195 or @xmath194 .",
    "increasing @xmath39 or @xmath40 by one adds another row or column of comparators to the transposition network .",
    "consider the case of adding a column of comparators ( i.e.  increasing @xmath40 by one ) .",
    "each @xmath194 which is output at the right hand side can only cause one 1 - 0 boundary .",
    "furthermore , ones do not move downwards in comparisons . therefore , a new 1 - 0 boundary can only be created if a value of @xmath194 from the left hand side reaches the right hand side , which means that the number of 1 - 0 boundaries can not increase by one in this case without also increasing @xmath72 by one .",
    "however , @xmath72 can not increase by more than one , since maximally a single value of @xmath194 reaches the right hand side .",
    "symmetrically , when increasing @xmath39 by one , we add a row of comparators at the bottom",
    ". if we have @xmath72 zeros at the bottom , each of these zeros can only be part of a single 1 - 0 boundary .",
    "we can only gain a single @xmath195 on the bottom by increasing @xmath39 by one , in which case also @xmath72 increases .",
    "therefore @xmath196 always dominates the number of 1 - 0 boundaries .",
    "@xmath128    using this insight , the llcs of two strings @xmath5 and @xmath20 with @xmath197 can be computed in time @xmath198 .",
    "this is done by tracing the intersections of the 1 - 0 boundaries with the @xmath199 antidiagonals of the alignment dag , as this is the only place where change can occur . by corollary  [ cor:1 - 0boundaries ] , we know a bound for the number of 1 - 0 boundaries .",
    "at each intersection of a 1 - 0 boundary with an antidiagonal , the corresponding characters in @xmath5 and @xmath20 must be compared to check whether a comparator exists .",
    "this can be done in constant time , and since there are @xmath199 antidiagonals we get the claimed running time . note that this algorithm does not require any pre - processing to obtain match lists .",
    "[ cor : dominant on 0 - 1 boundary ] all dominant matches must be on a 1 - 0 boundary in the transposition network .",
    "this follows immediately from theorem  [ thm : straycellsvscontours ] .",
    "corollary  [ cor : dominant on 0 - 1 boundary ] allows to narrow down the area in which to search for dominant matches , and can be used to extend algorithm  @xcite to achieve running time @xmath200 , similarly to  @xcite .",
    "the implicit highest - score matrix for comparing two strings of length @xmath40 can be computed in time @xmath178 .    using the 0 - 1 transposition network",
    ", we are able to determine for every match cell whether it is dominant or non - dominant , as well as for every mismatch cell whether it is part of a contour . looking at this in the more general setting of semi - local string comparison where we need to trace all seaweeds individually , we can still see that non - trivial comparisons between seaweeds can only occur when the cell is actually part of a contour .",
    "cells outside the contours are always mismatch cells which compare an input originating at the left hand side of the alignment dag to an input originating at the top of the alignment dag",
    ". therefore all the comparators in these cells can be replaced by swap operations ( i.e.  they contain seaweed crossings ) .    given all dominant matches on a contour and the values on all transposition network wires before they intersect the contour , we can compute the values on all wires of transposition network after the intersection in time which is linear in the length of the contour . as all comparators between contours perform swap operations , we can also compute the permutation of values performed between two contours in time linear in the length of the longer contour .",
    "it is possible to compute the set of all @xmath72-dominant matches with @xmath201 $ ] in @xmath178 time .",
    "we can use algorithm  @xcite for this . knowing the dominant matches in every antichain",
    ", we can trace its complete contour in time linear in its length .",
    "no contour can have length @xmath190 longer than @xmath202 , and there are exactly @xmath203 contours .",
    "further , we can obtain the inputs and outputs of all cells in a contour of length @xmath190 in time @xmath204 with @xmath205 .",
    "therefore , the worst case running time of our algorithm for semi - local string comparison is bounded by @xmath178",
    "in this paper , we have presented a new method of solving the semi - local string comparison problem using transposition networks .",
    "this method provides a unified view of different string comparison algorithms , and allows to obtain efficient algorithms for global string comparison which have the same complexity as the best known algorithms .",
    "furthermore , we have obtained new algorithms for sparse semi - local string comparison , high similarity and dissimilarity string comparison , as well as semi - local comparison of run - length compressed strings . in a separate paper",
    ", we will show that it is possible to implement the algorithms for semi - local string comparison efficiently for an application to lcs - filtered dot - plots  @xcite .",
    "we conclude that the transposition network method is a very general and flexible way of understanding and improving different string comparison algorithms .",
    "tiskin , a. : efficient representation and parallel computation of string - substring longest common subsequences . in : proceedings of parco .",
    "volume  33 of nic series .",
    ", john von neumann institute for computing ( 2005 ) 827834                            crochemore , m. , iliopoulos , c.s .",
    ", pinzon , y.j . , reid , j.f . : a fast and practical bit - vector algorithm for the longest common subsequence problem .",
    "information processing letters * 80*(6 ) ( december 2001 ) 279285"
  ],
  "abstract_text": [
    "<S> computing string or sequence alignments is a classical me - thod of comparing strings and has applications in many areas of computing , such as signal processing and bioinformatics . </S>",
    "<S> semi - local string alignment is a recent generalisation of this method , in which the alignment of a given string and all substrings of another string are computed simultaneously at no additional asymptotic cost . in this paper , we show that there is a close connection between semi - local string alignment and a certain class of traditional comparison networks known as transposition networks . the transposition network approach can be used to represent different string comparison algorithms in a unified form , and in some cases provides generalisations or improvements on existing algorithms . </S>",
    "<S> this approach allows us to obtain new algorithms for sparse semi - local string comparison and for comparison of highly similar and highly dissimilar strings , as well as of run - length compressed strings . </S>",
    "<S> we conclude that the transposition network method is a very general and flexible way of understanding and improving different string comparison algorithms , as well as their efficient implementation . </S>"
  ]
}