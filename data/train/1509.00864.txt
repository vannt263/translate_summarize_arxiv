{
  "article_text": [
    "fermat s little theorem states that if @xmath7 is prime and @xmath8 , then @xmath9 a composite number for which this congruence holds is called a _",
    "pseudoprime _ to the base @xmath10 .",
    "we can restate fermat s little theorem by algebraically factoring ( repeatedly ) the difference of squares that arises in @xmath11 . in which case , if @xmath7 is an odd prime , writing @xmath12 with @xmath13 odd , and @xmath8 , then either @xmath14 or @xmath15 for some integer @xmath16 with @xmath17 .",
    "if a composite @xmath7 satisfies the above , we call @xmath7 a _ strong pseudoprime _ to the base @xmath10 . unlike carmichael numbers , which are pseudoprimes to all bases , there",
    "do not exist composite numbers that are strong pseudoprimes to all bases .",
    "this fact forms the basis of the miller - rabin probabilistic primality test @xcite .",
    "define @xmath0 to be the smallest integer that is a strong pseudoprime to the first @xmath1 prime bases .",
    "( see a014233 at ` oeis.org ` . )",
    "the problem of finding strong pseudoprimes has a long history .",
    "pomerance , selfridge , and wagstaff @xcite computed @xmath0 for @xmath18 and @xmath19 .",
    "jaeschke @xcite computed @xmath0 for @xmath20 and @xmath21 . by looking at a narrow class of numbers ,",
    "zhang @xcite gave upper bounds on @xmath0 for @xmath22 .",
    "recently , jian and deng @xcite verified some of zhang s conjectures and computed @xmath0 for @xmath23 and @xmath24 .",
    "we continue in this effort with the following .",
    "@xmath25    we also verified jian and deng s work in finding @xmath26 .",
    "note that the erh implies @xmath27 , if @xmath0 exists @xcite .",
    "the proof of our theorem relies primarily on running an improved algorithm for finding strong pseudoprimes :    [ thm : runtime ] given a bound @xmath28 and an integer @xmath29 that grows with @xmath30 , there is an algorithm to find all integers @xmath31 that are products of exactly two primes and are strong pseudoprimes to the first @xmath1 prime bases using at most @xmath6 arithmetic operations .",
    "we have a heuristic argument extending this @xmath6 running time bound to integers with an arbitrary number of prime divisors .",
    "this result is an improvement over a heuristic @xmath32 from @xcite .",
    "our algorithm uses the work of jian and deng as a starting point , and our specific improvements are these :    * we applied the results in bleichenbacher s thesis @xcite to speed the computation of gcds .",
    "[ sec : gcd ] .",
    "* we applied the space - saving sieve @xcite which enabled us to sieve using full prime signature information .",
    "[ sec : sigsieve ] .",
    "* we used a simple table of linked - lists indexed by a hash function based on prime signatures .",
    "we used this to store small primes by signature for very fast lookup . see  [ sec : datastructure ] .",
    "* when it made sense to do so , we parallelized our code and made use of _ big dawg _ , butler university s cluster supercomputer .",
    "our changes imply that adding more prime bases for a pseudoprime search ( that is , making @xmath1 larger ) speeds up the algorithm .",
    "the rest of this paper is organized as follows .",
    "section 2 contains a description of the algorithm and its theoretical underpinnings .",
    "section 3 contains the proof of the running time .",
    "section 4 contains implementation details .",
    "to find all @xmath5 that are strong pseudoprimes to the first @xmath1 prime bases , we use some well - known conditions to limit how many such integers @xmath7 we need to check .",
    "this is outlined in the first subsection below .",
    "we construct all possibilities by generating @xmath7 in factored form , @xmath33 , where @xmath34 is the number of prime divisors of @xmath7 , and @xmath35 .",
    "it turns out that @xmath34 can not be too big ; we only had to test up to @xmath36 .",
    "so we wrote separate programs for each possible @xmath34 and the case @xmath37 dominates the running time .",
    "let @xmath38 .",
    "our algorithms generate all candidate @xmath16 values , and then for each @xmath16 search for possible primes @xmath39 to match with @xmath16 , to form a strong pseudoprime candidate @xmath40 .    for the bound @xmath30 , we choose a cutoff value @xmath41 . for @xmath42",
    ", we use a gcd computation to search for possible primes @xmath39 , if they exist . for @xmath43",
    ", we use sieving to find possible primes @xmath39 .",
    "again , we use separate programs for gcds and for sieving .    once each @xmath7 is formed , we perform a strong pseudoprime test for the first @xmath1 prime bases to see if we have , in fact , found what we are looking for .      for the purposes of this paper , it suffices to check square - free odd integers .",
    "a computation by dorais and klyve @xcite shows that a pseudoprime to the bases 2 and 3 must be square - free if it is less than @xmath44 . since the values zhang conjectured as candidates for @xmath3 and @xmath4 are less than @xmath45 , we restrict our search to square - free numbers .    in general ,",
    "to rule out integers divisible by squares , it suffices to find all wieferich primes @xmath46 , and for each such prime , perform appropriate tests .",
    "this can easily be done in well under @xmath47 time .",
    "see  3.6.1 in @xcite .",
    "to each prime @xmath48 we associate a vector called its _",
    "signature_. let @xmath49 for @xmath50 distinct positive integers .",
    "then the signature of @xmath48 is @xmath51 where @xmath52 denotes valuation with respect to @xmath53 and @xmath54 is the multiplicative order of @xmath10 modulo @xmath48 .",
    "let @xmath48 be the prime @xmath55 .",
    "then @xmath56 if @xmath57 .    let @xmath58 with @xmath34 distinct primes , @xmath49 with different integers such that @xmath59 for all @xmath60 and @xmath61 .",
    "then @xmath7 is a strong pseudoprime to each base in @xmath62 if and only if n is a pseudoprime to each base in @xmath62 and @xmath63 .    if @xmath64 , then this theorem greatly limits the number of candidate @xmath16 values we need to check . in the case",
    "@xmath37 the initial sub - product @xmath16 is just a single prime , so this theorem does not , at first , appear to help .",
    "however , it does play a role in sieving for @xmath39 . for the rest of this paper ,",
    "we use @xmath62 as the vector containing the first @xmath65 or @xmath66 prime numbers .      as",
    "above , let @xmath67 .",
    "we explain in this subsection how to find all possible choices for @xmath39 to form @xmath40 as a strong pseudoprime to the first @xmath1 prime bases using a simple gcd computation .",
    "let @xmath68 be one of the @xmath50 from @xmath62 .",
    "the pseudoprimality condition @xmath69 implies that    @xmath70    i.e. , that @xmath39 divides @xmath71 . considering multiple bases",
    ", we know that @xmath39 must divide    @xmath72    however , since we are concerned with strong pseudoprimes , we can consider only the relevant algebraic factor of @xmath73 .",
    "following bleichenbacher s notation @xcite , let @xmath74 for @xmath75 odd and    @xmath76    a necessary condition for an integer @xmath7 of the from @xmath77 , for a given @xmath16 with @xmath39 prime , to be a strong pseudprime to the bases @xmath78 is that @xmath39 divide @xmath79 .",
    "this theorem allows us to construct the product of all possible @xmath39 values for a given @xmath16 by computing a gcd . to carry this out",
    ", we figure out which of the @xmath80 values would be the smallest , compute that , and then compute the next smallest @xmath81 value modulo the smallest , perform a gcd , and repeat until we get an answer @xmath82 , or use up all the @xmath50 base values .",
    "let @xmath83 , which is prime .",
    "we have @xmath84 in this case , we would begin the computations with @xmath85 since it is the smallest .",
    "we then compute @xmath86 .",
    "this tells us that any @xmath7 of the form @xmath87 is not a strong pseudoprime to the vector @xmath88 .",
    "these computations start off easy as @xmath16 is small and progressively get harder ( in an essentially linear fashion ) as @xmath16 grows .",
    "as a practical matter , these computations only need to be done once . as an example , @xcite found @xmath89 to be a strong pseudoprime to the first eight prime bases . when considering @xmath90 , they sieved ( which we explain in the next section ) for @xmath91 .",
    "it is reasonable to ask whether there is a larger prime that can be paired with @xmath92 that would form a strong pseudoprime to eight bases . in our computation",
    "we check by computing a gcd to answer  no . \"",
    "using gcds to rule out @xmath16 values integers @xmath34 and @xmath16 , where @xmath34 is the number of prime divisors and @xmath16 is the product of @xmath93 primes with matching signature , and the base vector @xmath62 containing the @xmath1 smallest primes .",
    "let @xmath94 give the smallest estimated value for @xmath95 as defined above . if @xmath96 , let @xmath97 else let @xmath98 .",
    "compute @xmath95 . compute @xmath99 using modular exponentiation .",
    "set @xmath100 ; set @xmath101 ; if @xmath102 set @xmath101 again .",
    "compute @xmath103 .",
    "set @xmath104 .",
    "we can rule out @xmath16 .",
    "we factor @xmath105 and check each prime @xmath106 with @xmath107 to see if @xmath108 is a strong pseudoprime .",
    "computing @xmath95 is the bottleneck of this algorithm .",
    "when using @xmath65 or higher , we never found anything to factor in the last step .",
    "as above , let @xmath109 and we try to construct @xmath77 by finding @xmath39 .",
    "in order to search up to a bound @xmath30 , we need to search primes @xmath39 in the interval @xmath110 $ ] .",
    "we combine two types of sieving to search this interval quickly .",
    "the first we call @xmath111-sieving , and the second we call signature sieving .",
    "for each prime @xmath48 define @xmath112 by the r - rank artin conjecture @xcite , we expect with very high probability that @xmath113 .",
    "let @xmath114 .",
    "since @xmath115 for any @xmath116 this means @xmath117 is a multiple of @xmath111 .",
    "so , @xmath118 . this tells us that @xmath39 lies in a specific residue class modulo @xmath111 , and we call searching for @xmath39 using this value _",
    "@xmath111-sieving_.    we can further narrow down the residue classes that @xmath39 may lie in with respect to primes in @xmath62 .",
    "the following two propositions appeared originally in @xcite .",
    "[ prop1 ] for primes @xmath48 and @xmath119 , if @xmath120 and @xmath121 then @xmath122 .",
    "[ prop2 ] for primes @xmath48 and @xmath119 , if @xmath123 and @xmath121 then @xmath124 .",
    "one may consider higher reciprocity laws , and jaeschke did so @xcite .",
    "we found quadratic reciprocity sufficient .",
    "the authors of @xcite consider searching for @xmath39 modulo @xmath125 .",
    "they considered @xmath126 residue classes modulo @xmath127 that arose from the propositions above . with the inclusion of each additional",
    "prime from @xmath62 , we effectively rule out half of the cases to consider , thereby doubling the speed of the sieving process .",
    "ideally , we would like to include every prime in @xmath62 for the best performance , but with normal sieving , the sieve modulus becomes quite large and requires we keep track of too many residue classes to be practical .",
    "instead , we adapted the space - saving wheel datastructure @xcite , which had been used successfully to sieve for pseudosquares .",
    "sieving for primes @xmath39 with specified quadratic character modulo a list of small primes is the same algorithmic problem .",
    "this wheel sieve uses a data structure that takes space proportional to @xmath128 instead of space proportional to @xmath129 as used in traditional sieving .",
    "it does , however , produce candidate primes @xmath39 out of order .",
    "this is not an issue , so long as we make sure the sieve modulus does not exceed @xmath30 . in practice",
    ", we dynamically include primes from @xmath62 so that @xmath130 , and we favor the inclusion of smaller primes .    sieving @xmath16 in factored form as @xmath38 , @xmath131 for @xmath132 , search bound @xmath30 , and base vector @xmath62 of length @xmath1 .",
    "compute @xmath133 .",
    "set @xmath134 .",
    "compute wheel modulus @xmath135 as follows : set @xmath136 .",
    "set @xmath137 set @xmath138 and set @xmath139 let @xmath140 be the signature of @xmath92 . build a wheel with modulus @xmath135 so that for each prime power @xmath141 we have primes @xmath48 generated by the wheel with @xmath142 consistent with @xmath140 as in propositions [ prop1 ] and [ prop2 ] . use the chinese remainder theorem to compute @xmath143 such that @xmath144 and @xmath145 .",
    "sieve for primes in the interval @xmath146 $ ] that are @xmath147 .",
    "for each such probable prime @xmath39 found , perform a strong pseudoprime test on @xmath108 .    note that if @xmath16 consists entirely of primes that are @xmath148 , then all primes @xmath39 found by the sieve , when using all of @xmath62 , will have the correct signature .",
    "consider @xmath149 .",
    "now , @xmath150 ( factorization is obtained via sieving ) .",
    "we may use signature information for the primes @xmath151 , @xmath152 , @xmath153 , @xmath154 , @xmath155 , @xmath156 , @xmath157 , and @xmath158 .",
    "however , since @xmath159 we may only use the first 4 primes in the signature before the combined modulus is too large . the signature information for 3 implies that @xmath160 however , the case @xmath161 need not be considered since we know ( because of @xmath111 ) that @xmath162 . given the signature information for the primes 5 and 13 , we search in @xmath163 and @xmath164 .",
    "at this point we sieve for primes @xmath165 . to this",
    "we add the following 12 new congruence conditions and sieve for each individual condition .    1 .",
    "let @xmath166 .",
    "1 .   let @xmath167 .",
    "2 .   let @xmath168 .",
    "3 .   let @xmath169 .",
    "4 .   let @xmath170 . 5 .",
    "let @xmath171 .",
    "let @xmath172 .",
    "2 .   let @xmath173 .",
    "let @xmath167 .",
    "2 .   let @xmath168 .",
    "3 .   let @xmath169 .",
    "4 .   let @xmath170 . 5 .",
    "let @xmath171 .",
    "let @xmath172 .      in order to compute gcds or sieve as described above ,",
    "it is necessary to construct integers @xmath38 in an efficient way , where all the primes @xmath174 have matching signatures .",
    "we do this by storing all small primes in a hash table datastructure that supports the following operations :    * insert the prime @xmath48 with its signature @xmath175 .",
    "we assume any prime being inserted is larger than all primes already stored in the datastructure .",
    "( that is , insertions are monotone increasing . )",
    "we also store @xmath176 with @xmath48 and its signature for use later , thereby avoiding the need to factor @xmath177 . *",
    "fetch a list of all primes from the datastructure , in the form of a sorted array @xmath178 $ ] , whose signatures match @xmath140 .",
    "the fetch operation brings the @xmath176 values along as well .",
    "we then use this algorithm to generate all candidate @xmath16 values for a given @xmath34 and @xmath62 :    generating @xmath16 values @xmath179 , search bound @xmath30 , cutoff @xmath180 , base vector @xmath62 of length @xmath1 .",
    "let @xmath181 denote our hash table datastructure let @xmath182 denote the smallest prime not in @xmath62 .",
    "compute @xmath176 from the factorization of @xmath177 ; @xmath178 : = t$].fetch(@xmath175 ) ; list of primes with matching signature form @xmath183\\cdots s[i_{t-2}]\\cdot p$ ] ; use @xmath16 in a gcd computation to find matching @xmath39 values ; use @xmath16 for a sieving computation to find matching @xmath39 values ;    note that the inner for - loop above is coded using @xmath184 nested for - loops in practice .",
    "this is partly why we wrote separate programs for each value of @xmath34 . to make this work as a single program that handles multiple @xmath34 values",
    ", one could use recursion on @xmath34 .",
    "also note that we split off the gcd and sieving computations into separate programs , so that the inner for - loop was coded to make sure we always had either @xmath42 or @xmath185 as appropriate .",
    "we implemented this datastructure as an array or table of @xmath186 linked lists , and used a hash function on the prime signature to compute which linked list to use .",
    "the hash function @xmath187 computes its hash value from the signature as follows :    * if @xmath188 , the all - zero vector , then @xmath189 , and we are done . *",
    "otherwise , compute a modified copy of the signature , @xmath190 . if @xmath140 contains only 0s and 1s , then @xmath191 .",
    "if not , find the largest integer entry in @xmath140 , and entries in @xmath190 are 1 if the corresponding entry in @xmath140 matches the maximum , and 0 otherwise .",
    "+ for example , if @xmath192 ( our example from earlier ) , then @xmath193 .",
    "* @xmath194 is the value of @xmath190 viewed as an integer in binary .",
    "+ so for our example , @xmath195 .",
    "computing a hash value takes @xmath196 time .",
    "each linked list is maintained in sorted order ; since the insertions are monotone , we can simply append insertions to the end of the list , and so insertion time is dominated by the time to compute the hash value , @xmath196 time .",
    "note that the signature and @xmath176 is stored with the prime for use by the fetch operation .",
    "the fetch operation computes the hash value , and then scans the linked list , extracting primes ( in order ) with matching signature .",
    "if the signature to match is binary ( which occurs roughly half the time ) , we expect about half of the primes in the list to match , so constructing the resulting array @xmath178 $ ] takes time linear in @xmath1 multiplied by the number of primes fetched .",
    "note that @xmath111 values are brought along as well .",
    "amortized over the full computation , fetch will average time that is linear in the size of the data returned .",
    "also note that the average cost to compare signatures that do nt match is constant .",
    "the total space used by the data structure is an array of length @xmath186 , plus one linked list node for each prime @xmath197 .",
    "each linked list node holds the prime , its @xmath111 value , and its signature , for a total of @xmath198 bits , since each prime is @xmath199 bits .",
    "now that all the pieces are in place , we can describe the algorithm as a whole .",
    "given an input bound @xmath30 , we compute the gcd / sieve cutoff @xmath41 ( this is discussed in  [ analysis ] below ) .",
    "we then compute gcds as discussed above using candidate @xmath16 values @xmath200 for @xmath201 .",
    "for some value of @xmath34 , we ll discover that there are no candidate @xmath16 values with @xmath93 prime factors , at which point we are done with gcd computations .",
    "next we sieve as discussed above , using candidate @xmath16 values @xmath202 for @xmath201 . again , for some @xmath34 value , we ll discover there are no candidate @xmath16 values with @xmath93 prime factors , at which point we are done .",
    "we wrote a total of eight programs ; gcd programs for @xmath203 and sieving programs for @xmath204 .",
    "also , we did not bother to use the wheel and signature sieving , relying only on @xmath111 sieving , for @xmath205 .",
    "we assume a ram model , with potentially infinite memory .",
    "arithmetic operations on integers of @xmath199 bits ( single - precision ) and basic array indexing and control operations all are unit cost .",
    "we assume fast , fft - based algorithms for multiplication and division of large integers",
    ". for @xmath7-bit inputs , multiplication and division cost @xmath206 operations @xcite . from this",
    ", an fft - based gcd algorithm takes @xmath207 operations ; see , for example , @xcite .",
    "let our modulus @xmath208 so that @xmath209 ; each base @xmath50 is an odd prime with @xmath210 , except for @xmath211 with @xmath212 .",
    "we use our two propositions from  [ sec : sigsieve ] , together with quadratic reciprocity to obtain a list of @xmath213 residue classes for each odd prime @xmath50 and two residue classes modulo @xmath21 .",
    "the total number of residue classes is @xmath214 .",
    "a prime we are searching for with a matching signature must lie in one of these residue classes .",
    "let us clarify that when we state in sums and elsewhere that a prime @xmath48 has signature _ equivalent _ to @xmath140 , we mean that the quadratic character @xmath215 is consistent with @xmath140 as stated in propositions [ prop1 ] and [ prop2 ] .",
    "we write @xmath216 to denote this consistency under quadratic character , which is weaker than @xmath217 .",
    "[ dirichlet ] given a signature @xmath140 of length @xmath1 , and let @xmath218 as above .",
    "let @xmath219 .",
    "if @xmath220 , then number of primes @xmath221 with @xmath222 is at most @xmath223    this follows almost immediately from the brun - titchmarsh theorem .",
    "see , for example , iwaniec @xcite .",
    "we simply sum over the relevant residue classes mod @xmath119 based on quadratic character using propositions [ prop1 ] and [ prop2 ] .",
    "we will choose @xmath1 proportional to @xmath224 so that @xmath225 for some constant @xmath226 .",
    "[ lemma : sum1p ] we have @xmath227    this follows easily from lemma [ dirichlet ] by partial summation",
    ". we could make this tighter by making use of theorem 4 from @xcite , and observe that the constants @xmath228 ( in their notation ) cancel with one another in a nice fashion when summing over different residue classes modulo @xmath119 .",
    "see also section 6 of that paper .",
    "let @xmath229 denote the number of integers @xmath230 with exactly @xmath34 distinct prime divisors , each of which has signature equivalent to @xmath140 of length @xmath1 .",
    "[ jslemma1 ] @xmath231    proof is by induction on @xmath34 .",
    "@xmath232 follows from lemma [ dirichlet ] .    for the general case , we sum over the largest prime divisor @xmath48 of @xmath7 , @xmath233 we used lemma [ lemma : sum1p ] for the last step .",
    "( see also the proof of theorem 437 in @xcite . )",
    "let @xmath234 denote the value of @xmath176 for the prime @xmath48 using a vector @xmath62 with the first @xmath1 prime bases .",
    "we need the following lemma from ( * ? ? ?",
    "2.4 ) :    [ lemma : pap ] there exists a constant @xmath235 such that @xmath236    using this , we obtain the following .",
    "[ thm : lambda ] let @xmath237 .",
    "then @xmath238    we have @xmath239 note that @xmath235 .      in order to prove our @xmath6 running time bound for @xmath179 , we make use of the conjecture below .",
    "let @xmath240 be the set of integers with exactly @xmath34 distinct prime divisors each of which has signature matching @xmath140 .",
    "in other words , @xmath229 counts integers in @xmath241 bounded by @xmath105 .",
    "[ conjecture ] let @xmath242 be as above . then @xmath243    [ thm : lambda2 ] assuming conjecture [ conjecture ] is true , we have @xmath244    the proof is essentially the same as that of theorem [ thm : lambda ] . simply substitute conjecture [ conjecture ] for lemma [ lemma : pap ] .",
    "we now have the pieces we need to prove our running time bound .",
    "as above , each pseudoprime candidate we construct will have the form @xmath40 , where @xmath16 is the product of @xmath93 distinct primes with matching signature .",
    "again , @xmath245 is our base vector of small primes of length @xmath1 .      in this case",
    "@xmath16 is prime",
    ".    * gcd computation .",
    "* for each prime @xmath246 we perform a gcd computation as described in  [ sec : gcd ] .",
    "the bottleneck of this computation is computing gcds of @xmath247-bit integers .",
    "this gives a running time proportional to @xmath248    * sieving computation .",
    "* for each prime @xmath249 with @xmath250 , we sieve the interval @xmath251 $ ] for primes that are @xmath252 .",
    "we also employ signature sieving , but for the simplicity of analysis , we omit that for now . using the methods from @xcite , we can sieve an arithmetic progression of length @xmath253 in @xmath254 operations .",
    "we do not need proof of primality here , so a fast probabilistic test works fine .",
    "this gives a running time proportional to @xmath255 at this point we know @xmath256 and , to keep the gcd and sieving computations balanced , @xmath257 , say .",
    "this means theorem [ thm : lambda ] applies ; we set @xmath258 and @xmath259 to obtain @xmath260 assuming that @xmath261 with @xmath30 .",
    "minimizing @xmath262 implies @xmath263 and gives the desired running time of @xmath6 .",
    "this completes our proof . @xmath264 .      in this case",
    "@xmath16 is composite",
    ".    * gcd computation . * for @xmath179",
    "we construct integers @xmath265 for computing gcds , with @xmath266 consisting of exactly @xmath184 prime divisors less than @xmath48 , with signatures matching @xmath175 . for each prime @xmath48",
    ", we perform a hash table lookup and fetch the list of such primes ; this is step 5 of algorithm 3 .",
    "this overhead cost is @xmath267 . summing this over all primes @xmath268",
    "gives @xmath269 .",
    "next , for each prime @xmath268 we construct at most @xmath270 values for @xmath266 ( step 7 of algorithm 3 ) , and using lemma [ jslemma1 ] and multiplying by the cost of computing the gcd , this gives us @xmath271 for the total running time .",
    "* sieving computation . *",
    "again , the main loop enumerates all choices for the second - largest prime @xmath272 .",
    "first , we construct all possible @xmath16-values with @xmath43 , @xmath273 , and @xmath274 , so @xmath275 with all the @xmath35 and @xmath276 .",
    "we also have @xmath277 .",
    "this implies @xmath278 .    for a given @xmath48 , fetching the list of primes below @xmath279 with matching signatures takes @xmath280 time ( algorithm 3 step 5 ) .",
    "summing over all @xmath281 , splitting the sum at @xmath282 , this takes @xmath283 time .",
    "as above , we write @xmath284 . we claim that the total number of @xmath16 values is @xmath285 .",
    "let @xmath75 be as above .",
    "there are at most @xmath286 values of @xmath266 for each @xmath48 .",
    "again , splitting this at @xmath287 , we have @xmath288 and @xmath289 this covers work done at step 7 of algorithm 3 .    finally , the cost of sieving is at most @xmath290 if we use theorem [ thm : lambda2 ] , based on our conjecture , and using the lower bound @xmath291 , this leads to the bound @xmath292 without the conjecture , we use lemma [ lemma : sum1p ] together with the argument outlined in hardy and wright @xcite in deriving ( 22.18.8 ) , we obtain that @xmath293 we then use @xmath294 as above , this leads to the bound @xmath295    to balance the cost of gcds with sieving , we want to balance ( [ t2gcd ] ) with ( [ t2sievea ] ) or ( [ t2sieveb ] ) , depending on whether we wish to assume our conjecture or not . simplifying a bit , this means balancing @xmath296 with either @xmath297 or @xmath298 .",
    "the optimal cutoff point is then either @xmath263 under the assumption of conjecture [ conjecture ] , or @xmath299 unconditionally , for a total time of @xmath300 with our conjecture , or @xmath301 without .",
    "we have proven the following .",
    "assuming conjecture [ conjecture ] , our algorithm takes @xmath6 time to find all integers @xmath5 that are strong pseudoprimes to the first @xmath1 prime bases , if @xmath302 with @xmath30 .    if we choose @xmath1 so that @xmath119 is a fractional power of @xmath30 , then lemma [ jslemma1 ] implies that there is a constant @xmath303 such that if @xmath304 , then there is no work to do .",
    "this explains why our computation did not need to go past @xmath36 .",
    "it also explains why , in practice , the @xmath37 case is the bottleneck of the computation , and is consistent with the implications of our conjecture that the work for each value of @xmath34 decreases as @xmath34 increases .",
    "in this final section , we conclude with some details from our algorithm implementation",
    ".                    in figure [ gcd - timing ] , we present the times to perform algorithm 1 on selected prime values for @xmath16 ( so this is for the @xmath37 case ) .",
    "the data points were obtained by averaging the time needed to carry out algorithm 1 for the first ten primes exceeding @xmath305 for @xmath306 .",
    "averaging was required because the size of the @xmath81 values is not uniformly increasing in @xmath16 .",
    "this explains the variance in the data ; for example , the first ten primes after @xmath307 happened to have smaller @xmath81 values on average than the first ten primes after @xmath308",
    ".    it should be clear from the data that our gmp algorithm for computing gcds was using an essentially linear - time algorithm .",
    "note that if we chose to extend the computation to large enough @xmath16 values , memory would become a concern and we would expect to see paging / thrashing degrade performance .          in figure",
    "[ crossover ] , we present a comparison of the timings for computing gcds ( algorithm 1 , diamonds on the graph ) with signature sieving ( algorithm 2 , squares on the graph ) . for this graph",
    ", we are looking at choosing the crossover point @xmath41 , and again , we are focusing on the @xmath37 case .",
    "* one would expect that the signature sieving curve should behave as an inverse quadratic ; the time to sieve for one prime @xmath249 is proportional to @xmath309 and we expect @xmath310 most of the time .",
    "however , utilizing signatures obscures this to some degree , since the algorithm can not make use of all prime bases if they divide @xmath111 , hence the minor variations in the curve . let us elaborate this here .",
    "+ the data points for signature sieving in figure [ crossover ] represent the average sieve time for the first 50 primes past @xmath305 for @xmath311 .",
    "there is a lot of variance in these timing because of the inclusion and exclusion of primes from the signature depending if they are relatively prime to @xmath111 .",
    "for example , @xmath312 has @xmath313 and therefore has few primes from the base set to use in signature sieving .",
    "the inability to add extra primes shows up in the timing data ; a careful inspection of the data shows a strange jump when primes transition from @xmath314 to @xmath315 .",
    "the data points to a steady decrease , then an almost two fold increase in time followed by a steady decrease again .",
    "we believe this is because , on average , one less base prime may be used in signature sieving .",
    "using one less base prime results in approximately twice as much work .",
    "* in the computation for @xmath3 , our actual crossover point @xmath41 was @xmath316 , even though the timing data would suggest the optimal crossover point is around @xmath317 .",
    "from a cost - efficiency point of view , we chose poorly .",
    "however , the choice was made with two considerations .",
    "one is that the program to compute gcds ( algorithm 1 ) is simple to write , so that program was up and running quickly , and we let it run while we wrote the sieving code ( algorithm 2 ) .",
    "second is that , initially , we did not know which @xmath0 value we would ultimately be able to compute . since the results from gcd computations apply to all larger values of @xmath1 , we opted to err in favor of computing more gcds .",
    "figure [ sievecomp ] shows the impact that signature sieving makes . here the squares in the graph give @xmath111-sieving times with no signature information used , and the diamonds show the same @xmath111-sieving work done while taking advantage of signature information using the space - saving wheel .",
    "since there is relatively little variance involved in @xmath111-sieving , each point represents the first prime after @xmath305 for @xmath311 . on the same interval signature sieving",
    "practically looks like it takes constant time compared to @xmath111-sieving .",
    "if we had opted to not incorporate signature sieving in , then the expected crossover point given these timings would occur when the primes are around @xmath318 .",
    "jonathan  p. sorenson , _",
    "sieving for pseudosquares and pseudocubes in parallel using doubly - focused enumeration and wheel datastructures _ , proceedings of the 9th international symposium on algorithmic number theory ( ants - ix ) ( nancy , france ) ( guillaume hanrot , francois morain , and emmanuel thom , eds . ) , springer , july 2010 , lncs 6197 , isbn 978 - 3 - 642 - 14517 - 9 , pp .  331339 .",
    "damien stehl and paul zimmermann , _ a binary recursive gcd algorithm _ , sixth international algorithmic number theory symposium ( burlington , vermont , usa ) ( duncan buell , ed . ) , springer , june 2004 , lncs 3076 , pp",
    ".  411425 .",
    "( 2006e:11194 )"
  ],
  "abstract_text": [
    "<S> let @xmath0 be the smallest strong pseudoprime to the first @xmath1 prime bases . </S>",
    "<S> this value is known for @xmath2 . </S>",
    "<S> we extend this by finding @xmath3 and @xmath4 . </S>",
    "<S> we also present an algorithm to find all integers @xmath5 that are strong pseudoprimes to the first @xmath1 prime bases ; with a reasonable heuristic assumption we can show that it takes at most @xmath6 time .    </S>",
    "<S> [ multiblock footnote omitted ]    -sieving . ] </S>"
  ]
}