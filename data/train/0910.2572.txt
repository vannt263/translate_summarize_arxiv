{
  "article_text": [
    "pixel detectors have an extremely broad spectrum of applications , ranging from high - energy physics to the photo cameras of everyday life .",
    "a large fraction of applications can benefit from a high - through clustering device that processes the collected data on the fly .",
    "it can serve as a first data - processing step with several purposes .",
    "pixel clustering is useful to reduce the amount of data at an early stage .",
    "this is extremely important when the data rate to process is large .",
    "the information from all pixels in the cluster can be summarized by the cluster properties of interest . for the detection of ionizing particle",
    ", the output would be the best estimate of the particle spatial position .",
    "medical applications that search for clusters of anomalous density in medical images  @xcite can also benefit from a fast clustering device .",
    "we propose a general purpose clustering algorithm that achieves high - throughput while maintaining the flexibility needed to be adaptable to different applications .",
    "this algorithm is being developed as part of the fast tracker  @xcite trigger upgrade for the atlas experiment  @xcite .",
    "it has many potential applications . for high - energy physics tracking detectors ,",
    "a fast clustering device allows us to imagine a self - clustering detector , where collected data is analyzed and clustered on the fly .",
    "the data transmitted by the thousands of fibers could be received and analyzed by a clustering device located on the remote end of the fibers ( off - detector ) .",
    "an even more challenging possibility would be to have the clustering logic integrated on the detector front - end itself . in this case",
    "we could take advantage of the data reduction associated with clustering to either reduce the power consumption need to send data off - detector or to increase the output rate .",
    "the first application is clustering of the atlas pixel detector data as part of the fast tracker processor .",
    "the fast tracker is an upgrade for the atlas trigger system .",
    "it will analyze silicon tracker data at the l1 output rate .",
    "the fast tracker will provide reconstructed tracks as input to the high level triggers  @xcite in alternative to raw detector hits .",
    "track reconstruction will cover the entire inner detector with offline - quality . in order to achieve these goals the first step of the fast tracker processing needs to perform clustering of the pixel detector data .",
    "the main challenge is to process the @xmath0160gbits input data rate .",
    "data is received over 132 s - link fibers each running at a 1.2 gbits .",
    "the data format consist of 32 bits words at a rate of 40mhz where each word corresponds to one detector hit , which encodes hit coordinates ( row and column ) within the module and the time over threshold ( tot ) information . through this document",
    "we will use the ability to process hits at a 40mhz rate as a benchmark .",
    "the clustering algorithm must provide high - quality resolution , in order to match the high quality needed the high level triggers .",
    "the atlas pixel modules are described in ref .",
    "each module is readout by 16 front end chips ( fe ) organized in two rows of 8 fe each .",
    "each fe reads out pixel hits by double column .",
    "because of its logic , hits in a double column are scrambled in the readout , while packets of data from each double column are read out one after the other in a fixed order .",
    "data packets from each of the 16 fe chips is received by the mcc chip that performs event building . the data stream after mcc processing contains data from each fe chips organized in consecutive packets . in other words , the final data stream sent out by the module has packets of data corresponding to double columns which are readout in a sorted and predefined order one after the other .",
    "the data is scrambled only within each double column .      in the case of silicon strip detectors ,",
    "the clustering becomes very easy if the strip readout is ordered .",
    "in fact , in this case contiguous hits belonging to the same cluster are also contiguous in the readout data stream .    for pixel detectors ,",
    "because of the intrinsic 2d nature of the problem , it is impossible to define a readout algorithm such that all hit pixels belonging to one cluster are readout consecutively .",
    "this means that the algorithm somehow has to loop over the list of hit pixels in a module in order to recognize that two or more hits belong to the same cluster .",
    "we define a cluster as a set of hits that are contiguous either through a common side or a common vertex ( in order words diagonally ) .",
    "if we imagine a software algorithm looping over all data from a pixel module , we can estimate that the algorithm complexity would be proportional to the square of the number of hits .",
    "the algorithm would take advantage of readout ordering to achieve a complexity that is proportional to the square of the local occupancy . in any case , the computing time will scale more than linearly with occupancy .",
    "this leads to potential troubles at high instantaneous - luminosity when the hit occupancy due to many pile - up events is high .",
    "is it possible to design a clustering algorithm that , regardless of the detector occupancy , has a processing time that scales linearly with the number of hits ?",
    "this is a very desirable feature because it matches the readout time that is always linear with the number of hits . in practice",
    "any algorithm that runs with a processing time that is linear with the number of hits , would be able to keep the pace with the readout at any instantaneous - luminosity .",
    "we will show that a simple hardware base algorithm can satisfy this requirement .",
    "the goal is an algorithm complexity that scales linearly with the number of hits , while achieving offline resolution . in order to combine speed with quality",
    ", we split the algorithm in two steps .",
    "the first step will group together hits belonging to the same cluster .",
    "this is the critical part of the algorithm where we will exploit a dedicated logic in order to achieve linear processing time .",
    "the second step will analyze hits in the cluster in order to calculate the cluster properties of interest .",
    "this second step , being separate from the first one , will have the flexibility needed to achieve the best resolution . as an additional benefit , it will be easy to specialize it to suit different applications .",
    "[ fig : block_diagram ] shows the two algorithm steps working together .",
    "the first step is represented by the core logic .",
    "the second step is represented by the average calculator . a detailed description of the first step follows .    in order to achieve linear processing time",
    ", we exploit the powerful logic of fpga .",
    "in fact , the 2d structure of fpgas is suitable for mapping the 2d structure of a pixel module .",
    "so let s imagine that the fpga logic represents a 2d grid of clustering cells . fig .",
    "[ fig : cell ] shows the logic of the elementary cell .",
    "each cell has three possible states : empty , hit , selected .",
    "the first step of the algorithm will receive data from one pixel module and start to load it onto the fpga grid , by marking the corresponding cells as hit ( write signal in the figure ) .",
    "once all data is loaded in the grid , an external finite state machine ( fsm ) will select the first hit in the grid through a priority chain .",
    "the first hit will be marked as selected .",
    "the selected status propagates to nearby hit cells through local logic .",
    "this is the key step of the algorithm that avoids any loop .",
    "as soon as the first cell is selected the fsm will start to readout all selected cell positions .",
    "again the fsm will start reading out selected cells using another identical priority chain",
    ". the list of these positions will be output and it will represent the first cluster . please note that the propagation of the selected status and the readout can happen at the same time with the loss of just one clock cycle needed to select the seed cell . at this point",
    "the algorithm can start over selecting next first hit in the grid , and so on .",
    "the two priority chains match the readout order of data that is sorted in the direction perpendicular to the columns",
    ". the column index will be the most significant and the row index the least significant .",
    "hence , the first hit is the one in the column with the lowest column index and within the same column the hit with the lowest row index . in fig .",
    "[ fig : cell ] the definition of a cluster is encoded in the combinatorial logic box .",
    "here we have the flexibility to redefine when hits belong to the same cluster without changing the overall structure of the algorithm .",
    "the description above defines the core ( first step ) of the algorithm .",
    "a second algorithm step will calculate the center of the cluster .",
    "the center will be calculated as a tot weighted average of the positions of the hits .",
    "this can be done with high speed and limited hardware resources after the cluster has been identified by the first algorithm step .",
    "the second step is completely decoupled from the first one .",
    "it can be modified to calculate any cluster property of interest depending on the specific application . in the description above the fpga grid does not store the tot information .",
    "the tot is stored in a ram while hits are being loaded on the grid . during grid readout",
    "the tot will be easily retrieved and sent to the second step logic .",
    "the algorithm described above uses a 2d grid of logic cells that represents a whole pixel module .",
    "it is 328x144 cells wide .",
    "it is important to evaluate the hardware size and the clock speed of this logic .",
    "we anticipate that the whole grid will need a lot of resources .",
    "then we will describe how to reduce the amount of logic to a manageable size .    for this exercise",
    ", we implemented the logic on a xv5vlx330 xilinx fpga  @xcite .",
    "the xv5vlx330 is currently the largest of the xv5vlx group .",
    "we use it as a reference point .",
    ".[tab : algo_performances]algorithm performances on a xc5vlx330 fpga . [ cols=\"^,^,^\",options=\"header \" , ]     tab .",
    "[ tab : algo_performances ] reports the clock period and area size as function of the grid size .",
    "the area usage scales as expected with the area of the grid .",
    "scaling the 328x8 to the full pixel module we obtain an area of 280% of one xv5vlx330 fpga .",
    "this clearly indicates that we need a more efficient way to cluster hits .",
    "a solution to this problem is in the next section .",
    "the clock speed also scales with the gird size .",
    "the priority logic is the net with the maximum delay .",
    "it determines the minimum clock period . because the priority logic involves all cells in the grid , the clock period scales with the grid size .",
    "we have seen that using an fpga - based processing grid that reproduces a full pixel module is not feasible .",
    "it would also be very inefficient .",
    "in fact , the current algorithm loads all data on the grid.,then it starts clustering data from the first ( priority wise ) hit .",
    "it is clear that pixels that are far away from the first hit do not take part in the clustering process .",
    "it is thus useless to have a grid as big as the module .    what is the minimum size of the processing grid that we can use ?",
    "of course it must be larger than a cluster .",
    "most clusters are up to 3 pixel wide along the @xmath1 direction and up to 5 pixel wide along the z and z coordinates refer to the cylindrical geometry of pixel modules in the barrel .",
    "] direction  @xcite .",
    "pixels are readout in groups of double columns , i.e. scrambled within a double column but sorted one double column after the other .",
    "because of this , the grid must be at least as long as a double column along the @xmath1 direction .",
    "this is needed in order to have room to store all hits received during readout for a given double column .",
    "an alternative option would be to store separately ( e.g. in a memory ) hits that are away by more than 3 pixel w.r.t to the first ( priority wise ) hit .",
    "however this would require checking all hits multiple times , with a price on processing time . this could lead to further optimization of the algorithm .",
    "one column is 164 pixels long .",
    "it corresponds to one fe chip .",
    "so our grid must be 164 pixels long along @xmath1 .",
    "we chose to make it 328 pixels wide in order to avoid edge effects at the center of the module .",
    "along the z direction we must choose a value bigger than 5 .",
    "a good number is 8 that allows for extra some margin .",
    "we can use a sliding window algorithm that scans the pixel module from left to right and clusters all hits .",
    "i assume a window size of 328x8 pixels .",
    "[ fig : sliding ] represents the working principle of the sliding window .",
    "the left most diagram shows a pixel module with all its hits and clusters .",
    "those are received from the input s - link and stored on the fifo .",
    "the center diagram shows the sliding window a 328x8 grid of processing logic .",
    "when we start to process a new module the sliding grid will be empty .",
    "as soon as the first hit is received by the fifo , the fsm will know its column number .",
    "thus we can align the left edge of the sliding grid to this column ( center diagram ) .",
    "the alignment procedure is virtual it corresponds to labeling the first column of the sliding grid .",
    "in other words the column number of the first hit is stored in a register .",
    "please note that if the column number is the second of a double column , we should align the sliding grid one column to the left of the first hit in order to allow room for all hits in the double column .",
    "the algorithm starts loading hits in the grid until the first hit beyond the sliding grid width is received .",
    "of course a fraction of the hits and even part of some clusters will not be loaded at this point . at this point load phase",
    "ends and one cluster is readout . the first ( priority wise ) hit is selected for readout . for the next cycle we can start reading out all selected hits .",
    "the selected signal is propagated from the first hit to its own neighborhood pixels that are hit .",
    "after one cluster is fully readout , the algorithm starts over aligning the grid to the next first hit and the grid is ready to load more hits .",
    "this is shown in the right diagram .",
    "hits that were left out during the previous load phase can now be loaded on the grid .",
    "this is the list of algorithm steps :    * align sliding grid to first hit * load hits * select first ( priority wise ) hit * readout all selected hits * start over with next cluster    this algorithm correctly clusters hits with the only exception of clusters exceeding 8 columns in length that will be split .",
    "this algorithm has a manageable hardware size .",
    "it can be implemented with 15% area usage on a xc5vlx330 or with 30% area usage on the smaller xc5vlx155 . from the list of steps above we",
    "can extract that the algorithm will need 2 clock cycles to process each hit ( one for loading it and one for reading it out ) plus 2 clock cycles per cluster ( one for aligning the grid and one for selecting the first hit ) .",
    "the clock cycle counting has been verified with fpga simulation .",
    "if we assume clusters of 2 hits on average , we get 3 clock cycles per hit . for larger clusters",
    "the average number of clock cycles per hit is smaller . at this point",
    "we can compare the hit processing time of 15ns ( clock period ) times 3 clock cycles per hit that equals 45ns with the hit rate from s - link input that is 40mhz or 25ns .",
    "this means that we need to gain a factor of 2 in speed .",
    "it can be gained using two sliding windows processing two modules in parallel .",
    "this would result in an area usage of 60% on a xc5vlx155 fpga .",
    "the implementation of the second algorithm step becomes easy because it is decoupled from the first step .",
    "we tried two options . a first option that ignores the tot information . in this simplified case",
    "the resolution is still good .",
    "the residual resolution with respect to the offline cluster position has an rms of a tenth of a pixel along each direction .",
    "as second option we used the full tot information in the same way as the current offline algorithm does . in this case",
    "we achieve the same resolution as the offline with the exception of a few anomalous clusters that exceed 8 columns in width .",
    "we have developed and studied a clustering algorithm for the pixel detectors .",
    "the proposed algorithm achieves linear processing time with respect to the number of readout hits . for this reason it is intrinsically stable with respect to detector occupancy .",
    "the algorithm can be implemented in hardware with one xc5vlx155 fpga .",
    "is uses 60% of its logic in order to process data from one input s - link .",
    "the algorithm is flexible in the definition of clustering and in the calculation of output cluster properties .",
    "it can be adapted to suit most applications .",
    "we thank mauro dellorso , paolo laurelli , giovanni maccarrone and andrea sansoni for the fruitful discussion on this subject .",
    "a. retico et al . , comput biol med . (",
    "2008 ) 38(4):525 - 34 a. annovi et al .",
    ", ieee trans .",
    "51 , 391 ( 2004 ) , http://twiki.cern.ch/twiki/bin/view/atlas/fasttracker the atlas collaboration , g. aad et al . , `` the atlas experiment at the cern large hadron collider '' , jinst 3 ( 2008 ) s08003 `` atlas high - level trigger , data acquisition and controls '' , atlas - tdr-016 ( 2003 ) , cern - lhcc-2003 - 022 g. aad et al .",
    ", `` atlas pixel detector electronics and sensors '' , jinst 3 ( 2008 ) p07007 http://www.xilinx.com/ `` pixel detector technical design report '' , atlas - tdr-011 ( 1998 ) , cern - lhcc-98 - 013"
  ],
  "abstract_text": [
    "<S> we present a fast general - purpose algorithm for high - throughput clustering of data `` with a two dimensional organization '' . the algorithm is designed to be implemented with fpgas or custom electronics . </S>",
    "<S> the key feature is a processing time that scales linearly with the amount of data to be processed . </S>",
    "<S> this means that clustering can be performed in pipeline with the readout , without suffering from combinatorial delays due to looping multiple times through all the data . </S>",
    "<S> this feature makes this algorithm especially well suited for problems where the data has high density , e.g. in the case of tracking devices working under high - luminosity condition such as those of lhc or super - lhc .    </S>",
    "<S> the algorithm is organized in two steps : the first step ( core ) clusters the data ; the second step analyzes each cluster of data to extract the desired information . </S>",
    "<S> the current algorithm is developed as a clustering device for modern high - energy physics pixel detectors . </S>",
    "<S> however , the algorithm has much broader field of applications . </S>",
    "<S> in fact , its core does not specifically rely on the kind of data or detector it is working for , while the second step can and should be tailored for a given application . </S>",
    "<S> for example , in case of spatial measurement with silicon pixel detectors , the second step performs center of charge calculation . </S>",
    "<S> applications can thus be foreseen to other detectors and other scientific fields ranging from hep calorimeters to medical imaging .    </S>",
    "<S> an additional advantage of this two steps approach is that the typical clustering related calculations ( second step ) are separated from the combinatorial complications of clustering . </S>",
    "<S> this separation simplifies the design of the second step and it enables it to perform sophisticated calculations achieving offline - quality in online applications . </S>",
    "<S> the algorithm is general purpose in the sense that only minimal assumptions on the kind of clustering to be performed are made .    </S>",
    "<S> clustering , trigger , pixel detectors , fpga , particle tracking </S>"
  ]
}