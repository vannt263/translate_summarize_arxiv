{
  "article_text": [
    "a growing body of work studies the design and real - time implementation of distributed controllers to ensure the efficient and robust operation of networked cyber - physical systems . in multi - agent scenarios ,",
    "energy consumption is correlated with the rate at which sensors take samples , processors recompute control inputs , actuator signals are transmitted , and receivers are left on listening for potential incoming signals . performing these tasks periodically is costly , might lead to inefficient implementations , or face hard physical constraints . to address these issues ,",
    "the goal of triggered control is to identify criteria that allow agents to tune the implementation of controllers and sampling schemes to the execution of the task at hand and the desired level of performance . in event - triggered control , the focus is on detecting events during the network execution that are relevant from the point of view of task completion and should trigger specific agent actions . in self - triggered control , the emphasis is instead on developing tests that rely only on current information available to individual agents to schedule future actions .",
    "event - triggered strategies generally result in less samples or controller updates but , when executed over networked systems , may be costly to implement because of the need for continuous availability of the information required to check the triggers .",
    "self - triggered strategies are more easily amenable to distributed implementation but result in conservative executions because of the over - approximation by individual agents about the state of the environment and the network",
    ". these strategies might be also beneficial in scenarios where leaving receivers on to listen to potential messages is costly .",
    "our objective in this paper is to build on the strengths of event- and self - triggered control to synthesize a unified approach for controlling networked systems in real time that combines the best of both worlds .",
    "the need for systems integration and the importance of bridging the gap between computing , communication , and control in the study of cyber - physical systems can not be overemphasized  @xcite .",
    "real - time controller implementation is an area of extensive research including periodic  @xcite , event - triggered  @xcite , and self - triggered  @xcite procedures .",
    "our approach shares with these works the aim of trading computation and decision making for less communication , sensor , or actuator effort while still guaranteeing a desired level of performance .",
    "of particular relevance to this paper are works that study self- and event - triggered implementations of controllers for networked cyber - physical systems .",
    "the predominant paradigm is that of a single plant that is stabilized through a decentralized triggered controller over a sensor - actuator network , see e.g.  @xcite .",
    "fewer works have considered scenarios where multiple plants or agents together are the subject of the overall control design .",
    "exceptions include consensus via event - triggered  @xcite or self - triggered control  @xcite , rendezvous  @xcite , model predictive control  @xcite , and model - based event - triggered control  @xcite .",
    "the event - triggered controller designed in  @xcite for a decentralized system with multiple plants requires agents to have continuous information about each others states .",
    "the works in  @xcite implement self - triggered communication schemes to perform distributed control where agents assume worst - case conditions for other agents when deciding when new information should be obtained . distributed strategies based on event - triggered communication and control are explored in  @xcite , where each agent has an a priori computed local error tolerance and once it violates it , the agent broadcasts its updated state to its neighbors . the same event - triggered approach is taken in  @xcite to implement gradient control laws that achieve distributed optimization .",
    "the works  @xcite are closer in spirit to the ideas presented here . in the interconnected system considered in  @xcite",
    ", each subsystem helps neighboring subsystems by monitoring their estimates and ensuring that they stay within some performance bounds .",
    "the approach requires different subsystems to have synchronized estimates of one another even though they do not communicate at all times . in  @xcite , agents do not have continuous availability of information from neighbors and instead decide when to broadcast new information to them .",
    "[ [ statement - of - contributions ] ] statement of contributions + + + + + + + + + + + + + + + + + + + + + + + + + +    we propose a novel scheme for the real - time control of networked cyber - physical systems that combines ideas from event- and self - triggered control .",
    "our approach is based on agents making promises to one another about their future states and being responsible for warning each other if they later decide to break them .",
    "this is reminiscent of event - triggered implementations .",
    "promises can be broad , from tight state trajectories to loose descriptions of reachability sets . with the information provided by promises , individual agents can autonomously determine when in the future fresh information will be needed to maintain a desired level of performance .",
    "this is reminiscent of self - triggered implementations .",
    "the benefits of the proposed scheme are threefold .",
    "first , because of the availability of the promises , agents do not require continuous state information about neighbors , in contrast to event - triggered strategies implemented over distributed systems that require the continuous availability of the information necessary to check the relevant triggers .",
    "second , because of the extra information provided by promises about what other agents plan to do , agents can generally wait longer periods of time before requesting new information and operate more efficiently than if only worst - case scenarios are assumed , as is done in self - triggered control .",
    "less overall communication is beneficial in reducing the total network load and decreasing chances of communication delays or packet drops due to network congestion .",
    "lastly , we provide theoretical guarantees for the correctness and performance of team - triggered strategies implemented over distributed networked systems .",
    "our technical approach makes use of set - valued analysis , invariance sets , and lyapunov stability .",
    "we also show that , in the presence of physical sources of error and under the assumption that 1-bit messages can be sent reliably with negligible delay , the team - triggered approach can be slightly modified to be robust to delays , packet drops , and communication noise .",
    "interestingly , the self - triggered approach can be seen as a particular case of the team - triggered approach where promises among agents simply consist of their reachability sets ( and hence do not actually constrain their state ) .",
    "we illustrate the convergence and robustness results through simulation in a multi - agent formation control problem , paying special attention to the implementation costs and the role of the tightness of promises in the algorithm performance .",
    "[ [ organization ] ] organization + + + + + + + + + + + +    section  [ se : statement ] lays out the problem of interest .",
    "section  [ se : triggered - control ] briefly reviews current real - time implementation approaches based on agent triggers .",
    "section  [ se : team - triggered ] presents the team - triggered approach for networked cyber - physical systems .",
    "sections  [ se : analysis ] and  [ se : robustness ] analyze the correctness and robustness , respectively , of team - triggered strategies .",
    "simulations illustrate our results in section  [ se : simulations ] .",
    "finally , section  [ se : conclusions ] gathers our conclusions and ideas for future work .",
    "[ [ notation ] ] notation + + + + + + + +    we let @xmath0 , @xmath1 , and @xmath2 denote the sets of real , nonnegative real , and nonnegative integer numbers , respectively .",
    "the two - norm of a vector is @xmath3",
    ". given @xmath4 and @xmath5 , @xmath6 denotes the closed ball centered at @xmath7 with radius @xmath8 . for @xmath9 with @xmath10 , we denote by @xmath11 the block - diagonal matrix with @xmath12 through @xmath13 on the diagonal , where @xmath14 and @xmath15 . given a set @xmath16 , we denote by @xmath17 its cardinality .",
    "we let  @xmath18 , respectively  @xmath19 , denote the collection of compact , respectively , compact and connected , subsets of  @xmath16 .",
    "the hausdorff distance between @xmath20 is @xmath21 the hausdorff distance is a metric on the set of all non - empty compact subsets of @xmath22 . given two bounded set - valued functions @xmath23 , its distance is @xmath24 an undirected graph  @xmath25 is a pair consisting of a set of vertices @xmath26 and a set of edges @xmath27 such that if @xmath28 , then @xmath29 .",
    "the set of neighbors of a vertex  @xmath30 is @xmath31 .",
    "given @xmath32 , we let @xmath33 denote the components of @xmath34 that correspond to vertex @xmath30 and its neighbors in  @xmath35 .",
    "we consider a distributed control problem carried out over an unreliable wireless network .",
    "consider @xmath36 agents whose communication topology is described by an undirected graph  @xmath35 .",
    "the fact that @xmath37 belongs to @xmath38 models the ability of agents @xmath30 and @xmath39 to communicate with one another .",
    "the agents  @xmath30 can communicate with are its neighbors @xmath40 in  @xmath35 .",
    "the state of  @xmath41 , denoted @xmath42 , belongs to a closed set @xmath43 .",
    "the network state @xmath44 therefore belongs to @xmath45 . according to the discussion above",
    ", agent @xmath30 can access @xmath46 when it communicates with its neighbors . by assumption",
    ", each agent has access to its own state at all times .",
    "we consider linear dynamics for each @xmath10 , @xmath47 with @xmath48 , @xmath49 , and @xmath50 . here , @xmath51 is a closed set of allowable controls for agent  @xmath30 .",
    "we assume the existence of a _ safe - mode _ controller @xmath52 , @xmath53 i.e. , a controller able to keep agent @xmath30 s state fixed . the existence of a safe - mode controller for a general controlled system may seem restrictive , but there exist many cases , including nonlinear systems , that admit one , such as single integrators or vehicles with unicycle dynamics .",
    "letting @xmath54 , the dynamics can be described by @xmath55 with @xmath56 and @xmath57 , where @xmath58 , and @xmath59 .",
    "we refer to the team of agents with communication topology  @xmath35 and dynamics  , where each agent has a safe - mode controller and access to its own state at all times , as a _ networked cyber - physical system_. the goal is to drive the agents states to some desired closed set of configurations @xmath60 and ensure that it stays there .",
    "depending on how @xmath61 is defined , this objective can capture different coordination tasks , including deployment , rendezvous , and formation control .",
    "the goal of the paper is not to design the controller that achieves this but rather synthesize efficient strategies for the real - time implementation of a given controller .    given the agent dynamics , the communication graph @xmath35 , and the set @xmath61 , our starting point is the availability of a control law that drives the system asymptotically to @xmath61 .",
    "formally , we assume that a continuous map  @xmath62 and a continuously differentiable function @xmath63 , bounded from below exist such that @xmath61 is the set of minimizers of @xmath64 and , for all @xmath65 ,    [ eq : derivativeassumption ] @xmath66    we assume that both the control law @xmath67 and the gradient @xmath68 are distributed over @xmath35 . by this",
    "we mean that , for each @xmath69 , the @xmath30th component of each of these objects only depends on @xmath70 , rather than on the full network state  @xmath7 . for simplicity , and with a slight abuse of notation ,",
    "we write @xmath71 and @xmath72 to emphasize this fact when convenient .",
    "this property has the important consequence that agent @xmath30 can compute these quantities with the exact information it can obtain through communication on  @xmath35 .",
    "note that   simply states that @xmath64 is a lyapunov function for the closed - loop system . instead ,",
    "is a more restrictive assumption that essentially states that each agent does not individually contribute in a negative way to the evolution of the lyapunov function .",
    "this latter assumption can in turn be relaxed  @xcite by selecting parameters @xmath73 with @xmath74 ( note that some @xmath75 would be positive and others negative ) and specifying instead that , for each @xmath10 , the left - hand side of   should be less than or equal to  @xmath75 . along these lines , one could envision the design of distributed mechanisms to dynamically adjust these parameters , but we do not go into details here for space reasons .    from an implementation viewpoint ,",
    "the controller @xmath67 requires continuous agent - to - agent communication and continuous updates of the actuator signals , making it unfeasible for practical scenarios . in the following section we develop a self - triggered communication and control strategy to address the issue of selecting time instants for information sharing",
    "this section provides an overview of the self - triggered communication and control approach to solve the problem described in section  [ se : statement ] . in doing so",
    ", we also introduce several concepts that play an important role in our discussion later .",
    "the general idea is to guarantee that the time derivative of the lyapunov function  @xmath64 along the trajectories of the networked cyber - physical system   is less than or equal to @xmath76 at all times , even when the information used by the agents is inexact .",
    "to model the case that agents do not have perfect information about each other at all times , we let each agent @xmath10 keep an estimate @xmath77 of the state of each of its neighbors @xmath78 .",
    "since @xmath30 always has access to its own state , @xmath79 is the information available to agent @xmath30 at time @xmath80 . since agents do not have access to exact information at all times",
    ", they can not implement the controller @xmath67 exactly , but instead use the feedback law @xmath81 we are now interested in designing a triggering method such that agent @xmath30 can decide when @xmath82 needs to be updated .",
    "let @xmath83 be the last time at which all agents have received information from their neighbors .",
    "then , the time @xmath84 at which the estimates should be updated is when @xmath85 unfortunately ,   requires global information and can not be checked in a distributed way .",
    "instead , one can define a local event that defines when a single agent @xmath10 should update its information as any time that @xmath86 as long as each agent  @xmath30 can ensure the local event   has not yet occurred , it is guaranteed that   has not yet occurred either .",
    "the problem with this approach is that each agent @xmath10 needs to have continuous access to information about the state of its neighbors @xmath40 in order to evaluate @xmath87 and check condition  .",
    "the self - triggered approach removes this requirement on continuous availability of information by having each agent employ instead the possibly inexact information about the state of their neighbors .",
    "the notion of reachability set plays a key role in achieving this .",
    "given @xmath88 , the _",
    "reachable set _ of points under   starting from @xmath89 in @xmath90 seconds is , @xmath91   \\rightarrow { { \\mathcal{u}}}_i } \\text{\\rm { such that } } z = e^{a_i s } y + \\int_{0}^{s }    e^{a_i ( s-\\tau ) } b_i u_i(\\tau ) d\\tau \\ } .\\end{aligned}\\ ] ] using this notion , if agents have exact knowledge about the dynamics and control sets of its neighboring agents ( but not their controllers ) , each agent can construct , each time state information is received , sets that are guaranteed to contain their neighbors states .    if @xmath92 is the time at which agent  @xmath30 receives state information @xmath93 from its neighbor @xmath94 , then the _ guaranteed set _ is given by @xmath95 and is guaranteed to contain @xmath96 for @xmath97 .",
    "we let @xmath98 when the starting state @xmath93 and time @xmath92 do not need to be emphasized .",
    "we denote by @xmath99 the information available to agent @xmath30 at time @xmath80 .",
    "[ re : computing - reachable - sets ] finding the guaranteed or reachable sets   can be in general computationally expensive .",
    "a common approach consists of computing over - approximations to the actual reachable set via convex polytopes or ellipsoids .",
    "there exist efficient algorithms to calculate and store these for various classes of systems , see e.g. ,  @xcite .",
    "furthermore , agents can deal with situations where they do not have exact knowledge about the dynamics of their neighbors ( so that the guaranteed sets can not be computed exactly ) by employing over - approximations of the actual guaranteed sets .    with the guaranteed sets in place",
    ", we can now provide a test that allows agents to determine when they should update their current information and control signals . at time @xmath92 ,",
    "agent @xmath30 computes the next time @xmath100 to acquire information via @xmath101 by   and the fact that @xmath102 , at time @xmath92 , @xmath103 if all agents use this triggering criterion for updating information , it is guaranteed that @xmath104 at all times because , for each @xmath10 , the true state @xmath96 is guaranteed to be in @xmath105 for all @xmath106 and @xmath107 .",
    "the condition   is appealing because it can be evaluated by agent @xmath30 with the information it possesses at time @xmath92 .",
    "once determined , agent @xmath30 schedules that , at time @xmath108 , it will request updated information from its neighbors .",
    "we refer to @xmath109 as the _ self - triggered request time _ for agent @xmath30 . due to the conservative way in which @xmath108 is determined ,",
    "it is possible that @xmath110 for some @xmath30 , which would mean that instantaneous information updates are necessary ( note that this can not happen for all @xmath10 unless the network state is already in @xmath61 ) .",
    "this can be dealt with by introducing a dwell time such that a minimum amount of time must pass before an agent can request new information and using the safe - mode controller while waiting for the new information .",
    "we do not enter into details here and defer the discussion to section  [ se : selftime ] .",
    "the problem with the self - triggered approach is that the resulting times are often conservative because the guaranteed sets can grow large quickly as they capture all possible trajectories of neighboring agents .",
    "it is conceivable that improvements can be made from tuning the guaranteed sets based on what neighboring agents _ plan _ to do rather than what they _ can _ do .",
    "this observation is at the core of the team - triggered approach proposed next .",
    "this section presents the team - triggered approach for the real - time implementation of distributed controllers on networked cyber - physical systems .",
    "the team - triggered approach incorporates the reactive nature of event - triggered approaches and , at the same time , endows individual agents with the autonomy characteristic of self - triggered approaches to determine when and what information is needed .",
    "agents make promises to their neighbors about their future states and inform them if these promises are violated later ( hence the connection with event - triggered control ) . with the extra information provided by the availability of the promises , each agent computes the next time that an update is required and requests information from their neighbors accordingly to guarantee the monotonicity of the lyapunov function @xmath64 introduced in section  [ se : statement ] ( hence the connection with self - triggered control ) .      a _ promise _ can be either a time - varying set of states ( state promise ) or controls ( control promise ) that an agent sends to another agent .    a _ state promise _ that agent @xmath111 makes to agent @xmath30 at time @xmath80 is a set - valued , continuous ( with respect to the hausdorff distance ) function @xmath112 \\in \\mathcal{c}^0([t ,      \\infty ) ; { \\mathbb{p}^\\text{cc}}({{\\mathcal{x}}}_j))$ ] .",
    "a _ state promise rule _ for agent @xmath113 generated at time @xmath80 is a continuous ( with respect to the distance @xmath114 defined in  ) map of the form @xmath115 .",
    "the notation @xmath112(t')$ ] conveys the promise @xmath116(t')$ ] that agent @xmath39 makes at time @xmath80 to agent @xmath30 about time  @xmath117 .",
    "a state promise rule is simply a way of generating state promises .",
    "this means that if agent @xmath39 must send information to agent @xmath30 at time @xmath80 , it sends the state promise @xmath112 = { r^\\text{s}}_j({x_{{{\\mathcal{n}}}}}^j[\\cdot]_{|[t,\\infty ) } ) $ ] .",
    "we require that , in the absence of communication delays or noise in the state measurements , the promises generated by a rule have the property that @xmath112(t ) = \\ { x_j(t ) \\}$ ] . for simplicity ,",
    "when the time at which a promise is received is not relevant , we use the notation @xmath118 $ ] , or simply @xmath119 .",
    "all promise information available to agent @xmath10 at some time @xmath80 is given by @xmath120_{|[t , \\infty ) } = ( { x_i}_{|[t,\\infty ) } , \\",
    "{ x_j^i[\\cdot]_{|[t,\\infty ) } \\}_{j \\in { { \\mathcal{n}}}(i ) } ) \\in \\mathcal{c}^0 \\left (    [ t,\\infty ) ; \\prod_{j \\in { { \\mathcal{n}}}(i ) \\cup \\ { i\\ } } { \\mathbb{p}^\\text{cc}}({{\\mathcal{x}}}_j ) \\right)$ ] . to extract information from this about a specific time @xmath121 , we use @xmath120(t')$ ] or simply @xmath122(t ' ) \\}_{j \\in { { \\mathcal{n}}}(i ) } ) \\in \\prod_{j \\in    { { \\mathcal{n}}}(i ) \\cup \\ { i\\ } } { \\mathbb{p}^\\text{cc}}({{\\mathcal{x}}}_j)$ ] .",
    "the generality of the above definitions allow promise sets to be arbitrarily complex but we restrict ourselves to promise sets that can be described with a finite number of parameters .",
    "[ re : control - promises - rules ] alternative to directly sending state promises , agents can share their promises based on their control rather than their state .",
    "the notation @xmath123(t')$ ] conveys the promise @xmath124(t')$ ] that agent  @xmath39 makes at time @xmath80 to agent @xmath30 about time  @xmath117 .",
    "given the dynamics of agent @xmath39 and state @xmath96 at time @xmath80 , agent @xmath30 can compute the state promise for  @xmath117 , @xmath125(t ' ) & = \\ { z \\in { { \\mathcal{x}}}_j \\ ; | \\ ; \\exists \\ , { u_j :   [ t ,          t ' ]   \\rightarrow { { \\mathcal{u}}}_j } \\text { with } u_j(s ) \\in u_j^i[t](s ) \\text { for }        s \\in [ t , t ' ]        \\\\        & \\hspace*{3 cm } \\text { such that } z = e^{a_j ( t'-t ) } x_j(t ) +        \\int_{t}^{t ' } e^{a_j ( t'-\\tau ) } b_j u_j(\\tau ) d\\tau \\ } .",
    "\\notag      \\end{aligned}\\ ] ] as an example , given @xmath113 , a continuous control law @xmath126 , and @xmath127 , the _ ball - radius control promise rule _ for agent  @xmath39 generated at time  @xmath80 is @xmath128_{|[t,\\infty ) } ) ( t')=        { \\overline{b}(u_j({x_{{{\\mathcal{n}}}}}^j(t)),\\delta_j ) } \\cap { { \\mathcal{u}}}_j \\qquad t '        \\geq t .",
    "\\end{aligned}\\ ] ] note that this promise is a ball of radius @xmath129 in the control space @xmath130 centered at the control signal used at time  @xmath80 . depending on whether @xmath129 is constant or changes with time",
    ", we refer to it as the static or dynamic ball - radius rule , respectively .",
    "the promise can be sent with three parameters , the state @xmath96 when the promise was sent , the control action @xmath131 at that time , and the radius  @xmath129 of the ball .",
    "the state promise can then be generated using  .",
    "promises allow agents to predict the evolution of their neighbors more accurately , which directly affects the network behavior . in general , tight promises correspond to agents having good information about their neighbors , which at the same time may result in an increased communication effort ( since the promises can not be kept for long periods of time ) . on the other hand ,",
    "loose promises correspond to agents having to use more conservative controls due to the lack of information , while at the same time potentially being able to operate for longer periods of time without communicating ( because promises are not violated ) .",
    "the availability of promises equips agents with set - valued information models about the state of other agents .",
    "this fact makes it necessary to address the definition of distributed controllers that operate on sets , rather than points .",
    "we discuss this in section  [ se : controllers - set - valued ] .",
    "the additional information that promises represent is beneficial to the agents because it decreases the amount of uncertainty when making action plans .",
    "section  [ se : selftime ] discusses this in detail . finally , these advantages rely on the assumption that promises hold throughout the evolution .",
    "as the state of the network changes and the level of task completion evolves , agents might decide to break former promises and make new ones .",
    "we examine this in section  [ se : brokenpromises ] .      here",
    "we discuss the type of controllers that the team - triggered approach relies on .",
    "the underlying idea is that , since agents possess set - valued information about the state of other agents through promises , controllers themselves should be defined on sets , rather than on points .",
    "there are different ways of designing controllers that operate with set - valued information depending on the type of system , its dynamics , or the desired task , see e.g. ,  @xcite . for the problem of interest here",
    ", we offer the following possible goals .",
    "one may be interested in simply decreasing the value of a lyapunov function as fast as possible , at the cost of more communication or sensing .",
    "alternatively , one may be interested in choosing the stabilizing controller such that the amount of required information is minimal at a cost of slower convergence time .",
    "we consider continuous ( with respect to the hausdorff distance ) controllers of the form @xmath132 that satisfy    [ eq : social - assumptions ] @xmath133    in other words , if exact , singleton - valued information is available to the agents , then the controller  @xmath134 guarantees the monotonic evolution of the lyapunov function  @xmath64 .",
    "we assume that @xmath134 is distributed over the communication graph  @xmath35 .",
    "as before , this means that for each @xmath10 , the @xmath30th component @xmath135 can be computed with information in @xmath136 rather than in the full space @xmath137 .",
    "controllers of the above form can be derived from the availability of the controller @xmath62 introduced in section  [ se : statement ] .",
    "specifically , let @xmath138 be a continuous map that is distributed over  @xmath35 and satisfies , for each @xmath41 , that @xmath139 for each @xmath140 and @xmath141 for each @xmath142 .",
    "essentially , what the map @xmath143 does for each agent is select a point from the set - valued information that it possesses .",
    "now , define @xmath144 note that this controller satisfies   and   because  @xmath67 satisfies   and  .",
    "[ ex : estimate ] here we construct a controller @xmath134 using   for the case when promises are generated according to the ball - radius control rule described in remark  [ re : control - promises - rules ] .",
    "to do so , note that it is sufficient to define the map @xmath145 only for tuples of sets of the form given in  , where the corresponding control promise is defined by  . with the notation of remark  [ re : control - promises - rules ] , recall that the promise that an agent @xmath39 sends at time @xmath80 is conveyed through three parameters @xmath146 , the state @xmath147 when the promise was sent , the control action @xmath148 at that time , and the radius  @xmath129 of the ball",
    "we can then define the @xmath39th component of the map @xmath143 as @xmath149(t'),\\dots , x_n[t](t ' ) ) = e^{a_j ( t'-t ) } y_j +        \\int_{t}^{t ' } e^{a_j ( t'-\\tau ) } b_j v_j d\\tau ,      \\end{aligned}\\ ] ] which is guaranteed to be in @xmath150(t')$ ] for  @xmath151 .",
    "this specification amounts to each agent @xmath30 calculating the evolution of its neighbors @xmath106 as if they were using a zero - order hold control .",
    "here we discuss how agents use the promises received from other agents to generate self - triggered information requests in the future .",
    "let @xmath92 be some time at which agent @xmath30 receives updated information ( i.e. , promises ) from its neighbors .",
    "until the next time information is obtained , agent  @xmath30 has access to the collection of functions @xmath152 describing its neighbors state and can compute its evolution under the controller  @xmath134 via @xmath153 note that this evolution of agent @xmath30 can be viewed as a promise that it makes to itself , i.e. , @xmath154(t ) = \\ { x_i(t ) \\}$ ] . with this in place",
    ", @xmath30 can schedule the next time @xmath108 at which it will need updated information from its neighbors by computing the worst - case time evolution of @xmath64 along its trajectory among all the possible evolutions of its neighbors given the information contained in their promises .",
    "formally , we define , for @xmath155 , @xmath156 where @xmath157 is the element of @xmath158 corresponding to @xmath30 .",
    "then , the trigger for when agent @xmath30 needs new information from its neighbors is similar to  , where we now use the promise sets instead of the guaranteed sets .",
    "specifically , the critical time at which information is requested is given by @xmath159 , where @xmath160 is an a priori chosen parameter that we discuss below and @xmath161 is implicitly defined by @xmath162 this ensures that for @xmath163 , agent @xmath30 is guaranteed to be contributing positively to the desired task .",
    "we refer to @xmath109 as the self - triggered request time .",
    "the parameter @xmath160 is the _ self - triggered dwell time_. we introduce it because , in general , it is possible that @xmath164 , implying that instantaneous communication is required . the dwell time is used to prevent this behavior as follows .",
    "note that @xmath165 is only guaranteed while @xmath166 $ ] .",
    "therefore , in case that @xmath167 , i.e. , if @xmath168 , agent @xmath30 uses the safe - mode control during @xmath169 $ ] to leave its state fixed .",
    "this design ensures the monotonicity of the evolution of  @xmath64 along the network execution .",
    "the team - triggered controller is defined  by @xmath170 for @xmath171 , where @xmath161 is given by  .",
    "note that the self - triggered dwell time  @xmath172 only limits the frequency at which an agent  @xmath30 can _ request _ information from its neighbors and does not provide guarantees on inter - event times of when its memory is updated or its control is recomputed . if a neighboring agent sends information to agent @xmath30 before this dwell time has expired ( because that agent has broken a promise ) , this triggers agent @xmath30 to update its memory and potentially recompute its control law .",
    "agent promises may need to be broken for a variety of reasons .",
    "for instance , an agent might receive new information from its neighbors , causing it to change its former plans .",
    "another example is given by an agent that made a promise that is not able to keep for as long as it anticipated .",
    "consider an agent @xmath10 that has sent a promise @xmath173 $ ] to a neighboring agent @xmath39 at some time  @xmath83 .",
    "if agent @xmath30 ends up breaking its promise at time @xmath174 , i.e. , @xmath175(t^*)$ ] , then it is responsible for sending a new promise  @xmath176 $ ] to agent  @xmath39 at time @xmath177 , where @xmath178 is an a priori chosen parameter that we discuss below .",
    "this implies that  @xmath30 must keep track of promises made to its neighbors and monitor them in case they are broken .",
    "note that this mechanism is implementable because each agent only needs information about its own state and the promises it has made to determine whether the trigger is satisfied .",
    "the parameter @xmath178 is known as the _ event - triggered dwell time_. we introduce it because , in general , the time @xmath179 between when agent @xmath30 makes and breaks a promise to an agent  @xmath39 might be arbitrarily small .",
    "the issue , however , is that if @xmath180 , agent @xmath39 operates under incorrect information about agent @xmath30 for @xmath181 .",
    "we deal with this by introducing a warning message warn that agent @xmath30 must send to agent @xmath39 when it breaks its promise at time @xmath180 . if agent @xmath39 receives such a warning message , it redefines the promise @xmath182 using the guaranteed sets   as follows , @xmath183(t ) & = \\bigcup_{x_i \\in x_i^j[\\cdot](t^ * ) }    { \\mathbf{x}}_i^j(t , x_i ) = \\bigcup_{x_i \\in x_i^j[\\cdot](t^ * ) }    { \\mathcal{r}}_i(t - t^*,x_i)\\end{aligned}\\ ] ] for @xmath184 , until the new message arrives at time @xmath185 . by definition of the reachable set , the promise @xmath186(t)$ ] is guaranteed to contain @xmath187 for @xmath188 .",
    "[ re : expiration ] it is also possible to set an expiration time  @xmath189 for the validity of promises .",
    "if this in effect and a promise is made at @xmath83 , it is only valid for @xmath190 $ ] .",
    "the expiration of the promise triggers the formulation of a new one .",
    "the combination of the self- and event - triggered information updates described above together with the team - triggered controller  @xmath191 as defined in   gives rise to the team - triggered law , which is formally presented in algorithm  [ tab : social ] .",
    "the self - triggered information request in algorithm  [ tab : social ] is executed by an agent anytime new information is received , whether it was actively requested by the agent , or was received from some neighbor due to the breaking of a promise .    _",
    "( self - trigger information update ) _",
    "+   +    compute own control @xmath192 for @xmath151 using   compute own state evolution @xmath193 for @xmath194 using   compute first time @xmath195 such that @xmath196 schedule information request to neighbors in @xmath197 seconds    _ ( respond to information request ) _ + at any time @xmath80 a neighbor @xmath106 requests information , agent @xmath30 performs :    send new promise @xmath198 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{[t,\\infty)})$ ] to agent @xmath39    _ ( event - trigger information update ) _ + at all times @xmath80 , agent @xmath30 performs :    send warning message warn to agent @xmath39 at time @xmath80 schedule to send new promise @xmath199 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{|[{t_{\\text{last}}}+{t_{\\text{d , event}}},\\infty)})$ ] to agent @xmath39 in @xmath200 seconds send new promise @xmath198 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{|[t,\\infty)})$ ] to agent @xmath39 at time @xmath80    _ ( respond to warning message ) _",
    "+   +    redefine promise set @xmath118(t ' ) = \\cup_{x_j \\in          x_j^i[\\cdot](t ) } { \\mathcal{r}}_j(t'-t , x_j)$ ] for @xmath151",
    "here we analyze the convergence properties of the team - triggered law .",
    "our first result establishes the monotonic evolution of the lyapunov function  @xmath64 along the network trajectories .",
    "[ prop : monotonicfull ] consider a networked cyber - physical system as described in section  [ se : statement ] executing the team - triggered law ( cf .",
    "algorithm  [ tab : social ] ) based on a continuous controller @xmath201 that satisfies   and is distributed over the communication graph  @xmath35 .",
    "then , the function @xmath64 is monotonically nonincreasing along any network trajectory .",
    "we start by noting that the time evolution of @xmath64 under algorithm  [ tab : social ] is continuous and piecewise continuously differentiable .",
    "moreover , at the time instants when the time derivative is well - defined , one has @xmath202 as we justify next , the last inequality follows by design of the team - triggered law . for each @xmath10 , if @xmath203 , then @xmath204 ( cf .  ) . in this case",
    "the corresponding summand of   is exactly  @xmath205 , as defined in  . if @xmath206 , then @xmath207 , for which the corresponding summand of   is exactly @xmath76 .",
    "the next result characterizes the convergence properties of team - triggered coordination strategies .",
    "[ prop : main - convergence ] consider a networked cyber - physical system as described in section  [ se : statement ] executing the team - triggered law ( cf .",
    "algorithm  [ tab : social ] ) with dwell times @xmath208 based on a continuous controller @xmath209 that satisfies   and is distributed over the communication graph  @xmath35 .",
    "then , any bounded network trajectory with uniformly bounded promises asymptotically approaches the desired set  @xmath61 .",
    "the requirements of uniformly bounded promises in proposition  [ prop : main - convergence ] means that there exists a compact set that contains all promise sets .",
    "note that this is automatically guaranteed if the network state space is compact .",
    "alternatively , if the sets of allowable controls are bounded , a bounded network trajectory with expiration times for promises implemented as outlined in remark  [ re : expiration ] would result in uniformly bounded promises .",
    "there are two main challenges in proving proposition  [ prop : main - convergence ] , which we discuss next .",
    "the first challenge is that agents operate asynchronously , i.e. , agents receive and send information , and update their control laws possibly at different times .",
    "to model asynchronism , we use a procedure called analytic synchronization , see e.g.  @xcite .",
    "let the time schedule of agent @xmath30 be given by @xmath210 , where @xmath211 corresponds to the @xmath212th time that agent @xmath30 receives information from one or more of its neighbors ( the time schedule @xmath213 is not known a priori by the agent ) .",
    "note that this information can be received because @xmath30 requests it itself , or a neighbor sends it to @xmath30 because an event is triggered .",
    "analytic synchronization simply consists of merging together the individual time schedules into a global time schedule @xmath214 by setting @xmath215 note that more than one agent may receive information at any given time @xmath216 .",
    "this synchronization is done for analysis purposes only . for convenience",
    ", we identify @xmath2 with @xmath217 via  @xmath218 .",
    "the second challenge is that a strategy resulting from the team - triggered approach has a discontinuous dependence on the network state and the agent promises .",
    "more precisely , the information possessed by any given agent are trajectories of sets for each of their neighbors , i.e. , promises . for convenience ,",
    "we denote by @xmath219 the space that the state of the entire network lives in .",
    "note that this set allows us to capture the fact that each agent @xmath30 has perfect information about itself , as described in section  [ se : statement ] .",
    "although agents only have information about their neighbors , the above space considers agents having promise information about all other agents to facilitate the analysis . this is only done to allow for a simpler technical presentation , and does not impact the validity of the arguments made here .",
    "the information possessed by all agents of the network at some time @xmath80 is collected in @xmath220_{|[t,\\infty ) } , \\dots , x^n[\\cdot]_{|[t,\\infty ) }    \\right ) \\in s,\\end{aligned}\\ ] ] where @xmath221_{|[t,\\infty ) } = \\left ( x_1^i[\\cdot]_{|[t,\\infty ) } ,    \\dots , x_n^i[\\cdot]_{|[t,\\infty ) } \\right ) \\in s_i$ ] . here ,",
    "@xmath222 $ ] is shorthand notation to denote the fact that promises might have been made at different times , earlier than @xmath80 .",
    "the team - triggered lawcorresponds to a discontinuous map of the form @xmath223 .",
    "this fact makes it difficult to use standard stability methods to analyze the convergence properties of the network .",
    "our approach to this problem consists of defining a discrete - time set - valued map @xmath224 whose trajectories contain the trajectories of the team - triggered law .",
    "although this ` over - approximation procedure ' enlarges the set of trajectories to consider , the gained benefit is that of having a set - valued map with suitable continuity properties that is amenable to set - valued stability analysis .",
    "we describe this in detail next .",
    "we start by defining the set - valued map  @xmath225 .",
    "let @xmath226 .",
    "we define the @xmath227th component of all the elements in @xmath228 to be @xmath229 .",
    "the @xmath30th component of the elements in @xmath228 is given by one of following possibilities .",
    "the first possibility models the case when agent @xmath30 does not receive any information from its neighbors . in this case , the @xmath30th component of the elements in @xmath228 is simply the @xmath30th component of @xmath230 , @xmath231 the second possibility models the case when agent @xmath30 has received information ( including a warn message ) from at least one neighbor : the @xmath30th component of the elements in @xmath228 is @xmath232 where each agent has access to its own state at all times ,    @xmath233    ( here , with a slight abuse of notation , we use @xmath191 to denote the controller evaluated at @xmath234 ) and , @xmath235 for @xmath236 , where @xmath237 corresponds to the redefined promise   for @xmath238 as a result of the warning message .",
    "we emphasize two properties of the set - valued map @xmath225 .",
    "first , any trajectory of the team - triggered lawis also a trajectory of the non - deterministic dynamical system defined by  @xmath239 , @xmath240 second , although the map defined by the team - triggered lawis discontinuous , the set - valued map @xmath225 is closed , as we show next ( a set - valued map @xmath241 is closed if @xmath242 , @xmath243 and @xmath244 imply that @xmath245 ) .    [ le : m - closed ] the set - valued map  @xmath246 is closed .    to show this we appeal to the fact that a set - valued map composed of a finite collection of continuous maps is closed  ( * ? ? ? * e1.9 ) . given @xmath247 ,",
    "the set @xmath248 is finitely comprised of all possible combinations of whether or not updates occur for every agent pair @xmath249 . in the case",
    "that an agent @xmath30 does not receive any information from its neighbors , it is trivial to show that   is continuous in @xmath247 because @xmath250 is simply the restriction of @xmath251 to the interval @xmath252 , for each @xmath10 and @xmath106 . in the case that an agent @xmath30 does receive updated information , the above argument still holds for agents @xmath39 that did not send information to agent  @xmath30 .",
    "if an agent @xmath39 sends a warning message to agent @xmath30 , @xmath253 is continuous in @xmath247 by continuity of the reachable sets on their starting point .",
    "if an agent @xmath39 sends a new promise to agent @xmath30 , @xmath254 is continuous in @xmath247 by definition of the function @xmath255 .",
    "finally , one can see that @xmath256 is continuous in @xmath257 from  .",
    "we are now ready to prove proposition  [ prop : main - convergence ] .    here",
    "we resort to the lasalle invariance principle for set - valued discrete - time dynamical systems  ( * ? ? ?",
    "* theorem 1.21 ) .",
    "let @xmath258 , which is closed and strongly positively invariant with respect to  @xmath239 .",
    "a similar argument to that in the proof of proposition  [ prop : monotonicfull ] shows that the function @xmath64 is nonincreasing along  @xmath239 . combining this with the fact that the set - valued map  @xmath239 is closed ( cf .",
    "lemma  [ le : m - closed ] ) , the application of the lasalle invariance principle implies that the trajectories of  @xmath239 that are bounded in the first @xmath36 components approach the largest weakly positively invariant set contained in @xmath259 we now restrict our attention to those trajectories of  @xmath239 that correspond to the team - triggered law .",
    "for convenience , let @xmath260 be the map that extracts the true position information in @xmath247 , i.e. , @xmath261 given a trajectory @xmath262 of the team - triggered lawthat satisfies all the assumptions of the statement of proposition  [ prop : main - convergence ] , the bounded evolutions and uniformly bounded promises ensure that the trajectory  @xmath262 is bounded .",
    "then , the omega limit set @xmath263 is weakly positively invariant and hence is contained in @xmath264 .",
    "our objective is to show that , for any @xmath265 , we have @xmath266 .",
    "we show this reasoning by contradiction .",
    "let @xmath267 but suppose @xmath268 .",
    "this means that @xmath269 for all @xmath10 .",
    "take any agent @xmath30 , by the self - triggered information updates , agent @xmath30 will request new information from neighbors in at most @xmath172 seconds .",
    "this means there exists a state @xmath270 for which agent @xmath30 has just received updated information from its neighbors @xmath271 . since @xmath272 , we know @xmath273 .",
    "we also know , since information was just updated , that @xmath274 is exact for all @xmath106 .",
    "but , by  , @xmath275 because @xmath276 .",
    "this means that each time any agent @xmath30 updates its information , we must have @xmath277 .",
    "however , by  , there must exist at least one agent @xmath30 such that @xmath278 since @xmath279 , which yields a contradiction .",
    "thus for the trajectories of the team - triggered law , @xmath280 implies that @xmath281 .",
    "given the convergence result of proposition  [ prop : main - convergence ] , a termination condition for the team - triggered lawcould be included via the implementation of a distributed algorithm that employs tokens identifying what agents are using safe - model controllers , see e.g. ,  @xcite . also , according to the proof of proposition  [ prop : main - convergence ] , the actual value of the event - triggered dwell time  @xmath282 does not affect the convergence property of the trajectories of the constructed discrete - time set - valued system .",
    "however , the dwell time does affect the rate of convergence of the actual continuous - time system ( as a larger dwell time corresponds to more time actually elapsing between each step of the constructed discrete - time system ) .",
    "[ rem : safe - mode - controller ] the assumption on the availability of the safe - mode controller plays an important role in the proof of proposition  [ prop : main - convergence ] because it provides individual agents with a way of avoiding having a negative impact on the monotonic evolution of the lyapunov function .",
    "we believe this assumption can be relaxed for dynamics that allow agents to execute maneuvers that bring them back to their current state . under such maneuvers ,",
    "the lyapunov function will not evolve monotonically but , at any given time , will always guarantee to be less than or equal to its current value at some future time .",
    "we have not pursued this approach here for simplicity and instead defer it for future work .    the next result states that , under the team - triggered lawwith positive dwell times , the system does not exhibit zeno behavior .",
    "[ le : zeno ] under the assumptions of proposition  [ prop : main - convergence ] , the network executions do not exhibit zeno behavior .    due to the self - triggered dwell time  @xmath172",
    ", the self - triggered information request steps in algorithm  [ tab : social ] guarantee that the minimum time before an agent @xmath30 asks its neighbors for new information is @xmath283 .",
    "similarly , due to the event - triggered dwell time  @xmath282 , agent @xmath30 will never receive more than two messages ( one accounts for promise information , the other for the possibility of a warn message ) from a neighbor @xmath39 in a period of @xmath178 seconds .",
    "this means that any given agent can never receive an infinite amount of information in finite time .",
    "when new information is received , the control law   can only switch a maximum of two times until new information is received again . specifically ,",
    "if an agent @xmath30 is using the normal control law when new information is received , it may switch to the safe - mode controller at most one time until new information is received again . if instead an agent @xmath30 is using the safe - mode control controller when new information is received , it may immediately switch to the normal control law , and then switch back to the safe - mode controller some time in the future before new information is received again .",
    "the result follows from the fact that @xmath284 is finite for each @xmath10 .",
    "dwell times play an important role in preventing zeno behavior .",
    "however , a constant self - triggered dwell time throughout the network evolution might result in wasted communication effort because some agents might reach a state where their effect on the evolution of the lyapunov function is negligible compared to others . in such case , the former agents could implement larger dwell times , thus decreasing communication effort , without affecting the overall performance .",
    "next , we give an example of such an adaptive dwell time scheme .",
    "let @xmath80 be a time at which agent @xmath10 has just received new information from its neighbors @xmath40 .",
    "then , the agent sets its dwell time to @xmath285 for some a priori chosen @xmath286 , @xmath287 . the intuition behind this design is the following .",
    "the value @xmath288 can be interpreted as a measure of how far agent @xmath39 is from reaching a point where it can not no longer contribute positively to the global task . as agents are nearing this point , they are more inclined to use the safe mode control to stay put and hence do not require fresh information .",
    "therefore , if agent @xmath30 is close to this point but its neighbors are not ,   sets a larger self - triggered dwell time to avoid excessive requests for information .",
    "conversely , if agent @xmath30 is far from this point but its neighbors are not ,   sets a small dwell time to let the self - triggered request mechanism be the driving factor in determining when new information is needed . for agent @xmath30 to implement this , in addition to current state information and promises ,",
    "each neighbor @xmath106 also needs to send the value of @xmath289 at time @xmath80 . in the case",
    "that information is not received from all neighbors , agent @xmath30 simply uses the last computed dwell time .",
    "section  [ se : simulations ] illustrates this adaptive scheme in simulation .",
    "this section studies the robustness of the team - triggered approach in scenarios with packet drops , delays , and communication noise .",
    "we start by introducing the possibility of packet drops in the network . for any given message an agent sends to another agent ,",
    "assume there is an unknown probability @xmath290 that the packet is dropped , and the message is never received .",
    "we also consider an unknown ( possibly time - varying ) communication delay @xmath291 in the network for all @xmath80 where @xmath292 is known .",
    "in other words , if agent @xmath39 sends agent @xmath30 a message at time @xmath80 , agent @xmath30 will not receive it with probability @xmath293 or receive it at time @xmath294 with probability @xmath295 .",
    "we assume that small messages ( i.e. , 1-bit messages ) can be sent reliably with negligible delay .",
    "this assumption is similar to the `` acknowledgments '' and `` permission '' messages used in other works , see  @xcite and references therein .",
    "lastly , we also account for the possibility of communication noise or quantization .",
    "we assume that messages among agents are corrupted with an error which is upper bounded by some @xmath296 known to the agents .    with this model , the team - triggered lawas described in algorithm  [ tab : social ] does not guarantee convergence because the monotonic behavior of the lyapunov function no longer holds .",
    "the problem occurs when an agent @xmath39 breaks a promise to agent @xmath30 at some time @xmath80 .",
    "if this occurs , agent @xmath30 will operate with invalid information ( due to the sources of error described above ) and compute @xmath297 ( as defined in  ) incorrectly for @xmath151 .",
    "next , we discuss how the team - triggered lawcan be modified in scenarios with unreliable communication . to deal with communication noise ,",
    "when an agent @xmath30 receives an estimated promise @xmath298 from another agent @xmath39 , it must be able to create a promise set @xmath119 that contains the actual promise that agent @xmath39 intended to send .",
    "we refer to this action as making a promise set valid .",
    "the following example shows how it can be done for the promises described in remark  [ re : control - promises - rules ] .    in the scenario with bounded communication noise , agent @xmath39 sends the control promise conveyed through @xmath299 and @xmath129 , to agent @xmath30 at time @xmath80 as defined in remark  [ re : control - promises - rules ] , but @xmath30 receives instead @xmath300 and @xmath301 , where it knows that @xmath302 , @xmath303 and @xmath304 , given that @xmath305 and @xmath306 are known a priori .",
    "to ensure that the promise agent @xmath30 operates with about agent @xmath39 contains the true promise made by @xmath39 , agent @xmath30 can set @xmath307(t ' ) = { \\overline{b } ( { \\widehat}{u}_j^i({x_{{{\\mathcal{n}}}}}^j(t ) )        , { \\widehat}{\\delta}_j + { \\bar{\\omega}}+ \\bar{\\delta } ) } \\cap { { \\mathcal{u}}}_j \\qquad        t ' \\geq t .",
    "\\end{aligned}\\ ] ] to create the state promise from this , @xmath30 would need the true state @xmath96 of @xmath39 at time @xmath80 .",
    "however , since only the estimate @xmath308 is available , we modify   by @xmath309(t ' ) = \\cup_{y_j \\in { \\overline{b}({\\widehat}{x}_j^i(t),{\\bar{\\omega } } ) } }        \\ { z \\in { { \\mathcal{x}}}_j \\ ; | \\ ; \\exists \\ , { u_j :   [ t , t ' ]   \\rightarrow { { \\mathcal{u}}}_j }        \\text { with } u_j(s ) \\in u_j^i[t](s ) \\text { for } s \\in [ t , t ' ]        \\\\",
    "\\text { such that } z = e^{a_j ( t'-t ) } y_j + \\int_{t}^{t ' }        e^{a_j ( t'-\\tau ) } b_j u_j(\\tau ) d\\tau \\ } .",
    "\\eqoprocend      \\end{gathered}\\ ] ]    we deal with the packet drops and communication delays with warning messages similar to the ones introduced in section  [ se : brokenpromises ] .",
    "let an agent @xmath39 break its promise to agent @xmath30 at time @xmath80 , then agent @xmath39 sends  @xmath30 a new promise set @xmath112 $ ] for @xmath151 and warning message warn .",
    "since agent @xmath30 only receives warn at time @xmath80 , the promise set @xmath112 $ ] may not be available to agent @xmath30 for @xmath310 .",
    "if the packet is dropped , then the message never comes through , if the packet is successfully transmitted , then @xmath112(t')$ ] is only available for @xmath311 . in either case , we need a promise set @xmath118(t')$ ] for @xmath151 that is guaranteed to contain @xmath312 .",
    "we do this by redefining the promise using the reachable set , similarly to  .",
    "note that this does not require the agents to have a synchronized global clock , as the times @xmath121 and @xmath80 are both monitored by the receiving agent @xmath30 . in other words , it is not necessary for the message sent by agent @xmath39 to be timestamped . by definition of reachable set , the promise @xmath118(t')$ ]",
    "is guaranteed to contain @xmath312 for @xmath151 .",
    "if at time @xmath313 , agent @xmath30 has still not received the promise @xmath112 $ ] from  @xmath39 , it can send agent @xmath39 a request req for a new message at which point  @xmath39 would send  @xmath30 a new promise @xmath314 $ ] .",
    "note that warn is not sent in this case because the message was requested from @xmath39 by  @xmath30 and not a cause of @xmath39 breaking a promise to @xmath30 .",
    "the robust team - triggered law , formally presented in algorithm  [ tab : socialdelays ] , ensures the monotonic evolution of the lyapunov function @xmath64 even in the presence of packet drops , communication delays , and communication noise .    _",
    "( self - trigger information update ) _ +   +    create valid promise @xmath112 $ ] with respect to @xmath305 compute own control @xmath192 for @xmath151 using   compute own state evolution @xmath193 for @xmath151 using",
    "compute first time @xmath195 such that @xmath196 schedule information request to neighbors in @xmath197 seconds send agent @xmath39 a request req for new information    _ ( respond to information request ) _ + at any time @xmath80 a neighbor @xmath106 requests information , agent @xmath30 performs :    send new promise @xmath315 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{|[t,\\infty)})$ ] to agent @xmath39    _ ( event - trigger information update ) _ + at all times @xmath80 , agent @xmath30 performs :    send warning message warn to agent @xmath39 schedule to send new promise @xmath316 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{|[{t_{\\text{last}}}+{t_{\\text{d , event}}},\\infty)})$ ] to agent @xmath39 in @xmath200 seconds send new promise @xmath315 =        { r^\\text{s}}_i({x_{{{\\mathcal{n}}}}}^i[\\cdot]_{|[t,\\infty)})$ ] to agent @xmath39    _ ( respond to warning message ) _",
    "+   +    redefine promise set @xmath118(t ' ) = \\cup_{x_j^0 \\in          x_j^i[\\cdot](t ) } { \\mathcal{r}}_j(t'-t , x_j^0)$ ] for @xmath151 send agent @xmath39 a request req for new information    the next result establishes the asymptotic correctness guarantees on the robust team - triggered law . in the presence of communication noise or delays ,",
    "convergence can be guaranteed only to a set that contains the desired set  @xmath61 .",
    "[ cor : unreliable - convergence ] consider a networked cyber - physical system as described in section  [ se : statement ] with packet drops occurring with some unknown probability @xmath317 , messages being delayed by some known maximum delay @xmath318 , and communication noise bounded by  @xmath305 , executing the robust team - triggered law ( cf .",
    "algorithm  [ tab : socialdelays ] ) with dwell times @xmath208 based on a continuous controller @xmath209 that satisfies   and is distributed over the communication graph  @xmath35 .",
    "let @xmath319 then , any bounded network trajectory with uniformly bounded promises asymptotically converges to @xmath320 with probability 1 .",
    "we begin by noting that by equation  , the definition  , and the continuity of @xmath134 , @xmath61 can be written as @xmath321 one can see that @xmath322 by noticing that , for any @xmath323 , @xmath324 , no matter which point @xmath325 is taken , one has @xmath326 . to show that the bounded trajectories of the robust team - triggered lawconverge to  @xmath327 , we begin by noting that all properties of  @xmath239 used in the proof of proposition  [ prop : main - convergence ] still hold in the presence of packet drops , delays , and communication noise as long as the time schedule  @xmath213 is unbounded for each agent  @xmath328 .",
    "in order for the time schedule @xmath213 to be unbounded , each agent @xmath30 must receive an infinite number of messages , and @xmath329 .",
    "since packet drops have probability @xmath317 , the probability that there is a finite number of updates for any given agent @xmath30 over an infinite time horizon is  @xmath76 .",
    "thus , with probability  @xmath330 , there are an infinite number of information updates for each agent . using a similar argument to that of lemma  [ le : zeno ]",
    ", one can show that the positive dwell times @xmath331 ensure that zeno behavior does not occur , meaning that @xmath332 . then , by the analysis in the proof of proposition  [ prop : main - convergence ] , the bounded trajectories of  @xmath239 still converge to @xmath333 as defined in  .",
    "for a bounded evolution @xmath262 of the robust team - triggered law , we have that @xmath334 is weakly positively invariant .",
    "note that , since agents may never have exact information about their neighbors , we can no longer leverage properties   and   to precisely characterize  @xmath263 .",
    "we now show that for any @xmath335 , we have @xmath336 .",
    "let @xmath335 .",
    "this means that @xmath337 for all @xmath10 .",
    "take any agent @xmath30 , by the robust team - triggered law , agent @xmath30 will request new information from neighbors in at most @xmath172 seconds .",
    "this means there exists a state @xmath338 for which agent @xmath30 has just received updated , possibly delayed , information from its neighbors @xmath106 . since @xmath339 , we know @xmath340 .",
    "we also know , since information was just updated , that @xmath341 .",
    "since @xmath342 , we know that @xmath343 , for all @xmath328 .",
    "this means that @xmath344 , thus @xmath345 .    from the proof of corollary  [ cor : unreliable - convergence ]",
    ", one can see that the modifications made to the robust team - triggered lawmake the omega limit sets of its trajectories larger than those of the team - triggered law , resulting in @xmath346 .",
    "the set  @xmath327 depends on the lyapunov function  @xmath64 .",
    "however , the difference between @xmath347 and  @xmath61 vanishes as @xmath305 and @xmath318 vanish .",
    "in this section we present simulations of coordination strategies derived from the team- and self - triggered approaches in a planar multi - agent formation control problem .",
    "our starting point is the distributed coordination algorithm based on graph rigidity analyzed in  @xcite which makes the desired network formation locally ( but not globally ) asymptotically stable . in this regard",
    ", the state space @xmath348 of section  [ se : statement ] corresponds to the domain of attraction of the desired equilibria and , as long as the network trajectories do not leave this set , the convergence results still hold .",
    "the local convergence result of the team - triggered approach here is only an artifact of the specific example and , in fact , if the assumptions   are satisfied globally , then the system is globally asymptotically stabilized .",
    "the interested reader is referred to  @xcite for a similar study in a optimal networked deployment problem where the assumptions hold globally .",
    "consider @xmath349 agents communicating over a graph which is only missing the edge @xmath350 from the complete graph .",
    "the agents seek to attain a rectangle formation of side lengths @xmath330 and @xmath351 .",
    "each agent has unicycle dynamics , @xmath352 where @xmath353 and @xmath354 are the control inputs .",
    "the safe - mode controller is then simply @xmath355 . the distributed control law is defined as follows .",
    "each agent computes a goal point @xmath356 where @xmath357 is the pre - specified desired distance between agents @xmath30 and @xmath39 , and @xmath358 denotes the unit vector in the direction of @xmath359 .",
    "then , the control law is given by @xmath360^t \\cdot ( p_i^*(x ) -",
    "x_i ) , { u_{\\text{max}}}\\ } , 0    \\right\\rbrace ,    \\\\                v_i^ * & = \\max \\left\\lbrace \\min \\ { k(\\angle ( p_i^*(x ) - x_i ) -      \\theta_i ) , { v_{\\text{max}}}\\ } , -{v_{\\text{max}}}\\right\\rbrace , \\end{aligned}\\ ] ] where @xmath361 is a design parameter . for our simulations we set @xmath362 .",
    "this continuous control law essentially ensures that the position @xmath42 moves towards @xmath363 when possible while the unicycle rotates its orientation towards this goal .",
    "this control law ensures that @xmath364 given  by @xmath365 is a nonincreasing function for the closed - loop system to establish the asymptotic convergence to the desired formation .",
    "for the team - triggered approach , we use both static and dynamic ball - radius promise rules . the controller  @xmath191 is then defined by  , where controller  @xmath134 is given by   as described in example  [ ex : estimate ] .",
    "note that although the agent has no forward velocity when using the safe controller , it will still rotate in place .",
    "the initial conditions are @xmath366 , @xmath367 , @xmath368 , and @xmath369 and @xmath370 for all @xmath30 .",
    "we begin by simulating the team - triggered approach using fixed dwell times of @xmath371 and @xmath372 and the static ball - radius promise of remark  [ re : control - promises - rules ] with the same radius @xmath373 for all agents .",
    "figure  [ fig : trajectories ] shows the trajectories of the team - triggered law .    [ cc][cc ] agent 1 [ cc][cc ] agent 2 [ cc][cc ] agent 3 [ cc][cc ] agent 4 [ cc][cc ] team - triggered law [ cc][cc ] self - triggered law        to compare the team- and self - triggered approaches , we denote by @xmath374 the number of times  @xmath30 has requested new information ( and thus has received a message from each one of its neighbors ) and by @xmath375 the number of messages @xmath30 has sent to a neighboring agent because it decided to break its promise .",
    "the total number of messages for an execution is @xmath376 .",
    "figure  [ fig : social ] compares the number of required communications in both approaches .",
    "remarkably , for this specific example , the team - triggered approach outperforms the self - triggered approach in terms of required communication without sacrificing any performance in terms of time to convergence ( the latter is depicted through the evolution of the lyapunov function in figure  [ fig : social - adaptive](b ) below ) .",
    "less overall communication has an important impact on reducing network load . in figure",
    "[ fig : social](a ) , we see that very quickly all agents are requesting information as often as they can ( as restricted by the self - triggered dwell time ) , due to the conservative nature of the self - triggered time computations . in the execution of the team - triggered lawin figure  [ fig : social](b ) , we see that the agents are requesting information from one another less frequently .",
    "figure  [ fig : social](c ) shows that agents were required to break a few promises early on in the execution .",
    "[ cc][cc ] agent 1 [ cc][cc ] agent 2 [ cc][cc ] agent 3 [ cc][cc ] agent 4 [ cc][cc ] [ cc][cc]5 [ cc][cc]10 [ cc][cc]15 [ cc][cc]20 [ cc][cc]25 [ cc][cc]30 [ cc][cc ] [ cc][cc]35 [ cc][cc]40 [ cc][cc]45 [ cc][cc]50 [ cc][cc ] [ cc][cc]60 [ cc][cc ] [ cc][cc]70 [ cc][cc]80 [ cc][cc]90 [ cc][cc]100 [ cc][cc]0.5 [ cc][cc]1 [ cc][cc]1.5 [ cc][cc]2 [ cc][cc]2.5 [ cc][cc]3.5 [ cc][cc]3 [ cc][cc]4 [ cc][cc]6 [ cc][cc]7 [ cc][cc]8 [ cc][cc]9 [ cc][cc]0    ( -158,65)@xmath377 ( -80,-5 ) time ( -158,65)@xmath377 ( -80,-5 ) time ( -158,65)@xmath378 ( -80,-5)time    [ cc][cc]0.5 [ cc][cc]0.45 [ cc][cc]0.4 [ cc][cc]0.35 [ cc][cc]0.3 [ cc][cc]0.25 [ cc][cc]0.2 [ cc][cc]0.15 [ cc][cc]0.1 [ cc][cc]0.05 [ cc][cc]0.6 [ cc][cc]0.8 [ cc][cc]100 [ cc][cc]300 [ cc][cc]200 [ cc][cc]500 [ cc][cc]600 [ cc][cc]700 [ cc][cc]400 [ cc][cc]900 [ cc][cc]500 [ cc][cc]800 [ cc][cc]1000 [ cc][cc]1200 [ cc][cc]1 [ cc][cc]1.5 [ cc][cc]0    ( -225,105)@xmath379 ( -107,5)@xmath380 ( -222,105)@xmath381 ( -107,5)@xmath380    next , we illustrate the role that the tightness of promises has on the network performance . with the notation of remark  [ re : control - promises - rules ] for the static ball - radius rule ,",
    "let @xmath382 . note that when @xmath383 , the promise generated by   is a singleton , i.e. , an exact promise .",
    "on the other hand , when @xmath384 , the promise generated by   contains the reachable set , corresponding to no actual commitment being made ( i.e. , the self - triggered approach ) .",
    "figure  [ fig : changinglambda ] compares the value of the lyapunov function after a fixed amount of time ( 30 seconds ) and the total number of messages sent @xmath381 between agents by this time for varying tightness of promises .",
    "the dwell times here are fixed at @xmath371 and @xmath372 .",
    "note that a suitable choice of  @xmath380 helps greatly reduce the amount of communication compared to the self - triggered approach ( @xmath385 ) while maintaining a similar convergence rate .",
    "finally , we demonstrate the added benefits of using adaptive promises and dwell times . figure  [ fig : social - adaptive](a ) compares the total number of messages sent in the self - triggered approach and the team - triggered approaches with fixed promises and dwell times ( fpfd ) , fixed promises and adaptive dwell times ( fpad ) , adaptive promises and fixed dwell times ( apfd ) , and adaptive promises and dwell times ( apad ) .",
    "the parameters of the adaptive dwell time used in   are @xmath386 and @xmath387 . for agent @xmath388 , the radius  @xmath129 of the dynamic ball - radius rule of remark  [ re : control - promises - rules ]",
    "is @xmath389 .",
    "this plot shows the advantage of the team - triggered approach in terms of required communication over the self - triggered one and also shows the additional benefits of implementing the adaptive promises and dwell time .",
    "this is because by using the adaptive dwell time , agents decide to wait longer periods for new information while their neighbors are still moving . by using the adaptive promises , as agents near convergence , they are able to make increasingly tighter promises , which allows them to request information from each other less frequently . as figure  [ fig : social - adaptive](b )",
    "shows , the network performance is not compromised despite the reduction in communication .",
    "[ cc][cc ] self - triggered [ cc][cc ] team - triggered fpfd [ cc][cc ] team - triggered fpad [ cc][cc ] team - triggered apfd [ cc][cc ] team - triggered apad [ cc][cc ] agent 4 [ cc][cc ] [ cc][cc]10 [ cc][cc]5 [ cc][cc]15 [ cc][cc]25 [ cc][cc]20 [ cc][cc]30 [ cc][cc]40 [ cc][cc]50 [ cc][cc]60 [ cc][cc]70 [ cc][cc]80 [ cc][cc]90 [ cc][cc]100 [ cc][cc]150 [ cc][cc]200 [ cc][cc]250 [ cc][cc]300 [ cc][cc]350 [ cc][cc]400 [ cc][cc]450 [ cc][cc]500 [ cc][cc]600 [ cc][cc]700 [ cc][cc]400 [ cc][cc]900 [ cc][cc]500 [ cc][cc]800 [ cc][cc]1000 [ cc][cc]0.5 [ cc][cc]1 [ cc][cc]1.5 [ cc][cc]0    ( -225,105)@xmath381 ( -110,4)time ( -205,105)@xmath64 ( -110,4)time",
    "we have proposed a novel approach , termed team - triggered , that combines ideas from event- and self - triggered control for the implementation of distributed coordination strategies for networked cyber - physical systems .",
    "our approach is based on agents making promises to each other about their future states .",
    "if a promise is broken , this triggers an event where the corresponding agent provides a new commitment . as a result ,",
    "the information available to the agents is set - valued and can be used to schedule when in the future further updates are needed .",
    "we have provided a formal description and analysis of team - triggered coordination strategies and have also established robustness guarantees in scenarios where communication is unreliable .",
    "the proposed approach opens up numerous venues for future research . among them",
    ", we highlight the robustness under disturbances and sensor noise , more general models for individual agents , the design of team - triggered implementations that guarantee the invariance of a desired set in distributed scenarios , the relaxation of the availability of the safe - mode control via controllers that allow agents to execute maneuvers that bring them back to their current state , relaxing the requirement on the negative semidefiniteness of the derivative of the lyapunov function along the evolution of each individual agent , methods for the systematic design of controllers that operate on set - valued information models , understanding the implementation trade - offs in the design of promise rules , analytic guarantees on the performance improvements with respect to self - triggered strategies , and the impact of evolving topologies on the generation of promises .        c.  nowzari and j.  corts , `` robust team - triggered coordination of networked cyber - physical systems , '' in _ control of cyber - physical systems _",
    "( d.  c. tarraf , ed . ) , vol .",
    "449 of _ lecture notes in control and information sciences _ , pp .",
    "317336 , new york : springer , 2013 .",
    "j.  sztipanovits , x.  koutsoukos , g.  karsai , n.  kottenstette , p.  antsaklis , v.  gupta , b.  goodwine , j.  baras , and s.  wang , `` toward a science of cyber  physical system integration , '' _ proceedings of the ieee _ ,",
    "100 , no .  1 ,",
    "pp .  2944 , 2012 .",
    "k.  j. astrm and b.  m. bernhardsson .",
    ", `` comparison of riemann and lebesgue sampling for first order stochastic systems , '' in _ ieee conf .  on decision and control",
    "_ , ( las vegas , nv ) , pp .",
    "20112016 , dec .",
    "2002 .",
    "m.  c.  f. donkers and w.  p. m.  h. heemels , `` output - based event - triggered control with guaranteed l@xmath391-gain and improved and decentralised event - triggering , '' _ ieee transactions on automatic control _ , vol .",
    "57 , no .  6 , pp .",
    "13621376 , 2012 .",
    "e.  garcia and p.  j. antsaklis , `` model - based event - triggered control for systems with quantization and time - varying network delays , '' _ ieee transactions on automatic control _",
    "58 , no .  2 , pp .",
    "422434 , 2013 .",
    "m.  althoff , c.  l. guernic , and b.  h. krogh , `` reachable set computation for uncertain time - varying linear systems , '' in _ proceedings of the 14th international conference on hybrid systems : computation and control _ , ( chicago , il ) , pp .  93102 , 2011 .",
    "g.  frehse , `` phaver : algorithmic verification of hybrid systems past hytech , '' in _ hybrid systems : computation and control _ ( m.  morari and l.  thiele , eds . ) , vol .",
    "3414 of _ lecture notes in computer science _ , pp .",
    "258273 , heidelberg , germany : springer , 2005 .",
    "f.  bullo , j.  corts , and s.  martnez , _ distributed control of robotic networks_. applied mathematics series , princeton university press , 2009 .",
    "electronically available at http:/@xmath392/coordinationbook.info .",
    "m.  guinaldo , d.  lehmann , j.  s. moreno , s.  dormido , and k.  h. johansson , `` distributed event - triggered control with network delays and packet losses , '' in _ ieee conf .  on decision and control",
    "_ , ( hawaii , usa ) , pp .  16 , dec ."
  ],
  "abstract_text": [
    "<S> this paper studies the real - time implementation of distributed controllers on networked cyber - physical systems . </S>",
    "<S> we build on the strengths of event- and self - triggered control to synthesize a unified approach , termed team - triggered , where agents make promises to one another about their future states and are responsible for warning each other if they later decide to break them . the information provided by these promises </S>",
    "<S> allows individual agents to autonomously schedule information requests in the future and sets the basis for maintaining desired levels of performance at lower implementation cost . </S>",
    "<S> we establish provably correct guarantees for the distributed strategies that result from the proposed approach and examine their robustness against delays , packet drops , and communication noise . </S>",
    "<S> the results are illustrated in simulations of a multi - agent formation control problem . </S>"
  ]
}