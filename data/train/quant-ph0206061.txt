{
  "article_text": [
    "the methods of quantum error correction @xcite have , in principle , provided a means for suppressing destructive decoherence in quantum computer memories and quantum communication channels . in practice , however , a finite - sized error - correcting code can only protect against a subset of possible errors ; one expects that protected information will still degrade , albeit to a lesser degree .",
    "the problem of characterizing a quantum code s performance could thus be phrased as follows : what are the effective noise dynamics of the encoded information that result from the physical noise dynamics in the computing or communication device ?",
    "one could address this question by direct simulation of the quantum dynamics and coding procedure .",
    "however , for codes of non - trivial size , this approach rapidly becomes intractable .",
    "for example , in studies of fault - tolerance @xcite one often considers families of concatenated codes @xcite .",
    "an @xmath0-qubit code concatenated with itself @xmath1 times yields an @xmath2-qubit code , providing better error resistance with increasing @xmath1 . for even modest values of @xmath0 and @xmath1 , simulation of the resulting @xmath3-dimensional hilbert space",
    "requires massive computational resources ; using simulation to find the asymptotic performance as @xmath4 ( as required for fault - tolerant applications ) is simply not on option .    instead",
    ", a quantum code is often characterized by the set of discrete errors that it can perfectly correct @xcite .",
    "for example , the shor nine - bit code @xcite was designed to perfectly correct arbitrary decoherence acting on a single bit in the nine - bit register .",
    "typical analyses of such codes implicitly assume that the physical dynamics can be described by single - bit errors occurring at some probabilistic rate ; if this rate is small ( e.g. @xmath5 for @xmath6 ) , the probability that these errors will accumulate into a multi - bit uncorrectable error is also small ( e.g. @xmath7 ) .",
    "this type of leading - order analysis is limited to a weak - noise regime , and to error models strongly resembling the errors against which the code protects .",
    "outside of this regime , these approximation methods fail to accurately describe the evolution of the encoded information .    in this work",
    "we take a different approach to characterizing error - correcting codes , which leads to a simple , exact analysis for arbitrary error models .",
    "as suggested above , a code transforms the physical dynamics of the device into the effective dynamics of the encoded information . in section",
    "[ sec : effective ] we derive this transformation for arbitrary noise , and present a compact method for its calculation .    in the case of",
    "identical , uncorrelated noise on individual qubits , this notion becomes particularly natural : encoding a logical qubit in several physical qubits yields an evolution less noisy than if the logical qubit had been stored , unencoded , in a single physical qubit .",
    "thus a code acts a map on the space of qubit dynamics , mapping the dynamics of a single _ physical _ qubit to the dynamics of the encoded _ logical _ qubit . in section [ sec : coding_map ]",
    "we show how to calculate this map , and in section [ sec : concatenated ] we use these maps to dramatically simplify the calculation of effective dynamics for concatenated codes when the physical dynamics do not couple code blocks .    in section [ sec : diagonal ]",
    ", we restrict our attention to uncorrelated single - bit pauli errors , and in section [ sec : performance ] we calculate the exact performance of several codes of interest under these error models .",
    "finally , in section [ sec : thresholds ] we use the coding maps to calculate the performance of certain concatenated codes , and find the exact threshold error probability for perfect fidelity in the infinite concatenation limit .",
    "these thresholds serve as important figures of merit for concatenation schemes , and for the codes considered here we find that the traditional approximate methods underestimate these thresholds by up to @xmath8 .",
    "section [ sec : conclusion ] concludes , suggesting potential future applications for these techniques .",
    "in this section we first describe error - correcting codes using a language that will facilitate the subsequent development .",
    "we will then present our method for exactly describing the effective dynamics of the encoded information .",
    "though for clarity we restrict our discussion to codes storing a single qubit ( sometimes called @xmath9 codes ) all of the presented methods generalize naturally to codes storing quantum information of arbitrary dimension .    as an important preliminary ,",
    "it can be argued @xcite that all physically possible transformations taking quantum states @xmath10 on a hilbert space @xmath11 to states @xmath12 on a hilbert space @xmath13 may be written in the following form : @xmath14 where the @xmath15 are linear operators from @xmath11 to @xmath13 and @xmath16 denotes the identity operator on @xmath11 .",
    "such transformations are called _ quantum operations _ or _ channels _ , and are necessarily linear , trace - preserving , and completely positive .",
    "it is easy to see that the composition of quantum operations is also a quantum operation .",
    "( one also sees definitions requiring only @xmath17 , corresponding to the weaker requirement that a quantum operation be trace non - increasing rather than trace - preserving .",
    "however , the requirement of trace - preservation is better suited to our purposes here .",
    "see @xcite for a discussion of the distinction . )      the error - correction process , consisting of encoding , noise , and decoding , is depicted in figure [ fig : qec_process ] ; we consider each stage in turn .",
    "an @xmath0-qubit code @xmath18 uses a register of @xmath0 qubits to encode a single logical qubit @xmath19+\\beta\\ket[1]$ ] by preparing the register in the state @xmath20+\\beta\\ket[\\1bar]$ ] , where @xmath21 $ ] and @xmath22 $ ] are orthogonal states in the @xmath23-dimensional hilbert space of the register .",
    "the codespace ( i.e. , the space of initial register states ) is spanned by these two states . in",
    "what follows it will be convenient to describe states by density matrices : let the logical qubit be given by @xmath24 and the initial register state by @xmath25 . writing @xmath26+\\ketbra[\\1bar,1]$ ] , the _ encoding operation _",
    "@xmath27 is given by @xmath28 = b\\rho_0 b^\\dagger.\\ ] ] as @xmath29 + \\ketbra[1,1 ] = \\mathbf{1}$ ] , @xmath30 is a quantum operation .     is encoded in an @xmath0-qubit register as @xmath25 .",
    "a noise process transforms the register to state @xmath31 , which is then decoded to yield the logical single - qubit state @xmath32 . ]    after the encoding , the register state evolves due to some noise dynamics . in the setting of a quantum computer memory ,",
    "the dynamics are continuous in time ; assuming evolution for a time @xmath33 , we have @xmath34 $ ] with @xmath35 a quantum operation depending continuously on @xmath33 .",
    "( for master equation evolution @xmath36 $ ] , we have @xmath37 . )",
    "we will often omit the subscript @xmath33 and simply write @xmath38 . in the setting of a quantum communication channel , the noise process is usually given by the discrete application of a quantum operation @xmath38 ; thus if the transmitted state is @xmath25 , the received state is @xmath39 $ ] , which we write as @xmath31 for consistency .",
    "after the noise process , an attempt is made to recover the initial register state @xmath25 from the current register state @xmath31 by applying a quantum operation @xmath40 , which may be written as @xmath41 = \\sum_j a_j \\rho(t ) a_j^\\dagger \\;\\;\\;\\mathrm{with}\\;\\;\\ ; \\sum_j a_j^\\dagger a_j = \\mathbf{1}.\\ ] ] as the initial state @xmath25 is known to be in the codespace , it is clearly more beneficial to return the state @xmath31 to the codespace than to do otherwise : lacking any other information , one could at least prepare the completely mixed state in the codespace @xmath42+\\ketbra[\\1bar,\\1bar])$ ] , yielding an average fidelity of @xmath43 , rather than leaving the register outside the codespace , yielding a fidelity of 0 .",
    "we will therefore restrict our attention to error - correction processes @xmath40 that take all register states back to the codespace .",
    "( i.e. , we assume no leakage errors during recovery . )    with the above assumption , the post - recovery state @xmath44 $ ] has support entirely on the codespace ; thus it can be described by its restriction to the codespace , the logical single - qubit state @xmath32 such that @xmath45 = \\mathcal{r}[\\rho(t)]$ ] .",
    "call @xmath46 the _ decoding operation _",
    "( shown to be a quantum operation in lemma 1 of appendix [ sec : miscellaneous ] ) : @xmath47 = b^\\dagger \\mathcal{r}[\\rho(t ) ] b = \\sum_j b^\\dagger a_j \\rho(t ) a_j^\\dagger b.\\ ] ] with this definition , @xmath48 $ ] .",
    "we will consider the logical state @xmath32 as the outcome of the error - correction process , and therefore may say that the code is given by its encoding and decoding operations , i.e. @xmath49 .    to build intuition for the decoding operation @xmath50 , we note that for most codes considered in the literature ( and all of the specific codes considered later in this paper ) the recovery procedure is given in a particular form .",
    "first , a syndrome measurement is made , projecting the register state onto one of @xmath51 orthogonal two - dimensional subspaces ; let the measurement be specified by projectors @xmath52 .",
    "after the measurement ( whose outcome is given by @xmath53 , the index of the corresponding projector ) , the recovery operator @xmath54 acts on the register , unitarily mapping the subspace projected by @xmath55 back to the codespace .",
    "for such codes , the recovery superoperator is given by ( [ eqn : recovery_kraus ] ) with @xmath56 , and @xmath44 $ ] is the expected state that results from averaging over syndrome measurement outcomes .    for codes of this form ,",
    "let @xmath57 , \\ket[1_j]\\}$ ] denote the orthonormal basis for the syndrome space projected by @xmath55 such that @xmath58 = \\ket[\\0bar]$ ] and @xmath59 = \\ket[\\1bar]$ ] .",
    "then @xmath60 + \\ketbra[\\1bar,1_j]$ ] , and using the expression for @xmath50 given in ( [ eqn : decoding_kraus ] ) yields @xmath61 & = & \\sum_j b^\\dagger r_j p_j \\rho(t ) p_j^\\dagger   r_j^\\dagger b \\\\   & = & \\sum_j ( \\ketbra[0,0_j]+\\ketbra[1,1_j ] ) \\rho(t )              ( \\ketbra[0_j,0]+\\ketbra[1_j,1 ] ) \\end{array}\\ ] ] thus @xmath48 $ ] is the sum of the single - qubit density matrices that result from restricting @xmath31 to each of the syndrome spaces , with basis @xmath57 , \\ket[1_j]\\}$ ] determined by the recovery operator .    as an example , consider the bitflip code @xcite , a three - qubit code that protects against single bitflip errors .",
    "the bitflip code s encoding transformation is given by @xmath62 \\mapsto \\ket[\\0bar ] = \\ket[000 ] , \\;\\;\\ ; \\ket[1 ] \\mapsto \\ket[\\1bar ] = \\ket[111].\\ ] ] after the action of some error dynamics , the syndrome measurement then projects the register state into one of four subspaces : the codespace itself , and the three subspaces that result from flipping the first , second , or third bit of states in the codespace .",
    "the corresponding recovery operator simply flips the appropriate bit back , attempting to reverse the error .",
    "thus the basis specifying the decoding operation is given by @xmath63 = \\ket[000 ] , & \\ket[1_0 ] = \\ket[111 ] , \\\\",
    "\\ket[0_1 ] = \\ket[100 ] , & \\ket[1_1 ] = \\ket[011 ] , \\\\",
    "\\ket[0_2 ] = \\ket[010 ] , & \\ket[1_2 ] = \\ket[101 ] , \\\\",
    "\\ket[0_3 ] = \\ket[001 ] , & \\ket[1_3 ] = \\ket[110]\\phantom { , }   \\end{array } \\right \\}.\\ ] ] we will use the bitflip code as an example throughout this work .      the transformation @xmath64 gives the effective dynamics of the encoded information resulting from the physical dynamics @xmath38 .",
    "let @xmath65 be the map giving these effective dynamics : @xmath66 $ ] . from the above discussion ,",
    "the effective dynamics are simply the result of encoding , followed by noise , followed by decoding , i.e. @xmath67 as @xmath65 is the composition of quantum operations @xmath30 , @xmath38 and @xmath50 , it is itself a quantum operation .",
    "we may therefore call @xmath65 the _ effective channel _ describing the code @xmath68 and physical noise dynamics @xmath38 .    because the effective channel @xmath65 is only a map on single qubit states",
    ", it should have a compact description  in particular , a description much more compact than some arbitrary noise @xmath38 acting on @xmath0-qubit states . by calculating such a compact description",
    ", we may easily find the effective evolution of an arbitrary initial state @xmath24 without explicitly considering the physical noise dynamics .",
    "as we now show , @xmath65 may be written as a @xmath69 matrix with a simple interpretation .",
    "( see @xcite for a full discussion of qubit channels represented in this fashion . )    for each pauli matrix @xmath70 , let @xmath71_0 = \\tr(\\sigma \\rho_0)$ ] .",
    "the pauli matrices form a basis for qubit density matrices , and so the initial logical qubit @xmath24 may linearly parameterized by its expectation values @xmath71_0 $ ] as follows : @xmath72_0 i + \\frac{1}{2}\\expval[x]_0 x +           \\frac{1}{2}\\expval[y]_0 y + \\frac{1}{2}\\expval[z]_0 z.\\ ] ] ( as the trace of a density matrix must be 1 we will always have @xmath73=1 $ ] , but it will be convenient to include this term . ) similarly , the final logical qubit @xmath32 may be linearly parameterized by its expectation values @xmath71_f",
    "= \\tr(\\sigma \\rho_f)$ ] .",
    "thus the effective channel @xmath65 may be written as the mapping from the expectation values @xmath71_0 $ ] of @xmath24 to the expectation values @xmath71_f$ ] of @xmath32 .",
    "writing @xmath74_0 , \\expval[x]_0 , \\expval[y]_0 , \\expval[z]_0)^\\mathrm{t}$ ] and @xmath75_f , \\expval[x]_f , \\expval[y]_f , \\expval[z]_f)^\\mathrm{t}$ ] , the linearity of @xmath65 allows it to be written as the @xmath69 matrix such that @xmath76 .",
    "the fidelity of a pure logical qubit @xmath24 through the effective channel is then given by @xmath77 . thus to fully characterize the effective channel @xmath65 we need only find the entries of its @xmath69 matrix representation .",
    "( more generally , if the code stored a @xmath78-dimensional state rather than the two - dimensional state of a qubit , the logical density matrices @xmath24 and @xmath32 would be expanded in the basis of the identity matrix and the @xmath79 generators of @xmath80 , and @xmath65 would be represented as a @xmath81 matrix . )    to find these matrix elements , we consider the encoding and decoding processes in more detail . letting @xmath82 denote @xmath83 $ ] , the encoding transformation @xmath30 acts on @xmath24 ( given by ( [ eqn : rho_0_param ] ) ) to prepare the initial register state @xmath84_0 e_i + \\expval[x]_0 e_x + \\expval[y]_0 e_y + \\expval[z]_0 e_z.\\ ] ] thus the encoding operation @xmath30 is completely characterized by the @xmath82 operators , which are easily constructed from the codewords : @xmath85+\\ketbra[\\1bar,\\1bar ] ) \\\\ e_x & = & \\frac{1}{2}(\\ketbra[\\0bar,\\1bar]+\\ketbra[\\1bar,\\0bar ] ) \\\\ e_y & = & \\frac{1}{2}(-i\\ketbra[\\0bar,\\1bar]+i\\ketbra[\\1bar,\\0bar ] ) \\\\ e_z & = & \\frac{1}{2}(\\ketbra[\\0bar,\\0bar]-\\ketbra[\\1bar,\\1bar ] ) .",
    "\\end{array}\\ ] ] as expected , @xmath25 is the state @xmath24 on the codespace , and vanishes elsewhere .",
    "now consider the decoding process , which yields the logical state @xmath32 .",
    "we may express the expectation values @xmath71_f$ ] in terms of @xmath31 , the register state prior to recovery , as follows : @xmath86_f & = & \\tr(\\sigma \\rho_f ) = \\tr(\\sigma \\dop[\\rho(t ) ] ) \\\\                    & = & \\tr \\left(\\sum_j \\sigma b^\\dagger a_j \\rho(t )                                         a_j^\\dagger b \\right ) .",
    "\\end{array}\\ ] ] exploiting the cyclic property of the trace and noting that @xmath87 = 2e_\\sigma$ ] , we have @xmath88_f = \\tr(d_\\sigma \\rho(t ) ) \\;\\;\\;\\mathrm{where}\\;\\;\\ ; d_\\sigma = 2\\sum_j a_j^\\dagger e_\\sigma a_j.\\ ] ] thus the decoding operation @xmath50 is completely characterized by the @xmath89 operators .",
    "substituting @xmath90 $ ] into ( [ eqn : sigma_f ] ) , we have @xmath71_f = \\tr(d_\\sigma \\nop[\\rho(0)])$ ] . substituting in the expression for @xmath25 given by ( [ eqn : rho(0)_param ] )",
    "then yields @xmath91_f = \\tr \\left ( d_\\sigma\\nop \\left [ \\sum_{\\sigma ' }                          \\expval[\\sigma']_0 e_{\\sigma ' } \\right ] \\right                          ) .\\ ] ] letting the matrix elements of @xmath65 be given by @xmath92)\\ ] ] for @xmath93 , we have @xmath71_f = \\sum_{\\sigma'}g_{\\sigma\\sigma'}\\expval[\\sigma']_0 $ ] , i.e. @xmath94 .    to completely characterize the effective channel @xmath65 , then , we need only compute these matrix elements .",
    "in fact , trace - preservation ( i.e. @xmath73_f = \\expval[i]_0)$ ] requires @xmath95 and @xmath96 . thus the effect on the logical information of the potentially complex dynamics of the @xmath0-qubit register space",
    "are characterized by the remaining twelve matrix elements of @xmath65 .",
    "if @xmath38 is time - dependent , then the only observable effects of this time - dependence will appear in the time dependence of the @xmath97 , and @xmath98 gives the effective channel for correction performed at time @xmath33 .",
    "note that the dynamics @xmath38 need not be related to those against which the code was designed to protect .",
    "we have thus shown that the effective dynamics may be calculated by evaluating ( [ eqn : g_formula ] ) , which requires constructing the @xmath82 and @xmath89 operators .",
    "the @xmath82 operators are easily understood to be the operators which act as @xmath99 on the codespace and vanish elsewhere ; to build intuition for the @xmath89 operators , consider codes whose recovery is specified by syndrome measurement projectors @xmath52 and recovery operators @xmath100 as discussed in section [ sec : qec_basics ] . for these codes , we have @xmath56 , and so @xmath101",
    ". this expression may be simplified by noting that @xmath82 maps the codespace to itself and vanishes elsewhere , and @xmath54 unitarily maps the space projected by @xmath55 to the codespace .",
    "thus @xmath102 unitarily maps the space projected by @xmath55 to itself and vanishes elsewhere , i.e. @xmath103 .",
    "we therefore have @xmath104 using the expressions for @xmath82 given in ( [ eqn : eops ] ) and @xmath105+\\ketbra[\\1bar,1_j]$ ] , we have @xmath106+\\ketbra[1_j,1_j ] ) \\\\ d_x & = & \\sum_j ( \\ketbra[0_j,1_j]+\\ketbra[1_j,0_j ] ) \\\\ d_y & = & \\sum_j ( -i\\ketbra[0_j,1_j]+i\\ketbra[1_j,0_j ] ) \\\\ d_z & = & \\sum_j ( \\ketbra[0_j,0_j]-\\ketbra[1_j,1_j ] ) .",
    "\\end{array}\\ ] ] thus we see that in this case @xmath89 is simply the sum of the operators @xmath107 acting on each of the syndrome spaces , with @xmath108-eigenstates @xmath109 $ ] and @xmath110 $ ] determined by the recovery procedure .",
    "note that @xmath111 is the identity operator on the entire register space .",
    "one often considers noise models @xmath38 consisting of uncorrelated noise on each of the @xmath0 physical qubits .",
    "this type of model arises naturally in a communication setting , where the register qubits are sent over a noisy transmission line one at a time , and is also appropriate for various physical implementations of a quantum computer .",
    "( by contrast , one can also consider error models in which correlated noise dominates @xcite . ) for such models , we may write @xmath112 where @xmath113 is a quantum operation on a single qubit .    the goal of encoding a qubit is to suppress decoherence : multiple qubits are employed to yield an effective channel @xmath65 , which should be less noisy than the channel resulting from storing information in a single physical qubit , namely @xmath113 .",
    "a code can thus be seen as a map on channels , taking @xmath113 to @xmath65 .",
    "more precisely , for an @xmath0-qubit code @xmath68 , define the corresponding _ coding map _ @xmath114 by @xmath115",
    "we now derive an expression for the coding map @xmath114 of an arbitrary code @xmath49 . in section [ sec : calculating_g ] we described how @xmath65 may be specified by its matrix elements @xmath97 , given by ( [ eqn : g_formula ] ) .",
    "since @xmath113 is a single - qubit quantum operation , it may also be written as a @xmath69 matrix such that if @xmath113 takes @xmath10 to @xmath12 , then @xmath116 . we seek an expression for the matrix elements of the effective channel @xmath65 in terms of the matrix elements of the physical channel @xmath113 .",
    "operators on @xmath0 qubits may be written as sums of tensor products of @xmath0 pauli matrices ; we may therefore write the @xmath117 and @xmath89 operators describing @xmath68 as @xmath118 e.g. , for the bitflip code described in section [ sec : qec_basics ] by ( [ eqn : bitflip_codewords ] ) and ( [ eqn : bitflip_recovery_basis ] ) , we may calculate the @xmath119 and @xmath89 operators using ( [ eqn : eops ] ) and ( [ eqn : dops ] ) ; expanding the results in the basis of pauli operators yields @xmath120 and @xmath121    to find the matrix elements of the effective channel , we substitute ( [ eqn : uncorrelated_noise ] ) , ( [ eqn : e_pauli ] ) , and ( [ eqn : d_pauli ] ) into the expression for these matrix elements given by ( [ eqn : g_formula ] ) .",
    "noting that @xmath122 = \\nop^{(1)}[\\frac{1}{2}\\mu_1 ] \\otimes \\ldots \\otimes \\nop^{(1)}[\\frac{1}{2}\\mu_n]$ ] and @xmath123 yields @xmath124 ) \\right ) .\\ ] ] from the orthogonality of pauli matrices , the matrix @xmath125 , when written as a vector of expectation values , has a 1 in the @xmath126 component and zeros elsewhere .",
    "further , @xmath127 is simply the @xmath128 component of @xmath129 .",
    "thus @xmath130 ) = \\nop^{(1)}_{\\nu_i \\mu_i}$ ] , and we have @xmath131    thus the matrix elements of @xmath65 can be expressed as polynomials of the matrix elements of @xmath113 , with the polynomial coefficients depending only on the @xmath119 and @xmath89 of the code .",
    "these polynomials specify @xmath132 . by computing these polynomials for a code @xmath18",
    ", one can easily calculate the effective channel for the code @xmath18 due to any error model with identical , uncorrelated noise acting on each physical qubit .",
    "( if a different noise model acts on each physical qubit , i.e. @xmath133 , simply replace @xmath134 with @xmath135 in ( [ eqn : g_uncorrelated ] ) . )",
    "we now consider concatenated codes @xcite .",
    "we first describe the procedure for constructing such codes , and then show how the coding maps @xmath132 make the calculation of the effective channels for such codes straightforward .",
    "we now describe how two codes may be concatenated to form a larger code ; the procedure is depicted in figure [ fig : concatenation ] .",
    "let the two codes be an @xmath136-qubit code @xmath137 , called the outer code , and an @xmath0-qubit code @xmath138 , called the inner code .",
    "a logical qubit @xmath24 is encoded first using the outer code @xmath139 , yielding the @xmath136-qubit state @xmath140 $ ] .",
    "each of these qubits is then encoded by the inner code ; i.e. , the map @xmath141 acts on @xmath140 $ ] .",
    "the composition of these encodings forms the encoding map for the concatenated code : @xmath142 the @xmath136 sections of the register encoding each of the @xmath136 qubits in @xmath140 $ ] are called blocks ; each block contains @xmath0 qubits .",
    "after the encoding , a noise process @xmath143 acts on the entire @xmath144-qubit register .",
    "a simple error - correction scheme ( and one that seems reasonable for use in a scalable architecture ) coherently corrects each of the code blocks based on the inner code , and then corrects the entire register based on the outer code .",
    "i.e. , the decoding map for the concatenated code is given by @xmath145 we denote the concatenated code ( with this correction scheme ) by @xmath146 ; note that @xmath147 is an @xmath144-qubit code .",
    "suppose that we have computed the effective channel @xmath65 due to a code @xmath138 with some noise dynamics @xmath38 , and wish to consider the effective channel @xmath148 resulting from the concatenated code @xmath147 .",
    "we assume that each @xmath0-bit block in the register evolves according to the noise dynamics @xmath38 and no cross - block correlations are introduced , i.e. that the evolution operator on the @xmath144-bit register is @xmath149 by definition , we have @xmath148 = @xmath150 . substituting ( [ eqn : etilde ] ) , ( [ eqn : dtilde ] ) and ( [ eqn : ntilde ] ) into this expression yields @xmath151 where we have used @xmath152 .",
    "this result makes sense : each of the @xmath136 blocks of @xmath0 bits represents a single logical qubit encoded in @xmath153 , and as the block has dynamics @xmath38 , this logical qubit s evolution will be described by @xmath65 . comparing with the definition of the coding map ( [ eqn : omega_definition ] ) , we then have @xmath154 thus given the effective channel for a code @xmath153 and an error model , the coding map @xmath155 makes it straightforward to compute the effective channel due to the concatenated code @xmath147 .",
    "further , suppose that the original noise model @xmath38 had the form of uncorrelated noise on single physical qubits , as given by ( [ eqn : uncorrelated_noise ] ) .",
    "then @xmath156 , and so @xmath157 . we may therefore conclude that composing coding maps gives the coding map for the concatenated code , i.e. @xmath158    more generally , we may characterize both the finite and asymptotic behavior of any concatenation scheme involving the codes @xmath159 by computing the maps @xmath160 .",
    "then the finite concatenation scheme @xmath161 is characterized by @xmath162 .",
    "we expect the typical @xmath132 to be sufficiently well - behaved that standard dynamical systems methods @xcite will yield the @xmath4 limit of @xmath163 ; one need not compose the @xmath163 explicitly . in section [ sec : thresholds ] , we will consider such asymptotic limits in more detail .",
    "as an application of the methods presented above , we will consider the commonly - considered error model in which each physical register qubit is subjected to the symmetric depolarizing channel @xcite .",
    "these single - qubit noise dynamics are given by the master equation @xmath164 + \\frac{\\gamma}{4}\\mathcal{l}_y[\\rho ] + \\frac{\\gamma}{4}\\mathcal{l}_z[\\rho]\\ ] ] where for any linear qubit operator @xmath165 the lindblad decoherence operator @xmath166 is given by @xmath167 = c \\rho c^\\dagger - \\frac{1}{2}c^\\dagger c \\rho                  - \\frac{1}{2}\\rho c^\\dagger c\\ ] ] and @xmath168 is a measure of the noise strength .",
    "this master equation is easily solved , yielding a qubit channel with matrix representation @xmath169 before calculating effective channels due to this error model , it will be useful to discuss the more general set of channels whose matrix representation is diagonal .",
    "as we will see , these channels correspond to single - bit pauli channels , and will allow us to demonstrate the power of the techniques developed above .",
    "consider a qubit channel given by a diagonal matrix @xmath113 . from trace preservation @xmath170",
    ", so let the channel with @xmath171 , @xmath172 and @xmath173 be denoted @xmath174 $ ] for compactness .",
    "( thus the depolarizing channel ( [ eqn : depolarizing_matrix ] ) is given by @xmath175 $ ] . ) in @xcite it is shown that complete positivity of such a channel requires @xmath176    now consider the single - bit pauli channel in which the transmitted state is subjected to the pauli operators @xmath177 , @xmath178 , and @xmath108 with exclusive probabilities @xmath179 , @xmath180 , and @xmath181 , i.e. @xmath182 it is easy to show that this channel has the diagonal matrix representation @xmath183,\\ ] ] and so any pauli channel is a diagonal channel .",
    "the converse is also true : choosing @xmath184 , @xmath185 , and @xmath186 yields the channel @xmath174 $ ] , and the complete positivity constraints ( [ eqn : cp_constraints ] ) yield the standard probability rules @xmath187 and @xmath188 .",
    "thus any diagonal channel may be realized as a pauli channel .",
    "pauli channels are among the most commonly considered error models in the literature , and we will restrict our attention to diagonal channels for the remainder of this work .    the effect of a diagonal channel on a qubit is simple to interpret : we have @xmath189_f = x\\expval[x]_0 $ ] , @xmath190_f = y\\expval[y]_0 $ ] , and @xmath191_f = z\\expval[z]_0 $ ] .",
    "thus the @xmath177 , @xmath178 , and @xmath108 components of @xmath192 decay independently , and we may therefore speak of the decoherence of @xmath189 $ ] , @xmath190 $ ] , and @xmath191 $ ] . recalling from section [ sec : calculating_g ] that the fidelity of a pure state @xmath10 through a qubit channel @xmath65 is given by @xmath193 , the respective fidelities of @xmath177- , @xmath178- , and @xmath108-eigenstates through the channel are @xmath194 , @xmath195 , and @xmath196 . more generally , the fidelity of a pure state ( requiring @xmath189 ^ 2+\\expval[y]^2+\\expval[z]^2=1 $ ] ) is given by @xmath197 ^ 2+y\\expval[y]^2+z\\expval[z]^2)$ ] .",
    "a common figure of merit for a channel is the worst - case fidelity of a pure state , which for a diagonal channel is @xmath198 .",
    "thus if for a given error model a code @xmath18 yields an effective channel @xmath174 $ ] and a code @xmath199 yields an effective channel @xmath200 $ ] , we say that @xmath18 outperforms @xmath199 if @xmath201 .",
    "many commonly considered codes are _ stabilizer codes _ @xcite , which are designed to detect and correct pauli errors ; it would therefore not be so surprising if the coding maps for such codes were particularly well - behaved when acting on a pauli channel .",
    "in fact , as proved in appendix [ sec : stabilizer ] , if @xmath18 is a stabilizer code and @xmath113 is diagonal , then @xmath202 is also diagonal . thus just as arbitrary codes act as maps on the space of qubit channels , stabilizer codes act as maps on the space of diagonal qubit channels .",
    "we will now present the effective channels for several codes of interest under diagonal error models .",
    "the codes considered here may all be formulated as stabilizer codes ; thus , as described in the previous section , the effective channels will also be diagonal .",
    "the diagonal elements of the effective channel @xmath203)$ ] may be calculated either using the coding map methods presented in section [ sec : coding_map ] , or using the stabilizer formalism as shown in appendix [ sec : stabilizer ] , which may be computationally advantageous . for each code",
    ", we will compute the effective channel for a general diagonal error model @xmath174 $ ] , and then interpret the results for the symmetric depolarizing channel @xmath204 $ ] .",
    "the bitflip code first mentioned in section [ sec : qec_basics ] is a stabilizer code ; letting @xmath205 denote the corresponding coding map , we find @xmath206)= \\left [ x^3,\\ : \\tfrac{3}{2}x^2 y-\\tfrac{1}{2}y^3 ,               \\ :   \\tfrac{3}{2}z-\\tfrac{1}{2}z^3 \\right ] .\\ ] ] as the bitflip code is only a three - qubit code , it is not unreasonable to check this result with more conventional methods , e.g. by counting bitflip and phaseflip errors , or by working in the heisenberg picture to compute the evolution of the relevant expectation values . however , for larger codes such computations will rapidly become unmanageable .    to examine the bitflip code acting under the symmetric depolarizing channel ,",
    "define @xmath207 = \\omega^\\btf(\\ndep_t)$ ] ; the functions @xmath208 , @xmath209 , and @xmath210 are plotted in figure [ fig : bitflip_performance ] along with @xmath211 ( describing the decoherence of the physical qubits ) for comparison .",
    "we see that @xmath212 , and thus the decoherence of @xmath191 $ ] is suppressed by the bitflip code .",
    "however , @xmath213 , and thus the decoherences of @xmath189 $ ] and @xmath190 $ ] are increased by the bitflip code .",
    "$ ] due to the bitflip code under the symmetric depolarizing channel .",
    "the respective fidelities of @xmath177 , @xmath178 and @xmath108 eigenstates for correction performed at time @xmath33 are given by @xmath214 , @xmath215 , and @xmath216 .",
    "[ fig : bitflip_performance ] ]    more generally , for any @xmath217 we have @xmath218 and @xmath219 , so for any physical channel in this regime the bitflip code always suppresses decoherence of @xmath191 $ ] and increases decoherence of @xmath189 $ ] .",
    "decoherence of @xmath190 $ ] is suppressed when @xmath220 and @xmath221 , and increased for all other positive values of @xmath222 and @xmath223 .",
    "we may therefore conclude that under a general pauli channel the bitflip code increases the fidelity of some transmitted states at the expense of others , and thus the bitflip code is outperformed by storing the logical qubit in a single physical bit .",
    "however , as the bitflip code is designed to only protect against physical bitflip ( @xmath177 ) errors , it should not be expected to perform well in the presence of arbitrary pauli errors . if we consider physical channels with only @xmath177 errors , we find that the bitflip code suppresses decoherence of all encoded states .",
    "more precisely , suppose that the physical qubits are evolving via a pauli channel ( [ eqn : pauli_channel ] ) with only @xmath177 errors , i.e. @xmath224 . then @xmath174 = [ 1,1 - 2p_x,1 - 2p_x]$ ] , and @xmath225 ) = [ 1,1-\\frac{3}{2}p_x^2 + \\frac{1}{2}p_x^3 , 1-\\frac{3}{2}p_x^2 + \\frac{1}{2}p_x^3]$ ] .",
    "thus we have reproduced the usual result of a leading - order analysis : the bitflip code suppresses decoherence due to @xmath177 errors to order @xmath226 .",
    "now consider the three - qubit phaseflip code @xcite , with encoding @xmath227 \\mapsto \\ket[\\pm\\pm\\pm]$ ] for @xmath227 = \\frac{1}{\\sqrt{2}}(\\ket[0]+\\ket[1])$ ] .",
    "this code is completely analogous to the bitflip code , detecting and correcting single phaseflip ( @xmath108 ) errors instead of single bitflip ( @xmath177 ) errors .",
    "the phaseflip code s coding map @xmath228 is exactly the same as that of the bitflip code , with the role of @xmath177 and @xmath108 interchanged : @xmath229)= \\left [ \\tfrac{3}{2}x-\\tfrac{1}{2}x^3,\\ : \\tfrac{3}{2}z^2 y-\\tfrac{1}{2}y^3 , \\ : z^3 \\right ] .\\ ] ] the concatenation phaseflip(bitflip ) yields the shor nine - bit code @xcite with encoding @xmath227 \\mapsto \\frac{1}{\\sqrt{8}}(\\ket[000 ] \\pm \\ket[111])^{\\otimes 3}$ ] .",
    "thus @xmath230 .",
    "evaluating this composition using the coding maps ( [ eqn : poly_bit ] ) and ( [ eqn : poly_phase ] ) , @xmath231 ) & = & \\omega^\\phf(\\omega^\\btf([x , y , z ] ) ) \\nonumber \\\\ & = & [ p(x),q(x , y , z),r(z)]\\end{aligned}\\ ] ] where @xmath232 ( the combinatoric analysis required to reproduce this result by counting bitflip and phaseflip errors would be quite tedious ! )    to examine the shor code acting on the symmetric depolarizing channel , let @xmath233 = \\omega^\\shor(\\ndep_t)$ ] ; the functions @xmath234 , @xmath235 and @xmath236 are plotted in figure [ fig : shor_performance ] .",
    "we see that for short times ( or equivalently , weak noise - strength @xmath168 ) , the shor code suppresses decoherence of @xmath189 $ ] , @xmath190 $ ] , and @xmath191 $ ] . for long times",
    ", however , the code increases the decoherence of all three expectation values , and as @xmath237 , in an intermediate regime the code suppresses the decoherence of some of the expectation values while increasing that of others .",
    "thus to suppress the decoherence of an arbitrary logical state , correction needs to be performed at a time @xmath33 when @xmath238 .",
    "$ ] due to the shor code under the symmetric depolarizing channel .",
    "[ fig : shor_performance ] ]    above we defined the phaseflip code by the encoding @xmath227 \\mapsto \\ket[\\pm\\pm\\pm]$ ] ; we could have also used the encoding given by @xmath239 \\mapsto \\ket[+++]$ ] , @xmath240\\mapsto \\ket[---]$ ] . call the code with this encoding phaseflip@xmath241 , with coding map @xmath242 . as this modification of the phaseflip code simply interchanges the encoded @xmath177- and @xmath108-eigenstates ,",
    "the new effective channel is simply that of the original phaseflip code with the effects of the channel on the @xmath177 and @xmath108 components of @xmath192 interchanged : @xmath243 ) = [ z^3,\\frac{3}{2}z^2 y-\\frac{1}{2}y^3 , \\frac{3}{2}x-\\frac{1}{2}x^3]$ ] ( compare to ( [ eqn : poly_phase ] ) ) .",
    "we could then use this version of the phaseflip code to define an alternative version of the shor code with the encoding @xmath239 \\mapsto \\frac{1}{\\sqrt{8}}(\\ket[000 ] + \\ket[111])^{\\otimes 3}$ ] , @xmath240 \\mapsto \\frac{1}{\\sqrt{8}}(\\ket[000 ] - \\ket[111])^{\\otimes 3}$ ] . call this code shor@xmath241 , with corresponding coding map @xmath244 .",
    "we find @xmath245 ) = [ r(z),q(x , y , z),p(x)].\\ ] ] with the polynomials @xmath246 , @xmath247 and @xmath248 defined by ( [ eqn : poly_shor ] ) .",
    "comparing to ( [ eqn : form_poly_shor ] ) , we see that again this modification of the shor code simply interchanges the effect of the channel on @xmath177 and @xmath108 components of @xmath192 . assuming that the encoded logical states are randomly distributed ( as opposed to always sending @xmath108-eigenstates , for example ) ,",
    "the choice of using the shor code or the shor@xmath241 code is simply one of aesthetics : the effective channels are identical up to interchange of the decoherence of @xmath189 $ ] and @xmath191 $ ] .",
    "however , as we will see in the next section , this choice does have an impact when these codes are concatenated .    for comparison ,",
    "we consider two other stabilizer codes of interest .",
    "the steane code @xcite is a seven - bit code designed to correct errors consisting either of a pauli error ( @xmath177 , @xmath178 , or @xmath108 ) on a single qubit of the codeword , or of an @xmath177 and a @xmath108 error on separate qubits .",
    "we find @xmath249 ) = [ s(x),t(x , y , z),s(z)]\\ ] ] with @xmath250 let @xmath251 = \\omega^\\steane(\\ndep_t)$ ] ; we find that the functions @xmath252 , @xmath253 and @xmath254 are qualitatively similar to the analogous functions of the shor code .",
    "if they were plotted in figure [ fig : shor_performance ] , these functions would be interspersed between the plotted curves : for all values of @xmath255 , we have @xmath256 .",
    "though the shor code more effectively suppresses decoherence for logical @xmath108-eigenstates , the steane code performs better in the worst case ( @xmath178-eigenstates ) , and thus outperforms the shor code .",
    "the five - bit code @xcite corrects pauli errors on a single qubit of the codeword .",
    "we find @xmath257 ) =   [ u(x , y , z),u(y , z , x),u(z , x , y)]\\ ] ] with @xmath258 letting @xmath259 = \\omega^\\five(\\ndep_t)$ ] yields @xmath260 , as expected from the symmetries of the code and of the map @xmath261 .",
    "thus the fidelity of a state through this channel is independent of the state .",
    "these functions also have qualitatively similar behavior to those plotted in figure [ fig : shor_performance ] , and for @xmath255 we have @xmath262 .",
    "thus the five - bit code outperforms both the shor and steane codes .",
    "we now consider the effective channel due to families of concatenated codes under the symmetric depolarizing channel .",
    "first , consider the shor code concatenated with itself @xmath1 times , denoted by shor@xmath263 . from section [ sec : concatenated ] , we know that the coding map for this code is given by @xmath264 . as @xmath265 takes diagonal channels to diagonal channels , the effective channel due to shor@xmath263 is also diagonal .",
    "let @xmath266 = ( \\omega^\\shor)^\\ell(\\ndep_t),\\ ] ] which may be calculated using the polynomials of @xmath267 given in ( [ eqn : poly_shor ] ) .",
    "the functions @xmath268 for @xmath269 are plotted in figure [ fig : shor_pointwise_z ] .",
    "we immediately observe that as @xmath270 the functions @xmath268 approach a step function . denoting the step function s time of discontinuity by @xmath271",
    ", we have @xmath272 where @xmath273 for @xmath274 , each layer of concatenation decreases the @xmath191 $ ] decoherence , yielding perfect preservation of the encoded @xmath191 $ ] information in the infinite concatenation limit .",
    "however , for @xmath275 , the @xmath191 $ ] decoherence increases .",
    "thus in the infinite concatenation limit , the code will perfectly protect @xmath191 $ ] of the logical qubit if correction is performed prior to @xmath271 ; if correction is performed after this time , all @xmath191 $ ] information is lost .    , where @xmath276 $ ] is the effective channel for @xmath1 concatenations of the shor code under the symmetric depolarizing channel .",
    "[ fig : shor_pointwise_z ] ]    similarly , the functions @xmath277 and @xmath278 approach step function limits as @xmath4 ; call the discontinuous times of these step functions @xmath279 and @xmath280 . to perfectly protect an arbitrary state in the infinite concatenation limit , correction must be performed prior to @xmath281 .",
    "we call @xmath282 the _ storage threshold_. ( we use the term `` storage threshold '' to indicate that the threshold takes into account only noise in the register , rather than gate or measurement errors also considered in fault - tolerant settings . )",
    "we now show how the coding map @xmath267 may be used to find this threshold .",
    "observe in figure [ fig : shor_pointwise_z ] that the plots of @xmath268 all intersect at a point @xmath283 .",
    "writing @xmath267 in the form ( [ eqn : form_poly_shor ] ) , we have @xmath284 . the function @xmath285 is plotted in figure [ fig : r(z ) ] .",
    "we see that the map @xmath286 has fixed points at @xmath287 , @xmath288 , and a point @xmath289 .",
    "( we find @xmath290 by numerically solving @xmath291 on the interval @xmath292 . )",
    "iterating the map pushes points in the interval @xmath293 toward @xmath287 , and pushes points in the interval @xmath294 toward @xmath288 . in the language of dynamical systems",
    "@xcite , @xmath287 and @xmath288 are attracting fixed points , and @xmath290 is a repelling fixed point .",
    "this behavior leads to the shape of the plots in figure [ fig : shor_pointwise_z ] .",
    "we then invert @xmath295 to find @xmath296 .",
    "the function @xmath297 has the same qualitative behavior on @xmath292 as @xmath285 , so we may similarly find @xmath298 and @xmath299 .",
    "( plotted as the thick curve ) .",
    "observe that the map @xmath286 has fixed points at 0 , 1 , and @xmath290 .",
    "the arrows depict the iteration of this map pushing points in the interval @xmath293 toward 0 and points in the interval @xmath294 toward 1 .",
    "[ fig : r(z ) ] ]    we can not use the same method to find @xmath280 , as @xmath300 is a function of @xmath301 , @xmath302 and @xmath303 , not just of @xmath302 alone .",
    "( this problem is evident from plots of the functions @xmath278 : though these functions approach a step function in the @xmath4 limit , they do not all intersect at a point as the plots of @xmath268 do . )",
    "however , we now argue that finding @xmath279 and @xmath271 is sufficient to find @xmath280 . for @xmath304 , @xmath305 and @xmath306 . using the complete positivity constraints ( [ eqn : cp_constraints ] )",
    ", we find that if @xmath174 $ ] is a channel , @xmath307 implies @xmath308 .",
    "since the space of channels @xmath174 $ ] is closed and bounded ( it consists of the boundary and interior of a tetrahedron in @xmath309 ) , @xmath305 and @xmath306 implies @xmath310 . now for @xmath311 , @xmath312 and @xmath313 . using the complete positivity constraints ( [ eqn : cp_constraints ] ) , we find that if @xmath174 $ ] is a channel , @xmath314 and @xmath315 implies @xmath316 .",
    "thus we may conclude that for these values of @xmath33 , @xmath317 .",
    "we now have @xmath318 for @xmath304 , and @xmath319 for @xmath320 , thus we conclude @xmath321 . more generally , if we know @xmath279 and @xmath271 , then @xmath280 is given by @xmath322 .",
    "we may therefore conclude that @xmath323 , and so @xmath324 .",
    "( the value of @xmath280 could also be obtained from the dynamics of the polynomial maps @xmath246 , @xmath247 and @xmath248 without making reference to the complete positivity constraint , but the method presented here requires less argumentation . )    we may also phrase these thresholds in the language of finitely probable errors . consider the symmetric pauli channel given by ( [ eqn : pauli_channel ] ) with @xmath325 .",
    "this channel subjects a qubit to a random pauli error with probability @xmath326 , and is described by @xmath327 $ ] .",
    "observe that the symmetric pauli channel and the symmetric depolarizing channel are related by @xmath328 .",
    "thus in the infinite concatenation limit with @xmath329 acting on each register qubit , the @xmath71 $ ] of the logical qubit will be perfectly protected if @xmath330 .",
    "define the threshold probability @xmath331 ; for @xmath332 , all encoded qubits are perfectly protected in the infinite concatenation limit .",
    "values for @xmath333 and @xmath334 appear in table [ tbl : asymptotics ] .",
    ".code storage threshold results .",
    "( see text for discussion . )",
    "[ tbl : asymptotics ] [ cols=\"^,^,^,^,^,^,^\",options=\"header \" , ]     we now use similar methods to derive thresholds for the shor@xmath241 , steane , and five - bit codes presented in the previous section .",
    "first , consider the shor@xmath241 code .",
    "let @xmath335 = ( \\omega^{\\shor'})^\\ell(\\ndep_t)$ ] .",
    "the @xmath336 approach a step function as @xmath4 , but @xmath337 and @xmath338 approach a limit cycle of period 2 : we find that @xmath339 and @xmath340 both approach @xmath341 for some value of @xmath342 , while @xmath343 and @xmath344 approach @xmath345 for some distinct value of @xmath346 . from the form of @xmath347 given in ( [ eqn : form_poly_shor_prime ] ) , we see that @xmath348 is a function of @xmath349 , and @xmath350 a function of @xmath351 , so it is not so surprising that the sequence @xmath352 converges and the sequence @xmath353 converges . to find the threshold , we simply consider the sequence of channels @xmath354 $ ] , generated by the map @xmath355 . from ( [ eqn : form_poly_shor_prime ] ) we see that @xmath356 and @xmath357 .",
    "thus to find the values @xmath279 , @xmath280 and @xmath271 , we find the fixed points of the maps @xmath358 and @xmath359 , and proceed as with the shor code . as shown in table [ tbl : asymptotics ] , we find that , compared to the shor code , the shor@xmath241 code has greater values for @xmath279 and @xmath280 , and a lesser value for @xmath271 .",
    "as the threshold @xmath282 is given by the minimum of these three values , the shor@xmath241 code outperforms the shor code in the infinite concatenation limit .",
    "the map @xmath360 , given by ( [ eqn : poly_steane ] ) , has the same form as the shor code map ( [ eqn : form_poly_shor ] ) , and therefore we can use the same methods to find the steane code thresholds .",
    "the map @xmath261 , given by ( [ eqn : poly_five ] ) , has a different form .",
    "however , as @xmath361 has the symmetric form @xmath362 $ ] and @xmath261 preserves this symmetry by taking @xmath362 $ ] to @xmath363 $ ] , we may find @xmath364 simply by finding the fixed point of @xmath365 .",
    "results are summarized in table [ tbl : asymptotics ] .",
    "we find that the five - bit code has the largest threshold , and therefore the best performance in the infinite concatenation limit .",
    "it is interesting to note that the shor@xmath241 code outperforms the steane code in the infinite concatenation limit , even though the opposite is true for only one layer of each code .",
    "we conclude our discussion of the thresholds by comparing the exact values of @xmath334 to those calculated with traditional leading - order techniques ( e.g. in @xcite ) .",
    "first consider the five - bit code . under the symmetric pauli channel @xmath329 , a physical qubit is unmodified with probability @xmath366 .",
    "the five - bit code perfectly protects its encoded information if no more than one of the five physical qubits are subjected to a pauli error . under @xmath329 ,",
    "the probability of no errors on any physical qubit is @xmath367 , and the probability of exactly one error is @xmath368 .",
    "we then assume that all greater - weight errors are uncorrectable , and find that the probability of a correctable error is @xmath369 .",
    "the threshold value @xmath334 is the value of @xmath326 at which the single physical qubit and the encoded information have the same probability of error .",
    "thus to estimate the threshold we solve @xmath370 , yielding @xmath371 .",
    "thus the leading - order calculation underestimates the actual threshold ( 0.1376 ) by @xmath372 .",
    "( the assumption that all errors of greater weight are uncorrectable assures that the approximation underestimates , rather than overestimates , the threshold . )",
    "the steane code corrects all weight - one errors , and weight - two errors consisting of an @xmath177 on one bit and a @xmath108 on another bit .",
    "a similar calculation finds the probability of a correctable error to be @xmath373 , yielding @xmath374 , a @xmath375 underestimate .",
    "the shor code corrects all weight - one errors , and weight - two errors such that any @xmath177 and @xmath178 operators occur in different blocks , and any @xmath178 and @xmath108 errors occur in the same block .",
    "the probability of a correctable error is found to be @xmath376 , yielding @xmath377 , a @xmath378 underestimate .",
    "the analysis is exactly the same for the shor@xmath241 code , yet the shor@xmath241 code has a very different threshold ; in this case , the leading - order result underestimates the threshold by @xmath8 .",
    "we have shown how a code s performance for a given error model can be described by the effective channel for the encoded information .",
    "the methods presented for calculating the effective channel have allowed us to find the performance of several codes of interest under single - bit pauli channels , and further have allowed us to find thresholds describing these codes asymptotic limits of concatenation under the symmetric depolarizing channel . though we chose to restrict our attention to diagonal channels , these methods can be applied to any uncorrelated error model ( e.g. the amplitude - damping channel @xcite , which is non - diagonal ) , and will substantially simplify the exact analysis of code performance in these more general settings .",
    "we believe that this effective channel description of code performance may be useful in other contexts as well .",
    "for example , this work could be extended to take account of encoding and decoding circuit errors , thereby providing a method for calculating exact fault - tolerant thresholds .",
    "also , by providing a comprehensive method for describing the performance of a quantum code without reference to a particular error model ( e.g. bitflip and phaseflip errors ) perhaps these methods will allow us to address open questions such as the optimal code for a given error model , and the quantum channel capacity .",
    "this work was partially supported by the caltech muri center for quantum networks and the nsf institute for quantum information . b.r .",
    "acknowledges the support of an nsf graduate fellowship , and thanks j. preskill and p. parrilo for insightful discussions .",
    "in this appendix we consider the effective channel @xmath379 when @xmath113 is diagonal and @xmath18 is a stabilizer code .",
    "we show that @xmath65 is also diagonal , and show how the stabilizer formalism facilitates its calculation .",
    "the reader unfamiliar with stabilizer codes is directed to @xcite for an introduction , and to @xcite for a more complete discussion .    since @xmath113 is diagonal , the terms @xmath380 in the expression for the effective channel ( [ eqn : g_uncorrelated ] )",
    "vanish for @xmath381 .",
    "thus we have @xmath382 dramatically simplifying the calculation of @xmath65 . the coefficients @xmath383 and @xmath384 are defined in terms of the @xmath119 and @xmath89 operators in ( [ eqn : e_pauli ] ) and ( [ eqn : d_pauli ] ) ; to calculate these operators we now consider the code @xmath18 in more detail .",
    "let @xmath18 be a stabilizer code given by stabilizer @xmath385 , storing one qubit in an @xmath0-qubit register .",
    "the stabilizer @xmath386 defines the codespace , and the logical operators @xmath387 determine the particular basis of codewords @xmath21 $ ] , @xmath22 $ ] .",
    "recall that the @xmath119 operators act as @xmath388 on the codespace and vanish elsewhere .",
    "it can be shown that @xmath389 acts as a projector onto the codespace , and by definition the logical operators @xmath390 act as @xmath391 on the codespace .",
    "thus @xmath392 will act as @xmath388 on the codespace and vanish elsewhere .    as an example , consider the bitflip code introduced in section [ sec : qec_basics ] .",
    "the bitflip code may be specified as a stabilizer code , with @xmath393 , @xmath394 , @xmath395 , @xmath396 , @xmath397 .",
    "the above expression reproduces the expressions for the @xmath119 presented in ( [ eqn : bitflip_eops ] ) . without the stabilizer formalism ,",
    "deriving ( [ eqn : bitflip_eops ] ) is an exercise in expanding projectors in a basis of pauli operators ; with this method the computation is very simple .",
    "we now construct the @xmath89 operators for the stabilizer code . as in section [ sec : qec_basics ] , let @xmath52 be the projectors describing the syndrome measurement . for a stabilizer code , the recovery operators @xmath54 are each chosen to be a pauli operator taking the space projected by @xmath55 back to the codespace",
    ". consider the expression for @xmath89 given by ( [ eqn : dops_nobasis ] ) ; substituting in the expression ( [ eqn : eops_stabilizer ] ) for @xmath82 , we have @xmath398 now because @xmath54 , @xmath399 and @xmath400 are all pauli operators , they either commute or anti - commute . for two pauli operators @xmath401 and @xmath402 , let @xmath403 for @xmath404 . commuting the @xmath54 to the left in the above expression and noting that @xmath405 , @xmath406 with @xmath407 .",
    "again , as an example consider the stabilizer definition of the bitflip code .",
    "the recovery operators are @xmath408 , @xmath409 , @xmath410 , and @xmath410 . evaluating the above expression for @xmath89 yields the previous result of ( [ eqn : bitflip_dops ] ) .    using the expressions ( [ eqn : eops_stabilizer ] ) and ( [ eqn : dops_stabilizer ] ) for the @xmath119 and @xmath89 operators in the stabilizer formalism , we we will now find the coefficients @xmath383 and @xmath411 as defined in ( [ eqn : e_pauli ] ) and ( [ eqn : d_pauli ] ) .",
    "since @xmath412 is a pauli operator , the sums ( [ eqn : eops_stabilizer ] ) and ( [ eqn : dops_stabilizer ] ) are expansions of these operators @xmath119 and @xmath89 in the pauli basis ; if we were to write down these sums explicitly for a given stabilizer code , the coefficients @xmath413 and @xmath414 could be read off immediately , e.g. from ( [ eqn : bitflip_eops ] ) and ( [ eqn : bitflip_dops ] ) .",
    "this approach may be formalized as follows .",
    "first , note that @xmath399 and @xmath400 are both hermitian pauli operators , and they commute ; therefore their product is also a hermitian pauli operator , i.e. @xmath415 . for any operator @xmath416 with @xmath417 , let @xmath418 , and let @xmath419 such that @xmath420 .",
    "then , using @xmath421 , we may re - write ( [ eqn : eops_stabilizer ] ) and ( [ eqn : dops_stabilizer ] ) as @xmath422    comparing ( [ eqn : eops_stabilizer_phi ] ) with the definition of @xmath423 in ( [ eqn : e_pauli ] ) , we see that each term of the sum over @xmath424 contributes to a single coefficient @xmath425 , as @xmath426 is of the form @xmath427 . similarly , each term in ( [ eqn : dops_stabilizer_phi ] ) contributes to a single coefficient @xmath428 .",
    "lemma 2 of appendix [ sec : miscellaneous ] shows that @xmath429 unless @xmath430 and @xmath431 .",
    "thus each term in ( [ eqn : eops_stabilizer_phi ] ) contributes to a _ distinct _",
    "coefficient @xmath425 , and each term in ( [ eqn : dops_stabilizer_phi ] ) contributes to a _ distinct _ coefficient @xmath428 .",
    "we may therefore simply read off the coefficients from ( [ eqn : eops_stabilizer_phi ] ) and ( [ eqn : dops_stabilizer_phi ] ) , yielding @xmath432 and all other @xmath423 and @xmath433 vanishing .",
    "we now evaluate @xmath434 where @xmath435 $ ] using ( [ eqn : g_uncorrelated_diag ] ) .",
    "the only non - vanishing terms @xmath384 occur when @xmath436 for some @xmath424 and @xmath107 , and the only the only non - vanishing terms @xmath383 occur when @xmath437 for some @xmath424 and @xmath391 .",
    "thus the coefficients @xmath438 of ( [ eqn : g_uncorrelated_diag ] ) will vanish unless @xmath439 for some @xmath424 and @xmath440 .",
    "as proved in lemma 2 of appendix [ sec : miscellaneous ] , this can not happen when @xmath441 .",
    "thus all the matrix elements @xmath442 vanish when @xmath441 , i.e. @xmath65 is diagonal",
    ".    having demonstrated that the coding map @xmath132 of a stabilizer code @xmath18 takes diagonal channels to diagonal channels , and because @xmath443 from trace preservation , we need only compute @xmath444 , @xmath445 , and @xmath446 using ( [ eqn : g_uncorrelated_diag ] ) to find @xmath203)$ ] . these computations can be performed using the methods of section [ sec : coding_map ] , but we conclude this section by expressing these elements using the stabilizer formalism , which may be computationally advantageous .",
    "consider the diagonal terms @xmath447 given by ( [ eqn : g_uncorrelated_diag ] ) .",
    "we need only sum over the non - vanishing coefficients @xmath413 and @xmath414 , which are given by ( [ eqn : alpha_stabilizer ] ) and ( [ eqn : beta_stabilizer ] ) .",
    "substituting in these expressions yields @xmath448 where @xmath449 denotes @xmath126 for @xmath450 .",
    "now as @xmath451 $ ] , the product of the matrix elements of @xmath113 in the previous expression is simply a product of @xmath222 s , @xmath223 s and @xmath452 s ; each factor appears as many times as ( respectively ) @xmath177 , @xmath178 and @xmath108 appear in @xmath453 .",
    "letting @xmath454 denote the @xmath107-weight of a pauli operator @xmath326 , e.g. @xmath455 , we have @xmath456          _ proof : _ from ( [ eqn : decoding_kraus ] ) we have @xmath457 = \\sum_j b^\\dagger a_j \\rho a_j^\\dagger b.\\ ] ] to prove that @xmath50 is a quantum operation , we must show @xmath458 where @xmath16 is the identity on the register space . as we assumed that @xmath40 maps all states into the codespace , we can choose the operators @xmath15 to only have range on the codespace .",
    "with such a choice , @xmath459+\\ketbra[\\1bar,\\1bar])a_j = a_j^\\dagger bb^\\dagger a_j$ ] .",
    "we therefore have @xmath460 from ( [ eqn : recovery_kraus ] ) we have @xmath461 , and so @xmath50 is a quantum operation .",
    "@xmath462      _",
    "proof : _ suppose we have @xmath467 ; then @xmath468 . as the stabilizers @xmath399 and @xmath469 act trivially on the codespace , @xmath412 and @xmath470 act respectively as @xmath107 and @xmath471 on the codespace .",
    "thus we must have @xmath472 , which requires @xmath431 and the @xmath473 sign be positive .",
    "we now have @xmath474 ; right - multiplying by @xmath400 yields @xmath475 , and thus @xmath476 . @xmath462"
  ],
  "abstract_text": [
    "<S> when a logical qubit is protected using a quantum error - correcting code , the net effect of coding , decoherence ( a physical channel acting on qubits in the codeword ) and recovery can be represented exactly by an effective channel acting directly on the logical qubit . in this paper we describe a procedure for deriving the map between physical and effective channels that results from a given coding and recovery procedure . </S>",
    "<S> we show that the map for a concatenation of codes is given by the composition of the maps for the constituent codes . </S>",
    "<S> this perspective leads to an efficient means for calculating the exact performance of quantum codes with arbitrary levels of concatenation . </S>",
    "<S> we present explicit results for single - bit pauli channels . for certain codes under the symmetric depolarizing channel </S>",
    "<S> , we use the coding maps to compute exact threshold error probabilities for achievability of perfect fidelity in the infinite concatenation limit .    bar bar </S>"
  ]
}