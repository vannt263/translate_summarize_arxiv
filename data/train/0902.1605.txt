{
  "article_text": [
    "in the basic data stream model , the input consists of a stream of data items which can be read only sequentially , one after the other . for processing these data items",
    ", a memory buffer of limited size is available .",
    "when designing data stream algorithms , one aims at algorithms whose memory size is far smaller than the size of the input .",
    "typical application areas for which data stream processing is relevant are , e.g. , ip network traffic analysis , mining text message streams , or processing meteorological data generated by sensor networks . data stream algorithms are also used to support query optimization in relational database systems .",
    "in fact , virtually all query optimization methods in relational database systems rely on information about the number of distinct values of an attribute or the self - join size of a relation  and these pieces of information have to be maintained while the database is updated .",
    "data stream algorithms for accomplishing this task have been introduced in the seminal paper @xcite .",
    "most parts of the data stream literature deal with the task of performing * one pass over a single stream*. for a detailed overview on algorithmic techniques for this scenario we refer to @xcite .",
    "_ lower bounds _ on the size of memory needed for solving a problem by a one - pass algorithm are usually obtained by applying methods from _ communication complexity _",
    "( see , e.g. , @xcite ) .",
    "in fact , for many concrete problems it is known that the memory needed for solving the problem by a deterministic one - pass algorithm is at least linear in the size @xmath0 of the input . for some of these problems , however , _ randomized _ one - pass algorithms can still compute good _ approximate _ answers while using memory of size sublinear in @xmath0 .",
    "typically , such algorithms are based on _ sampling _ ,",
    "i.e. , only a `` representative '' portion of the data is taken into account , and _ random projections _ , i.e.",
    ", only a rough `` sketch '' of the data is stored in memory .",
    "see @xcite for a comprehensive survey of according algorithmic techniques and for pointers to the literature .",
    "also the generalization where * multiple passes over a single stream * are performed , has received considerable attention in the literature .",
    "techniques for proving lower bounds in this scenario can be found , e.g. , in @xcite",
    ".    a few articles also deal with the task of * processing several streams in parallel*. for example , the authors of @xcite consider algorithms which perform one pass over several streams .",
    "they introduce a new model of multi - party communication complexity that is suitable for proving lower bounds on the amount of memory necessary for one - pass algorithms on multiple streams . in @xcite ,",
    "these results are used for determining the exact space complexity of processing particular xml twig queries .",
    "+ in recent years , the database community has also addressed the issue of designing general - purpose _ data stream management systems _ and query languages that are suitable for new application areas where multiple data streams have to be processed in parallel . to get an overview of this research area",
    ", @xcite is a good starting point .",
    "foundations for a theory of _ stream queries _ have been laid in @xcite .",
    "stream - based approaches have also been examined in detail in connection with _ xml query processing and validation _ , see , e.g.  the papers @xcite .    the _ finite cursor machines _",
    "( fcms , for short ) of @xcite are a computation model for performing * multiple passes over multiple streams*. fcms were introduced as an abstract model of database query processing .",
    "formally , they are defined in the framework of _ abstract state machines_. informally , they can be described as follows : the input for an fcm is a relational database , each relation of which is represented by a _ table _ , i.e. , an ordered list of rows , where each row corresponds to a tuple in the relation .",
    "data elements are viewed as `` indivisible '' objects that can be manipulated by a number of `` built - in '' operations .",
    "this feature is very convenient to model standard operations on data types like integers , floating point numbers , or strings , which may all be part of the universe of data elements .",
    "fcms can operate in a finite number of _ modes _ using an _ internal memory _ in which they can store bitstrings .",
    "they access each relation through a finite number of _ cursors _ , each of which can read one row of a table at any time .",
    "the model incorporates certain _ streaming _ or _ sequential processing _",
    "aspects by imposing a restriction on the movement of the cursors : they can move on the tables only sequentially in one direction . thus ,",
    "once the last cursor has left a row of a table , this row can never be accessed again during the computation .",
    "note , however , that several cursors can be moved asynchronously over the same table at the same time , and thus , entries in different , possibly far apart , regions of the table can be read and processed simultaneously .",
    "a common feature of the computation models mentioned so far in this paper is that the input streams are _ read - only _ streams that can not be modified during a pass .",
    "recently , also * stream - based models for external memory processing * have been proposed , among them the _ strsort model _",
    "@xcite , the _ w - stream _ model @xcite , and the model of _ read / write streams _ @xcite . in these models ,",
    "several passes may be performed over a single stream or over several streams in parallel , and during a pass , the content of the stream may be modified . +    a detailed introduction to",
    "_ algorithms on data streams _",
    ", respectively , to the related area of _ sublinear algorithms _ can be found in @xcite .",
    "a survey of _ stream - based models for external memory processing _ and of methods for proving _ lower bounds _ in these models is given in @xcite .",
    "a database systems oriented overview of so - called _ data stream systems _ can be found in @xcite . for a list of _ open problems _ in the area of data streams we refer to @xcite .",
    "+    in the remainder of this article , a new computation model for multi - pass processing of multiple streams is introduced : the _ _ . in this model , (",
    "read - only ) streams can be processed by forward scans as well as backward scans , and several `` heads '' can be used to perform several passes over the streams in parallel . after fixing the basic notation in section  [ section : preliminaries ] , the computation model of is introduced in section  [ section : mpms - automata ] . in section  [ section : main - result ] , we consider the _ set disjointness problem _ and prove upper bounds as well as lower bounds on the size of memory and the number of heads that are necessary for solving this problem with an .",
    "section  [ section : conclusion ] concludes the paper by pointing out some directions for future research .",
    "if @xmath1 is a function from the set of non - negative integers to the set of reals , we shortly write @xmath2 instead of @xmath3 ( where @xmath4 denotes the smallest integer @xmath5 ) . we write @xmath6 to denote the logarithm of @xmath0 with respect to base 2 . for a set @xmath7 we write @xmath8 to denote the set of all finite strings over alphabet @xmath7 .",
    "we view @xmath8 as the set of all finite _ data streams _ that can be built from elements in @xmath7 . for a stream @xmath9 write @xmath10 to denote the length of @xmath11 , and we write @xmath12 to denote the element in @xmath7 that occurs at the @xmath13-th position in @xmath11 , i.e. , @xmath14 .",
    "in this section , we fix a computation model for multi - pass processing of multiple streams .",
    "the model is quite powerful : streams can be processed by forward scans as well as backward scans , and several `` heads '' can be used to perform several passes over the stream in parallel . for simplicity , we restrict attention to the case where just _ two _ streams are processed in parallel .",
    "note , however , that it is straightforward to generalize the model to an arbitrary number of streams .",
    "the computation model , called _ _ _ _ , can be described as follows : let @xmath7 be a set , and let @xmath15 be integers with @xmath16 and @xmath17 .",
    "an    _ @xmath18 with parameters @xmath19 _    receives as input two streams @xmath9 and @xmath20 .",
    "the automaton s memory consists of @xmath21 different states ( note that this corresponds to a memory buffer consisting of @xmath22 bits ) .",
    "the automaton s state space is denoted by @xmath23 .",
    "we assume that @xmath23 contains a designated _ start state _ and that there is a designated subset @xmath24 of @xmath23 of so - called _ accepting states_.    on each of the input streams @xmath11 and @xmath25 , the automaton has @xmath26 heads that process the stream from left to right ( so - called _ forward heads _ ) and @xmath27 heads that process the stream from right to left ( so - called _ backward heads _ ) .",
    "the heads are allowed to move asynchronously .",
    "we use @xmath28 to denote the total number of heads , i.e. , @xmath29 .    in the _ initial configuration _ of @xmath18 on input @xmath30 ,",
    "the automaton is in the _ start state _ ,",
    "all _ forward _ heads on @xmath11 and @xmath25 are placed on the leftmost element in the stream , i.e. , @xmath31 resp .",
    "@xmath32 , and all _ backward _ heads are placed on the rightmost element in the stream , i.e. , @xmath33 resp .",
    "@xmath34 .    during each computation step , depending on ( a ) the current state ( i.e. , the current content of the automaton s memory ) and ( b ) the elements of @xmath11 and @xmath25 at the current head positions , a deterministic transition function determines ( 1 ) the next state ( i.e. , the new content of the automaton s memory ) and ( 2 ) which of the @xmath28 heads should be advanced to the next position ( where forward heads are advanced one step to the right , and backward heads are advanced one step to the left ) .",
    "formally , the transition function can be specified in a straightforward way by a function @xmath35 where @xmath23 denotes the automaton s state space , and @xmath36 is a special symbol ( not belonging to @xmath7 ) which indicates that a head has reached the end of the stream ( for a forward head this means that the head has been advanced beyond the rightmost element of the stream , and for a backward head this means that the head has been advanced beyond the leftmost element of the stream ) .",
    "the automaton s computation on input @xmath30 ends as soon as each head has passed the entire stream .",
    "the input is _ accepted _ if the automaton s state then belongs to the set @xmath24 of accepting states , and it is _ rejected _ otherwise .",
    "+    the computation model of is closely related to the _ finite cursor machines _ of @xcite . in both models , several streams can be processed in parallel , and several heads ( or , `` cursors '' ) may be used to perform several `` asynchronous '' passes over the same stream in parallel .",
    "in contrast to the of the present paper , finite cursor machines were introduced as an abstract model for database query processing , and their formal definition in @xcite is presented in the framework of _ abstract state machines_.    note that can be viewed as a generalization of other models for one - pass or multi - pass processing of streams .",
    "for example , the scenario of @xcite , where a single pass over two streams is performed , is captured by an where 1  forward head and no backward heads are available on each stream . also , the scenario where @xmath37 consecutive passes of each input stream are available ( cf .",
    ", e.g. , @xcite ) , can be implemented by an : just use @xmath37 forward heads and @xmath38 backward heads , and let the @xmath13-th head wait at the first position of the stream until the @xmath39-th head has reached the end of the stream .",
    "throughout section  [ section : main - result ] we consider a particular version of the _ set disjointness problem _ where , for each integer @xmath40 ,  @xmath41 is a fixed set of @xmath42 data items .",
    "we write @xmath43 to denote the following decision problem : the input consists of two streams @xmath11 and @xmath25 over @xmath44 with @xmath45 .",
    "the goal is to decide whether the sets @xmath46 and @xmath47 are disjoint .",
    "an _ solves _ the problem @xmath43 if , for all valid inputs to @xmath43 ( i.e. , all @xmath48 with @xmath45 ) , it accepts the input if , and only if , the corresponding sets are disjoint .",
    "it is straightforward to see that the problem @xmath43 can be solved by an with @xmath49  states and a single forward head on each of the two input streams : during a first phase , the head on @xmath11 processes @xmath11 and stores , in the automaton s current state , the subset of @xmath44 that has been seen while processing @xmath11 .",
    "afterwards , the head on @xmath25 processes @xmath25 and checks whether the element currently seen by this head belongs to the subset of @xmath44 that is stored in the automaton s state . clearly , @xmath49 states suffice for this task , since @xmath50 .",
    "we thus obtain the following trivial upper bound :    [ prop : upper - bound - trivial ] @xmath43 can be solved by an with parameters @xmath51 .",
    "the following result shows that , at the expense of increasing the number of forward heads on each stream to @xmath52 , the memory consumption can be reduced exponentially :    [ prop : upper - bound - sqrt ] @xmath43 can be solved by an with parameters @xmath53 .",
    "states suffice . ]",
    "the automaton proceeds in two phases .",
    "the goal in _",
    "phase  1 _ is to move , for each @xmath54 , the @xmath13-th head on @xmath11 onto the @xmath55-th position in @xmath11 . this way , after having finished _ phase  1 _ , the heads partition @xmath11 into @xmath52 sub - streams , each of which has length @xmath52 .",
    "note that @xmath56 states suffice for accomplishing this : the automaton simply stores , in its state , the current position of the rightmost head(s ) on @xmath11 .",
    "it starts by leaving head  1 at position @xmath57 and moving the remaining heads on @xmath11 to the right until position @xmath58 is reached .",
    "then , it leaves head  2 at position @xmath58 and proceeds by moving the remaining heads to the right until position @xmath59 is reached , etc .    during _ phase  2 _",
    ", the automaton checks whether the two sets are disjoint .",
    "this is done in @xmath52 sub - phases . during the @xmath60-th sub - phase , the @xmath60-th head on @xmath25 processes @xmath25 from left to right and",
    "compares each element in @xmath25 with the elements on the current positions of the @xmath52 heads on @xmath11 .",
    "when the @xmath60-th head on @xmath25 has reached the end of the stream , each of the heads on @xmath11 is moved one step to the right .",
    "this finishes the @xmath60-th sub - phase .",
    "note that _",
    "phase  2 _ can be accomplished by using just 2 states : by looking at the combination of heads on @xmath25 that have already passed the entire stream , the automaton can tell which sub - phase it is currently performing .",
    "thus , for _ phase  2 _ we just need one state for indicating that the automaton is in _",
    "phase  2 _ , and an additional state for storing that the automaton has discovered already that the two sets are _ not _ disjoint .",
    "we first show a lower bound for where only forward heads are available :    [ thm : lower - bound - forward ] for all integers @xmath0 , @xmath21 , @xmath26 , such that , for  @xmath61  and  @xmath62 , @xmath63 the problem @xmath43 can not be solved by any with parameters @xmath64 .",
    "let @xmath0 , @xmath21 , and @xmath26 be chosen such that they meet the theorem s assumption . for contradiction ,",
    "let us assume that @xmath18 is an with parameters @xmath64 that solves the problem @xmath43 .",
    "recall that  @xmath65 is a fixed set of @xmath42 data items . throughout the proof",
    "we will restrict attention to input streams @xmath11 and @xmath25 which are enumerations of the elements in a set @xmath66 for arbitrary @xmath67 and its complement @xmath68 .",
    "+ note that for all @xmath69 we have @xmath70 for each @xmath67 we let @xmath71 be the stream of length @xmath0 which is defined as follows : for each @xmath72 , it carries data item @xmath73 at position @xmath13 ; and for each @xmath74 , it carries data item @xmath75 at position @xmath13 .",
    "the stream @xmath76 contains the same data items as @xmath71 , but in the opposite order : for each @xmath72 , it carries data item @xmath73 at position @xmath77 ; and for each @xmath74 , it carries data item @xmath75 at position @xmath77 .    for sets @xmath69",
    ", we write @xmath78 to denote the input instance @xmath79 and @xmath80 for the problem @xmath43 . from ( [ equ:1 ] ) and our assumption that the @xmath18 solves @xmath43 , we obtain that @xmath81 throughout the remainder of this proof , our goal is to find two sets @xmath82 such that    1 .",
    "@xmath83 ,  and 2 .",
    "the accepting run of @xmath18 on @xmath84 is `` similar '' to the accepting run of @xmath18 on @xmath85 , so that the two runs can be combined into an accepting run of @xmath18 on @xmath86 ( later on in the proof , we will see what `` similar '' precisely means )",
    ".    then , however , the fact that @xmath18 accepts input @xmath86 contradicts ( [ equ:2 ] ) and thus finishes the proof of theorem  [ thm : lower - bound - forward ] .    for accomplishing this goal",
    ", we let @xmath87 be 1 plus the number of pairs of heads on the two streams .",
    "we subdivide the set @xmath88 into @xmath89 consecutive blocks @xmath90 of equal size @xmath91 .",
    "i.e. , for each @xmath92 , block @xmath93 consists of the indices in @xmath94 .",
    "we say that a pair @xmath95 of heads of @xmath18 _ checks block @xmath93 _ during the run on input @xmath78 if , and only if , at some point in time during the run , there exist @xmath96 such that head @xmath97 is on element @xmath73 or @xmath75 in @xmath79 and head @xmath98 is on element @xmath99 or @xmath100 in @xmath80 .",
    "note that each pair of heads can check at most one block , since only forward heads are available and the data items in @xmath80 are arranged in the reverse order ( with respect to the indices @xmath13 of elements @xmath73 and @xmath75 ) than in @xmath79 . since there are @xmath89 blocks , but only @xmath101 pairs @xmath95 of heads on the two streams , we know that for each @xmath69 there exists a block @xmath93 that is _ not checked _ during @xmath18 s run on @xmath78 .    in the following ,",
    "we determine a set @xmath102 with @xmath103 such that for all @xmath104 , item ( 2 ) of our goal is satisfied .",
    "we start by using a simple averaging argument to find a @xmath105 and a set @xmath106 such that    for each @xmath107 , block @xmath108 is not checked during @xmath18 s run on input @xmath84 ,  and    @xmath109 .    for the remainder of the proof we fix @xmath110 .",
    "+ we next choose a sufficiently large set @xmath111 in which everything outside block @xmath112 is fixed : + a simple averaging argument shows that there is a @xmath111 and a @xmath113 such that    for each @xmath114 ,  @xmath115 ,  and    @xmath116 .",
    "we next identify a set @xmath117 such that for all @xmath118 the runs of @xmath18 on @xmath84 and @xmath119 are `` similar '' in a sense suitable for item  ( 2 ) of our goal . to this end , for each head @xmath120 of @xmath18 we let @xmath121 be the _ configuration _",
    "( i.e. , the current state and the absolute positions of all the heads ) in the run of @xmath18 on input @xmath84 at the particular point in time where head @xmath120 has just left block @xmath112 ( i.e. , head @xmath120 has just left the last element @xmath73 or @xmath75 with @xmath122 that it can access ) .",
    "we let @xmath123 be the ordered tuple of the configurations @xmath121 for all heads @xmath120 of @xmath18 .",
    "note that the number of possible configurations @xmath121 is  @xmath124 , since @xmath18 has @xmath21 states and since each of the @xmath61 heads can be at one out of @xmath125 possible positions in its input stream .",
    "consequently , the number of possible @xmath28-tuples @xmath123 of configurations is  @xmath126 . +",
    "a simple averaging argument thus yields a tuple @xmath127 of configurations and a set @xmath117 such that    for all @xmath128 ,  @xmath129 ,  and    @xmath130    using the theorem s assumption on the numbers @xmath0 , @xmath21 , and @xmath26 , one obtains that @xmath131 .",
    "therefore , we can find two sets @xmath118 with @xmath83 .",
    "to finish the proof of theorem  [ thm : lower - bound - forward ] , it remains to show that the runs of @xmath18 on @xmath84 and on @xmath119 can be combined into a run of @xmath18 on @xmath86 such that @xmath18 ( falsely ) accepts input @xmath86 . to this end",
    "let us summarize what we know about @xmath132 and @xmath133 in @xmath134 :    @xmath132 and @xmath133 only differ in block @xmath112 .",
    "block @xmath112 is not checked during @xmath18 s runs on @xmath84 and on @xmath119 .",
    "i.e. , while any head on @xmath71 ( resp .",
    "@xmath135 ) is at an element @xmath73 or @xmath75 with @xmath122 , no head on @xmath136 ( resp .",
    "@xmath137 ) is on an element @xmath99 or @xmath100 with @xmath138 .",
    "considering @xmath18 s runs on @xmath84 and on @xmath119 , each time a head leaves the last position in @xmath112 that it can access , both runs are are in exactly the same configuration .",
    "i.e. , they are in the same state , and all heads are at the same absolute positions in their input streams .    due to item  ( a )",
    ", @xmath18 s run on input @xmath86 starts in the same way as the runs on @xmath84 and @xmath119 : as long as no head has reached an element in block @xmath112 , the automaton has not yet seen any difference between @xmath86 on the one hand and @xmath84 and @xmath119 on the other hand .    at some point in time , however , some head @xmath120 will enter block @xmath112 , i.e. , it will enter the first element @xmath73 or @xmath75 with @xmath122 that it can access .",
    "the situation then is as follows :    if @xmath120 is a head on @xmath139 , then , due to item  ( b ) , no head on @xmath137 is at an element in @xmath112 .",
    "therefore , until head @xmath120 leaves block @xmath112 , @xmath18 will go through the same sequence of configurations as in its run on input @xmath84 .",
    "item  ( c ) ensures that when @xmath120 leaves block @xmath112 , @xmath18 is in the same configuration as in its runs on @xmath84 and on @xmath119 .",
    "similarly , if @xmath120 is a head on @xmath137 , then , due to item  ( b ) , no head on @xmath139 is at an element in @xmath112 .",
    "therefore , until head @xmath120 leaves block @xmath112 , @xmath18 will go through the same sequence of configurations as in its run on input @xmath119 .",
    "item  ( c ) ensures that when @xmath120 leaves block @xmath112 , @xmath18 is in the same configuration as in its runs on @xmath119 and on @xmath84 .    in summary , in @xmath18 s",
    "run on @xmath86 , each time a head @xmath120 has just left the last element in block @xmath112 that it can access , it is in exactly the same configuration as in @xmath18 s runs on @xmath84 and on @xmath119 at the points in time where head @xmath120 has just left the last element in block @xmath112 that it can access .",
    "after the last head has left block @xmath112 , @xmath18 s run on",
    "@xmath86 finishes in exactly the same way as @xmath18 s runs on @xmath84 and @xmath119 .",
    "in particular , it accepts @xmath86 ( since it accepts @xmath84 and @xmath119 ) .",
    "this , however , is a contradiction to ( [ equ:2 ] ) .",
    "thus , the proof of theorem  [ thm : lower - bound - forward ] is complete .",
    "let us compare the lower bound from theorem  [ thm : lower - bound - forward ] with the upper bound of proposition  [ prop : upper - bound - sqrt ] : the upper bound tells us that @xmath43 can be solved by an with @xmath140 states and @xmath52 forward heads on each input stream . the lower bound implies ( for large enough @xmath0 ) that if just @xmath141{n}$ ] forward heads are available on each stream , not even @xmath142{n}}$ ] states suffice for solving the problem @xmath43 with an .",
    "a straightforward calculation shows that the assumptions of theorem  [ thm : lower - bound - forward ] are satisfied , for example , for all sufficiently large integers @xmath0 and all integers @xmath21 and @xmath26 with  @xmath143{\\frac{n}{\\lg n}}$ ]  and  @xmath144 .",
    "theorem  [ thm : lower - bound - forward ] can be generalized to the following lower bound for where also backward heads are available :    [ thm : lower - bound - general ] for all @xmath0 , @xmath21 , @xmath26 , @xmath27 such that , for  @xmath145  and  @xmath146 , @xmath63 the problem @xmath43 can not be solved by any with parameters @xmath147 .",
    "the overall structure of the proof is the same as in the proof of theorem  [ thm : lower - bound - forward ] .",
    "we consider the same sets @xmath148 , for all @xmath149 .",
    "the stream @xmath71 is chosen in the same way as in the proof of theorem  [ thm : lower - bound - forward ] , i.e. , for each @xmath72 , the stream @xmath71 carries data item @xmath73 at position @xmath13 ; and for each @xmath74 , it carries data item @xmath75 at position @xmath13 .",
    "similarly as in the proof of theorem  [ thm : lower - bound - forward ] , the stream @xmath76 contains the same data items as @xmath71 .",
    "now , however , the order in which the elements occur in @xmath76 is a bit more elaborate . for fixing this order",
    ", we choose the following parameters : @xmath150 we subdivide the set @xmath88 into @xmath151 consecutive blocks @xmath90 of equal size @xmath152 .",
    "i.e. , for each @xmath153 , block @xmath93 consists of the indices in @xmath154 . + afterwards , we further subdivide each block @xmath93 into @xmath155 consecutive subblocks of equal size @xmath91 .",
    "these subblocks are denoted @xmath156 .",
    "thus , each subblock @xmath157 consists of the indices in @xmath158 .",
    "now let @xmath159 be the permutation of @xmath88 which maps , for all @xmath160 with @xmath161 and @xmath162 ,  element @xmath163  onto  element   @xmath164 .",
    "thus , @xmath159 maps elements in block @xmath93 onto elements in block @xmath165 , and inside these two blocks , @xmath159 maps the elements of subblock @xmath157 onto elements in subblock @xmath166 .",
    "note that @xmath159 reverses the blocks @xmath93 in order , but it does _ not _ reverse the order of the subblocks @xmath167 .",
    "finally , we are ready to fix the order in which the elements in @xmath148 occur in the stream @xmath76 : for each @xmath72 , the stream @xmath76 carries data item @xmath73 at position @xmath168 ; and for each @xmath74 , it carries data item @xmath75 at position @xmath168 .    in the same way as in the proof of theorem  [ thm : lower - bound - forward ] , we write @xmath78 to denote the input instance @xmath79 and @xmath80 .",
    "a pair of heads @xmath95 is called _ mixed _ if one of the heads is a forward head and the other is a backward head . since @xmath159 reverses the order of the blocks @xmath169 , it is straightforward to see that every _ non - mixed _ pair of heads can check at most one of the blocks @xmath169 . since there are @xmath151 blocks , but only @xmath170 non - mixed pairs of heads , we know that for all @xmath69 there exists a block @xmath93 that is _ not checked _ by any non - mixed pair of heads during @xmath18 s run on input @xmath78 .",
    "the same averaging argument as in the proof of theorem  [ thm : lower - bound - forward ] thus tells us that there is a @xmath171 and a set @xmath172 such that    for each @xmath173 , block @xmath174 is not checked by any non - mixed pair of heads during @xmath18 s run on input @xmath84 ,  and    @xmath175 .    from our particular choice of @xmath159 , it is straightforward to see that every _ mixed _ pair of heads can check at most one of the subblocks @xmath176 . since there are @xmath177 such subblocks , but only @xmath178 mixed pairs of heads , there must be a @xmath179 and a set @xmath180 such that    for each @xmath181 , subblock @xmath182 is not checked by any pair of heads during @xmath18 s run on input @xmath84 ,  and    @xmath183 .    for the remainder of the proof we fix @xmath184 , and",
    "we let @xmath185 denote the total number of heads . using these notations , the rest of the proof",
    "can be taken vertatim from the proof of theorem  [ thm : lower - bound - forward ] .",
    "the proof of theorem  [ thm : lower - bound - general ] is implicit in @xcite ( see theorem 5.11 in @xcite ) .",
    "there , however , the proof is formulated in the terminology of a different machine model , the so - called _ finite cursor machines_.",
    "several questions concerning the computational power of occur naturally . on a technical level , it would be nice to determine the exact complexity of the set disjointness problem with respect to .",
    "in particular : is the upper bound provided by proposition  [ prop : upper - bound - sqrt ] optimal ? can backward scans significantly help for solving the set disjointness problem ? are @xmath52 heads really necessary for solving the set disjointness problem when only a sub - exponential number of states are available ?    a more important task , however , is to consider also randomized versions of , to design efficient randomized approximation algorithms for particular problems , and to develop techniques for proving lower bounds in the randomized model .",
    "m.  grohe , y.  gurevich , d.  leinders , n.  schweikardt , j.  tyszkiewicz , and j.  van den bussche .",
    "database query processing using finite cursor machines . ,",
    "2009 . to appear . a preliminary version can be found in _ proc .",
    "icdt07 _ , pages 284298 .",
    "m.  grohe , a.  hernich , and n.  schweikardt .",
    "randomized computations on large data sets : tight lower bounds . in _ proc .",
    "pods06 _ , pages 243252 , 2006 .",
    "full version available as corr report , arxiv : cs.db/0703081 .",
    "m.  grohe , c.  koch , and n.  schweikardt .",
    "tight lower bounds for query processing on streaming and external memory data . accepted at _ theoretical computer science _ , special issue for selected papers from icalp05 .",
    "m.  henzinger , p.  raghavan , and s.  rajagopalan . computing on data streams . in _ external memory algorithms _ , volume  50 , pages 107118 .",
    "dimacs series in discrete mathematics and theoretical computer science , 1999 ."
  ],
  "abstract_text": [
    "<S> this paper gives a brief overview of computation models for data stream processing , and it introduces a new model for multi - pass processing of multiple streams , the so - called _ _ . two algorithms for solving the set disjointness problem with these automata are presented . </S>",
    "<S> the main technical contribution of this paper is the proof of a lower bound on the size of memory and the number of heads that are required for solving the set disjointness problem with .    </S>",
    "<S> nicole schweikardt </S>"
  ]
}