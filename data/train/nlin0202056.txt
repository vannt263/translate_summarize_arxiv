{
  "article_text": [
    "chaotic systems can not be predicted for very long times because of the exponential divergence of nearby trajectories . associated with the divergence of trajectories",
    "is a lack of history dependence ; the current behavior of the system is not dependent on the past behavior .",
    "the absence of history dependence can be understood in various ways . here",
    "i take a computational perspective on chaotic systems and analyze trajectories in terms of computational complexity .",
    "if , using a massively parallel computer , a typical long trajectory can be manufactured in far fewer parallel steps than the actual length of the trajectory then the trajectory lacks history dependence or historical complexity .",
    "alternatively , if parallelism does not allow one to generate a typical trajectory much more quickly than its actual length then the trajectory displays a complex history dependence .",
    "these considerations are illustrated using the one - dimensional quadratic map , @xmath2 with @xmath3 $ ] and @xmath4 .",
    "the objective is to produce typical trajectories for the map but since computing devices are necessarily restricted to finite precision we are really interested in generating typical _ _  @xcite .",
    "a of accuracy @xmath5 is a sequence @xmath6 such that for all @xmath7 ( @xmath8 ) , latexmath:[\\[\\label{eq : po }    works to a precision substantially better than @xmath5 so that bounds such as given in eq.[eq : po ] can be checked with reasonable certainty .    for chaotic dynamics with a positive lyapunov exponent @xmath10 , a and an exact trajectory that are initially equal remain close only for a time that is roughly given by @xmath11 .",
    "nonetheless , for small @xmath5 a will have nearly the same statistical properties as a real trajectory and , in any case , numerical results about chaotic systems are learned from not real trajectories .",
    "the goal then is to produce a chosen from the uniform distribution over . a typical of length @xmath0",
    "can be generated using one processor in time linear in @xmath0 by iterating the map using arithmetic of precision much better than @xmath5 and then adding a noise term on each step chosen from the uniform distribution on @xmath12 $ ] .",
    "could a typical trajectory be produced in far fewer than @xmath0 parallel steps with the aid of many processor ?",
    "the model of parallel computation implicit in this question is the pram ( parallel random access machine ) , the standard model in the theory of parallel computational complexity  @xcite .",
    "a pram is an idealized , fully scalable device with many identical ( except for distinct integer labels ) processors .",
    "processor all run the same program and all communicate with a global memory in unit time .",
    "massive parallelism is envisioned here however the number of processors is required to be polynomially bounded in @xmath13 , the effective number of ( binary ) degrees of freedom of a of length @xmath0 and accuracy @xmath5 .    in the next section",
    "we show how to produce a typical trajectory in parallel using monte carlo path sampling .",
    "the procedure is correct but inefficient .",
    "we then describe how simulated annealing together with path sampling can produce a typical in parallel time that scales linearly in @xmath1 and polynomially in @xmath14 using a number of processors that is polynomial in @xmath13 .",
    "the method described in this section is based on path sampling ideas put forward by chandler and collaborators  @xcite . the uniform probability density for ,",
    "@xmath15 is given by @xmath16 where @xmath17 and @xmath18 is the invariant distribution .",
    "a simple monte carlo procedure can be used to sample paths from @xmath19 .",
    "given an existing , a single time @xmath20 is chosen and a proposal for a new value for @xmath21 is obtained according to @xmath22 where @xmath23 is chosen from the uniform distribution on @xmath12 $ ] . the proposed value is accepted if it is also the case that @xmath24 .",
    "it is straightfoward to verify that this monte carlo procedure satisfies detailed balance with respect to @xmath25 .",
    "the question of ergodicity of the markov chain in the space is less clear .",
    "however , even if ergodicity holds , the actual mixing time for the monte carlo procedure would be long when @xmath5 is small since the time to obtain an independent is at least as great as @xmath26 , the time to diffuse a distance order one given a step size of @xmath5 . to be considered an efficient process for generating , the parallel time should increase no more rapidly than some power of the _ logarithm _ of @xmath27 . this goal can be achieved by first using a simulated annealing procedure to produce a that is random on long time scales then to use the above monte carlo path sampling to randomize the small scales .",
    "long are constructed by independently generating many _ segments _ or short trajectories and then `` welding '' the segments together . in the welding step the discontinuity between successive segments is eliminated by simulated annealing .",
    "in addition to simulated annealing , it is sometimes necessary to extend segments to obtain a weld to the next segment .",
    "the fundamental time scale in the system is @xmath28 the time required for typical errors to grow to be order one .",
    "the length of the segments , @xmath29 used in the construction should be longer than the fundamental time @xmath30 so that the beginning and end of each segment is uncorrelated .",
    "we also need to allow for extensions at either end of the segment and for a `` warm - up '' so that the initial point of the segment is chosen from invariant distribution .",
    "thus , in practice , for each segment we start with a random number and iterate the map @xmath31 times , choosing the segment of length @xmath29 from a predetermined part of the longer sequence of length @xmath32 .    having made a collection of segments , we now attempt to weld them together into a long .",
    "this is done in such a way that the initial value or _",
    "anchor point _ of each segment is held fixed .",
    "the discontinuity between successive segments is annealed until all errors are less than @xmath5 .",
    "the monte carlo annealing procedure is designed to lower the error @xmath33 associated with three successive elements , @xmath34 and @xmath35 , @xmath36 if @xmath37 for every @xmath7 then we have a . for each time @xmath7 , with the exception of the anchor points ,",
    "the monte carlo annealing procedure begins with a measurement of @xmath38 . if @xmath39 nothing is done .",
    "otherwise a new value @xmath40 is proposed , @xmath41 where @xmath42 is chosen as a gaussian random variable with mean zero and standard deviation @xmath43 .",
    "if @xmath44 , is less than @xmath45 , the proposal is accepted as the new value for @xmath21 .",
    "if the error increases , the proposal is accepted with probability @xmath46 .",
    "the value of the inverse temperature for each monte carlo step and is taken to be @xmath47 so that the acceptance ratio is independent of the size of the error . in a single monte carlo sweep ,",
    "all except the initial and final values of each segment are processed using the above procedure .",
    "given @xmath48 processors this can be done in constant parallel time by first processing the even and then the odd values of the time @xmath7 .",
    "in the chaotic regime ( @xmath49 ) the annealing procedure should yield a valid for large enough @xmath29 and sufficiently many monte carlo sweeps . in practice , however , some welds require a very large number of sweeps .",
    "specifically , the probability distribution for the number of sweeps needed to achieve a weld has a long tail leading to parallel running times for creating that are dominated by the few most difficult welds .",
    "two additional kinds of steps , called _ forward shifts _ and _ backward shifts _ cure this difficulty .",
    "suppose segment @xmath50 together with its final condition , the first element of segment @xmath51 , is not fully annealed after a predetermined number of annealing sweeps .",
    "then segment @xmath50 is restored to its original state and either it is extended forward one step or segment @xmath51 is extended backwards one step . in the case of a backwards shift ,",
    "the element prepended to segment @xmath51 is considered a new anchor points and serves as the new final condition for segment @xmath50 .",
    "the net effect of either a forward or backward shift is that the discontinuity between segments @xmath50 and @xmath51 occurs with a different pair of numbers .",
    "annealing sweeps and shifts are interleaved , a fixed number of monte carlo annealing sweeps are attempted and if all errors are not less than @xmath5 , a shift is done .",
    "the process is repeated until a satisfactory weld is achieved .",
    "successive shifts are alternately of the forward and backward type . in sec.[sec : vs ] , i show that the combination of monte carlo annealing and shifts produces a in @xmath52 parallel steps .",
    "shifts serve several purpose . first",
    ", they simply provide for the possibility of more monte carlo sweeps , though if this were their only function it could be accomplished by directly increasing the number of sweeps .",
    "second , shifts permit the algorithm to perform properly for periodic orbits or nearly periodic stretches of aperiodic orbits . the annealing procedure by itself can not generate long for periodic orbits since welds are often attempted between segments that are out of phase with one another .",
    "adding shifts to the annealing procedure insures that periodic will be correctly generated .",
    "for example , consider the case of a period two orbit , a single forward or backward shift of some segments will insure that all welds are satisfactory . for period @xmath53 orbits ,",
    "as many as @xmath54 shifts are necessary to insure that all welds are satisfactory .    shifts may also provide padding around hard to weld regions of a trajectory . during a shift ,",
    "new points are added to one end of a segment but no points are removed .",
    "thus shifts do not bias the against difficult to weld regions in the invariant measure .",
    "for example , it is observed that if the final condition for a segment is very near the maximum of the support in the invariant measure at @xmath55 then one or more backward shifts are usually necessary so that the point near @xmath55 is surrounded by a region of small errors and is not involved in the annealing process .",
    "this section provides the details of the parallel algorithm for producing typical that combines the path sampling method of sec.[sec : ps ] and the annealing procedure of sec .",
    "[ sec : an ] .",
    "first the annealing procedure is used to generate a and then path sampling is used to further randomize it .",
    "the algorithm is controlled by several parameters : @xmath0 is the total length of the desired , @xmath5 is the desired accuracy , @xmath29 is the length of each segment , @xmath56 is the warm - up length , @xmath57 , an even number , is the maximum number of shifts that are attempted , @xmath58 is the number of monte carlo annealing sweeps carried out between shifts and @xmath59 is the number of monte carlo path sampling sweeps .",
    "the algorithm is described below :    1 .",
    "in parallel , generate @xmath60 sequences @xmath61 each of length @xmath62 , with @xmath63 and @xmath64 .",
    "the initial value of each sequence is a uniform random number on @xmath65 and subsequent values are obtained by iterating the map @xmath66 times to precision much greater than @xmath5 .",
    "this step requires @xmath67 parallel time .",
    "these @xmath68 sequences are used to define @xmath69 segments @xmath70 each of length @xmath29 , where the index @xmath71 , @xmath72 gives the number of shifts .",
    "@xmath73 for @xmath74 while @xmath75 .",
    "note that the final point in segment @xmath76 is a taken from sequence @xmath51 .",
    "3 .   in parallel",
    ", for each @xmath77 , and each @xmath78 , anneal segment @xmath76 .",
    "the annealing procedure consists of @xmath58 monte carlo sweeps . during a single annealing sweep first the even and then the odd elements of the segment are updated in parallel .",
    "the initial and final points @xmath79 and @xmath80 are held fixed during the annealing procedure .",
    "a single monte carlo update of the point @xmath81 consists of the following procedure : * compute @xmath82 from eq.[eq : defe ] . * if @xmath39 , do nothing . if @xmath83 propose a new value @xmath84 where @xmath42 is a gaussian random variable with mean zero and standard deviation @xmath43 . *",
    "compute @xmath85 . if @xmath86 accept the proposed change , @xmath87 .",
    "if @xmath88 accept the proposed move with probability @xmath89 $ ] where @xmath47 .",
    "+ the parallel time required for this step is @xmath90 .",
    "4 .   in parallel , for each @xmath77 find @xmath91 , that smallest value of @xmath71 such that the segment is successfully annealed .",
    "the annealing is successful for this segment if , for all @xmath92 , the errors are sufficiently small , @xmath93 .",
    "if for any @xmath50 , annealing is unsuccessful for all @xmath94 , the algorithm fails .",
    "this step can be carried out in constant parallel time .",
    "the full @xmath95 is a concatenation of sequences obtained from each original sequence @xmath96 .",
    "the contribution to the from @xmath96 is the concatenation of @xmath97 and @xmath98 .",
    "the first of these sequences is composed of the anchor points and the second sequence is the annealed segment . to obtain a of length exactly @xmath0 ,",
    "the obtained above is simply truncated after @xmath0 steps .",
    "the path sampling monte carlo procedure described in sec .",
    "[ sec : ps ] further randomizes @xmath99 . during a single sweep ,",
    "first all the even and then all the odd elements of the are updated in parallel .",
    "the number of sweeps is @xmath59 . on each monte carlo",
    "step a new value for @xmath100 is proposed according to eq .",
    "[ eq : prop ] and accepted only if the trajectory is still a within error @xmath5 .",
    "the randomization step requires parallel time @xmath101 .",
    "the central questions addressed in this section are ( 1 ) whether the algorithm succeeds in creating a , ( 2 ) how the scaling of the number of parallel steps depends on the length and accuracy of the and the parameter @xmath102 of the map and ( 3 ) whether the algorithm samples the uniform distribution on .",
    "a sequential algorithm that carries out the annealing and path sampling routines one segment at a time was used to study these questions . in the simulations reported below",
    ", the parameters are chosen to be @xmath103 , @xmath104 and @xmath105 . the assumption behind these choices is that memory is lost on a time scale @xmath30 so that placing independently chosen anchor points separated by @xmath106 is satisfactory .",
    "the annealing process that welds successive segments is expected to influence a region whose length is order @xmath30 . since information is transmitted diffusively by local monte carlo moves , having the number of monte carlo sweeps scale as @xmath107 should suffice .",
    "the annealing stage of the parallel algorithm can be studied one segment at a time since each segment is independently annealed .",
    "first , i observed that , given enough shifts , the annealing step always produced a successful weld .",
    "the choice of the maximum number of shifts @xmath57 for the annealing stage must be large enough to make the failure probability for the whole algorithm small . for long trajectories , @xmath108 , the choice of @xmath57",
    "is determined by the tail of the distribution of the number of shifts , @xmath109 required to obtain a weld since the whole procedure fails if even one segment is not successfully annealed .",
    "suppose @xmath110 is the cumulative probability distribution for @xmath109 .",
    "an estimate of the maximum number of shifts , @xmath57 needed to insure all segments are annealed is given by the relation @xmath111 figure [ fig : cvs ] shows @xmath112 vs.  @xmath109 .",
    "these data were collected for the case of @xmath113 ( the period doubling transition to chaos occurs at @xmath114 ) and the six curves from left to right are for @xmath115 through @xmath116 , respectively . each curve is obtained from annealing @xmath117 segments except for the @xmath118 curve which is obtained from @xmath119 segments . for @xmath113",
    "the lyapunov exponent is @xmath120 and so , for example , with @xmath121 , @xmath122 , @xmath123 and @xmath124 . over a reasonable range following an initial transient and before",
    "the noise becomes large , the data falls on straight lines suggesting that the distribution is asymptotically exponential , @xmath125 .",
    "equation [ eq : ests ] then implies that @xmath126 and we can conclude that the parallel running time is @xmath52 since no other contribution to the running time depends on the overall length of the .     vs.  number of shifts , @xmath109 . from left to right , @xmath115 to @xmath116 .",
    "]    how does the decay constant @xmath127 and thus the running time depend on the choice of the accuracy @xmath5 .",
    "figure [ fig : svs ] shows @xmath127 vs.  @xmath5 on a logarithmic scale for the case @xmath113 and suggests that @xmath127 is a polynomial function of @xmath128 .",
    "the other simulation parameters , @xmath32 , @xmath58 and @xmath59 are also polynomial in @xmath128 so we conclude that the full algorithm has a running time that is polynomial in @xmath128 and linear in @xmath1 .     for the distribution of shifts vs.accuracy @xmath5 on a logarithmic scale .",
    "]    i also considered two other parameter values for the quadratic map , @xmath129 where @xmath130 and @xmath131 where @xmath132 . in both cases ,",
    "the accuracy was set to @xmath121 .",
    "the decay of @xmath133 appears to be exponential in both cases but with rather different values of the decay constant : @xmath134 and @xmath135 for @xmath136 and @xmath137 , respectively .",
    "either @xmath127 depends strongly on @xmath10 or perhaps there are additional @xmath102 dependent factors controlling @xmath127 .",
    "for example , for @xmath113 and 3.8 the invariant measure has support on a single interval but for @xmath129 the support consists of two intervals .",
    "the annealing stage of the algorithm creates a but it is not typical in the sense of being chosen from the distribution of eq .",
    "[ eq : typ ] . on long time scales ,",
    "the is randomized by the random choice of initial conditions for each sequence . however , the individual errors , @xmath138 are not guaranteed to be independent random variables on the interval @xmath12 $ ] . for example , anchor regions of the have errors much less than @xmath5 .",
    "the hypothesis is that @xmath139 path sampling monte carlo sweeps are sufficient to randomize the short time scales and produce a typical from the produced by the annealing stage . to check this hypothesis , i computed mean values and autocorrelation functions for errors and cross correlations between errors and values of the .",
    "the quantities @xmath140 , ( @xmath141 ) , @xmath142 , @xmath143 and @xmath144 were all found to be zero within error bars for the case @xmath113 and @xmath121 .",
    "here the angled brackets indicate an average over segments and over @xmath7 .",
    "the vanishing of these quantities is a necessary but not sufficient condition that is chosen from the uniform distribution described by eqs.[eq : typ ] and [ eq : typ1 ] .",
    "more work is needed to firmly establish that the algorithm with @xmath145 path sampling sweeps samples the uniform distribution to good approximation .",
    "however , even without the path sampling stage , the produced by the annealing stage are typical in a different sense .",
    "as shown in @xcite , any an exact trajectory ( i.  e.  remains close to over its entire length ) though possibly for a larger value of @xmath102 .",
    "i have exhibited a parallel algorithm that generates of the quadratic map .",
    "numerical evidence suggests that the parallel time required to generate a typical increases linearly in @xmath1 and polynomially in @xmath14 though more work would be required to establish these scalings with certainty .",
    "essentially the same parallel algorithm can be applied to other one - dimensional and higher dimensional maps .",
    "it would be interesting to explore whether the annealing / shift procedure is sufficient to efficiently sample for other maps .    since there is little demand for very long of the quadratic map , the fast parallel algorithm is probably not of practical value .",
    "the significance of its existence and complexity is that it characterizes the history dependence of the map .",
    "the existence of a fast parallel simulation is a strong statement against history dependence since it shows that the logical path from independent random numbers ( used to drive the monte carlo procedures ) to a typical is much shorter than the length of the .",
    "the length of this logical path is one measure of the potential for generating historical complexity . in very few logical steps , very little complexity",
    "can be arise .",
    "the idea that complexity tends to emerge at the `` edge of chaos '' @xcite is born out here since the basic time scale @xmath30 for the parallel algorithm diverges when the lyapunov exponent vanishes",
    ". an appealing feature of characterizing systems by computational complexity is that very different systems in statistical physics systems , for example diffusion limited aggregation  @xcite , sandpiles  @xcite or the bak - sneppen model  @xcite , can be compared to one another within the same framework ."
  ],
  "abstract_text": [
    "<S> the parallel computational complexity of the quadratic map is studied . </S>",
    "<S> a parallel algorithm is described that generates typical pseudotrajectories of length @xmath0 in a time that scales as @xmath1 and increases slowly in the accuracy demanded of the pseudotrajectory . </S>",
    "<S> long pseudotrajectories are created in parallel by putting together many short pseudotrajectories ; monte carlo procedures are used to eliminate the discontinuities between these short pseudotrajectories and then suitably randomize the resulting long pseudotrajectory . </S>",
    "<S> numerical simulations are presented that show the scaling properties of the parallel algorithm . </S>",
    "<S> the existence of the fast parallel algorithm provides a way to formalize the intuitive notion that chaotic systems do not generate complex histories . </S>"
  ]
}