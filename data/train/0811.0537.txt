{
  "article_text": [
    "an execution of a procedural program can reveal not just a linear sequence of program states encountered during the execution , but also the correspondence between each point during the execution at which a procedure is called and the point when we return from that procedure call .",
    "this leads naturally to the notion of a finite or infinite nested word ( see @xcite ) .",
    "a nested word is simply a finite or @xmath1-word supplied with an additional binary matching relation which relates corresponding call and return points ( and of course satisfies `` well - bracketing '' properties ) .",
    "finite nested words offer an alternative way to view any data which has both a sequential string structure as well as a tree - like hierarchical structure .",
    "examples of such data are xml documents and parse trees .",
    "pushdown systems ( pdss ) , boolean programs , and recursive state machines ( rsms ) , are equivalent abstract models of procedural programs , with finite data abstraction but unbounded call stack .",
    "software model checking technology is by now thoroughly developed for checking @xmath1-regular properties of runs for these models , when the runs are viewed as ordinary words ( see @xcite ) .",
    "unfortunately , temporal logic and @xmath1-regular properties over ordinary words are inadequate for expressing a variety of properties of program executions that are useful in interprocedural program analysis and software verification .",
    "these include hoare - like pre / post conditions on procedures , stack inspection properties , and other useful program analysis properties that go well beyond @xmath1-regular ( see @xcite for some examples ) . on the other hand",
    ", many such program analysis properties can easily be expressed when runs are viewed as nested words .",
    "runs of boolean programs and rsms can naturally be viewed as nested words once we add `` summary edges '' between matching calls and returns , and we can thus hope to extend model checking technology for procedural programs using richer temporal logics over nested words which remain tractable for analysis .",
    "these considerations motivated the definition of visibly pushdown languages ( vpls ) @xcite and the call - return temporal logic @xcite .",
    "is a temporal logic over nested words which extends ltl with new temporal operators that allow for navigation through a nested word both via its ordinary sequential structure , as well as its matching call - return summary structure .",
    "the standard ltl model checking algorithms for rsms and pdss can be extended to allow model checking of , with essentially the same complexity @xcite .",
    "vpls @xcite are a richer class of languages that capture mso - definable properties of nested words .",
    "recently , results about vpls have been recast in light of nested words , and in particular in terms of nested word automata @xcite which offer a machine acceptor for ( @xmath1-)regular nested words , with all the expected closure properties .    over ordinary words ,",
    "ltl has long been considered the temporal logic of choice for program verification , not only because its temporal operators offer the right abstraction for reasoning about events over time , but because it provides a good balance between expressiveness ( first - order complete ) , conciseness ( can be exponentially more succinct compared to automata ) , and the complexity of model - checking ( linear time in the size of the finite transition system , and pspace in the size of the temporal formula ) .",
    "this raises the question : _ what is the right temporal logic for nested words ? _    the question obviously need not have a unique answer , particularly since nested words can arise in various application domains : for example , program verification , as we already discussed , or navigation and querying xml documents under `` sequential '' representation ( see , e.g. , @xcite ) .",
    "however , it is reasonable to hope that any good temporal logic for nested words should possess the same basic qualities that make ltl a good logic for ordinary words , namely :    1 .   _",
    "first - order expressive completeness : _ ltl has the same expressive power as first - order logic over words , and we would want the same over nested words ( of course , even more expressiveness , such as full mso , would be nice but natural temporal logics are subsumed by first order logic and any further expressiveness typically comes at a cost , even over words , of some other desirable properties ) ; 2 .   _ reasonable complexity for model checking and satisfiability ; _ and 3 .   _ nice closure properties _ :",
    "ltl is closed under boolean combinations including negation without any blow - up , and we would want the same for a logic over nested words .",
    "+ finally ( and perhaps least easy to quantify ) , we want 4 .   _",
    "natural temporal operators with simple and intuitive semantics_.    unfortunately , the logic appears to be deficient with respect to some of these criteria : although it is easily first - order expressible , it is believed to be incomplete but proving incompleteness appears to be difficult .",
    "can express program path properties ( for example , every _ lock _",
    "operation is eventually followed by an _ unlock _ operation ) and local path properties ( for example",
    ", if a procedure executes a _ lock _ operation then the same procedure later executes an _",
    "unlock _ operation before returning ) , but it seems incapable of expressing scope - bounded path properties ( for example , every _ lock _",
    "operation in a procedure is eventually followed by an _ unlock _",
    "operation before the procedure returns ) .",
    "such scope - bounded path properties are natural program requirements , and are expressible in the first - order logic of nested words .",
    "there is much related work in the xml community on logics for trees ( see , e.g. , surveys @xcite ) , but they tend to have different kinds of deficiencies for our purposes : they concentrate on the hierarchical structure of the data and largely ignore its linear structure ; also , they are designed for finite trees .",
    "we introduce and study new temporal logics over nested words .",
    "the main logic we consider , _ nested word temporal logic _",
    "( @xmath2 ) extends ltl with both a future and past variant of the standard until operator , which is interpreted over _ summary paths _ rather than the ordinary linear sequence of positions .",
    "a summary path is the unique shortest directed path one can take between a position in a run and some future position , if one is allowed to use both successor edges and matching call - return summary edges .",
    "we show that @xmath2 possesses all the desirable properties we want from a temporal logic on nested words . in particular",
    ", it is both first - order expressively complete and has good model checking complexity .",
    "indeed we provide a tableaux construction which translates an @xmath2 formula into a nested word automaton , enabling the standard automata theoretic approach to model checking of boolean programs and rsms with complexity that is polynomial in the size the model and exptime in the size of the formula ( and indeed exptime - complete ) .",
    "we then explore some alternative temporal logics , which extend variants of with variants of unary `` within '' operators proposed in @xcite , and we show that these extensions are also fo - complete .",
    "however , we observe that the model checking and satisfiability problems for these logics are 2exptime - complete .",
    "these logics are  provably  more concise than @xmath2 , but we pay for conciseness with added complexity .",
    "it follows from our proof of fo - completeness for @xmath2 that over nested words , every first - order formula with one free variable can be expressed using only 3 variables .",
    "more generally , we show , using ef games , that 3 variables suffice for expressing any first order formula with two or fewer free variables , similarly to the case of words @xcite or finite trees @xcite .",
    "finally , we show that a natural unary temporal logic over nested words is expressively complete for first - order logic with 2 variables , echoing a similar result known for unary temporal logic over ordinary words @xcite .",
    "vpls and nested words were introduced in @xcite .",
    "the logic  was defined in @xcite with the goal of expressing and checking some natural non - regular program specifications .",
    "the theory of vpls and  has been recast in light of nested words in @xcite .",
    "other aspects of nested words ( automata characterizations , games , model - checking ) were further studied in @xcite .",
    "it was also observed that nested words are closely related to a sequential , or `` event - based '' api for xml known as sax @xcite ( as opposed to a tree - based dom api @xcite ) .",
    "sax representation is very important in streaming applications , and questions related to recognizing classes of nested words by the usual word automata have been addressed in @xcite .",
    "while finite nested words can indeed be seen as xml documents under the sax representation , and while much effort has been spent over the past decade on languages for tree - structured data ( see , e.g. , @xcite for surveys ) , adapting the logics developed for tree - structured data is not as straightforward as it might seem , even though from the complexity point of view , translations between the dom and the sax representations are easy @xcite .",
    "the main problem is that most such logics rely on the tree - based representation and ignore the linear structure , making the natural navigation through nested words rather unnatural under the tree representation .",
    "translations between dom and sax are easy for first - order properties , but verifying navigational properties expressed in first - order is necessarily non - elementary even for words if one wants to keep the data complexity linear @xcite .",
    "on the other hand , logics for xml tend to have good model - checking properties ( at least in the finite case ) , typically matching the complexity of ltl @xcite .",
    "we do employ such logics ( e.g. , those in @xcite ) in the proof of the expressive completeness of @xmath2 , first by using syntactic translations that reconcile both types of navigation , and then by combining them with a composition game argument that extends the result to the infinite case , which is not considered in the xml setting .",
    "this , however , involves a nontrivial amount of work .",
    "furthermore , `` within '' operators do not have any natural analog on trees , and the proof for them is done by a direct composition argument on nested words .",
    "basic notations are given in section [ notations - sec ] .",
    "section [ tl - sec ] defines temporal logics on nested words , and section [ expcompl - sec ] presents expressive completeness results .",
    "we study model - checking in section [ mc - sec ] , and in section [ fv - sec ] we prove the 3-variable property and present a logic for the 2-variable fragment .",
    "a _ matching _ on @xmath3 or an interval @xmath4 $ ] of @xmath3 consists of a binary relation @xmath5 and two unary relations @xmath6 and @xmath7 , satisfying the following : ( 1 ) if @xmath8 holds then @xmath9 and @xmath10 and @xmath11 ; ( 2 ) if @xmath8 and @xmath12 hold then @xmath13 and if @xmath8 and @xmath14 hold then @xmath15 ; ( 3 ) if @xmath16 and @xmath9 and @xmath10 then there exists @xmath17 such that either @xmath18 or @xmath19 .",
    "let @xmath20 be a finite alphabet .",
    "a _ finite nested word _ of length @xmath21 over @xmath20 is a tuple @xmath22 , where @xmath23 , and @xmath24 is a matching on @xmath4 $ ] .",
    "a _ nested @xmath1-word _ is a tuple @xmath22 , where @xmath25 , and @xmath24 is a matching on @xmath3 .",
    "we say that a position @xmath26 in a nested word @xmath27 is a _ call _ position if @xmath9 holds ; a _ return _ position if @xmath28 holds ; and an _ internal _ position if it is neither a call nor a return .",
    "if @xmath8 holds , we say that @xmath26 is the matching call of @xmath29 , and @xmath29 is the matching return of @xmath26 , and write @xmath30 and @xmath31 .",
    "calls without matching returns are _ pending _ calls , and returns without matching calls are _ pending _ returns ( sometimes we will alternatively refer to such calls and returns as _ unmatched _ ) .",
    "a nested word is said to be _ well - matched _ if no calls or returns are pending .",
    "note that for well - matched nested words , the unary predicates @xmath6 and @xmath7 are uniquely specified by the relation @xmath5 .",
    "a nested word @xmath32 is represented as a first - order structure @xmath33 where @xmath34 is @xmath35 if @xmath36 is a finite word of length @xmath21 and @xmath3 if @xmath27 is a nested @xmath1-word ; @xmath37 is the usual ordering , @xmath38 is the set of positions labeled @xmath39 , and @xmath24 is the matching relation . when we talk about first - order logic ( fo ) over nested words , we assume fo  over such structures ( i.e. the vocabulary is that of words plus the matching relation ) .    for a nested word @xmath27 , and two elements @xmath40 of @xmath27 , we denote by @xmath41 $ ] the substructure of @xmath27 ( i.e. a finite nested word ) induced by elements @xmath42 such that @xmath43 . if @xmath44 we assume that @xmath41 $ ] is the empty nested word . for nested @xmath1-words",
    "@xmath27 , we let @xmath45 $ ] denote the substructure induced by elements @xmath46 .    when this is clear from the context , we do not distinguish references to positions in subwords @xmath41 $ ] and @xmath27 itself , e.g. , we shall often write @xmath47,i)\\models{\\varphi}$ ] to mean that @xmath48 is true at the first position of @xmath41 $ ] .    figure  [ fig : shape ] shows two finite nested words ( without the labeling with alphabet symbols ) .",
    "nesting edges are drawn using dashed lines .",
    "for the first word , the relation @xmath5 is @xmath49 , the set @xmath6 is @xmath50 , and the set @xmath7 is @xmath51 . for the second word , the relation @xmath5 is @xmath52 , the set @xmath6 is @xmath53 , and the set @xmath7 is @xmath54 .",
    "note that our definition allows a nesting edge from a position @xmath26 to its linear successor , and in that case there will be two edges from @xmath26 to @xmath55 ; this is the case for positions 2 and 3 of the second sequence .",
    "the second sequence has two pending calls and two pending returns .",
    "pending calls are depicted by dashed outgoing edges and pending returns are depicted by dashed incoming edges .",
    "note that all pending return positions in a nested word appear before any of the pending call positions ( this is enforced by condition ( 3 ) of the definition of matchings ) .",
    "the _ quantifier rank _ ( or _ quantifier depth _ ) of an @xmath56 formula @xmath48 is the depth of quantifier nesting in @xmath48 .",
    "rank-@xmath57 type _ of a structure @xmath58 over a relational vocabulary is the set @xmath59 , where @xmath48 ranges over fo sentences over the vocabulary .",
    "it is well - known that there are finitely many rank-@xmath57 types for all @xmath57 , and for each rank-@xmath57 type @xmath60 there is an @xmath56 sentence @xmath61 such that @xmath62 iff the rank-@xmath57 type of @xmath58 is @xmath60 .",
    "sometimes we associate types with formulas that define them .",
    "many proofs in this paper make use of _ ehrenfeucht - frass _",
    "( ef ) games , see for example @xcite .",
    "this game is played on two structures , @xmath58 and @xmath63 , over the same vocabulary , by two players , _",
    "player i _ and _ player ii_. in round @xmath26 player i  selects a structure , say @xmath58 , and an element @xmath64 in the domain of @xmath58 ; player ii  responds by selecting an element @xmath65 in the domain of @xmath63",
    ". player ii  _ wins _ in @xmath57 rounds , for @xmath66 , if @xmath67 defines a partial isomorphism between @xmath58 and @xmath63 .",
    "also , if @xmath68 is an @xmath69-tuple in the domain of @xmath58 and @xmath70 is an @xmath69-tuple in the domain of @xmath63 , where @xmath71 , we write @xmath72 whenever player ii  wins in @xmath57 rounds no matter how player i  plays , but starting from position @xmath73 .",
    "we write @xmath74 iff @xmath58 and @xmath63 have the same rank-@xmath57 type , that is for every @xmath56 sentence @xmath48 of quantifier rank-@xmath57 , @xmath75 .",
    "it is well - known that @xmath74 iff player ii  has a winning strategy in the @xmath57-round ehrenfeucht - frass game on @xmath58 and @xmath63 .    in the proof of theorem [ 3var th ]",
    ", we shall also use _",
    "@xmath57-pebble games_. in such a game , player i  and player ii  have access to @xmath57 matching pebbles each , and each round consists of player i   either removing , or placing , or replacing a pebble in one structure , and player ii  replicating the move in the other structure .",
    "the correspondence given by the matching pebbles should be a partial isomorphism .",
    "if player ii  can play while maintaining partial isomorphism for @xmath69 rounds , then the structures agree on all @xmath76 sentences of quantifier rank up to @xmath69 ; if player ii  can play while maintaining partial isomorphism forever , then the structures agree on all @xmath76 sentences .",
    "( @xmath76 is first - order logic where at most @xmath57 distinct variables may occur . )",
    "we now describe our approach to temporal logics for nested words .",
    "it is similar to the approach taken by the logic @xmath0 @xcite .",
    "namely , we shall consider ltl - like logics that define the next / previous and until / since operators for various types of paths in nested words .",
    "all the logics will be able to refer to propositional letters , including the base unary relations @xmath6 and @xmath7 , and will be closed under all boolean combinations .",
    "we shall write @xmath77 for true and @xmath78 for false .",
    "for all the logics , we shall define the notion of satisfaction with respect to a position in a nested word : we write @xmath79 to denote that the formula @xmath48 is true in position @xmath26 of the word @xmath27 .    since nested words are naturally represented as transition systems with two binary relations  the successor and the matching relation  in all our logics we introduce _ next operators _",
    "@xmath80 and @xmath81 .",
    "the semantics of those is standard : @xmath82 iff @xmath83 , @xmath84 iff @xmath26 is a call with a matching return @xmath29 ( i.e. , @xmath8 holds ) and @xmath85 . likewise",
    ", we shall have _ past _ operators @xmath86 and @xmath87 : that is , @xmath88 is true in position @xmath89 iff @xmath48 is true in position @xmath90 , and @xmath91 is true in position @xmath29 if @xmath29 is a return position with matching call @xmath26 and @xmath48 is true at @xmath26 .",
    "the _ until / since operators _ depend on what a path is .",
    "in general , there are various notions of paths through a nested word .",
    "we shall consider until / since operators for paths that are unambiguous : that is , for every pair of positions @xmath26 and @xmath29 with @xmath11 , there could be at most one path between them .",
    "then , with respect to any such given notion of a path , we have the until and since operators with the usual semantics :    1 .",
    "@xmath92 iff there is a position @xmath93 and a path @xmath94 between them such that @xmath95 and @xmath96 for every @xmath97 .",
    "@xmath98 iff there is a position @xmath99 and a path @xmath100 between them such that @xmath95 and @xmath96 for every @xmath101 .",
    "the approach of @xmath0 was to introduce three types of paths , based on the linear successor ( called _ linear paths _ ) , the call - return relation ( called _ abstract paths _ ) , and the innermost call relation ( called _ call paths _ ) .    to define those",
    ", we need the notions @xmath102 and @xmath103 for each position @xmath26  these are the innermost call within which the current action @xmath26 is executed , and its corresponding return .",
    "formally , @xmath102 is the greatest matched call position @xmath44 whose matching return is after @xmath26 ( if such a call position exists ) , and @xmath103 is the least matched return position @xmath104 whose matching call is before @xmath26",
    ".    given two positions @xmath11 , a sequence @xmath94 is    1 .   a _ linear path _ if @xmath105 for all @xmath106 ; 2 .   a _ call path _ if @xmath107 for all @xmath108 ; 3 .",
    "an _ abstract path _",
    "if @xmath109    we shall denote until / since operators corresponding to these paths by @xmath110 for linear paths , @xmath111 for call paths , and @xmath112 for abstract paths .",
    "our logics will have some of the next / previous and until / since operators .",
    "some examples are :    1 .",
    "when we restrict ourselves to the purely linear fragment , our operators are @xmath80 and @xmath86 , and @xmath113 and @xmath114 , i.e. , precisely ltl ( with past operators ) .",
    "2 .   the logic @xmath0 @xcite has the following operators : the next operators @xmath80 and @xmath81 ; the linear and abstract untils ( i.e. , @xmath113 and @xmath115 ) , the call since ( i.e. , @xmath116 ) and a previous operator @xmath117 , defined by : @xmath118 iff @xmath102 is defined and @xmath119 .    another notion of a path combines both the linear and the nesting structure .",
    "it is the shortest directed path between two positions @xmath26 and @xmath29 . unlike an abstract path , it decides when to skip a call based on position @xmath29",
    ". basically , a summary path from @xmath26 to @xmath29 moves along successor edges until it finds a call position @xmath57 .",
    "if @xmath57 has a matching return @xmath42 such that @xmath29 appears after @xmath42 , then the summary path skips the entire call from @xmath57 to @xmath42 and continues from @xmath42 ; otherwise the path continues as a successor path . note that every abstract path is a summary path , but there are summary paths that are not abstract paths .",
    "a _ summary path _ between @xmath11 in a nested word @xmath27 is a sequence @xmath94 such that for all @xmath108 , @xmath120 the corresponding until / since operators are denoted by @xmath121 and @xmath122 .",
    "we will also consider two special kinds of summary paths : _ summary - down _ paths are allowed to use only _ call _ edges ( from a call position , @xmath26 to @xmath55 where @xmath55 is not a return ) , _ nesting _ edges ( from a call to its matching return ) , and _ internal _ edges ( from some @xmath26 to @xmath55 where @xmath26 is not a call and @xmath55 is not a return ) , and _ summary - up _ paths are allowed to use only _ return _ edges ( from a position preceding a return to the return ) , nesting edges and internal edges .",
    "( in other words , summary - down paths are summary paths with no return edges and summary - up paths are summary paths with no call edges . )",
    "we will use @xmath123 and @xmath124 to denote the corresponding until operators .",
    "a general summary path is a concatenation of a summary - up path and summary - down path : @xmath125 is equivalent to @xmath126 .",
    "we will also study the expressiveness of various until modalities when the logic is extended with the _ within _ operator , which allows restriction to a subword . if @xmath48 is a formula , then @xmath127 is a formula , and @xmath128 iff @xmath26 is a call , and @xmath47,i)\\models{\\varphi}$ ] , where @xmath129 if @xmath26 is a matched call , @xmath130 if @xmath26 is an unmatched call and @xmath27 is finite , and @xmath131 otherwise .",
    "in other words , @xmath127 evaluates @xmath48 on a subword restricted to a single procedure .    to understand the various notions of paths in a nested word ,",
    "let us consider the left word shown in figure  [ fig : shape ] again .",
    "an abstract path uses internal and nesting edges ; for example , @xmath132 and @xmath133 are abstract paths .",
    "summary - down paths , in addition , can use call edges ; for example , @xmath134 is a summary - down ( but not an abstract ) path .",
    "summary - up paths can use internal and nesting edges , and can also go along return edges ; for example , @xmath135 is a summary - up path .",
    "a summary path is a summary - up path followed by a summary - down path ; for example , @xmath136 in the right word of figure  [ fig : shape ] is a summary path ( which also happens to be a linear path ) .",
    "every two positions have a unique summary path connecting them , and this is the `` shortest '' path in the underlying graph between these positions .",
    "we now discuss how the various operators can be used for specifying requirements for sequential structured programs . in the classical linear - time semantics of programs , an execution of a program",
    "is modeled as a word over program states . in the nested - word semantics , this linear structure",
    "is augmented with nesting edges from entries to exits of program blocks .",
    "the main benefit is that using nesting edges one can skip procedure calls entirely , and continue to trace a local path through the calling procedure .",
    "a program is now viewed as a generator of nested words , and requirements are written using temporal logics over nested words .",
    "suppose we want to express the requirement that , along a global program execution , every write to a variable is followed by a read before the variable is written again .",
    "if @xmath137 and @xmath138 denote the atomic propositions that capture write and read operations , respectively , then the requirement is expressed by the until formula over linear paths ,    @xmath139\\ ] ] here , @xmath140 is defined in the usual manner from the linear until : @xmath141 stands for @xmath142 .",
    "this property is clearly already expressible in ltl and does not use nesting edges at all .",
    "now let us review some of the properties expressible in the nested call - return logic of @xcite , but not expressible in ltl . in the classical verification formalisms such as hoare logic , correctness of procedures is expressed using pre and post conditions .",
    "partial correctness of a procedure @xmath143 specifies that if the pre - condition @xmath144 holds when the procedure @xmath143 is invoked , then if the procedure terminates , the post - condition @xmath145 is satisfied upon return .",
    "total correctness , in addition , requires the procedure to terminate .",
    "assume that all calls to the procedure @xmath143 are characterized by the proposition @xmath146 .",
    "then , the requirement @xmath147\\ ] ] expresses the total correctness , while @xmath148\\ ] ] expresses the partial correctness .",
    "both these specifications crucially rely upon the abstract - next operator .",
    "the abstract path starting at a position inside a procedure @xmath143 is obtained by successive applications of internal and nesting edges , and skips over invocations of other procedures called from @xmath143 . using the abstract versions of temporal operators",
    ", we can specify properties of such abstract paths .",
    "for example , suppose we want to specify that if a procedure writes to a variable , then it ( that is , the same invocation of the same procedure ) will later read it and do so before writing to it again .",
    "the requirement is expressed by the until formula over abstract paths @xmath149\\ ] ]    the call since - path starting at a position inside a procedure @xmath143 is obtained by successively jumping to the innermost call positions , and encodes the active stack at that position .",
    "stack inspection can specify a variety of security properties .",
    "for instance , the requirement that a procedure @xmath143 should be invoked only within the context of a procedure @xmath150 , with no intervening call to an overriding module @xmath151 , is expressed by the formula @xmath152.\\ ] ]    finally , we turn to _ scope - bounded linear - path _ properties . for a procedure ,",
    "the corresponding scope - bounded linear path is the linear path ( that is , the path obtained by following linear edges ) from its call to it return . that is , a scope - bounded path corresponding to a procedure @xmath153 includes the executions of the procedures ( transitively ) called by @xmath153 , but terminates when the current invocation of @xmath153 returns .",
    "properties about scope - bounded paths are useful in asserting contracts for modules .",
    "suppose we want to assert that a procedure @xmath143 , and the procedures it calls , do not write to a variable before it returns .",
    "this is an invariant of the scope - bounded path , and is captured by the formula : @xmath154\\ ] ] recall that the within operator @xmath155 restricts the evaluation of a formula to a single procedure call .",
    "the same requirement can also be captured using summary paths .",
    "it is even easier to state it using summary - down paths : @xmath156\\ ] ]    suppose we want to specify the requirement that if a procedure writes to a variable then it is read along the scope - bounded path before being written again .",
    "we can use the within modality to express this property : @xmath157\\ ] ] this requirement can also be alternatively specified using summary - down paths as follows : @xmath158\\ ] ] the formula says that from every write operation , there is a read operation along some summary - down path ( and thus , within the same scope ) such that along the path , there is no write , and if the path uses a summary edge , then the enclosed subword also does not contain a write .",
    "it is easy to see that the above requirements concerning scope - bounded paths are specifiable in the first - order logic of nested words .",
    "it is conjectured that they are not specifiable in .",
    "in this section , we study logics that are expressively complete for fo , i.e. temporal logics that have exactly the same power as foformulas with one free variable over finite and infinite nested words . in other words , for every formula @xmath48 of an expressively complete temporal logic there is an fo  formula @xmath159 such that @xmath79 iff @xmath160 for every nested word @xmath27 and position @xmath26 in it , and conversely , for every fo  formula @xmath161 there is a temporal formula @xmath162 such that @xmath163 iff @xmath164 .",
    "our starting point is a logic @xmath2 ( nested - word temporal logic ) based on summary paths introduced in the previous section .",
    "we show that this logic is expressively complete for fo , and of course remains expressively complete with the addition of other first - order expressible operators which may be useful for verification of properties of procedural programs . when we provide upper bounds on the complexity of model checking for @xmath2",
    ", we shall in fact show that the upper bounds hold with respect to an extension , @xmath165 , which includes a number of additional operators .",
    "we then look at logics close to those in the verification literature , i.e. , with operators such as _ call _ and _ abstract until _ and _ since _ , and ask what needs to be added to them to get expressive completeness .",
    "we confirm a conjecture of @xcite that a _ within _ operator is sufficient .",
    "such an operator evaluates a formula on a nested subword .",
    "we then discuss the role of this within operator .",
    "we show that , if added to @xmath2 , it does not increase expressiveness , but makes the logic exponentially more succinct .      the logic @xmath2 ( _ nested words temporal logic _ ) has next and previous operators , as well as until and since with respect to summary paths .",
    "that is , its formulas are given by : @xmath166 where @xmath39 ranges over @xmath20 .",
    "we use abbreviations @xmath167 for @xmath168 ( true in an internal position ) . note that in the absence of pending calls and returns , @xmath6 and @xmath169 are definable as @xmath170 and @xmath171 , respectively .",
    "[ nwtl - thm ] @xmath172 over both finite and infinite nested words .    _",
    "proof_. we start with the easy direction @xmath173 .    [ nwtl - to - fo - lemma ] for every @xmath2 formula @xmath48 , there exists an fo  formula @xmath174 that uses at most three variables @xmath175 such that for every nested word @xmath27 ( finite or infinite ) , and every position , @xmath26 in @xmath27 , we have @xmath79 iff @xmath176 .",
    "the proof is by induction on the formulas and very simple for all the cases except @xmath121 and @xmath122 : for example , @xmath177    for translating @xmath121 , we need a few auxiliary formulas . our first goal is to define a formula @xmath178 saying that @xmath179 is @xmath180 , i.e. the return of the innermost call within which @xmath181 is executed . for that , we start with @xmath182 saying that @xmath183 is a return that is preceded by @xmath181 and whose matching call precedes @xmath181 , that is , @xmath183 is a candidate for @xmath180 .",
    "then the formula @xmath178 is given by @xmath184 likewise , we define @xmath185 stating that that @xmath183 equals @xmath186 , that is , the innermost call within which @xmath181 is executed",
    ". now define @xmath187 and @xmath188 as @xmath189 .",
    "then this formula says that the summary path from @xmath179 to @xmath183 does not pass through @xmath181 , assuming @xmath190 . with this , @xmath191 is given by @xmath192 the proof for @xmath193 is similar .",
    "this concludes the proof of the lemma .    in the proof of the other direction , @xmath194",
    ", we shall use a tree representation of nested words .",
    "the translation is essentially the same as in @xcite . for each nested word @xmath27",
    "we have a binary tree @xmath195 ( i.e. , its nodes are elements of @xmath196 ) and a function @xmath197 that maps each position of @xmath27 to a node of @xmath195 as follows :    1 .",
    "the first position of @xmath27 is mapped into the root of @xmath195 ; 2 .",
    "if @xmath198 then : 1 .   if @xmath26 is an internal , or an unmatched call , or a matched call whose return is the last position of @xmath27 , or an unmatched return , and @xmath26 is not the last position of @xmath27 , then @xmath199 has only child @xmath200 and @xmath201 ; 2 .",
    "if @xmath26 is a matched call whose return is not the last position in @xmath27 , then @xmath199 has both children @xmath200 and @xmath202 and @xmath203 , and @xmath204 .",
    "if @xmath26 is a matched return , then @xmath199 has no children .",
    "the @xmath20-labels of @xmath26 and @xmath205 are the same .",
    "if @xmath26 was a pending call , we label @xmath205 with @xmath206 , and if @xmath26 was a pending return , we label @xmath205 with @xmath207 .    note that @xmath208 is a bijection , and that labels @xmath206 and @xmath207 may only occur on the leftmost branch of @xmath195 .",
    "an example of a nested word and its translation are given in fig .",
    "[ transl - fig ] .    to relate paths in nested words and paths in their tree translations ,",
    "we introduce the notions of semi - strict and strict paths .",
    "intuitively , a semi - strict path in a nested word corresponds to a path on its tree translation that , in addition to following tree edges , can jump from a node with no children to its successor in the depth - first traversal of the tree ( where depth - first starts with the right subtree and then moves to the left subtree ) .",
    "a strict path is just a path that follows tree edges .",
    "these are both slight modifications of summary paths .",
    "more precisely , a _ semi - strict path _ between positions @xmath26 and @xmath29 , with @xmath11 , in a nested word @xmath27 , is a sequence @xmath209 such that @xmath210 that is , when skipping a call , instead of jumping to the matching return position , a semi - strict path will jump to its successor .",
    "a _ strict path _ is a semi - strict path @xmath211 in which no @xmath212 with @xmath108 is a matched return position . in other words ,",
    "a strict path stops if it reaches a matched return position .",
    "in particular there may be positions @xmath213 in a nested word such that no strict path exists between them .",
    "for example , in fig .",
    "[ transl - fig ] , @xmath214 is a semi - strict path . although @xmath214 is not a path in the tree ( we jump from 5 to 6 ) , this",
    "is allowed under the definition of semi - strict paths .",
    "strict paths are exactly the paths on the tree ; for example , @xmath215 is such a path .    #",
    "1#2#3#4#5 @font    ( 4397,2527)(0,1010 ) ( 3196,1357)(0,0)[lb]5 ( 721.000,1638.250 ) ( 46,1725 ) ( 46,1725 ) ( 496,1725 ) ( 496,1725 ) ( 946,1725 ) ( 946,1725 ) ( 1396,1725 ) ( 1396,1725 ) ( 1846,1725 ) ( 1846,1725 ) ( 2296,1725 ) ( 2296,1725 ) ( 3646,2330 ) ( 3646,2330 ) ( 3346,2025 ) ( 3346,2025 ) ( 3346,1425 ) ( 3346,1425 ) ( 3646,1725 ) ( 3646,1725 ) ( 3946,2025 ) ( 3946,2025 ) ( 4246,1725 ) ( 4246,1725 ) ( 46,1732)(496,1732 ) ( 376.000,1702.000)(496.000,1732.000)(376.000,1762.000)(376.000,1702.000 ) ( 496,1732)(946,1732 ) ( 826.000,1702.000)(946.000,1732.000)(826.000,1762.000)(826.000,1702.000 ) ( 946,1732)(1396,1732 ) ( 1276.000,1702.000)(1396.000,1732.000)(1276.000,1762.000)(1276.000,1702.000 ) ( 1396,1732)(1846,1732 ) ( 1726.000,1702.000)(1846.000,1732.000)(1726.000,1762.000)(1726.000,1702.000 ) ( 1846,1732)(2296,1732 ) ( 2176.000,1702.000)(2296.000,1732.000)(2176.000,1762.000)(2176.000,1702.000 ) ( 3646,2332)(3346,2032 ) ( 3409.640,2138.066)(3346.000,2032.000)(3452.066,2095.640)(3409.640,2138.066 ) ( 3646,2332)(3946,2032 ) ( 3839.934,2095.640)(3946.000,2032.000)(3882.360,2138.066)(3839.934,2095.640 ) ( 3946,2032)(4246,1732 ) ( 4139.934,1795.640)(4246.000,1732.000)(4182.360,1838.066)(4139.934,1795.640 ) ( 3946,2032)(3646,1732 ) ( 3709.640,1838.066)(3646.000,1732.000)(3752.066,1795.640)(3709.640,1838.066 ) ( 3646,1732)(3346,1432 ) ( 3409.640,1538.066)(3346.000,1432.000)(3452.066,1495.640)(3409.640,1538.066 ) ( 26,1499)(0,0)[lb]1 ( 486,1499)(0,0)[lb]2 ( 946,1499)(0,0)[lb]3 ( 1396,1499)(0,0)[lb]4 ( 1846,1499)(0,0)[lb]5 ( 2296,1499)(0,0)[lb]6 ( 3571,2407)(0,0)[lb]1 ( 3196,2032)(0,0)[lb]6 ( 4021,2032)(0,0)[lb]2 ( 4321,1732)(0,0)[lb]3 ( 3496,1732)(0,0)[lb]4 ( 946.000,1063.250 )    the until / since operators for semi - strict paths and strict paths will be denoted by @xmath216 and @xmath217 , respectively . versions of @xmath2 in which @xmath218 are replaced by @xmath216 ( @xmath217 ) will be denoted by @xmath219 ( @xmath220 ) .",
    "we will use @xmath221 for @xmath222 , and @xmath223 for @xmath224 , to capture matching return and call positions , respectively .    the proof is based on two lemmas .    [ nwtl - lemma - one ] @xmath225 .",
    "[ nwtl - lemma - two ] @xmath226 .",
    "this of course implies the theorem : @xmath227 .",
    "note that as a corollary we also obtain @xmath228 .    for translating an @xmath220 formula @xmath48 into an equivalent formula @xmath229 of @xmath219 we need to express @xmath230 with @xmath231 , which is simply @xmath232 , and likewise for the since operators . for translating each @xmath219 formula @xmath48 into an equivalent @xmath2 formula @xmath233",
    ", again we need to consider only the case of until / since operators .",
    "the formula @xmath234 is translated into @xmath235 where @xmath236 is a formula defined as follows : @xmath237 the idea is that we split a semi - strict path into a semi - strict up path ( where call edges are excluded ) followed by a semi - strict down path ( where return edges are excluded ) .",
    "the first until in ( [ trans - eq ] ) captures the semi - strict up path and the second until in @xmath236 captures the semi - strict down path .",
    "the translation for @xmath238 is similar .",
    "the proof that the translation is correct is a rather detailed case analysis which we have relegated to the appendix .    we start with the finite case , and then show how the inclusion extends to nested @xmath1-words .    as a tool we shall need a slight modification of a result from @xcite providing an expressively complete temporal logic for trees with at most binary branching .",
    "we consider binary trees whose domain @xmath239 is a prefix - closed subset of @xmath196 , and we impose a condition that if @xmath240 then @xmath241 .",
    "when we refer to fo  on trees , we assume they have two successor relations @xmath242 and the descendant relation @xmath243 ( which is just the prefix relation on strings ) plus the labeling predicates , which include two new labels @xmath206 and @xmath207 ( for pending calls and returns ) .",
    "each node can be labeled by either a letter from @xmath20 , or by a letter from @xmath20 and @xmath206 , or by a letter from @xmath20 and @xmath207 ( i.e. labels @xmath206 and @xmath207 need not be disjoint from other labels ) .",
    "we also consider the following logic @xmath244 : @xmath245 where @xmath39 ranges over @xmath246 , with the following semantics :",
    "1 .   @xmath247 iff @xmath248 for some @xmath249 ; 2 .",
    "@xmath250 iff @xmath251 ( where @xmath26 is either @xmath252 or @xmath253 ) ; 3 .   @xmath254 iff @xmath255",
    "; 4 .   @xmath256 iff @xmath257 ; 5 .",
    "@xmath258 iff there exists @xmath259 such that @xmath260 , @xmath261 , and @xmath262 for all @xmath263 such that @xmath264 ; 6 .",
    "@xmath265 iff there exists @xmath259 such that @xmath266 , @xmath261 , and @xmath262 for all @xmath263 such that @xmath267 .",
    "[ marx - lemma ] ( see @xcite )  for unary queries over finite binary trees , @xmath268 .",
    "this lemma is an immediate corollary of expressive completeness of logic @xmath269 from @xcite on ordered unranked trees , as for a fixed number of siblings , the until and since operators can be expressed in terms of the next and previous operators .",
    "the result of @xcite applies to arbitrary alphabets , and thus in particular to our labeling that may use @xmath206 and @xmath207 .",
    "the following is immediate by using the tree representation of nested words and a straightforward translation of formulae .",
    "[ fo - to - fo - claim ] for every @xmath56 formula @xmath270 over nested words there is an foformula @xmath159 over trees such that for every nested word @xmath27 and a position @xmath26 in it , we have @xmath271 iff @xmath272 .",
    "in fact the converse , that fo  over trees @xmath273 can be translated into fo  over nested words , is true too , but we do not need it in this proof .",
    "since @xmath274 by lemma [ marx - lemma ] , all that remains to prove is the following claim .",
    "[ tltree - to - nwtl ] for every @xmath244 formula @xmath48 , there exists an @xmath220 formula @xmath275 such that for every nested word @xmath27 and every position @xmath26 in it , we have @xmath276    this is now done by induction , omitting the obvious cases of propositional letters and boolean connectives .",
    "we note that a path down the tree from @xmath205 to @xmath277 corresponds precisely to the strict path from @xmath26 to @xmath29 ( that is , if such a strict path is @xmath278 , then @xmath279 is the path from @xmath205 to @xmath277 in @xmath195 ) . hence , the translations of until and since operators are : @xmath280 for translating next and previous operators , and pending calls / returns , define : @xmath281 then the rest of the translation is as follows : @xmath282 now with the proof completed for finite nested words , we extend it to the case of nested @xmath1-words .",
    "note that claim [ fo - to - fo - claim ] continues to hold , and claim [ tltree - to - nwtl ] provides a syntactic translation that applies to both finite and infinite nested words , and thus it suffices to prove an analog of lemma [ marx - lemma ] for trees of the form @xmath195 , where @xmath27 ranges over nested @xmath1-words .    if @xmath27 is a nested @xmath1-word , then @xmath195 has exactly one infinite branch , which consists precisely of all nodes of the form @xmath205 where @xmath26 is an _ outer _ position ,",
    "i.e. , not inside any ( matched ) call .",
    "we say that @xmath26 is inside a call if there exists a call @xmath29 with a matching return @xmath57 such that @xmath283 .",
    "if @xmath26 is an outer position , then we shall call @xmath205 an _ outer _",
    "node in the tree @xmath195 as well .",
    "if @xmath26 is an outer position which is not a matched call , then @xmath55 is also an outer position and @xmath284 is the left successor of @xmath205 .",
    "if @xmath26 is an outer position and a call with @xmath285 being its matching return , then the left successor of @xmath205 on the infinite path is @xmath286 .",
    "furthermore , the subtree @xmath287 , which has @xmath205 as the root , plus its right child , and all the descendants of the right child , is finite and isomorphic to @xmath288}$ ] ( note that @xmath41 $ ] has no pending calls / returns ) .",
    "if @xmath26 is an outer position other than a matched call , we let @xmath287 be a single node tree labeled with @xmath26 s label in @xmath27 .",
    "let @xmath27 now be a nested @xmath1-word .",
    "for each outer position @xmath26 we let @xmath289 be the rank-@xmath69 type of @xmath287 .",
    "if @xmath26 is not a matched call , such a type is completely described by @xmath26 s label ( which consists of a label in @xmath20 and potentially @xmath206 or @xmath207 ) .",
    "if @xmath29 is not an outer position , and @xmath26 is an outer position such that @xmath290 , where @xmath57 is the matching return of @xmath26 , then @xmath291 is the rank-@xmath69 type of @xmath292,{\\iota_{\\text{\\rm w - t}}}(j))$ ] ( i.e. , the type of @xmath293 $ ] with a distinguished node corresponding to @xmath29 ) .",
    "next , for a nested @xmath1-word @xmath27 , let @xmath199 be a node in @xmath195 such that @xmath198 .",
    "let @xmath294 enumerate all the outer positions of @xmath27 , and assume that @xmath212 is such that @xmath295  that is , @xmath205 is a node in the subtree @xmath296 .",
    "we now define a finite word @xmath297 of length @xmath298 such that its positions @xmath299 are labeled @xmath300 , and an @xmath1-word @xmath301 such that its positions @xmath302 are labeled by @xmath303 .",
    "next we show :    [ nwtl - comp - claim ] let @xmath304 be two nested @xmath1-words , and @xmath305 two nodes in @xmath195 and @xmath306 such that :    1 .   @xmath307 ; 2 .",
    "@xmath308 ; 3 .",
    "@xmath309 .    then @xmath310 .",
    "a standard composition argument shows that player ii  wins .",
    "if @xmath294 enumerate outer positions in @xmath27 and @xmath311 , then a move by player i , say , in @xmath195 , occurs either in @xmath312 with @xmath44 , or in @xmath287 , or in @xmath312 with @xmath285 .",
    "player iithen selects @xmath313 so that the response is in @xmath314 according to his winning strategy in games either ( a ) or ( b ) ( if @xmath29 is in @xmath287 , then @xmath313 is in @xmath315 ) , and then , since the rank-@xmath69 types of @xmath312 and the chosen @xmath314 are the same , selects the actual response according to the winning strategy @xmath316 .",
    "next we show how claim [ nwtl - comp - claim ] proves that @xmath56 is expressible in @xmath244 over infinite trees @xmath195 .",
    "first note that being an outer node is expressible : since @xmath317 is true in right children of matched calls , then @xmath318 is true if no node on the path to the root is inside a call , that is , precisely in outer nodes .",
    "next note that for each rank-@xmath69 type @xmath60 of a tree there is a @xmath244 formula @xmath319 such that if @xmath198 is an outer node of @xmath195 , then @xmath320 iff the rank-@xmath69 type of @xmath287 is @xmath60 . if @xmath26 is not a matched call , then such a type is uniquely determined by @xmath26 s label and perhaps @xmath206 or @xmath207 , and thus is definable in @xmath244 .    if @xmath26 is a matched call , the existence of such a formula @xmath319 follows from the fact that the rank-@xmath69 type of @xmath287 is completely determined by the label of @xmath26 and the rank-@xmath69 type @xmath321 of the subtree @xmath322 of @xmath287 rooted at the right child of @xmath199 ( recall that the root only has a right child , by the definition of @xmath287 )",
    "type @xmath321 is expressible in fo and , since @xmath287 is finite , by lemma [ marx - lemma ] it is expressible by a @xmath244 formula @xmath323 .",
    "if we now inductively take conjunction of every subformula in @xmath323 with @xmath324 , we obtain a formula @xmath325 such that @xmath326 iff @xmath327 iff the rank-@xmath69 type of @xmath322 is @xmath321 .",
    "hence , @xmath319 is expressible in @xmath244 as a boolean combination of propositional letters from @xmath20 and formulas @xmath328 .",
    "note that in this case , @xmath319 does not use @xmath206 and @xmath207 .    by claim [ nwtl - comp - claim ] , we need to express , for each node @xmath198 , the rank-@xmath69 types of @xmath297 and @xmath301 in @xmath244 over @xmath195 , as well as the rank-@xmath69 type of @xmath329 , in order to express a quantifier - rank @xmath69 formula , as it will be a boolean combination of such formulas .",
    "given @xmath199 , we need to define @xmath330  the outer position in whose scope @xmath199 occurs  and then from that point evaluate two fo formulas , defining rank-@xmath69 types of words over the alphabet of rank-@xmath69 types of finite trees . by kamp",
    "s theorem @xcite , each such fo formula is equivalent to an ltl formula whose propositional letters are rank-@xmath69 types of trees .",
    "assume we have an ltl formula @xmath236 expressing the rank-@xmath69 type @xmath331 of @xmath301 . by kamp s theorem and the separation property for ltl",
    ", it is written using only propositional letters , boolean connectives , @xmath80 and @xmath332 ( that is , no @xmath86 and @xmath333 ) .",
    "we now inductively take conjunction of each subformula of @xmath236 with @xmath334 ( i.e. , a @xmath244 formula which is true in left successors ) , replace ltl connectives @xmath80 and @xmath332 by @xmath335 and @xmath336 , and replace each propositional letter @xmath60 by @xmath319 , to obtain a @xmath244 formula @xmath337",
    ". then @xmath338 iff @xmath301 has type @xmath331 .",
    "thus , for a formula @xmath339 is true in @xmath340 iff the rank-@xmath69 type of @xmath301 is @xmath331 .",
    "the proof for @xmath297 is similar .",
    "since this word is finite , by kamp s theorem and the separation property , there is an ltl formula @xmath236 that uses @xmath86 , @xmath333 , propositional letters and boolean connectives such that @xmath236 evaluated in the last position of the word expresses its rank-@xmath69 type . since there is exactly one path from each node to the root , to translate @xmath236 into a @xmath244 formula @xmath337 we just need to replace propositional letters by the corresponding formulas @xmath319 , and @xmath86 by @xmath341 . then , as for the case of @xmath301 , we have that @xmath337 evaluated in @xmath330 expresses the type of @xmath297",
    ". then finally the same formula as in the case of @xmath301 evaluated in @xmath199 expresses that type .",
    "finally we need a @xmath244 formula that expresses @xmath289 , the rank-@xmath69 type of @xmath287 , when evaluated in @xmath340 .",
    "we can split this into two cases .",
    "if @xmath342 is true in @xmath205 , then , as explained earlier , the rank-@xmath69 type of @xmath287 is a boolean combination of propositional letters , and thus definable .",
    "so we now consider the case when @xmath342 is not true in @xmath205",
    ". then @xmath289 is given by a boolean combination of formulas that specify ( 1 ) the label of @xmath212 , and ( 2 ) the rank-@xmath69 type of the subtree of @xmath296 rooted at the right child of @xmath330 with @xmath199 as a distinguished node .",
    "this type can be expressed by a formula @xmath236 in @xmath244 over @xmath343 by @xcite .",
    "hence if in @xmath236 we recursively take the conjunction of each subformula with @xmath324 , we obtain a formula @xmath337 of @xmath244 that expresses the type of @xmath344 when evaluated in @xmath345 .",
    "thus , @xmath329 is expressible by a boolean combination of formulas @xmath337 and @xmath346 where @xmath39 is a propositional letter .",
    "this completes the proof of translation of fo  into @xmath244 over nested @xmath1-words , and thus the proof of lemma [ nwtl - lemma - two ] and theorem [ nwtl - thm ] .",
    "recall that @xmath76 stands for a fragment of fo  that consists of formulas which use at most @xmath57 variables in total .",
    "first , from our translation from @xmath2 to fo  we get :    over nested words , every fo  formula with at most one free variable is equivalent to an @xmath347 formula .",
    "it is well known that ltl over @xmath1-words has the separation property , and in particular , every ltl formula is equivalent to an ltl formula without the past connectives when evaluated in the first position of an @xmath1-word . in the case of nested words , however , the situation is quite different from ltl .",
    "the following proposition shows that past connectives are necessary even when one evaluates formulae in the first position of a nested word .",
    "we let @xmath348 be the future fragment of @xmath2 ( i.e. the fragment that does not use @xmath122 and the operators @xmath86 and @xmath87 ) .",
    "[ nwtlf - prop ] there are fo  sentences over nested words that can not be expressed in @xmath348 .    _",
    "proof_. we shall look at finite nested words ; the proof for the infinite case applies verbatim . to evaluate a formula @xmath48 of @xmath348 in position @xmath26 of a nested word @xmath27 of length @xmath21 one only needs to look at @xmath349 $ ] .",
    "that is , if @xmath27 and @xmath350 of length @xmath21 and @xmath351 respectively are such that @xmath349\\cong{{\\bar{w}}}[i',n']$ ] , then @xmath79 iff @xmath352 for every formula @xmath48 of @xmath348 .    furthermore ,",
    "for every collection of @xmath348 formulas @xmath353 , one can find a number @xmath354 such that @xmath355 { \\equiv}_k { { \\bar{w}}}[i',n ' ] \\ \\ \\ \\text{implies}\\ \\ \\ \\ ( { { \\bar{w}}},i)\\models\\psi_p \\leftrightarrow ( { { \\bar{w}}}',i')\\models\\psi_p , \\ \\",
    "\\text{for all } p\\leq l.\\ ] ] in particular , if @xmath356 stands for the word of length @xmath357 in which all positions are labeled @xmath358 and the matching relation is empty , there are numbers @xmath359 depending only on @xmath360 , such that @xmath361    now consider the following @xmath2 formula : @xmath362 saying that the first position is a call , and the predecessor of its matching return is labeled @xmath39 .",
    "we claim that this is not expressible in @xmath348 .",
    "assume to the contrary that there is a formula @xmath363 of @xmath348 equivalent to @xmath364 .",
    "let @xmath360 be the collection of all subformulas of @xmath363 , including @xmath363 itself , and let @xmath365 and @xmath366 be constructed as above .",
    "we now consider two nested words @xmath367 and @xmath368 of length @xmath369 whose underlying words are @xmath370 of length @xmath371 , such that the matching relation @xmath372 of @xmath367 has one edge @xmath373 , and the matching relation @xmath374 of @xmath368 has one edge @xmath375 . in other words ,",
    "the only return position of @xmath367 is @xmath376 , and the only return position of @xmath368 is @xmath377 , and thus @xmath378=b^{k_1}$ ] and @xmath379=b^{k_2}$ ] .",
    "further notice that for every @xmath380 we have @xmath381\\cong { { \\bar{w}}}_2[i , n]$ ] .",
    "observe that @xmath382 and @xmath383 .",
    "we now prove by induction on formulas in @xmath360 that for each such formula @xmath236 we have @xmath384 iff @xmath385 , thus proving that @xmath363 and @xmath364 can not be equivalent .    1 .",
    "the base case of propositional letters is immediate .",
    "the boolean combinations are straightforward too .",
    "3 .   let @xmath386 .",
    "then @xmath387 since @xmath388\\cong { { \\bar{w}}}_2[2,n]$ ] .",
    "4 .   let @xmath389 .",
    "then @xmath390 since @xmath391 . 5 .",
    "let @xmath392 .",
    "assume @xmath384 .",
    "consider three cases",
    "case 1 : @xmath393 . by the hypothesis @xmath394",
    "and we are done .",
    "2 .   case 2 : the witness for @xmath395 occurs beyond the only return . then @xmath396 and @xmath397 . since @xmath398 we have @xmath399 , and by the hypothesis , @xmath400 , so @xmath401 .",
    "3 .   case 3 : the witness for @xmath395 occurs inside the call . since for every position @xmath402 we have @xmath403 iff @xmath404 and likewise for @xmath405 , the same summary path witnesses @xmath395 in @xmath368 .",
    "+ thus , @xmath385 . +",
    "now assume @xmath385 .",
    "in the proof of @xmath384 is the same as above in cases 1 and 2 . for case 3 ,",
    "assume that in the path which is a witness for @xmath395 the position in which @xmath405 is true is the 2nd or the 3rd position in the word .",
    "then the same path witnesses @xmath384 , as in the proof of case 3 above .",
    "next assume it is a position with index @xmath29 higher than @xmath406 ( which is still labeled @xmath358 ) where @xmath405 first occurs .",
    "then @xmath48 must be true in all positions @xmath26 with @xmath407 in @xmath368 .",
    "hence @xmath48 is true in all such positions in @xmath367 as well , and thus the summary path in @xmath367 that skips the first call ( i.e. jumps from @xmath253 to @xmath406 ) witnesses @xmath395 .",
    "hence , in all the cases @xmath385 implies @xmath384 , which completes the inductive proof , and thus shows the inexpressibility of @xmath364 in @xmath348 .",
    "note also that adding all other until / since pairs to @xmath2 does not change its expressiveness .",
    "that is , if we let @xmath165 be @xmath408 , then :    @xmath409 .",
    "later , when we provide our upper bounds for model - checking , we shall pride the upper bounds with respect to @xmath165 rather than just @xmath2 .",
    "_ remark _  in the conference version , we had a corollary stating that the since operator can be eliminated for formulae evaluated in the first position of a nested word .",
    "it relied on the proof of theorem [ nwtl - thm ] and the _ separation property _ for @xmath244 claimed in @xcite .",
    "the latter , as was discovered recently , is incorrect .",
    "the proof of theorem [ nwtl - thm ] relies only on the expressive completeness of @xmath244 which is correct @xcite and thus is not affected .",
    "we now go back to the three until / since operators originally proposed for temporal logics on nested words , based on the the linear , call , and abstract paths . in other words ,",
    "our basic logic , denoted by @xmath410 , is @xmath411    we now extend this logic with the _ within _ @xmath155 operator proposed in @xcite .",
    "recall that @xmath128 iff @xmath26 is a call , and @xmath47,i)\\models{\\varphi}$ ] , where @xmath129 if @xmath26 is a matched call , @xmath130 if @xmath26 is an unmatched call and @xmath27 is finite , and @xmath131 otherwise .",
    "we denote this extended logic by @xmath412 .",
    "[ within - thm ] @xmath413 over both finite and infinite nested words .",
    "the translation from @xmath414 into @xmath56 is similar to the translation used in the proof of theorem [ expcompl - one ] . to prove the other direction ,",
    "we show how to translate @xmath220 into @xmath414 .",
    "recall that by lemma [ nwtl - lemma - two ] , we know that @xmath415 over both finite and infinite nested words . more precisely , for every formula @xmath416 in @xmath220 , we show how to construct a formula @xmath417 in @xmath418 such that for every nested word @xmath27 ( finite or infinite ) and position @xmath26 in it , we have that @xmath419 if and only if @xmath420 .",
    "since @xmath421 includes the same past modalities as @xmath220 , @xmath417 is trivial to define for the atomic formulas , boolean combinations and next and previous modalities : @xmath422 thus , we only need to show how to define @xmath423 and @xmath424 .",
    "formula @xmath423 is defined as : @xmath425 \\ \\vee \\   \\bigg[\\neg { { \\tt{mret}}}\\wedge   \\bigg(\\bigg(\\beta_\\varphi { { { \\mathbf u}}^a}(\\neg { { \\tt{mret}}}\\wedge \\alpha_\\psi)\\bigg )   \\ \\vee \\\\   \\bigg(\\beta_\\varphi { { { \\mathbf u}}^a}(\\beta_\\varphi \\wedge { { \\text{\\raisebox{1pt}{$\\bigcirc$}}}}({{\\tt{mret}}}\\wedge \\alpha_\\psi))\\bigg ) \\ \\vee",
    "\\   \\bigg(\\beta_\\varphi { { { \\mathbf u}}^a}{{\\mathcal{w}}}{\\text{\\large $ \\diamond$}}(\\alpha_\\psi \\wedge { { { \\text{\\large $ \\mathbf{\\circleddash}$}}}}(\\gamma { { { \\mathbf s}}^c}(\\alpha_\\varphi \\wedge \\neg { { { \\text{\\large $ \\mathbf{\\circleddash}$}}}}\\top)))\\bigg)\\bigg)\\bigg ]    \\end{gathered}\\ ] ] where @xmath221 is defined as @xmath222 , to capture matching return positions , @xmath426 is defined as @xmath427 and formulas @xmath428 , @xmath236 are defined as : @xmath429 moreover , formula @xmath424 is defined as : @xmath430 this concludes the proof of the theorem .",
    "the logic @xmath0 , as defined in @xcite , did not have all the operators of @xmath410 .",
    "in fact it did not have the previous operators @xmath86 and @xmath87 , and it only had linear and abstract until operators , and the call since operator .",
    "that is , @xmath0 was defined as @xmath431 and we assume that @xmath39 ranges over @xmath432 , where @xmath207 is true in pending returns . notice that @xmath207 is not expressible with the remaining operators .",
    "recall that the operator @xmath117 is the previous operator corresponding to call paths ; formally , @xmath118 iff @xmath102 is defined and @xmath119 .",
    "a natural question is whether there is an expressively - complete extension of this logic .",
    "it turns out that the past modality @xmath86 , together with two _ within _ operators based on @xmath433 and @xmath434 ( the innermost call and its return ) functions provide such an extension .",
    "we define two new formulas @xmath435 and @xmath436 with the semantics as follows :    1 .   @xmath437 iff @xmath438,j ) \\models { \\varphi}$ ] , where @xmath439 if @xmath102 is defined , and @xmath440 otherwise .",
    "2 .   @xmath441 if @xmath47,i ) \\models { \\varphi}$ ] , where @xmath442 if @xmath103 is defined , and @xmath130 ( if @xmath27 is finite ) or @xmath443 ( if @xmath27 is infinite ) otherwise .",
    "the logic obtained by adding @xmath433 and @xmath434 to @xmath0 is denoted by @xmath444 .",
    "[ expcompl - one ] @xmath445 over both finite and infinite nested words .    as a corollary ( to the proof )",
    "we obtain the following :    for every fo formula @xmath270 over finite or infinite nested words , there is a formula @xmath405 of @xmath444 that does not use the @xmath115 operator , such that @xmath446 iff @xmath447 .",
    "the proof of this result is somewhat involved , and relies on different techniques .",
    "the operators used in @xmath0 do not correspond naturally to tree translations of nested words , and the lack of all until / since pairs makes a translation from @xmath2 hard .",
    "we thus use a composition argument _ directly _ on nested words .",
    "the theorem is proved for finite nested words , but the same techniques can be used to prove the infinite case .",
    "we extend the vocabulary with two constants @xmath448 and @xmath449 , and assume that @xmath448 is always interpreted as the first element of the nested word and @xmath449 as the last element .",
    "let @xmath27 be a finite nested word of length @xmath21 and and @xmath26 an element in @xmath27 .",
    "let @xmath450 , where @xmath71 , be all elements in @xmath27 such that , for each @xmath451 $ ] , @xmath452 and there is an element @xmath453 such that @xmath454 and @xmath455 . assume without loss of generality that @xmath456 .",
    "fix @xmath66 .",
    "let @xmath457 be the set of all rank-@xmath57 types of nested words with distinguished constants @xmath448 and @xmath449 ( including the rank-@xmath57 type of the empty nested word ) .",
    "we define the word @xmath458 over alphabet @xmath459 as follows :    1 .",
    "the element @xmath460 is labeled with the tuple whose first component is the rank-@xmath57 type of @xmath461,{{\\rm min}},{{\\rm max}})$ ] and whose second component is the rank-@xmath57 type of @xmath462,{{\\rm min}},{{\\rm max}})$ ] if @xmath463 ( notice that if @xmath464 then @xmath465 $ ] is the empty nested word , and the same is true of @xmath466 $ ] if @xmath467 ) ; otherwise , it is labeled with the tuple whose first component is the rank-@xmath57 type of @xmath468,{{\\rm min}},{{\\rm max}})$ ] and whose second component is the rank-@xmath57 type of @xmath469,{{\\rm min}},{{\\rm max}})$ ] ( notice that if @xmath470 then @xmath471 $ ] is the empty nested word ) ; 2 .   for each @xmath472 ,",
    "the element @xmath473 is labeled with the tuple whose first component is the rank-@xmath57 type of @xmath474,{{\\rm min}},{{\\rm max}})$ ] and whose second component is the rank-@xmath57 type of @xmath475,{{\\rm min}},{{\\rm max}})$ ] ; and 3 .   if @xmath476 then the element @xmath477 is labeled with the the tuple whose first component is the rank-@xmath57 type of @xmath478,{{\\rm min}},{{\\rm max}})$ ] and whose second component is the rank-@xmath57 type of @xmath479,{{\\rm min}},{{\\rm max}})$ ] .",
    "the following is our composition argument :    [ lemma : comp ]",
    "let @xmath367 and @xmath368 be two nested words , and let @xmath26 and @xmath480 be two elements in @xmath367 and @xmath368 , respectively",
    ". then @xmath481 implies @xmath482 .",
    "first we need to introduce some terminology .",
    "let @xmath27 be a finite nested word of length @xmath21 and @xmath26 be a position in @xmath27 .",
    "assume elements @xmath483 are defined as above .",
    "with each element @xmath199 of @xmath27 we associate an element @xmath484 $ ] of @xmath485 as follows :    1 .",
    "if @xmath486 and @xmath199 belongs to @xmath465 $ ] or @xmath487 $ ] , then @xmath484 $ ] is the first element of @xmath485 . in such case",
    "we say that @xmath488 $ ] and @xmath487 $ ] are the left and right intervals represented by @xmath484 $ ] , respectively . + if @xmath489 and @xmath199 is an arbitrary element of @xmath27 , then @xmath484 $ ] is also the first ( and unique ) element of @xmath485 .",
    "in such case we say that @xmath490 $ ] and @xmath349 $ ] are the left and right intervals represented by @xmath484 $ ] , respectively .",
    "if @xmath463 and @xmath199 belongs to @xmath491 $ ] or @xmath492 $ ] , then @xmath484 $ ] is the last element of @xmath485 . in such case",
    "we say that @xmath491 $ ] and @xmath492 $ ] are the left and right intervals represented by @xmath484 $ ] , respectively .",
    "3 .   if @xmath463 and @xmath199 belongs to @xmath493 $ ] or @xmath494 $ ] , for some @xmath495 , then @xmath484 $ ] is the @xmath496-th element of @xmath485 . in such case",
    "we say that @xmath493 $ ] and @xmath494 $ ] are the left and right intervals represented by @xmath484 $ ] , respectively .",
    "we denote by @xmath484^l$ ] and @xmath484^r$ ] the left and right intervals represented by @xmath484 $ ] , respectively .",
    "we now prove the lemma . for each round @xmath29 ( @xmath497 ) of the @xmath57-round game on @xmath498 and @xmath499 ,",
    "player ii s response @xmath500 in @xmath368 to an element @xmath473 in @xmath367 , played by player i is defined as follows ( the strategy for the case when player i  picks a point in @xmath368 is completely symmetric ) .",
    "assume that player i  plays element @xmath501 $ ] in @xmath502 in round @xmath29 of the @xmath503-round game on @xmath502 and @xmath504 .",
    "then given that @xmath481 , player ii  uses her winning strategy to choose a response @xmath505 $ ] in @xmath504 to @xmath501 $ ] .",
    "thus , by definition of @xmath506 , we have that the right and left intervals represented by @xmath501 $ ] have the same rank-@xmath57 type as the right and left intervals represented by @xmath505 $ ] , respectively . hence ,",
    "if @xmath473 belongs to the left interval represented by @xmath501 $ ] , then the player iican find response @xmath500 to @xmath473 according to the winning strategy for the @xmath57-round game on @xmath501^l$ ] and @xmath505^l$ ] , and if @xmath473 belongs to the right interval represented by @xmath501 $ ] , then the player ii  can find response @xmath500 to @xmath473 according to the winning strategy for the @xmath57-round game on @xmath501^r$ ] and @xmath505^r$ ] .",
    "assume that for round @xmath507 the elements played by following this strategy are ( 1 ) @xmath508,\\dots,[p_j])$ ] in @xmath502 , ( 2 ) @xmath509,\\dots,[q_j])$ ] in @xmath504 , ( 3 ) @xmath510 in @xmath367 , and ( 4 ) @xmath511 in @xmath368 .",
    "we note that by definition of the strategy , for every @xmath512 $ ] , we have that @xmath513 or @xmath514 . since we assume that the @xmath515 $ ] s and @xmath505 $ ] s are played according to a winning strategy for player ii  in the @xmath503-round game on @xmath502 and @xmath504 , it is the case that : @xmath516,\\dots,[p_j ] ) & \\equiv_{k - j+2 } & \\\\ ( \\omega_k({{\\bar{w}}}_2,i'),[q_1],\\dots,[q_j ] ) .",
    "\\end{aligned}\\ ] ] by the way the strategy is defined , for each @xmath517 $ ] , if @xmath518 and @xmath519 are the subtuples of @xmath520 containing the elements from @xmath520 that belong to @xmath521^l$ ] and @xmath521^r$ ] , respectively , then the corresponding subtuples @xmath522 and @xmath523 of @xmath511 contain the elements from @xmath524 that belong to @xmath525^l$ ] and @xmath525^r$ ] , respectively .",
    "further , by definition of the strategy , we also have that @xmath526^l,\\bar a^l_{\\ell},{{\\rm min}},{{\\rm max } } ) \\equiv_{k - j } ( [ b_{\\ell}]^l,\\bar b^l_{\\ell},{{\\rm min}},{{\\rm max}})$ ] and @xmath526^r,\\bar a^r_{\\ell},{{\\rm min}},{{\\rm max } } ) \\equiv_{k - j } ( [ b_{\\ell}]^r,\\bar b^r_{\\ell},{{\\rm min}},{{\\rm max}})$ ] .    we now show how to define player ii s response in the round @xmath527 .",
    "let us assume without loss of generality that for round @xmath527 of the game on @xmath498 and @xmath499 , player i  picks an element @xmath528 in @xmath367 that belongs to the left interval represented by @xmath529 $ ] ( all the other cases can be treated in a similar way ) .",
    "player ii  response @xmath530 in @xmath368 is defined as follows .",
    "first , there must be an element @xmath484 $ ] in @xmath504 such that @xmath516,\\dots,[p_j],[p_{j+1 } ] ) & \\equiv_{k - j+1 } & \\\\",
    "( \\omega_k({{\\bar{w}}}_2,i'),[q_1],\\dots,[q_j],[s ] ) , \\end{aligned}\\ ] ] where @xmath531 . the latter , together with the way that the strategy is defined , implies that there is an element @xmath358 in @xmath484^l$ ] such that @xmath532^l,\\bar a',a_{j+1},{{\\rm min}},{{\\rm max } } ) \\equiv_{k - j-1 } ( [ s]^l,\\bar b',b,{{\\rm min}},{{\\rm max}})$ ] , where @xmath533 is the subtuple of @xmath520 containing all the elements in @xmath510 that belong to @xmath529^l$ ] and @xmath534 is the corresponding subtuple of @xmath511 .",
    "we then set @xmath535 .",
    "we show by induction that , for each @xmath536 , if @xmath510 and @xmath511 are the first @xmath29 moves played by player i  and player ii  on @xmath498 and @xmath499 , respectively , according to the strategy defined above , then @xmath537 defines a partial isomorphism between @xmath498 and @xmath499 .",
    "this is sufficient to show that @xmath538 .",
    "assume @xmath539 . since @xmath481 , it must be th case that the labels of the last elements of @xmath502 and @xmath504 coincide .",
    "thus , @xmath540^r , i ) \\equiv_0 ( [ i']^r , i')$ ] , and we conclude that @xmath26 and @xmath480 have the same label , and @xmath26 is a call ( resp .",
    "return ) iff @xmath480 is a call ( resp .",
    "further , if @xmath541 then @xmath502 has only one element and that element is labeled @xmath542 , for some @xmath543 . since @xmath544",
    ", @xmath545 also has a single element and that element is labeled @xmath542 .",
    "it follows that @xmath546 .",
    "the converse can be proved analogously . in the same way it is possible to show that @xmath547 iff @xmath548 .",
    "assume that the property holds for @xmath29 .",
    "also , assume without loss of generality that for the round @xmath527 of the game on @xmath498 and @xmath499 , player i  picks an element @xmath528 in @xmath367 that belongs to the right interval represented by @xmath529 $ ] ( all the other cases can be treated in a similar way ) .",
    "we prove that @xmath530 as defined above preserves the partial isomorphism .",
    "first we show that @xmath549 iff @xmath550 . in this case",
    "@xmath529 $ ] is the last element of @xmath502 , and @xmath481 implies that @xmath551 $ ] is the last element of @xmath504 . since @xmath549 is the first element of @xmath529^r$ ] , @xmath530 has to be the first element of @xmath551^r$ ] , which is @xmath480 .    in the same way it is possible to prove that @xmath552 iff @xmath553 , and that @xmath554 iff @xmath555 .",
    "further , it is also clear that the label of @xmath528 in @xmath367 is @xmath39 iff the label of @xmath530 in @xmath368 is @xmath39 , for each @xmath556 .",
    "next we consider the remaining cases .    1 .",
    ". then @xmath532^r,\\bar a',a_{j+1},{{\\rm min}},{{\\rm max } } ) \\equiv_{k - j-1}\\!([b_{j+1}]^r,\\bar b',b_{j+1},{{\\rm min}},{{\\rm max}})$ ] , where @xmath533 is the subtuple of @xmath558 containing all the elements in @xmath510 that belong to @xmath529^l$ ] and @xmath534 is the corresponding subtuple of @xmath511 .",
    "this immediately implies that @xmath559 .",
    "the converse is proved analogously .",
    "2 .   @xmath560 .",
    "this is similar to the previous case .",
    "3 .   suppose first that @xmath561 holds for some @xmath562 $ ] .",
    "since @xmath528 belongs to @xmath529^r$ ] , we have that @xmath563 belongs to @xmath521^r$ ] and , thus , we only need to consider the cases @xmath521 = [ a_{j+1}]$ ] and @xmath529 < [ a_{\\ell}]$ ] . if @xmath521 = [ a_{j+1}]$ ] , then @xmath526^r , a_{\\ell},a_{j+1 } ) \\equiv_{0 } ( [ b_{\\ell}]^r , b_{\\ell},b_{j+1})$ ] and , therefore , @xmath564 also holds .",
    "if @xmath529 < [ a_{\\ell}]$ ] , then @xmath551 < [ b_{\\ell}]$ ] and , thus , @xmath565 holds since @xmath566 and @xmath530 belong to @xmath525^r$ ] and @xmath551^r$ ] , respectively .",
    "+ suppose , on the other hand , that @xmath567 holds for some @xmath517 $ ] .",
    "we need to consider three cases : @xmath521 = [ a_{j+1}]$ ] , @xmath521 < [ a_{j+1}]$ ] and @xmath529 < [ a_{\\ell}]$ ] . if @xmath521 = [ a_{j+1}]$ ] , then @xmath526^r , a_{\\ell},a_{j+1 } ) \\equiv_{0 } ( [ b_{\\ell}]^r , b_{\\ell},b_{j+1})$ ] and , therefore , @xmath568 also holds .",
    "if @xmath529 > [ a_{\\ell}]$ ] , then @xmath563 belongs to @xmath521^l$ ] and @xmath551 < [ b_{\\ell}]$ ] and , thus , @xmath568 holds since @xmath566 belongs to @xmath525^l$ ] while @xmath530 belongs to @xmath551^r$ ] .",
    "finally , if @xmath521 > [ a_{j+1}]$ ] , then @xmath525 > [ b_{j+1}]$ ] and , thus , @xmath568 holds since @xmath530 belongs to @xmath551^r$ ] and every element in @xmath551^r$ ] is bigger than every element in either @xmath525^r$ ] or @xmath525^l$ ] .",
    "+ the converse is proved analogously .",
    "4 .   suppose first that @xmath569 holds for some @xmath562 $ ] .",
    "since @xmath528 belongs to the right interval represented by @xmath529 $ ] , it is the case that @xmath521 $ ] also belongs to @xmath529^r$ ] .",
    "thus , given that @xmath526^r , a_{\\ell},a_{j+1 } ) \\equiv_{0 } ( [ b_{\\ell}]^r , b_{\\ell},b_{j+1})$ ] , we conclude that @xmath570 holds .",
    "+ second , @xmath571 holds for some @xmath517 $ ] .",
    "it is not hard to see that @xmath521 = [ a_{j+1}]$ ] .",
    "we need to consider two cases : if @xmath563 belongs to @xmath529^r$ ] , then @xmath526^r , a_{\\ell},a_{j+1 } ) \\equiv_{0 } ( [ b_{\\ell}]^r , b_{\\ell},b_{j+1})$ ] , and thus , @xmath572 holds . if @xmath563 belongs to @xmath529^l$ ] , then @xmath563 is the first element of @xmath529^l$ ] and @xmath528 is the last element of @xmath529^r$ ] .",
    "thus , since @xmath532^l , a_{\\ell},{{\\rm min } } ) \\equiv_0 ( [ b_{j+1}]^l , b_{\\ell},{{\\rm min}})$ ] , we conclude that @xmath566 is the first element of @xmath551^l$ ] .",
    "further , since @xmath532^r , a_{j+1},{{\\rm max } } ) \\equiv_0 ( [ b_{j+1}]^l , b_{j+1},{{\\rm max}})$ ] , we conclude that @xmath530 is the last element of @xmath551^r$ ] .",
    "therefore , @xmath572 holds .",
    "+ the converse is proved analogously .",
    "this concludes the proof of the lemma .",
    "we now present the proof of theorem [ expcompl - one ] .",
    "we first show that every @xmath573 formula @xmath416 is equivalent to an @xmath56 formula @xmath574 over nested words , that is , for every nested word @xmath27 it is the case that @xmath575 iff @xmath576 .",
    "the translation is standard , and can be done by recursively defining @xmath574 from @xmath416 as shown below .",
    "we use the notation @xmath577}$ ] for the _ relativization _ of @xmath578 to elements in the interval @xmath579 $ ] , that is , @xmath577}$ ] is obtained from @xmath578 by replacing each subformula of the form @xmath580 with @xmath581 and each subformula of the form @xmath582 with @xmath583 .",
    "here is the translation :    @xmath584 @xmath585 @xmath586}\\,\\big ) \\,\\,\\vee\\ , \\\\ & & \\ \\ \\ ( \\exists y \\exists z \\,({{\\mu}}(y , z ) \\,\\wedge\\ , y < x \\,\\wedge\\ , x < z \\,\\wedge\\ , \\\\ & & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\forall u \\forall v ( u < x \\wedge x < v \\wedge { { \\mu}}(u , v ) \\,\\rightarrow\\ , u = y \\vee u <",
    "y ) \\,\\wedge\\ , \\alpha_\\varphi(y)^{[y , x ] } ) ) , \\\\",
    "\\alpha_{{{\\mathcal{r}}}\\varphi}(x ) & \\!\\!\\!:=\\!\\!\\ ! & ( \\neg \\exists y \\exists z \\,({{\\mu}}(y , z ) \\,\\wedge\\ , y < x \\,\\wedge\\ , x < z ) \\,\\wedge\\ , \\forall z \\,(\\neg \\exists u ( z <",
    "u ) \\,\\rightarrow\\ , \\alpha_\\varphi(x)^{[x , z]}\\,\\big ) \\,\\,\\vee\\ , \\\\ & & \\ \\ \\ ( \\exists y \\exists z \\,({{\\mu}}(y , z ) \\,\\wedge\\ , y < x \\,\\wedge\\ , x < z \\,\\wedge\\ , \\\\ & & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\forall u \\forall v ( u < x \\wedge x < v \\wedge { { \\mu}}(u , v ) \\,\\rightarrow\\ , u = y \\vee u <",
    "y ) \\,\\wedge\\ , \\alpha_\\varphi(x)^{[x , z ] } ) ) .",
    "\\end{aligned}\\ ] ]    we now show the other direction , that is , @xmath587 .",
    "we start by proving the result for @xmath56 sentences ( that is , we prove that for every @xmath56 sentence @xmath416 there is an @xmath573 formula @xmath405 , such that @xmath588 iff @xmath589 ) , and then extend it to the case of @xmath56 formulas with one free variable",
    ". let @xmath48 be an fo sentence .",
    "we use induction on the quantifier rank to prove that @xmath48 is equivalent to an @xmath573 formula .",
    "for @xmath590 the property trivially holds , as @xmath48 is a boolean combination of formulas of the form @xmath591 , @xmath592 , @xmath593 , @xmath594 , etc .",
    "all of them can be easily expressed in @xmath573 .",
    "we now prove for @xmath595 assuming that the property holds for @xmath57 .",
    "since every @xmath56 sentence of quantifier rank @xmath596 is a boolean combination of @xmath56 sentences of the form @xmath597 , where @xmath270 is a formula of quantifier rank @xmath57 , we just have to show how to express in @xmath573 a sentence of this form .",
    "let @xmath457 be the set of all rank-@xmath57 types of nested words over alphabet @xmath598 .",
    "we distinguish by @xmath599 the rank-@xmath57 type of the empty nested word . by induction hypothesis",
    ", for each @xmath600 there is an @xmath573 formula @xmath601 such that @xmath602 iff the rank-@xmath57 type of @xmath603 is @xmath60 .",
    "let @xmath604 be the set of all rank-@xmath503 types of words over alphabet @xmath605 .",
    "we first construct , for each @xmath606 , an @xmath573 formula @xmath607 over alphabet @xmath20 such that , @xmath608 for each nested word @xmath27 and position @xmath26 of @xmath27 .",
    "fix @xmath609 . from kamp",
    "s theorem @xcite , there is an ltl formula @xmath610 over alphabet @xmath605 such that a word @xmath611 satisfies @xmath610 evaluated on its last element iff the rank-@xmath503 type of @xmath611 is @xmath612 . by the separation property of ltl",
    ", we can assume that @xmath610 only mentions past modalities @xmath86 and @xmath333 .",
    "moreover , given that @xmath613 , we can also assume that @xmath610 is a boolean combination of formulas of the form either @xmath614 or @xmath615 , where @xmath614 does not mention any temporal modality and @xmath616 is an arbitrary past ltl formula .",
    "thus , since @xmath573 is closed under boolean combinations , to show how to define @xmath607 from @xmath610 , we only need to consider two cases : ( 1 ) @xmath610 is an ltl formula over @xmath459 without temporal modalities , and ( 2 ) @xmath610 is of the form @xmath617 , where @xmath614 is an arbitrary past ltl formula over @xmath605 .",
    "next we consider these two cases .    1 .",
    "assume that @xmath610 is an ltl formula without temporal modalities .",
    "then @xmath607 is defined to be @xmath618 , where @xmath619 is defined recursively as follows . given @xmath620 ,",
    "@xmath621 is defined as follows , where we assume that @xmath622 is the rank-@xmath57 type of any nested word with a single element labeled @xmath39 ( @xmath623 ) : 1 .",
    "if @xmath624 , then @xmath621 is defined as the disjunction of the following formulas : a.   @xmath625 ; b.   @xmath626 ; c.   @xmath627 ; d.   @xmath628 ; e.   @xmath629 ; f.   @xmath630 .",
    "2 .   if @xmath631 then @xmath632 is simply @xmath633 ; and 3 .   if @xmath634 and @xmath635 , then @xmath632 is defined as @xmath636 . + furthermore ,",
    "if @xmath405 and @xmath416 are ltl formulas without temporal modalities , then @xmath637 2 .",
    "assume that @xmath610 is a formula of the form @xmath617 , where @xmath614 is an arbitrary past ltl formula .",
    "then @xmath607 is defined to be @xmath638 , where @xmath639 is defined recursively as follows . given @xmath640 ,",
    "@xmath641 is defined as follows : 1 .",
    "if @xmath642 , then @xmath643 is defined as the disjunction of the following formulas : a.   @xmath644 ; b.   @xmath645 ; c.   @xmath646 ; d.   @xmath647 .",
    "if @xmath648 and @xmath649 , then @xmath643 is defined as @xmath650 ; 3 .   if @xmath543 and @xmath651 , then @xmath643 is defined as @xmath652 ; and 4 .",
    "if @xmath653 then @xmath643 is defined as @xmath654 .",
    "+ furthermore , if @xmath405 and @xmath416 are past ltl formulas , then @xmath655    now , let @xmath597 be an @xmath56 sentence such that the quantifier rank of @xmath270 is @xmath57 . then , from our composition method @xmath270 can be expressed in @xmath573 as the formula @xmath656 , where @xmath657 is the set of all rank-@xmath503 types of words over alphabet @xmath605 that belong to @xmath658 .",
    "thus , @xmath597 can be expressed as the following @xmath573 formula : @xmath659 .",
    "this concludes the proof of the theorem .",
    "finally , from the composition method and the previous proof we see that the equivalence @xmath660 also holds for unary queries over nested words .",
    "in this section we show that both satisfiability and model - checking are decidable in single - exponential - time for @xmath2 , and in polynomial time in the size of the model . here",
    "we assume the model of the procedural program is given as a recursive state machine ( rsm ) @xcite .",
    "( runs of an rsm can naturally be viewed as nested words when matching function calls ( or `` box entries '' ) and returns ( or `` box exits '' ) along the run are paired together . ) in fact we prove this bound for @xmath165 , an fo - complete extension of @xmath2 with all of @xmath661 .",
    "we use automata - theoretic techniques : translating formulae into equivalent automata on nested words .",
    "we then show that the logic based on adding the _ within _ operator to @xmath165 , ( and even just adding _ within _ to @xmath0 ) requires doubly - exponential time for model - checking , but is exponentially more succinct .",
    "a _ nondeterministic  nested word automaton _ ( bnwa ) @xmath143 over an alphabet @xmath20 is a structure @xmath662 consisting of a finite set of states @xmath663 , a set of initial states @xmath664 , a set of  accepting states @xmath665 , a set of hierarchical symbols @xmath153 , a set of initial hierarchical symbols @xmath666 , a set of final hierarchical symbols @xmath667 , a call - transition relation @xmath668 , an internal - transition relation @xmath669 , and a return - transition relation @xmath670 .",
    "the automaton @xmath143 starts in an initial state and reads the nested word from left to right .",
    "the state is propagated along the linear edges as in the case of a standard word automaton . however , at a call , the nested word automaton propagates state along the linear edge as well as a hierarchical symbol along the nesting edge ( if there is no matching return , then the latter is required to be in @xmath671 for acceptance ) . at a matched return , the new state is determined based on the state propagated along the linear edge as well as the symbol along the incoming nesting edge ( edges incident upon unmatched returns are assumed to be labeled with initial hierarchical symbols ) .    formally ,",
    "@xmath357 of the automaton @xmath143 over a nested word @xmath672 is a sequence @xmath673 of states along the linear edges , and a sequence @xmath674 , for every call position @xmath26 , of hierarchical symbols along nesting edges , such that @xmath675 and for each position @xmath26 , if @xmath26 is a call then @xmath676 ; if @xmath26 is internal , then @xmath677 ; if @xmath26 is a return such that @xmath678 , then @xmath679 ; and if @xmath26 is an unmatched return then @xmath680 for some @xmath681 .",
    "the run @xmath357 is accepting if ( 1 ) for all pending calls @xmath26 , @xmath682 , and ( 2 ) the final state @xmath683 if @xmath27 is a finite word of length @xmath684 , and for infinitely many positions @xmath26 , @xmath685 , if @xmath27 is a nested @xmath1-word .",
    "the automaton @xmath143 accepts the nested word @xmath27 if it has an accepting run over @xmath27 .",
    "nested word automata have the same expressiveness as the monadic second order logic over nested words , and the language emptiness problem for them can be decided in polynomial - time  @xcite .",
    "we now show how to build a bnwa accepting the satisfying models of a formula of @xmath165 .",
    "this leads to decision procedures for satisfiability and model checking .",
    "given a formula @xmath416 , we wish to construct a  nested word automaton @xmath686 whose states correspond to sets of subformulas of @xmath416 . intuitively , given a nested word @xmath27 , a run @xmath357 , which is a linear sequence @xmath687 of states and symbols @xmath674",
    "labeling nesting edges from call positions , should be such that each state @xmath688 is precisely the set of formulas that hold at position @xmath55 .",
    "the label @xmath674 is used to remember abstract - next formulas that hold at position @xmath26 and the abstract - previous formulas that hold at matching return . for clarity of presentation , we first focus on formulas with next operators @xmath80 and @xmath81 , and until over summary - down paths .    given a formula @xmath416 , the closure of @xmath416 , denoted by @xmath689 , is the smallest set that satisfies the following properties :    1 .",
    "@xmath689 contains @xmath416 , @xmath6 , @xmath7 , @xmath690 , and @xmath691 ; 2 .   if either @xmath692 , or @xmath693 or @xmath694 is in @xmath689 then @xmath695 ; 3",
    "if @xmath696 , then @xmath697 ; 4 .   if @xmath698 , then @xmath405 , @xmath162 , @xmath699 , and @xmath700 are in @xmath689 ; and 5 .   if @xmath695 and @xmath405 is not of the form @xmath701 ( for any @xmath614 ) , then @xmath702 .",
    "it is straightforward to see that the size of @xmath689 is only linear in the size of @xmath416 .",
    "henceforth , we identify @xmath703 with the formula @xmath405 .",
    "an _ atom _ of @xmath416 is a set @xmath704 that satisfies the following properties :    1 .   for every @xmath695 , @xmath705 iff @xmath706 .",
    "2 .   for every formula @xmath696 , @xmath707 iff ( @xmath708 or @xmath709 ) .",
    "3 .   for every formula @xmath710 ,",
    "@xmath711 iff either @xmath709 or ( @xmath708 and @xmath712 and @xmath713 ) or ( @xmath714 and @xmath715 ) .",
    "4 .   @xmath716 contains exactly one of the elements in the set @xmath717 .",
    "5 .   if @xmath718 for some @xmath405 , then @xmath719 .",
    "these clauses capture local consistency requirements .",
    "in particular , a summary - down until formula @xmath720 holds at a position if either the second argument @xmath162 holds now , or @xmath405 holds now and satisfaction of @xmath720 is propagated along a call , internal , or nesting edge .",
    "a hierarchical - atom of @xmath416 is a set @xmath721 such that if @xmath705 then @xmath722 . a hierarchical - atom contains possible abstract - next obligations to be propagated across nesting edges .    given a formula @xmath416 , we build a nested word automaton @xmath686 as follows .",
    "the alphabet @xmath20 is @xmath723 , where @xmath724 is the set of atomic propositions .",
    "1 .   atoms of @xmath416 are states of @xmath686 ; 2 .",
    "an atom @xmath716 is an initial state iff @xmath725 ; 3 .",
    "hierarchical - atoms of @xmath416 are hierarchical symbols of @xmath686 ; 4 .",
    "all hierarchical symbols are initial ; 5 .   for atoms",
    "@xmath726 and a symbol @xmath727 , @xmath728 is an internal transition of @xmath686 iff ( a ) @xmath729 ; and ( b ) for @xmath730 , @xmath731 iff @xmath732 ; and ( c ) for each @xmath733 , @xmath391 iff @xmath734 .",
    "6 .   for atoms @xmath735 , a hierarchical - atom @xmath736 , and a symbol @xmath727 ,",
    "@xmath737 is a call transition of @xmath686 iff ( a ) @xmath719 ; and ( b ) for @xmath730 , @xmath731 iff @xmath732 ; and ( c ) for each @xmath733 , @xmath738 iff @xmath734 ; and ( d ) for each @xmath722 , @xmath739 iff @xmath718 .",
    "7 .   for atoms",
    "@xmath740 , hierarchical - atom @xmath736 , and a symbol @xmath727 , @xmath741 is a return transition of @xmath686 iff ( a ) @xmath742 ; and ( b ) for @xmath730 , @xmath731 iff @xmath743 ; and ( c ) for each @xmath733 , @xmath391 iff @xmath744 ; and ( d ) for each @xmath722 , @xmath745 iff @xmath746 .",
    "the transition relation ensures that the current symbol is consistent with the atomic propositions in the current state , and next operators requirements are correctly propagated .",
    "the sole final hierarchical symbol is the empty hierarchical - atom .",
    "this ensures that , in an accepting run , at a pending call , no requirements are propagated along the nesting edge . for each until - formula @xmath405 in the closure , let @xmath747 be the set of atoms that either do not contain @xmath405 or contain the second argument of @xmath405 .",
    "then a nested word @xmath27 over the alphabet @xmath723 satisfies @xmath416 iff there is a run @xmath357 of @xmath686 over @xmath27 such that all pending call edges are labeled with the sole final hierarchical symbol , and for each until - formula @xmath748 , for infinitely many positions @xmath26 , @xmath749 .",
    "this multi-  accepting condition can be translated to  acceptance as usual by adding a counter .",
    "now we proceed to show how to handle various forms of until operators . in each case",
    ", we specify the changes needed to the definition of the closure and local consistency requirements for atoms .    1 .   -10 pt**global paths:**if @xmath750 , then @xmath405 , @xmath162 , @xmath751 are in @xmath689 .",
    "local consistency of @xmath716 requires that for every formula @xmath752 , @xmath753 iff either @xmath709 or ( @xmath708 and @xmath754 ) .",
    "2 .   -10 pt**summary - up paths:**if @xmath755 , then @xmath405 , @xmath162 , @xmath756 , and @xmath757 are in @xmath689 .",
    "local consistency of @xmath716 requires that for every formula @xmath758 , @xmath759 iff either @xmath709 , or ( @xmath708 and @xmath719 and @xmath760 ) , or ( @xmath708 and @xmath761 and @xmath762 ) .",
    "-10 pt**abstract paths:**if @xmath763 , then @xmath405 , @xmath162 , @xmath764 , @xmath765 , and @xmath766 are in @xmath689 . local consistency of @xmath716 requires that for every formula @xmath767 , @xmath768 iff either @xmath709 , or ( @xmath708 and @xmath719 and @xmath769 ) , or ( @xmath708 and @xmath761 and @xmath712 and @xmath770 ) , or ( @xmath714 and @xmath771 and @xmath772 and @xmath770 ) .",
    "the last case accounts for propagation of the eventuality across unmatched returns .",
    "4 .   -10 pt**call paths:**recall that positions along a call path are related by the innermost call operator : a call path jumps from a call position @xmath26 to a position @xmath29 such that @xmath773 .",
    "thus , a call path can be simulated by a summary - down path consisting of call edges , summary edges and internal edges , where the formula is asserted only before following the call edge .",
    "this effect is captured by using an auxiliary operator as follows .",
    "if @xmath774 , then @xmath405 , @xmath162 , @xmath775 , @xmath776 , and @xmath777 are in @xmath689 .",
    "local consistency of @xmath716 requires that for every formula @xmath778 , @xmath779 iff either @xmath709 or ( @xmath708 and @xmath780 and @xmath781 ) ; and @xmath782 iff either @xmath783 , or @xmath784 , or ( @xmath712 and @xmath781 ) .",
    "5 .   -10 pt**summary paths : * *",
    "the summary - until is handled using the fact that @xmath785 is equivalent to @xmath786 .",
    "note that the definition of @xmath686 stays unchanged , as the correct propagation of requirements is handled by next and abstract - next formulas ensured by local consistency .",
    "the eventual satisfaction of until formulas is handled the same way as before : for each until - formula @xmath405 in the closure , let @xmath747 be the set of atoms that either do not contain @xmath405 or contain the second argument of @xmath405 , and it is required that each such @xmath747 is visited infinitely often .",
    "the past - time formulas ( previous , abstract - previous , and various forms of since operators ) are handled in a symmetric manner .",
    "thus , we have shown :    [ exp - buchi ] for a formula @xmath416 of @xmath165 , one can effectively construct a nondeterministic  nested word automaton @xmath686 of size @xmath787 accepting the models of @xmath416 .    since the automaton @xmath686 is exponential in the size of @xmath416 , we can check satisfiability of @xmath416 in exponential - time by testing emptiness of @xmath686 .",
    "exptime - hardness follows from the corresponding hardness result for @xmath0 .",
    "the satisfiability problem for @xmath165 is exptime - complete .",
    "when programs are modeled by nested word automata @xmath143 ( or equivalently , pushdown automata , or recursive state machines ) , and specifications are given by formulas @xmath416 of @xmath165 , we can use the classical automata - theoretic approach : negate the specification , build the nwa @xmath788 accepting models that violate @xmath416 , take the product with the program @xmath143 , and test for emptiness of @xmath789 . note",
    "that the program typically will be given more compactly , say , as a boolean program  @xcite , and thus , the nwa @xmath143 may itself be exponential in the size of the input .",
    "model checking @xmath165 specifications with respect to boolean programs is exptime - complete .",
    "if the program model is given as a recursive state machine or nested word automaton , the running time is polynomial in the model and exponential in the @xmath165 formula , and remains exptime - complete .",
    "we now show that adding _ within _ operators makes model - checking doubly exponential . given a formula @xmath416 of @xmath2 or @xmath165 ,",
    "let @xmath790 be a special proposition that does not appear in @xmath416 .",
    "let @xmath791 be the language of nested words @xmath27 such that for each position @xmath26 , @xmath792 iff @xmath793 .",
    "we construct a doubly - exponential automaton @xmath150 that captures @xmath791 .",
    "first , using the tableau construction for @xmath165 , we construct an exponential - size automaton @xmath143 that captures nested words that satisfy @xmath416 .",
    "intuitively , every time a proposition @xmath790 is encountered , we want to start a new copy of @xmath143 , and a state of @xmath150 keeps track of states of multiple copies of @xmath143 . at a call , @xmath150 guesses whether the call has a matching return or not . in the latter case , as in case of determinization construction for nested word automata  @xcite , we need to maintain pairs of states of @xmath143 so that the join at return positions can be done correctly .",
    "a state of @xmath150 , then , is either a set of states of @xmath143 or a set of pairs of states of @xmath143 .",
    "we explain the latter case .",
    "the intended meaning is that a pair @xmath794 belongs to the state of @xmath150 , while reading position @xmath26 of a nested word @xmath27 , if the subword from @xmath26 to the first unmatched return can take the automaton @xmath143 from state @xmath145 to state @xmath795 .",
    "when reading an internal symbol @xmath39 , a summary @xmath794 in the current state can be updated to @xmath796 , provided @xmath143 has an internal transition from @xmath145 to @xmath611 on symbol @xmath39 .",
    "let @xmath150 read a call symbol @xmath39 .",
    "consider a summary @xmath794 in the current state , and a call - transition @xmath797 of @xmath143 .",
    "then @xmath150 guesses the return transition @xmath798 that will be used by @xmath143 at the matching return , and sends the summary @xmath799 along the call edge and the triple @xmath800 along the nesting edge . while processing a return symbol @xmath358 ,",
    "the current state of @xmath150 must contain summaries only of the form @xmath801 where the two states match , and for each summary @xmath800 retrieved from the state along the nesting edge , the new state contains @xmath796 .",
    "finally , @xmath150 must enforce that @xmath802 holds when @xmath790 is read .",
    "only a call symbol @xmath39 can contain the proposition @xmath790 , and when reading such a symbol , @xmath150 guesses a call transition @xmath803 , where @xmath804 is the initial state of @xmath143 , and a return transition @xmath805 , where @xmath806 is an accepting state of @xmath143 , and sends the summary @xmath799 along the call edge and the symbol @xmath358 along the nesting edge .    for every formula @xmath416 of @xmath165",
    ", there is a nested word automaton that accepts the language @xmath791 and has size doubly - exponential in @xmath807 .",
    "consider a formula @xmath416 of @xmath808 .",
    "for every within - subformula @xmath809 of @xmath416 , let @xmath810 be obtained from @xmath811 by substituting each top - level subformula @xmath812 in @xmath811 by the proposition @xmath813 .",
    "each of these primed formulas is a formula of @xmath165 .",
    "then , if we take the product of the nested word automata accepting @xmath814 corresponding to all the within - subformulas @xmath811 , together with the nested word automaton @xmath815 , the resulting language captures the set of models of @xmath416 .",
    "intuitively , the automaton for @xmath814 is ensuring that the truth of the proposition @xmath816 reflects the truth of the subformula @xmath809 .",
    "if @xmath811 itself has a within - subformula @xmath812 , then the automaton for @xmath811 treats it as an atomic proposition @xmath813 , and the automaton checking @xmath813 , running in parallel , makes sure that the truth of @xmath813 correctly reflects the truth of @xmath812 .    for the lower bound",
    ", the decision problem for ltl games can be reduced to the satisfiability problem for formulas with linear untils and within operators  @xcite , and this shows that for @xmath0 extended with the within operator , the satisfiability problem is 2exptime - hard .",
    "we thus obtain :    for the logic @xmath165 extended with the within operator @xmath155 the satisfiability problem and the model checking problem with respect to boolean programs , are both 2exptime - complete .    [ [ remark - checking - barwmodelsvarphi - for - finite - nested - words ] ] remark : checking @xmath817 for finite nested words + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for finite nested words , one evaluates the complexity of checking whether the given word satisfies a formula , in terms of the length @xmath818 of the word and the size of the formula .",
    "a straightforward recursion on subformulas shows that for @xmath2 formulas the complexity of this check is @xmath819 , and for both logics with _ within _ operators , @xmath444 and @xmath412 , it is @xmath820 .",
    "we saw that adding within operators to @xmath165 increases the complexity of model - checking by one exponent .",
    "thus there is no polynomial - time translation from @xmath821 to @xmath165 .",
    "we now prove a stronger result that gives a space bound as well : while @xmath808 has the same power as @xmath165 , its formulae can be exponentially more succinct than formulas of @xmath165 . that is , there is a sequence @xmath822 , @xmath823 , of @xmath808 formulas such that @xmath822 is of size @xmath824 , and the smallest formula of @xmath165 equivalent to @xmath822 is of size @xmath825 . for this result",
    ", we require nested @xmath1-words to be over the alphabet @xmath826 .",
    "[ succinct - theo ] @xmath821 is exponentially more succinct than @xmath165 .",
    "_ proof_. the proof is based upon succinctness results in @xcite , by adapting their examples to nested words .    from the fo completeness of @xmath165 ,",
    "we have that @xmath821 can be translated into @xmath165 .",
    "we show that at least an exponential blow - up is necessary for such translation .",
    "more precisely , we construct a sequence @xmath827 of @xmath821 formulas of size @xmath824 , such that the shortest @xmath165 formula that is equivalent to @xmath822 is of size @xmath825 .",
    "our proof is a modification of similar proofs given in @xcite .",
    "assume @xmath828 , and let @xmath822 be the following @xmath821 formula ( here , @xmath829 and @xmath830 are abbreviations for @xmath831 and @xmath832 , respectively ) : @xmath833 it is not hard to see that @xmath834 iff for all positions @xmath40 in @xmath27 such that @xmath8 holds , if position @xmath684 in @xmath41 $ ] coincides with @xmath26 on @xmath835 , then @xmath684 also coincides with @xmath26 on @xmath460 .",
    "it is shown in theorem [ exp - buchi ] that for each @xmath165 formula @xmath364 , the language @xmath836 is recognized by a nondeterministic nested word automaton of size @xmath837 .",
    "thus , to prove the theorem , it is enough to show that every such automaton for @xmath838 is of size @xmath839 .",
    "let @xmath143 be a nondeterministic nested word automaton for @xmath838 .",
    "assume that @xmath840 is an enumeration of the symbols in @xmath841 .",
    "for every @xmath842 let @xmath843 be the word @xmath844 over alphabet @xmath845 , where for each @xmath846 : @xmath847 it is not hard to see that for each @xmath848 , the nested @xmath1-word @xmath849 , where @xmath850 , is such that @xmath851 . let @xmath852 and @xmath853 be pairs of states such that ( 1 ) there exists an accepting run of @xmath143 on @xmath849 such that @xmath143 is in state @xmath854 and has hierarchical symbol @xmath855 in call position @xmath856 , and @xmath143 is in state @xmath857 in internal position @xmath858 ; ( 2 ) there exists an accepting run of @xmath143 on @xmath859 such that @xmath143 is in state @xmath860 and has hierarchical symbol @xmath861 in call position @xmath856 , and @xmath143 is in state @xmath862 in internal position @xmath858 . next we show that @xmath863 if @xmath864 . on the contrary , assume that @xmath865 . then @xmath143 accepts @xmath866 , which leads to a contradiction since @xmath867 .",
    "given that the number of different @xmath868 s is @xmath869 , the latter implies that the number of different triples of states and hierarchical symbols of @xmath143 is at least @xmath869 .",
    "thus , if @xmath69 is equal to the number of states of @xmath143 plus the number of hierarchical symbols of @xmath143 , then @xmath870 and , hence , @xmath871 . therefore , the size of @xmath143 is @xmath839 .",
    "this concludes the proof of the theorem .",
    "we have already seen that fo  formulas in one free variable over nested words can be written using just three distinct variables , as in the case of the usual , unnested , words . for finite nested words",
    "this is a consequence of a tree representation of nested words and the three - variable property for fo  over finite trees @xcite , and for infinite nested words this is a consequence theorem [ nwtl - thm ] .    in this section",
    "we prove two results .",
    "first , we give a model - theoretic proof that fo  formulas with zero , one , or two free variables over nested words ( finite or infinite ) are equivalent to @xmath347 formulas .",
    "given the @xmath872 collapse , we ask whether there is a temporal logic expressively complete for @xmath873 , the two - variable fragment .",
    "we adapt techniques from @xcite to find a temporal logic that has the same expressiveness as @xmath873 over nested words ( in a vocabulary that has successor relations corresponding to the `` next '' temporal operators ) .",
    "we give a model - theoretic , rather than a syntactic , argument , that uses ehrenfeucht - frass games and shows that over nested words , formulas with at most two free variables are equivalent to @xmath347 formulas .",
    "note that for finite nested words , the translation into trees , already used in the proof of theorem [ nwtl - thm ] , can be done using at most three variables .",
    "this means that the result of @xcite establishing the 3-variable property for finite ordered unranked trees gives us the 3-variable property for finite nested words .",
    "we prove that @xmath872 over arbitrary nested words .",
    "[ 3var th ] over finite or infinite nested words , every fo  formula with at most @xmath874 free variables is equivalent to an @xmath347 formula .",
    "_ proof_. as we mentioned already , in the finite case this is a direct consequence of @xcite so we concentrate on the infinite case .",
    "it is more convenient for us to prove the result for ordered unranked forests in which a subtree rooted at every node is finite .",
    "the way to translate a nested @xmath1-word into such a forest is as follows : when a matched call @xmath26 with @xmath8 is encountered , it defines a subtree with @xmath26 as its root , and @xmath527 as the next sibling ( note that this is different from the translation into binary trees we used before ) .",
    "if @xmath26 is an internal position , or a pending call or a pending return position , then it has no descendants and its next sibling is @xmath55 .",
    "matched returns do not have next sibling , nor do they have any descendants .",
    "the nodes in the forest are labeled with @xmath6 , @xmath7 , and the propositions in @xmath20 , as in the original nested word .",
    "it is routine to define , in fo , relations @xmath875 and @xmath876 for descendant and younger sibling in such a forest .",
    "furthermore , from these relations , we can define the usual @xmath877 and @xmath5 in nested words using at most @xmath406 variables as follows . for @xmath878 ,",
    "the definition is given by @xmath879 and for @xmath880 , by @xmath881 thus , it suffices to prove the three - variable property for such ordered forests , which will be referred to as @xmath882 , @xmath883 , etc .",
    "we shall use pebble games .",
    "let @xmath884 be the @xmath69-move , @xmath885-pebble game on structures @xmath882 and @xmath883 where initially pebbles @xmath886 are placed on @xmath887 in @xmath882 and @xmath888 in @xmath883 .",
    "player ii  has a winning strategy for @xmath889 iff @xmath890 and @xmath891 agree on all formulas with at most @xmath885 variables and quantifier - depth @xmath69 .",
    "we know from @xcite that to prove theorem [ 3var th ] , it suffices to show the following ,    for all @xmath57 , if player ii  has a winning strategy for the game @xmath892 @xmath893 , then she also has a winning strategy for the game @xmath894",
    ".    we will show how player ii  can win the @xmath57-pebble game by maintaining a set of 3-pebble sub - games on which she will copy player i s moves and decide on good responses using her winning strategy for these smaller 3-pebble games .",
    "the choice of these sub - games will partition the universe @xmath895 so that each play by player i  in the @xmath57-pebble game will be answered in one @xmath406-pebble game .",
    "this is similar to the proof that linear orderings have the 3-variable property @xcite .",
    "the subgames , @xmath896 , that player iimaintains will all be _ vertical _ in which @xmath897 and @xmath898 hold , or _",
    "horizontal _ in which @xmath899 and @xmath900 hold .",
    "the following lemma gives the beginning strategy of player ii  in which she replaces an arbitrary game configuration with a set of configurations each of which is vertical or horizontal .",
    "[ rajeev le ] if player ii  wins @xmath901 .",
    "then there are points @xmath902 from @xmath882 and @xmath903 from @xmath883 such that player ii  wins the horizontal game @xmath904 and the vertical games @xmath905 for @xmath906 .    for this proof since @xmath882 and @xmath883 are fixed , we will describe a game only by listing the chosen points , e.g. , @xmath907 .",
    "we simulate two moves of the game , @xmath908 , in which we choose player i s moves and then player ii  answers according to her winning strategy .",
    "let @xmath909 denote the least common ancestor of @xmath611 and @xmath885 .",
    "first , we have player i  place pebble @xmath910 on @xmath911 , the unique child of @xmath912 that is an ancestor of @xmath913 .",
    "( note that if @xmath914 then this move can be skipped and similarly for the second move if @xmath915 . )",
    "player ii  answers by placing @xmath910 on some point @xmath916 .",
    "second , player i  should move pebble @xmath917 from @xmath913 to @xmath918 , the unique child of @xmath912 that is an ancestor of @xmath919 . player ii  moves @xmath917 to some point @xmath920 .    since player",
    "ii  has moved according to her winning strategy , we have that she still has a winning strategy for the three games in the statement of the lemma .",
    "furthermore , since @xmath911 and @xmath918 are siblings and we have two remaining moves , @xmath916 and @xmath920 must be siblings as well .",
    "using lemma [ rajeev le ] we initially partition the universe according to four subgames :    1 .",
    "@xmath921 with domain everything not below @xmath922 or @xmath923 . here",
    "@xmath924 , i.e. , the parent of @xmath911 , @xmath925 , i.e. , the parent of @xmath916 and @xmath926 and @xmath927 are the roots of @xmath882 and @xmath883 , ( the roots are not necessary but then the subgames are all on horizontal or vertical pairs ) , or 2 .",
    "@xmath928 with domain everything below @xmath911 or @xmath916 , 3 .",
    "@xmath929 , with domain everything below @xmath918 or @xmath920 , 4 .",
    "@xmath930 , with the remaining domain .",
    "we now have to explain , inductively , how all moves of player i  in the @xmath57-pebble game are answered by player ii  and how , in the process , the universe is further partitioned .",
    "we inductively assume that player iihas a winning strategy for each of the 3-pebble , m - move sub - games .",
    "there are two cases :    * vertical : * player i  places a new pebble on a point @xmath39 that is in the domain of a vertical game : @xmath907 .",
    "we thus know that @xmath913 is a proper ancestor of @xmath39 .",
    "the interesting case is where neither of @xmath39 and @xmath919 is above the other so , without loss of generality , assume that @xmath931 .",
    "we place @xmath910 on @xmath918 , the child of @xmath932 that is above @xmath919 .",
    "let player ii move according to her winning strategy , placing @xmath910 on some point @xmath920 .",
    "we split the original game into @xmath933 and @xmath934 so player ii  has a winning strategy for these 3-pebble , @xmath935 move sub - games .",
    "next , in the @xmath933 game we place @xmath910 on @xmath922 , the parent of @xmath918 and we let player ii  answer according to her winning strategy , placing @xmath910 on some point , @xmath923 .",
    "we then split off the game @xmath936 .",
    "returning to the game @xmath933 , we have player i  place @xmath910 on @xmath937 , the sibling of @xmath918 above @xmath39 , and let player ii  answer according to her winning strategy , placing @xmath910 on some point , @xmath938 .    finally , we let player i  move @xmath917 to @xmath39 , and let player ii  reply with @xmath917 on some point @xmath358 .    the sub - games are thus :",
    "@xmath936 , @xmath939 , @xmath940 , and @xmath934 and player ii  has winning strategies for the @xmath941 game on all of them .",
    "* horizontal : * in this case , we have the configuration , @xmath907 , consisting of a pair of siblings .",
    "the only interesting case occurs when player i  puts a new pebble on some vertex , @xmath39 , s.t .",
    "@xmath942 . in this case",
    ", we have player i  place pebble @xmath910 on @xmath937 , the sibling of @xmath913 above @xmath39 .",
    "player ii  will place pebble @xmath910 on some vertex , @xmath938 , which must be a sibling of @xmath943 and @xmath944 .",
    "next , in the game below @xmath937 and @xmath938 , we let player i  place pebble @xmath945 on @xmath39 and we let player ii  answer according to her winning strategy in this game , placing @xmath945 on some vertex , @xmath358 .",
    "the domain of the original configuration is thus split into domains for three sub - games : @xmath946 , @xmath947 , and @xmath948 . on each of these , player ii  has a winning strategy for the 3-pebble , @xmath949 move game .",
    "we now complete the proof that player ii  wins @xmath950 .",
    "whenever player i  places a new pebble on some point , say @xmath39 , in the original game , player ii  will answer as described above , i.e. , in one of the little games we will have player ii  wins @xmath951 where there are @xmath357 moves remaining in the big game .",
    "player ii  then answers in the big game by placing the corresponding pebble on @xmath358 . to see that the resulting moves are a win for player ii",
    ", we must just consider any two pebbled points , @xmath952 , and @xmath953 . if they came from the same sub - game",
    ", then they agree on relations @xmath954 because player ii  wins the sub - game .",
    "otherwise , @xmath955 came from one sub - game , @xmath956 , and @xmath957 came from another sub - game , @xmath958 . by our choice of the domains and transitivity of @xmath954 , it thus follows that @xmath959 stand in the same relation with respect to @xmath954 as @xmath960 do .      in this section",
    ", we construct a temporal logic that captures the two - variable fragment of fo  over nested words .",
    "note that for finite unranked trees , a navigational logic capturing @xmath873 is known @xcite : it corresponds to a fragment of xpath .",
    "however , translating the basic predicates over trees into the vocabulary of nested words requires @xmath406 variables , and thus we can not apply existing results even in the finite case .    our temporal logic will be based on several next and eventually operators . since @xmath873 over a linear ordering can not define the successor relation but temporal logics have next operators , we explicitly introduce successors into the vocabulary of @xmath56 .",
    "these successor relations in effect partition the linear edges into three disjoint types ; _ interior _ edges , _ call _ edges , and _ return _ edges , and the nesting edges ( except those from a position to its linear successor ) into two disjoint types ; _ call - return _ summaries , and _ call - interior - return _ summaries .    1 .",
    "@xmath961 holds iff @xmath962 and either @xmath8 or @xmath26 is not a call and @xmath29 is not a return .",
    "2 .   @xmath963 holds iff @xmath26 is a call and @xmath962 is not a return ; 3 .",
    "@xmath964 holds iff @xmath26 is not a call and @xmath962 is a return .",
    "4 .   @xmath965 holds iff @xmath8 and there is a path from @xmath26 to @xmath29 using only call and return edges .",
    "@xmath966 holds iff @xmath8 and neither @xmath962 nor @xmath965 .",
    "let @xmath967 denote the set @xmath968 of all edge types .",
    "in addition to the built - in predicates @xmath969 for @xmath970 , we add the _ transitive closure _ of all unions of subsets of these relations .",
    "that is , for each non - empty set @xmath971 of edge types , let @xmath972 stand for the union @xmath973 , and let @xmath974 be the reflexive - transitive closure of @xmath972 .",
    "now when we refer to @xmath873 over nested words , we mean @xmath873 in the vocabulary of the unary predicates plus all the @xmath974 s , the five successor relations , and the built - in unary @xmath6 and @xmath7 predicates .",
    "we define a temporal logic @xmath975 that has future and past versions of next operators parameterized by edge types , and eventually operators parameterized by a set of edge types . for example , @xmath976 means eventually along a path containing only call edges .",
    "its formulas are given by : @xmath977 where @xmath39 ranges over @xmath20 , @xmath978 ranges over @xmath967 , and @xmath457 ranges over non - empty subsets of @xmath967 .",
    "the semantics is defined in the obvious way .",
    "for example , @xmath979 iff for some position @xmath29 , @xmath980 and @xmath981 ; @xmath982 iff for some position @xmath29 , @xmath983 and @xmath984 ; and @xmath985 iff @xmath9 holds in @xmath27 .",
    "for an @xmath873 formula @xmath270 with one free variable @xmath179 , let @xmath986 be its quantifier depth , and for a @xmath975 formula @xmath987 , let @xmath988 be its operator depth .",
    "[ translation theorem ]    1 .",
    "@xmath975 is expressively complete for @xmath873 over nested words .",
    "if formulas are viewed as dags ( i.e identical subformulas are shared ) , then every @xmath873 formula @xmath270 can be converted to an equivalent @xmath975 formula @xmath987 of size @xmath989 and @xmath990 .",
    "the translation is computable in time polynomial in the size of @xmath987 .",
    "model checking of @xmath975 can be carried out with the same worst case complexity as for nwtl .",
    "_ proof_. the translation from @xmath975 into @xmath873 is standard and can be done with negligible blow - up in the size of the formula , so we concentrate on the other direction .",
    "the proof generalizes the proof of an analogous result for unary temporal logic over words from @xcite .",
    "given an @xmath991 formula @xmath270 the translation procedure works a follows .",
    "when @xmath270 is atomic , i.e. , of the form @xmath992 , it outputs @xmath39 .",
    "when @xmath270 is of the form @xmath993 or @xmath692we say that @xmath270 is _",
    "composite_it recursively computes @xmath994 and @xmath995 , or @xmath162 and outputs @xmath996 or @xmath997 .",
    "the two cases that remain are when @xmath270 is of the form @xmath998 or @xmath999 . in both cases ,",
    "we say that @xmath270 is _ existential_. in the first case , @xmath270 is equivalent to @xmath1000 and , viewing @xmath179 as a dummy free variable in @xmath1001 , this reduces to the second case .    in the second case , we can rewrite @xmath1002 in the form @xmath1003 where @xmath363 is a propositional formula , each formula @xmath1004 is an atomic order formula , each formula @xmath1005 is an atomic or existential @xmath991 formula with @xmath1006 , and each formula @xmath1007 is an atomic or existential @xmath991 formula with @xmath1008 .    in order to be able to recurse on subformulas of @xmath48 we have to separate the @xmath1005 s from the @xmath1007 s .",
    "we first introduce a case distinction on which of the subformulas @xmath1005 hold or not .",
    "we obtain the following equivalent formulation for @xmath48 : @xmath1009 we proceed by a case distinction on which order relation holds between @xmath179 and @xmath183 , where @xmath878 .",
    "we consider mutually exclusive cases , determined by the following formulas , which we call _ order types_.    1 .",
    "@xmath1010 is @xmath1011 .",
    "2 .   for each @xmath970",
    ", @xmath1012 is @xmath1013 .",
    "3 .   for each @xmath970",
    ", @xmath1014 is @xmath1015 .",
    "4 .   let @xmath1016 be a sequence over @xmath967 such that @xmath1017 , all @xmath1018 s are distinct , and a call never appears before return ( that is , if @xmath1019 then @xmath1020 for @xmath1021 .",
    "then @xmath1022 stands for @xmath1023where for @xmath1024 , the set @xmath1025 equals the set @xmath1026 , but with @xmath357 removed if both @xmath1027 and @xmath357 belong to this set .",
    "we claim that these order types are mutually exclusive and complete , and are expressible in @xmath975 ( and hence , in @xmath873 ) . first , let us show that the order types form a disjoint partition , meaning for all pairs @xmath1028 such that @xmath878 , we have exactly one of these relationships holding true . to see this ,",
    "suppose @xmath1029 .",
    "then either @xmath1030 holds for some type @xmath978 ( and the successor relations @xmath969 are disjoint , for distinct @xmath978 s ) , or there is a path from @xmath179 to @xmath183 that uses at least two edges .",
    "the key observation is that a path from @xmath179 to @xmath183 is a summary path iff the path does not contain a call edge followed later by a return edge .",
    "also , there is a unique summary path from @xmath179 to @xmath183 .",
    "we can now classify the paths by the edge types that this unique summary path contains , and the order in which they first appear in the path .",
    "for example , @xmath1031 holds when there is a path from @xmath179 to @xmath183 using 2 or more call edges ; @xmath1032 holds when there is a path from @xmath179 to @xmath183 which begins with a call edge , uses at least one call - interior - return summary edge , and uses only these two types of edges ; @xmath1033 holds when there is a path from @xmath179 to @xmath183 that can be split into three consecutive parts : a part containing only return edges , a part containing at least one internal and only internal and return edges , and a part containing at least one call and only call and internal edges . note that some of these order types are empty :",
    "for example , two summary edges can never follow one another , and hence @xmath1034 can never hold .",
    "emptiness of some of the order types is not relevant to the proof .",
    "when we assume that one of these order types is true , each atomic order formula evaluates to either @xmath1035 or @xmath1036 , in particular , each of the @xmath1004 s evaluates to either @xmath1035 or @xmath1036 ; we will denote this truth value by @xmath1037 .",
    "for example , when @xmath1038 holds then ( 1 ) @xmath1030 is true for @xmath1039 and false for @xmath1040 , and ( 2 ) @xmath1041 is true if @xmath457 contains @xmath1042 or if @xmath457 contains both @xmath1027 and @xmath357 , and false otherwise .",
    "we can finally rewrite @xmath48 as follows , where @xmath1043 stands for the set of all order types : @xmath1044 if @xmath60 is an order type , @xmath161 an @xmath991 formula , and @xmath162 an equivalent @xmath1045 formula , there is a way to obtain a @xmath1045 formula @xmath1046 equivalent to @xmath1047 , as follows .",
    "assume that @xmath878 .    1 .   for the order type @xmath1010 , @xmath1048 is @xmath162 itself .",
    "2 .   for each @xmath970 ,",
    "for the order type @xmath1012 , @xmath1048 is @xmath1049 .",
    "3 .   for each @xmath970",
    ", for the order type @xmath1014 , @xmath1048 is @xmath1050 .",
    "4 .   for order type",
    "@xmath1022 , where @xmath1016 is a sequence over @xmath967 , @xmath1048 is @xmath1051 @xmath1052 , where for @xmath1053 , the set @xmath1025 equals the set @xmath1026 , but with @xmath357 removed if both @xmath1027 and @xmath357 belong to this set .",
    "the case corresponding to past operators is analogous .",
    "our procedure will therefore recursively compute @xmath1054 for @xmath1055 and @xmath1056 for @xmath1057 and output    @xmath1058    now we verify that @xmath1059 and @xmath988 are bounded as stated in the theorem .",
    "note that the size @xmath1059 is measured by viewing the @xmath975 formula as a dag , i.e. , sharing identical subformulas . that @xmath1060 is easily seen from the operator depth in the translation table above .",
    "the proof that @xmath1061 for some constant @xmath1027 is inductive on the quantifier depth of @xmath48 .",
    "the base case is trivial , and the only interesting case in the inductive step is when @xmath48 is of the form @xmath1062 as above . in this case , we have to estimate the length of ( [ eq : translation ] ) .",
    "there are @xmath1063 possibilities for @xmath1064 in ( [ eq : translation ] ) , and each disjunct in ( [ eq : translation ] ) has length at most @xmath1065 for some constant @xmath1066 . by induction hypothesis , the latter is bounded by @xmath1067 , which implies the claim , provided @xmath1027 is chosen large enough .",
    "it is straightforward to verify that our translation to @xmath987 can be computed in time polynomial in @xmath1059 .",
    "model checking of @xmath975 can be achieved with the same complexity as for nwtl using a variant of the tableaux construction in section [ mc - sec ] .",
    "we have provided several new temporal logics over nested words and shown that they are first - order expressively complete .",
    "we have furthermore shown that first - order logic over nested words has the three - variable property , and we have also provided a temporal logic over nested words that is complete for two - variable first - order logic . we have shown , via an automata - theoretic approach based on nested word automata , that satisfiability for the logic @xmath165 is exptime - complete , and that model checking runs in time polynomial in the size of the rsm model and exponential in the size of the formula . when the within modality is added to @xmath2 ,",
    "the complexity of model checking becomes doubly exponential .",
    "we note that it remains open whether the original temporal logic , proposed for nested words in @xcite , is first - order complete , but we conjecture that it is not .",
    "the authors were supported by : alur  nsf cpa award 0541149 ; arenas  grants 1050701 , 7060172 and 1070732 ; arenas and barcel  grant p04 - 067-f from the millennium nucleus centre for web research ; immerman  nsf grants ccf-0541018 and ccf-0830174 ; libkin  ec grant mexc - ct-2005 - 024502 and epsrc grant e005039 .    99    r.  alur , m.  benedikt , k.  etessami , p.  godefroid , t.  reps , m.  yannakakis .",
    "analysis of recursive state machines .",
    "27(4 ) : 786818 ( 2005 ) .",
    "r. alur , k. etessami and p. madhusudan . a temporal logic of nested calls and returns . in _",
    "tacas04 _ , pages 467481 .",
    "r. alur and p. madhusudan .",
    "visibly pushdown languages . in _ stoc04 _ , pages 202211 .",
    "r. alur and p. madhusudan .",
    "adding nesting structure to words . in _ dlt06 _ ,",
    "pages 113 .",
    "t. ball and s. rajamani .",
    "bebop : a symbolic model checker for boolean programs . in _",
    "spin00 _ , pages 113130 .",
    "v.  brny , c.  lding , o.  serre .",
    "regularity problems for visibly pushdown languages . , pages 420431 .",
    "document object model dom . .",
    "j. esparza and s. schwoon . a bdd - based model checker for recursive programs . in _",
    "pages 324336 .",
    "k. etessami , m. vardi , and t. wilke .",
    "first - order logic with two variables and unary temporal logic .",
    "179(2 ) : 279295 , 2002 .",
    "m.  frick , m.  grohe .",
    "the complexity of first - order and monadic second - order logic revisited .",
    ", 215224 .",
    "g.  gottlob , c.  koch .",
    "monadic datalog and the expressive power of languages for web information extraction .",
    "51 ( 2004 ) , 74113 .",
    "n.  immerman . .",
    "springer , 1999 .",
    "n. immerman and d. kozen .",
    "definability with bounded number of bound variables .",
    "83 ( 1989 ) , 121 - 139 .",
    "h.  kamp .",
    "tense logic and the theory of linear order .",
    "phd thesis , ucla , 1968 .",
    "n.  klarlund , t.  schwentick and d.  suciu .",
    "xml : model , schemas , types , logics , and queries . in _",
    "logics for emerging applications of databases _ , springer , 2003 , pages 141 .",
    "l.  libkin .",
    "logics for unranked trees : an overview . in _",
    "icalp 2005 _ , pages 35 - 50 .    c.  lding , p.  madhusudan , o.  serre .",
    "visibly pushdown games . in _",
    "fsttcs 2004 _ , pages 408420 .",
    "p. madhusudan , personal communication .",
    "conditional xpath , the first order complete xpath dialect . in _ pods04 _",
    ", pages 1322 .",
    "conditional xpath . tods 30(4 ) : 929959 , 2005 .",
    "m. marx and m. de rijke .",
    "semantic characterizations of navigational xpath . in _ tdm04 _ , pages 6773 .",
    "f.  neven , t.  schwentick .",
    "expressive and efficient pattern languages for tree - structured data . , pages 145 - 156 .",
    "f. laroussinie , n. markey , and p. schnoebelen .",
    "temporal logic with forgettable past . in _",
    "lics02 _ , pages 383392 .",
    "f. neven and t. schwentick .",
    "query automata over finite trees .",
    "275(1 - 2 ) : 633674 , 2002 .",
    "sax : a simple api for xml . .",
    ". expressive completeness of temporal logic of trees . 2 : 157 - 180 , 1992 .",
    "l.  segoufin .",
    "typing and querying xml documents : some complexity bounds . in _",
    "pods03 _ , pages 167178 .",
    "l.  segoufin , v.  vianu . validating streaming xml documents . in _",
    "pods02 _ ,",
    "pages 5364 .",
    "v.  vianu . .",
    "acm pods01 _ , pages 115 .",
    "for translating each @xmath219 formula @xmath48 into an equivalent @xmath2 formula @xmath233 , we need to consider only the case of until / since operators .",
    "the formula @xmath234 is translated into @xmath1068 where @xmath236 is a formula defined as follows : @xmath237 the proof that the translation is correct is by induction on the structure of @xmath219 formulas .",
    "again we need to consider only the case of until / since operators .",
    "assume that @xmath405 , @xmath614 are equivalent to @xmath1069 and @xmath1070 , respectively .",
    "we need to prove that @xmath234 is equivalent to ( [ trans - eq - app ] ) . +   + ( @xmath1071 )",
    "we first show that if @xmath1072 satisfies ( [ trans - eq - app ] ) , then @xmath1073 .",
    "given that @xmath1072 satisfies ( [ trans - eq - app ] ) , either @xmath1074 or @xmath1072 satisfies the second disjunct of ( [ trans - eq - app ] ) . since",
    "@xmath1070 and @xmath614 are assumed to be equivalent , in the former case @xmath1073 .",
    "thus , assume that the latter case holds .",
    "then @xmath1075 , since @xmath405 and @xmath1069 are equivalent , and there exists a summary path @xmath1076 such that : @xmath1077we consider three cases .",
    "a.   assume that there exists a position @xmath1078 ( @xmath1079 $ ] ) such that @xmath1078 is a matched call position and @xmath1080 , and let @xmath1081 ( @xmath1082 $ ] ) be the first such position .",
    "then only one semi - strict path with endpoints @xmath1083 and @xmath1084 can be obtained from the sequence @xmath1085 by removing all positions @xmath1078 ( with @xmath1086 $ ] ) such that @xmath1087 is a matched call position and @xmath1088 ; let @xmath1089 be that semi - strict path .",
    "next we show that : @xmath1090 from which we conclude that @xmath1073 . + given that @xmath1091 , @xmath1092 and we assume that @xmath614 and @xmath1070 are equivalent , we have that @xmath1093 .",
    "next we show that @xmath1094 for every @xmath1095 $ ] .",
    "if @xmath1096 , then the property holds since @xmath1097 and we assume that @xmath405 and @xmath1069 are equivalent .",
    "assume that @xmath1098 $ ] . if @xmath1099 is not a return position , then @xmath1100 since @xmath1101 ( recall that @xmath1099 is a position in the summary path @xmath1102 since @xmath1103 ) .",
    "if @xmath1099 is a return position , then we have to consider two cases .",
    "if @xmath1104 , then we have that @xmath1105 is not a call position since @xmath1099 is a return position , @xmath1106 is a semi - strict path and @xmath1107 $ ] . given that @xmath1108 is a position in the summary path @xmath1109 , we conclude that @xmath1110 . thus , from the fact that @xmath1108 is not a call position , we conclude that @xmath1111 .",
    "hence , @xmath1094 .",
    "otherwise , @xmath1112 , and we conclude that @xmath1108 is a matched call position and @xmath1113 . thus , since @xmath1081 is the smallest one satisfying @xmath1114 and @xmath1115 , and we know from ( [ gamma - eq - one ] ) that @xmath1116 , we see that @xmath1117 and , since @xmath1108 is a matched call , we conclude that @xmath1118 and , therefore , @xmath1094 . b.   assume that condition ( i ) does not hold , and also assume that either @xmath212 is not a matched call position or @xmath212 is a matched call position and @xmath1119 .",
    "then given that @xmath1120 , we have that there exists a position @xmath1121 such that @xmath1122 and @xmath1123 is either @xmath1124 or @xmath1125 . only one semi - strict path with endpoints @xmath1083 and @xmath1123 can be obtained from the sequence @xmath1126 by removing all positions @xmath1078 ( with @xmath1127 $ ] ) such that @xmath1087 is a matched call position and @xmath1088 ; let @xmath1128 be that semi - strict path .",
    "next we show that : @xmath1090 from which we conclude that @xmath1073 . + given that @xmath1129 and the hypothesis that @xmath614 and @xmath1070 are equivalent , we have that @xmath1130 .",
    "next we show that @xmath1094 for every @xmath1095 $ ] .",
    "if @xmath590 , then the property holds since @xmath1075 .",
    "assume that @xmath1131 $ ] . if @xmath1099 is not a return position , then @xmath1094 since @xmath1132 ( recall that @xmath1099 is a position in the summary path @xmath1133 ) .",
    "if @xmath1099 is a return position , then we have to consider two cases .",
    "if @xmath1104 , then we have that @xmath1105 is not a call position since @xmath1134 is a semi - strict path and @xmath1135 $ ] .",
    "thus , given that @xmath1108 is a position in the summary path @xmath1136 , we have that @xmath1137 , from which we conclude that @xmath1118 .",
    "hence , @xmath1138 .",
    "otherwise , @xmath1139 , and we conclude that @xmath1108 is a matched call position and @xmath1113 . thus , given that condition ( i ) does not hold , we have that @xmath1117 ( since @xmath1108 is a position in the summary path @xmath1140 and @xmath1141 ) .",
    "thus , given that @xmath1108 is a matched call , we conclude from ( [ gamma - eq - one ] ) that @xmath1142 and , therefore , @xmath1094 .",
    "c.   we now look at the remaining cases , that is , condition ( i ) does not hold , @xmath212 is a matched call , and @xmath1143 . by ( [ gamma - eq - two ] ) , this implies @xmath1144 . from @xmath1145",
    ", we see that there exists a summary path @xmath1146 such that : @xmath1147we first show that @xmath1148 .",
    "assume to the contrary that @xmath1149 .",
    "since the first position on the path is inside the call @xmath212 , there exists @xmath1150 $ ] such that @xmath1151 . given that @xmath1123 is not a return position ( since @xmath1152 ) , we have that @xmath1153 and , therefore , @xmath1154 is also a position in the summary path @xmath1155 . but given that @xmath1156 is the matching return of @xmath212 and @xmath1157 , we have that @xmath1154 is not a call position .",
    "thus , @xmath1158 , which contradicts the fact that @xmath1159 witnesses formula @xmath236 . therefore indeed @xmath1148 .",
    "+ given that @xmath1160 , we conclude that there exists a position @xmath1161 such that @xmath1162 and @xmath1163 is either @xmath1164 or @xmath1084 .",
    "only one semi - strict path with endpoints @xmath1083 and @xmath1163 can be obtained from the sequence @xmath1165 by removing all positions @xmath1078 ( with @xmath1086 $ ] ) such that @xmath1087 is a matched call position and @xmath1088 ; let @xmath1166 be that semi - strict path . next we show that : @xmath1090 from which we conclude that @xmath1073 . +",
    "given that @xmath1167 , we conclude that that @xmath1130 .",
    "next we show that @xmath1094 for every @xmath1095 $ ] .",
    "if @xmath590 , then the property holds since @xmath1075 and we assume that @xmath405 and @xmath1069 are equivalent .",
    "assume that @xmath1131 $ ] . if @xmath1099 is not a return position , then @xmath1094 since @xmath1132 ( recall that @xmath1099 is a position in the sequence @xmath1168 ) .",
    "if @xmath1099 is a return position , then we need to consider two cases .",
    "if @xmath1104 , then we have that @xmath1105 is not a call position since @xmath1134 is a semi - strict path and @xmath1135 $ ] .",
    "thus , given that @xmath1108 is a position in the sequence @xmath1169 and @xmath1170 ( since @xmath212 is a call position ) , we have that @xmath1171 , from which we conclude that @xmath1118 .",
    "hence , @xmath1138 .",
    "if @xmath1139 , then we have that @xmath1108 is a matched call position and @xmath1113 .",
    "moreover , in this case we also have that @xmath1172 . indeed , to see this ,",
    "assume to the contrary that @xmath1173 .",
    "then given that @xmath1148 , we know that @xmath1174 .",
    "thus , given that @xmath212 is a call position , @xmath1175 and @xmath1176 , we conclude that @xmath1177 .",
    "therefore , given that @xmath1099 is a return position and @xmath1178 is a summary path , there exists @xmath1179 $ ] such that @xmath1180 is a call position with matching return @xmath1099 .",
    "but since @xmath1108 and @xmath1099 are both positions in the summary path @xmath1181 and @xmath1182 , we conclude that this path contains three positions @xmath39 , @xmath358 and @xmath1027 such that @xmath1183 and @xmath1027 is the matching return of call position @xmath39 , which contradicts the definition of summary path .",
    "so we proved @xmath1172 .",
    "now we have that @xmath1184 , from which we conclude that @xmath1118 since condition ( i ) does not hold and @xmath1182 .",
    "hence , @xmath1094 .",
    "( @xmath1185 ) we now show that if @xmath1073 , then @xmath1072 satisfies ( [ trans - eq - app ] ) .",
    "given that @xmath1186 , there exists a semi - strict path @xmath1187 such that : @xmath1188 notice that if @xmath1189 , then @xmath1190 and , therefore , @xmath1072 satisfies the first disjunct of ( [ trans - eq - app ] ) since @xmath614 and @xmath1070 are assumed to be equivalent .",
    "thus , we suppose that @xmath1191 , and we consider two cases .",
    "a.   assume that there exists @xmath1192 $ ] such that @xmath1078 is a matched call position , @xmath1193 and @xmath1194 is not a return position , and let @xmath212 be the first such position .",
    "then only one summary path with endpoints @xmath1083 and @xmath212 can be obtained from the semi - strict path @xmath1195 by adding positions @xmath1196 for every @xmath1197 $ ] such that @xmath1078 is a matched call position and @xmath1198 ; let @xmath1199 be that summary path . next we show that : + [ cols= \" < \" , ]    + from which we conclude that @xmath1072 satisfies ( [ trans - eq - app ] ) . + we start by showing that the first condition above holds .",
    "let @xmath1200 $ ] .",
    "if @xmath1099 is a return position , then we have that @xmath1201 .",
    "otherwise , by definition of @xmath1202 , we have that @xmath1099 is a position in the semi - strict path @xmath1109 .",
    "thus , from ( [ m - eq1 ] ) we conclude that @xmath1094 and , hence , @xmath1203 since @xmath405 and @xmath1069 are assumed to be equivalent .",
    "it only remains to show that @xmath1204 .",
    "if @xmath1099 is a matched call position and @xmath1205 , then given that @xmath1168 is a semi - strict path and condition ( i ) does not hold , we have that @xmath1099 and @xmath1206 are both positions in the semi - strict path @xmath1169 .",
    "thus , from ( [ m - eq1 ] ) we conclude that @xmath1207 and , therefore , @xmath1208 .",
    "if @xmath1099 is a matched call position and @xmath1209 , then given that @xmath1168 is a semi - strict path and condition ( i ) does not hold , we have that @xmath1210 and @xmath1211 .",
    "thus , given that @xmath1212 , we conclude that @xmath1213 .",
    "finally , if @xmath1099 is not a matched call position , then we have that @xmath1214 is a position in the semi - strict path @xmath1109 ( since @xmath1215 ) .",
    "thus , from ( [ m - eq1 ] ) we conclude that @xmath1216 and , therefore , @xmath1217 .",
    "+ to conclude the proof of the lemma , we show that the second condition above also holds , that is , @xmath1218 . if @xmath1219 is a return position , we immediately conclude that @xmath1220 .",
    "thus , assume that @xmath1219 is not a return position . but in this case we conclude that @xmath1219 is a position in the semi - strict path @xmath1109 and , thus , @xmath1221 since @xmath1222 and we assume that @xmath405 and @xmath1069 are equivalent . it only remains to show that : @xmath1223 if @xmath1219 is a matched call position , then given that condition ( i ) does not hold , we have that @xmath1224 .",
    "thus , given that @xmath1212 and we assume that @xmath614 and @xmath1070 are equivalent , we conclude that @xmath1225 and , therefore , @xmath1226 .",
    "if @xmath1219 is not a matched call position , then we have that @xmath1227 .",
    "thus , given that @xmath1212 , we have that @xmath1225 and , therefore , @xmath1228 .",
    "this concludes the proof of lemma [ nwtl - lemma - one ] ."
  ],
  "abstract_text": [
    "<S> nested words are a structured model of execution paths in procedural programs , reflecting their call and return nesting structure . </S>",
    "<S> finite nested words also capture the structure of parse trees and other tree - structured data , such as xml .    </S>",
    "<S> we provide new temporal logics for finite and infinite nested words , which are natural extensions of ltl , and prove that these logics are first - order expressively - complete . </S>",
    "<S> one of them is based on adding a `` within '' modality , evaluating a formula on a subword , to a logic @xmath0 previously studied in the context of verifying properties of recursive state machines ( rsms ) . </S>",
    "<S> the other logic , nwtl , is based on the notion of a summary path that uses both the linear and nesting structures . for nwtl </S>",
    "<S> we show that satisfiability is exptime - complete , and that model - checking can be done in time polynomial in the size of the rsm model and exponential in the size of the nwtl formula ( and is also exptime - complete ) .    </S>",
    "<S> finally , we prove that first - order logic over nested words has the three - variable property , and we present a temporal logic for nested words which is complete for the two - variable fragment of first - order . </S>"
  ]
}