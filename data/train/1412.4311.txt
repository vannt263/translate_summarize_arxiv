{
  "article_text": [
    "when querying a database , a user may not always obtain the expected results , and the system could provide some explanations",
    ". they could be useful to further understand the data or check if the query is the intended one .",
    "actually , the notion of explanation for a query result was introduced in @xcite , on the basis of the deeper concept of _ actual causation_.    a tuple @xmath0 is an _ actual cause _ for an answer @xmath1 to a conjunctive query @xmath2 from a relational database instance @xmath3 if there is a _ contingent _ set of tuples @xmath4 , such that , after removing @xmath4 from @xmath3 , @xmath1 is still an answer , but after further removing @xmath0 from @xmath5 , @xmath1 is not an answer anymore . here , @xmath4 is a set of tuples that has to accompany @xmath1 for it to be a cause .",
    "actual causes and contingent tuples are restricted to be among a pre - specified set of _ endogenous tuples _ , which are admissible , possible candidates for causes , as opposed to _ exogenous tuples _ , which may also be present in the database . in rest of this paper , whenever we simply say  cause \" , we mean  actual cause \" .    in applications involving large data sets , it is crucial to rank potential causes by their _ responsibilities _",
    "@xcite , which reflect the relative ( quantitative ) degrees of their causality for a query result . the responsibility measure for a cause",
    "is based on its _ contingency sets _ : the smallest ( one of ) its contingency sets , the strongest it is as a cause .",
    "actual causation , as used in @xcite , can be traced back to @xcite , which provides a model - based account of causation on the basis of _ counterfactual dependence_. responsibility was introduced in @xcite , to capture the intuitive notion of _ degree of causation_.    apart from the explicit use of causality , research on explanations for query results has focused mainly , and rather implicitly , on provenance @xcite    .",
    "a close connection between causality and provenance has been established in @xcite . however , causality is a more refined notion that identifies causes for query results on the basis of user - defined criteria , and ranks causes according to their responsibilities @xcite .    _ consistency - based diagnosis _",
    "@xcite , a form of model - based diagnosis @xcite , is an area of knowledge representation .",
    "the problem here is , given the _ specification _ of a system in some logical formalism and a usually unexpected _ observation _ about the system , to obtain _ explanations _ for the observation , in the form of a diagnosis for the unintended behavior .    in a different direction , a database instance , @xmath3 , that is expected to satisfy certain integrity constraints may fail to do so . in this case",
    ", a _ repair _ of @xmath3 is a database @xmath6 that does satisfy the integrity constraints and _ minimally departs _ from @xmath3 .",
    "different forms of minimality can be applied and investigated .",
    "a _ consistent answer _ to a query from @xmath3 and wrt .",
    "the integrity constraints is a query answer that is obtained from all possible repairs , i.e. is invariant or certain under the class of repairs .",
    "these notions were introduced in @xcite ( surveys of the area can be found in @xcite ) . although not in the context of repairs , consistency - based diagnosis has been applied to consistency restoration of a database wrt .",
    "integrity constraints @xcite .",
    "these three forms of reasoning , namely inferring causes from databases , consistency - based diagnosis , and consistent query answering ( and repairs ) are all _ non - monotonic _ @xcite .",
    "for example , a ( most responsible ) cause for a query result may not be such anymore after the database is updated .",
    "furthermore , they all reflect some sort of _ uncertainty _ about the information at hand . in this work",
    "we establish natural , precise , useful , and deeper connections between these three reasoning tasks .",
    "more precisely , we unveil a strong connection between computing causes and their responsibilities for conjunctive query answers , on one hand , and computing repairs in databases wrt . _ denial constraints _ , on the other .",
    "these computational problems can be reduced to each other . in order to obtain repairs wrt . _ a set _ of denial constraints from causes",
    ", we investigate causes for queries that are _ unions of conjunctive queries _ , and develop algorithms to compute causes and responsibilities .",
    "we show that inferring and computing actual causes and their responsibilities in a database setting become diagnosis reasoning problems and tasks .",
    "actually , a causality - based explanation for a conjunctive query answer can be viewed as a diagnosis , where in essence the first - order logical reconstruction of the relational database provides the system description @xcite , and the observation is the query answer .",
    "we also establish a bidirectional connection between diagnosis and repairs .",
    "being the causality problems the main focus of this work , we take advantage of algorithms and complexity results both for consistency - based diagnosis ; and database repairs and consistent query answering @xcite . in this way , we obtain new complexity results for the main problems of causality , namely computing actual causes , determining their responsibilities , and obtaining most responsible causes ; and also for their decision versions .",
    "in particular , we obtain fixed - parameter tractable algorithms for some of them . more precisely , our main results are as follows :  ( the complexity results are all in data complexity )    \\1 .  for a boolean conjunctive query and its associated denial constraint ( the former being its violation view ) ,",
    "we establish a precise connection ( characterization and computational reductions ) between actual causes for the query ( being true ) and the subset- and cardinality - repairs of the instance wrt .  the denial constraint .",
    "we obtain causes from repairs .",
    "we obtain repairs from causes , for which we extend the treatment of causality to unions of conjunctive queries ( to represent multiple denial constraints ) .",
    "we characterize an actual cause s responsibility in terms of cardinality - repairs .",
    "we provide algorithms to compute causes and their ( minimal ) contingency sets for unions of conjunctive queries .",
    "the causes can be computed in ptime .",
    "we establish a precise connection between consistency - based diagnosis for a boolean conjunctive query being unexpectedly true according to a system description , and causes for the query being true .",
    "in particular , we show how to compute actual causes , their contingency sets , and responsibilities using the diagnosis characterization . hitting - set - based algorithmic approaches to diagnosis",
    "inspire our algorithmic / complexity approaches to causality .",
    "we reformulate the causality problems as hitting set problems and vertex cover problems on hypergraphs , which allows us to apply results and techniques for the latter to causality .",
    "( a ) checking minimal contingency sets can be done in ptime .",
    "( b ) the responsibility ( decision ) problem for conjunctive queries becomes _ np_-complete .",
    "( c ) however , it is fixed - parameter tractable when the parameter is the inverse of the responsibility bound .",
    "( d ) the functional problem of computing the causes responsibilities is @xmath7-complete , and deciding most responsible causes is @xmath8-complete .",
    "the structure of the resulting hitting - set problem allows us to obtain efficient parameterized algorithms and good approximation algorithms for computing causes and minimal contingency sets .",
    "\\7 .  on the basis of the causality / repair connection , and the dichotomy result for causality @xcite",
    ", we obtain a dichotomy result for the complexity of deciding the existence of repairs of a certain size wrt .",
    "single , self - join - free denial constraints .",
    "we discuss extensions and open issues that deserve investigation .",
    "the paper is structured as follows .",
    "section [ sec : prel ] introduces technical preliminaries for relational databases , causality in databases , database repairs and consistent query answering , consistency - based diagnosis , and relevant complexity classes .",
    "section [ sec : causfrepair ] characterizes actual causes and responsibilities in terms of database repairs .",
    "section [ sec : causfrepair ] characterizes repairs and consistent query answering in terms of causes and contingency sets for queries that are unions of conjunctive queries ; and presents an algorithm for computing both of the latter .",
    "section [ sec : mbdtorep ] formulates causality problems as consistency - based diagnosis problems , and the latter as repair problems .",
    "section [ sec : mbdcomx ] shows complexity and algorithmic results ; in particular a fixed - parameter tractability result for causes responsibilities .",
    "finally , section [ sec : disc ] discusses several relevant issues , connections and open problems around causality in databases .",
    "proofs of results without an implicit proof in the main body of this paper can be found in the appendix .",
    "we consider relational database schemas of the form @xmath9 , where @xmath10 is the possibly infinite database domain of _ constants _ and @xmath11 is a finite set of _ database predicates _ ) that we assume do not appear , unless explicitly stated otherwise .",
    "] of fixed arities .",
    "a database instance @xmath3 compatible with @xmath12 can be seen as a finite set of ground atomic formulas ( in databases aka .",
    "atoms or tuples ) , of the form @xmath13 , where @xmath14 has arity @xmath15 , and @xmath16 . a _ conjunctive query _ ( cq )",
    "is a formula @xmath17 of the first - order ( fo ) logic language , @xmath18 , associated to @xmath19 of the form  @xmath20 , where the @xmath21 are atomic formulas , i.e. @xmath22 , and the @xmath23 are sequences of terms , i.e. variables or constants .",
    "the @xmath24 in @xmath17 shows all the free variables in the formula , i.e. those not appearing in @xmath25 .",
    "if @xmath24 is non - empty , the query is _ open_.",
    "if @xmath24 is empty , the query is _ boolean _ ( a bcq ) , i.e. the query is a sentence , in which case , it is true or false in a database , denoted by @xmath26 and @xmath27 , respectively .",
    "a sequence @xmath28 of constants is an answer to an open query @xmath17 if @xmath29 $ ] , i.e. the query becomes true in @xmath3 when the variables are replaced by the corresponding constants in @xmath28 .",
    "an _ integrity constraint _ is a sentence of language @xmath18 , and then , may be true or false in an instance for schema @xmath19 . given a set @xmath30 of integrity constraints , a database instance @xmath3 is _ consistent _ if @xmath31 ; otherwise it is said to be _",
    "inconsistent_. in this work we assume that sets of integrity constraints are always finite and logically consistent . a particular class of integrity constraints is formed by _ denial constraints _ ( dcs ) , which are sentences @xmath32 of the form : @xmath33 , where @xmath34 and each @xmath35 is a database atom , i.e. predicate @xmath36 .",
    "( the atoms may contain constants . )",
    "denial constraints are exactly the negations of bcqs .    * causality and responsibility . *   assume that the database instance is split in two , i.e. @xmath37 , where @xmath38 and @xmath39 denote the sets of _ endogenous _ and _ exogenous _ tuples , respectively",
    ". a tuple @xmath40 is called a _ counterfactual cause _ for a bcq @xmath2 , if @xmath41 and @xmath42 .",
    "a tuple @xmath40 is an _ actual cause _ for @xmath2 if there exists @xmath43 , called a _ contingency set _ , such that @xmath0 is a counterfactual cause for @xmath2 in @xmath5  @xcite .",
    "we will concentrate mostly on cqs .",
    "however , the definition of actual causes and contingency sets can be applied without a change to monotone queries in general @xcite .",
    "the _ responsibility _ of an actual cause @xmath0 for @xmath2 , denoted by @xmath44 , is the numerical value @xmath45 , where @xmath46 is the size of the smallest contingency set for @xmath0 .",
    "we can extend responsibility to all the other tuples in @xmath38 by setting their value to @xmath47 .",
    "those tuples are not actual causes for @xmath2 .",
    "[ ex : cfex1 ] consider @xmath48 @xmath49 @xmath50 , and the query @xmath51 .",
    "it holds : @xmath26 .",
    "tuple @xmath52 is a counterfactual cause for @xmath2 .",
    "if @xmath52 is removed from @xmath3 , @xmath2 is not true anymore .",
    "therefore , the responsibility of @xmath52 is 1 . besides , @xmath53 is an actual cause for @xmath2 with contingency set @xmath54 .",
    "if @xmath55 is removed from @xmath3 , @xmath2 is still true , but further removing @xmath53 makes @xmath2 false .",
    "the responsibility of @xmath53 is @xmath56 , because its smallest contingency sets have size @xmath57 .",
    "likewise , @xmath55 and @xmath58 are actual causes for @xmath2 with responsibility @xmath56 .",
    "for the same @xmath2 , but with @xmath59 , and the partition @xmath60 and @xmath61 , it turns out that both @xmath52 and @xmath58 are counterfactual causes for @xmath2.@xmath62    * _ notation : _ *  @xmath63 denotes the set of actual causes for bcq @xmath2 ( being true ) from instance @xmath37 .",
    "when @xmath64 and @xmath65 , we sometimes simply write : @xmath66 .    * database repairs .",
    "*  given a set @xmath30 of integrity constraints , a _ subset repair _",
    "( simply , s - repair ) of a possibly inconsistent instance @xmath3 for schema @xmath19 is an instance @xmath6 for @xmath19 that satisfies @xmath30 and makes @xmath67 minimal under set inclusion . @xmath68 denotes the set of s - repairs of @xmath3 wrt .",
    "@xmath30 @xcite .",
    "similarly , @xmath6 is a _ cardinality repair _ ( simply c - repair ) of @xmath3 if @xmath6 satisfies @xmath30 and minimizes @xmath69 .",
    "@xmath70 denotes the class of c - repairs of @xmath3 wrt .",
    "c - repairs are s - repairs of minimum cardinality .    for dcs",
    ", s - repairs and c - repairs are obtained from the original instance by deleting an s - minimal , resp .",
    "c - minimal , set of tuples .",
    "if it minimal under set inclusion in @xmath71 .",
    "similarly , a set is c - minimal if it is minimal in cardinality within @xmath71 .",
    "] more generally , different _ repair semantics _ may be considered to restore consistency wrt .",
    "general integrity constraints .",
    "they depend on the kind of allowed updates on the database ( i.e. tuple insertions / deletions , changes of attribute values ) , and the minimality conditions on repairs ( e.g. subset - minimality , cardinality - minimality , etc . ) .",
    "given @xmath3 and @xmath30 , a repair semantics determines a class of intended or preferred repairs @xcite .",
    "given a repair semantics , _ rs _ ,  @xmath28 is a _",
    "consistent answer _ to an open query @xmath17 if @xmath72 $ ] for every",
    "_ rs_-repair @xmath73 .",
    "a bcq is _ consistently true _ if it is true in all _ rs_-repairs .",
    "if @xmath28 is a consistent answer to @xmath17 wrt .",
    "s - repairs , we say it is an _ s - consistent answer_. similarly for _ c - consistent answers_.    consistent query answering for dcs under s - repairs was investigated in detail @xcite .",
    "c - repairs and consistent query answering were investigated in detail in @xcite .",
    "@xcite for more references . )",
    "* consistency - based diagnosis .",
    "* consistency - based diagnosis , a form of model - based diagnosis @xcite , considers problems @xmath74 @xmath75 , where @xmath76 is the description in logic of the intended properties of a system under the _ explicit _ assumption that all the _ components _ in @xmath77 , are working normally .",
    "@xmath78 is a fo sentence that represents the observations . if the system does not behave as expected ( as shown by the observations ) , then the logical theory obtained from @xmath79 plus the explicit assumption , say @xmath80 , that the components are indeed behaving normally , becomes inconsistent .",
    "@xmath81 is an _ abnormality _ predicate .",
    "expresses that component @xmath82 is ( behaving ) abnormal(ly ) . ]",
    "the inconsistency is captured via the _ minimal conflict sets _",
    ", i.e. those minimal subsets @xmath83 of @xmath77 , such that @xmath84 is inconsistent .",
    "as expected , different notions of minimality can be used at this point .",
    "a _ minimal diagnosis _ for @xmath85 is a minimal subset @xmath86 of @xmath77 , such that @xmath87 is consistent .",
    "that is , consistency is restored by flipping the normality assumption to abnormality for a minimal set of components , and those are the ones considered to be ( jointly ) faulty .",
    "the notion of minimality commonly used is s - minimality , i.e. a diagnosis that does not have a proper subset that is a diagnosis .",
    "we will use this kind of minimality in relation to diagnosis .",
    "diagnosis can be obtained from conflict sets @xcite .    * complexity classes . *  we recall some complexity classes @xcite used in this paper .",
    "@xmath88 is the class of functional problems associated to decision problem in the class _ ptime _ ,",
    "i.e. that are solvable in polynomial time .",
    "@xmath89 ( or @xmath90 ) is the class of decision problems solvable in polynomial time by a machine that makes calls to an @xmath91 oracle . for @xmath92",
    "the number of calls is logarithmic .",
    "it is not known if @xmath92 is strictly contained in @xmath93 .",
    "@xmath94 is similarly defined .",
    "let @xmath95 be an instance for schema @xmath12 , and @xmath96 a bcq .",
    "@xmath2 may be unexpectedly true , i.e. @xmath26 .",
    "now , @xmath97 is logically equivalent to the dc @xmath98 .",
    "the requirement that @xmath97 holds can be captured by imposing @xmath99 on @xmath3 . due to @xmath26",
    ", it holds @xmath100 .",
    "so , @xmath3 is inconsistent wrt .",
    "@xmath99 , and could be repaired .",
    "repairs for ( violations of ) dcs are obtained by tuple deletions . intuitively , a tuple that participates in a violation of @xmath99 in @xmath3 is an actual cause for @xmath2 .",
    "s - minimal sets of tuples like this are expected to correspond to s - repairs for @xmath3 and @xmath99 .",
    "more precisely , given an instance @xmath101 , a bcq @xmath2 , and a tuple @xmath40 , we consider the class containing the sets of differences between @xmath3 and those s- or c - repairs that do not contain @xmath0 , and are obtained by removing a subset of @xmath38 : @xmath102    it holds @xmath103 . now",
    ", any @xmath104 @xmath105 can be written as @xmath106 . from the s - minimality of s - repairs , @xmath107 , but @xmath108 , i.e. @xmath109 , but @xmath110 .",
    "so , @xmath0 is an actual cause for @xmath2 with contingency set @xmath111 .",
    "[ pro : c&r ] _ given @xmath112 , and a bcq @xmath2 , @xmath40 is an actual cause for @xmath2  iff @xmath113.@xmath62 _    [ pro : r&r ] _ given @xmath112 , a bcq @xmath2 , and @xmath40 :  ( a ) if @xmath114 @xmath115 , then @xmath116 .",
    "( b ) otherwise , @xmath117 , where @xmath118 @xmath105 and there is no @xmath119 such that @xmath120 .",
    "@xmath62 _    [ cor : card ] _ given @xmath112 , and a bcq @xmath2 ,",
    "@xmath40 is a most responsible actual cause for @xmath2  iff @xmath121.@xmath62 _    [ ex : causasrepex1 ] ( ex .",
    "[ ex : cfex1 ] cont . )",
    "consider the same instance @xmath3 and query @xmath2 . in this case , the dc @xmath99 is , in datalog notation , a negative rule :  @xmath122 .    here , @xmath123",
    "@xmath124 @xmath125 @xmath126 @xmath127 and @xmath128 , with @xmath129 @xmath130 @xmath131 @xmath132 @xmath133 ,  @xmath134 @xmath135 @xmath49 @xmath50 ,  @xmath136 @xmath130 @xmath137 @xmath138 .    for tuple @xmath53 , @xmath139 @xmath140 @xmath141 , which , by propositions [ pro : c&r ] and [ pro : r&r ] , confirms that @xmath53 is an actual cause , with responsibility @xmath56 .  for tuple @xmath52 , @xmath142 @xmath143 @xmath144 .",
    "so , @xmath52 is an actual cause with responsibility 1 .",
    "similarly , @xmath55 is an actual cause with responsibility @xmath56 , because @xmath145 @xmath146 @xmath147 @xmath148 @xmath149 .",
    "it holds @xmath150 @xmath151 , because all repairs contain @xmath152 , @xmath153 .",
    "this means they do not participate in the violation of @xmath99 or contribute to make @xmath2 true .",
    "so , they are not actual causes for @xmath2 , confirming the result in example [ ex : cfex1 ] .    @xmath154 . from corollary",
    "[ cor : card ] , @xmath52 is the most responsible cause .",
    "@xmath62    [ rem : ucq ] _ the results in this section can be easily extended to unions of bcqs without built - ins , i.e. essentially fo monotone queries without built - ins .",
    "this can be done by associating a dc to each disjunct of the query , and considering the corresponding problems for database repairs wrt .",
    "several dcs ( cf .",
    "section [ sec : disjcauses ] ) . @xmath62 _",
    "we now characterize repairs for inconsistent databases wrt .  _ a set of _ dcs in terms of actual causes , and reduce their computation to computation of causes .",
    "consider an instance @xmath3 for schema @xmath12 , and a set of dcs @xmath155 on @xmath19 .",
    "for each @xmath156 , of the form @xmath157 , consider its associated _ violation view _",
    "defined by a bcq , namely @xmath158 .",
    "next , consider the query obtained as the union of the individual violation views : @xmath159 , a _ union of _ bcqs ( ubcqs ) .",
    "clearly , @xmath3 violates ( is inconsistent wrt . )",
    "@xmath155 iff @xmath160 .",
    "it is easy to verify that @xmath3 is consistent wrt .",
    "@xmath155 iff @xmath161 , i.e. there are no actual causes for @xmath162 to be true when all tuples are endogenous .",
    "now , let us collect all _ s - minimal contingency sets _ associated with an actual cause @xmath0 for @xmath162 : @xmath163    notice that for @xmath164 , @xmath165 .",
    "if @xmath166 and @xmath164 , from the definition of actual cause and the s - minimality of @xmath167 , its holds that @xmath168 is an s - minimal subset of @xmath3 with @xmath169 .",
    "so , @xmath170 is an s - repair for @xmath3 .",
    "then , the following holds .",
    "[ pro : sr&cp ] _ for an instance @xmath3 and a set dcs @xmath155 , @xmath171 is an s - repair for @xmath3 wrt .",
    "@xmath155 iff , for every @xmath172 : @xmath166 and @xmath173 .",
    "@xmath62 _    to establish a connection between most responsible actual causes and c - repairs , collect the most responsible actual causes for @xmath162 : @xmath174    [ pro : cr&mrp ] _ for instance @xmath3 and set of dcs @xmath155 , @xmath171 is a c - repair for @xmath3 wrt .",
    "@xmath155 iff , for every @xmath175 : @xmath176 and @xmath177 .",
    "@xmath62 _    actual causes for @xmath178 , with their contingency sets , account for the violation of some @xmath156 .",
    "removing those tuples from @xmath3 should remove the inconsistency . from propositions",
    "[ pro : sr&cp ] and [ pro : cr&mrp ] we obtain :    [ col : sr&cp ] _ given an instance @xmath3 and a set dcs @xmath155 , the instance obtained from @xmath3 by removing an actual cause , resp",
    ". a most responsible actual cause , for @xmath178 together with any of its s - minimal , resp .",
    "c - minimal , contingency sets forms an s - repair , resp . a c - repair , for @xmath3 wrt .",
    "@xmath155 . @xmath62 _    [ ex : rc2cp ] consider @xmath179 and @xmath180 , with @xmath181 and @xmath182 .",
    "the violation views are @xmath183 and @xmath184 . for @xmath185 , @xmath186 .",
    "@xmath3 is inconsistent wrt .",
    "@xmath155 .    with all tuples endogenous , @xmath187 .",
    "its elements are associated with sets of s - minimal contingency sets : @xmath188 ,  @xmath189 @xmath190 , @xmath191 . from corollary [ col :",
    "sr&cp ] , and @xmath192 @xmath193 , @xmath194 is an s - repair .",
    "so is @xmath195 @xmath196 .",
    "these are the only s - repairs .",
    "furthermore , @xmath197 . from corollary [ col :",
    "sr&cp ] , @xmath198 is also a c - repair for @xmath3 .",
    "@xmath62    an actual cause @xmath0 with any of its s - minimal contingency sets determines a unique s - repair .",
    "the last example shows that , with different combinations of a cause and one of its contingency sets , we may obtain the same repair ( e.g. for the first two @xmath199s ) .",
    "so , we may have more minimal contingency sets than minimal repairs . however , we may still have exponentially many minimal contingency sets , so as we may have exponentially many minimal repairs .",
    "[ ex : repsvsconts ] consider @xmath200 and the dc @xmath201 .",
    "@xmath3 is inconsistent wrt .",
    "there are exponentially many s - repairs of @xmath3 : @xmath202 , @xmath203 , @xmath204 , ... , @xmath205 .",
    "the c - repairs are only @xmath6 and @xmath206 .    for the bcq @xmath207 associated to @xmath32 , @xmath208 , and @xmath209 and @xmath210",
    "are actual causes for @xmath207 ( courterfactual causes with responsibility @xmath57 ) .",
    "all tuples in @xmath211 are actual causes , each with exponentially many s - minimal contingency sets .",
    "for example , @xmath212 has the s - minimal contingency set @xmath213 , among exponentially many others ( any set built with just one element from each of the pairs @xmath214 , ... , @xmath215 is one ) .",
    "@xmath62    the characterization results obtained so far extend those in @xcite for single dcs .",
    "if we want to compute repairs wrt . sets of dcs from causes for ubcqs using , say corollary [ col : sr&cp ] , we first need an algorithm for computing the actual causes and their ( minimal ) contingency sets for ubcqs . these algorithms could be used as a first stage for the computation of s - repairs and c - repairs wrt .",
    "sets of dcs .",
    "however , these algorithms ( cf . section [ sec : disjcausescont ] ) are also interesting _ per se_.",
    "the ptime algorithm for computing actual causes in @xcite is for single conjunctive queries , but does not compute the actual causes contingency sets . actually , doing the latter increases the complexity ,",
    "because _ deciding responsibility_. ] of actual causes is @xmath216-hard @xcite ( which would be tractable if we could efficiently compute all ( minimal ) contingency sets ) . in principle , an algorithm for responsibilities can be used to compute c - minimal contingency sets , by iterating over all candidates , but example [ ex : repsvsconts ] shows that there can be exponentially many of them .",
    "we first concentrate on the problem of computing actual causes for ubcqs , without their contingency sets , which requires some notation .",
    "[ def : hsstuff ] given @xmath217 , with each @xmath218 a bcq , and an instance @xmath3 ,  ( a ) @xmath219 is the collection of all s - minimal subsets of @xmath3 that satisfy a disjunct @xmath220 of @xmath2 .",
    "( b ) @xmath221 consists of the s - minimal subsets @xmath167 of @xmath38 for which there exists a @xmath222 with @xmath223 and @xmath224 . @xmath62",
    "@xmath221 contains all s - minimal sets of endogenous tuples that simultaneously ( and possibly accompanied by exogenous tuples ) make the query true .",
    "it is easy to see that @xmath219 and @xmath221 can be computed in polynomial time in the size of @xmath3 .",
    "now , generalizing a result for cqs in @xcite , actual causes for a ubcqs can be computed in ptime in the size of @xmath3 without computing contingency sets .",
    "[ pro : ubcqcausesindirect ] _ given @xmath225 and a ubcq @xmath2 ,  ( a )  @xmath0 is an actual cause for @xmath2 iff there is   @xmath226 with @xmath227 .",
    "( b ) the decision problem ( about membership of ) @xmath228 belongs to @xmath229 .",
    "@xmath62 _",
    "[ ex : al2 ] ( ex .",
    "[ ex : rc2cp ] cont . )",
    "consider the query @xmath230 , and assume that for @xmath3 ,  @xmath231 and @xmath232 .",
    "it holds @xmath233 . since @xmath234 ,  @xmath235",
    "so , @xmath236 is the only actual cause for @xmath237 .",
    "@xmath62      it is possible to develop a ( naive ) algorithm that accepts as input an instance @xmath37 , and a ubcq @xmath2 , and returns @xmath238 , and also , for each @xmath239 ,  its ( set of ) s - minimal contingency sets @xmath240 .",
    "the basis for the algorithm is a correspondence between the actual causes for @xmath2 with their contingency sets and a _ hitting - set problem_. is a collection of non - empty subsets of a set @xmath241 , a subset @xmath242 is a _ hitting set _ for @xmath71 if , for every @xmath243 , @xmath244 .",
    "@xmath245 is an s - minimal hs if no proper subset of it is also an hs .",
    "@xmath241 is a minimum hs is it has minimum cardinality . ]",
    "more precisely , for a fixed ubcq @xmath2 , consider the _ hitting - set framework _",
    "@xmath246 , with @xmath221 as in definition [ def : hsstuff ] .",
    "different decision problems can be imposed on it . the s - minimal _ hitting sets _ ( hss ) for @xmath247 correspond to actual causes with their s - minimal contingencies for @xmath2 .",
    "most responsible causes for @xmath2 are in correspondence with minimum hitting sets for @xmath247 .",
    "notice that these hitting sets are all subsets of @xmath38 .",
    "[ pro : ubcqcauses ] _ for @xmath225 and a ubcq @xmath2 , it holds :  ( a ) @xmath0 is an actual cause for @xmath2 with s - minimal contingency set @xmath4 iff @xmath248 is an s - minimal hs for @xmath247 .",
    "( b ) @xmath0 is a most responsible actual cause for @xmath2 with c - minimal contingency set @xmath4 iff @xmath248 is a minimum hs for @xmath247.@xmath62 _    [ ex : al1 ] ( ex .",
    "[ ex : rc2cp ] and [ ex : al2 ] cont . )   @xmath3 and @xmath2 are as before , but we now all tuples are endogenous . here , @xmath249 @xmath250 .",
    "@xmath247 has two s - minimal hss : @xmath251 and @xmath252 .",
    "each of them implicitly contains an actual cause ( any of its elements ) with an s - minimal contingency set ( what s left after removing the actual cause ) .",
    "@xmath253 is also the c - minimal hitting set , and contains the most responsible actual cause , @xmath236 .",
    "@xmath62    [ rem : hs]_for @xmath254 , @xmath221 can be computed in ptime , and its elements are bounded in size by @xmath255 , which is the maximum number of atoms in one of @xmath2 s disjuncts .",
    "this is a special kind of hitting - set problems .",
    "for example , deciding if there is a hitting set of size at most @xmath256 as been called the @xmath257-_hitting - set problem _",
    "@xcite , and @xmath257 is the bound on the size of the sets in the set class . in our case , @xmath257 would be @xmath255 .",
    "@xmath62 _",
    "corollary [ col : sr&cp ] and proposition [ pro : ubcqcauses ] can be used to compute repairs .",
    "if the classes of s- and c - minimal hss for @xmath247 ( with @xmath64 ) are available , computing s- and c - repairs will be in ptime in the sizes of those classes .",
    "however , it is well known that computing minimal hss is a complex problem . actually ,",
    "as example [ ex : repsvsconts ] implicitly shows , we can have exponentially many of them in @xmath258 ; so as exponentially many minimal repairs for a @xmath3 wrt . a denial constraint .",
    "so , the complexity of contingency sets computation is in line with the complexities of computing hitting sets and repairs .",
    "the computation of causes , contingency sets , and most responsible causes via minimal / minimum hs computation can then be used to compute repairs and decide about repair questions . since the hs problems in our case are of the @xmath257-hitting set kind , good algorithms and approximations for the latter ( cf .",
    "section [ sec : fpt ] ) could be used in the context of repairs ( all this via corollary [ col : sr&cp ] and proposition [ pro : ubcqcauses ] ) .",
    "consider an instance @xmath3 ( with all tuples endogenous ) and a set @xmath155 of dcs .",
    "for the disjunctive violation view @xmath162 , the following result is obtained from propositions [ pro : sr&cp ] and [ pro : cr&mrp ] , and corollary [ col : sr&cp ] .",
    "[ col : consinf ] _ for an instance @xmath3 and set dcs @xmath155 , it holds :  ( a ) for every @xmath259 , there is an s - repair that does not contain @xmath0 .",
    "( b ) for every @xmath260 , there is a c - repair that does not contain @xmath0 .",
    "( c ) for every @xmath261 and @xmath262 , @xmath263 and @xmath264 . @xmath62 _    for a projection - free , and a possibly non - boolean cq @xmath2 , we are interested in its consistent answers from @xmath3 wrt .",
    "@xmath155 . for example",
    ", for @xmath265 , the s - consistent ( c - consistent ) answers would be of the form @xmath266 , where @xmath267 and @xmath268 belong to all s - repairs ( c - repairs ) of @xmath3 . from corollary [ col : consinf ]",
    ", @xmath266 is an s - consistent , resp .",
    "c - consistent , answer iff @xmath267 and @xmath268 belong to @xmath3 , but they are not actual causes , resp .",
    "most responsible actual causes , for @xmath178 .",
    "[ pro : cqa ] _ for an instance @xmath3 , a set of dcs @xmath155 , and a projection - free cq @xmath269 :  ( a ) @xmath28 is an s - consistent answer iff , for each @xmath270 , @xmath271 .",
    "( b ) @xmath28 is a c - consistent answer iff , for each @xmath270 , @xmath272 .",
    "@xmath62 _",
    "[ ex : cqa1 ] ( ex .",
    "[ ex : rc2cp ] cont . ) consider @xmath273 .",
    "we had @xmath274 @xmath275 @xmath276 , @xmath197 .",
    "then , @xmath277 is both an s- and a c - consistent answer .",
    "@xmath62    notice that proposition [ pro : cqa ] can easily be extended to conjunction of ground atomic queries .",
    "actually , from it we obtain the following result that will be useful later on .",
    "[ cor : cqa&cox ] _ given @xmath3 , a set of dcs @xmath155 , the ground atomic query @xmath278 is c - consistently true if @xmath279 and it is not a most responsible cause for @xmath162.@xmath62 _    [ ex : cqa2 ] for @xmath280 and the dc @xmath281 : @xmath282 @xmath283 . from proposition",
    "[ pro : cqa ] , the ground atomic query @xmath284 is both s- and c - consistently true in @xmath3 wrt .",
    "@xmath32 , because , @xmath285 .",
    "@xmath62    the cqs considered in proposition [ pro : cqa ] and its corollary [ cor : cqa&cox ] are not the particularly interesting , but will use those results to obtain relevant results for causality later on , e.g. theorem [ the : cqa&ca&cox ] .",
    "let @xmath95 be an instance for schema @xmath12 , and @xmath96 , a bcq .",
    "assume @xmath2 is , possibly unexpectedly , true in @xmath3 .",
    "so , for the associated dc @xmath98 , @xmath100 .",
    "@xmath2 is our _ observation _ , for which we want to find explanations , using a consistency - based diagnosis approach .    for each predicate @xmath14",
    ", we introduce predicate @xmath286 , with the same arity as @xmath287 .",
    "a tuple in its extension is _ abnormal _ for @xmath287 .",
    "the  system description \" , @xmath76 , includes , among other elements , the original database , expressed in logical terms , and the dc being true  under normal conditions \" .",
    "more precisely , we consider the following _ diagnosis problem _ , @xmath288 , associated to @xmath2 .",
    "the fo system description , @xmath76 , contains the following elements :    \\(a ) @xmath289 , which is reiter s logical reconstruction of @xmath3 as a fo theory @xcite ( cf .",
    "example [ ex : mbdaex5 ] ) .",
    "\\(b ) sentence @xmath290 , which is @xmath99 rewritten as follows : @xmath291    this formula can be refined by applying the abnormality predicate , @xmath81 , to endogenous tuples only . for this",
    "we need to use additional auxiliary predicates @xmath292 , with the same arity of @xmath293 , which contain the endogenous tuples in @xmath287 s extension ( see example [ ex : mbdaex5 ] ) .",
    "\\(c )     the inclusion dependencies : @xmath294 ,  @xmath295 , and @xmath296 , for each @xmath14 .",
    "the last entry , @xmath2 , in @xmath297 is the _ observation _ ,",
    "which together with _ sd _ will produce and inconsistent theory , because we make the initial and explicit assumption that all the abnormality predicates are empty ( equivalently , that all tuples are normal ) , i.e. we consider , for each predicate @xmath287 , the sentence . ]",
    "@xmath298    where , * false * is a propositional atom that is always false .",
    "actually , the second entry in @xmath85 tells us how we can restore consistency , namely by ( minimally ) changing the abnormality condition on tuples in @xmath38 . in other words ,",
    "the rules ( [ eq : default ] ) are subject to qualifications : some endogenous tuples may be abnormal .",
    "each diagnosis shows an s - minimal set of endogenous tuples that are abnormal .",
    "[ ex : mbdaex5 ] ( ex .",
    "[ ex : cfex1 ] cont . ) for the instance @xmath299",
    "@xmath300 @xmath301 , with @xmath38 @xmath124 @xmath302 @xmath50 , consider the diagnostic problem @xmath303 @xmath304 , with @xmath76 containing :    \\(a ) predicate completion axioms :  @xmath305 ,  @xmath306 , + @xmath307 @xmath308 ,  @xmath309 .",
    "unique names assumption : @xmath310 .",
    "\\(b ) @xmath311 + @xmath312 .",
    "\\(c ) @xmath313 ,  @xmath314 , @xmath315 , + @xmath316 , @xmath317 ,  @xmath318 .",
    "the normality assumptions for tuples are :  @xmath319 @xmath320 ,  @xmath321 .",
    "@xmath62    now , the observation is @xmath2 ( being true ) , obtained by evaluating query @xmath2 on ( theory of ) @xmath3 . in this case , @xmath100 .",
    "since all the abnormality predicates are assumed to be empty , @xmath99 is equivalent to @xmath322 , which also becomes false wrt @xmath3 . as a consequence",
    ", @xmath323 is an inconsistent fo theory .",
    "a diagnosis is a set of endogenous tuples that , by becoming abnormal , restore consistency .",
    "[ def : diag ] ( a ) a _ diagnosis _ for @xmath85 is a @xmath324 , such that  @xmath325  is consistent .",
    "( b ) @xmath326 denotes the set of s - minimal diagnoses for @xmath85 that contain a tuple @xmath40 .",
    "( c ) @xmath327 denotes the set of c - minimal diagnoses in @xmath326 .",
    "@xmath62    by definition , @xmath328 .",
    "diagnoses for @xmath85 and actual causes for @xmath2 are related .",
    "[ pro : ac&diag ] _ consider @xmath112 , a bcq @xmath2 , and the diagnosis problem @xmath85 associated to @xmath2 .",
    "tuple @xmath40 is an actual cause for @xmath2 iff @xmath329 .",
    "@xmath62 _    the responsibility of an actual cause @xmath0 is determined by the cardinality of the diagnoses in @xmath327 .",
    "[ pro : r&diag ] _ for @xmath112 , a bcq @xmath2 , the associated diagnosis problem @xmath85 , and a tuple @xmath40 , it holds : ( a ) @xmath330 iff @xmath331 .",
    "( b ) otherwise , @xmath332 , where @xmath333 . @xmath62 _",
    "[ ex : mbdaex6 ] ( ex .",
    "[ ex : mbdaex5 ] cont . )",
    "@xmath85 has two diagnosis : @xmath334 and @xmath335 .  here , @xmath336 and @xmath337 @xmath338 .",
    "from propositions [ pro : ac&diag ] and [ pro : r&diag ] , @xmath52 and @xmath58 are actual cases , with responsibility @xmath57 .",
    "@xmath62    in consistency - based diagnosis , minimal diagnoses can be obtained as s - minimal hss of the collection of s - minimal _ conflict sets _",
    "section [ sec : prel ] ) @xcite . in our case ,",
    "conflict sets are s - minimal sets of endogenous tuples that , if not abnormal ( only endogenous ones can be abnormal ) , and together , and possibly in combination with exogenous tuples , make ( [ eq : ext ] ) false .",
    "it is easy to verify that the conflict sets of @xmath85 coincide with the sets in @xmath339 ( cf .",
    "definition [ def : hsstuff ] and remark [ rem : hs ] ) . as a consequence ,",
    "conflict sets for @xmath85 can be computed in ptime , the hss for @xmath85 contain actual causes for @xmath2 , and the hs problem for the diagnosis problems is of the @xmath257-hitting - set kind .",
    "the connection between consistency - based diagnosis and causality allows us , in principle , to apply techniques for the former , e.g. @xcite , to the latter .",
    "[ ex : mbdgrep ] ( ex . [ ex : mbdaex5 ] cont . )",
    "the diagnosis problem @xmath303 @xmath304 gives rise to the hs framework @xmath340 , with @xmath341 corresponding to the conflict set @xmath342 .",
    "@xmath247 has two minimum hss : @xmath343 and @xmath344 , which are the s - minimal diagnosis for @xmath297 .",
    "then , the two tuples are actual causes for @xmath2 ( cf . proposition   [ pro : ac&diag ] ) . from proposition",
    "[ pro : r&diag ] , @xmath345 . @xmath62",
    "the solutions to the diagnosis problem can be used for computing repairs .",
    "[ pro : diag ] _ consider a database instance @xmath3 with only endogenous tuples , a set of dcs of the form @xmath346 , and their associated  abnormality \" integrity constraints in ( [ eq : ext ] ) ( in this case we do not need @xmath347 atoms ) .",
    "each s - minimal diagnosis @xmath86 gives rise to an s - repair of @xmath3 , namely @xmath348 ; and every s - repair can be obtained in this way .",
    "similarly , for c - repairs using c - minimal diagnoses .",
    "@xmath62 _    [ ex : mbdaex6 + ] ( ex .",
    "[ ex : mbdaex6 ] cont . )",
    "the instance @xmath299",
    "@xmath300 @xmath301 has three ( both s- and c- ) repairs wrt . the dc @xmath349 , namely @xmath350 , @xmath351 , and @xmath352 .",
    "they can be obtained as @xmath353 @xmath354 from the only ( s- and c- ) diagnoses , @xmath334 , @xmath335 , @xmath355 , resp .",
    "@xmath62    the kind of diagnosis problem we introduced above can be formulated as a _ preferred - repair problem _ @xcite ( see @xcite for a general approach to prioritized repairs ) . for this , it is good enough to materialize tables for the auxiliary predicates @xmath286 and @xmath347 , and consider the dcs of the form ( [ eq : ext ] ) ( with the @xmath347 atoms if not all tuples are endogenous ) , plus the dcs ( [ eq : default ] ) .",
    "the initial extensions for the @xmath286 predicates are empty . if @xmath3 is inconsistent wrt .",
    "this set of dcs , the s - repairs that are obtained by only _ inserting _ endogenous tuples into the extensions of the @xmath286 predicates correspond to s - minimal diagnosis , and each s - minimal diagnosis can be obtained in this way .",
    "there are three main computational problems in database causality . for a bcq @xmath2 and database @xmath3 , they are : ( a ) the _ causality problem _ ( cp )",
    "that is about computing the actual causes for @xmath2 .",
    "( b ) the _ responsibility problem _ ( rp ) that is about computing the responsibility @xmath44 of a given actual cause @xmath0 . since a tuple that is not an actual cause has responsibility @xmath47 , the latter problem subsumes the former .",
    "( c ) computing the _ most responsible actual causes _ ( mrc ) .",
    "these problems have corresponding _",
    "decision versions_. both cp and its decision version , cpd , are solvable in polynomial time @xcite , which can be extended to ubcqs ( cf .",
    "proposition [ pro : ubcqcausesindirect ] ) .",
    "we consider the decision version of the second problem .",
    "[ def : resp ] for a bcq @xmath2 , the _ responsibility decision problem _ ( rpd ) is ( deciding about membership of )   @xmath356 @xmath357  and  @xmath358 .",
    "@xmath62    the complexity analysis of rpd in @xcite is restricted to conjunctive queries without self - joins , for which a dichotomy result holds :  depending on the syntactic structure of a query , rpd is either in ptime or is np - hard . here",
    ", we generalize the complexity analysis for rpd to general cqs .",
    "we will also investigate the decision version , mrcd , of mrc , i.e. about deciding most responsible actual causes .",
    "this is a natural problem , because actual causes with the highest responsibility tend to provide most interesting explanations for query answers @xcite .",
    "[ def : mracp ] for a bcq @xmath2 , the _ most responsible cause decision problem _ is @xmath359 @xmath360 .",
    "@xmath62    we start by analyzing a more basic decision problem : _ s - minimal contingency checking _ ( mccd ) .",
    "[ def : cusp ] for a bcq @xmath2 , @xmath361 @xmath362  ( cf .",
    "( [ eq : ct ] ) ) .",
    "@xmath62    due to the results in sections [ sec : causfrepair ] and [ sec : repairfcauses ] , it clear that there is a close connection between mccd and the _ s - repair checking _",
    "problem in consistent query answering @xcite , about deciding if instance @xmath6 is an s - repair of instance @xmath3 wrt .",
    "a set of integrity constraints .",
    "actually , the following result is obtained from the membership of the s - repair checking problem of logspace for dcs ( * ? ? ?",
    "[ pro : cspccpx ] _ for a bcq @xmath2 , @xmath363 .",
    "@xmath62 _",
    "we could also consider the decision problem defined as in definition [ def : cusp ] , but with c - minimal @xmath4 .",
    "we will not use results about this problem in the following .",
    "furthermore , its connection with the c - repair checking problem is less direct .",
    "as one can see from section [ sec : causfrepair ] , c - minimal contingency sets correspond to a repair semantics somewhere between the s - minimal and c - minimal repair semantics ( a subclass of _ srep _ , but a superclass of _ crep _ ) :  it is about an s - minimal repair with minimum cardinality that does not contain a particular tuple .",
    "now we establish that rpd is _",
    "np_-complete for cqs in general .",
    "the _ np_-hardness is shown in @xcite .",
    "membership of _ np _ is obtained using proposition [ pro : cspccpx ] .    [ the : rp(d)cmx ] _ ( a ) for every bcq @xmath2 , @xmath364 .",
    "( b ) @xcite  there are cqs @xmath2 for which @xmath365 is _ np_-hard . @xmath62 _    in order to better understand the complexity of the problem , rp , of computing responsibility , we will investigate the _ functional _ , non - decision version of the problem .    the main source of complexity when computing responsibilities is related to the hitting - set problem associated to @xmath246 in remark [ rem : hs ] . in this case",
    ", it is about computing the cardinality of a minimum hitting set that contains a given vertex ( tuple ) @xmath0 . that this is a kind of _ @xmath257-hitting - set problem _",
    "@xcite will be useful in section [ sec : fpt ] .",
    "our responsibility problem can also be seen as a _",
    "vertex cover problem _ on the _ hypergraph _ @xmath366 associated to @xmath246 . in it ,",
    "the set of hyperedges @xmath367 coincides with the collection @xmath221 .",
    "determining the responsibility of a tuple @xmath0 becomes the problem on hypergraphs of determining the size of a minimum vertex cover ( vc ) that contains vertex @xmath0 ( among all vcs that contain the vertex ) .",
    "again , in this problem the hyperedges are bounded by @xmath255 .",
    "[ ex : hyperexm ] for @xmath368 , and @xmath369 @xmath370 ,  @xmath371 .",
    "@xmath3 is the set of vertices of hypergraph @xmath372 , and its hyperedges are @xmath373 , @xmath374 .",
    "the following are the minimal vcs : @xmath375 , @xmath376 @xmath370 , @xmath377 .",
    "then , @xmath378 is an actual cause with responsibility @xmath57 .",
    "the other tuples are actual causes with responsibility @xmath56 . @xmath62    _ to simplify the presentation",
    ", we will formulate and address our computational problems as problems for graphs ( instead of hypergraphs ) .",
    "however , our results still hold for hypergraphs @xcite .",
    "actually , the following _ representation lemma _ holds .",
    "_    [ lemma : resclx ] _ there is a fixed database schema @xmath12 and a bcq @xmath379 , without built - ins , such that , for every graph @xmath380 and @xmath381 , there is an instance @xmath3 for @xmath12 and a tuple @xmath382 , such that the size of a minimum vc of @xmath383 containing @xmath384 equals the responsibility of @xmath0 as an actual cause for @xmath2.@xmath62 _    having represented our responsibility problem as a graph - theoretic problem , we first consider the following _ membership minimal vc problem _ ( mmvc ) : given a graph @xmath380 , a vertex @xmath385 , determine the size of a minimum vc of @xmath383 that contains @xmath384 .",
    "[ lemma : mmvcand ] _ given a graph @xmath383 and a vertex @xmath384 in it , there is a graph @xmath386 extending @xmath383 that can be constructed in polynomial time in @xmath387 , such that the size of a minimum vc for @xmath383 that contains @xmath384 and the size of a minimum vc for @xmath386 coincide.@xmath62 _    from this lemma and the @xmath94-completeness of determining the size of a maximum clique in a graph @xcite , we obtain :    [ pro : mmvccml ] _ mmvc problem for graphs is @xmath94-complete .",
    "@xmath62 _    from lemma [ lemma : resclx ] and proposition [ pro : mmvccml ]",
    "we obtain the complexity result for rp .",
    "membership can also be obtained from theorem [ the : rp(d)cmx ] .    [ the : r&diag ] _ ( a ) for every bcq without built - ins , @xmath2 , computing the responsibility of a tuple as a cause for @xmath2 is in @xmath388 .",
    "( b ) there is  a database schema and a bcq @xmath2 , without built - ins , such that computing the responsibility of a tuple as a cause for @xmath2 is @xmath94-complete . @xmath62",
    "_    now we address the most responsible causes problem , mrcd .",
    "we use the connection with consistent query answering of section [ sec : cqa ] , namely corollary [ cor : cqa&cox ] , and the @xmath389-completeness of consistent query answering under the c - repair semantics for queries that are conjunctions of ground atoms and a particular dc ( * ? ? ?",
    "4 ) .    [ the : cqa&ca&cox ] _ ( a ) for every bcq without built - ins , @xmath390 .",
    "( b ) there is a database schema and a bcq @xmath2 , without built - ins , for which @xmath359 is @xmath8-complete .",
    "@xmath62 _    from proposition [ pro : ubcqcauses ] and the @xmath391-completeness of determining the size of c - repairs for dcs ( * ? ? ?",
    "3 ) , we obtain the following for the computation of the highest responsibility value .    [ pro : crepair&res&cox ] _ ( a ) for every bcq without built - ins , computing the responsibility of the most responsible causes is in @xmath391 .",
    "( b ) there is a database schema and a bcq @xmath2 , without built - ins , for which computing the responsibility of the most responsible causes is @xmath391-complete . @xmath62 _      we need to cope with the intractability of computing most responsible causes .",
    "the area of _ fixed parameter tractability _ ( fpt )",
    "@xcite provides tools to attack this problem . in this regard",
    ", we recall that a decision problem with inputs of the form @xmath392 , where @xmath393 is a distinguished parameter of the input , is fixed parameter tractable ( or belongs to the class fpt ) , if it can be solved in time @xmath394 , where @xmath82 and the hidden constant do not depend on @xmath395 or @xmath396 , and @xmath397 does not depend on @xmath396 .    in our case , the _ parameterized version of the decision problem _ @xmath365 ( cf .",
    "definition [ def : resp ] ) is denoted with @xmath398 , and the distinguished parameter is @xmath256 , such that @xmath399 . that @xmath398 belongs to fpt can be obtained from its formulation as a @xmath257-hitting - set problem ( @xmath257 being the fixed upper bound on the size of the sets in the set class ) ; in this case about deciding if there is a hs that contains the given tuple @xmath0 that has cardinality smaller that @xmath256 .",
    "this problem belongs to fpt .",
    "[ the : fpt ] _ for every bcq @xmath2 , @xmath398 belongs to fpt , where the parameter is the inverse of the responsibility bound .",
    "@xmath62 _",
    "the proof of this result is interesting _ per se _ , and we sketch it here .",
    "first , there is a ptime parameterized algorithm for the @xmath257-hitting - set problem about deciding if there is a hs of size at most @xmath256 that runs in time @xmath400 , with @xmath15 the size of the underlying set and @xmath401 @xcite . in our case , @xmath402 , and @xmath403  ( cf .",
    "also @xcite ) .    now , to decide if the responsibility of a given tuple @xmath0 is greater than @xmath404 , we consider the associated hypergraph @xmath372 , and we decide if it has a vc that contains @xmath0 and whose size is less than @xmath256 .",
    "in order to answer this , we use lemma [ lemma : mmvcand ] , and build the extended hypergraph @xmath405 .",
    "the size of a minimum vc for @xmath405 gives the size of the minimum vc of @xmath372 that contains @xmath0 . if @xmath372 has a vc that contains @xmath0 of size less than @xmath256 , then @xmath405 has a vc of size less than @xmath256 .",
    "if @xmath405 has a vc of size less than @xmath256 , its minimum size for a vc is less than @xmath256 .",
    "since this minimum is the same as the size of a minimum vc for @xmath372 that contains @xmath0 , @xmath372 has a vc of size less than @xmath256 that contains @xmath0 . as a consequence ,",
    "it is good enough to decide if @xmath405 has a vc of size less than @xmath256 . for this",
    ", we use the hs formulation of this hypergraph problem , and the already mentioned fpt algorithm .    this result and",
    "the corresponding algorithm show that the higher the required responsibility degree , the lower the computational effort needed to compute the actual causes with at least that level of responsibility . in other terms , parameterized algorithms are effective for computing actual causes with high responsibility or most responsible causes . in general , parameterized algorithms are very effective when the parameter is relatively small @xcite .",
    "now , in order to compute most responsible causes , we could apply , for each actual cause @xmath0 , the just presented fpt algorithm on the hypergraph @xmath372 , starting with @xmath406 , i.e. asking if there is vc of size less than @xmath57 that contains @xmath0 .",
    "if the algorithm returns a positive result , then @xmath0 is a counterfactual cause , and has responsibility @xmath57 .",
    "otherwise , the algorithm will be launched with @xmath407 , until a positive result is returned .",
    "( the procedure can be improved through binary search on @xmath408 , with @xmath409 possibly much smaller than @xmath258 . )    the complexity results and algorithms provided in this section can be extend to ubcqs .",
    "this is due to remark [ rem : ucq ] and the construction of @xmath221 , which the results in this section build upon .",
    "for the @xmath257-hitting - set problem there are also efficient parameterized approximation algorithms @xcite .",
    "they could be used to approximate the responsibility problem .",
    "furthermore , approximation algorithms developed for the minimum vc problem on bounded hypergraphs @xcite should be applicable to approximate most responsible causes for query answers . via the causality / repair connection ( cf .",
    "section [ sec : cqa ] ) , it should be possible to develop approximation algorithms to compute s - repairs of particular sizes , c - repairs , and consistent query answers wrt .",
    "dcs .      in @xcite",
    "the class of _ linear _ cqs is introduced . for them , computing tuple responsibilities is tractable . roughly speaking , a bcq is linear if its atoms can be ordered in a way that every variable appears in a continuous sequence of atoms , e.g. @xmath410 is linear , but not @xmath411 , for which rpd is _",
    "np_-hard @xcite . the class of bcqs for which computing responsibility ( more precisely , our @xmath412 decision problem ) is tractable can be extended to _",
    "weakly linear_. now , the dichotomy result in @xcite says that for a bcq @xmath2 without self - joins , rdp is tractable when @xmath2 is weakly - linear , but _",
    "np_-hard , otherwise .",
    "due to the causality / repair connection of section [ sec : repairfcauses ] , we can obtain the following results for database repairs .",
    "[ theo : dichotomy ] _ ( a ) for single weakly - linear dcs , c - repair checking and deciding if the size of a c - repair is larger than a bound are both tractable .",
    "is weakly - linear if the corresponding bcq @xmath207 is weakly - linear . in this way",
    "any adjective that applies to bcqs can be applied to dcs . ]",
    "+ ( b ) for single , self - join free dcs @xmath32 , and the problem @xmath413 of deciding if there is a repair @xmath6 for a given input instance @xmath3 and a tuple @xmath414 with @xmath415 and @xmath416 , is a subset of @xmath3 that satisfies @xmath32 . here ,",
    "@xmath417 . ]",
    "the following dichotomy holds : ( b1 ) if @xmath32 is weakly - linear , @xmath413 is tractable .",
    "( b2 ) otherwise , it is _ np_-complete . @xmath62 _",
    "this dichotomy result for repairs shows that interesting results in one of the areas ( causality , in this case ) have counterparts in some of the others .",
    "the form the reincarnation of the known result takes in the new area ( repairs , in this case ) is interesting _ per se_.    notice that both problems in ( a ) in theorem [ theo : dichotomy ] may be intractable even for single dcs @xcite .",
    "more specifically , c - repair checking can be _",
    "conp_-hard for single dcs @xcite .",
    "actually , the single dc used in ( * ? ? ?",
    "* lemma 4 ) is of the form @xmath418 , whose associated bcq is not weakly - linear . as a matter of fact , this bcq is a _",
    "np_-hard for rdp @xcite .",
    "in this research we have unveiled and formalized some first interesting relationships between causality in databases , database repairs , and consistency - based diagnosis . these connections allow us to apply results and techniques developed for each of them to the others .",
    "this is particularly beneficial for causality in databases , where still a limited number of results and techniques have been obtained or developed .",
    "the connections we established here inspired complexity results for causality , e.g. theorems [ the : r&diag ] and [ the : cqa&ca&cox ] , and were used to prove them .",
    "we appealed to several non - trivial results ( and the proofs thereof ) about repairs / cqa obtained in @xcite .",
    "it is also the case that the well - established hitting - set approach to diagnosis inspired a similar approach to causal responsibility , which in its turn allowed us to obtain results about its fixed - parameter tractability .",
    "it is also the case that diagnostic reasoning , as a form of non - monotonic reasoning , can provide a solid foundation for causality in databases and query answer explanation , in general @xcite .    our work creates a theoretical basis for deeper and mathematically more complex investigations . in particular , it also opens interesting research directions , some of which are briefly discussed below .",
    "* preferred causes for queries . * in section [ sec : causfrepair ] we characterized causes and most responsible causes in terms of s - repairs and c - repairs , resp .",
    "this could be generalized by using the notion of _ preferred repair _",
    "these are repairs whose minimization correspond to a _ priority relationship _ , @xmath419 , between instances .",
    "let assume it defines a corresponding class of preferred repairs , @xmath420 .",
    "inspired by ( [ eq : df ] ) , we can define , for a bcq @xmath2 :  @xmath421 @xmath422 , and , @xmath40 is a  @xmath419-cause iff @xmath423 . in this way",
    ", a whole class of preferences on causes can be introduced , which is natural problem @xcite .    * endogenous repairs . *  the partition of a database into endogenous and exogenous tuples may also be of interest in the context of repairs . considering that we should have more control on endogenous tuples than on exogenous ones , which may come from external sources",
    ", it makes sense to consider _ endogenous repairs_. they are obtained by updates ( of any kind ) on endogenous tuples .",
    "for example , in the case of dcs , endogenous repairs would be obtained by deleting endogenous tuples only .",
    "if there are no repairs based on endogenous tuples , a preference condition could be imposed on repairs @xcite , privileging those that change exogenous the least .",
    "( of course , it could also be the other way around , that is we may feel more inclined to change exogenous tuples than our endogenous ones . )    as a further extension , it could be possible to assume that combinations of ( only ) exogenous tuples never violate the integrity constraints , which could be checked at upload time . in this sense",
    ", there would be a part of the database that is considered to be consistent , while the other is subject to possible repairs .",
    "( for slightly related research , see @xcite . )    * objections to causality .",
    "* causality as introduced by halpern and pearl in @xcite , aka .",
    "hp - causality , is the basis for the notion of causality in @xcite .",
    "hp - causality has been the object of some criticism @xcite , which is justified in some ( more complex , non - relational ) settings , specially due to the presence of different kinds of _ logical variables _ ( or lack thereof ) .",
    "in our context the objections do not apply : variables just say that a certain tuple belongs to the instance ( or not ) ; and for relational databases the closed - world assumption applies . in @xcite ,",
    "the definition of hp - causality is slightly modified . in our setting , this modified definition does not change actual causes or their properties .    *",
    "asp specification of causes .",
    "*   s - repairs can be specified by means of _ answer set programs _ ( asps ) @xcite , and c - repairs too , with the use of weak program constraints @xcite .",
    "this should allow for the introduction of asps in the context of causality , for specification and reasoning .",
    "there are also asp - based specifications of diagnosis @xcite that could be brought into a more complete picture .    *",
    "causes and functional dependencies , and beyond .",
    "*  functional dependencies are dcs with conjunctive violation views with inequality , and are still monotonic .",
    "there is much research on repairs and consistent query answering for functional dependencies , and more complex integrity constraints @xcite . in causality ,",
    "mostly cqs without built - ins have been considered .",
    "the repair connection could be exploited to obtain results for causality and cqs with inequality , and also other classes of queries .",
    "* view updates and abduction .",
    "*  abduction @xcite is another form of model - based diagnosis , and is related to the subjects investigated in this work.the _ view update problem _ , about updating a database through views , is a classical problem in databases that has been treated through abduction @xcite .",
    "user knowledge imposed through view updates creates or reflects _ uncertainty _ about the base data , because alternative base instances may give an account of the intended view updates .",
    "the view update problem , specially in its particular form of of _ deletion propagation _ , has been recently related in @xcite to causality as introduced in @xcite .",
    "( notice only tuple deletions are used with violation views and repairs associated to dcs . )",
    "database repairs are also related to the view update problem . actually , _ answer set programs _ ( asp ) for database repairs",
    "@xcite implicity repair the database by updating intentional , annotated predicates .",
    "even more , in @xcite , in order to protect sensitive information , databases are explicitly and virtually  repaired \" through secrecy views that specify the information that has to be kept secret .",
    "these are prioritized repairs that have been specified via asps .",
    "abduction has been explicitly applied to database repairs @xcite .",
    "the deep interrelations between causality , abductive reasoning , view updates and repairs are the objects of our ongoing research efforts @xcite .",
    "* acknowledgments : *  research funded by nserc discovery , and the nserc strategic network on business intelligence ( bin ) . conversations with alexandra meliou during leo bertossi s visit to u. of washington in 2011 are much appreciated .",
    "he is also grateful to dan suciu and wolfgang gatterbauer for their hospitality .",
    "l. bertossi is grateful to benny kimelfeld for stimulating conversations .",
    "part of the research was developed by l. bertossi at _ logicblox _ and _ the center for semantic web research _ ( chile ) .",
    "their support is much appreciated .    10    afrati , f. and kolaitis , p. repair checking in inconsistent databases : algorithms and complexity .",
    "31 - 41 .",
    "arenas , m. , bertossi , l. and chomicki , j. consistent query answers in inconsistent databases .",
    ", 1999 , pp .",
    "68 - 79 .",
    "arenas ,  m. , bertossi ,  l. and chomicki ,  j. answer sets for consistent query answers .",
    "_ theory and practice of logic programming _ , 2003 , 3(4&5):393 - 424 .",
    "arenas , m. , bertossi , l. , chomicki , j. , he , x. , raghavan , v. and spinrad , j. scalar aggregation in inconsistent databases . , 2003 , 296:405 - 434 .",
    "arieli ,  o. , denecker ,  m. , van nuffelen ,  b. and bruynooghe ,  m. coherent integration of databases by abductive logic programming .",
    "_ j. artif .",
    "_ , 2004 , 21:245 - 286 .",
    "barcelo ,  p. , bertossi ,  l. and bravo ,  l. characterizing and computing semantically correct answers from databases with annotated logic and answer sets . in _ semantics of databases _ , springer lncs 2582 , 2003 , pp . 1 - 27 .",
    "bertossi , l. consistent query answering in databases . , 2006 , 35(2):68 - 76 .",
    "bertossi ,  l. and li ,  l. achieving data privacy through secrecy views and null - based virtual updates .",
    "_ ieee transaction on knowledge and data engineering _ , 2013 , 25(5):987 - 1000 .",
    "bertossi , l. .",
    "morgan & claypool , synthesis lectures on data management , 2011 .",
    "bertossi ,  l. and salimi ,  b. unifying causality , diagnosis , repairs and view - updates in databases .",
    "presented at the first international workshop on big uncertain data ( buda 2014 ) .",
    "corr arxiv paper cs.db/1405.4228 .",
    "brankovic , l. , and h. fernau , h. parameterized approximation algorithms for hitting set . in _ approximation and online algorithms _ , 2012 ,",
    "springer lncs 7164 , pp .",
    "63 - 76 .",
    "buneman , p. , khanna , s. and tan , w.  c. why and where : a characterization of data provenance . , 2001 , pp .",
    "316330 .",
    "buneman , p. and tan , w.  c. provenance in databases . , 2007 , pp .",
    "11711173 .",
    "cheney , j. , chiticariu , l. and tan , w.  c. provenance in databases : why , how , and where .",
    ", 2009 , 1(4 ) : 379 - 474 .",
    "cheney , j. , chong , s. , foster , n. , seltzer , m.  i. and vansummeren , s. provenance : a future history .",
    ", 2009 , pp . 957964 .",
    "cheney , j. is provenance logical ?",
    ", 2011 , pp . 26 .",
    "chomicki , j. and marcinkowski , j. minimal - change integrity maintenance using tuple deletions . , 2005 , 197(1 - 2):90 - 121 .",
    "chockler , h. and halpern , j.  y. responsibility and blame : a structural - model approach . , 2004 , 22:93 - 115 .",
    "console ,  l. and torasso ,  p. a spectrum of logical definitions of model - based diagnosis .",
    "_ computational intelligence _ , 1991 , 7:133 - 141",
    "console , l. , sapino m.  l. and theseider - dupre ,  d. the role of abduction in database view updating .",
    ", 1995 , 4(3 ) : 261 - 280 .",
    "cui , y. , widom , j. and wiener , j.  l. tracing the lineage of view data in a warehousing environment . , 2000",
    ", 25(2):179 - 227 .",
    "eiter , t. , gottlob , g. and leone , n. abduction from logic programs : semantics and complexity . , 1997 , 189(1 - 2):129 - 177 .",
    "eiter ,  th . , faber ,  w. , leone ,  n. and pfeifer ,  g. the diagnosis frontend of the dlv system . _ ai commun .",
    "_ , 1999 , 12(1 - 2):99 - 111 .",
    "fernau , h. parameterized algorithmics for _ d_-hitting set . , 2010",
    ", 87(14):3157 - 3174 .",
    "feldman , a. , provan g. , and gemund a.v .",
    "approximate model - based diagnosis using greedy stochastic search .",
    ", 2010 , 87(14):3157 - 3174 .",
    "flum , j. and grohe , m. _ parameterized complexity theory_. texts in theoretical computer science , springer verlag , 2006 .",
    "gertz , m. diagnosis and repair of constraint violations in database systems .",
    "phd thesis , universitt hannover , 1996 .",
    "greco ,  s. , pijcke ,  f. and wijsen ,  j. certain query answering in partially consistent databases .",
    "_ pvldb _ , 2014 , 7(5):353 - 364 .",
    "halpern ,  j. , and pearl ,  j. causes and explanations : a structural - model approach : part 1 , 2001 , pp .",
    "194 - 202 .",
    "halpern ,  j. , and pearl ,  j. causes and explanations : a structural - model approach : part 1 .",
    ", 2005 , 56:843 - 887 .",
    "halperin , e. improved approximation algorithms for the vertex cover problem in graphs and hyper - graphs .",
    ", 2000 , pp .",
    "329 - 337 .",
    "halpern ,  j. appropriate causal models and stability of causation .",
    "kr14 , 2014 .",
    "kakas a.  c. and mancarella ,  p. database updates through abduction . , 1990 ,",
    "650 - 661 .",
    "karvounarakis , g. and green , t.  j. semiring - annotated data : queries and provenance ? , 2012 , 41(3):5 - 14 .",
    "krentel , m. the complexity of optimization problems . , 1988 , 36:490 - 509 .",
    "karvounarakis , g. ives , z.  g. and tannen , v. querying data provenance . , 2010 , pp .",
    "951962 .",
    "kimelfeld , b. a dichotomy in the complexity of deletion propagation with functional dependencies .",
    "acm pods , 2012 .",
    "kimelfeld , b. , vondrak , j. and williams , r. maximizing conjunctive views in deletion propagation .",
    "acm trans .",
    "database syst .",
    "_ , 2012 , 37(4):24 .",
    "lopatenko , a. and bertossi , l. complexity of consistent query answering in databases under cardinality - based and incremental repair semantics . , 2007 , springer lncs 4353 , pp .",
    "179 - 193 .",
    "meliou , a. , gatterbauer , w. and suciu , d. bringing provenance to its full potential using causal reasoning . , 2011 .",
    "meliou , a. , gatterbauer , w. moore , k.  f. and suciu , d. the complexity of causality and responsibility for query answers and non - answers . , 2010 , pp .",
    "34 - 41 .",
    "meliou , a. , gatterbauer .",
    "w. , halpern , j.  y. , koch , c. , moore k.  f. and suciu , d. causality in databases .",
    ", 2010 , 33(3):59 - 67 .",
    "mozetic , i , holzbaur , c. controlling the complexity in model - based diagnosis , 1994 , 11(1 - 4 ) : 297 - 314 .",
    "niedermeier , r. and rossmanith , p. an efficient fixed - parameter algorithm for 3-hitting set . in _ j. discrete algorithms _ , 2003 1(1):89 - 102 .",
    "okun , m. on approximation of the vertex cover problem in hypergraphs . in _",
    "discrete optimization _ , 2005,2(1):101 - 111 .",
    "papadimitriou ,  ch .",
    "_ computational complexity_. addison - wesley , 1994 .",
    "reiter , r. a theory of diagnosis from first principles .",
    ", 1987 , 32(1):57 - 95 .",
    "reiter , r. towards a logical reconstruction of relational database theory .",
    "in _ on conceptual modelling _ ,    springer , 1984 , pp .",
    "191 - 233 .",
    "salimi , b. and bertossi , l. causality in databases : the diagnosis and repair connections . presented at _ the 15th international workshop on non - monotonic reasoning ( nmr 2014)_. corr arkiv paper cs.db/1404.6857 , 2014 .",
    "staworko ,  s. , chomicki ,  j. and marcinkowski ,  j. prioritized repairing and consistent query answering in relational databases . , 2012 , 64(2 - 3):209 - 246 .",
    "struss , p. model - based problem solving . in _ handbook of knowledge representation _ , chap . 10 .",
    "elsevier , 2008 .",
    "tannen , v. provenance propagation in complex queries . in _",
    "buneman festschrift _ , 2013 , springer lncs 8000 , pp .",
    "483 - 493 .",
    "yakout ,  m. , elmagarmid ,  a. , neville ,  j. , ouzzani ,  m. and ilyas ,  i. guided data repair .",
    "_ pvldb _ , 2011 , 4(5):279 - 289 .",
    "* proof of proposition [ pro : ubcqcausesindirect]:*assume @xmath424 , and there exists a @xmath425 s.t .",
    "@xmath227 . consider a set @xmath43 such that , for all @xmath426 where @xmath427 , @xmath428 and @xmath429 .",
    "with such a @xmath4 , @xmath0 is an actual cause for @xmath2 with contingency set @xmath4 .",
    "so , it is good enough to prove that such @xmath4 always exists .",
    "in fact , since all subsets of @xmath221 are s - minimal , then , for each @xmath426 with @xmath427 , @xmath430 . therefore , @xmath4 can be obtained from the set of difference between each @xmath431 and @xmath167 .",
    "now , if @xmath0 is an actual cause for @xmath2 , then there exist an s - minimal @xmath432 , such that @xmath433 , but @xmath434 .",
    "this implies that there exists an s - minimal subset of @xmath435 , such that @xmath436 and @xmath437 . due to the s - minimality of @xmath4 ,",
    "it is easy to see that @xmath0 is included in a subset of @xmath221 .",
    "@xmath62 +      * proof of propositions [ pro : ac&diag ] and [ pro : r&diag ] : * it is easy to verify that the conflict sets of @xmath85 coincide with the sets in @xmath339 ( cf",
    ". definition [ def : hsstuff ] ) .",
    "the results obtained from the characterization of minimal diagnosis as minimal hitting sets of sets of conflict sets ( cf .",
    "section [ sec : prel ] and @xcite ) and proposition [ pro : ubcqcauses ] .",
    "@xmath62 +    * proof of proposition [ pro : cspccpx]:*we provide a ptime algorithm to decide if @xmath438 .",
    "consider @xmath3 and the dc @xmath99 associated to @xmath2 ( cf .",
    "section [ sec : causfrepair ] ) . @xmath438",
    "iff @xmath439 is an s - repair for @xmath3 ( which follows from the proof of proposition [ pro : c&r ] ) .",
    "repair checking can be done in logespace ( * ? ? ?",
    "5 ) , therefore the decision can be made in ptime .",
    "@xmath62 +    * proof of theorem [ the : rp(d)cmx]:*we describe a non - deterministic ptime algorithm to decide rpd .",
    "non - deterministically guess a subset @xmath43 , return _ yes _ if @xmath440 and @xmath441 ; otherwise return _",
    "no_. according to proposition [ pro : cspccpx ] this can be done in ptime in data complexity .",
    "@xmath62 +    * proof of lemma [ lemma : resclx ] : * consider a graph @xmath442 , and assume the vertices of @xmath383 are uniquely labeled . consider the database schema with relations , @xmath443 and @xmath444 , and the conjunctive query @xmath445 .",
    "@xmath446 stores the vertices of @xmath383 , and @xmath447 , the labeled edges .",
    "for each edge @xmath448 , @xmath447 contains @xmath15 tuples of the form @xmath449 , where @xmath15 is the number of vertices in @xmath383 .",
    "all the values in the third attribute of @xmath447 are different , say from 1 to @xmath450 .",
    "the size of the database instance obtained through this padding of @xmath383 is still polynomial in size .",
    "it is clear that @xmath26 .",
    "assume @xmath451 is the minimum vertex cover of @xmath383 that contains the vertex @xmath384 .",
    "consider the set of tuples @xmath452 . since @xmath453 , @xmath454 .",
    "then , @xmath455 .",
    "this is because for every tuple @xmath456 in the instance , either @xmath457 or @xmath458 belongs to @xmath459 .. due to the minimality of @xmath451 , @xmath460 .",
    "therefore , tuple @xmath461 is an actual cause for @xmath2 .",
    "suppose , @xmath4 is a c - minimal contingency set associated to @xmath462 .",
    "due to the c - minimality of @xmath4 , it entirely consists of tuples in @xmath446 .",
    "it holds that @xmath463 and @xmath464 .",
    "consider the set @xmath465 . since @xmath466 , for every tuple @xmath456 in @xmath3 , either @xmath467 or @xmath468 .",
    "therefore , @xmath469 is a minimum vertex cover of @xmath383 that contains @xmath384 .",
    "it holds that @xmath470 .",
    "so the size of a minimum vertex cover of @xmath383 that contains @xmath384 can be obtained from @xmath471 .",
    "@xmath62 +    * proof of lemma [ lemma : mmvcand]:*the size of @xmath472 , the minimum vertex cover of @xmath383 that contains the vertex @xmath384 , can be computed from the size of @xmath473 , the maximum independent set of @xmath383 , that does not contains @xmath384 . in fact , @xmath474 since @xmath475 is a maximum independent set that does not contain @xmath384 , it must contain one of the adjacent vertices of @xmath384 ( otherwise , @xmath475 is not maximum , and @xmath384 can be added to @xmath475 ) .",
    "therefore , @xmath476 can be computed from the size of a maximum independent set @xmath475 that contains @xmath477 , one of the adjacent vertices of @xmath384 .    given a graph @xmath383 and a vertex @xmath477 in it , a graph @xmath386 that extends @xmath383",
    "can be constructed in polynomial time in the size of @xmath383 , such that there is a maximum independent set @xmath475 of @xmath383 containing @xmath477 iff @xmath477 belongs to every maximum independent set of @xmath386 iff the sizes of maximum independent sets for @xmath383 and @xmath386 differ by one ( * ? ? ?",
    "* lemma 1 ) ) .",
    "actually , the graph @xmath386 in this lemma can be obtained by adding a new vertex @xmath478 that is connected only to the neighbors of @xmath477 .",
    "its holds : @xmath479 is a minimum vertex cover of @xmath386 . from ( [ one ] ) ,",
    "( [ two ] ) and ( [ three ] ) , we obtain : @xmath480 .",
    "@xmath62 +    * proof of proposition [ pro : mmvccml]:*we prove membership by describing an algorithm in @xmath94 for computing the size of the minimum vertex cover of a graph @xmath380 that contains a vertex @xmath385 .",
    "we use lemma [ lemma : mmvcand ] , and build the extended graph @xmath386 .",
    "the size of a minimum vc for @xmath386 gives the size of the minimum vc of @xmath383 that contains @xmath384 .",
    "since computing the maximum cardinality of a clique can be done in time @xmath94 @xcite , computing a minimum vertex cover can be done in the same time ( just consider the complement graph ) .",
    "therefore , mmvc belong to @xmath481 .",
    "hardness can be obtained by a reduction from computing minimum vertex covers in graphs to mmvc .",
    "given a graph @xmath383 construct the graph @xmath386 as follows : add a vertex @xmath384 to @xmath383 and connect it to all vertices of @xmath383 .",
    "it is easy to see that @xmath384 belongs to all minimum vertex covers of @xmath386 .",
    "furthermore , the sizes of minimum vertex covers for @xmath383 and @xmath386 differ by one .",
    "consequently , the size of a minimum vertex cover of @xmath383 can be obtained from the size of a minimum vertex cover of @xmath386 that contains @xmath384 .",
    "computing the minimum vertex cover is @xmath94-complete .",
    "this follows from the @xmath94-completeness of computing the maximum cardinality of a clique in a graph @xcite .",
    "@xmath62 +    * proof of theorem [ the : cqa&ca&cox]:*(a ) we provide an algorithm in @xmath92 to decide whether @xmath482 . construct the hitting set framework @xmath246 ( cf . definition [ def : hsstuff ] and remark [ rem : hs ] ) and its associated hypergraph @xmath366 , where , @xmath367 coincides with the collection @xmath221 .",
    "it holds that @xmath0 is a most responsible cause for @xmath2 iff @xmath247 has a c - minimal hitting set that contains @xmath0 ( cf .",
    "proposition [ pro : ubcqcauses ] ) .",
    "therefore , @xmath0 is a most responsible cause for @xmath2 iff @xmath0 belongs to some minimum vertex cover of @xmath372 .",
    "its is easy to see that @xmath372 has a minimum vertex cover that contains @xmath0 iff @xmath372 has a maximum independent set that does not contains @xmath0 . checking if @xmath0 belongs to all maximum independent set of @xmath372 can be done in @xmath8 ( * ? ? ?",
    "* lemma 2 ) . if @xmath0 belongs to all independent sets of @xmath372 , then @xmath483 ; otherwise @xmath482 . as a consequence",
    ", the decision can be made in time @xmath8 .",
    "\\(b ) the proof is by a reduction , via corollary [ cor : cqa&cox ] , from consistent query answering under the c - repair semantics for queries that are conjunctions of ground atoms , which was proved to be @xmath8-complete in ( * ? ? ?",
    "4 ) . actually , that proof ( of hardness ) uses a particular database schema @xmath19 and a dc @xmath32 . in our case , we can use the same schema @xmath19 and the violation query @xmath207 associated to @xmath32 ( cf .",
    "section [ sec : repairfcauses ] ) .",
    "@xmath62 +    * proof of proposition [ pro : crepair&res&cox]:*(a ) we describe an algorithm in @xmath94 that , given an instance @xmath37 and a bcq @xmath2 , computes the responsibility of most responsible causes for @xmath2 . consider the hypergraph @xmath372 as obtained in theorem [ the : cqa&ca&cox ] .",
    "the responsibility of most responsible causes for @xmath2 can be obtained from the size of the minimum vertex cover of @xmath372 ( cf .",
    "proposition [ pro : ubcqcauses ] ) .",
    "the size of the minimum vertex cover in a graph can be computed in @xmath94 , which is obtained from the membership of @xmath94 of computing the maximum cardinality of a clique in graph @xcite .",
    "it is easy to verify that minimum vertex covers in hyprgraphs can be computed in the same time .",
    "\\(b ) this is by a reduction from the problem of determining the size of c - repairs for dcs shown to be @xmath391-complete in ( * ? ? ?",
    "3 ) . actually , that proof ( of hardness ) uses a particular database schema @xmath19 and a dc @xmath32 . in our case",
    ", we may consider the same schema @xmath19 and the violation query @xmath484 associated to @xmath32 ( cf .",
    "section [ sec : repairfcauses ] ) .",
    "the size of c - repairs for an inconsistent instance @xmath3 of the schema @xmath19 wrt .",
    "@xmath32 can be obtained from the responsibility of most responsible causes for @xmath484 ( cf .",
    "corollary [ col : sr&cp ] ) .",
    "@xmath62 +    * proof of theorem [ theo : dichotomy]:*(a ) we use proposition [ pro : cr&mrp ] . to check that @xmath6 is a c - repair of @xmath3 , check for every tuple in @xmath175 , first if @xmath485 , which can be done in ptime .",
    "if yes , next check if @xmath486 . the responsibility of @xmath0 can be computed by binary search over the set @xmath487 , repeatedly using an algorithm to the _ test _ : @xmath488 ? .",
    "the cost of the _ test _",
    "( i.e. the decision problem _ rpd _ ) depends on @xmath99 ( as given by the dichotomy result in @xcite ) . for each @xmath0 , we need in the worst case , essentially @xmath489 calls to the _ test_.",
    "considering all tuples , the whole test needs , say a quadratic number of calls to _",
    "test_. for weakly - linear queries , this can be done in polynomial time .",
    "\\(b ) there is a repair @xmath6 of size greater than @xmath490 with @xmath491 iff there exists a @xmath0 and a @xmath492 , such that @xmath0 is an actual cause for @xmath207 , and @xmath4 is a contingency set for @xmath0 , @xmath493 and @xmath494 iff there is @xmath0 with @xmath495 .",
    "so , if the last test is in ptime , the decision problem about repairs is also in ptime ."
  ],
  "abstract_text": [
    "<S> in this work we establish and investigate connections between causality for query answers in databases , database repairs wrt . </S>",
    "<S> denial constraints , and consistency - based diagnosis . </S>",
    "<S> the first two are relatively new problems in databases , and the third one is an established subject in knowledge representation . we show how to obtain database repairs from causes and the other way around . </S>",
    "<S> causality problems are formulated as diagnosis problems , and the diagnoses provide causes and their responsibilities . </S>",
    "<S> the vast body of research on database repairs can be applied to the newer problem of determining actual causes for query answers and their responsibilities . </S>",
    "<S> these connections , which are interesting _ per se _ , allow us , after a transition -inspired by consistency - based diagnosis- to computational problems on hitting sets and vertex covers in hypergraphs , to obtain several new algorithmic and complexity results for causality in databases . </S>"
  ]
}