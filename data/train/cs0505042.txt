{
  "article_text": [
    "mixed integer linear programming ( milp ) methods have attracted attention because of their modeling capability and because powerful solvers are available commercially . the utilization of milp for modeling and control problems is described in  @xcite and for hybrid systems and practical applications in  @xcite .",
    "milp methods are used in  @xcite for cooperative reconnaissance , in  @xcite for spacecraft path planning , and in  @xcite for cooperative control problems .",
    "powerful software packages such as cplex  @xcite solve milps efficiently for problems in which the number of binary variables is of reasonable size .",
    "however , a major disadvantage of milp is its computational complexity . because milp is np - hard in the number of binary variables used in the problem formulation  @xcite , computational requirements grow significantly as the number of binary variables needed to model the problem increases .",
    "motivated to generate efficient milp problem formulations , we have developed several iterative techniques that require fewer binary variables than standard milp methods .",
    "the milp obstacle avoidance methods from  @xcite and those from  @xcite , developed independently , specify a uniformly distributed set of discrete times at which obstacle avoidance is enforced .",
    "we call this approach uniform gridding . in this approach",
    ", there is no avoidance guarantee between time steps . in addition , many of the avoidance times are unnecessary , resulting in large milps that require a significant computational effort to solve . here , we present an iterative milp obstacle avoidance algorithm that can be used alone or in combination with the uniform gridding approach .",
    "the algorithm guarantees obstacle avoidance over the entire trajectory and distributes avoidance times efficiently , resulting in smaller milps that can be solved faster .",
    "we also present an iterative milp obstacle growing algorithm that allows the use of a coarse set of uniformly distributed obstacle avoidance times . in this approach ,",
    "collision free trajectories are found by artificially increasing the size of the obstacles that collide with the trajectory generated by the milp , iterating until the resulting trajectory is collision free .",
    "next , we consider the minimum time trajectory generation problem using milp .",
    "the milp approach to this problem presented in  @xcite generates an approximate solution .",
    "time is discretized uniformly , and an auxiliary binary variable and a set of inequality constraints are added for each discrete time .",
    "this approach gives an estimate to the time optimal solution that depends on the sampling time chosen . for more accuracy , the sampling time",
    "is reduced , which results in a larger number of binary variables in the milp formulation and thus increases the computation time , possibly exponentially . here , we present an iterative milp algorithm that solves for the time optimal solution to the problem .",
    "the algorithm uses binary search . at each iteration",
    ", the feasibility of a milp with only one discrete time ( for the minimum time part of the problem ) needs to be determined .",
    "the paper is organized as follows : in section  [ vehicle_dynamics ] , we describe the dynamics of the vehicles we use to motivate our methods . in section  [ sec : avoidance ] , we describe two iterative milp algorithms for obstacle avoidance , and we perform an average case computational complexity study comparing the performance of the iterative time step selection algorithm with the uniform gridding approach .",
    "finally , in section  [ mintimeprob ] , we describe an iterative milp algorithm for minimum time control problems . all files for generating the plots found in this paper are available online  @xcite .",
    "we motivate our methods using the wheeled robots of cornell s robocup team  @xcite . in this section ,",
    "we show how to simplify their nonlinear governing equations using a procedure from  @xcite .",
    "the result is a linear set of governing equations coupled by a nonlinear constraint on the control input .",
    "this procedure allows real - time calculation of many near - optimal trajectories and is a major factor for cornell s success in the robocup competition .",
    "we then show how to represent the simplified system in a milp problem formulation .",
    "the result is a set of linear discrete time governing equations subject to a set of linear inequality constraints .    0 by restricting the admissible control inputs we simplify the governing equations in a way that allows near optimal performance .",
    "this procedure allows real - time calculation of many near - optimal trajectories and has been successfully used by cornell s robocup team  @xcite .    because we will use milp as a tool throughout this paper we discretize the simplified equations of motion in time , requiring the control input be constant in between time steps",
    "this results in linear , discrete - time governing equations with varying coefficients , because we have allowed for a nonuniform time discretization .",
    "we approximate the nonlinear constraint on the control input by a set of linear inequality constraints .",
    "we then pose an example optimal control problem . using the discretized equations of motion and the linear inequality constraints on the control input , we formulate the problem as a linear program .",
    "each vehicle is equipped with a three - motor omni - directional drive , which allows it to move along any direction irrespective of its orientation .",
    "this allows superior maneuverability compared to traditional nonholonomic ( car - like ) vehicles .",
    "the nondimensional governing equations of each vehicle are given by @xmath0 +    \\left [ \\begin{array}{c }      \\dot{x}(t ) \\\\",
    "\\dot{y}(t ) \\\\",
    "\\frac{2ml^2}{i}\\dot{\\theta}(t )     \\end{array } \\right ] =    \\mathbf{u}(\\theta(t),t),\\ ] ] where @xmath1 , @xmath2\\nonumber,\\end{aligned}\\ ] ] and @xmath3 . in these equations",
    "@xmath4 are the coordinates of the vehicle , @xmath5 is its orientation , @xmath6 is the @xmath5-dependent control input , @xmath7 is the mass of the vehicle , @xmath8 is its moment of inertia , @xmath9 is the distance from the drive to the center of mass , and @xmath10 is the voltage applied to motor @xmath11 .",
    "the set of admissible voltages @xmath12 is the unit cube , and the set of admissible control inputs is given by @xmath13 .",
    "these governing equations are coupled and nonlinear . to simplify them",
    ", we replace the set @xmath14 with the maximal @xmath15-independent set found by taking the intersection of all possible sets of admissible controls .",
    "the result is a @xmath15-independent control set defined by control input @xmath16 and the inequality constraints @xmath17 and @xmath18 . using the restricted set as the allowable control set , the governing equations decouple and are given by @xmath0 +    \\left [ \\begin{array}{c }      \\dot{x}(t ) \\\\",
    "\\dot{y}(t ) \\\\",
    "\\frac{2ml^2}{i}\\dot{\\theta}(t )     \\end{array } \\right ] =    \\left [ \\begin{array}{c }      u_x(t ) \\\\",
    "u_y(t ) \\\\",
    "u_\\theta(t )     \\end{array } \\right].\\ ] ] the constraints on the control input couple the degrees of freedom .    to decouple the @xmath15 dynamics",
    "we further restrict the admissible control set to a cylinder defined by the following two inequalities : @xmath19 and @xmath20 now , the equations of motion for the translational dynamics of the vehicle are given by @xmath21 subject to equation  ( [ nl_u_constraint ] ) . in state space",
    "form , equation  ( [ eqn : gov ] ) is @xmath22 , where @xmath23 is the state and @xmath24 is the control input .    to represent the governing equations in a milp framework , we discretize the control input in time .",
    "we require the control input be constant between time steps .",
    "the result is a set of linear discrete time governing equations , which we derive next .",
    "let @xmath25 be the number of discretization steps for the control input @xmath26 .",
    "let @xmath27 $ ] be the time at step @xmath28 .",
    "let @xmath29>0 $ ] be the time between steps @xmath28 and @xmath30 , for @xmath31 .",
    "the discrete time governing equations are given by @xmath32 & { } = { } & \\mathbf{a}[k ] \\mathbf{x}_u[k ]   + \\mathbf{b}[k ] \\mathbf{u}[k ] , \\label{disdyn}\\end{aligned}\\ ] ] where @xmath33 = \\mathbf{x}(t_u[k])$ ] , @xmath34 = \\mathbf{u}(t_u[k])$ ] , 0 @xmath35 =      \\left [ \\begin{array}{cccc }      1 & 0 & 1-e^{-t_u[k ] } & 0 \\\\       0 & 1 & 0 & 1-e^{-t_u[k ] } \\\\       0 & 0 & e^{-t_u[k ] } & 0 \\\\       0 & 0 & 0 & e^{-t_u[k ] }      \\end{array } \\right ] ,    \\nonumber\\end{aligned}\\ ] ] @xmath36 =      \\left [ \\begin{array}{cc }      t_u[k]-1+e^{-t_u[k ] } & 0 \\\\       0 & t_u[k]-1+e^{-t_u[k ] } \\\\       1-e^{-t_u[k ] } & 0 \\\\       0 & 1-e^{-t_u[k ] }      \\end{array } \\right ] ,    \\nonumber\\end{aligned}\\ ] ] @xmath33 = ( x_u[k],y_u[k],\\dot{x}_u[k],\\dot{y}_u[k])$ ] , and @xmath34 = ( u_{x}[k],u_{y}[k])$ ] . the coefficients @xmath37 $ ] and @xmath38 $ ] are functions of @xmath28 because we have allowed for nonuniform time discretizations .",
    "they can be calculated explicitly in the usual way  @xcite .",
    "because there will be several different time discretizations used in this paper , we use subscripts to differentiate them . in this section ,",
    "we use the subscript @xmath39 to denote variables associated with the discretization in the control input @xmath26 .",
    "the discrete time governing equations can be solved explicitly in the usual way  @xcite . in later sections of this paper",
    ", it will be necessary to represent the position of the vehicle , at times between control discretization steps , in terms of the control input .",
    "because the set of governing equations is linear , given the discrete state @xmath33 $ ] and the control input @xmath34 $ ] , we can calculate the vehicle s state at any time @xmath40 using the following equations : @xmath41 + ( 1 - e^{t_u[k ] - t } ) \\dot{x}_u[k]\\nonumber\\\\    & & { + } \\:(t - t_u[k ] - 1 + e^{t_u[k ] - t } ) u_{x}[k],\\nonumber\\\\    % % y(t)&{}= { } & y_u[k ] + ( 1 - e^{t_u[k ] - t } ) \\dot{y}_u[k]\\nonumber\\\\    % % & & { + } \\:(t - t_u[k ] - 1 + e^{t_u[k ] - t } ) u_{y}[k ] ,    \\dot{x}(t)&{}= { } & ( e^{t_u[k ] - t } ) \\dot{x}_u[k ]    + ( 1 - e^{t_u[k ] - t } )   u_{x}[k ] ,    % k_u&{}= { } & \\left\\lfloor \\frac{t}{t } \\right\\rfloor .",
    "\\label{inbetween}\\end{aligned}\\ ] ] where @xmath28 satisfies @xmath27 \\leq t \\leq t_u[k+1]$ ] .",
    "if the time discretization of the control input is uniform , @xmath42 = t_u$ ] for all @xmath43 , then @xmath44 .",
    "the components of the vehicle s state , @xmath45 and @xmath46 , can be calculated in a similar way .",
    "the control input constraint given by equation  ( [ nl_u_constraint ] ) can not be expressed in a milp framework because it is nonlinear . to incorporate this constraint , we approximate it with a set of linear inequalities that define a polygon .",
    "the polygon inscribes the region defined by the nonlinear constraint .",
    "we take the conservative inscribing polygon to guarantee that the set of allowable controls defined by the region is feasible .",
    "similar to work in  @xcite , we define the polygon by the set of @xmath47 linear inequality constraints @xmath48 \\sin \\frac{2 \\pi m}{m_u } +     u_{y}[k ] \\cos \\frac{2 \\pi m}{m_u } \\leq \\cos \\frac{\\pi}{m_u}\\nonumber\\\\     & & \\forall m \\in \\ { 1,\\ldots , m_u \\ } ,    \\label{linconstraint}\\end{aligned}\\ ] ] for each step @xmath49 .    to illustrate the approach ,",
    "consider the following minimum control effort trajectory generation problem .",
    "given a vehicle governed by equations  ( [ disdyn ] ) and  ( [ linconstraint ] ) , find the sequence of control inputs @xmath50\\}_{k=0}^{n_u-1}$ ] that transfers the vehicle from starting state @xmath51 to finishing state @xmath52 and minimizes the cost function @xmath53| + |u_{y}[k]| \\right ) .",
    "\\label{mincontrolcost1}\\end{aligned}\\ ] ] to convert the absolute values in the cost function to linear form , we introduce auxiliary continuous variables @xmath54 $ ] and @xmath55 $ ] and the inequality constraints @xmath56 \\leq u_{x}[k ] \\leq z_x[k]\\nonumber\\\\ & & -z_y[k ] \\leq u_{y}[k ] \\leq z_y[k ] .",
    "\\label{slackconstraints}\\end{aligned}\\ ] ] minimizing @xmath54 $ ] subject to the inequalities @xmath57 \\leq z_x[k]$ ] and @xmath57 \\geq -z_x[k]$ ] is equivalent to minimizing @xmath58|$ ] ( similarly for @xmath59|)~\\cite{bertsimas97}$ ] . using the auxiliary variables , the cost function can be written as a linear function , @xmath60 + z_y[k ] \\right ) .",
    "\\label{mincontrolcost2}\\end{aligned}\\ ] ] the resulting optimization problem ( minimize  ( [ mincontrolcost2 ] ) subject to  ( [ disdyn ] ) ,  ( [ linconstraint ] ) ,  ( [ slackconstraints ] ) , and the boundary conditions ) is in milp form .",
    "because binary variables do not appear in the problem formulation , it is a linear program and is easily solved to obtain the optimal sequence of control inputs . 0",
    "problem 1 @xmath61 + z_y[k ]    \\right ) \\\\    \\\\",
    "\\mbox{subject to }      & \\mathbf{x}[k+1 ] = \\mathbf{a } \\mathbf{x}[k ] + \\mathbf{b }      \\mathbf{u}[k ] \\\\    & \\mathbf{x}[0 ] = \\mathbf{x}_0 \\\\    & \\mathbf{x}[t_f ] = \\mathbf{x}_f \\\\    & u_{ux}[k ] \\sin \\frac{2 \\pi m}{m } +       u_{uy}[k ] \\cos \\frac{2 \\pi m}{m } \\leq       \\cos \\frac{\\pi}{m } & \\forall m \\in \\ { 1,\\ldots , m \\ } \\\\    & u_{ux}[k ] \\leq z_x[k ] \\\\    & u_{ux}[k ] \\geq -z_x[k ] \\\\    & u_{uy}[k ] \\leq z_y[k ] \\\\    & u_{uy}[k ] \\geq -z_y[k ]    \\end{array}\\ ] ] for all @xmath62 . 0     plane .",
    "the circle and dotted line denote the initial position and velocity , respectively .",
    "the square denotes the final position .",
    "figure  ( b)(d ) show the time histories of the control inputs , the positions , and the velocities , respectively .",
    "the solid lines for figure  ( b)(d ) represent @xmath63 components and the dotted lines represent @xmath64 components .",
    "the following parameters were used : @xmath65 , @xmath66 , @xmath29 = 0.3 $ ] for all @xmath28 , @xmath67 , and @xmath68 . ]",
    "in vehicle control , it is necessary to avoid other vehicles , stationary and moving obstacles , and restricted regions . in this section , we show how to use milp to solve obstacle avoidance problems , we present two iterative milp obstacle avoidance algorithms that are more computationally efficient than standard methods , and we perform an average case computational complexity study .      we start by showing a milp method to guarantee circular obstacle avoidance at @xmath69 discrete times . a version of this method for uniformly distributed obstacle avoidance times is presented in  @xcite , and a similar method is presented independently in  @xcite .",
    "the method we present here allows nonuniform distributions of obstacle avoidance times  @xcite , which we take advantage of in our iterative algorithm presented in the next section .",
    "we use subscript @xmath70 to denote variables associated with the time discretization for obstacle avoidance . for step @xmath28 , taken to be an element of the set @xmath71 , let @xmath72 $ ] be the time at which obstacle avoidance is enforced .",
    "let @xmath73 denote the radius of the obstacle , and let @xmath74,y_{obst}[k])$ ] denote the coordinates of its center at time @xmath72 $ ] .",
    "we approximate the obstacle with a polygon , denoted @xmath75 $ ] , defined by a set of @xmath76 inequalities .",
    "the polygon is given by @xmath77=\\ { \\mbox { } ( \\bar{x},\\bar{y } ) : ( \\bar{x}-x_{obst}[k ] ) \\sin \\frac{2 \\pi m}{m_{o}}\\\\ \\qquad+\\:(\\bar{y}-y_{obst}[k ] ) \\cos \\frac{2 \\pi m}{m_{o } } \\leq r_{obst},\\\\ \\qquad\\forall m \\in \\{1,\\ldots , m_{o}\\ } \\mbox { } \\}. \\end{array } \\label{obst_con1}\\ ] ]    to guarantee obstacle avoidance at time @xmath72 $ ] the coordinates of the vehicle must be outside the region @xmath75 $ ] .",
    "this avoidance condition can be written as @xmath78,y_o[k ] ) \\notin \\mathcal{o}[k]$ ] , where @xmath78,y_o[k])$ ] are the coordinates of the vehicle at time @xmath72 $ ] . here",
    "@xmath79 = x(t_o[k])$ ] and @xmath80=y(t_o[k])$ ] are expressed in terms of the control inputs using equation  ( [ inbetween ] ) .",
    "because at least one constraint defining the region @xmath75 $ ] must be violated in order to avoid the obstacle , the avoidance condition is equivalent to the following condition : there exists an @xmath7 such that @xmath78-x_{obst}[k ] ) \\sin \\frac{2 \\pi m}{m_{o}}+(y_o[k]-y_{obst}[k ] ) \\cos \\frac{2 \\pi m}{m_{o } } > r_{obst}$ ] .    to express this avoidance constraint in a milp problem formulation , it must be converted to an equivalent set of linear inequality constraints .",
    "we do so by introducing auxiliary binary variable @xmath81 \\in \\ { 0,1 \\}$ ] and the following @xmath76 inequality constraints : @xmath82-x_{obst}[k ] ) \\sin \\frac{2 \\pi m}{m_{o } } + ( y_o[k]-y_{obst}[k ] ) \\cos \\frac{2 \\pi m}{m_{o}}\\\\ \\qquad > r_{obst } - h b_m[k ] , \\quad\\forall m \\in \\ { 1,\\ldots , m_{o } \\ } ,   \\end{array}\\ ] ] where @xmath83 is a large positive number taken to be larger than the maximum dimension of the vehicle s operating environment plus the radius of the obstacle .",
    "if @xmath81 = 1 $ ] , the right side of the inequality is a large , negative number that is always less than the left side . in this case , the inequality is inactive because it is trivially satisfied . if @xmath81= 0 $ ] ,",
    "the inequality is said to be active because it reduces to an inequality from the existence condition above . for obstacle avoidance , at least one of the constraints in equation  ( [ avoidconstraints1 ] ) must be active . to enforce this ,",
    "we introduce the following inequality constraint into the problem formulation : @xmath84 \\leq m_{o}-1 .    \\label{avoidconstraints2}\\end{aligned}\\ ] ]    therefore , to enforce obstacle avoidance at time @xmath72 $ ] , the set of binary variables @xmath85\\}_{m=1}^{m_o}$ ] and the constraints given by equations  ( [ avoidconstraints1 ] ) and  ( [ avoidconstraints2 ] ) are added to the milp problem formulation .",
    "consider the example problem from section  [ vehicle_dynamics ] , adding obstacles that must be avoided . in this problem , we want to transfer the vehicle from start state @xmath86 to finish state @xmath87 in time @xmath88 using minimal control effort and avoiding obstacles . to enforce obstacle avoidance at each time in the set @xmath89\\}_{k=1}^{n_o}$",
    "] , we augment the milp formulation in section  [ vehicle_dynamics ] with the set of binary variables @xmath85\\}_{m=1}^{m_o}$ ] , constraints  ( [ avoidconstraints1 ] ) , and constraint  ( [ avoidconstraints2 ] ) for all @xmath28 in the set @xmath71 .    distributing the avoidance times uniformly ( uniform gridding ) results in a trajectory that avoids obstacles at each discrete time in the set . however , the trajectory can collide with obstacles between avoidance times .",
    "this is shown for an example instance in figure  [ compareplot](a ) . 0    ) , and figure  ( b ) shows the trajectory using a finer uniform gridding ( @xmath90 ) .",
    "figure  ( c ) shows the trajectory using iterative milp avoidance ( @xmath91 ) .",
    "the obstacles are circles , and the polygons represent the obstacles in the milp formulation .",
    "the parameters are @xmath92 , @xmath93 , @xmath94 , @xmath95 , and @xmath96.,width=163 ]    ) , figure  ( b ) shows the trajectory using a finer uniform gridding ( @xmath90 ) , and figure  ( c ) shows the trajectory using iterative milp avoidance ( @xmath91 ) .",
    "the circles denote obstacles , and the polygons denote the buffer regions used in the milp formulation .",
    "the values of the parameters are @xmath92 , @xmath93 , @xmath94 , @xmath97 , and @xmath96 . ]",
    "a simple method to reduce this behavior is to take a finer discretization , which increases the number avoidance times , as shown in figure  [ compareplot](b ) .",
    "however , this is not desirable in milp because an increase in the number of avoidance times increases the number of binary variables in the problem .",
    "it is advantageous to use as few avoidance times as possible .",
    "next , we propose an iterative algorithm to do so .",
    "the method distributes avoidance times where they are needed most , as shown in figure  [ compareplot](c ) , and guarantees obstacle avoidance if an obstacle free trajectory exists .",
    "the idea is to first solve the milp with no obstacle avoidance times ( or with a coarse set of avoidance times ) and check the resulting trajectory for collisions .",
    "then , if there are collisions , augment the milp formulation with an avoidance time ( and the corresponding binary variables and constraints ) for each collision .",
    "the avoidance time for each collision is taken from the interval of time that the trajectory is within the obstacle .",
    "next , solve the augmented milp and check the resulting trajectory for collisions , repeating the procedure until a collision free trajectory is found .",
    "the algorithm is outlined in table  [ obstalgo ] and proceeds as follows : first , formulate the vehicle control problem as a milp and choose an initial set of avoidance times @xmath89\\}_{k=1}^{n_o}$ ] .",
    "this set is usually taken to be the empty set or a coarsely distributed set of times .",
    "next , introduce a buffer zone for each obstacle @xmath98 with radius @xmath99 , where @xmath100 is the buffer factor .",
    "radius @xmath101 is larger than @xmath102 ( usually taken slightly larger ) and is used as the radius of obstacle @xmath98 in the milp formulation .",
    "this is done to guarantee obstacle avoidance and termination of the algorithm , which we show later in this section .",
    "next , solve the milp using the buffer regions as the obstacles .",
    "then , check the resulting trajectory for collisions using each obstacle s true radius , @xmath102 for each obstacle @xmath98 . to check for collisions , sample the trajectory and check whether or not each sample point is inside any of the obstacles .    if there are no collisions , terminate the algorithm .",
    "otherwise , for each collision @xmath11 , compute the time interval @xmath103 $ ] in which the trajectory is within the obstacle .",
    "this interval can be computed efficiently using a bisection routine and the collision check routine .",
    "then , for each collision @xmath11 , augment the milp problem formulation with avoidance constraints at time @xmath104 taken to be in the interval @xmath103 $ ] . in this paper , we take @xmath105 .",
    "next , solve the augmented milp and check the resulting trajectory for collisions .",
    "if there are no collisions , terminate the algorithm . otherwise , repeat the procedure until there are no collisions .    snapshots of intermediate steps in the iterative algorithm are shown in figure  [ actionplot ] .",
    "the procedure adds obstacle avoidance points where they are needed most , thus avoiding unnecessary and computationally costly constraints and binary variables .    ' denotes a time at which obstacle avoidance is enforced .",
    "the values of the parameters are @xmath92 , @xmath93 , @xmath94 , @xmath97 , and @xmath96 .",
    ", width=326 ]    -t_o[k]$ ] , is greater than @xmath106 , the trajectory can intersect the obstacle as shown in the figure on the left . in this case , the algorithm will add a new avoidance constraint at time @xmath104 .",
    "if the difference is less than @xmath107 , the trajectory can not intersect the obstacle , and a new avoidance constraint can not be added in between .",
    ", title=\"fig : \" ] ( -225,-10)@xmath108-t_o[k ] \\geq 2 \\delta t_{\\min}$ ] ( -100,-10)@xmath108-t_o[k ] < 2 \\delta t_{\\min}$ ]    now we show that the iterative algorithm in table  [ obstalgo ] terminates .",
    "the minimum distance between the boundary of a buffer zone and the boundary of the obstacle it surrounds is @xmath109 . for a problem involving multiple obstacles ,",
    "the minimum of these distances is given by @xmath110 , where @xmath111 is the radius of the smallest obstacle in the environment .",
    "the minimum time it takes the vehicle to travel between the boundary of a buffer zone and its corresponding obstacle is given by @xmath112 , where @xmath113 is the maximum velocity of the vehicle .",
    "consider two consecutive obstacle avoidance times denoted @xmath72 $ ] and @xmath108 $ ] .",
    "the vehicle must be located outside all buffer zones at these two times because we have enforced this as a hard constraint in the milp .",
    "if the difference @xmath108 - t_o[k]$ ] is less than @xmath107 , the vehicle s trajectory can not intersect the obstacle because there is not enough time to enter the buffer zone , collide with the obstacle , then exit the buffer zone ( see figure  [ fig : termfig1 ] ) . in order for the trajectory to intersect the obstacle in the interval between these two times , the difference @xmath108 - t_o[k]$ ] must be greater than @xmath107 . in summary",
    ", the algorithm will not add an obstacle avoidance time in the interval if @xmath108 - t_o[k ] < 2 \\delta t_{\\min}$ ] , but it can add an obstacle avoidance time if @xmath108 - t_o[k ] \\geq 2 \\delta t_{\\min}$ ] .",
    "therefore , in the worst case , once the algorithm reaches a point where the time interval between each obstacle avoidance time is less than @xmath107 , the algorithm must terminate .",
    "next we bound the number of steps it takes for the algorithm to terminate .",
    "the smallest possible time interval between consecutive obstacle avoidance times is @xmath114 .",
    "this can be seen by looking at figure  [ fig : termfig2 ] , where @xmath108 $ ] and @xmath72 $ ] are two consecutive avoidance times and @xmath115 is the time at which the trajectory enters the obstacle and @xmath116 is the time it exits the obstacle .",
    "suppose the vehicle is moving at its maximum velocity from time @xmath72 $ ] to @xmath115 .",
    "the algorithm will detect this intersection , compute times @xmath115 and @xmath116 , and pick a new obstacle avoidance time @xmath104 in the interval @xmath117 $ ] .",
    "suppose the algorithm picks @xmath118 , then @xmath119 = \\delta t_{\\min}$ ] .",
    "the time interval can not be any less because the vehicle can not pass through the buffer zone in time less than @xmath114 . in the trajectory generation problem ,",
    "if @xmath120 is the vehicle s starting time and @xmath88 is its finishing time , the maximum number of time intervals added by the algorithm is @xmath121 .",
    "therefore , the algorithm will terminate in a maximum of @xmath122 steps .",
    "this is a worst case result . in practice",
    "the algorithm terminates in fewer steps .",
    "assume the vehicle is moving at @xmath113 between times @xmath72 $ ] and @xmath115 .",
    "if the algorithm selects @xmath115 as the new obstacle avoidance time , the difference @xmath123 $ ] is equal to @xmath114 .",
    "this is the minimum possible time interval between avoidance times because the vehicle can not move any faster .",
    ", width=153 ]      being consistent with our goal to reduce the number of obstacle avoidance times in our milp problem formulations , we propose another iterative milp algorithm for obstacle avoidance .",
    "this algorithm iteratively grows the buffer zones surrounding the obstacles until a collision free trajectory is found .",
    "the idea is to first solve the milp with a coarse set of avoidance times and an initial set of buffer zones surrounding each obstacle .",
    "then , check the resulting trajectory for collisions . if there are collisions , increase the size of each buffer zone that surrounds an obstacle with which the trajectory collides .",
    "next , solve the milp with these new buffer zones and check the resulting trajectory for collisions .",
    "this process is repeated until there are no collisions .",
    "the details of the algorithm are listed in table  [ tbl : obstgrowalgo ] .",
    "snapshots of intermediate steps of the algorithm are shown in figure  [ fig : itergrow ] .",
    "the crosses denote the coarse set of times at which obstacle avoidance is enforced in the milp . as the figure shows , the size of the buffer regions surrounding the obstacles with which the trajectory intersects is increased until the resulting trajectory , generated by the milp , avoids all obstacles .",
    "the situation in which this algorithm is most useful is when uniform gridding is used and the resulting trajectory clips an obstacle , barely intersecting it . in this case , the algorithm pushes the trajectory away from the clipped obstacle in a few iterations , resulting in a collision free trajectory .",
    "however , if the initial distribution of avoidance times is too coarse , the algorithm could have problems . in this case",
    ", the buffer regions could grow to be large and engulf the initial or final position , which results in an infeasible milp .          in this section",
    ", we explore the average case computational complexity of the iterative milp obstacle avoidance algorithm by solving randomly generated problem instances .",
    "each instance is generated by randomly picking parameters from a uniform distribution over the intervals defined below .",
    "each milp is solved using ampl  @xcite and cplex  @xcite on a pc with intel piii 550mhz processor , 1024 kb cache , 3.8 gb ram , and red hat linux .",
    "for all instances solved , processor speed was the limiting factor , not memory .    for comparison , we solve the same instances using uniform gridding with sample time @xmath124 .",
    "this sample time is the maximum sample time that guarantees obstacle avoidance , assuming the vehicle travels in a straight line between sample times .",
    "this is a good approximation since @xmath125 is small for the instances we solve .",
    "see appendix  [ appendix2 ] for details .",
    "each obstacle avoidance time is given by @xmath72 = k \\delta t_{c}$ ] , where @xmath126 and @xmath127 .",
    "the instances are generated as follows : the start state is taken to be @xmath128 , where @xmath129 is constant , and @xmath130 and @xmath131 are random variables chosen uniformly from the intervals @xmath132 $ ] and @xmath133 $ ] , respectively .",
    "the final state is fixed with zero velocity , @xmath134 .",
    "we generate @xmath135 obstacles each with position @xmath136 and radius @xmath73 .",
    "the parameters @xmath73 , @xmath137 , and @xmath15 are random variables chosen uniformly from the respective intervals @xmath138 $ ] , @xmath139 $ ] , and @xmath133 $ ] such that no obstacle overlaps the circle of radius @xmath140 with position @xmath129 or the circle of radius @xmath141 with position @xmath142 .    for the instances generated in this paper ,",
    "we set the intervals to be @xmath143 $ ] , @xmath144 $ ] , and @xmath145 $ ] .",
    "the constant parameters are taken to be @xmath146 , @xmath147 , @xmath148 , and @xmath149 .",
    "the solution to an instance of the obstacle avoidance problem with three obstacles is shown in figure  [ fig:3obst ] for the the uniform gridding method and for the iterative milp methods .",
    "each cross denotes the time along the trajectory at which obstacle avoidance is enforced .",
    "the uniform gridding method with sample time @xmath125 requires @xmath150 obstacle avoidance times , shown in figure  [ fig:3obst](b ) , while the iterative milp time step selection algorithm requires only @xmath151 avoidance times , shown in figure  [ fig:3obst](c ) .",
    "notice the efficiency in which the iterative algorithm distributes the avoidance times .",
    "for comparison , we also solve this instance using uniform gridding with sample time @xmath152 ( figure  [ fig:3obst](a ) ) and using the iterative obstacle growing algorithm ( figure  [ fig:3obst](d ) ) .",
    "for uniform gridding , choosing sample time @xmath107 guarantees obstacle avoidance as discussed in section  [ sec : stepselect ] .",
    "however , as shown in the figure , this dense set of obstacle avoidance times is very conservative .",
    "( @xmath153 ) , ( b ) uniform gridding with sample time @xmath154 ( @xmath150 ) , ( c ) iterative time step selection ( @xmath155 ) , and ( d ) iterative obstacle growing ( @xmath156 ) .",
    "the straight line segment denotes the initial velocity @xmath157 , the circular regions denote obstacles , the dashed regions denote the polygonal buffer zones , and each cross denotes a time along the trajectory at which obstacle avoidance is enforced . , width=336 ]    in figure  [ fig : comptime ] , we plot the fraction of instances solved versus computation time for the two methods . as these figures show , the iterative milp method is less computationally intensive than the uniform gridding method for the instances solved .",
    "for example , 70% of the instances are solved in 0.4 seconds or less using the iterative milp algorithm for the 3 obstacle case .",
    "in contrast , no instances are solved in 0.4 seconds or less using uniform gridding for the 3 obstacle case .    .",
    "for each curve , 500 random instances were solved .",
    "the values of the parameters are @xmath65 , @xmath158 , and @xmath159.,title=\"fig:\",width=288 ] . for each curve ,",
    "500 random instances were solved .",
    "the values of the parameters are @xmath65 , @xmath158 , and @xmath159.,title=\"fig:\",width=288 ]    in figure  [ fig : expgrow ] , we plot the computation time necessary to solve 70% of the randomly generated instances versus the number of obstacles on the field .",
    "data is plotted for the uniform gridding method and for the iterative milp method .",
    "the computational requirements for both methods grow exponentially with the number of obstacles",
    ". however , as the figure shows , the iterative milp method is less computationally intensive and the computation time grows at a slower rate .",
    "in this section , we present an iterative milp algorithm for solving minimum time problems using a vehicle trajectory generation problem as motivation . in  @xcite , milp methods for this problem are presented .",
    "time is discretized uniformly and the sampling interval that contains the optimal time is found using milp . to get better bounds on the optimal time ,",
    "the sample time of the discretization must be reduced , which results in a larger number of binary variables . in appendix",
    "[ sec : tgprim ] , this method is outlined in the context of the vehicle considered in this paper .",
    "here we propose an iterative algorithm that converges to the optimal time using binary search . at each iteration the feasibility of a milp is determined using a solver such as cplex  @xcite . in each milp ,",
    "the number of binary variables and the number of constraints are much fewer than those for other techniques because only one discrete time step is needed .    to motivate the iterative algorithm we consider a minimum time vehicle control problem .",
    "given a vehicle governed by equations  ( [ disdyn ] ) and  ( [ linconstraint ] ) , find the sequence of control inputs @xmath160 \\}_{k=0}^{n_u-1}$ ] that transfers the vehicle from initial state @xmath51 to final state @xmath52 in minimum time .",
    "suppose we know that the optimal time , denoted @xmath161 , is within the time interval @xmath162 $ ] .",
    "let time @xmath163 .",
    "consider the milp given by equation  ( [ disdyn ] ) , equation  ( [ linconstraint ] ) , constraint @xmath51 , and constraint @xmath52 with final time taken to be @xmath164 .",
    "we use equation  ( [ inbetween ] ) to express @xmath165 in terms of the control inputs . to determine",
    "if there exists a sequence of control inputs that transfers the vehicle from start state to finish state , we solve the milp without an objective function ( this is a feasibility problem ) .",
    "if the milp is feasible , @xmath161 must be within the interval @xmath166 $ ] .",
    "otherwise , the milp is infeasible and @xmath161 must be within the interval @xmath167 $ ] . by determining the feasibility of the milp",
    ", we have cut the bound on the optimal time @xmath161 in half .",
    "this suggests an iterative binary search procedure that converges to @xmath161 .",
    "the iterative algorithm is outlined in table  [ mintimealgo ] and proceeds as follows : first , pick a time interval @xmath168 $ ] that bounds the optimal time @xmath161 .",
    "the lower bound is taken to be @xmath169 , where @xmath170 is the straight line distance from the initial position to the final position and @xmath113 is the maximum velocity of the vehicle .",
    "the upper bound is taken to be a feasible time in which the vehicle can reach the destination .",
    "a simple way to compute a feasible time is to try time @xmath171 , where @xmath172 , increasing @xmath173 until a feasible time is found .",
    "set @xmath174 , @xmath175 , and @xmath176 .",
    "next , set the final time in the milp problem formulation to be @xmath164 , and determine if the resulting milp is feasible using the milp solver .",
    "if the milp is feasible , the optimal time @xmath161 must be within the interval @xmath166 $ ] . in this case ,",
    "set @xmath177 . otherwise , the milp is infeasible and the vehicle can not reach the destination in time @xmath178 .",
    "the optimal time @xmath161 must be within the interval @xmath167 $ ] . in this case , set @xmath179 .",
    "then , update @xmath178 by setting @xmath180 .",
    "if the difference @xmath181 is less than some desired tolerance for our calculation of @xmath161 , denoted @xmath182 , the algorithm terminates . otherwise , repeat the process by setting the final time to @xmath164 and continue with the steps outlined previously until the computed value of @xmath161 is within the desired tolerance @xmath182 .    after the @xmath28th iteration ,",
    "the time interval containing optimal time @xmath161 has length @xmath183 .",
    "the solid lines of figure  [ mintime1 ] show the solution to an instance of the minimum time problem .",
    "the iterative procedure was stopped after thirteen iterations , which took approximately one second on our pentium iii 550 mhz computer . to achieve the same accuracy using the uniform time discretization method , solving one large milp with a small sampling time , it took five minutes on the same computer .",
    "our iterative procedure converges to the time optimal solution of the problem stated in the beginning of this section .",
    "this solution is an approximate solution to the continuous time version of the minimum time vehicle control problem .",
    "in the continuous time version of the problem , the vehicle is governed by equations  ( [ eqn : gov ] ) and  ( [ nl_u_constraint ] ) .",
    "we wish to transfer the vehicle from starting state @xmath86 to finishing state @xmath87 in minimum time . in figure",
    "[ mintime1 ] , we compare our near optimal solution to the continuous time problem ( solid lines ) to another technique ( dotted lines ) for generating near optimal solutions from  @xcite , which was used successfully in the robocup competition .",
    "in addition to being used on its own , our iterative approach can be combined with the uniform discretization approach . in this case",
    ", the uniform approach is run first with a coarse discretization ( large sampling time @xmath184 ) .",
    "the output is a time interval of size @xmath184 , which contains the optimal time @xmath161 .",
    "we use this time interval as the input to our iterative algorithm .",
    "the @xmath28th step of the iterative algorithm outputs a time interval of length @xmath185 containing the optimal time @xmath161 , and thus quickly converges to the optimal time .     given by the iterative milp algorithm .",
    "for comparison we plot the near optimal solution ( dotted lines ) for the continuous time version of the problem obtained using techniques from  @xcite .",
    "the parameters are : @xmath186 , @xmath187 , @xmath188 , @xmath189 .",
    ", width=316 ]",
    "we have presented iterative milp algorithms for obstacle avoidance and for minimum time control problems .",
    "the iterative milp time selection algorithm picks obstacle avoidance times and intelligently distributes them where they are needed most .",
    "the iterative milp obstacle growing algorithm allows a course set of obstacle avoidance times to be used instead of a dense distribution , which is required to guarantee obstacle avoidance for standard milp methods . both of these algorithms reduce the number of binary variables needed to formulate and solve obstacle avoidance trajectory generation problems using milp . to demonstrate the computational benefits of the iterative milp time step selection algorithm",
    ", we performed an average case computational complexity analysis . for comparison",
    ", we also performed the analysis on the standard uniform gridding method .",
    "the iterative algorithm significantly outperformed the uniform gridding method .",
    "in addition , we also present an iterative algorithm for solving minimum time problems using milp .",
    "we found that the algorithm significantly outperforms standard techniques for minimum time problems using milp .    due to the reduced computational requirements of these methods",
    ", they can be applied more widely in practice .",
    "computational efficiency is especially important for real time control in dynamically changing environments where new control plans need to be generated often and in real time using a strategy such as model predictive control  @xcite . in our research",
    "@xcite , we use these methods to solve cooperative control problems such as those described in  @xcite . however , there is much room for improvement , including decreasing computation time further and developing methods that scale better with increased numbers of obstacles and vehicles . in",
    "@xcite we discuss ideas to further decrease the computational requirements of milp methods .",
    "we feel that intelligent time step selection methods , such as those presented in this paper , can be very useful in reducing computational requirements and should be pursued further .",
    "one aspect that needs inspection is the intelligent selection of the discretization for the control input to the vehicle .",
    "here we derive the minimum sample time , denoted @xmath125 , that guarantees obstacle avoidance between sample times , assuming the vehicle moves in a straight line path between sample times .",
    "this is a good approximation , because @xmath125 is small for the problems we solve .",
    "let @xmath190 be the straight line distance the vehicle can travel between any two consecutive avoidance times .",
    "the cord of the smallest buffer region that is tangent to the obstacle it surrounds is denoted the critical cord .",
    "the critical cord length is given by @xmath191 because @xmath192 .    if @xmath193 , the vehicle is guaranteed to avoid the obstacle between avoidance times .",
    "if @xmath194 , the vehicle can collide with the obstacle between avoidance times .",
    "the critical time interval @xmath125 is given by @xmath195 where @xmath113 is the maximum velocity of the vehicle .",
    "here we consider a minimum time trajectory generation problem . we are given a vehicle governed by the discrete time system  ( [ disdyn ] ) and subject to the constraints  ( [ linconstraint ] ) .",
    "the objective is to find the sequence of control inputs @xmath160 \\}_{k=0}^{n_u-1}$ ] that transfers the system from the initial state @xmath51 to the final state @xmath196 in minimum time .",
    "applying the techniques of  @xcite , we introduce a uniform time discretization with constant sampling time @xmath184 .",
    "the solution of the resulting milp gives a feasible time that is within @xmath184 of the optimal time .",
    "discretize time into @xmath197 times given by @xmath198 = kt$ ] , where @xmath28 is an element of the set @xmath199 .",
    "the discretization must be chosen so that @xmath200 = n_t t$ ] is larger than the optimal time .    next ,",
    "introduce auxiliary binary variable @xmath201 \\in \\ { 0,1 \\}$ ] and the inequality constraints , @xmath202 ) - x_f \\leq h(1-\\delta[k])\\nonumber\\\\    & & x(t_t[k ] ) - x_f \\geq -h(1-\\delta[k])\\nonumber\\\\    & & y(t_t[k ] ) - y_f \\leq h(1-\\delta[k])\\nonumber\\\\    & & y(t_t[k ] ) - y_f \\geq -h(1-\\delta[k])\\nonumber\\\\    & & \\dot{x}(t_t[k ] ) -\\dot{x}_f \\leq h(1-\\delta[k])\\nonumber\\\\    & & \\dot{x}(t_t[k ] ) -\\dot{x}_f \\geq -h(1-\\delta[k])\\nonumber\\\\    & & \\dot{y}(t_t[k ] ) -\\dot{y}_f \\leq h(1-\\delta[k])\\nonumber\\\\    & & \\dot{y}(t_t[k ] ) -\\dot{y}_f \\geq -h(1-\\delta[k ] ) ,    \\label{eqn : mincon1}\\end{aligned}\\ ] ] for each @xmath28 in the set @xmath203 . here , the state @xmath204)$ ] is written in terms of the control inputs using equation  ( [ inbetween ] ) , and @xmath83 is a large positive constant taken to be greater than the largest dimension of the operating environment .",
    "if @xmath201=0 $ ] , every constraint in equation  ( [ eqn : mincon1 ] ) is trivially satisfied because , for example , @xmath205 ) - x_f$ ] is always less than @xmath83 . otherwise , @xmath201=1 $ ] and the constraints in equation  ( [ eqn : mincon1 ] ) enforce the condition @xmath204",
    "= \\mathbf{x}_f)$ ] . to require that the final condition be satisfied at only one discrete time @xmath198 $ ] the following constraint is introduced , @xmath206 = 1.\\ ] ]",
    "finally , we introduce the cost function to be minimized , @xmath207.\\ ] ] by minimizing this cost the final state @xmath87 is reached at the earliest discrete time , @xmath198 $ ] , possible . the output after solving the resulting milp is a single @xmath208 such that @xmath209=1 $ ] .",
    "the optimal time is therefore within the interval @xmath210 , t_t[k_{sol } ] ] $ ]",
    ".    1 j. s. bellingham , m. tillerson , m. alighanbari , and j. p. how , `` cooperative path planning for multiple uavs in dynamic and uncertain environments , '' _ proc .",
    "ieee conf .",
    "decision and control _ , las vegas , neveda , dec .",
    "2002 , pp . 28162822 .",
    "a. bemporad and m. morari , `` control of systems integrating logic , dynamics , and constraints , '' _ automatica _ , vol .",
    "407428 , 1999 .",
    "d. bertsimas and j. n. tsitsiklis , _ introduction to linear optimization _ , athena scientific , belmont , massachusetts , 1997 .",
    "m.  campbell , r.  dandrea , d.  schneider , a.  chaudhry , s.  waydo , j.  sullivan , j.  veverka , and a.  klochko , `` roboflag games using systems based , hierarchical control , '' _ proceedings of the american control conference _ , june 46 , 2003 , pp .",
    "r.   dandrea , t.  kalmr - nagy , p.  ganguly , and m.  babish , `` the cornell robocup team , '' in g. kraetzschmar , p. stone , t. balch eds .",
    ", _ robot soccer worldcup iv , lecture notes in artificial intelligence _ , springer , 2001 .",
    "r.  dandrea and r.  m.  murray , `` the roboflag competition , '' _ proceedings of the american control conference _ , june 46 , 2003 , pp .",
    "r.  dandrea and m.  babish , `` the roboflag testbed , '' _ proceedings of the american control conference _ ,",
    "june 46 , 2003 , pp .",
    "656660 . m.  g.  earl and r.  dandrea , `` multi - vehicle cooperative control using mixed integer linear programming , '' a preprint is available at cs/0501092 m.  g.  earl and r.  dandrea , `` a decomposition approach to multi - vehicle cooperative control , ''",
    "a preprint is available at cs/0504081 m.  g.  earl and r.  dandrea , `` a study in cooperative control : the roboflag drill , '' _ proceedings of the american control conference _ , anchorage , alaska may 810 , 2002 , pp .  18111812 . m. g. earl and r. dandrea , `` modeling and control of a multi - agent system using mixed integer linear programming , '' _ proc .",
    "ieee conf .",
    "decision and control _ , las vegas , nevada , dec .",
    "2002 , pp .",
    "107111 . all files for generating the plots found in this paper are available online at ` http://control.mae.cornell.edu/earl/milp2 ` r.  fourer , d.  m.  gay , b.  w.  kernighan , `` ampl  a modeling language for mathematical programming , '' boyd & fraser , 1993 . `",
    "m. r. garey and d. s. johnson . _ computers and intractability : a guide to the theory of np - completeness_. w. h. freeman and co. , 1979 .",
    "_ ilog ampl cplex system version 7.0 user s guide _ , 2000 . ` http://www.ilog.com/products/cplex ` d.  q.  mayne , j.  b.  rawlings , c.  v.  rao , and p.  o.  m.  scokaert , `` constrained model predictive control : stability and optimality , '' _ automatica _ , vol .",
    "36 , pp .  789814 , 2000 . m.  morari , m.  baotic , and f.  borrelli , `` hybrid systems modeling and control , '' _",
    "european journal of control _ , vol .",
    "9 , no . 2 - 3 ,",
    "177 - 189 , 2003 .",
    "t. kalmr - nagy , r. dandrea , and p. ganguly .",
    "`` near - optimal dynamic trajectory generation and control of an omnidirectional vehicle , '' _ robotics and autonomous systems _ , vol .",
    "4764 , 2004 .",
    "j.  ousingsawat and m.  e.  campbell , `` establishing optimal trajectories for multi - vehicle reconnaissance , '' _ aiaa guidance , navigation and control conference _",
    "a.  richards , t.  schouwenaars , j.  p.  how , and e.  feron , `` spacecraft trajectory planning with avoidance constraints using mixed - integer linear programming , '' _ journal of guidance , control , and dynamics _ , vol .",
    "25 , pp . 755764 , july  august 2002 .",
    "a. richards and j. p. how , `` aircraft trajectory planning with collision avoidance using mixed integer linear programming , '' _ proc .",
    "american control conf .",
    "_ , anchorage , alaska may 810 , 2002 . h.  p.  rothwangl , `` numerical synthesis of the time optimal nonlinear state controller via mixed integer programming , '' _ proc .",
    "american control conf .",
    "_ , arlington , va , june 2001 , pp . 32013205 . p. stone , m. asada , t. balch , r. dandrea , m. fujita , b. hengst , g. kraetzschmar , p. lima , n. lau , h. lund , d. polani , p. scerri , s. tadokoro , t. weigel , and g. wyeth , `` robocup-2000 : the fourth robotic soccer world championships , '' _ ai magazine _ , vol .",
    "22(1 ) , pp .  1138 , spring 2001 ."
  ],
  "abstract_text": [
    "<S> mixed integer linear programming ( milp ) is a powerful tool for planning and control problems because of its modeling capability and the availability of good solvers . </S>",
    "<S> however , for large models , milp methods suffer computationally . in this paper </S>",
    "<S> , we present iterative milp algorithms that address this issue . </S>",
    "<S> we consider trajectory generation problems with obstacle avoidance requirements and minimum time trajectory generation problems . </S>",
    "<S> the algorithms use fewer binary variables than standard milp methods and require less computational effort . </S>"
  ]
}