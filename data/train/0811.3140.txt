{
  "article_text": [
    "irc  @xcite is one of the oldest digital communication protocols on the internet  @xcite .",
    "this protocol is a form of synchronous conferencing which is mainly used for its one - to - many communication capabilities .",
    "although its popularity has somewhat diminished since the introduction of instant messaging applications @xcite like the msn messenger @xcite , it is still widely used .    in this paper , we first give some background information about irc in section  [ sec : bg ] . in section  [ sec : ds ] we elaborate on the phenomenon of _ desynched channels _ and in section  [ sec : place ] we describe how to place a boundary , section  [ sec : properties ] covers the occurrence of _ fake modes _ and section  [ sec : back ] describes how to remove a desync . in section  [ sec : app ] , we give some examples of possible uses of fake modes and we conclude in section  [ sec : con ] .",
    "an irc network consists of multiple servers connected to each other , there are no cycles in this network , so the topology of this network is an undirected tree ( acyclic graph ) .",
    "an irc network also has clients connected to its servers , and messages are relayed from server to server to transfer a message from one client to another .",
    "this topology introduces some drawbacks ; if a connection between two servers is terminated , the graph will split into two parts .",
    "this is called a _",
    "netsplit_. when a server disconnects from the network , there are several things that can happen ; if the server in question is a leaf node , only the server itself is split from the network .",
    "if on the other hand the server is connected to @xmath0 other servers the network is split into @xmath1 parts .",
    "on irc , there are so - called _ modes _ , divided in `` user modes '' and `` channel modes '' , which indicate rights and/or restrictions on users and channels .",
    "a complete list of these modes can be found in @xcite .",
    "a problem that can arise in a netsplit , is that a channel can have different modes at each side of the split .",
    "this becomes a problem when the network is rejoined and some action has to be taken to make sure the channel modes are consistent throughout the network again .",
    "most problems concerning netsplits have been fixed already and we shall not elaborate on this subject .",
    "we shall however investigate another less - known drawback of the irc topology known as _",
    "we discuss this phenomenon in the context of ircnet  @xcite only , many other irc networks do not have this problem , or to a lesser extent .",
    "since all messages ( including mode changes ) are propagated through the network , there is no real concept of simultaneity .",
    "if for instance , at time @xmath2 client @xmath3 sends a message and at time @xmath4 client @xmath5 sends a message , there is no guarantee that a third client @xmath6 gets these messages in order .",
    "if client @xmath6 for example is physically closer to @xmath5 , it might receive the message of @xmath5 before that of @xmath3 arrives .",
    "normally these are only minor inconveniences but things get worse if channel  mode changes are involved .",
    "in general , a channel becomes _ desynched _ if two incompatible mode changes are propagated through the network at the same time .",
    "there are two different cases to be distinguished .    with mutual exclusiveness , we mean acting on each others mode or presence on the channel .          in case",
    "[ it : one ] the desynchronisation works as follows : consider the picture in figure  [ fig : flow ] , we have servers @xmath7 and @xmath8 , client @xmath3 on server @xmath9 and client @xmath10 on server @xmath11 . now",
    "both @xmath3 and @xmath10 issue an incompatible mode change at time @xmath2 .",
    "assume that it takes one time unit for the change to propagate from one server to another .",
    "notice that clients on this channel will see two mode changes following each other , but not in the same order .",
    "clients on the left side of the boundary ( the dotted line between server @xmath11 and @xmath9 ) will see the mode change of @xmath10 first , then that of @xmath3 .",
    "the clients on the other side will see the mode change of @xmath3 first , then that of @xmath5 .",
    "the channel is now desynched and the boundary is between server @xmath11 and @xmath9 .    the cases for which this mechanism applies are :    the following channel modes also `` flow '' in this way , except the server does not propagate the mode if the mode change does not have any effect ; the command is rejected by the server .",
    "therefore , a simultaneous mode change like this will always result in the toggling of this mode .    as a concluding remark ,",
    "this type of desynching is relatively harmless , since it is easy to get back in sync again and this type of desynching is non - transferable . in section  [ sec : back ] we discuss how to get a desynched channel back in sync and in section  [ sec : col ] we discuss the more dangerous `` colliding '' desynchronisation and the concept of transferable desynchronisation .",
    "in case  [ it : two ] the desynchronisation goes as follows : consider the picture in figure  [ fig : collide ] , again we have servers @xmath7 and @xmath8 , client @xmath3 on server @xmath9 and client @xmath10 on server @xmath11 .",
    "now both @xmath3 and @xmath10 issue an incompatible and mutually exclusive mode change at the same time @xmath2 .",
    "again , assume that it takes one time unit for the change to propagate from one server to another .",
    "notice that in this case the result is the opposite of what happens with a `` flowing '' desync .",
    "the clients on the channel in question only see one mode change , the one on their side of the boundary .",
    "the cases for which this mechanism applies are :    both of these cases result in having ops on one side of the boundary and not on the other . at first glance",
    ", this only seems a disadvantage , but in section  [ sec : app ] we show some possible uses .",
    "a netjoin can also cause desyncronisation of a channel .",
    "if for example , during a netsplit a conflicting mode is set , a netjoin will result in a `` flowing '' desynchronisation of the channel .",
    "only `` flowing '' desyncs can occur on a netjoin and there are only a couple of modes that can generate such a desynchronisation :    notice that a conflict is not the absence of a mode versus the presence of one , so a conflicting ` + l ` mode is not ` + l ` versus ` -l ` , but for example ` + l 10 ` versus ` + l 11 ` .    also note that the ` + s ` / ` + p ` conflict is fixed in all operational ircnet servers .",
    "now we shall discuss how to place the desync boundary . to desync a channel ,",
    "we need two clients , @xmath3 and @xmath5 , both on different servers .",
    "first , observe that the desync boundary will always be between the servers @xmath3 and @xmath5 are on .",
    "the easiest way to desync is by having two clients on adjacent servers . this way the boundary will always be between those two servers",
    ". using example  [ ex : col ] will result in a desync .        if @xmath3 and @xmath5 are not on adjacent servers , the boundary can be created anywhere ( as long as it is between the servers @xmath3 and @xmath5 are on ) .",
    "where the boundary will be created exactly is a matter of timing . by adjusting the delay between the commands @xmath3 and @xmath5",
    "give that will result in a desync , the position of the boundary can be manipulated .",
    "here we see a procedure that will desync a channel .",
    "this approach assumes that clients @xmath3 and @xmath5 are controlled by one user .",
    "first , the user chooses two adjacent servers on the path from @xmath3 to @xmath5 .",
    "the server closest to @xmath3 we call @xmath11 and the other one we call @xmath12",
    ". then client @xmath3 measures the latency to server @xmath11 , this can be done with the ` /ping ` command for example .",
    "client @xmath5 does the same for server @xmath12 .",
    "now , depending on the difference in latency , client @xmath3 is kicked or deopped and after the appropriate delay , client @xmath5 is kicked or deopped or vice versa .",
    "if the user does not have control over both clients , then two users must work together to create a desync boundary .",
    "both users must agree on the present time however , so something like running ntp  @xcite will be needed .",
    "first , both users must agree on two adjacent servers on the path to each other .",
    "each user now takes the server closest to it and calls it @xmath11 .",
    "then it measures the latency to @xmath11 and communicates this to the other user .",
    "after this , they agree on a time in the near future @xmath13 ( of course , @xmath13 must be later than the delay added to the present time ) .",
    "now , depending on the difference in delay , on time @xmath13 either client @xmath3 or @xmath5 will delay for the appropriate time before issuing the kick or deop .",
    "setting a mode on one side of a desynchronised channel will result in a _ fake mode _ on the other side .",
    "having a fake voice ( voice on one side , but not on the other ) is not very harmful , it is often even irritating to have one , especially on a moderated channel . only part of the other clients on the channel will be able to see what the client with a fake voice has to say . furthermore , the fake voice client gets a `` can not send to channel '' message from the opposite side ( the side it is not voiced on ) each time it says something . if the voice is on the opposite side and the channel is moderated , a fake voice is useless .",
    "having a fake ops is more useful , because with this you can make other clients a fake ( op , voice ) too , also channel modes can be faked ( even if these channel modes can not be used to desync themselves ) .",
    "a fake op can desynchronise the topic for example , or the ` + m ` setting .",
    "every channel mode , including all the lists ( ban ( ` + b ` ) , ban - exception ( ` + e ` ) , etc ) can be desynchronised in this way . leaving the channel in a very messy state .",
    "a fake join is an artifact of a kick on a desynchronised channel .",
    "it occurs when we have the following situation :    ` a - b|c `    where the ` - ` denotes a normal connection between servers and the ` | ` denotes the desync boundary .",
    "we have client @xmath3 on server @xmath9 , client @xmath5 on server @xmath14 and client @xmath6 on server @xmath15 .",
    "assume that client @xmath5 only has ops on its side of the boundary .",
    "if client @xmath5 now kicks @xmath3 , client @xmath6 will not see @xmath3 leave ( because from its perspective , @xmath5 does not have ops and therefore no right to kick @xmath3 ) .",
    "if @xmath3 now rejoins the channel , only @xmath5 will see him join and since @xmath6 already sees him as joined , no new join is seen .",
    "instead a `` fake join '' error message is generated .",
    "when a fake join or mode is generated , the error that results from it will be logged on ` & channel ` .",
    "this is one of the channels on the local server where server messages are logged",
    ".    this error will be visible on all servers on the side the fake join was generated .",
    "the servers at the other side see nothing but normal operation .",
    "the error message itself includes the channel where the fake mode occurred and the client that generated the fake mode .",
    "the ` & channel ` is also used for reop notices .",
    "there are a few tests to see where the boundary is .",
    "one is by giving a client voice on one side of the boundary and setting channel mode ` + m ` on the other .",
    "when this client now sends a message , it will receive the error message `` can not send to channel '' from some foreign server .",
    "the boundary lies between that server and the next one , as seen from the perspective of the client .",
    "other possibilities are kicking a client from one side of the boundary and setting channel mode ` + n ` on the other .",
    "there are several more cases like this , sometimes resulting in different error messages ( like `` you re not on that channel '' ) .",
    "there are several ways to accomplish this , depending on the circumstances . synchronizing all channel modes and joined clients will resync the channel . in most cases ,",
    "a channel operator can repair the desynchronisation , provided there are operators left on both sides of the boundary .",
    "if there are no channel operators left , recreating the channel is one of the last options left . if there are clients that have been kicked from one side of the boundary , rejoining the channel will fix this .",
    "another , but less reliable way to repair a desynched channel is to wait for a netsplit ( and the consecutive netjoin ) . in some cases",
    ", this can get a channel back in sync , or at least give a desynched ops control over the whole channel again , making it able to repair the channel manually .",
    "this also applies to semi - kicked clients , they will rejoin the channel as in a normal netjoin and gain the privileges they had on their own side of the split .",
    "we now give a few examples on what fake modes can be used for .",
    "we are only covering a small subset of all possibilities and even these can be combined .",
    "also remember that in all cases , the actual act of desynching requires operator status .",
    "the desynching itself might be done almost unseen , or it might take several attempts , arousing suspicion .      as mentioned in section  [ sec : back ] , a netjoin can resynchronise a channel .",
    "this can be used to regain ops on the other side of the boundary .",
    "here is what can happen :    user @xmath3 can even take further actions to increase the chance of a takeover . by de - opping everyone at its side of the border , the operators on the other side will have fake modes too .",
    "if these operators kick the clients @xmath3 brings in , it looks to them like the channel is cleaned up . in reality",
    "it has no effect on the side @xmath3 is on .",
    "as mentioned in example  [ ex : prepare ] , a client can be made invisible by kicking them from one side of the boundary .",
    "this can be used as an advantage in several ways .    in practice",
    "this can be used in large networks that have users in a few countries , but not in the one of user @xmath5 .",
    "there is even the possibility to do this beforehand , by desynchronising the channel , and then cleaning up the channel except for the cloaked client .",
    "when a new client @xmath3 now joins on @xmath9 or @xmath15 , this client will think it has created a new channel and it gets a serverops as usual .",
    "this new client is now operator on the whole channel , but does not know that @xmath5 is on there too .",
    "user @xmath5 might even have ops left or have a whole assembly of clients joined to server @xmath14 .",
    "on ircnet , an uncollidable channel is one that has the ` ! ` -prefix ( ` ! channel ` for example ) .",
    "on such a channel anonymous mode ( ` + a ` ) can be set by the channel creator ( who has mode ` + o ` ) .",
    "when a channel has mode ` + a ` , everyone will have the nick ` anonymous ` and the ` /names ` command will show only the nick of the one who gave the command .",
    "the ` + a ` mode can also be desynched , like any other .",
    "this can lead to the following situation :    notice that this two - server setup is only a simplified version , this idea is more effective when instead of only one server ( @xmath14 ) there rest of the irc network is on that side .    also notice that client @xmath3 can set its part of the channel to invite - only ( ` + i ` ) , thus preventing anyone joining the non - anonymous part of the channel and finding out what is going on .",
    "if a desynchronised channel is used for monitoring or cloaking , having multiple boundaries could be useful .",
    "consider the following :    ` a|b|c `    assume that client @xmath3 is on server @xmath9 , and is cloaked ( as described in section  [ sec : cloak ] ) from servers @xmath14 and @xmath15 .",
    "assume that server @xmath14 is empty .",
    "if the desync boundary between @xmath9 and @xmath14 now disappears ( because of an accident caused by client @xmath3 , or a netsplit for example ) , it can be recreated without people on server @xmath15 ever noticing that client @xmath3 was present .",
    "if the boundary is recreated by clients that only have ops on servers @xmath9 and @xmath14 , the creation of the boundary will even be undetectable for people on server @xmath15 .",
    "notice that if the boundary between servers @xmath14 and @xmath15 disappears , client @xmath3 will stay cloaked too , but recreating the boundary will be more difficult because it will not go unnoticed for the clients residing on server @xmath15 .",
    "tests have shown that the process of desynching a channel is fairly easy . even without using the procedures described in section  [ sec : place ] , but by using a script where only the order of the commands were adjusted manually , desynching was usually accomplished within two or three attempts . if the boundary is not in a desired position , it can always be removed as described in section  [ sec : back ] as long as there is a spare ops on the channel to get the channel back in sync .",
    "the position of the boundary can be manipulated to some extent , as explained in section  [ sec : place ] .",
    "determining where the boundary is , can be done as described in section  [ sec : det ] , so when a boundary is not in the desired place , it can be removed and another attempt can be made .    having a desynched channel can have some advantages , as seen in section  [ sec : app ] .",
    "it can , for example , be used to appear invisible on a channel or for monitoring anonymous channels .",
    "as mentioned in section  [ sec : bg ] , other irc networks have not been investigated thoroughly .",
    "we can report that on an unreal  @xcite network like undermind  @xcite , the desyncs that occur are of no use .",
    "the desync by simultaneous deop seems to trigger a response from the servers that result in both clients having ops on the wrong side of the desync boundary , rendering them useless .",
    "simultaneous kicks do not result in a desync at all , both clients just get kicked .",
    "other networks might or might not have desynchronisation behaviour as described in this paper .",
    "the authors would like to thank the users on the ircnet ` ! ircd ` channel for their insights concerning fake joins .",
    "xx ` http://en.wikipedia.org/wiki/internet_relay_chat ` ` http://en.wikipedia.org/wiki/internet ` ` http://en.wikipedia.org/wiki/instant_messaging ` ` http://en.wikipedia.org/wiki/windows_live_messenger ` ` http://ircnet.irchelp.org/ ` ` http://rfc.net/rfc2812.html ` ` http://www.ircnet.org/ ` ` http://www.ntp.org/ ` ` http://www.unrealircd.com/ ` ` http://www.undermind.net/ `"
  ],
  "abstract_text": [
    "<S> in this paper we describe what a desynchronised channel on irc is . </S>",
    "<S> we give procedures on how to create such a channel and how to remove desynchronisation . </S>",
    "<S> we explain which types of desynchronisation there are , what properties desynchronised channels have , and which properties can be exploited . </S>"
  ]
}