{
  "article_text": [
    "rate - compatible coding schemes are desirable to provide different error protection requirements , or accommodate time - varying channel characteristics .",
    "especially , we would like to design a pair of encoder and decoder which can adapt both different code length and different code rate without changing their basic structure in the hybrid automatic repeat - request ( harq ) protocols .",
    "in such cases , rate compatible punctured convolutional ( rcpc ) codes @xcite or rate compatible punctured turbo ( rcpt ) codes @xcite are typical coding techniques , which are broadly applied in modern wireless communication systems , such as lte ( long term evolution ) . recently , as the first constructive capacity - achieving coding scheme , polar codes @xcite reveal the advantages of error performance and many attractive application prospects . according to the original code construction @xcite , polar codes are also able to support rate compatibility partially since the code rate can be precisely adjusted by adding or deleting one information bit .",
    "however , the code length @xmath0 still is limited to the power of two , i.e. , @xmath1 .",
    "consequently , puncturing code bits and shortening the code length becomes the key technique of designing good rate - compatible punctured polar ( rcpp ) codes .    to the best of the authors knowledge",
    ", the puncturing schemes of polar codes can be summarized as two categories .",
    "first , some code bits are punctured in the encoder and the decoder has no _ a priori _ information about these bits which can be regarded as the ones transmitting over zero - capacity channels . in this paper",
    ", we call this category as the capacity - zero ( c0 ) puncturing mode .",
    "second , the values of the punctured code bits are predetermined and known by the encoder and decoder .",
    "thus the associated channels can be regarded as one - capacity channels .",
    "we use the capacity - one ( c1 ) puncturing mode to sketch the feature of this category .    for the puncturing schemes under the c0 mode ,",
    "eslami _ et al . _",
    "first proposed a stopping - tree puncturing to match arbitrary code length under the belief propagation ( bp ) decoding @xcite .",
    "then , shin _ et al . _",
    "proposed a reduced generator matrix method to efficiently improve the error performance of the rcpp codes under the successive cancellation ( sc ) decoding @xcite , whereas searching the good polarizing matrices is still a time consuming process . in @xcite ,",
    "a heuristic puncturing approach was proposed for the codes with short length . in @xcite , an efficiently universal puncturing scheme , named quasi - uniform puncturing algorithm ( qup )",
    "was proposed and the corresponding rcpp codes can outperform the performance of turbo codes in 3g/4 g wireless systems .    on the other hand , for the puncturing schemes under the c1 mode , wang _ et al . _",
    "@xcite first introduced the concept of capacity - one puncturing and devised a simple puncturing method by finding columns with weight 1 to improve the error performance of sc decoding .",
    "later , the author in @xcite exploited the structure of polar codes and proposed a reduced - complexity search algorithm to jointly optimize the puncturing patterns and the values of the punctured bits .    to sum up , for the mainstream sc / sc - like decoding , most of the current puncturing schemes under the c0 or c1 modes are heuristic methods and lack of a systematic framework to design the rcpp codes .",
    "intuitively , the optimal punctured scheme under the sc decoding can be obtained by enumerating each punctured pattern and calculating the relative upper bound of block error rate ( bler ) .",
    "obviously , this exhausted search is intractable due to the prohibitive complexity .",
    "theoretically , like the optimization of rcpc or rcpt codes , rcpp codes can also be constructed by the optimization of the distance spectra ( ds ) or weight enumeration function ( wef ) @xcite for different punctured patterns .",
    "but due to the high complexity of ds / wef calculation of polar codes @xcite , it is also unrealistic to design rcpp codes based on these metrics .",
    "hence , designing a feasible and computable measurement is crucial for the optimization of rcpp codes under the sc decoding .    in this paper , we establish a complete framework to design and optimize the rcpp codes under the sc / sc - like decoding .",
    "based on this framework , we obtain the optimal puncturing schemes for both modes .",
    "the main contributions of this paper can be summarized as follows .",
    "\\(1 ) first , we propose a new tool , called polar spectra ( ps ) , to simplify the performance evaluation of rcpp codes under sc decoding .",
    "conceptually , polar spectra are defined on the code tree and include two categories : ps1 and ps0 , which represent the number of paths with the same hamming weight or complemental hamming weight ( the number of zeros ) respectively .",
    "based on ps , we introduce two kinds of path weight enumeration function ( pwef1 and pwef0 ) to indicate the distribution of ( complemental ) path weight .",
    "furthermore , three performance metrics , the spectrum distance for pwef0 ( sd0 ) , the spectrum distance for pwef1 ( sd1 ) , and joint spectrum distance ( jsd ) for the entire ps , are defined to optimize the distribution of ( complemental ) path weight under two puncturing modes ( c0 and c1 ) .",
    "\\(2 ) second , for the c0 mode , thanks to the easily analyzed property of ps , we prove that the quasi - uniform puncturing ( qup ) algorithm proposed in @xcite can maximize the metrics sd1 and jsd .",
    "moreover , we analyze the structure feature of this puncturing and obtain the exact number of equivalent puncturing tables .",
    "\\(3 ) third , for the c1 mode , we propose a new reversal quasi - uniform puncturing ( rqup ) and prove that this scheme can maximize the metrics sd0 and jsd .",
    "the remainder of the paper is organized as follows .",
    "section [ section_ii ] describes the preliminaries of polar codes , including polar coding , decoding algorithm , and upper bounds analysis of bhattacharyya parameter .",
    "section [ section_iii ] describes the puncturing modes of rcpp codes and sketches out the en-/decoding process .",
    "the concepts of polar spectra , pwefs ( pwef0 and pwef1 ) , and spectrum distances ( sd0 , sd1 , and jsd ) are introduced in section [ section_iv ] . the qup algorithm is presented and proved to be the optimal one under the c0 puncturing mode in section [ section_v ] .",
    "similarly , the rqup scheme is proposed and proved to maximize the sd0 and jsd under the c1 puncturing mode in section [ section_vi ] .",
    "section [ section_vii ] provides the numerical analysis for various puncturing schemes and simulation results for rcpp and turbo codes in lte systems .",
    "finally , section [ section_viii ] concludes the paper .",
    "in this paper , calligraphy letters , such as @xmath2 and @xmath3 , are mainly used to denote sets , and the cardinality of @xmath2 is defined as @xmath4 .",
    "the cartesian product of @xmath2 and @xmath3 is written as @xmath5 and @xmath6 denotes the @xmath7-th cartesian power of @xmath2 .",
    "we write @xmath8 to denote an @xmath0-dimensional vector @xmath9 and @xmath10 to denote a subvector @xmath11 of @xmath8 , @xmath12 .",
    "further , given an index set @xmath13 and its complement set @xmath14 , we write @xmath15 and @xmath16 to denote two complementary subvectors of @xmath8 , which consist of @xmath17s with @xmath18 or @xmath19 respectively",
    ". we use @xmath20 to denote the expectation operation of a random variable .    throughout this paper",
    ", @xmath21 means ",
    "logarithm to base 2 \" , and @xmath22 stands for the natural logarithm .      given a b - dmc @xmath23 with input alphabet @xmath24 and output alphabet @xmath3 , the channel transition probabilities can be defined as @xmath25 , @xmath26 and @xmath27 and the corresponding reliability metric , bhattacharyya parameter , can be expressed as @xmath28 applying channel polarization transform for @xmath1 independent uses of b - dmc @xmath29 , after channel combining and splitting operation @xcite , we can obtain a group of polarized channels @xmath30 , @xmath31 .",
    "the bhattacharyya parameters of these channels satisfy the following recursion @xmath32 by using of the channel polarization , the polar coding can be described as follows .",
    "given the code length @xmath0 , the information length @xmath33 and code rate @xmath34 , the indices set of polarized channels can be divided into two subsets : one set @xmath35 to carry information bits and the other complement set @xmath14 to assign the fixed binary sequence , named frozen bits .",
    "so a message block of @xmath36 bits is transmitted over the @xmath33 most reliable channels @xmath37 with indices @xmath38 and the others are used to transmit the frozen bits .",
    "so a binary source block @xmath39 consisting of @xmath33 information bits and @xmath40 frozen bits can be encoded into a codeword @xmath41 by @xmath42 where the matrix @xmath43 is the @xmath0-dimension generator matrix .",
    "this matrix can be recursively defined as @xmath44 , where  @xmath45 \" denotes the @xmath7-th kronecker product , @xmath46 is the bit - reversal permutation matrix , and @xmath47 $ ] is the @xmath48 kernel matrix .    in this paper , we mainly use the trellis or factor graph based on the coding relationship @xmath49 to describe the structure of polar or rcpp codes , where the source bits are arranged by the bit - reversal order and the code bits by the natural order . on the other hand",
    ", we also introduce the dual trellis to simplify the analysis of puncturing schemes .",
    "the dual trellis or dual factor graph is defined as a trellis deduced from the constraint @xmath50 ( see ( * ? ? ?",
    "* lemma1 ) ) . compared with the original trellis , in this dual trellis ,",
    "the source bits are assigned by the natural order and the code bits by the bit - reversal order .    for the construction of polar codes ,",
    "the calculation of channel reliabilities and selection of good channels are the critical steps . in this paper , for the convenience of theoretic analysis , we mainly use bhattacharyya parameter to indicate the channel reliability .",
    "as pointed in @xcite , polar codes can be decoded by the sc decoding algorithm with a low complexity @xmath51 .",
    "furthermore , many improved sc decoding algorithms , such as , successive cancellation list ( scl ) @xcite , successive cancellation stack ( scs ) @xcite , successive cancellation hybrid ( sch ) @xcite , and crc aided ( ca)-scl / scs @xcite decoding can be applied to improve the performance of polar codes .      the channel index @xmath52 can be expanded as @xmath53 where @xmath54 denote the @xmath7-bit binary expansion of @xmath55 and @xmath56 is the polarization level .",
    "let @xmath57 and @xmath58 , where @xmath59 denotes the upper bound of the bhattacharyya parameter at level @xmath56 . according to the analytical idea of asymptotic convergence of bhattacharyya parameter in @xcite ,",
    "the iteration of the upper bound in the logarithmic domain can be expressed as @xmath60",
    "in this section , we introduce the definition of rcpp codes and describe the corresponding coding and decoding process . then",
    ", we review the puncturing modes of rcpp codes , such as the c0 and c1 modes . in the end , we analyze the upper bound of bhattacharyya parameter for both modes .",
    "rcpp codes are a kind of rate- and length- compatible polar codes .",
    "the entire encoding process can be described by two steps . in the first step ,",
    "an original @xmath33-bit information block is coded by the coding constraint ( [ equation3 ] ) , that is , a binary source block @xmath39 consisting of the information subvector @xmath61 and the frozen subvector @xmath62 is encoded into a code block @xmath41 .    then in the second step , in order to adapt the rate variation , the length of @xmath0-bit code block is shortened according to the puncturing table . here",
    ", the puncturing table @xmath63 is defined as @xmath64 with @xmath65 , @xmath66 , where @xmath67 means that the code bit @xmath68 in the corresponding index is not to be transmitted , and vise versa .",
    "let @xmath69 and @xmath70 denote the puncturing set and the complement set , whereby the corresponding cardinalities are defined as @xmath71 and @xmath72 respectively .",
    "since the code length of the original polar codes is limited to a power of @xmath73 , without loss of generality , it suffices to concern only on the case that @xmath74 .",
    "so after puncturing @xmath75 code bits , an @xmath76 length rcpp codeword @xmath77 can be obtained from the table @xmath63 .",
    "accordingly , the code rate of rcpp coding scheme can be defined as @xmath78 .",
    "the encoding process of rcpp code can also be equally described based on the puncturing of source bits .",
    "firstly , we introduce a puncturing set of source bits @xmath79 , which satisfies @xmath80 . after deleting @xmath75 bits ,",
    "a minished source vector @xmath81 is obtained .",
    "then the codeword @xmath77 with the code length @xmath76 can be written by @xmath82 where the dimension - reduction generator matrix @xmath83 is obtained by eliminating the columns corresponding to the set @xmath84 and rows corresponding to the set @xmath79 from the matrix @xmath85 .",
    "the construction of rcpp codes is similar to that of polar codes .",
    "let @xmath86 denote the punctured channel . for rcpp codes ,",
    "the transmission channel @xmath87 can be regarded as a compound of the original b - dmc and the punctured channel , i.e. , @xmath88 .",
    "similarly , under the puncturing operation , after channel splitting and combing , we can also obtain a group of polarized channels @xmath89 and the corresponding bhattacharyya parameters @xmath90 .",
    "the decoder of rcpp codes has the same decoding structure as that of polar codes .",
    "however , the initialization of bit llrs for those punctured bits is different for the c0 or c1 modes , which will be further explained in the next subsection .      by now",
    ", we have two puncturing modes for rcpp codes : c0 mode and c1 mode . for the former ,",
    "the code bits in the puncturing set @xmath84 are deleted in the encoder and their values are unknown in the the decoder .",
    "thus , the transition probabilities of punctured channel @xmath86 are @xmath91 .",
    "the corresponding channel capacity is zero , that is , @xmath92 .",
    "given a punctured bit @xmath68 ( @xmath93 ) , for the c0 mode , the corresponding llr in the decoder is @xmath94 .    on the contrary , for the latter",
    ", the punctured bits are set as frozen bits @xcite in the encoder and their values are fixed and known in the decoder .",
    "suppose the fixed value is zero , that is , @xmath95 , the transition probabilities are @xmath96 , @xmath97 .",
    "so the channel capacity is one , that is , @xmath98 and the corresponding llr is @xmath99 .    for two channel polarization , the factor graphs of polar codes under the c0 and c1 modes are shown in fig .",
    "[ fig_two_channel ] .        in this figure and throughout the paper ,",
    "black circle and black squares denote the variable and check nodes of the factor graph , meanwhile , red cross and blue triangle stand for the punctured bits under the c0 or c1 modes respectively . in fig .",
    "[ fig_two_channel](a ) ( [ fig_two_channel](b ) ) , the code bit @xmath100 ( @xmath101 ) is punctured and the corresponding bhattacharyya parameter is @xmath102 . the relative puncturing tables are @xmath103 and @xmath104 respectively . on the other hand , in fig .",
    "[ fig_two_channel](c ) , the code bit @xmath101 are punctured and the corresponding bhattacharyya parameter is @xmath105 , meanwhile , the source bit @xmath106 is a frozen bit . in this scheme , the puncturing table is @xmath104 .",
    "[ lemma2 ] for two channel polarization under the c0 mode , both puncturing tables @xmath103 or @xmath104 can generate the same polarization results .",
    "[ lemma3 ] for two channel polarization under the c1 mode , the puncturing table satisfies @xmath104 and the source bit @xmath106 should be assigned a fixed value .",
    "in addition , the reliabilities of polarized channels satisfies @xmath107 and @xmath108 respectively .",
    "these two lemmas will be proved in the appendix .",
    "furthermore , they can be recursively applied in the process of @xmath0 channels polarization .",
    "[ c1_mode_bc ] given a rcpp code constructed under the c1 mode , the bhattacharyya parameters of the polarized channels are smaller than those of the original polarized channels , that is , @xmath109 .",
    "this lemma reveals that the puncturing under the c1 mode will improve the reliability of each polarized channel and will be proved in the appendix .",
    "let @xmath110 denote the upper bounds of the bhattacharyya parameters under puncturing and @xmath111 , on the corresponding trellis , the upper bounds of bhattacharyya parameters can be iteratively evaluated by considering the reliability difference of the polarized channels .    in the first case ,",
    "a pair of independent polarized channels @xmath112 with the same reliability are considered . by using the same binary expansion in ( [ binary_expansion ] ) , we can write the iteration of these bounds in the logarithmic domain as @xmath113    in the second case , we consider a pair of channels have different reliabilities , meanwhile , one is a punctured channel and the other is a polarized channel .    for the c0 mode , from lemma [ lemma2 ]",
    ", the upper bounds at level @xmath56 can be iteratively calculated in the logarithmic domain as @xmath114    accordingly , for the c1 mode , from lemma [ lemma3 ] , the upper bounds can also be written by @xmath115    now , we consider the third case , that is , a pair of channels have different reliabilities and the bhattacharyya parameters of both channels are not equal to @xmath116 or @xmath117 . obviously , the channels in this case are obtained from channel polarization in the first and second cases .",
    "let @xmath118 and @xmath119 denote the upper bounds of these two channels in a log - scale respectively .",
    "[ c0_mode_ub_set ] for the c0 mode , the upper bound of the bhattacharyya parameter at level @xmath120 should be set to the maximum value , that is , @xmath121 .",
    "furthermore , the upper bounds at level @xmath56 can be iteratively calculated by ( [ bhattaharyya_bound_log ] ) .    in this case",
    ", one channel is obtained from the @xmath76 b - dmcs polarization and the other from the polarization of punctured channels and b - dmcs .",
    "we select the maximum value of as the upper bound of bhattacharyya parameter at level @xmath120 , which can indicate the worse reliability of rcpp codes under the c0 mode .",
    "[ c1_mode_ub_set ] for the c1 mode , the upper bound at level @xmath120 should be set to the minimum value , that is , @xmath122 .    by lemma [ c1_mode_bc ]",
    ", if the minimum value is selected as the upper bound of bhattacharyya parameter at level @xmath120 , this bound ensures that the reliability of each polarized channel under the c1 mode is better than that of the original polarized channel .",
    "so for the c0 mode , the upper bounds of bhattacharyya parameters can be iteratively calculated by using ( [ bhattaharyya_bound_log ] ) and ( [ bound_log_c0 ] ) in logarithmic domain .",
    "correspondingly , for the c1 mode , the upper bounds can be evaluated by using ( [ bhattaharyya_bound_log ] ) and ( [ bound_log_c1 ] ) .",
    "[ example1 ] figure [ fig_trellis ] gives two examples of @xmath123 channel polarization with @xmath124 punctured bits under two puncturing modes .",
    "in this figure , the numbers next to the variable nodes of each level denote the upper bounds ( in the logarithmic domain ) of bhattacharyya parameters of the transmission channels .    in fig .",
    "[ fig_trellis](a ) , under the c0 mode , the first code bit is punctured and the puncturing table is @xmath125 . applying lemma [ c0_mode_ub_set ] , the number next to the white circle node should be changed from @xmath126 to @xmath127 . on the other hand , in fig .",
    "[ fig_trellis](b ) , under the c1 mode , the fourth code bit are punctured and the puncturing table is @xmath128 . from lemma [ lemma3 ] , we can conclude that source bit @xmath129 at level @xmath73 should be set to a fixed value .",
    "furthermore , by lemma [ c1_mode_ub_set ] , the number next to the white circle node should be altered from @xmath130 to @xmath127 .",
    "in this section , we show how to use a code tree to describe the process of channel polarization with puncturing operation . based on the tree structure",
    ", we introduce the concepts of polar spectra ( ps ) and path weight enumeration function ( pwef ) .",
    "furthermore , three types of spectrum distance , such as sd0 , sd1 , and jsd , are introduced as key performance metrics to indicate the distribution of polar spectra .",
    "code tree is a compact representation of trellises for polar or rcpp codes .",
    "given the parent code length @xmath131 , the code tree @xmath132 is a binary tree , where @xmath133 and @xmath134 denote the set of nodes and the set of edges or branches , respectively .",
    "the depth of a node is the length of the path from the root to this node .",
    "the set of all the nodes at a given depth @xmath56 is denoted by @xmath135 .",
    "the root node has a depth of zero .",
    "the nodes in the set @xmath136 can be enumerated one - by - one from left to right on the tree , that is , @xmath137 denotes the @xmath138-th node in @xmath136 . except for the nodes at the @xmath7-th depth , each",
    "@xmath139 has two descendants in @xmath140 , and the two corresponding branches are labeled as @xmath116 and @xmath117 , respectively .",
    "the nodes @xmath141 are called leaf nodes .",
    "let @xmath142 denote a subtree with a root node @xmath143 .",
    "the depth of this subtree can be defined as the difference between the depth of leaf node and that of the root node , that is , @xmath144 .",
    "recall that channel index @xmath52 can be expanded by a binary sequence ( [ binary_expansion ] ) , hence , we can use this sequence to label a path @xmath145 from the root node to one leaf node to denote a path on the code tree with a depth @xmath7 .",
    "the superscript will be stripped without causing confusion .",
    "] , whereby one branch between depth @xmath120 and depth @xmath56 is assigned a bit value @xmath146 .",
    "let @xmath147 denote a partial path from the root node to a node in depth @xmath56 .",
    "note that , using this labeling method , the source bits corresponding to the leaf nodes are arranged by a natural order .",
    "considering the one - to - one correspondence between the channel @xmath52 and the path @xmath148 , we use the reliability of channel @xmath52 to denote the reliability of the corresponding path @xmath148 . furthermore , given an end node @xmath149 of one path",
    ", the reliability of this node can also be evaluated by that of the path and denoted by @xmath150 .",
    "figure [ fig_code_tree ] shows two examples of code tree with a parent code length @xmath123 for the c0 and c1 modes .",
    "each code tree is a compact presentation of the trellis in example [ example1 ] .",
    "each depth in the tree corresponds to one level on the trellis shown in fig .",
    "[ fig_trellis ] .",
    "the source bit @xmath151 corresponds to a binary expansion @xmath152 and this sequence is assigned to a path @xmath153 which is also indicated by a node sequence @xmath154 . in example",
    "[ example1 ] , the punctured source bits under the c0 or c1 modes are @xmath155 or @xmath129 respectively .    as shown in fig .",
    "[ fig_code_tree](a ) , the leftmost path is pruned and there are two subtrees , such as @xmath156 and @xmath157 .",
    "the reliability metrics corresponding to the root nodes of these subtrees are @xmath130 and @xmath127 , respectively .",
    "similarly , in fig .",
    "[ fig_code_tree](b ) , the rightmost path is pruned and there are two subtrees , such as @xmath158 and @xmath159 .",
    "the reliability metrics corresponding to the root nodes of these subtrees are @xmath127 and @xmath126 , respectively .        generally , for the punctured source bits on the code tree , we have the following lemmas .    [ lemma5 ] for the c0 mode ,",
    "if one punctured leaf node is a right descendent of a subtree , then the left descendent of this subtree is also punctured .",
    "given an arbitrary subtree @xmath160 , it has a left descendent @xmath161 and a right one @xmath162 .",
    "these two leaf nodes are corresponding to two channel polarization . under the c0 mode , if this subtree is punctured one bit , by lemma [ lemma2 ] , the left descendent @xmath161 should be firstly punctured .",
    "furthermore , if the right descendent @xmath162 is punctured , this subtree will be fully deleted .",
    "[ lemma6 ] for the c1 mode , if one punctured leaf node is a left descendent of a subtree , then the right descendent of this subtree is also punctured .    according to lemma [ lemma3 ] , using the same argument as that of lemma [ lemma5 ] ,",
    "we can obtain the conclusion .",
    "now , we consider the performance analysis of polar or rcpp codes on the code tree .",
    "because each path @xmath148 is relative to a polarized channel @xmath52 ( refer to footnote 1 ) , the corresponding upper bound of bhattacharyya parameter @xmath163 can be iteratively evaluated by using ( [ log_bp_bound ] ) or ( [ bhattaharyya_bound_log ] ) in a log scale .",
    "this calculation includes two operators , that is , the adding - one operator @xmath164 and the doubling operator @xmath165 .",
    "given the initial value of the root node @xmath166 , a sequence of numbers @xmath167 can be recursively calculated by @xmath168 where @xmath169 . from ( [ bhattaharyya_bound_log ] ) ,",
    "when @xmath170 , the operator @xmath171 is applied and when @xmath172 , the operator @xmath173 is used .    the path weight @xmath174 is defined as the hamming weight of the binary vector @xmath175 , that is , @xmath176 .",
    "furthermore , we can define the complemental path weight @xmath177 as the complemental hamming weight of the path @xmath148 , that is , @xmath178 .    obviously , during the @xmath7 iterations of the @xmath179 , we enumerate doubling @xmath174 times and adding - one @xmath177 times .",
    "and these two weights satisfy @xmath180 .",
    "[ theorem1 ] given a path @xmath148 with the path weight @xmath174 and the complemental path weight @xmath177 , the corresponding upper bound of bhattacharyya parameter @xmath181 can be further bounded by @xmath182 where @xmath183 and @xmath184 satisfy @xmath185    suppose the path @xmath175 is relative to an operator sequence @xmath186 and the beginning of the sequence is @xmath187 ( if the beginning is @xmath188 , we will check the sequence and find a partial one with the beginning of @xmath189 ) .",
    "so there exists @xmath190 for which @xmath191 and @xmath173 .",
    "according to the argument in ( * ? ? ?",
    "* lemma 1 ) , swapping @xmath192 and @xmath193 will decrease the result of recursion .",
    "so after continuously swapping over the sequence , we can obtain a lower bound on @xmath179 corresponds to choosing @xmath194 and @xmath195 , that is , @xmath196 . by a similar argument , we can find an upper bound @xmath197 which is proved in @xcite .",
    "since path weight and complemental path weight indicate the reliability of polarized channel , given the end node @xmath149 of the path @xmath148 , we can use the lower bound @xmath183 to present the reliability of this node , that is @xmath198    polar spectra are defined by the distribution of path weight or complemental path weight on the code tree and characterized by two sets , ps1 and ps0 , to count the number of paths with a certain path weight or complemental path weight respectively .",
    "let @xmath199 denote the ps1 set of a rcpp code with the code length @xmath76 , where @xmath200 represents the number of paths with a path weight @xmath201 on the code tree after the puncturing .",
    "similarly , @xmath202 denotes the corresponding ps0 set , where @xmath203 means the number of paths with a complemental path weight @xmath204 .    for the original polar code ,",
    "i.e. , @xmath205 , due to the structure of perfect binary tree , the elements in ps1 and ps0 satisfy @xmath206 and @xmath207 respectively . by theorem [ theorem1 ] , the set of ps1 or ps0",
    "directly determine the reliability of polarized channel .",
    "hence , how to approach these original polar spectra is the aim of optimal puncturing for rcpp codes .",
    "path weight enumeration function ( pwef ) is characterized by two types of polynomials whose coefficients are taken from the corresponding polar spectra . given the ps1 set @xmath208 , pwef on the path weight ( pwef1 ) can be defined as @xmath209 , where @xmath210 is a dumb variable .",
    "similarly , given the ps0 set @xmath211 , pwef on the complemental path weight ( pwef0 ) can be defined as @xmath212 .",
    "[ lemma7 ] the ps1 and ps0 of an original polar code are symmetric , that is , given a pair of paths @xmath213 and @xmath214 , we have @xmath215 and @xmath216 .",
    "further , the corresponding pwef1 and pwef0 satisfy @xmath217 .",
    "we introduce two types of spectrum distances , sd1 and sd0 , defined by the expectation of path weight and complemental weight respectively .    the spectrum distance for path weight ( sd1 )",
    "is given by @xmath218=\\frac{1}{m}\\left.\\frac{d\\mathcal{h}(x)}{dx}\\right|_{x=1}\\\\             & = \\sum\\limits_{k = 0}^n { p_1(n , k , q)k}= \\sum\\limits_{k = 0}^n { \\frac{h_m^{\\left ( k \\right)}}{m}k } \\end{aligned}\\ ] ] where @xmath219 is the probability of path weight @xmath201 for a rcpp code with @xmath75 bits puncturing . correspondingly , the spectrum distance for complemental path weight ( sd0 ) is given by @xmath220=\\frac{1}{m}\\left.\\frac{d\\mathcal{c}(x)}{dx}\\right|_{x=1}\\\\             & = \\sum\\limits_{r = 0}^n { p_0(n , r , q)r}= \\sum\\limits_{r = 0}^n { \\frac{c_m^{\\left(r \\right)}}{m}r } \\end{aligned}\\ ] ] where @xmath221 .",
    "in addition , we can define the joint spectrum distance ( jsd ) as follows @xmath222+\\mathbb{e}\\left[f_h(\\omega_n)\\right]\\\\                          & = \\sum\\limits_{k = 0}^n { p_1(n , k , q)k}+\\sum\\limits_{r = 0}^n { p_0(n , r , q)r}. \\end{aligned}\\ ] ]    hereafter , we use sd0/sd1/jsd as the main metrics to evaluate and optimize the puncturing table . if these metrics of one puncturing scheme are very close to those of the original polar code , this scheme will generate an optimal rcpp code .",
    "[ corollary2 ] the sd1 and sd0 of the original polar code are @xmath223=\\frac{n}{2}$ ] and @xmath224=\\frac{n}{2}$ ] respectively .",
    "the proof is direct . by lemma [ lemma7 ] ,",
    "since the probability @xmath225 of the original polar code obeys the binomial distribution , we can write @xmath226=\\sum\\limits_{k = 0}^n { p_1(n , k,0)k }                                                                   = \\sum\\limits_{k = 0}^n{\\binom{n}{k}\\frac{k}{2^n}}=\\frac{n}{2}. \\end{aligned}\\ ] ] the derivation of sd0 is similar and omitted .",
    "in this section , the quasi - uniform puncturing ( qup ) algorithm is described and proved to maximize the spectrum distances sd1 and jsd .",
    "consider the single - bit puncturing under c0 mode . in this case , puncturing at different locations is equivalent regardless of a slight variation in its code tree .",
    "[ theorem3 ] for the c0 mode , when only one bit is punctured , puncturing any code bit @xmath68 is equivalent to puncturing the first code bit @xmath100 , meanwhile , the source bit @xmath155 is punctured .",
    "the polarized transformation @xmath227 is inverted as @xmath228 @xcite .",
    "hence , the first source bit can be written as @xmath229 .",
    "this bit @xmath155 is constrained by all the code bits via the modulo-2 operation .",
    "when any one code bit is punctured under the c0 mode , it is easy to see that the source @xmath155 bit must be punctured according to lemma [ lemma2 ] .",
    "[ theorem4 ] for single bit puncturing under the c0 mode , the maximal path weight on the code tree is @xmath230 , similarly , the maximal complemental path weight is also @xmath230 .    according to theorem [ theorem3 ] ,",
    "after single bit puncturing under the c0 mode , the leftmost path @xmath231 ( @xmath232 ) corresponding to the first source bit @xmath155 on the code tree is pruned .",
    "the nodes associated to this pruned path are @xmath233 .",
    "so the original code tree is decomposed into @xmath7 subtrees and each has a root node @xmath234 .",
    "since every bit @xmath146 is punctured , by using ( [ bound_log_c0 ] ) , we can calculate the reliability metric of each root node , that is , @xmath235 . for one root node @xmath236",
    ", we regard its reliability metric as an inheritance from the predecessor @xmath237 .",
    "applying lemma [ c0_mode_ub_set ] and ( [ bhattaharyya_bound_log ] ) on all the subtrees , we can evaluate the reliability of each leaf node . obviously , the rightmost subtree @xmath157 has the largest depth and its rightmost path has the maximal path weight @xmath230 .",
    "furthermore , the leftmost path of each subtree has the maximal complemental path weight @xmath230 .    for a code tree shown in fig .",
    "[ fig_code_tree](a ) , the rightmost path on the subtree @xmath157 has the maximal path weight @xmath117 .",
    "and the leftmost path on all subtrees has the maximal complemental path weight @xmath117 .",
    "the reliability metrics of two root nodes @xmath238 and @xmath239 are inherited from those of the predecessors @xmath240 and @xmath241 respectively , that is @xmath242 and @xmath243 .",
    "the quasi - uniform puncturing ( qup ) algorithm proposed in @xcite can be outlined as follows .    1 .",
    "initialize the table @xmath63 as all ones , and then set the first @xmath75 bits as zeros ; 2 .",
    "perform bit - reversal permutation on the table @xmath63 and obtain the puncturing table .",
    "the puncturing table generated by the qup algorithm is constructive and regular , thereby providing useful tool for the practical application of coding and decoding .",
    "the initial table is @xmath245 .",
    "after bit - reversal permutation , the puncturing table is @xmath246 , that means the code bits @xmath100 , @xmath247 , and @xmath248 should be punctured .",
    "[ theorem5 ] the punctured positions in the qup puncturing table are roughly uniform , that is , the distance between any two neighboring punctured positions , @xmath249 , satisfies @xmath250 where @xmath251 .",
    "this theorem is proved in @xcite .",
    "[ lemma8 ] for the qup algorithm , the source bit vector @xmath252 is punctured , that is , @xmath253 . equally , the @xmath75 leftmost leaf nodes on the code tree are pruned .    from the operation of qup algorithm , the puncturing set of code bits @xmath84",
    "is generated after bit - reversal permutation .",
    "recall that the source vector can be written by @xmath254 , so the source vector @xmath39 is punctured by the natural order , that is , @xmath253 .",
    "equally , the leaf nodes set @xmath255 on the code tree and the corresponding subtrees are pruned .",
    "meanwhile , each of the rest subtrees has a different depth .",
    "theoretically , the optimal puncturing table of rcpp codes can be optimized by a brute - force search of the distance spectra ( for ml decoding ) or bler bounds ( for sc decoding ) . however , the exhausted search for all the puncturing patterns is difficult to be realized .",
    "we are , therefore , concerned with the puncturing scheme to optimize the spectrum distances .",
    "[ lemma9 ] for a subtree after any puncturing scheme under the c0 mode , suppose @xmath143 and @xmath256 are a root node and its predecessor respectively .",
    "let @xmath257 denote a pruned path from the original root @xmath240 to a punctured leaf node and containing the leftmost path of the subtree @xmath258 .",
    "so the reliability of the root node @xmath143 can be addressed by @xmath259 where @xmath260 is the complemental path weight .    given the puncturing set of source bits @xmath79 for an arbitrary puncturing , the leaf nodes pertaining to this set can be bit - by - bit punctured on the original code tree . obviously",
    ", the source bit @xmath155 should be punctured firstly and the reliability metrics of the root nodes on the resulted subtrees can be inherited from the predecessors on the pruned path @xmath261 by theorem [ theorem4 ] . since the pruned path @xmath261 is an all - zero path , the corresponding path weight is @xmath116 and only the complemental path weight affects the calculation of the reliability . assuming that one root node is @xmath236 and the corresponding partial path ( from the original root to this node ) is @xmath262 , the reliability of this root can be expressed as @xmath263 .",
    "furthermore , the rest punctured source bits can be pruned from these subtrees .",
    "each subtree @xmath264 can be regarded as a perfect code tree . according to lemma [ lemma5 ] ,",
    "the leftmost path on these trees will be punctured and a group of new subtrees are generated .",
    "then , for a root node @xmath143 on a final subtree , assuming the corresponding path @xmath265 is a path from the original root to this root node , by theorem [ theorem4 ] , the reliability can be written as @xmath266",
    ". generally , the pruned path @xmath257 can be decomposed into two partial paths , that is , @xmath267 , where the partial path @xmath268 is a path from the original root @xmath240 to the node @xmath256 and the partial path @xmath269 is a path from the node @xmath256 to the pruned leaf node . by lemma [ lemma5 ] , the path @xmath269 is an all - zero path and the branch between the node @xmath256 and the node @xmath143 is taken the value @xmath117 .",
    "hence , we have @xmath270 .    [ theorem6 ] given a rcpp code with a length @xmath271 , for the c0 mode , the puncturing table generated by the qup algorithm will maximize the spectrum distance sd1 .",
    "for an arbitrary puncturing scheme under the c0 mode , the original code tree can be decomposed into a group of subtrees . assuming that each subtree has a depth @xmath272 and @xmath273 leaf nodes , the depth satisfies @xmath274 by theorem [ theorem4 ] .",
    "so the code length @xmath76 can be expressed as @xmath275 where @xmath276 stands for the number of subtrees with the depth @xmath272 .",
    "define a set @xmath277 , whose elements are arranged in the ascending order , that is , @xmath278 .",
    "so we can calculate the sd1 over all subtrees by lemma [ lemma9 ] , yielding @xmath279&=\\sum\\limits_{j = 1}^{|\\mathcal{e}| } \\sum\\limits_{k = 0}^{l_j } { \\frac{1}{m}}\\binom{l_j}{k}k\\alpha_{l_j}\\\\                                                      & = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } \\sum\\limits_{k = 0}^{l_j } { \\frac{2^{l_j}}{m}}{\\frac{1}{2^{l_j}}}\\binom{l_j}{k}k\\alpha_{l_j}\\\\                                                      & = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{l_j}}{m}}\\alpha_{l_j } \\sum\\limits_{k = 0}^{l_j}{\\frac{1}{2^{l_j}}}\\binom{l_j}{k}k                                                      = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{{l_j}-1}}{m}}{l_j}\\alpha_{l_j}. % \\overset{(1)}{= } \\end{aligned}\\ ] ] just as the proof of corollary [ corollary2 ] , the last equality is derived from the mean of binomial distribution .    for any puncturing scheme",
    ", the number @xmath280 can be an arbitrary integer , such as @xmath276 .",
    "we can treat the structure of sd1 in ( [ sd1_c0_equ ] ) as a representation and carry of binary number from low - order to high - order .",
    "assuming two consecutive orders @xmath281 and @xmath272 ( @xmath282 ) and the corresponding digits @xmath283 and @xmath284 , it is easy to assert @xmath285 hence , in order to maximize sd1 , the digits @xmath280 should be limited to @xmath116 or @xmath117 .",
    "this means that @xmath286 is the binary expansion of the code length @xmath76 .    on the other hand , according to lemma [ lemma8 ] , the digits @xmath280 corresponding the qup algorithm are taken the values @xmath116 or @xmath117 .",
    "therefore , the puncturing table of qup algorithm can maximize the sd1 .",
    "[ theorem7 ] given a rcpp code with a length @xmath271 , for the c0 mode , the puncturing table generated by the qup algorithm will maximize the spectrum distance jsd .",
    "like the proof of theorem [ theorem6 ] , for an arbitrary puncturing scheme under the c0 mode , the code length can be expanded by ( [ equ_code_length ] ) . for the subtrees with the same depth @xmath272 ,",
    "define @xmath287 as a pruned path set , where @xmath288 is the @xmath289-th pruned path containing a predecessor of one subtree .",
    "let @xmath290 .",
    "thus , according to lemma [ lemma9 ] , the spectrum distance sd0 can be calculated by averaging over all subtrees to yield @xmath291                    = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } \\sum\\limits_{s = 1}^{\\alpha_{l_j } } \\sum\\limits_{r = 0}^{l_j } { \\frac{1}{m}}\\binom{l_j}{r}\\left(r+n_{j , s}-l_j\\right)\\\\                    & = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } \\sum\\limits_{s = 1}^{\\alpha_{l_j } } \\sum\\limits_{r = 0}^{l_j } { \\frac{1}{m}}\\binom{l_j}{r } n_{j , s }                       -\\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{{l_j}-1}}{m}}{l_j}\\alpha_{l_j}\\\\                    & = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{l_j}}{m}}\\sum\\limits_{s = 1}^{\\alpha_{l_j}}n_{j , s}-\\mathbb{e}\\left[d_h(\\omega_n)\\right ] % \\overset{(1)}{= } \\end{aligned}\\ ] ] where the second line is derived from the mean of the binomial distribution .",
    "the above expression enables us to explicitly represent the jsd as @xmath292+\\mathbb{e}\\left[f_h(\\omega_n)\\right]=\\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{l_j}}{m}}\\sum\\limits_{s = 1}^{\\alpha_{l_j}}n_{j , s}.\\ ] ]    we also treat the structure of jsd in ( [ jsd_c0_equ ] ) as a process of binary carry computation from low - order to high - order . assuming two consecutive orders @xmath293 and @xmath294 , if @xmath295 for an arbitrary puncturing , there are two digits , @xmath296 and @xmath297 , for two subtrees . on the contrary ,",
    "if qup scheme is applied , there is only one subtree and the corresponding digit is @xmath298 .",
    "obviously , we have @xmath299 therefore , the puncturing table generated by qup algorithm can maximize the jsd by a recursion of ( [ equ_jsd_c0_iter ] ) .    for puncturing with the qup algorithm ,",
    "the code length @xmath76 is expressible as @xmath300 where @xmath301 satisfies @xmath302 .",
    "the pwef1 of a rcpp code constructed by qup algorithm is @xmath303 .",
    "[ theorem8 ] suppose a rcpp code with the length @xmath271 , for the c0 mode , the sd1 corresponding to qup satisfies @xmath304\\le \\frac{n-1}{2}$ ] .",
    "first , we prove the right - side inequality . due to @xmath305 , we have @xmath306 next , let @xmath307 and @xmath308 , we need to prove @xmath309 . due to @xmath310 , we have @xmath311\\\\             & \\ge\\frac{1}{2m}\\left[2^{n-1}-\\sum\\limits_{k = 0}^{n-2 } \\left(n-2-k\\right)2^k\\right]\\\\             & \\overset{(1)}{=}\\frac{1}{2m}\\left[2^{n-1}-\\left(2^{n-1}-n\\right)\\right]=\\frac{n}{2m}>0 \\end{aligned}\\ ] ] where the equality ( 1 ) is derived from the summation of arithmetico - geometric sequence @xcite .    [ corollary8 ] for the c0 mode , the jsd corresponding to qup satisfies @xmath312 .    by theorem [ theorem7 ] ,",
    "for the qup puncturing , there is only one prune path corresponding to a subtree with a depth @xmath272 and this path contains the leftmost path of the parent subtree .",
    "so we have @xmath313 . like the proof in theorem [ theorem8 ] , we have @xmath314 .    for the left - side inequality , by theorem [ theorem8 ] , we have @xmath315\\ge n-2 $ ] .",
    "recall that for single bit puncturing under the c0 mode , any code bit puncturing is equivalent by theorem [ theorem3 ] .",
    "generally , we have the following definition about the equivalent class for multiple bit puncturing .",
    "given the puncturing set of source bits @xmath79 and its corresponding puncturing table @xmath63 ( or puncturing set of code bits @xmath84 ) , if another puncturing table @xmath316 ( or @xmath317 ) can generate the same set @xmath79 , we call these two tables @xmath63 and @xmath316 ( or two sets @xmath84 and @xmath317 ) are equivalent , that is , they belong to an equivalent class .    for the qup algorithm ,",
    "the puncturing length @xmath75 can be expressed as @xmath318 where @xmath319 and satisfies @xmath320 .",
    "further , let @xmath321 and @xmath322 .",
    "we introduce the function @xmath323 to simplify the analysis .    for the c0 mode ,",
    "the number of puncturing tables equivalent to that generated by qup algorithm is @xmath324 .",
    "given a dual trellis with the original length @xmath1 , we use @xmath325 to denote a variable node at the @xmath326-th row and the @xmath327-th column , where the row index is ascending from top to bottom and the column index is increasing from left to right .    by lemma [ lemma8 ]",
    ", the source puncturing set generated by the qup algorithm is @xmath253 .",
    "let @xmath328 and @xmath329 .",
    "the set @xmath79 can be decomposed into a group of subsets , that is , @xmath330 , where @xmath331 . by this decomposition",
    ", we can separately consider the number of equivalent tables corresponding to each subset .",
    "suppose there are @xmath332 source bits have been punctured , these nodes will generate @xmath333 equivalent puncturing schemes with @xmath334 candidate puncturing nodes at column @xmath335 due to the iterative application of lemma [ lemma2 ] .",
    "at the present , we calculate the number of equivalent puncturings corresponding to the source bits in @xmath336 .",
    "define the relative node set on the trellis as @xmath337 and the corresponding source vector as @xmath338 .",
    "let @xmath339 .",
    "after extending these nodes from column @xmath116 to column @xmath335 , we can obtain a local code vector @xmath340 which satisfies @xmath341 .",
    "so the corresponding nodes in the set @xmath342 become fully dependent by this local coding constraint . in order to puncture the nodes in @xmath336 ,",
    "the nodes in @xmath343 are inevitably punctured .    in all @xmath333 equivalent puncturing schemes",
    ", we consider each constraint between the candidate nodes of one scheme and the nodes in @xmath343 . without loss of generality ,",
    "the candidate nodes in the set @xmath344 are chosen to form a multi - butterfly constraint with the nodes in @xmath343 .    due to @xmath345",
    ", we have @xmath346 .",
    "let @xmath347 , we have @xmath348 . when extending from column @xmath335 to column @xmath349 , the nodes in @xmath350 can form a multi - butterfly constraint with those in @xmath351 , that is , @xmath352 where @xmath353 and @xmath354 . while , the nodes in @xmath355 are free and not constrained by the set @xmath351 .    hence , we consider the equivalent puncturing nodes corresponding to two sets @xmath350 and @xmath356 respectively . in the first case ,",
    "the node @xmath353 is a mandatory puncturing node and the node @xmath354 only is a candidate one . in order to ensure these two nodes",
    "are punctured , by lemma [ lemma2 ] , the generated nodes @xmath357 and @xmath358 must be punctured .",
    "when extending from column @xmath349 to column @xmath359 , each one of these two generated nodes can be regarded as a root of a tree with a depth @xmath360 . since only one node",
    "is punctured on each tree , by theorem [ theorem3 ] , the number of equivalent puncturing nodes is @xmath361 .",
    "therefore , the total number of this case is @xmath362 .    in the second case ,",
    "the node in @xmath356 is a mandatory puncturing node , which can also be regarded as a root of a tree with a depth @xmath363 . similarly by theorem [ theorem3 ] ,",
    "the total number of equivalent schemes for this case is @xmath364 .",
    "so the number of equivalent puncturings for the source bits in @xmath365 is @xmath366 .    iteratively applying the above analysis for all subsets , the number of equivalent puncturing tables of qup algorithm is calculated by @xmath367\\\\      & = h\\left[\\sum \\limits_{z=1}^{|\\mathcal{u}| } \\left(\\sum \\limits_{e=0}^{z } 2^{m_e } \\left(m_{z+1}-m_{z}\\right)-2\\sum \\limits_{e=0}^{z-1 }",
    "2^{m_e } \\right)\\right ] .",
    "\\end{aligned}\\ ] ]    the second term of the argument inside the function @xmath368 of ( [ equ_punc_class ] ) can be rewritten as @xmath369 where @xmath370 due to @xmath321 .",
    "expanding the first term of the argument inside the function @xmath368 of ( [ equ_punc_class ] ) and by @xmath322 , we have @xmath371\\\\ & = \\sum \\limits_{e=0}^{1 } 2^{m_e } \\left(m_2-m_1\\right)+\\cdots+\\sum \\limits_{e=0}^{|\\mathcal{u}| } 2^{m_e } \\left(m_{|\\mathcal{u}|+1}-m_{|\\mathcal{u}|}\\right)\\\\ & = -\\sum \\limits_{z=1}^{|\\mathcal{u}| } m_z 2^{m_z}+m_{|\\mathcal{u}|+1 } \\sum \\limits_{e=0}^{|\\mathcal{u}| } 2^{m_e}\\\\ & = \\sum \\limits_{z=1}^{|\\mathcal{u}| } \\left(n - m_z\\right ) 2^{m_z}. \\end{aligned}\\ ] ]    combining ( [ hfun_2nd_sum ] ) and ( [ hfun_1st_sum ] ) , we complete the proof .",
    "an equivalent class example for the qup puncturing under the c0 mode is shown in fig .",
    "[ figure_equclass_puncturing_c0mode ] . given a dual trellis with the original code length @xmath372 and the punctured bits number @xmath373 , the puncturing set of source bits is @xmath374 .",
    "due to @xmath375 , we have @xmath376 and @xmath377 .    as shown in fig .",
    "[ figure_equclass_puncturing_c0mode ] , since the nodes @xmath378 and @xmath379 compose a butterfly constraint ( marked by a blue dash box ) , @xmath380 and @xmath381 are the mandatory puncturing nodes . on the other hand ,",
    "the node @xmath382 has two candidate puncturing nodes @xmath383 and @xmath384 ( marked by a green cross ) .",
    "therefore , for the puncturing nodes in @xmath385 , the number of equivalent puncturings is @xmath386 .",
    "assuming the candidate node @xmath383 is selected to be punctured , then the nodes @xmath387 and @xmath388 must be punctured because these two nodes form a butterfly constraint with the nodes @xmath380 and @xmath383 .",
    "hence , the number of equivalent puncturings for the node @xmath381 is @xmath389 , which is corresponding to a perfect tree with the root @xmath381 ( marked by red lines ) .",
    "moreover , the number of equivalent puncturings for the nodes @xmath387 and @xmath388 is @xmath390 , which is relative to two perfect trees with these two nodes as the roots ( marked by purple and yellow lines respectively ) .",
    "so the total number of equivalent puncturing tables is @xmath391 .    as an example , the puncturing set corresponding to qup algorithm is @xmath392 .",
    "there are two sets with equivalent puncturing , that is , @xmath393 and @xmath394 .",
    "we can arbitrarily select three indices from each set of these two set and form an equivalent puncturing scheme , such as @xmath395 or @xmath396 .     and",
    "in this section , reversal quasi - uniform puncturing ( rqup ) is described and proved to maximize the sd0 and jsd .",
    "single bit puncturing under the c1 mode is symmetric to the operation under the c0 mode .",
    "therefore , the corresponding polar spectra are also almost optimal .",
    "[ theorem11 ] for single bit puncturing under the c1 mode , the maximal complemental path weight on the code tree is @xmath230 , in addition , the maximal path weight is @xmath230 .    based on the symmetry of single bit puncturing under the c0 and c1 modes , the proof is similar to that of theorem [ theorem4 ] and omitted .      for the c1 mode",
    ", the reversal quasi - uniform puncturing ( rqup ) algorithm can be described as follows :    1 .",
    "initialize the table @xmath63 as all ones , and then set the last @xmath75 bits of the vector as zeros ; 2 .",
    "perform bit - reversal permutation on the table @xmath63 and obtain the puncturing table .",
    "one of the main differences between rqup and qup algorithm is that the initialization table of rqup is reversal to that of qup .",
    "the puncturing table generated by the rqup algorithm is also constructive and regular .",
    "it is easy to prove that rqup has a similar property of theorem [ theorem5 ] .",
    "rqup algorithm can ensure that each punctured code bit is known by the decoder .",
    "let @xmath398 denote the codeword after bit - reversal permutation .",
    "for the rqup algorithm , the subvector @xmath399 should be punctured . due to the coding constraint @xmath400 and the lower - triangle property of the matrix @xmath401 ,",
    "if each source bit @xmath402 is set to a frozen value , each bit @xmath403 will be set to a fixed value .",
    "[ corollary10 ] for the rqup algorithm , the source bit vector @xmath404 is punctured , that is , @xmath405 . equally , the @xmath75 rightmost leaf nodes on the code tree are pruned .",
    "like the rcpp code design under the c0 mode , we also concern the puncturing scheme under the c1 mode to optimize the spectrum distance .",
    "[ lemma11 ] for a subtree after any puncturing scheme under the c1 mode , suppose @xmath143 and @xmath256 are the root node and its predecessor .",
    "let @xmath257 denote a pruned path containing the rightmost path of the subtree @xmath258 .",
    "so the reliability of the root node @xmath143 can be expressed by @xmath406 .    like the proof of lemma [ lemma9 ] , for a root node @xmath143 on a final subtree , assuming the corresponding path @xmath265 is a path from the original root to this root node , by lemma [ c1_mode_ub_set ] , the reliability can be written as @xmath407 .",
    "further , like the definition in lemma [ lemma9 ] , the pruned path @xmath257 can be decomposed into two partial paths , that is , @xmath267 . by lemma [ lemma6 ] ,",
    "the path @xmath269 is an all - one path and the branch between the node @xmath256 and the node @xmath143 is taken the value @xmath116 .",
    "hence , we have @xmath408 .",
    "[ theorem14 ] given a rcpp code generated under the c1 mode , the puncturing table generated by the rqup algorithm will maximize the spectrum distance sd0 .",
    "for an arbitrary puncturing scheme under the c0 mode , the original code tree can be decomposed into a group of subtrees .    using the binary expansion in ( [ equ_code_length ] ) and the definition of set @xmath409 in theorem [ theorem6 ]",
    ", we can calculate and average the spectrum distance sd0 over all subtrees by lemma [ lemma11 ] , that is , sd0 can be written as @xmath410=\\sum\\limits_{j = 1}^{|\\mathcal{e}| } \\sum\\limits_{r = 0}^{l_j } { \\frac{1}{m}}\\binom{l_j}{r}r\\alpha_{l_j }                                                      = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{{l_j}-1}}{m}}{l_j}\\alpha_{l_j}. % \\overset{(1)}{= } \\end{aligned}\\ ] ]    like the proof in theorem [ theorem6 ] , in order to maximize sd0 , the digit @xmath280 should be limited to @xmath116 or @xmath117 .",
    "this means that @xmath411 is the binary representation of the code length @xmath76 .",
    "therefore , the rqup algorithm can maximize sd0 .    given a rcpp code with a length @xmath271 , for the c1 mode",
    ", the puncturing table generated by the rqup algorithm will maximize the spectrum distance jsd .    like the proof of theorem [ theorem7 ] , for an arbitrary puncturing scheme under the c1 mode",
    ", we introduce a pruned path set @xmath287 and a digit @xmath412 .",
    "so sd1 can be calculated and averaged over all subtrees by lemma [ lemma11 ] , that is , @xmath413                    = \\sum\\limits_{j = 1}^{|\\mathcal{e}| } { \\frac{2^{l_j}}{m}}\\sum\\limits_{s = 1}^{\\alpha_{l_j}}n_{j , s}-\\mathbb{e}\\left[f_h(\\omega_n)\\right ] .",
    "% \\overset{(1)}{=}\\ ] ] by the same proof in theorem [ theorem7 ] , we conclude that rqup algorithm can maximize the jsd .",
    "the pwef0 of a rcpp code constructed by rqup algorithm is @xmath414    where the set @xmath415 is defined in ( [ equ_code_length_qup ] ) .",
    "[ theorem16 ] suppose a rcpp code with a length @xmath271 , for the c1 mode , the sd0 and jsd corresponding to rqup satisfies @xmath416\\le \\frac{n-1}{2}$ ] and @xmath312 respectively .",
    "the proof is similar to that of theorem [ theorem8 ] and corollary [ corollary8 ] .",
    "in this section , at first , we compare various puncturing schemes under the c0 or c1 modes by calculating the spectrum distances sd0/sd1",
    ". then rcpp codes based on different puncturing schemes under sc or scl decodings are evaluated .",
    "furthermore , the blers of rcpp and turbo codes are also compared via simulations over awgn channels .",
    "we compare the spectrum distances of various puncturing schemes . for the c0 mode",
    ", we mainly concern three typical puncturing schemes , such as qup algorithm @xcite , the algorithm proposed by eslami _",
    "_ @xcite and that proposed by shin _",
    "_ @xcite . on the other hand , for the c1 mode , we mainly investigate two puncturing schemes , such as rqup algrithm proposed in this paper and the algorithm proposed by wang _",
    ". _ @xcite . for the latter ,",
    "given the generator @xmath85 , the index of column with column weight 1 is selected as the punctured position .",
    "however there may be many selections for the column weight 1 as stated in ( * ? ? ?",
    "* algorithm1 ) . in order to simplify evaluation , we use a puncturing table where the last @xmath75 code bits are punctured as a reference of wang algorithm .        for all the puncturing schemes under the c0 or c1 modes , the spectrum distances sd1/sd0 versus code length ( @xmath417 ) are shown in fig .",
    "[ fig_sd0_sd1_vs_code_length ] . among the three puncturing schemes",
    "( qup / shin / eslami ) under the c0 mode , the sd1 of qup algorithm is larger than that of the others due to the optimal polar spectra ps1 .",
    "similarly , the sd0 of rqup is better than that of wang method due to the optimal ps0 .",
    "recall that the polar spectra of qup and rqup schemes are symmetrical , the sd1 of qup and sd0 of rqup are overlapped as depicted in fig .",
    "[ fig_sd0_sd1_vs_code_length ] .",
    "further , we observe that the sd1 ( sd0 ) of qup ( rqup ) is distributed between @xmath418 and @xmath419 which is consistent with theorem [ theorem8 ] ( [ theorem16 ] ) .    for jsds of all the puncturing schemes",
    ", we can observe the similar results , that is , qup or rqup have the maximal jsds under the c0 or c1 modes . due to the limitation of space , these results are not shown here .",
    "however , the performance comparison just based on jsd may result a bias conclusion . as an example , sd1 versus sd0 at the code length @xmath420 for all the schemes is drawn in fig . [ fig_sd1_vs_sd0 ] .        in this @xmath73-d chart ,",
    "the point a located at @xmath421 is relative to the sd1/sd0 of the original polar code with the code length @xmath422 .",
    "recall that the aim of rcpp codes optimization is to approach the spectrum distances of the parent codes as close together as possible , that is , in this chart , the more one point corresponding to a puncturing scheme is close to the point a , the better this scheme will achieve an error performance .",
    "all points relative to qup are concentrated at @xmath423 and all points relative to rqup at @xmath424 . obviously , among the three puncturing schemes ( qup / shin / eslami ) under the c0 mode , qup has the maximal value of sd1 when the value of sd0 is fixed .",
    "on the other hand , given the fixed sd1 , the sd0 of qup is larger than that of wang scheme .",
    "first , we compare the error performance of rcpp codes with various puncturing schemes under the bi - awgn channels .",
    "the gaussian approximation algorithm @xcite is applied to construct these codes . given the sc decoding and the parent code length @xmath425 , the bler performance comparisons of rcpp codes based on all the puncturing schemes with the code length @xmath426 are shown in fig .",
    "[ fig_varrate_sc_comp ] for the code rate @xmath427 , @xmath428 and @xmath429 respectively .     and code rate @xmath430 ( the parent code length @xmath431 ) . ]    for the low code rate @xmath427 , compared with other schemes , such as wang , rqup and shin algorithms",
    ", we can see that qup achieves the best error performance .",
    "on the other hand , for the high code rate @xmath428 , rqup is the best one among all the puncturing schemes . these results are consistent with the analysis in section [ section_v ] and [ section_vi ] .",
    "further , we find that the error performance of qup is worse than that of rqup in the high code rate and vice versa in the low code rate .",
    "especially , we observe that the schemes of qup , rqup and wang can achieve almost the same performance and they are better than shin or eslami schemes .",
    "these phenomena may imply that the code rate @xmath429 is a critical value .",
    "so rqup will be the best scheme when @xmath432 and qup will be the best one when @xmath433 .",
    "next we compare the performance of rcpp and turbo codes under awgn channel .",
    "rcpp codes are constructed from the parent code with the code length @xmath425 by qup or rqup schemes and ca - scl is used as a decoding algorithm with the maximum list size @xmath434 .",
    "an eight - state turbo code in 3gpp lte standard @xcite is used as a reference .",
    "a crc code is used in all concatenation coding schemes ( both for turbo and rcpp codes ) .",
    "the log - map algorithm is applied in turbo decoding and the maximum number of iterations is @xmath435 .     and",
    "bler of @xmath436    we investigate the relationship of bit signal noise ratio ( snr ) and code length for these two codes .",
    "the performance curves of @xmath437 vs code length @xmath76 ( @xmath438 ) for the lte turbo and rcpp codes ( punctured by qup and rqup algorithms ) at the bler of @xmath439 and code rate @xmath440 are shown in fig .",
    "[ fig_coding_gain33 ] .    in most cases",
    ", rcpp codes can achieve additional coding gains relative to lte turbo codes .",
    "for the low code rate @xmath427 , as shown in fig .",
    "[ fig_coding_gain33 ] , a maximum @xmath441 db additional gain can be obtained at the code length @xmath442 and the rcpp codes punctured by qup algorithms can achieve slightly better performance than those codes punctured by rqup . on the other hand , for the high code rate @xmath428 , a maximum @xmath443 db performance gain",
    "can be attained at the code length @xmath442 and the bler of @xmath444 .",
    "in contrast to the case of low code rate , the rqup algorithms can generate better rcpp codes in this case .    for the medium code rate @xmath429 , additional gain",
    "can be obtained and the rcpp codes punctured by qup or rqup algorithms can achieve the same performance . due to the limitation of space , these results are not shown .",
    "in this paper , we propose a theoretic framework based on the polar spectra to analyze and design rate - compatible punctured polar code .",
    "guided by the spectrum distances , two simple quasi - uniform puncturing methods ( qup and rqup ) are proposed to generate the puncturing tables under the c0/c1 modes . by the analysis of the performance metrics , such as sd0/sd1/jsd",
    ", we prove that these two algorithms can achieve the maximal value of corresponding spectrum distance .",
    "simulation results in awgn channel show that the performance of rcpp codes by qup or rqup can be equal to or exceed that of the turbo codes at the same code length .      without loss of generality , we consider the polarization of the first scenario @xmath103 , that is , @xmath445 . under the c0 mode , due to @xmath446 , for @xmath447",
    ", the transition probabilities of polarized channel @xmath448 can be written by @xmath449 so the channel @xmath448 is degraded to a punctured channel and @xmath450 .",
    "on the other hand , we analyze the llr of polarized channel @xmath451 .",
    "let @xmath452 denote the llr of b - dmc @xmath453 .",
    "due to @xmath454 , the corresponding probability density function ( pdf ) is @xmath455 , where @xmath456 is the dirac function .",
    "since the source bit @xmath106 is relative to a variable node , the pdf of the corresponding llr can be derived as @xmath457 where @xmath458 is the convolutional operation .",
    "so the polarized channel @xmath451 has the same reliability as that of the original b - dmc , that is , @xmath459 .          by the coding relationship @xmath227 , the channel transition probabilities can be presented as @xmath462 where the punctured vector @xmath463 is composed of the punctured code bits @xmath464 ( @xmath465 ) , and",
    "the corresponding received vector can be written by @xmath466 .    under the c1 mode , we assume @xmath467 is only true for each specific pair @xmath468 . therefore , for the specific vector @xmath469 , we can write @xmath470",
    ". let @xmath471 and @xmath472 .",
    "furthermore , these two vectors satisfy @xmath473 and @xmath474 respectively .",
    "so we have @xmath475 where @xmath476 .",
    "recall that the value of the punctured bit in the c1 mode is known by the decoder . apparently , puncturing the code bit @xmath101 is a good selection because this bit is only involved one source bit @xmath106 .",
    "hence , in order to ensure that the bit @xmath101 is punctured and has a fixed value to the decoder , as shown in fig .",
    "[ fig_two_channel](c ) , the puncturing table should be @xmath104 .",
    "let @xmath481 and @xmath482 denote the llrs of the source bits @xmath155 and @xmath106 ( @xmath483 ) respectively .",
    "considering the check node constraint , we have @xmath484 where @xmath485 is the hyperbolic tangent function .",
    "therefore , we can conclude that @xmath486 .",
    "e. arikan , `` channel polarization : a method for constructing capacity achieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _",
    "55 , no . 7 , pp . 3051 - 3073 , july 2009 ."
  ],
  "abstract_text": [
    "<S> polar codes are the first class of constructive channel codes achieving the symmetric capacity of the binary - input discrete memoryless channels . </S>",
    "<S> but the corresponding code length is limited to the power of two . in this paper , we establish a systematic framework to design the rate - compatible punctured polar ( rcpp ) codes with arbitrary code length . a new theoretic tool , called polar spectra , </S>",
    "<S> is proposed to count the number of paths on the code tree with the same number of zeros or ones respectively . </S>",
    "<S> furthermore , a spectrum distance sd0 ( sd1 ) and a joint spectrum distance ( jsd ) are presented as performance criteria to optimize the puncturing tables . for the capacity - zero puncturing mode ( punctured bits are unknown to the decoder ) </S>",
    "<S> , we propose a quasi - uniform puncturing algorithm , analyze the number of equivalent puncturings and prove that this scheme can maximize sd1 and jsd . </S>",
    "<S> similarly , for the capacity - one mode ( punctured bits are known to the decoder ) , we also devise a reversal quasi - uniform puncturing scheme and prove that it has the maximum sd0 and jsd . </S>",
    "<S> both schemes have a universal puncturing table without any exhausted search . </S>",
    "<S> these optimal rcpp codes outperform the performance of turbo codes in lte wireless communication systems .    </S>",
    "<S> polar codes , rate - compatible punctured polar ( rcpp ) codes , polar spectra , path weight enumerating function ( pwef ) , spectrum distance ( sd ) . </S>"
  ]
}