{
  "article_text": [
    "the classical mean - payoff games  @xcite are two - player zero - sum games that are played on weighted finite graphs , where two players  max and min  take turn to move a token along the edges of the graph to jointly construct an infinite play .",
    "the objectives of the players max and min are to respectively maximize and minimize the limit average reward associated with the play .",
    "mean - payoff games are well - studied in the context of optimal controller synthesis in the framework of ramadge - wonham  @xcite , where the goal of the game is to find a control strategy that maximises the average reward earned during the evolution of the system .",
    "mean - payoff games enjoy a special status in verification , since @xmath0-calculus model checking and parity games can be reduced in polynomial - time to solving mean - payoff games .",
    "mean - payoff objectives can also be considered as quantitative extensions  @xcite of classical bchi objectives , where we are interested in the limit - average share of occurrences of accepting states rather than merely in whether or not infinitely many accepting states occur . for a broader discussion on quantitative verification , in general , and the transition from the classical qualitative to the modern quantitative interpretation of deterministic bchi automata , we refer the reader to henzinger s excellent survey  @xcite .",
    "we study mean - payoff games played on an infinite configuration graph of timed automata .",
    "asarin and maler  @xcite were the first to study games on timed automata and they gave an algorithm to solve timed games with reachability time objective .",
    "their work was later generalized and improved upon by alur et al .",
    "@xcite and bouyer et al .",
    "bouyer et al .",
    "@xcite also studied the more difficult average payoffs , but only in the context of scheduling , which in game - theoretic terminology corresponds to 1-player games .",
    "however , they left the problem of proving decidability of 2-player average reward games on priced timed automata open .",
    "jurdziski and trivedi  @xcite proved the decidability of the special case of average time games where all locations have unit costs .",
    "more recently , mean - payoff games on timed automata have been studied by brenguier , cassez and raskin @xcite where they consider average payoff per time - unit . using the undecidability of _ energy games _",
    "@xcite , they showed undecidability of mean - payoff games on weighted timed games with five or more clocks .",
    "they also gave a semi - algorithm to solve cycle - forming games on timed automata and characterized the conditions under which a solution of these games gives a solution for mean - payoff games .",
    "on the positive side , we characterize general conditions under which dynamic programming based techniques can be used to solve the mean - payoff games on timed automata . as a proof - of - concept",
    ", we consider one - clock binary - priced timed games , and prove the decidability of mean - payoff games for this subclass .",
    "our decidability result can be considered as the average - payoff analog of the decidability result by brihaye et al .",
    "@xcite for reachability - price games on timed automata .",
    "we strengthen the known undecidability results for mean - payoff games on timed automata in three ways : i ) we show that the mean - payoff games over priced timed games is undecidable for timed games with only three clocks ; ii ) secondly , we show that undecidability can be achieved with binary price - rates ; and finally , iii ) our undecidability results are applicable for problems where the average payoff is considered per move as well as for problems when it is defined per time - unit .",
    "howard  @xcite introduced gain and bias optimality equations to characterize optimal average on one - player finite game arenas .",
    "gain and bias optimality equations based characterization has been extended to two - player game arenas  @xcite as well as many subclasses of uncountable state and action spaces  @xcite . the work of bouyer et al .",
    "@xcite is perhaps the closest to our approach  they extended optimality equations approach to solve games on hybrid automata with certain strong reset assumption that requires all continuous variables to be reset at each transition , which in the case of timed automata is akin to requiring all clocks to be reset at each transition . to the best of our knowledge , the exact decidability for timed games does not immediately follow from any previously known results .",
    "howard s optimality equations requires two variable per state : the gain of the state and the bias of the state . informally speaking",
    ", the gain of a state corresponds to the optimal mean - payoff for games starting from that state , while the bias corresponds to the limit of transient sum of step - wise deviations from the optimal average .",
    "hence , intuitively at a given point in a game , both players would prefer to first optimize the gain , and then choose to optimize bias among choices with equal gains .",
    "we give general conditions under which a solution of gain - bias equations for a finitary abstraction of timed games can provide a solution of gain - bias equations for the original timed game . for this purpose , we exploit a region - graph like abstraction of timed automata  @xcite called the boundary region abstraction ( bra ) .",
    "our key contribution is the theorem that states that every solution of gain - bias optimality equations for boundary region abstraction carries over to the original timed game , as long as for every region , the gain values are constant and the bias values are affine .",
    "the paper is organized in the following manner . in section  [ sec : prelims ]",
    "we describe mean - payoff games and introduce the notions of _ gain _ and _ bias _ optimality equations .",
    "this section also introduces mean - payoff games over timed automata and states the key results of the paper .",
    "section [ sec : brg ] introduces the _ boundary region abstraction _ for timed automata and characterizes the conditions under which the solution of a game played over the boundary region abstraction can be lifted to a solution of mean payoff game over priced timed automata . in section  [ sec : dec ] we present the strategy improvement algorithm to solve optimality equations for mean - payoff games played over boundary region abstraction and connect them to solution of optimality equations over corresponding timed automata .",
    "finally , section [ sec : undec ] sketches the undecidability of mean - payoff games for binary - priced timed automata with three clocks .",
    "we begin this section by introducing mean - payoff games on graphs with uncountably infinite vertices and edges , and show how , and under what conditions , gain - bias optimality equations characterize the value of mean - payoff games .",
    "we then set - up mean - payoff games for timed automata and state our key contributions .",
    "a game arena @xmath1 is a tuple @xmath2 where @xmath3 is a ( potentially uncountable ) set of states partitioned between sets @xmath4 and @xmath5 of states controlled by player min and player max , respectively ; @xmath6 is a ( potentially uncountable ) set of _ actions _ ; @xmath7 is a partial function called _ transition function _ ; and @xmath8 is a partial function called _",
    "price function_.    we say that a game arena is _ finite _ if both @xmath3 and @xmath6 are finite . for any state @xmath9 , we let @xmath10 denote the set of actions available in @xmath11 , i.e. , the actions @xmath12 for which @xmath13 and @xmath14 are defined . a transition of a game arena is a tuple @xmath15 such that @xmath16 and we write @xmath17 .",
    "a finite play starting at a state @xmath18 is a sequence of transitions @xmath19 such that for all @xmath20 we have that @xmath21 is a transition . for a finite play @xmath22",
    "we write @xmath23 for the final state of @xmath24 , here @xmath25 .",
    "the concept of an infinite play @xmath26 is defined in an analogous way .",
    "we write @xmath27 and @xmath28 for the set of plays and the set of finite plays starting at @xmath9 respectively .",
    "a _ strategy _ of player @xmath29 is a function @xmath30 such that @xmath31 for all finite plays @xmath32 , i.e.  for any finite play , a strategy of @xmath29 returns an action available to @xmath29 in the last state of the play .",
    "a strategy @xmath33 of @xmath34 is defined analogously and we let @xmath35 and @xmath36 denote the sets of strategies of @xmath29 and @xmath34 , respectively . a strategy @xmath37 is _ positional _ if @xmath38 implies @xmath39 for all @xmath40 .",
    "this allows us to represent a positional strategy as a function in @xmath41 $ ] .",
    "let @xmath42 and @xmath43 denote the set of positional strategies of @xmath29 and @xmath34 , respectively .",
    "for any state @xmath11 and strategy pair @xmath44 , let @xmath45 denote the unique infinite play @xmath26 in which @xmath29 and @xmath34 play according to @xmath0 and @xmath33 , respectively , i.e. for all @xmath46 we have that @xmath47 implies @xmath48 and @xmath49 implies @xmath50 .",
    "in a mean - payoff game on a game arena , players @xmath29 and @xmath34 move a token along the transitions indefinitely thus forming an infinite play @xmath51 in the game graph .",
    "the goal of player @xmath29 is to minimize @xmath52 and the goal of player @xmath34 is to maximize @xmath53 .",
    "the _ upper value _",
    "@xmath54 and the lower value @xmath55 of a state @xmath9 are defined as : @xmath56 respectively .",
    "it is always the case that @xmath57 .",
    "a mean - payoff game is called _ determined _ if for every state @xmath9 we have that @xmath58 . then , we write @xmath59 for this number and we call it the _ value _ of the mean - payoff game at state  @xmath11 .",
    "we say that a game is _ positionally - determined _ if for every @xmath60 we have strategies @xmath61 and @xmath62 such that for every initial state @xmath9 , we have that @xmath63 for a given @xmath64 we call each such strategy an @xmath64-optimal strategy for the respective player .",
    "given two functions @xmath65 ( gain ) and @xmath66 ( bias ) , we say that @xmath67 is a solution to the optimality equations for mean - payoff game on @xmath68 , denoted @xmath69 if @xmath70 we prove the following theorem connecting a solution of the optimality equations with mean - payoff games .",
    "we exploit this theorem to solve mean - payoff games on timed automata .",
    "[ thm : gain - bias - correctness ] if there exists a function @xmath65 with finite image and a function @xmath66 with bounded image such that @xmath71 then for every state @xmath9 , we have that @xmath72 and for every @xmath73 both players have positional @xmath64-optimal strategies .",
    "assume that we are given the functions @xmath65 with finite image and @xmath66 with bounded image such that @xmath71 . in order to prove the result we show , for every @xmath60",
    ", the existence of positional strategies @xmath74 and @xmath75 such that @xmath76 the proof is in two parts .    * given @xmath60 we compute the positional strategy @xmath77 satisfying the following conditions : @xmath78 if @xmath79 where @xmath17 . notice that it is always possible to find such strategy since @xmath67 satisfies optimality equations and @xmath80 is finite image .",
    "+ now consider an arbitrary strategy @xmath81 and consider the run @xmath82 .",
    "notice that for every @xmath46 we have that @xmath83 if @xmath49 and @xmath84 if @xmath47 . hence @xmath85 is a non - increasing sequence .",
    "since @xmath80 is finite image , the sequence eventually becomes constant .",
    "assume that for @xmath86 we have that @xmath87 .",
    "now notice that for all @xmath86 we have that @xmath88 if @xmath49 and @xmath89 if @xmath47 . summing these equations",
    "sidewise form @xmath90 to @xmath91 we have that @xmath92 .",
    "rearranging , we get @xmath93 since @xmath33 is an arbitrary strategy in @xmath36 , we have @xmath94 . *",
    "this part is analogous to the first part of the proof and is omitted .",
    "the proof is now complete .",
    "priced timed game arenas ( ptgas ) extend classical timed automata  @xcite with a partition of the actions between two players @xmath29 and @xmath34 .",
    "before we present the syntax and semantics of ptgas , we need to introduce the concept of clock variables and related notions .",
    "* let @xmath95 be a finite set of _",
    "clocks_. a _ clock valuation _ on @xmath95 is a function @xmath96 and we write @xmath97 ( or just @xmath98 when @xmath95 is clear from the context ) for the set of clock valuations . abusing notation",
    ", we also treat a valuation @xmath99 as a point in @xmath100 .",
    "let @xmath101 denote the clock valuation that assigns 0 to all clocks .",
    "if  @xmath102 and @xmath103 then we write @xmath104 for the clock valuation defined by @xmath105 for all @xmath106 . for @xmath107 , we write @xmath108 for the valuation where @xmath109 equals @xmath110 if @xmath111 and @xmath112 otherwise . for @xmath113 , we write @xmath114 for the smallest closed set in  @xmath98 containing @xmath115 .",
    "although clocks are usually allowed to take arbitrary non - negative values , for notational convenience we assume that there is a @xmath116 such that for every @xmath106 we have @xmath117 .    * clock constraints . * a _ clock constraint _ over @xmath95 with upper bound @xmath116 is a conjunction of _ simple constraints _ of the form @xmath118 or @xmath119 , where @xmath120 , @xmath121 , @xmath122 , and @xmath123 . for @xmath124 and @xmath116 , let @xmath125 be the set of clock constraints with upper bound @xmath126 which hold in  @xmath99 , i.e.  those constraints that resolve to @xmath127 after substituting each occurrence of a clock @xmath128 with @xmath129 .",
    "* regions and zones . *",
    "every clock region is an equivalence class of the indistinguishability - by - clock - constraints relation . for a given set of clocks @xmath95 and upper bound @xmath116 on clock constraints , a _ clock region _",
    "is a maximal set @xmath130 such that @xmath131 for all @xmath132 . for the set of clocks @xmath95 and upper bound @xmath126 we write @xmath133 for the corresponding finite set of clock regions .",
    "we write @xmath134 $ ] for the clock region of @xmath99 .",
    "a _ clock zone _ is a convex set of clock valuations that satisfies constraints of the form @xmath135 , @xmath136 , @xmath137 and @xmath138 .",
    "we write @xmath139 for the set of clock zones over the set of clocks @xmath95 and upper bound @xmath126 .",
    "when @xmath95 and @xmath126 are clear from the context we write @xmath140 and @xmath141 for the set of regions and zones . in this paper we fix a positive integer @xmath126 , and work with @xmath126-bounded clocks and clock constraints .",
    "a priced timed game arena is a tuple @xmath142 where @xmath143 and @xmath144 are sets of _ locations _ controlled by player min and player max and we write @xmath145 ; @xmath146 is a finite set of _ actions _ ; @xmath95 is a finite set of _ clocks _ ; @xmath147 is an _ invariant condition _ ; @xmath148 is an _",
    "action enabledness function _ ; @xmath149 is a _",
    "clock reset function _ ; @xmath150 is a _ transition function _ ; and @xmath151 is a _ price information function_. a ptga is binary - priced when @xmath152 for all @xmath153 .",
    "when we consider a ptga as an input of an algorithm , its size is understood as the sum of the sizes of encodings of @xmath154 , @xmath95 , @xmath155 , @xmath146 , @xmath156 , @xmath24 , @xmath157 and @xmath158 .",
    "we draw the states of @xmath29 players as circles , while states of @xmath34 player as boxes .",
    "let @xmath159 be a ptga .",
    "a _ configuration _ of a ptga is a pair @xmath160 , where @xmath161 is a location and @xmath99 a clock valuation such that @xmath162 . for any @xmath103 , we let @xmath163 equal the configuration @xmath164 . in a configuration @xmath165 , a timed action ( time - action pair ) @xmath166 is available if and only if the invariant condition @xmath167 is continuously satisfied while @xmath168 time units elapse , and @xmath169 is enabled ( i.e.  the enabling condition",
    "@xmath170 is satisfied ) after @xmath168 time units have elapsed .",
    "furthermore , if the timed action @xmath166 is performed , then the next configuration is determined by the transition relation @xmath157 and the reset function @xmath24 , i.e. the clocks in @xmath171 are reset and we move to the location @xmath172 .    a game on a ptga starts in an _ initial configuration _ @xmath173 and players @xmath29 and @xmath34 construct an infinite play by taking turns to choose available timed actions @xmath174 whenever the current location is controlled by them and the price @xmath175",
    "is paid to the max by player min .",
    "formally , ptga semantics is given as a game arena .",
    "[ ptgsem - def ] let @xmath159 be a ptga .",
    "the semantics of @xmath176 is given by game arena @xmath177   \\ ! ] } { = } ( s , s_{\\text{min } } , s_{\\text{max } } ,   a , t , \\pi)$ ] where    * @xmath178 is the set of states such that @xmath179 if and only if @xmath162 ; * @xmath180 ( or @xmath181 ) if @xmath182 and @xmath183 ( or @xmath184 , respectively ) .",
    "* @xmath185 is the set of _ timed actions _ ; * @xmath186 is the transition function such that for @xmath182 and @xmath187 , we have @xmath188 if and only if * * @xmath189 for all @xmath190 $ ] ; @xmath191 ; @xmath192 , @xmath193 , @xmath194 .",
    "* @xmath195 is the reward function where @xmath196 .",
    "we are interested in the mean - payoff decision problem for timed automata @xmath176 that asks to decide whether the value of the mean - payoff game for a given state is below a given budget . for a ptga @xmath176 and budget @xmath197",
    ", we write @xmath198 for the @xmath199-mean payoff decision problem that asks whether value of the game at the state @xmath200 is smaller than @xmath199 .",
    "the following theorem summarizes the key contribution of this paper .",
    "the decision problem @xmath198 for binary - priced timed automata @xmath176 is undecidable for automata with three clocks , and decidable for automata with one clock .",
    "in this section we introduce an abstraction of priced timed games called the boundary region abstraction ( that generalizes classical corner - point abstraction  @xcite ) , and characterize conditions under which a solution of optimality equations for the boundary region abstraction can be lifted to a solution of optimality equations for timed automata .",
    "observe that in order to keep our result as general as possible , we present the abstraction and corresponding results for timed automata with an arbitrary number of clocks . in the following section , we show that the required conditions hold for the case of one - clock binary - priced timed automata .",
    "* timed successor regions . *",
    "recall that @xmath140 is the set of clock regions . for @xmath201",
    ", we say that @xmath202 is in the future of @xmath203 , denoted @xmath204 , if there exist @xmath205 , @xmath206 and @xmath103 such that @xmath207 and say @xmath202 is the _ time successor _ of @xmath203 if @xmath208 for all @xmath209 and write @xmath210 , or equivalently @xmath211 , to denote this fact . for regions @xmath201 such that @xmath212 we write @xmath213 $ ] for the zone @xmath214 . *",
    "thin and thick regions . *",
    "we say that a region @xmath203 is _ thin _ if @xmath134 { \\neq } [ \\nu{+}\\varepsilon]$ ] for every @xmath205 and @xmath215 and _ thick _ otherwise .",
    "we write @xmath216 and @xmath217 for the sets of thin and thick regions , respectively .",
    "observe that if @xmath218 then , for any @xmath205 , there exists @xmath215 , such that @xmath134 { = } [ \\nu { + } \\varepsilon]$ ] and the time successor of a thin region is thick , and vice versa .    * intuition for the boundary region graph ( brg ) . *",
    "recall that @xmath126 is an upper bound on clock values and let @xmath219 . for any @xmath102 , @xmath220 and @xmath106",
    ", we define @xmath221 if @xmath222 , and @xmath223 if @xmath224 .",
    "intuitively , @xmath225 returns the amount of time that must elapse in @xmath99 before the clock @xmath226 reaches the integer value @xmath227 . observe that ,",
    "for any @xmath228 , there exists @xmath220 and @xmath106 , such that @xmath205 implies @xmath229 for all @xmath230 in the past of @xmath202 and write @xmath231 .",
    "the boundary region abstraction is motivated by the following .",
    "consider @xmath232 , @xmath165 and @xmath212 such that @xmath205 , @xmath213 \\subseteq { \\mathit{inv}}(\\ell)$ ] and @xmath233 .",
    "( for illustration , see figure  [ fig : finboundary ] in appendix ) .",
    "* if @xmath234 , then there are infinitely many @xmath103 such that @xmath235 . however , amongst all such @xmath168 s , for one of the boundaries of @xmath202 , the closer @xmath104 is to this boundary , the ` better ' the timed action @xmath174 becomes for a player s objective . however , since @xmath202 is a thick region , the set @xmath236 is an open interval , and hence does not contain its boundary values . let the closest boundary of @xmath202 from @xmath99 be defined by the hyperplane @xmath237 and the farthest boundary of @xmath202 from @xmath99 be defined by the hyperplane @xmath238 .",
    "@xmath239 are such that @xmath240 ( @xmath241 ) is the infimum ( supremum ) of the time spent to reach the lower ( upper ) boundary of region @xmath242 .",
    "let the zones that correspond to these boundaries be denoted by @xmath243 and @xmath244 respectively",
    ". then @xmath245 and @xmath246 .",
    "in the boundary region abstraction we include these ` best ' timed actions through @xmath247 and @xmath248 . * if @xmath228 , then there exists a unique @xmath103 such that @xmath249 .",
    "moreover since @xmath202 is a thin region , there exists a clock @xmath111 and a number @xmath250 such that @xmath251 and @xmath252 .",
    "in the boundary region abstraction we summarise this ` best ' timed action from region @xmath203 via region @xmath202 through the action @xmath253 .    based on this intuition above the boundary region abstraction ( bra )",
    "is defined as follows .",
    "[ brg - def ] for a priced timed game arena @xmath159 the boundary region abstraction of @xmath176 is given by the game arena @xmath254    * @xmath255 is the set of states such that @xmath256 if and only if @xmath257 and @xmath258 ( recall that @xmath259 denotes the closure of @xmath203 ) ; * @xmath260 ( or @xmath261 ) if @xmath256 and @xmath183 ( or @xmath184 , resp . ) .",
    "* @xmath262 is the set of actions ; * for @xmath263 and @xmath264 , function @xmath265 is defined if @xmath266 { \\subseteq } { \\mathit{inv}}(\\ell)$ ] and @xmath267 and it equals @xmath268 where @xmath269 , @xmath270=\\nu'$ ] and @xmath271={\\zeta}'$ ] with @xmath272 and one of the following conditions holds : + @xmath273 ; @xmath274 for some @xmath275 ; @xmath276 for some @xmath277 ; * for @xmath256 and @xmath278 the reward function @xmath279 is given by : + @xmath280    although the boundary region abstraction is not a finite game arena , every state has only finitely many time - successor ( the boundaries of the regions ) and for a fixed initial state we can restrict attention to a finite game arena due to the following observation .",
    "[ prop : reachable - subgraph - is - finite - game ] let @xmath176 be a priced timed game arena and @xmath281 the corresponding bra . for any state of @xmath281 ,",
    "its reachable sub - graph is finite and can be constructed in time exponential in the size of @xmath176 when @xmath176 has more than one clock . for one clock @xmath176 ,",
    "the reachable sub - graph of @xmath281 can be constructed in time polynomial in the size of @xmath176 . moreover , the reachable sub - graph from the initial location and clock valuation is precisely the corner - point abstraction .      in what follows , unless specified otherwise , we fix a ptga @xmath159 with semantics @xmath177   \\ ! ] } { = } ( s , s_{\\text{min } } , s_{\\text{max } } ,   a , t , \\pi)$ ] and bra @xmath282 .",
    "let @xmath283 and @xmath284 be such that @xmath285 , i.e. for every @xmath286 we have that @xmath287 for a function @xmath288 we define a function @xmath289 as @xmath290)$ ] . in this section",
    "we show under what conditions we can lift a solution @xmath67 of optimality equations of bra to @xmath291 for priced timed game arena .",
    "given a set of valuations @xmath292 , a function @xmath293 is _ affine _ if for any valuations @xmath294 we have that for all @xmath295 $ ] , @xmath296 .",
    "we say that a function @xmath297 is regionally affine if @xmath298 is affine over a region for all @xmath299 and @xmath230 , and @xmath300 is regionally constant if @xmath301 is constant over a region for all @xmath299 and @xmath230 .",
    "some properties of affine functions that are useful in the proof of the key lemma are given in lemma [ lem - keyprop ] .",
    "[ lem - keyprop ] [ lem : prop ] let @xmath302 and @xmath303 be convex sets .",
    "let @xmath304 and @xmath305 be affine functions .",
    "then for @xmath107 we have that @xmath306)$ ] is also an affine function , and @xmath307 + @xmath308 @xmath309 is the unique continuous closure of @xmath310 .",
    "[ thm : the - key - thm ] let @xmath283 and @xmath284 are such that @xmath285 and @xmath80 is regionally constant and @xmath311 is regionally affine , then @xmath312 .",
    "we need to show that @xmath312 , i.e. for every @xmath313 consider the case when @xmath314 and consider the right side of the gain equations .",
    "@xmath315 \\rightarrow^ { * } { \\zeta } '' \\\\ [ { \\zeta } ,          { \\zeta } '' ] \\in { \\mathit{inv}}(\\ell ) } }    \\min_{a \\in { \\mathit{act } } } \\inf_{\\substack{t \\::\\:\\\\ \\nu+t \\in { \\zeta } '' } }    { \\ { g(\\delta(\\ell , a ) , ( \\nu{+}t)[\\rho(a){:=}0 ] , [ ( \\nu{+}t)][\\rho(a){:=}0 ] )   \\}}\\\\             & = &   \\min_{\\alpha \\in { { \\widehat{a}}}(\\ell , \\nu , [ \\nu ] ) } { \\ { g(\\ell ' , \\nu ' , { \\zeta } ' )       \\::\\ : ( \\ell , \\nu , { \\zeta } ) \\xrightarrow{\\alpha } ( \\ell ' , \\nu',{\\zeta } ' ) \\ } }    = g(\\ell , \\nu , [ \\nu ] ) = { g^\\boxplus}(\\ell , \\nu).\\end{aligned}\\ ] ] the first equality holds since @xmath285 .",
    "the second equality follows since @xmath80 is regionally constant and hence it suffices to consider the delay @xmath225 that corresponds to either left or right boundary of the region @xmath316 , i.e. for fixed @xmath317 and @xmath232 we have that @xmath318 , { \\zeta } ' ) \\ } } = g(\\ell ' , \\nu_\\alpha[c{:=}0 ] , { \\zeta } ' ) $ ] where @xmath272 , @xmath319={\\zeta}'$ ] with @xmath320 if @xmath321 is thin , and @xmath322 for some @xmath275 if @xmath321 is thick .",
    "similarly , for the bias equations , we need to show : @xmath323 , { \\zeta } ' ) \\}}\\\\ & = & \\pi((\\ell , \\nu , [ \\nu ] ) , ( { \\mathsf{time}}(\\nu , ( b_\\alpha , c_\\alpha ) ) ) ) - g(\\ell , \\nu , [ \\nu ] ) + b(\\ell ' , \\nu_\\alpha[c{:=}0 ] , { \\zeta } ' ) \\end{aligned}\\ ] ] where @xmath272 , @xmath319={\\zeta}'$ ] with @xmath320 if @xmath321 is thin ; and @xmath324 for some @xmath275 or @xmath325 for some @xmath277 if @xmath321 is thick .",
    "given @xmath311 is regionally affine ( and hence linear in @xmath168 ) and the price function is linear in @xmath168 , the whole expression @xmath326 , { \\zeta}')$ ] is linear in @xmath168 and from lemma  [ lem : prop ] it attains its infimum or supremum on either boundary of the region .",
    "given the undecidability with 3 or more clocks , we focus on one clock ptga . we provide a strategy improvement algorithm to compute a solution @xmath283 and @xmath284 of the optimality equations , i.e. @xmath285 for the bra @xmath327 of one - clock binary - priced ptgas with certain `` integral payoff '' restriction .",
    "further , we show that for one clock binary - priced integral - payoff ptga , the solution of optimality equations of corresponding brg is such that the gains are regionally constant and biases are regionally affine . hence by theorem [ thm : the - key - thm ] , the algorithm can be applied to solve mean - payoff games for one - clock binary - priced integral - payoff ptgas .",
    "we also show how to lift the integral - payoff restriction to recover decidability for one - clock binary - priced ptga . * regionally constant positional strategies . * standard strategy improvement algorithms iterate over a finite set of strategies such that the value of the subgame at each iteration gets strictly improved . however , since there are infinitely many positional strategies in a boundary region abstraction , we focus on `` regionally constant '' positional strategies ( ) .",
    "we say that a positional strategy @xmath328 of player min is regionally - constant if for all @xmath329 we have that @xmath134 { = } [ \\nu']$ ] implies that @xmath330 .",
    "we similarly define for player max . in other words , in an a player chooses same boundary action for every valuation of a region  as a side - result we show that optimal strategies for both players have this form .",
    "observe that there are finitely many for both players .",
    "we write @xmath331 and @xmath332 for the set of for player min and player max , respectively . for a bra @xmath333 , @xmath334 , and",
    "@xmath335 we write @xmath336 and @xmath337 for the `` one - player '' game on the sub - graph of bras where the strategies of player max and min have been fixed to @xmath33 and @xmath0 , respectively .",
    "similarly we define the zero - player game @xmath338 where strategies of both players are fixed to @xmath0 and @xmath33 .",
    "let @xmath339 be a zero - player game on the subgraph where strategies of player max ( and min ) is fixed to @xmath33 ( and @xmath0 ) .",
    "observe that for @xmath338 the unique runs originating from states @xmath340 and @xmath341 with @xmath134 = [ \\nu']$ ] follow the same `` lasso '' after one step , i.e. the unique runs @xmath342 and @xmath343 are such that for @xmath344 and @xmath345 we have that @xmath346 , @xmath347 and @xmath348 for all @xmath349 $ ] .",
    "this is so because for one - clock timed automata the successors of the states @xmath340 and @xmath350 for action @xmath351 is the same @xmath352 where @xmath353 if @xmath354 and @xmath355 otherwise .",
    "consider the optimality equations ( section  [ app : oe ] ) for the lasso .",
    "observe that the gain for the states @xmath356 is the same , and let s call it @xmath357 .",
    "if we add the bias equations side - wise for the cycle , we get @xmath358 .",
    "it follows from the previous observation that the gains are regionally constant .",
    "* integral payoff ptga . * the gain in a zero - player game , @xmath339 ,",
    "although regionally - constant , may not be a whole number .",
    "we say that a ptga is integral - payoff if for every pair @xmath359 of the gain as defined above is a whole number .",
    "observe that the denominator in the gains correspond to the number of edges in a simple cycle of the bra @xmath281 .",
    "if there are @xmath360 simple cycles in the region graph of length @xmath361 , then let @xmath362 be the least - common multiple of @xmath363 .",
    "we multiply constants appearing in the guards and invariants of the timed automata by @xmath362 .",
    "it is easy to observe that mean - payoff of any state in the original ptga @xmath176 is the mean - payoff in @xmath364 divided by @xmath362 . for notational convenience , we assume that the given ptga is an integral - payoff ptga and hence for strategy profile @xmath365 the gain is regionally constant and integral",
    ".    consider @xmath338 as a ( single successor ) weighted graph @xmath366 where    * @xmath367 ( with an order @xmath368 ) and @xmath369 * @xmath370 if @xmath371 , @xmath372 , and @xmath373 ( or @xmath374 ) for all @xmath375 and @xmath376 for some @xmath377 . * @xmath378 is the expression @xmath379",
    "@xmath67      let @xmath176 be a one - clock integral - payoff binary - priced ptga @xmath176 and @xmath333 be its boundary region graph .",
    "for a given profile @xmath359 , algorithm  [ alg2 ] computes the solution for the optimality equations @xmath380 .",
    "this algorithm considers @xmath338 as a graph whose vertices are `` regions '' @xmath381 , { \\zeta})$ ] corresponding to state @xmath256 of the boundary region graph , edges are boundary actions between them determined by the regionally constant strategy profile , and weight of an edge is the time function associated with the boundary action .",
    "observe that every cycle in this graph will have constant weight on the edges since taking boundary actions in a loop will require going from an integral valuation to another integral valuation , and the average cost of such a cycle can be easily computed .",
    "also observe that , not unlike standard convention  @xcite , our algorithm chooses a vertex in a cycle arbitrarily and fixes the bias of all of the states in that vertex to @xmath110 .",
    "this is possible since optimality equations over a cycle are underdetermined , and we exploit this flexibility to achieve solution to biases in a particularly `` simple '' structure .",
    "we say that a function @xmath297 is regionally simple  @xcite if for all @xmath153 , @xmath201 either i ) there exists a @xmath382 such that @xmath383 for all @xmath205 ; or ii ) there exists @xmath384 and @xmath106 such that @xmath385 for all @xmath205 .",
    "key properties of regionally simple functions ( lemma  [ lem : simple ] in appendix [ app - lem_simple ] ) include that they are also regionally affine , closed under minimum and maximum , and if @xmath284 be a regionally simple function and @xmath386 be a regionally constant function , then @xmath387 where @xmath388 is a regionally simple function .",
    "using these properties and induction on the distance to @xmath368-minimal element in the reachable cycle , we prove the correctness and following property of algorithm  [ alg2 ] .",
    "[ lem : zero - player ] algorithm  [ alg2 ] computes solution of optimality equations @xmath389 for @xmath335 and @xmath334 .",
    "moreover , @xmath80 is regionally constant and @xmath311 is regionally simple .",
    "choose an arbitrary regionally constant positional strategy @xmath390 @xmath67    the strategy improvement algorithm to solve optimality equations is given as algorithm  [ sia ] .",
    "it begins by choosing an arbitrary regionally constant positional strategy @xmath391 and at every iteration of the loop ( @xmath392@xmath393 ) the algorithm computes ( @xmath394@xmath395 ) the value @xmath67 of the current @xmath33 and based on the value , the function @xmath396 returns an improved strategy by picking boundary action that lexicographically maximizes gain and bias respecting the policy that switches a decision only for a strict improvement .",
    "we formally define the function @xmath396 as follows : for @xmath397 , @xmath398 , and @xmath399 we let strategy @xmath400 be such that for all @xmath401 we have @xmath402 where @xmath403 and @xmath404 picks an arbitrary element from a set .",
    "improvemaxstrategy satisfies the following .",
    "[ lemma2 ] if @xmath334 , @xmath80 is regionally constant , and @xmath311 is regionally simple , then function @xmath400 returns a regionally constant positional strategy .",
    "the lines ( @xmath394@xmath395 ) compute the value of the strategy @xmath33 of player max via a strategy improvement algorithm .",
    "this sub - algorithm works by starting with an arbitrary strategy of player min and computing the value @xmath67 of the zero - player ptga @xmath338 . based on the value",
    ", the function @xmath405 returns an improved strategy of min .",
    "the function @xmath405 is defined as a dual of the function @xmath396 where @xmath33 is replaced by @xmath0 and @xmath406 by @xmath407 .",
    "improveminstrategy satisfies the following .",
    "[ lemma1 ] if @xmath335 , @xmath80 is regionally constant , and @xmath311 is regionally simple , then function @xmath408 returns a regionally constant positional strategy .",
    "it follows from lemma  [ lemma2 ] and lemma  [ lemma1 ] that at every iteration of the strategy improvement the strategies @xmath0 and @xmath33 are .",
    "together with finiteness of the set of and strict improvement at every step ( lemma  [ impr1 ] and  [ impr2 ] ) , we get following result .",
    "[ thm : final ] algorithm  [ sia ] computes solution of optimality equations @xmath409 for integral payoff ptga @xmath176 . moreover , @xmath80 is regionally constant and @xmath311 is regionally affine .",
    "this theorem  together with theorem  [ thm : the - key - thm ] and theorem  [ thm : gain - bias - correctness]gives a proof of decidability for mean - payoff games for integral - payoff binary - priced one - clock timed automata .",
    "[ thm_undec ] the mean - payoff problem @xmath198 is undecidable for ptga @xmath176 with 3 clocks having location - wise price - rates @xmath410 for all @xmath153 and @xmath411 .",
    "moreover , it is undecidable for binary - priced @xmath176 with 3 clocks and @xmath412 .",
    "we first show the undecidability result of the mean - payoff problem @xmath413 with location prices @xmath414 and no edge prices .",
    "we prove the result by reducing the non - halting problem of 2 counter machines .",
    "our reduction uses a ptga with 3 clocks @xmath415 , location prices @xmath414 , and no edge prices . each counter machine instruction ( increment , decrement , zero check )",
    "is specified using a ptga module .",
    "the main invariant in our reduction is that on entry into any module , we have @xmath416 , @xmath417 and @xmath418 , where @xmath419 are the values of counters @xmath420 .",
    "we outline the construction for the decrement instruction of counter @xmath421 in figure [ fig_undec_mpg_dec_new ] . for conciseness , we present here modules using arbitrary location prices . however , we can redraw these with extra locations and edges using only the location prices from @xmath414 as shown for @xmath422 in figure  [ redraw ] in appendix .",
    "the role of the min player is to faithfully simulate the two counter machine , by choosing appropriate delays to adjust the clocks to reflect changes in counter values .",
    "player max will have the opportunity to verify that player @xmath29 did not cheat while simulating the machine .    at ( 0,-.5 ) ( lk )",
    "@xmath110 ; ( ) [ above of = lk , node distance=5mm]@xmath423 ;    at ( 3,-.5 ) ( chk)@xmath110 ; ( ) [ above of = chk , node distance=5mm]@xmath424 ;    ( ) [ below right of = chk , node distance=6.5mm , xshift=-3 mm ] @xmath425 $ ] ;    at ( 6,-.5)(lk1)@xmath426 ;    at ( -2,-.5 ) ( w1)@xmath427 ;    at ( 8,-.5 ) ( w2)@xmath428 ;    at ( -3,-2.5)(a ) @xmath429 ; ( ) [ above of = a , node distance=5mm]@xmath6 ;    at ( -0.5,-2.5 ) ( b)@xmath430 ; ( ) [ above of = b , node distance=5mm]@xmath311 ;    at ( 2,-2.5 ) ( c)@xmath431 ; ( ) [ above of = c , node distance=5mm]@xmath432 ;    at ( 4.5,-2.5 ) ( d ) @xmath110 ; ( ) [ above of = d , node distance=5mm]@xmath433 ;    at ( 7,-2.5 ) ( e ) @xmath110 ; ( ) [ above of = e , node distance=5mm]@xmath156 ;    ( lk ) edge node @xmath434 node[below ] @xmath435(chk ) ; ( chk ) edge node[below ] @xmath436 ( lk1 ) ; ( chk ) edge[bend left ] node ( w1 ) ; ( chk ) edge[bend left ] node ( w2 ) ;    \\(a ) edge node @xmath437 node[below]@xmath436 ( b ) ; ( b ) edge node @xmath438 node[below]@xmath439 ( c ) ; ( c ) edge node @xmath440 node[below]@xmath439 ( d ) ; ( d ) edge node @xmath441 node[below]@xmath436 ( e ) ; ( e )  ( 7 , -3.8 )  node[above ] @xmath442 ( -3 , -3.8 )  ( a ) ;    at ( -4.5 , -2.5 ) ( n ) @xmath443 ; ( -4,-4.2 ) rectangle ( 7.5,-1.6 ) ;    [ fig_undec_mpg_dec_new ]    we enter location @xmath423 with @xmath444 and @xmath418 .",
    "lets denote by @xmath445 the value @xmath446 . to correctly decrement @xmath421 , player min should choose a delay of @xmath447 at location @xmath423 . at location @xmath424",
    ", there is no time elapse and player max has three possibilities : ( @xmath448 ) to go to @xmath426 and continue the simulation , or ( @xmath449 ) to enter the widget @xmath443 , or ( iii ) to enter the widget @xmath450 .",
    "if player min makes an error , and delays @xmath451 or @xmath452 at @xmath423 ( @xmath60 ) , then player max can enter one of the widgets and punish player min .",
    "player max enters widget @xmath443 if the error made by player min is of the form @xmath451 at @xmath423 and enters widget @xmath450 if the error made by player min is of the form @xmath452 at @xmath423 .",
    "let us examine the widget @xmath443 .",
    "when we enter @xmath443 for the first time , we have @xmath453 , @xmath454 and @xmath418 . in @xmath443 ,",
    "the cost of going once from location @xmath6 to @xmath156 is @xmath455 .",
    "also , when we get back to @xmath6 after going through the loop once , the clock values with which we entered @xmath443 are restored ; thus , each time , we come back to @xmath6 , we restore the starting values with which we enter @xmath443 .",
    "the third clock is really useful for this purpose only .",
    "it can be seen that the mean cost of transiting from @xmath6 to @xmath6 through @xmath156 is @xmath64 . in a similar way",
    ", it can be checked that the mean cost of transiting from @xmath6 to @xmath6 through @xmath156 in widget @xmath450 is @xmath64 when player min chooses a delay @xmath452 at @xmath423 .",
    "thus , if player min makes a simulation error , player max can always choose to goto one of the widgets , and ensure that the mean pay - off is not @xmath456 .",
    "note that when @xmath457 , then player min will achieve his objective : the mean pay - off will be 0 .",
    "details of other gadgets are in appendix  [ app : undec ] .    in the appendix  [ app : undec_per_time_unit ] , we show how this undecidability results extends ( with the same parameters ) if one defines mean payoff per time unit instead of per step .",
    "this way of averaging across time spent was considered in  @xcite , where the authors show the undecidability of @xmath413 with 5 clocks .",
    "we improve this result to show undecidability already in @xmath458 clocks .    10    r.  alur , m.  bernadsky , and p.  madhusudan .",
    "optimal reachability for weighted timed games . in _ proc . of icalp _ , pages 122133 .",
    "springer , 2004 .",
    "r.  alur and d.  dill . a theory of timed automata .",
    ", 126(2):183235 , 1994 .",
    "e.  asarin and o.  maler .",
    "as soon as possible : time optimal control for timed automata . in f.",
    "w. vaandrager and j.  h. van schuppen , editors , _ proc . of hscc _ ,",
    "pages 1930 , 1999 .",
    "h.  bjrklund , s.  sandberg , and s.  vorobyov .",
    "a combinatorial strongly subexponential strategy improvement algorithm for mean payoff games . in _ proc . of mfcs _ , pages 673685 , 2004 .",
    "p.  bouyer .",
    "weighted timed automata : model - checking and games . in _ proc .",
    "of mfps _ , volume 158 , pages 317 , 2006 .",
    "p.  bouyer , t.  brihaye , m.  jurdzinski , r.  lazic , and m.  rutkowski .",
    "average - price and reachability - price games on hybrid automata with strong resets . in _ formats _ , volume 5215 of _ lncs _ , pages 6377 , 2008 .",
    "p.  bouyer , e.  brinksma , and k.  g. larsen .",
    "staying alive as cheaply as possible .",
    "in _ proc . of hscc _ ,",
    "volume 2993 of _ lncs _ , pages 203218 .",
    "springer , 2004 .",
    "p.  bouyer , f.  cassez , e.  fleury , and k.  g. larsen .",
    "optimal strategies in priced timed game automata . in _ proc . of fsttcs _ ,",
    "volume 3328 of _ lncs _ , pages 148160 .",
    "springer , 2004 .",
    "p.  bouyer , k.  g. larsen , and n.  markey .",
    "lower - bound constrained runs in weighted timed automata . in _ proc .",
    "of qest _ , pages 128137 , 2012 .",
    "r.  brenguier , f.  cassez , and j.  f. raskin",
    ". energy and mean - payoff timed games . in _ proc . of hscc _ , pages 283292 , 2014 .",
    "t.  brihaye , g.  geeraerts , s.  n. krishna , l.  manasa , b.  monmege , and a.  trivedi .",
    "adding negative prices to priced timed games . in _ proc .",
    "of concur _ , pages 560575 , 2014 .",
    "e.  dynkin and a.  yushkevich . .",
    "springer , 1979 .",
    "a.  ehrenfeucht and a.  mycielski .",
    "positional strategies for mean payoff games .",
    ", 8:109113 , 1979 .",
    "j.  filar and k.  vrieze . .",
    "springer , 1997 .",
    "v.  a. gurvich , a.  v. karzanov , and l.  g. khachiyan .",
    "cyclic games and an algorithm to find minimax cycle means in directed graphs . , 28:8591 , 1988 .",
    "thomas  a. henzinger .",
    "quantitative reactive modeling and verification .",
    ", 28(4):331344 , 2013 .    r.  a. howard . . mit press , 1960 .",
    "m.  jurdziski and a.  trivedi .",
    "reachability - time games on timed automata . in _ proc .",
    "of icalp _ , pages 838849 .",
    "springer , 2007 .",
    "m.  jurdziski and a.  trivedi .",
    "average - time games . in r.",
    "hariharan , m.  mukund , and v.  vinay , editors , _ proc . of fsttcs",
    "_ , dagstuhl seminar proceedings , 2008 .",
    "marvin  l. minsky . .",
    "prentice - hall , inc . , 1967 .",
    "m.  l. puterman .",
    "wiley , 1994 .",
    "j. ramadge and w.  m. wonham . the control of discrete event systems . in _",
    "ieee _ , volume  77 , pages 8198 , 1989 .",
    "a.  trivedi . .",
    "phd thesis , department of computer science , the university of warwick , 2009 .",
    "u.  zwick and m.  paterson .",
    "the complexity of mean payoff games on graphs .",
    ", 158:343359 , 1996 .",
    "let @xmath1 be a finite game arena .",
    "for technical convenience let us fix an arbitrary but fixed linear order @xmath459 on the set of states  @xmath3 . for a positional strategy @xmath460",
    "we write @xmath461 for the subgame of @xmath1 where the outgoing transitions from the states controlled by player @xmath34 have been restricted to the ones allowed by @xmath33 .",
    "we similarly define @xmath462 and @xmath463 .",
    "* strategy improvement algorithm for finite game arenas . * the strategy improvement algorithm to compute s solution of optimality equations works as follows .    1 .",
    "fix an arbitrary positional strategy @xmath464 for player  max .",
    "( _ best counter - strategy against @xmath33_. ) compute the best counter - strategy @xmath0 for player  min against the strategy @xmath33 by performing the following steps",
    "( _ minimize gain_. ) for every state @xmath9 , let @xmath465 be the value of the minimum average weight of a cycle reachable from the state @xmath11 in the strategy subgame @xmath461 ; let @xmath466 denote such a cycle reachable from the state  @xmath11 .",
    "let @xmath467 be the @xmath368-smallest state on the cycle  @xmath466 .",
    "let @xmath468 be the set of states @xmath469 , such that @xmath470 , i.e. , the set of states which have the same reachable minimum average weight cycle in the graph @xmath461 as the state @xmath11 .",
    "( _ minimize bias_. ) for every state @xmath9 , let @xmath471 be the weight of the shortest path from the state @xmath11 to the state @xmath467 in the subgraph of @xmath461 induced by the set of states @xmath468 , and where @xmath465 was subtracted from the price of every transition in the subgraph @xmath461 . for every state @xmath472 , set @xmath473 to be the state @xmath474 , such that @xmath475 for some @xmath169 , @xmath476 ( and hence @xmath477 ) , and @xmath478 .",
    "+ observe that the functions @xmath80 and @xmath311 thus obtained satisfy the optimality equations for the subgame @xmath461 .",
    "however , these function may not satisfy the optimality equations for the original game @xmath1 .",
    "the next step `` locally '' changes the strategy  @xmath33 , intuitively in order to make progress towards computing the optimality equations .",
    "( _ local improvement of strategy @xmath33_. ) for every state @xmath479 , set @xmath480 to be a successor @xmath469 of the state  @xmath11 , which first maximizes @xmath481 and then maximizes  @xmath482 . in other words",
    ", @xmath480 is the successor @xmath469 of the state @xmath11 which maximizes @xmath483 according to the lexicographical ordering on pairs , where we use the usual ordering on the reals in both coordinates .",
    "importantly , if the current @xmath33-successor of the state @xmath11 is already maximum in the above lexicographic sense , @xmath480 remains unchanged , even if there are other successors @xmath469 of @xmath11 with the same pair of values @xmath483 as the state  @xmath480 .",
    "_ this assumption is important for finite termination of the strategy improvement algorithm .",
    "if the local improvement of the strategy @xmath33 in the previous step resulted in a change of @xmath33 in at least one state then go back to step  2 . otherwise stop .",
    "we establish the following two fundamental properties of the iterative scheme of strategy improvement described above . the first observation that a locally optimal strategy yields a solution to optimality equations is straightfoward to check .",
    "[ proposition : witness - from - termination ] if the algorithm stops then the tuple @xmath67 computed in the last iteration is a solution to optimality equations .",
    "next , we show that in every non - terminating iteration of the algorithm , the pair @xmath67 consisting of the gain function @xmath80 and the bias function @xmath311 , that are uniquely determined from the current pair of strategies @xmath33 and @xmath0 , strictly increases according to a certain linear ordering as a result of the local improvement .",
    "this implies finite termination of the algorithm , since there are only finitely many positional strategies .",
    "thus , together with lemma  [ proposition : witness - from - termination ] , we get the existence of an oe solution , which establishes positional determinacy of mean - payoff games on finite game arenas .",
    "[ lemma : global - improvement ] let @xmath0 ( @xmath484 ) be the best counter - strategy for player  min against a strategy @xmath33 ( @xmath391 ) for player  max , and let @xmath80 ( @xmath485 ) and @xmath311 ( @xmath486 ) be as computed in step  2 of an iteration of the algorithm starting from the strategy @xmath33 ( @xmath391 . )",
    "if the strategy @xmath391 is a non - trivial local improvement of the strategy @xmath33 , as computed in step  3 of the algorithm , then for every state @xmath9 , the following hold .    1",
    ".   we have @xmath487 .",
    "2 .   if @xmath488 then @xmath489 .",
    "3 .   if @xmath490 and @xmath491 then either @xmath492 , or @xmath493 and @xmath494 .    in order to verify property  1",
    "it suffices to show that the average weight of every cycle reachable from a state @xmath11 in the strategy subgraph @xmath495 is no smaller than the smallest average weight of a cycle reachable from the state @xmath11 in the strategy subgraph @xmath496 .",
    "first , observe that for every transition @xmath497 in the subgraph of the graph @xmath495 , we have the inequality @xmath498 .",
    "it implies in @xmath495 we have that @xmath465 is smaller than average of the cheapest reachable cycle . on the other hand @xmath499",
    "is the average of the cheapest cycle in @xmath495 .",
    "it follows that @xmath498 .",
    "now we argue that the properties  2 and  3 hold . from the assumption that @xmath488 it follows that the paths from the state @xmath11 in graphs @xmath463 and @xmath500 lead to the same cycle . we need to prove that @xmath489 and that @xmath501 implies @xmath502 .",
    "first , observe that for every transition @xmath497 in the subgraph of the graph @xmath461 induced by the set of states @xmath468 , we have the inequality @xmath503 ; it follows by the construction of @xmath311 as the weights of shortest paths to the state @xmath11 ( step 2(b ) ) .",
    "moreover , by the definition of the myopic improvement of the strategy @xmath33 ( step  3 ) , for every transition @xmath497 in the subgraph of the graph @xmath495 induced by the set of states @xmath504 , we have @xmath503 .",
    "now let @xmath505 be a path from the state @xmath11 to the state @xmath467 in the subgraph of the graph @xmath495 induced by the set of states @xmath504 . then adding the @xmath158 inequalities @xmath506 , for @xmath507 , we get that @xmath508 .",
    "this , however , implies that @xmath509 , since if the previous inequality holds for _ all _ the paths from @xmath11 to @xmath467 in the appropriate subgraph of @xmath495 , then it also holds for the shortest such .",
    "this establishes property  2 .",
    "property  3 now follows from the strictness of the inequality @xmath510 if we assume that @xmath501 .",
    "note that this is when the assumption at the end of step  3 is necessary to avoid looping without strict improvement of neither the gain nor the bias function from one iteration of the algorithm to another .",
    "at ( 0,0 ) ( l0 ) @xmath511 ; at ( 5,0 ) ( l1 ) @xmath512 ;    ( l0 ) edge node [ pos=0.7 , above ] @xmath513 ( l1 ) ;    = [ font= ] = [ rounded corners=3pt , fill = gold , draw , minimum size=1.4em , inner sep=0em ] = [ -latex , rounded corners ]    at ( 0,0 ) ( l0 ) @xmath514 ; at ( 6.5,2.5 ) ( l1 ) @xmath515 ; at ( 6.5,1 ) ( l2 ) @xmath516 ; at ( 3.8,-1.6 ) ( l3 ) @xmath517 ; at ( 3.8,-3 ) ( l4 ) @xmath518 ; at ( 3.8,-4.4 ) ( l5 ) @xmath519 ;    ( @xmath520 )  ( l0 ) ; ( l0.-192)|-(l1 ) node[pos=0.75,above ] @xmath521 ; ( l0.-193)|-(l2 ) node[pos=0.75,above ] @xmath522 ; ( l0.194)|-(l3 ) node[pos=.75,above ] @xmath523 ; ( l0.193)|-(l4 ) node[pos=.75,above ] @xmath524 ; ( l0.192)|-(l5 ) node[pos=.75,above ] @xmath525 ;    \\(x ) at ( 8.3,-3.1 )    iin 0,1 in 0,1 ( i+0.1,+0 )  ( i+0.9,+0 ) ; ( i+0,+0.1 )  ( i+0,+0.9 ) ; ( i , ) circle ( 0.05 ) ; ( i+0.2,+0.1 )  ( i+0.9,+0.1 )  ( i+ 0.9 , + 0.8 )  cycle ; ( i+0.1,+0.2 )  ( i+0.8,+0.9 )  ( i+ 0.1 , + 0.9 )  cycle ; ( i+0.1,+0.1 )  ( i+0.9,+0.9 ) ; iin 0,1 in 2 ( i+0.1,+0 )  ( i+0.9,+0 ) ; ( i , ) circle ( 0.05 ) ; iin 2 in 0,1 ( i+0,+0.1 )  ( i+0,+0.9 ) ; ( i , ) circle ( 0.05 ) ; ( 2,2 ) circle ( 0.05 ) ;    at ( 0.7,0.25 ) @xmath526 ; at ( 1.25,0.5 ) @xmath527 ; at ( 1.7,1 ) @xmath528 ; at ( 1.7,1.25 ) @xmath529 ; at ( 2.05,1.25 ) @xmath530 ; ( r5 ) at ( -0.4,0.3 ) @xmath531 ; ( r5 )  ( 0,0 ) ; at ( 0,0.25 ) @xmath532 ; ( r7 ) at ( -0.4,0.6 ) @xmath533 ; ( r7 )  ( 0,1 ) ; at ( 0,1.25 ) @xmath534 ; at ( 0.7,1.25 ) @xmath535 ; at ( 0.7,0 ) @xmath536 ;    at ( -0.2,0 ) @xmath110 ; at ( -0,-0.3 ) @xmath110 ; at ( -0.2,1 ) @xmath537 ; at ( -0.2,2 ) @xmath392 ; at ( 1,-0.3 ) @xmath537 ; at ( 2,-0.3 ) @xmath392 ; ( 1.5,-0.3 )  ( 1.8,-0.3 ) node[midway , above ] @xmath128 ; ( -0.2,1.5 ) ",
    "( -0.2,1.8 ) node[midway , left ] @xmath538 ;    ( -0.5,-0.5 ) rectangle ( 2.5,2.5 ) ;    ;    a ptga is shown at the top of figure  [ fig : finboundary ] .",
    "a sub - graph of bra reachable from @xmath539 is shown below the ptga in the same figure .",
    "the names of the regions correspond to the regions depicted in the bottom right corner .",
    "edges are labelled @xmath540 and the intuitive meaning is to wait until clock @xmath226 reaches the value @xmath227 in the boundary of the region @xmath203 . considering the region @xmath527 , we see that it is determined by the constraints @xmath541 .",
    "the bold numbers on edges correspond to the time delay before the action labelling the edge is taken .",
    "figure  [ fig : finboundary ] includes the actions available in the initial state and one of the action pairs that are available in the state @xmath542 .",
    "consider the timed game shown in figure  [ fig : bias ] .",
    "all the locations here belong to the player @xmath29 .",
    "there are two cycles in which the gains or the average weight of the cycles is @xmath543 . if corresponding to two or more strategies , the gains are the same , then the strategy that minimizes the bias is chosen by the player @xmath29",
    ". the bias @xmath471 of a player @xmath29 state @xmath544 where @xmath161 is a location of the priced timed game and @xmath99 is a clock valuation is given by @xmath545 if @xmath472 .",
    "the @xmath546 is replaced by a @xmath547 for a player @xmath34 state .",
    "@xmath465 denotes the gain of state @xmath11 .",
    "considering the bias of the states @xmath548 and @xmath549 to be 0 , the bias of a state @xmath550 turns out to be @xmath551 when the edge @xmath552 is considered and the bias of @xmath550 is the constant function @xmath553 when the edge @xmath554 is considered . here",
    "@xmath555 denotes the value of clock @xmath128 . for @xmath556 ,",
    "the value of @xmath551 is smaller than @xmath553 and hence the edge @xmath554 is chosen while the edge @xmath552 is chosen when @xmath557 .",
    "thus the bias is not regionally affine .",
    "this can be attributed to the fact that the gain is not integral .",
    "let us consider another example of one - clock priced timed games with three price rates : @xmath110 , @xmath537 and @xmath553 shown in figure  [ fig : ce-0 + 1 - 1 ] .",
    "the value of the game is @xmath558 which is obtained by the following sequence of moves by both players . from the initial state @xmath559 ,",
    "player @xmath29 waits at @xmath512 for @xmath560 time units and then moves the token to location @xmath561 .",
    "player @xmath34 moves the token to @xmath562 immediately and subsequently the token reaches @xmath512 with the value of clock @xmath563 , where @xmath157 is an infintesimal positive quantity .",
    "the token is forwarded to @xmath561 now instantaneously or after an infintesimal delay so that the value of clock @xmath128 is still less than 1 .",
    "player @xmath34 now forwards the token to @xmath564 when the value of clock @xmath128 becomes 1 . at location @xmath564 ,",
    "@xmath565 amount of time is elapsed . in the next move of player @xmath34 ,",
    "the token reaches the initial state @xmath566 .",
    "the @xmath64-optimal strategies of both @xmath29 and player @xmath34 are not regionally constant boundary strategies .",
    "[ lem - bias ] in one clock binary non - integral payoff ptga the bias may not be regionally affine .",
    "the same is true for for the bra of the ptga .",
    "consider the example in figure [ fig : bias ] .",
    "there are two loops , one consisting of locations @xmath561 and @xmath564 and the other one with locations @xmath562 and @xmath567 . for the states @xmath548 and @xmath568 where @xmath99 is any valuation of clock @xmath128 , the gain @xmath357 equals @xmath543 . for the states @xmath569 and @xmath549 such that @xmath570 also have their gain @xmath357 equal to @xmath543 .",
    "hence the corresponding ptga is a non - integral payoff one .",
    "note that all the states in the non - integral payoff ptga in figure [ fig : bias ] belong to the player @xmath29 . since the gains corresponding to both the loops are the same , the optimal strategy of the player @xmath29 from a state @xmath550 is determined by the bias of a successor state .",
    "we now show that the bias of a state @xmath550 may not be regionally affine . for computing the bias in the loop consisting of the locations @xmath561 and @xmath564 ,",
    "let us consider that @xmath571 .",
    "thus considering the successor state of a state @xmath550 to be the state @xmath572 , we have @xmath573 in the loop consisting of locations @xmath562 and @xmath567 , let @xmath574 .",
    "now @xmath575 thus considering the successor state of a state @xmath550 to be the state @xmath576 , we have @xmath577 hence the bias at @xmath550 is given by @xmath578 .",
    "this gives us that the edge @xmath579 is chosen when @xmath557 , while the edge @xmath580 is chosen when @xmath556 .",
    "hence the bias of location @xmath512 is not regionally affine in non - integral payoff ptga .",
    "it is easy to see that the lemma also holds for the bra on the ptga .",
    "simple functions were introduced by asarin and maler  @xcite in the context of reachability timed games for timed automata .",
    "[ lem : simple ] a function @xmath581 is simple if    * either , there exists @xmath384 such that for all @xmath102 we have @xmath582 ; * or , there exists @xmath384 and @xmath106 such that for all @xmath102 we have @xmath583 .",
    "we say that a function @xmath297 is regionally simple if for all @xmath153 , @xmath201 either i ) there exists a @xmath382 such that @xmath383 for all @xmath205 ; or ii ) there exists @xmath384 and @xmath106 such that @xmath385 for all @xmath205 .",
    "the simple functions have the following properties .    1 .",
    "every simple function is an affine function . 2 .",
    "every regionally simple function is a regionally affine function .",
    "3 .   for @xmath153",
    ", @xmath201 let @xmath584 = { \\zeta}\\}}$ ] . for simple functions @xmath585 we have that *",
    "@xmath586 is either @xmath300 or @xmath357 .",
    "* @xmath587 is either @xmath300 or @xmath357 .",
    "minimum and maximum of a finite set of regionally simple functions is regionally simple .",
    "let @xmath284 be a regionally simple function and @xmath588 be a regionally constant function .",
    "let @xmath589 as @xmath590 where @xmath388 .",
    "we have that @xmath591 is a regionally simple function .",
    "the proof is in many parts .    1 .",
    ". there are four cases to consider . * for all @xmath205 we have @xmath593 and @xmath594 . if @xmath595 the @xmath596 else @xmath597 . similarly if @xmath595 then @xmath598 else @xmath599 .",
    "* for all @xmath205 we have @xmath593 and @xmath600 . notice that if for some valuation @xmath601 then for all valuations @xmath602 since the difference between various valuations in a region is strictly less than @xmath537 .",
    "the lemma follows for this case from this observation .",
    "* for all @xmath205 we have @xmath603 and @xmath604 .",
    "this case is analogous to previous case and omitted .",
    "* for all @xmath205 we have @xmath603 and @xmath605 .",
    "if for some region @xmath606 then for all valuations this inequality will follow since difference between various values of clocks from different valuations in a region is strictly smaller than @xmath537 .",
    "4 .   similar to property  3 . 5 .   let @xmath284 be a regionally simple function and @xmath588 be a regionally constant function .",
    "let @xmath589 as @xmath590 where @xmath388 .",
    "let @xmath607 and @xmath608 .",
    "let @xmath609 be such that @xmath610 .",
    "there are eight cases to consider . * @xmath611 is @xmath612 , @xmath613 and @xmath614 . in this case",
    "@xmath615 ( an integer ) is a simple function .",
    "* @xmath611 is @xmath616 , @xmath613 and @xmath617 in this case @xmath618 ( an integer ) is a simple function .",
    "* @xmath611 is @xmath616 , @xmath619 and @xmath614 in this case @xmath620 is a simple function . *",
    "@xmath611 is @xmath616 , @xmath619 and @xmath617 in this case @xmath621 is a simple function . * @xmath611 is @xmath622 , @xmath613 and @xmath614 in this case @xmath623 ( an integer ) is a simple function .",
    "we have @xmath624 as there in only one clock .",
    "* @xmath611 is @xmath622 , @xmath613 and @xmath617 in this case @xmath625 ( an integer ) is a simple function .",
    "* @xmath611 is @xmath622 , @xmath619 and @xmath614 in this case @xmath626 is a simple function . *",
    "@xmath611 is @xmath622 , @xmath619 and @xmath617 in this case @xmath621 is a simple function .",
    "the proof is now complete .",
    "let @xmath339 be a zero - player game on the subgraph where strategies of player max ( and min ) is fixed to @xmath33 ( and @xmath0 ) .",
    "we sketch an algorithm @xmath627 which returns the solution of optimality equations @xmath380 .",
    "observe that for @xmath628 the unique runs originating from states @xmath340 and @xmath341 with @xmath134 = [ \\nu']$ ] follow the same `` lasso '' after one step , i.e. the unique runs @xmath629 are such that for @xmath344 and @xmath345 we have that @xmath346 , @xmath347 and @xmath348 for all @xmath630 $ ] .",
    "this is so because for one - clock timed automata the successors of the states @xmath340 and @xmath350 for action @xmath351 is the same @xmath352 where @xmath353 if @xmath354 and @xmath355 otherwise .",
    "consider the optimality equations for the lasso .",
    "we show this via an induction on the distance from the region whose biases we fixed earlier to @xmath110 .",
    "let @xmath632 be the run such that @xmath344 and for all states @xmath633 .",
    "we prove via induction that @xmath634 is a simple function .",
    "the base case follows easily since @xmath633 which is a simple function .",
    "assume that @xmath634 is simple we show that @xmath635 defined as @xmath636 is also simple where @xmath637 .",
    "this follows form property  5 of lemma  [ lem : simple ] .      to prove this lemma it suffices to show that the function @xmath638 is regionally constant .",
    "we already have that @xmath80 is regionally constant . from the property  5 of lemma  [",
    "lem : simple ] it follows that @xmath639 is regionally simple .",
    "note that since maximum ( property 3 of lemma  [ lem : simple ] of any finite set of simple functions over a region is one of the functions from the set , it follows that the set @xmath640 is regionally constant .",
    "the proof for the lemma  [ lemma1 ] is similar and hence omitted .",
    "the following two lemmas together with finiteness of regionally constant positional strategies give the proof of theorem  [ thm : final ] .",
    "the proofs of these lemma are similar to lemma  [ lemma : global - improvement ] and hence omitted .",
    "[ impr1 ] let @xmath641 . if @xmath642 then @xmath643 is such that @xmath644 and if @xmath645 then @xmath646 .",
    "[ impr2 ] let @xmath647 .",
    "if @xmath648 then @xmath649 is such that @xmath650 and if @xmath651 then @xmath652 .",
    "we prove our undecidability result using a reduction from two - counter machine .",
    "a two - counter machine @xmath653 is a tuple @xmath654 where @xmath655 is the set of instructions  including a distinguished terminal instruction @xmath656 called halt  and @xmath657 is the set of two _ counters_. the instructions @xmath154 are one of the following types :    1 .",
    "( increment @xmath226 ) @xmath658 ; goto @xmath423 , 2 .",
    "( decrement @xmath226 ) @xmath659 ; goto @xmath423 , 3 .",
    "( zero - check @xmath226 ) @xmath660 : if @xmath661 then goto @xmath423 else goto @xmath662 , 4 .   ( halt ) @xmath663 halt .    where @xmath111 , @xmath664 .",
    "a configuration of a two - counter machine is a tuple @xmath665 where @xmath666 is an instruction , and @xmath667 are natural numbers that specify the value of counters @xmath668 and @xmath669 , respectively .",
    "the initial configuration is @xmath670 .",
    "a run of a two - counter machine is a ( finite or infinite ) sequence of configurations @xmath671 where @xmath672 is the initial configuration , and the relation between subsequent configurations is governed by transitions between respective instructions .",
    "the run is a finite sequence if and only if the last configuration is the terminal instruction @xmath656 .",
    "note that a two - counter machine has exactly one run starting from the initial configuration .",
    "the _ halting problem _ for a two - counter machine asks whether its unique run ends at the terminal instruction @xmath656 .",
    "it is well known  ( @xcite ) that the halting problem for two - counter machines is undecidable .                                at ( -2,-5.2 )",
    "( b1)@xmath537 ; ( ) [ above of = b1,node distance=5mm , color = gray]@xmath311 ; at ( -0.5,-5.2 ) ( c1)@xmath110 ; ( b1 ) edge node @xmath438 node[below]@xmath439 ( c1 ) ; at ( 1,-5.2 ) ( c2)@xmath537 ; ( c1 ) edge node[above]@xmath441 node[below]@xmath436 ( c2 ) ; at ( 2.5,-5.2 ) ( c3)@xmath110 ; ( c2 ) edge node[above]@xmath438 node[below]@xmath439 ( c3 ) ; at ( 4,-5.2 ) ( c4)@xmath537 ; ( c3 ) edge node[above]@xmath441 node[below]@xmath436 ( c4 ) ;    at ( 5.5,-5.2 ) ( c5)@xmath110 ; ( c4 ) edge node[above]@xmath438 node[below]@xmath439 ( c5 ) ; at ( 7,-5.2 ) ( c6)@xmath537 ; ( c5 ) edge node[above]@xmath441 node[below]@xmath436 ( c6 ) ; at ( 8.5,-5.2 ) ( c7)@xmath110 ; ( c6 ) edge node[above]@xmath438 node[below]@xmath439 ( c7 ) ; ( ) [ above of = c7,node distance=5mm , color = gray]@xmath432 ;      : the module to increment @xmath421 is given in fig .  [ fig_undec_mpg_inc_new ] .",
    "again , we start at @xmath423 with @xmath444 and @xmath418",
    ". let @xmath446 be called as @xmath445 .",
    "a time of @xmath676 is spent at @xmath423 .",
    "let the time spent at @xmath677 be denoted @xmath678 . to correctly increment counter 1",
    ", @xmath678 must be @xmath679 .",
    "no time is spent at @xmath424 .",
    "player max can either continue simulation of the next instruction , or can enter one of the widgets @xmath680 to verify if @xmath678 is indeed @xmath679 .",
    "if player min makes an error by elapsing a time @xmath681 , then player max chooses the widget @xmath682 .",
    "it can be seen that the cost of going from @xmath6 to @xmath156 once in @xmath682 is @xmath683 .",
    "the mean cost incurred by min in going from @xmath6 to @xmath6 through @xmath156 once , when max chooses @xmath682 is hence @xmath64 .",
    "similarly , if min makes an error by elapsing a time @xmath684 , then player max chooses the widget @xmath685 .",
    "the mean cost incurred in one transit from @xmath6 to @xmath6 through @xmath156 in @xmath685 is again @xmath64 .",
    "if min makes no simulation error , then the mean cost incurred is 0 .",
    "\\(a ) edge node @xmath686 node[below]@xmath439 ( b ) ; ( b ) edge node @xmath441 node[below]@xmath436 ( c ) ; ( c ) edge node @xmath674 node[below]@xmath436 ( d ) ; ( d ) edge node @xmath438 node[below]@xmath439 ( e ) ; ( e ) ",
    "( 9 , -3.5 ) ",
    "( 0 , -3.5 ) ",
    "( a ) ; at ( -.8 , -2.6 ) ( n ) @xmath682 ; ( -.5,-3.7 ) rectangle ( 9.5,-1.75 ) ;                  ( a1 ) edge node @xmath686 node[below]@xmath439 ( b1 ) ; ( b1 ) edge node @xmath441 node[below]@xmath436 ( c1 ) ; ( c1 ) edge node @xmath674 node[below]@xmath436 ( d1 ) ; ( d1 ) edge node @xmath438 node[below]@xmath439 ( e1 ) ; ( e1 )  ( 9 , 2.5 )  ( 0 , 2.5 )  ( a1 ) ;        : fig .",
    "[ fig_undec_mpg_zerocheck ] shows the module for zero - check instruction for counter @xmath687 .",
    "@xmath423 is a no time elapse location , from where , player min chooses one of the locations @xmath688 or @xmath689 .",
    "both these are player max locations , and player max can either continue the simulation , or can go to the check widgets @xmath690 or @xmath691 to verify the correctness of player min s choice . the widgets @xmath690 and @xmath691 are given in fig .",
    "[ fig_undec_mpg_wze ] and fig .",
    "[ fig_undec_mpg_wzne_new ] respectively .",
    "\\(a ) edge node @xmath699 ( b ) ; ( b ) edge[bend right=10 ] node[below ] @xmath435 ( chk ) ; ( chk ) edge [ bend right=10 ] node[above ] @xmath700",
    "( b ) ; ( chk ) edge node ( wd11 ) ; ( chk ) edge node ( wd12 ) ; ( b ) edge node[left ] @xmath701 ( t ) ; ( t ) edge [ loop left ] node @xmath702 ( t ) ; ( chk ) edge node[left]@xmath703 node[right]@xmath436 ( c ) ; ( c ) edge[bend right=20 ] node[above ] @xmath704 ( d ) ; ( c ) edge[bend right=20 ] node[below ] @xmath436 ( d ) ; ( d ) edge[bend right=20 ] node[above ] @xmath702 ( c ) ;                  \\(a ) edge node @xmath699 ( b ) ; ( b ) edge[bend right=10 ] node[below ] @xmath705 ( chk ) ; ( chk ) edge [ bend right=10 ] node[above ] @xmath706 ( b ) ; ( chk ) edge node ( wd11 ) ; ( chk ) edge node ( wd12 ) ; ( b ) edge node[left ] @xmath707 ( d ) ; ( d ) edge[bend left=70 ] node[left ] @xmath708 ( t ) ; ( d ) edge[bend left=70 ] node[right ] @xmath436 ( t ) ; ( t ) edge[bend left=70 ] node[left ] @xmath702 ( d ) ;        * consider the case when player min guessed that @xmath687 is zero , and entered the location @xmath688 in fig .",
    "[ fig_undec_mpg_zerocheck ] .",
    "let us assume that player max verifies player min s guess by entering @xmath690 ( fig .",
    "[ fig_undec_mpg_wze ] ) .",
    "no time is spent in the initial location @xmath6 of @xmath690 .",
    "we are therefore at @xmath311 with @xmath710 and @xmath711 . in case @xmath712",
    ", we can directly go to the @xmath698 state , and keep looping there forever , incurring mean cost 0 . if that is not the case , player min has to prove his claim right , by multiplying @xmath713 with 5 repeatedly , till @xmath713 becomes 1 ; clearly , this is possible iff @xmath714 .",
    "the loop between @xmath311 and @xmath424 precisely does this : each time player min spends a time @xmath715 in @xmath311 , player max can verify that @xmath716 by going to @xmath443 or @xmath450 or come back to @xmath311 .",
    "no time is elapsed in @xmath424 . finally ,",
    "if @xmath717 , we can go to @xmath698 , and player min achieves his objective .",
    "however , if @xmath687 was non - zero , then @xmath713 will never reach 1 after repeatedly multiplying @xmath713 with 5 ; in this case , at some point , the edge from @xmath424 to @xmath432 will be enabled . in this case",
    ", the infinite loop between @xmath432 and @xmath697 , will lead to a mean cost greater than 0 . *",
    "consider now the case when player min guessed that @xmath687 is non - zero , and hence entered the location @xmath718 in fig .",
    "[ fig_undec_mpg_zerocheck ] .",
    "let us assume now that player max enters @xmath691 ( fig .",
    "[ fig_undec_mpg_wzne_new ] ) to verify player min s guess .",
    "similar to @xmath690 , no time is spent at location @xmath6 of @xmath691 , and the clock values at @xmath311 are @xmath710 and @xmath711 . if @xmath712 , then @xmath717 , in which case , the location @xmath433 is reached , from where , the loop between @xmath719 is taken incurring a mean cost greater than 0 .",
    "+ if that is not the case , player @xmath29 , to prove his claim , repeatedly multiplies @xmath713 by 5 using the loop between @xmath311 and @xmath424 .",
    "@xmath713 becomes @xmath537 iff @xmath714 .",
    "once @xmath713 becomes @xmath537 , the edge from @xmath311 to @xmath433 will be enabled . in this case",
    ", the infinite loop between @xmath433 and @xmath697 , will lead to a mean cost greater than 0 .",
    "note that once @xmath713 becomes 1 , player @xmath29 can also wait in @xmath311 and transit to @xmath424 .",
    "however , due to the guard on the edge from @xmath311 to @xmath424 , the delay at @xmath311 will be less than @xmath447 , ( when @xmath717 , @xmath720 , @xmath712 ) say @xmath721 in which case too player @xmath34 can go to @xmath443 or @xmath450 and the mean cost will be @xmath64 . if @xmath687 was non - zero , then @xmath713 will never reach 1 after repeatedly multiplying @xmath713 with 5 ; in this case , at some point , @xmath713 will be greater than 1 and the edge from @xmath311 to @xmath698 will be enabled and player @xmath29 can achieve his objective by moving to @xmath698 .      on entry into the location @xmath722 ( for halt instruction ) , we reset clock @xmath713 to 0 ; from @xmath722 , we go to a state @xmath698 with price 1 , with a self loop that checks @xmath717 , and resets @xmath713 .    1 .",
    "assume that the two counter machine halts .",
    "if player min simulates all the instructions correctly , he will incur a mean cost @xmath723 , by either reaching the @xmath698 after @xmath722 : when player min does not cheat , player max has no incentive to enter any of the check widgets , he will just let the computation continue , till the halt location is reached .",
    "this will incur a mean cost @xmath723 .",
    "if player min makes an error in his computation , player max can always enter an appropriate widget , making the mean cost @xmath723 . in summary , if the two counter machine halts , then player min has no strategy to achieve his goal ( mean pay off @xmath456 ) .",
    "2 .   assume that the two counter machine does not halt .",
    "* if player min simulates all the instructions correctly , and if player max never enters a check widget , then player min incurs cost 0 , since all locations in the main modules have price 0 .",
    "even if player max enters some widget , the mean cost of player min is still 0 , since no errors were made by min . however ,",
    "if player min makes an error , player max can enter a check widget , ensuring that the mean cost is @xmath723 .",
    "thus , if the two counter machine does not halt , player min has a strategy ( by making no errors ) to achieve mean cost 0 . + in summary , if the two counter machine does not halt , player min has a strategy to achieve his goal , and vice - versa .    thus , player min incurs a mean cost @xmath456 iff he chooses the strategy of faithfully simulating the two counter machine , when the machine does not halt . when the machine halts , the mean cost incurred by player min is more than 0 irrespective of whether he makes a simulation error or not .",
    "now we argue that the @xmath198 problem is undecidable for ptgas with @xmath725 clocks , having only binary location prices and no edge prices , for @xmath726 .",
    "we note that in the previous undecidability result , all the modules apart from the @xmath727 and @xmath728 use binary location prices .",
    "thus we now give here these modules with only binary prices .",
    "[ dec_binary_pos ] shows the module @xmath427 while fig .",
    "[ dec_binary_neg ] shows the module @xmath428 with location prices 0 and 1 .",
    "the modules @xmath732 and @xmath728 can also be similarly made with only binary prices .",
    "the module @xmath427 is chosen by the @xmath34 player when the error made by the @xmath29 player while simulating the decrement counter @xmath421 operation is @xmath64 .",
    "the module @xmath428 is chosen by the @xmath34 player when the error made by the @xmath29 player is @xmath733 .",
    "when no error is made by the @xmath29 player , the mean cost @xmath427 is @xmath734 while the cost in the presence of an error is @xmath735 .",
    "the modules for zerocheck ( figure [ fig_undec_mpg_zerocheck ] ) can be used as they are . in case",
    "an error is made in the guess , the meanpayoff incurred by shuttling between locations @xmath736 ( figure [ fig_undec_mpg_wze ] ) or @xmath719 ( figure [ fig_undec_mpg_wzne_new ] ) is @xmath737 .",
    "mean - payoff game ( per time unit ) has been studied in @xcite . the mean - payoff ( per time unit ) of a play is defined as the long - run average of cost per time unit .",
    "formally , the mean payoff of a play @xmath738 starting from a state @xmath11 in which players @xmath29 and @xmath34 play according to @xmath0 and @xmath33 respectively is @xmath739      [ thm - undec_per_time ] the mean - payoff problem @xmath198 is undecidable for ptga @xmath176 with 3 clocks having location - wise price - rates @xmath410 for all @xmath153 and @xmath411 . moreover , it is undecidable for binary - priced @xmath176 with 3 clocks and @xmath740 .",
    "we first show the undecidability of @xmath413 with location prices @xmath414 and no edge prices .",
    "we prove the result by reducing the non - halting problem of 2 counter machines .",
    "given a two counter machine @xmath741 , we construct a ptga @xmath1 with 3 clocks @xmath415 , and arbitrary location prices , but no edge prices , and show that player @xmath29 has a winning strategy iff @xmath741 does not halt .",
    "we specify a module for each instruction of the two counter machine . on entry into a module",
    ", we have @xmath742 , @xmath417 and @xmath418 , where @xmath419 are the values of counters @xmath420 .",
    "we construct the ptga @xmath1 whose building blocks are the modules for instructions . the role of player min",
    "is to faithfully simulate the two counter machine , by choosing appropriate delays to adjust the clocks to reflect changes in counter values .",
    "player max will have the opportunity to verify that player @xmath29 did not cheat while simulating the machine .",
    "we shall now present modules for increment , decrement and zero check instructions .",
    "for conciseness of the figures , we present here modules using arbitrary prices .",
    "however , we can redraw these with extra locations and edges using only the location prices from @xmath414 , as was done in the case of theorem [ thm_undec ] .",
    "\\(a ) edge node @xmath437 node[below]@xmath436 ( b ) ; ( b ) edge node @xmath438 node[below]@xmath439 ( c ) ; ( c ) edge node @xmath440 node[below]@xmath439 ( d ) ; ( d ) edge node @xmath441 node[below]@xmath436 ( e ) ; ( e ) ",
    "( 9 , -4.5 ) ",
    "( 0 , -4.5 ) ",
    "( a ) ; at ( -.8 , -3.5 ) ( n ) @xmath443 ; ( -.5,-4.7 ) rectangle ( 9.5,-2.75 ) ;                ( a1 ) edge node @xmath437 node[below]@xmath436 ( b1 ) ; ( b1 ) edge node @xmath438 node[below]@xmath439 ( c1 ) ; ( c1 ) edge node @xmath440 node[below]@xmath439 ( d1 ) ; ( d1 ) edge node @xmath441 node[below]@xmath436 ( e1 ) ; ( e1 )  ( 9 , -7 ) ",
    "( 0 , -7 ) ",
    "( a1 ) ; at ( -.8 , -6 ) ( n ) @xmath450 ; ( -.5,-7.2 ) rectangle ( 9.5,-5.25 ) ;      the module to simulate the decrement of counter @xmath421 is given in figure  [ fig - undec_mpg_dec_new_ptu ] .",
    "we enter location @xmath423 with @xmath745 , @xmath417 and @xmath418 .",
    "lets denote by @xmath445 the value @xmath446 . to correctly decrement @xmath421 , player",
    "min should choose a delay of @xmath447 at location @xmath423 .",
    "at location @xmath424 , there is no time elapse .",
    "player max has three possibilities : ( @xmath448 ) to go to @xmath426 , or ( @xmath449 ) to enter the widget @xmath443 , or ( iii ) to enter the widget @xmath450 .",
    "if player min makes an error , and delays @xmath451 or @xmath452 at @xmath423 ( @xmath60 ) , then player max can enter one of the widgets and punish player min .",
    "player max enters widget @xmath443 if the error made by player min is of the form @xmath451 at @xmath423 and enters widget @xmath450 if the error made by player min is of the form @xmath452 at @xmath423 .",
    "let us examine the widget @xmath443 .",
    "when we enter @xmath443 for the first time , we have @xmath453 , @xmath454 and @xmath418 . in @xmath443 ,",
    "the cost of going once from location @xmath6 to @xmath156 is @xmath455 .",
    "also , when we get back to @xmath6 after going through the loop once , the clock values with which we entered @xmath443 are restored ; thus , each time , we come back to @xmath6 , we restore the starting values with which we enter @xmath443 .",
    "the third clock is really useful for this purpose only . the total time elapsed in 3 time units ;",
    "at @xmath6 , the value of clock @xmath746 is 0 and the transition from @xmath156 to @xmath6 is enabled when @xmath747 .",
    "hence the mean cost of transiting from @xmath6 to @xmath6 through @xmath156 is @xmath748 . in a similar way",
    ", it can be checked that the mean cost of transiting from @xmath6 to @xmath6 through @xmath156 in widget @xmath450 is @xmath748 when player min chooses a delay @xmath452 at @xmath423 .",
    "thus , if player min makes a simulation error , player max can always choose to go to one of the widgets , and ensure that the mean pay - off is _ not _ @xmath456 .",
    "note however that when @xmath457 , then player min will always achieve his objective : the mean pay - off will be 0 .",
    "\\(a ) edge node @xmath686 node[below]@xmath439 ( b ) ; ( b ) edge node @xmath441 node[below]@xmath436 ( c ) ; ( c ) edge node @xmath674 node[below]@xmath436 ( d ) ; ( d ) edge node @xmath438 node[below]@xmath439 ( e ) ; ( e ) ",
    "( 9 , -3.5 ) ",
    "( 0 , -3.5 ) ",
    "( a ) ; at ( -.8 , -2.6 ) ( n ) @xmath682 ; ( -.5,-3.7 ) rectangle ( 9.5,-1.75 ) ;                  ( a1 ) edge node @xmath686 node[below]@xmath439 ( b1 ) ; ( b1 ) edge node @xmath441 node[below]@xmath436 ( c1 ) ; ( c1 ) edge node @xmath674 node[below]@xmath436 ( d1 ) ; ( d1 ) edge node @xmath438 node[below]@xmath439 ( e1 ) ; ( e1 )  ( 9 , 2.5 )  ( 0 , 2.5 )  ( a1 ) ;        : the module to increment @xmath421 is given in fig .  [ fig - undec_mpg_inc_new_ptu ] .",
    "again , we start at @xmath423 with @xmath444 and @xmath418 .",
    "let @xmath446 be called as @xmath445 .",
    "a time of @xmath676 is spent at @xmath423 .",
    "let the time spent at @xmath677 be denoted @xmath678 . to correctly increment counter 1",
    ", @xmath678 must be @xmath679 . no time is spent at @xmath424",
    ". player max can either continue simulation of the next instruction , or can enter one of the widgets @xmath680 to verify if @xmath678 is indeed @xmath679 .",
    "if player min makes an error by elapsing a time @xmath681 , then player max chooses the widget @xmath682 .",
    "it can be seen that the cost of going from @xmath6 to @xmath156 once in @xmath682 is @xmath683 and the time spent in moving from @xmath6 to @xmath6 through @xmath156 is 3 time units .",
    "hence the mean cost incurred by min in going from @xmath6 to @xmath6 through @xmath156 once , when max chooses @xmath682 is hence @xmath748 .",
    "similarly , if min makes an error by elapsing a time @xmath684 , then player max chooses the widget @xmath685 .",
    "the mean cost incurred in one transit from @xmath6 to @xmath6 through @xmath156 in @xmath685 is again @xmath748 . if min makes no simulation error , then the mean cost incurred is 0 .      :",
    "figure  [ fig - undec_mpg_zerocheck_ptu ] shows the module for zero - check instruction for counter @xmath687 .",
    "@xmath423 is a no time elapse location , from where player min chooses one of the locations @xmath688 or @xmath689 .",
    "both these are player max locations , and player max can either continue the simulation , or can go to the check widgets @xmath690 or @xmath691 to verify the correctness of player min s choice . the widgets @xmath690 and @xmath691 are given in figure  [ fig - undec_mpg_wze_ptu ] and figure [ fig - undec_mpg_wzne_new_pte ] respectively .",
    "\\(a ) edge node @xmath699 ( b ) ; ( b ) edge[bend right=10 ] node[below ] @xmath435 ( chk ) ; ( chk ) edge [ bend right=10 ] node[above ] @xmath700 ( b ) ; ( chk ) edge node ( wd11 ) ; ( chk ) edge node ( wd12 ) ; ( b ) edge node[left ] @xmath701 ( t ) ; ( t ) edge [ loop left ] node @xmath702 ( t ) ; ( chk ) edge node[left]@xmath703 node[right]@xmath436 ( c ) ; ( c ) edge[bend right=20 ] node[above ] @xmath704 ( d ) ; ( c ) edge[bend right=20 ] node[below ] @xmath436 ( d ) ; ( d ) edge[bend right=20 ] node[above ] @xmath702 ( c ) ;                \\(a ) edge node @xmath699 ( b ) ; ( b ) edge[bend right=10 ] node[below ] @xmath705 ( chk ) ; ( chk ) edge [ bend right=10 ] node[above ] @xmath706 ( b ) ; ( chk ) edge node ( wd11 ) ; ( chk ) edge node ( wd12 ) ; ( b ) edge node[left ] @xmath707 ( d ) ; ( d ) edge[bend left=70 ] node[left ] @xmath708 ( t ) ; ( d ) edge[bend left=70 ] node[right ] @xmath436 ( t ) ; ( t ) edge[bend left=70 ] node[left ] @xmath702 ( d ) ;      * consider the case when player min guessed that @xmath687 is zero , and entered the location @xmath688 in figure [ fig - undec_mpg_zerocheck_ptu ] .",
    "let us assume that player max verifies player min s guess by entering @xmath690 ( figure [ fig - undec_mpg_wze_ptu ] ) .",
    "no time is spent in the initial location @xmath6 of @xmath690 .",
    "we are therefore at @xmath311 with @xmath710 and @xmath711 . in case @xmath712",
    ", we can directly go to the @xmath698 state , and keep looping there forever , incurring mean cost 0 .",
    "if that is not the case , player min has to prove his claim right , by multiplying @xmath713 with 5 repeatedly , till @xmath713 becomes 1 ; clearly , this is possible iff @xmath714 .",
    "the loop between @xmath311 and @xmath424 precisely does this : each time player min spends a time @xmath715 in @xmath311 , player max can verify that @xmath716 by going to @xmath443 or @xmath450 or come back to @xmath311 .",
    "no time is elapsed in @xmath424 . finally ,",
    "if @xmath717 , we can go to @xmath698 , and player min achieves his objective .",
    "however , if @xmath687 was non - zero , then @xmath713 will never reach 1 after repeatedly multiplying @xmath713 with 5 ; in this case , at some point , the edge from @xmath424 to @xmath432 will be enabled . in this case , the infinite loop between @xmath432 and @xmath697 , will lead to a mean cost of 1 . *",
    "consider now the case when player min guessed that @xmath687 is non - zero , and hence entered the location @xmath718 in fig .",
    "[ fig - undec_mpg_zerocheck_ptu ] .",
    "let us assume now that player max enters @xmath691 ( fig .",
    "[ fig - undec_mpg_wzne_new_pte ] ) to verify player min s guess .",
    "similar to @xmath690 , no time is spent at location @xmath6 of @xmath691 , and the clock values at @xmath311 are @xmath710 and @xmath711 . if @xmath712 , then @xmath717 , in which case , the location @xmath433 is reached , from where , the loop between @xmath719 is taken incurring a mean cost of 1 . if that is not the case , player @xmath29 repeatedly multiplies @xmath713 by 5 using the loop between @xmath311 and @xmath424 .",
    "@xmath713 becomes @xmath537 iff @xmath714 .",
    "once @xmath713 becomes @xmath537 , the edge from @xmath311 to @xmath433 will be enabled . in this case",
    ", the infinite loop between @xmath433 and @xmath697 , will lead to a mean cost of 1 .",
    "note that if once @xmath713 becomes 1 , player @xmath29 could also wait in @xmath311 and transit to @xmath424 .",
    "however , due to the guard on the edge from @xmath311 to @xmath424 , the delay at @xmath311 will be less than @xmath447 , where @xmath749 .",
    "say the delay is @xmath721 in which case too player @xmath34 can go to @xmath443 or @xmath450 and the mean cost will be greater than 0 . if @xmath687 was non - zero , then @xmath713 will never reach 1 after repeatedly multiplying @xmath713 with 5 ; in this case , at some point , @xmath713 will be greater than 1 and the edge from @xmath311 to @xmath698 will be enabled and player @xmath29 can achieve its objective by moving to @xmath698 .      on entry into the location @xmath722 ( for halt instruction )",
    ", we reset clock @xmath713 to 0 ; from @xmath722 , we go to a state @xmath698 with price 1 , with a self loop that checks @xmath717 , and resets @xmath713 .    1 .",
    "assume that the two counter machine halts .",
    "if player min simulates all the instructions correctly , he will incur a mean cost @xmath723 , by either reaching the @xmath698 after @xmath722 : when player min does not cheat , player max has no incentive to enter any of the check widgets , he will just let the computation continue , till the halt location is reached .",
    "this will incur a mean cost @xmath723 .",
    "if player min makes an error in his computation , player max can always enter an appropriate widget , making the mean cost @xmath723 . in summary , if the two counter machine halts , then player min has no strategy to achieve his goal ( mean pay off @xmath456 ) .",
    "2 .   assume that the two counter machine does not halt .",
    "* if player min simulates all the instructions correctly , and if player max never enters a check widget , then player min incurs cost 0 , since all locations in the main modules ( modules simulating decrement counters , increment counters and zero check ) have price 0 .",
    "even if player max enters some widget , the mean cost of player min is still 0 , since no errors were made by min .",
    "however , if player min makes an error , player max can enter a check widget , ensuring that the mean cost is @xmath723 .",
    "thus , if the two counter machine does not halt , player min has a strategy ( by making no errors ) to achieve mean cost 0 . + in summary , if the two counter machine does not halt , player min has a strategy to achieve his goal , and vice - versa .    thus , player min incurs a mean cost @xmath456 iff he chooses the strategy of faithfully simulating the two counter machine , when the machine does not halt . when the machine halts , the mean cost incurred by player min is more than 0 irrespective of whether he makes a simulation error or not",
    ".    now we argue that the @xmath198 ( @xmath724 ) problem is undecidable for ptgas with @xmath725 clocks , having _ only binary location prices and no edge prices_. we note that in the previous undecidability result , all the modules apart from the @xmath727 and @xmath728 use binary location prices . as in figure [ dec_binary_neg ] and",
    "figure [ dec_binary_pos ] , these modules can be constructed easily .",
    "the module @xmath427 is chosen by the @xmath34 player when the error made by the @xmath29 player while simulating the decrement counter @xmath421 operation is @xmath64 .",
    "the module @xmath428 is chosen by the @xmath34 player when the error made by the @xmath29 player is @xmath733 ."
  ],
  "abstract_text": [
    "<S> mean - payoff games on timed automata are played on the infinite weighted graph of configurations of priced timed automata between two players  player min and player max  by moving a token along the states of the graph to form an infinite run . </S>",
    "<S> the goal of player min is to minimize the limit average weight of the run , while the goal of the player max is the opposite . </S>",
    "<S> brenguier , cassez , and raskin recently studied a variation of these games and showed that mean - payoff games are undecidable for timed automata with five or more clocks . </S>",
    "<S> we refine this result by proving the undecidability of mean - payoff games with three clocks . on a positive side </S>",
    "<S> , we show the decidability of mean - payoff games on one - clock timed automata with binary price - rates . </S>",
    "<S> a key contribution of this paper is the application of dynamic programming based proof techniques applied in the context of average reward optimization on an uncountable state and action space . </S>"
  ]
}