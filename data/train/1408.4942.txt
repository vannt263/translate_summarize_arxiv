{
  "article_text": [
    "algorithms for computing multiplicative order or simply order and primitive root or generator are important in the area of random number generation and discrete logarithm problem among others . in this paper",
    "we consider the problem of computing the order of an element over @xmath6 , which is multiplicative group modulo @xmath7 .",
    "as stated above order of an element @xmath8 is the least positive integer @xmath2 such that @xmath9 . in number",
    "theoretic language , we say that the order of @xmath0 modulo @xmath10 is @xmath2 , if @xmath2 is the smallest positive integer such that @xmath11 .",
    "we also consider the related problem of computing the primitive root in @xmath6 .",
    "if order of an element @xmath12 usually denoted as @xmath13 is equal to @xmath14 i.e. order of multiplicative group modulo @xmath2 , then @xmath0 is called called primitive root or primitive element or generator [ 3 ] of @xmath15 .",
    "it is called generator because every element in @xmath16 is some power of @xmath0 .",
    "+ efficient deterministic algorithms for both of the above problems are not known yet .",
    "however if the prime factorization of @xmath17 is provided then efficient algorithms can be designed .",
    "since factorization itself is very difficult for large numbers , and no polynomial time algorithm is known for this problem .",
    "therefore no direct method is available to solve these problems when the size of the group or @xmath2 is very large .",
    "+ work has been done on searching for primitive root in @xmath18 .",
    "here the task is to generate a subset of @xmath18 , which contains at least one primitive root [ 8 , 9 ] . assuming extended riemann hypothesis ( erh ) it has been shown that there exists a positive integer @xmath19 for some constant @xmath20 such that @xmath21 is primitive root over @xmath22 [ 10 ] .",
    "however searching for small primitive root not necessarily imply a fast method for computing primitive root .",
    "in [ 5 ] authors presented a randomized algorithm for generating primitive root modulo a prime with high probability , in particular the algorithm computes every prime factor @xmath23 of @xmath24 such that @xmath23 is less than some specified value .",
    "+ for computing order and primitive root in @xmath6 , factorization of order of the group @xmath25 is required , and as we mentioned before that factorization of @xmath26 can not be calculated efficiently for large @xmath7 , and there is no any other approach to attack the problem , it has been suggested to construct or generate a large prime @xmath7 together with primitive root for @xmath6 . in this setting prime factorization of @xmath27 is known and the task is to compute primitive root with high probability .",
    "this paper describes the algorithms in this context .",
    "we describe straight forward basic algorithms as well as a logarithmic improvement over the traditional one . + this paper is organized as follows .",
    "section ii explains preliminaries and basic algorithms , section iii describes modified algorithms and their analysis , finally , section iv contains conclusion .",
    "a group @xmath28 is an algebraic structure , which consists of a set @xmath1 together with a binary operation * over @xmath1 , such that * follows closure , associative property , @xmath1 possesses a unique identity element @xmath4 , and every element @xmath0 of @xmath1 has unique inverse @xmath29 .",
    "when the binary operation * is clear from context , the group is simply represented by @xmath1 .",
    "order or size of a group is the number of elements in @xmath1 and denoted as @xmath30 .",
    "if order of a group is a finite number , then it is called finite group .",
    "if @xmath1 is a group then order of @xmath31 is the least positive integer @xmath2 such that @xmath3 .",
    "+ the set @xmath32 under addition modulo @xmath2 forms a group where equivalence class @xmath33_n$ ] is the identity and equivalence class @xmath34_n$ ] is the inverse of @xmath35_n$ ] .",
    "the set @xmath36 or @xmath37 under multiplication modulo @xmath2 forms a group with equivalence class @xmath38_n$ ] as identity , and inverse of @xmath35_n$ ] is denoted by @xmath35_n^{-1}$ ] .",
    "+ a multiplicative group @xmath1 is said to be cyclic group if @xmath39 , it implies that there exists @xmath31 such that for every @xmath40 there exists @xmath2 with @xmath41 . here",
    "@xmath0 is called generator or primitive root or primitive element . by definition",
    "every cyclic group consists of a generator .",
    "for example additive group @xmath42 is finite cyclic group with equivalence class @xmath38_n$ ] as a generator .",
    "now we state following results , which can be found in any standard algebra texts [ 4 , 7 ] . + * proposition 1*. _ let @xmath1 be a finite group and @xmath43 is a subgroup of @xmath1 , then @xmath44_. + let @xmath45 , here @xmath46 .",
    "let there be an element @xmath40 and @xmath47 , now by taking product of @xmath48 and elements of subgroup @xmath43 , we can create @xmath2 new and distinct elements of @xmath1 . which are @xmath49 .",
    "note that if @xmath50 , it imply that @xmath51 , which is not possible since all @xmath52 s are distinct by definition .",
    "also @xmath53 , and since @xmath43 is subgroup , therefore by definition it is closed , and every element has a inverse .",
    "it imply that @xmath54 again a contradiction . by repeating in this way for every new element of @xmath1 which is not already in @xmath43",
    ", we can produce @xmath2 more new and distinct elements of @xmath1 .",
    "suppose we stop after @xmath10 iterations then @xmath55 and therefore @xmath56 divides @xmath5 .",
    "+ * proposition 2*. _ let @xmath1 be a finite group and @xmath31 , then @xmath57_. + since @xmath58 is a subgroup which happened to be cyclic and generated by @xmath0 .",
    "@xmath59 divides @xmath5 . +",
    "* proposition 3*. _ let @xmath1 be a finite group and @xmath31 , then @xmath60_. + using proposition 2 , we can write @xmath61 for @xmath62 . hence @xmath63 .",
    "above proposition in number - theoretic context can be stated as follows .",
    "+ * proposition 4*. ( euler s theorem ) _ if @xmath0 is relatively prime to a positive integer @xmath2 , then @xmath64 for all @xmath65_. + since @xmath66 is multiplicative group with @xmath67 and identity 1 .",
    "+ * proposition 5*. ( fermat s theorem ) _",
    "@xmath68 for any prime @xmath7 and all @xmath69_. + restricting @xmath2 to prime number @xmath7 and putting @xmath70 in euler s theorem , proposition 5 follows .",
    "+ * proposition 6*. _ let @xmath1 be a finite group whose order is a prime number then @xmath1 is a cyclic group_. + here @xmath5 is a prime number .",
    "suppose @xmath31 and is distinct from @xmath4 . from proposition 2 @xmath71 and @xmath72 .",
    "it follows that @xmath73 . + * proposition 7*. _ the multiplicative group @xmath66 is cyclic , if @xmath2 equals to 2 , 4 , @xmath74 and @xmath75 for any odd prime @xmath7 and positive integer @xmath4 _ [ 6 ] . +",
    "* proposition 8*. _ let @xmath76 such that @xmath0 has order @xmath77 , @xmath48 has order @xmath78 and @xmath79 , i.e. @xmath77 and @xmath78 are relatively prime , then @xmath80 has order @xmath81_. + we have @xmath82 . therefore @xmath83",
    "let @xmath84 , then @xmath85 . hence @xmath86 but @xmath79 so @xmath87",
    "similarly @xmath88 and therefore @xmath89 .",
    "* proposition 9*. _ let @xmath65 . if @xmath90 and @xmath91 for some prime @xmath7 and @xmath92 , then @xmath0 has order @xmath74_. + let @xmath10 be the multiplicative order of @xmath0 , that is @xmath10 is the least positive integer such that @xmath93 . if @xmath90 then , @xmath94 . since @xmath7 is prime ,",
    "let @xmath95 then @xmath96 should be one of @xmath97 . in the case",
    "@xmath98 , it imply that @xmath99 , which is contradiction and therefore @xmath100 . +",
    "* proposition 10*. _ let @xmath69 and @xmath101 .",
    "let prime factorization of @xmath24 be @xmath102 .",
    "let @xmath103 be the largest integer such that @xmath104 , then order of @xmath0 is @xmath105 _ [ 1 ] .",
    "+ algorithms for computing order and primitive root can be found in any standard computational number theory and related books [ 1 , 2 , 7 ] . in this section",
    "we describe straight forward algorithms to perform these tasks .",
    "computation of multiplicative - order is described in algorithm 1 .",
    "input to this algorithm are prime factorization of order of finite cyclic group @xmath106 , along with an element @xmath0 of this group @xmath107 . output to this algorithm is multiplicative order of @xmath0 .",
    "* input * : @xmath108 * output * : multiplicative order @xmath2 of @xmath0 @xmath109 + @xmath2    algorithm 2 describes primitive - root computation . input to this algorithm is prime factorization of order of group @xmath107 , and output to this algorithm is primitive root of this group .",
    "primitive - root is a randomized algorithm as it selects a random element @xmath0 of @xmath107 in the first step of each iteration .",
    "* input * : @xmath110 * output * : primitive root @xmath0 of @xmath107 select @xmath69 at random + @xmath0",
    "for computing multiplicative order of an element @xmath65 , where prime factorization of @xmath2 is given as @xmath111 and we are required to compute @xmath112 . let @xmath113 for @xmath114 . therefore @xmath115 .",
    "here we assume that @xmath116 is calculated as @xmath117 . to compute @xmath116 ,",
    "@xmath118 multiplications are required .",
    "for example , to compute @xmath119 , it requires @xmath118 multiplications . by using some precomputations @xmath116",
    "can be computed in only @xmath120 multiplications .",
    "therefore total cost to compute @xmath121 becomes @xmath122 bit operations .",
    "+ for @xmath123 , we have @xmath124 . with precomputing : + @xmath125 + @xmath126 + we can compute each @xmath116 in only two multiplications . + @xmath127 + @xmath128 + @xmath129 + @xmath130 +   + similarly for @xmath131 , we have + @xmath125 , @xmath126 + @xmath132 , @xmath133 + @xmath134 , @xmath135 + now by using above precomputations , we can compute each @xmath116 is only @xmath136 multiplications .",
    "+ @xmath137 + @xmath138 + @xmath139 + @xmath140 + @xmath141 + @xmath142 + @xmath143 + @xmath144 + above method is generalized in the algorithm 3 .",
    "input to k - exponentiation algorithm is @xmath145 along with with its @xmath146 factors . here , we assume that @xmath146 is exact power of some positive integer that is @xmath147 .",
    "output of this algorithm is @xmath146 integers @xmath148 such that @xmath149 , where @xmath117 .",
    "brief description of this algorithm is as follows .",
    "first precomputed values are assigned in @xmath150 etc .",
    "for loop is used to compute @xmath116 values for @xmath151 , first if loop is used to check whether @xmath152 depending on that second ( inner ) if loop is used to check whether @xmath153 is odd or even . if @xmath153 is odd @xmath116 is calculated in if loop , otherwise it is calculated in else loop . again",
    "this calculation is repeated where @xmath154 in else ( outer ) loop .",
    "* input * : @xmath155 * output * : @xmath156 @xmath157 + @xmath158 + .......... compute @xmath159 , @xmath160 compute @xmath156 @xmath148    correctness of k - exponentiation algorithm can be easily established using induction on number of products @xmath146 .",
    "+ * theorem 1 .",
    "* _ k - exponentiation algorithm computes @xmath149 for @xmath151 where @xmath161 . _ + _ proof _ : assume @xmath147 .",
    "since @xmath162 is the number of products in our case , we shall use induction on @xmath10 . for the base case",
    "we take @xmath163 , therefore we have @xmath164 .",
    "it is a trivial case . here",
    "@xmath165 and @xmath166 . as a induction hypothesis",
    "assume that the above statement is true for upto @xmath167 .",
    "given the statement for @xmath168 .",
    "we can construct the products for @xmath169 . note that in case of @xmath168 , we have two products of length @xmath170 which are @xmath171 and @xmath172 . using these products",
    "we can construct @xmath173 .",
    "it is the first product of length @xmath174 . for the second product , we need two more construction of length @xmath170 .",
    "it is @xmath175 .",
    "now we have constructed both products of length @xmath174 using the products of length @xmath176 , and the statement follows for @xmath169 .",
    "now , using @xmath116 , we can compute @xmath149 for @xmath151 . + complexity to compute @xmath121 for @xmath65 is @xmath122 operations . note that",
    ", we can compute @xmath116 in @xmath177 operations . whereas @xmath121 can be computed using repeated squaring algorithm for modular exponentiation in @xmath178 operations for @xmath65 .",
    "in general algorithm 3 performs @xmath179 precomputations and using that it calculates each @xmath116 in @xmath180 multiplications .",
    "+ using k - exponentiation algorithm as a subroutine , we can write the modified - multiplicative - order algorithm . it is described in algorithm 4 .",
    "again , input to this algorithm are prime factorization of order of group @xmath106 , along - with an element @xmath69 .",
    "output to this algorithm is multiplicative order of @xmath0 .",
    "first step of this algorithm calls k - exponentiation to compute @xmath181 for @xmath114 and stores it in list @xmath148 . in the second step @xmath103",
    "is initialized to 0 , for @xmath114 . after that for each @xmath153 in the while loop maximum integer @xmath103 is calculated such that @xmath104 , and using that final order is computed .",
    "+    * input * : @xmath108 * output * : multiplicative order @xmath2 of @xmath0 @xmath182 k - exponentiation @xmath183 + @xmath184 + @xmath185    * theorem 2 . * _ algorithm 4 computes multiplicative order of @xmath69 . _    _ proof _ : statement of the theorem follows from proposition 8 and 10 .",
    "+ overall complexity of this algorithm is dominated by computing @xmath181 , which is @xmath186 bit operations in @xmath107 .",
    "primitive root of a finite cyclic group is an element whose order is equal to size of the group . from this basic definition of primitive root itself ,",
    "we can write a simple algorithm , which select a random element @xmath69 and computes it s multiplicative order .",
    "if multiplicative order is equal to @xmath70 then it is one of the primitive root .",
    "this method is summarized in algorithm 5 named as simple - primitive - root . in algorithm 5 , if loop uses to check whether order of @xmath0 is equal to @xmath24 , if it is the case @xmath0 is returned otherwise algorithm calls itself and go to first step . if we want to find out least primitive root , then instead of choosing an element randomly , better way is to start from least value of @xmath0 to consecutive higher value @xmath187 etc .",
    "+    * input * : @xmath110 * output * : primitive root @xmath0 of @xmath107 select @xmath69 at random + @xmath188 multiplicative - order @xmath189 + @xmath0 simple - primitive - root @xmath190    while the above algorithm for computing primitive root using multiplicative order is simple , other methods are also there to find primitive element .",
    "one such method we have seen in algorithm 2 .",
    "now we describe the modified - primitive - root algorithm using k - exponentiation .",
    "it is outlined in algorithm 6 .",
    "modified - primitive - root is almost same as algorithm 2 , except that it calls k - exponentiation to compute @xmath181 for @xmath114 and stores it in list @xmath148 . at any time in the if loop ,",
    "whenever algorithm detects @xmath191 , it calls itself and go to step 1 and chooses another random element .",
    "+    * input * : @xmath110 * output * : primitive root @xmath0 of @xmath107 select @xmath69 at random + @xmath182 k - exponentiation @xmath183 + @xmath0    correctness of algorithm 6 follows from proposition 2 , 8 and 9 . again the algorithm is dominated by the computation of @xmath181 , which using k - exponentiation is @xmath186 operations instead of @xmath192 operations .",
    "these randomized algorithms works particularly because for a prime @xmath7 , @xmath107 has @xmath193 primitive roots .",
    "this paper described the algorithms for computing multiplicative order and primitive root in finite cyclic group .",
    "it also presented k - exponentiation algorithm as a subroutine to compute order and primitive elements . in general",
    "if the prime factorization of @xmath70 is given , or @xmath107 is constructed in such a way that factors of @xmath24 is available , then efficient algorithms can be designed to compute order and primitive roots ."
  ],
  "abstract_text": [
    "<S> multiplicative order of an element @xmath0 of group @xmath1 is the least positive integer @xmath2 such that @xmath3 , where @xmath4 is the identity element of @xmath1 . </S>",
    "<S> if the order of an element is equal to @xmath5 , it is called generator or primitive root . </S>",
    "<S> this paper describes the algorithms for computing multiplicative order and primitive root in @xmath6 , we also present a logarithmic improvement over classical algorithms . </S>"
  ]
}