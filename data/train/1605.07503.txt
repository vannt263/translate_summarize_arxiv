{
  "article_text": [
    "this paper focuses in solving the classical decision boolean satisfiability problem ( sat ) using the results in  @xcite for an special case of the decision boolean satisfiability problem , named simple sat ( ssat ) . in  @xcite ,",
    "the chapter 6 depicts reducibility .",
    "this term means the ability to solve a problem by finding and solving simple subproblems .",
    "this idea is used here between sat and ssat .",
    "i focused to the cnf version of sat , which it is justified for the logical equivalence and the abroad literature .",
    "talking about sat is immediately related to np class of problem and its algothms  @xcite .",
    "the dominant characteristic of ssat is that all its formulas have the same number of logical variables .",
    "briefly , the main results in  arxiv : barron2016 are the lower upper bound @xmath0 of the ssat s algorithms for an extreme case with one or none solution , and such algorithms realize one lecture of the ssat s or one exploration of the research space @xmath2 $ ] and they are numerical without algebra . therefore the complexity for ssat@xmath3 ( where @xmath1 is the number of boolean variables and @xmath4 the number of rows ) is that the existence of the solution is @xmath5 when @xmath6 and it is bounded by @xmath7 for @xmath8 or @xmath9 on the other hand , in  arxiv : barron2015b it is depicted that for ssat does not exist an efficient algorithm for solving it .",
    "this shortly , because the extreme problem ssat@xmath3 with one or none solution and repeated rows , @xmath10 requieres one exploration of the rows .",
    "the extreme problem ssat@xmath3 can be builded selecting randomly one number or none in @xmath11 $ ] .",
    "then the only way to infers the solution is verifying that the ssat@xmath3 s rows corresponds to @xmath12 of @xmath13 different formulas .",
    "on the other hand , the extreme problem ssat@xmath3 corresponds to a very easy sat@xmath14 .",
    "this article analyzes how to solve sat using properties of ssat and without using algebra ( @xcite , and  @xcite ) .",
    "the importance of the sat s complexity is that sat is a complete np problem , and if it has an efficient algorithm then any np problem can be solved efficiently . on the other hand ,",
    "it has not an efficient algorithm , then @xmath15 @xmath16 @xmath17 @xmath16 @xmath18 in  @xcite , it is depicted that @xmath19 @xmath16 @xmath15 because ssat could be see as a subproblem of sat",
    ". here , a carefully resume of the preeminent properties of the ssat and sat are depicted and used to build an special algorithm for solving any sat .",
    "some propositions of my previous works over the np class , sat , and ssat in  @xcite ,  @xcite ,  @xcite , and  @xcite are repeated for making this article self - content .",
    "it is worth to mention that the binary numerical approach depicted here is for solving any sat with one lecture of the sat s rows with the upper bound @xmath0 steps .",
    "section  [ sc : nota_conve ] contains basic definition , concepts and conventions used .",
    "the section  [ sc : propforsolsat ] depicts the propositions that they characterize necessary and sufficient conditions for building an algorithm for sat .",
    "the next section  [ sc : algthmssat ] depicts the algorithms of the parallel algorithm for solving sat .",
    "it is proved that lower upper bound of the iterations for solving sat is @xmath20 , where @xmath1 is the number of logical variables .",
    "section  [ sc : compleforssat ] discusses and justifies why the strategies of using ssat s properties is less complex for solving sat than algebra procedures .",
    "particularly , two operations , expansion and simplification are depicted to connect ssat and sat .",
    "the last section depicts my conclusions and future work .",
    "[ sc : nota_conve ] a boolean variable only takes the values : @xmath21 ( false ) or @xmath22 ( true ) .",
    "the logical operators are * not * : @xmath23 * and * : @xmath24 and * or * : @xmath25    hereafter , @xmath26 is the corresponding binary alphabet . a binary string , @xmath27 @xmath28 @xmath29 is mapped to its corresponding binary number in @xmath30 $ ] and reciprocally .",
    "moreover , @xmath31 corresponds to the binary string @xmath32 where @xmath33    such translation has no cost , if @xmath27 and @xmath34 are represented in the ascii code by a ( 097 ) and  ( 226 ) .",
    "the table for the translation is @xmath35    [ cols= \" < , < \" , ]     the clause @xmath36 is written as a@xmath37 @xmath38 @xmath39 a@xmath40 a@xmath41 .",
    "the translation is @xmath42c[c_{n-2}]\\ldots c[c_{1}]c[c_{0}]$ ] where @xmath43 is the logical variable a@xmath44 or @xmath44 in the position @xmath45 .",
    "hereafter , the sat s formulas are translated to its corresponding binary string .    a sat@xmath3 problem consists to answer if a system of @xmath4 clauses or row boolean formulas in conjunctive normal form over @xmath1 boolean variables has an assignation of logical values such the system of formulas are true .",
    "the system of formulas is represented as a matrix , where each clause or row formula corresponds to a disjunctive clause . by example , let sat@xmath46 be    @xmath47    this problem is satisfactory .",
    "the assignation @xmath48 and @xmath49 is a solution , as it is depicting by substituting the boolean values : @xmath50    a simple of sat [ ssat@xmath3 ] is a sat@xmath52 with the requirement that its rows have the same number of boolean variables in a given order .",
    "the variables order for sat or ssat do not imply to rewrite the problem , it has a constant cost that can be assumed at the lecture of each formula .    hereafter , the boolean variables of sat are identified by @xmath27 with subindexes from @xmath53 $ ] , i.e. , @xmath54 . for the set @xmath55 @xmath56 as in  @xcite , prop .",
    "an enumeration for address identification of any subset of logical variables is as follows : @xmath57    the function @xmath58 $ ] gives an unique identification as a natural number for any subset of boolean variables of @xmath59 .",
    "it could be possible to define an address polynomial for @xmath60 , but for the moment the next algorithm can help for building the previos correspondence .",
    "[ alg : idxset ] * input : * @xmath61 : set of logical variables .",
    "* output : * @xmath62 : integer ; // the unique index in @xmath30 $ ] for the set @xmath27 .",
    "* variables in memory * : @xmath63 : integer ; @xmath64 : variable set treated as a number of base @xmath65    @xmath66    @xmath67 // where @xmath68 is the cardinality function .    * if * @xmath69 * equals * @xmath21 * then *    * output * : `` @xmath62 . '' ;    * stop * ;    * end if *    @xmath70 ;    * for * @xmath71 * do *    @xmath72 //",
    "@xmath73 binomial coefficient    * end do *    * build * @xmath74 ; // the lower set of variables in order of size @xmath69    * while * @xmath75 * do*.    @xmath76    * repeat *    @xmath77    * if * variables in @xmath78 different and in descending order * then *    * exit *    * end if *    * until * false ;    @xmath79 ;    @xmath80;.    * end while *    * output * : `` @xmath81 . '' ;    * stop * ;    giving any sat@xmath3 and @xmath82 any clause of it , then @xmath82 can be associated to an unique and appropriate ssat@xmath83 using the algorithm  alg : idxset , where @xmath82 represents the set of boolean variables in the clause @xmath82 with the convention that they subindex are in descending order .",
    "the cross - join operator ( @xmath84 ) corresponds with two operations : a cross product and the natural join or ( @xmath85 ) join .",
    "the @xmath86 join is like the relational data base natural join operation .",
    "it is used between two set of variables @xmath82 and @xmath87 and the solutions of ssat@xmath88 as follow :    ssat@xmath83 @xmath89 ssat@xmath90    1 .   *",
    "if * @xmath91 * then * ssat@xmath92 ssat@xmath93 .",
    "2 .   * if * @xmath94 and there are common values between + ssat@xmath95 and ssat@xmath93 for the variables in @xmath96 * then * + @xmath97 3 .",
    "* if * @xmath98 and there are not a common values between + ssat@xmath95 and ssat@xmath93 for the variables in @xmath96 * then * @xmath99    in the case 1 and 2 , ssat@xmath100 and ssat@xmath101 are compatibles . in the case",
    "3 ) they are incompatibles , i.e. , there is not a satisfactory assignation for both .",
    "an example of the case 1 ) is the following @xmath102sat@xmath103 @xmath104    a ssat@xmath105 is the three first clauses of @xmath106 , its solution is @xmath107 .$ ]    a ssat@xmath108 is the last two clauses of @xmath106 , its solutions are @xmath109 .$ ]    then the solutions of sat@xmath110 are @xmath111 @xmath112    @xmath113 .$ ]    an example of the case 2 ) is the following @xmath114sat@xmath103    @xmath115    a ssat@xmath105 is the three first clauses of @xmath116 , its solution is @xmath117.$ ]    a ssat@xmath118 is the last two clauses of @xmath116 , its solutions are @xmath119 .$ ]    then sat@xmath120 has solution , because @xmath21 is the common value for @xmath121 .",
    "the solutions are @xmath122 .$ ]    an example of the case 3 ) is the following @xmath123sat@xmath124 @xmath125    a ssat@xmath105 is the three first clauses of @xmath126 , its solution is @xmath117 .$ ]    a ssat@xmath127 is the last four clauses of @xmath126 , its solutions are @xmath128.$ ]    then sat@xmath120 has not solution because there is not a common value for the variable @xmath121 .",
    "[ sc : propforsolsat ] the translation of the ssat@xmath3 s formulas can be arranged as a matrix @xmath129 @xmath112 @xmath130 $ ] where each binary number @xmath131 corresponds to a each ssat@xmath3 s clause .",
    "ssat can be see as a logic circuit , it only depends of the selection of the binary values assigned to @xmath1 lines , each line inputs the corresponding binary value to its boolean variable @xmath132 .",
    "this is an important consideration because the complexity of the evaluation as a circuit of a logic function is @xmath133 with @xmath69 a fixed time .",
    "@xmath69 corresponds to the time that the electrons activate the circuit in parallel lines for each variable .",
    "therefore , such evaluation can be considered as @xmath5 . the figure  [ fig : boxsatnxm ] depicts sat@xmath3 s logic circuit .",
    "the inner approach means to take the candidates from the translation of the problem s formulas .",
    "the outside approach means to the candidates from the problem s search space .",
    "a deterministic approach means to take the candidates for solving a problem with the data in its given order .",
    "a probabilistic approach means to take the candidates for solving a problem with no repetition and in random order , i.e. , it likes a random permutation of the numbers @xmath134.$ ]    [ prop : binnumblock ] any disjunctive clause over the variables @xmath135 @xmath136 @xmath137 corresponds a binary number @xmath138 @xmath112 @xmath139 @xmath39 @xmath140 .    1 .",
    "@xmath141 where @xmath34 is the complement of @xmath27 .",
    "2 .   @xmath142 where @xmath138 and @xmath143 correspond to the translation of @xmath27 and @xmath144 3 .",
    "@xmath145 and @xmath146 where the values of the boolean variables correspond to the bits of @xmath143 and @xmath147    without loss of generality , @xmath27 @xmath112 @xmath148 the translation of @xmath138 and @xmath34 @xmath112 @xmath149 the translation of @xmath143 . then @xmath150 @xmath112 @xmath151 @xmath152 @xmath153 @xmath152 @xmath21",
    "the translation of the ssat s rows allows to define a table of binary numbers .",
    "the following boards have not a satisfactory assignation in @xmath154 and @xmath155 :    @xmath156    i called unsatisfactory or blocked boards to the previous ones .",
    "it is clear that they have not a solution because each binary number has its binary complement . to find an unsatisfactory board is like to order the number and its complement , by example : @xmath157 @xmath158 @xmath159 @xmath160 @xmath161 @xmath162 @xmath163 and @xmath164 correspond to the unsatisfactory board : @xmath165    by inspection , it is possible to verify that the previous binary numbers correspond to ssat@xmath166 of the translated binary numbers with no solution because any binary number is blocked by its complement binary number ( see prop .",
    "[ prop : binnumblock ] ) . by example",
    ", @xmath167 and @xmath168 correspond to @xmath169 .",
    "substituting by example @xmath170 , we get @xmath171 @xmath172 @xmath173 @xmath172 @xmath174    [ prop : solsat_binary ] let be ssat@xmath3 with @xmath4 rows and @xmath6 .",
    "there is a satisfactory assignation that correspond to a binary string in @xmath29 as a number from @xmath21 to @xmath12 .",
    "let @xmath175 be any binary string that corresponds to a binary number from @xmath21 to @xmath176 , where @xmath175 has not its complement into the translated formulas of the given ssat@xmath3 .",
    "then @xmath175 coincide with at least one binary digit of each binary number of the translated rows formulas , the corresponding logical variable is 1 .",
    "therefore , all rows are 1 , i.e. , @xmath175 makes ssat@xmath3 = 1 .    the previous proposition point out when a solution @xmath177 $ ] exists for ssat .",
    "more important , ssat can be see like the problem to look for a number @xmath175 which its complements does not corresponded to the translated numbers of the ssat s formulas .",
    "[ prop : nosolsat_binary ] let be ssat@xmath178 where its rows correspond to the @xmath21 to @xmath12 binary numbers .",
    "then it is an unsatisfactory board .",
    "the binary strings of the values from @xmath21 to @xmath176 are all possible assignation of values for the board .",
    "these strings correspond to all combinations of @xmath29 , and by the prop .",
    "[ prop : binnumblock ] ssat@xmath178 has not solution .",
    "this proposition  [ prop : nosolsat_binary ] states that if @xmath179 and ssat has different rows , then there is not a solution .    [",
    "prop : sufcondsato1 ] for any ssat@xmath3 the conditions a ) @xmath4 rows formulas with @xmath180 or b ) @xmath4 different formulas with @xmath179 are sufficient conditions for deciding the solution of any ssat@xmath3 without further operations . under any of these two conditions",
    "the complexity for determining the existence of the solution of ssat is @xmath181    the results follow from the prop .",
    "[ prop : solsat_binary ] and from the prop .",
    "[ prop : nosolsat_binary ] .",
    "[ prop : nosolsat ] given sat@xmath182 there is not solution , if @xmath183 exists , where @xmath183 is any subset of boolean variables , with their rows formulas isomorphic to an unsatisfactory board .",
    "the subset @xmath183 satisfies the proposition  [ prop : nosolsat_binary ] .",
    "therefore , it is not possible to find satisfactory set of @xmath1 values for sat@xmath3 .    here , the last proposition depicts a condition to determine the no existence of the solution for sat .",
    "this property is easy to implement in an algorithm using dynamic objects and when the set @xmath183 is associated with ssat@xmath184 . in order to determine that sat",
    "contains a subproblem ssat which it is an unsatisfactory board , it is the same to verify that ssat@xmath184 has not solution .    in similar way",
    ", the next proposition identifies when two ssat can determine the no solution of sat .",
    "[ prop : nosolsatby2ssat ] given sat@xmath182 there is not solution , if @xmath185 and @xmath186 exist , where @xmath185 and @xmath186 are any subset of logical variables , such @xmath187 @xmath188 @xmath189 , and the unique solution of ssat@xmath190 and the unique solution of ssat@xmath191 have no same values for the boolean variables in @xmath187 .",
    "the result follows because the unique solution of ssat@xmath190 blocks the solution of ssat@xmath191 and reciprocally .",
    "[ prop : sat_twoone ] given ssat@xmath3 as a circuit .    1 .",
    "let @xmath69 be the translation of any clause of ssat@xmath3 .",
    "let @xmath69 be any binary number , @xmath69 @xmath28 @xmath192 $ ] .",
    "if ssat@xmath193@xmath194 , then    1 .",
    "ssat@xmath195 and the formulas of @xmath69 and @xmath196 are in ssat@xmath182 2 .",
    "ssat@xmath193 @xmath194 and the translation of @xmath196 is a formula of ssat@xmath3 .    1 .",
    "when ssat@xmath197 is not satisfied , it is because the formula of @xmath196 is @xmath21 .",
    "ssat@xmath193 contains the formulas of @xmath69 and @xmath198 ( see prop .  [",
    "prop : binnumblock ] ) .",
    "2 .   ssat@xmath197 , then by prop .",
    "[ prop : binnumblock ] the translation of @xmath196 is a formula of ssat@xmath3 .    let be @xmath199 an alphabet . given ssat@xmath3 , the set @xmath200 @xmath112 @xmath201 ssat@xmath3@xmath202@xmath203 @xmath204 @xmath205 of the satisfactory assignations is a regular expression .",
    "@xmath206 .",
    "the last proposition depicts that a set of binary strings @xmath200 of the satisfactory assignations can be computed by testing ssat@xmath3@xmath202@xmath203 for all @xmath207 $ ] , and the cost to determine @xmath200 is @xmath20 , the number of different strings in @xmath29 .    with @xmath200 @xmath188 @xmath189 there is not opposition to accept that ssat@xmath3 has solution , no matters if @xmath4 is huge and the formulas are in disorder or repeated .",
    "it is enough and sufficient to evaluate ssat@xmath3@xmath208 , @xmath209 .    on the other hand , @xmath200",
    "@xmath112 @xmath189 , there is not a direct verification .",
    "this implies the condition @xmath210",
    "@xmath211 @xmath212 ssat@xmath213 it is necessary , for verifying @xmath200 @xmath112 @xmath189 to test all numbers in the search space .    [ prop : buildsolssat ]    ssat@xmath3  has different row formulas , and @xmath214 .",
    "any subset of @xmath29 could be a solution for an appropriate ssat@xmath3 .",
    "any string of @xmath29 corresponds to a number in @xmath30 $ ] and a ssat s formula .",
    "@xmath189 is the solution of a blocked board . , i.e. , for any ssat@xmath3  with @xmath179 .    for @xmath215 , it is possible to build a ssat@xmath3   with only @xmath27 as the solution .",
    "the blocked numbers @xmath30 $ ] @xmath216 @xmath217 and @xmath27 are translated to ssat s formulas . by construction , ssat@xmath3@xmath218    for @xmath219 different solutions .",
    "let @xmath220 be the given expected solutions .",
    "build the set @xmath35 from the given solutions without any blocked pairs .",
    "then the blocked numbers @xmath221 $ ] @xmath216 @xmath222 and the numbers of @xmath35 are translated to ssat s rows .",
    "[ prop : evalmatchfixedpoint ] let be @xmath223 , @xmath224 the following strategies of resolution of sat@xmath3 are equivalent .    1 .   the evaluation of sat@xmath225 as logic circuit .",
    "[ stp : match ] a matching procedure that consists verifying that each @xmath226 match at least one digit @xmath227 @xmath228 .",
    "sat@xmath229 , it means that at least one variable of each clause is 1 , i.e. , each @xmath230 @xmath231 for at least one bit , this matches to 1 in @xmath232 , @xmath233 .",
    "the evaluation strategies are equivalent but the computational cost is not .",
    "the strategy  [ stp : match ] implies at least @xmath234 iterations . this is a case for using each step of a cycle to analyze each variable in a clause or to count how many times a boolean variable is used .",
    "an equivalent formulation of ssat@xmath3  is to look for a binary number @xmath235 from @xmath21 to @xmath236    1 .   if @xmath237 and @xmath238 then sat@xmath239 2",
    "if @xmath240 and ssat@xmath3 has different rows then @xmath241 $ ] and ssat@xmath242    1 .",
    "when @xmath243 , this means that the corresponding formula of @xmath235 is not blocked and for each sat@xmath3 s clause at least one boolean variable coincides with one variable of @xmath244 therefore sat@xmath239 2 .",
    "@xmath240 , then @xmath245 $ ] with @xmath246 there are two cases .",
    "1 ) @xmath247 , therefore , ssat@xmath248 .",
    "2 ) @xmath249 , therefore ssat@xmath250    this previous proposition , depicts the equivalence between ssat with the numerical problem to determine if there is a binary string , which is not blocked by the binary translations of the ssat s formulas . only @xmath69 and its",
    "complement @xmath196 are opposed ( see prop .",
    "[ prop : binnumblock ] .",
    "this point out the lack of other type of relations between the rows of ssat .",
    "more important , this proposition allows for verifying and getting a solution for any ssat@xmath3 without to evaluate ssat@xmath3 as a function . by example",
    ", sat@xmath251 corresponds to the set @xmath252 :    @xmath253    @xmath254    how @xmath255 and @xmath256 then ssat@xmath257 on the other hand , @xmath258 with @xmath259 then ssat@xmath260    the next propositions , depicts the difficult for determining solving extreme ssat .",
    "[ prop : probsel ] let @xmath1 be large , and ssat@xmath3 an extreme problem , i.e. , @xmath261 @xmath262 , and @xmath263 .    1 .",
    "the probability for selecting a solution ( @xmath264@xmath265 ) after testing @xmath219 different candidates ( @xmath266 ) is @xmath267 ( it is insignificant ) .",
    "2 .   given @xmath35 @xmath268",
    "@xmath2 $ ] with a polynomial cardinality , i.e. , @xmath269 @xmath112 @xmath270 , with a constant @xmath271 the probability that the solution belongs @xmath35 ( @xmath264@xmath272 ) is insignificant , and more and more insignificant when @xmath1 grows .",
    "3 .   solving ssat@xmath3 is not efficient .    assuming that @xmath273 .    1 .",
    "the probability @xmath264@xmath265 corresponds to product of the probabilities for be selected and be the solution . for the inner approach ( i.e.",
    ", the @xmath219 candidates are from the translations of the ssat@xmath3 s rows ) @xmath264@xmath265 @xmath112 @xmath274 for the outside approach ( i.e. , the @xmath219 candidates are from the @xmath30 $ ] the search space ) @xmath264@xmath265",
    "@xmath112 @xmath275 2 .",
    "@xmath264@xmath276 @xmath112 @xmath277 then @xmath264@xmath278 @xmath112 @xmath279 @xmath280 @xmath281 , and @xmath282 ( lhpital s rule ) @xmath112 @xmath283 @xmath284 for @xmath1 large , @xmath285 and @xmath286 moreover , for the inner approach , @xmath264@xmath287 @xmath112 @xmath288 for the outside approach , @xmath264@xmath287 @xmath112 @xmath289 3 .   in any approach , inner or outside ,",
    "many rows of ssat@xmath3 have large probability to be blocked , because there is only one solution .",
    "then the probability after @xmath219 iterations remains @xmath290 .",
    "it is almost impossible to find the solution with @xmath219 small or a polinomial number of @xmath1 .",
    "assuming that @xmath291 .",
    "@xmath264@xmath292 @xmath112 @xmath174    1 .   for the inner approach and for the outside approach , @xmath264@xmath265",
    "@xmath112 @xmath174 2 .   it is equivalent @xmath210 @xmath211 ssat@xmath293 @xmath112 @xmath294 @xmath295.$ ] this means that it is necessary to test all the numbers in @xmath30.$ ]    one important similarity between the extreme ssat as a numerical problem ( see prop .  [",
    "prop : buildsolssat ] ) for one or none solution is the interpretation to guest such type of solution .",
    "it is like a lottery but with the possibility that there is not winner number .",
    "the exponential constant @xmath20 causes a rapidly decay as it depicted in fig .",
    "[ fig : probdecy ] where @xmath296 .",
    "[ sc : algthmssat ] the previous sections depict characteristics and properties of ssat .",
    "the complexity for solving any ssat@xmath3 has two cases :    1 .",
    "it is @xmath297 when @xmath298 2 .",
    "it is @xmath299 , when giving @xmath300 in this case , it is necessary at least one carefully review of the ssat s rows versus the search space @xmath301 $ ] .",
    "the algorithms using the external approach are based in a random permutation with only one lecture of the ssat s rows or they stop if a satisfiable assignation is found .",
    "there are two source of data for solving ssat@xmath3 , 1 ) its @xmath4 rows or 2 ) the search space of all possible logical values for its variables ( @xmath302 ) .",
    "the second is large and @xmath4 could be large also .",
    "therefore , the efficient type of algorithms for solving ssat must be doing in one way without cycles , and with the constraint that the total iterations must be related to @xmath6 , or @xmath0 , or @xmath13 .",
    "this is because the fixed point approach or inside search(taking candidates from the translation ssat s formulas ) and the outside approach or probabilistic approach ( taking candidates from the search space @xmath2.$ ]    the situation for solving ssat@xmath3 is subtle .",
    "its number of rows could be exponential , but for any ssat@xmath3 , there are no more than @xmath13 different rows , then @xmath303 means duplicate rows .",
    "it is possible to consider duplicate rows but this is not so important as to determine at least one solution in @xmath302 .",
    "the search space @xmath302 corresponds to a regular expression and it is easy to build by a finite deterministic automata ( kleene s theorem ) but in order .",
    "however , to test the binary numbers in order is not adequate .    based in the algorithm  3 in  @xcite , the update information for any ssat@xmath83 is the following algorithm .",
    "[ alg : updtssat]*input : * list of object : ssat@xmath304 , ssat@xmath83 , @xmath305 : clause of sat@xmath3 , where @xmath306 .    * output * : ssat@xmath83 , @xmath307 list of binary numbers such that , @xmath308 , ssat@xmath83@xmath309 .    * variables in memory",
    "* : @xmath310 $ ] : list as an array of integers , double link structure @xmath311 , @xmath312 : integer ; @xmath313:=@xmath21 : integer ; @xmath314 : integer ; @xmath315 : integer ;    * if * ssat@xmath83 * does not exist then *    create object ssat@xmath83    * end if *    with ssat@xmath83    @xmath69 @xmath112 * translate to binary formula * ( @xmath305 ) ;    * if * @xmath316$].previous * not equal * @xmath317 *  or * @xmath316$].next * not equal * @xmath317 * then *    // update the links of @xmath318    @xmath319$].previous@xmath320$].next @xmath321$].next ;    @xmath319$].next@xmath320$].previous @xmath321$].previous ;    * if * @xmath196 * equal * @xmath322 * then *    @xmath322 : = @xmath316$].next ;    * end if *    * if * @xmath196 * equal * @xmath323 * then *    @xmath323 : = @xmath316$].previous ;    * end if *    @xmath316$].next @xmath324 ;    @xmath316$].previous @xmath325    @xmath326    * end if *    * if * @xmath313 * equal * @xmath13 * then *    * output : * there is not solution for sat@xmath327 ;    * everything stop * ;    * end if *    * end with *    * return *    [ alg : sat_one ] * input : * @xmath1 , sat@xmath328 .",
    "* output : * it determines if there is a solution or not of sat@xmath328 .    * variables in memory * : @xmath82 : set of variables of @xmath59 ; ssat@xmath83 : list of objects ssat .    * while not * eof(sat@xmath328 ) ;    @xmath329 sat@xmath328 s clause ;    // update the information of ssat@xmath83    algorithm  [ alg : updtssat](ssat , r ) ;    * end while * ;    * with the variables and the solutions of all * ssat@xmath83 * determine the set * @xmath330 * of the corresponding * @xmath331 operation .    *",
    "if * @xmath330 * is empty * * then *    * output * : \" algorithm  [ alg : sat_one ] .",
    "there is not solution for the given sat .",
    "the solutions of all ssat@xmath83 are incompatibles . \"",
    "* the process stops * ;    * else *    * output * : \" algorithm  [ alg : sat_one ] .",
    "there is solution for the given sat .",
    "let be @xmath175 any assignation @xmath332 .",
    "it is a solution for sat@xmath333 , i.e. ,    all ssat@xmath83 are compatible . \"",
    "* the process stops * ;    * end if *    the next algorithm , is a version of the probabilistic algorithm 4 in  arxiv : barron2015b .",
    "it solves sat@xmath3 in straight forward using an outside approach , i.e , all the candidates are randomly and univocally selected from search space @xmath30.$ ]    [ alg : sat_two ] * input : * @xmath1 , sat@xmath328 .    *",
    "output : * @xmath334 $ ] , such that sat@xmath328@xmath335 or ssat has not solution ( it determines if there is a solution or not of sat@xmath328 ) .",
    "* variables in memory * : @xmath336$]=@xmath337 $ ] : integer ; @xmath338=@xmath12 : integer ; @xmath339 : integer .    * for * i:=0 to @xmath340    * if * @xmath341 $ ] * equals * @xmath45 * then *    // * select randomly * @xmath342 $ ] ;    @xmath343 @xmath112 floor(@xmath344 @xmath280 @xmath345 ) + @xmath346 ;    // rand ( ) return a random number in ( 0,1 ) ;    //",
    "floor(x ) return the lower integer of x    @xmath347 @xmath112 @xmath348 $ ] ;    @xmath348 $ ] @xmath112 @xmath341 $ ] ;    @xmath341 $ ] @xmath112 @xmath347 ;    * end if *    @xmath343 = @xmath349 $ ] ;    * if * sat@xmath350 * equals * @xmath22 * then *    * output * : \" algorithm  alg : sat_two .",
    "there is solution for the given sat .",
    "the assignation @xmath27 is a solution for sat@xmath351 . \"",
    "* the process stops * ;    * end if *    * if * sat@xmath352 * equals * @xmath22 * then *    * output * : \" algorithm  alg : sat_two .",
    "there is solution for the given sat .",
    "the assignation @xmath353 is a solution for sat@xmath328 . \"",
    "* the process stops * ;    * end if *    * end for *    @xmath354;$ ]    * if * sat@xmath355 * equals * @xmath22 * then *    * output * : \" algorithm  [ alg : sat_two ] .",
    "there is solution for the given sat .",
    "the assignation @xmath343 is a solution for sat@xmath328 . \"",
    "* the process stops * ;    * end if *    * if * sat@xmath356 * equals * @xmath22 * then *    * output * : \" algorithm  [ alg : sat_two ] .",
    "there is solution for the given sat .",
    "the assignation @xmath353 is a solution for sat@xmath328 . \"",
    "* the process stops * ;    * end if *    * output * : \" algorithm  [ alg : sat_two ] .",
    "there is not solution for the given sat .",
    "its rows cover all search space @xmath221 $ ] , and they are blocked . \"",
    "* the process stops * ;    the complexity of the previous algorithm is @xmath357 .",
    "no matters if the clauses of sat@xmath328 are huge or duplicates or disordered , i.e. , @xmath358 .",
    "[ alg : parallel]*input : * @xmath359sat@xmath360    * output * : the solution of sat@xmath360    * variables in memory * : list of object : ssat@xmath361 .",
    "* run in parallel *    algorithm  [ alg : sat_one]@xmath362 ;    algorithm  [ alg : sat_two]@xmath362 ;    * end run *    [ prop : ssatforsat ] let @xmath1 be large , and sat@xmath328 , @xmath303 . then sat",
    "is solved at most @xmath0 steps by running algorithm  alg : parallel , which it runs in parallel the algorithms  [ alg : sat_one ] and  [ alg : sat_two ] .    assuming enough time and memory .",
    "the two algorithms  [ alg : sat_one ] and  [ alg : sat_two ] run independently in parallel .    the algorithm  [ alg : sat_one ] runs the algorithm  [ alg : updtssat ] with the current @xmath82 of sat@xmath328 until @xmath363 or finishes at the end of the sat@xmath3 s rows .",
    "where @xmath364 number of boolean variables , and @xmath365 number of different rows .",
    "when @xmath363 , the process stops because there is a blocked ssat@xmath83 .",
    "after finish to read the rows , with the variables and the solutions of all ssat@xmath83 , it determines from @xmath85 join operation the set @xmath330 .",
    "if @xmath330 @xmath112 @xmath189 then the process stops , all ssat@xmath83 are incompatibles . otherwise , @xmath330",
    "@xmath366 @xmath189 and any @xmath367 is a solution for sat@xmath360    on the other hand , the algorithm  [ alg : sat_two ] takes two candidates at the same time @xmath368 $ ] and @xmath369 .",
    "if one of them satisfies sat@xmath328 then stop . otherwise , after all candidates are tested , sat@xmath3 has @xmath20 different rows then the process stops because sat@xmath3 s rows cover all search space @xmath221 $ ] , and they are blocked",
    ".    finally , algorithm  [ alg : sat_two ] limits the steps at most @xmath0 even if the number of clauses @xmath370",
    "[ sc : compleforssat ]    an extreme ssat is a problem with one solution or none but without duplicates rows . for one solution , the simple comparison @xmath371 allows to answer that the problem has a solution in one step . on the other hand ,",
    "the no solution case has complexity @xmath5 , knowing that ssat@xmath178 has different rows , there is nothing to look for . but",
    "again , to know that ssat@xmath178 has different rows , it has the cost of at least @xmath372 by verifying at least one time the ssat@xmath178 s rows correspond to all combinations of @xmath29 .    by example",
    ", the following ssat@xmath373 has one solution @xmath374 , @xmath375 , and @xmath376 : @xmath377 $ \\\\ & $ ( \\overline{x}_{2}\\vee \\overline{x}_{1}\\vee \\overline{x}_{0})$ &   & 000 & 0 \\\\ $ \\wedge $ & $ ( \\overline{x}_{2}\\vee \\overline{x}_{1}\\vee x_{0})$ &   & 001 & 1 \\\\ $ \\wedge $ & $ ( \\overline{x}_{2}\\vee x_{1}\\vee \\overline{x}_{0})$ &   & 010 & 2 \\\\ $ \\wedge $ & $ ( \\overline{x}_{2}\\vee x_{1}\\vee x_{0})$ &   & 011 & 3 \\\\ $ \\wedge $ & $ ( x_{2}\\vee \\overline{x}_{1}\\vee x_{0})$ &   & 101 & 5 \\\\ $ \\wedge $ & $ ( x_{2}\\vee x_{1}\\vee \\overline{x}_{0})$ &   & 110 & 6 \\\\ $ \\wedge $ & $ ( x_{2}\\vee x_{1}\\vee x_{0})$ &   & 111 & 7\\end{tabular } \\text { \\ } \\ ] ]    by construction , the unique solution is the binary string of @xmath378 .",
    "it corresponds to the translation @xmath379 .",
    "it satisfies ssat@xmath373 , as the assignation @xmath374 , @xmath375 , and @xmath376 .",
    "it is not blocked by @xmath164 , which corresponds to the missing formula @xmath380 ( the complement of the formula @xmath378 ) .",
    "the other numbers @xmath381 are blocked by @xmath382 .",
    "an extreme ssat has the next relation with a sat :    1 .",
    "the unique solution of ssat@xmath383 corresponds to a sat with @xmath1 rows , where each row corresponds to each variable of the solution . by example , for the previous ssat@xmath373 its corresponding sat@xmath384 is @xmath385 2 .",
    "the no solution case ssat@xmath52 corresponds to a blocked board , by example , sat@xmath386 could be @xmath387    the extreme ssat problem is designed to test how difficult is to determine one or none solution knowing only @xmath1 the number of variables , and @xmath4 the number of rows .",
    "it is extreme because @xmath388 could be huge .",
    "however , the corresponding versions of the extreme ssat have two easy sat problems .",
    "it is nor complicated but laborious to verify or build both ssat and sat .",
    "the next proposition allows to transform sat in ssat , and reciprocally .",
    "[ prop : ftfvyfnv ] let @xmath389 be a boolean formula and @xmath390 a boolean variable , which is not in @xmath389",
    ". then @xmath391    the result follows from factorization and distribution laws : @xmath392 .",
    "the previous proposition allows to define the operations expansion and simplification ( see fig .  [",
    "fig : sattssat ] ) :    1 .   expansion .",
    "add the two corresponding clauses for each boolean variable , which are not in @xmath389 , where @xmath389 is a factor or part of a boolean formula .",
    "2 .   simplification .",
    "two clauses simplifies into one clause by the factorization : @xmath393    [ prop : sattssat ] ssat and sat are equivalent , i.e. , any ssat can be transformed in sat , and reciprocally by using by prop .",
    "[ prop : ftfvyfnv ] .    giving a sat , the formulas are completed by expansion ( see fig .  [",
    "fig : sattssat ] ) from the previous proposition to build a ssat .",
    "reciprocally , given a ssat by using factorization it could be simplified to a sat or there is nothing to do . in any case , sat and its expansion ssat or ssat and its simplified sat has the same set of solution by prop .",
    "[ prop : ftfvyfnv ] .",
    "it is important to note , that for solving ssat the complexity is bounded quasi lineal as a function of the number of ssat s rows and it is bounded @xmath20 , because the size of the search space of all possible solutions @xmath29 or @xmath30 $ ] but in function of the @xmath1 the number of the logical variables of the problem .",
    "more important , it is trivial to solve ssat when @xmath371 and when @xmath179 and ssat@xmath178 s rows are different .    on the other hand , when @xmath394 it is by construction that at least one checking between ssat and its search space is necessary to determine its solution .",
    "this up an objection to disqualify the extreme problem because it is by construction exponential in the number of ssat s rows .",
    "moreover , what could be a source of such type of problem or it is a theoretical curiosity . in my opinion , it is not a curiosity but a future technological issue . in  @xcite , the algorithm 5 is an hybrid hardware - software over quantum computation and a sat as an appropriate electronic logical circuit .",
    "the creation of novel electronic circuits is near to the level of the crystalline structures .",
    "this means that figure  [ fig : boxsatnxm ] could correspond to a crystalline structure .",
    "here , for technical reasons existence and solutions are necessary to determine .    on the other hand , sat as the general problem could have rows with any length and in any order .",
    "it is trivial to build a random sat generator problems .",
    "the minimum parameter is @xmath1 the number of logical variables , and the output are @xmath4 the numbers of rows and the rows . solving an arbitrary sat by using algebra",
    "increase the complexity because it requires to compare and match rows and variables in some special order and with ad - hoc and appropriate structure for finding factor or parts where to apply the operations expansion or simplification ( see fig .",
    "[ fig : sattssat ] ) .",
    "this has as consequence more than one lecture or access of the sat s rows , i.e. , more than @xmath4 operations , for ordering and matching sat s rows and variables which it is not appropriate when @xmath4 is large , i.e. , @xmath8 or @xmath9    the algorithm  [ alg : parallel ] and particularly the algorithm  [ alg : sat_one ] do one lecture of the sat s rows for extracting information of its subproblem ssat .",
    "together with the @xmath85 operation at the step 9 , the algorithm  [ alg : sat_one ] determines if such ssat are compatibles or not .",
    "the iterations are less than @xmath4 because the detection of a blocked ssat is a sufficient condition to determine the no solution of the given sat . on the other branch",
    ", the algorithm  [ alg : sat_two ] divides the search space in two sections for testing two candidates at the same time in one iteration .",
    "it is possible to divide the search space in more sections but the candidates for testing in each step grows exponentially , 4,8 , @xmath395 , @xmath39 .",
    "the testing of the candidates can be in parallel and the complexity can be reduced to @xmath396 where @xmath395 are the candidates for testing . in our case , @xmath397 , therefore the search space is exploring in @xmath0 steps .",
    "this means that it is necessary to have @xmath395 processors for testing @xmath395 candidates to get a lower upper bound of @xmath396 iterations . taking in consideration",
    "that @xmath395 processor with @xmath398 is not posible , the lower upper bound is @xmath0 .",
    "the algorithm  [ alg : sat_one ] is capable to process under enough memory and time with complexity @xmath399 any @xmath400-sat .",
    "the @xmath401-sat formulation means formulas in cnf with clauses of @xmath82 variables where any variable is repeated at most @xmath175 times . in particular , any @xmath402-sat or @xmath403-sat or @xmath404-sat can be solved as the algorithm of the state of art  @xcite .",
    "considering that @xmath405 is solved by short - cut strategies . to detect @xmath402-sat",
    "is when @xmath406 , and the solutions(ssat@xmath83 ) @xmath188 @xmath189 .",
    "it is trivial and fast to create any @xmath407 @xmath408 solutions(ssat@xmath83 ) .",
    "it is similar for @xmath403-sat . finally ,    for any @xmath409-sat with exactly @xmath82 clauses .",
    "the complexity to determine @xmath410 sat is @xmath411 .    by constructing , @xmath412 ,",
    "it is a ssat@xmath413 , i.e. , its parameters @xmath404 are giving .",
    "the result follows by the proposition  [ prop : sufcondsato1 ] .",
    "[ sc : conclusions and future work ] the results here confirm that there is a upper limit for the sat s complexity ( it was predicted in the article  @xcite )",
    ". the outside approach and the evaluation of ssat as a circuit correspond to the probabilistic type of method allow to build the stable algorithm  [ alg : sat_two ] .",
    "this algorithm is a more detailed version of the probabilistic algorithm 4 of  arxiv : barron2015b .",
    "it states the upper bound @xmath0 steps for solving any sat .",
    "the consequences , when the result of the no existence of an efficient algorithm for the np problems is accepted , are huge and paramount",
    ". numerical intensive computers , supercomputers , high very large density of logical gates , quantum computation and the hybrid hardware - software will open a new era in the computer science .",
    "l.  zhang , c.  f. madigan , m.  h. moskewicz , and s.  malik .",
    "efficient conflict driven learning in a boolean satisfiability solver . in _ proceedings of the 2001 ieee / acm international conference on computer - aided design _ , iccad 01 , pages 279285 , piscataway , nj , usa , 2001 .",
    "ieee press ."
  ],
  "abstract_text": [
    "<S> this paper depicts an algorithm for solving the decision boolean satisfiability problem using the binary numerical properties of a special decision satisfiability problem , parallel execution , object oriented , and short termination . </S>",
    "<S> the two operations : expansion and simplification are used to explains why using algebra grows the resolution steps . </S>",
    "<S> it is proved that its complexity has an upper bound of @xmath0 where @xmath1 is the number of logical variables of the given problem .    </S>",
    "<S> algorithms , complexity , sat , np , cnf . </S>",
    "<S> 68q10 , 68q12,68q19,68q25 . </S>"
  ]
}