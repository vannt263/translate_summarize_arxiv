{
  "article_text": [
    "professional software engineers recognize routine testing as an indispensable best practice @xcite@xcite@xcite@xcite , on par with the use of revision - control systems .",
    "testing provides a bulwark against regression , makes refactoring and optimization tractable , and helps assure reproducible results .",
    "the risk of undesirable outcomes  from large chunks of time sunk in debugging @xcite to portability issues @xcite to retracted papers @xcite  can be mitigated , and huge software - development investments protected , through a commitment to systematic software testing .",
    "but , while advocated for on behalf of the scientific - software community @xcite , and accepted in principle by the community itself , testing is often embraced late , or forgone entirely , for a variety of reasons . scientists who develop software rate",
    "their understanding of testing concepts lower than they do the importance of testing itself , and may harbor ( legitimate ) doubts related to the usefulness of testing in the face of numerical approximation errors , difficulties explicitly stating requirements , and the exploratory nature of scientific software @xcite .",
    "they may be unaware of the benefits of testing , or of existing techniques they might adopt @xcite .",
    "some may assume that adequate testing is done by the authors of software components they reuse , or believe that their code is too simple to require testing @xcite .",
    "this paper presents a system testing framework , ddts ( for _ dependency - driven test system _ ) , that seeks to ease the introduction of routine testing into scientific - software development efforts . in line with the goals of organizations like software carpentry @xcite and the software sustainability institute @xcite , ddts is concerned with helping development teams adopt testing sooner rather than later , via a relatively simple tool appropriate to their needs , or at least to the needs of a typical scientific - software project .",
    "since small teams may consider testing less important than larger ones @xcite , and since they likely have fewer resources at their disposal to begin with , a low barrier to entry may make the difference between the adoption of testing and its neglect  an important consideration given that small projects may grow into large ones .",
    "ddts exposes a small set of stub software routines which , when fleshed out to describe the build , run and other activities pertinent to the program - under - test , specify an interface between the framework and that program , and provide a somewhat opinionated recipe for testing .",
    "these routines may call ( in shells spawned by the framework ) existing build- and run - automation scripts developers already run by hand , and so include these utilities , whose continued correct operation is certainly worthy of routine testing , under the system testing umbrella .",
    "this paper s contributions are the description of a set of requirements , derived from and validated through experience , for a practical system testing framework that can be easily applied to a variety of scientific - software codes ; and a discussion of how these requirements are realized in ddts .",
    "as evidence of the framework s general applicability  and , it is hoped , its suitability for use by fledgling or even established software projects  we describe test - suite applications created for several atmosphere / climate model codes at both the u.s . national oceanic and atmospheric administration ( noaa ) and",
    "the u.s . national aeronautics and space administration ( nasa ) .",
    "we generally omit details on internal mechanisms , use of design patterns , etc . and",
    "instead describe those implementation details that benefit developers using ddts to implement a system test suite for their software project .",
    "ddts follows a _ system testing _ approach . unlike unit testing , which focuses on software s basic units ",
    "functions and subroutines  system testing is concerned with the behavior of the program - under - test as a whole .",
    "while unit testing is a powerful and desirable technique , it can in practice be difficult to apply to legacy science codes @xcite ( e.g. due to programming habits common in languages like fortran , like long subroutines that mutate global data ) , and in cases where it is difficult to establish `` passing '' criteria for floating - point implementations of some complex algorithms .",
    "the detailed knowledge of a routine required to write an effective unit test may only be available to domain experts , limiting collaboration with other developers ( e.g. software engineers ) in building up test suites .",
    "acknowledging that the perfect need not be the enemy of the good , system testing avoids some of these difficulties by testing software at a higher level of abstraction , and can be an appropriate starting place for many projects .",
    "those not already using unit testing can easily obtain some quality assurance by adopting system testing via a framework like ddts . projects already taking advantage of a unit testing framework like junit @xcite or pfunit @xcite can achieve even higher levels of assurance through the addition of system tests , which may also test external components like file , batch and database systems .",
    "the remainder of this paper discusses ddts design criteria and implementation ; current extensions to the original design ; experiences applying ddts to specific scientific codes ; and possible future work .",
    "this section discusses the several criteria that guided the design of ddts .",
    "a practical conceptual structure for the organization of test activities employs the ideas of _ builds _ , _ runs _ , _ groups _ of runs , and _ suites _ of groups .",
    "the build and run concepts map onto their obvious counterparts outside the framework : builds onto the executable programs and libraries created from source code , and runs onto individual executions , with specific configurations , of those programs .",
    "groups represent sets of comparisons between runs output , and exist to tie together runs expected to produce output that is `` equivalent '' , in a sense described later .",
    "suites represent collections of these comparison groups .",
    "figure [ figure:1 ] shows an example hierarchy of builds , runs , groups under a suite .",
    "two useful methods for judging the correctness of an execution of the program - under - test are _ run - vs - run _ and _ run - vs - baseline _ comparisons .",
    "the framework should support both .    throughout this paper , _",
    "run _ refers to a single execution of the program - under - test , and should not be confused with the execution of the testing framework itself , referred to in this paper as a _ test - suite invocation_. a single test - suite invocation may perform many runs , perhaps representing various configurations of the program - under - test .      in a run - vs - run comparison , one run s output is compared to that of another ( with a different but compatible configuration ) executed in the same test - suite invocation , with the expectation that the two will be equivalent .    here",
    ", `` equivalent '' simply means that some defined comparator function ( or _ oracle _ , e.g. `` bitwise identical '' ) judges both sets of output to represent the same results .",
    "`` compatible '' means that any configuration differences are not expected to change the behavior of the program in a way that would affect output equivalence .",
    "for example , two runs might use different numbers of mpi ( message passing interface ) tasks or openmp threads , or different parallel io mechanisms , and these differences would not be expected to lead to different output .",
    "run - vs - run comparisons are useful for detecting cases where programming errors lead to unwanted differences ( e.g. due to using data from uninitialized arrays ) , and are especially helpful for detecting parallelization errors ( e.g. using data from out - of - date halo regions ) .",
    "it is the standard generally adhered to when domain experts modify a scientific code : their work is _ expected _ to change ( and hopefully improve ) a program s output  but not to introduce inconsistencies between compatible runs .      in a run - vs - baseline comparison , a run s output",
    "is tested for equivalence , in the sense described above , to that of a corresponding run executed by an earlier test - suite invocation and stored as part of a `` baseline '' collection of output from one or more runs .",
    "this method ensures against unexpected changes in the tested program s output .",
    "it is the standard generally adhered to by software engineers working on a scientific code , and ensures that refactoring and optimizations do not change results .",
    "the run - vs - baseline method helps domain experts to avoid unintended changes output",
    ".    note that neither of these methods relate to output validation / verification ( correctness of the output s _ meaning _ ) , which must be established by other means .      to support regular , consistent use of test suites as part of the development cycle , the framework should provide a simple means to execute test suites , with unambiguous pass / fail result messages .",
    "a test suite may execute any number of individual runs , each perhaps requiring the compilation of executable programs , provisioning of input data , creation of run - time directories , etc .",
    ", as well as some number of comparisons to establish suite success or failure .",
    "end users ( people simply running a test suite ) benefit from the automation of these tedious tasks , and can be shielded from the details of their execution  at least until tests fail .",
    "the potentially voluminous information collected during execution of a test suite should be retained , as it may be useful for post - mortem analysis and debugging .",
    "a balance should be maintained between terse progress information shown to the user , and verbose information collected in a log file .",
    "many scientific - software development efforts are pursued on shared platforms ( computer systems ) where developers may not have permission to install new system software , establish network services , or communicate freely with remote systems .",
    "this is commonly the case on high - performance computing ( hpc ) platforms .",
    "the test framework should therefore be lightweight : it should rely on as few external components ( e.g. web servers , databases ) as possible , and should provide a command - line interface to support operation on restrictive platforms . a need to convince system - administration staff to install extra software components to support testing should be avoided .",
    "it may also be necessary to develop and test on multiple platforms . while the program - under - test might not change when moving to a new platform , resources like compilers , libraries and batch systems likely will .",
    "some of this diversity may be hidden by the program s existing build- and run - automation systems ( scripts , makefiles , etc . ) .",
    "the framework should make it simple to define test suites for each platform , reusing existing test - suite code and build / run automation utilities wherever possible .",
    "that is , once the interface between the framework , the program , and one platform is established , it should be straightforward to redefine pieces of this interface to support new platforms .",
    "as with the requirement for easy portability of a test suite to multiple platforms , the framework should similarly make it easy to extend the definitions of suites , runs and builds .",
    "the guiding software - engineering principle here is dry ( _ do nt repeat yourself _ ) @xcite : if a new build , run or suite definition is needed , and if an existing one is close to what is required , it should be possible to automatically produce the new definition by composing the old one with a set of desired modifications .",
    "this should be done automatically by the framework each time a test suite is invoked , replacing error - prone , duplicative copy - and - paste with dry dynamic derivation .",
    "the framework should therefore provide an inheritance mechanism to support extensibility , similar to the inheritance mechanisms of object - oriented programming languages .    to encourage domain experts to compose and modify tests",
    ", it should be simple to define builds , runs and suites without learning a new programming language or being exposed to framework internals .",
    "two benefits of a _ declarative _ approach recommend it for this task : first , its simplicity welcomes a wider audience of users than a traditional programming language might ; and second , unlike an _ imperative _ syntax that would imply an order of execution , opportunities for parallelism can be automatically extracted from declarative forms @xcite .",
    "a declarative syntax should therefore be used to define those high - level test - suite activities that can be executed concurrently .",
    "finally , developers defining or running test suites should not be forced to consider the order in which builds , runs and comparisons must be carried out , the actual mechanics of their execution , or how information might be shared between them .",
    "given the existence in the test - suite application of appropriately implemented interfaces between the framework , program and platform , the framework should deduce from the declarative definitions the dependencies between them , and so the order in which they must be executed , and should arrange for information sharing between them .",
    "this minimizes maintenance costs as test suites grow in size and complexity .",
    "the configuration space of a scientific code is often huge , and system tests typically can cover only a small fraction .",
    "even then , a test suite providing reasonable coverage may require dozens or even hundreds of builds and runs . to achieve practical turnaround times ( crucial when a test - suite pass is a prerequisite for a commit to a revision - control repository ) , the framework should exploit parallelism to overlap execution of independent components when the underlying platform supports efficient concurrent execution .",
    "this structure of this section mirrors that of the previous one to discuss how each of these design criteria is currently realized in ddts .      simple text files defining builds ,",
    "runs , groups and suites control the high - level testing activities performed by ddts , and are kept in subdirectories appropriately named _ builds _ , _ runs _ and _ suites_. the definitions contained in these files are referred to in other definition files by their pathless filenames .",
    "for example , a build definition contained in the file _ builds / gfortran _ would be referenced in a run definition file simply as _",
    "these references are used to build up suite definitions from run definitions , and to tie runs to builds .",
    "a typical ddts invocation of a certain named suite would start by determining its prerequisite _ group _ components , then the _ run _ prerequisites of each group , etc .",
    ", leading to the eventual execution of all activities in the required order .",
    "this system is described further in a later subsection .      in ddts ,",
    "a suite definition is composed of one or more named groups , each of which contains the names of one or more runs ( actual syntax is shown in a later subsection ) .",
    "the presence of multiple runs in the same group directs ddts to verify the equivalence of their output as a condition of test - suite success .",
    "this concise notation not only declares that the named runs must be ( successfully ) executed , but also implicitly requests performance of run - vs - run comparisons of their respective output files .",
    "no special command - line syntax is needed when invoking ddts to obtain this essential behavior .",
    "ddts _ use - baseline _ command - line option requests that run - vs - baseline comparisons also be performed when executing a test suite ( or even a single run ) .",
    "the option s argument is a path to a directory containing a set of baseline output generated by a previous test - suite invocation .",
    "any ddts run s definition may include an optional _ baseline _ key associating it with a specific named baseline , and the framework will compare the output of each run so defined with the matching set of baseline output in the specified directory .    similarly , the _ gen - baseline _ command - line option requests that a baseline be generated from the output of a suite ( or single run ) .",
    "its argument names a directory where the baseline should be stored .",
    "since more than one run in a test - suite invocation may associate with the same baseline , only one should contribute its output to the baseline .",
    "the mechanism governing this is described in a later subsection .    by default",
    ", ddts uses a bitwise - exact comparator to judge whether output files are equivalent , but custom comparators may be specified in suite and run definition files .",
    "this is discussed further in a later subsection .",
    "note that , because runs need not associate with _ any _ baseline , and because groups defined in suite definitions are allowed to contain only a single run , it is possible to define `` smoke test '' runs expected merely to run to completion , and whose output is not tested at all .",
    "these runs may , in fact , not exercise the primary program - under - test , but buttress the test suite s overall assurances by testing related code or even platform components .      in the most common use case",
    ", ddts can be invoked with a single command - line argument : the name of a defined test suite to execute ( e.g. _ ddts suite1 _ ) . as discussed above , a suite definition ( usually ) implies a set of run - vs - run comparisons , described as a comparison group , that test for equivalence of output within the group and for the ability to successfully build , configure and run the program - under - test to completion .",
    "execution of a single run ( e.g. _ ddts run run1 _ ) is also supported , and useful , for example , when iterating on a failed test , evaluating possible fixes , before executing the entire suite again .    ddts limits screen output , so as not to overwhelm the user with information . during execution",
    ", it prints basic progress messages when , for example , builds or runs start and finish , comparisons are performed , baselines are created , and in several other informational or warning cases .",
    "it reports errors as they occur and , if none are detected , prints a final definitive `` all tests passed '' message .",
    "significantly more verbose output is collected in a unique log file created for each ddts invocation .",
    "for example , the results of individual output file comparisons are logged , as is the entire output generated by external shell commands executed by the framework .",
    "all messages printed to the screen are also logged , so that the log file is a complete record of each ddts invocation s activities .    in case",
    "specific applications require more screen or log file output than is generated by default , ddts provides routines to write to both the screen and the log file , callable by the code written by test - suite application implementers to interface ddts to the platform and program - under - test .",
    "compute platforms and resource allocations come and go , and a scientific - software development effort may outlive both , making portability of a code  as well as its tests  valuable .",
    "portability also benefits teams wanting to run their code on multiple platforms at once , for example to take advantage of a variety of hardware and software configurations . in recognition of these needs ,",
    "ddts implementation supports simple portability .",
    "ddts is written in ruby @xcite and designed to run on the jruby @xcite implementation which , in turn , runs on the java virtual machine .",
    "ruby is a high - level , object - oriented , dynamically - typed , interpreted language with a concise syntax and a robust standard library  features that were all useful in the development of the framework .",
    "of course , many languages offer similar benefits , and java itself is famously portable . more important",
    ", then , is the advantage ruby confers on the developers of library routines ( see below ) , which may be written in a boilerplate - free scripting style likely to be comfortable for many would - be ddts application implementers who may have experience writing shell scripts , perl , python or , of course , ruby .",
    "the decision to target jruby was based on the observation that finding or provisioning a reasonably modern java ( jruby s only external requirement ) on any given platform  especially an hpc platform  is easier than finding an up - to - date native ruby installation .",
    "also , since jruby emulates several ruby versions , ddts can support only one and maintain portability via jruby s support for that version .",
    "ddts is command - line based , requires only java and a single jruby jar file , and writes only to the screen and to its log files , so that it requires no database , web server , or other external service .",
    "it is intended to interact with the program - under - test primarily by automating actions users would normally execute by hand .    before discussing portability via specialization of the platform interface",
    ", some background on a ddts application s `` library '' routines is necessary .",
    "the purpose of this detour is to illustrate what the task of applying ddts to a to - be - tested piece of software involves : which routines can be defined , what they do , how information from yaml definition files is made available to the library routines , etc .",
    "r c c c c c c order & routine & called from & purpose + 1 & lib_suite_prep & test - suite core thread & suite - wide setup + 2 & lib_build_prep & run thread & pre - build setup + 3 & lib_build & run thread & main build actions + 4 & lib_build_post & run thread & post - build teardown + 5 & lib_data & run thread & prepare data for all runs + 6 & lib_run_prep & run thread & pre - run setup + 7 & lib_run & run thread & main run actions + 8 & lib_run_post & run thread & post - run teardown + 9 & lib_run_check & run thread & check for run success + 10 & lib_outfiles & run thread & identify the run s output files + 11 & lib_comp & run thread & for run - vs - baseline comparison + 12 & lib_comp & comparison - group thread & for run - vs - run comparison + 13 & lib_suite_post & test - suite core thread & suite - wide teardown +    additionally , lib_queue_del_cmd is called asynchronously , by each run thread , if the test suite fails and a batch system is in use .    the interface between ddts , the program - under - test and the execution platform is defined by thirteen routines ( ruby methods ) . a source file containing correct but useless stub versions of these routines",
    "is packaged with ddts as _",
    "an application of ddts to the program - under - test and execution platform requires that some or all of these routines ( depending on the needs of the program and platform ) be overridden , in the file _",
    "library.rb_ , with versions whose bodies do actual work .",
    "six of the routines are responsible for performing prep ( e.g. setup ) , main ( e.g. test - case execution ) and post ( e.g. teardown ) work related to executing builds ( _ lib_build_prep _ , _ lib_build _ and _ lib_build_post _ ) and runs ( _ lib_run_prep _ , _ lib_run _ and _ lib_run_post _ ) .",
    "this division is arbitrary , and left intentionally undefined , but experience indicates that this breakdown is useful for organizing build and run activities , and that many fall naturally into these categories . ultimately , it is up to the library implementer to decide how activities should be grouped together .",
    "for some test - suite applications , the authors have found it useful to do meaningful work in each of the routines ; in others , some routines are simply pass - through stubs .",
    "two routines , _ lib_suite_prep _ and _ lib_suite_post _ , provide a place to execute general setup and teardown activities on behalf of the entire test suite , before any and after all builds or runs are performed .",
    "the remaining five routines are responsible for actions like returning the list of output files created by the program - under - test that are subject to comparison ; making input data needed by test - suite runs available prior to execution of those runs ; determining whether or not a single run completed successfully ( independent of the quality of its output ) ; removing a queued or running job from the batch system , if one is in use , when a test suite fails ; and providing an alternative to the default bitwise - exact comparator .",
    "table [ table : routines ] lists the ddts library routines , and the order in and context from which they are called .",
    "it is evident that most work is done by run threads . as discussed later , when several runs depend on a common build , the three _",
    "lib_build * _ routines will be executed by a single run thread , and the resulting executable(s ) shared by those runs .",
    "the _ lib_comp _",
    "routine is potentially called twice : once , when a run thread compares its output to its baseline , and again when a comparison group compares the output of two runs against one another .",
    "note that , excepting the two _",
    "_ routines , the order in which the library routines are called is determined by the recursive , bottom - up , dependency - driven nature of the test - suite definitions : for example , builds must be performed before runs , output is identified after runs complete , and comparisons are performed based on the identified output .",
    "ddts core driver calls library routines directly , so their argument lists and expected return values are defined and documented .",
    "some arguments are flexibly defined , with details left to the discretion of the library implementer .",
    "for example , _",
    "lib_run _ is allowed to return an arbitrary object that will later be passed to _",
    "lib_run_post_. the library implementer , knowing from the documentation that _",
    "lib_run_post _ will be responsible for determining whether or not the run completed successfully , should determine the specific type and value of the returned object . on the other hand , the structure and contents of the return value required from _",
    "lib_outfiles _ is precisely defined in the ddts documentation .",
    "the first argument to each of the library routines is an object called _ env _ , which contains a structure initially reflecting only the build , run and suite definitions pertaining to this particular ddts invocation , and appropriate to each of the test - suite execution phases .",
    "for example , in a library routine called from the context of a run , the _",
    "env.run _ substructure will contain keys and values from that run s definition file ( e.g. _ env.run.build _ will contain the name of the build used by this run , and _",
    "env.run.baseline_ , if defined , will contain the name of the baseline with which this run is associated ) .",
    "the syntax of the build , run and suite definitions are discussed later , but it is useful to note here that the _ env _ structure may be arbitrarily modified by library routines , according to the implementer s needs . in particular , it may be useful to pass information between library routines via the _ env _ structure , beyond what is required or allowed by the routines other arguments and return values .",
    "returning now to the topic of portability , a particular ddts application might require that , for example , the _ lib_run _ routine use a certain batch - submission command on one platform , and a different command on another .",
    "ddts supports this requirement via the build , run and suite definition files : if a library routine name appears as a key in a definition file , that key s associated value names a routine to be called in place of the original .",
    "for example , if a run s definition file contains the key - value pair _ lib_run _ : _ lib_run_sge _",
    ", then the ddts core driver will invoke _ lib_run_sge _ for this run where it would normally have invoked _",
    "_ lib_run_sge _",
    "routine must then be defined in _",
    "library.rb _ and would execute a job - submission command appropriate to the sun grid engine ( sge ) batch system .",
    "a run defined for a different platform might specify _",
    "lib_run _ : _",
    "lib_run_pbs _ to submit a job to the portable batch system ( pbs ) .",
    "this mechanism allows specialization of library routines for platform portability .",
    "ruby , as a dynamic language , makes this aliasing feature trivial to implement .",
    "a full ddts application involves three distinct types of programming tasks , suited to three programmer skill levels , a division that leads to a useful separation of concerns .",
    "first , and perhaps most complex , is the ddts core driver , which handles the overall test - suite workflow , including thread and mutex management , logging , command - line and definition - file processing and baseline generation and comparison .",
    "it is written and maintained by the ddts developers and is not intended to be modified for any particular test - suite application .",
    "second , and somewhat less complex , is the library implementation , where the program and platform interface routines are defined .",
    "the complexity of these routines depends on an application s needs , but tends to be low .",
    "they often resemble simple shell scripts that mimic actions users would manually perform on the command line when building software , configuring it , submitting batch jobs , etc .",
    "still , the library must be implemented by someone familiar with both the program - under - test and with ddts itself , and able to perform basic ruby programming .",
    "once implemented , however , the program and platform interface defined in the library usually requires little maintenance .",
    "third , by design least complex , and intended for modification by anyone who might need to create or execute test suites , are the declarative definition files that control high - level test - suite behavior .",
    "two advantages of a declarative approach are , first , that it simplifies programming ; and , second , that it is agnostic about execution order and so encourages parallelism . both advantages can be explained in terms of kowalski s _ algorithm = logic + control _",
    "concept @xcite : a program s declarative logic component describes the problem to be solved , while its imperative control component prescribes the actual mechanics of execution .",
    "different control components can be used to solve the same logically defined problem , and the logical declaration language can remain unaware of control details .",
    ".... $ ddts show suite zeus    group_zeus_intel :     zeus_intel_mpt_1    zeus_intel_mpt_10    zeus_intel_mpt_20    zeus_intel_serial group_zeus_lahey :     zeus_lahey_serial ....",
    "ddts logic component consists of a set of build , run and suite definition files , expressed in yaml @xcite .",
    "they provide , in a sense , simple domain - specific languages . a suite definition ( figure [ figure:2 ] ) , for example",
    ", poses the question `` is the output produced by each run in each of the defined comparison groups equivalent to the output of the other runs in the same group ? ''",
    "an affirmative answer implies a test - suite pass .",
    "the mechanics of how this question is answered  that is , how a run is performed , where its output is located , how output files are compared , etc . ",
    "are not specified at this level . nor is the order in which runs must be performed made explicit , which admits the possibility that they might execute in parallel .",
    "these details are made explicit in the ddts library defined for the application , in cooperation with the framework s core driver .",
    "the simplicity of yaml , examples of which can be seen in figures [ figure:2 ] and [ figure:3 ] , owes much to its light use of punctuation and reliance on indentation to express structure .",
    "this makes reading and writing definitions easy , and helps scientific - software developers to define their own suites by creating groups and assigning runs to them .",
    "they need to understand almost nothing about ddts or the library implementation to create complex suites comprising builds , runs , comparisons , etc .",
    "ddts supports very flexible run definitions . except for the required",
    "_ build _ and optional _ baseline _ keys , the contents of a run definition depend only on what information the library implementer decides is required by the run - related library routines , and is made available to these via the passed - in _ env _ object .",
    "but , generally speaking , a run definition poses the question `` if a run of the program - under - test , configured with these parameters , successfully runs to completion , what is its output and where can it be found ? ''",
    "this is the information required by the comparison group , one level up in the execution hierarchy , to determine its success or failure .",
    ".... $ ddts show run jet_pgi_cpu_nophys_10    # jet_pgi_cpu_nophys_10 < jet_std < nim_base    baseline : jet_pgi_nophys build : jet_pgi_cpu_p lib_build_prep : lib_build_prep_jet lib_run_prep : lib_run_prep_std namelist_file : nimnamelist namelists :    cntlnamelist :      glvl : 5      nz : 32      physics : none    computetasknamelist :      computetasks : 10    queuenamelist :      maxqueuetime : 00:20:00 ....    to honor the dry principle and support code reuse , ddts build , run and suite definition files support an _ extends _ key , whose value is the name of another definition , of the same type , to use as a base to build upon .",
    "this mechanism resembles single inheritance in object - oriented design .",
    "final definitions are composed recursively , starting with each definition s _ extends _ ancestor , then updating it dynamically with the keys / values from the current definition .",
    "cycles in _ extends _ ancestry chains are detected and treated as errors .",
    "ddts provides a _ show _ command ( e.g. _ ddts show run run1 _ ) that displays the fully - composed definition for a given build , run or suite , along with its ancestry .",
    "see figure [ figure:3 ] for an example .",
    ".... $ cat runs / run3 build : build2 key1 : value1    $ cat runs / run4 extends : run3 key2 : value2    $ ddts show run run4    # run4 < run3    build : build2 key1 : value1 key2 : value2 ....    .... $ cat suites / suite1 group1 :    - run1    - run2 group2 :    - run3    - run4 # newly - added run ....    using the _ extends _ mechanism , developers can , for example , define a new run by extending the definition of an existing run and simply overriding definition parameters of interest , or adding new parameters ( figure [ figure:4 ] ) . since ddts definition names correspond to filenames , once a new run definition file is created in the appropriate directory , it can be incorporated into a test suite by adding its pathless filename to the list of runs in an existing ( or new ) comparison group .",
    "when that suite is next executed , the new run will be performed and its output compared against any other runs in its group .",
    "figure [ figure:5 ] shows an example of a suite definition file with a newly - added run .",
    "( the _ extends _ mechanism is , of course , optional : developers can also choose to create complete definitions from scratch , or by copying other definitions in their entirety . )    finally , ddts build , run and suite definitions imply a set of dependencies that determine the execution order of test suite activities .",
    "each run associates with a build via its _ build _ key , making the build the run s prerequisite .",
    "several runs may depend on the same build , so that all must acquire that build before proceeding to execution .",
    "similarly , at the suite level , each comparison group depends on the output created by its member runs , and the suite as a whole depends on the success / failure status of each of its comparison groups .",
    "so , runs consume the product ( executable programs ) of builds , comparison groups consume the product ( output files ) of runs , and suites consume the products ( results of equivalence tests ) of comparison groups .",
    "end users need not concern themselves with how or when each of these requirements , established by ddts logic component ( definition files ) , will be satisfied : those details are left to the control component  the library routines and core driver .",
    "a separation of concerns similar to ddts three - complexity - level breakdown is described in @xcite , where _ software developers _ create general but more complex test components , which can then be combined and applied by _",
    "software testers _ to create specific test - case instances , corresponding to ddts runs .",
    "the relationships described by ddts build , run and suite definition files can be viewed as a directed graph whose nodes are build , run , comparison and suite - summary activities , and whose edges reflect dependencies . in figure",
    "[ figure:1 ] , for example , _ suite1 _ depends on comparison groups _",
    "group1 _ and _ group2 _ ; _ group1 _ depends on runs _",
    "run1 _ and _ run2 _ ; and _ run1 _ and _ run2 _ share a dependence on _ build1_. the two builds can execute concurrently , as can all four runs , once their build dependencies are satisfied .",
    "ddts executes each node when all its prerequisite neighbors have finished executing .",
    "independent activities are overlapped , via thread - based parallelism , to optimize test - suite turnaround time . using a delegation - of - responsibility approach , each run ,",
    "comparison group and the main test suite itself correspond to a single thread each .",
    "the main test - suite thread creates threads for each comparison group , joins each when it completes , and deems the entire test suite a success if each comparison group reports success within its group .",
    "each comparison group thread , in turn , creates threads for each member run , joins them , locates each run s output , and performs comparisons between pairs of output files , reporting success or failure to the main test - suite thread based on these comparisons .",
    "the final test - suite result is therefore built bottom - up : runs upon builds , comparisons upon runs , and the suite itself upon comparisons .",
    "while several runs may depend on the same build , the build needs to be performed only once , and the executables shared .",
    "ddts run threads execute builds in a mutex - protected critical region , whose first action is to check whether the build has already been performed and to skip the remainder of the region if it has . the first run thread to obtain the lock and enter the region finds that the build has _",
    "not _ yet been performed and so performs it , as if on behalf of all runs depending on that build .",
    "all other runs subsequently entering the critical region simply skip ahead and make use of the now - existing build .",
    "similar mutex - competition mechanisms decide which run , of a set sharing a common _ baseline _ key , will contribute their output when generating a new baseline ; which run will provision input data for all runs ; and which comparison group will execute a run defined in more than one group ( cases where this is a useful configuration exist ) .",
    "this use of threads and locks allows the dependency graph to be executed , greedily , as quickly as possible , with simple logic in the ddts core driver .",
    "collaboration between noaa and nasa has been beneficial to the development of ddts , whose original design reflected the needs of modeling groups at noaa .",
    "nasa s needs differed and indicated a need for a number of new features .",
    "for example :    * a suite - level _ build_only _ key was added to specify that only builds ( no runs or comparisons ) should be performed , the suite being deemed a success if all builds complete successfully .",
    "* a suite - level _ continue _ key was added to specify that the test suite should not terminate on errors , but simply report them , and continue running to collect as much information as possible . at noaa , where ddts applications are used as pre - commit tests , failing early minimizes resource use and lets developers correct errors as soon as they are detected .",
    "( experience has shown that multiple runs in a suite will usually fail , eventually , due to a common underlying bug , and that addressing that bug immediately is an efficient use of time . ) at nasa , where ddts applications are run as unattended regression tests , detecting all errors ( not just the first ) is valuable .",
    "* by default , ddts deletes builds created by previous test - suite invocations to prevent false positives due to reuse of existing executables or libraries .",
    "a suite - level _ retain_builds _ key was added to suppress this behavior , speeding up total test - suite execution time when the source code for the program - under - test has not changed . *",
    "a run - level _ require _ key was added to specify that a run may not begin executing before the run named by this key s value completes .",
    "this allows , for example , execution of a short run before a longer one is attempted .",
    "* the _ lib_suite_post _ library routine was added to support post - suite activities like sending emails to staff with regression - test results .",
    "( the _ lib_suite_prep _ routine was added for symmetry . )",
    "also , the _ env _ structure made available to _ lib_suite_post _ was augmented with access to build and run objects from the entire test suite , for analysis and reporting purposes .",
    "* while the ddts - tested noaa models were developed with bitwise - identical output between certain configurations ( e.g. different mpi task counts ) , and from run to run with identical configurations , as a requirement , the default bitwise - identity comparator is not universally appropriate .",
    "for instance , tests of netcdf files created by many models may fail simply due to embedded timestamps that vary from run to run .",
    "so the ability to specify a custom comparator by defining a _ lib_comp _ library routine was added to support testing a wider range of output file types . *",
    "originally , ddts decided whether a run completed successfully by searching for a sentinel string , provided in the run definition , in the output messages emitted by the program - under - test . for greater flexibility , this mechanism was replaced with the _ lib_run_check _ library routine , whose boolean return value indicates success or failure , and whose implementation is up to the library implementer : for example , one may need to consider the contents of multiple files to judge a run s completion status . *",
    "ddts initially expected to find _",
    "library.rb_ , the directories containing build / run / suite definition files and related artifacts in the same directory as the ddts core driver code . to support multiple applications with a single copy of ddts , and different it deployment schemes , ddts was extended to allow overriding default paths via environment variables specifying the directories containing the core driver , the directory containing the application , and the directory where framework output ( log and temporary files ) should be created .",
    "ruby has proven an excellent choice for ddts development , as it has been easy to add new features , especially those relying on dynamic invocation of routines based on run - time information as , for example , when overriding generic library routines with specialized implementations ( e.g. overriding _ lib_run _ with _",
    "lib_run_sge _ for a suite running on a platform using the sge batch system ) .",
    "jruby has provided the hoped - for portability and ruby - version stability .    early in the noaa / nasa collaboration , one of the authors had the opportunity to implement a simple prototype test - suite application for a small nasa model .",
    "although ddts was well understood , the model itself was completely unfamiliar .",
    "it was nevertheless possible to code the program and platform interfaces , via the required routines in _ library.rb_ , and to define a suite comprising several runs and a single build , in only a few hours .",
    "while many applications will be more complex , this exercise illustrated the ease with which an initial ddts test - suite application , suitable for extension , can be created .",
    "the following two subsections describe actively - used applications of ddts to models at both noaa and nasa .",
    "pre - commit tests were in regular use by developers of noaa s flow - following finite - volume icosahedral model ( fim ) @xcite in 2011 , when ddts was initially developed , but the limitations of the imperative approach used for those tests had become clear : each new test added to the suite meant writing new ( or , worse , duplicated ) code in the test scripts . creating suites exercising different groups of runs",
    "led to increasingly complicated sets of logical conditionals to enable or disable certain runs . and determining which builds needed to be performed to meet runs requirements , or deciding which tasks could run concurrently , was a manual and error - prone process .    the first version of ddts was written for use with the non - hydrostatic icosahedral model ( nim ) @xcite in 2011 . in 2012 , ddts was applied to fim as well . since these two numerical weather - prediction models share a number of developers and general design characteristics , ddts was well suited to both . in 2013 ,",
    "ddts was applied to the ionosphere plasmasphere electrodynamics ( ipe ) model @xcite , a space - weather prediction model also developed at noaa .",
    "although ipe s build , configuration and run mechanisms had much less in common with those of nim and fim , it proved straightforward to slot its command - line build / run utilities and manual actions into the ddts framework .",
    "the ddts applications defined for these models handle a great deal of test complexity .",
    "the nim application , for example , tests the model on three hpc platforms , using serial , mpi distributed - memory parallel and openmp shared - memory parallel builds ; two physics packages ; single- and double - precision builds ; cpu and gpu architectures ; and an optional parallel io package , among many other configurations .",
    "the nearly 40 developers of the three noaa models use ddts - based testing as a pre - commit check : that is , they only commit code changes to the revision - control repository when they are able to pass their respective test suites , using run - vs - run comparisons , run - vs - baseline , or both , as appropriate . since these models test suites are designed to be run by developers , ddts , the associated library implementations , and each application s build / run / suite definition files are kept in the repository alongside the model code itself , so that developers always check out everything together .",
    "this arrangement maintains a rigorous relationship between the current model code and the test suites appropriate to it .",
    "while no formal study has been performed on the effects of pre - commit testing on these development efforts , it can be confidently , albeit anecdotally , reported that test suites fail often , and that the underlying errors so detected would be dangerous , confusing , difficult to debug , and a massive waste of time were they to be committed to revision control and foisted on other developers .",
    "bugs are easiest to fix when the changes causing them are fresh in the mind  especially in the mind of the developer who introduced them .      several nasa science codes , which were already undergoing systematic regression testing using various ad hoc solutions , standardized on ddts for system testing .",
    "this decision led to greater flexibility in test design and lower maintenance effort due to common infrastructure .",
    "ddts simple workflow was found to be sufficient to support regression - testing efforts at nasa goddard space flight center and , extended as described in the previous section , is flexible enough to handle idiosyncrasies of the several tested models .",
    "for example , enabling the suite - level _ continue _ feature allows ddts to to attempt execution of all runs in a suite , even if one or more fails .",
    "this behavior differs from the `` fail fast '' mode used for pre - commit testing by noaa developers .",
    "while noaa s ddts applications are packaged with the model code they test , this relationship is reversed at nasa : ddts is maintained separately , with custom applications for each tested model .",
    "each application s _ lib_build_prep _ routine polls the revision - control repository for changes to model code , and time - consuming updates and builds are performed only if the model has changed ( a behavior made possible by the suite - level _ retain_builds _ setting ) . in addition , a set of routines used across multiple applications , callable from the standard library routines , is maintained separate from _",
    "library.rb_.    the nasa - unified weather research and forecasting ( nu - wrf ) @xcite model consists of several executable pre - processors that must run in a specific sequence to attain the desired output .",
    "the nu - wrf workflow has been defined as a ddts run , parameterized via run - definition files .",
    "the configuration information exposed in yaml , controlling ruby code in library routines , is sufficient to generate a large variety of tests without further programming , allowing greatly increased coverage of tested preprocessors .",
    "the land data toolkit ( ldt ) , which can generate input data for nu - wrf simulations , is currently undergoing rapid development as part of the gsfc land information system ( lis ) @xcite and will be published with lis version 7 .",
    "ldt testing requires exercising a large number of run - time options , achieved mainly by making small changes to the input test data , to increase internal code coverage .",
    "this use case leverages ddts _ extends _ mechanism to derive a large number of similar run definitions from a common ancestor , differentiating runs by overriding a small number of the inherited settings .",
    "ddts is also under consideration for long - term use with the nasa goddard institute for space studies modele project @xcite , and preliminary results indicate that it is possible to break up modele s build and run phases to fit the ddts framework .",
    "ddts run - level _ require _ mechanism is especially useful for modele tests , as it makes it possible to attempt a long simulation only after a short one has run successfully .",
    "this is an important hpc resource - management consideration , giving up some available parallelism to avoid wasting valuable compute resources .",
    "ddts _ require _ mechanism is also used to test `` restart '' runs by using the output of a completed run as the input to another .",
    "nasa s success in transitioning testing for these models indicates that adopting ddts can be straightforward and advantageous even in cases where some form of testing is already in place .",
    "one of the authors has also created and demonstrated prototype ddts applications for both the noaa environmental modeling system ( nems ) @xcite , a multi - model numerical weather prediction framework being developed at the u.s .",
    "national centers for environmental prediction ; and for yonsei university s global / regional integrated model system ( grims ) @xcite . both nems and grims exhibited design and structural elements different from the models previously tested with ddts , but proved amenable to testing with the framework .",
    "r c c c c c c & fim & ipe & lis ldt & modele & nim & nu - wrf + platforms supported & 2 & 1 & 1 & 1 & 3 & 1 ^ 3^ + suite definitions & 9 & 1 & 2 & 4 & 3 & 18 + run definitions & 56 & 7 & 36 & 21 & 122 & 50 + build definitions & 16 & 4 & 2 & 40 & 27 & 32 ^ 4^ + ddts loc^1^ & 1112 & 852 ^ 2^ & 1112 & 1112 & 1112 & 1112 + library loc^1^ & 487 & 164 & 931 & 876 & 381 & 1500 + definitions loc^1^ & 674 & 70 & 549 & 495 & 1164 & 4171 +    \\1 .",
    "loc = lines of code .",
    "2 . older version .",
    "3 . support for a second hpc platform is planned .",
    "not all in use currently .",
    "table [ table : metrics ] shows metrics , including counts of supported platforms , build / run / suite definitions , and lines of code , for several scientific codes using ddts . note",
    "that not every definition file necessarily represents a complete build , run or suite : some are merely fragments establishing common settings , meant to be extended in other definition files .",
    "future work may address the following current limitations :    * when using ddts standard bitwise - exact comparator , a relatively small number of tests is sufficient , due to the transitive property of equality .",
    "ddts may designate one run the `` master '' and compare each other run against it : if each run is bitwise - identical to the master , all runs are bitwise identical . when using an alternative comparator ( e.g. equality within some defined tolerance ) however , the transitive property no longer holds : the fact that a tested value from run a is equal to its counterpart from run b within tolerance , and b equal to c within the same tolerance , does not imply that the values from a and c are equal within tolerance .",
    "therefore , ddts should be equipped with an option to conduct a ( potentially much larger ) set of all - pairs comparisons when using an alternative comparator . *",
    "currently , ddts only allows a single run thread , via the mutex - locking mechanism previously described , to execute _",
    "lib_data _ to obtain and prepare input data for all runs in the test suite , under the assumption that all runs have the same data requirements .",
    "this is too restrictive and should be made flexible to allow runs to associate with different input data sets , in the same way they associate with different baselines . *",
    "the _ require _ key should be extended to support builds as well as runs , which would allow finer - grained tests of complex build systems , as well as builds of supported libraries . *",
    "the single - inheritance _ extends _ mechanism may also be too restrictive : definition ancestry chains can quickly grow long , and designing a robust hierarchy may need careful planning .",
    "a `` mixin''-style _ include _ mechanism that would allow insertion of arbitrary definition fragments anywhere in the hierarchy might be helpful .",
    "ddts is a practical testing framework designed to introduce routine testing into scientific - software projects as painlessly as possible .",
    "it has been used to implement both developer pre - commit test suites and unattended regression test suites , and has undergone active development to respond the needs of real - world scientific - software projects at nasa and noaa , supporting teams ranging from a small handful of developers to several dozen , and accommodating various deployment environments .",
    "it leverages the ruby programming language and the jruby implementation to remain lightweight and portable , and yaml to provide a simple , declarative domain - specific language to define test - suite activities and the dependency relationships between them .",
    "the ddts framework s design incorporates sound software - engineering principles and exposes some of them ( e.g. dry ) to the test - suite application developer .",
    "the user who ultimately invokes the framework only needs to deal with a simple command - line interface , but is welcomed to participate in the design of new test cases and suites by the simple declarative syntax of the build , run and suite definitions .",
    "it is easy to start testing with ddts : a small set of routines must be defined to interface ddts to the program - under - test and the computer platform , then simple yaml written to define builds , runs , comparison groups and test suites .",
    "iterative test - suite development is encouraged : one can explore the testing problem , building up a complete ddts application one piece at a time , from builds up to suites , without knowing beforehand exactly what the result will look like , and employing advanced configuration options only as requirements present themselves . at its simplest ,",
    "a ddts application can organize , standardize and automate the processes developers now perform manually , introducing systematic routine testing into their projects and , hopefully , helping scientific - software development efforts proceed on a sound basis .",
    "ddts is open - source , and distributed under a free - software license .",
    "it may be obtained at _",
    "/ maddenp / ddts_. the online repository includes a sample application that demonstrates many of the features described in this paper .",
    "the authors would like to thank tom henderson , whose original test system for fim defined ( and met ) many of the ddts design criteria , and whose feedback on the design and implementation of ddts has been invaluable .",
    "et al_. , `` the nmi build & test laboratory : continuous integration framework for distributed computing software , '' in _ proc .",
    "20th conf . on large installation system administration _ , berkeley , ca , 2006 , pp 263 - 273",
    ".            j. e. hannay , _",
    "et al_. , `` how do scientists develop and use scientific software ? '' in _ proc .",
    "2009 icse workshop on software engineering for computational science and engineering _ , vancouver , bc , 2009 , pp 1 - 8 .",
    "maruyama _ et al_. , `` the ionosphere - plasmasphere - electrodynamics ( ipe ) model : an impact of the realistic geomagnetic field model on the ionospheric dynamics and energetics , '' to be submitted to _ j. geophys .",
    "_ , 2014a ."
  ],
  "abstract_text": [
    "<S> many scientific - software projects test their codes inadequately , or not at all . despite its well - known benefits , adopting routine </S>",
    "<S> testing is often not easy . </S>",
    "<S> development teams may have doubts about establishing effective test procedures , writing test software , or handling the ever - growing complexity of test cases . </S>",
    "<S> they may need to run ( and test ) on restrictive hpc platforms . </S>",
    "<S> they almost certainly face time and budget pressures that can keep testing languishing near the bottom of their to - do lists . </S>",
    "<S> this paper presents ddts , a framework for building test suite applications , designed to fit scientific - software projects requirements . </S>",
    "<S> ddts aims to simplify introduction of rigorous testing , and to ease growing pains as needs mature . </S>",
    "<S> it decomposes the testing problem into practical , intuitive phases ; makes configuration and extension easy ; is portable and suitable to hpc platforms ; and exploits parallelism . </S>",
    "<S> ddts is currently used for automated regression and developer pre - commit testing for several scientific - software projects with disparate testing requirements .    </S>",
    "<S> software testing , software quality , scientific computing </S>"
  ]
}