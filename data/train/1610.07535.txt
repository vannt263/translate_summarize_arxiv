{
  "article_text": [
    "automata theory is particularly fruitful in terms of equivalence theorems : regular expressions , deterministic and nondeterministic automata , the myhill - nerode theorem , the regular word logic and the weak second order theory of one successor all are equally expressive in the languages they describe . in this paper ,",
    "i concern myself not with regular predicates ( predicates which hold only for the words in a regular language ) but with regular functions , functions whose behavior can be recognized by an automaton .",
    "this allows a translation of the krohn - rhodes theorem into yet another equivalent .",
    "the krohn - rhodes theorem concerns itself with _",
    "finite state transducers _ , an abstraction of systems that :    * accept inputs from a discrete set at discrete times , * retain some memory about previous inputs , which updates whenever an input is read , * for each input read , produce some output from a discrete set based on the input and memory .",
    "these are an abstraction of synchronous ( as opposed to those that update continuously ) , digital ( as opposed to those that deal with analog values ) systems .",
    "originally proved in @xcite , the krohn - rhodes theorem itself gives a decomposition of arbitrary finite state transducers into a cascade of transducers from a small generating set .",
    "computational implementations of this decomposition are available @xcite .",
    "the krohn - rhodes theorem can be used to analyze the rough behavior of automata , providing applications to artificial intelligence @xcite .",
    "finite state transducers are formalized as follows :    a _",
    "moore machine _ is a tuple : @xmath0 .",
    "* @xmath1 is a finite set of input characters ( alphabet ) .",
    "* @xmath2 is a finite set of states .",
    "* @xmath3 is the initial state .",
    "* @xmath4 is a finite set of output characters .",
    "* @xmath5 is the transition function .",
    "* @xmath6 is the output function .    for convenience",
    ", i will sometimes denote the map @xmath7 by @xmath8 .",
    "given an input word @xmath9 , construct a run @xmath10 and output @xmath11 such that :    * @xmath12 = q_0 $ ] .",
    "* @xmath13 = \\delta(r[i],w[i])$ ] for @xmath14 . * @xmath15 = \\epsilon(r[i])$ ] , for @xmath16 .",
    "where the indexing notation is such that : @xmath17 , \\ldots , w[|w|-1].\\ ] ]    the correct way of thinking about moore machines is that each input acts as a transition between one state and the next , or that each state is the state between inputs .",
    "a proper representation would have input characters half a step offset from states .",
    "outputs are simply a product of the state the automaton is in and so should be in step with the states .",
    "however , representing the sequences of input characters and states as words requires a choice of direction to shift half a step .",
    "a considerable effort has been made to pick the option to result in the cleanest presentation . in this paper ,",
    "the input character @xmath18 $ ] tells the device how to transition from state @xmath19 $ ] to state @xmath13$].$ ] telling the device how to transition from state @xmath20 $ ] to state @xmath19 $ ] .",
    "this alternative is not uncommon . ]",
    "this example below shows how inputs , states , and outputs , respectively , line up according to my notation .",
    "i will typically consider moore machines that simply output their states :    a moore machine is said to be _ transparent _ if @xmath21 and @xmath22 is the identity . in this case ,",
    "moore machines are presented as a tuple : @xmath23 .",
    "moore machines can be interpreted as functions from input words to output words :    given a moore machine @xmath24 , and word @xmath9 , i denote by @xmath25 the output of @xmath26 on input @xmath27 , with @xmath28 .",
    "moore machines , however , represent only a small subset of those functions on words which can be reasoned about using finite automata .    given two alphabets , @xmath29 , a function on words @xmath30 is said to be :    * _ length - preserving _ if for any word @xmath27 , @xmath31 .",
    "* _ causal _ if @xmath32 $ ] depends only on @xmath33 , \\ldots , w[i]$ ] . * _ strictly causal _ if @xmath32 $ ] depends only on @xmath33 , \\ldots , w[i-1]$ ] . * _ character - wise _ if @xmath32 $ ] depends only on @xmath18 $ ] .",
    "define the following useful functions for dealing with words :    * let @xmath34 denote the _",
    "_ successor-__@xmath35 function which appends the character @xmath35 to the end of a word .",
    "* let @xmath36 denote the function which removes the last character of a word .",
    "* let @xmath37 denote the function which removes the first character of a word .    given a moore machine @xmath26 ,",
    "the function @xmath26 computes is strictly causal , and increases length by 1 .",
    "it is often more convenient to deal with length preserving versions of this function :    given a moore machine @xmath24 , and word @xmath9 , denote by :    * @xmath38 the output of @xmath26 on input @xmath27 with the last state removed . * @xmath39 the output of @xmath26 on input @xmath27 with the first state ( the start state ) removed .",
    "given a moore machine @xmath26 , the function @xmath40 is strictly causal and length preserving , and the function @xmath41 is causal and length preserving .    the notion of finite automaton , or finite state recognizer , is more commonly studied than the finite state transducer . _ finite state automata _ are an abstraction of systems that :    * accept inputs from a discrete set at discrete times , * retain some memory about previous inputs , which updates whenever an input is read , * having finished reading a sequence of inputs , either _ accepts _ or _",
    "rejects_.    just as finite state transducers can be interpreted as functions on words , finite state automata can be interpreted as predicates on words , returning a boolean value after having read in a word .",
    "their predicative nature means that finite state automata are more convenient to use in applications to formal logic . on the other hand , real world systems are more often interested in transforming inputs , and",
    "so are better represented by finite state transducers .    finite automata yield a notion of a regular set or regular event , a collection of words or sequences of inputs which are exactly those which some finite automaton accepts",
    "once i define what it means to represent a function of words with an automaton , this will yield a notion of regular function .",
    "finite state recognizers are formalized as follows :    a _ finite state automaton _ is a tuple : @xmath42 .",
    "* @xmath1 is a finite set of input characters ( alphabet ) .",
    "* @xmath2 is a finite set of states .",
    "* @xmath43 is the set of initial states .",
    "* @xmath5 is the transition relation .",
    "* @xmath44 is the set of final states .    given an input word @xmath9 , @xmath45 is a run on input @xmath27 if :    * @xmath12 \\in i$ ] . *",
    "@xmath46,w[i],r[i+1])$ ] for @xmath14 .",
    "@xmath27 is _ accepted _ if there is a run @xmath10 on input @xmath27 such that @xmath47 \\in f$ ] .",
    "a finite state automaton @xmath48 is _ deterministic _ if :    * @xmath49 is a singleton .",
    "* @xmath50 is a function from @xmath51 , that is , given a @xmath52 , and @xmath53 , there is a unique @xmath54 such that @xmath55 .    by default",
    ", @xmath56 is nondeterministic .",
    "a well known theorem of finite automata is that :    [ detlemma ] if @xmath57 is the set of accepted inputs of some automaton , then it is also the set of accepted inputs of some deterministic automaton .    in either case",
    ", @xmath57 is _",
    "regular_.    a common convention in logic is to identify a function @xmath58 with the relation @xmath59 which consists of all pairs of the form @xmath60 , or , for @xmath61-ary functions , @xmath62 for @xmath63 in the domain of @xmath58 . as such , a regular function can be defined as a relation which is regular and also a function .",
    "the question now is how to input multiple words , especially multiple words of different lengths , to a finite automaton    i introduce the @xmath64 map to merge words together in parallel so they can be read by an automaton . for words of different lengths ,",
    "i add a dummy character @xmath65 .",
    "define the map @xmath66 which satisfies : @xmath67_j = \\begin{cases } w_j[i ] & \\text { it exists } \\\\ \\ # & \\text { otherwise } \\end{cases}\\ ] ] and @xmath68 .",
    "below is shown how @xmath64 combines words together into one word :    @xmath69    now i can define the notion of regular relation and regular function :    an @xmath61-ary relation @xmath70 is _ regular _ if there is a finite automaton @xmath56 with input alphabet @xmath71 such that : @xmath72    an @xmath61-ary function @xmath73 is _ regular _ if there is a finite automaton @xmath56 with input alphabet @xmath74 such that : @xmath75    regular relations and functions are a key part of the analysis of various automaton logics .",
    "for instance :    given a finite alphabet @xmath1 , let @xmath76 where :    * @xmath77 is the prefix relation on words , * @xmath78 is the equal length relation on words , * @xmath34 is the _",
    "successor-@xmath35 _ unary operation , which appends an @xmath35 onto the end of a word .",
    "i call @xmath79 the _ regular word logic over @xmath1_. operation , and containment . ]",
    "[ wordlogic ] if @xmath57 is a relation on @xmath80 , the following are equivalent :    * @xmath57 is regular , * @xmath57 is given by a formula @xmath81 in the language of @xmath82 .",
    "hence my interest in regular functions .",
    "if @xmath83 is a formula in the language of @xmath79 such that : @xmath84 then , since lexicographic ordering @xmath85 is regular and well - founded , the following relation is regular @xmath86,\\ ] ] and also a function . restrictions of this sort are called _",
    "skolem functions_.    it is also worth noting that a classification of the regular functions also yields a classification of the regular languages , since for any regular language @xmath57 , the characteristic function @xmath87 is regular .",
    "the idea of achieving quantifier elimination on the regular word logic via function composition was inspired in part by a theorem in @xcite , which decomposes regular predicates in terms of shifting operations , character - wise operations , and a univeral regular predicate .    finally , in this section , i connect moore machines and finite automata :    given a moore machine @xmath88 , the functions @xmath89 and @xmath41 are regular .",
    "construct a deterministic finite automaton that keeps track of two pieces of information : the state the moore machine is expected to be in at any particular point , and a boolean value to keep track of whether the proposed output has so far been correct .",
    "additionally , in the case of @xmath26 , there will be a final character of the form @xmath90 and a small amount of information must be kept track of to handle this correctly .",
    "for example , for @xmath40 , let : @xmath91 where : @xmath92    every strictly causal , length - preserving , regular function is given by @xmath40 for some moore machine @xmath26 .",
    "every causal , length - preserving function is given by @xmath41 for some moore machine @xmath26 .",
    "i prove this for a binary , strictly causal , length - preserving , regular function @xmath58 .",
    "the proof is nearly identical in the general case .",
    "let @xmath93 be given . by proposition [ wordlogic ] ,",
    "there is a formula @xmath94 in the language @xmath95 such that @xmath96    since @xmath58 is a strictly causal function , the first @xmath97 characters of the input determine the @xmath61th character of the output . by simple tricks in @xmath95",
    ", one can construct a formula @xmath98 for each @xmath99 such that @xmath98 is true of exactly those sequences of characters that produce an output of @xmath100 in the next place .",
    "these @xmath98 describe a collection of regular sets which partition all of @xmath80 .",
    "let @xmath101 be a finite automaton that recognizes the corresponding collection .",
    "now to construct the moore machine @xmath26 .",
    "it should run each of the @xmath101 in parallel to determine its state .",
    "since the @xmath101 recognize disjoint collections , exactly one of the @xmath101 will be in an accept state at any time .",
    "the @xmath22 function for the moore machine should take in the tuple of states for the @xmath101 and output the one which is in an accept state .",
    "it suffices now to check that @xmath40 is identically @xmath58 .",
    "the proof for @xmath41 is similar .    of course , there are plenty of other regular functions . in this paper",
    "i provide a small set of functions whose closure under multi - ary composition generates all of them . in the next section",
    ", i will interpret the proof of proposition [ detlemma ] to reduce the problem to studying functions given by the actions of moore machines and reverse moore machines .",
    "moore machines allow one to construct functions which transmit information only to the right ( towards the end of the inputs ) , but they need to be combined with a method to transmit information to the left .",
    "consider , for instance , the @xmath37 function , which removes the first character of a string , shifting to the left .",
    "alternately , a function which outputs @xmath102 or @xmath103 depending on whether there are an even or odd number of @xmath104s in the input .",
    "these functions are regular , but not causal .",
    "in this section , i define reverse moore machines , and provide a technique for decomposing a length - preserving regular function as a multivariable composition of a moore machine function , a reverse moore machine function , and character - wise maps to connect them .",
    "this will require several stages .",
    "first , i will briefly discuss some notation for discussing character - wise functions .",
    "second , i will introduce the notion of a reverse moore machine similar to the moore machines introduced in section 1 .",
    "third , i will present the decomposition .",
    "this decomposition is based on the classical powerset determinization construction , viewed from a novel perspective . in the next section",
    ", i will discuss handling general regular functions .",
    "first , some notation for functions which operate character - wise :    given two finite alphabets @xmath29 , and a function @xmath93 , call the function @xmath105 which applies @xmath58 to each character of the input , the _ character - wise @xmath58 map_.    if @xmath58 is an @xmath61-ary function for @xmath106 , one can also make sense of @xmath107 .",
    "let @xmath108 then one defines the partial function @xmath109 which takes in inputs of all the same lengths and produces an output of the same length , where : @xmath110 noting that @xmath64 does not produce characters with @xmath65 in them for equal - length inputs .    of course , @xmath107 is causal and length preserving ( and reverse - causal , when i define the notion ) .",
    "every moore machine function can be written as the action of the corresponding transparent moore machine composed with a bitwise application of its @xmath22 function .",
    "i now define some notation for dealing with reverse moore machines , analogous to the notation established previously .",
    "a _ reverse moore machine _ is a tuple : @xmath111 .",
    "* @xmath1 is a finite set of input characters ( alphabet ) .",
    "* @xmath2 is a finite set of states .",
    "* @xmath112 is the final state .",
    "* @xmath4 is a finite set of output characters .",
    "* @xmath5 is the reverse transition function .",
    "* @xmath6 is the output function .",
    "given an input word @xmath9 , construct a run @xmath10 and output @xmath11 such that :    * @xmath47 = q_f$ ] .",
    "* @xmath19 = \\delta(r[i+1],w[i])$ ] for @xmath14 .",
    "* @xmath15 = \\epsilon(r[i])$ ] , for @xmath16 .    here",
    "i show below how inputs , states , and outputs , respectively , line up according to this notation .        to prevent type mismatches , i will denote reverse moore machines with letters @xmath113 as opposed to letters @xmath114 for moore machines .",
    "a reverse moore machine is said to be _ transparent _ if @xmath21 and @xmath22 is the identity . in this case , the reverse moore machine is presented as a tuple : @xmath115 .    as before , one can interpret reverse moore machines as functions from input words to output words :    given a reverse moore machine @xmath116 , and word @xmath9 , denote by :    * @xmath117 the output of @xmath57 on input @xmath27 . *",
    "@xmath118 the output of @xmath57 on input @xmath27 with the last state removed . *",
    "@xmath119 the output of @xmath57 on input @xmath27 with the first state ( the start state ) removed .",
    "analogous to the notions of causal and strictly causal , one has notions of reverse causal and strictly reverse causal :    given two alphabets , @xmath29 , a function on words @xmath30 is said to be :    * _ reverse causal _ if @xmath32 $ ] depends only on @xmath18 , w[i+1 ] , \\ldots$ ] . * _ strictly reverse causal _ if @xmath32 $ ] depends only on @xmath120 , w[i+2 ] , \\ldots$ ] .    of course , a function is character - wise iff it is causal and reverse causal .",
    "one also has a notion of reverse deterministic automaton :    a finite automaton @xmath121 is _ reverse deterministic _ if :    * @xmath122 is a singleton . * for each @xmath123 , there is a unique @xmath124 such that @xmath125 .",
    "a reverse deterministic automaton can also be viewed as a transparent reverse moore machine .",
    "i now have the notation to state the main result :    [ detharvest ] any length - preserving regular function can be written as a multivariable composition of the form : @xmath126    it s worth noting that @xmath127 has the same action here as @xmath64 .",
    "i ve chosen to use @xmath127 here to indicate that i m not using the length - padding features of @xmath64 .",
    "a few lemmas must be proved first :    [ automatize ] given a length - preserving regular function @xmath128 , there is an automaton @xmath129 with state set @xmath2 and map @xmath130 such that @xmath131 is @xmath132 applied to any run of @xmath129 on input @xmath27 .    given the length - preserving function @xmath30 , let : @xmath133 witness the regularity of @xmath58 . since @xmath134 automatically rejects any inputs with a @xmath65 in them , one can restrict it to : @xmath135 recognizing the same set of inputs .",
    "construct an automaton : @xmath136 where : @xmath137 @xmath129 is nondeterministic .",
    "i assert that runs of @xmath129 on input @xmath27 will necessarily have @xmath4 component @xmath138 , for some @xmath139 .",
    "firstly , it should be clear that if @xmath10 is an accepting run of @xmath56 on input @xmath140 , then @xmath141 is an accepting run of @xmath129 on input @xmath27 for any @xmath139 .    now , suppose @xmath142 is an accepting run of @xmath129 on input @xmath27 .",
    "then it is easy to check that @xmath143 is an accepting run of @xmath56 on input @xmath144 .",
    "since @xmath56 witnessed @xmath58 being a regular function , @xmath145 must be @xmath131 .",
    "this completes the proof for @xmath22 taking the @xmath4 component of the states of @xmath129 .",
    "given a nondeterministic automaton @xmath121 , define its _ determinization _ : @xmath146 where : @xmath147    typically throughout this paper i will be concerned with the determinization as a transparent moore machine , so the set of final states does nt matter much .",
    "given a nondeterministic automaton @xmath148 , define its _ harvester _",
    ": @xmath149 where :    * the @xmath150 such that @xmath151 ( for @xmath54 ) is given by the least @xmath152 such that @xmath153 or @xmath154 if none exist . * the @xmath150 such that @xmath155 is given by finding the least @xmath156 such that there is a @xmath152 such that @xmath153 and then having @xmath150 be the least @xmath152 such that @xmath153 .",
    "if no such @xmath156 exists , then @xmath150 is given by @xmath154 .",
    "the powerset determinization of an automaton @xmath56 produces an automaton that keeps track of , at every position , the set of states of @xmath56 which are reachable through some sequence of transitions , having read the input up to that point",
    ". however , not every one of these reachable states necessarily shows up in some accepting run : it may be that being in one state now means later on having to be in another state which it can not transition out of , or that being in a state now dooms the automaton to being in a reject state once it has finished reading the input . in order to use the determinization to find an accepting run of the original automaton , provided",
    "there is an accepting run , one needs to start at the end and work backwards , all the while staying within states that one knows can be traced through a sequence of transitions back to a start state at the beginning .    specifically ,",
    "if the automaton is in a state @xmath150 which is reachable through some sequence of transitions after having read @xmath157 , then there must be at least one state @xmath124 which is reachable through some sequence of transitions after having read @xmath27 such that reading @xmath35 takes it from state @xmath124 to state @xmath150 .",
    "it is necessary to introduce an additional dummy state @xmath154 to start out in to make sure the harvester automaton is reverse - deterministic .",
    "although this application of the harvester automaton will see only pairs of the form @xmath158 for @xmath35 some symbol being read by the original automaton and @xmath159 the set of states reachable immediately prior to reading that specific @xmath35 , the automaton should be prepared to read in arbitrary input pairs . an invalid input will cause the reverse deterministic automaton to go into the dummy @xmath154 state . additionally , a cheap fix is necessary to account for the fact that one does nt know what state the run of the original automaton ends on and one needs a single `` final '' state for the reverse deterministic automaton to `` start out '' in .",
    "the dummy @xmath154 state represents all final states which are reachable . truncating the run",
    "will remove this dummy state .",
    "[ decomp ] suppose one has a nondeterministic automaton @xmath56 , and valid input @xmath27 .",
    "let @xmath160 be the run of @xmath161 on input @xmath27 .",
    "i claim that @xmath162 on input @xmath163 will have run @xmath10 , an accepting run of @xmath56 on input @xmath27 .",
    "it suffices to show that the only occurrence of @xmath154 in @xmath10 is as the final character . by construction",
    ", @xmath162 will satisfy the transition relations . as mentioned before the construction of @xmath162 also prevents backwards transitioning into the @xmath154 state for this particular input , since a reachable state can always be traced back to a reachable state .    by lemma [ automatize ] ,",
    "given a regular , length - preserving function @xmath58 , there is a nondeterministic automaton @xmath129 which takes in a word @xmath27 and has a run @xmath10 which projects to @xmath131 . by lemma [ decomp ] : @xmath164 by modifying the outer reverse moore machine , one can throw in the appropriate projection to its output map to produce @xmath131 .",
    "this completes the proof of theorem [ detharvest ] .",
    "this is a remarkable result .",
    "every length - preserving regular function can be computed in a two - step process : one pass forwards through the input leaving behind some information , then a pass backwards through the input with this additional information to directly produce the output .",
    "two passes suffice ; having more passes does nt increase the expressive power .",
    "the only functions this paper has dealt with so far were length - preserving . in this section , i show that most of the interesting behavior of regular functions was already captured in the length - preserving case .",
    "suppose @xmath93 is a regular function .",
    "then there is a fixed constant @xmath165 associated to @xmath58 such that @xmath131 is no longer than @xmath166 for every @xmath27 .    the proof is based on the pumping lemma .",
    "let @xmath56 be a deterministic automaton with @xmath165 states accepting exactly words of the form @xmath140 . choose a specific @xmath27 and",
    "suppose @xmath131 is longer than @xmath166 .",
    "imagine what happens as @xmath56 reads in @xmath140 , specifically , after @xmath27 is finished , and @xmath56 is reading in characters of the form @xmath90 for some @xmath139 . because there are more positions like this than there are states of @xmath56 , by the pigeonhole principle some two positions will have the same state , say at positions @xmath167 and @xmath168 .",
    "note however that if one removes all positions in @xmath140 between @xmath167 and @xmath168 ( including @xmath167 , excluding @xmath168 ) one still has an accepting run , of the form @xmath169 for some @xmath170 strictly shorter than @xmath131 .",
    "this contradicts the assumption that @xmath56 accepted exactly words of the form @xmath140 .    from this",
    ", one can also show that for any @xmath61-ary regular function @xmath58 , there is a fixed constant @xmath165 associated to @xmath58 such that @xmath171 is no longer than @xmath165 plus the length of the maximum input .",
    "note that the automaton @xmath56 in the proof never encounters the input character @xmath172 . as such",
    ", one may assume that this character acts as the identity on the states of @xmath56 .",
    "the resulting automaton recognizes all pairs of the form @xmath173 for arbitrary @xmath174 ( @xmath175 simply represents a @xmath165-fold composition of the @xmath176 function ) . by adding in a counter",
    ", one can recognize exactly the pairs of the form @xmath177 .",
    "as such , the function which takes @xmath178 to @xmath179 for @xmath180 is a length - preserving regular function @xmath170 , and thus can be written as a composition of character - wise maps , truncated moore machines , and truncated reverse moore machines as in theorem 1 .",
    "now @xmath58 can be written as : @xmath181 where @xmath182 removes final @xmath65 characters .",
    "note that one does not know how many final @xmath65 characters there will be . for functions which reduce length , the number will be more than @xmath165 and could be as much as @xmath183 .",
    "one might be tempted to try to replace @xmath182 with some function like @xmath184 ( or , even less suited to the task , @xmath36 ) , which either removes a single final @xmath65 or leaves the word alone if it can not . however , since there are regular functions which take words of arbitrary length and reduce them to length 1 , the generating set needs a generator that can produce unbounded shortening as well .",
    "note that if @xmath58 is @xmath61-ary for @xmath106 , it follows that : @xmath185 for some regular , length - preserving function @xmath170 .",
    "as such :    any regular function can be written as a multivariable composition of :    * truncated moore machines , * truncated reverse moore machines , * character - wise maps , * @xmath64 ( allowing one to generate multiary character - wise maps ) , * @xmath34 for various @xmath35 , * @xmath182 .",
    "it s worth noting here that this generating set is infinite . specifically , there are an infinite number of moore machines and reverse moore machines .",
    "there are also an infinite number of character - wise maps , but this is nt essential ",
    "one could use encoding methods to work purely with a single two - character alphabet ( plus , optionally , the dummy character @xmath65 ) .",
    "the infinitude of the generating set , however , is essential .",
    "the easiest way to see this is to talk about period introduction .",
    "provided the input to a regular function has a sufficiently long periodic portion in the middle , the output of the regular function will also have a long periodic portion in the middle ( it suffices to verify this of the generators above ) .",
    "what s more , the period of the periodic portion of the output can only have prime factors which show up either in the periods of the periodic portions of the inputs or which are smaller than the number of states of the associated automaton to the regular function .",
    "however , one can easily build regular functions which introduce any prime factor into the periodicity of their inputs , so there must not be any bound on the sizes of associated automata to regular functions in the generating set . in summary :    any set of regular functions which generates all regular functions under multivariable composition must be infinite .",
    "i conclude this paper with a discussion of known results regarding the krohn - rhodes theorem .",
    "first , i will provide a proof of the krohn - rhodes theorem adapted from ginzburg @xcite .",
    "then i will use the krohn - rhodes theorem to decompose the moore machine and reverse moore machine generators into smaller , simpler generators .",
    "the idea of interpreting a the cascade given by the krohn - rhodes theorem as a composition of functions can be found in @xcite .",
    "this paper will spell out this composition precisely and in modern notation , as has been done for previous compositions .",
    "a few sections will be dedicated to cleaning up the resulting set of generators , followed by proposed future research .",
    "in this section , i present the krohn - rhodes theorem as adapted to the context of multivariate composition of regular functions .",
    "the original proof of the krohn - rhodes theorem , in @xcite , was presented in terms of wreath products of semigroups .",
    "more modern presentations of the krohn - rhodes theorem typically present it in terms of the cascade product of finite state transducers .",
    "the cascade product of two transducers @xmath186 is a single system consisting of both machines .",
    "first , machine @xmath187 reads in both the input to the system and the current state of @xmath188 to update its state .",
    "when it has finished , machine @xmath188 updates its state based only on the input to the system . finally , an output is produced based on the states of @xmath188 and @xmath187 .",
    "this reflects the reality of systems where updating the states of machines takes a small but appreciable amount of time . in a well designed system",
    ", @xmath187 should not have to wait for @xmath188 to finish its update before it can update its state .",
    "as such , @xmath187 uses the state of @xmath188 prior to reading the input to update .",
    "the krohn - rhodes theorem separates out two extremes of behavior for finite automata . in general , reading in an input character induces a function on the states of the automaton .",
    "this function may map two states to the same state or to separate states . at one extreme",
    ", it may act as a _",
    "permutation _ in which case it maps all states to separate states . in this case",
    ", it is possible to undo this action .",
    "one can recover the state before reading a character which acts as a permutation , provided one knows which character the automaton read . at the other extreme , an input character may act as a _ reset _ in which case it maps all states to the same state . in this case all information about the previous state is lost .      * a _ permutation automaton _ if each of its inputs acts as a permutation on its states , * a _ reset automaton _ if each of its inputs acts as a reset or the identity on its states , * a _ permutation - reset automaton _ if each of its inputs acts as a permutation or a reset on its states .",
    "given a transparent moore machine @xmath26 , one can write its truncated action @xmath40 as a multivariable composition of truncated actions of permutation - reset moore machines @xmath189 for @xmath61 the number of states of @xmath26 , and a final character - wise map @xmath58 .",
    "what s more , this composition takes on a fairly simple form .",
    "let : @xmath190 then : @xmath191    every map in this composition is length - preserving .",
    "of course one can write this as simply one large multivariable composition of a character - wise map and truncated actions of permutation - reset transparent moore machines , but this is unwieldy to write down .",
    "the above also presents an efficient way of computing the composition , although readers concerned with efficiency are encouraged to look into the holonomy decomposition @xcite .",
    "the proof is inductive : i show that for every transparent moore machine @xmath26 , there s another transparent moore machine @xmath192 that keeps track of a state @xmath26 is not in in a permutation - reset way .",
    "this reduces the amount of information that needs to be kept track of by one state , and one can keep doing this until one has kept track of all the information to know what state @xmath26 is in .",
    "the proof in @xcite allows for the possibility that one can keep track of several states the automaton @xmath26 is not in in a permutation - reset way at the same time , as opposed to one at a time in the proof below .",
    "this is more efficient , but adds needless complexity to the proof .",
    "* @xmath170 either acts as : * * a bijection from @xmath49 to @xmath195 ( a permutation on the position indices ) , * * or has singleton image ( a reset on position indices ) , * and for @xmath196 , with @xmath197,@xmath198 . * for any @xmath199 , @xmath58 maps elements of @xmath200 to @xmath201 .",
    "suppose @xmath58 does not act as a bijection .",
    "then @xmath170 which maps everything to the smallest element of @xmath195 which is not in the image of @xmath58 has singleton image and satisfies the inequality condition .        given a transparent moore machine @xmath203 , there is a permutation - reset transparent moore machine @xmath192 with the same state set such that on input @xmath27 , the state of @xmath26 at any one time is not the state of @xmath192 .        if the action of @xmath35 was a permutation originally , it is still a permutation in the new automaton .",
    "this permutation not only maps the state the automaton is in before reading @xmath35 to the state afterwards , but also from a state the automaton is not in before reading @xmath35 to a state the automaton is not in afterwards . in the second case , note that the choice of @xmath124 does not depend on @xmath150 , so this action is a reset .",
    "obviously , it maps a state the original automaton is not in before reading @xmath35 to a state the automaton is not in after reading @xmath35",
    ".    given transparent moore machines @xmath209 as above with state sets @xmath2 , there is a third transparent moore machine : @xmath210 such that for any input @xmath27 , if @xmath26 on reading @xmath27 winds up in state @xmath150 , and @xmath192 on reading @xmath27 winds up in state @xmath211 then @xmath212 on reading @xmath213 will wind up in state @xmath214 , where @xmath150 is the element in positionst element of a set as being in position @xmath167 . to avoid confusion ,",
    "i avoid using the notation `` @xmath167th element '' , instead using notation `` the element in position @xmath167 '' . ]",
    "@xmath214 of @xmath215 .",
    "* computing @xmath220 .",
    "this is the state @xmath192 says that @xmath26 is not in after reading @xmath35 . *",
    "computing @xmath150 , the @xmath167th element of @xmath215 .",
    "this is the state of @xmath26 prior to reading @xmath35 .",
    "* return @xmath168 , the index of @xmath208 in @xmath221 .",
    "* inductive case : * given @xmath26 , one can write : @xmath224 with @xmath192 permutation - reset . by the inductive hypothesis , one can write @xmath225 , which has one fewer state than @xmath26 , as : @xmath226 where : @xmath227        alternately , fiddling with some parentheses in the definitions in the automata : @xmath231 where : @xmath232 in which case : @xmath233 one can combine @xmath160 and @xmath58 to get a single character - wise function on @xmath234 , thus completing the induction .",
    "the proof is still straightforward if one unwinds the induction . in the construction",
    ", @xmath235 is keeping track of a state @xmath26 is not in , but it may as well be keeping track of an index for a state @xmath26 is not in .",
    "@xmath236 is keeping track of an index of a state @xmath26 is not in once one has removed the state in position @xmath235 from @xmath2 .",
    "@xmath237 is keeping track of an index of a state @xmath26 is not in once one has removed the states that @xmath236 and @xmath237 are keeping track of from @xmath2 . and so forth .",
    "one can formalize this indexed removal process as follows :      one can interpret an ordinal removal sequence for @xmath61 as a series of commands operating on an ordered set of size @xmath61 of the form `` remove the @xmath241st smallest element remaining . ''",
    "note that as elements are removed , there are fewer elements remaining , hence the decreasing upper limit on @xmath242 in the second constraint .",
    "consistent with the rest of this paper , i begin indexing with 0 , so a 0 means remove the smallest element ."
  ],
  "abstract_text": [
    "<S> while automata theory often concerns itself with regular predicates , relations corresponding to acceptance by a finite state automaton , in this article i study the regular functions , such relations which are also functions in the set - theoretic sense . here </S>",
    "<S> i present a small ( but necessarily infinite ) collection of ( multi - ary ) functions which generate the regular functions under composition . to this end , this paper presents an interpretation of the powerset determinization construction in terms of compositions of input - to - run maps . </S>",
    "<S> furthermore , known results using the krohn - rhodes theorem to further decompose my generating set are spelled out in detail , alongside some coding tricks for dealing with variable length words . </S>",
    "<S> this will include two clear proofs of the krohn - rhodes theorem in modern notation . </S>"
  ]
}