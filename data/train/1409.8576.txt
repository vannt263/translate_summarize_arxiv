{
  "article_text": [
    "in many applications from a wide variety of fields , the data to be processed can partially ( or even almost completely ) be affected by severe noise in several phases , e.g. , occlusions during a visual recording or packet losses during transmission in a communication channel . the partial , i.e. , localized , corruptions resulted in the data due to such problems often severely degrade the performance of the target application ; for instance , face recognition or pedestrian detection under occlusion @xcite . in order to reduce the impact of this adverse effect",
    ", we develop a complete and novel framework , which efficiently detects , localizes and imputes corruptions by identifying the local anomalies in a given suspicious data instance .",
    "we emphasize that neither the existence nor , if exists , the location of a corruption is known in our framework .",
    "moreover , the proposed algorithms do not assume a model but operate in a data driven manner .",
    "we consider the local corruptions as statistical deviations from the nominal distribution of the uncorrupted ( clean ) observations . to detect and localize corruptions , i.e. , such statistical deviations , we model a corruption as an anomaly due to an external factor ( communication failure in a channel or occluder object in an image ) , which locally overwrites a data instance and",
    "moves it outside the support of the nominal distribution .",
    "however , corruptions that we consider as examples of anomalies have further specific properties such that ( a ) the corruptions in an instance are confined to unknown intervals along the data attributes , i.e. , localized , and ( b ) not only a corrupted part but also all of its subparts are anomalous .",
    "thus , a corruption does not provide an anomaly due to an incompatible combination of normal subparts .",
    "based on these properties that accurately model a wide variety of real life applications , we characterize the event of corruption and formulate the corresponding detection / localization as an anomaly detection problem , cf .",
    "@xcite .",
    "the introduced algorithm applies a series of statistical tests with a pre - specified false alarm rate to the parts of the suspicious instance after extracting the nominal statistics from a reference ( training ) data set of uncorrupted ( clean ) observations . as a result ,",
    "each part is labeled as anomalous / normal and the local anomalies are identified .",
    "these parts are generated and organized through a binary tree partitioning of the data attributes , each node of which corresponds to a part of the suspicious instance .",
    "once the nodes ( or parts ) are labeled as anomalous / normal on this tree , the patterns of corruption are identified using the aforementioned characterization to detect and localize corruptions .",
    "we point out that this localization procedure transforms the nominal distribution into a multivariate bernoulli distribution with a success probability that precisely coincides with the constant false alarm rate of the local anomaly tests . considering the hierarchy among the binary labels implied by the tree as a directed acyclic graph",
    ", the resulting multivariate bernoulli distribution achieves a certain dependency structure . under this condition",
    ", we derive the false alarm rate of the proposed framework in detecting the corruptions and show that it is a constant rate , namely , no parameter tuning is required even if the data change .",
    "if a corruption is localized , then we impute / replace the affected attributes with the estimates of the underlying unknown true attributes . for this purpose",
    ", we additionally develop a novel _ maximum a posteriori _ ( map ) estimator using the  score function \" defined in @xcite .",
    "our estimator exploits the local dependencies among the data attributes , where the locality is encoded in the binary partitioning tree .",
    "we point out that the implementation of this map estimator does not load extra computational cost since it utilizes the outputs of our anomaly detection approach , which are computed prior to the imputation phase .",
    "furthermore , we also propose a novel distance measure named  ranked euclidian distance \" as a generalization to the standard euclidean distance , which is used in the course of the labeling of each part as anomalous / normal .",
    "the proposed distance measure is compared with the standard euclidean distance in the experiments and shown to be superior in terms of detecting and localizing corruptions .",
    "we conduct tests over several well - known machine learning data sets @xcite , which are exposed to severe data corruptions .",
    "our experiments indicate that the proposed framework achieves significant improvements after imputation up to @xmath0 in terms of the classification purposes and outperforms the typical approaches .",
    "the proposed algorithms are also empirically shown to be robust to varying training phase conditions with strong corruption separation capabilities .      in this study ,",
    "the corrupted attributes are considered to be statistically independent with the underlying unobserved true data , i.e. , corrupted attributes are of no use in estimation of the uncorrupted counterparts .",
    "hence , if one knows which attributes are corrupted in an instance , then those attributes can readily be treated as missing data , cf . @xcite . for example",
    ", classification and clustering with missing data is a well - studied problem in the machine learning literature .",
    "the corresponding studies such as @xcite are related to inference with incomplete data @xcite and generative models @xcite , where bayesian frameworks @xcite are used for inference under missing data conditions .",
    "alternatively , pseudo - likelihood @xcite and dependency network @xcite approaches solve data completion problem by learning conditional distributions . in @xcite , the probability density of the missing data is modeled conditioned on a set of introduced latent variables and thereafter , a map based inference is used .",
    "however , all of the studies @xcite either assume the knowledge of the location of the missing attributes or impose strong modeling constraints ; as opposed to the model free solutions in this paper .",
    "on the other hand , imputation is commonly used as a pre - processing tool @xcite .",
    "the mixture of factor analyzers @xcite approach replaces the missing attributes with samples drawn from a parametric density , which models the distribution of the underlying true data .",
    "the proposed imputation techniques in @xcite are , whereas , both non - parametric and based on the inference of the posterior densities via certain kernel expansions . on the contrary , the map estimator in this study does not even attempt to estimate the posterior density either in a parametric or non - parametric manner . instead , the introduced method is only based on the sufficient rank statistics .",
    "we emphasize that unlike our approach , the incomplete data approaches generally assume the knowledge of the missing attributes , i.e. , they are precisely localized and provided beforehand .",
    "for example , the occluded pixels in the event of occlusion of a target object in an image can not be known a priori , which requires a detection and localization step .",
    "since the existing studies do not have such a step , an exhaustive list of the occluded pixels as the result of a manual inspection of the missing attributes is required as an input to the algorithms proposed in the corresponding literature . in this",
    "regard , our study is the first to jointly handle the issues of detecting / localizing missing attributes , i.e. , corruptions , as well as their imputation in one complete framework .",
    "hence , the generic local corruption detection and imputation algorithm of our framework complements the missing data imputation approaches as an additional merit .",
    "data imputation and completion is also essential in image processing for handling corrupted images , e.g. , @xcite .",
    "generally , a corrupted image is restored by explicitly learning the image statistics @xcite or by using neural networks @xcite .",
    "these denoising studies do not attempt to localize corruptions in an image , but treat them as a noise and filter it out using statistical approaches applied to the image globally .",
    "even though this is a valid approach for image enhancement , an attempt to correct / enhance an image globally in case of only a localized corruption might be even detrimental since the uncorrupted parts are also affected by global operations . additionally , it is not usually possible to locally impute corrupted portions using denoising approaches .",
    "there exist several studies that aim localization as well .",
    "studies such as @xcite indicate that occlusion , as an example of corruption , is a common phenomenon and detrimental in pedestrian detection as well as face recognition applications . in this",
    "regard , detection of occluded , i.e. , corrupted , visual objects had been previously investigated in a number of studies @xcite . in these studies ,",
    "occlusion detection is performed using domain specific knowledge ( visual cues ) or external information ( object geometry ) , which , however , are not always available in general data imputation setting . from the machine learning perspective , descriptors are extracted from various parts of the occluded object in @xcite and similarly ; part - based descriptors are weighted with the occlusion measure in @xcite to relieve the corresponding degrading effects . since these approaches",
    "do not directly target handling occlusions , i.e. , corruptions , they only provide partial or limited solutions .",
    "several other studies propose solutions via extracting occlusion maps , e.g. , @xcite . in @xcite ,",
    "hog based classification errors ; and in @xcite , template based reconstruction errors are used to generate such an occlusion map .",
    "however , both studies assume rigid models and significantly rely on domain specific knowledge ; and in general fail to remain applicable if the data source belongs to another domain . in this study , we assume that data is generic and no domain information is available , yet detection and imputation of corruption is necessary for improving the subsequent processing stages , such as classification .      1 .",
    "this study is the first to jointly handle localized data corruptions in one statistical framework that is designed completely model free for the goal of separating a corruption and imputing the affected data attributes .",
    "we also provide a false alarm rate ( in detecting corruptions ) analysis of the framework via directed acyclic graphs . 2 .   a novel map estimator for imputation and a novel distance measure for corruption localization purposes",
    "is proposed .",
    "the proposed framework is computationally efficient in the sense that ( i ) it effectively utilizes a binary search for corruption separation , and ( ii ) the computational load due to our map based imputation is insignificant .",
    "we propose a characterization for anomalies , e.g. , rarities , incompatible combinations and corruptions , which is a novel notion .",
    "+    in section [ sec : pd ] , we provide the problem description .",
    "we then present our algorithm in section [ sec : thethemethod ] and the associated computational complexity in section [ sec : complexity ] .",
    "we report the corruption detection / localization performance of the proposed algorithm as well as the improvement in classification tasks achieved by the imputation in section [ sec : experiments ] .",
    "the paper concludes with a discussion in section [ sec : conclusion ] .",
    "we have a possibly corrupted test instance @xmath1 along with a set of uncorrupted ( clean ) independent and identically distributed observations @xmath2 as the nominal training ( reference ) data , where @xmath3 \\in \\mathbb{r}^d \\sim f_{0}(\\mathbf s)$ ] , @xmath4 is data dimensionality and @xmath5 is the unknown nominal density .",
    "the test instance @xmath6 is considered to be corrupted with probability @xmath7 by severe noise in multiple non - overlapping intervals along its dimensions ( attributes ) , which are completely unknown .",
    "suppose that for such an interval , the corruption is localized and confined to the attributes @xmath8 for some @xmath9 and @xmath10 in @xmath11 $ ] with @xmath12 .",
    "we assume that the corrupted attributes are uniformly and independently distributed , @xmath13 , where @xmath14 is the uniform distribution defined in a finite support .",
    "moreover , @xmath15 is also statistically independent with the true data and hence , the knowledge of @xmath16 is irrelevant to the uncorrupted counterparts .",
    "note that this corruption model implies a total erasure of data in several unknown portions due to an independent source overwriting the attributes in those portions , e.g. , an occluder in computer vision applications @xcite .",
    "typically , since no information is provided about the independent source in such applications , we consider that the uniformity assumption draws a worst case scenario and it is realistic . on the other hand , @xmath6 is considered to be uncorrupted with probability @xmath17 .",
    "therefore , whether a test instance @xmath6 includes a corruption is unknown ; and it is generally modeled to be drawn from the mixture @xmath18 @xcite , where @xmath19 is the probability density of the corrupted instances .    the density @xmath19 can be derived from the unknown nominal density @xmath5 using the described corruption model , if the distributions of @xmath9 , @xmath10 and the number of corrupted intervals are further specified ; which is unnecessary in the context of this paper . hypothetically , if one can correct an instance @xmath6 drawn from the density @xmath19 by replacing all the corrupted attributes , e.g. , @xmath16 , with the underlying true attributes , e.g. , @xmath20 , and obtain @xmath21 , then @xmath21 should follow the nominal density @xmath22 . similarly ,",
    "if the corruptions in @xmath6 can be localized , then the corresponding portions would follow the multivariate uniform density @xmath23 of the appropriate dimensionality . on the other hand",
    ", this corruption model potentially creates significant statistical deviations from the reference data since a corrupted observation @xmath24 and @xmath25 , in general , increasingly diverges from @xmath22 as the corruption strength increases . here",
    ", the corruption strength can be considered as the number of corrupted attributes and/or the variance of the corruption @xmath26 that overwrites the true data .",
    "furthermore , our modeling of corruptions poses a missing ( incomplete ) data problem since the unknown true attributes @xmath20 in a corrupted interval are statistically irrelevant to the corrupted attributes @xmath16 . in this paper , by exploiting the statistical deviations from the nominal distribution of observations , we aim to detect and localize the possible corruptions in a given instance @xmath6 and impute the corrupted or missing attributes .    to this end",
    ", we formulate an anomaly detection approach to define this framework in section [ sec : thethemethod ] , where we draw the distinctions among several examples of anomalous observations and separate the event of corruption .",
    "then , we propose our algorithm and analyze the associated false alarm probability in detecting corruptions as well as the computational complexity .",
    "in this section , we develop a novel framework for a complete treatment of possible corruptions in the input data @xmath6 . for presentational clarity and without loss of generality , we assume that the input data @xmath6 can be corrupted only in a single interval throughout this section .",
    "note that the generalization to the case of corruptions spread onto several intervals is immediate and indeed , we present a corresponding detailed experiment in section [ sec : experiments ] . since the corruptions are modeled as local statistical deviations within this framework , we give a brief description of the anomaly detection approach that we work with in section [ sec : corruptionsandanomalies ] .",
    "based on the characterization of corruptions through their distinctive properties in section [ sec : treelozalization ] , we present algorithm tcs ( tree - based corruption separation ) .",
    "after we derive a novel map estimator for imputation in section [ sec : theimp ] , we derive the false alarm rate of the proposed framework in detecting the corruptions in section [ sec : acf ] .",
    "a localized corruption is considered to affect an instance in a certain part(s ) such that the affected attributes statistically deviate from the vast majority of the data .",
    "the proposed algorithm in this paper localizes the corrupted attributes by identifying the local anomalies through a series of statistical checks of the test instance with the reference data . in this section ,",
    "we briefly describe the anomaly detection approach that we work with and present a novel distance measure for the corruption localization purpose .",
    "the probability density of a possibly corrupted test instance @xmath6 can be modeled as @xmath27 @xmath28 is the null hypothesis from which the nominal data are drawn , @xmath29 is the hypothesis representing the corrupted observations , and @xmath30 $ ] is the corresponding mixing coefficient . within the framework of anomaly detection approaches ,",
    "the nominal distribution @xmath5 is usually assumed unknown or hard to estimate ; and instead , a set of nominal observations is provided . then for a given test instance @xmath6 , the task in @xcite is to decide whether the null hypothesis @xmath31 was realized or the alternative @xmath32 such that the detection rate ( of anomalies ) is maximized with a constant false alarm rate @xmath33 . for this purpose ,",
    "the score function @xcite @xmath34 is proposed , where @xmath35 is the indicator function and @xmath36 is the euclidean distance from @xmath6 to its nearest @xmath37th neighbor in @xmath38 , if @xmath39 ; and to its nearest @xmath40th neighbor in @xmath38 , otherwise .",
    "based on this score function , the test instance @xmath6 is declared as anomalous @xcite , if @xmath41 when the mixing distribution @xmath19 is assumed uniform , it is shown in @xcite that @xmath42 is an asymptotically consistent estimator of the density level of the test instance @xmath43 under certain smoothness conditions .",
    "remarkably , @xmath44 provides the minimum volume set at level @xmath33 , which is the most powerful decision region for testing @xmath31 vs @xmath32 with a constant false alarm rate @xmath33 @xcite .",
    "we note that the precision of the test defined in degrades faster with the dimensionality than it improves with the size of the training data . as a result",
    ", we here point out several practical issues about detecting the existence of a corruption with this approach .",
    "briefly , i ) a direct test of an instance @xmath6 does not localize a possible corruption for imputation , ii ) on the contrary , a truly corrupted instance , i.e. , an instance of hypothesis @xmath32 , does not necessarily test positive due to the limited training data , high dimensionality as well as that the corruption might not be sufficiently strong ; and iii ) corruptions have further specific properties in addition to that they provide anomalies , which must be incorporated to achieve a better false alarm rate compared to @xmath33 .",
    "+ _ ranked euclidean distances _ : to address the first issue in this list , we propose a novel distance measure ( not a metric in the mathematical sense ) , which is sensitive to only a certain @xmath45 fraction of the attributes for a given pair of instances @xmath6 and @xmath46 . for instance , a corruption of only a single attribute in a given test instance @xmath6 might be significantly strong such that the whole instance turns anomalous with the test in used with the standard euclidean distance . in this case ,",
    "any part of the instance @xmath6 including the corrupted attribute would test positive , which creates an ambiguity in terms of the localization , i.e. , separation , of the corrupted attribute , and in turn requires an exhaustive search over all possible subsets in the space of the attributes .    to overcome such ambiguities ,",
    "we propose a distance measure so that the test in results positive only when the corruption has a sufficiently large support , which disregards a pre - specified fraction of the attributes that are most responsible for a possible corruption .",
    "we define this measure for an @xmath47 $ ] as @xmath48 where @xmath49 is a permutation of the attributes with @xmath50 is the floor operator .",
    "since this distance measure depends only on the @xmath45 fraction of the least deviated attributes between @xmath6 and @xmath46 , a corruption must have a support of at least @xmath51-length to make an instance anomalous with respect to the reference data . here",
    ", @xmath52 can be seen as the precision of the localization when an anomalous instance is checked with the test in using the distance measure defined in .",
    "this precision obviously can not be made arbitrarily large since as @xmath53 approaches @xmath54 , the distance @xmath55 becomes more prone to noise and the correlation structure between the attributes is less exploited .",
    "we investigate this trade - off further in our simulations .",
    "the distance measure @xmath55 recovers the standard euclidean distance when @xmath56 and will be named in the rest of the paper as  ranked euclidean distance \" .",
    "we note that for the cases @xmath57 , @xmath55 fails to be a metric in the mathematical sense , i.e. , @xmath58 is not satisfied , which requires to specify a nominal density model on @xmath5 to derive the same asymptotic consistency in @xcite for the score values @xmath59 in estimating the density levels @xmath60 with @xmath55 .",
    "however , we do not assume -in this work- any density model for @xmath5 or do not take any stochastic assumptions regarding the data source .    in the following section ,",
    "we characterize the corruptions by presenting their specific properties and propose an algorithm to localize and impute corruptions",
    ".      if a test instance is subject to corruption in a small part only , the corruption might not be detectable when it is checked using an anomaly detection algorithm without a detailed analysis in its parts .",
    "on the other hand , an anomalous observation does not necessarily contain a corruption since it might simply be a false alarm , in fact an uncorrupted observation . to address these two issues ,",
    "we propose a statistical analysis of a test instance through its parts using a binary partitioning tree in the space of data attributes on which , we also provide a characterization to separate the event of corruption among possible anomaly scenarios .",
    "suppose that an instance @xmath61\\in \\mathbb{r}^d$ ] corresponds to the root node @xmath62 on a binary tree .",
    "using half - way splits for presentational simplicity , let the set of attributes @xmath63 be assigned to the left child node @xmath64 of the root and @xmath65 assigned to the right child node @xmath66 , fig .",
    "[ fig : example1 ] .",
    "note that @xmath67 with @xmath68 and @xmath69 . based on this strategy for generating subparts of an instance ,",
    "we propose algorithm tcs ( tree - based corruption separation ) to separate and impute corruptions , which recursively expands a depth-@xmath70 binary tree to partition the space of attributes . for each node @xmath71 created in the course of this expansion , the corresponding attributes / part of the test instance , e.g.",
    ", @xmath72 with @xmath73 , is checked whether it is consistent with the reference data restricted to those attributes , e.g. , @xmath74 with @xmath73 , using the test defined in .",
    "we here use the ranked euclidean distance @xmath75 in this testing with a pre - specified @xmath45 . therefore ,",
    "each node @xmath71 encountered in this expansion is assigned a binary label as anomalous / normal and a fully labeled ( possibly unbalanced ) tree is obtained for the test instance @xmath6 .",
    "we emphasize that algorithm tcs does not completely construct this depth @xmath70-binary tree at the beginning but instead expands it by creating the nodes and the edges as needed to achieve an efficient implementation , which continues until that each data attribute is decided to be corrupted or uncorrupted .",
    "we consider several scenarios where the observation @xmath76 at a node @xmath71 can be anomalous . in fig .",
    "[ fig : simplecorruption ] , the nodes are illustrated as circles , if the corresponding part is found to be anomalous ; and squares otherwise .",
    "an anomaly can be wide - spread onto the attributes and consist of anomalous subparts as illustrated in fig .",
    "[ fig : simplecorruption]a , which is regarded as a conclusive pattern since a corruption is characterized and defined in section [ sec : pd ] by that all of the subparts of a corrupted instance are also corrupted .",
    "hence , a corruption at the starred node in fig . [ fig : simplecorruption]a is declared , unless it is the root node .",
    "note that a global corruption at the root is disregarded in this work since it is not localized .",
    "in another case , an anomalous observation could be non anomalous in its parts as illustrated in fig .",
    "[ fig : simplecorruption]b , which simply happens due to an incompatible or rare combination of attributes in its subparts .",
    "this is a typical situation , where an anomalous observation is not corrupted .",
    "hence , this case also provides a conclusive pattern in our consideration such that a corruption is rejected at the anomalous node . on the contrary , the case in fig .",
    "[ fig : simplecorruption]c is an inconclusive pattern , which suggests a corruption at the right child , however , whether the corruption is spread in attributes of that child or localized is unknown .",
    "hence , the attributes of the right child is further split and explored similarly .",
    "then , if the conclusive pattern in fig . [",
    "fig : simplecorruption]a ( or fig .",
    "[ fig : simplecorruption]b ) is realized , then the corruption is accepted and localized ( or rejected ) at the starred node in fig .",
    "[ fig : simplecorruption]d",
    ". otherwise , the search continues . on the other hand , if a significantly small subset of the corrupted attributes are left at the left child node in fig .",
    "[ fig : simplecorruption]c , it might not be detectable and labeled as normal",
    ". then the corresponding attributes should further be split as illustrated in fig .",
    "[ fig : simplecorruption]d .",
    "this process recursively defines a corruption localization with an improved false alarm rate as several anomalies are rejected as they are false alarms , i.e. , non corrupted anomalies .",
    "the introduced algorithm tcs then searches in a breadth - first - search fashion the described binary tree for a corruption .",
    "when the conclusive ( or terminating ) pattern shown in fig .",
    "[ fig : simplecorruption]a ( fig .",
    "[ fig : simplecorruption]b ) is found in the course of this expansion , the search is stopped at the parent node of the found pattern , i.e. , the tree is pruned on that branch , and corruption is declared ( or no corruption is found and no action is necessary ) for the corresponding attributes .",
    "this search of corruption at each branch starting from the root node continues to the corresponding leaf node , unless a terminating pattern is found . finally ,",
    "if a conclusive pattern is not encountered at a branch from the root to an anomalous leaf , we opt to accept the corruption at the leaf to favor a better detection at a cost of an increased corruption false alarm rate .",
    "an illustration of the progress of the algorithm is given in fig .",
    "[ fig : example1 ] , where the corrupted attributes are successfully located . note that a small set of the attributes are mislabeled as corrupted , i.e. , false alarms , in the region 3 , which can be corrected if the partitioning resolution is improved by increasing the depth @xmath70 .",
    "= 3.5 cm      we emphasize that in most of the detection and estimation applications , the posterior density , e.g. , @xmath77 in , of the target is too complicated to assume realistic parametric models so that the nonparametric approaches are often favored in such situations @xcite . in accordance , we introduce an algorithm that works under a completely model free setting regarding both the localization of the corruptions and the imputation .",
    "furthermore , we point out that map based estimators are generally known to generate more plausible results when the posterior density is multi - modal , compared to mmse based estimators , i.e. , simple ( possibly weighted ) averaging , which can even generate infeasible solutions @xcite .",
    "this is often the case especially for the computer vision and machine learning applications such as edge preserving image denoising @xcite .",
    "for instance , the gradients in an occluded pedestrian image would get too smoothed in an mmse based imputation , which might cause the gradient based feature extractors , e.g. , hog @xcite , to fail or not perform satisfactory in case of an pedestrian detection application @xcite . for these reasons ,",
    "we propose a novel map based imputation technique , which always generates feasible and likely estimates and approximates the true map estimator as the size of the reference data increases .",
    "once a corruption is localized for an instance @xmath6 at a node @xmath71 , then our task is to estimate the original attributes @xmath78 using the training data set @xmath38 as well as the instance @xmath6 and impute accordingly , i.e. , replace the corrupted attributes in @xmath6 with the estimates .",
    "since we assume the corrupted attributes @xmath79 to be statistically independent with the underlying true data @xmath78 , we treat the corrupted attributes as missing data , which then should have no effect in estimation of the true attributes . hence , we condition this estimation of the data @xmath78 on the remaining attributes in @xmath6 . on the other hand , we note that in most of the applications such as the image compression @xcite , the data attributes being in sufficiently close proximity are usually modeled to manifest high correlation . in accordance",
    ", we propose to estimate the unknown data @xmath78 conditioned on the attributes @xmath80 associated with its nearest neighbor on our tree , i.e. , the sibling node @xmath81 of @xmath71 .",
    "note that due to the localization of corruptions by algorithm tcs ( tree - based corruption separation ) , the attributes at the sibling node @xmath81 are certainly detected to be uncorrupted in case of the standard euclidean distance ; and detected to be uncorrupted with significantly high probability in case of the ranked euclidean distance ( cf . section [ sec : acf ] ) . in the following ,",
    "we introduce a novel _ maximum a posteriori _ ( map ) estimator of the true data underlying the corrupted attributes based on the standard euclidean distance ( @xmath75 with @xmath56 ) and then discuss the generalization over @xmath45 for the ranked euclidean distance measure .",
    "we also stress that the implementation of this estimator is only based on the outputs of our corruption localization algorithm , which are computed before the imputation phase in the course of algorithm tcs .",
    "therefore , computationally , the imputation phase that we develop is efficient such that it does not require further computations .    *",
    "input : * @xmath82 ; @xmath83    initialize @xmath84 : set of corrupted attributes initialize @xmath85 : imputed test data create the root node @xmath86 and label create nodes @xmath87 and @xmath88 ; and label declare corruption at @xmath71 : @xmath89 impute attributes @xmath90 in @xmath46 declare corruption at @xmath91 : @xmath92 impute attributes @xmath93 in @xmath46 and    * return:*@xmath94 and @xmath46    since the only relevant part of the test instance @xmath6 to the proposed map estimator is @xmath80 , we have @xmath95 where @xmath96 represents a realization of the conditional probability density of the true data underlying the corrupted attributes @xmath90 .",
    "then , the map estimator of @xmath96 maximizes the posterior distribution as @xmath97 for any @xmath98 , and under certain smoothness constraints on @xmath5 with @xmath99 , let @xmath100 hold with some probability @xmath101 , where @xmath102 ( w.r.t . the standard euclidean distance ) is the @xmath103-ball around @xmath96 in @xmath104 and @xmath105 .",
    "then we point out that @xmath106 hence , since @xmath103 can be made arbitrarily small , we obtain @xmath107 and by the bayes rule @xmath108 with probability @xmath54 , where the denominator is dropped since it does not depend on the maximizer , i.e. , @xmath96 . to approximate the map estimator given in , we adapt the nonparametric k - nearest neighbor ( knn ) based density estimation approach @xcite .",
    "let us define a small neighborhood around @xmath80 in @xmath109 as @xmath110 where @xmath111 is the euclidean distance and @xmath112 is the @xmath111 distance from @xmath113 to its nearest @xmath114th neighbor in @xmath115 for some @xmath116 .",
    "note that as @xmath117 , @xmath118 , where @xmath119 is the lebesgue measure",
    ". then yields @xmath120 with probability @xmath54 .",
    "when @xmath121 is sufficiently large with @xmath122 for some @xmath123 or @xmath124 is sufficiently small , we assume that @xmath125 is subject to negligible variations only . then , we ( with probability @xmath54 ) obtain the approximation : @xmath126 where , in order to obtain the corresponding maximum in the reference set @xmath38 , knowing the rank statistics in @xmath127 is enough , i.e. , explicitly estimating / computing the density is unnecessary .",
    "therefore , using the density function defined in , we obtain @xmath128 for sufficiently large @xmath121 , note that @xmath129 approximates @xmath130 @xcite , i.e. , @xmath131 @xmath132 based on which we replace , i.e. , impute , the corrupted attributes @xmath79 in the instance @xmath6 with @xmath133 and obtain the imputed data as @xmath46 .",
    "this estimator is implemented in algorithm tcs ( tree - based corruption separation ) at every node in the tree , where a corruption is detected .",
    "namely , we i ) obtain the @xmath37 neighbors of the test instance in the reference data set @xmath38 with respect to the attributes associated with the node @xmath81 ; ii ) for those neighbors in @xmath38 , find the one , say @xmath134 , attaining the largest score value defined in using the attributes associated with the parent node @xmath135 ; then iii ) impute the instance @xmath6 , which is detected to be corrupted at the node @xmath71 , using @xmath134 for the attributes @xmath136 . in the realistic case of high dimensional and limited data , when the standard euclidean distance is used as in our derivations ,",
    "@xmath80 might include corrupted attributes even though it is detected as normal , which clearly adversely affects the calculation of the neighborhood @xmath137 in .",
    "in addition , @xmath76 might only include a small support of corruption , and then we would not like to impute @xmath76 completely . to overcome these two issues , we propose to use the ranked euclidean distance defined in .",
    "to this end , the neighborhood @xmath137 is defined using @xmath55 with an appropriate @xmath138 in .",
    "this cancels the adverse effect , up to a certain degree , of a possible corruption in @xmath80 as desired . nevertheless , recalling that @xmath55 only uses the @xmath45 fraction of the attributes @xmath139 and set the others free ,",
    "@xmath75 is not a metric in the mathematical sense and then , as @xmath117 , @xmath118 does not hold . as a result ,",
    "the correlation structure given in is less exploited in imputation as @xmath45 decreases . meanwhile , as @xmath45 decreases , the support of the detected corruption in @xmath140 increases , i.e. , localization improves .",
    "therefore , we obviously have a trade - off between the imputation quality and the localization , which is sensitive to the choice of @xmath45 and investigated in the experiments in greater detail .",
    "however , @xmath45 should be set typically around @xmath141 since we use half - way splits .",
    "finally , note that the imputation brings almost no further computational complexity , since these steps do computationally only depend on the anomaly detection results , cf . and , at the corrupted node , its sibling node as well as its parent node , which are all generated prior to the imputation steps .    in the following section ,",
    "the proposed framework is shown to achieve a constant false alarm rate in terms of the corruption detection . moreover ,",
    "this false alarm rate is precisely calculated under a certain dependency structure among the anomalous / normal labels on the partitioning tree .      since the imputation is an  overwriting \" operation , whether or not to impute a suspicious instance is certainly a ",
    "critical \" decision . in case of a false decision",
    "if the suspicious instance is in fact uncorrupted , i.e. ,  a false alarm in detecting corruptions \" , the imputation would correspond to data loss . in this section",
    ", we study the rate of such occurrences and analyze the false alarm rate of the proposed algorithms in detecting corruptions .",
    "the anomaly detection test applied at every node in algorithm tcs ( tree - based corruption separation ) operates with a constant false alarm rate @xmath33 , whereas the proposed approach is able to reject corruptions at anomalous nodes .",
    "for example , when the terminating pattern in fig .",
    "[ fig : simplecorruption]b is encountered , all the anomalies that can be present in the tree rooted from the terminating pattern are rejected , i.e. , they are not counted as corruptions .",
    "for this reason , the false alarm rate of the proposed approach must be defined in the sense of corruptions as opposed to anomalies . to analyze this false alarm rate in detecting corruptions ,",
    "one also must account for that the anomaly detection test at a node could be strongly correlated with the outputs of the previous tests in the course of algorithm tcs , since the data attributes are in general correlated . in this section ,",
    "we first model the labeling of the nodes , i.e. , anomalous vs normal , on the partitioning tree , cf .",
    "[ fig : example1 ] , as a directed acyclic graph @xcite achieving a certain dependency structure and then derive the false alarm rate of algorithm tcs . under this modeling , we also show that the constant false alarm rate in detecting the local anomalies at each node globally maps to also a constant false alarm rate in detecting the corruptions .",
    "recall that algorithm tcs expands the binary tree in fig .",
    "[ fig : example1 ] for a given uncorrupted test instance @xmath142 and declares a corruption only if the conclusive pattern in fig .",
    "[ fig : simplecorruption]a is encountered or a leaf node is found anomalous in the described breadth - first search .",
    "in addition to the corruption localization as well as the imputation capabilities of the proposed algorithm tcs , let us denote the corruption detection in algorithm tcs by @xmath143 , if @xmath142 is detected to be corrupted and @xmath144 , otherwise .",
    "then our task is to find the false alarm probability in detecting the corruptions , which is given by @xmath145 where @xmath33 is the constant false alarm rate of the detection at each node and @xmath5 is the nominal density .",
    "next , we observe that algorithm tcs maps every data instance to a binary observation such that the nominal distribution @xmath5 is transformed into a multivariate bernoulli distribution @xmath146 , i.e. , @xmath147 where @xmath148 , @xmath70 is the depth and @xmath149 is the anomaly decision at the root node such that @xmath150 , if an anomaly detected ; and @xmath151 , otherwise .",
    "similarly for the others such as @xmath152 is the decision at the left hand child of the root and @xmath153 is the decision at the right hand child .",
    "note that the proposed algorithm does not completely construct the binary tree but expands , i.e. , the nodes and the edges are created as needed .",
    "therefore , we do not completely observe the binary vector @xmath154 that an instance @xmath142 maps to , however , we temporarily suppose that all the labels are available for ease of exposition .",
    "once @xmath142 is mapped to @xmath154 , since algorithm tcs declares a corruption based on only the vector of binary labels @xmath154 , we equivalently have @xmath155 where @xmath156 is the corruption decision ( with abuse of notation ) , @xmath157 is the complement , i.e. , @xmath158 and @xmath146 is the corresponding nominal probability mass function such that @xmath159 in order to calculate the probability mass function @xmath146 , we model the binary tree , where each node corresponds to a binary random variable , as a directed acyclic graph @xcite such that the binary random variables at any two sibling nodes are independent conditioned on the knowledge of the label at the parent node .",
    "namely , for any non leaf node @xmath71 and its children @xmath160 and @xmath161 on the binary partitioning tree , we assume the following conditional independency for the associated random labels : @xmath162 , from which we obtain @xmath163 cf . fig .",
    "[ fig : dag ] .    here , we emphasize that @xmath142 ( or @xmath154 ) is assumed to be uncorrupted in the false alarm analysis to calculate the probability given in , i.e.",
    ", it does not have any localized corruptions by definition . then",
    ", if @xmath142 is declared , at the root node without loss of generality , as anomalous then this anomaly is not due to a corruption but simply a  rarity \" as the test in is based on density levels . on the contrary to the case of corruption ,",
    "since a  rarity \" at a node is not a localized phenomenon , we expect that the children inherit the parent label independently .",
    "therefore , we assumed the conditional independency in as a generating dependency structure for the simplest graph presented in fig .",
    "[ fig : dag ] , which straightforwardly generalizes to the binary tree of the anomalous vs normal labels from root to the leaves . based on this",
    ", we obtain @xmath164 where @xmath165 is the collection of the binary variables associated with the nodes in the tree rooted from node @xmath62 that excludes @xmath149 , and the last equation follows from and the bayes rule .",
    "we observe that the starred factors in the expression are of similar forms such that the last equation can be expanded further using similar lines of derivations up until the leaves appear .",
    "thus , the calculation of @xmath166 requires the calculation of the probabilities of the form @xmath167 or @xmath168 , e.g. , @xmath169 in .",
    "let us denote any child of the node @xmath71 by @xmath81 for generalization .",
    "note that if @xmath170 and @xmath171 were independent then we would have @xmath172 when @xmath173 .",
    "however , we anticipate a statistical dependency between @xmath170 and @xmath171 generating a positive covariance .",
    "that is , conditioned on the knowledge of @xmath170 , we would like to impose that @xmath171 is more likely to attain the value @xmath174 compared to the prior conditions , i.e. , @xmath81 is likely to inherit the label of its parent . on the other hand , provided that @xmath170 and @xmath171 are identically dependent , we would have that @xmath175 , where @xmath176 is the indicator function . to introduce this into the derivations , we parameterize the probability mass function @xmath177 as the weighted average between @xmath178 and @xmath179 as @xmath180 where @xmath181 $ ] is a parameter defining the degree of dependency which generates an increasing covariance as @xmath182 increases in the interval @xmath183 $ ] such that @xmath184 implies the statistical independency of @xmath170 and @xmath171 ; and @xmath185 implies identical dependency .",
    "then , the probability mass function @xmath166 can be calculated using this parametrization based on the recursion in @xmath186 .",
    "hence , exhaustively enumerating all possible @xmath154 s and running algorithm tcs for each of them , one can calculate the false alarm rate @xmath187 in , which is not a practical choice . instead , through the conditional factorization in",
    ", we opt to simplify the expression and obtain an efficient recursion . to this end , for a given node @xmath71 with depth @xmath188 , let us define the probability conditioned on @xmath174 that algorithm tcs does not declare a corruption in the tree rooted from @xmath71 denoted by @xmath189 as @xmath190 here , @xmath189 solely depends on the depth variable @xmath191 due to the symmetric factorization by the conditional independency from parents to children .",
    "therefore , the notation simplifies to @xmath192 or @xmath193 . using the @xmath194 possible configurations for @xmath195",
    ", we can calculate @xmath192 as a function of @xmath196 .",
    "noting that two of those configurations are the conclusive patterns , termination and corruption patterns , we obtain @xmath197 where @xmath198 as a short hand notation ; the second term corresponds to the continuation of algorithm tcs and the first term corresponds to the terminating pattern .",
    "unlike the second term , the first term does not have a multiplier since the search stops at such a node .",
    "note that the corruption pattern is disregarded by definition .",
    "similarly , we also have @xmath199 recalling that we declare corruptions at leaf nodes on the basis of local anomalies , we can further define @xmath200 and provide the initialization to the recursion @xmath192 and @xmath193 . on the other hand , we never declare corruptions at root since we are focused only on localized corruptions , which is an exception and can straightforwardly incorporated in our recursions . in terms of the recursions regarding @xmath192",
    ", the only change is that the corruption pattern should not be disregarded which does not lead to a corruption detection and so does not stop the search .",
    "then , we simply have @xmath201 and the recursion @xmath193 stays valid for @xmath202 . now that we have the recursion equations defined for all depth levels on the binary tree",
    ", we can efficiently calculate the false alarm rate of algorithm tcs as follows . letting @xmath62",
    "represent the root node , we obtain from @xmath203 then , recalling that @xmath204 , the false alarm rate @xmath187 is given by @xmath205 which is equivalent to first calculating the probability that algorithm tcs never declares a corruption and then subtracting this probability from @xmath54 .",
    "we point out that the false alarm rate @xmath187 of algorithm tcs ( tree - based corruption separation ) in detecting the corruptions as found in is a data - independent quantity . therefore , under the simplification through the conditional independency , we conclude that the false alarm rate @xmath33 of the anomaly detection at each node maps to a constant false alarm probability of our corruption detection @xmath187 . secondly ,",
    "even though the dependency parameter @xmath182 does not appear , i.e. , hidden , in the expression , @xmath187 is clearly affected by @xmath182 .",
    "for example , if @xmath185 , i.e. , if the binary label of a child node is identically dependent on the parent label and hence @xmath206 , then it can be shown that @xmath207 . if @xmath184 , i.e. , if the binary label of a child node is independent with the parent label and hence @xmath208 , then obviously @xmath209 . in fig . [",
    "fig : dagfig ] , we plot the hypothetical curves resulted from mapping the constant false alarm rate @xmath33 in detecting the local anomalies to the corruption false alarm rate @xmath187 via the described model of conditional independency for several degree of dependencies @xmath182 .",
    "we experimentally discuss the efficacy of this model in representing the relation between @xmath33 and @xmath187 in section [ sec : experiments ] .",
    "moreover , the parameter @xmath182 between @xmath174 and @xmath171 can also be chosen depth dependent , i.e. , @xmath210 , instead of a uniform choice over the partitioning tree .",
    "an example of a depth dependent modeling is given in section [ sec : experiments ] .",
    "finally , note that the directed acyclic graph modeling of the anomalous vs normal labeling uniformly holds for all @xmath45 s in choosing the ranked euclidean distance .",
    "we also discuss the impact of various @xmath45 s on the fitness of the described dependency structure in section [ sec : experiments ] .    in the following section , we explain the important points of our implementation and discuss the corresponding computational complexity .",
    "computationally , the main building block in algorithm tcs ( tree - based corruption separation ) is the application of the anomaly test defined in , which computes the train - to - train distance matrix @xmath211 and the test - to - train distance vector @xmath212 .",
    "operating on these distances , the score function defined in for the test instance must be computed , which then requires the computation and sorting of @xmath213 .",
    "in addition , since we label each node as anomalous or not in our tree expansion , these distances must actually be computed at each node with respect to the corresponding attributes , e.g. , @xmath214 and @xmath215 at a node @xmath71 . for this purpose",
    ", we adapt the  integral image \" approach in case of using the standard euclidean distance .",
    "namely , let us define the volume @xmath216 , @xmath217 with @xmath218 ; and @xmath219 , @xmath217 ( similarly for @xmath220 ) .",
    "then , we simply have @xmath221 at a node @xmath71 , where @xmath136 corresponds to the set of attributes in positions between @xmath222 and @xmath223 .",
    "the volume @xmath224 and the sorting of @xmath213 can be computed offline once the training set is provided , which defines a training phase complexity @xmath225 , where sorting is the dominant contributor . for a given test instance",
    ", we compute @xmath226 and sort at each node @xmath71 in the expansion of our tree , which defines the test phase complexity @xmath227 for our algorithm , where sorting is the dominant contributor . in case of using the ranked euclidean distances ,",
    "since it is not possible to utilize the integral image approach anymore , the computational load is multiplied by constant factors .",
    "next , we illustrate the efficacy of the proposed framework in separating , i.e. , detecting and localizing , corruptions and imputing .",
    "in this section , we test the introduced algorithm tcs ( tree - based corruption separation ) over several well - known machine learning data sets subject to synthetically generated data corruptions to demonstrate the performance of the proposed approach .",
    "we first discuss the efficacy of the false alarm rate estimation method explained in section [ sec : acf ] in terms of the corruption detection and evaluate the performance of the critical steps in algorithm tcs , which are the corruption detection , localization and imputation .",
    "then , we report the improvements achieved by the proposed framework in several classification tasks .    in the first set of experiments , we adapted a @xmath228 digit classification task consisting of a training set of @xmath229 samples and a test set of @xmath230 samples based on the usps data @xcite .",
    "each of these samples is a @xmath231 gray scale image of either a  0 \" image or a  1 \" image , where each pixel has a real intensity value in [ 0,1 ] .",
    "we synthetically generate a corruption as described in section [ sec : pd ] and apply to each instance in the test set with probability @xmath232 . to be more precise , for a test instance chosen to be corrupted ,",
    "we ( uniformly ) randomly specify a square region of size between @xmath233 of the total area , i.e. , the number of pixels in the chosen region is not less than @xmath234 and not more than @xmath235 , overwrite each pixel in this region with a value randomly ( using the uniform distribution @xmath26 ) drawn from the interval @xmath183 $ ] . then , after the training and test instances are vectorized column wise such that @xmath236 , the proposed algorithm tcs is provided with the clean training data and run over the test set .",
    "we emphasize that by this vectorization scheme , the corrupted square region corresponds to multiple corrupted intervals in the vectorized observation .",
    "hence , this example also illustrates that algorithm tcs can handle multiple corruptions .",
    "ideally , the neighborhood size parameter @xmath37 for both imputation and corruption separation purposes should be optimized at every node of our binary tree since the data dimensionality from node to node varies .",
    "however , we opt not to optimize @xmath37 for presentational clarity and set as @xmath237 near the midpoint of @xmath238 $ ] , which is empirically found appropriate . using the @xmath228 digit usps data ,",
    "we investigate the response of the algorithm tcs to the local anomaly detection false alarm rate @xmath239 and the ranked euclidean distance parameter @xmath240 . as for the depth parameter",
    ", we use the deepest possible tree with @xmath241 such that the leaves are associated with @xmath194 pixels and hence , @xmath54 pixel at least is then used in the distance calculation with @xmath242 .",
    "= 6.4 cm    in fig .",
    "[ fig : dagfig ] , we compare the hypothetical false alarm rate @xmath187 we derive in section [ sec : acf ] with the corresponding experimental realizations with respect to varying local anomaly detection false alarm @xmath243 . the hypothetical map from @xmath33 to @xmath187",
    "is generated with several choices for the dependency parameter , @xmath244 , whereas the realizations correspond to several choices for the distance parameter , @xmath245 .",
    "our experiments indicate that when the statistical dependency @xmath182 in from a parent node to one of its children nodes , cf .",
    "[ fig : dag ] , is chosen around @xmath246 , the relationship between the local anomaly false alarm rate @xmath33 and the corruption detection false alarm rate @xmath187 is accurately modeled .",
    "this experimentally shows that the labeling of local anomalies over a binary partitioning tree shown in fig .",
    "[ fig : example1 ] can be considered as a directed acyclic graph .",
    "we also observe that in the case of euclidean distance , i.e. , @xmath55 with @xmath56 , while @xmath247 is more accurate for small @xmath33 s , @xmath182 tends to approach @xmath248 as @xmath33 increases for a better modeling .",
    "this small deviation mainly happens since the conditional independency assumption explained in fig .",
    "[ fig : dag ] do not hold in case of euclidean distance for a certain pattern .",
    "namely , although the labeling for a parent and its children nodes as @xmath249 ( a normal parent node with anomalous children nodes ) is not possible with the standard euclidean distance due to the test defined in , the directed acyclic graph modeling assigns it a positive probability , which then overestimates the corruption detection false alarm rate .",
    "nevertheless , this positive probability is the smallest among the ones assigned to the all possible patterns of three nodes as desired and hence , the ordering of the patterns in terms of their probabilities is still reasonable even in the case of the euclidean distance . on the contrary , since this pattern is also possible in case of the ranked euclidean distance , the accuracy of our hypothetical results improves as @xmath45 decreases .",
    "= 6.1 cm    next , we study the corruption detection and localization performance of our algorithm on the @xmath228 digit usps data . in fig .",
    "[ fig : roc ] , we plot the empirical false alarm rates versus the empirical true detection rates in terms of both corruption detection and corruption localization with respect to @xmath243 . here , the true detection rate is the empirical probability , i.e. , relative frequency , of a truly corrupted data instance ( data attribute in case of localization ) to be declared corrupted and , the false alarm rate is the empirical probability of a truly uncorrupted data instance ( data attribute in case of localization ) to be declared corrupted . as we discuss in section [ sec : thethemethod ] , the ranked euclidean distance is experimentally shown to produce a better detection as well as localization performance on the usps data as @xmath45 decreases .",
    "recall that for a small @xmath45 around @xmath250 , we enforce a corruption to be widely spread for algorithm tcs to detect it at a node , which then clearly improves the localization .",
    "similarly , the corruption detection performance also improves as @xmath45 decreases .",
    "since the ranked euclidean distance disregards a certain fraction of largest attribute - wise deviations , algorithm tcs behaves conservatively in declaring corruptions .",
    "this reduces the false alarms in terms of the local anomalies and in turn , reduces the false encounters of the terminating pattern shown in fig .",
    "[ fig : simplecorruption]b .",
    "hence , the corruption search is not stopped mistakenly , and algorithm tcs does not miss certain corruptions , which leads to a better detection rate with the ranked euclidean distance using a small @xmath45 around @xmath250 .",
    "we emphasize that the local anomaly detection false alarm rate @xmath33 can be set independently for detection and localization to precisely determine the operating point on the roc curves in fig .",
    "[ fig : roc ] .",
    "however , in this study , we use one single @xmath33 in all phases of algorithm tcs . note that when the false alarm rate is set around @xmath251 , our algorithm is able to provide a detection rate around @xmath252 and a localization rate around @xmath248 .",
    "= 9.0 cm = 5.0 cm    on the other hand , the ranked euclidean distance parameter @xmath45 can not be made arbitrarily small since , as @xmath45 decreases , the determination of the neighbors of a test instance in the reference set degrades and hence , the imputation quality is adversely affected .",
    "observe that with small @xmath45 , only a small fraction of attributes are used in determination of @xmath137 in despite that the rest of the attributes might be informative through the local correlations and hence , the imputation quality degrades .",
    "we illustrate this effect in fig .",
    "[ fig : impqual ] , where we use the improvements in the distance wise deviations after imputation to measure the imputation quality . for this purpose ,",
    "we define @xmath253 as the distance wise imputation quality , where @xmath254 is the number of the corrupted test instance ( which is approximately @xmath255 ) , @xmath256 is a corrupted test instance , @xmath257 is the uncorrupted original instance and @xmath258 is the corresponding instance after imputation . note that this quality metric measures on average that how much of the distortion by the corruption is recovered after imputation .",
    "the average imputation quality defined in is plotted versus the local anomaly detection false alarm @xmath243 in fig .",
    "[ fig : impqual ] .",
    "we first observe that for large @xmath33 , since the false alarm rate is also large , the imputation even further disturbs the data .",
    "secondly , for small @xmath33 around @xmath259 , the proposed imputation technique is able to correct a corrupted instance up to @xmath260 in case of @xmath261 .",
    "moreover , our experiments also indicate that for @xmath45 less than @xmath250 , the ranked euclidean distance is not able to produce desirable results despite its superiority in terms of detection and localization , which reinforces our discussion about that @xmath45 can not be made too small .    unlike an mmse based approach",
    ", our map based imputation does not target minimizing the reconstruction error but the most likely replacement for a corruption .",
    "therefore , the distance - wise imputation quality measure in is not fair to use for a comparison .",
    "indeed , an mmse based estimator for imputation would produce visually blurry results , for instance on the usps data . in this",
    "regard , we present several visual examples that the proposed framework generates on the usps data with @xmath262 in fig .",
    "[ fig : visualexamples ] .",
    "note that the presented visual examples tend to generate image gradients that are naturally aligned with the image statistics , since our imputation method is not based on an averaging to minimize the reconstruction error but filling in the missing part with the most likely candidate extracted from the reference data .",
    "we also observe some cases , where the corruption along a border between the cells of our partitioning tree remains after the imputation , cf .",
    "the second last column in fig .",
    "[ fig : visualexamples ] . the residual corruptions in such cases can be handled by increasing the depth of the tree or using m - ary trees as opposed to binary splits , which is not in the scope of this study .",
    "in addition to the visual comparisons , we also evaluate the performance of the introduced framework in terms of the classification purposes . on the described @xmath228 digit usps data , we report the data scatter plots of the test instances in fig . [",
    "fig : thesep ] , where we project the original , corrupted and imputed test data onto the two eigen vectors of the training set with the largest eigenvalues for visualization .",
    "we clearly observe a better class separation between two classes after the imputation , when compared to the class separation in the corrupted data .",
    "the distance between the class means is calculated to be @xmath263 in the original uncorrupted data , @xmath264 in the corrupted data and @xmath265 after the imputation .",
    "this approximately corresponds to a @xmath266 performance improvement achieved by the proposed framework both in terms of the mean separation and classification accuracy , cf .",
    "[ fig : thesep ] .",
    "[ cols=\"^,^,^ \" , ]     [ table : impute ]    our algorithms ,  tcs - map \" ( tree - based corruption separation with map imputation ) , perform significantly better than the method ",
    "m - nn \" and comparably with the method  tcs - nn \" .",
    "we point out that the method  tcs - nn \" strongly relies on the proposed algorithm tcs , which is the reason underlying the success of  tcs - nn \" since the method ",
    "m - nn \" is outperformed by  tcs - nn \" ( both of the methods  m - nn \" and  tcs - nn \" uses the nn imputation but  m - nn \" does not have the proposed tree - based corruption separation step ) . the method ",
    "m - nn \" occasionally even further corrupts the data , cf .",
    "the negative improvements for sonar or g241c or g241n .",
    "moreover , it is difficult to choose between the methods  4-nn \" and  16-nn \" since there is no clear superiority .",
    "namely , there is definitely a scaling issue for the method ",
    "if the corruption in an instance covers a small portion , e.g. , @xmath267 , then choosing @xmath268 too large would leave several undetectable corruptions in addition to imputing large chunks of clean data due to the false alarms ( negative improvements ) .",
    "similarly , if the corruption in an instance covers a large portion , e.g. , @xmath269 , then choosing @xmath268 too small would not only again harden the anomaly detection ( due to the use of insufficient data in detecting corruptions ) but also complicate the imputation since on what to condition the imputation becomes ambiguous .",
    "for a good imputation in this case , one would need to identify ( with significant imperfections due the use of insufficient data because of a small @xmath268 ) all the corrupted and uncorrupted segments ; and then condition the imputation on uncorrupted ones , which leads to a non - homogenous different evaluation for every instance that requires computationally a very high load .",
    "therefore , choosing an appropriate @xmath268 is in general hard since it must depend on the amount of the corruption , which might be unknown and random .",
    "the proposed framework resolves this scaling issue in a computationally efficient way via the binary searches and fast imputations .",
    "moreover , our algorithm  tcs - map \" is experimentally shown to be also robust to corruptions in training data in the sense that it strongly preserves its corruption separation / imputation capabilities even after including @xmath270 corruptions in training .",
    "lastly , our estimator that is used for imputation asymptotically ( as the data size increases ) recovers the true map estimator ; and the nn estimator is certainly asymptotically sub - optimal both in the mean square error ( mse ) and the likelihood maximization sense .",
    "however , the map imputation and the nn imputation ( only when combined with the proposed tree based corruption separation ) performs comparably in our experiments , which is due to the sparsity of the data compared to the dimensionality .",
    "we first note that the map estimator yields the nn estimator , if the neighborhood size is set @xmath271 in the imputation phase , which can easily be achieved via cross validation for @xmath37 .",
    "clearly , with such a cross validation , the map imputation can only perform better than the nn imputation and we opt not to optimize @xmath37 for presentational clarity .",
    "additionally , the nn imputation is definitely sensitive to corruptions in the training data since the attributes of the nearest neighbor that are used for imputation can also be corrupted with a certain probability , e.g. , with probability @xmath272 in our experiments . on the other hand ,",
    "that possibly ( with probability @xmath272 ) corrupted nearest neighbor would achieve a lower score value @xmath59 if it was truly corrupted and it would not be picked by our map estimator for imputation .",
    "thus , the proposed map estimator can handle such situations and is robust to corruptions , where the nn imputation performance potentially degrades more .",
    "in fact , in our experiments , the map imputation either enhances its superiority or becomes superior or approaches nn imputation for most of the data sets after including corruptions in training , e.g. , image or ringnorm data sets in table [ table : nonlin ] .    to further demonstrate the power of the proposed estimator",
    ", we devise a separate experiment , where we use a data set consisting of two gaussian components with unitary covariances .",
    "we use the means @xmath273 $ ] and @xmath274 $ ] for positive and negative classes , respectively .",
    "we generate @xmath275 samples as the training data , ( @xmath276 for each class ) , and next suppose that the second attribute of each sample is corrupted / missing ; and therefore imputed by our map estimator with varying neighborhood size @xmath37 and the nn estimator .",
    "note that in this part , we use standard euclidean distance only . after repeating this @xmath277 times ,",
    "the resulting imputed data is compared to the original training data in the mse sense and in terms of the classification accuracy .",
    "we summarize our findings in table [ table : impute ] , where the map imputation with @xmath271 coincides with the nn imputation .",
    "the map imputation is consistently better than the nn imputation as expected .",
    "for instance , when @xmath278 , we obtain @xmath279 improvements in the mse sense ; and @xmath267 improvements in terms of the classification ( original classification accuracy is around @xmath280 ) .",
    "in this paper , we proposed a comprehensive framework for handling localized and severe data corruptions .",
    "the novel contributions of the proposed framework includes ( i ) a first algorithm to jointly detect and localize such corruptions by identifying the local anomalies , ( ii ) a _ maximum a posteriori _ based estimator for imputation ; and a distance measure for corruption separation purposes , ( iii ) computational efficiency via the binary searches and the fast imputations , and ( iv ) a characterization for anomalous observations , e.g. , rarities , incompatible combinations and corruptions .",
    "we point out that our algorithm does not assume prior information or a model for the input data and instead , works in a completely data driven way .",
    "furthermore , we conducted a false alarm rate analysis and showed that the desired false alarm rate in detecting corruptions can be set independently with the input data .",
    "our algorithm is tested against the synthetically generated corruptions in several well - known machine learning data sets and experimentally shown to provide signicant improvements in terms of classication purposes with strong corruption separation capabilities .",
    "the proposed algorithms outperform the typical approaches and are robust to varying training phase conditions .",
    "stefanos zafeiriou , georgios tzimiropoulos , maria petrou , and tania stathaki , `` regularized kernel discriminant analysis with a robust kernel for face recognition and verification , '' , vol .",
    "3 , pp . 526534 , 2012 .",
    "roberto perdisci , guofei gu , and wenke lee , `` using an ensemble of one - class svm classifiers to harden payload - based anomaly detection systems , '' in _ sixth international conference on data mining .",
    "ieee icdm06 .",
    "_ , 2006 , pp . 488498 .",
    "david heckerman , david  m. chickering , christopher meek , robert rounthwaite , and carl kadie , `` dependency networks for inference , collaborative filtering , and data visualization , '' , vol .",
    "1 , pp . 4975 , 2001 .",
    "nelson  h. yung and andrew  h. lai , `` detection of vehicle occlusion using a generalized deformable model , '' in _ proceedings of the ieee international symposium on circuits and systems _ , 1998 ,",
    ".  4 , pp ."
  ],
  "abstract_text": [
    "<S> we introduce a comprehensive and statistical framework in a model free setting for a complete treatment of localized data corruptions due to severe noise sources , e.g. , an occluder in the case of a visual recording . within this framework </S>",
    "<S> , we propose i ) a novel algorithm to efficiently separate , i.e. , detect and localize , possible corruptions from a given suspicious data instance and ii ) a _ maximum a posteriori _ ( map ) estimator to impute the corrupted data . as a generalization to euclidean distance </S>",
    "<S> , we also propose a novel distance measure , which is based on the ranked deviations among the data attributes and empirically shown to be superior in separating the corruptions . </S>",
    "<S> our algorithm first splits the suspicious instance into parts through a binary partitioning tree in the space of data attributes and iteratively tests those parts to detect local anomalies using the nominal statistics extracted from an uncorrupted ( clean ) reference data set . </S>",
    "<S> once each part is labeled as anomalous vs normal , the corresponding binary patterns over this tree that characterize corruptions are identified and the affected attributes are imputed . under a certain conditional independency structure assumed for the binary patterns , </S>",
    "<S> we analytically show that the false alarm rate of the introduced algorithm in detecting the corruptions is independent of the data and can be directly set without any parameter tuning . </S>",
    "<S> the proposed framework is tested over several well - known machine learning data sets with synthetically generated corruptions ; and experimentally shown to produce remarkable improvements in terms of classification purposes with strong corruption separation capabilities . </S>",
    "<S> our experiments also indicate that the proposed algorithms outperform the typical approaches and are robust to varying training phase conditions .    </S>",
    "<S> localized corruption , occlusion , map based imputation , anomaly detection . </S>"
  ]
}