{
  "article_text": [
    "consider a network , represented as a finite graph @xmath1 , where the vertices are unlabeled , and edge labels are possibly not unique . in @xmath1 operate @xmath2 _ oblivious mobile robots _ ( or simply `` robots '' ) , that is , indistinguishable computational entities with no memory , located at the vertices of the network , and capable of moving from vertex to neighboring vertex of @xmath1 .",
    "robots are activated by an adversarial _ scheduler _ @xmath3 . whenever activated",
    ", a robot observes the location of the other robots in the graph ( the current _ configuration _ ) ; it computes a destination ( a neighboring vertex or the current location ) ; and it moves there .",
    "the computation of the destination is made by executing an algorithm , the same for all robots , whose sole input is the current configuration .",
    "the current activity terminates after the move , and no memory of the computation is retained ; in other words , the entities are _ stateless_. the overall system is represented by the triplet @xmath4 .",
    "notice that , even if the algorithm @xmath5 the robots execute is deterministic , its executions may still be non - deterministic . indeed , since the network s port numbers may not be unique",
    ", it may be impossible for an algorithm to unambiguously indicate where each robot has to move .",
    "this model , introduced by klasing , markou , and pelc @xcite as an extension of the model of oblivious robots in continuous spaces ( e.g. , @xcite ) , has been extensively employed and investigated , focusing on basic problems in specific classes of graphs under different schedulers : _ gathering _ and _ scattering _",
    "( e.g. , @xcite ) , and _ exploration _ and _ traversal _",
    "( e.g. , @xcite ) . note that , with the exception of @xcite , the literature assumes unlabelled edges . in this paper",
    ", we consider both labelled and unlabelled edges , and focus on the fully synchronous scheduler @xmath6 , which simply activates every robot at every turn .",
    "we then embark on a different , more general , type of investigation .",
    "consider the system @xmath7 .",
    "whenever the robots move in the graph according to algorithm @xmath5 , the system transitions from the current configuration to a ( possibly ) different one .",
    "the obliviousness of the robots implies that always the same ( or equivalent ) transition occurs from the same given configuration .",
    "consider now the _ configuration graph _ where there is a directed edge from one configuration to another if some algorithm dictates such a transition .",
    "then the execution of @xmath5 in @xmath7 from a given configuration is just a walk in this graph from that configuration .",
    "the execution can be viewed in a natural way as the computation of a discrete function @xmath8 by the system , where @xmath8 maps a configuration @xmath9 into the configuration @xmath10 reached by executing ( one step of ) @xmath5 from @xmath9 , defining a subgraph of the configuration graph , called function graph .",
    "the concept of function computation and function graph are formally defined in section  [ s2 ] .",
    "we seek to understand which functions are computed by which systems . knowing the structure of such functions gives us information on the robots behavior as they execute an algorithm , and what tasks the robots can and can not perform in a network .",
    "for instance , if an algorithm computes a function whose graph has no cycles , it means that the robots will eventually be stationary regardless of their initial position ; if the function has a unique fixed point , it means that the algorithm solves a _ pattern formation _ problem .",
    "on the other hand , if the function s graph has only cycles of length @xmath11 ( possibly with some `` branches '' attached ) , the robots are collectively implementing a _ self - stabilizing clock _ of period @xmath12 .",
    "if such graphs can be embedded in the configuration graph , then we know that such algorithms exist , and that the corresponding problems are solvable in the system .",
    "in this paper we focus on identifying sets of systems that are _ universal _ , in the sense that they compute all finite functions . in section  [ s4 ] ,",
    "we identify several classes of universal fully synchronous systems .",
    "in particular , among other results , we prove that    the following families of systems are universal :    @xmath13 ,    @xmath14 ,    @xmath15 .    in section  [ s5 ] , we focus on computing discrete functions using the smallest possible networks , perhaps at the cost of employing a large numbers of robots .",
    "in particular , for a given finite set @xmath16 , we study the minimum size that a network must have for the robots to be able to compute all functions from @xmath16 to @xmath16 .",
    "we are able to approximate the minimum size of such a network up to a factor that tends to 2 as @xmath0 goes to infinity .",
    "the main tool we use in our investigation is the _ simulation _ between algorithms , which in turn defines _ domination _ between systems . if system @xmath17 dominates system @xmath18 , then @xmath17 computes at least all the functions computed by @xmath18 .",
    "the other tool is constituted by the _ path _ and _ ring _ graphs ( section  [ s3 ] ) .",
    "these are the main ingredients of all our stronger results , because rings and paths are fundamental topologies with important properties that can be extended to other graphs via simulation .",
    "in this section we introduce the models of mobile robots that we are going to study . informally , we consider networks with port numbers , which are represented as graphs where each vertex has a label on each outgoing edge .",
    "port numbers are not required to be unique , which allows us to model anonymous networks with unlabeled edges , as well .    on a network",
    "we may place any number of robots , which are indistinguishable mobile entities with no memory . at all times",
    ", each robot must be located at a vertex of the network , and any number of robots may occupy the same vertex .",
    "all robots follow the same algorithm , which takes as input the network and the robots positions , and tells each robot to which adjacent vertex it has to move next ( or it may tell it to stay still ) .",
    "time is discretized , and we assume that robots can move to adjacent vertices instantaneously .",
    "even if algorithms are deterministic , their executions may still be non - deterministic .",
    "this is partly because the network s port numbers may not be unique , and therefore it may be impossible for an algorithm to unambiguously indicate where each robot has to move .",
    "another potential source of non - determinism is the scheduler , which is an adversary that decides which robots are going to be activated next . in this paper",
    "we will focus on the fully synchronous scheduler , which simply activates every robot at every turn .",
    "we will also briefly discuss the semi - synchronous scheduler in section  [ s6 ] .",
    "[ [ labeled - graphs . ] ] labeled graphs . + + + + + + + + + + + + + + +    a _ labeled graph _ is a triplet @xmath19 , where @xmath20 is an undirected graph called the _ base graph _ , and @xmath21 is a function that maps each ordered pair @xmath22 , such that @xmath23 , to a non - negative integer called _ label_. a labeled graph is also referred to as a _ network_. a network is _ unlabeled _ if all its labels are equal .",
    "an _ automorphism _ of a labeled graph @xmath19 is a permutation @xmath24 of @xmath25 preserving adjacencies and labels , i.e. , for all @xmath26 , if @xmath23 , then @xmath27 and @xmath28 .",
    "if there exists an automorphism that maps a vertex @xmath29 to a vertex @xmath30 , then @xmath29 and @xmath30 are _ equivalent vertices _ in @xmath1 .",
    "the _ quotient graph _ @xmath31 is the labeled graph @xmath1 obtained by identifying equivalent vertices , and preserving adjacencies and labels .    [ [ configuration - spaces . ] ] configuration spaces .",
    "+ + + + + + + + + + + + + + + + + + + + +    let @xmath32 , for every @xmath33 .",
    "arrangement _ of @xmath2 robots on a network @xmath19 is a mapping from @xmath34 to @xmath25 .",
    "an arrangement specifies the locations of @xmath2 _ distinguishable _ robots on a network whose vertices are all _",
    "distinguishable_. however , we ultimately intend to model _ identical _ robots , which _ can not distinguish _ between equivalent vertices of the network , unless such vertices are occupied by different amounts of robots .",
    "the following definition serves this purpose : two arrangements @xmath35 , are _ equivalent _ if there exist an automorphism @xmath36 and a permutation @xmath37 of @xmath34 such that @xmath38 .",
    "the _ configuration space _ @xmath39 , where @xmath1 is a network and @xmath2 is a positive integer , is the quotient of the set of arrangements of @xmath2 robots on @xmath1 under the above equivalence relation between arrangements .",
    "the elements of the configuration space are called _ configurations_.    say that an arrangement @xmath40 is equivalent to itself under an automorphism @xmath24 and a permutation @xmath37 , as defined above . then , whenever @xmath41 and @xmath42 , we say that @xmath30 and @xmath43 are _ equivalent vertices _ in @xmath40 , and @xmath44 and @xmath45 are _ equivalent robots _ in @xmath40 .",
    "a class of _ indistinguishable _ vertices @xmath46 ( respectively , a class of _ indistinguishable _ robots @xmath47 ) of a configuration @xmath48 is a mapping from each arrangement @xmath49 to an equivalence class of vertices @xmath50 ( respectively , an equivalence class of robots @xmath51 ) of @xmath40 such that , for all @xmath52 and all automorphisms @xmath24 and permutations @xmath37 under which @xmath53 and @xmath54 are equivalent , @xmath55 ( respectively , @xmath56 ) .    [ [ configuration - graphs . ] ] configuration graphs .",
    "+ + + + + + + + + + + + + + + + + + + + +    while the configuration space contains all the configurations that are distinguishable , either by the base graph s topology , or by the labels , or by the robots positions , the _ configuration graph _ specifies which configurations can reach which other configurations `` in one step '' . of course , this depends on a notion of algorithm , and on a notion of scheduler .",
    "an _ algorithm _ for @xmath2 robots on a network @xmath1 is a function that maps a pair @xmath57 into a set @xmath58 , where @xmath48 ( describing the network s configuration at the moment the algorithm is executed ) , and @xmath46 and @xmath58 are classes of indistinguishable vertices of @xmath9 ( indicating the executing robot s location and its destination , respectively ) such that , for every arrangement @xmath49 and every vertex @xmath59 , there exists a vertex @xmath60 such that either @xmath61 or @xmath62 is adjacent to @xmath29 . according to this definition , a robot can only specify its destination as a class of indistinguishable vertices , representing either a null movement or a movement to some adjacent vertex .",
    "an _ execution _ for @xmath2 robots in a network @xmath1 is a sequence of configurations of @xmath39 .",
    "a _ scheduler _ for @xmath2 robots in a network @xmath1 is a binary relation between algorithms and executions .",
    "possible _ executions of an algorithm under some scheduler are the executions that correspond to the algorithm under the relation specified by such a scheduler .",
    "a _ system of oblivious mobile robots _ is a triplet @xmath63 , where @xmath1 is a labeled graph , @xmath64 , and @xmath3 is a scheduler for @xmath2 robots in @xmath1 .    the _ configuration graph _ @xmath65 , where @xmath63 is a system of oblivious mobile robots , is a directed graph on the configuration space @xmath39 , where @xmath66 if there is an algorithm @xmath5 and a possible execution @xmath67 of @xmath5 under @xmath3 , such that there exists an index @xmath68 satisfying @xmath69 and @xmath70 .",
    "the _ deterministic configuration graph _ @xmath71 , where @xmath63 is a system of oblivious mobile robots , is a directed graph on the configuration space @xmath39 , where @xmath72 if there is an algorithm @xmath5 such that , for all possible executions @xmath67 of @xmath5 under @xmath3 , and for every index @xmath68 satisfying @xmath69 , we have @xmath70 .    intuitively , @xmath73 is a subgraph of @xmath74 whose edges represent moves that can be deterministically done by the robots , i.e. , on which all the scheduler s choices yield the same result . if @xmath75 , then @xmath17 is said to be a _ deterministic _ system .    [ [ fully - synchronous - scheduler . ] ] fully synchronous scheduler .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    given an algorithm @xmath5 for @xmath2 robots on a network , we say that a configuration @xmath76 _ yields _ from a configuration @xmath9 under algorithm @xmath5 if , for every arrangement @xmath49 there is an arrangement @xmath77 such that , for every @xmath78 , either @xmath79 or @xmath80 is adjacent to @xmath81 and , if @xmath46 is the class of indistinguishable vertices of @xmath9 such that @xmath82 , then @xmath83 , where @xmath84 .",
    "the _ fully synchronous scheduler _",
    "@xmath85 is defined as follows : @xmath86 if , for every @xmath87 , @xmath88 yields from @xmath89 . in the rest of the paper , we will write @xmath90 instead of @xmath91 .    in other words ,",
    "the fully synchronous scheduler lets every robot move at every turn to the destination it computes .",
    "however , if a robot s destination consists of several indistinguishable vertices , the scheduler may arbitrarily decide to move the robot to any of those vertices , provided that it can be reached in at most one hop .",
    "all these choices are made by the scheduler at each turn and for each robot , independently .",
    "[ [ simulating - algorithms . ] ] simulating algorithms .",
    "+ + + + + + + + + + + + + + + + + + + + + +    to define the concept of simulation , we preliminarily define a relation on executions . given an execution @xmath67 for @xmath2 robots on a network @xmath1 , an execution @xmath92 for @xmath93 robots on a network @xmath94 , and a surjective partial function @xmath95 , we say that @xmath96 is _ compliant _ with @xmath97 under @xmath98 if either @xmath98 is undefined on @xmath99 , or there exists a weakly increasing surjective function @xmath100 such that , for every @xmath101 , @xmath98 is defined on @xmath89 , and @xmath102 .",
    "an algorithm @xmath5 under system @xmath17 _ simulates _ an algorithm @xmath103 under system @xmath18 if there is a surjective partial function @xmath95 such that each execution of @xmath5 under @xmath17 is compliant under @xmath98 with at least one execution of @xmath103 under @xmath18 .    in this definition ,",
    "@xmath98 `` interprets '' some configurations of the simulating system @xmath17 as configurations of the simulated system @xmath18 , in such a way that every configuration of @xmath18 is represented by at least one configuration of @xmath17 .",
    "moreover , the definition of compliance ensures that the simulating algorithm @xmath5 makes configurations transition in a way that agrees with @xmath103 under @xmath98 .",
    "[ [ computing - functions . ] ] computing functions .",
    "+ + + + + + + + + + + + + + + + + + + +    we define the implicit computation of a function as the simulation of a system consisting in a single robot on a network whose shape is given by the function itself .",
    "the network _ induced _ by a function @xmath104 is defined as @xmath105 , where @xmath106 .",
    "hence the base graph of @xmath107 has edges of the form @xmath108 , and the labeling @xmath21 makes all vertices of @xmath107 distinguishable from each other . the algorithm @xmath109 _ associated _ to the function @xmath8 is the algorithm for one robot on @xmath107 that always makes the robot move from any vertex @xmath110 to the vertex @xmath111 .",
    "we say that an algorithm @xmath5 _ computes _ a function @xmath104 under system @xmath17 if it simulates the algorithm @xmath109 under @xmath112 .",
    "what this definition intuitively means is that each element of @xmath16 is represented by a set of robot configurations ; an algorithm computes @xmath8 if any execution from a configuration representing",
    "@xmath110 eventually yields a configuration representing @xmath111 without passing through configurations that represent other elements of @xmath16 ( or that represent no element of @xmath16 ) .",
    "if an algorithm under system @xmath17 computes a function @xmath8 ( respectively , simulates an algorithm @xmath103 ) , then we say that @xmath17 computes @xmath8 ( respectively , simulates @xmath103 ) .",
    "moreover , a system @xmath17 _ dominates _",
    "@xmath18 if every algorithm under @xmath18 is simulated by some algorithm under @xmath17 .",
    "we use the notation @xmath113 to indicate all the concepts defined above : @xmath16 may be a function computed by an algorithm @xmath114 ( under some system ) , or it can be an algorithm simulated by @xmath114 , or a system dominated by a system @xmath114 , etc .",
    "the relation @xmath115 is transitive .",
    "let us prove that , if @xmath116 and @xmath117 , then @xmath118 , where @xmath5 is an algorithm under system @xmath63 , @xmath103 is an algorithm under system @xmath119 , and @xmath120 is an algorithm under system @xmath121 .",
    "all other cases ( i.e. , those involving functions or systems instead of only algorithms ) trivially follow from this basic case .    let the surjective partial function @xmath122 express the fact that @xmath5 simulates @xmath103 , and let the surjective partial function @xmath123 express the fact that @xmath103 simulates @xmath120 .",
    "let us show that @xmath124 , which is a surjective partial function from @xmath39 to @xmath125 , expresses the fact that @xmath5 simulates @xmath120 .",
    "let @xmath67 be an execution of @xmath5 under @xmath17 .",
    "if @xmath126 is undefined on @xmath99 , then @xmath96 complies with any execution of @xmath120 , by definition .",
    "so , let us assume that @xmath126 is defined on @xmath99 , and therefore @xmath98 is defined on @xmath99 , and @xmath127 is defined on @xmath128 .",
    "this implies that , for all @xmath87 , @xmath98 is defined on @xmath89 , by definition of simulation .",
    "moreover , @xmath96 is compliant under @xmath98 with some execution @xmath92 of @xmath103 under @xmath18 .",
    "so there is a weakly increasing surjective function @xmath100 such that @xmath102 .",
    "in particular , @xmath129 .",
    "but we know that @xmath127 is defined on @xmath128 , and hence on @xmath130 . by definition of computation , @xmath127 is therefore defined on each @xmath131 , with @xmath87 . moreover , @xmath97 is compliant under @xmath127 with some execution @xmath132 of @xmath120 under @xmath133 .",
    "so there is a weakly increasing surjective function @xmath134 such that @xmath135 .",
    "now , let @xmath136 be an index . by the above",
    ", @xmath126 is defined on @xmath89 , and @xmath137 since @xmath138 is itself a weakly increasing surjective function , this implies that @xmath96 is compiant with @xmath139 under @xmath126 , and hence @xmath5 simulates @xmath120 .    if a system @xmath17 dominates a system @xmath18 , then all functions computed by @xmath18 are also computed by @xmath17 .",
    "suppose that @xmath140 . then , for any function @xmath8 such that @xmath141 , the transitivity of @xmath115 implies that @xmath142 .",
    "[ o1 ] for every network @xmath1 , the system @xmath143 is deterministic , and its configuration graph is isomorphic to the graph obtained from the quotient graph @xmath31 by replacing each unoriented edge @xmath144 with the two oriented edges @xmath22 and @xmath145 , and adding a self - loop @xmath146 to each vertex @xmath30 .    if there is just one robot in the network , all non - deterministic choices of a neighboring vertex among equivalent ones yield equivalent configurations",
    "this proves that @xmath143 is deterministic .",
    "note that the arrangements of one robot on @xmath1 consist of all the mappings of the form @xmath147 , with @xmath30 a vertex of @xmath1 . for each such @xmath30 ,",
    "let @xmath148 be the configuration corresponding to the arrangement @xmath147 , and let @xmath149 $ ] be the equivalence class of @xmath31 such that @xmath150 $ ] . by definition of equivalence , for any two arrangements @xmath151 and @xmath147 , @xmath152 if and only if @xmath30 and @xmath43 are equivalent in @xmath1 .",
    "this implies that the relation @xmath98 that maps @xmath148 to @xmath149 $ ] for every vertex @xmath30 is a well - defined bijection between the configuration space @xmath153 and the vertex set of @xmath31 .",
    "let us prove that @xmath98 induces a graph isomorphism , if the edges of @xmath31 are modified as in the observation s statement .",
    "let @xmath154 be an edge of the configuration graph of @xmath143 . by definition of fully synchronous scheduler",
    ", this holds if and only if there is an algorithm @xmath155 that takes @xmath156 and the class of indistinguishable vertices of @xmath156 containing @xmath29 , and maps it to the class of indistinguishable vertices of @xmath156 containing @xmath30 .",
    "such an algorithm exists if and only if there is a vertex @xmath62 indistinguishable from @xmath29 in @xmath156 and a vertex @xmath43 indistinguishable from @xmath30 in @xmath156 such that either @xmath157 or @xmath62 and @xmath43 are neighbors in @xmath1 .",
    "however , since there is a unique robot in the network , @xmath61 , and @xmath30 and @xmath43 have the same distance from @xmath29 . in other words , either @xmath158=[v]$ ] , or @xmath29 and @xmath30 are non - equivalent neighbors in @xmath1 . in the first case , the edge @xmath154 is correctly mapped into the self - loop on @xmath158 $ ] in the modified @xmath31 .",
    "the second case is equivalent to @xmath158 $ ] and @xmath149 $ ] being adjacent in @xmath31 , which is true if and only if there is the directed edge @xmath159,[v])$ ] in the modified @xmath31 .",
    "a fundamental question is whether adding robots to a network allows to compute more functions .",
    "we can at least prove that adding robots does not reduce the set of computable functions , provided that the network is not pathologically small .",
    "for all networks @xmath1 with at least three vertices and all @xmath64 , @xmath160 .",
    "it suffices to show that @xmath161 . for each configuration in @xmath39 , choose a vertex that contains the largest number of robots , and add one robot to it . this way we obtain @xmath162 distinct configurations of @xmath163 .",
    "we can generate yet another configuration by placing @xmath164 robots on a vertex , @xmath164 robots on another vertex , and the remainder on a third vertex .",
    "we can also show that a single robot does not compute more functions than @xmath64 robots , in any network @xmath1 .",
    "[ t:1tok ] for all networks @xmath1 and all @xmath64 , @xmath165 .    in the simulation",
    "we use only the configurations of @xmath90 in which all robots lie in equivalent vertices of @xmath1 .",
    "then each robot pretends to be the only robot in the network , and makes the move that the unique robot of @xmath143 would make .",
    "this is a well - defined simulation even if @xmath90 is not deterministic , due to proposition  [ o1 ] .",
    "we can extend this idea to show that @xmath166 , provided that @xmath167 is deterministic .",
    "[ p : corspecial2 ] @xmath168 , provided that @xmath169 is deterministic and @xmath170 .",
    "the configurations of @xmath169 that we use in our simulation are only those in which there is a ( unique ) vertex @xmath30 occupied by at least @xmath171 robots .",
    "each of these configurations is mapped to the configuration of @xmath90 that is obtained by removing @xmath172 robots from @xmath30 .",
    "this mapping is surjective .",
    "the simulation can be carried out because @xmath169 is deterministic , and therefore robots occupying the same vertex can never be separated , implying that there is always going to be a vertex with at least @xmath171 robots .    finally , we conjecture that adding robots increases a system s computational capabilities .",
    "[ con:1 ] for all networks @xmath1 and all @xmath64 , @xmath173 .",
    "the first special type of network we consider is the one whose base graph consists of a single _",
    "path_. this fundamental configuration will turn out to be of great importance in sections  [ s4 ] and  [ s5 ] , when studying universal classes of systems . in terms of labeling , we focus on two extreme cases : a labeling that gives a consistent orientation to the whole network ( i.e. , each vertex in the path has port labels indicating which neighbor is on the `` left '' and which one is on the `` right '' ) , and the anonymous unlabeled network . in the first case we have an _ oriented path _ , and in the second case we have an _ unoriented path_. by @xmath174 and @xmath175 we denote , respectively , the oriented and the unoriented path with @xmath0 vertices and @xmath2 robots , under the fully synchronous scheduler .    [ [ oriented - paths . ] ] oriented paths .",
    "+ + + + + + + + + + + + + + +    let us study the configuration graph of @xmath174 .",
    "since the path has an orientation , no two vertices are equivalent .",
    "therefore , by proposition  [ o1 ] , @xmath176 consists of a path of length @xmath0 with bidirectional edges and a self - loop on each vertex . in general , the configuration space of @xmath174 is in bijection with the set of weakly increasing @xmath2-tuples of integers in @xmath177 .",
    "hence , for a fixed @xmath2 , the size of the configuration space is @xmath178    if these @xmath2-tuples are thought of as points of @xmath179 , they constitute the set of lattice points in the @xmath2-dimensional simplex whose @xmath180 vertices have the form @xmath181 .",
    "this simplex has @xmath180 facets , two of which correspond to configurations in which the first or the last vertex of the network is occupied by a robot , while the other @xmath182 facets correspond to configurations in which exactly @xmath182 vertices are occupied ( i.e. , exactly two robots share a vertex ) .",
    "the edges of the configuration graph ( that are not self - loops ) connect bidirectionally all pairs of points whose chebyshev distance is at most 1 , with the exception of the points that lie on the aforementioned @xmath182 facets .",
    "indeed , since no algorithm can separate two robots that occupy the same vertex , it follows that those facets ( as well as all their intersections ) can never be left once they are reached .",
    "figure  [ f1](a ) shows the configuration graph of @xmath183 .",
    "[ p : grid ] for all @xmath33 , @xmath184 contains an @xmath185 grid with bidirectional edges and self - loops .",
    "since an oriented path gives the robots a sense of direction , an algorithm can unambiguously indicate to which neighbor each robot is supposed to move .",
    "therefore @xmath186 .",
    "[ p : opdet ] for all @xmath187 , the system @xmath174 is deterministic .",
    "[ [ unoriented - paths . ] ] unoriented paths .",
    "+ + + + + + + + + + + + + + + + +    let us study the configuration graph of @xmath175 . since the network in this system is unlabeled , if two vertices are symmetric with respect to the center of the path , they are equivalent .",
    "so , the configuration space is in bijection with the set of weakly increasing @xmath2-tuples of integers in @xmath177 , where each @xmath2-tuple @xmath188 is identified with its `` symmetric '' one , @xmath189 .",
    "elementary computations reveal that , if @xmath2 is fixed , these @xmath2-tuples are @xmath190    geometrically , the configuration space of @xmath175 can be represented as the set of lattice points in a truncated @xmath2-dimensional simplex , which is obtained by cutting the simplex of @xmath174 roughly in half , along a suitable hyperplane .",
    "figures  [ f1](b ) and  [ f1](c ) show the configuration graphs of @xmath191 and @xmath192 .    if @xmath0 is even , we have @xmath193 , because each robot has a unique closest endpoint of the path , which it can use to specify unambiguously in which direction it intends to move .",
    "however , if @xmath194 is odd and @xmath195 , the two graphs differ .",
    "indeed , if the configuration is symmetric and the central vertex is occupied by more than one robot , then it is impossible to guarantee that all the central robots will move in the same direction : the adversary will decide how many of these robots go left , and how many go right .",
    "for instance , @xmath196 differs from @xmath197 in that the vertex in @xmath198 has no outgoing edges in @xmath196 , because these correspond to non - deterministic moves .",
    "[ p : updet ] for all @xmath187 , the system @xmath199 is deterministic .",
    "[ cols=\"^,^,^ \" , ]      now we consider _ ring _ networks , which are networks whose base graph is a single cycle .",
    "this is another fundamental class of networks , which will have a great importance in sections  [ s4 ] and  [ s5 ] . like a path ,",
    "a ring can be _ oriented _ if its labeling gives a consistent sense of direction to the robots in the network ( i.e. , each vertex has port labels indicating which neighbor lies in the `` clockwise '' direction , and which one lies in the `` counterclockwise '' direction ) , and _ unoriented _ if the network is unlabeled .",
    "therefore we have the two systems @xmath200 and @xmath201 , denoting , respectively , the oriented and the unoriented ring with @xmath0 vertices and @xmath2 robots , under the fully synchronous scheduler .",
    "[ [ oriented - rings . ] ] oriented rings .",
    "+ + + + + + + + + + + + + + +    let us study the structure of @xmath202 .",
    "note that , in a ring network , all vertices are equivalent .",
    "therefore , by proposition  [ o1 ] , @xmath203 consists of a single vertex with a self - loop .    in the case of @xmath204 robots ,",
    "a configuration is uniquely identified by the distance @xmath205 of the two robots on the ring , which may be any integer between @xmath206 and @xmath207 .",
    "if @xmath208 , the robots are bound to remain on the same vertex .",
    "if @xmath209 ( hence @xmath0 is even ) , the robots are located on indistinguishable vertices , and they are bound to remain on indistinguishable vertices . in all other cases , it is possible to distinguish the two robots and move them independently , thanks to the orientation of the ring .",
    "therefore , if @xmath210 , an algorithm may move the two robots independently in any direction , thus adding any integer between @xmath211 and @xmath212 to @xmath205 ( subject to the @xmath213 constraint ) . figures  [ f1](d ) and  [ f1](e ) show the configuration graphs of @xmath214 and @xmath215 .    in general ,",
    "the configuration space of @xmath200 is in bijection with the set of binary _ necklaces _ of length @xmath0 and density @xmath2 , i.e. , the binary strings having @xmath2 zeros and @xmath216 ones , taken modulo rotations . to count them ,",
    "the plya enumeration theorem can be applied , as in  @xcite .",
    "if @xmath2 is fixed , the configuration space has size @xmath217 where @xmath218 is euler s totient function .",
    "since the ring is oriented , we have @xmath219 .    [",
    "p : ordet ] for all @xmath187 , the system @xmath200 is deterministic .",
    "[ [ unoriented - rings . ] ] unoriented rings .",
    "+ + + + + + + + + + + + + + + + +    the structure of @xmath220 is similar to that of @xmath202 , except that now two configurations are indistinguishable also if they are `` reflections '' of each other .",
    "the case @xmath221 is again trivial and yields a single configuration , but the case @xmath204 is more interesting . as before",
    ", a configuration of @xmath222 is identified by an integer @xmath205 with @xmath213 , but the two robots are now indistinguishable , and therefore they must always make symmetric moves .",
    "hence @xmath205 may only change by @xmath211 or @xmath212 ; the only exception is when @xmath0 is odd and @xmath223 , which can change to @xmath224 ( as well as to @xmath225 ) , and vice versa .",
    "so , if @xmath0 is odd , @xmath226 is isomorphic to @xmath227 .",
    "if @xmath0 is even , @xmath226 consists of two connected components : the one corresponding to even @xmath205 s is isomorphic to @xmath228 , and the one corresponding to odd @xmath229 is isomorphic to @xmath230 .",
    "figures  [ f1](f ) ,  [ f1](g ) , and  [ f1](h ) show the configuration graphs of @xmath231 , @xmath232 , and @xmath233 .",
    "[ p : urpaths ] for all @xmath187 , @xmath220 consists of either a single path or two disjoint paths .    in general , instead of representing the configurations of @xmath201 with necklaces as before , we use _",
    "bracelets _ of length @xmath0 and density @xmath2 , i.e. , binary strings having @xmath2 zeros and @xmath216 ones , taken modulo rotations and reflections .",
    "the size of the configuration space can be computed again with the plya enumeration theorem , this time using the dihedral group instead of the cyclic group . for fixed @xmath2 ,",
    "its size is @xmath234    with unoriented rings , the deterministic configuration graph is slightly different . if @xmath208 or @xmath209 , the adversary may choose to keep @xmath205 unvaried , by making both robots always move in the same direction .",
    "therefore , the configurations corresponding to @xmath208 and @xmath209 have no outgoing edges in @xmath235 .",
    "other than that , the two graphs are the same .",
    "next we describe how different systems of paths and rings dominate each other .    for all @xmath187 and @xmath170 , @xmath236 , @xmath237 , and @xmath238 .",
    "by properties  [ p : opdet ] ,  [ p : updet ] , and  [ p : ordet ] , the systems @xmath239 , @xmath240 , and @xmath241 are deterministic . thus all relations follow from theorem  [ p : corspecial2 ] .",
    "[ t : op2up ] for all @xmath187 , @xmath242 .",
    "we place the @xmath2 robots of @xmath199 on the first @xmath0 vertices of the path , leaving the other half empty .",
    "this gives an implicit orientation to the path , and now the simulation is trivial .",
    "[ t : op2or ] for all @xmath33 and @xmath195 , @xmath243 .",
    "we use only the configurations of @xmath244 having a vertex occupied by a single robot , followed in clockwise order by @xmath245 empty vertices .",
    "the simulation is performed by the other @xmath2 robots on the remaining @xmath0 vertices , which are always unambiguously identified because @xmath195 .",
    "[ t : up2ur ] for all @xmath33 and @xmath195 , @xmath246 .",
    "we use only the configurations of @xmath247 having a vertex occupied by one robot , surrounded on both sides by sequences of @xmath245 empty vertices .",
    "the simulation is performed by the other @xmath2 robots on the remaining @xmath0 vertices , which are always unambiguously identified because @xmath195 .",
    "a system @xmath17 is _ universal for @xmath177 _ if it computes every function on @xmath177 . in this case",
    ", we write @xmath248 . note that this extension of the relation @xmath115 preserves its transitivity .",
    "a set of systems @xmath249 is _ universal _ if , for every @xmath33 and every function @xmath250 , there is a system @xmath251 that computes @xmath8 .",
    "one robot is sufficient for universality , even on unlabeled networks .",
    "[ t : univ1 ] @xmath252 is universal .    given a function @xmath253 , take the complete graph @xmath254 and attach @xmath68 dangling vertices to its @xmath68-th vertex , for all @xmath255 .",
    "to compute @xmath8 , instruct the robot to move from the vertex with @xmath68 dangling vertices to the one with @xmath256 dangling vertices ( which is always distinguishable ) .    however , complete graphs are very demanding networks .",
    "if no vertex in the network has more than two neighbors , universality requires more robots : two for paths and oriented rings , and three for unoriented rings .",
    "[ t : app1 ] @xmath257 , @xmath258 , @xmath259 , and @xmath260 are not universal .",
    "this is trivially true for @xmath259 , since @xmath261 has only one configuration .",
    "let the _ cycle function _",
    "@xmath262 be defined as @xmath263 .",
    "note that , if a system computes @xmath264 , its configuration graph must contain a cycle of length at least @xmath265 . by proposition  [ o1 ] and property  [ p : urpaths ] , the configuration graphs of @xmath266 , @xmath267 , and @xmath222 consist of either a single path or two disjoint paths .",
    "it follows that none of these systems can compute @xmath264 , for any @xmath268 .",
    "next we show that two robots are indeed sufficient to compute every function on arbitrarily long oriented and unoriented paths and oriented rings , and that three robots are sufficient for unoriented rings .",
    "first we introduce a definition : an algorithm is _ sequential _ if it never instructs two robots to move at the same time .",
    "[ l : draw ] for all @xmath33 , @xmath269 .",
    "the algorithms used in the computations are sequential .",
    "let @xmath253 , and consider the base graph @xmath1 of the network induced by @xmath8 .",
    "each connected component of @xmath1 consists of a single cycle ( possibly degenerating in a vertex with a self - loop ) to which some disjoint trees are attached .",
    "each tree is rooted at the vertex that it shares with the cycle , and all edges in the tree are directed towards the root . in particular , @xmath1 is planar .",
    "we would like to reduce the maximum degree of @xmath1 to 3 .",
    "we do so by a series of local transformations of @xmath1 , as shown in figure  [ f4 ] .",
    "if @xmath1 has a vertex @xmath30 of degree greater than 3 , we transform it as follows .",
    "if @xmath22 and @xmath270 are edges of @xmath1 , we delete them , we create a new vertex @xmath271 , and we add the edges @xmath272 , @xmath273 , and @xmath274 .",
    "this transformation creates a new vertex of degree 3 , and decreases by 1 the degree of @xmath30 .",
    "if @xmath30 has initial indegree @xmath275 , this operation is performed on @xmath30 exactly @xmath276 times , adding @xmath276 vertices to the graph .    .",
    "]    therefore , by repeatedly applying this transformation , we obtain a new planar graph @xmath94 on at most @xmath277 vertices , with maximum degree at most 3 , such that @xmath1 is a graph minor of @xmath94 . as shown in  @xcite",
    ", @xmath94 admits a planar orthogonal grid drawing on an @xmath185 grid .",
    "so , @xmath94 is a minor of some graph @xmath278 ( obtained by adding vertices on some edges of @xmath94 ) that in turn is a subgraph of an @xmath185 grid with self - loops and bidirectional edges .    by properties  [ p : grid ] and  [ p : opdet ] ,",
    "this @xmath185 grid is a subgraph of @xmath279 .",
    "it is easy to check that @xmath280 computes @xmath8 under the surjective partial function induced by the composition of these graph minor relations .",
    "indeed , whenever the computation reaches a configuration corresponding to a vertex of @xmath1 that has been splitted during the first set of transformations , it just follows the edges generated during the splitting . this is possible because all these edges represent deterministic moves , so they can be chosen by the algorithm and have to be complied by the fully synchronous scheduler .    on the other hand ,",
    "if the computation reaches a configuration corresponding to an edge of @xmath1 that has been extended in order to embed it in the grid , the computation follows the extended edge .",
    "again , this is possible because these edges represent deterministic moves .",
    "[ t : pathuniv ] @xmath281 , @xmath282 , @xmath283 , and @xmath284 are universal .    for @xmath281 , @xmath282 , and @xmath284 , this immediately follows from lemma  [ l : draw ] , theorems  [ t : op2up ] and  [ t : up2ur ] , and the transitivity of @xmath115 .    for oriented rings , we need a different argument .",
    "the shape of the configuration graph of @xmath285 is illustrated in figures  [ f1](d ) and  [ f1](e ) . given a function @xmath8",
    "whose induced network is @xmath107 , we can embed @xmath107 in @xmath286 , provided that @xmath0 is large enough , for instance as shown in figure  [ f3 ] . in general , each connected component of the base graph of @xmath107 is a cycle @xmath287 with some trees attached to it . for each leaf of such a tree , connected to @xmath287 via a path @xmath288 ,",
    "we embed a copy of @xmath287 in @xmath286 and attach a copy of @xmath288 to it , mapping each vertex to the appropriate vertex of @xmath289 . the resulting surjective partial function",
    "@xmath98 indeed defines a simulation .",
    "we can generalize this result in two directions .",
    "first , to systems of two robots on networks whose quotient graphs contain arbitrarily long paths .",
    "[ cor:1 ] @xmath290 is universal .",
    "we prove that @xmath291 , and the universality follows from lemma  [ l : draw ] . by assumption",
    ", the robots can agree on an oriented path @xmath288 of length @xmath0 in @xmath292 , since all its vertices are distinguishable , due to the definition of quotient graph .",
    "then , a robot located at some vertex of @xmath293 is interpreted as lying on the corresponding vertex of @xmath292 and follows whatever algorithm it is simulating , remaining on vertices of @xmath293 corresponding to @xmath288 ; this way , the two robots can simulate @xmath294 on @xmath293 .",
    "theorem  [ t : pathuniv ] can also be generalized to systems of three robots on networks with arbitrarily long _ girths _ ( the girth of a graph being the length of its shortest cycle , or infinity if there are no cycles ) .",
    "[ cor:2 ] @xmath295 is universal .",
    "we show that @xmath296 . by lemma  [ l :",
    "draw ] , it is sufficient to simulate any _ sequential _",
    "algorithm @xmath5 for @xmath280 .",
    "in particular , @xmath5 does not make the two robots move if they lie on the same vertex , or both would have to move , and the algorithm would not be sequential . to do the simulation",
    ", we choose a shortest cycle @xmath287 in @xmath297 , and we initially place all three robots on it : one robot @xmath40 will remain fixed in one vertex , then we will keep @xmath298 empty vertices on @xmath287 after @xmath40 , while the other two robots @xmath299 and @xmath300 simulate @xmath5 on the next @xmath277 vertices , with @xmath300 always farthest from @xmath40 .",
    "this makes the robots distinguishable ( unless @xmath299 and @xmath300 coincide ) , because @xmath287 has length at least @xmath301 ( see figure  [ f5 ] ) .    .",
    "]    since @xmath287 is a shortest cycle , there is a unique shortest path @xmath288 in @xmath297 containing all three robots . indeed ,",
    "if this were not the case , there would be two vertices of @xmath287 connected by two disjoint paths of length at most @xmath302 , implying the existence of a cycle of length at most @xmath303 , and contradicting the fact that the girth is at least @xmath301 .",
    "due to the uniqueness of @xmath288 , if @xmath299 and @xmath300 have to move within @xmath288 , they can deterministically do so .",
    "this may cause @xmath299 and @xmath300 to switch positions , in which case we simply rename them and we pretend they have not moved .",
    "if @xmath300 has to move away from @xmath299 ( hence @xmath299 and @xmath300 are not on the same vertex , and @xmath299 stays still because @xmath5 is sequential ) , it proceeds along a shortest cycle that contains @xmath288 .",
    "this could be a non - deterministic move , but it will indeed keep the robots on a same shortest cycle , although maybe not @xmath287 .",
    "all the configurations obtained this way are mapped to the corresponding configuration of @xmath280 , and this yields a surjective partial function that describes the simulation .",
    "our conjecture is that the above results characterize the universal classes of systems with at least three robots on unlabeled networks .",
    "[ con:2 ] the set @xmath304 , where @xmath305 and every @xmath306 is an unlabeled network , is universal if and only if either the quotient graphs @xmath307 have unboundedly long sub - paths , or the graphs @xmath306 have unboundedly long shortest cycles .",
    "in this section , our goal is to compute all the functions on @xmath177 under the fully synchronous scheduler , using the smallest possible network , and perhaps a large number of robots .",
    "we are able to approximate the minimum size of such a network up to a factor that tends to 2 as @xmath0 goes to infinity , using very short oriented paths .",
    "nonetheless , thanks to the simulation tools developed in section  [ ss32 ] , we could as well use unoriented paths or rings , again achieving the optimum size up to factors that tend to small constants .",
    "[ l : ham ] for all @xmath187 , @xmath308 .",
    "we divide the base graph of @xmath309 into @xmath2 sub - paths of length @xmath0 . in every sub - path ,",
    "we place a different amount of robots on each vertex , from @xmath206 to @xmath245 robots .",
    "the possible placements of such robots within a sub - path correspond to the @xmath310 permutations of @xmath0 distinct objects .",
    "it is well known that the set of permutations can be ordered in such a way that each permutation is obtained from the previous one by swapping only two adjacent objects  @xcite .",
    "if we let the @xmath68-th permutation under this ordering encode the @xmath68-th vertex of @xmath311 , we can simulate a move of @xmath68-th robot of @xmath311 by simply swapping the robots occupying two adjacent vertices of the @xmath68-th sub - path of @xmath309 .",
    "[ t : opt1 ] for all @xmath33 , @xmath312 , with @xmath313 .",
    "immediate from lemma  [ l : draw ] , lemma  [ l : ham ] with @xmath204 , and the transitivity of @xmath115 .",
    "this tells us that , on a network with @xmath314 vertices , all the functions on a set of size @xmath315 can be computed , provided that enough robots are available .",
    "we can also show that , on the same network , it is impossible to compute all functions on a set of size @xmath316 .",
    "[ t : opt2 ] for all networks @xmath19 and all @xmath187 , if @xmath317 , then @xmath318 .",
    "let @xmath5 be an algorithm that computes the cycle function @xmath319 under @xmath90 , according to the surjective partial function by @xmath320 .",
    "for any execution @xmath67 of @xmath5 such that @xmath321 , the sequence @xmath322 must span the whole range @xmath177 infinitely often . moreover , since @xmath39 is finite , there is a configuration @xmath9 that occurs infinitely many times in @xmath96 .",
    "hence there are two such occurrences , say @xmath323 , between which @xmath96 spans at least @xmath324 different configurations . during this fragment of the execution",
    ", no two separate sets of robots may end up on the same vertex at the same time , or they become impossible to separate deterministically , contradicting the fact that @xmath9 must be reached again . in particular , the number of vertices that are occupied by some robots remains the same , @xmath325 .",
    "it follows that @xmath205 can not be larger than @xmath326 .",
    "thus @xmath327 , as desired .",
    "in addition to the fully synchronous scheduler , also a semi - synchronous and an asynchronous one can be defined .",
    "both schedulers may activate any subset of the robots at each turn , keeping the others quiescent .",
    "the asynchronous scheduler may even delay the robots , making them move based on obsolete observations of the network .",
    "our universality results can be extended to both these schedulers , by observing that all the algorithms we used in our simulations are sequential .",
    "we can also prove a weaker version of theorem  [ t : opt1 ] for these schedulers : @xmath328 , with @xmath329 ; we have a matching lower bound for both schedulers , as well .",
    "these results indicate that the semi - synchronous and asynchronous schedulers , albeit not drastically reducing the robots computing powers , make them somewhat less efficient .",
    "f.  bonnet , a.  milani , m.  potop - butucaru , and s.  tixeuil .",
    "asynchronous exclusive perpetual grid exploration without sense of direction . in _ proceedings of 15th international conference on principles of distributed system ( opodis ) _",
    ", 251265 , 2011 .",
    "j.  chalopin , p.  flocchini , b.  mans , and n.  santoro .",
    "network exploration by silent and oblivious robots . in _ proceedings of 36th international workshop on graph",
    "theoretic concepts in computer science ( wg ) _ , pages 208219 , 2010 .",
    "t.  izumi , t.  izumi , s.  kamei , and f.  ooshita .",
    "mobile robots gathering algorithm with local weak multiplicity in rings . in _ proceedings of 17th international colloquium on structural information and communication complexity ( sirocco ) _ , 101113 , 2010 .",
    "s.  kamei , a.  lamani , f.  ooshita , and s.  tixeuil .",
    "gathering an even number of robots in an odd ring without global multiplicity detection . in _ proceedings of 37th international symposium on mathematical foundations of computer science ( mfcs ) _",
    ", 542553 , 2012 .",
    "a. kosowski and a.  navarra .",
    "graph decomposition for improving memoryless periodic exploration . in _ proceedings of 34th international symposium on mathematical foundations of computer science ( mfcs ) _",
    ", 501512 , 2009 .",
    "a.  lamani , m.  gradinariu potop - butucaru , and s.  tixeuil .",
    "optimal deterministic ring exploration with oblivious asynchronous robots . in _ proceedings of 17th int .",
    "colloquium on structural information and communication complexity ( sirocco ) _",
    ", 183196 , 2010 .",
    "l. millet , m. potop - butucaru , n. sznajder , and s. tixeuil . on the synthesis of mobile robots algorithms : the case of ring gathering . in _ proceedings of 16th international symposium on stabilization , safety , and security of distributed systems ( sss ) _ , 237251 , 2014 ."
  ],
  "abstract_text": [
    "<S> an oblivious mobile robot is a stateless computational entity located in a spatial universe , capable of moving in that universe . when activated , the robot observes the universe and the location of the other robots , chooses a destination , and moves there . </S>",
    "<S> the computation of the destination is made by executing an algorithm , the same for all robots , whose sole input is the current observation . </S>",
    "<S> no memory of all these actions is retained after the move . </S>",
    "<S> when the spatial universe is a graph , distributed computations by oblivious mobile robots have been intensively studied focusing on the conditions for feasibility of basic problems ( e.g. , gathering , exploration ) in specific classes of graphs under different schedulers . in this paper , we embark on a different , more general , type of investigation .    with their movements from vertices to neighboring vertices , </S>",
    "<S> the robots make the system transition from one configuration to another . </S>",
    "<S> thus the execution of an algorithm from a given configuration defines in a natural way the computation of a discrete function by the system . </S>",
    "<S> our research interest is to understand which functions are computed by which systems . in this paper </S>",
    "<S> we focus on identifying sets of systems that are _ universal _ , in the sense that they can collectively compute all finite functions . </S>",
    "<S> we are able to identify several such classes of fully synchronous systems . </S>",
    "<S> in particular , among other results , we prove the universality of the set of all graphs with at least one robot , of any set of graphs with at least two robots whose quotient graphs contain arbitrarily long paths , and of any set of graphs with at least three robots and arbitrarily large finite girths .    </S>",
    "<S> we then focus on the minimum size that a network must have for the robots to be able to compute all functions on a given finite set . </S>",
    "<S> we are able to approximate the minimum size of such a network up to a factor that tends to 2 as @xmath0 goes to infinity .    </S>",
    "<S> the main technique we use in our investigation is the _ simulation _ between algorithms , which in turn defines _ domination _ between systems . </S>",
    "<S> if a system dominates another system , then it can compute at least as many functions . the other ingredient is constituted by _ path _ and _ ring _ networks , of which we give a thorough analysis . </S>",
    "<S> indeed , in terms of implicit function computations , they are revealed to be fundamental topologies with important properties . </S>",
    "<S> understanding these properties enables us to extend our results to larger classes of graphs , via simulation . </S>"
  ]
}