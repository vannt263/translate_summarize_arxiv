{
  "article_text": [
    "browser - based notebooks ( i.e. ,  jupyter ) have gained tremendous popularity with data scientists in recent years for a variety of reasons :  the tight integration of code and execution output elevates the analytical process and its products to first class citizens , since the notebook itself can be serialized , reloaded , and shared . the ability to manipulate , rearrange , and insert snippets of code ( in `` cells '' ) lines up well with the iterative nature of data science and a wide range of analytics tasks .",
    "a recent development is the seamless integration of browser - based notebooks with scalable data analytics platforms , such that code written in a notebook cell can be executed on a potentially large cluster and the results can be further manipulated in the notebook .",
    "this integration , exemplified by the commercial databricks platform that provides a notebook frontend to spark clusters  @xcite , allows data scientists to analyze large amounts of data in a convenient and flexible manner .",
    "the advent of notebooks means that the browser has , in essence , become the `` shell '' .",
    "however , in all implementations that we are aware of , the browser is simply a dumb rendering endpoint :  all query execution is handled by backend servers . in the terminology of franklin",
    "@xcite , this is referred to as _ query shipping_. however , modern browsers are capable of so much more :  they embed powerful javascript engines capable of running real - time collaborative tools , online multi - player games , rendering impressive 3d scenes , supporting complex , interactive visualizations , and even running first - person shooters .",
    "these applications take advantage of html5 standards such as webgl , websocket , and indexeddb , and therefore do not require additional plug - ins ( compared to flash or , yuck , java applets ) .",
    "we asked ourselves :  is it possible to exploit modern javascript engines and build a high - performance data management system that runs _ completely in the browser _ ? and",
    "if so , what new opportunities does such a platform create ?",
    "we tackle these two questions in turn :  first , we present afterburner , a prototype analytical rdbms implemented in javascript that executes completely inside a web browser , is standards compliant , and has no external dependencies .",
    "experiments with a few simple queries on a modest dataset show that afterburner achieves comparable performance to the analytical database monetdb  @xcite _ running natively on the same machine_. this finding is interesting in that it shows how far javascript has come as an efficient execution platform , from its much - maligned performance characteristics in the early days .",
    "second , we discuss the `` so what ? ''  question by highlighting the potential of our techniques for supporting ubiquitous in - browser interactive analytics and query execution strategies that make use of query operators running both in the browser and on backend servers .    the primary contribution of our work is a feasibility demonstration of in - browser analytics . to our knowledge , we are the first to propose this somewhat unconventional idea of embedding an analytical rdbms inside the browser and exploring the implications thereof . the idea of splitting query execution across the client and the server , of course , is not new , but we believe that javascript presents a fresh take on the decades - old technique .",
    "afterburner is implemented as a javascript library , primarily designed to run inside a standards - compliant web browser . however , with minimal modifications it can run in other javascript environments such as node.js . in the current implementation , data is loaded into the browser from a flat file on the client s file system , although in principle data ingest could be accomplished via a rest api call , a websocket , or a variety of other means .",
    "all data are immutable and packed in a columnar layout in memory once loaded .",
    "afterburner generates compiled query plans that exploit two javascript features :  typed arrays and asm.js , which we explain below .",
    "array objects in javascript can store elements of any type and are not arrays in a traditional sense ( compared to say , c ) since consecutive elements may not be contiguous ; furthermore , the array itself can dynamically grow and shrink .",
    "this flexibility limits the optimizations that the javascript engine can perform both during compilation and at runtime . in the evolution of javascript , it became clear that the language needed more efficient methods to quickly manipulate binary data : typed arrays are the answer .",
    "typed arrays in javascript are comprised of buffers , which simply represent untyped binary data , and views , which impose a read context on the buffer . as an example , the following creates a 64-byte buffer :    ....    var buffer = new arraybuffer(64 ) ; ....    before we can manipulate the data , we need to create a view from it . with the following :    ....    var int32view = new int32array(buffer ) ; ....    we can now manipulate int32view as an array of 32-bit integers ( e.g. , iterate over it with a for loop ) .",
    "typed arrays allow the developer to create multiple views over the same buffer , which provides a mechanism to interact with , for example , arbitrary c structs or complex webgl data .",
    "afterburner takes advantage of exactly this feature to pack relational data into a columnar layout .    in afterburner ,",
    "each column is laid out end - to - end in the underlying buffer ( which can be traversed with a view of the corresponding type ) .",
    "the table itself is a group of pointers to the offsets of the beginning of the data in each column .",
    "figure  [ fig : memory ] shows the physical memory layout storing the lineitem table from the tpc - h benchmark , which we use as a running example .",
    "a lineitem pointer serves as the entry point into a group of 32-bit integer pointers , which represent the offsets of the data in each column ( l_orderkeys , l_partkeys , etc . ) .",
    "currently , our implementation supports integers , floats , dates , and strings . for the first three types , values are stored as literals ( essentially , as an array ) . for a column of strings , we store null - terminated strings prefixed with a header of pointers into the beginning of each string , essentially a ( char * * ) in c.    intermediate data for query execution in afterburner",
    "are also stored using typed arrays .      in conjunction with typed arrays , afterburner takes advantage of asm.js , a strictly - typed subset of javascript that is designed to be easily optimizable by an execution engine .",
    "consider the following fragment of javascript for counting the number of records that matches a particular predicate on the column extendedprice :    ....    function count(val ) {                        var cnt = 0 ;      for ( var i d ; i d < orderkey.length ; id++ )        if ( extendedprice[id ] < val ) cnt++ ;      return cnt ;    }                                        ....    for expository convenience , we refer to javascript without asm.js optimizations as _ vanilla _ javascript .",
    "the equivalent function in asm.js is as follows :    ....    function count_asm(val , length ) {      \" use asm \" ;      val=+(val ) ;      length = length|0 ;      length = length<<2 ;      id=0 ;      while ( ( id|0 ) < ( length|0 ) ) {        if ( + ( extendedprice[id>>2 ] ) < + ( val ) )          cnt=(cnt+1)|0 ;        id=(id+4)|0 ;      }      return cnt|0 ;    } ....    a key feature of asm.js is the use of type hints , such as x|0 and + ( x ) , which are applied to variables or arithmetic expressions . the type hint ( x|0 ) specifies a 32-bit integer and + ( x ) specifies a 32-bit floating point value . with these hints ,",
    "asm.js essentially introduces a static type system while retaining backwards compatibility with vanilla javascript , since in vanilla javascript these hints just become no - ops . note that accesses to typed views must indicate the byte offset and the size of each element .",
    "the extendedprice column is a 32-bit float view and thus the byte offsets can be computed by multiplying the index variable n by 4 using the shift operator ( > > ) .",
    "any javascript function can request validation of a block of code as valid asm.js via a special prologue directive , use asm , which happens when the source code is loaded .",
    "validated asm.js code ( typically referred to as an asm.js module ) is amenable to ahead - of - time ( aot ) compilation , in contrast to just - in - time ( jit ) compilation in vanilla javascript .",
    "executable code generated by aot compilers can be quite efficient , through the removal of runtime type checks ( since everything is statically typed ) , operation on unboxed ( i.e. , primitive ) types , and the removal of garbage collection .",
    "an asm.js module can take three optional parameters , which provide hooks for integration with external vanilla javascript code :  a standard library object , providing access to a limited subset of the javascript standard libraries ; a foreign function interface ( ffi ) , providing access to custom external javascript functions ; and a heap buffer , providing a single arraybuffer to act as the asm.js heap .",
    "thus , a typical asm.js module declaration is as follows :    ....    function myasmmodule(stdlib , foreign , heap ) {      \" use asm \" ;        //",
    "module body    } ....    at a high - level , afterburner translates sql into the string representation of an asm.js module ( i.e. , the physical query plan , through code templates described below ) , calls eval on the code , which triggers aot compilation and links the module to the calling javascript code , and finally executes the module ( i.e. , executes the query plan ) .",
    "the typed array storing all the tables ( i.e. , the entire database ) is passed into the module as a parameter , and the query results are returned by the module .",
    "the compiled query approach of afterburner takes after systems like hique  @xcite and hyper  @xcite , which have recently popularized the idea of code generation for relational query processing .",
    "one well - known drawback of this approach is that compiling generated code using a tool like gcc can overshadow its benefits for short - running queries . as an alternative ,",
    "neuman  @xcite proposed a hybrid compilation model , where the queries are compiled into an intermediate representation such as llvm , which is then linked to pre - compiled native code to achieve native - like performance while avoiding native compilation overhead . in the context of our work ,",
    "we have found compilation overhead to be negligible , primarily because compilation speed is already something that javascript engines optimize for , since all javascript code on the web is stored as text .      instead of string - based sql queries",
    ", afterburner executes queries written using an api that is heavily driven by method chaining , often referred to as a _",
    "fluent _ api .",
    "for example , consider a simple query over the orders table from the benchmark :    ....    select orderkey , orderdate    from orders     where orderdate=`1996 - 01 - 01 ' ; ....    this query would be expressed in afterburner as follows :    ....    sql.select ( )      .field(`orderkey ' )      .field(`orderdate ' )      .from(`orders ' )      .where(eq(`orderdate ' , date(`1996 - 01 - 01 ' ) ) ) ....    note that there is a very straightforward mapping from the method calls to clauses in a standard sql query , so we can view the fluent api as little more than syntactic sugar . however , this query api has a few advantages :  first , it saves us from having to write a query parser .",
    "second , this fluent api is similar to dataframes  @xcite , an interface for data manipulation that many data scientists are familiar with today .",
    "starting from an sql query expressed in the fluent - style api , afterburner generates the string representation of the asm.js code that corresponds to the query . in the current implementation",
    ", this is performed in a straightforward way based on a small number of fixed code templates in which various sub - expressions ( e.g. , the filter predicate , join key , group by clause , etc . )  are plugged . at present , afterburner has a fixed ( hard - coded ) physical plan for each class of queries ( i.e. , it does not perform query optimization ) .",
    "our prototype implementation supports simple filter queries , inner joins , group bys , simple aggregations , and order bys .",
    "we discuss below in more detail :    * simple filters . *",
    "a code template supports generating query plans for simple filter  project or filter  aggregate queries .",
    "the code template generates a loop that increments a record iterator , which is used in combination with the starting offset of a column to access a particular attribute .",
    "inside the loop , the template can either generate code to materialize a projection or to compute simple aggregates such as count , avg , or sum .",
    "* joins . * the code template for supporting filter  project or filter  aggregate queries over an inner join implements a standard hash join . in the build phase",
    ", the code loops over one relation to build the hash table .",
    "in the probe phase , the generated code loops over the second relation to probe the hash table for matching records , and then either materializes a projection or computes an aggregate .",
    "* group bys . * a group by plan loops over one relation to build a hash table over one or more grouping keys .",
    "another loop is used to iterate over the hash table in order to process the groups .",
    "as indicated in the introduction , the main purpose of this work is to demonstrate the _ feasibility _ of in - browser analytics .",
    "we freely admit that afterburner is far from a complete analytical database , but we believe that our prototype is sufficient to answer this question .    in this section ,",
    "we compare the performance of afterburner with vanilla javascript and monetdb ( v11.17.17 ) in exactly the same execution environment on a commodity desktop machine .",
    "afterburner and vanilla javascript execute inside the browser , while monetdb runs natively . for the vanilla javascript condition ,",
    "we simply remove the use asm prologue directive so that generated code is not validated as asm.js .",
    "however , the code still uses typed arrays .    for data",
    ", we used the tpc - h data generator with a scale factor of 1 gb :  this creates a lineitem table with 6  million rows and an orders table with 1.5  million rows .",
    "table  [ exp : tab ] shows the four queries used in the evaluation .",
    "the first three queries are very simple , and the final query is a slightly simplified version of q3 in the tpc - h benchmark .",
    ".sample queries used in our performance evaluation .",
    "q4 is a slightly simplified version of q3 from the tpc - h benchmark . [",
    "cols=\"<\",options=\"header \" , ]     we sketch out what the performance of such an in - browser analytics scenario might look like . consider a tpc - h database at a 100 gb scale factor :  let s focus on the top orders query q4 in table  [ exp : tab ] , where the data scientist wants to dive into data from january 1996 . for the sake of argument , we assume this exploration requires repeated querying that can not be easily captured in a single query .",
    "we exemplify this with q5 in table  [ exp : variants ] , which pulls up the top 10 orders on a particular day .",
    "running this query in monetdb takes 800  ms on a server with dual 8 cores intel xeon e5 - 2670 processors ( 2.6  ghz ) with 256  gb of memory on ubuntu 14.04 .",
    "this corresponds to scenario ( 1 ) above  run individual selective queries directly on the data warehouse .",
    "alternatively , the data scientist might materialize the results of q6 in table  [ exp : variants ] into a temporary table ( containing 2 million rows ) .",
    "running a simple filter query for a particular day on this temporary table ( on the backend server ) takes 28  ms .",
    "this corresponds to scenario ( 2 ) above , although we are not taking into account network latency .    as an alternative",
    ", we can bring the materialized results of q6 into the browser and then run the filter query with afterburner .",
    "such a query takes 25  ms on the same client machine described in section  [ sec : eval ] .",
    "we do not include the data transfer time , which would be amortized across multiple queries that probe the materialized results .",
    "such a scenario has the advantage of seamless , low - latency client - side interactions ( it s still sql ) without the data management issues that come with creating temporary tables . pushing simple filter queries over to the client side naturally decreases load on the server , and",
    "since afterburner is just javascript , it can integrate into any browser - based analytics tool , ranging from simple dashboards to full - fledged interactive notebooks .",
    "what s more , the ubiquity of javascript means that afterburner can run anywhere there is a browser , including mobile phones , tablets , and even the connected toaster oven or refrigerator of the near future .",
    "java once promised developers that they can write their code once and have it run anywhere , but javascript has come much closer to actually delivering that promise  as evidenced by the range of complex websites today that run on multiple platforms , on multiple types of hardware , in multiple browsers .",
    "this shows that analytics capabilities in javascript can easily achieve widespread deployment .",
    "finally , we realize that our current working scenario  materializing a subset of data for further analysis inside the browser",
    " represents a specific instance of split - execution strategies , where the client ( i.e. , the browser ) and the server collaborate to execute a query . in our case , the user explicitly decides what queries run where , but this need not be the case .",
    "for example , franklin et al .",
    "@xcite discuss _ query shipping _",
    "( basically , all systems today , where queries are shipped to the server and results sent back ) , _ data shipping _",
    "( where the server sends the client tuples and query operators execute on the client ) , and _ hybrid shipping _ ( where query operators execute on both the client and the server ) . in our case",
    ", it could be possible for a query planner to automatically place query operators either on the server or in the browser to optimize some objective ( latency , utilization , etc . ) .",
    "one of the challenges with previous work is that the execution context on the client and server might be different , but javascript nicely solves this problem for us .",
    "there is an emerging trend of building internet - scale services using node.js , which unifies server - side and client - side processing around javascript for customer - facing applications .",
    "throw something like afterburner into the mix , perhaps we could integrate customer - facing services with backend data analytics   all around javascript !",
    "such a thought should send shivers down the spine of any sane developer , but this idea is so nutty we feel it s worth exploring !",
    "we d like to thank members of waterloo s data systems group ( dsg ) for their encouragement ( `` you guys are nuts , but you should pursue this anyway '' ) and ashraf aboulnaga for helpful comments on previous drafts of this paper .",
    "m.  armbrust , r.  s. xin , c.  lian , y.  huai , d.  liu , j.  k. bradley , x.  meng , t.  kaftan , m.  j. franklin , a.  ghodsi , and m.  zaharia . : relational data processing in spark . in _ proceedings of the 2015 acm",
    "sigmod international conference on management of data ( sigmod 2015 ) _ , pages 13831394 , melbourne , australia , 2015 .",
    "a. boncz , m.  zukowski , and n.  nes .",
    ": hyper - pipelining query execution . in _ proceedings of the second biennial conference on innovative data systems research ( cidr 2005 ) _ , pages 225237 , asilomar , california , 2005 .",
    "m.  j. franklin , b.  t. jnsson , and d.  kossmann .",
    "performance tradeoffs for client - server query processing . in _ proceedings of the 1996 acm",
    "sigmod international conference on management of data _ , pages 149160 ,",
    "montreal , quebec , canada , 1996 .",
    "k.  krikellas , s.  viglas , and m.  cintra .",
    "generating code for holistic query evaluation . in _ proceedings of the 26th international conference on data engineering ( icde 2010 ) _ ,",
    "pages 613624 , long beach , california .",
    "m.  zaharia , m.  chowdhury , t.  das , a.  dave , j.  ma , m.  mccauley , m.  j. franklin , s.  shenker , and i.  stoica . : a fault - tolerant abstraction for in - memory cluster computing . in _ proceedings of the 9th usenix symposium on networked systems design and implementation _ , san jose , california , 2012 ."
  ],
  "abstract_text": [
    "<S> this paper explores the novel and unconventional idea of implementing an analytical rdbms in pure javascript so that it runs completely inside a browser with no external dependencies . </S>",
    "<S> our prototype , called afterburner , generates compiled query plans that exploit typed arrays and asm.js , two relatively recent advances in javascript . on a few simple queries , </S>",
    "<S> we show that afterburner achieves comparable performance to monetdb running natively on the same machine . </S>",
    "<S> this is an interesting finding in that it shows how far javascript has come as an efficient execution platform . beyond a mere technical curiosity , we discuss how our techniques could support ubiquitous in - browser interactive analytics ( potentially integrating with browser - based notebooks ) and also present interesting opportunities for split - execution strategies where query operators are distributed between the browser and backend servers . </S>"
  ]
}