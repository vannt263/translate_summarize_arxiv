{
  "article_text": [
    "two main versions of the string matching problem differ in which of the two components ",
    "pattern @xmath2 or text @xmath0  is provided first in the input ( or is considered as fixed ) and can then be preprocessed before processing the other component .",
    "the framework when the text has to be preprocessed is usually called _ indexing _ , as it can be viewed as constructing a text index supporting matching queries .    real - time variants of the string matching problem are about as old as the string matching itself . in the 70s ,",
    "existence of real - time string matching algorithms was first studied for turing machines .",
    "for example , it has been shown that the language @xmath6 can be recognized by a turing machine , while the language @xmath7 can not @xcite . in the realm of the ram model ,",
    "the real - time variant of pattern - preprocessing string matching has been extensively studied , leading to very efficient solutions ( see e.g. @xcite and references therein ) . the indexing variant , however , still has important unsolved questions .    back in the 70s , slisenko @xcite claimed a real - time algorithm for recognizing the language @xmath8 on the ram model , but its complex and voluminous full description made it unacknowledged by the scientific community , and the problem remained to be considered open for many years . in 1994 , kosaraju @xcite reported another solution to this problem . in our present work , however , we are interested in a more general problem , when matching queries can be made at all moments , rather than after the entire text has been received . specifically , in our problem , a streaming text should be processed in real time so that at each moment , a matching query @xmath2 can be made to the portion of the text received so far .",
    "we call this the _ real - time indexing problem_. this problem has been considered in 2008 by amir and nor @xcite , who extended kosaraju s algorithm to deal with repetitive queries made at any moment of the text scan .",
    "all the three existing real - time indexing solutions @xcite support only existential queries asking whether the pattern occurs in the text , but are unable to report occurrences of the pattern . designing a real - time text indexing algorithm that would support queries on all occurrences of a pattern",
    "is stated in @xcite as the most important remaining open problem .",
    "the algorithms of @xcite assume a constant size alphabet and are both based on constructions of `` incomplete '' suffix trees which can be built real - time but can only answer existential queries . to output all occurrences of a pattern ,",
    "a fully - featured suffix tree is needed , however a real - time suffix tree construction , first studied in @xcite , is in itself an open question .",
    "the best currently known algorithms spend on each character @xmath9 worst - case time in the case of constant - size alphabets @xcite , or @xmath10 time for arbitrary alphabets @xmath11 @xcite .",
    "a truly real - time suffix tree construction seems unlikely to exist .",
    "therefore , a suffix tree alone seems to be insufficient to solve the real - time indexing problem .    in this paper",
    ", we propose the first real - time text indexing solution that supports reporting all pattern occurrences , under the assumption of constant size alphabet .",
    "similar to the previous works on real - time indexing , we assume that the text is read right - to - left , or otherwise the pattern needs to be reversed before executing the query . the general idea is to maintain several data structures , three in our case , each supporting queries for different pattern lengths .",
    "each of these structures is based on a suffix tree ( or suffix - tree - like structure ) exteded by some auxiliary data structures . to update a suffix tree",
    ", we use an implementation of weiner s algorithm which is somewhat similar to but simpler than that of @xcite .",
    "the simplification is achieved by using some external algorithmic tools , such as colored predecessor queries @xcite . as a result",
    ", we can update a suffix tree in @xmath9 worst - case time per letter , under the assumption that alphabet size is bounded by @xmath12 and without resorting to a deamortization as in @xcite .",
    "this is an interesting result in itself .",
    "the paper is organized as follows . in section  [ preliminaries ] ,",
    "we describe auxiliary data structures and present our method for online update of suffix trees . in section  [ sec : algo ] , we describe the three data structures for different pattern lengths that constitute a basis of our solution .",
    "these data structures , however , do not provide a fully real - time algorithm . then in section",
    "[ sec : realtime ] , we show how to `` fix '' the solution of section  [ sec : algo ] in order to obtain a fully real - time algorithm .    throughout the paper",
    ", @xmath13 is an alphabet of constant size @xmath14 .",
    "since the text @xmath0 is read right - to - left , it will be convenient for us to enumerate symbols of @xmath0 from the end , i.e. @xmath15 and substring @xmath16 will be denoted @xmath17 $ ] .",
    "@xmath18 $ ] denotes suffix @xmath19 $ ] . throughout this paper , we reserve @xmath5 to denote the number of objects ( occurrences of a pattern , elements in a list , etc ) in the query answer .",
    "in this section , we describe main algorithmic tools used by our algorithms .",
    "we use data structures from  @xcite for searching in dynamic colored lists .",
    "[ [ colored - range - reporting - in - a - list . ] ] colored range reporting in a list .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let elements of a dynamic linked list @xmath20 be assigned positive integer values called _",
    "a colored range reporting query on a list @xmath20 consists of two integers @xmath21 and two pointers @xmath22 and @xmath23 that point to elements @xmath24 and @xmath25 of @xmath20 .",
    "an answer to a colored range reporting query consists of all elements @xmath26 occurring between @xmath24 and @xmath25 ( including @xmath24 and @xmath25 ) such that @xmath27 , where @xmath28 is the color of @xmath29 .",
    "the following result on colored range reporting has been proved by mortensen  @xcite .",
    "[ lemma : colrep ] suppose that @xmath30 for all @xmath26 and some constant @xmath31 .",
    "we can answer color range reporting queries on @xmath20 in @xmath32 time using an @xmath33-space data structure , where @xmath34 is the number of elements in @xmath20 .",
    "insertion of a new element into @xmath20 is supported in @xmath35 time .",
    "note that the bound @xmath31 follows from the description in [ 12 ] : the data structure in  @xcite uses q - heaps  @xcite to answer certain queries on the set of colors in constant time .",
    "[ [ colored - predecessor - problem . ] ] colored predecessor problem . + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the colored predecessor query on a list @xmath20 consists of an element @xmath26 and a color @xmath36 .",
    "the answer to a query @xmath37 is the closest element @xmath38 which precedes @xmath29 such that @xmath39 .",
    "the following lemma is also proved in  @xcite ; we also refer to  @xcite , where a similar problem is solved .",
    "[ lemma : colpred ] suppose that @xmath30 for all @xmath26 and some constant @xmath31 .",
    "there exists an @xmath33 space data structure that answers colored predecessor queries on @xmath20 in @xmath35 time and supports insertions in @xmath35 time , where @xmath34 is the number of elements in @xmath20 .",
    "classical suffix tree construction algorithms read the input text online and spend an amortized constant time on each text letter , however in the worst - case , they can spend as much as a linear time on an individual letter .",
    "several papers studied the question of reducing the worst - case time spent on a letter , trying to approach the real - time update @xcite .",
    "all of them follow weiner s algorithm and process the text right - to - left , as only one new suffix has to be added when a new letter is prepended from left , resulting in a constant amount of modifications . breslauer and",
    "italiano @xcite showed how to deamortize weiner s algorithm _ in the case of constant - size alphabets _ in order to obtain @xmath9 worst - case time on each new letter .",
    "kopelowitz  @xcite proposed a solution for an arbitrary alphabet @xmath11 spending @xmath40 worst - case _ expected _ time on each prepended letter . very recently ,",
    "fischer and gawrychowski  @xcite showed how to obtain a ( deterministic ) worst - case time @xmath41 for arbitrary alphabets .    in this section ,",
    "we show a simple implementation of weiner s algorithm that achieves a worst - case @xmath9 time per letter in the case when the alphabet size is bounded by @xmath42 .",
    "our solution uses lemma  [ lemma : colpred ] as well as a constant - time solution to dynamic lowest common ancestor ( lca ) problem @xcite .",
    "thus , the solution below can be viewed as a simpler and slightly more general version of the result of @xcite , extending it from constant - size alphabets to alphabets of size @xmath42 .",
    "we first briefly recall the main idea of weiner s algorithm using a description similar to @xcite . updating a suffix tree when a new letter @xmath43 is prepended to the current text @xmath0 is done through maintaining w - links defined as follows .",
    "for a suffix tree node labeled @xmath44 and a letter @xmath45 , w - link @xmath46 points to the locus of string @xmath47 in the suffix tree , provided that @xmath47 is a substring of @xmath0 ( i.e. exists in the current suffix tree ) .",
    "note that the locus of @xmath47 can be an explicit or an implicit node , and @xmath46 is called a _",
    "hard _ or _ soft _ w - link respectively .",
    "the following properties of w - links will be useful in the sequel .",
    "[ wlink - props ]    * if for some letter @xmath43 , a node has a defined w - link @xmath48 , then any its ancestor node has a defined w - link @xmath48 too .",
    "* if two nodes @xmath44 and @xmath49 have defined hard w - links @xmath48 , then @xmath50 has a defined hard w - link @xmath48 too .",
    "when @xmath43 is prepended to a current text @xmath0 , a new leaf labeled @xmath51 must be created and attached to either an existing node or a new node created by splitting an existing edge . to find the attachment node ,",
    "the algorithm finds the lowest ancestor @xmath44 of the leaf labeled @xmath0 for which a ( possibly soft ) w - link @xmath46 is defined .",
    "then the target node @xmath46 is the branching node .",
    "the main difficulty of weiner s approach is to find the lowest ancestor of a leaf with a defined w - link @xmath46 .",
    "another difficulty is to update ( soft ) w - links when the attachment node results from an edge split ( see @xcite ) .    in our solution , we store only hard w - links and do not store soft w - links at all .",
    "note that a hard w - link , once installed , does not need to be updated for the rest of the algorithm @xcite .",
    "information about soft w - links is computed `` on the fly '' using the following lemma .",
    "[ lemma : wlink1 ] assume that for a node @xmath44 , @xmath46 is defined and is a soft link pointing to an implicit node located on an edge @xmath52 .",
    "then there exists a unique highest descendant @xmath53 of @xmath44 for which @xmath54 is a hard link , and , moreover , @xmath55 .    to find the lowest ancestor @xmath44 of a given node @xmath56 with a defined ( possibly soft ) w - link @xmath46 ,",
    "consider the euler tour of the current suffix tree in which each internal node occurs two times corresponding to its first and last visits .",
    "then the following lemma holds .",
    "[ lemma : wlink2 ] consider a node @xmath56 .",
    "assume that @xmath57 is not defined and @xmath44 is the lowest ancestor of @xmath56 for which a ( possibly soft ) link @xmath46 is defined .",
    "let @xmath58 be the closest node preceding @xmath56 in the euler tour of the suffix tree such that @xmath59 is a hard link .",
    "let @xmath60 be the closest node following @xmath44 in euler tour of the suffix tree such that @xmath61 is a hard link .",
    "then @xmath44 is the lowest node between @xmath62 and @xmath63 .",
    "moreover , if @xmath62 is the lowest , then @xmath58 is the highest descendant of @xmath44 with a defined hard w - link @xmath48 , otherwise @xmath60 is such a descendant .    by lemma  [ wlink - props](i ) ,",
    "if @xmath57 is not defined , then @xmath48 is not defined for any descendant of @xmath56 .",
    "thus , no node occurring between the first and the second occurrences of @xmath56 in the euler tour has a defined link @xmath48 .",
    "consequently , definitions of nodes @xmath58 and @xmath60 are unambiguous .    by lemma  [ lemma : wlink1 ]",
    ", @xmath44 has a unique closest descendant , say @xmath49 , with a defined hard link @xmath64 .",
    "if @xmath49 occurs before @xmath56 in the euler tour , then @xmath49 is the closest node preceding @xmath56 in the euler tour with defined @xmath64 . to show this , assume",
    "there is a closer such node @xmath65 .",
    "observe that @xmath65 is also a descendant of @xmath44 and @xmath65 is not a descendant of @xmath49 . by lemma  [ wlink - props](ii ) ,",
    "@xmath66 is a node with a defined hard link @xmath48 . on the other hand",
    ", @xmath66 is a proper ancestor of @xmath49 which is a contradiction . therefore , @xmath49 is node @xmath58 from the lemma .",
    "symmetrically , if @xmath49 occurs after @xmath56 in the euler tour , then @xmath49 is node @xmath60 from the lemma . clearly , to compute @xmath44 , it is sufficient to pick the lowest between @xmath62 and @xmath63 .",
    "based on the above , we implement weiner s algorithm by maintaining the euler tour of the current suffix tree in a colored list @xmath67 .",
    "if a node @xmath44 has a defined hard w - link @xmath46 , then both occurrences of @xmath44 in @xmath67 are colored with @xmath43 .",
    "note that a node can have up to @xmath68 hard w - links and therefore have up to @xmath69 occurrences in @xmath67 .",
    "however , the total number of hard w - links is limited by the number of tree nodes , as a node has at most one _ incoming _ hard w - link .    by lemma  [ lemma : colpred ] , we can answer colored predecessor and successor queries on @xmath67 in @xmath70 time .",
    "therefore , nodes @xmath58 and @xmath60 defined in lemma  [ lemma : wlink2 ] can be found in @xmath70 time .",
    "using lowest common ancestor queries on a dynamic tree @xcite , @xmath62 and @xmath63 can be computed in @xmath1 time .",
    "therefore , updating the suffix tree after prepending a new symbol is done is @xmath71 time .",
    "as an update can introduce two new hard w - links , we also need to update the colored list @xmath72 .",
    "this is easily done in @xmath1 time .",
    "( details are left out and can be found e.g. in @xcite . )",
    "we conclude with the final result of this section .",
    "[ update - time ] consider a text over an alphabet @xmath11 , @xmath73 , arriving online right - to - left .",
    "after prepending a new letter to the current text @xmath0 , the suffix tree of @xmath0 can be updated in time @xmath74 using an auxiliary data structure of size @xmath75 .",
    "in this section we describe the main part of our algorithm of real - time text indexing .",
    "based on the suffix tree construction from the previous section , the algorithm updates the index by reading the text in the right - to - left order .",
    "however , the algorithm we describe in this section will not be on - line , as it will have to access symbols to the left of the currently processed symbol .",
    "another `` flaw '' of the algorithm is that it will support pattern matching queries only with an additional exception : we will be able to report all occurrences of a pattern except for those with start positions among a small number of most recently processed symbols of @xmath0 . in the next section",
    "we will show how to fix these issues and turn our algorithm into a fully real - time indexing solution that reports all occurrences of a pattern .",
    "the algorithm distinguishes between three types of query patterns depending on their length : _ long patterns _ contain at least @xmath76 symbols , _ medium - size patterns _ contain between @xmath77 and @xmath76 symbols , and _ short patterns _ contain less than @xmath77 symbols . ] . for",
    "each of the three types of patterns , the algorithm will maintain a separate data structure supporting queries in @xmath3 time for matching patterns of the corresponding type .      to match long patterns",
    ", we maintain a _ sparse suffix tree _",
    "@xmath78 storing only suffixes that start at positions @xmath79 for @xmath80 and @xmath81 .",
    "suffixes stored in @xmath78 are regarded as strings over a meta - alphabet of size @xmath82 .",
    "this allows us to use the method of section  [ sec : onlinenew ] to update @xmath78 , spending @xmath9 time on each each meta - character encoding @xmath9 regular characters .",
    "( we recall that @xmath83 . )    using @xmath78 we can find occurrences of a pattern @xmath2 that start at positions @xmath84 for @xmath80 , but not occurrences starting at positions @xmath85 for @xmath86 . to be able to find all occurrences ,",
    "we maintain a list @xmath87 defined similarly to list @xmath67 from section  [ sec : onlinenew ] .",
    "the list @xmath87 contains copies of all nodes of @xmath78 as they occur during the euler tour of @xmath78 .",
    "@xmath87 contains one element for each leaf and two elements for each internal node of @xmath78 . if a node of @xmath87 is a leaf that corresponds to a suffix @xmath18 $ ] , we mark it with the meta - character @xmath88=t_{i+1}t_{i+2}\\ldots t_{i+d}$ ] which is interpreted as the color of the leaf for the suffix @xmath18 $ ] . colors",
    "are ordered by lexicographic order of underlying strings .",
    "if @xmath89 is a string with @xmath90 , then @xmath91 defines an interval of colors , denoted @xmath92 $ ] , corresponding to all character strings of length @xmath93 with prefix @xmath91 .",
    "recall that there are @xmath42 different colors . on list @xmath87",
    ", we maintain the data structure of lemma  [ lemma : colrep ] for colored range reporting queries .",
    "the update of @xmath78 and @xmath87 is done as follows .",
    "after reading character @xmath94 where @xmath95 for @xmath80 , we add suffix @xmath18 $ ] , viewed as a string over the meta - alphabet of cardinality @xmath42 , to @xmath78 following the algorithm described in section  [ sec : onlinenew ] .",
    "in addition , we have to update @xmath87 , i.e. to insert to @xmath87 the new leaf holding the suffix @xmath18 $ ] colored with @xmath96 .",
    "( note that at this point the algorithm `` looks ahead '' for the forthcoming @xmath93 letters of @xmath0 . )",
    "if a new internal node has been inserted into @xmath78 , we also update the list @xmath87 accordingly .",
    "since the meta - alphabet size is only @xmath42 , navigation in @xmath78 from a node to a child can be supported in @xmath1 time .",
    "observe that the children of any internal node @xmath97 are naturally ordered by the lexicographic order of edge labels .",
    "we store the children of @xmath49 in a data structure @xmath98 which allows us to find in time @xmath1 the child whose edge label starts with a string ( meta - character ) @xmath99 .",
    "moreover , we can also compute in time @xmath1 the `` smallest '' and the `` largest '' child of @xmath49 whose edge label starts with a string @xmath89 with @xmath100 .",
    "@xmath98 will also support adding a new edge to @xmath98 in @xmath1 time .",
    "data structure @xmath98 can be implemented using e.g. atomic heaps @xcite ; since all elements in @xmath98 are bounded by @xmath101 , we can also implement @xmath98 as described in  @xcite .",
    "we now consider a long query pattern @xmath102 and show how the occurrences of @xmath2 are computed .",
    "an occurrence of @xmath2 is said to be a @xmath103-occurrence if it starts in @xmath0 at a position @xmath104 , for some @xmath105 . for each @xmath103 , @xmath106",
    ", we find all @xmath103-occurrences as follows .",
    "first we `` spell out '' @xmath107 in @xmath78 over the meta - alphabet , i.e. we traverse @xmath78 proceeding by blocks of up to @xmath93 letters of @xmath13 .",
    "if this process fails at some step , then @xmath2 has no @xmath103-occurrences . otherwise , we spell out @xmath108 completely , and retrieve the closest explicit descendant node @xmath109 , or a range of descendant nodes @xmath110 in the case when @xmath108 spells to an explicit node except for a suffix of length less than @xmath93 .",
    "the whole spelling step takes time @xmath111 .",
    "now we jump to the list @xmath87 and retrieve the first occurrence of @xmath109 ( or @xmath112 ) and the second occurrence of @xmath109 ( or @xmath113 ) in @xmath87 .",
    "a leaf @xmath44 of @xmath114 corresponds to a @xmath103-occurrence of @xmath2 if and only if @xmath44 occurs in the subtree of @xmath109 ( or the subtrees of @xmath115 ) and the color of @xmath44 belongs to @xmath116 $ ] . in the list @xmath87 , these leaves occur precisely within the interval we computed .",
    "therefore , all @xmath103-occurrences of @xmath2 can be retrieved in time @xmath117 by a colored range reporting query ( lemma  [ lemma : colrep ] ) , where @xmath118 is the number of @xmath103-occurrences .",
    "summing up over all @xmath103 , all occurrences of a long pattern @xmath2 can be reported in time @xmath119 , as @xmath120 , @xmath83 and @xmath121 .",
    "now we show how to answer matching queries for patterns @xmath2 where @xmath122 . in a nutshell",
    ", we apply the same method as in section  [ sec : long ] with the main difference that the sparse suffix tree will store only _ truncated suffixes _ of length @xmath76 , i.e. prefixes of suffixes bounded by @xmath76 characters .",
    "we store truncated suffixes starting at positions spaced by @xmath123 characters .",
    "the total number of different truncated suffixes is at most @xmath124 .",
    "this small number of suffixes will allow us to search and update the data structures faster compared to section  [ sec : long ] .",
    "we now describe the details of the construction .",
    "we store all truncated suffixes that start at positions @xmath125 , for @xmath80 and @xmath126 , in a tree @xmath127 .",
    "@xmath127 is organized in the same way as the standard suffix tree ; that is , @xmath127 is a compacted trie for substrings @xmath128 $ ] , where these substrings are regarded as strings over the meta - alphabet @xmath129 . and @xmath130 are integers and @xmath131 divides @xmath132 .",
    "if this is not the case , we can find @xmath133 and @xmath93 that satisfy these requirements such that @xmath134 and @xmath135 . ]",
    "observe that the same truncated suffix can occur several times .",
    "therefore , we augment each leaf @xmath49 with a list of _ colors _ @xmath136 corresponding to left contexts of the corresponding truncated suffix @xmath91 . more precisely ,",
    "if @xmath137 $ ] for some @xmath80 , then @xmath138 $ ] is added to @xmath136 . note that the number of colors is bounded by @xmath139 .",
    "furthermore , for each color @xmath36 in @xmath136 , we store all positions @xmath140 of @xmath0 such that @xmath91 occurs at @xmath141 and @xmath142=col$ ] .",
    "similar to section  [ sec : long ] , we maintain a colored list @xmath143 that stores the euler tour traversal of @xmath127 . for each internal node , @xmath143 contains two elements . for every leaf @xmath49 and for each value @xmath36 in its color list @xmath136",
    ", @xmath143 contains a separate element colored with @xmath36 .",
    "observe that since the size of @xmath143 is bounded by @xmath144 , updates of @xmath143 can be supported in @xmath145 time and colored reporting queries on @xmath143 can be answered in @xmath146 time ( lemma  [ lemma : colrep ] ) .",
    "truncated suffixes are added to @xmath127 using a method similar to that of section  [ sec : long ] . after reading a symbol @xmath147 for some @xmath80",
    ", we insert @xmath148 $ ] colored with @xmath138 $ ] into the tree @xmath127 .",
    "insertion of @xmath149 is done as described in section  [ sec : onlinenew ] , and the list @xmath143 is updated accordingly .",
    "if @xmath143 already contains a leaf with string value @xmath149 and color @xmath138 $ ] , we add @xmath125 to the list of its occurrences , otherwise we insert a new element into @xmath143 and initialize its location list to @xmath125 .",
    "altogether , the addition of a new truncated suffix @xmath149 requires @xmath150 time .    a query for a pattern @xmath102 , such that @xmath151 , is answered in the same way as in section  [ sec : long ] .",
    "for each @xmath152 , we find locus nodes @xmath153 ( possibly with @xmath154 ) of @xmath155 .",
    "then , we find all elements in @xmath143 occurring between the first occurrence of @xmath156 and the second occurrence of @xmath157 and colored with a color @xmath36 that belongs to @xmath158 $ ] . for every such element , we traverse the associated list of occurrences : if a position @xmath141 is in the list , then @xmath2 occurs at position @xmath159 .",
    "the total time needed to find all occurrences of a medium - size pattern @xmath2 is @xmath160 since @xmath161 .",
    "finally , we describe our indexing data structure for patterns @xmath2 with @xmath162 .",
    "we maintain the tree @xmath163 of truncated suffixes of length @xmath164 seen so far in the text .",
    "for every position @xmath141 of @xmath0 , @xmath163 contains the substring @xmath165 $ ] .",
    "@xmath163 is organized as a compacted trie .",
    "we support queries and updates on @xmath163 using tabulation .",
    "there are @xmath166 different trees , and @xmath167 different queries can be made on each tree .",
    "therefore , we can afford explicitly storing all possible trees @xmath163 and tabulating possible tree updates .",
    "each internal node of a tree stores pointers to its lefmost and rightmost leaves , the leaves of a tree are organized in a list , and each leaf stores the encoding of the corresponding string @xmath168 .    the _ update table _ @xmath169 stores , for each tree @xmath163 and for any string @xmath168 , @xmath170 , a pointer to the tree @xmath171 ( possibly the same ) obtained after adding @xmath168 to @xmath163 .",
    "table @xmath169 uses @xmath172 space . the _ output table _",
    "@xmath173 stores , for every string @xmath168 of length @xmath174 , the list of positions in the current text @xmath0 where @xmath168 occurs .",
    "@xmath173 has @xmath175 entries and all lists of occurrences take @xmath176 space altogether .",
    "when scanning the text , we maintain the encoding of the string @xmath168 of @xmath174 most recently read symbols of @xmath0 .",
    "the encoding is updated after each symbol using bit operations . after reading a new symbol , the current tree @xmath163 is updated using table @xmath169 and the current position is added to the entry @xmath177 $ ] .",
    "updates take @xmath1 time .    to answer a query @xmath2 , @xmath178",
    ", we find the locus @xmath44 of @xmath2 in the current tree @xmath163 , retrieve the leftmost and rightmost leaves and traverse the leaves in the subtree of @xmath44 .",
    "for each traversed leaf @xmath179 with label @xmath168 , we report the occurrences stored in @xmath177 $ ] .",
    "the query takes time @xmath3 .",
    "the indexes for long and medium - size patterns , described in sections  [ sec : long ] and [ sec : medium ] respectively , do not provide real - time indexing solutions for several reasons .",
    "the index for long patterns , for example , requires to look ahead for the forthcoming @xmath93 symbols when processing symbols @xmath180 for @xmath95 , @xmath80 .",
    "furthermore , for such @xmath141 , we are unable to find occurrences of query patterns @xmath2 starting at positions @xmath181 before processing @xmath180 .",
    "a similar situation holds for medium - size patterns .",
    "another issue is that in our previous development we assumed the length @xmath182 of @xmath0 to be known , whereas this may of course not be the case in the real - time setting . in this section ,",
    "we show how to fix these issues in order to turn the indexes real - time .",
    "firstly we show how the data structures of sections  [ sec : long ] and [ sec : medium ] can be updated in a real - time mode .",
    "then , we describe how to search for patterns that start among most recently processed symbols .",
    "we describe our solutions to these issues for the case of long patterns , as a simple change of parameters provides a solution for medium - size patterns too .",
    "finally , we will show how we can circumvent the fact that the length of @xmath0 is not known in advance .    in the algorithm of section  [ sec : long ] ,",
    "the text is partitioned into blocks of length @xmath93 , and the insertion of a new suffix @xmath18 $ ] is triggered only when the leftmost symbol @xmath180 of a block is reached .",
    "the insertion takes time @xmath183 and assumes the knowledge of the forthcoming block @xmath184 . to turn this algorithm real - time",
    ", we apply a standard deamortization technique .",
    "we distribute the cost of the insertion of suffix @xmath185 $ ] over @xmath93 symbols of the block @xmath184 .",
    "this is correct , as by the time we start reading the block @xmath184 , we have read the block @xmath186 and therefore have all necessary information to insert suffix @xmath185 $ ] . in this way",
    ", we spend @xmath1 time per symbol to update all involved data structures .",
    "now assume we are reading a block @xmath184 , i.e. we are processing some symbol @xmath187 for @xmath188 . at this point , we are unable to find occurrences of a query pattern @xmath2 starting at @xmath189 as well as within the two previous blocks , as they have not been indexed yet .",
    "this concerns up to @xmath190 most recent symbols .",
    "we then introduce a separate procedure to search for occurrences that start in @xmath191 leftmost positions of the already processed text .",
    "this can be done by simply storing @xmath0 in a compact form @xmath192 where every @xmath193 consecutive symbols are packed into one computer word most recently read symbols in compact form . ] .",
    "thus , @xmath192 uses @xmath194 words of space . using @xmath192",
    ", we can test whether @xmath195=p$ ] , for any pattern @xmath2 and any position @xmath196 , in @xmath197 time .",
    "therefore , checking @xmath191 positions takes time @xmath198 for a long pattern @xmath2 .",
    "we now describe how we can apply our algorithm in the case when the text length is not known beforehand . in this case , we assume @xmath199 to take increasing values @xmath200 as long as the text @xmath0 keeps growing . here , @xmath201 is some appropriate initial value and @xmath202 for @xmath203 .",
    "suppose now that @xmath204 is the currently assumed value of @xmath199 .",
    "after we reach character @xmath205 , during the processing of the next @xmath206 symbols , we keep building the index for @xmath207 and , in parallel , rebuild all the data structures under assumption that @xmath208 . in particular , if @xmath209 , we build a new index for long patterns , and if @xmath210 , we build a new index for meduim - size and short patterns . if @xmath211 , we also construct a new compact representation @xmath192 introduced earlier in this section .",
    "altogether , we distribute the construction cost of the data structures for @xmath212 $ ] under assumption @xmath213 over the processing of @xmath214 . since @xmath215 , processing these @xmath206 symbols remains real - time . by the time @xmath216 has been read ,",
    "all data structures for @xmath213 have been built , and the algorithm proceeds with the new value @xmath217 .",
    "observe finally that the intervals @xmath218 $ ] are all disjoint , therefore the overhead per letter incurred by the procedure remains constant . in conclusion , the whole algorithm remains real - time .",
    "we finish with our main result .",
    "[ maintheorem ] there exists a data structure storing a text @xmath0 over a constant - size alphabet that can be updated in @xmath1 worst - case time after prepending a new symbol to @xmath0 .",
    "this data structure supports reporting all occurrences of a pattern @xmath2 in the current text @xmath0 in @xmath3 time , where @xmath5 is the number of occurrences .",
    "in this paper we presented the first real - time indexing data structure that supports reporting all pattern occurrences in optimal time @xmath3 .",
    "as in the previous works on this topic  @xcite , we assume that the input text is over an alphabet of constant size .",
    "it may be possible to extend our result to alphabets of poly - logarithmic size .",
    "a.  amir , t.  kopelowitz , m.  lewenstein , and n.  lewenstein . towards real - time suffix tree construction . in m.  consens and g.  navarro , editors ,",
    "international symposium on string processing and information retrieval ( spire ) _ , volume 3772 of _ lecture notes in computer science _ , pages 6778 .",
    "springer berlin heidelberg , 2005 .",
    "a.  amir , t.  kopelowitz , m.  lewenstein , and n.  lewenstein . towards real - time suffix tree construction . in _ proc .",
    "12th international conference on string processing and information retrieval ( spire 2005 ) _ , pages 6778 , 2005 .",
    "d.  breslauer , r.  grossi , and f.  mignosi .",
    "simple real - time constant - space string matching . in r.",
    "giancarlo and g.  manzini , editors , _ combinatorial pattern matching _ , volume 6661 of _ lecture notes in computer science _ , pages 173183 .",
    "springer berlin heidelberg , 2011 .",
    "d.  breslauer and g.  f. italiano . near real - time suffix tree construction via the fringe marked ancestor problem . in _ proc .",
    "18th international symposium on string processing and information retrieval ( spire 2011 ) _ , pages 156167 , 2011 .",
    "g.  franceschini and r.  grossi . .",
    "in _ proc . international colloquium on automata , languages and programming ( icalp 2004 ) _ , lecture notes in computer science , pages 606617 .",
    "springer berlin / heidelberg , 2004 .",
    "t.  kopelowitz . on - line indexing for general alphabets via predecessor queries on subsets of an ordered list . in _ proc .",
    "53rd annual ieee symposium on foundations of computer science ( focs 2012 ) _ , pages 283292 , 2012 .",
    "s.  r. kosaraju .",
    "real - time pattern matching and quasi - real - time construction of suffix trees ( preliminary version ) . in _ proc .",
    "26th annual acm symposium on theory of computing ( stoc 1994 ) _ , pages 310316 .",
    "acm , 1994 .",
    "g.  kucherov , y.  nekrich , and t.  starikovskaya .",
    "cross - document pattern matching . in j.",
    "krkkinen and j.  stoye , editors , _ proceedings of the 23rd annual symposium on combinatorial pattern matching ( cpm ) , july 3 - 5 , 2012 , helsinki ( finland ) _ , volume 7354 of _ lecture notes in computer science _ ,",
    "pages 196207 .",
    "springer verlag , 2012 .    c.  w. mortensen .",
    "fully - dynamic two dimensional orthogonal range and line segment intersection reporting in logarithmic time . in _ proc .",
    "14th annual acm - siam symposium on discrete algorithms ( soda 2003 ) _ , pages 618627 , 2003 .",
    "a.  slisenko .",
    "string - matching in real time : some properties of the data structure . in _ mathematical foundations of computer science 1978 , proceedings ,",
    "7th symposium , zakopane , poland , september 4 - 8 , 1978 _ , volume  64 of _ lecture notes in computer science _ , pages 493496 .",
    "springer , 1978 ."
  ],
  "abstract_text": [
    "<S> in this paper we describe a data structure that supports pattern matching queries on a dynamically arriving text over an alphabet of constant size . </S>",
    "<S> each new symbol can be prepended to @xmath0 in @xmath1 worst - case time . at any moment </S>",
    "<S> , we can report all occurrences of a pattern @xmath2 in the current text in @xmath3 time , where @xmath4 is the length of @xmath2 and @xmath5 is the number of occurrences . </S>",
    "<S> this resolves , under assumption of constant size alphabet , a long - standing open problem of existence of a real - time indexing method for string matching ( see @xcite ) . </S>"
  ]
}