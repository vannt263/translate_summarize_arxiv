{
  "article_text": [
    "as neural networks are applied to increasingly complex tasks , they are often trained to meet end - to - end objectives that go beyond simple functional specifications .",
    "these objectives include , for example , generating realistic images ( e.g. ,  @xcite ) and solving multiagent problems ( e.g. ,  @xcite ) . advancing these lines of work , we show that neural networks can learn to protect their communications in order to satisfy a policy specified in terms of an adversary .",
    "cryptography is broadly concerned with algorithms and protocols that ensure the secrecy and integrity of information .",
    "cryptographic mechanisms are typically described as programs or turing machines .",
    "attackers are also described in those terms , with bounds on their complexity ( e.g. , limited to polynomial time ) and on their chances of success ( e.g. , limited to a negligible probability ) .",
    "a mechanism is deemed secure if it achieves its goal against all attackers .",
    "for instance , an encryption algorithm is said to be secure if no attacker can extract information about plaintexts from ciphertexts .",
    "modern cryptography provides rigorous versions of such definitions  @xcite",
    ".    adversaries also play important roles in the design and training of neural networks .",
    "they arise , in particular , in work on adversarial examples  @xcite and on generative adversarial networks ( gans )  @xcite . in this latter context , the adversaries are neural networks ( rather than turing machines ) that attempt to determine whether a sample value was generated by a model or drawn from a given data distribution . furthermore",
    ", in contrast with definitions in cryptography , practical approaches to training gans do not consider all possible adversaries in a class , but rather one or a small number of adversaries that are optimized by training .",
    "we build on these ideas in our work .",
    "neural networks are generally not meant to be great at cryptography .",
    "famously , the simplest neural networks can not even compute xor , which is basic to many cryptographic algorithms .",
    "nevertheless , as we demonstrate , neural networks can learn to protect the confidentiality of their data from other neural networks : they discover forms of encryption and decryption , without being taught specific algorithms for these purposes .    knowing how to encrypt",
    "is seldom enough for security and privacy .",
    "interestingly , neural networks can also learn _ what _ to encrypt in order to achieve a desired secrecy property while maximizing utility .",
    "thus , when we wish to prevent an adversary from seeing a fragment of a plaintext , or from estimating a function of the plaintext , encryption can be selective , hiding the plaintext only partly .",
    "the resulting cryptosystems are generated automatically . in this respect",
    ", our work resembles recent research on automatic synthesis of cryptosystems , with tools such as zoocrypt  @xcite , and contrasts with most of the literature , where hand - crafted cryptosystems are the norm .",
    "zoocrypt relies on symbolic theorem - proving , rather than neural networks .",
    "classical cryptography , and tools such as zoocrypt , typically provide a higher level of transparency and assurance than we would expect by our methods .",
    "our model of the adversary , which avoids quantification , results in much weaker guarantees . on the other hand , it is refreshingly simple , and it may sometimes be appropriate .",
    "consider , for example , a neural network with several components , and suppose that we wish to guarantee that one of the components does not rely on some aspect of the input data , perhaps because of concerns about privacy or discrimination .",
    "neural networks are notoriously difficult to explain , so it may be hard to characterize how the component functions . a simple solution is to treat the component as an adversary , and to apply encryption so that it does not have access to the information that it should not use . in this respect ,",
    "the present work follows the recent research on fair representations  @xcite , which can hide or remove sensitive information , but goes beyond that work by allowing for the possibility of decryption , which supports richer dataflow structures",
    ".    classical cryptography may be able to support some applications along these lines .",
    "in particular , homomorphic encryption enables inference on encrypted data  @xcite . on the other hand , classical cryptographic functions",
    "are generally not differentiable , so they are at odds with training by stochastic gradient descent ( sgd ) , the main optimization technique for deep neural networks . therefore , we would have trouble learning _ what _ to encrypt , even if we know how to encrypt .",
    "integrating classical cryptographic functions  and , more generally , integrating other known functions and relations ( e.g. ,  @xcite)into neural networks remains a fascinating problem .",
    "prior work at the intersection of machine learning and cryptography has focused on the generation and establishment of cryptographic keys  @xcite , and on corresponding attacks  @xcite . in contrast , our work takes these keys for granted , and focuses on their use ; a crucial , new element in our work is the reliance on adversarial goals and training .",
    "more broadly , from the perspective of machine learning , our work relates to the application of neural networks to multiagent tasks , mentioned above , and to the vibrant research on generative models and on adversarial training ( e.g. ,  @xcite ) . from the perspective of cryptography , it relates to big themes such as privacy and discrimination .",
    "while we embrace a playful , exploratory approach , we do so with the hope that it will provide insights useful for further work on these topics .",
    "section  [ sec : sharedkey ] presents our approach to learning symmetric encryption ( that is , shared - key encryption , in which the same keys are used for encryption and for decryption ) and our corresponding results .",
    "appendix  [ sec : publickey ] explains how the same concepts apply to asymmetric encryption ( that is , public - key encryption , in which different keys are used for encryption and for decryption ) .",
    "section  [ sec : appexperiments ] considers selective protection .",
    "section  [ sec : conclusion ] concludes and suggests avenues for further research .",
    "appendix  [ sec : background ] is a brief review of background on neural networks .",
    "this section discusses how to protect the confidentiality of plaintexts using shared keys .",
    "it describes the organization of the system that we consider , and the objectives of the participants in this system .",
    "it also explains the training of these participants , defines their architecture , and presents experiments .",
    "a classic scenario in security involves three parties : alice , bob , and eve .",
    "typically , alice and bob wish to communicate securely , and eve wishes to eavesdrop on their communications .",
    "thus , the desired security property is secrecy ( not integrity ) , and the adversary is a `` passive attacker '' that can intercept communications but that is otherwise quite limited : it can not initiate sessions , inject messages , or modify messages in transit .",
    "we start with a particularly simple instance of this scenario , depicted in figure  [ fig : symm ] , in which alice wishes to send a single confidential message @xmath0 to bob .",
    "the message @xmath0 is an input to alice .",
    "when alice processes this input , it produces an output @xmath1 .",
    "( `` @xmath0 '' stands for `` plaintext '' and `` @xmath1 '' stands for `` ciphertext '' . )",
    "both bob and eve receive @xmath1 , process it , and attempt to recover  @xmath0 .",
    "we represent what they compute by @xmath2 and @xmath3 , respectively .",
    "alice and bob have an advantage over eve : they share a secret key @xmath4 .",
    "we treat @xmath4 as an additional input to alice and bob .",
    "we assume one fresh key @xmath4 per plaintext @xmath0 , but , at least at this abstract level , we do not impose that @xmath4 and  @xmath0 have the same length .    for us ,",
    "alice , bob , and eve are all neural networks .",
    "we describe their structures in sections  [ sec : nnarchitecture ] and  [ sec : sharedkeyexperiments ] .",
    "they each have parameters , which we write @xmath5 , @xmath6 , and @xmath7 , respectively .",
    "since @xmath5 and @xmath6 need not be equal , encryption and decryption need not be the same function even if alice and bob have the same structure . as is common for neural networks , alice , bob , and eve work over tuples of floating - point numbers , rather than sequences of bits .",
    "in other words , @xmath4 , @xmath0 , @xmath2 , @xmath3 , and @xmath1 are all tuples of floating - point numbers .",
    "note that , with this formulation , @xmath1 , @xmath2 , and @xmath3 may consist of arbitrary floating - point numbers even if @xmath0 and @xmath4 consist of 0s and 1s . in practice ,",
    "our implementations constrain these values to the range @xmath8 , but permit the intermediate values .",
    "we have explored alternatives ( based on williams reinforce algorithm  @xcite or on foerster et al.s discretization technique  @xcite ) , but omit them as they are not essential to our main points .",
    "this set - up , although rudimentary , suffices for basic schemes , in particular allowing for the possibility that alice and bob decide to rely on @xmath4 as a one - time pad , performing encryption and decryption simply by xoring the key @xmath4 with the plaintext @xmath0 and the ciphertext @xmath1 , respectively .",
    "however , we do not require that alice and bob function in this way  and indeed , in our experiments in section  [ sec : sharedkeyexperiments ] , they discover other schemes . for simplicity",
    ", we ignore the process of generating a key from a seed .",
    "we also omit the use of randomness for probabilistic encryption  @xcite .",
    "such enhancements may be the subject of further work .      informally , the objectives of the participants are as follows .",
    "eve s goal is simple : to reconstruct @xmath0 accurately ( in other words , to minimize the error between @xmath0 and @xmath3 ) .",
    "alice and bob want to communicate clearly ( to minimize the error between @xmath0 and @xmath2 ) , but also to hide their communication from eve .",
    "note that , in line with modern cryptographic definitions ( e.g. ,  @xcite ) , we do not require that the ciphertext @xmath1 `` look random '' to eve .",
    "a ciphertext may even contain obvious metadata that identifies it as such .",
    "therefore , it is not a goal for eve to distinguish @xmath1 from a random value drawn from some distribution . in this respect ,",
    "eve s objectives contrast with common ones for the adversaries of gans . on the other hand",
    ", one could try to reformulate eve s goal in terms of distinguishing the ciphertexts constructed from two different plaintexts .    given these objectives , instead of training each of alice and bob separately to implement some known cryptosystem  @xcite ,",
    "we train alice and bob jointly to communicate successfully and to defeat eve without a pre - specified notion of what cryptosystem they may discover for this purpose .",
    "much as in the definitions of gans , we would like alice and bob to defeat the best possible version of eve , rather than a fixed eve .",
    "of course , alice and bob may not win for every plaintext and every key , since knowledge of some particular plaintexts and keys may be hardwired into eve .",
    "( for instance , eve could always output the same plaintext , and be right at least once . )",
    "therefore , we assume a distribution on plaintexts and keys , and phrase our goals for alice and bob in terms of expected values .    we write @xmath9 for alice s output on input @xmath10 , write @xmath11 for bob s output on input @xmath12 , and write @xmath13 for eve s output on input @xmath1 .",
    "we introduce a distance function @xmath14 on plaintexts .",
    "although the exact choice of this function is probably not crucial , for concreteness we take the l1 distance @xmath15 where @xmath16 is the length of plaintexts .",
    "we define a per - example loss function for eve : @xmath17 intuitively , @xmath18 represents how much eve is wrong when the plaintext is @xmath0 and the key is @xmath4 .",
    "we also define a loss function for eve over the distribution on plaintexts and keys by taking an expected value : @xmath19 we obtain the `` optimal eve '' by minimizing this loss : @xmath20 similarly , we define a per - example reconstruction error for bob , and extend it to the distribution on plaintexts and keys : @xmath21 l_b(\\theta_a,\\theta_b ) = { { \\mathbb{e}}}_{p , k}(d(p , b(\\theta_b , a(\\theta_a , p , k),k ) ) ) \\end{array}\\ ] ] we define a loss function for alice and bob by combining @xmath22 and the optimal value of  @xmath23 : @xmath24 this combination reflects that alice and bob want to minimize bob s reconstruction error and to maximize the reconstruction error of the `` optimal eve '' .",
    "the use of a simple subtraction is somewhat arbitrary ; below we describe useful variants .",
    "we obtain the `` optimal alice and bob '' by minimizing @xmath25 : @xmath26    we write `` optimal '' in quotes because there need be no single global minimum . in general , there are many equi - optimal solutions for alice and bob . as a simple example , assuming that the key is of the same size as the plaintext and the ciphertext , alice and bob may xor the plaintext and the ciphertext , respectively , with any permutation of the key , and all permutations are equally good as long as alice and bob use the same one ; moreover , with the way we architect our networks ( see section  [ sec : nnarchitecture ] ) , all permutations are equally likely to arise .",
    "training begins with the alice and bob networks initialized randomly .",
    "the goal of training is to go from that state to @xmath27 , or close to @xmath27 .",
    "we explain the training process next",
    ".      our training method is based upon sgd . in practice , much as in work on gans , our training method cuts a few corners and incorporates a few improvements with respect to the high - level description of objectives of section  [ sec : objectives ] .",
    "we present these refinements next , and give further details in section  [ sec : sharedkeyexperiments ] .",
    "first , the training relies on estimated values calculated over `` minibatches '' of hundreds or thousands of examples , rather than on expected values over a distribution .",
    "we do not compute the `` optimal eve '' for a given value of @xmath5 , but simply approximate it , alternating the training of eve with that of alice and bob . intuitively , the training may for example proceed roughly as follows .",
    "alice may initially produce ciphertexts that neither bob nor eve understand at all . by training for",
    "a few steps , alice and bob may discover a way to communicate that allows bob to decrypt alice s ciphertexts at least partly , but which is not understood by ( the present version of ) eve .",
    "in particular , alice and bob may discover some trivial transformations , akin to rot13 .",
    "after a bit of training , however , eve may start to break this code .",
    "with some more training , alice and bob may discover refinements , in particular codes that exploit the key material better .",
    "eve eventually finds it impossible to adjust to those codes .",
    "this kind of alternation is typical of games ; the theory of continuous games includes results about convergence to equilibria ( e.g. ,  @xcite ) which it might be possible to apply in our setting .",
    "furthermore , in the training of alice and bob , we do not attempt to maximize eve s reconstruction error . if we did , and made eve completely wrong , then eve could be completely right in the next iteration by simply flipping all output bits ! a more realistic and useful goal for alice and bob",
    "is , generally , to minimize the mutual information between eve s guess and the real plaintext . in the case of symmetric encryption",
    ", this goal equates to making eve produce answers indistinguishable from a random guess .",
    "this approach is somewhat analogous to methods that aim to prevent overtraining gans on the current adversary  ( * ? ? ?",
    "* section  3.1 ) . additionally , we can tweak the loss functions so that they do not give much importance to eve being a little lucky or to bob making small errors that standard error - correction could easily address .",
    "finally , once we stop training alice and bob , and they have picked their cryptosystem , we validate that they work as intended by training many instances of eve that attempt to break the cryptosystem .",
    "some of these instances may be derived from earlier phases in the training .",
    "[ [ the - architecture - of - alice - bob - and - eve ] ] the architecture of alice , bob , and eve + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    because we wish to explore whether a general neural network can learn to communicate securely , rather than to engineer a particular method , we aimed to create a neural network architecture that was _ sufficient _ to learn mixing functions such as xor , but that did not strongly encode the form of any particular algorithm .    to this end , we chose the following `` mix & transform '' architecture .",
    "it has a first fully - connected ( fc ) layer , where the number of outputs is equal to the number of inputs .",
    "the plaintext and key bits are fed into this fc layer . because each output bit can be a linear combination of all of the input bits",
    ", this layer enables  but does not mandate  mixing between the key and the plaintext bits .",
    "in particular , this layer can permute the bits .",
    "the fc layer is followed by a sequence of convolutional layers , the last of which produces an output of a size suitable for a plaintext or ciphertext .",
    "these convolutional layers learn to apply some function to groups of the bits mixed by the previous layer , without an a priori specification of what that function should be .",
    "notably , the opposite order ( convolutional followed by fc ) is much more common in image - processing applications .",
    "neural networks developed for those applications frequently use convolutions to take advantage of spatial locality . for neural cryptography , we specifically wanted locality ",
    "i.e . , which bits to combine ",
    "to be a _ learned _",
    "property , instead of a pre - specified one .",
    "while it would certainly work to manually pair each input plaintext bit with a corresponding key bit , we felt that doing so would be uninteresting .",
    "we refrain from imposing further constraints that would simplify the problem . for example",
    ", we do not tie the parameters @xmath5 and @xmath6 , as we would if we had in mind that alice and bob should both learn the same function , such as xor .      as a proof - of - concept , we implemented alice , bob , and eve networks that take @xmath16-bit random plaintext and key values , and produce @xmath16-entry floating - point ciphertexts , for @xmath28 , @xmath29 , and  @xmath30 .",
    "both plaintext and key values are uniformly distributed .",
    "keys are not deliberately reused , but may reoccur because of random selection .",
    "( the experiments in section  [ sec : appexperiments ] consider more interesting distributions and also allow plaintext and key values to have different sizes . )",
    "we implemented our experiments in tensorflow  @xcite .",
    "we ran them on a workstation with one gpu ; the specific computation platform does not affect the outcome of the experiments .",
    "we plan to release the source code for the experiments .",
    "[ [ network - structure ] ] network structure + + + + + + + + + + + + + + + + +    our networks follow the `` mix & transform '' pattern described in section  [ sec : nnarchitecture ] . the alice network concatenates two @xmath16-bit inputs ( the plaintext and the key ) into a @xmath31-entry vector , using @xmath32 and @xmath33 to represent the bit values .",
    "this vector is processed through a @xmath34 fc layer , then sent through a succession of four 1-d convolutional layers .",
    "the convolutional layers are described in terms of their window size , input depth , and output depth .",
    "each has a `` stride''the amount by which the window is shifted at each step .",
    "the concrete layers are @xmath35 $ ] , @xmath36 $ ] , @xmath37 $ ] , and @xmath38 $ ] , with strides of @xmath39 .",
    "intuitively , the first layer slides a size-4 window across the @xmath31 output elements from the fc layer , outputting two numbers ( output depth 2 ) , with stride @xmath33 .",
    "we use a sigmoid nonlinear unit after each layer except the final one . after the final layer , where the output is reduced to @xmath16 elements",
    ", we use a tanh nonlinear unit .",
    "( recall that tanh has an output domain between @xmath40 $ ] , bringing the values back to a range that can map to binary values . )",
    "the bob network is identical to the alice network the eve network takes only the ciphertext as input , and thus has a first @xmath41 fc layer .    [ [ training ] ] training + + + + + + + +    to train the networks , we use a `` minibatch '' size ranging from 256 to 4096 entries . unless otherwise specified , we present the results from the training runs with 4096 entries .",
    "we use tensorflow s adam  @xcite optimizer with a learning rate of @xmath42 .",
    "we do not reduce the learning rate over time because we wish alice , bob , and eve to be able to continue to respond strongly to changes in other components , until alice and bob  hopefully  achieve a solution that is robust to additional changes in eve .",
    "training alternates between alice / bob and eve , with alice / bob training for one minibatch , and then eve training for two minibatches .",
    "we chose this ratio in order to give a slight computational edge to the adversary eve without training it so much that it becomes excessively specific to the exact current parameters of alice and bob .",
    "empirically , this value has worked well .",
    "[ [ loss - functions ] ] loss functions + + + + + + + + + + + + + +    eve s loss function is exactly as described above : the l1 distance between eve s guess and the input plaintext .",
    "the loss function for alice and bob is more complex , as indicated in sections  [ sec : objectives ] and  [ sec : sharedkeytraining ] .",
    "this function has two components , related to bob s reconstruction error and to the eavesdropper s success .",
    "the first component is simply the l1 distance between bob s output and the input plaintext .",
    "the latter component , on the other hand , is @xmath43 .",
    "this definition expresses the goal , described in section  [ sec : sharedkeytraining ] , that eve should not do better than random guessing .",
    "accordingly , this component is minimized when half of the message bits are wrong and half are right .",
    "we choose a quadratic formula in order to place more emphasis on making eve have a large error , and to impose less of a penalty when eve guesses a few bits correctly , as should happen occasionally even if eve s guesses are effectively random . adopting this formulation allowed us to have a meaningful per - example loss function ( instead of looking at larger batch statistics ) , and improved the robustness of training .",
    "its cost is that our final , trained alice and bob typically allow eve to reconstruct slightly more bits than purely random guessing would achieve .",
    "we have not obtained satisfactory results for loss functions that depend linearly ( rather than quadratically ) on eve s reconstruction error .",
    "the best formulation remains an open question .",
    "[ [ post - training - evaluation ] ] post - training evaluation + + + + + + + + + + + + + + + + + + + + + + + +    after successfully training the networks so that they cross an accuracy threshold ( e.g. , at most 0.05 bits of reconstruction error for alice and bob , with eve achieving only 1 - 2 bits more than random guessing would predict ) , we reset the eve network and train it from scratch 5 times , each for up to 250,000 steps , recording the best result achieved by any eve .",
    "an alice / bob combination that fails to achieve the target thresholds within 150,000 steps is a training failure . if the retrained eves obtain a substantial advantage , the solution is non - robust . otherwise , we consider it a successful training outcome .    [",
    "[ results ] ] results + + + + + + +    figure  [ fig : bob_vs_eve_one ] shows , for one successful run , the evolution of bob s reconstruction error and eve s reconstruction error vs.  the number of training steps for @xmath44 bit plaintext and key values , using a minibatch size of 4096 .",
    "each point in the graph is the mean error across 4096 examples .",
    "an ideal result would have bob s reconstruction error drop to zero and eve s reconstruction error reach 8 ( half the bits wrong ) . in this example , both reconstruction errors start high . after a period of time , alice and",
    "bob start to communicate quite effectively , but in a way that allows eve to improve its understanding as well , gradually .",
    "then , around step 10,000 , alice and bob counter eve s progress . by about step 15,000 ,",
    "the training goals are effectively achieved .",
    "the remaining steps merely increase eve s reconstruction error slightly .",
    "this training graph does _ not _ look like a typical result for neural networks , where monotonicity in the number of steps is generally expected .",
    "instead , the dynamics of this adversarial training appear somewhat more reminiscent of evolutionary processes .",
    "these dynamics appear to depend on somewhat random - seeming change to cause the bits to mix slightly , but once there is some mixing , the gradient descent can rapidly drive it farther .    supporting",
    "this interpretation is the observation that training is not always successful . with @xmath44 ,",
    "six of twenty initial runs were failures that never got bob s reconstruction error under the 0.05 threshold , or failed to drive eve s reconstruction error above 7.3 bits ( of 16 ) . in order to test the robustness of the other fourteen alice / bob combinations , we retrained eve five times , and obtained reconstruction errors for eve that ranged from 4.67 to 6.97 bits , with a mean of 6.1 .",
    "figure  [ fig : bob_vs_eve_two ] shows the final reconstruction errors of bob and of the most effective retrained eve for those fourteen alice / bob combinations . if we somewhat arbitrarily define success as maintaining bob s reconstruction error at or under 0.05 bits , and requiring that eve get at least 6 bits wrong , on average , then training succeeded half of the time ( ten of twenty cases ) .    although training with an adversary is often unstable  @xcite , we suspect that some additional engineering of the neural network and its training may be able to increase this overall success rate . with a minibatch size of only 512 ,",
    "for example , we achieved a success rate of only @xmath45 ( vs.  the @xmath46 that we achieved with a minibatch size of 4096 ) . in the future",
    ", it may be worth studying the impact of minibatch sizes , and also that of other parameters such as the learning rate .",
    "analogous results hold in general for @xmath47 and @xmath48-bit keys and plaintexts ; training appears to be successful somewhat more often for @xmath48 . basically",
    ", the experiments for @xmath47 and @xmath48 indicate that there is nothing special about @xmath44 which , to a cryptographer , may look suspiciously tiny .",
    "we focus our presentation on the case of @xmath44 because , first , the experiments run more rapidly , and second , it is modestly easier to examine their behavior .",
    "for one successful training run , we studied the changes in the ciphertext induced by various plaintext / key pairs .",
    "although we did not perform an exhaustive analysis of the encryption method , we did make a few observations .",
    "first , it is key - dependent : changing the key and holding the plaintext constant results in different ciphertext output .",
    "it is also plaintext - dependent , as required for successful communication .",
    "however , it is not simply xor . in particular , the output values are often floating - point values other than 0 and 1 .",
    "moreover , the effect of a change to either a key bit or a plaintext bit is spread across multiple elements in the ciphertext , not constrained to a single bit as it would be with xor . a single - bit flip in the key",
    "typically induces significant changes in three to six of the 16 elements in the ciphertext , and smaller changes in other elements .",
    "plaintext bits are similarly diffused across the ciphertext .",
    "building on the results of section  [ sec : sharedkey ] , we study selective protection . in other words , we consider the question of whether neural networks can learn what information to protect , given confidentiality objectives described in terms of an adversary . in the simplest case",
    ", a plaintext may have several components ; if we wish to keep the adversary from seeing one of the components , it may suffice to encrypt it .",
    "more generally , we may wish to publish some values correlated with the plaintext but prevent the adversary from calculating other values .",
    "in such scenarios , protecting information selectively while maximizing utility is both challenging and interesting .      to test these ideas and to demonstrate the viability of selective protection , we focus on a concrete experiment .",
    "we construct an artificial dataset consisting of tuples of four values , @xmath49 .",
    "we aim to build and train a system that outputs two predictions of d , given the first three values as inputs : a `` true '' prediction of d ( that is , the most accurate possible estimate of  d given @xmath50 ) , and a `` privacy - preserving '' estimate of d , which we call d - public , defined as the best possible estimate of d that does not reveal any information about the value of  c.    the system organization is essentially that of figure  [ fig : symm ] , with alice and bob sharing a key , but here alice receives @xmath50 and produces d - public in addition to a ciphertext ; both bob and eve have access to alice s outputs ; bob uses them for producing an improved estimate of d , while eve attempts to recover c. thus , our goal is to demonstrate that the adversarial training permits approximating d without revealing c , and that this approximation can be combined with encrypted information and with a key in order to obtain a better approximation of  d.    the distributions of a , b , c , and d are constructed so that there is substantial correlation between them . in particular , knowing d exactly would convey some information about the likely values of  c. in our experiments , a , b , c , and d are normally distributed floating - point values with a correlation matrix imposed upon them .",
    "the specifics of how we generate a , b , c , and d are standard : we compute the cholesky decomposition @xmath51 of a 4 @xmath52 4 correlation matrix that specifies the pairwise correlations , we generate vectors of 4 normally distributed floating - point values , and then we multiply these vectors by @xmath53 in order to generate values of a , b , c , and d.    although a , b , c , and d do not correspond to any real - world data , these experiments are loosely inspired by real - world tasks .",
    "for example , a , b , and c may represent attributes of a user , which may in general be correlated , and d may represent a decision about the user , a prediction of the user s behavior , or a recommendation to the user .      in the experiments that follow , we use an augmented version of the neural network architecture of section  [ sec : nnarchitecture ] .",
    "the inputs first go into a new fc layer ( 12 inputs  eight key bits and four values  and 12 outputs ) ; the outputs of that first layer are fed into a network with the architecture of section  [ sec : nnarchitecture ] . intuitively , we chose this augmented architecture because a single fc layer should be capable of predicting d from a , b , and c , as well as making a prediction decorrelated with c ; and the architecture of section  [ sec : nnarchitecture ] suffices to encrypt any of the output of the first layer under the key .",
    "we therefore believed this augmented architecture would be sufficient to accomplish its task , though it may be more than is necessary to do so .",
    "we train eve with the goal of minimizing the squared error of its estimate of c. we train alice and bob with the goal of minimizing a linear combination of three terms : the squared error of each of the two estimates of d , and the absolute value of the covariance of eve s estimate of c with respect to the actual value of  c. we compute this covariance on a batch of training examples , and define the loss function for alice and bob batch - wise .",
    "a human engineer would naturally try to design the system somewhat differently ",
    "likely first computing the desired quantities , and then encrypting the values to be hidden , relying on the encryption and decryption components developed in section  [ sec : sharedkey ] as modules .",
    "we prefer instead an end - to - end approach , because our goal is to understand whether a neural network can learn to hide information selectively , given only a high - level specification ( `` do not leak information about c , but let people with the right key learn as much as possible about d '' ) . in this end - to - end approach ,",
    "the system does not have distinct , pre - assigned units for encryption and decryption , and all components are trained jointly . in particular , although we benefit from some of the insights from section  [ sec : sharedkey ] , we do not rely on the components developed there .",
    "end - to - end approaches are sometimes preferred in machine learning because they can more efficiently use resources and information . in our case , this feature may mean , in particular , that the cryptographic operations are optimized for the given distribution of inputs .",
    "nevertheless , our choices have the primary goal of maximizing insight , not efficiency .",
    "to understand whether the system is learning to hide information properly , we train a separate evaluator that we call `` blind eve '' , which is aware of the distribution of  c. blind eve tries to guess c relying only upon this baseline information , whereas the real eve also knows the intermediate output ( d - public ) and the ciphertext .",
    "if eve s reconstruction error becomes equal to that of blind eve , we know that eve is not successfully extracting information from the public estimate and the ciphertext .",
    "figure  [ fig : hide_c ] shows the results of adversarial training to learn to hide c. the red `` public error '' line shows the average error of d - public vs. d. the green `` bob error '' line shows bob s average reconstruction error , which drops over time until bob is making the best possible prediction of d given the input .",
    "the public error becomes low , but is slightly higher than bob s .",
    "the blue dots show eve s average error _ improvement _ over blind eve .",
    "after a few steps of training , eve s error is substantially lower than that of blind eve ( by 0.10.2 ) .",
    "as time proceeds , eve s relative advantage becomes zero .",
    "eve is not able to reconstruct any more information about c than would be possible by simply knowing the distribution of values of c.",
    "in this paper , we demonstrate that neural networks can learn to protect communications . the learning does not require prescribing a particular set of cryptographic algorithms , nor indicating ways of applying these algorithms : it is based only on a secrecy specification represented by the training objectives . in this",
    "setting , we model attackers by neural networks ; alternative models may perhaps be enabled by reinforcement learning .    there is more to cryptography than encryption . in this spirit",
    ", further work may consider other tasks , for example steganography , pseudorandom - number generation , or integrity checks .",
    "finally , neural networks may be useful not only for cryptographic protections but also for attacks .",
    "while it seems improbable that neural networks would become great at cryptanalysis , they may be quite effective in making sense of metadata and in traffic analysis .",
    "we are grateful to samy bengio , laura downs , lfar erlingsson , jakob foerster , nando de freitas , ian goodfellow , geoff hinton , chris olah , ananth raghunathan , and luke vilnis for discussions on the matter of this paper .",
    "29 [ 1]#1 [ 1]`#1 ` urlstyle [ 1]doi : # 1    martn abadi , ashish agarwal , paul barham , eugene brevdo , zhifeng chen , craig citro , gregory  s. corrado , andy davis , jeffrey dean , matthieu devin , sanjay ghemawat , ian  j. goodfellow , andrew harp , geoffrey irving , michael isard , yangqing jia , rafal jzefowicz , lukasz kaiser , manjunath kudlur , josh levenberg , dan mane , rajat monga , sherry moore , derek  gordon murray , chris olah , mike schuster , jonathon shlens , benoit steiner , ilya sutskever , kunal talwar , paul  a. tucker , vincent vanhoucke , vijay vasudevan , fernanda  b. vigas , oriol vinyals , pete warden , martin wattenberg , martin wicke , yuan yu , and xiaoqiang zheng .",
    "tensorflow : large - scale machine learning on heterogeneous distributed systems .",
    "_ corr _ , abs/1603.04467 , 2016 .",
    "url http://arxiv.org/abs/1603.04467 .",
    "martn abadi , paul barham , jianmin chen , zhifeng chen , andy davis , jeffrey dean , matthieu devin , sanjay ghemawat , geoffrey irving , michael isard , manjunath kudlur , josh levenberg , rajat monga , sherry moore , derek  gordon murray , benoit steiner , paul  a. tucker , vijay vasudevan , pete warden , martin wicke , yuan yu , and xiaoqiang zhang .",
    "tensorflow : a system for large - scale machine learning .",
    "_ corr _ , abs/1605.08695 , 2016 .",
    "url http://arxiv.org/abs/1605.08695 .",
    "boaz barak , oded goldreich , russell impagliazzo , steven rudich , amit sahai , salil vadhan , and ke  yang . on the ( im)possibility of obfuscating programs .",
    "_ j. acm _ , 590 ( 2):0 6:16:48 , may 2012 .",
    "issn 0004 - 5411 .",
    "doi : 10.1145/2160158.2160159 .",
    "url http://doi.acm.org/10.1145/2160158.2160159 .",
    "gilles barthe , juan  manuel crespo , benjamin grgoire , csar kunz , yassine lakhnech , benedikt schmidt , and santiago zanella - bguelin .",
    "fully automated analysis of padding - based encryption in the computational model . in _ proceedings of the 2013 acm sigsac conference on computer",
    "& # 38 ; communications security _ , ccs 13 , pp .   12471260 , new york , ny , usa , 2013 .",
    "isbn 978 - 1 - 4503 - 2477 - 9 .",
    "doi : 10.1145/2508859.2516663 .",
    "url http://doi.acm.org/10.1145/2508859.2516663 .",
    "xi  chen , yan duan , rein houthooft , john schulman , ilya sutskever , and pieter abbeel .",
    "infogan : interpretable representation learning by information maximizing generative adversarial nets .",
    "_ corr _ , abs/1606.03657 , 2016 .",
    "url https://arxiv.org/abs/1606.03657 .    emily  l. denton , soumith chintala , arthur szlam , and robert fergus .",
    "deep generative image models using a laplacian pyramid of adversarial networks .",
    "_ corr _ , abs/1506.05751 , 2015 .",
    "url http://arxiv.org/abs/1506.05751 .",
    "sbastien dourlens .",
    "applied neuro - cryptography .",
    "mmoire , universit paris 8 , dpartement micro - informatique micro - electronique .",
    "harrison edwards and amos  j. storkey . censoring representations with an adversary .",
    "_ corr _ , abs/1511.05897 , 2015 .",
    "url http://arxiv.org/abs/1511.05897 .",
    "jakob  n. foerster , yannis  m. assael , nando de  freitas , and shimon whiteson .",
    "learning to communicate to solve riddles with deep distributed recurrent q - networks . _",
    "corr _ , abs/1602.02672 , 2016 .",
    "url http://arxiv.org/abs/1602.02672 .",
    "jakob  n. foerster , yannis  m. assael , nando de  freitas , and shimon whiteson . learning to communicate with deep multi - agent reinforcement learning .",
    "_ corr _ , abs/1605.06676 , 2016 .",
    "url http://arxiv.org/abs/1605.06676 .",
    "yaroslav ganin , evgeniya ustinova , hana ajakan , pascal germain , hugo larochelle , franois laviolette , mario marchand , and victor  s. lempitsky . domain - adversarial training of neural networks .",
    "_ corr _ , abs/1505.07818 , 2015 .",
    ".    ran gilad - bachrach , nathan dowlin , kim laine , kristin  e. lauter , michael naehrig , and john wernsing .",
    "cryptonets : applying neural networks to encrypted data with high throughput and accuracy . in maria - florina balcan and kilian  q. weinberger ( eds . ) ,",
    "_ proceedings of the 33nd international conference on machine learning , icml 2016 , new york city , ny , usa , june 19 - 24 , 2016 _ , volume  48 of _ jmlr workshop and conference proceedings _ , pp .",
    "jmlr.org , 2016 .",
    "url http://jmlr.org/proceedings/papers/v48/gilad-bachrach16.html .",
    "shafi goldwasser and silvio micali .",
    "probabilistic encryption .",
    "_ j. comput .",
    "_ , 280 ( 2):0 270299 , 1984 .",
    "doi : 10.1016/0022 - 0000(84)90070 - 9",
    ". url http://dx.doi.org/10.1016/0022-0000(84)90070-9 .",
    "ian  j. goodfellow , jean pouget - abadie , mehdi mirza , bing xu , david warde - farley , sherjil ozair , aaron  c. courville , and yoshua bengio .",
    "generative adversarial nets . in zoubin ghahramani ,",
    "max welling , corinna cortes , neil  d. lawrence , and kilian  q. weinberger ( eds . ) , _ advances in neural information processing systems 27 : annual conference on neural information processing systems 2014 , december 8 - 13 2014 , montreal , quebec , canada _ , pp .",
    "26722680 , 2014 .",
    "url http://papers.nips.cc/paper/5423-generative-adversarial-nets .",
    "ian  j. goodfellow , jonathon shlens , and christian szegedy . explaining and harnessing adversarial examples .",
    "_ corr _ , abs/1412.6572 , 2014 .",
    "url http://arxiv.org/abs/1412.6572 .",
    "diederik  p. kingma and jimmy ba .",
    "adam : a method for stochastic optimization .",
    "_ corr _ , abs/1412.6980 , 2014 .",
    "url http://arxiv.org/abs/1412.6980 .",
    "wolfgang kinzel and ido kanter . neural cryptography .",
    "_ arxiv preprint cond - mat/0208453 _ , 2002 .",
    "alexander klimov , anton mityagin , and adi shamir .",
    "analysis of neural cryptography . in yuliang zheng ( ed . ) , _ advances in cryptology - asiacrypt 2002 , 8th international conference on the theory and application of cryptology and information security , queenstown , new zealand , december 1 - 5 , 2002 , proceedings _",
    ", volume 2501 of _ lecture notes in computer science _ , pp .   288298 .",
    "springer , 2002 .",
    "isbn 3 - 540 - 00171 - 9 .",
    "doi : 10.1007/3 - 540 - 36178 - 2_18 .",
    "url http://dx.doi.org/10.1007/3-540-36178-2_18 .",
    "yann lecun , yoshua bengio , and geoffrey hinton .",
    "deep learning .",
    ", 521:0 436444 , 2015 .",
    "christos louizos , kevin swersky , yujia li , max welling , and richard  s. zemel .",
    "the variational fair autoencoder . _",
    "corr _ , abs/1511.00830 , 2015 .",
    "url http://arxiv.org/abs/1511.00830 .",
    "arvind neelakantan , quoc  v. le , and ilya sutskever .",
    "neural programmer : inducing latent programs with gradient descent .",
    "_ corr _ , abs/1511.04834 , 2015 .",
    "url http://arxiv.org/abs/1511.04834 .",
    "sebastian nowozin , botond cseke , and ryota tomioka .",
    "f - gan : training generative neural samplers using variational divergence minimization .",
    "_ corr _ , abs/1606.00709 , 2016 .",
    "url https://arxiv.org/abs/1606.00709 .",
    "lillian  j ratliff , samuel  a burden , and s  shankar sastry . characterization and computation of local nash equilibria in continuous games . in _",
    "communication , control , and computing ( allerton ) , 2013 51st annual allerton conference on _ , pp .   917924 .",
    "ieee , 2013 .",
    "andreas ruttor .",
    "_ neural synchronization and cryptography_. phd thesis , julius maximilian university of wrzburg , 2006 .",
    "url http://www.opus - bayern.de / uni - wuerzburg / volltexte/2007/2361/.    tim salimans , ian goodfellow , wojciech zaremba , vicki cheung , alec radford , and xi  chen",
    ". improved techniques for training gans .",
    "_ corr _ , abs/1606.03498 , 2016 .",
    "url https://arxiv.org/abs/1606.03498 .",
    "sainbayar sukhbaatar , arthur szlam , and rob fergus . learning multiagent communication with backpropagation .",
    "_ corr _ , abs/1605.07736 , 2016 .",
    "url http://arxiv.org/abs/1605.07736 .",
    "christian szegedy , wojciech zaremba , ilya sutskever , joan bruna , dumitru erhan , ian  j. goodfellow , and rob fergus .",
    "intriguing properties of neural networks .",
    "_ corr _ , abs/1312.6199 , 2013 .",
    "url http://arxiv.org/abs/1312.6199 .",
    "ronald  j. williams .",
    "simple statistical gradient - following algorithms for connectionist reinforcement learning . in _",
    "machine learning _ , pp .   229256 , 1992 .",
    "pengtao xie , misha bilenko , tom finley , ran gilad - bachrach , kristin  e. lauter , and michael naehrig .",
    "crypto - nets : neural networks over encrypted data .",
    "_ corr _ , abs/1412.6181 , 2014 .",
    "url http://arxiv.org/abs/1412.6181 .",
    "paralleling section  [ sec : sharedkey ] , this section examines asymmetric encryption ( also known as public - key encryption ) .",
    "it presents definitions and experimental results , but omits a detailed discussion of the objectives of asymmetric encryption , of the corresponding loss functions , and of the practical refinements that we develop for training , which are analogous to those for symmetric encryption .      in asymmetric encryption ,",
    "a secret is associated with each principal .",
    "the secret may be seen as a seed for generating cryptographic keys , or directly as a secret key ; we adopt the latter view .",
    "a public key can be derived from the secret , in such a way that messages encrypted under the public key can be decrypted only with knowledge of the secret .",
    "we specify asymmetric encryption using a twist on our specification for symmetric encryption , shown in figure  [ fig : asymm ] . instead of directly supplying the secret encryption key to alice , we supply the secret key to a public - key generator , the output of which is available to every node .",
    "only bob has access to the underlying secret key .",
    "much as in section  [ sec : sharedkey ] , several variants are possible , for instance to support probabilistic encryption .",
    "the public - key generator is itself a neural network , with its own parameters .",
    "the loss functions treats these parameters much like those of alice and bob . in training",
    ", these parameters are adjusted at the same time as those of alice and bob .      in our experiments on asymmetric encryption ,",
    "we rely on the same approach as in section  [ sec : sharedkeyexperiments ] .",
    "in particular , we adopt the same network structure and the same approach to training .",
    "the results of these experiments are intriguing , but much harder to interpret than those for symmetric encryption . in most training runs ,",
    "the networks failed to achieve a robust outcome . often , although it appeared that alice and bob had learned to communicate secretly , upon resetting and retraining eve , the retrained adversary was able to decrypt messages nearly as well as bob was .",
    "however , figure  [ fig : asymm - result ] shows the results of _ one _ training run , in which even after five reset / retrain cycles , eve was unable to decrypt messages between alice and bob .",
    "our chosen network structure is not sufficient to learn general implementations of many of the mathematical concepts underlying modern asymmetric cryptography , such as integer modular arithmetic .",
    "we therefore believe that the most likely explanation for this successful training run was that alice and bob accidentally obtained some `` security by obscurity '' ( cf .  the derivation of asymmetric schemes from symmetric schemes by obfuscation  @xcite ) .",
    "this belief is somewhat reinforced by the fact that the training result was fragile : upon further training of alice and bob , eve _ was _ able to decrypt the messages .",
    "however , we can not rule out that the networks trained into some set of hard - to - invert matrix operations resulting in `` public - key - like '' behavior .",
    "our results suggest that this issue deserves more exploration .",
    "further work might attempt to strengthen these results , perhaps relying on new designs of neural networks or new training procedures .",
    "a modest next step may consist in trying to learn particular asymmetric algorithms , such as lattice - based ciphers , in order to identify the required neural network structure and capacity .",
    "most of this paper assumes only a few basic notions in machine learning and neural networks , as provided by general introductions ( e.g. ,  @xcite ) .",
    "the following is a brief review .",
    "neural networks are specifications of parameterized functions .",
    "they are typically constructed out of a sequence of somewhat modular building blocks .",
    "for example , the input to alice is a vector of bits that represents the concatenation of the key and the plaintext .",
    "this vector ( @xmath54 ) is input into a `` fully - connected '' layer , which consists of a matrix multiply ( by @xmath55 ) and a vector addition ( with @xmath56 ) : @xmath57 . the result of that operation",
    "is then passed into a nonlinear function , sometimes termed an `` activation function '' , such as the sigmoid function , or the hyperbolic tangent function , tanh . in classical neural networks ,",
    "the activation function represents a threshold that determines whether a neuron would `` fire '' or not , based upon its inputs .",
    "this threshold , and matrices and vectors such as @xmath55 and @xmath56 , are typical neural network `` parameters '' .",
    "`` training '' a neural network is the process that finds values of its parameters that minimize the specified loss function over the training inputs .",
    "fully - connected layers are powerful but require substantial amounts of memory for a large network .",
    "an alternative to fully - connected layers are `` convolutional '' layers .",
    "convolutional layers operate much like their counterparts in computer graphics , by sliding a parameterized convolution window across their input .",
    "the number of parameters in this window is much smaller than in an equivalent fully - connected layer .",
    "convolutional layers are useful for applying the same function(s ) at every point in an input .",
    "a neural network architecture consists of a graph of these building blocks ( often , but not always , a dag ) , specifying what the individual layers are ( e.g. , fully - connected or convolutional ) , how they are parameterized ( number of inputs , number of outputs , etc . ) , and how they are wired ."
  ],
  "abstract_text": [
    "<S> we ask whether neural networks can learn to use secret keys to protect information from other neural networks . specifically , we focus on ensuring confidentiality properties in a multiagent system , and we specify those properties in terms of an adversary . </S>",
    "<S> thus , a system may consist of neural networks named alice and bob , and we aim to limit what a third neural network named eve learns from eavesdropping on the communication between alice and bob </S>",
    "<S> . we do not prescribe specific cryptographic algorithms to these neural networks ; instead , we train end - to - end , adversarially . </S>",
    "<S> we demonstrate that the neural networks can learn how to perform forms of encryption and decryption , and also how to apply these operations selectively in order to meet confidentiality goals . </S>"
  ]
}