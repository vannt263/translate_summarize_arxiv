{
  "article_text": [
    "set reconciliation occurs naturally . for example , routers may need to reconcile their routing tables and files on mobile devices may need to be synchronized with those in the cloud . the reconciliation problem is to find the set differences between two distributed sets . here",
    ", the set difference for a host is defined as the set of elements that the host has but the other host does not .",
    "once two hosts can find their respective set differences , each can use the information to solve the reconciliation problem by adding its difference set to the other or removing it from its own set to reconcile the two sets to their union or intersection , respectively . in this paper , for presentation simplicity , we consider a simpler case that a host just reconcile its set to the same as the set that the other host currently possesses .",
    "we describe the problem we wish to solve in mathematical notation .",
    "suppose that there are two hosts , @xmath0 and @xmath1 , which possess two sets , @xmath2 and @xmath3 , respectively .",
    "the elements of @xmath2 and @xmath3 are from a set @xmath4 .",
    "the difference sets for @xmath0 and @xmath1 are @xmath5 and @xmath6 , respectively .",
    "for example , if @xmath0 has @xmath7 and b has @xmath8 , then we have @xmath9 and @xmath10 .",
    "we denote the size of a set @xmath11 by @xmath12 . to ease the presentation , we assume throughout the paper that @xmath13 , @xmath14 and @xmath15 for some positive integer @xmath16 .",
    "the method proposed in this paper can be naturally extended to the case of @xmath17 by simply increasing the space allocation from @xmath18 to @xmath19 ( described in sec .",
    "[ sec : cs - iblt ] ) .    in the reconciliation problem ,",
    "the two hosts wish to reconcile their sets , by making them identical .",
    "for example , @xmath1 can update @xmath3 by adding elements in @xmath20 to @xmath3 and removing elements in @xmath21 from @xmath3 .",
    "this means , in the above example , once @xmath1 knows @xmath9 and @xmath10 , @xmath1 performs the operation of @xmath22 .",
    "consequently , the reconciliation is accomplished .    in solving the reconciliation problem ,",
    "we are mainly concerned with the communication cost , the number of elements required to be transmitted between the two hosts .",
    "a straightforward method of solving the reconciliation problem is that host @xmath0 sends his entire set @xmath2 to host @xmath1 .",
    "after that , @xmath1 can check and identify the set differences between @xmath2 and @xmath3 .",
    "obviously , the communication cost for this method is @xmath13 .",
    "a more efficient but probabilistic method is to utilize bloom filter @xcite .",
    "more specifically , host @xmath0 constructs a bloom filter by inserting the elements in @xmath2 to the bloom filter and then sending the bloom filter to @xmath1 . with the received bloom filter",
    ", @xmath1 can check if the elements in @xmath3 is in the filter and thus can identify @xmath21 with some probability that not all these elements are identified due to hash table collisions in the bloom filter .",
    "similar queries made for the remaining elements in @xmath23 can be used to identify @xmath20 with some probability that extra elements are identified due to hash table collisions in the bloom filter . to lower false identifications , the size of bloom filter needs to be proportional to @xmath16 .",
    "therefore , the communication cost of this bloom filter approach is still asymptotically the same as the straightforward method .",
    "minsky _ et al_. @xcite developed a characteristic polynomial method . in this method , @xmath0 sends several evaluated values of the characteristic polynomial @xmath24 to @xmath1 , where @xmath24 is defined as @xmath25 with @xmath26 s being elements in @xmath2 .",
    "host @xmath1 does similar evaluation based on its own characteristic polynomial @xmath27 . by _",
    "rational interpolation _ , @xmath1 can derive @xmath24 and thus recover the set differences based on @xmath24 s and @xmath27 s evaluated values . here ,",
    "given @xmath28 pairs of @xmath29 , rational interpolation is to find a @xmath30 satisfying @xmath31 for each pair @xmath29 , where the polynomials @xmath32 and @xmath33 are of degrees @xmath34 and @xmath35 , respectively .    observe that @xmath36 .",
    "@xmath0 sends evaluated values of @xmath24 to @xmath1 , and @xmath1 calculates the value of @xmath37 at each predetermined evaluation point . once @xmath38 can be recovered from the evaluated values of @xmath37 , the set differences can be obtained by finding the roots of @xmath39 and @xmath40 .    a concrete example in @xcite shows how this characteristic polynomial method works .",
    "suppose that @xmath41 , @xmath42 , the prior knowledge about @xmath43 is available , the evaluation points @xmath44 have been predetermined , and a proper finite field @xmath45 has been chosen .",
    "under such conditions , @xmath24 and @xmath27 can be formulated as @xmath46 and @xmath47 , respectively .",
    "the evaluations of @xmath24 and @xmath27 at four evaluation points are @xmath48 , but we omit the detail in this paper . ] and @xmath49 over @xmath45 , respectively .",
    "the values of @xmath38 are therefore @xmath50 . from rational interpolation",
    "s perspective , the value @xmath51 corresponds to the size @xmath43of set differences and @xmath52 corresponds to @xmath53 of size @xmath54 .",
    "the interpolated @xmath55 , where the roots of numerator are @xmath56 and @xmath57 and the root of denominator is @xmath58 , can be used to derive the set differences between @xmath2 and @xmath3 .",
    "an issue in this reconciliation case is that only the size of set differences , instead of the individual @xmath34 and @xmath35 , is known and so rational interpolation can not be applied directly .",
    "nevertheless , a formula is given in @xcite to the estimates of @xmath34 and @xmath35 based only on the size of set differences . despite its algebraic computation over finite fields , a notable feature of this method is that the communication cost is only dependent on @xmath43 , instead of @xmath16 , due to the use of interpolation .",
    "very recently , goodrich and mitzenmacher @xcite developed a data structure , called invertible bloom lookup table ( iblt ) , to address the reconciliation problem .",
    "iblt can be thought of as a variant of counting bloom filter @xcite with the property that the elements inserted to bloom filter can be extracted even under collision . with the use of iblt",
    ", the reconciliation problem can be solved in approximately @xmath59 communication cost under the assumption that @xmath43 is known in advance .",
    "the aforementioned straightforward method and bloom filter approach incur a large amount of communication cost when @xmath2 is of large size . on the other hand , characteristic polynomial method and iblt",
    "are efficient only when prior knowledge about @xmath43 is available . without this prior knowledge",
    ", the computation overhead of the characteristic polynomial method can be as large as @xmath60 .",
    "iblt need to be repeatedly applied with progressively increasing @xmath43 , incurring a wasted communication cost which can be as large as @xmath61 .",
    "we propose an algorithm , called cs - iblt , which is a novel combination of compressed sensing ( cs ) and iblt , enabling the reconciliation problem to be solved with @xmath62 communication cost even without prior knowledge about @xmath43 .",
    "a distinguished feature of cs - iblt is that the number of transmitted messages changes with adapt to the value of @xmath43 , instead of the conventional wisdom that the correct @xmath43 must be estimated first .",
    "notably , this adaptive feature is attributed to the use of cs .",
    "first , we briefly review compressed sensing ( cs ) and invertible bloom lookup table ( iblt ) in sec . [",
    "sec : compressed sensing ] and sec .",
    "[ sec : invertible bloom lookup table ] , respectively .",
    "then , we describe our proposed cs - iblt algorithm in sec . [",
    "sec : cs - iblt ] .",
    "we provide analysis and comparison between iblt and cs - iblt in secs .",
    "[ sec : analysis ] and [ sec : comparison ] .",
    "suppose that @xmath63 is a @xmath64-sparse vector of length @xmath16 with @xmath65 .",
    "that is , only @xmath64 nonzero components can be found in @xmath63 .",
    "a standard compressed sensing ( cs ) formulation is @xmath66 , where @xmath67 and @xmath68 , with @xmath69 , are called measurement vector and measurement matrix , respectively .",
    "cs states that if @xmath70 is a random matrix satisfying the restricted isometry property and @xmath71 is greater than @xmath72 for some constant @xmath73 @xcite , then @xmath63 can be reconstructed based on @xmath74 with high probability .",
    "the vector @xmath63 can be reconstructed by @xmath75-minimization as follows : @xmath76      an invertible bloom lookup table ( iblt ) is composed of a @xmath77 array , @xmath78 , with @xmath79 hash functions , @xmath80 , @xmath81 , @xmath82 .",
    "it supports three operations , insert , delete , and list - entries .",
    "suppose that @xmath83 is a numeric value . to insert an element @xmath83 with the insert operation , @xmath84 $ ]",
    "is increased by @xmath83 and @xmath85 $ ] is increased by @xmath86 , for all @xmath87 .",
    "the deletion of an element @xmath83 with the delete operation is operated by decreasing @xmath84 $ ] by @xmath83 and decreasing @xmath85 $ ] by @xmath86 .",
    "the second column of iblt can be treated as a counting bloom filter @xcite .",
    "list - entries is used to dump all elements currently stored in iblt .",
    "it works by searching for the position @xmath88 where @xmath89=1 $ ] .",
    "if such @xmath90 is found , the corresponding @xmath91 $ ] is listed and operation delete(@xmath91 $ ] ) is performed .",
    "the above search - and - delete procedure is repeatedly performed until no such @xmath90 can be found . with this search - and - delete procedure , elements under collision",
    "can still be extracted .",
    "the list - entries operation fails if the resultant iblt is not empty .",
    "it succeeds otherwise .",
    "goodrich and mitzenmacher show in @xcite that to accommodate @xmath16 elements , the length @xmath92 of iblt needs to be greater than @xmath93 when @xmath79 , and @xmath94 are used , approximately @xmath95 , @xmath96 , @xmath97 , and @xmath98 should be allocated , respectively .",
    "the rationale behind this is that for fixed iblt size , larger @xmath79 implies more collision . to be able to perform the element extraction , collision",
    "can not too much although collision is allowed in iblt .",
    "thus , when larger @xmath79 is used , more space allocation is required . ]",
    "is selected to be @xmath99 .",
    "this makes sure the list - entries fails with negligible probability .",
    "recall that @xmath2 and @xmath3 are two sets of length @xmath16 . under cs - iblt ,",
    "host @xmath0 first constructs an iblt , @xmath100 , of length @xmath18 by inserting each element in @xmath2 to @xmath100 .",
    "( the choice of @xmath18 will be described in sec .",
    "[ sec : analysis ] . )",
    "host @xmath0 then constructs a random measurement matrix @xmath70 of dimension @xmath101 satisfying the restricted isometry property mentioned in sec . [ sec : compressed sensing ] .",
    "@xmath0 calculates @xmath102 .",
    "@xmath103 is thus an array of dimension @xmath104 .",
    "afterwards , @xmath0 repeatedly sends the rows of @xmath103 to @xmath1 continuously until it receives a positive acknowledgement from @xmath1 ( described below ) .",
    "host @xmath1 constructs @xmath105 , @xmath70 , and @xmath106 in a similar manner .",
    "note that with a seed commonly shared between @xmath0 and @xmath1 , their generated @xmath70 can be the same for each row .",
    "denote the @xmath90-th row of @xmath103 by @xmath107 .",
    "once receiving the @xmath90-th row @xmath107 of @xmath103 , @xmath1 performs cs recovery on @xmath108^t$ ] . by cs recovery on @xmath108^t$ ] , we mean that @xmath75-minimization is applied to the two columns in @xmath108^t$ ] separatively . because the entries in @xmath100 and @xmath105 are assumed to be integers , quantization is applied to the recovered result .",
    "suppose that @xmath1 obtains a recovery result @xmath109 after @xmath75-minimization is applied to @xmath108^t$ ] .",
    "@xmath1 then proceeds to the list - entries operation on @xmath109 and checks whether the list - entries operation succeeds or not .",
    "if the list - entries operation succeeds , @xmath1 sends a positive acknowledgment meaning `` stop sending more measurements '' to @xmath0 , and host b reconciles @xmath3 with @xmath2 , with the @xmath20 and @xmath21 extracted from @xmath109 .",
    "if the list - entries operation fails , @xmath1 waits for the next measurement @xmath110 and again performs the above operations on @xmath111 through @xmath110 .",
    "the above setting and procedures remain the same in the case of @xmath17 except that @xmath100 and @xmath105 of length at most @xmath19 are needed instead .",
    "note that @xmath19 corresponds to the extreme case of @xmath112 .",
    "figure [ fig : cs - iblt ] illustrates how cs - iblt works . hosts @xmath0 and @xmath1 possess @xmath113 and @xmath114 , respectively . in the following , we omit the second column of iblt in our cs - iblt algorithm for representation simplicity .",
    "that is , we omit the counting bloom filter part .",
    "observe that @xmath9 , @xmath115 , and @xmath116 .",
    "note that because of @xmath117 , iblts are of length @xmath118 .",
    "this corresponds to the requirement in sec .",
    "[ sec : cs - iblt ] that iblts of length @xmath18 need to be allocated .",
    "suppose that @xmath119 hash functions are used in the iblt in cs - iblt .",
    "@xmath100 and @xmath105 are derived according to the hash positions and then @xmath120 is calculated . with cs - iblt",
    ", @xmath0 only needs to send the first @xmath121 entries in @xmath103 to @xmath1 .",
    "that is , only six entries of @xmath122 are sufficient for @xmath1 to exactly recover the @xmath120 . from the recovered @xmath120 , @xmath123",
    ", we can extract @xmath86 and @xmath124 according to the iblt principles in sec .",
    "[ sec : invertible bloom lookup table ] . based on the rule described in sec .",
    "[ sec : analysis ] , @xmath1 knows that @xmath9 , @xmath115 .",
    "the following is the key relationship behind our proposed cs - iblt algorithm is : @xmath125 the cs recovery based on @xmath122 can generate an approximation @xmath109 of @xmath120 .",
    "when the number @xmath71 of measurements is sufficient in the cs recovery , @xmath109 is nearly identical to @xmath120 .",
    "based on the principles of iblt construction , @xmath120 can be thought of as an iblt with elements in @xmath20 and in @xmath126 , where @xmath126 is defined as the set @xmath127 .",
    "thus , @xmath1 first lists all the elements in @xmath109 .",
    "those positive elements are categorized as @xmath20 and those negative ones are categorized as @xmath126 .    on the other hand , when the number @xmath71 of measurements is insufficient for the exact recovery of @xmath120 .",
    "that is , @xmath109 is significantly deviated from @xmath120 , @xmath1 will be aware of this failed recovery because after the list - entries operation is applied to such @xmath109 , the list - entries operation fails with high probability . note that the reconstructed array @xmath109 behaves like a random one when an insufficient number of measurements is used .",
    "the list - entries operation is unlikely to be successful on a random array .",
    "therefore , the decoding procedure will proceed with high probability until @xmath128 is achieved .",
    "the number of measurements required to recover @xmath120 determines the communication cost of cs - iblt . recall that we are interested in recovering @xmath120 from @xmath129 , and the theory of cs states that the number of required measurements can be as small as @xmath72 , where @xmath64 is the number of nonzero entries in the vector to be recovered .",
    "observe that the iblt , @xmath120 , is constructed by adding elements in @xmath2 and removing elements in @xmath3 .",
    "based on the iblt principles in sec .",
    "[ sec : invertible bloom lookup table ] , the elements commonly shared between @xmath0 and @xmath1 , which are the elements in @xmath130 , will be eliminated and only the elements in the set difference @xmath131 remain in @xmath120 . recall that @xmath132 measurements are needed for accurate cs recovery , where @xmath64 is the number of nonzero elements .",
    "thus , as the vector to be recovered is @xmath109 with at most @xmath133 nonzero entries , @xmath134 measurements are sufficient for the cs recovery , where @xmath79 and @xmath43 denote the number of hash functions used in iblt and the inherent size of set differences , respectively .",
    "as reported in @xcite , the length of iblt with @xmath16 elements should be at least @xmath93 to ensure the successful execution of the list - entries operation in the case of @xmath135 .",
    "however , the value of @xmath93 is estimated based on an inherent assumption that the inserted elements are all positive .",
    "based on the iblt principles in sec .",
    "[ sec : invertible bloom lookup table ] , @xmath120 can be regarded as an iblt with elements of @xmath20 and @xmath126 .",
    "since there could be some negative elements in @xmath20 and @xmath126 , we suggest to use @xmath18 , rather than @xmath93 , according to our empirical experience .      in the case that prior knowledge about @xmath43 is unavailable",
    ", the use of iblt incurs a large amount of wasted communication . in particular , a reasonably first guess is @xmath136 , and host @xmath0 sends iblt of size @xmath137 to @xmath1 . if the real @xmath43 is smaller then @xmath138 , @xmath1 can obtain @xmath20 and @xmath21 successfully .",
    "essentially , @xmath139 communications are sufficient for finding the set differences and this means that we incur unnecessary communication cost which can be as large as @xmath140 .",
    "this extreme case occurs when @xmath141 .",
    "if the real @xmath43 is greater than @xmath138 , then the list - entries operation will be failed , and @xmath1 keeps waiting for the subsequent measurements from @xmath0 .",
    "this time , @xmath0 adopts a binary search - like approach to progressively have next @xmath142 .",
    "afterwards , hosts @xmath0 and @xmath1 repeat the above procedures until @xmath1 can empty @xmath109 . in the extreme case of @xmath143 , @xmath144 communication cost",
    "is required .",
    "this performance is even worse than that of straightforward method in which @xmath2 is sent to @xmath1 directly .    on the other hand , in the case of @xmath141 ,",
    "if cs - iblt is used , since the array @xmath120 is very sparse ( approximately only @xmath145 nonzero entries ) , only a very small number of measurements are needed . in the case of @xmath143 , @xmath18 measurements are sufficient for the cs recovery in cs - iblt .",
    "such communication cost occurs when all of the rows of @xmath103 are transmitted .",
    "in this section we demonstrate and compare the performance of iblt and cs - iblt via numerical experiments . figure [ fig : communication cost ]",
    "compares the performance of both methods under the assumption that prior knowledge about @xmath43 is not available .    in these experiments ,",
    "@xmath119 hash functions are used in both iblt and cs - iblt . in cs - iblt ,",
    "the random measurement matrix @xmath70 is gaussian distributed . in figure",
    "[ fig : k2n200 ] , @xmath146 and @xmath43 is varied from @xmath86 to @xmath147 .",
    "one can see in figure [ fig : k2n200 ] that communication cost of cs - iblt increases as @xmath43 increases due to the fact that the larger @xmath43 implies more nonzero entries in @xmath120 .",
    "in essence , the procedures in cs - iblt here are roughly like applying cs measurement matrix to a @xmath133-sparse array @xmath120 and then deriving the cs recovered array @xmath109 . on the other hand , in iblt , because no prior knowledge about @xmath43 can be used , the guessed @xmath43 , @xmath136 , is used initially .",
    "this choice of @xmath138 enables @xmath1 to decode the received iblt , resulting in a flat curve from @xmath141 to @xmath148 .",
    "similar observations can be made in figure [ fig : k2n1000 ] .",
    "cs - iblt shows its main advantage when @xmath43 is relatively small and large . in the case of small @xmath43",
    ", the overestimated @xmath138 incurs unnecessary communication but different measurements are adaptively transmitted one by one in cs - iblt .",
    "the sending stops immediately after the successful recovery of @xmath120 . in the case of large @xmath43 , several underestimated @xmath138 in iblt incurs useless communication but because of its adaptive property , even in the worst case , @xmath18 measurements can enable the successful recovery of @xmath120 .",
    "cs - iblt is inferior to iblt only in the case of moderate @xmath43 , which means that the initially guessed @xmath43 , @xmath138 , is pretty close to the real @xmath43 .",
    "the rationale behind this is that the communication cost of cs - iblt is still limited by the theory of cs .",
    "that is , it is still dependent on @xmath16 .",
    "however , if @xmath149 , we can think that iblt with prior knowledge about @xmath43 is utilized , resulting in only @xmath59 communication .",
    "hence , in such cases , cs - iblt is less efficient than iblt in terms of communication cost .",
    "we present a novel algorithm , cs - iblt , to address the reconciliation problem . according to our theoretical analysis and numerical experiments ,",
    "cs - iblt is superior to the previous methods in terms of communication cost in most cases under the assumption that no prior information is available .",
    "e. j. cands , j. k. romberg , and t. tao .",
    "robust uncertainty principles : exact signal reconstruction from highly incomplete frequency information . _ ieee transactions on infomation theory _ , 52(2):489 - 509 , 2006 ."
  ],
  "abstract_text": [
    "<S> we consider a reconciliation problem , where two hosts wish to synchronize their respective sets . </S>",
    "<S> efficient solutions for minimizing the communication cost between the two hosts have been previously proposed in the literature . </S>",
    "<S> however , they rely on prior knowledge about the size of the set differences between the two sets to be reconciled . in this paper , we propose a method which can achieve comparable efficiency without assuming this prior knowledge . </S>",
    "<S> our method uses compressive sensing techniques which can leverage the expected sparsity in set differences . </S>",
    "<S> we study the performance of the method via theoretical analysis and numerical simulations .    </S>",
    "<S> shell : bare demo of ieeetran.cls for journals </S>"
  ]
}