{
  "article_text": [
    "let @xmath6 be a finite field of size @xmath1 and consider a `` sparse '' polynomial @xmath7,\\ ] ] where the @xmath8 are nonzero and the exponents @xmath9 are distinct .",
    "suppose @xmath0 is provided as a straight - line program , a simple branch - free program which evaluates @xmath0 at any point ( see below for a formal definition ) .",
    "suppose also that we are given an upper bound @xmath2 on the degree of @xmath0 and an upper bound @xmath3 on the number of non - zero terms @xmath10 of @xmath0 .",
    "our goal is to recover the standard form for @xmath0 , that is , to recover the coefficients @xmath11 and their corresponding exponents @xmath12 as in .",
    "our main result is as follows .",
    "[ thm : cost ] let @xmath13 $ ] with at most @xmath3 non - zero terms and degree at most @xmath2 , and let @xmath14 .",
    "suppose we are given a division - free straight - line program @xmath15 of length @xmath16 that computes @xmath0 .",
    "then there exists an algorithm ( presented below ) that interpolates @xmath0 , with probability at least @xmath17 , with a cost of @xmath18{for        functions $ \\phi , \\psi : { { \\mathbb{r}}}_{>0 } \\rightarrow { { \\mathbb{r}}}_{>0}$ , we        say $ \\phi \\in { \\widetilde{\\mathcal{o}}}(\\psi)$ if and only if $ \\phi \\in { \\mathcal{o}}(\\psi(\\log        \\psi)^c)$ for a constant $ c \\geq 0$.}\\ ] ] bit operations .",
    "this cost improves on previous methods by a factor of @xmath3 , @xmath4 , or @xmath5 , and may lay the groundwork for even further improvements .",
    "see table [ tab : comp ] below for a detailed comparison of the complexity of various approaches to this problem .",
    "the interpolation algorithm presented in this paper is for straight - line programs , though it could be adapted to other more traditional models of interpolation .",
    "informally , a straight - line program is a very simple program , with no branches or loops , which evaluates a polynomial at any point , possibly in an extension ring or field .",
    "straight - line programs serve as a very useful model to capture features of the complexity of algebraic problems ( see , e.g. , @xcite ) especially with respect to evaluation in extension rings , as well as having considerable efficacy in practice ( see , e.g. , @xcite ) .    more formally , a division - free _ straight - line program _ over a ring @xmath19 , henceforth abbreviated as an _ slp _ , is a branchless sequence of arithmetic instructions that represents a polynomial function .",
    "it takes as input a vector @xmath20 and outputs a vector @xmath21 by way of a series of instructions @xmath22 of the form @xmath23 , where @xmath24 is an operation @xmath25 , or @xmath26 , and @xmath27 .",
    "the inputs and outputs may belong to @xmath19 or a ring extension of @xmath19 .",
    "we say a straight - line program _ computes _",
    "@xmath28 $ ] if it sets @xmath29 to @xmath30 .",
    "the straight - line programs in this paper compute over finite fields @xmath31 with @xmath1 elements , and ring extensions of @xmath31 .",
    "we assume that elements of @xmath31 are stored in some reasonable representation with @xmath32 bits , and that each field operation requires @xmath33 bit operations .",
    "similarly , we assume that elements in a field extension @xmath34 of @xmath31 can be represented with @xmath35 bits , and that operations in @xmath34 require @xmath36 bit operations .",
    "each of the algorithms described here determines @xmath0 by _ probing _ its slp : executing it at an input of our choosing and observing the output .",
    "this is analogous to evaluation of the polynomial at a point in an extension of the ground field in the more traditional interpolation model .",
    "to fairly account for the cost of such a probe we define the _ probe degree _ as the degree of the ring extension over @xmath31 in which the probe lies . a probe of degree @xmath37 costs @xmath38 field operations , or @xmath39 bit operations .",
    "the _ total probe size _ is the sum of the probe degrees of all the probes used in a computation .",
    "polynomials are also stored with respect to the power basis ( powers of @xmath40 ) in a _",
    "sparse representation_. in particular , @xmath0 as in would be stored as a list @xmath41_{1 \\leq i \\leq    t}$ ] .",
    "given such a polynomial @xmath0 , we let @xmath42 , denote the coefficient of the term of @xmath0 of degree @xmath43 ( which may well be zero ) . we let @xmath44 denote",
    "the sorted list of exponents of the nonzero terms in @xmath0 , and @xmath45 denote the number of nonzero terms of @xmath0 .",
    "when we write @xmath46 , we assume that the modular image @xmath47 is reduced , i.e. , it is stored as the remainder of @xmath0 divided by @xmath48 , and @xmath49 .",
    "we frequently refer to such @xmath47 as `` images '' of the original polynomial @xmath0 , as they reveal some limited amount of information about @xmath0 .    the problem of ( sparse ) interpolation",
    "can then be seen as one of conversion between representations : efficiently transform a polynomial given by a straight - line program into a `` standard '' sparse representation with respect to a power basis in @xmath40 as in , given `` size '' constraints @xmath2 and @xmath3 as  above .",
    "the following table gives a comparison of existing algorithms for the sparse interpolation of straight - line programs .    .",
    "a comparison of interpolation algorithms for straight - line programs ( ignoring polylogarithmic factors ) .",
    "+ det = deterministic , lv = las vegas , mc = monte carlo .",
    "[ tab : comp ] [ cols=\"<,>,^\",options=\"header \" , ]     most of these are probabilistic algorithms . by a _ las vegas _",
    "algorithm we mean one that runs in the expected time stated but produces an output of guaranteed correctness .",
    "monte carlo _",
    "algorithm takes an additional parameter @xmath50 and produces an output guaranteed to be correct with probability at least @xmath51 .",
    "the algorithm of @xcite finds a _ good prime _ , that is , a prime that separates all the terms of @xmath0 .",
    "for @xmath0 given by , @xmath52 and so the terms of the _ good image _",
    "@xmath53 remain distinct provided the exponents @xmath12 are distinct modulo @xmath54 .",
    "this good image gives us @xmath55 , which in turn makes it easy to identify other good primes .",
    "their algorithm then constructs the symmetric polynomial @xmath56 by chinese remaindering of images @xmath57 , for sufficiently many good primes @xmath58 , @xmath59 .",
    "note that the image @xmath60 gives the values @xmath61 and hence @xmath57 .",
    "given @xmath62 , the algorithm then factors @xmath62 to obtain the exponents @xmath12 .",
    "the corresponding coefficients of @xmath0 may be obtained by inspection of any good image .",
    "their algorithm can be made faster , albeit monte carlo , by using randomness ; we probabilistically search for a good prime by selecting primes at random over a specified range , choosing as our good prime",
    "@xmath54 one for which the image @xmath63 has maximally many terms .",
    "an information - theoretic lower bound on the total probe size required is @xmath64 bits , the number of bits used to encode @xmath0 in .",
    "this bound is met by prony s @xcite original algorithm , which requires a total probe size of @xmath65 under the implicit assumption that @xmath66 .",
    "much of the complexity of the sparse interpolation problem appears to arise from the requirement to accommodate _ any _ finite field .",
    "prony s algorithm is dominated by the cost of discrete logarithms in @xmath6 , for which no polynomial time algorithm is known in general . when there is a choice of fields ( say , as might naturally arise in a modular scheme for interpolating integer or rational polynomials ) more efficient interpolation methods have been developed .",
    "@xcite demonstrates a method for sparse interpolation over @xmath67 for primes @xmath54 such that @xmath68 is smooth ; see @xcite for further exposition . in our notation",
    ", this algorithm would require an essentially optimal @xmath69 bit operations .",
    "parallel algorithms and implementations for this case of chosen characteristic are also given by @xcite .",
    "moreover , our need for a bound @xmath3 on the number of non - zero terms is motivated by the hope of a las vegas or deterministic algorithm .",
    "the early termination approach of @xcite identifies @xmath10 with high probability at no asymptotic extra cost .",
    "we say a polynomial @xmath70 is _ diverse _ if its non - zero terms have distinct coefficients .",
    "the interpolation algorithm of @xcite distinguishes between images of distinct non - zero terms by _ diversifying _",
    "@xmath0 , that is , choosing an @xmath71 such that @xmath72 is diverse .",
    "this monte carlo algorithm entails three probabilistic steps .",
    "first , it determines @xmath55 by searching for a probable good prime .",
    "second , it finds an @xmath71 that diversifies @xmath63 .",
    "finally , it looks for more good primes @xmath54 , and constructs the exponents @xmath12 of @xmath0 by way of chinese remaindering on the congruences @xmath73 .",
    "this gives @xmath74 , from which it is straightforward to recover @xmath75 .",
    "the diversified interpolation algorithm was initially described for a `` remainder black box '' representation of @xmath0 , a weaker model than a straight - line program .",
    "to search for an appropriate @xmath76 , the algorithm requires that the field size @xmath1 is greater than @xmath77 . under the slp model",
    "we can easily adapt the algorithm to work when @xmath78 ; simply choose @xmath71 from a sufficiently large field extension .",
    "this slight adaptation increases the cost of a probe by a factor of @xmath79 .",
    "the cost of sparse slp interpolation using the diversified algorithm is then @xmath80 probes of degree @xmath81 , where @xmath50 is a given bound on the probability of failure . since each operation in @xmath6 costs @xmath33 bit operations , the cost in bit operations  is    @xmath82    for fixed",
    "@xmath83 this cost becomes @xmath84 .",
    "the diversified and probabilistic garg - schost interpolation algorithms may be made las vegas ( i.e. , guaranteed error free ) by way of a deterministic polynomial identity testing algorithm .",
    "the fastest - known method for certifying that polynomials ( given by algebraic circuits ) are equal over an arbitrary field , by @xcite , requires @xmath85 field operations in our notation . the gains in faster interpolation algorithms would be dominated by the cost of this certification ; hence they are fast monte carlo algorithms whose unchecked output may be incorrect with controllably small probability .      the algorithm of @xcite is faster than diversified interpolation when @xmath3 asymptotically dominates either @xmath4 or @xmath5 .",
    "the chief novelty behind that algorithm is to use smaller primes @xmath54 with relaxed requirements . instead of searching for good primes separating all of the non - zero terms of @xmath0",
    ", we probabilistically search for an _ ok prime _ @xmath54 which separates _ most _ of the non - zero terms of @xmath0 .",
    "given this prime @xmath54 we then construct images of the form @xmath86 , for a set of coprime moduli @xmath87 whose product exceeds @xmath2 , in order to build those non - colliding non - zero terms of @xmath0 .",
    "the resulting polynomial @xmath88 contains these terms , plus possibly a small number of _ deceptive terms _ not occurring in @xmath0 , such that @xmath89 now has at most @xmath90 non - zero terms .",
    "the algorithm then updates the bound @xmath91 and recursively interpolates the difference @xmath92 .",
    "the total cost of the recursive interpolation algorithm is @xmath80 probes of degree @xmath93 , for a total cost of @xmath94 bit operations , which is @xmath95 when @xmath50 is a constant .      as in @xcite ,",
    "our new algorithm recursively builds an approximation @xmath88 , initially zero , to the input polynomial @xmath0 given by an slp .",
    "the algorithm interpolates @xmath92 with bounds @xmath96 and @xmath97 .",
    "we update @xmath3 as we update @xmath98 .",
    "we begin with the details of our straight - line program model in section  [ sec : slp ] .",
    "section  [ sec : primes ] describes how we choose a set of @xmath99 ok primes @xmath100 , @xmath101 .",
    "given these primes @xmath102 , we then compute images @xmath103 for choices of @xmath104 that will ( probably ) allow us to identify images of like terms of @xmath98 .",
    "this approach relies on a more general notion of diversification .",
    "we explain how we choose the values @xmath104 and give a probabilistic analysis in section [ sec : div ] .",
    "section [ sec : terms ] details how we use information from the images @xmath105 to construct at least half of the terms of @xmath98 .",
    "section [ sec : recurse ] describes how the algorithm iteratively builds @xmath88 , followed by a probabilistic and cost analysis of the algorithm as a whole in section  [ sec : cost ] .",
    "some conclusions are drawn in section  [ sec : conclusion ] .",
    "in this paper we will only consider a single - input , division - free slp @xmath15 that computes a univariate polynomial @xmath0 over a finite field .",
    "we can reduce multivariate @xmath106 $ ] of total degree less than @xmath2 , by way of a _",
    "kronecker substitution_. interpolating the univariate polynomial @xmath107 preserves the number of non - zero terms of @xmath0 and allows the easy recovery of the original multivariate terms , but increases the degree bound to @xmath108 .",
    "see @xcite for recent advances on this topic .",
    "we will _ probe _",
    "@xmath15 , that is , execute the straight - line program on inputs of our choosing .",
    "one could naively input an indeterminant @xmath109 into @xmath15 , and expand each resulting polynomial @xmath110 .",
    "this sets @xmath29 to @xmath75 .",
    "unfortunately , intermediate polynomials @xmath110 may have a number of non - zero terms , and be of degrees , which grow exponentially in terms of @xmath16 , @xmath3 , and @xmath2 .",
    "instead , we limit the size of intermediate results by selecting a symbolic @xmath54-th root of unity @xmath111/\\langle z^p-1 \\rangle$ ] as input , for different choices of @xmath54 . at each instruction",
    "we expand @xmath112 $ ] , and reduce modulo @xmath113 .",
    "this sets @xmath29 to @xmath114 .",
    "using the method of @xcite , the cost of one such instruction becomes @xmath115 field operations .",
    "more generally we will produce images of the form @xmath116 , where @xmath71 is algebraic with degree @xmath117 over @xmath6 .",
    "that is , we choose as input @xmath118 , where @xmath109 is again a @xmath54-th root of unity . here",
    "the instruction cost becomes @xmath115 operations in @xmath34 , or @xmath119 operations in @xmath6 .",
    "we call @xmath120 the _ probe degree _ of a probe with input @xmath118",
    ".    we will also have to produce such images of polynomials given explicitly by sparse representations rather than implicitly in a slp .",
    "given a single term @xmath121 , @xmath122 , we can produce @xmath123 by computing @xmath124 via a square - and - multiply approach and reducing the exponent of @xmath125 modulo @xmath54 . for @xmath126",
    "the former step dominates this cost and requires @xmath127 operations in @xmath6 . for @xmath88 , a sum of at most @xmath3 such terms and @xmath128 ,",
    "the cost of constructing @xmath129 becomes @xmath130 .",
    "in particular , given an slp @xmath15 and a sparse polynomial @xmath88 , we will need to compute @xmath131 , as described above .",
    "procedure  [ proc : computeimage ] is a subroutine to perform such a computation , and its cost is @xmath132 operations in @xmath6 . when @xmath54 is at least of magnitude @xmath133 , the slp probe dominates the cost , and it becomes simply @xmath134 bit operations .",
    "@xmath135 , by probing @xmath15 at @xmath118 over @xmath136/\\langle z^p-1 \\rangle$ ] ; +",
    "the aim of sections [ sec : primes][sec : terms ] is to build a polynomial @xmath137 that contains at least half of the terms of @xmath92 . for notational simplicity , in these sections",
    "we write @xmath138 and let @xmath3 and @xmath2 bound @xmath139 and @xmath140 respectively .",
    "we will use images of the form @xmath141 , @xmath54 a prime , in order to extract information about the terms of @xmath142 .",
    "we say two terms @xmath143 and @xmath144 of @xmath142 _ collide _ modulo @xmath113 if @xmath54 divides @xmath145 , that is , if their reduced sum modulo @xmath113 is a single term .",
    "if a term @xmath143 of @xmath98 does not collide with any other term of @xmath142 , then its image @xmath146 contained in @xmath141 gives us its coefficient @xmath147 and the image of the exponent @xmath148 .",
    "we let @xmath149 denote the number of terms of @xmath142 that collide with any other term modulo @xmath113 .",
    "we need @xmath149 to be small so that the next approximation @xmath88 of @xmath0 contains many terms of @xmath0 , but the primes @xmath54 must also be small so that the cost of computing each @xmath88 is not too great . in this technical section ,",
    "we show how to bound the size of the primes @xmath54 to balance these competing concerns and minimize the total cost of the algorithm .    in the first phase of the algorithm",
    ", we will look for a set of primes @xmath100 , and corresponding images @xmath150 such that , in each of the images @xmath151 , most of the terms of @xmath98 are not in any collisions . more specifically",
    ", we want the primes @xmath152 and images @xmath153 to meet the following criteria :    1 .",
    "[ item : half_terms ] at least half of the terms of @xmath98 do not collide modulo @xmath154 with any other term of @xmath98 for at least @xmath155 of the primes @xmath102 ; 2 .   [",
    "item : half_col ] any pair of terms of @xmath98 collide modulo @xmath154 for fewer than @xmath155 of the primes @xmath102 ; 3 .   [ item : prod_d ] any @xmath155 of the primes @xmath102 have a product exceeding  @xmath2 .",
    "every nonzero term of an image @xmath151 is the image of a sum of terms of @xmath98 .",
    "if we are able to collect terms of the images @xmath151 , @xmath156 , that are images of the same sum of terms of @xmath98 , then from [ item : half_col ] , any such collection containing a term for at least @xmath157 images @xmath151 must be an image of a single term of @xmath98 . by [ item : half_terms ] , at least half of the terms of @xmath98 will produce such a collection . by [ item : prod_d ] , such collections will contain sufficient information to reconstruct the exponent of the corresponding term of @xmath98 .",
    "thus , given a means of collecting terms in this way , we will be able to construct half of the terms of @xmath98 .",
    "we note , since any two terms of @xmath98 have degree differing by at most @xmath2 , that [ item : prod_d ] implies [ item : half_col ] . to satisfy [ item : half_terms ]",
    ", it suffices that @xmath158 for each prime @xmath102 .",
    "we will accordingly call @xmath54 an _ ok prime _ in this paper if @xmath159 . to this end",
    "we establish a range in which most primes @xmath54 have @xmath160 , half the desired bound .",
    "[ lem : lambda ] let @xmath161 $ ] be a polynomial with @xmath162 terms and degree @xmath163 .",
    "let @xmath164 then fewer than half of the primes @xmath54 in the range @xmath165 $ ] satisfy @xmath166 .",
    "we will look for ok primes in the range @xmath165 $ ] . to satisfy [ item : prod_d ]",
    ", we will select @xmath167 primes .",
    "corollary  [ cor : lambda_ell ] gives us a means of selecting a set of primes for which a constant proportion of those primes @xmath54 have fewer than @xmath168 colliding terms .",
    "[ cor : lambda_ell ] suppose @xmath169 , and @xmath170 are as in lemma [ lem : lambda ] .",
    "let @xmath171 , and suppose @xmath172 if we randomly select @xmath173 distinct primes from @xmath174 $ ] , then @xmath175 for at least @xmath176 of the chosen primes @xmath54 , with probability at least @xmath177 .    by lemma [ lem : lambda ] , at least half of the primes @xmath54 in @xmath174 $ ] have @xmath160 .",
    "we require that a proportion of @xmath178 of the @xmath173 primes randomly selected to have this property .    in order to obtain a bound on at least @xmath179 of the primes having this property ,",
    "define random variables @xmath180 , for @xmath181 , to be 1 if the @xmath182th prime @xmath102 satisfies @xmath183 , and @xmath184 otherwise . from the reasoning",
    "above , we know that @xmath185 \\ge \\tfrac{1}{2}$ ] . therefore , the expected number of primes with this property , @xmath186 $ ] , is at least @xmath187 .",
    "hoeffding s inequality provides proof that the _ actual _ value of @xmath188 is not too much smaller than this expected value .",
    "specifically , theorems 1 and 4 of @xcite show that @xmath189 - \\tfrac{\\gamma}{4}\\right)^2\\right )      \\le \\exp\\left(\\tfrac{-\\gamma}{8}\\right).\\ ] ] for @xmath190 , this is less than  @xmath191 .",
    "we will generate some @xmath173 primes , of which @xmath176 primes @xmath54 have @xmath160 . in order to identify some primes",
    "@xmath54 for which @xmath149 is low , we have the following lemma .",
    "[ lem : choose_p ] suppose @xmath192 has @xmath193 non - zero terms , and @xmath194 has @xmath195 non - zero terms , with @xmath196",
    ". then @xmath197 .",
    "corollary [ cor : lambda_ell ] guarantees with high probability that at least @xmath176 primes @xmath102 of the @xmath173 selected satisfy @xmath198 .",
    "call these the `` best primes '' .",
    "unfortunately , there is no easy way to determine @xmath199 at this point , so we do not know which @xmath176 primes are the best primes !",
    "our solution to this seeming dilemma is to order the primes in decreasing order of @xmath200 . now consider any of the first @xmath176 primes @xmath102 in this ordering .",
    "since @xmath200 is among the largest @xmath176 values , we know that @xmath201 for some @xmath58 that is one of the `` best primes '' and satisfies @xmath202 .",
    "then by lemma  [ lem : choose_p ] , we know that @xmath203 , which is less than @xmath90 .    in other words , the first @xmath176 primes in this ordering are not necessarily the `` best '' , but they are good enough because they all satisfy @xmath204 .",
    "this method is described in procedure [ proc : findprimes ] below .",
    "the statement of corollary [ cor : lambda_ell ] assumes that there are a certain number of primes in @xmath165 $ ] , in order to pick @xmath173 of them .",
    "letting @xmath205 be the actual number of primes in this range , we require that @xmath206 .",
    "this puts further constraints on @xmath170 . by corollary 3 of @xcite , and using the definition of @xmath170 from lemma  [ lem : lambda ] , @xmath207 which is at least @xmath208 for @xmath209 .",
    "thus , for @xmath210 , we only require that @xmath211 .",
    "if the number of primes @xmath205 is even smaller than this , one could simply compute all @xmath205 primes in the interval and use them all instead of picking a random subset .",
    "since at least half these primes have @xmath160 , we would only require that @xmath212 , which must be true since @xmath213 .    to ensure that computing all @xmath205 primes in the interval does not increase the overall cost of the algorithm ,",
    "consider that in this case @xmath173 exceeds @xmath214 .",
    "then the upper bound of corollary 3 of @xcite gives @xmath215 therefore whether we choose only @xmath173 primes from the interval or are forced to compute all @xmath205 of them , the number of primes used is always @xmath216 .",
    "we make one further note on the cost of producing @xmath173 primes at random . in a practical implementation",
    ", one would likely choose numbers at random ( perhaps in a manner that avoids multiples of small primes ) , and perform monte carlo primality testing to verify whether such a number is prime .",
    "problems could arise if the algorithm produced pseudoprimes @xmath102 and @xmath58 that are not coprime .",
    "thus one would also have to consider the failure probability of primality testing in the analysis of such an approach .",
    "for the purposes of our analysis , we generate all the primes up to @xmath217 with @xmath218 bit operations using a wheel sieve @xcite , which does not dominate the cost in , and guarantees that all of the chosen @xmath54 are actually prime .",
    "the total cost is @xmath173 probes of degree at most @xmath217 , where @xmath219 for a field - operation cost of @xmath220    @xmath221 + @xmath222 + @xmath167 +    @xmath223 +",
    "at this stage we have probably found primes @xmath102 , @xmath158 , and their corresponding images @xmath151 , for @xmath224 .",
    "the challenge now remains to collect terms amongst the images @xmath225 that are images of the same term of @xmath142 . for our purposes we need a more general notion of diversification than that introduced by @xcite . to this end",
    "we will construct images @xmath226 where @xmath227 belongs to @xmath6 or a field extension @xmath34 .",
    "any term of an image @xmath151 is an image of either a single term of @xmath142 , or a sum of multiple terms of @xmath142 .",
    "our algorithm needs to identify and discard the terms in @xmath151 corresponding to multiple terms of @xmath98 , using only the single terms to reconstruct the actual terms in @xmath98 .",
    "to analyse this situation , consider the bivariate polynomials @xmath228 where each @xmath229 $ ] is the sum of the terms in @xmath98 with degrees congruent to @xmath37 modulo @xmath102 .",
    "each @xmath230 has between 0 and @xmath3 terms and degree at most @xmath2 in @xmath231 . for a given @xmath71",
    ", computing @xmath232 gives the univariate polynomial whose coefficient of degree @xmath37 is @xmath233 .",
    "consider a single term in the unknown polynomial @xmath98 . if that term does not collide with any others mod @xmath102 , then for some @xmath37 , @xmath230 consists of that single term .",
    "if the same term does not collide modulo @xmath234 , then there exists some @xmath235 such that @xmath236 . obviously , for any @xmath237 , we will have @xmath238 , and our algorithm can use this correlation to reconstruct the term , since its exponent equals @xmath37 mod @xmath102 and @xmath235 mod @xmath234 . based on the previous section , most of the terms in @xmath98 will not collide modulo most of the @xmath102 s , and so there will be sufficient information here to reconstruct those terms .",
    "the problem is that we may have @xmath239 , but @xmath240 .",
    "we call this a _ deception _ , since it may fool our algorithm into reconstructing a single term in @xmath98 that does not actually exist . our algorithm will evaluate with multiple choices @xmath104 , @xmath241 , for @xmath71 , and we `` hope '' that , whenever @xmath240 , at least one of @xmath104 s gives @xmath242 .",
    "in this case we say @xmath104 _ detects _ the deception .",
    "the following lemma provides this hope .",
    "[ lem : detect ] let @xmath161 $ ] be a polynomial of degree at most @xmath2 and at most @xmath3 nonzero terms .",
    "let @xmath102 be a prime such that @xmath204 and let @xmath243 for @xmath156 .",
    "let @xmath244 choose @xmath245 at random from @xmath246 . then , with probability at least @xmath177 , every deception amongst the images @xmath247 is detected by at least one of the @xmath104 .",
    "consider @xmath248 as above , with @xmath249 .",
    "as @xmath250 has degree at most @xmath2 , there are at most @xmath2 choices of @xmath71 for which @xmath239 .",
    "thus , if @xmath251 and @xmath252 , then at most half of the @xmath253 can comprise a root of a @xmath254 . thus , if we then select @xmath245 at random from @xmath246 and construct images @xmath255 for @xmath256 , @xmath257 , we will fail to detect a single given deception with probability at most @xmath258 as @xmath142 has at most @xmath3 terms , there are at most @xmath259 possible choices for @xmath260 ; however , only a small proportion of these choices may correspond to a term in an image @xmath151 .",
    "each @xmath151 , @xmath224 , contains at most @xmath261 terms that are images of a sum of at least two terms of @xmath142 .",
    "the remaining nonzero terms of @xmath151 are images of single terms of @xmath142 , of which there are at most @xmath3 .",
    "thus there are fewer than @xmath262 distinct sums corresponding to one of the nonzero @xmath230 .",
    "a deception occurs between a pair of such sums , thus there are fewer than @xmath263 deceptions .",
    "it then follows from that the probability that at least one deception is not detected by any of @xmath245 is bounded above by @xmath191 .",
    "it is important to note that @xmath264 is logarithmic in @xmath3 and @xmath176 , so that a multiplicative factor of @xmath264 will not affect the `` soft - oh '' cost of the algorithm in terms of @xmath3 or @xmath2 . if @xmath265 , then we need instead to work in an extension of @xmath6 of degree @xmath266 .",
    "the cost of computing @xmath105 , @xmath267 , in terms of @xmath6-operations , becomes @xmath268 which dominates the cost of section [ sec : primes ] .",
    "as we construct the images @xmath105 , we will build vectors of coefficients of images @xmath105 .",
    "namely , for every congruence class @xmath269 for which there exists a nonzero term of degree @xmath270 in at least one image @xmath105 , we will construct a vector @xmath271 , where @xmath272 contains the coefficient ( possibly zero ) of the term of @xmath105 of degree @xmath270 .",
    "we will use the vectors @xmath273 to identify terms of the images @xmath151 that are images of like terms of @xmath98 .",
    "we use these vectors @xmath273 as keys in a dictionary @xmath274 . each value in the dictionary",
    "is comprised of a list of those tuples @xmath275 for which @xmath276 .    provided the probabilistic steps of sections [ sec : primes ] and [ sec : div ] succeeded , if a key @xmath235 is found more than @xmath157 times , then it corresponds to a single , distinct term of @xmath98 , as opposed to a sum of terms of @xmath98 .",
    "this is indicated by the size of the list @xmath277 being at least  @xmath157 .",
    "the dictionary @xmath274 should be an ordered dictionary that supports logarithmic - time insertion and retrieval .",
    "any balanced binary search tree , such as a red - black tree will be suitable ( see , e.g. , @xcite , chapter 13 ) .",
    "to set @xmath277 , we first search to see if @xmath235 is an existing key ; if not , an empty list is first inserted as the value of @xmath277 .",
    "a red - black tree of size @xmath205 requires @xmath278 comparisons for insert and search operations .",
    "we compare keys @xmath279 lexicographically , which may entail @xmath264 comparisons of elements in @xmath34 .",
    "each comparison therefore requires @xmath280 bit operations .    the number of different vectors @xmath281 that will appear is bounded above by the number of distinct subsets of terms of @xmath98 which can collide modulo @xmath154 , for any of the primes @xmath102 .",
    "since there are @xmath176 primes , and at most @xmath3 terms in @xmath98 , there are no more than @xmath282 vectors which will be inserted as keys into @xmath274 .",
    "thus , the cost of constructing this tree is @xmath283 bit operations .",
    "this cost is dominated by that of constructing the @xmath105 . each term in each @xmath105 contains an element of @xmath34 and an exponent at most @xmath217 .",
    "this requires @xmath284 bits , which is @xmath285 .",
    "the additional bit - cost of traversing the images @xmath105 and appending to the lists in @xmath277 is reflected in the cost of their construction in section [ sec : div ] .",
    "after we have constructed the dictionary @xmath274 , we traverse it again to build terms of @xmath98 .",
    "for every key @xmath235 whose corresponding list has size at least @xmath157 , we have all the pairs @xmath286 such that @xmath287 . what remains is to construct the term corresponding to the key @xmath235 .",
    "we reconstruct the exponent by chinese remaindering on the first @xmath157 congruences @xmath288 .",
    "as each exponent is at most @xmath2 , the cost of constructing one exponent is bounded by @xmath289 bit operations .",
    "thus the total bit - cost of chinese remaindering becomes @xmath93 .",
    "as the bit cost of @xmath117 operations in @xmath6 is @xmath290 , this cost of chinese remaindering is bounded asymptotically by @xmath291 , the cost of constructing @xmath274 itself .",
    "we obtain the coefficient by inspection of @xmath151 .",
    "we sum all of these constructed terms into a polynomial @xmath137 approximating @xmath92 .",
    "procedure [ proc : buildapproximation ] restates the method described to construct @xmath137 . for the sake of brevity",
    ", this procedure does not detail the data structures used for the polynomials @xmath105 and @xmath137 that it constructs . in order to achieve the stated complexity bounds , these sparse polynomials must be implemented by dictionaries mapping exponents to coefficients that support logarithmic - time insertion and retrieval . as with @xmath274 ,",
    "a red - black tree , hash table , or similar standard data structure could be used .",
    "converting between such a representation and the usual list of coefficient - exponent pairs is trivial .",
    "@xmath292 [ proc : findprimes]@xmath293 + @xmath294 + @xmath295 + @xmath296 @xmath264 randomly chosen nonzero elements from @xmath34 ; + @xmath297 dictionary mapping @xmath298 to lists of pairs of integers ; +    @xmath299 +",
    "recall we have a polynomial @xmath88 approximating @xmath0 given by our straight - line program .",
    "we construct a polynomial @xmath137 that is comprised of at least @xmath90 terms of @xmath92 .",
    "once we have @xmath137 , we set @xmath300 , @xmath301 , and repeat the process until @xmath3 is @xmath302 , at which point @xmath98 consists of ( at most ) a single nonzero term .",
    "we thus execute this process at most @xmath303 times , where @xmath3 is the initial bound on the number of non - zero terms of @xmath0 .",
    "recall that the steps of sections [ sec : primes ] and [ sec : terms ] each succeed with probability greater than @xmath177 .",
    "thus , if we would like the algorithm to succeed with probability greater than @xmath304 , we can set @xmath305 as @xmath306 and @xmath307 , we will always have @xmath308 , which satisfies the constraint @xmath309 from section  [ sec : primes ] .    when @xmath310 , @xmath98 is a single term and its coefficient is given by @xmath311 .",
    "the exponent of the term comprising @xmath98 may be computed from @xmath312 for the first @xmath4 primes @xmath54 .",
    "this cost is @xmath4 probes of degree @xmath313 , or a cost of @xmath314 bit operations .",
    "we give the interpolation algorithm in procedure [ proc : majorityvotesparseinterpolate ] .",
    "we call the algorithm `` majority - vote '' sparse interpolation , as we effectively require a majority of the images @xmath315 , @xmath156 , to vote on whether a sum of terms of @xmath0 is in fact a single term .    @xmath316 + @xmath317[proc : computeimage]@xmath318 +    @xmath319",
    "we now are ready to analyze the cost of the algorithm [ proc : majorityvotesparseinterpolate ] and verify theorem  [ thm : cost ] .",
    "as we have argued in sections [ sec : primes][sec : terms ] , the cost of one iteration of the algorithm is dominated by the cost of constructing the images @xmath105 . recall that there are @xmath176 primes @xmath102 , each less than or equal to @xmath217 , and there are @xmath264 elements @xmath104 s , each in an extension @xmath34 .",
    "the total number of field operations is thus @xmath320 .",
    "the values of @xmath321 , and @xmath83 are specified in the input .",
    "recall the following parameters from equation , corollary  [ cor : lambda_ell ] and lemma  [ lem : detect ] :    @xmath322    therefore the total cost of the @xmath320 operations in @xmath6 is @xmath323 bit operations .",
    "the multiplicative @xmath303 factor due to the number of iterations does not affect the `` soft - oh '' cost above .",
    "this cost is a multiplicative factor of @xmath324 improvement over the cost of diversified interpolation @xcite .",
    "it also improves over the cost of recursive interpolation @xcite by a multiplicative factor of @xmath325 .",
    "we have presented a new algorithm for sparse interpolation over an arbitrary finite field that is asymptotically faster than those previously known . in terms of bit operations",
    "it improves on previous methods by `` soft - oh '' multiplicative factor of @xmath3 , @xmath326 , or @xmath5 .    in this `` majority - vote '' interpolation",
    ", we combine the main ideas of the previous two algorithms .",
    "namely , we reduce the probe degree by only aiming to reconstruct _ some _ of the terms of @xmath0 at every iteration ; and we distinguish images of distinct terms ( and subsets of terms ) by way of diversification .",
    "we mention a few open and motivating problems .",
    "first , we believe the algorithm in this paper has considerable potential in the more traditional numerical ( floating point ) domain . there ,",
    "an unknown sparse polynomial is reconstructed from a small number of evaluations in @xmath327 under a standard backward - error model of precision and stability .",
    "see @xcite for an example of a straight - line program interpolation algorithm adapted to floating point computation .",
    "our hope is that by evaluating at lower - order roots of unity ( such as used in this paper ) we can provably increase the numerical stability over the prony - like algorithm of @xcite , while maintaining its near - optimal efficiency .",
    "second , the algorithm presented here is monte carlo . it remains unknown whether there exist faster deterministic or las vegas polynomial identity tests that may render recursive or majority - vote interpolation las vegas of the same complexity .    finally , as noted earlier , an information theoretic lower - bound on sparse interpolation suggests a minimum bit - complexity of @xmath328 bit operations . while this paper gets closer ,",
    "some considerable improvements remain to be found .",
    "the first two authors would like to acknowledge the support of the natural sciences and engineering research council of canada ( nserc ) .",
    "the third author is supported by the national science foundation , award # 1319994 .",
    "andrew arnold and daniel  s. roche .",
    "multivariate sparse interpolation using randomized kronecker substitutions . to appear , international symposium on symbolic and algebraic computation ( issac14 ) , 2014 .",
    "andrew arnold , mark giesbrecht , and daniel  s. roche .",
    "faster sparse interpolation of straight - line programs . in _ proceedings of computer algebra in scientific computation ( casc 2013 ) _ , volume 8136 of _ lecture notes in computer sciences",
    "_ , pages 6175 , 2013 .",
    "markus blser , moritz hardt , richard  j. lipton , and nisheeth  k. vishnoi .",
    "deterministically testing sparse polynomial identities of unbounded degree . _ information processing letters _ , 1090 ( 3):0 187192 , 2009 .",
    "timothy  s. freeman , gregory  m. imirzian , erich kaltofen , and lakshman yagati . : a system for manipulating polynomials given by straight - line programs .",
    "_ acm trans .",
    "_ , 14:0 218240 , september 1988 .",
    "doi : 10.1145/44128.214376 .",
    "mark giesbrecht and daniel  s. roche .",
    "diversification improves interpolation . in _ proceedings of the 36th international symposium on symbolic and algebraic computation _",
    ", issac 11 , pages 123130 , new york , ny , usa , 2011 .",
    "isbn 978 - 1 - 4503 - 0675 - 1 .",
    "wassily hoeffding .",
    "probability inequalities for sums of bounded random variables .",
    "_ journal of the american statistical association _ , 580 ( 301):0 pp .",
    "1330 , 1963 .",
    "issn 01621459 .",
    "url http://www.jstor.org/stable/2282952 .",
    "seyed mohammad  mahdi javadi and michael monagan .",
    "parallel sparse polynomial interpolation over finite fields . in _ proc .",
    "international workshop on parallel symbolic computation ( pasco 2010 ) _ , pages 160168 , 2010 ."
  ],
  "abstract_text": [
    "<S> we present a new monte carlo algorithm for the interpolation of a straight - line program as a sparse polynomial @xmath0 over an arbitrary finite field of size @xmath1 . </S>",
    "<S> we assume _ a priori _ </S>",
    "<S> bounds @xmath2 and @xmath3 are given on the degree and number of terms of @xmath0 . </S>",
    "<S> the approach presented in this paper is a hybrid of the diversified and recursive interpolation algorithms , the two previous fastest known probabilistic methods for this problem . by making effective use of the information contained in the coefficients themselves , this new algorithm improves on the bit complexity of previous methods by a `` soft - oh '' factor of @xmath3 , @xmath4 , or  @xmath5 . </S>"
  ]
}