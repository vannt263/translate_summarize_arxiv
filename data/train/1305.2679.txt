{
  "article_text": [
    "we consider a generalization of the well - known index coding problem to the multi - sender setting where the senders are _ constrained _ to know only certain messages . as in the typical setup",
    "we have @xmath0 receivers each requiring some of the @xmath1 independent messages in the set @xmath2 , but in addition , we have @xmath3 separate senders who know only subsets of @xmath4 . the problem is precisely given by @xmath5 . here",
    ", @xmath6 corresponds to receiver @xmath7 , where @xmath8 is the subset of messages it knows a priori , and @xmath9 is the subset of messages it requires .",
    "furthermore , @xmath10 denotes messages that sender @xmath11 is constrained to know .",
    "clearly @xmath12 .",
    "without loss of generality , we assume that @xmath13 , meaning that each message bit is available at some sender(s ) .",
    "we define a multi - sender index code for the above setup :    an index code for problem instance @xmath14 consists of    1 .",
    "an encoding function for each sender @xmath15 , @xmath16 such that @xmath17 , 2 .   a decoding function for each receiver @xmath18 , @xmath19 such that + @xmath20 .",
    "that is , each sender encodes its @xmath21-bit message into an @xmath22-bit codeword .",
    "the codewords of all senders are given to all receivers .",
    "the total number of transmitted bits is thus @xmath23 , and @xmath24 the index codelength for the multi - sender generalization of the index coding problem .",
    "see fig .",
    "[ fig-0 ] for an illustration .",
    "we seek the optimal ( i.e. , the minimum ) index codelength , denoted @xmath25 , and an optimal index code ( i.e. , one of length @xmath25 ) . in this paper , we assume that each message bit and each codebit is binary , but our results hold as long as all messages and codeletters take values in the same alphabet .     is limited to know a subset @xmath26 of the message set @xmath4 .",
    "second , we consider the multicast setup where each receiver @xmath7 knows a unique message , i.e. , @xmath27 , and wants a larger subset of messages @xmath28 . ]",
    "the case @xmath29 reduces to the usual single - sender index coding problem studied in many works  @xcite .",
    "this generalization is of interest , for example , in distributed settings where senders are constrained to know only part of the entire message due to , for instance , limited bandwidth between senders for sharing the messages or decoding errors when downloading the messages from a central processor .",
    "clearly , a multi - sender index code for any @xmath30 case will also be a code for the single - sender @xmath29 case for the same @xmath31 decoding requirements .",
    "but the converse is not true .",
    "hence , the techniques described here are new , and previous techniques for the single - sender case do not straightforwardly apply .",
    "this paper also differentiates from other works  @xcite by considering a _ multicast _ setup . the classical setup ( which is _ multiprior unicast _ )",
    "is that each receiver @xmath7 requires only one unique message ( i.e. , each @xmath32 ) , knowing a set of message @xmath33 a priori .",
    "here we consider the case where each receiver @xmath7 knows only one unique message ( i.e. , each @xmath27 ) , but requires a set of messages @xmath28 , which can be a large subset of @xmath4 .",
    "we call this the _ uniprior multicast _ problem ; this setup ( first looked at in  @xcite ) is motivated by the _ multi - way relay channel _  @xcite .",
    "the differences between these two setups are depicted in fig .",
    "[ fig-0 ] . for the single - sender case ,",
    "the uniprior multicast problem is completely solved in  @xcite , which interestingly shows the optimal scheme to be _ linear _ ; this contrasts with the classical setup where it is known that linear codes can be sub - optimal  @xcite . here",
    "we explore the multi - sender generalization .",
    "note that for both unicast and uniprior multicast setups , the number of receivers , @xmath0 , equals the number of messages , @xmath1 .",
    "in this paper , we introduce a graphical representation of the uniprior multicast problem @xmath34 to capture both decoding requirements and sender constraints",
    ". this graphical representation shall be useful for stating and proving our subsequent results .",
    "a graph @xmath35 is a tuple of a vertex set @xmath36 and an arc / edge set @xmath37 .",
    "we correspond a vertex to each of the @xmath0 receivers .",
    "an arc @xmath38 conveys directional information from vertex @xmath39 to vertex @xmath40 , while an edge @xmath41 is undirected .",
    "an ( undirected ) graph has only edges , while a ( directed ) _ digraph _ has only arcs ; both can not have self - loops .",
    "we represent the multi - sender uniprior multicast problem as follows .",
    "the decoding requirements determined from @xmath42 is represented by an @xmath0-vertex _ information - flow _",
    "digraph @xmath35 , where @xmath43 if and only if ( iff ) receiver @xmath40 requires @xmath44 , i.e. , @xmath45 . the sender constraints determined from @xmath46",
    "is represented by an @xmath0-vertex _ message _ graph @xmath47 , where @xmath48 iff messages @xmath44 and @xmath49 are known to the same sender , i.e. , @xmath50 for some @xmath11 .",
    "note , both @xmath51 and @xmath52 share the _ same _ vertex set @xmath36 .",
    "we denote the optimal index codelength for the problem represented by @xmath53 as @xmath54 .    in the sequel ,",
    "we work on the _ simplified model _ described as follows : for any index coding problem @xmath55 , we construct a _ simplified _ @xmath56 by removing every message @xmath44 that is not required by any receiver ( meaning that vertex @xmath39 has no outgoing arc in @xmath57 ) from the receivers and the senders ; equivalently , we set @xmath58 . there is no loss of generality because an optimal index code for @xmath56 is an _",
    "optimal _ index code for @xmath59 , see proof in appendix  a.    note that an edge @xmath41 in the message graph does not indicate which sender(s ) owns both the messages ( i.e. the set of @xmath11 such that @xmath60 ) .",
    "this ambiguity will not affect the techniques developed in this paper , though we will point out in the conclusion the existence of certain multi - sender uniprior multicast problems where resolving this ambiguity may lead to further improvement of our results .",
    "we will use common graph terminology  @xcite : a _ strongly connected component _ ( scc ) of a digraph is a _",
    "maximal _ subgraph of the digraph such that in the subgraph , for any vertex pair @xmath61 , there is a directed path from @xmath39 to @xmath40 and another from @xmath40 to @xmath39 .",
    "vertex in a digraph has no outgoing arcs .",
    "a vertex @xmath40 is a _ predecessor _ of vertex @xmath39 iff there is a directed path from @xmath40 to @xmath39 .",
    "tree _ is a connected undirected subgraph with no cycle .",
    "the main contribution of this paper is the technique we propose to obtain a lower bound to @xmath25 , which will be tight in a few cases .",
    "the lower bound and achievability in this paper will be stated in terms of _ leaf sccs _ in the information - flow digraph @xmath51 .",
    "a leaf scc is an scc that has ( a ) no outgoing arc ( i.e. , from a vertex in the scc to a vertex outside the scc ) , and ( b ) at least two vertices ( i.e. , _ non - trivial _ ) .",
    "we first obtain results for the single - sender case ( i.e. , with no sender constraint ) .",
    "while the single - sender case has been solved  @xcite , we propose an alternative technique to obtain a lower bound to the index codelength .",
    "this then allows us to develop intuition on the main results for the general multi - sender case .",
    "this intuition is based on the following lemmas :    [ lemma : predecessor ] from any index code , each receiver @xmath39 must be able to decode the messages of all its predecessors .",
    "[ lemma : predecessor - all ] from any index code , any receiver must be able to decode the messages of all predecessors of any leaf vertex .",
    "lemma [ lemma : predecessor - all ] ( proven in appendix  b ) is a simple corollary to lemma [ lemma : predecessor ] .",
    "the proof of former is as follows :    for every arc @xmath62 , receiver @xmath39 must be able to decode @xmath49 .",
    "having decoded @xmath49 , receiver @xmath39 knows the only a priori message that receiver @xmath40 has .",
    "therefore , receiver @xmath39 must also be able to decode all messages required ( and hence decodable ) by receiver @xmath40 , i.e. , @xmath63 .",
    "further chaining of this argument shows that receiver @xmath39 must be able to decode messages @xmath49 of all predecessors @xmath40 of @xmath39 .",
    "we now use the above lemmas to develop a simple lower bound to the optimal index codelength .",
    "first , we make some useful graph - related definitions .",
    "a leaf scc with vertex set @xmath64 is said to be _ pruned _ , if one vertex @xmath65 is arbitrarily selected , and all outgoing arcs are removed from @xmath66 .",
    "a vertex is said to be _ grounded _ if the vertex is a leaf vertex or a predecessor of some leaf vertex .",
    "a digraph is said to be grounded if every vertex in the digraph is grounded .",
    "for example , directed tree is grounded ; more generally , a digraph that contains no leaf scc is grounded ( see appendix  c ) .",
    "consider @xmath53 .",
    "we prune all leaf sccs in @xmath51 to obtain a grounded digraph @xmath67 .",
    "let @xmath68 denote the number of non - leaf vertices in @xmath69 ( i.e. , each with at least one outgoing arc ) . then invoking lemma  [ lemma : predecessor - all ] , any receiver ( even those with no prior , i.e. , @xmath70 ) must be able to decode @xmath71 message bits ( the messages of all non - leaf vertices in @xmath67 ) .",
    "that is , we must have the lower bound @xmath72 .",
    "note that pruning a leaf scc reduces decoding requirements , and hence @xmath73 .",
    "consequently , we have @xmath74 . this lower bound  which does not take @xmath52 into account  is tight for the single - sender case .",
    "the lower bound @xmath71 derived above applies to any @xmath52 ( i.e. , both single - sender and multi - sender ) as long as @xmath51 remains the same .",
    "unfortunately , in our multi - sender setting , this lower bound may be _ unachievable _ due to the sender constraints ( captured by the message graph @xmath75 .",
    "there are specific situations where this lower bound is achievable .",
    "consider the case where every leaf scc of @xmath51 has the property that , there always exists a path in @xmath52 between any two vertices in the scc , where this path is constrained to involve only vertices within the scc .",
    "we say that such leaf sccs are _ message - connected_. if all leaf sccs in @xmath51 are message - connected , then a similar scheme to the single - sender case  @xcite achieves @xmath71 bits .",
    "we clarify the schemes in the later sec .",
    "[ section : achievable ] .",
    "the above - mentioned lower bound can be tightened by considering the sender constraints . to this end",
    ", we introduce new techniques in this paper , which requires the following further characterization of the leaf sccs in @xmath51 in relation to the message graph @xmath52 .    1 .",
    "recall that a leaf scc is _ message - connected _ iff a path exists in @xmath52 between any two vertices in the scc , and this path consists of vertices within the scc .",
    "a leaf scc is _ message disconnected _ iff there are two vertices in the scc with no path in @xmath52 between them ; 3 .",
    "a leaf scc which is neither message connected nor message disconnected is _",
    "semi message connected _ , referred also as semi leaf scc .",
    "thus , there exists a path in @xmath52 between two vertices in the scc with at least one vertex of the path outside the scc .",
    "semi leaf sccs are also further classified using the following property . for a vertex set @xmath76 ,",
    "a vertex @xmath77 is an _",
    "m - neighbor _ of @xmath64 iff there is an edge @xmath78 between @xmath39 and some @xmath65 . here , `` m '' is mnemonic for message .",
    "then , a semi leaf scc with vertex set @xmath64 , is said to be _ degenerated _ iff    1 .",
    "@xmath64 can be partitioned into _ two _ parts @xmath79 and @xmath80 such that there is no edge in @xmath52 across vertices from different parts , and 2 .",
    "there exists a vertex subset not in @xmath64 , denoted by @xmath81 , which * can only have at most one non - leaf vertex ( the other vertices must strictly be leaf ) + such that * every m - neighbor of @xmath79 is in @xmath82 or is a predecessor of some vertex in @xmath82 .",
    "( arcs in black ) and a message graph @xmath52 ( edges in red ) . by their definition , leaf sccs are determined by @xmath51 , but their various types are determined also in accordance with @xmath52 .",
    "these graphs illustrate concurrently three leaf sccs types :",
    "( i ) message connected , where there is a ( red ) path between any two vertices through only vertices in the scc ; ( ii ) message disconnected , containing two vertices can not be connected with a red path ; and ( iii ) semi message connected , where some vertices must be connected by a path with vertices outside the scc .",
    "note , the semi leaf scc here is degenerated because we can find two vertex sets @xmath83 and @xmath84 , such that all m - neighbors of @xmath83 are predecessors of @xmath85 . ]",
    "[ fig-1 ] illustrates the above characterizations of leaf sccs .",
    "the discussion in the previous section explains that a grounded graph @xmath67 delivers a lower bound to @xmath54 .",
    "we will describe new techniques to arrive at `` better '' grounded graphs @xmath67 from the original digraph @xmath51 , giving tighter lower bounds @xmath86 where @xmath87 is the message graph that may be modified from the original @xmath52 . here",
    ", we do not prune all leaf sccs ( pruning reduces @xmath71 ) , and this gives us a larger @xmath71 .",
    "if a digraph contains no leaf scc , then it is grounded ( proven in appendix  c ) .",
    "so , to produce the required @xmath88 , we devise algorithm  [ algorithm ] given below .",
    "this algorithm iteratively `` breaks '' leaf sccs or changes arc - connectivity of the vertices therein , such that the resultant @xmath67 contains no leaf scc .",
    "the algorithm is also specially designed to make sure that in each step , the optimal index codelength can not increase , thus giving @xmath89 combining and , we have the lower bound @xmath90    ( ) run breakleafscc    we propose different methods to _ break _ the leaf sccs in @xmath51 , such that they are no longer leaf sccs .",
    "algorithm  [ algorithm ] has two distinct phases . in phase 1",
    ", the procedure breakleafscc is run once to break all initial message - connected leaf sccs in @xmath51 , and then all message - disconnected and degenerated leaf sccs .",
    "note that some leaf sccs may be made message - connected or message - disconnected in step ( iii ) .",
    "also , pruning message - connected leaf sccs might make some semi leaf sccs degenerated .",
    "phase 2 breaks the remaining leaf sccs .",
    "step ( ii ) in breakleafscc involves _ appending _ a dummy leaf vertex @xmath39 to a leaf scc ( with vertex set @xmath64 ) , by appending an outgoing arc @xmath91 from some @xmath65 to @xmath39 . in step ( iv - a )",
    ", the choice of leaf scc for adding edges is arbitrary .",
    "nevertheless , a proper choice of leaf scc(s ) _ minimizes _ the number of rounds that step ( iv ) iterates , which we shall see will then give a better lower bound .",
    "let @xmath92 denote the number of message - connected leaf sccs in @xmath51 .",
    "note that @xmath92 for each @xmath51 is fixed , independent of the algorithm .",
    "let @xmath93 denote the number of leaf sccs ( they must be semi leaf sccs ) that remain after the initial run of breakleafscc in phase 1 , and @xmath94 denote the number of iterations in phase 2",
    ". we will show ( in sec .",
    "[ sec : remove - scc ] ) that step ( iv ) always reduces the number of leaf sccs , and so @xmath95 .",
    "we now state the main result of this paper :    [ lower bound ] [ theorem : multi - sender - lower - bound ] the optimal multi - sender index codelength is lower bounded as @xmath96    we will prove thm .  [",
    "theorem : multi - sender - lower - bound ] in sec .",
    "[ section : upper ] .",
    "we will see that the rhs of equals the rhs of .",
    "as mentioned earlier , the lower bound is optimized by finding the smallest @xmath94 .",
    "our achievability scheme is based on the construction of special trees in the message graph @xmath52 , referred to as _ connecting trees _",
    ", which has all the following properties placed on its vertex set @xmath97 :    1 .",
    "each vertex in @xmath97 has one or more outgoing arcs in @xmath51 .",
    "each vertex in @xmath97 has no outgoing arc in @xmath51 to @xmath98 , 3 .",
    "no vertex in @xmath97 belongs to any message - connected leaf sccs or another connecting tree .",
    "let @xmath99 denote the number of connecting trees that can be found .",
    "we will propose a coding scheme that achieves the following index codelength :    [ theorem : multi - sender - achievable ] the optimal multi - sender index codelength is upper bounded as @xmath100    we prove thm .",
    "[ theorem : multi - sender - achievable ] in sec .",
    "[ section : achievable ] .",
    "the achievability is optimized by finding the maximum number of connecting trees .    for fig .",
    "[ fig-1 ] , we can not form any connecting tree ; for fig .  [ fig-2 ] , we can form one connecting tree using the green vertices .     ( with black arcs ) and @xmath52 ( with red edges ) .",
    "there are two leaf sccs in the graph : ( i ) message connected , and ( ii ) degenerated . here",
    ", we can form a connecting tree using the green vertices .",
    ", width=151 ]      combining thms .",
    "[ theorem : multi - sender - lower - bound ] and [ theorem : multi - sender - achievable ] , we conclude @xmath101 , and thus the optimal index codelength is found within @xmath102 bits . in the following special cases",
    ", we have @xmath103 , and the lower bound is tight .    [ corollary : no - semi ] if no leaf scc remains after running phase 1 of algorithm  [ algorithm ] , then @xmath104    since @xmath105 , @xmath106 implies that @xmath107 .",
    "[ corollary : unique ] if each bit @xmath44 in the message set @xmath4 is known to only one sender ( i.e. , the @xmath0 sender constraint sets @xmath26 partition @xmath4 ) , then the optimal index codelength is given by .",
    "if messages @xmath44 and @xmath49 belong to some sender @xmath11 ( i.e. @xmath108 ) , then there exists an edge @xmath41 in the message graph @xmath52 .",
    "otherwise , if the messages @xmath109 belong to different senders , it is impossible to have a _ path _ between @xmath39 and @xmath40 .",
    "this means we have only message connected or disconnected leaf sccs , i.e. , there is no semi leaf scc .",
    "thus , @xmath110 .",
    "corollary  [ corollary : unique ] includes the result of the single - sender problem  @xcite as a special case .     on fig .",
    "[ fig-2 ] , where the dashed arcs are removed , and the blue arc added . ,",
    "width=132 ]      we now illustrate the lower bound and the achievability for the graph in fig .  [ fig-2 ] . for lower",
    "bound , we run algorithm  [ algorithm ] to obtain the resultant graph shown in fig .",
    "[ fig-3 ] ( with dashed arcs removed and blue edge / arc added ) . specifically , starting from fig .",
    "[ fig-2 ] , note that the furthest - left four vertices form a message - connected leaf scc . executing step ( i ) of the algorithm ,",
    "we remove all outdoing arcs from a vertex",
    ". here , vertex @xmath111 ( in fig .  [ fig-3 ] ) is arbitrarily chosen , and the dashed arc from @xmath111 is removed .",
    "the right three vertices form a degenerated leaf scc . executing step ( iii - a )",
    ", we add an arc ( indicated by the blue arc in fig .",
    "[ fig-3 ] ) from the vertex in @xmath79 to @xmath112 .",
    "entering phase 2 , we note that the right three vertices now form a message - connected leaf scc . executing step ( iv-0 ) , we prune the leaf scc by removing the dashed arc .",
    "the algorithm terminates here , after breaking all leaf sccs . from theorem  [ theorem : multi - sender - lower - bound ]",
    ", we have the lower bound @xmath113 .    for achievability , recall that we can form a connecting tree using the three green vertices in fig .",
    "[ fig-2 ] .",
    "so , theorem  [ theorem : multi - sender - achievable ] gives the upper bound @xmath114 .",
    "for this example , the optimal index codelength is 5 bits .",
    "we will refer to each vertex @xmath39 as receiver @xmath39 ( and vice versa ) , and @xmath44 as the message of receiver / vertex @xmath39 .    in sec .",
    "[ sec : remove - scc ] , we will prove that algorithm  [ algorithm ] produces a grounded @xmath67 , meaning that holds ; in sec  [ sec : cannot - increase - length ] , we will prove that @xmath67 produced by algorithm  [ algorithm ] satisfies .",
    "we now show that algorithm  [ algorithm ] produces a digraph with no leaf scc , and hence grounded . as the algorithm terminates after all leaf sccs",
    "have been broken , it suffices to show that the algorithm always terminates , i.e. , step ( iv ) iterates for a finite number of times .",
    "this is true if step ( iv ) always reduces the number of leaf sccs .",
    "we first show that any of the steps ( i ) , ( ii ) , and ( iii - b ) reduces the number of leaf sccs by one . in step ( i ) , after removing all outgoing arcs from some vertex @xmath66 in a leaf scc , @xmath66 and other vertices in the scc ( each having a directed path to @xmath66 ) are grounded . in steps ( ii ) and ( iii - b ) , an arc is added from a leaf scc to a leaf vertex .",
    "this will also ground all vertices in the scc . as any grounded vertex can not belong to a leaf scc ,",
    "each of these steps breaks the leaf scc it `` operates '' on , thereby reducing the number of leaf sccs by one .",
    "we now show that step ( iii - a ) can not increase the number of leaf sccs . step ( iii - a ) adds an arc from a leaf scc ( denote by @xmath115 ) to some vertex @xmath116 not in @xmath115 .",
    "there are three possibilities : ( 1 ) @xmath116 is grounded . using the argument for step ( ii ) ,",
    "the number of leaf sccs decreases by one .",
    "( 2 ) @xmath116 is not grounded and has no directed path to @xmath115 . in this case",
    "@xmath115 is made non - leaf , and the number of leaf sccs decreases by one .",
    "( 3 ) @xmath116 is not grounded and has a directed path to @xmath115 . in this case",
    "the scc @xmath115 expands to include more vertices ( including @xmath116 ) and arcs .",
    "the number of leaf sccs decreases ( if the expanded scc is non - leaf ) or stays the same ( otherwise ) .",
    "finally , consider each iteration ( iv ) .",
    "step ( iv - b ) makes a semi leaf scc message connected .",
    "this step , only adding edges , does not change the number of leaf sccs .",
    "when running breakleafscc in step ( iv - c ) , the leaf scc that has been made message - connected will be broken in step ( i ) , and other steps ( ii ) and ( iii ) can not increase the number of leaf sccs .",
    "so , step ( iv ) always reduces the number of leaf sccs .",
    "now , we prove by showing that each of the steps ( i)(iv ) can not increase the optimal index codelength , i.e. , @xmath117 where @xmath118 and @xmath47 respectively denote information - flow and message graphs before each of the steps ( i)(iv ) ; @xmath119 and @xmath120 , after the step .",
    "removing arcs in the information - flow digraph is equivalent to removing decoding requirements for the receivers .",
    "hence , we have .",
    "now , as adding an arc @xmath121 and a dummy receiver @xmath39 increases decoding requirements , we have @xmath122 .",
    "but , lemma  [ lemma : disconnected ] below says that using any optimal index code for @xmath53of length @xmath54a dummy receiver can decode all messages of all message - disconnected leaf sccs .",
    "hence , this index code also satisfies the decoding requirements of @xmath123 , i.e. , @xmath54 is achievable for the problem instance @xmath123 .",
    "so , in fact holds with equality .",
    "[ lemma : disconnected ] for any index code , any receiver is able to decode the messages of all message - disconnected leaf sccs .    let @xmath64 be the vertex set of a message - disconnected leaf scc .",
    "by definition , we can partition all vertices @xmath36 into two non - empty sets @xmath124 and @xmath125 , such that two vertices @xmath126 in the leaf scc lie on separate partitions and can not have an undirected path ( in @xmath52 ) between them .",
    "let @xmath127 and @xmath128 .",
    "the lack of edge - connectivity between @xmath124 and @xmath125 implies that any index code can be partitioned into two parts , @xmath129 , such that every bit in @xmath130 depends on only @xmath131 and not on @xmath132 , and vice versa .",
    "since @xmath111 and @xmath133 belong to an scc , receiver @xmath111 must decode @xmath134 ( see lemma  [ lemma : predecessor ] ) .",
    "note that @xmath130 ( which contains @xmath135 ) and @xmath136 do not have any message bit in common .",
    "so , knowing @xmath135 can help receiver @xmath111 decode only messages in @xmath130 .",
    "also , receiver @xmath111 must decode @xmath134 using solely @xmath136 , without using its prior .",
    "hence , if @xmath111 can decode @xmath134 , so can any receiver  even one without prior .",
    "since the choice of @xmath137 was arbitrary , we have lemma  [ lemma : disconnected ] .      recall the vertex subsets @xmath138 and @xmath139 . in step ( iii )",
    ", we append an arc from @xmath79 to some vertex @xmath140 . if we can show that receiver @xmath116 can decode all messages of @xmath79 ( using any index code for @xmath53 ) , then by the arguments for step ( ii ) , we conclude holds with an equality .",
    "by lemmas  [ lemma : predecessor ] and [ lemma : predecessor - all ] , receiver @xmath116 can decode the messages of all m - neighbors of @xmath79 , denoted as @xmath141 , as each vertex in @xmath141 is either grounded , a predecessor of @xmath116 , or @xmath116 itself .",
    "let @xmath142 and @xmath143 , where @xmath111 must decode @xmath134 .",
    "we will show that if @xmath111 can decode @xmath134 , so can @xmath116 .",
    "consequently , @xmath116 can decode all messages of @xmath79 .",
    "there is no edge across @xmath79 and @xmath80 , meaning that any index codebit can not be a function of messages from both the sets .",
    "so , we can partition any index code for @xmath53 into @xmath129 , where @xmath130 does not contain any message of @xmath79 , and @xmath136 contains only the messages of @xmath79 and @xmath141 .",
    "any advantage in decoding that @xmath111 has over @xmath116 is due to knowing @xmath135 , but @xmath135 can help @xmath111 only in decoding the messages in @xmath130 , which @xmath111 can then use to decode the messages in @xmath136 ( which contain @xmath134 ) .",
    "as @xmath116 is able decode the messages of @xmath141 , which contains all the overlap of messages in @xmath130 and @xmath136 , @xmath116 is as capable as @xmath111 in decoding @xmath134 .",
    "appending an edge @xmath41 is equivalent to appending messages @xmath144 to some sender s message set @xmath26 .",
    "doing so relaxes the sender constraints , and thus the optimal codelength can only decrease . hence holds .      combining and , we have .",
    "we now show .    in each iteration ( iv ) ,",
    "exactly one message - connected leaf scc is pruned , either in step ( iv-0 ) or in step ( iv - c ) , which executes step ( i ) _ once _ through breakleafscc .",
    "note that step ( iv - b ) makes only _ one _ leaf scc message connected . out of all the steps , only pruning , i.e. , step ( i ) , changes @xmath145reducing it by one at each run .",
    "so when algorithm  [ algorithm ] terminates , we have @xmath146 where @xmath147 is the number of times step ( @xmath111 ) is run . from and",
    ", we have .",
    "this completes the proof of thm .  [",
    "theorem : multi - sender - lower - bound ] .",
    "in this section , we will show that there exists an index code of length @xmath149 .",
    "let a set of connecting trees be @xmath150 , and all the message - connected leaf sccs in @xmath51 be @xmath151 .",
    "further , let the remaining vertices in @xmath51 be @xmath152 .",
    "denote by @xmath153 the set of all non - leaf vertices in @xmath154 . by definition , all @xmath155 and @xmath154 are disjoint .",
    "our coding scheme is as follows :    1 .   for each connecting tree @xmath156",
    ", we transmit all @xmath157 , i.e. , we transmit the network - coded bits of the associated message pair for each edge .",
    "note that we transmit @xmath158 bits . 2 .   for each message - connected leaf scc @xmath159 (",
    "which is edge - connected by definition ) , we first obtain a spanning tree , denoted by @xmath160 , where @xmath161 .",
    "we then transmit all @xmath162 .",
    "note that we transmit @xmath163 bits .",
    "3 .   for the rest of the non - leaf vertices",
    ", we transmit @xmath164 , i.e. , we transmit the message bits uncoded .",
    "each vertex in the connecting trees and the message - connected sccs has at least one outgoing arc .",
    "hence , the coding scheme generates an index code of length @xmath165 .",
    "we can easily verify that the index code can be transmitted , as each message pair to be xored is associated with an edge , i.e. , both the message bits belong to some sender .",
    "finally , we show that each receiver is able to obtain its required messages .",
    "recall that each receiver @xmath39 needs to decode all messages in @xmath166 .",
    "now , each receiver @xmath39 must belong to one  and only one  of the following groups :    1 .",
    "( connecting tree ) @xmath167 : knowing @xmath44 , receiver @xmath39 can decode all @xmath168 from @xmath169 by traversing the tree ( which is connected by definition ) .",
    "it can also decode the messages @xmath170 , sent uncoded .",
    "since all connecting trees and message - connected leaf sccs have no outgoing arcs , each incoming arc to @xmath39 must be from either @xmath171 or @xmath153 .",
    "so , receiver @xmath39 is able to decode all its required messages .",
    "2 .   ( message - connected leaf scc )",
    "@xmath172 : using the same argument as that for the connecting trees , we can show that receiver @xmath39 can decode all its required messages .",
    "3 .   ( the remaining vertices )",
    "@xmath173 : using the argument in point 1 , all incoming arcs to vertex @xmath39 must come from @xmath174 .",
    "since we sent @xmath175 uncoded , receiver @xmath39 can decode all its required messages .",
    "we now show that the pairwise linear coding proposed in sec .",
    "[ section : achievable ] can be suboptimal .",
    "consider an index coding problem with @xmath177 messages / receivers , @xmath178 where @xmath179 , and @xmath180 senders having the following messages @xmath181 , @xmath182 , @xmath183 , and @xmath184 respectively .",
    "we can also show that the largest @xmath186 , i.e. , the pairwise linear coding ( thm .  [ theorem : multi - sender - achievable ] ) can only achieve 5 bits .",
    "however , if each sender sends the xor of its three message bits , the 4-bit lower bound is achievable .",
    "this example illustrates that  in stark contrast to the single - sender case  the pairwise coding scheme described in sec .",
    "[ section : achievable ] is not always optimal .",
    "it also shows a disadvantage of using @xmath52 : it can not differentiate a sender having @xmath187 from three senders having @xmath188 respectively . for future work , we will investigate a more general coding scheme and a more informative graphical representation .",
    "consider an index coding problem , and denote its optimal codelength by @xmath189 .",
    "let @xmath190 be the set of receivers whose messages @xmath191 are not required by any other receiver .",
    "further consider the simplified index coding problem where @xmath58 for all @xmath192 .",
    "denote its optimal codelength by @xmath193 .",
    "it follows from proposition  [ proposition : simplified ] that @xmath196 .",
    "now consider any optimal index code @xmath197 for . by definition",
    "it can contain @xmath191 .",
    "since @xmath197 is an index code , all receivers in can decode their required messages when @xmath198 for all @xmath192 ( these messages @xmath44 are not required by any receiver ) .",
    "so , @xmath197 with all @xmath44 set to 1 is also an optimal index code .",
    "denote this code by @xmath199 .",
    "now , since @xmath199 does not depend on the actual contents of @xmath191 , @xmath199 can also be sent by the senders in , and it also satisfies the decoding requirement of .",
    "this means @xmath199 is an index code for , and hence @xmath200 .",
    "appendix b recall that in the simplified graphs , if @xmath39 is a leaf vertex , then @xmath58 , i.e. , it has no prior message .",
    "consequently any receiver @xmath201 , regardless of the prior knowledge @xmath202 it possesses , is as good as the leaf vertex ( receiver ) @xmath39 .",
    "hence @xmath201 must be able to decode all messages decodable by receiver @xmath39 , and the result follows from the proof of lemma  [ lemma : predecessor ] .",
    "appendix c given any digraph @xmath51 , we form a _ supergraph _ @xmath203 by replacing each ( leaf or non - leaf ) scc with at least two vertices by a ( special ) vertex referred to as a _ supernode_. first , @xmath203 can not contain any directed cycle .",
    "otherwise , all supernodes and vertices in the cycle form an scc , and it would have been collapsed into a supernode . further , if @xmath51 has no leaf scc , meaning that @xmath203 has no leaf supernode , then every supernode and non - leaf vertex must have a path to a leaf vertex .",
    "this means @xmath51 is grounded .",
    "@xmath148      y.  birk and t.  kol , `` coding on demand by an informed source ( iscod ) for efficient broadcast of different supplemental data to caching clients , '' _ ieee trans .",
    "inf . theory _ ,",
    "vol .  52 , no .  6 , pp . 28252830 , june 2006 .",
    "s.  el rouayheb , a.  sprintson , and c.  georghiades , `` on the index coding problem and its relation to network coding and matroid theory , '' _ ieee trans .",
    "inf . theory _ ,",
    "56 , no .  7 , pp .",
    "31873195 , july 2010 ."
  ],
  "abstract_text": [
    "<S> we focus on the following instance of an index coding problem , where a set of receivers are required to decode multiple messages , whilst each knows one of the messages a priori . </S>",
    "<S> in particular , here we consider a generalized setting where they are multiple senders , each sender only knows a subset of messages , and all senders are required to collectively transmit the index code . for a single sender , </S>",
    "<S> ong and ho ( icc , 2012 ) have established the optimal index codelength , where the lower bound was obtained using a pruning algorithm . in this paper , </S>",
    "<S> the pruning algorithm is simplified , and used in conjunction with an appending technique to give a lower bound to the multi - sender case . </S>",
    "<S> an upper bound is derived based on network coding . while the two bounds do not match in general , for the special case where no two senders know any message bit in common , the bounds match , giving the optimal index codelength . </S>",
    "<S> the results are derived based on graph theory , and are expressed in terms of strongly connected components . </S>"
  ]
}