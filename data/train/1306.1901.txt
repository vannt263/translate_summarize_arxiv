{
  "article_text": [
    "program termination is a hot research topic in program analysis .",
    "the last few years have witnessed the development of termination analyzers for mainstream programming languages such as c  @xcite and java  @xcite with remarkable precision and performance .",
    "these systems are largely based on techniques and tools coming from the field of declarative constraint programming .    beyond the specificities of the targeted programming languages and",
    "after several abstractions ( see , e.g. , @xcite ) , termination analysis of entire programs boils down to termination analysis of individual loops .",
    "various categories of loops have been identified : for the purposes of this paper we focus on _ single - path linear constraint _ ( slc ) loops  @xcite .",
    "an slc loop over @xmath0 variables @xmath1 , ",
    ",  @xmath2 has the form @xmath3 where @xmath4 and @xmath5 are column vectors of variables , @xmath6 is an integer matrix , @xmath7 , @xmath8 and @xmath9 .",
    "such a loop can be conveniently written as a constraint logic programming rule : @xmath10 when variables take their values in @xmath11 ( resp . , @xmath12 ) , we call such loops _ integer _",
    ", _ rational _ ) loops .",
    "they model a computation that starts from a point @xmath13 ; if @xmath14 is false , the loop terminates ; otherwise , a new point @xmath15 is chosen that satisfies @xmath16 and iteration continues replacing the values of @xmath13 by those of @xmath15 .",
    "loop termination can always be ensured by a _ ranking function _",
    "@xmath17 , a function from @xmath18 or @xmath19 to a well - founded set .",
    "as the domain of @xmath17 is well - founded , the computation terminates . to the best of our knowledge , decidability of universal termination of slc loops ( i.e. , from any starting point and for any choice of the next point at each iteration ) is an open question .",
    "some sub - classes have been shown to be decidable  @xcite .",
    "for instance , braverman proves that termination of loops where the body is a _ deterministic _",
    "assignment @xmath20 is decidable when the variables range over @xmath12 .",
    "the problem is open for the non - deterministic case , as stated in his paper . on the other hand ,",
    "various generalizations have been shown to be undecidable  @xcite .",
    "a way to investigate loop termination is to restrict the class of considered ranking functions . in the following section",
    ", we recall a well - known technique for computing linear ranking functions for rational slc loops .",
    "in section  [ sec : eventual - linear - ranking - functions ] we present the main contribution of the paper , namely the definition of _ eventual linear ranking functions _ : these are linear functions that become ranking functions after a finite unrolling of the loop .",
    "we shall see that the number of unrolling is not pre - defined , but depends on the data processed by the loop .",
    "section  [ sec : eventual - linear - ranking - functions ] presents complete decision procedures for the existence of eventual linear ranking functions of slc loops .",
    "the presentation is gradual and illustrates the algorithms by means of constraint logic programming ( clp ) technology and dialogs with real clp tools .",
    "section  [ sec : related - work - and - experiments ] discusses related work and a preliminary experimentation conducted on the benchmarks proposed in two very recent papers .",
    "section  [ sec : conclusion - and - future - work ] concludes the paper .",
    "we first define the notion of linear ( resp . , affine )",
    "ranking function for an slc loop .",
    "[ def - fn - rng - lin ] let @xmath21 be the slc loop @xmath22 @xmath23 where @xmath24 is an n - ary relation symbol .",
    "a _ linear _ ( resp . ,",
    "_ affine _ ) _ ranking function _",
    "@xmath17 for @xmath21 is a linear ( resp .",
    ", affine ) map from @xmath19 to @xmath12 such that @xmath25    in words , continuation of the iteration , i.e. , @xmath26 , entails that @xmath17 stays positive and strictly decreases by at least @xmath27 for each iteration .",
    "we point out that if @xmath26 is not satisfiable , the loop ends immediately and any linear function is a ranking function . in the paper ,",
    "we assume that @xmath26 is satisfiable",
    ".    might seem too restrictive when working with rational numbers as one might prefer to replace the decrease by @xmath27 by a decrease by @xmath28 , a fixed positive quantity .",
    "actually , by multiplying such an @xmath28-decrease ranking function by @xmath29 , we see that the two definitions are equivalent with respect to the existence of a ranking function .",
    "although the class of affine ranking functions subsumes the class of linear ranking functions , any decision procedure for the existence of linear ranking functions can be extended to a decision procedure for the existence of affine ranking functions . to see this , note that an affine ranking function for @xmath30 where @xmath31 is distinct from the variables in @xmath13 .    in this section ,",
    "we focus on linear ranking functions for slc loops . after the presentation of a formulation of farkas lemma we consider the problem of verifying linear ranking functions , and then the detection of such ranking functions .",
    "a linear inequation @xmath32 over rational numbers is a logical consequence of a finite satisfiable conjunction @xmath33 of linear inequations when @xmath32 is a linear positive combination of the inequations of @xmath33 .",
    "more formally , let @xmath33 be @xmath34 and suppose that @xmath33 has at least one solution .",
    "farkas lemma states the equivalence of @xmath35 and @xmath36      given an slc loop @xmath21 and a linear function @xmath17 , we can easily check whether @xmath17 is a ranking function for @xmath21 by testing the unsatisfiability of @xmath37 and @xmath38 .",
    "this test has polynomial complexity and can be done with a complete rational solver such as , e.g. , clp(@xmath12 ) @xcite .",
    "[ ex : linear - ranking - function ] for the slc loop @xmath21 : @xmath39 the linear function @xmath40 is a ranking function , as proved by the following _ sicstus prolog _ session .    .... ? - use_module(library(clpq ) ) .",
    "% library(clpq ) compiled true . ? - { x > = 0 , y1 = < y - 1 , x1 = < x + y , y = < -1 ,      x < 1 + x1}. false . ?",
    "- { x > = 0 , y1 = < y - 1 , x1 = < x + y ,",
    "y = < -1 ,      x < 0}. false . ?",
    "- ....      given an slc loop , we would like to know whether it admits a linear ranking function @xmath17 .",
    "this problem , which has been studied in depth @xcite , is decidable in polynomial time .",
    "let us consider example  [ ex : linear - ranking - function ] and formally ask whether there exists a ranking function of the form @xmath41 : @xmath42 this formulation of the problem is executable by quantifier elimination on a symbolic computation system like reduce  @xcite :    .... 1 : load_package redlog ; 2 : rlset r ; 3 : f:=ex({a , b},all({x , y , x1,y1 } ,    ( x>=0 and y1<=y-1 and x1<=x+y and y<= -1 )    impl    ( a*x+b*y>=1+a*x1+b*y1 and a*x+b*y>=0 ) ) ) ; 4 : rlqe f ; ....    statement  ` 1 ` loads the quantifier elimination module .",
    "statement  ` 2 ` defines @xmath43 as the domain of discourse .",
    "statement  ` 3 ` initializes formula @xmath44 .",
    "statement  ` 4 ` runs quantifier elimination over @xmath44 and returns an equivalent formula , ` true ` in this case .",
    "hence , formula @xmath44 is true and there exists at least one linear ranking function .",
    "we can now determine the coefficients of function @xmath17 as follows :    .... 5 : g:=all({x , y , x1,y1 } ,    ( x>=0 and y1<=y-1 and x1<=x+y and y<= -1 )    impl    ( a*x+b*y>=1+a*x1+b*y1 and a*x+b*y>=0 ) ) ; 6 : rlqe g ; ....    we obtain @xmath45 and all values for @xmath46 and @xmath47 satisfying the above formula , such as @xmath48 and @xmath49 , are equally good . unfortunately , the complexity of the algorithms involved will prevent us from systematically obtaining such a result within acceptable time and memory bounds .",
    "we now recall the most famous algorithm for this problem  @xcite . considering @xmath46 and @xmath47 as _ parameters _ of the problem , we can apply farkas lemma . for the strict decrease of the ranking function we have @xmath50 application of farkas lemma to this problem",
    "can be depicted as follows : @xmath51 we know that formula  ( [ decrease - of - the - ranking - function ] ) is equivalent to the existence of four non - negative rational numbers @xmath52 ,  ,  @xmath53 such that : @xmath54    the positivity of the ranking function , that is , @xmath55 can be written as @xmath56 by farkas lemma , formula   is equivalent to the existence of four other non - negative rational numbers @xmath57 ,  ,",
    "@xmath58 such that : @xmath59    summarizing , by farkas lemma , formula   is equivalent to the conjunction of formulas   and : @xmath60    in theory , the problem of the existence of a linear ranking function is polynomial .",
    "since computing one solution ( that is , values for @xmath46 and @xmath47 ) is not harder than determining its existence , a `` witness '' function , which would constitute a _ termination certificate _ , can also be computed in polynomial time .",
    "the space of all linear ranking functions as defined in definition [ def - fn - rng - lin ] , described by parameters @xmath46 and @xmath47 , can be obtained by elimination of @xmath61 and @xmath62 from   using , e.g. , the algorithm of fourier - motzkin .",
    "for example the sicstus prolog program    .... fm(a , b ) : -     { l1 > = 0 , l2 > = 0 , l3 > = 0 , l4 > = 0 ,      lp1 > = 0 , lp2 > = 0 , lp3 > = 0 , lp4 > = 0 ,      a = l1 + l2 , b = l2 + l3 - l4 ,      a = l2 , b = l3 , 1 = < l3 + l4 ,      a = lp1 + lp2 , b = lp2 + lp3 - lp4 ,      0 = lp2 , 0 = lp3 , 0 = < lp3 + lp4}. ....    can be queried as follows :    ....    b = 0 , { a > = 1}.    ....    it can be shown that the computed answer is equivalent to the ( significantly more involved ) condition generated by reduce .",
    "in the previous section we have illustrated a method to decide the existence of a linear ranking function for a rational slc loop , something that implies termination of the loop .",
    "of course , the method can not decide termination in all cases .",
    "[ ex - fn - rng - lin - evt - p ] the loop @xmath63 does not admit a linear ranking function .",
    "can we conclude that such loop does not always terminate ?",
    "no , because it may admit a non - linear ranking function .",
    "in this section we will extend the previous method so as to detect _ eventual linear ranking functions _",
    ", that is , linear functions that behave as ranking functions _ after a finite number of executions of the loop body_. suppose that the considered slc loop is always given with a linear function @xmath64 that increases at each iteration of the loop in the following sense :    [ def - inc - lin - fn ] let @xmath21 be the slc loop @xmath22 @xmath23 .",
    "a function @xmath65 is _ increasing for @xmath21 _ if it is linear and satisfies : @xmath66    [ ex - fn - rng - lin - evt - f ] the function @xmath67 is increasing for the loop of , since @xmath31 decreases by at least @xmath27 at each iteration .",
    "the generalization to affine functions is useless .",
    "moreover , as we are merely interested in the existence of an increasing function , the value of the increase ( @xmath27 or @xmath68 ) is irrelevant",
    ".    we can now give the definition which is central to our paper .",
    "[ def - fn - rng - lin - evt ] let @xmath21 be the rational slc loop in clausal form @xmath69 , where @xmath24 is an @xmath0-ary relation ; let also @xmath65 be a linear increasing function for @xmath21 .",
    "an _ eventual linear ranking function _ @xmath17 for @xmath70 is a linear map of @xmath19 to @xmath12 such that @xmath71    for comparison with definition  [ def - fn - rng - lin ] , remark that the threshold @xmath72 is existentially quantified and that @xmath73 is imposed in the implication antecedent .",
    "it should also be noted that , if such a rational @xmath72 exists , then each @xmath74 satisfies the condition of definition  [ def - fn - rng - lin - evt ] . on the other hand ,",
    "since , by hypothesis , @xmath75 strictly increases at each iteration , there are two cases : either @xmath75 is bounded from above by a constant , and thus the loop will terminate ; or , after a finite number of iterations , @xmath75 will cross the threshold @xmath72 and @xmath17 becomes a linear ranking function in the sense of section  [ sec : linear - ranking - functions ] so that , again , the loop terminates .",
    "eventual linear ranking functions are a generalization of linear ranking functions .",
    "[ lrf - implies - elrf ] let @xmath21 be an slc loop .",
    "if @xmath17 is a linear ranking function for @xmath21 , then there exists an increasing function @xmath75 such that @xmath70 has an eventual linear ranking function .    by hypothesis",
    ", there exists a linear ranking function @xmath76 for @xmath21 .",
    "the linear function @xmath77 is non - positive and strictly increasing for @xmath21 . considering @xmath78 it can be seen that the function @xmath79 is an eventual linear ranking function for @xmath70 .",
    "the generalization is strict as the loop of example  [ ex - fn - rng - lin - evt - p ] has no linear ranking function , but does have an eventual linear ranking function , as will be shown in the next section .      as a first step towards full automation of the synthesis of eventual linear ranking functions , we assume that an slc loop is given with a particular linear increasing function .",
    "let us consider , e.g. , the slc loop of example  [ ex - fn - rng - lin - evt - p ] and the increasing function of example  [ ex - fn - rng - lin - evt - f ] .",
    "defining @xmath41 , @xmath17  is an eventual linear ranking function when @xmath80 this definition of the problem , that we will denote for brevity with @xmath81 , is also solvable via quantifier elimination , hence the problem is decidable . considering @xmath46 , @xmath47 and @xmath72 as parameters",
    ", we can apply farkas lemma as follows : @xmath82 hence , formula @xmath83 is equivalent to the conjunction of formulas @xmath84 , i.e. , @xmath85 ensuring the positivity of the ranking function .",
    "let us focus on @xmath84 .",
    "we observe that the product @xmath86 leads to a non - linearity that we can circumvent by noting that , as @xmath87 , either @xmath88 ( hence @xmath89 ) or @xmath90 .",
    "in the latter case , we introduce a new variable @xmath91 .",
    "we have the property :    [ lem1-fn - rng - lin - evt ] formula @xmath92 is equivalent to the disjunction @xmath93 .    in our case",
    ", @xmath94 is equivalent to @xmath95    ( @xmath96 ) let @xmath72 be a rational number and @xmath61 s for @xmath97 four non - negative rational numbers such that @xmath84 holds . if @xmath88 then @xmath84 simplifies to @xmath94 which is true . if @xmath90 , we take @xmath98 and we can see that @xmath99 is true .",
    "( @xmath100 ) assume first that @xmath94 is true .",
    "then , taking @xmath88 and @xmath101 ( any rational number would be fine for @xmath72 ) , we see that @xmath92 is true . assume then that @xmath99 is true .",
    "taking @xmath102 ( this is always possible as @xmath103 ) , we observe that there exists @xmath72 such that @xmath84 is true .    for the positivity condition , we can prove in a similar way    [ lem2-fn - rng - lin - evt ] formula @xmath104 is equivalent to the disjunction @xmath105 .    in our case",
    ", @xmath106 is equivalent to @xmath107    combining the previous results gives    formula @xmath108 is equivalent to @xmath109 \\land [ { \\mathrm{pos}}_1(a , b ) \\lor { \\mathrm{pos}}_2(a , b)]$ ] .",
    "thanks to the previous lemmata , it only remains to justify the equivalence between the formulas @xmath110 and @xmath111 .",
    "( @xmath96 ) let @xmath112 be a rational such that @xmath113 .",
    "we have @xmath114 and @xmath115 because @xmath116    ( @xmath100 ) assume the existence of @xmath117 such that @xmath118 and the existence of @xmath119 such that @xmath120 .",
    "then the rational @xmath121 verifies @xmath122 and shows that @xmath110 .",
    "back to our initial problem , the existence of an eventual linear ranking function is equivalent to the satisfiability of at least one of the following four linear systems : @xmath123 which we can decide in polynomial time . for our running example",
    ", @xmath124 is satisfiable as proved by the following sicstus prolog query :    .... ?",
    "- dec2pos1 .",
    "? - ....    after compilation of the program :    .... dec2pos1 : -     { l1 > = 0 , l2 > = 0 , l3 > = 0 , l4 > 0 ,      a = l1 + l2 , b = l2 + l3 - l4 ,      a = l2 , b = l3 , 1 = <",
    "l3 + p ,      lp1 > = 0 , lp2 > = 0 , lp3 > = 0 ,      a = lp1 + lp2 , b = lp2 + lp3 ,      0 = lp2 , 0 = lp3 , 0 = < lp3}. ....    the procedure we have informally outlined by means of examples is actually completely general . it is embodied in algorithm  [ algo1 ] , which is a ( correct and complete ) decision procedure for the existence of an eventual linear ranking function given a linear increasing function .",
    "@xmath21 , an slc loop @xmath125 , and @xmath75 , a linear increasing function for @xmath21 returns  if and only if , for some vector @xmath126 , @xmath127 is an eventual linear ranking function for @xmath70 .",
    "@xmath128 @xmath129 @xmath130 @xmath131    [ algo - is - a - decision - procedure - for - elrf ] let @xmath21 be an slc loop and @xmath75 an increasing function for @xmath21",
    ". decides in polynomial time the existence of an eventual linear ranking function for @xmath70 .",
    "computing an eventual linear ranking function @xmath17 and its associated threshold @xmath72 can be done as follows :    * if @xmath132 is satisfiable , we compute a solution @xmath126 , @xmath133 is a standard linear ranking function and proposition  [ lrf - implies - elrf ] applies ; * if @xmath134 is satisfiable , we compute a solution @xmath126 , @xmath135 , @xmath136 and we take @xmath137 ; * if @xmath138 is satisfiable , we compute a solution @xmath126 , @xmath139 , @xmath140 and we take @xmath141 ; * if @xmath142 is satisfiable , we compute a solution @xmath126 , @xmath139 , @xmath140 , @xmath135 , @xmath136 and we take @xmath143 .    continuing with , here is the most general solution of @xmath124 :    .... ? -   { l1 > = 0 , l2>= 0 , l3 > = 0 , l4 > 0 ,       a = l1 + l2 , b = l2 + l3 - l4 ,       a = l2 , b = l3 , 1 = < l3 + p ,       lp1 > = 0 , lp2 > = 0 , lp3 > = 0 ,       a = lp1 + lp2 , b = lp2 + lp3 ,       0 = lp2 , 0 = lp3 , 0 = < lp3}. b = 0 , l1 = 0 , l3 = 0 , lp2 = 0 , lp3 = 0 , { lp1 = l4 , l2 = l4 , a = l4 , l4 > 0 , p > = 1}. ? - ....    one particular solution is @xmath144 , @xmath145 , @xmath146 . hence @xmath40 is an eventual linear ranking function from the threshold @xmath147 .    we also provide a decision procedure for the existence of an eventual _ affine _ ranking function .",
    "the existence of an eventual affine ranking function for an slc loop and associated increasing function , @xmath70 , can be decided in polynomial time .    from @xmath21 , @xmath148 ,",
    "we construct @xmath149 , @xmath150 where @xmath31 does not occur in @xmath13 . note that @xmath149 is an slc loop and that @xmath151 is an increasing function for @xmath149 .",
    "algorithm  [ algo1 ] applied to @xmath152 gives an answer in polynomial time .",
    "if algorithm  [ algo1 ] returns * true * then , by correctness , there exists a threshold @xmath72 and an eventual linear function @xmath153 for @xmath152 .",
    "we readily check that @xmath154 is an eventual affine ranking function for @xmath70 from @xmath72 .",
    "if algorithm  [ algo1 ] returns * false * then , by completeness , there is no eventual linear ranking function for @xmath152 .",
    "assuming there exists an eventual affine ranking function @xmath155 from @xmath72 for @xmath70 , then @xmath153 should be an eventual linear ranking function from @xmath72 for @xmath156 , which is a contradiction .",
    "hence there is no eventual affine ranking function for @xmath70 .",
    "[ ex - fn - rng - aff - evt - p ] the slc loop @xmath157 associated to the linear increasing function @xmath158 does not admit an eventual linear ranking function , but does admit @xmath159 as an eventual affine ranking function from @xmath160 .",
    "we now consider the problem in its full generality : given an slc loop @xmath21 , does there exist an increasing function for @xmath21 such that @xmath21 admits an eventual linear ranking function ?",
    "note that the space of increasing functions can be obtained as a convex set over their coefficients via the farkas lemma and existentially quantified variables elimination .",
    "[ def - inc ] let @xmath161 be an slc loop .",
    "we denote by @xmath162 the set of vectors @xmath163 such that @xmath164 is increasing for @xmath21 .",
    "[ ex - full - detection ] a linear ranking function does not exist for the slc loop @xmath21",
    "@xmath165 @xmath166 induces the space of functions of the form @xmath167 , which are increasing for @xmath21 .",
    "let us consider the slc loop of example  [ ex - full - detection ] associated to an increasing function @xmath168 induced by @xmath162 .",
    "defining @xmath169 and considering @xmath170 and @xmath171 as parameters , @xmath17 is an eventual linear ranking function when @xmath172 this definition of the problem is denoted @xmath173 .",
    "we can apply farkas lemma as follows : @xmath174 formula @xmath175 is equivalent to the conjunction of formulas @xmath176 , i.e. , @xmath177 ensuring the positivity of the ranking function .",
    "let us focus on @xmath176 .",
    "we observe that the products with @xmath178 lead to a non - linearity that we can circumvent by noting that , as @xmath179 , either @xmath180 or @xmath181 . in the latter case",
    ", we introduce a vector @xmath182 of two new variables where @xmath183 and @xmath184 together with , as previously , the new variable @xmath185 . formula",
    "@xmath186 is equivalent to the disjunction @xmath187 where in our case , @xmath188 is equivalent to @xmath189    for the positivity condition , formula @xmath190 is equivalent to the disjunction @xmath191 where we introduce a vector @xmath192 of two new variables where @xmath193 , @xmath194 together with , as previously , the new variable @xmath195 . in our case",
    ", @xmath196 is equivalent to @xmath197    back to our initial problem , the existence of an eventual linear ranking function is equivalent to the satisfiability of at least one of the following four systems :    1 .",
    "@xmath132 : this case means that the increasing function and @xmath72 are irrelevant . in other words , for each solution @xmath126 , @xmath133 is a standard linear ranking function and proposition  [ lrf - implies - elrf ] applies .",
    "2 .   @xmath198 : note that satisfiability of @xmath199 is not sufficient , as its solution might lead to the coefficients @xmath200 and @xmath201 ( @xmath202 is strictly positive by definition ) , which could correspond to a non - increasing linear function .",
    "the third conjunct , @xmath203 , ensures that we stay within the space of increasing functions .",
    "@xmath204 : this case is symmetric to previous one .",
    "@xmath205 : this case combines the two previous ones . note that the condition ensures that we consider the same linear ranking function and the same increasing function both in @xmath206 and in @xmath207 .    for our running example , the following sicstus prolog query proves that @xmath208 is satisfiable    .... ?",
    "- dec2incpos1 .",
    "? - ....    after compilation of the program    .... dec2incpos1 : -     { % dec2 :      l1 > = 0 , l2 > = 0 , l3 > = 0 ,      a1 = l1 + l2 + p1 , a1 = l2 , l > 0 ,      a2 = l2 - l3 + p2 , a2 = l3 , -1 > = -l3 - p ,      % inc : b1 = < -2 , b1 - 2*b2 = 0      p1 = < -2*l , p1 - 2*p2 = 0 ,      % pos1 :      lp1 > = 0 , lp2 > = 0 , lp3 > = 0 ,      a1 = lp1 + lp2 , 0 = lp2 ,      a2 = lp2 - lp3 , 0 = lp3 , 0 > = -lp3}. ....    the procedure we have informally outlined by means of examples is actually completely general and is embodied in algorithm  [ algo2 ] .",
    "@xmath21 , an slc loop @xmath125 returns  if and only if there exists an increasing function @xmath75 for @xmath21 and @xmath209 such that @xmath17 is an eventual linear ranking function for @xmath70 .",
    "@xmath210 @xmath128 @xmath211 @xmath130 @xmath212 @xmath213 @xmath214 @xmath215 @xmath216    [ algo2-is - a - decision - procedure - for - elrf ]",
    "let @xmath21 be an slc loop",
    ". decides the existence of an increasing function @xmath75 and a linear function @xmath17 such that @xmath17 is an eventual linear ranking function for @xmath70 .",
    "exactly as in the previous section , if algorithm  [ algo2 ] returns * true * then we can extract an increasing function @xmath75 , a threshold @xmath72 , and a linear function @xmath17 .",
    "we can also generalize the approach to the fully automated detection of eventual affine ranking functions .    with respect to complexity , algorithm  [ algo2 ]",
    "is not polynomial for two reasons . in step 1 ,",
    "computing the set @xmath162 of linear increasing functions for @xmath21 requires elimination of existentially quantified variables . in step 2 ,",
    "formula @xmath217 leads to a non - linear system and we may have to check its satisfiability in step 10 .",
    "although decidable , we are not aware of the existence of polynomial algorithms for these problems .      given @xmath21 an slc loop , an associated increasing function @xmath75 , and a linear function @xmath17 , we want to know whether @xmath17 is a ranking function .",
    "we can run algorithm  [ algo1 ] , with the coefficients @xmath126 fully instantiated .",
    "if needed , we can compute the threshold @xmath72 as explained in section  [ sec : elrf - semi - detection ] .",
    "it follows that the verification problem is polynomial .",
    "we have implemented both algorithms in sicstus prolog . however , as @xmath217 of algorithm  [ algo2 ] leads to a non - linear system , we relaxed this formula to @xmath218 which is now linear .",
    "as shown in the following proposition , the existence of an eventual linear ranking function ( hence termination ) is preserved , but the associated increasing function is not linear .",
    "let @xmath21 be an slc loop and assume that @xmath219 is true .",
    "then there exists a non - linear increasing function @xmath75 such that @xmath220 is an eventual linear ranking function for ( @xmath21,@xmath75 ) .",
    "as @xmath221 is true , there exists an increasing function @xmath222 and a rational @xmath117 such that when the value of @xmath222 is beyond @xmath117 , @xmath17 decreases .",
    "similarly , as @xmath223 is true , there exists an increasing function @xmath224 and a rational @xmath119 such that when the value of @xmath224 is beyond @xmath119 , @xmath17 is non - negative .",
    "let @xmath225 and @xmath226 .",
    "one readily checks that @xmath75 is a non - linear increasing function for @xmath21 and @xmath17 is an eventual linear ranking function for @xmath70 .",
    "as eventual linear ranking functions generalize linear ranking functions , we focus on related work that goes beyond linear ranking functions for slc loops . in order to appreciate the relative power of the different methods , we report on the results obtained with our algorithms on the loops discussed in the papers where the other approaches were introduced .    the method proposed in @xcite",
    "repeatedly divides the state space to find a linear ranking function on each subspace , and then checks that the transitive closure of the transition relation is included in the union of the ranking relations . as the process may not terminate , one needs to bound the search .",
    "@xcite also proposes a test suite , upon which we tested our approach . as expected , every loop ( * ? ? ?",
    "* table  1 ) which terminates with a linear ranking also has an eventual linear ranking .",
    "moreover , loops 6 , 12 , 13 , 18 , 21 , 23 , 24 , 26 , 27 , 28 , 31 , 32 , 35 , and  36 admit an eventual linear ranking function ( which is discovered without using neither @xmath217 nor its relaxation ) . these are all shown terminating with the tool of @xcite . on the other hand ,",
    "loops 14 , 34 , and 38 do have a _ disjunctive ranking function _ ( following the terminology of @xcite ) , but do not admit an eventual linear ranking function .",
    "@xcite shows how to partition the loop relation into behaviors that terminate and behaviors to be analyzed in a subsequent termination proof after refinement .",
    "this work addresses both termination and conditional termination problems in the same framework . concerning the benchmarks proposed in ( * ?",
    "? ? * table  1 ) , loops 641 all have an eventually linear ranking function except for loops 11 , 14 , 30 , 34 , and  38 .    a method based on abstract interpretation for synthesizing ranking functions",
    "is described in @xcite .",
    "although the work contains no completeness result , the approach is able to discover piecewise - defined ranking functions .",
    "finally , let us point out that the concept of _ eventual termination _ appeared first in  @xcite .",
    "the class loops studied in these works is wider but , as the technique of  @xcite relies on finite differences , this approach is incomplete . on the other hand , while @xcite is also based on farkas lemma , it seems [ a.  r.  bradley , personal communication , may 2013 ] that the _ polyranking _ approach can not prove , e.g. , termination of the slc loop @xmath227 , which admits an eventual linear ranking function .",
    "we have proposed a definition of eventual linear ranking function for slc loops that strictly generalizes the concept of linear ranking function .",
    "we also defined two correct and complete algorithms for detecting such ranking functions under different hypotheses .",
    "the first algorithm shows that the mere knowledge of the right increasing function allows checking the existence or even synthesizing an eventual linear ranking function in polynomial time .",
    "the second algorithm decides the existence of an eventual linear ranking function in its full generality but is not polynomial .",
    "we have also explained how to extend the algorithms for deciding eventual affine ranking functions .",
    "the algorithms admit a simple formulation as a constraint logic program and have been fully implemented in sicstus prolog inside the binterm termination prover  @xcite .",
    "it has to be noted that a nice property of the notion of eventual ( not necessarily linear ) ranking function is its simplicity .",
    "this is important when functions that witness termination have to be provided ( and/or understood ) by humans .",
    "this is the case when annotating a c / acsl program with loop variants @xcite : for the cases when a ranking function to be specified in a ` loop variant ` clause is not obvious , one could extend acsl with a ` loop prevariant ` clause that allows the annotator to indicate a candidate increasing function . in the linear case , our first algorithm can efficiently decide whether the two clauses constitute a termination witness .    on the other hand ,",
    "there obviously are , as indicated in section  [ sec : related - work - and - experiments ] , more complex classes of ranking functions and algorithms that allow to establish the termination of slc loops that do not admit an eventual linear ranking functions . a proper assessment of the relative merits of these approaches , all extremely recent",
    ", requires an extensive experimental evaluation that is one of our objectives for future work .",
    "the verification of linear ranking functions for integer slc loops , i.e. , checking the satisfiability of @xmath228 and @xmath229 , is an @xmath230-complete problem .",
    "concerning the existence of linear ranking functions , as the farkas lemma is not true for the integers , the method presented in section  [ sec : linear - ranking - functions ] is not valid .",
    "the problem , which has been solved very recently in @xcite , is @xmath231-complete , and the paper proposes an exponential - time algorithm .",
    "extending the present approach to integer slc loops is another interesting idea to consider for future work .",
    "a.  m. ben - amram and s.  genaim . on the linear ranking problem for integer linear - constraint loops . in r.",
    "giacobazzi and r.  cousot , editors , _ proceedings of the 40th annual acm sigplan - sigact symposium on principles of programming languages ( popl 13 ) _ , pages 5162 , rome , italy , 2013 .",
    "association for computing machinery .",
    "m.  bozga , r.  iosif , and f.  konecn .",
    "deciding conditional termination . in c.  flanagan and b.  knig , editors , _ tools and algorithms for the construction and analysis of systems : proceedings of the 18th international conference ( tacas 2012 ) _ , volume 7214 of _ lecture notes in computer science _ , pages 252266 , tallinn , estonia , 2012 .",
    "springer .",
    "a.  r. bradley , z.  manna , and h.  b. sipma .",
    "the polyranking principle . in l.",
    "caires , g.  f. italiano , l.  monteiro , c.  palamidessi , and m.  yung , editors , _ automata , languages and programming : proceedings of the 32nd international colloquium ( icalp 2005 ) _ , volume 3580 of _ lecture notes in computer science _ , pages 13491361 , lisbon , portugal , 2005 .",
    "springer .",
    "a.  r. bradley , z.  manna , and h.  b. sipma .",
    "termination of polynomial programs . in r.",
    "cousot , editor , _ verification , model checking and abstract interpretation : proceedings of the 6th international conference ( vmcai 2005 ) _ , volume 3385 of _ lecture notes in computer science _ ,",
    "pages 113129 , paris , france , 2005 .",
    "springer - verlag , berlin .",
    "m.  braverman .",
    "termination of integer linear programs . in t.  ball and r.  b. jones , editors ,",
    "_ computer aided verification : proceedings of the 18th international conference ( cav 2006 ) _ , volume 4144 of _ lecture notes in computer science _ , pages 372385 , seattle , wa , usa , 2006 .",
    "springer .",
    "b.  cook , a.  podelski , and a.  rybalchenko .",
    "termination proofs for systems code . in m.",
    "i. schwartzbach and t.  ball , editors , _ proceedings of the acm sigplan 2006 conference on programming language design and implementation _ , pages 415426 , ottawa , ontario , canada , 2006 .",
    "association for computing machinery .",
    "a.  c. hearn .",
    "the first forty years . in a.",
    "dolzmann , a.  seidl , and t.  sturm , editors , _ algorithmic algebra and logic : proceedings of the a3l 2005 conference in honor of the 60th birthday of volker weispfenning _ , pages 1924 , passau , germany , 2005 .      c.  otto , m.  brockschmidt , c.  von essen , and j.  giesl .",
    "automated termination analysis of java bytecode by term rewriting . in c.",
    "lynch , editor , _ proceedings of the 21st international conference on rewriting techniques and applications ( rta 2010 ) _ , volume  6 of _ leibniz international proceedings in informatics ( lipics ) _ , pages 259276 , edinburgh , scotland , uk , 2010 . schloss dagstuhl  leibniz - zentrum fuer informatik .",
    "a.  podelski and a.  rybalchenko . a complete method for the synthesis of linear ranking functions . in b.  steffen and g.  levi , editors , _ verification , model checking and abstract interpretation : proceedings of the 5th international conference ( vmcai 2004 ) _ , volume 2937 of _ lecture notes in computer science _ , pages 239251 ,",
    "venice , italy , 2004 .",
    "springer .",
    "k.  sohn and a.  van gelder .",
    "termination detection in logic programs using argument sizes ( extended abstract ) . in d.",
    "j. rosenkrantz , editor , _ proceedings of the tenth acm sigact - sigmod - sigart symposium on principles of database systems _ , pages 216226 ,",
    "denver , co , usa , 1991 .",
    "association for computing machinery .",
    "a.  tiwari .",
    "termination of linear programs . in r.",
    "alur and d.  peled , editors , _ computer aided verification : proceedings of the 16th international conference ( cav 2004 ) _ , volume 3114 of _ lecture notes in computer science _ ,",
    "pages 7082 , boston , ma , usa , 2004 .",
    "springer .    c.  urban .",
    "the abstract domain of segmented ranking functions . in f.",
    "logozzo and m.  fahndrich , editors , _ proceedings of the 20th international symposium on static analysis ( sas 2013 ) _ , lecture notes in computer science , seattle , wa , usa , 2013 .",
    "springer . to appear .",
    "h.  yi chen , s.  flur , and s.  mukhopadhyay .",
    "termination proofs for linear simple loops . in a.",
    "min and d.  schmidt , editors , _ proceedings of the 19th international symposium on static analysis ( sas 2012 ) _ , volume 7460 of _ lecture notes in computer science _ , pages 422438 ,",
    "deauville , france , 2012 ."
  ],
  "abstract_text": [
    "<S> program termination is a hot research topic in program analysis . </S>",
    "<S> the last few years have witnessed the development of termination analyzers for programming languages such as c and java with remarkable precision and performance . </S>",
    "<S> these systems are largely based on techniques and tools coming from the field of declarative constraint programming . in this paper , we first recall an algorithm based on farkas lemma for discovering linear ranking functions proving termination of a certain class of loops . </S>",
    "<S> then we propose an extension of this method for showing the existence of _ eventual linear ranking functions _ , </S>",
    "<S> i.e. , linear functions that become ranking functions after a finite unrolling of the loop . </S>",
    "<S> we show correctness and completeness of this algorithm .    </S>",
    "<S> termination analysis , ranking function , eventual linear ranking function . </S>"
  ]
}