{
  "article_text": [
    "in the last few years graph databases gained more and more relevance in application areas such as the semantic web , social networks , bioinformatics , network traffic analysis , and crime detection .",
    "this led to the definition of many query formalisms for graph databases , like , for instance , _ regular path queries _",
    "( rpqs @xcite ) , _ nested regular expressions _ ( nres @xcite ) , _ conjunctive regular path queries _ ( crpqs @xcite ) , gxpath @xcite , and their derivatives .",
    "all these languages are based on the idea of specifying regular expressions describing paths in the input graph , and can be considered , to some extent , a generalization of existing path query languages for semistructured data ( see xpath @xcite , for instance ) .",
    "regular path query languages are often used in other graph query languages , like cypher @xcite or pql @xcite , to specify patterns in variable binding clauses .",
    "regular path query languages are essentially _ untyped_.",
    "this means that one can not statically infer the structure of query results ( _ type inference _ ) , check if the results satisfy a given schema ( _ type - checking _ ) , and verify if the query results would always be empty ( _ query correctness _ ) .",
    "furthermore , the lack of type information greatly limits the optimization opportunities for query engines and makes application development more complex .",
    "[ [ par : ourcontrib ] ] our contribution + + + + + + + + + + + + + + + +    in this paper we describe a simple , yet expressive , schema language for edge - labelled data graphs .",
    "a schema is formed by a collection of _ schema elements _ , each one describing the set of incoming and outgoing edges of a class of graph nodes ; edges are specified through regular expressions .",
    "unlike what happens in other schema languages for graphs @xcite @xcite , that allow the designer to describe in full detail the structure of outgoing edges as well as the structure of node values , but give her very limited modelling choices for incoming edges , our schema language makes no distinction between incoming and outgoing edges , and gives the designer the same modeling tools for both classes of edges .",
    "this increased expressive power has the drawback that , as we will show in section [ sec : preldefs ] , in the general case , schema emptiness checking is undecidable ; hence , a few restrictions on regular expressions describing edges are needed in order to ensure that the semantics of graph schemas is well defined , and to make schema emptiness decidable .",
    "the resulting class of schemas is named _",
    "well - formed schemas _ and can be viewed as a generalization of dtds @xcite to data graphs .",
    "the proposed language is a first step towards the definition and analysis of even more powerful schema languages for data graphs .    in the second part of the paper we leverage on well - formed schemas to build a type inference system , working in polynomial time , for rpqs , nres , and gxpath queries with good soundness and completeness properties ; in particular , this type inference system is sound and complete on rpqs , while completeness has to be relaxed on nres and gxpath queries .",
    "this means that , by using this system , it is possible to decide whether an rpq is satisfiable on graphs conforming to a given schema in polynomial time .",
    "[ [ par : papout ] ] paper outline + + + + + + + + + + + + +    the paper is structured as follows . in section [ sec : preldefs ] we first describe the data model and the type language used in our approach ; then , we present a schema language for data graphs and discuss the emptiness problem for the resulting schemas . in section [ sec : querylan ] , next , we survey regular path query languages and describe their semantics . in section [ sec : rules ] , then , we present our type inference systems . in sections",
    "[ sec : relworks ] and [ sec : concl ] , we discuss some related works and draw our conclusions .",
    "following @xcite , we model a _ data graph _ as an edge - labelled graph , as shown below .    given a finite alphabet @xmath0 and a ( possibly ) infinite value domain @xmath1 ,",
    "a data graph @xmath2 over @xmath0 and @xmath1 is a triple @xmath3 , where :    * @xmath4 is a finite set of nodes ; * @xmath5 is a set of labelled , directed edges @xmath6 ; * @xmath7 is a mapping from nodes to values .",
    "given a node @xmath8 , we indicate with @xmath9 and @xmath10 the set of incoming and outgoing edges , respectively . formally :    * @xmath11 ; * @xmath12 .",
    "we assume that sequences of outgoing ( incoming ) edges of a node are unordered , as it is often the case in graph databases . given a set of edges @xmath13",
    ", we will indicate with @xmath14 the unordered concatenation of the labels of the edges in @xmath15 .",
    "this data model is general enough to capture many practical use graphs , ranging from rdf data to social network graphs , as shown by the following example .",
    "[ ex : first ] consider the graph shown in figure [ fig : first ] .",
    "this graph contains bibliographic information coming from a fragment of the rdf representation of the dblp repository @xcite . as in @xcite",
    ", we indicate the value of a node inside its graphical representation , and use rdf properties to label edges .    in this work",
    "we propose a schema language for data graphs that associates to each schema element a pair of regular expressions describing sequences of labels of the incoming and outgoing edges of each node .",
    "regular expressions obey the following grammar : @xmath16 where @xmath17 denotes the empty sequence , @xmath18 is a symbol in @xmath0 , @xmath19 and @xmath20 denote , respectively , union and unordered concatenation , and @xmath21 is the kleene star . as expected , unordered concatenation @xmath20 is commutative , associative and has @xmath17 as neutral element . in particular",
    ", the expression @xmath22 is equivalent to all of its possible permutations .",
    "in the following we will also use @xmath23 and @xmath24 as abbreviations for @xmath25 and @xmath26 .",
    "the semantics of regular expressions is denoted as @xmath27 , denoting the minimal function satisfying the following equations : @xmath28 where @xmath29 denotes unordered language concatenation and is defined in the obvious way , while for any @xmath30 , @xmath31 with @xmath32 .",
    "regular expressions are the building blocks of our schema language .    given a regular expression @xmath33 over @xmath0 , @xmath34 is the set of symbols in @xmath0 appearing in @xmath33 .    given a finite alphabet @xmath0 , a schema element @xmath35 over @xmath0 is a pair @xmath36 , where @xmath37 and @xmath38 are regular expressions over @xmath0 .",
    "the semantics of a schema element @xmath35 is defined as follows .",
    "@xmath39    a schema element , then , specifies constraints on the incoming and outgoing edges of a node .",
    "consider , for instance , the following schema element : @xmath40    this element describes graph nodes having an incoming @xmath18-edge , an incoming @xmath41-edge , as well as an incoming edge labelled with @xmath42 or @xmath43 ; these nodes must also have an outgoing @xmath44-edge together with zero or more outgoing @xmath45-edges .    in our schema language ,",
    "hence , we not only impose constraints on outgoing edges , but also on incoming edges .",
    "this is in contrast to what happens in schema languages for xml data ( e.g. , dtds @xcite and xml schema @xcite ) .",
    "this choice is motivated by the observation that in a graph each vertex may have multiple incoming edges and , hence , multiple _ fathers _ , while in an xml tree each node , except for the root , has a single father .",
    "therefore , it is important to give the schema designer the ability to model the set of incoming edges , so to avoid potentially dangerous situations .",
    "consider , for instance , a data graph describing a bibliographic database , where nodes can represent books , papers , authors , and publishers ; of course , while author nodes can have incoming edges labelled with `` writtenby '' , they can not allow for incoming edges with label `` publishedby '' , which , instead , are allowed for publisher nodes only .",
    "the use of regular expressions for modeling incoming edges makes our language quite different from existing graph schema languages like tsl @xcite and shex @xcite . in all these languages ,",
    "the designer can use regular expressions to specify the sequence of outgoing edges for each node type ; each edge is described by a label and by the type of the receiving node .",
    "therefore , in these languages it is not possible to specify , for instance , that a node of a given type can have exactly one incoming edge of a given kind .",
    "[ def : grsch ] a graph schema @xmath46 is a finite set of schema elements @xmath47 such that :    1 .   @xmath48 .",
    "\\forall l \\in { sym({{{{e}}_{i}}.in})}. \\exists j \\in [ 0 .. n ] .",
    "l \\in { sym({{{{e}}_{j}}.out})}$ ] ; 2 .",
    "\\forall l \\in { sym({{{{e}}_{i}}.out})}. \\ \\exists j \\in [ 0 .. n ] .",
    "l \\in { sym({{{{e}}_{j}}.in})}$ ] ; 3 .",
    "@xmath49 : ( { { { { e}}_{i}}.in } \\cap { { { { e}}_{j}}.in } = \\emptyset \\vee { { { { e}}_{i}}.out } \\cap { { { { e}}_{j}}.out } = \\emptyset)$ ] .",
    "conditions 1 and 2 above are necessary to ensure that the schema can not define graphs with dangling edges : any symbol used in an outgoing edge must also be used to label an incoming edge , and vice versa . as we will see later , these conditions are not sufficient to imply non - emptiness .",
    "condition 3 guarantees the uniqueness of node typing : a graph node can be typed by at most one schema element .",
    "schema semantics is defined as follows .",
    "[ gsem ] a data graph @xmath3 over @xmath0 and @xmath1 is described by a graph schema @xmath46 ( @xmath50 ) if and only for each @xmath51 there exists @xmath52 such that @xmath53 .",
    "[ ex : second ] consider again the graph of example [ ex : first ] .",
    "this graph can be typed by the schema @xmath54 , where : @xmath55      a graph schema , even though it satisfies all the properties of definition [ def : grsch ] , may be empty , and it could be difficult for the user to figure out whether the schema she has defined is empty . for a simple schema like the following one , emptiness can be easily detected .",
    "[ ex : empty ] consider the graph schema @xmath56 , where : @xmath57    this schema satisfies conditions 1 - 3 of definition [ def : grsch ] .",
    "however , it is empty as cardinality constraints expressed by regular expressions of incoming and outgoing edges are incompatible .",
    "for some schemas , checking compatibility between incoming and outgoing edges can be far from being obvious , as happens for the following one .",
    "[ ex : nonempty ] consider the graph schema @xmath58 , where : @xmath59    in this schema each @xmath60 node produces 4 outgoing c - edges , that are consumed by @xmath61 and @xmath62 nodes .",
    "this schema is not empty , as it possible to build a well - formed graph comprising 2 @xmath60 nodes , 2 @xmath61 nodes , and 3 @xmath62 nodes .    without imposing restrictions on the class of regular expressions being used ,",
    "checking the emptiness of a schema is not decidable . to show this undecidability result",
    ", it is necessary to establish an equivalence between graph schemas and homogeneous systems of linear diophantine equations with parameters .",
    "indeed , we associate to each schema element a distinct variable , and build , for each symbol , a polynomial equation describing the produced and consumed edges labelled with that symbol .",
    "each symbol equation contains the variables of the schema elements producing or consuming edges labelled with that symbol ; the coefficient of each variable describes the number of produced or consumed edges .",
    "the result is an homogeneous system which has a non - zero natural solution if and only if the schema is not empty .",
    "the following example illustrates this approach .",
    "[ ex : sysex ] consider again the schema of example [ ex : empty ] .",
    "this empty schema consists of two schema elements ( @xmath60 and @xmath61 ) to which we can associate variables @xmath63 and @xmath64 .",
    "regular expressions in the schema use three different symbols ( @xmath65 , @xmath66 , and @xmath67 ) , so we have to define the following three linear equations : @xmath68    in the first equation variable @xmath63 has coefficient @xmath69 , as @xmath60 produces an @xmath18-edges , while variable @xmath64 has coefficient @xmath70 since @xmath61 consumes an @xmath18-edge . as it can be easily seen , the only solution of this system is ( 0,0,0 ) .",
    "consider now the schema of example [ ex : nonempty ] .",
    "as illustrated before , this schema is not empty and comprises three schema elements ( @xmath60 , @xmath61 , and @xmath62 ) to which we can associate variables @xmath63 , @xmath64 , and @xmath71 . as for the previous example",
    ", we have three distinct symbols in the schema , so we can define a system with the following linear equations : @xmath72    it easy to see that ( 2,2,3 ) is a solution for this system .",
    "this means that it is possible to build a graph with 2 @xmath60 vertices , 2 @xmath61 vertices , and 3 @xmath62 vertices .    in the case",
    "a schema contains kleene stars , it is possible to build an equivalent diophantine system by introducing natural parameters , as shown in the following example .",
    "[ ex : exstar ] consider the graph schemas @xmath58 , where : @xmath73    to build an equivalent system we can associate a distinct parameter to each occurrence of the kleene star ; in particular , we associate the parameter @xmath74 to the occurrence in @xmath60 , and a parameter @xmath75 to the occurrence in @xmath61 .",
    "the resulting system is the following : @xmath76    while this system contains equations that are linear in variables @xmath63 , @xmath64 , and @xmath71 , coefficients are no longer constant and can assume any value in @xmath77 .",
    "in the case of the schemas of example [ ex : sysex ] , it is quite easy to verify if the corresponding system is consistent and has a non - trivial , positive integer solution . indeed , as pointed out in @xcite , it suffices to build the _ convex hull _ of the set of m - dimensional points defined by the columns of the system coefficient matrix and to check if @xmath78 is contained in this polytope .",
    "however , in the case of the schema of example [ ex : exstar ] , this approach can no longer be used .",
    "indeed , the coefficient matrix contains parameters that prevent one from computing the convex hull .",
    "the problem of the consistency of homogeneous systems of diophantine equations with parameters has been already studied @xcite . in @xcite xie et al .",
    "proved that , even if we restrict to linear polynomial of parameters ( no nested kleene stars ) , there exists a fixed @xmath79 such that the problem is undecidable if the system contains at least @xmath80 equations ( i.e. , the schema uses at least @xmath80 distinct symbols ) , and that the problem is decidable for systems of 2 equations ; in @xcite clauss showed that the problem is decidable if the system contains a single parameter , two variables , and any number of equations .",
    "these results motivate the need for a restriction on the class of schemas that ensures the non - emptiness of the schema .",
    "to develop such a restriction , we propose here an approach based on several ingredients .",
    "the first one consists of restricting the kind of regular expressions that can be used in element types . as seen before , one source of difficulty is the presence of regular expressions with multiple occurrences of a symbol .",
    "another aspect that complicates the problem is nesting of repetitions : indeed , it is known that the consistency of systems of diophantine equations is undecidable if equation degree is greater or equal to 4 @xcite , and nested kleene stars in a schema just increase the degree of the equations in the corresponding system .",
    "consider , for instance , the following schema : @xmath81 the corresponding system , which uses four parameters @xmath74 , @xmath75 , @xmath82 , and @xmath83 , has degree 4 , as shown below : @xmath84    inspired by our previous works @xcite , we restrict here to _ conflict - free _ ( cf ) regular expressions , that are expressions where i ) any symbol may occur at most once ( single - occurrence constraint ) , and ii ) repetition * /+ is only allowed over symbols . by using conflict - free expressions only",
    ", we can avoid the issues related to the nesting of repetitions as well as those concerning multiple occurrences of the same symbol .",
    "conflict - free expressions obey the following grammar : @xmath85 and satisfy the single - occurrence constraint : for any @xmath86 or @xmath87 subexpression of a cf type , @xmath88 holds .",
    "the expression @xmath89 is conflict - free , while the expression used in example [ ex : nonempty ] in schema element @xmath60 is not , as the single - occurrence constraint is not respected there ; the expression @xmath90 is another example of a non conflict - free expression : single - occurrence is met , but the restriction over repetitions is not .",
    "existing studies have shown that users tend to define cf expressions when creating schemas for xml data @xcite .",
    "we believe that the same will hold in the context of data graphs as the reasons that lead users to adopt cf expressions depend on aspects that are orthogonal to the the particular data model at hand : conflict - free expressions , indeed , have a semantics that is relatively simple to understand by humans , and , at the same time , they allow one to describe and constrain a wide class of sequences that arise in the context of semi - structured data management .",
    "the following example shows that , unfortunately , conflict - freedom together with properties that characterise schemas ( definition [ def : grsch ] ) are not sufficient to ensure non emptiness of graph schemas .",
    "[ ex : emptycf ] consider the simple graph schema @xmath91 , where : @xmath92    in this schema each @xmath60 node produces both a @xmath41 and an @xmath18 outgoing edge .",
    "the only nodes that can receive these edges are in turn of type @xmath60 .",
    "these nodes , however , can receive either a @xmath41 or an @xmath18 edge , and in turn emit other two @xmath18 and @xmath41 edges .",
    "this implies that no finite graph meets this schema .",
    "an alternative , and equivalent , formulation of the above schema is the following one , obtained by distributing element types over the union type in @xmath93 expression .",
    "@xmath94    this formulation better highlights that , indeed , there are two kinds of nodes that can be generated by schema @xmath46 : the first one is for nodes receiving an @xmath18-edge , and the second one is for nodes receiving a @xmath41-edge .",
    "now , since both @xmath18 and @xmath41 are emitted by both kinds , we could ensure non - emptiness by modifying the schema as follows : @xmath95    it is easy to verify that this schema is not empty and that infinitely many graphs conform to it .",
    "the idea underlying this modification is that , whenever a symbol @xmath18 is emitted by multiple schema elements in a schema , then each occurrence of @xmath18 that appears in a receiving expression occurs under a @xmath21 .",
    "this implies that there must exist a schema element whose vertices can accept as many @xmath18-edges as needed .",
    "as we will see , the generalisation and formalisation of the above sketched restriction actually ensures non - emptiness . before switching to the formal treatment",
    ", it is worth stressing that this restriction demands that , whenever a symbol @xmath41 is emitted by multiple nodes @xmath96 with different types , any node @xmath97 receiving at least a @xmath41-edge is allowed by its type @xmath98 to have have multiple incoming @xmath41-edges , thus allowing @xmath97 to be shared by @xmath99 via multiple @xmath41-edges .",
    "note that , of course , a similar restriction is needed to for received symbols wrt emitted symbols : whenever a symbol @xmath18 is received by multiple schema elements in a schema , then each occurrence of @xmath18 that appears in a emitting expression occurs under a @xmath21 .",
    "this rules out empty schemas like the one including the following node types ( note that this schema is obtained from a previous one by simply swapping @xmath100 and @xmath101 expression ) .",
    "@xmath102    we identified this restriction after several other attempts with other restrictions . while proving non emptiness for these restrictions , the main problem we had was that a constructive approach ( based on trying to build a graph valid wrt the schema in an incremental way ) failed because , each time a node of a given type was introduced , this could receive ( emit ) pending edges emitted ( received ) by other nodes already created in the process , but , at the same time , this new node introduced other constraints ( pending outgoing and incoming edges ) that existing nodes could not satisfy .",
    "so this , in turn , triggered the introduction of another node which re - creates the same situation , therefore leading to a circular and possibly non - terminating process .",
    "we have identified the above depicted restriction in such a way that a terminating constructive approach can be used in the proof of non - emptiness . while the restriction we adopt may seem artificial , we believe that it does not limit the modelling opportunities for the schema designer and that it can be safely adopted in automatic schema - learning approaches .",
    "importantly , our restriction does not exclude schemas describing graphs where some nodes can receive at most one edge with a given label , as illustrated by the following example .",
    "consider graphs for representing social networks where users publish posts , which are commented and/or liked by other users , which in turn can establish friendship relationships with other users . a well formed schema for this database is @xmath103 , where : @xmath104 { { e}_{post } } & = & ( post { \\cdot}{{commented}^ { * } }   { \\cdot}{{liked}^ { * } } , \\epsilon ) \\end{array}\\ ] ] of course , a user can publish several posts , while a post is posted by only one user .    in order to formalize the above illustrated restriction , we have first to normalize regular expressions .",
    "regular expressions must be transformed in _ disjunctive normal form _ ( dnf ) , and then the whole schema must be normalized ( as illustrated before ) in order to distribute unions over type definitions .",
    "the following example illustrates why normalisation is necessary for proving non - emptiness .",
    "[ ex : emptycf2 ] consider the simple graph schema @xmath91 , where : @xmath105    it can be easily proved ( by contradiction ) that this schema is empty .",
    "however , in its current formulation this schema satisfies the restriction sketched above , as each symbol occurs once in every incoming / outgoing regular expression and no repetition is used , hence contradicting our previous claim .",
    "this is due to the fact that , as in example [ ex : emptycf ] , the current formulation hides that the schema actually defines two kinds of nodes . in order to exhibit this property ,",
    "the outgoing regular expression must be normalised , thus obtaining the following schema : @xmath106    furthermore , the whole schema must be transformed in order to distribute element type definitions over the union emerged by means of normalisation , thus obtaining :    @xmath107 as it can be observed , this schema formulation does not satisfy our restriction .    [ def : dnf ] a regular expression @xmath33 is in disjunctive normal form ( dnf ) if it obeys the following grammar .",
    "@xmath108    any regular expression can be transformed in dnf by using the function defined below , where @xmath109 denotes a union - free regular expression , and @xmath110 denotes @xmath111 .",
    "[ def : norm ] @xmath112    it is easy to prove that @xmath33 and @xmath113 are equivalent for any @xmath33 .",
    "to prove that @xmath113 actually transforms any regular expression in disjunctive normal form , we need a preliminary lemma .    [",
    "lem : normprel ] given a cf regular expression @xmath33 , if @xmath33 contains a single union , then @xmath113 is in dnf .",
    "we prove the thesis by induction on the level of the parse tree of @xmath33 where the union is located .",
    "assume that the parse tree of @xmath33 contains @xmath114 levels , where 0 is the level of the root .",
    "base : :    assume that the union is located on the root of the parse tree ( level    0 ) .",
    "then @xmath115 , where @xmath116    and @xmath117 are union - free .",
    "hence , @xmath33 is    already in dnf  and    @xmath118    is in dnf .",
    "inductive step : :    assume that the thesis is true for any regular expression containing a    single union @xmath86 at level @xmath119 and    assume that @xmath33 contains a single union at level    @xmath120 .",
    "then , if we indicate with    @xmath121 the subterm at level @xmath119    surrounding @xmath86 ,    @xmath122 , where    @xmath116 , @xmath117 , and @xmath123 are    union - free . in this case , by applying rule ( 4 ) of definition    [ def : norm ] ,    @xmath124 , where    @xmath125 .    in @xmath126",
    "the union is at level    @xmath119 , hence , by induction ,    @xmath127 is in dnf , which proves the    thesis .",
    "[ lem : norm ] given a cf regular expression @xmath33 , @xmath113 is in dnf .",
    "we prove the thesis by induction on the number of unions inside @xmath33 .",
    "base : :    if @xmath33 contains a single union , the thesis is true by    lemma [ lem : normprel ] .",
    "inductive step : :    we assume that the thesis is true for regular expressions containing    @xmath97 unions . let @xmath33 be a regular expression    containing @xmath114 unions .",
    "we proceed by induction on the    level of the topmost union .",
    "+    if the topmost union is at level 0 , then    @xmath115 , where @xmath116 and    @xmath117 contain at most @xmath97 unions ; by    induction , @xmath128 and @xmath129    are in dnf .",
    "therefore ,    @xmath130 is in dnf .",
    "+    assume now that the topmost union @xmath86 is at    level @xmath120 and the thesis is true for level    @xmath119 .",
    "then , if @xmath121 is the subterm at    level @xmath119 containing @xmath86 ,    @xmath131 .",
    "@xmath116 , @xmath117 , and @xmath123    contain at most @xmath97 unions ; hence , by the outer induction ,    @xmath128 , @xmath129 , and    @xmath132 are in dnf .",
    "if    @xmath131 , then , by    applying rule ( 4 ) of definition [ def : norm ] ,    @xmath124 , where    @xmath125 ;    @xmath133 , hence , lifts the union to level    @xmath119 ; by inner induction , we have the thesis .",
    "[ def : dnorm ] given a schema @xmath46 , we indicate with @xmath134 its _ double normalisation _ ,",
    "i.e. , the schema obtained from @xmath46 by first normalising each regular expression in @xmath135 s in @xmath46 , and then by distributing element types over unions of normalised expressions in @xmath135 s .",
    "formally , @xmath134 is the set of element types @xmath136 such that : there exists @xmath137 in @xmath46 with @xmath138 and @xmath139 , and @xmath140 $ ] and @xmath141 $ ]",
    ".    we can now introduce the class of _ well - formed schemas _ corresponding to our restriction .",
    "a schema @xmath46 is well - formed if the following holds .    for any symbol @xmath18 ,",
    "if there exist @xmath142 and @xmath143 in @xmath134 such that @xmath18 occurs in both @xmath144 and @xmath145 ( @xmath146 and @xmath147 ) then , for any @xmath148 in @xmath134 , any occurrence of @xmath18 in @xmath100 ( @xmath101 , respectively ) must be under a @xmath21 .",
    "every well - formed schema @xmath149 is not empty .",
    "we first observe that @xmath46 and @xmath134 are equivalent , that ( * ) each type in @xmath134 contains only union - free and cf @xmath150 expressions , and that ( * * ) @xmath134 respects the properties 1 and 2 of definition [ def : grsch ] ( these properties can be easily proved ) .",
    "we then prove that @xmath134 is not empty . to this end",
    "we prove that any schema @xmath151 satisfying ( * ) and ( * * ) has a valid graph @xmath2 having exactly one node for each element type in @xmath151 and that , for each node of @xmath2 having type @xmath152 in @xmath151 , there exists an incoming / outgoing @xmath18-edge for each @xmath18 in @xmath150 .",
    "clearly this property entails the desired one .",
    "we proceed by induction on @xmath153 , i.e. , the number of schema elements in @xmath151 .    for the base case",
    "@xmath154 we can build a graph with only one node with an @xmath18 incoming ( outgoing ) edge for _ each _ symbol @xmath18 in the regular expressions of the only type @xmath155 of @xmath134 . the fact that this graph is valid with respect to @xmath134 follows from ( * ) and ( * * ) .",
    "let us consider now the case that @xmath156 with @xmath157 .",
    "we pick a type @xmath148 in @xmath158 and build a schema @xmath159 by dropping out @xmath148 from @xmath151 and by deleting , in expressions of remaining types , every symbol that occurs only in @xmath148 .",
    "the schema @xmath160 still satisfies properties ( * ) and ( * * ) , so by induction we can assume that there exists a graph @xmath2 conforming to it and that ( * * * ) each type in @xmath159 has exactly one corresponding node in @xmath2 and that each node of @xmath2 having type @xmath161 there exists an incoming / outgoing @xmath18-edge for each @xmath18 in the @xmath162 .",
    "now , we add a new node @xmath97 node to @xmath2 as follows",
    ". the new node @xmath97 will contain an incoming ( outgoing ) @xmath18-edge _ for each _",
    "symbol @xmath18 in the regular regular expression @xmath100 ( @xmath101 ) of the dropped type @xmath148 .",
    "in addition , we reactivate erased symbols in types of @xmath159 and add a corresponding incoming / outgoing edge in each node of a type @xmath163 in @xmath159 for which the symbol has been reactivated in @xmath164 .    at this point , it may happen that some of the added edges are dangling",
    ". we will show that we can connect these edges to exiting nodes ( including @xmath97 ) thanks to the following facts .",
    "properties 1 and 2 of definition [ def : grsch ] , plus ( * * * ) ensure that for each new dangling @xmath18-edge either i ) there is an existing ( not dangling ) @xmath18-edge @xmath165 connecting two nodes @xmath166 and @xmath167 of @xmath2 ( this is the case when the added edge is outgoing / incoming for @xmath97 and the edge symbol is already used in types in @xmath159 ) , or ii ) the dangling edge has a reactivated label @xmath18 ( a label used in @xmath44 but not in @xmath159 ) and actually multiple of such pending @xmath18-edges can exist .    for the first case i ) we can distinguish two sub - cases .",
    "the first one is that the dangling @xmath18-edge is outgoing from @xmath97 .",
    "recall that types corresponding to @xmath97 , @xmath168 and @xmath169 are different types @xmath170 .",
    "wlog , assume that the existing @xmath18-edge is from @xmath168 to @xmath169 . before proceeding , observe that at this point we have : @xmath142 and @xmath18 occurs in @xmath144 , @xmath148 and @xmath18 occurs in @xmath101 , and @xmath143 and @xmath18 occurs in @xmath171 .",
    "since @xmath149 is well - formed , this means that @xmath18 occurs in @xmath147 under a @xmath21 , and this implies that the dangling edge can be connected to @xmath167 .",
    "the second case is that the dangling edge is an incoming edge of @xmath97 .",
    "this case can be proved as above .    concerning the case",
    "ii ) we can distinguish the following two sub - cases .",
    "the first one deals with one or more pending @xmath18-edges that are outgoing from a node of @xmath2 or from @xmath97 . recall that @xmath18 is in @xmath172 but in no other type of @xmath159 .",
    "now , we observe that these edges originates from nodes of different types of @xmath173 , thanks to ( * * * ) and to the fact that @xmath97 has exactly one edge for each symbol of @xmath44 ; recall that @xmath18 has been reactivated .",
    "thanks to ( * * ) we have that there must be a type @xmath174 in @xmath173 with @xmath175 . in the case that only one pending @xmath18-edge exists , the case is proved since the edge can be connected to the node having type @xmath176 ( observe that it may be the case that a pending _ incoming _",
    "@xmath18-edge has been added for this node ; in this case the two edges are simply merged ) . in the remaining case",
    "is we have more than one pending @xmath18-edge ; in this case thanks to ( * * ) , ( * * * ) and to well - formedness of @xmath46 , we have that there must be a type @xmath174 in @xmath173 with @xmath175 such that @xmath18 is under a @xmath21 .",
    "so the node having type @xmath177 is able to receive all of the pending outgoing @xmath18-edges .",
    "the second ii ) sub - case deals with one or more pending incoming @xmath18-edges targeting either a node of @xmath2 or @xmath97 .",
    "this case is similar to the previous one .",
    "rpqs , nres , and gxpath are graph query languages based on the idea of using regular expressions to specify patterns that must be matched by paths in the input graph . given a query @xmath178 ,",
    "the result of its evaluation over a graph @xmath2 is always a set of node pairs @xmath179 such that @xmath8 and @xmath180 are connected by a path @xmath181 in @xmath2 matching the query @xmath178 .",
    "these languages mainly differ in the class of supported regular expressions , ranging from standard regular expressions to expressions with counters and nested predicates .",
    "_ regular path queries _ ( rpqs ) are the most basic language we are analyzing here . given a finite alphabet @xmath0 , an rpq @xmath182 over @xmath0 is defined by the following grammar : @xmath183    given a graph @xmath3 , the semantics of rpqs can be defined as follows .",
    "@xmath184    where @xmath185 is the symbol for the concatenation of binary relations and @xmath186 denotes the concatenation of @xmath187 with itself @xmath119 times .",
    "consider the schema of example [ ex : second ] and the following query : @xmath188    this query selects all the conference papers and relates them to the corresponding conference series . in the case of the graph of example [ ex : first ] , the result is the following : @xmath189    as it can be seen from the example , rpqs can express neither branching nor backward navigation , which are introduced by nres queries .",
    "_ nested regular expressions _ ( nres ) are an evolution of rpqs and form the basis of the path language of sparql @xcite .",
    "nres introduce the ability of traversing edges backwards , as in 2rpqs @xcite , as well as the ability of specifying conditions inside paths .",
    "nres obey the following grammar : @xmath190 \\end{array}\\]]where @xmath191 denotes a backward navigation and @xmath192 $ ] allows one to express conditions inside a path expression . given a graph @xmath3 , the semantics of nres",
    "can be defined as follows .",
    "@xmath193 \\rrbracket } } _ { g } } } & = & \\ { ( u , u ) \\mid ( u , v ) \\in { { { { \\llbracket n \\rrbracket } } _ { g } } } \\}\\end{aligned}\\ ] ]    [ ex : nre ] consider again the graph of example [ ex : first ] and the schema of example [ ex : second ] .",
    "the following query returns all pairs @xmath194 where @xmath63 is the author of a paper in a conference series @xmath64 , but also published a paper in a journal @xmath71 : @xmath195 \\cdot { creator^{- } } \\cdot partof \\cdot series\\ ] ]    the result of this query is @xmath196 .",
    "observe that this query can not be expressed through rpqs or 2rpqs .",
    "gxpath is the most powerful language we are examining here and has been recently proposed by libkin et al . in @xcite .",
    "gxpath is essentially an adaptation of xpath to data graphs .",
    "wrt the previous languages , gxpath introduces the _ complement _ operator , data tests on the values stored into nodes , as well as counters , which generalize the kleene star .    among the various fragments of gxpath",
    ", we focus here on the navigational , path - positive fragment with intersection , described by the following grammar .",
    "@xmath197 \\end{array}\\ ] ]    given a graph @xmath3 , the semantics of gxpath can be defined as follows .",
    "@xmath198 \\rrbracket } } _ { g } } } & = & \\ { ( u , u ) \\mid ( u , v ) \\in { { { { \\llbracket \\alpha \\rrbracket } } _ { g } } } \\}\\end{aligned}\\ ] ]    [ ex : qcycle ] consider the graph depicted in figure [ fig : secgraph ] .",
    "\\(1 ) at ( 1,0 ) 1 ; ( 2 ) at ( 0,-1 ) 3 ; ( 3 ) at ( 2,-1 ) 7 ; ( 4 ) at ( 1,-2 ) 1 ; ( 5 ) at ( 3,-2 ) 5 ; ( 6 ) at ( 0,-3 ) 2 ; ( 7 ) at ( 2,-3 ) 3 ;    \\(1 ) edge[swap ] node a ( 2 ) ( 2 ) edge[swap ] node a ( 4 ) ( 3 ) edge[swap ] node a ( 1 ) edge node d ( 5 ) ( 4 ) edge[swap ] node a ( 3 ) edge[swap ] node b ( 6 ) edge node c ( 7 ) ;    consider now the following query : @xmath199 \\cdot ( b + c)$ ] .",
    "this query selects all pairs of nodes @xmath194 where @xmath63 is part of a cycle and @xmath64 is reachable from @xmath63 through an edge labelled with @xmath41 or @xmath42 .    in the following",
    "we will indicate with rpq , nre , and gxp  the three classes of regular expressions we are studying here .",
    "in this section we present a type inference approach for typing rpqs , nres , and gxpath queries . the approach we propose here is a basic yet useful one .",
    "it associates to each query a set of schema element pairs ; hence , a query @xmath178 is typed by a set @xmath200 , where @xmath201 and @xmath202 are schema elements describing the nodes at the beginning and at the end of path @xmath181 matching @xmath178 .",
    "another advantage of this typing approach is that can be performed in polynomial time ( theorem [ theo : bcomplx ] ) and that it is sound and complete for rpqs ( theorems [ theo : basicsound ] and [ theo : rpqcompl ] ) . for nre and gxpath queries only soundness holds ( we will provide counterexamples for completeness ) .",
    "typing rules rely on the judgement defined below .",
    "we use the meta - variables @xmath203 and @xmath204 to denote sets of schema element pairs .",
    "@xmath205 is a judgment stating that , given a well - formed @xmath46 and a graph @xmath50 , @xmath203 is an upper bound for @xmath206 .",
    "type inference rules for rpqs , nres , and gxpath queries are shown in tables .[table : basicrpqrules ] , .[table : basicnrerules ] , and .[table : basicgxprules ] . in these rules",
    ", @xmath185 is the operator for the usual combination of binary relations , and @xmath207 . in table",
    ".[table : basicrpqrules ] rule ( typeepsilon ) types @xmath17 queries , rule ( typelabel ) deals with forward navigation , while rules ( typeunion ) and ( typeconc ) type queries with union and concatenation , respectively .",
    "rule ( typestar ) , finally , deals with @xmath208 queries .    in table",
    ".[table : basicnrerules ] , rules ( typebacklabel ) and ( typecond ) infer a type for queries with backward navigation and nested conditions , respectively .    in table",
    ".[table : basicgxprules ] , finally , rules ( typeanylabel ) , ( typecount ) , and ( typeintersect ) deal with , respectively , wildcard queries , counting , and intersection .",
    "[ table : basicrpqrules ]    basic inference rules for rpqs .",
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa @xmath209{\\strut}{\\vdash_{{{\\mathcal{s } } } } { \\epsilon } : { { \\ { ( { { { e}}_{i } } , { { { e}}_{i } } ) \\}_{i } } } }    \\end{array }    \\end{array}$ ] +    @xmath210{\\strut}{\\vdash_{{{\\mathcal{s } } } } { a } : { { \\ { ( { { { e}}_{i } } , { { { e}}_{i}}^{\\prime } ) \\}_{i } } } }    \\end{array }    \\end{array}$ ] +    @xmath211{\\strut}{\\vdash_{{{\\mathcal{s } } } } { r_{1 } + r_{2 } } : { { { \\mathcal{e}}}_{1 } \\cup { { \\mathcal{e}}}_{2 } } }    \\end{array }    \\end{array}$ ]     @xmath212{\\strut}{\\vdash_{{{\\mathcal{s } } } } { r_{1 } \\cdot r_{2 } } : { { { \\mathcal{e}}}_{1 } { \\circ}{{\\mathcal{e}}}_{2 } } }    \\end{array }    \\end{array}$ ]     +    @xmath213{\\strut}{\\vdash_{{{\\mathcal{s } } } } { r^ { * } } : { \\bigcup_{i \\geqslant 0 } { { \\mathcal{e}}}^{i } } }    \\end{array }    \\end{array}$ ]    [ table : basicnrerules ]    additional basic inference rules for nres . aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa @xmath214{\\strut}{\\vdash_{{{\\mathcal{s } } } } { { a^{- } } } : { { \\ { ( { { { e}}_{i } } , { { { e}}_{i}}^{\\prime } ) \\}_{i } } } }    \\end{array }    \\end{array}$ ] +    @xmath215{\\strut}{\\vdash_{{{\\mathcal{s } } } } { [ n ] } : { { first({{\\mathcal{e}}}_{1 } ) } \\times { first({{\\mathcal{e}}}_{1 } ) } } }    \\end{array }    \\end{array}$ ]    [ table : basicgxprules ]    additional basic inference rules for gxpath queries . aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa @xmath216{\\strut}{\\vdash_{{{\\mathcal{s } } } } { \\ _ } : { { \\ { ( { { { e}}_{i } } , { { { e}}_{i}}^{\\prime } ) \\}_{i } } } }    \\end{array }    \\end{array}$ ] +    @xmath217{\\strut}{\\vdash_{{{\\mathcal{s } } } } { { \\alpha^{m , n } } } : { \\bigcup_{i = m}^{n } { { \\mathcal{e}}}^{i } } }    \\end{array }    \\end{array}$ ]     +    @xmath218{\\strut}{\\vdash_{{{\\mathcal{s } } } } { \\alpha_{1 } \\cap \\alpha_{2 } } : { { { \\mathcal{e}}}_{1 } \\cap { { \\mathcal{e}}}_{2 } } }    \\end{array }    \\end{array}$ ]    [ ex : basicinf ] consider again the query of example [ ex : nre ] . to type this query , rules ( typeconc ) and ( typecond )",
    "are first invoked ; rule ( typecond ) , in turn , invokes rules ( typeconc ) , ( typelabel ) , and ( typebacklabel ) to type @xmath219 .",
    "rule ( typebacklabel ) returns the set @xmath220 , while rule ( typelabel ) returns @xmath221 .",
    "rule ( typeconc ) , hence , returns @xmath222 , while rule ( typecond ) returns @xmath223 .    rules ( typeconc ) , ( typelabel ) , and ( typebacklabel ) are called again to type @xmath224 , returning @xmath225 .    therefore , the result of the type inference is @xmath226 , as expected .",
    "the soundness of basic type inference is stated by the following theorem .",
    "[ theo : basicsound ] given a well - formed @xmath46 and a query @xmath178 on a graph @xmath227 , if @xmath205 , then , for each @xmath228 there exists @xmath229 such that @xmath230 and @xmath231 .    by structural induction on the queries .",
    "( @xmath232 ) : :    trivial .",
    "( @xmath233 ) : :    let @xmath234 . by definition of query semantics ,",
    "there exists    @xmath235 . by definition of well - formed schemas",
    ",    there exists @xmath236    such that @xmath237 , @xmath238 , and    @xmath239    for some @xmath80 . by rule ( typelabel ) ,    @xmath229 .",
    "( @xmath240 ) : :    let @xmath241 . by definition of query semantics , there exists    @xmath242 . by definition of well - formed schemas ,",
    "there exists @xmath236    such that @xmath237 , @xmath238 , and    @xmath243    for some @xmath80 . by rule ( typebacklabel ) ,    @xmath229 .",
    "( @xmath244 ) : :    let @xmath245 . by definition of query semantics , there exists    @xmath246 such that @xmath235 . by    definition of well - formed schemas",
    ", there exists    @xmath236 such that    @xmath237 , @xmath238 , and    @xmath239    for some @xmath80 . by rule ( typeanylabel ) ,    @xmath229 .",
    "( @xmath247 ) : :    let @xmath248 .",
    "by definition of query semantics ,    @xmath249 or @xmath250 .",
    "wlog we can assume that    @xmath249 ( the case for    @xmath250 is symmetrical ) .",
    "by induction , there exist    @xmath236 such that    @xmath237 , @xmath251 , and @xmath252 , where    @xmath253 .    by rule ( typeunion ) ,    @xmath229 .",
    "( @xmath254 ) : :    let @xmath255 . by definition of query semantics , there exists    @xmath256 such that    @xmath257 and @xmath258 .",
    "let    @xmath253    and    @xmath259 .    by induction and by uniqueness of vertex typing , there exist    @xmath260 such    that @xmath237 , @xmath261 , @xmath262 , @xmath263 ,    and @xmath264 . by    rule ( typeconc ) ,    @xmath265 .",
    "( @xmath266 ) : :    the thesis follows from the soundness of typing of union and    concatenation .",
    "( @xmath267}$ ] ) : :    let @xmath268 \\rrbracket    } } _ { g}}}$ ] . by definition of query semantics , there exists    @xmath51 such that    @xmath269 . let    @xmath270 .    by induction",
    ", there exist    @xmath236 such that    @xmath237 , @xmath251 , and    @xmath263 . by rule    ( typecond ) , @xmath229 .",
    "( @xmath271 ) : :    the thesis follows from the soundness of typing for union and    concatenation .",
    "( @xmath272 ) : :    let    @xmath273 . by definition of query semantics ,    @xmath274 and    @xmath275 .",
    "let    @xmath276    and    @xmath277 .    by induction and by uniqueness of node typing , there exist    @xmath236 such that    @xmath237 , @xmath251 , @xmath263 ,    and @xmath278 .",
    "by    rule ( typeintersect ) ,    @xmath229 .",
    "the basic type inference approach returns quite simple information .",
    "this fact is counterbalanced by its polynomial complexity , as stated by the following theorem .",
    "[ theo : bcomplx ] @xmath205 can be evaluated in polynomial time .    to prove the thesis we must first observe that , given a query @xmath178 of length @xmath279 , each rule consumes at least one node in the parsing tree of @xmath178 .",
    "this implies that @xmath178 will be typed by a number of rule invocations polynomial in @xmath279 .    to complete the proof",
    ", it suffices to prove that each rule can be evaluated in polynomial time .",
    "this proof can be done by induction on the queries .",
    "the only non trivial cases are those concerning rules ( typestar ) and ( typecount ) .",
    "to evaluate these rules in polynomial time it suffices to recognize that a set @xmath203 can be interpreted as the set of edges in a schema element graph .",
    "evaluating these rules , hence , is equivalent to the computation of the reflexive and transitive closure of the graph ( bounded , in the case of rule ( typecount ) ) .",
    "the unbounded closure can be computed in polynomial time by exploiting the warshall s algorithm , while the bound closure can be computed in polynomial time by relying on the usual squaring method .",
    "basic type inference for rpqs is not only sound , but also complete .",
    "proof of completeness relies on a number of definitions and properties .",
    "the first definition specifies the set of paths matching a query .",
    "[ def : paths ] given a rpq @xmath178 on graphs over a finite alphabet @xmath0 , the set of paths that can match @xmath178 is recursively defined as follows .",
    "@xmath280    the second definition specifies when two nodes @xmath281 and @xmath8 are connected by a path @xmath181 in a graph @xmath2 .",
    "a path can be either @xmath17 ( the empty path ) or a path @xmath282 , where @xmath18 is an edge label , and @xmath283 is a path in turn .",
    "path concatenation @xmath284 is defined in the obvious way .",
    "given a graph @xmath3 , we say that two nodes @xmath285 are connected by a path @xmath181 if either @xmath286 and @xmath287 , or @xmath288 and there exists a pair @xmath289 such that @xmath290 and @xmath283 connects nodes @xmath291 .",
    "it is easy to prove that , if @xmath292 connects @xmath293 and @xmath294 connects @xmath295 in @xmath2 , then @xmath284 connects @xmath296 in @xmath2 .",
    "the following lemma relates rpq semantics , path semantics , and graph paths .",
    "[ lemma : auxc0 ] given a rpq @xmath178 and a graph @xmath3 , if @xmath285 are connected by a path @xmath181 in @xmath2 , and @xmath297 , then @xmath298 .    by structural induction on @xmath178 .",
    "( @xmath232 ) : :    trivial .",
    "( @xmath233 ) : :    if @xmath297 , it must be that @xmath299 .    by definition of the semantics of rpqs , it follows that each pair of    nodes @xmath285 that is connected by @xmath299    is in @xmath300 .",
    "( @xmath301 ) : :    simple induction . (",
    "@xmath302 ) : :    given that @xmath303 , we have that    @xmath304 with @xmath305 ,    @xmath306 .",
    "also , since @xmath181 connects    @xmath307 , @xmath292 connects ( @xmath308 )    and @xmath294 connects ( @xmath309 ) for a node    @xmath310 in @xmath2 .",
    "by induction we have    @xmath311 and @xmath312 , so the thesis follows by definition of    @xmath300 .",
    "( @xmath313 ) : :    given that @xmath314 , we have that    @xmath315 with    @xmath316 and @xmath317 . since    @xmath181 connects @xmath318 , we have that    @xmath319 in    @xmath2 are respectively connected by    @xmath320 .",
    "so by induction we have    @xmath321 and the thesis follows by definition of    @xmath300 .",
    "we need now to define paths over schemas .",
    "given a schema @xmath322 , we say that two types @xmath323 are connected by a path @xmath181 if either @xmath286 and @xmath324 , or @xmath325 and there exists @xmath326 such that :    * @xmath327 , and * @xmath328 are connected by @xmath283 .",
    "the following lemma relates rpq typing and paths over schemas .",
    "[ lemma : auxc1 ]    given a schema @xmath46 and a query @xmath329 whose inputs are described by @xmath46 , if @xmath205 , then , for each @xmath229 there exists a path @xmath181 over @xmath149 such that @xmath181 connects @xmath330 and @xmath331 .    by structural induction on @xmath178 .",
    "cases @xmath232 , @xmath233 , and @xmath301 are trivial .",
    "( @xmath302 ) : :    we have that    @xmath332 ,    with @xmath306 , and    @xmath333 .",
    "by induction we have that , for each pair    @xmath334 and    @xmath335 , there exist    @xmath292 connecting @xmath336 and    @xmath294 connecting @xmath337 on    @xmath46 .",
    "so the thesis follows by taking    @xmath304 .",
    "( @xmath338 ) : :    the case is similar to the above once observed that    @xmath339 means that    there exist @xmath340 ,    @xmath341 , @xmath342 ,    @xmath343 in @xmath203    and that each of these couples is connected by a path    @xmath344 on @xmath46 such that    @xmath316 , with @xmath345 .    to prove completeness of our rpq typing rules we also need the following definition and couple of lemmas .    given a schema @xmath46 and its double normalisation @xmath134 , we indicate with @xmath346 the function from @xmath134 to @xmath46 associating to each type @xmath35 in @xmath134 the unique type @xmath176 in @xmath46 from which @xmath35 has been generated ( definition [ def : dnorm ] ) .    also , for every @xmath176 in @xmath347 , @xmath348 is the set of element types generated by @xmath176 by means of double normalisation .",
    "[ lem : auxc4 ] given a schema @xmath46 with the pair of element types @xmath349 , if this pair is connected by @xmath181 on @xmath46 , then there exist @xmath350 for @xmath306 such that @xmath351 are connected by @xmath181 in @xmath134 .    by induction on @xmath352 . if @xmath299 , then there exist two types @xmath353 and @xmath354 in @xmath46 such that @xmath355 .",
    "we have @xmath356 and @xmath357 for @xmath358 . similarly , @xmath359 and @xmath360 for for @xmath361 . by definition of double normalisation",
    "we know that there will be @xmath362 and @xmath363 obtained by normalisation of @xmath353 and @xmath354 such that @xmath364 and @xmath365 , which prove the basic case .",
    "concerning the case @xmath366 with @xmath367 ( if @xmath283 is empty the case has already been proved ) , by hypothesis we have that @xmath368 is connected by @xmath18 and that @xmath369 is connected by @xmath283 . by induction",
    "we can assume that there exists in @xmath134 a couple @xmath370 connected by @xmath18 and a couple @xmath371 connected by @xmath283 , with @xmath372 and @xmath373 in @xmath374 .",
    "it is easy to prove that the type @xmath375 is in @xmath374 and that it both receives @xmath18 and emits @xmath41 .",
    "so we have that @xmath18 connects @xmath376 and @xmath283 connects @xmath377 in @xmath134 , so the thesis is proved .",
    "[ lemma : auxc3 ] for any well formed schema @xmath46 there exists a graph @xmath2 that respects @xmath46 and such that : if @xmath349 are connected by @xmath181 in @xmath347 , then two nodes @xmath378 in @xmath2 are connected by @xmath181 , with @xmath379 having type @xmath380 , for @xmath306 .    for any @xmath349 in @xmath46 by lemma [ lem : auxc4 ]",
    "we have that there exist @xmath350 for @xmath306 such that @xmath351 are connected by @xmath181 in @xmath134 .",
    "we then prove that the desired @xmath2 exists for @xmath134 with nodes @xmath378 having types @xmath351 , and therefore @xmath349 .",
    "the proof of the existence of such a @xmath2 is quite similar to that for theorem [ theo : rpqcompl ] , so we omit the details , and just observe that the graph @xmath2 we are looking for is actually the graph built in that proof , which ensures that each node of the built graph corresponds to a different type in @xmath134 , and that each node of a type @xmath176 in @xmath134 has a incoming ( outgoing ) @xmath18-edge for each @xmath381 ( for each @xmath382 ) .",
    "this directly implies that we can connect the two nodes @xmath383 in @xmath2 corresponding to types @xmath351 with the path @xmath181 .",
    "we have now all the tools to prove completeness of rpq typing over well - formed schemas .",
    "[ theo : rpqcompl ] given a well - formed schema @xmath46 and a query @xmath329 whose inputs are described by @xmath46 , if @xmath205 , then , for each @xmath229 , there exists @xmath50 such that @xmath206 contains @xmath307 , where @xmath230 and @xmath231 .    by lemma [ lemma : auxc1 ]",
    "we have that @xmath330 are connected by a path @xmath181 in @xmath46 and that @xmath297 . by lemma [ lemma : auxc3 ]",
    "we have that there exists a graph @xmath2 meeting @xmath46 an including two nodes @xmath307 connected by @xmath181 .",
    "so by lemma [ lemma : auxc0 ] we can conclude that @xmath384 and @xmath230 and @xmath231 .    theorem [ theo : rpqcompl ] has important consequences . indeed , as shown by corollary [ cor : sat ] , we can prove that , for rpqs , the following satisfiability problem can be decided in polynomial time .",
    "given a well - formed @xmath46 and a query @xmath178 in a language @xmath385 , is there a graph @xmath50 such that @xmath386 ?    [ cor : sat ] @xmath387 can be decided in polynomial time .",
    "consider a query @xmath178 and a well - formed @xmath46 .",
    "we must first prove that : @xmath388    @xmath389 : :    assume that there is no graph    @xmath390 such that @xmath391 .",
    "then , by theorem [ theo : rpqcompl ] ,    @xmath392 . indeed , if    @xmath205 with    @xmath393 , by theorem    [ theo : rpqcompl ] there would exist at least one graph    @xmath394 for which    @xmath391 , which is a contradiction . @xmath395 : :    assume that    @xmath392 . then ,",
    "by    theorem [ theo : basicsound ] , there is no graph    @xmath390 such that @xmath391 . indeed , if    @xmath391 , then , by theorem [ theo : basicsound ] ,    @xmath205 ,    where @xmath393 , which is a    contradiction .",
    "the fact that @xmath205 can be evaluated in polynomial ( by theorem [ theo : bcomplx ] ) completes the proof .",
    "while sound , basic type inference is not complete for nres and gxpath queries , as shown in the following example .",
    "consider the following graph schema : @xmath396    consider now the query @xmath397 \\cdot a \\cdot c$ ] .",
    "this query looks for nodes having outgoing edges labelled with @xmath18 and @xmath41 . as @xmath60 prescribes that these edges are mutually exclusive",
    ", the result of this query is always empty .",
    "however , the rules first infer the set @xmath398 for the nested regular expression , and the set @xmath399 for the @xmath400 . the inferred set , hence , is @xmath399 .",
    "describing the structure of graphs is a subject that has been analyzed only in a few papers .",
    "graph grammars @xcite probably represent the most widely known approach for describing graphs . as a plain string grammar ,",
    "a graph grammar shows how a graph can be generated starting from a source node , by applying a set of production rules . as for string or tree grammars ,",
    "graph grammars are used for generating graphs , for transforming existing graphs into new ones , or for pattern matching , but they are not suitable for type inference .",
    "tsl is the schema language of trinity @xcite , a main - memory graph processing system based on the microsoft ecosystem . by using a tsl script , which is compiled in .net object code ,",
    "it is possible to specify the structure of nodes , which can have richly defined values , e.g. , those required by bfs and dfs algorithms , as well as the type of outgoing edges ; apparently , there is no way to describe constraints on incoming edges , which can have any cardinality .",
    "shex @xcite is a schema language for rdf data . as in tsl , in shex",
    "it is possible to describe complex node structures , and , unlike in tsl , outgoing edges can be defined by using regular expressions .",
    "however , just as in tsl , there is no way to specify constraints on incoming edges .",
    "this means that , for instance , in a schema describing cars and car owners , one can impose the constraint that a single person can own at most @xmath97 cars , but not the constraint that a car can have one single owner at a time .",
    "this makes impossible to define empty shex schemas , but it limits the expressivity of the language .",
    "in this paper we described a schema language for data graphs , introduced a mild restriction that makes impossible to define empty schemas , and used this schema formalism to create a type inference system for rpqs , nres , and gxpath queries .",
    "this type inference system is sound and , in the case of rpqs , it is also complete , hence making possible to check the satisfiability of a query just by looking at its inferred type .    in the near future",
    "we plan to work on three directions .",
    "first , we want to understand if schema well - formedness can be checked in polynomial or if double normalization is mandatory .",
    "second , we want to better investigate the emptiness problem for a more general class of graph schemas and try to relax the 1/ * constraint , in particular by exploring approaches for checking the consistency of systems of linear diophantine equations with linear parameters . finally , we want to study type inference techniques that return more detailed information about an input query , e.g. , the set of paths that the query may traverse in an input graph matching a given schema .",
    "authors would like to thank maria grazia russo for her suggestions about systems of diophantine equations .",
    "t.  bray , j.  paoli , c.  m. sperberg - mcqueen , e.  maler , f.  yergeau , and j.  cowan .",
    "xtensible markup language ( xml ) 1.1 ( second edition ) .",
    "technical report , world wide web consortium , 2006 .",
    "w3c recommendation .",
    "d.  colazzo , g.  ghelli , l.  pardini , and c.  sartiani .",
    "efficient asymmetric inclusion of regular expressions with interleaving and counting for xml type - checking .",
    "_ , 492:0 88116 , 2013 .",
    "g.  ghelli , d.  colazzo , and c.  sartiani .",
    "efficient inclusion for a class of xml types with interleaving and counting . in _",
    "database programming languages , 11th international symposium , dbpl 2007 , vienna , austria , september 23 - 24 , 2007 , revised selected papers _ , volume 4797 of _ lecture notes in computer science _ , pages 231245 .",
    "springer , 2007 .",
    "isbn 978 - 3 - 540 - 75986 - 7 .",
    "j.  l. pfaltz and a.  rosenfeld .",
    "web grammars . in _ proceedings of the 1st international joint conference on artificial intelligence , washington , dc ,",
    "may 1969 _ , pages 609620 .",
    "william kaufmann , 1969 .",
    "isbn 0 - 934613 - 21 - 4 .",
    "b.  shao , h.  wang , and y.  li .",
    "trinity : a distributed graph engine on a memory cloud . in _ proceedings of the acm sigmod international conference on management of data , sigmod 2013 , new york ,",
    "ny , usa , june 22 - 27 , 2013 _ , pages 505516 .",
    "acm , 2013 .",
    "isbn 978 - 1 - 4503 - 2037 - 5 .",
    "s.  staworko , i.  boneva , j.  e.  l. gayo , s.  hym , e.  g. prudhommeaux , and h.  r. solbrig . complexity and expressiveness of shex for rdf . in _",
    "18th international conference on database theory , icdt 2015 , march 23 - 27 , 2015 , brussels , belgium _ , volume  31 of _ lipics _ , pages 195211 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik , 2015 .",
    "isbn 978 - 3 - 939897 - 79 - 8 .",
    "g.  xie , z.  dang , and o.  h. ibarra . a solvable class of quadratic diophantine equations with applications to verification of infinite - state systems . in _ automata , languages and programming , 30th international colloquium , icalp 2003 , eindhoven , the netherlands , june 30 - july 4 , 2003 .",
    "proceedings _ ,",
    "volume 2719 of _ lecture notes in computer science _ , pages 668680 .",
    "springer , 2003 .",
    "isbn 3 - 540 - 40493 - 7 ."
  ],
  "abstract_text": [
    "<S> regular path query languages for data graphs are essentially _ untyped_. the lack of type information greatly limits the optimization opportunities for query engines and makes application development more complex . in this paper </S>",
    "<S> we discuss a simple , yet expressive , schema language for edge - labelled data graphs . </S>",
    "<S> this schema language is , then , used to define a query type inference approach with good precision properties .    </S>",
    "<S> theory , languages    rpqs , type inference , data graphs </S>"
  ]
}